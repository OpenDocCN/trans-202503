<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="137" id="Page_137"/>6</span><br/>
<span class="ChapterTitle">How User Space Starts</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">The point where the kernel starts init, its first user-space process, is significant—not just because the memory and CPU are finally ready for normal system operation, but because that’s where you can see how the rest of the system builds up as a whole. Prior to this point, the kernel follows a well-controlled path of execution defined by a relatively small number of software developers. User space is far more modular and customizable, and it’s also quite easy to see what goes into the user-space startup and operation. If you’re feeling a little adventurous, you can use this to an advantage, because understanding and changing the user-space startup requires no low-level programming.</p>
<p><span epub:type="pagebreak" title="138" id="Page_138"/>User space starts in roughly this order:</p>
<ol class="decimal">
<li value="1">init</li>
<li value="2">Essential low-level services, such as udevd and syslogd</li>
<li value="3">Network configuration</li>
<li value="4">Mid- and high-level services (cron, printing, and so on)</li>
<li value="5">Login prompts, GUIs, and high-level applications, such as web servers</li>
</ol>
<h2 id="h1-500402c06-0001">	6.1	Introduction to init</h2>
<p class="BodyFirst"><em>init</em> is a user-space program like any other program on the Linux system, and you’ll find it in <em>/sbin</em> along with many of the other system binaries. Its main purpose is to start and stop the essential service processes on the system. </p>
<p>On all current releases of major Linux distributions, the standard implementation of init is systemd. This chapter focuses on how systemd works and how to interact with it.</p>
<p>There are two other varieties of init that you may encounter on older systems. System V init is a traditional sequenced init (Sys V, usually pronounced “sys-five,” with origins in Unix System V), found on Red Hat Enterprise Linux (RHEL) prior to version 7.0 and Debian 8. Upstart is the init on Ubuntu distributions prior to version 15.04.</p>
<p>Other versions of init exist, especially on embedded platforms. For example, Android has its own init, and a version called <em>runit</em> is popular on lightweight systems. The BSDs also have their own version of init, but you’re unlikely to see them on a contemporary Linux machine. (Some distributions have also modified the System V init configuration to resemble the BSD style.)</p>
<p>Different implementations of init have been developed to address several shortcomings in System V init. To understand the problems, consider the inner workings of a traditional init. It’s basically a series of scripts that init runs, in sequence, one at a time. Each script usually starts one service or configures an individual piece of the system. In most cases, it’s relatively easy to resolve dependencies, plus there’s a lot of flexibility to accommodate unusual startup requirements by modifying scripts.</p>
<p>However, this scheme suffers from some significant limitations. These can be grouped into “performance problems” and “system management hassles.” The most important of these are as follows:</p>
<ul>
<li>Performance suffers because two parts of the boot sequence cannot normally run at once.</li>
<li>Managing a running system can be difficult. Startup scripts are expected to start service daemons. To find the PID of a service daemon, you need to use <code>ps</code>, some other mechanism specific to the service, or a semistandardized system of recording the PID, such as <em>/var/run/myservice.pid</em>.</li>
<li><span epub:type="pagebreak" title="139" id="Page_139"/>Startup scripts tend to include a lot of standard “boilerplate” code, sometimes making it difficult to read and understand what they do.</li>
<li>There is little notion of on-demand services and configuration. Most services start at boot time; system configuration is largely set at that time as well. At one time, the traditional inetd daemon was able to handle on-demand network services, but it has largely fallen out of use.</li>
</ul>
<p>Contemporary init systems have dealt with these problems by changing how services start, how they are supervised, and how the dependencies are configured. You’ll soon see how this works in systemd, but first, you should make sure that you’re running it.</p>
<h2 id="h1-500402c06-0002">	6.2	Identifying Your init</h2>
<p class="BodyFirst">Determining your system’s version of init usually isn’t difficult. Viewing the init(1) manual page normally tells you right away, but if you’re not sure, check your system as follows:</p>
<ul>
<li>If your system has <em>/usr/lib/systemd</em> and <em>/etc/systemd</em> directories, you have systemd.</li>
<li>If you have an <em>/etc/init</em> directory that contains several <em>.conf</em> files, you’re probably running Upstart (unless you’re running Debian 7 or older, in which case you probably have System V init). We won’t cover Upstart in this book because it has been widely supplanted by systemd.</li>
<li>If neither of the above is true, but you have an <em>/etc/inittab</em> file, you’re probably running System V init. Go to <span class="xref" itemid="xref_target_Section 6.5">Section 6.5</span>.</li>
</ul>
<h2 id="h1-500402c06-0003">	6.3	systemd</h2>
<p class="BodyFirst">The systemd init is one of the newest init implementations on Linux. In addition to handling the regular boot process, systemd aims to incorporate the functionality of a number of standard Unix services, such as cron and inetd. It takes some inspiration from Apple’s launchd.</p>
<p>Where systemd really stands out from its predecessors is its advanced service management capabilities. Unlike a traditional init, systemd can track individual service daemons after they start, and group together multiple processes associated with a service, giving you more power and insight into exactly what is running on the system.</p>
<p>systemd is goal-oriented. At the top level, you can think of defining a goal, called a <em>unit</em>, for some system task. A unit can contain instructions for common startup tasks, such as starting a daemon, and it also has dependencies, which are other units. When starting (or <em>activating</em>) a unit, systemd attempts to activate its dependencies and then moves on to the details of the unit.</p>
<p><span epub:type="pagebreak" title="140" id="Page_140"/>When starting services, systemd does not follow a rigid sequence; instead, it activates units whenever they are ready. After boot, systemd can react to system events (such as the uevents outlined in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>) by activating additional units.</p>
<p> Let’s start by looking at a top-level view of units, activation, and the initial boot process. Then you’ll be ready to see the specifics of unit configuration and the many varieties of unit dependencies. Along the way, you’ll get a grip on how to view and control a running system.</p>
<h3 id="h2-500402c06-0001">6.3.1	Units and Unit Types</h3>
<p class="BodyFirst">One way that systemd is more ambitious than previous versions of init is that it doesn’t just operate processes and services; it can also manage filesystem mounts, monitor network connection requests, run timers, and more. Each capability is called a <em>unit type</em>, and each specific function (such as a service) is called a <em>unit</em>. When you turn on a unit, you <em>activate</em> it. Each unit has its own configuration file; we’ll explore those files in <span class="xref" itemid="xref_target_Section">Section</span> <span class="xref" itemid="xref_target_6.3.3">6.3.3</span>.</p>
<p>These are the most significant unit types that perform the boot-time tasks on a typical Linux system:</p>
<ol class="none">
<li><span class="RunInHead">Service units</span>  Control the service daemons found on a Unix system.</li>
<li><span class="RunInHead">Target units</span>  Control other units, usually by grouping them.</li>
<li><span class="RunInHead">Socket units</span>  Represent incoming network connection request locations.</li>
<li><span class="RunInHead">Mount units</span>  Represent the attachment of filesystems to the system.<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You can find a complete list of unit types in the systemd(1) manual page. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</li>
</ol>
<p>Of these, service and target units are the most common and the easiest to understand. Let’s take a look at how they fit together when you boot a system.</p>
<h3 id="h2-500402c06-0002">6.3.2	Booting and Unit Dependency Graphs</h3>
<p class="BodyFirst">When you boot a system, you’re activating a default unit, normally a target unit called <em>default.target</em> that groups together a number of service and mount units as dependencies. As a result, it’s somewhat easy to get a partial picture of what’s going to happen when you boot. You might expect the unit dependencies to form a tree—with one unit at the top, branching into several units below for later stages of the boot process—but they actually form a graph. A unit that comes late in the boot process can depend on several previous units, making earlier branches of a dependency tree join back together. You can even create a dependency graph with the <code>systemd-analyze dot</code> command. The entire graph is quite large on a typical system (requiring significant computing power to render), and it’s hard to read, but there are ways to filter units and zero in on individual portions.</p>
<p><span epub:type="pagebreak" title="141" id="Page_141"/><a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a> shows a very small part of the dependency graph for the <em>default.target</em> unit found on a typical system. When you activate that unit, all of the units below it also activate.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	On most systems, <em>default.target</em> is a link to some other high-level target unit, such as one that represents a user interface startup. On the system shown in <a href="#figure6-1">Figure 6-1</a>, <em>default.target</em> groups the units necessary to start a GUI.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<figure>
<img src="image_fi/500402c06/f06001_new.png" alt="f06001_new"/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>: Unit dependency graph</p></figcaption></figure>
<p>This figure is a greatly simplified view. On your own system, you won’t find it feasible to sketch out the dependencies just by looking at the unit configuration file at the top and working your way down. We’ll take a closer look at how dependencies work in <span class="xref" itemid="xref_target_Section 6.3.6">Section 6.3.6</span>.</p>
<h3 id="h2-500402c06-0003">6.3.3	systemd Configuration</h3>
<p class="BodyFirst">The systemd configuration files are spread among many directories across the system, so you might need to do a little hunting when you’re looking for a particular file. There are two main directories for systemd configuration: the <em>system unit</em> directory (global configuration; usually <em>/lib/systemd/system</em> or <em>/usr/lib/systemd/system</em>) and the <em>system configuration</em> directory (local definitions; usually <em>/etc/systemd/system</em>). </p>
<p>To prevent confusion, stick to this rule: avoid making changes to the system unit directory, because your distribution will maintain it for you. Make your local changes to the system configuration directory. This general rule also applies systemwide. When given the choice between modifying something in <em>/usr</em> and <em>/etc</em>, always change <em>/etc</em>.</p>
<p><span epub:type="pagebreak" title="142" id="Page_142"/>You can check the current systemd configuration search path (including precedence) with this command:</p>
<pre><code>$ <b>systemctl -p UnitPath show</b>
<code>UnitPath=/etc/systemd/system.control /run/systemd/system.control /run/systemd/transient /etc/systemd/system /run/systemd/system /run/systemd/generator /lib/systemd/system /run/systemd/generator.late</code></code></pre>
<p>To see the system unit and configuration directories on your system, use the following commands:</p>
<pre><code>$ <b>pkg-config systemd --variable=systemdsystemunitdir</b>
/lib/systemd/system
$ <b>pkg-config systemd --variable=systemdsystemconfdir</b>
/etc/systemd/system</code></pre>
<h4 id="h3-500402c06-0001">Unit Files</h4>
<p class="BodyFirst">The format for unit files is derived from the XDG Desktop Entry specification (used for <em>.desktop</em> files, which are very similar to <em>.ini</em> files on Microsoft systems), with section names in square brackets (<code>[]</code>) and variable and value assignments (options) in each section. </p>
<p>As an example, consider the <em>dbus-daemon.service</em> unit file for the desktop bus daemon:</p>
<pre><code>[Unit]
Description=D-Bus System Message Bus
Documentation=man:dbus-daemon(1)
Requires=dbus.socket
RefuseManualStart=yes

[Service]
ExecStart=/usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
ExecReload=/usr/bin/dbus-send --print-reply --system --type=method_call --dest= org.freedesktop.DBus / org.freedesktop.DBus.ReloadConfig</code></pre>
<p>There are two sections, <code>[Unit]</code> and <code>[Service]</code>. The <code>[Unit]</code> section gives some details about the unit and contains description and dependency information. In particular, this unit requires the <em>dbus.socket</em> unit as a dependency.</p>
<p>In a service unit such as this, you’ll find the details about the service in the <code>[Service]</code> section, including how to prepare, start, and reload the service. You’ll find a complete listing in the systemd.service(5) and systemd.exec(5) manual pages, as well as in the discussion of process tracking in <span class="xref" itemid="xref_target_Section 6.3.5">Section 6.3.5</span>.</p>
<p>Many other unit configuration files are similarly straightforward. For example, the service unit file <em>sshd.service</em> enables remote secure shell logins by starting sshd.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="143" id="Page_143"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	The unit files you find on your system may differ slightly. In this example, you saw that Fedora uses the name <em>dbus-daemon.service</em>, and Ubuntu uses <em>dbus.service</em>. There may be changes in the actual files as well, but they are often superficial.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c06-0002">Variables</h4>
<p class="BodyFirst">You’ll often find variables inside unit files. Here’s a section from a different unit file, this one for the secure shell that you’ll learn about in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>:</p>
<pre><code>[Service]
EnvironmentFile=/etc/sysconfig/sshd
ExecStartPre=/usr/sbin/sshd-keygen
ExecStart=/usr/sbin/sshd -D $OPTIONS $CRYPTO_POLICY
ExecReload=/bin/kill -HUP $MAINPID</code></pre>
<p>Everything that starts with a dollar sign (<code>$</code>) is a variable. Although these variables have the same syntax, their origins are different. The <code>$OPTIONS</code> and <code>$CRYPTO_POLICY</code> options, which you can pass to sshd upon unit activation, are defined in the file specified by the <code>EnvironmentFile</code> setting. In this particular case, you can look at <em>/etc/sysconfig/sshd</em> to determine if the variables are set and, if so, what their values are.</p>
<p>In comparison, <code>$MAINPID</code> contains the ID of the <em>tracked process</em> of the service (see <span class="xref" itemid="xref_target_Section 6.3.5">Section 6.3.5</span>). Upon unit activation, systemd records and stores this PID so that you can use it to manipulate a service-specific process later on. The <em>sshd.service</em> unit file uses <code>$MAINPID</code> to send a hangup (HUP) signal to sshd when you want to reload the configuration (this is a very common technique for dealing with reloads and restarting Unix daemons).</p>
<h4 id="h3-500402c06-0003">Specifiers</h4>
<p class="BodyFirst">A <em>specifier</em> is a variable-like feature often found in unit files. Specifiers start with a percent sign (<code>%</code>). For example, the <code>%n</code> specifier is the current unit name, and the <code>%H</code> specifier is the current hostname.</p>
<p>You can also use specifiers to create multiple copies of a unit from a single unit file. One example is the set of <code>getty</code> processes that control the login prompts on virtual consoles, such as <em>tty1</em> and <em>tty2</em>. To use this feature, add an @ symbol to the end of the unit name, before the dot in the unit filename.</p>
<p>For example, the <code>getty</code> unit filename is <em>getty@.service</em> in most distributions, allowing for the dynamic creation of units, such as <em>getty@tty1</em> and <em>getty@tty2</em>. Anything after the @ is called the <em>instance</em>. When you look at one of these unit files, you may also see a <code>%I</code> or <code>%i</code> specifier. When activating a service from a unit file with instances, systemd replaces the <code>%I</code> or <code>%i</code> specifier with the instance to create the new service name.</p>
<h3 id="h2-500402c06-0004"><span epub:type="pagebreak" title="144" id="Page_144"/>6.3.4	systemd Operation</h3>
<p class="BodyFirst">You’ll interact with systemd primarily through the <code>systemctl</code> command, which allows you to activate and deactivate services, list status, reload the configuration, and much more. </p>
<p>The most essential commands help you to obtain unit information. For example, to view a list of active units on your system, issue a <code>list-units</code> command. (This is the default command for <code>systemctl</code>, so technically you don’t need the <code>list-units</code> argument.)</p>
<pre><code>$ <b>systemctl list-units</b></code></pre>
<p>The output format is typical of a Unix information-listing command. For example, the header and the line for <em>-.mount</em> (the root filesystem) looks like this:</p>
<pre><code>UNIT                      LOAD   ACTIVE SUB       DESCRIPTION
-.mount                   loaded active mounted   Root Mount</code></pre>
<p>By default, <code>systemctl list-units</code> produces a lot of output, because a typical system has numerous active units, but it’s still an abridged form because <code>systemctl</code> truncates any really large unit names. To see the full names of the units, use the <code>--full</code> option, and to see all units (not just those that are active), use the <code>--all</code> option.</p>
<p>A particularly useful <code>systemctl</code> operation is getting the status of a specific unit. For example, here’s a typical <code>status</code> command and some of its output:</p>
<pre><code>$ <b>systemctl status sshd.service</b>
· sshd.service - OpenBSD Secure Shell server
   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
   Active: active (running) since Fri 2021-04-16 08:15:41 EDT; 1 months 1 days ago
 Main PID: 1110 (sshd)
    Tasks: 1 (limit: 4915)
   CGroup: /system.slice/sshd.service
           ⌙1110 /usr/sbin/sshd -D</code></pre>
<p>A number of log messages may also follow this output. If you’re used to a traditional init system, you might be surprised by the amount of useful information available from this one command. You get not only the state of the unit but also the processes associated with the service, when the unit started, and a number of log messages, if available. </p>
<p>The output for other unit types includes similar useful information; for example, the output from mount units includes when the mount happened, the exact command line used for it, and its exit status.</p>
<p>One interesting piece of the output is the control group (cgroup) name. In the preceding example, the control group is <code>/system.slice/sshd.service</code>, and the processes in the cgroup are shown below it. However, you may also <span epub:type="pagebreak" title="145" id="Page_145"/>see control groups named starting with <code>systemd:/system</code> if the processes of a unit (for example, a mount unit) have already terminated. You can view systemd-related cgroups without the rest of the unit status with the <code>systemd-cgls</code> command. You’ll learn more about how systemd uses cgroups in <span class="xref" itemid="xref_target_Section 6.3.5">Section 6.3.5</span>, and how cgroups work in<span class="xref" itemid="xref_target_ Section 8.6"> Section 8.6</span>.</p>
<p>The <code>status</code> command also displays only the most recent diagnostic log messages for the unit. You can view all of a unit’s messages like this:</p>
<pre><code>$ <b>journalctl --unit=</b><var class="bold">unit_name</var></code></pre>
<p>You’ll learn much more about <code>journalctl</code> in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Depending on your system and user configuration, you might need superuser privileges to run <var>journalctl</var>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c06-0004">How Jobs Relate to Starting, Stopping, and Reloading Units</h4>
<p class="BodyFirst">To activate, deactivate, and restart units, you use the commands <code>systemctl start</code>, <code>systemctl stop</code>, and <code>systemctl restart</code>. However, if you’ve changed a unit configuration file, you can tell systemd to reload the file in one of two ways:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">systemctl reload </code><var class="bold">unit</var></span>  Reloads just the configuration for <var>unit</var>.</li>
<li><span class="RunInHead"><code class="bold">systemctl daemon-reload</code></span>  Reloads all unit configurations.</li>
</ol>
<p>Requests to activate, reactivate, and restart units are called <em>jobs</em> in systemd, and they are essentially unit state changes. You can check the current jobs on a system with:</p>
<pre><code>$ <b>systemctl list-jobs</b></code></pre>
<p>If a system has been up for some time, you can reasonably expect there to be no active jobs because all activations required to start the system should be complete. However, at boot time, you can sometimes log in fast enough to see jobs for units that start very slowly. For example:</p>
<pre><code>  JOB UNIT                      TYPE            STATE  
   1 graphical.target          start           waiting
   2 multi-user.target         start           waiting
  71 systemd-...nlevel.service start           waiting
  75 sm-client.service         start           waiting
  76 sendmail.service          start           running
 120 systemd-...ead-done.timer start           waiting</code></pre>
<p>In this case, job 76, the <em>sendmail.service</em> unit startup, is taking a really long time. The other listed jobs are in a waiting state, most likely because they’re all waiting for job 76. When <em>sendmail.service</em> finishes starting and is fully active, job 76 will complete, the rest of the jobs will also complete, and the job list will be empty.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="146" id="Page_146"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	The term <em>job</em> can be confusing, especially because some other init systems use it to refer to features that are more like systemd units. These jobs also have nothing to do with the shell’s job control.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>See <span class="xref" itemid="xref_target_Section 6.6">Section 6.6</span> to learn how to shut down and reboot the system.</p>
<h4 id="h3-500402c06-0005">Adding Units to systemd</h4>
<p class="BodyFirst">Adding units to systemd is primarily a matter of creating, then activating and possibly enabling, unit files. You should normally put your own unit files in the system configuration directory (<em>/etc/systemd/system</em>)<em> </em>so that you won’t confuse them with anything that came with your distribution and so that the distribution won’t overwrite them when you upgrade.</p>
<p>Because it’s easy to create target units that don’t actually do anything or interfere with your system, give it a try. To create two targets, one with a dependency on the other, follow these steps:</p>
<ol class="decimal">
<li value="1">Create a unit file named <em>test1.target</em> in <em>/etc/systemd/system</em>:
<pre><code>[Unit]
Description=test 1</code></pre>
</li>
<li value="2">Create a <em>test2.target</em> file with a dependency on <em>test1.target</em>:
<pre><code>[Unit]
Description=test 2
Wants=test1.target</code></pre>
<p class="ListBody">The <code>Wants</code> keyword here defines a dependency that causes <em>test1.target</em> to activate when you activate <em>test2.target</em>. Activate the <em>test2.target</em> unit to see it in action:</p>
<pre><code># <code class="bold">systemctl start test2.target</code></code></pre>
</li>
<li value="3">Verify that both units are active:
<pre><code># <code class="bold">systemctl status test1.target test2.target</code>
· test1.target - test 1
   Loaded: loaded (/etc/systemd/system/test1.target; static; vendor preset: enabled)
   Active: active since Tue 2019-05-28 14:45:00 EDT; 16s ago

May 28 14:45:00 duplex systemd[1]: Reached target test 1.

· test2.target - test 2
   Loaded: loaded (/etc/systemd/system/test2.target; static; vendor preset: enabled)
   Active: active since Tue 2019-05-28 14:45:00 EDT; 17s ago</code></pre>
</li>
<li value="4"><span epub:type="pagebreak" title="147" id="Page_147"/>If your unit file has an <code>[Install]</code> section, you need to “enable” the unit before activating it:
<pre><code><code class="bold"># systemctl enable </code><var class="bold">unit</var></code></pre>
</li>
</ol>
<p>The <code>[Install]</code> section is another way to create a dependency. We’ll look at it (and dependencies as a whole) in more detail in <span class="xref" itemid="xref_target_Section 6.3.6">Section 6.3.6</span>.</p>
<h4 id="h3-500402c06-0006">Removing Units from systemd</h4>
<p class="BodyFirst">To remove a unit, follow these steps:</p>
<ol class="decimal">
<li value="1">Deactivate the unit if necessary:
<pre><code># <code class="bold">systemctl stop </code><var class="bold">unit</var></code></pre>
</li>
<li value="2">If the unit has an <code>[Install]</code> section, disable the unit to remove any symbolic links created by the dependency system:
<pre><code># <code class="bold">systemctl disable </code><var class="bold">unit</var></code></pre>
</li>
</ol>
<p>You can then remove the unit file if you like.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Disabling a unit that is implicitly enabled (that is, does not have an <var>[Install]</var> section) has no effect.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c06-0005">6.3.5	systemd Process Tracking and Synchronization</h3>
<p class="BodyFirst">systemd wants a reasonable amount of information and control over every process it starts. This has been difficult historically. A service can start in different ways; it could fork new instances of itself or even daemonize and detach itself from the original process. There’s also no telling how many subprocesses the server can spawn.</p>
<p>In order to manage activated units easily, systemd uses the previously mentioned cgroups, a Linux kernel feature that allows for finer tracking of a process hierarchy. The use of cgroups also helps minimize the work that a package developer or administrator needs to do in order to create a working unit file. In systemd, you don’t have to worry about accounting for every possible startup behavior; all you need to know is whether a service startup process forks. Use the <code>Type</code> option in your service unit file to indicate startup behavior. There are two basic startup styles:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">Type=simple</code></span>  The service process doesn’t fork and terminate; it remains the main service process.</li>
<li><span class="RunInHead"><code class="bold">Type=forking</code></span>  The service forks, and systemd expects the original service process to terminate. Upon this termination, systemd assumes the service is ready.</li>
</ol>
<p><span epub:type="pagebreak" title="148" id="Page_148"/>The <code>Type=simple</code> option doesn’t account for the fact that a service may take some time to initiate, and as a result systemd doesn’t know when to start any dependent units that absolutely require such a service to be ready. One way to deal with this is to use delayed startup (see <span class="xref" itemid="xref_target_Section 6.3.7">Section 6.3.7</span>). However, some <code>Type</code> startup styles can indicate that the service itself will notify systemd when it’s ready:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">Type=notify</code></span>  When ready, the service sends a notification specific to systemd with a special function call.</li>
<li><span class="RunInHead"><code class="bold">Type=dbus</code></span>   When ready, the service registers itself on the D-Bus (Desktop Bus).</li>
</ol>
<p>Another service startup style is specified with <code>Type=oneshot</code>; here the service process terminates completely with no child processes after starting. It’s like <code>Type=simple</code>, except that systemd does not consider the service to be started until the service process terminates. Any strict dependencies (which you’ll see soon) will not start until that termination. A service using <code>Type=oneshot</code> also gets a default <code>RemainAfterExit=yes</code> directive so that systemd regards a service as active even after its processes terminate.</p>
<p>A final option is <code>Type=idle</code>. This works like the <code>simple</code> style, but it instructs systemd not to start the service until all active jobs finish. The idea here is just to delay a service start until other services have started to keep services from stepping on one another’s output. Remember, once a service has started, the systemd job that started it terminates, so waiting for all other jobs to finish ensures that nothing else is starting.</p>
<p>If you’re interested in how cgroups work, we’ll explore them in more detail in <span class="xref" itemid="xref_target_Section 8.6">Section 8.6</span>.</p>
<h3 id="h2-500402c06-0006">6.3.6	systemd Dependencies</h3>
<p class="BodyFirst">A flexible system for boot-time and operational dependencies requires some degree of complexity, because overly strict rules can cause poor system performance and instability. For example, say you want to display a login prompt after starting a database server, so you define a strict dependency from the login prompt to the database server. This means if the database server fails, the login prompt will also fail, and you won’t even be able to log in to your machine to fix the issue! </p>
<p>Unix boot-time tasks are fairly fault tolerant and can often fail without causing serious problems for standard services. For example, if you removed a system’s data disk but left its <em>/etc/fstab</em> entry (or mount unit in systemd), the boot-time filesystem mount would fail. Though this failure might affect application servers (such as web servers), it typically wouldn’t affect standard system operation.</p>
<p>To accommodate the need for flexibility and fault tolerance, systemd offers several dependency types and styles. Let’s first look at the basic types, labeled by their keyword syntax:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">Requires  </code></span>  Strict dependencies. When activating a unit with a <code>Requires</code> dependency unit, systemd attempts to activate the dependency unit. If the dependency unit fails, systemd also deactivates the dependent unit.</li>
<li><span epub:type="pagebreak" title="149" id="Page_149"/><span class="RunInHead"><code class="bold">Wants</code> </span>  Dependencies for activation only. Upon activating a unit, systemd activates the unit’s <code>Wants</code> dependencies, but it doesn’t care if those dependencies fail.</li>
<li><span class="RunInHead"><code class="bold">Requisite</code><b> </b></span>  Units that must already be active. Before activating a unit with a <code>Requisite</code> dependency, systemd first checks the status of the dependency. If the dependency hasn’t been activated, systemd fails on activation of the unit with the dependency.</li>
<li><span class="RunInHead"><code class="bold">Conflicts</code> </span>  Negative dependencies. When activating a unit with a <code>Conflict</code> dependency, systemd automatically deactivates the opposing dependency if it’s active. Simultaneous activation of conflicting units fails.</li>
</ol>
<p>The <code>Wants</code> dependency type is especially significant because it doesn’t propagate failures to other units. The systemd.service(5) manual page states that this is how you should specify dependencies if possible, and it’s easy to see why. This behavior produces a much more robust system, giving you the benefit of a traditional init, where the failure of an earlier startup component doesn’t necessarily prohibit later components from starting.</p>
<p>You can view a unit’s dependencies with the <code>systemctl</code> command, as long as you specify a type of dependency, such as <code>Wants</code> or <code>Requires</code>:</p>
<pre><code># <b>systemctl show -p </b><var class="bold">type unit</var></code></pre>
<h4 id="h3-500402c06-0007">Ordering</h4>
<p class="BodyFirst">So far, the dependency syntax you’ve seen hasn’t explicitly specified order. For example, activating most service units with <code>Requires</code> or <code>Wants</code> dependencies causes these units to start at the same time. This is optimal, because you want to start as many services as possible as quickly as possible to reduce boot time. However, there are situations when one unit must start after another. For instance, in the system that <a href="#figure6-1">Figure 6-1</a> is based on, the <em>default.target</em> unit is set to start after <em>multi-user.target</em> (this order distinction is not shown in the figure).</p>
<p>To activate units in a particular order, use the following dependency modifiers:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">Before</code> </span>  The current unit will activate before the listed unit(s). For example, if <code>Before=bar.target</code> appears in <em>foo.target</em>, systemd activates <em>foo.target</em> before <em>bar.target</em>.</li>
<li><span class="RunInHead"><code class="bold">After</code> </span>  The current unit activates after the listed unit(s).</li>
</ol>
<p>When you use ordering, systemd waits until a unit has an active status before activating its dependent units.</p>
<h4 id="h3-500402c06-0008">Default and Implicit Dependencies</h4>
<p class="BodyFirst">As you explore dependencies (especially with <code>systemd-analyze</code>), you might start to notice that some units acquire dependencies that aren’t explicitly stated in unit files or other visible mechanisms. You’re most likely to encounter this in target units with <code>Wants</code> dependencies—you’ll find that <span epub:type="pagebreak" title="150" id="Page_150"/>systemd adds an <code>After</code> modifier alongside any unit listed as a <code>Wants</code> dependency. These additional dependencies are internal to systemd, calculated at boot time, and not stored in configuration files.</p>
<p>The added <code>After</code> modifier is called a <em>default dependency</em>, an automatic addition to the unit configuration meant to avoid common mistakes and keep unit files small. These dependencies vary according to the type of unit. For example, systemd doesn’t add the same default dependencies for target units as it does for service units. These differences are listed in the DEFAULT DEPENDENCIES sections of the unit configuration manual pages, such as systemd.service(5) and systemd.target(5).</p>
<p>You can disable a default dependency in a unit by adding <code>DefaultDependencies=no</code> to its configuration file.</p>
<h4 id="h3-500402c06-0009">Conditional Dependencies</h4>
<p class="BodyFirst">You can use several<em> conditional dependency </em>parameters to test various operating system states rather than systemd units. For example:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">ConditionPathExists=p</code> </span>      True if the (file) path <em>p</em> exists in the system.</li>
<li><span class="RunInHead"><code class="bold">ConditionPathIsDirectory=p</code> </span>  True if <em>p</em> is a directory.</li>
<li><span class="RunInHead"><code class="bold">ConditionFileNotEmpty=p</code> </span>     True if <em>p</em> is a file and it’s not zero-length.</li>
</ol>
<p>If a conditional dependency in a unit is false when systemd tries to activate the unit, the unit does not activate, although this applies only to the unit in which it appears. That is, if you activate a unit that has a conditional dependency and some unit dependencies, systemd attempts to activate those unit dependencies regardless of whether the condition is true or false.</p>
<p>Other dependencies are primarily variations on the preceding ones. For example, the <code>RequiresOverridable</code> dependency is just like <code>Requires</code> when running normally, but it acts like a <code>Wants</code> dependency if a unit is manually activated. For a full list, see the systemd.unit(5) manual page.</p>
<h4 id="h3-500402c06-0010">The [Install] Section and Enabling Units</h4>
<p class="BodyFirst">So far, we’ve been looking at how to define dependencies in a dependent unit’s configuration file. It’s also possible to do this “in reverse”—that is, by specifying the dependent unit in a dependency’s unit file. You can do this by adding a <code>WantedBy</code> or <code>RequiredBy</code> parameter in the <code>[Install]</code> section. This mechanism allows you to alter when a unit should start without modifying additional configuration files (for example, when you’d rather not edit a system unit file).</p>
<p>To see how this works, consider the example units back in <span class="xref" itemid="xref_target_Section 6.3.4">Section 6.3.4</span>. We had two units, <em>test1.target</em> and <em>test2.target</em>, with <em>test2.target</em> having a <code>Wants</code> dependency on <em>test1.target</em>. We can change them so that <em>test1.target</em> looks like this:</p>
<pre><code>[Unit]
Description=test 1
	
[Install]
WantedBy=test2.target</code></pre>
<p><span epub:type="pagebreak" title="151" id="Page_151"/>And <em>test2.target</em> is as follows:</p>
<pre><code>[Unit]
Description=test 2</code></pre>
<p>Because you now have a unit with an <code>[Install]</code> section, you need to <em>enable</em> the unit with <code>systemctl</code> before you can start it. Here’s how that works with <em>test1.target</em>:</p>
<pre><code># <b>systemctl enable test1.target</b>
Created symlink /etc/systemd/system/test2.target.wants/test1.target → /etc/systemd/system/test1.target.</code></pre>
<p>Notice the output here—the effect of enabling a unit is to create a symbolic link in a <em>.wants</em> subdirectory corresponding to the dependent unit (<em>test2.target</em> in this case). You can now start both units at the same time with <code>systemctl start test2.target</code> because the dependency is in place.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Enabling a unit does not activate it.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>To disable the unit (and remove the symbolic link), use <code>systemctl</code> as follows:</p>
<pre><code># <b>systemctl disable test1.target</b>
Removed /etc/systemd/system/test2.target.wants/test1.target.</code></pre>
<p>The two units in this example also give you a chance to experiment with different startup scenarios. For example, see what happens when you try to start only <em>test1.target</em>, or when you try to start <em>test2.target</em> without enabling <em>test1.target</em>. Or, try changing <code>WantedBy</code> to <code>RequiredBy</code>. (Remember, you can check the status of a unit with <code>systemctl status</code>.)</p>
<p>During normal operation, systemd ignores the <code>[Install]</code> section in a unit but notes its presence and, by default, considers the unit to be disabled. Enabling a unit survives reboots.</p>
<p>The <code>[Install]</code> section is usually responsible for the <em>.wants</em> and <em>.requires</em> directories in the system configuration directory (<em>/etc/systemd/system</em>). However, the unit configuration directory (<em>[/usr]/lib/systemd/system</em>) also contains <em>.wants</em> directories, and you may also add links that don’t correspond to <code>[Install]</code> sections in the unit files. These manual additions are a simple way to add a dependency without modifying a unit file that may be overwritten in the future (by a software upgrade, for instance), but they’re not particularly encouraged because a manual addition is difficult to trace.</p>
<h3 id="h2-500402c06-0007">6.3.7	systemd On-Demand and Resource-Parallelized Startup</h3>
<p class="BodyFirst">One of systemd’s features is the ability to delay a unit startup until it is absolutely needed. The setup typically works like this:</p>
<ol class="decimal">
<li value="1">You create a systemd unit (call it Unit A) for the system service you’d like to provide.</li>
<li value="2"><span epub:type="pagebreak" title="152" id="Page_152"/>You identify a system resource, such as a network port/socket, file, or device, that Unit A uses to offer its services.</li>
<li value="3">You create another systemd unit, Unit R, to represent that resource. These units are classified into types, such as socket units, path units, and device units.</li>
<li value="4">You define the relationship between Unit A and Unit R. Normally, this is implicit based on the units’ names, but it can also be explicit, as we’ll see shortly.</li>
</ol>
<p>Once in place, the operation proceeds as follows:</p>
<ol class="decimal">
<li value="1">Upon activation of Unit R, systemd monitors the resource.</li>
<li value="2">When anything tries to access the resource, systemd blocks the resource, and the input to the resource is buffered.</li>
<li value="3">systemd activates Unit A.</li>
<li value="4">When ready, the service from Unit A takes control of the resource, reads the buffered input, and runs normally.</li>
</ol>
<p>There are a few concerns here:</p>
<ul>
<li>You must make sure that your resource unit covers every resource that the service provides. This normally isn’t a problem, because most services have just one point of access.</li>
<li>You need to make sure your resource unit is tied to the service unit that it represents. This can be implicit or explicit, and in some cases, many options represent different ways for systemd to perform the handoff to the service unit.</li>
<li>Not all servers know how to interface with the resource units systemd can provide.</li>
</ul>
<p>If you already know what traditional utilities like inetd, xinetd, and automount do, you’ll see many similarities. Indeed, the concept is nothing new; systemd even includes support for automount units.</p>
<h4 id="h3-500402c06-0011">An Example Socket Unit and Service </h4>
<p class="BodyFirst">Let’s look at an example, a simple network echo service. This is somewhat advanced material, and you might not fully understand it until you’ve read the discussion of TCP, ports, and listening in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> and sockets in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, but you should be able to get the basic idea.</p>
<p>The idea of an echo service is to repeat anything that a network client sends after connecting; ours will listen on TCP port 22222. We’ll start building it with a <em>socket unit</em> to represent the port, as shown in the following <em>echo.socket</em> unit file:</p>
<pre><code>[Unit]
Description=echo socket

<span epub:type="pagebreak" title="153" id="Page_153"/>[Socket]
ListenStream=22222
Accept=true</code></pre>
<p>Note that there’s no mention of the service unit that this socket supports inside the unit file. So, what is that corresponding service unit file?</p>
<p>Its name is <em>echo@.service</em>. The link is established by naming convention; if a service unit file has the same prefix as a <em>.socket</em> file (in this case, <em>echo</em>), systemd knows to activate that service unit when there’s activity on the socket unit. In this case, systemd creates an instance of <em>echo@.service</em> when there’s activity on <em>echo.socket</em>. Here’s the <em>echo@.service</em> unit file:</p>
<pre><code>[Unit]
Description=echo service

[Service]
ExecStart=/bin/cat
StandardInput=socket</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you don’t like the implicit activation of units based on the prefixes, or you need to link units with different prefixes, you can use an explicit option in the unit defining your resource. For example, use <var>Socket=bar.socket</var> inside <em>foo.service</em> to have <em>bar.socket</em> hand its socket to <em>foo.service</em>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>To get this example unit running, you need to start the <em>echo.socket</em> unit:</p>
<pre><code># <b>systemctl start echo.socket</b></code></pre>
<p>Now you can test the service by connecting to your local TCP port 22222 with a utility such as <code>telnet</code>. The service repeats what you enter; here’s an example interaction:</p>
<pre><code>$ <b>telnet localhost 22222</b>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<b>Hi there.</b>
Hi there.</code></pre>
<p>When you’re bored with this and want to get back to your shell, press <span class="KeyCaps">ctrl</span>-] on a line by itself and then press <span class="KeyCaps">ctrl</span>-D. To stop the service, stop the socket unit like so:</p>
<pre><code># <b>systemctl stop echo.socket</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	<var>telnet</var> may not be installed by default on your distribution.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c06-0012"><span epub:type="pagebreak" title="154" id="Page_154"/>Instances and Handoff</h4>
<p class="BodyFirst">Because the <em>echo@.service</em> unit supports multiple simultaneous instances, there’s an <em>@</em> in the name (recall that the <em>@</em> specifier signifies parameterization). Why would you want multiple instances? Say you have more than one network client connecting to the service at the same time, and you want each connection to have its own instance. In this case, the service unit <em>must</em> support multiple instances because we included the <code>Accept=true</code> option in <em>echo.socket</em>. That option instructs systemd not only to listen on the port, but also to accept incoming connections on behalf of the service unit and pass it to them, creating a separate instance for each connection. Each instance reads data from the connection as standard input, but it doesn’t necessarily need to know that the data is coming from a network connection.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Most network connections require more flexibility than just a simple gateway to standard input and output, so don’t expect to be able to create complex network services with a service unit file like the <em>echo@.service</em> unit file shown here.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If a service unit can do the work of accepting a connection, don’t put an <em>@</em> in its unit filename, and don’t put <code>Accept=true</code> in the socket unit. In this case, the service unit takes complete control of the socket from systemd, which in turn does not attempt to listen on the network port again until the service unit finishes.</p>
<p>The many different resources and options for handoff to service units make it difficult to provide a categorical summary. Not only that, but the documentation for the options is spread out over several manual pages. For the resource-oriented units, check systemd.socket(5), systemd.path(5), and systemd.device(5). One document that’s often overlooked for service units is systemd.exec(5), which contains information about how the service unit can expect to receive a resource upon activation.</p>
<h4 id="h3-500402c06-0013">Boot Optimization with Auxiliary Units</h4>
<p class="BodyFirst">An overall goal of systemd is to simplify dependency order and speed up boot time. Resource units such as socket units provide a way to do this that’s similar to on-demand startup. We’ll still have a service unit and an auxiliary unit representing the service unit’s offered resource, except that in this case, systemd starts the service unit as soon as it activates the auxiliary unit rather than waiting around for a request. </p>
<p>The reason for this scheme is that essential boot-time service units such as <em>systemd-journald.service</em> take some time to start, and many other units depend on them. However, systemd can offer the essential resource of a unit (such as a socket unit) very quickly, and then it can immediately activate not only the essential unit but also any units that depend on it. Once the essential unit is ready, it takes control of the resource.</p>
<p><a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a> shows how this might work in a traditional sequential system. In this boot timeline, Service E provides an essential Resource R. Services A, B, and C depend on this resource (but not on each other) and must <span epub:type="pagebreak" title="155" id="Page_155"/>wait until Service E has started. Because the system will not start a new service until it’s done starting the preceding one, it takes quite a long time to get around to starting Service C.</p>
<figure>
<img src="image_fi/500402c06/f06002.png" alt="f06002"/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: Sequential boot timeline with a resource dependency</p></figcaption></figure>
<p><a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a> shows a possible equivalent systemd boot configuration. The services are represented by Units A, B, C, and E, with a new Unit R representing the resource that Unit E provides. Because systemd can provide an interface for Unit R while Unit E starts, Units A, B, C, and E can all be started at the same time. When ready, Unit E takes over for Unit R. An interesting point here is that Unit A, B, or C may not need to access the resource that Unit R provides before finishing startup. What we’re doing is providing them with the <em>option</em> to start accessing the resource as soon as possible.</p>
<figure>
<img src="image_fi/500402c06/f06003.png" alt="f06003"/>
<figcaption><p><a id="figure6-3">Figure 6-3</a>: systemd boot timeline with a resource unit</p></figcaption></figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="156" id="Page_156"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	When you parallelize startup like this, there’s a chance that your system will slow down temporarily due to a large number of units starting at once.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The takeaway is that, although you’re not creating an on-demand unit startup in this case, you’re using the same features that make on-demand startup possible. For common real-world examples, see the journald and D-Bus configuration units on a machine running systemd; they’re very likely to be parallelized in this way.</p>
<h3 id="h2-500402c06-0008">6.3.8	systemd Auxiliary Components</h3>
<p class="BodyFirst">As systemd has grown in popularity, it has grown to include support for a few tasks not related to startup and service management, both directly and through auxiliary compatibility layers. You may notice the numerous programs in <em>/lib/systemd</em>; these are the executables related to those functions. </p>
<p>Here are a few specific system services:</p>
<ol class="none">
<li><span class="RunInHead">udevd</span>  You learned about this in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>; it’s part of systemd.</li>
<li><span class="RunInHead">journald</span>  A logging service that handles a few different logging mechanisms, including the traditional Unix <code>syslog</code> service. You’ll read more about this in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</li>
<li><span class="RunInHead">resolved</span>  A name service caching daemon for DNS; you’ll learn about that in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>.</li>
</ol>
<p>All of the executables for these services are prefixed with <code>systemd-</code>. For example, the systemd-integrated udevd is called <code>systemd-udevd</code>.</p>
<p>If you dig deeper, you’ll find that some of these programs are relatively simple wrappers. Their function is to run standard system utilities and notify systemd of the results. One example is <code>systemd-fsck</code>.</p>
<p>If you see a program in <em>/lib/systemd</em> that you can’t identify, check for a manual page. There’s a good chance that it will describe not only the utility but also the type of unit it’s meant to augment.</p>
<h2 id="h1-500402c06-0004">	6.4	System V Runlevels</h2>
<p class="BodyFirst">Now that you’ve learned about systemd and how it works, let’s shift gears and look at some aspects of the traditional System V init. At any given time on a Linux system, a certain base set of processes (such as crond and udevd) is running. In System V init, this state of the machine is called its <em>runlevel</em>, which is denoted by a number from 0 through 6. A system spends most of its time in a single runlevel, but when you shut down the machine, init switches to a different runlevel in order to terminate the system services in an orderly fashion and tell the kernel to stop. </p>
<p>You can check your system’s runlevel with the <code>who -r</code> command like this:</p>
<pre><code>$ <b>who -r</b>
run-level 5  2019-01-27 16:43</code></pre>
<p><span epub:type="pagebreak" title="157" id="Page_157"/>This output tells us that the current runlevel is 5, as well as the date and time that the runlevel was established.</p>
<p>Runlevels serve various purposes, but the most common one is to distinguish between system startup, shutdown, single-user mode, and console mode states. For example, most systems traditionally used runlevels 2 through 4 for the text console; a runlevel of 5 means that the system starts a GUI login.</p>
<p>But runlevels are becoming a thing of the past. Even though systemd supports them, it considers runlevels obsolete as end states for the system, preferring target units instead. To systemd, runlevels exist primarily to start services that support only the System V init scripts.</p>
<h2 id="h1-500402c06-0005">	6.5	System V init</h2>
<p class="BodyFirst">The System V init implementation is among the oldest used on Linux; its core idea is to support an orderly bootup to different runlevels with a carefully constructed startup sequence. System V init is now uncommon on most server and desktop installations, but you may encounter it in versions of RHEL prior to version 7.0, as well as in embedded Linux environments, such as routers and phones. In addition, some older packages may only provide startup scripts designed for System V init; systemd can handle those with a compatibility mode that we’ll discuss in <span class="xref" itemid="xref_target_Section 6.5.5">Section 6.5.5</span>. We’ll look at the basics here, but keep in mind that you might not actually encounter anything covered in this section.</p>
<p>A typical System V init installation has two components: a central configuration file and a large set of boot scripts augmented by a symbolic link farm. The configuration file <em>/etc/inittab</em> is where it all starts. If you have System V init, look for a line like the following in your <em>inittab</em> file: </p>
<pre><code>id:5:initdefault:</code></pre>
<p>This indicates that the default runlevel is 5. </p>
<p>All lines in <em>inittab</em> take the following form, with four fields separated by colons in this order: </p>
<ol class="decimal">
<li value="1">A unique identifier (a short string, such as <code>id</code> in the previous example).</li>
<li value="2">The applicable runlevel number(s).</li>
<li value="3">The action that init should take (default runlevel to 5 in the previous example).</li>
<li value="4">A command to execute (optional).</li>
</ol>
<p>To see how commands work in an <em>inittab</em> file, consider this line: </p>
<pre><code>l5:5:wait:/etc/rc.d/rc 5</code></pre>
<p>This particular line is important because it triggers most of the system configuration and services. Here, the <code>wait</code> action determines when and how System V init runs the command: run <code>/etc/rc.d/rc 5</code> once when entering <span epub:type="pagebreak" title="158" id="Page_158"/>runlevel 5 and then wait for this command to finish before doing anything else. The <code>rc 5</code> command executes anything in <em>/etc/rc5.d</em> that starts with a number (in numeric order). We’ll cover this in more detail shortly. </p>
<p>The following are some of the most common <em>inittab</em> actions in addition to <code>initdefault</code> and <code>wait</code>:</p>
<span class="RunInHead"><code class="bold">respawn</code></span>
<ol class="none">
<li>The <code>respawn</code> action tells init to run the command that follows and, if the command finishes executing, to run it again. You’re likely to see something like this in an <em>inittab</em> file: 
<pre><code>1:2345:respawn:/sbin/mingetty tty1</code></pre>
</li>
<li>The <code>getty</code> programs provide login prompts. The preceding line is used for the first virtual console (<em>/dev/tty1</em>), which is the one you see when you press <span class="KeyCaps">alt</span>-F1 or <span class="KeyCaps">ctrl-alt</span>-F1 (see <span class="xref" itemid="xref_target_Section 3.4.7">Section 3.4.7</span>). The <code>respawn</code> action brings the login prompt back after you log out. </li>
</ol>
<span class="RunInHead"><code class="bold">ctrlaltdel</code></span>
<ol class="none">
<li>The <code>ctrlaltdel</code> action controls what the system does when you press <span class="KeyCaps">ctrl-alt-del</span> on a virtual console. On most systems, this is some sort of reboot command using the <code>shutdown</code> command (discussed in <span class="xref" itemid="xref_target_Section 6.6">Section 6.6</span>). </li>
</ol>
<span class="RunInHead"><code class="bold">sysinit</code></span>
<ol class="none">
<li>The <code>sysinit</code> action is the first thing that init should run when starting, before entering any runlevels.<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	For more available actions, see the inittab(5) manual page. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</li>
</ol>
<h3 id="h2-500402c06-0009">6.5.1	System V init: Startup Command Sequence</h3>
<p class="BodyFirst">Now let’s look at how System V init starts system services, just before it lets you log in. Recall this <em>inittab</em> line from earlier: </p>
<pre><code>l5:5:wait:/etc/rc.d/rc 5</code></pre>
<p>This short line triggers many other programs. In fact, <code>rc</code> stands for <em>run commands</em>, which many people refer to as <em>scripts</em>, <em>programs</em>, or <em>services</em>. But where are these commands? </p>
<p>The <code>5</code> in this line tells us that we’re talking about runlevel 5. The commands are probably in either <em>/etc/rc.d/rc5.d</em> or <em>/etc/rc5.d</em>. (Runlevel 1 uses <em>rc1.d</em>, runlevel 2 uses <em>rc2.d</em>, and so on.) For example, you might find the following items in the <em>rc5.d</em> directory: </p>
<pre><code>S10sysklogd     S20ppp          S99gpm
S12kerneld      S25netstd_nfs   S99httpd
S15netstd_init  S30netstd_misc  S99rmnologin
<span epub:type="pagebreak" title="159" id="Page_159"/>S18netbase      S45pcmcia       S99sshd
S20acct         S89atd          
S20logoutd      S89cron         </code></pre>
<p>The <code>rc 5</code> command starts programs in the <em>rc5.d</em> directory by executing the following commands in this sequence: </p>
<pre><code>S10sysklogd start
S12kerneld start
S15netstd_init start
S18netbase start
--<var>snip</var>--
S99sshd start</code></pre>
<p>Notice the <code>start</code> argument in each command. The capital <em>S</em> in a command name means that the command should run in <em>start</em> mode, and the number (00 through 99) determines where in the sequence <code>rc</code> starts the command. The <em>rc*.d</em> commands are usually shell scripts that start programs in <em>/sbin</em> or <em>/usr/sbin</em>. </p>
<p>Normally, you can figure out what a particular command does by viewing the script with <code>less</code> or another pager program.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Some <em>rc*.d</em> directories contain commands that start with <em>K</em> (for “kill,” or stop mode). In this case, <var>rc</var> runs the command with the <var>stop</var> argument instead of <var>start</var>. You’ll most likely encounter <var>K</var> commands in runlevels that shut down the system.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You can run these commands by hand; however, normally you’ll want to do so through the <em>init.d</em> directory instead of the <em>rc*.d</em> directories, which we’ll look at next.</p>
<h3 id="h2-500402c06-0010">6.5.2	The System V init Link Farm</h3>
<p class="BodyFirst">The contents of the <em>rc*.d</em> directories are actually symbolic links to files in yet another directory, <em>init.d</em>. If your goal is to interact with, add, delete, or modify services in the <em>rc*.d</em> directories, you need to understand these symbolic links. A long listing of a directory such as <em>rc5.d</em> reveals a structure like this: </p>
<pre><code>lrwxrwxrwx . . . S10sysklogd -&gt; ../init.d/sysklogd
lrwxrwxrwx . . . S12kerneld -&gt; ../init.d/kerneld
lrwxrwxrwx . . . S15netstd_init -&gt; ../init.d/netstd_init
lrwxrwxrwx . . . S18netbase -&gt; ../init.d/netbase
--<var>snip</var>--
lrwxrwxrwx . . . S99httpd -&gt; ../init.d/httpd
--<var>snip</var>--</code></pre>
<p>A large number of symbolic links across several subdirectories like this is called a <em>link farm</em>. Linux distributions contain these links so that they can use the same startup scripts for all runlevels. This is a convention, not a requirement, but it simplifies organization. </p>
<h4 id="h3-500402c06-0014"><span epub:type="pagebreak" title="160" id="Page_160"/>Starting and Stopping Services</h4>
<p class="BodyFirst">To start and stop services by hand, use the script in the <em>init.d</em> directory. For example, one way to start the httpd web server program manually is to run <code>init.d/httpd start</code>. Similarly, to kill a running service, you can use the <code>stop</code> argument (<code>httpd stop</code>, for instance).</p>
<h4 id="h3-500402c06-0015">Modifying the Boot Sequence</h4>
<p class="BodyFirst">Changing the boot sequence in System V init is normally done by modifying the link farm. The most common change is to prevent one of the commands in the <em>init.d</em> directory from running in a particular runlevel. You have to be careful about how you do this, however. For example, you might consider removing the symbolic link in the appropriate <em>rc*.d</em> directory. But if you ever need to put the link back, you might have trouble remembering its exact name. One of the best approaches is to add an underscore (<code>_</code>) at the beginning of the link name, like this: </p>
<pre><code># <b>mv S99httpd _S99httpd</b></code></pre>
<p>This change causes <code>rc</code> to ignore <em>_S99httpd</em> because the filename no longer starts with <em>S</em> or <em>K</em>, but the original name still indicates its purpose. </p>
<p>To add a service, create a script like those in the <em>init.d</em> directory and then create a symbolic link in the correct <em>rc*.d</em> directory. The easiest way to do this is to copy and modify one of the scripts already in <em>init.d</em> that you understand (see <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> for more information on shell scripts).</p>
<p>When adding a service, choose an appropriate place in the boot sequence to start it. If the service starts too soon, it may not work due to a dependency on some other service. For nonessential services, most systems administrators prefer numbers in the 90s, which puts the services after most of the services that came with the system.</p>
<h3 id="h2-500402c06-0011">6.5.3	run-parts</h3>
<p class="BodyFirst">The mechanism that System V init uses to run the <em>init.d</em> scripts has found its way into many Linux systems, regardless of whether they use System V init. It’s a utility called <code>run-parts</code>, and the only thing it does is run a bunch of executable programs in a given directory, in some kind of predictable order. You can think of <code>run-parts</code> as almost like a person who enters the <code>ls</code> command in some directory and then just runs whatever programs are listed in the output.</p>
<p>The default behavior is to run all programs in a directory, but you often have the option to select certain programs and ignore others. In some distributions, you don’t need much control over the programs that run. For example, Fedora ships with a very simple <code>run-parts</code> utility.</p>
<p>Other distributions, such as Debian and Ubuntu, have a more complicated <code>run-parts</code> program. Their features include the ability to run programs based on a regular expression (for example, using the <code>S[0-9]{2}</code> expression <span epub:type="pagebreak" title="161" id="Page_161"/>for running all “start” scripts in an <em>/etc/init.d </em>runlevel<em> </em>directory) and to pass arguments to the programs. These capabilities allow you to start and stop System V runlevels with a single command.</p>
<p>You don’t really need to understand the details of how to use <code>run-parts</code>; in fact, most people don’t know that it even exists. The main things to remember are that it shows up in scripts from time to time and that it exists solely to run the programs in a given directory.</p>
<h3 id="h2-500402c06-0012">6.5.4	System V init Control</h3>
<p class="BodyFirst">Occasionally, you’ll need to give init a little kick to tell it to switch runlevels, to reread its configuration, or to shut down the system. To control System V init, you use <code>telinit</code>. For example, to switch to runlevel 3, enter:</p>
<pre><code># <b>telinit 3</b></code></pre>
<p>When switching runlevels, init tries to kill off any processes not in the <em>inittab</em> file for the new runlevel, so be careful when changing runlevels. </p>
<p>When you need to add or remove jobs, or make any other change to the <em>inittab</em> file, you must tell init about the change and have it reload the file. The <code>telinit</code> command for this is: </p>
<pre><code># <b>telinit q</b></code></pre>
<p>You can also use <code>telinit s</code> to switch to single-user mode.</p>
<h3 id="h2-500402c06-0013">6.5.5	systemd System V Compatibility</h3>
<p class="BodyFirst">One feature that sets systemd apart from other newer-generation init systems is that it tries to do a more complete job of tracking services started by System V–compatible init scripts. It works like this:</p>
<ol class="decimal">
<li value="1">First, systemd activates <em>runlevel&lt;N&gt;.target</em>, where <em>N</em> is the runlevel.</li>
<li value="2">For each symbolic link in <em>/etc/rc&lt;N&gt;.d</em>, systemd identifies the script in <em>/etc/init.d</em>.</li>
<li value="3">systemd associates the script name with a service unit (for example, <em>/etc/init.d/foo</em> would be <em>foo.service</em>).</li>
<li value="4">systemd activates the service unit and runs the script with either a <code>start</code> or <code>stop</code> argument, based on its name in <em>rc&lt;N&gt;.d</em>.</li>
<li value="5">systemd attempts to associate any processes from the script with the service unit.</li>
</ol>
<p>Because systemd makes the association with a service unit name, you can use <code>systemctl</code> to restart the service or view its status. But don’t expect any miracles from System V compatibility mode; it still must run the init scripts serially, for example.</p>
<h2 id="h1-500402c06-0006"><span epub:type="pagebreak" title="162" id="Page_162"/>	6.6	Shutting Down Your System</h2>
<p class="BodyFirst">init controls how the system shuts down and reboots. The commands to shut down the system are the same regardless of which version of init you run. The proper way to shut down a Linux machine is to use the <code>shutdown</code> command.</p>
<p>There are two basic ways to use <code>shutdown</code>. If you <em>halt</em> the system, it shuts the machine down and keeps it down. To make the machine halt immediately, run this:</p>
<pre><code># <b>shutdown -h now</b></code></pre>
<p>On most machines and versions of Linux, a halt cuts the power to the machine. You can also <em>reboot</em> the machine. For a reboot, use <code>-r</code> instead of <code>-h</code>. </p>
<p>The shutdown process takes several seconds. You should avoid resetting or powering off a machine during a shutdown. </p>
<p>In the preceding example, <code>now</code> is the time to shut down. Including a time argument is mandatory, but there are many ways to specify it. For example, if you want the machine to shut down sometime in the future, you can use <code>+</code><var>n</var>, where <var>n</var> is the number of minutes <code>shutdown</code> should wait before proceeding. See the shutdown(8) manual page for other options.</p>
<p>To make the system reboot in 10 minutes, enter: </p>
<pre><code># <b>shutdown -r +10</b></code></pre>
<p>On Linux, <code>shutdown</code> notifies anyone logged on that the machine is going down, but it does little real work. If you specify a time other than <code>now</code>, the <code>shutdown</code> command creates a file called <em>/etc/nologin</em>. When this file is present, the system prohibits logins by anyone except the superuser.</p>
<p>When the system shutdown time finally arrives, <code>shutdown</code> tells init to begin the shutdown process. On systemd, this means activating the shutdown units, and on System V init, it means changing the runlevel to 0 (halt) or 6 (reboot). Regardless of the init implementation or configuration, the procedure generally goes like this:</p>
<ol class="decimal">
<li value="1">init asks every process to shut down cleanly.</li>
<li value="2">If a process doesn’t respond after a while, init kills it, first trying a TERM signal.</li>
<li value="3">If the TERM signal doesn’t work, init uses the KILL signal on any stragglers. </li>
<li value="4">The system locks system files into place and makes other preparations for shutdown. </li>
<li value="5">The system unmounts all filesystems other than the root. </li>
<li value="6">The system remounts the root filesystem read-only. </li>
<li value="7">The system writes all buffered data out to the filesystem with the <code>sync</code> program. </li>
<li value="8"><span epub:type="pagebreak" title="163" id="Page_163"/>The final step is to tell the kernel to reboot or stop with the <code>reboot(2)</code> system call. This can be done by init or an auxiliary program, such as <code>reboot</code>, <code>halt</code>, or <code>poweroff</code>. </li>
</ol>
<p>The <code>reboot</code> and <code>halt</code> programs behave differently depending on how they’re called, which may cause confusion. By default, these programs call <code>shutdown</code> with the <code>-r</code> or <code>-h</code> options. However, if the system is already at a halt or reboot runlevel, the programs tell the kernel to shut itself off immediately. If you really want to shut down your machine in a hurry, regardless of any potential damage from a disorderly shutdown, use the <code>-f</code> (force) option. </p>
<h2 id="h1-500402c06-0007">	6.7	The Initial RAM Filesystem</h2>
<p class="BodyFirst">The Linux boot process is, for the most part, fairly straightforward. However, one component has always been somewhat confounding: <em>initramfs</em>, or the <em>initial RAM filesystem</em>. Think of it as a little user-space wedge that goes in front of the normal user mode start. But first, let’s talk about why it exists.</p>
<p>The problem stems from the availability of many different kinds of storage hardware. Remember, the Linux kernel does not talk to the PC BIOS interface or EFI to get data from disks, so in order to mount its root filesystem, it needs driver support for the underlying storage mechanism. For example, if the root is on a RAID array connected to a third-party controller, the kernel needs the driver for that controller first. Unfortunately, there are so many storage controller drivers that distributions can’t include all of them in their kernels, so many drivers are shipped as loadable modules. But loadable modules are files, and if your kernel doesn’t have a filesystem mounted in the first place, it can’t load the driver modules that it needs.</p>
<p>The workaround is to gather a small collection of kernel driver modules along with a few other utilities into an archive. The boot loader loads this archive into memory before running the kernel. Upon start, the kernel reads the contents of the archive into a temporary RAM filesystem (the initramfs), mounts it at <em>/</em>, and performs the user-mode handoff to the init on the initramfs. Then, the utilities included in the initramfs allow the kernel to load the necessary driver modules for the real root filesystem. Finally, the utilities mount the real root filesystem and start the true init.</p>
<p>Implementations vary and are ever-evolving. On some distributions, the init on the initramfs is a fairly simple shell script that starts a udevd to load drivers, and then mounts the real root and executes the init there. On distributions that use systemd, you’ll typically see an entire systemd installation there with no unit configuration files and just a few udevd configuration files.</p>
<p>One basic characteristic of the initial RAM filesystem that has (so far) remained unchanged since its inception is the ability to bypass it if you don’t need it. That is, if your kernel has all the drivers it needs to mount your root filesystem, you can omit the initial RAM filesystem in your boot loader configuration. When successful, eliminating the initial RAM filesystem slightly shortens boot time. Try it yourself at boot time by using the <span epub:type="pagebreak" title="164" id="Page_164"/>GRUB menu editor to remove the <code>initrd</code> line. (It’s best not to experiment by changing the GRUB configuration file, as you can make a mistake that will be difficult to repair.) It has gradually become a little more difficult to bypass the initial RAM filesystem because features such as mount-by-UUID may not be available with generic distribution kernels.</p>
<p>You can check the contents of your initial RAM filesystem, but you’ll need to do a little bit of detective work. Most systems now use archives created by <code>mkinitramfs</code> that you can unpack with <code>unmkinitramfs</code>. Others might be older compressed <code>cpio</code> archives (see the cpio(1) manual page). </p>
<p>One particular piece of interest is the “pivot” near the very end of the init process on the initial RAM filesystem. This part is responsible for removing the contents of the temporary filesystem (to save memory) and permanently switch to the real root.</p>
<p>You won’t typically create your own initial RAM filesystem, as it’s a painstaking process. There are a number of utilities for creating initial RAM filesystem images, and your distribution likely comes with one. Two of the most common are <code>mkinitramfs</code> and <code>dracut</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The term <em>initial RAM filesystem</em> <em>(initramfs) </em>refers to the implementation that uses the <var>cpio</var> archive as the source of the temporary filesystem. There’s an older version called the <em>initial RAM disk</em>, or <em>initrd</em>, that uses a disk image as the basis of the temporary filesystem. This has fallen into disuse because it’s much easier to maintain a <var>cpio</var> archive. However, you’ll often see the term <em>initrd</em> used to refer to a <var>cpio</var>-based initial RAM filesystem. Often, the filenames and configuration files still contain <em>initrd</em>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c06-0008">	6.8	Emergency Booting and Single-User Mode</h2>
<p class="BodyFirst">When something goes wrong with the system, your first recourse is usually to boot the system with a distribution’s “live” image or with a dedicated rescue image, such as SystemRescueCD, that you can put on removable media. A live image is simply a Linux system that can boot and run without an installation process; most distributions’ installation images double as live images. Common tasks for fixing a system include the following: </p>
<ul>
<li>Checking filesystems after a system crash.</li>
<li>Resetting a forgotten password.</li>
<li>Fixing problems in critical files, such as <em>/etc/fstab</em> and <em>/etc/passwd.</em></li>
<li>Restoring from backups after a system crash.</li>
</ul>
<p>Another option for booting quickly to a usable state is <em>single-user mode</em>. The idea is that the system quickly boots to a root shell instead of going through the whole mess of services. In the System V init, single-user mode is usually runlevel 1. In systemd, it’s represented by <em>rescue.target</em>. You normally enter the mode with the <code>-s</code> parameter to the boot loader. You may need to type the root password to enter single-user mode. </p>
<p><span epub:type="pagebreak" title="165" id="Page_165"/>The biggest problem with single-user mode is that it doesn’t offer many amenities. The network almost certainly won’t be available (and if it is, it will be hard to use), you won’t have a GUI, and your terminal may not even work correctly. For this reason, live images are nearly always considered preferable.</p>
<h2 id="h1-500402c06-0009">	6.9	Looking Forward</h2>
<p class="BodyFirst">You’ve now seen the kernel and user-space startup phases of a Linux system, and how systemd tracks services once they’ve started. Next we’ll go a little deeper into user space. There are two areas to explore, starting with a number of system configuration files that all Linux programs use when interacting with certain elements of user space. Then we’ll see essential services that systemd starts.</p>
</section>
</body></html>