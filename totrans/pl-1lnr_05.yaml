- en: Chapter 6. Text Conversion and Substitution
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at various one-liners that change, convert, and
    substitute text, including base64 encoding and decoding, URL escaping and unescaping,
    HTML escaping and unescaping, converting text case, and reversing lines. You’ll
    also get to know the `y`, `tr`, `uc`, `lc`, and `reverse` operators and string-escape
    sequences.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 ROT13 a string
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This one-liner uses the `y` operator (also known as the `tr` operator) to do
    ROT13\. The operators `y` and `tr` perform string transliteration. Given `y/search/replace/`,
    the `y` operator transliterates all occurrences of the characters found in the
    `search` list with the characters in the corresponding positions in the `replace`
    list. The `y` and `tr` operators are often mistaken for taking a regular expression,
    but they don’t. They transliterate things and take a list of characters in both
    the `search` and `replace` parts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this one-liner, `A-Za-z` creates the following list of characters:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And `N-ZA-Mn-za-m` creates this list:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that in the second list the uppercase and lowercase alphabets are offset
    by 13 characters. Now the `y` operator translates each character in the first
    list to a character in the second list, thus performing the ROT13 operation. (One
    fun fact about ROT13 is that applying it twice produces the same string; that
    is, ROT13(ROT13(*string*)) equals *string*.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'To ROT13 the whole file *bananas.txt* and print it to the screen, just do this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use Perl’s `-i` argument to do in-place replacement of the file.
    For example, to ROT13 *oranges.txt* in-place, write this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This one-liner first creates a backup file called *oranges.txt.bak* and then
    replaces the contents of *oranges.txt* with ROT13-ed text. The `.bak` part of
    the `-i` command creates the backup file. You can omit the `.bak` part of the
    command if you’re sure about the result, but I recommend always using `-i.bak`
    because one day you might make a mistake and mess up an important file. (I speak
    from experience.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Base64-encode a string
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This one-liner uses the `MIME::Base64` module. It exports the `encode_base64`
    function, which takes a string and returns a base64-encoded version of it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'To base64-encode the whole file, use this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the `-0777` argument together with `-n` causes Perl to slurp the whole
    file into the `$_` variable. Next, the file is base64-encoded and printed. (If
    Perl didn’t slurp the entire file, it would be encoded line by line, and you’d
    end up with a mess.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Base64-decode a string
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `MIME::Base64` module also exports the `decode_base64` function, which takes
    a base64-encoded string and decodes it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The entire file can be decoded similarly with
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 6.4 URL-escape a string
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To use this one-liner, you need to install the `URI::Escape` module first by
    entering `cpan URI::Escape` in the shell. The module exports two functions: `uri_escape`
    and `uri_unescape`. The first function performs *URL escaping* (sometimes referred
    to as *URL encoding*), and the other does *URL unescaping* (or *URL decoding*).
    Now, to URL-escape a string, just call `uri_escape($string)` and you’re done!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The output of this one-liner is `http%3A%2F%2Fexample.com`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 URL-unescape a string
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This one-liner uses the `uri_unescape` function from the `URI::Escape` module
    to perform URL unescaping. It unescapes the output of the previous one-liner to
    reverse the operation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The output of this one-liner is `http://example.com`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 HTML-encode a string
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This one-liner uses the `encode_entities` function from the `HTML::Entities`
    module to encode HTML entities. For example, you can turn `<` and `>` into `&lt;`
    and `&gt;`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 6.7 HTML-decode a string
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This one-liner uses the `decode_entities` function from the `HTML::Entities`
    module. For example, you can turn `&lt;` and `&gt;` back into `<` and `>`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 Convert all text to uppercase
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This one-liner uses the `uc` function, which, by default, operates on the `$_`
    variable and returns an uppercase version of the text it contains.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do the same thing with the `-p` command-line option, which enables
    the automatic printing of the `$_` variable and modifies it in-place:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or you can apply the `\U` escape sequence to string interpolation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This one-liner uppercases everything that follows it (or everything up to the
    first occurrence of `\E`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 6.9 Convert all text to lowercase
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This one-liner is similar to the previous one. The `lc` function converts the
    contents of `$_` to lowercase.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also use the escape sequence `\L` and string interpolation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `\L` lowercases everything after it (or until the first instance of `\E`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 6.10 Uppercase only the first letter of each line
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This one-liner first lowercases the input with the `lc` function and then uses
    `ucfirst` to uppercase only the first character. For example, if you pass it a
    line that says *foo bar baz*, it produces the text *Foo bar baz*. Similarly, if
    you pass it a line *FOO BAR BAZ*, it lowercases the line first and then uppercases
    the first letter, producing *Foo bar baz* again.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do the same thing using escape codes and string interpolation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First `\L` lowercases the whole line and then `\u` uppercases the first character.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 6.11 Invert the letter case
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This one-liner changes the case of the letters: The capital letters become
    lowercase letters, and the lowercase letters become capital letters. For example,
    the text *Cows are COOL* becomes *cOWS ARE cool*. The transliteration operator
    `y` (explained in one-liner 6.1 on page 59) creates a mapping from capital letters
    `A-Z` to lowercase letters `a-z` and a mapping from lowercase letters `a-z` to
    capital letters `A-Z`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 6.12 Title-case each line
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This one-liner attempts to title-case a string, meaning the first letter of
    each word is uppercased; for example, *This Text Is Written In Title Case*. This
    one-liner works by matching every word with `\w+` and replacing the matched word
    with `\u$1`, which uppercases the first letter of the word.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 6.13 Strip leading whitespace (spaces, tabs) from the beginning of each line
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This one-liner deletes all whitespace from the beginning of every line with
    the help of the substitution operator `s`. Given `s/regex/replace/`, it replaces
    the matched `regex` with the `replace` string. In this case, the `regex` is `^[
    \t]+`, which means “match one or more spaces or tabs at the beginning of the string,”
    and `replace` is empty, meaning “replace the matched part with an empty string.”
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The regular expression class `[ \t]` can also be replaced by `\s+` to match
    any whitespace (including tabs and spaces):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 6.14 Strip trailing whitespace (spaces, tabs) from the end of each line
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This one-liner deletes all whitespace from the end of each line. The `regex`
    of the `s` operator says “match one or more spaces or tabs at the end of the string.”
    The `replace` part is empty again, which means “erase the matched whitespace.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also achieve the same by writing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, you replace with `[ \t]+$` with `\s+`, as in one-liner 6.13.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 6.15 Strip whitespace (spaces, tabs) from the beginning and end of each line
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This one-liner combines one-liners 6.13 and 6.14\. It specifies the global `/g`
    flag to the `s` operator because you want it to delete whitespace at the beginning
    *and* the end of the string. If you don’t specify this, it deletes whitespace
    only at the beginning (if there is whitespace) or only at the end (if there was
    no whitespace at the beginning).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also replace `[ \t]+$` with `\s+` and get the same results:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Writing `\s+` is shorter than writing `[ \t]+`. And `s` stands for space, which
    makes it easier to remember.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 6.16 Convert UNIX newlines to DOS/Windows newlines
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This one-liner substitutes the UNIX newline character `\012` (`LF`) for the
    Windows/DOS newline character `\015\012` (`CRLF`) on each line. One nice feature
    of `s/regex/replace/` is that it can take characters other than forward slashes
    as delimiters. Here, it uses vertical pipes to delimit `regex` from `replace`
    to improve readability.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Newlines are usually represented as `\n` and carriage returns as `\r`, but
    across platforms, the meanings of the `\n` and `\r` sequences can vary. The UNIX
    newline character, however, is always available as `\012` (`LF`), and the carriage-return
    character represented by `\r` is always available as `\015` (`CR`). That’s why
    you use those numeric codes: Sometimes using the flexible sequence is preferable,
    but not here.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 6.17 Convert DOS/Windows newlines to UNIX newlines
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This one-liner works in the opposite direction from one-liner 6.16\. It takes
    Windows newlines (`CRLF`) and converts them to UNIX newlines (`LF`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 6.18 Convert UNIX newlines to Mac newlines
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Mac OS previously used `\015` (`CR`) as newlines. This one-liner converts UNIX’s
    `\012` (`LF`) to Mac OS’s `\015` (`CR`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 6.19 Substitute (find and replace) “foo” with “bar” on each line
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This one-liner uses the `s/regex/replace/` command to substitute the first occurrence
    of `foo` with `bar` on each line.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace all `foo`s with `bar`s, add the global `/g` flag:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 6.20 Substitute (find and replace) “foo” with “bar” on lines that match “baz”
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This one-liner is roughly equivalent to
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This expanded code puts each line into the variable `$line` and then checks
    to see if a line in that variable matches `baz`. If so, it replaces `foo` with
    `bar` in that line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: You could also write
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 6.21 Print paragraphs in reverse order
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This one-liner uses the `-00` argument discussed in one-liner 2.7 (page 14)
    to turn paragraph slurp mode on, meaning that Perl reads text paragraph by paragraph,
    rather than line by line. Next, it uses the `<>` operator to make Perl read the
    input from either standard input or files specified as arguments. Here, I’ve specified
    `file` as the argument so Perl will read `file` paragraph by paragraph (thanks
    to `-00`). Once Perl finishes reading the file, it returns all paragraphs as a
    list and calls `reverse` to reverse the order of the paragraph list. Finally,
    `print` prints the list of reversed paragraphs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 6.22 Print all lines in reverse order
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This one-liner evaluates the `reverse` operator in the scalar context. In the
    previous one-liner, you saw that evaluating `reverse` in the list context reverses
    the whole list, that is, the order of the elements. To do the same for scalar
    values such as `$_` that contain the whole line, you have to call `reverse` in
    the scalar context. Otherwise, it simply reverses a list with only one element,
    which is the same list! Once you’ve done that, you simply print the reversed line.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Often you can drop the `$_` variable when using operators and Perl will still
    apply the function on the `$_` variable. In other words, you can rewrite the same
    one-liner as
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or you can substitute `-n` for `-p`, modify the `$_` variable, and set its
    value to reverse:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can also write this as
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, `$_` is dropped because most Perl operators default to `$_` when not given
    an argument.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 6.23 Print columns in reverse order
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This one-liner reverses the order of columns in a file. The `-a` command-line
    argument splits each line into columns at spaces and puts them in the `@F` array,
    which is then reversed and printed. This one-liner is similar to one-liner 4.4
    on page 32; I explained the `@{[ ... ]}` construct there. It simply lets you run
    code inside of double quotes. For example, given the following input file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'the one-liner reverses the order of the columns, and the output is the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the columns in your input are separated by any character other than a space,
    you can use the `-F` command-line argument to set a different delimiter. For example,
    given the following input file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'you can add the `-F:` command-line argument to the one-liner like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样在单行命令中添加`-F:`命令行参数：
- en: '[PRE45]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'and it produces this output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它会产生如下输出：
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice, however, that the `:` characters are missing in this output. To get
    them back, you need to modify the one-liner a bit and set the `$"` variable to
    `":"`, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而请注意，输出中缺少了`:`字符。要恢复它们，你需要稍微修改单行命令，并将`$"`变量设置为`":"`，如下所示：
- en: '[PRE47]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This produces the expected output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生预期的输出：
- en: '[PRE48]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `$"` variable changes the character that’s printed between array elements
    when an array is interpolated within a double-quoted string.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`$"`变量会改变在数组元素间插入的字符，当数组被插入到双引号字符串中时就是这样。'
