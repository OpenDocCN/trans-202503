<html><head></head><body>
<section><header>
<h1 class="Appendix"><span class="AppendixNumber"><span epub:type="pagebreak" title="269" id="Page_269"/>C</span><br/>
<span class="AppendixTitle">Exercises</span></h1>
</header>
<blockquote class="Epigraph" epub:type="epigraph">
<p class="Epigraph">Exploration is the engine that drives innovation. </p>
<p class="EpigraphSource">—Edith Widder</p>
</blockquote>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This appendix contains some ideas for further exploration, open questions, and challenges for readers who want to go beyond the material covered in this book. </p>
<p class="ListHead"><b>Chapter 1: Foundations</b></p>
<ul>
<li>The book focuses on information security in conventional computer systems, but appliances and devices also run on software, and these are increasingly connected to the internet. How do we extend principles such as C-I-A to secure software that interacts with the physical world?</li>
</ul>
<p class="ListHead"><b>Chapter 2: Threats</b></p>
<ul>
<li>Threat model an existing software design, or just one component of a large system.</li>
<li>For fun, threat model a favorite movie or scene from a book where adversaries battle over a prized asset.</li>
</ul>
<p class="ListHead"><b><span epub:type="pagebreak" title="270" id="Page_270"/>Chapter 3: Mitigations</b></p>
<ul>
<li>Write helper functions to limit the exposure of sensitive data in memory as described in “Minimize Data Exposure” on <span class="xref" itemid="xref_target_page 47">page 47</span>.</li>
<li>Intentionally code a Confused Deputy and try to exploit it, or challenge a colleague to do so. Fix the vulnerability and confirm that the code is secure.</li>
<li>Design a library to enforce an extensible access policy for an existing data access API. </li>
</ul>
<p class="ListHead"><b>Chapter 4: Patterns</b></p>
<ul>
<li>Take an existing design, or undertake a new one, and see how many of the chapter’s patterns you can use to make it as secure as possible.</li>
<li>What additional security patterns and anti-patterns can you think of? Keep a running list, adding to the ones presented in the chapter, and share them with colleagues.</li>
<li>Are allowlists always better than blocklists? Think of an exception, or explain why none exist.</li>
</ul>
<p class="ListHead"><b>Chapter 5: Cryptography</b></p>
<ul>
<li>An easy way to play around with real crypto tools is with the OpenSSL command line (<a href="https://wiki.openssl.org/index.php/Main_Page" class="LinkURL">https://wiki.openssl.org/index.php/Main_Page</a>). You can use it to experiment with symmetric and asymmetric crypto, as well as MACs (called <em>digests</em> in <code>openssl(1)</code>), or even create and check your own certificates. </li>
<li>Find a high-quality crypto library and try using it to implement the basic operations described in the chapter. How was the API in terms of ease of use, and how confident are you that your implementation is secure?</li>
<li>If the previous exercise proved difficult, how could you redesign the API to be easier to use, as well as more foolproof?</li>
<li>Code the crypto API improvements you thought of, or wrap the original library to provide a better API.</li>
</ul>
<p class="ListHead"><b>Chapter 6: Secure Design</b></p>
<ul>
<li>Explore Google’s design document writing guidance (<a href="https://www.industrialempathy.com/posts/design-docs-at-google/" class="LinkURL">https://www.industrialempathy.com/posts/design-docs-at-google/</a>). </li>
<li>If you haven’t written a software design document before, try it out the next time you get an opportunity to do so (making it as informal and high level as you like). </li>
<li>If you work on a codebase that has no written design document, retroactively create one. For large systems, create designs for one component at a time, focusing on whatever components are most important to security or otherwise of interest. </li>
</ul>
<p class="ListHead"><b><span epub:type="pagebreak" title="271" id="Page_271"/>Chapter 7: Security Design Reviews</b></p>
<ul>
<li>Find existing designs and review them as a learning exercise. Don’t just look for vulnerabilities; create a broad assessment of both strengths and weaknesses, including places where security matters most, ways the design enhances security, mitigation alternatives, and ways in which security could be improved or made more usable.</li>
<li>Share and discuss your findings from the preceding exercise with colleagues. </li>
</ul>
<p class="ListHead"><b>Chapter 8: Secure Programming</b></p>
<ul>
<li>To get a feel for realistic examples of security vulnerabilities, look for security bugs that have already been found and fixed in your codebase or in open source software projects. I suggest focusing on open source projects because vulnerabilities are usually described in detail and you can see the code. The US Department of Homeland Security sponsors a large database of publicly known vulnerabilities (<a href="https://cve.mitre.org/" class="LinkURL">https://cve.mitre.org/</a>). The Chromium bug database is another good source of public vulnerabilities (<a href="https://bugs.chromium.org/p/chromium/issues/list/" class="LinkURL">https://bugs.chromium.org/p/chromium/issues/list/</a>). A good starting point is to filter these databases for fixed security bugs so you can see the actual code changes. </li>
<li><em>Underhanded coding</em>, also known as <em>obfuscated coding</em>, is the fine art of using footguns and other trickery to write code that works differently from what a casual inspection of the code would indicate. Underhanded coding contests challenge programmers to show off their creativity in pushing programming languages to their limits. But the same techniques used to camouflage malicious code as benign can also, if stumbled upon inadvertently, become footguns. Check out these sites for a start, or try to craft your own: <a href="http://www.underhanded-c.org/" class="LinkURL">http://www.underhanded-c.org/</a> and <a href="https://underhandedcrypto.com/" class="LinkURL">https://underhandedcrypto.com/</a>.</li>
</ul>
<p class="ListHead"><b>Chapter 9: Low-Level Coding Flaws</b></p>
<ul>
<li>Why don’t languages that provide fixed-width integer types provide any mechanism to detect overflow? Would it help? If so, how would you extend the C language to take advantage of it?</li>
<li>Explore how analysis tools such as Valgrind detect issues with memory management (<a href="https://valgrind.org/docs/manual/mc-manual.html" class="LinkURL">https://valgrind.org/docs/manual/mc-manual.html</a>).</li>
<li>Write a little program that includes a few kinds of memory management vulnerabilities, such as both read and write buffer overflows. Use a tool like Valgrind to see if it detects the bugs. Try varying the code to make it harder for the tool to analyze, and see if you can sneak a bug past it.</li>
</ul>
<p class="ListHead"><b>Chapter 10: Untrusted Input</b></p>
<ul>
<li>Identify the untrusted inputs on the main attack surface of the system you work on and see how thoroughly input validation is implemented and tested.</li>
<li><span epub:type="pagebreak" title="272" id="Page_272"/>If you find that untrusted inputs may represent vulnerabilities, implement input validation.</li>
<li>Often, input validation for a system is repetitive. Look for opportunities to use common code or helper functions to handle it reliably. Consider ways of baking input validation into frameworks so it cannot be accidentally forgotten.</li>
</ul>
<p class="ListHead"><b>Chapter 11: Web Security</b></p>
<ul>
<li>Write security requirements for a component that creates and authenticates a web session. Design and threat model it, and find a friend to security review it.</li>
<li>Build an implementation of your web session into a simple web app. Try to impersonate another session, or steal the necessary session state. Better yet, find a friend to “attack” your implementation. </li>
<li>Add a CSRF protection mechanism to the component and test it in your web app.</li>
<li>Explore ways of securing web sessions without the use of cookies as an experiment to understand the essence of the security challenge.</li>
<li>Find the source code (and ideally, a written design document) for a web framework and learn how it implements sessions, prevents XSS and CSRF vulnerabilities, and ensures that HTTPS secures all web interactions. By threat modeling or other means, can you find any vulnerabilities? If you want to try attacking it, put up your own test server to do that.</li>
</ul>
<p class="ListHead"><b>Chapter 12: Security Testing</b></p>
<ul>
<li>In the codebase of your choice, locate some area where security is important and look for additional security test cases that should be added. Write and contribute new security test cases.</li>
<li>Consider this alternative example of a vulnerability in GotoFail that the security tests we wrote wouldn’t catch—in place of the extra <code>goto fail;</code>, instead insert the line: 
<pre><code>if (expected_hash[0] == 0x23) goto fail;</code></pre></li>
<li>This sort of technique might be used to secretly include a vulnerability that requires a specific trigger as a kind of backdoor. Detecting this would require a test case with an expected hash whose first byte was 0x23. Can you write tests to detect this sort of vulnerability without knowing the specifics?</li>
<li>Check out an old version of an open source software project with a known vulnerability. Run the test suite and ensure that all tests pass. Write a security regression test to confirm the vulnerability. Sync up to the next version that fixes the vulnerability, merging in your regression test. Your security regression test should now pass; if not, fix it. Then, check for additional, related vulnerabilities in the latest version.</li>
</ul>
<p class="ListHead"><b><span epub:type="pagebreak" title="273" id="Page_273"/>Chapter 13: Secure Development Best Practices</b></p>
<ul>
<li>Explore easy ways to make incremental code quality improvements, such as using lint or code scanning tools, as well as checking the test coverage of error and exception handling.</li>
<li>See how well the security aspects of your codebase are documented and make needed improvements.</li>
<li>Whenever you do code reviews, put on your security hat for another pass when appropriate.</li>
<li>Consider security when you do bug triage, or perhaps browse your bug database with security in mind to see if bugs that have security implications are being punted.</li>
</ul>
<p class="ListHead"><b>Afterword</b></p>
<ul>
<li>Look for opportunities to make improvements along the lines mentioned in the conclusion, even if this means taking small steps: broader security participation, earlier integration of a security perspective and strategy, reduction or management of complexity, improvement in transparency about security practice, and so on.</li>
<li>Identify a unique security challenge and design and develop a reusable component that addresses it.</li>
<li>Pursue other ideas of your own to raise the security bar and spread the word.</li>
</ul>
</section>
</body></html>