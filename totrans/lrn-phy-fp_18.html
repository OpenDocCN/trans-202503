<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_279"/><span class="big">16</span><br/>MECHANICS IN THREE DIMENSIONS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">To predict the motion of a projectile, a satellite, or any object that can move unconstrained through three-dimensional space, we need to use three-dimensional vectors to describe velocity, acceleration, and force. In this chapter, we’ll merge the three-dimensional vectors we described in <a href="ch10.xhtml">Chapter 10</a> with the state-based solution techniques of <a href="ch15.xhtml">Chapter 15</a>.</p>&#13;
<p class="indent">Describing the state of an object or particle remains central to our task of predicting its future motion. We’ll develop an appropriate set of state variables for a particle in three dimensions and define a new type called <span class="literal">ParticleState</span> to hold them.</p>&#13;
<p class="indent">Acknowledging the dependence that forces have on state variables, we assign the name <em>one-body force</em> to a function that returns a force vector when presented with a particle state. We give multiple examples of one-body forces, such as Earth’s surface gravity and air resistance.</p>&#13;
<p class="indent">Solving a mechanics problem is a process of transforming information through a sequence of representations, beginning with a list of one-body forces, then a differential equation, then a state-update function, and finally <span epub:type="pagebreak" id="page_280"/>a list of states. Newton’s second law appears as the transformation from forces to differential equation. A numerical method transforms a differential equation into a state-update function. Iteration of the state-update function from an initial state produces a list of states.</p>&#13;
<p class="indent">This chapter explores the foundational ideas and code that allow us to predict motion by transforming information through a sequence of representations. Let’s start with some introductory code.</p>&#13;
<h3 class="h3" id="ch16lev1">Introductory Code</h3>&#13;
<p class="noindent">In this chapter and the next two, we’ll create a module that contains ideas for setting up and solving Newton’s second law in three dimensions. Before we start adding type signatures and function definitions, there’s some code we need to have at the top of our source code file. This introductory code consists of four parts: a request for warnings, a request to use a language option, a name for the module, and a collection of types and functions we wish to import from other modules.</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
{-# LANGUAGE MultiParamTypeClasses #-}&#13;
&#13;
module Mechanics3D where&#13;
&#13;
import SimpleVec&#13;
    ( R, Vec, PosVec, (^+^), (^-^), (*^), (^*), (^/), (&lt;.&gt;), (&gt;&lt;)&#13;
    , vec, sumV, magnitude, zeroV, xComp, yComp, zComp, iHat, jHat, kHat)&#13;
import Mechanics1D&#13;
    ( RealVectorSpace(..), Diff(..), NumericalMethod&#13;
    , Time, TimeStep, rungeKutta4, solver )&#13;
import SpatialMath&#13;
    ( V3(..), Euler(..) )&#13;
import Graphics.Gnuplot.Simple&#13;
    ( Attribute(..), Aspect(..), plotFunc, plotPaths )&#13;
import qualified Graphics.Gloss as G&#13;
import qualified Vis as V</pre>&#13;
<p class="indent">As usual, we begin by turning on warnings. We then turn on the language option that allows multi-parameter type classes, just as we did in the last chapter. We give this module the name <span class="literal">Mechanics3D</span>, which is how we will refer to it when we use any of the types or functions we define in this module in stand-alone programs or in other modules we write in later chapters. The remainder of the code consists of import statements, indicating that we wish to use types, type classes, and functions defined in modules that other people have written, or those defined in modules that we wrote in previous chapters.</p>&#13;
<p class="indent">In particular, we import vector operations from the <span class="literal">SimpleVec</span> module we wrote in <a href="ch10.xhtml">Chapter 10</a> and some differential equation solving types, type <span epub:type="pagebreak" id="page_281"/>classes, and functions from the <span class="literal">Mechanics1D</span> module we wrote in <a href="ch15.xhtml">Chapter 15</a>. We’ve listed the name of each piece we’re importing from the <span class="literal">SimpleVec</span> and <span class="literal">Mechanics1D</span> modules, as opposed to simply importing the module as a whole. This is my preferred style because it shows where each of the names we use in the module comes from. If you want to import all of the names, you can write a one-line import statement composed of the keyword <span class="literal">import</span> followed by the module name, as we did in <a href="ch15.xhtml">Chapter 15</a>. If you import all of the names from many different modules, one of the names that you use may be defined in multiple modules, causing the compiler to complain. You will then need to clarify which module you want the name imported from.</p>&#13;
<p class="indent">The parenthetical with two dots, <span class="literal">(..)</span>, after a data type like <span class="literal">Attribute</span> means we want to import the data type and all of its constructors. If we omit the two dots, we will only import the name of the data type. Two dots after a type class, such as <span class="literal">RealVectorSpace</span>, mean we want to import the functions owned by the type class in addition to the name of the type class itself.</p>&#13;
<p class="indent">Lastly, we have the qualified import of the <span class="literal">Graphics.Gloss</span> and <span class="literal">Vis</span> modules. The first qualified import statement assigns the short name <span class="literal">G</span> to the <span class="literal">Graphics.Gloss</span> module, allowing us to access any type or function provided by <span class="literal">Graphics.Gloss</span> as long as it’s prefixed by the short name <span class="literal">G</span> and a dot. The <span class="literal">Picture</span> type from the <span class="literal">Graphics.Gloss</span> module, for example, must be referred to as <span class="literal">G.Picture</span>. One reason I chose the qualified import method for the <span class="literal">Graphics.Gloss</span> and <span class="literal">Vis</span> modules is that they define several identical names, such as <span class="literal">simulate</span>. I want to use both definitions of <span class="literal">simulate</span> in the code I write, and I need a way of telling the compiler which definition I mean in each use.</p>&#13;
<p class="indent">Having completed our introductory code, let’s look at Newton’s second law in three dimensions.</p>&#13;
<h3 class="h3" id="ch16lev2">Newton’s Second Law in Three Dimensions</h3>&#13;
<p class="noindent">Equation 14.1 gave Newton’s second law in one dimension. In three dimensions, position, velocity, acceleration, and force are described by vectors rather than numbers. In three dimensions, the net force on an object is the vector sum of the forces acting on that object:</p>&#13;
<div class="imagec"><img src="Images/281equ01.jpg" alt="Image" width="538" height="51"/></div>&#13;
<p class="indent">Here is Newton’s second law in three dimensions as a differential equation:</p>&#13;
<div class="imagec"><img src="Images/281equ02.jpg" alt="Image" width="463" height="25"/></div>&#13;
<p class="indent"><a href="ch16.xhtml#ch16fig1">Figure 16-1</a> shows a schematic diagram for Newton’s second law in three dimensions. Since acceleration, velocity, and position are being treated as vectors now, two of the integrators have vector inputs, vector outputs, and vector state.</p>&#13;
<div class="imagel" id="ch16fig1"><img src="Images/282fig01.jpg" alt="Image" width="601" height="486"/></div>&#13;
<p class="figcap"><em>Figure 16-1: Schematic representation of Newton’s second law</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_282"/>Here the forces depend on time, position, and velocity. Acceleration depends on net force. Velocity is the integration of acceleration, and position is the integration of velocity. The type below each integrator indicates the type of quantity that the integrator holds as state. The integrator that outputs time holds a real number as state. The integrator that outputs position holds a vector as state. The integrator that outputs velocity also holds a vector as state.</p>&#13;
<p class="indent">The two integrators in loops in the diagram hold velocity and position as state, so at a minimum, we need velocity and position to be state variables. We included time as a state variable for convenience in <a href="ch14.xhtml">Chapters 14</a> and <a href="ch15.xhtml">15</a>, and we will continue to do so here. Writing Newton’s second law as a set of coupled first-order differential equations gives the following equations:</p>&#13;
<div class="imagec"><img src="Images/282equ01.jpg" alt="Image" width="477" height="161"/></div>&#13;
<p class="indent">Equations 16.3, 16.4, and 16.5 contain information equivalent to the diagram in <a href="ch16.xhtml#ch16fig1">Figure 16-1</a>.</p>&#13;
<p class="indent">Having introduced Newton’s second law in three dimensions, let’s now turn to the question of how we will describe the state of a particle in three dimensions.</p>&#13;
<h3 class="h3" id="ch16lev3"><span epub:type="pagebreak" id="page_283"/>The State of One Particle</h3>&#13;
<p class="noindent">The state of a particle plays five roles. First, the state specifies the information necessary for prediction; it’s the current information about the system that allows future prediction without historical information about the system (information from the past). Second, the state gives a template for the first-order differential Equations 16.3, 16.4, and 16.5 that form the starting point for our numerical approximation methods; each first-order differential equation expresses the time rate of change of one of the state variables in terms of the state variables themselves. Third, the state describes the information that needs to be updated by a state-update function. Fourth, the state encompasses the information that the forces depend on. Finally, knowing the state at all times counts as a solution to a Newton’s second law problem because anything we want to know about a particle is some function of its state.</p>&#13;
<p class="indent">Since the forces that act on a particle can depend on the particle’s mass (such as the force of gravity) or charge (such as the Lorentz force law, which we’ll discuss later in the chapter), it’s convenient to include mass and charge in the state. However, its certainly not necessary; mass and charge remain constant throughout most physical situations, so we could treat them as global values independent of state. But including mass and charge as state variables will simplify some of our code and allow some forces to be expressed as functions of state only instead of as functions of state and one or more parameters.</p>&#13;
<p class="indent">The definition of the <span class="literal">ParticleState</span> data type we’ll use for the state of one particle includes mass, charge, time, position, and velocity as state variables.</p>&#13;
<pre>data ParticleState = ParticleState { mass     :: R&#13;
                                   , charge   :: R&#13;
                                   , time     :: R&#13;
                                   , posVec   :: Vec&#13;
                                   , velocity :: Vec }&#13;
                     deriving Show</pre>&#13;
<p class="indent">We use record syntax to give each field of the new data type its own extraction function (<span class="literal">mass</span>, <span class="literal">charge</span>, and so on). An extraction function is also called an eliminator or selector. We decided to make a new data type (using the <span class="literal">data</span> keyword) rather than a type synonym so that this type has no chance of being confused with any other type. We want to be able to display values of this data type, so we want <span class="literal">ParticleState</span> to be an instance of type class <span class="literal">Show</span>. By including <span class="literal">deriving Show</span>, we ask that the compiler automatically figure out how to make a <span class="literal">Show</span> instance.</p>&#13;
<p class="indent">For convenience, let’s define a default <span class="literal">ParticleState</span>, which can be used to make new particle states.</p>&#13;
<pre>defaultParticleState :: ParticleState&#13;
defaultParticleState = ParticleState { mass     = 1&#13;
                                     , charge   = 0&#13;
                                     , time     = 0&#13;
                                     , posVec   = zeroV&#13;
                                    , velocity  = zeroV }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_284"/>The <span class="literal">defaultParticleState</span> allows us to define a particle state without needing to explicitly provide all five pieces of information. For example, to specify the state of a 2-kg rock with no net charge, at the origin, moving with velocity <img class="inline" src="Images/e0284-01.jpg" alt="Image" width="72" height="25"/> m/s, we can write the following:</p>&#13;
<pre>rockState :: ParticleState&#13;
rockState&#13;
    = defaultParticleState { mass    = 2                         -- kg&#13;
                           , velocity = 3 *^ iHat ^+^ 4 *^ kHat  -- m/s&#13;
                           }</pre>&#13;
<p class="indent">Because we have the default state, we don’t need to explicitly give state variables that are the same as those of the default, such as charge, time, and position. Recall that the operator <span class="literal">*^</span> is used to scale a vector on the right by a number on the left.</p>&#13;
<p class="indent">Newton’s second law is a recipe for constructing a differential equation from a list of force functions. Throughout <a href="ch14.xhtml">Chapters 14</a> and <a href="ch15.xhtml">15</a>, we saw the usefulness of force functions in which the force depends on the state of the particle. We’ll define a <em>one-body force</em> to be a force that depends on the current particle state as expressed by <span class="literal">ParticleState</span>; in other words, a force that could depend on time or the particle’s position, velocity, mass, or charge.</p>&#13;
<pre>type OneBodyForce = ParticleState -&gt; Vec</pre>&#13;
<p class="indent">We’ll see in the following section that many common forces in mechanics are naturally expressed as one-body forces.</p>&#13;
<p class="indent">The code we write below for Newton’s second law will produce a differential equation. In other words, it will produce a function that gives the time derivatives of state variables when presented with the state variables themselves. How should we return these time derivatives of state variables? Since the state variables are bundled together into an object with type <span class="literal">ParticleState</span>, we will similarly bundle together the time derivatives into an object with type <span class="literal">DParticleState</span>. Here is our definition of the new data type <span class="literal">DParticleState</span>:</p>&#13;
<pre>data DParticleState = DParticleState { dmdt :: R&#13;
                                     , dqdt :: R&#13;
                                     , dtdt :: R&#13;
                                     , drdt :: Vec&#13;
                                     , dvdt :: Vec }&#13;
                      deriving Show</pre>&#13;
<p class="indent">As there are five quantities contained in the particle state, so there are five quantities in the state derivative. The real number whose extraction function is <span class="literal">dmdt</span> (named after the derivative <em>dm</em>/<em>dt</em>) holds the rate at which mass changes. Mass will not change in any of our examples, so this rate will be zero, but the ability to have mass change is useful in some situations, such <span epub:type="pagebreak" id="page_285"/>as rocket motion (in which a rocket expends fuel). Each of the other extraction functions has a name designed to indicate that the quantity represents the rate of change of a state variable. The names <span class="literal">dqdt</span> and <span class="literal">dtdt</span> label the real numbers for the rates at which charge and time change with time, respectively. The rate at which time changes with time is 1, so it’s a little silly to keep track of this rate. An alternative is to write a data type that omits this quantity; I have chosen a data type whose structure parallels that of the state, even if some slots hold information that seems obvious. The names <span class="literal">drdt</span> and <span class="literal">dvdt</span> label the rates at which position and velocity change. These quantities are vectors, as the data type definition shows.</p>&#13;
<p class="indent">The function <span class="literal">newtonSecondPS</span> below is the Haskell representation of Newton’s second law, which is equivalent to differential Equations 16.3, 16.4, and 16.5.</p>&#13;
<pre>newtonSecondPS :: [OneBodyForce]&#13;
               -&gt; ParticleState -&gt; DParticleState  -- a differential equation&#13;
newtonSecondPS fs st&#13;
    = let fNet = sumV [f st | f &lt;- fs]&#13;
          m = mass st&#13;
          v = velocity st&#13;
          acc = fNet ^/ m&#13;
      in DParticleState { dmdt = 0    -- dm/dt&#13;
                        , dqdt = 0    -- dq/dt&#13;
                        , dtdt = 1    -- dt/dt&#13;
                        , drdt = v    -- dr/dt&#13;
                        , dvdt = acc  -- dv/dt&#13;
                        }</pre>&#13;
<p class="indent">The function <span class="literal">newtonSecondPS</span> is a recipe for converting a list of one-body forces into a differential equation. The PS in the name indicates that the function works with the <span class="literal">ParticleState</span> data type. The differential equation produced by <span class="literal">newtonSecondPS</span> expresses the time rate of change of each of the state variables in terms of the state variables themselves. Given values for each of the five state variables, the function <span class="literal">newtonSecondPS</span> returns values for the time rate of change of each of these five.</p>&#13;
<p class="indent">The function <span class="literal">newtonSecondPS</span> consists of a <span class="literal">let</span> expression, in which we first find the <span class="literal">Vec</span> representing the net force on the particle in the current state, name it <span class="literal">fNet</span>, then name the mass and velocity of the particle <span class="literal">m</span> and <span class="literal">v</span>, respectively, and finally compute the acceleration of the particle by dividing the net force by the mass. The body of the <span class="literal">let</span> expression returns a state derivative with type <span class="literal">DParticleState</span>. The derivatives of mass and charge with respect to time are 0 because mass and charge do not change. The derivative of time with respect to time is 1. Finally, the derivative of position is the velocity in the current state, and the derivative of velocity is the acceleration calculated in the <span class="literal">let</span> expression.</p>&#13;
<p class="indent">We regard the function <span class="literal">newtonSecondPS fs</span>, where <span class="literal">fs</span> is the list of one-body forces that describes the physical situation, as the Haskell version of the differential equation that expresses Newton’s second law. The schematic <span epub:type="pagebreak" id="page_286"/>diagram in <a href="ch16.xhtml#ch16fig1">Figure 16-1</a>, the differential Equations 16.3, 16.4, and 16.5, and the Haskell function <span class="literal">newtonSecondPS</span> are different ways of expressing Newton’s second law for a single object in three dimensions.</p>&#13;
<h3 class="h3" id="ch16lev4">Solving Newton’s Second Law</h3>&#13;
<p class="noindent">Our strategy for constructing and solving Newton’s second law for one particle consists of transforming information about the physical situation through a sequence of four different forms:</p>&#13;
<ol>&#13;
<li class="noindent">One-body forces</li>&#13;
<li class="noindent">Differential equation</li>&#13;
<li class="noindent">State-update function</li>&#13;
<li class="noindent">List of states</li>&#13;
</ol>&#13;
<p class="indent"><a href="ch16.xhtml#ch16fig2">Figure 16-2</a> shows a functional diagram of the data representations, shown as vertical arrows, and the functions that transform the data from one representation to another, shown as boxes.</p>&#13;
<div class="imagel" id="ch16fig2"><img src="Images/286fig01.jpg" alt="Image" width="591" height="473"/></div>&#13;
<p class="figcap"><em>Figure 16-2: Data flow for solving a one-particle mechanics problem</em></p>&#13;
<p class="indent">A list of one-body forces is the first in a sequence of four information representations we use to describe a physical situation, each getting closer to a solution. The list of one-body forces characterizes the physical setting or situation in which a particle finds itself, serving as an algebraic analogue to the visual and geometric free-body diagrams that introductory physics classes use to show all of the forces acting on an object.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_287"/>Newton’s second law provides the means to transform the one-body forces into a differential equation, our second information representation. The function <span class="literal">newtonSecondPS</span> expresses Newton’s second law as it applies to the <span class="literal">ParticleState</span> data type. The Haskell representation of a differential equation is a function <span class="literal">ParticleState -&gt; DParticleState</span> that gives the time rates of change of the state variables in terms of the state variables themselves.</p>&#13;
<p class="indent">A state-update function is our third information representation; it describes how to take a small step forward in time, producing a new state from an old state. The two-and three-dimensional animation tools we use take a state-update function as input; inasmuch as an animated visualization of a particle’s motion counts as a solution to a mechanics problem, the state-update function at the heart of that animation can also be regarded as a solution. To obtain a state-update function from a differential equation, we need a numerical method. By using a numerical method, we admit that we’re looking only for an approximate solution to our mechanics problem rather than an exact solution as can sometimes be found by working with a differential equation analytically. We have a choice of numerical methods; <span class="literal">euler 0.01</span>, <span class="literal">eulerCromerPS 0.1</span>, and <span class="literal">rungeKutta4 0.1</span> will be examples of numerical methods that can be used to produce a state-update function. We’ll write the function <span class="literal">eulerCromerPS</span> later in this chapter, and we’ll also show how to make use of the general-purpose functions <span class="literal">euler</span> and <span class="literal">rungeKutta4</span> that we wrote in the last chapter. Having chosen a numerical method, we apply it to the differential equation to obtain a state-update function.</p>&#13;
<p class="indent">The fourth information representation we use is a list of states. The list gives the state of the particle at each time calculated by the numerical method; in other words, each list element is the state at a particular time that is one time step advanced from that of the previous list element. This is pretty much all the information we could hope to know about the particle. From it, we can graph any state variable as a function of time or some other state variable.</p>&#13;
<p class="indent">Other quantities we might care about, but that are not contained in the state, such as energy or momentum, are functions of the state variables. If we wish, we can write a higher-order function that produces a position function or a velocity function for the particle from the information contained in the list of states. To obtain the list of states from the state-update function, we simply iterate the state-update function using the Prelude function <span class="literal">iterate</span>, which applies the state-update function to a given initial state and then to the updated state over and over again to make a list.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16fig2">Figure 16-2</a> should be regarded as an overview of the process of solving a one-particle mechanics problem in three dimensions. The figure is similar to <a href="ch15.xhtml#ch15fig2">Figure 15-2</a>; the two main differences are (1) we’re using the new <span class="literal">ParticleState</span> data type, which contains mass, and (2) the new figure allows a choice of numerical method where the previous figure insisted on the Euler method.</p>&#13;
<p class="indent">In summary, the broad outline of our process is to translate our problem (given by one-body forces) into something mathematical (a differential equation), solve the mathematics problem (by using a numerical method to <span epub:type="pagebreak" id="page_288"/>produce a state-update function and iterating to produce a list of states), and then return to physics to interpret the results.</p>&#13;
<p class="indent">Having given an overview of the process we’ll employ to solve Newton’s second law, which begins with a list of one-body forces, let’s take a look at some examples of one-body forces.</p>&#13;
<h3 class="h3" id="ch16lev5">One-Body Forces</h3>&#13;
<p class="noindent">We introduced the definition of a one-body force earlier in this chapter, but we did not give any examples. Many of the common forces that we may want to include in Newton’s second law are naturally expressed as one-body forces.</p>&#13;
<h4 class="h4" id="ch16lev6">Earth Surface Gravity</h4>&#13;
<p class="noindent">An object near Earth’s surface feels a gravitational force from the earth. (This is theory 2 from the list of gravity theories on <a href="ch10.xhtml#ch10lev19">page 148</a>.) If <strong>g</strong> is the acceleration of gravity that points toward the center of the earth, the gravitational force exerted by Earth on a particle or object with mass <em>m</em> that is near Earth’s surface is</p>&#13;
<div class="equationc"><strong>F</strong><sub><em>g</em></sub> = <em>m</em><strong>g</strong></div>&#13;
<p class="indent">If we agree to let the z-direction of our coordinate system point away from Earth’s center, and to use SI units, then a one-body force for Earth surface gravity can be written as follows:</p>&#13;
<pre>-- z direction is toward the sky&#13;
-- assumes SI units&#13;
earthSurfaceGravity :: OneBodyForce&#13;
earthSurfaceGravity st&#13;
    = let g = 9.80665  -- m/s^2&#13;
      in (-mass st * g) *^ kHat</pre>&#13;
<p class="indent">Recall that a one-body force is a function from particle state to force vector. The local variable <span class="literal">st</span> holds the particle state, and <span class="literal">mass st</span> extracts the mass from the particle state using the extraction function <span class="literal">mass</span> that is automatically generated because we used record syntax when we defined <span class="literal">ParticleState</span>.</p>&#13;
<p class="indent">If Earth’s surface gravity is a force that acts on our particle, all we need to do is include <span class="literal">earthSurfaceGravity</span> in the list of one-body forces that forms the input to <span class="literal">newtonSecondPS</span>. The appropriate mass will be taken from the state, and the force of gravity will be included in Newton’s second law.</p>&#13;
<h4 class="h4" id="ch16lev7">Gravity Produced by the Sun</h4>&#13;
<p class="noindent">Any object with mass exerts a gravitational force on any other object with mass. (This is theory 3 from the list of gravity theories on <a href="ch10.xhtml#ch10lev19">page 148</a>.) If the objects are spherical in shape, the force exerted by one object on another is directly proportional to the mass of each object and inversely proportional <span epub:type="pagebreak" id="page_289"/>to the square of the distance between their centers. This is the content of Newton’s law of universal gravity, which we will discuss in more detail in <a href="ch19.xhtml">Chapter 19</a>.</p>&#13;
<p class="indent">In our solar system, there are many examples of pairs of objects with one much more massive than the other, such as sun/Earth, Earth/moon, and Earth/telecommunications satellite. If we want to understand Earth’s motion as it moves through the solar system, it is a good approximation to suppose two things: one, that the gravitational attraction of other planets such as Mars, Venus, and Jupiter have a very small effect on Earth, and can therefore be ignored; and two, that the sun is so massive compared to Earth that its position can be taken to be fixed. Under these approximations, the universal gravity produced by the sun can be regarded as a one-body force acting on Earth (or on Mars, Venus, Halley’s comet, and so on).</p>&#13;
<p class="indent">The gravitational force exerted by the sun on an object or particle with mass <em>m</em> is</p>&#13;
<div class="imagec"><img src="Images/289equ01.jpg" alt="Image" width="184" height="43"/></div>&#13;
<p class="noindent">where <em>G</em> is Newton’s gravitational constant (in SI units, <em>G</em> = 6.67408 × 10–<sup>11</sup> N m<sup>2</sup>/kg<sup>2</sup>), <em>M<sub>s</sub></em> is the mass of the sun (<em>M<sub>s</sub></em> = 1.98848 × 10<sup>30</sup> kg), <em>r</em> is the distance between the center of the sun and the center of the object, and</p>&#13;
<div class="imagec"><img src="Images/289equ02.jpg" alt="Image" width="56" height="40"/></div>&#13;
<p class="noindent">is a unit vector pointing from the sun toward the object. The minus sign implies that the force on the object is toward the sun. A one-body force for sun gravity can be written as follows:</p>&#13;
<pre>-- origin is at center of sun&#13;
-- assumes SI units&#13;
sunGravity :: OneBodyForce&#13;
sunGravity (ParticleState m _q _t r _v)&#13;
    = let bigG = 6.67408e-11  -- N m^2/kg^2&#13;
          sunMass = 1.98848e30  -- kg&#13;
      in (-bigG * sunMass * m) *^ r ^/ magnitude r ** 3</pre>&#13;
<p class="indent">Here we use pattern matching on the input to extract the state variables instead of the extraction function we used for the previous one-body force of Earth surface gravity. Instead of naming the particle state with a local variable like <span class="literal">st</span>, we match the pattern of a particle state using the <span class="literal">ParticleState</span> constructor. We assign the five local variables that follow the constructor the values mass, charge, time, position, and velocity, respectively. We don’t need charge, time, or velocity to compute the gravitational force that the sun exerts, so they are preceded by underscores. (We could have used <em>only</em> the underscore for any or all of the unused variables, but providing a name after the underscore reminds us of exactly what is being ignored.) The choice of whether to use extraction functions or pattern matching to get the state variables out of the state is a matter of style, and you can use whatever you like best.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_290"/>If we are interested in the motion of the moon around the earth, we can express Earth’s universal gravity as a one-body force that acts on the moon. Exercise 16.4 asks you to write a one-body force for the universal gravity produced by Earth. If, on the other hand, we are interested in the motion of the moon through the solar system, then gravity from both the sun and Earth is important, and it’s better to use the techniques of <a href="ch19.xhtml">Chapter 19</a>.</p>&#13;
<h4 class="h4" id="ch16lev8">Air Resistance</h4>&#13;
<p class="noindent">Air resistance is a one-body force that depends on the velocity of the object moving through the air. We assume that the air is still with respect to our coordinate system. In <a href="ch14.xhtml">Chapter 14</a>, we developed an expression for air resistance that we applied in one-dimensional situations. In three-dimensional situations, velocity is a vector, and the force of air resistance appears as</p>&#13;
<div class="imagec"><img src="Images/290equ01.jpg" alt="Image" width="437" height="45"/></div>&#13;
<p class="noindent">with the parameters <em>C</em>, <em>ρ</em>, and <em>A</em> still representing the drag coefficient, the density of the air, and the cross-sectional area of the object, respectively.</p>&#13;
<p class="indent">Here is the Haskell code for the one-body force that corresponds to Equation 16.6:</p>&#13;
<pre>airResistance :: R  -- drag coefficient&#13;
              -&gt; R  -- air density&#13;
              -&gt; R  -- cross-sectional area of object&#13;
              -&gt; OneBodyForce&#13;
airResistance drag rho area (ParticleState _m _q _t _r v)&#13;
    = (-0.5 * drag * rho * area * magnitude v) *^ v</pre>&#13;
<p class="indent">We are using pattern matching on the input when we name the incoming particle state <span class="literal">ParticleState _m _q _t _r v</span>. The force depends only on the velocity, so the velocity is the only state variable that needs to be named.</p>&#13;
<p class="indent">For any situation in which we want to include air resistance, we need to estimate a drag coefficient, determine the cross-sectional area of our object, and determine an appropriate value for the density of air. At a reasonable temperature and pressure near Earth’s surface, the density of air is about 1.225 kg/m<sup>3</sup>. If, for example, 0.8 was our drag coefficient and 0.003 m<sup>2</sup> was the cross-sectional area of our object, then including</p>&#13;
<pre>airResistance 0.8 1.225 0.003</pre>&#13;
<p class="noindent">in the list of one-body forces for <span class="literal">newtonSecondPS</span> would include the force of air resistance in Newton’s second law.</p>&#13;
<p class="indent">If we were going to do a lot of air resistance problems, we might put the cross-sectional area of the object into the state since it’s clearly a property of the object. We might even consider putting the drag coefficient into the state, if that can be regarded as a property of the object rather than a property of the interaction between the object and the air. We won’t make these modifications to our state data type; instead, we’ll stick with our <span class="literal">ParticleState</span>, <span epub:type="pagebreak" id="page_291"/>and when forces depend on parameters that are not included in the state, we’ll just handle it on a case-by-case basis, as we did here.</p>&#13;
<h4 class="h4" id="ch16lev9">Wind Force</h4>&#13;
<p class="noindent">The one-body force of air resistance just considered assumes that the air is motionless with respect to our coordinate system. The one-body wind force we consider in this section is a generalization of air resistance in that the air moves at some constant velocity with respect to our coordinate system. We can use our air resistance formula to find the wind force, but the appropriate velocity to use is the <em>relative velocity</em> between the object and the wind. If <strong>v</strong> is the velocity of the object with respect to our coordinate system, and <strong>v</strong><sub>wind</sub> is the velocity of the air with respect to our coordinate system, then <strong>v</strong> – <strong>v</strong><sub>wind</sub> is the velocity of the object with respect to the air. The wind force can be expressed as follows:</p>&#13;
<div class="imagec"><img src="Images/291equ01.jpg" alt="Image" width="513" height="44"/></div>&#13;
<p class="indent">Here is the corresponding Haskell code:</p>&#13;
<pre>windForce :: Vec  -- wind velocity&#13;
          -&gt; R    -- drag coefficient&#13;
          -&gt; R    -- air density&#13;
          -&gt; R    -- cross-sectional area of object&#13;
          -&gt; OneBodyForce&#13;
windForce vWind drag rho area (ParticleState _m _q _t _r v)&#13;
    = let vRel = v ^-^ vWind&#13;
      in (-0.5 * drag * rho * area * magnitude vRel) *^ vRel</pre>&#13;
<p class="indent">The code for wind force is similar to the code for air resistance. Exercise 17.5 gives an opportunity to try out this force. Notice that if the wind velocity is chosen to be 0, the wind force becomes the force of air resistance we treated in the previous section. Air resistance is the force that stationary air exerts on an object, while wind force is the force that moving air exerts on an object. If the force of air is important in a situation, you’ll want air resistance or the wind force, but not both.</p>&#13;
<h4 class="h4" id="ch16lev10">Force from Uniform Electric and Magnetic Fields</h4>&#13;
<p class="noindent">We haven’t talked about electric or magnetic fields yet, but we will in <a href="part03.xhtml">Part III</a> of the book. For now, the important things to know are that these fields are produced by electric charge and that a particle experiences a force in the presence of electric and/or magnetic fields. When these fields are <em>uniform</em>, meaning the same at different places in space, a single vector describes the electric field and a single vector describes the magnetic field.</p>&#13;
<p class="indent">Suppose that <strong>E</strong> is a uniform electric field vector and <strong>B</strong> is a uniform magnetic field vector. These fields exert a force on a charged particle traveling <span epub:type="pagebreak" id="page_292"/>through them, given by</p>&#13;
<div class="imagec"><img src="Images/e0292-01.jpg" alt="Image" width="455" height="21"/></div>&#13;
<p class="noindent">where <em>q</em> is the electric charge of the particle and <strong>v</strong>(<em>t</em>) is the velocity of the particle. This equation is called the <em>Lorentz force law</em>, and we will study it in more detail when we turn to electromagnetic theory, including the more general situation in which the fields need not be uniform. Here is the corresponding Haskell code for the one-body force:</p>&#13;
<pre>uniformLorentzForce :: Vec  -- E&#13;
                    -&gt; Vec  -- B&#13;
                    -&gt; OneBodyForce&#13;
uniformLorentzForce vE vB (ParticleState _m q _t _r v)&#13;
    = q *^ (vE ^+^ v &gt;&lt; vB)</pre>&#13;
<p class="indent">The function <span class="literal">uniformLorentzForce</span> has type <span class="literal">Vec -&gt; Vec -&gt; OneBodyForce</span>, which is the same as <span class="literal">Vec -&gt; Vec -&gt; ParticleState -&gt; Vec</span>. Given a vector <span class="literal">vE :: Vec</span> for the electric field, a vector <span class="literal">vB :: Vec</span> for the magnetic field, and a particle state <span class="literal">ParticleState _m q _t _r v :: ParticleState</span> using pattern matching on the input, the function returns a force vector by applying the Lorentz force law (Equation 16.8). The charge and velocity of the particle are the state variables needed to compute this electromagnetic force.</p>&#13;
<p class="indent">Having seen several examples of one-body forces, let’s continue along <a href="ch16.xhtml#ch16fig2">Figure 16-2</a> and explore the state-update process.</p>&#13;
<h3 class="h3" id="ch16lev11">State Update for One Particle</h3>&#13;
<p class="noindent">A numerical method transforms a differential equation into a state-update function. The Euler-Cromer method is a numerical method, and because it’s not a general-purpose numerical method, we need to write a new function for it for each state data type we want to use. Here is the Euler-Cromer function for the <span class="literal">ParticleState</span> data type:</p>&#13;
<pre>eulerCromerPS :: TimeStep        -- dt for stepping&#13;
              -&gt; NumericalMethod ParticleState DParticleState&#13;
eulerCromerPS dt deriv st&#13;
    = let t   = time     st&#13;
          r   = posVec   st&#13;
          v   = velocity st&#13;
          dst = deriv st&#13;
          acc = dvdt dst&#13;
          v'  = v ^+^ acc ^* dt&#13;
      in st { time     = t  +         dt&#13;
            , posVec   = r ^+^ v'  ^* dt&#13;
            , velocity = v ^+^ acc ^* dt&#13;
            }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_293"/>As we saw with the Euler-Cromer method in the last chapter, the key difference compared with the Euler method is that it uses an updated velocity to update position. The update equations in <span class="literal">eulerCromerPS</span> are almost identical to those in <span class="literal">eulerCromer1D</span> of the previous chapter, with the one difference being that we are now working with vectors.</p>&#13;
<p class="indent">The Euler and fourth-order Runge-Kutta methods are general-purpose methods for solving any differential equation. In <a href="ch15.xhtml">Chapter 15</a>, we wrote the <span class="literal">euler</span> and <span class="literal">rungeKutta4</span> functions, which can work with any differential equation and any state type. To use them with the <span class="literal">ParticleState</span> data type, we must write a <span class="literal">RealVectorSpace</span> instance for <span class="literal">DParticleState</span> and a <span class="literal">Diff</span> instance relating the <span class="literal">ParticleState</span> and <span class="literal">DParticleState</span> types.</p>&#13;
<p class="indent">Here is the <span class="literal">RealVectorSpace</span> instance:</p>&#13;
<pre>instance RealVectorSpace DParticleState where&#13;
    dst1 +++ dst2&#13;
        = DParticleState { dmdt = dmdt dst1  +  dmdt dst2&#13;
                         , dqdt = dqdt dst1  +  dqdt dst2&#13;
                         , dtdt = dtdt dst1  +  dtdt dst2&#13;
                         , drdt = drdt dst1 ^+^ drdt dst2&#13;
                         , dvdt = dvdt dst1 ^+^ dvdt dst2&#13;
                         }&#13;
    scale w dst&#13;
        = DParticleState { dmdt = w *  dmdt dst&#13;
                         , dqdt = w *  dqdt dst&#13;
                         , dtdt = w *  dtdt dst&#13;
                         , drdt = w *^ drdt dst&#13;
                         , dvdt = w *^ dvdt dst&#13;
                         }</pre>&#13;
<p class="indent">In this instance declaration, we define addition to be item-wise addition for each item, and we define scalar multiplication to be item-wise scaling for each item.</p>&#13;
<p class="indent">Here is the <span class="literal">Diff</span> instance:</p>&#13;
<pre>instance Diff ParticleState DParticleState where&#13;
    shift dt dps (ParticleState m q t r v)&#13;
        = ParticleState (m  +  dmdt dps  * dt)&#13;
                        (q  +  dqdt dps  * dt)&#13;
                        (t  +  dtdt dps  * dt)&#13;
                        (r ^+^ drdt dps ^* dt)&#13;
                        (v ^+^ dvdt dps ^* dt)</pre>&#13;
<p class="indent">Each item in the state is shifted by the product of its derivative with the time step.</p>&#13;
<p class="indent">Having made these instance declarations, we now have access to the functions <span class="literal">euler</span> and <span class="literal">rungeKutta4</span> we wrote in the previous chapter. We can use any of the three numerical methods, Euler, Euler-Cromer, or fourth-order Runge-Kutta, to produce a state-update function from a differential equation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_294"/><a href="ch16.xhtml#ch16fig2">Figure 16-2</a> showed the four data representations we use to solve a mechanics problem and three functions that transform from one data representation to another. Compositions of these three functions are important enough to name and are shown as arrows on the sides of <a href="ch16.xhtml#ch16fig3">Figure 16-3</a>. We wrote <span class="literal">solver</span> in the last chapter and will write <span class="literal">updatePS</span> and <span class="literal">statesPS</span> shortly.</p>&#13;
<div class="imagel" id="ch16fig3"><img src="Images/294fig01.jpg" alt="Image" width="562" height="482"/></div>&#13;
<p class="figcap"><em>Figure 16-3: Data representations and functions that transform among them</em></p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16fig3">Figure 16-3</a> again shows the four data representations, with one small change. Where <a href="ch16.xhtml#ch16fig2">Figure 16-2</a> has a list of states as the final representation, <a href="ch16.xhtml#ch16fig3">Figure 16-3</a> has a function from initial state to list of states, which we call an <em>evolver</em>. The reason for this change is that we want to view each representation in <a href="ch16.xhtml#ch16fig3">Figure 16-3</a> as the result of applying a single function to the single input consisting of the previous representation. In other words, where the initial state appears as an input in <a href="ch16.xhtml#ch16fig2">Figure 16-2</a>, it is part of the type of the evolver in <a href="ch16.xhtml#ch16fig3">Figure 16-3</a>. To transform between adjacent representations in <a href="ch16.xhtml#ch16fig3">Figure 16-3</a>, we apply Newton’s second law, then a numerical method, and then iteration.</p>&#13;
<p class="indent">Let’s write a function <span class="literal">statesPS</span> that produces all three transformations of <a href="ch16.xhtml#ch16fig3">Figure 16-3</a> by producing the differential equation from the forces, using a numerical method to turn the differential equation into a state-update function, and iterating the state-update function to produce an evolver. The inputs to this function will be a numerical method and a list of one-body forces. The output will be an evolver that can act on an initial state to produce an infinite list of states. We call this function <span class="literal">statesPS</span> because it produces a list of states when supplied with an initial state and is for the <span class="literal">ParticleState</span> data type.</p>&#13;
<span epub:type="pagebreak" id="page_295"/>&#13;
<pre>statesPS :: NumericalMethod ParticleState DParticleState&#13;
         -&gt; [OneBodyForce]  -- list of force funcs&#13;
         -&gt; ParticleState -&gt; [ParticleState]  --evolver&#13;
statesPS method = iterate . method . newtonSecondPS</pre>&#13;
<p class="indent">The local variable <span class="literal">method</span> stands for the numerical method we provide when we use <span class="literal">statesPS</span>. We see from the definition that this function is a composition of three functions, as suggested by <a href="ch16.xhtml#ch16fig3">Figure 16-3</a>. Recall that numerical methods are things like <span class="literal">euler 0.01</span>, <span class="literal">eulerCromerPS 0.1</span>, and <span class="literal">rungeKutta4</span> <span class="literal">0.1</span>. Notice that the function <span class="literal">newtonSecondPS</span>, which transforms forces into a differential equation, can be used with any numerical method.</p>&#13;
<p class="indent">It is similarly useful, especially for animation, to name the function that transforms from a list of forces to a state-update function. We’ll call this function <span class="literal">updatePS</span>, and we see from its definition that it is simply the composition of Newton’s second law with a numerical method.</p>&#13;
<pre>updatePS :: NumericalMethod ParticleState DParticleState&#13;
         -&gt; [OneBodyForce]&#13;
         -&gt; ParticleState -&gt; ParticleState&#13;
updatePS method = method . newtonSecondPS</pre>&#13;
<p class="indent"><a href="ch16.xhtml#ch16fig3">Figure 16-3</a> demonstrates how this function fits into the sequence of data representations.</p>&#13;
<p class="indent">The final composition of transformations we might want to make is expressed by the function <span class="literal">solver</span> we wrote in the previous chapter. Unlike <span class="literal">statesPS</span> and <span class="literal">updatePS</span>, which require the <span class="literal">ParticleState</span> data type, the function <span class="literal">solver</span> works with any data type (any state space). If you look back on its definition, you will see that it is just the composition of a numerical method with iteration.</p>&#13;
<p class="indent">We are now in a wonderful position. All we need to do to solve any one-body problem in mechanics is give the computer:</p>&#13;
<ul class="bull">&#13;
<li class="noindent">A numerical method</li>&#13;
<li class="noindent">A list of one-body forces</li>&#13;
<li class="noindent">The body’s initial state</li>&#13;
</ul>&#13;
<p class="indent">The computer will then calculate a list of states, which we can use to find quantities like position and velocity at arbitrary times.</p>&#13;
<p class="indent">Putting everything together, we can write a function <span class="literal">positionPS</span>, similar to <span class="literal">positionFtxv</span> and others we have written before, that takes the three pieces of information listed above and produces a function that gives the position of the object at any time.</p>&#13;
<pre>positionPS :: NumericalMethod ParticleState DParticleState&#13;
           -&gt; [OneBodyForce]  -- list of force funcs&#13;
           -&gt; ParticleState   -- initial state&#13;
           -&gt; Time -&gt; PosVec  -- position function&#13;
positionPS method fs st t&#13;
   = let states = statesPS method fs st&#13;
         dt = time (states !! 1) - time (states !! 0)&#13;
         numSteps = abs $ round (t / dt)&#13;
         st1 = solver method (newtonSecondPS fs) st !! numSteps&#13;
     in posVec st1</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_296"/>The function begins by naming the incoming numerical method <span class="literal">method</span>, the list of one-body forces <span class="literal">fs</span>, the initial particle state <span class="literal">st</span>, and the time <span class="literal">t</span>. The first line in the <span class="literal">let</span> clause uses <span class="literal">statesPS</span> to create an infinite list of particle states based on the numerical method, forces, and initial particle state given. The second line calculates the time step by subtracting the times of the first and second states in the list. The third line finds the number of time steps necessary to get as close as possible to the desired time <span class="literal">t</span>. The fourth line picks out the state that is closest to the desired time, and the body of the <span class="literal">let</span> construction, after the <span class="literal">in</span> keyword, uses the extraction function <span class="literal">posVec</span> to pick out the position from the state.</p>&#13;
<p class="indent">Having written functions that allow us to solve any one-body mechanics problem using the numerical method of our choice, let’s turn our attention to some last details about animation.</p>&#13;
<h3 class="h3" id="ch16lev12">Preparing for Animation</h3>&#13;
<p class="noindent">In <a href="ch13.xhtml">Chapter 13</a>, we discussed how to make 2D and 3D animations with the <span class="literal">Graphics.Gloss</span> and <span class="literal">Vis</span> modules. Remember that each module has a <span class="literal">simulate</span> function, but the two functions are not parallel in terms of the inputs they require. In this section, we’ll ease future strain on our brains by creating two new functions, <span class="literal">simulateGloss</span> and <span class="literal">simulateVis</span>, that take very similar inputs to each other, so we can switch from 2D animation to 3D and back without having to remember all of the details about how the <span class="literal">gloss</span> <span class="literal">simulate</span> function differs from the <span class="literal">not-gloss</span> <span class="literal">simulate</span> function.</p>&#13;
<h4 class="h4" id="ch16lev13">Two Helpful Animation Functions</h4>&#13;
<p class="noindent">Each of the functions <span class="literal">simulateGloss</span> and <span class="literal">simulateVis</span> calls its own version of <span class="literal">simulate</span> to do the actual work. The intention is that we use these new functions instead of either version of <span class="literal">simulate</span>. We’ll briefly explain how <span class="literal">simulate</span> <span class="literal">Gloss</span> and <span class="literal">simulateVis</span> work; however, unlike many of the Haskell functions in this book, the point of writing these functions is not to illustrate important or beautiful ideas about physics or programming. Instead, the point is to make animation easier. We are willing to pay the cost of writing these functions once because we’ll then enjoy the benefit of being able to use them again and again to make animations in a more convenient way.</p>&#13;
<p class="indent">It’s more important to understand how to use these functions than it is to understand how they work. If you want to skip the definitions and the explanation of how the functions work, it will not cause you trouble later. However, do pay attention to the types of these two new functions and the inputs that must be provided for them to do their job.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_297"/>Here are the type signatures and function definitions for <span class="literal">simulateGloss</span> and <span class="literal">simulateVis</span>:</p>&#13;
<pre>simulateGloss :: R    -- time-scale factor&#13;
              -&gt; Int  -- animation rate&#13;
              -&gt; s    -- initial state&#13;
              -&gt; (s -&gt; G.Picture)&#13;
              -&gt; (TimeStep -&gt; s -&gt; s)&#13;
              -&gt; IO ()&#13;
simulateGloss tsFactor rate initialState picFunc updateFunc&#13;
    = G.simulate (G.InWindow "" (1000, 750) (10, 10)) G.black rate&#13;
      initialState picFunc&#13;
          (\_ -&gt; updateFunc . (* tsFactor) . realToFrac)&#13;
&#13;
simulateVis :: HasTime s =&gt; R  -- time-scale factor&#13;
            -&gt; Int             -- animation rate&#13;
            -&gt; s               -- initial state&#13;
            -&gt; (s -&gt; V.VisObject R)&#13;
            -&gt; (TimeStep -&gt; s -&gt; s)&#13;
            -&gt; IO ()&#13;
simulateVis tsFactor rate initialState picFunc updateFunc&#13;
    = let visUpdateFunc ta st&#13;
              = let dtp = tsFactor * realToFrac ta - timeOf st&#13;
                in updateFunc dtp st&#13;
      in V.simulate V.defaultOpts (1/fromIntegral rate)&#13;
      initialState (orient . picFunc) visUpdateFunc</pre>&#13;
<p class="indent">The <span class="literal">simulateGloss</span> function makes a 2D animation, while <span class="literal">simulateVis</span> makes a 3D animation. Each function takes five inputs. The meaning and order of the inputs are the same in both functions, even though one of the five inputs has a different type in <span class="literal">simulateGloss</span> than it has in <span class="literal">simulateVis</span>. Let’s discuss the meaning and purpose of each of the five inputs.</p>&#13;
<h5 class="h5" id="ch16lev14">Time-Scale Factor</h5>&#13;
<p class="noindent">The first input to <span class="literal">simulateGloss</span> and <span class="literal">simulateVis</span>, <span class="literal">tsFactor</span>, says how fast we want the animation to run compared with physical evolution. There will be times when we want the animation to run faster or slower than the corresponding physical situation evolves. For example, it takes the moon about a month to orbit Earth, but we might want an animation in which the moon makes a full cycle in six seconds. We’re almost always going to want an animation that happens in seconds or minutes. Smaller than that and it’s too rapid to see; larger than that and we lose patience.</p>&#13;
<p class="indent">We can distinguish between two forms of time. <em>Physical time</em> is the time for some process to occur in the physical world. The physical time for one period of the moon orbiting Earth is one month. <em>Animation time</em> is the time for some process to occur in a computer animation. The animation time for one period of the moon orbiting Earth is six seconds in our example.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_298"/>To allow a difference between physical time and animation time, our <span class="literal">simulateGloss</span> and <span class="literal">simulateVis</span> functions take a <em>time-scale factor</em> as their first input, hence the name <span class="literal">tsFactor</span>. The time-scale factor is the ratio of physical time to animation time. For the moon orbit example, where the physical time is much larger than the animation time, the time-scale factor is a number (much) bigger than 1. A time-scale factor smaller than 1 should be used for a process that occurs very quickly in the physical world that we want to view in “slow motion” so we see interesting changes as they occur. By specifying a time-scale factor as the first input to <span class="literal">simulateGloss</span> or <span class="literal">simulateVis</span>, we are declaring how fast we want the animation to run compared with physical evolution.</p>&#13;
<h5 class="h5" id="ch16lev15">Animation Rate</h5>&#13;
<p class="noindent">The <em>animation rate</em>, called <span class="literal">rate</span> in the code shown earlier, is the number of picture frames displayed per second of animation time, and it’s the second input to <span class="literal">simulateGloss</span> and <span class="literal">simulateVis</span>. Because a new picture frame is generated every time the state-update function is called to produce a new state, the animation rate is also the number of state updates per second of animation time.</p>&#13;
<p class="indent">There is a relationship between the time-scale factor, the animation rate, and the time step. If we let <em>α</em> denote the time-scale factor, <em>r</em> the animation rate, and Δ<em>t<sub>p</sub></em> the time step (which is a physical time, hence subscript p), the relationship is</p>&#13;
<div class="imagec"><img src="Images/298fig01.jpg" alt="Image" width="70" height="38"/></div>&#13;
<p class="indent">Only two of these can be chosen independently. Since the time step is a physical time, and since we are likely to be interested in situations with physical time scales ranging from nanoseconds to years, it’s convenient to tell <span class="literal">simulateGloss</span> or <span class="literal">simulateVis</span> the time-scale factor and the animation rate and let them calculate the time step to be used for state update. This way, if we choose a sensible time-scale factor, we can pick something like 20 frames/second for the animation rate and we’ll have a decent chance of using a reasonable time step. If we find we need a smaller time step, we can increase the animation rate (as we do in the next chapter for Halley’s comet).</p>&#13;
<h5 class="h5" id="ch16lev16">Initial State</h5>&#13;
<p class="noindent">The third input is the initial state of the particle or system we wish to animate, <span class="literal">initialState</span>. In this chapter, the state of a particle has the type <span class="literal">ParticleState</span>. In the previous chapter, the state of a particle in one dimension had type <span class="literal">State1D</span>. In <a href="ch19.xhtml">Chapter 19</a>, the state of a system of particles will have type <span class="literal">MultiParticleState</span>. Our two animation functions can work with any of these, as indicated by the type variable <span class="literal">s</span> used for the initial state.</p>&#13;
<h5 class="h5" id="ch16lev17">Display Function</h5>&#13;
<p class="noindent">The fourth input, <span class="literal">picFunc</span>, is a display function that must explain what 2D or 3D picture to make for a given state. Since <span class="literal">gloss</span> uses the <span class="literal">Picture</span> type for <span epub:type="pagebreak" id="page_299"/>a picture and <span class="literal">not-gloss</span> uses the <span class="literal">VisObject R</span> type, this fourth input has a different type in <span class="literal">simulateGloss</span> than in <span class="literal">simulateVis</span>. When we want to produce an animation for a specific physical situation, we’ll need to write a display function for that situation. The <span class="literal">not-gloss</span> package has its own type for three-dimensional vectors, which differs from the <span class="literal">Vec</span> type we have been using. Since there is a three-dimensional translation function called <span class="literal">Trans</span> that takes a <span class="literal">not-gloss</span> vector as input, it will be useful to have a conversion function around when we write the display function for a 3D animation. The function <span class="literal">v3FromVec</span> produces a <span class="literal">not-gloss</span> vector from a <span class="literal">Vec</span>.</p>&#13;
<pre>v3FromVec :: Vec -&gt; V3 R&#13;
v3FromVec v = V3 x y z&#13;
    where&#13;
      x = xComp v&#13;
      y = yComp v&#13;
      z = zComp v</pre>&#13;
<p class="indent">We’ll use this function in the 3D animations of projectile motion and of a proton in a magnetic field in the next chapter.</p>&#13;
<h5 class="h5" id="ch16lev18">State-Update Function</h5>&#13;
<p class="noindent">The fifth and final input is a state-update function, <span class="literal">updateFunc</span>. State-update functions have been central to our method for solving Newton’s second law, even in the absence of animation. Notice that the type of the state-update function is <span class="literal">TimeStep -&gt; s -&gt; s</span>. This function must explain how to create a new state from an old state when given a time step. We are not choosing the time step here. Instead, we are specifying a function that takes a time step as input, along with an old state, and returns a new state. To obtain a state-update function, we can either apply a numerical method to a differential equation that comes from Newton’s second law or use the <span class="literal">updatePS</span> function we defined earlier with a numerical method and a list of one-body forces.</p>&#13;
<p class="indent">The five inputs just discussed—the time-scale factor, animation rate, initial state, display function, and state-update function—contain everything about the physical situation we’re modeling as well as all the information about how to produce a picture as a function of time.</p>&#13;
<p class="indent">Having discussed the inputs to the functions <span class="literal">simulateGloss</span> and <span class="literal">simulateVis</span> to make 2D and 3D animations, let’s look at how the functions work.</p>&#13;
<h4 class="h4" id="ch16lev19">How the Functions Work</h4>&#13;
<p class="noindent">It is easier to understand how the <span class="literal">simulateGloss</span> function works, so we’ll start with that one. The <span class="literal">simulateGloss</span> function names the five inputs, <span class="literal">tsFactor</span> for the time-scale factor, and so on. It calls <span class="literal">gloss</span>’s <span class="literal">simulate</span> function to do the actual work, passing six arguments to that function. The first argument to <span class="literal">simulate</span> specifies an empty window name, a window size in pixels, and a window location. Since these parameters are not so interesting, and since we <span epub:type="pagebreak" id="page_300"/>are unlikely to want to change these values from animation to animation, we have picked some values that we hope will work once and for all. The second argument to <span class="literal">simulate</span> is a background color, which we choose to be black. The third, fourth, and fifth inputs are the animation rate, initial state, and display function. These are all inputs to <span class="literal">simulateGloss</span>, so they can simply be passed along to <span class="literal">gloss</span>’s <span class="literal">simulate</span>.</p>&#13;
<p class="indent">The final input required by <span class="literal">gloss</span>’s <span class="literal">simulate</span> is an update function, but it differs from the state-update function we have been working with in three ways. First, <span class="literal">gloss</span>’s <span class="literal">simulate</span> expects an update function whose first argument is a <span class="literal">ViewPort</span>, which we do not intend to use. To give a place for the viewport, we write an anonymous function that throws away its first argument. Second, <span class="literal">gloss</span>’s <span class="literal">simulate</span> expects an update function that works with animation time rather than physical time. Since our update functions work with physical time, we need to do a conversion here using the time-scale factor. Third, we need to convert <span class="literal">R</span> to <span class="literal">Float</span> using <span class="literal">realToFrac</span>. In summary, our <span class="literal">simulateGloss</span> function works by providing inputs to <span class="literal">gloss</span>’s <span class="literal">simulate</span> function from the inputs given to <span class="literal">simulateGloss</span>. Two of the inputs to <span class="literal">gloss</span>’s <span class="literal">simulate</span> are simply specified, three are passed unchanged from inputs to <span class="literal">simulateGloss</span>, and one is a modification of a <span class="literal">simulateGloss</span> input.</p>&#13;
<p class="indent">The <span class="literal">simulateVis</span> function gives the same names to its five inputs that <span class="literal">simulateGloss</span> uses because the inputs have the same meanings. It calls <span class="literal">not</span> <span class="literal">-gloss</span>’s <span class="literal">simulate</span> function to do the actual work, passing five arguments to that function. The first argument to <span class="literal">simulate</span> specifies some options, which we set, once and for all, to the default options. The second argument to <span class="literal">simulate</span> is the number of seconds per frame at which the animation should run. Since this is just the inverse of the animation rate, we can invert the <span class="literal">rate</span> after suitably changing its type from an integer to a real number. The third input is the initial state, which we pass along unchanged.</p>&#13;
<p class="indent">The fourth input is the display function, which we could pass along unchanged, but we don’t because I want to take this opportunity to use the <span class="literal">orient</span> function, originally written in <a href="ch13.xhtml">Chapter 13</a> and repeated below, to rotate the axes so that the y-axis points to the right, the z-axis points up the screen, and the x-axis points to the left and appears to extend out of the screen. In other words, I’m using <span class="literal">orient</span> so our animations will automatically use my favorite coordinate system.</p>&#13;
<pre>orient :: V.VisObject R -&gt; V.VisObject R&#13;
orient pict = V.RotEulerDeg (Euler 270 180 0) $ pict</pre>&#13;
<p class="indent">The fifth and final input required by <span class="literal">not-gloss</span>’s <span class="literal">simulate</span> is an update function; however, it differs substantially from the state-update function <span class="literal">updateFunc</span> that we have to work with. Because the difference is so substantial, we use a <span class="literal">let</span> construction to define a local function <span class="literal">visUpdateFunc</span> that we will pass as the final input to <span class="literal">not-gloss</span>’s <span class="literal">simulate</span> function. We name the first <span class="literal">visUpdateFunc</span> input <span class="literal">ta</span> as a reminder that it represents animation time. We name the second <span class="literal">visUpdateFunc</span> input <span class="literal">st</span> for state. Our strategy is to use the <span class="literal">updateFunc</span> passed to <span class="literal">simulateVis</span> to calculate the value of <span class="literal">visUpdateFunc ta st</span>, which has type <span class="literal">s</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_301"/>The difference between <span class="literal">visUpdateFunc</span> and <span class="literal">updateFunc</span> is all in how they interpret their first argument. The first input to <span class="literal">visUpdateFunc</span>, named <span class="literal">ta</span>, is the animation time elapsed since the beginning of the animation. In contrast, the first input to <span class="literal">updateFunc</span> is the physical time <em>step</em> since the previous state was calculated. Inside the local definition of <span class="literal">visUpdateFunc</span>, we have access to the animation time <span class="literal">ta</span> that we must use to calculate the physical time step <span class="literal">dtp</span> we will send to <span class="literal">updateFunc</span>. This conversion is more complicated than for <span class="literal">gloss</span> because we are really doing two conversions: one from animation time to physical time and one from physical time since the animation’s start to the physical time step. We use a nested <span class="literal">let</span> construction to define the local variable <span class="literal">dtp</span>, the physical time step we will send to <span class="literal">updateFunc</span> to produce the new state <span class="literal">visUpdateFunc ta st</span>. We calculate <span class="literal">dtp</span>, a real number with type <span class="literal">R</span>, by first converting the type of <span class="literal">ta</span> from <span class="literal">Float</span> to <span class="literal">R</span>, scaling this animation time by the time-scale factor to produce the physical time since the simulation began, and then subtracting the (physical) time of the old state. The physical time associated with state <span class="literal">st</span> is <span class="literal">timeOf st</span>. I explain how that works next.</p>&#13;
<p class="indent">We need to know the time (which is one of the state variables in <span class="literal">Particle</span> <span class="literal">State</span>) of a state. This would be no problem if <span class="literal">simulateVis</span> was intended to work only with the <span class="literal">ParticleState</span> data type. But we want <span class="literal">simulateVis</span> to be able to work with any state space <span class="literal">s</span>, or at least any state space <span class="literal">s</span> that contains time as a state variable. To solve this problem, it seems we must invent a new type class, called <span class="literal">HasTime</span>, for types that represent states from which a particular value of time can be extracted. The type class owns just one function, <span class="literal">timeOf</span>, which pulls the time out of the state. Here is the definition of the type class <span class="literal">HasTime</span>:</p>&#13;
<pre>class HasTime s where&#13;
    timeOf :: s -&gt; Time</pre>&#13;
<p class="indent">Each type that aspires to be an instance of <span class="literal">HasTime</span> must express how to implement <span class="literal">timeOf</span> through an instance declaration. Here is the instance declaration for <span class="literal">ParticleState</span>:</p>&#13;
<pre>instance HasTime ParticleState where&#13;
    timeOf = time</pre>&#13;
<p class="indent">In summary, our <span class="literal">simulateVis</span> function works by providing inputs to <span class="literal">not</span> <span class="literal">-gloss</span>’s <span class="literal">simulate</span> function from the inputs given to <span class="literal">simulateVis</span>. One of the inputs to <span class="literal">not-gloss</span>’s <span class="literal">simulate</span> is simply specified, two are passed unchanged from inputs to <span class="literal">simulateVis</span>, and two are modifications of <span class="literal">simulateVis</span> inputs.</p>&#13;
<h3 class="h3" id="ch16lev20">Summary</h3>&#13;
<p class="noindent">This chapter applies Newtonian mechanics to a single object moving in three dimensions. Solving a mechanics problem is a process of transforming information through a sequence of four representations, starting with one-body forces, then a differential equation, then a state-update function, and finally a list of states. Newton’s second law appears in this process as the means to transform a list of forces acting on an object into a differential equation. <span epub:type="pagebreak" id="page_302"/>A numerical method transforms a differential equation into a state-update function. We used the Euler-Cromer method and fourth-order Runge-Kutta method with appropriately chosen time steps as numerical methods in this chapter. A state-update function is an essential ingredient in an animation of motion.</p>&#13;
<p class="indent">The state-based paradigm remained central in this chapter, where we defined a new data type to hold the state of a particle. This new data type includes the particle’s mass and charge, as well as its position and velocity and the time. We introduced the notion of a one-body force, which became the main way we talked about forces in this chapter. In the next chapter, we apply these ideas to specific examples and animate many of our results.</p>&#13;
<h3 class="h3" id="ch16lev21">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 16.1.</strong> Apply the function <span class="literal">newtonSecondPS</span> to a very simple list of forces, say the list of just a constant force, and a very simple state, say the <span class="literal">defaultParticleState</span>, and find the type of the resulting expression.</p>&#13;
<p class="noindentts"><strong>Exercise 16.2.</strong> Write a function</p>&#13;
<pre>constantForce :: Vec -&gt; OneBodyForce&#13;
constantForce f = undefined f</pre>&#13;
<p class="noindentts">that takes a force vector as input and returns a <span class="literal">OneBodyForce</span> that will return the given constant force regardless of what state it is provided with. For example, if we use <span class="literal">constantForce</span> to make a one-body force that always produces 10<img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/> N,</p>&#13;
<pre>tenNewtoniHatForce :: OneBodyForce&#13;
tenNewtoniHatForce = constantForce (10 *^ iHat)</pre>&#13;
<p class="noindentts">then <span class="literal">tenNewtoniHatForce defaultParticleState</span> should produce <span class="literal">vec 10.0 0.0 0.0</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 16.3.</strong> Write a function</p>&#13;
<pre>moonSurfaceGravity :: OneBodyForce&#13;
moonSurfaceGravity = undefined</pre>&#13;
<p class="noindentts">that returns the gravitational force exerted by Earth’s moon on an object near the moon’s surface.</p>&#13;
<p class="noindentts"><strong>Exercise 16.4.</strong> Write a one-body force for the universal gravity produced by Earth.</p>&#13;
<pre>earthGravity :: OneBodyForce&#13;
earthGravity = undefined</pre>&#13;
<p class="noindentts"><strong>Exercise 16.5.</strong> Use the function <span class="literal">uniformLorentzForce</span> to find the direction of the force on a proton moving in the positive x-direction in a uniform magnetic field in the positive z-direction. There is no electric field. You can <span epub:type="pagebreak" id="page_303"/>choose the speed of the proton and the magnitude of the magnetic field to be whatever you like. Given the direction of the force, what do you expect the subsequent motion of the proton to be?</p>&#13;
<p class="noindentts"><strong>Exercise 16.6.</strong> The tools we’ve developed in this chapter solve a mechanics problem by producing an infinite list of particle states. To make sense of that solution, we often want to extract some of the data and graph it. Suppose we wanted to plot the y-component of velocity as a function of time. We would want a list of pairs of (<em>t</em>, <em>v<sub>y</sub></em>) values. Write a function</p>&#13;
<pre>tvyPair :: ParticleState -&gt; (R,R)&#13;
tvyPair st = undefined st</pre>&#13;
<p class="noindentts">that produces the desired pair of numbers from the state of one particle. Then write a function</p>&#13;
<pre>tvyPairs :: [ParticleState] -&gt; [(R,R)]&#13;
tvyPairs sts = undefined sts</pre>&#13;
<p class="noindentts">that produces a list of numerical pairs from a list of states of one particle. You can use your <span class="literal">tvyPair</span> function in the body of this second function.</p>&#13;
<p class="noindentts"><strong>Exercise 16.7.</strong> Write a predicate</p>&#13;
<pre>tle1yr :: ParticleState -&gt; Bool&#13;
tle1yr st = undefined st</pre>&#13;
<p class="noindentts">that returns <span class="literal">True</span> if the time contained in the state (assumed to be a number of seconds) is less than or equal to one year and returns <span class="literal">False</span> otherwise. This predicate could be used with <span class="literal">takeWhile</span> to transform an infinite list of states into a finite list in preparation for making a graph.</p>&#13;
<p class="noindentts"><strong>Exercise 16.8.</strong> Write a function</p>&#13;
<pre>stateFunc :: [ParticleState]&#13;
          -&gt; Time -&gt; ParticleState&#13;
stateFunc sts t&#13;
    = let t0 = undefined sts&#13;
          t1 = undefined sts&#13;
          dt = undefined t0 t1&#13;
          numSteps = undefined t dt&#13;
      in undefined sts numSteps</pre>&#13;
<p class="noindentts">that produces a function from time to particle state when given a list of states. Assume that the times between adjacent states are all the same.</p>&#13;
<p class="noindentts"><strong>Exercise 16.9.</strong> In all of our work with air resistance so far, we have assumed the density of air to be a constant. However, the density of air near Earth’s surface actually decreases with altitude. A useful approximation for how air density changes with altitude is given by</p>&#13;
<div class="equationc"><em>ρ</em> = <em>ρ</em>0<em>e</em><sup>–<em>h</em>/<em>h</em><sub>0</sub></sup></div>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_304"/>where <em>ρ</em><sub>0</sub> is the air density at sea level, <em>h</em> is the distance above sea level, <em>ρ</em> is the air density at height <em>h</em> above sea level, and <em>h</em><sub>0</sub> is a constant.</p>&#13;
<p class="indent">Taking <em>h</em><sub>0</sub> = 8,500 meters and using the z-component of position for height above sea level, write a one-body force</p>&#13;
<pre>airResAtAltitude :: R  -- drag coefficient&#13;
                 -&gt; R  -- air density at sea level&#13;
                 -&gt; R  -- cross-sectional area of object&#13;
                 -&gt; OneBodyForce&#13;
airResAtAltitude drag rho0 area (ParticleState _m _q _t r v)&#13;
    = undefined drag rho0 area r v</pre>&#13;
<p class="noindentts">that can be used instead of <span class="literal">airResistance</span> for situations in which an object finds itself at high altitude. To test this new function, the following function compares the range of a lead ball fired from sea level with some initial velocity at some angle under three different conditions: (a) no air resistance, (b) uniform air resistance, and (c) air resistance that varies with altitude. The diameter of the lead ball is 10 cm. Supply the initial state and the final line of code (the two places marked <span class="literal">undefined</span>), and then use the code to see the ranges for a ball fired at 45<sup>∘</sup>. Try initial speeds of 10 m/s, 100 m/s, and 300 m/s.</p>&#13;
<pre>projectileRangeComparison :: R -&gt; R -&gt; (R,R,R)&#13;
projectileRangeComparison v0 thetaDeg&#13;
    = let vx0 = v0 * cos (thetaDeg / 180 * pi)&#13;
          vz0 = v0 * sin (thetaDeg / 180 * pi)&#13;
          drag = 1&#13;
          ballRadius = 0.05    -- meters&#13;
          area = pi * ballRadius**2&#13;
          airDensity  =    1.225  -- kg/m^3 @ sea level&#13;
          leadDensity = 11342     -- kg/m^3&#13;
          m = leadDensity * 4 * pi * ballRadius**3 / 3&#13;
          stateInitial = undefined m vx0 vz0&#13;
          aboveSeaLevel :: ParticleState -&gt; Bool&#13;
          aboveSeaLevel st = zComp (posVec st) &gt;= 0&#13;
          range :: [ParticleState] -&gt; R&#13;
          range = xComp . posVec . last . takeWhile aboveSeaLevel&#13;
          method = rungeKutta4 0.01&#13;
          forcesNoAir&#13;
              = [earthSurfaceGravity]&#13;
          forcesConstAir&#13;
              = [earthSurfaceGravity, airResistance    drag airDensity area]&#13;
          forcesVarAir&#13;
              = [earthSurfaceGravity, airResAtAltitude drag airDensity area]&#13;
          rangeNoAir    = range $ statesPS method forcesNoAir    stateInitial&#13;
          rangeConstAir = range $ statesPS method forcesConstAir stateInitial&#13;
          rangeVarAir   = range $ statesPS method forcesVarAir   stateInitial&#13;
      in undefined rangeNoAir rangeConstAir rangeVarAir</pre>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_305"/><strong>Exercise 16.10.</strong> Consider dropping a ball from a height of 10 meters near Earth’s surface. Use the functions we defined in this chapter to write a function that produces a list of particle states for this motion. Extra credit if you can use the <span class="literal">takeWhile</span> function to extract the particle states with <em>z</em> ≥ 0 (those in which the ball is still at or above Earth’s surface) from the infinite list.<span epub:type="pagebreak" id="page_306"/></p>&#13;
</div></body></html>