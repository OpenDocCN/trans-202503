- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OBJECTS,
    FUNCTIONS, AND TYPES</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll learn about objects, functions, and types. We’ll examine
    how to declare variables (objects with named identifiers) and functions, take
    the addresses of objects, and dereference those object pointers. Each object or
    function instance has a type. You’ve already seen some types that are available
    to C programmers. The first thing you’ll learn in this chapter is one of the last
    things that I learned: every type in C is either an object type or a function
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Entities</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *object* is storage in which you can represent values. To be precise, an
    object is defined by the C standard (ISO/IEC 9899:2024) as a “region of data storage
    in the execution environment, the contents of which can represent values,” with
    the added note, “when referenced, an object can be interpreted as having a particular
    type.” A variable is an example of an object.
  prefs: []
  type: TYPE_NORMAL
- en: '*Variables* have a declared *type* that tells you the kind of object its value
    represents. For example, an object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    contains an integer value. Type is important because the collection of bits that
    represent one type of object can have a different value if interpreted as a different
    type of object. For example, the number 1 is represented in the IEEE Standard
    for Floating-Point Arithmetic by the bit pattern <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3f800000</samp>
    (IEEE 754-2019). But if you were to interpret this same bit pattern as an integer,
    you’d get the value 1,065,353,216 instead of 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Functions* are not objects but do have types. A function type is characterized
    by both its return type and the number and types of its parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: The C language also has *pointers*, which can be thought of as an *address*—a
    location in memory where an object or function is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Just like objects and functions, object pointers and function pointers are different
    things and must not be interchanged. In the following section, you’ll write a
    simple program that attempts to swap the values of two variables to help you better
    understand objects, functions, pointers, and types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Declaring Variables</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you declare a variable, you assign it a type and provide it a name, or
    *identifier*, by which the variable is referenced. Optionally, you can also *initialize*
    the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-1](chapter2.xhtml#Lis2-1) declares two integer objects with initial
    values. This simple program also declares, but doesn’t define, a <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function to swap those values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: A program meant
    to swap two integers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This example program shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function with a single *compound statement* that includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    characters and all the statements between them (also referred to as a *block*).
    We define two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, within the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function. We declare the variables as having the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and initialize them to <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>, respectively. Each
    variable must have a declaration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function then calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function ❷ to try to swap the values of the two integers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function is declared in this program ❶ but not defined. We’ll look at some possible
    implementations of this function later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Swapping Values,
    First Attempt</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each object has a storage duration that determines its *lifetime*, which is
    the time during program execution for which the object exists, has storage, has
    a constant address, and retains its last-stored value. Objects must not be referenced
    outside their lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables such as <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> from [Listing 2-1](chapter2.xhtml#Lis2-1)
    have *automatic storage duration*, meaning that they exist until execution leaves
    the block in which they’re declared. We’re going to try to swap the values stored
    in these two variables. [Listing 2-2](chapter2.xhtml#Lis2-2) shows our first attempt
    to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: A first attempt
    at implementing the</samp> <samp class="I">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function is declared
    with two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, that we use to pass arguments
    to this function. C distinguishes between *parameters*, which are objects declared
    as part of the function declaration that acquire a value on entry to the function,
    and *arguments*, which are comma-separated expressions we include in the function
    call expression. We also declare a temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function and initialize it
    to the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. This variable
    is used to temporarily save the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    so that it’s not lost during the swap.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the generated executable to test the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This result may be surprising. The variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> were initialized to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>,
    respectively. The first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    within the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function
    shows that these two values were swapped, but the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> shows the original
    values unchanged. Let’s examine what happened.
  prefs: []
  type: TYPE_NORMAL
- en: C is a *call-by-value* (also called a *pass-by-value*) language, which means
    that when you provide an argument to a function, the value of that argument is
    copied into a distinct variable for use within the function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function assigns the values of the objects you pass as arguments to their respective
    parameters. When the parameter values in the function are changed, the argument
    values in the caller are unaffected because they are distinct objects. Consequently,
    the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> retain their original values
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> during the second
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>. The goal
    of the program was to swap the values of these two objects. By testing the program,
    we’ve discovered it has a bug, or defect.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Swapping Values,
    Second Attempt</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To repair this bug, we can use pointers to rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function. We use the indirection (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>)
    operator to both declare pointers and dereference them, as shown in [Listing 2-3](chapter2.xhtml#Lis2-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: The revised</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    using pointers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When used in a function declaration or definition, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    acts as part of a pointer declarator indicating that the parameter is a pointer
    to an object or function of a specific type. In the rewritten <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function, we declare two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>, both having the type
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator denotes
    indirection. If its operand has type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    the result of the operation has type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    For example, consider the following assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This replaces the value of the pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    with the value of the pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>.
    Now consider the assignment in the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">*pb</samp> operation reads
    the value referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>,
    while the <samp class="SANS_TheSansMonoCd_W5Regular_11">*pa</samp> operation reads
    the location referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>.
    The value referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>
    is then written to the location referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, you must
    also place an ampersand (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    character before each variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> (*address-of*)
    operator generates a pointer to its operand. This change is necessary because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function now accepts
    arguments of type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    instead of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-4](chapter2.xhtml#Lis2-4) shows the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    program with comments describing the objects created during execution of this
    code and their values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: A simulated call
    by reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Upon entering the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function block, the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are initialized to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>,
    respectively. The code then takes the addresses of these objects and passes them
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function,
    the parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pb</samp> are now both declared as type
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and contain
    copies of the arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    from the calling function (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>).
    These address copies still refer to the exact same objects, so when the values
    of their referenced objects are swapped in the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function, the contents of the original objects declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    are also swapped. This approach simulates *call by* reference (also known as *pass
    by* reference) by generating object addresses, passing those by value, and then
    dereferencing the copied addresses to access the original objects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Object Types</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section introduces object types in C. Specifically, we’ll cover the Boolean
    type, character types, and arithmetic types (including both integer and floating
    types).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boolean</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Boolean data type has one of two possible values (<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>) that represent
    the two truth values of logic and Boolean algebra. Objects declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    can store only the values <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example declares a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp>
    that takes a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> argument
    and returns a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_missile</samp> function
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp> function
    and assigns the return value to the Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">armed</samp>.
    This value can then be tested to determine whether the missile is armed.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, Boolean values were represented by integers and still behave as
    integers. They can be stored in integer variables and used anywhere integers would
    be valid, including in indexing, arithmetic, parsing, and formatting. C guarantees
    that any two true values will compare equally (which was impossible to achieve
    before the introduction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    type). You should use the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    type to represent Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C language defines the following character types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. Each compiler implementation defines <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    to have the same alignment, size, range, representation, and behavior as either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. Regardless of the choice made, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is a separate type from the other two and is incompatible with both.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type is commonly
    used to represent character data in C language programs. Objects of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> can represent the *basic execution
    character set*—the minimum set of characters required in the execution environment—including
    upper- and lowercase letters, the 10 decimal digits, the space character, punctuation,
    and control characters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type is inappropriate for integer data; use <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> to represent small, signed integer values, and use <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> to represent small, unsigned integer values.
  prefs: []
  type: TYPE_NORMAL
- en: The size of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is always 1 byte, and its width is <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>
    bits. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> macro
    from <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp> defines the
    number of bits in a byte. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>
    macro cannot be less than 8, and on most modern platforms, it is 8.
  prefs: []
  type: TYPE_NORMAL
- en: The basic execution character set suits the needs of many conventional data
    processing applications, but its lack of non-English letters is an obstacle to
    acceptance by international users. To address this need, the C standards committee
    specified a new wide type to allow large character sets. You can represent the
    characters of a large character set as *wide characters* by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type, which generally takes more space than a basic character. Typically, implementations
    choose 16 or 32 bits to represent a wide character. The C standard library provides
    functions that support both narrow and wide character types. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type was not designed to support Unicode and has consequently fallen out of favor
    for most implementations with the notable exception of Microsoft Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arithmetic</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C provides several *arithmetic types* that can be used to represent integers,
    enumerators, and floating-point values. [Chapter 3](chapter3.xhtml) covers some
    of these in more detail, but here’s a brief introduction.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Signed integer types* can be used to represent negative numbers, positive
    numbers, and zero. The standard signed integer types include <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each signed integer type, there is a corresponding *unsigned integer type*
    that uses the same amount of storage: <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long
    long int</samp>. The unsigned types can represent positive numbers and zero. These
    unsigned integer types along with type <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    make up the standard unsigned integer types.'
  prefs: []
  type: TYPE_NORMAL
- en: Except for <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> itself,
    the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> may be omitted
    in the declarations for these types, so you might, for example, declare a type
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The signed and unsigned integer types are used to represent integers of various
    widths. Each platform determines the width for each of these types, given some
    constraints. Each type has a minimum representable range. The types are ordered
    by width, guaranteeing that wider types are at least as large as narrower types.
    This means that an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long int</samp> can represent all values that an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> can represent, an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> can represent all values that can be represented by an object of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and so forth. The implementation-defined
    minimum and maximum representable values for integer types are specified in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp> header file.
  prefs: []
  type: TYPE_NORMAL
- en: '*Extended integer types* may be provided in addition to the standard integer
    types. They are implementation defined, meaning that their width, precision, and
    behavior are up to the compiler. Extended integer types are typically larger than
    the standard integer types (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">__int128</samp>).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the standard and extended integer types, C23 adds *bit-precise
    integer types*. These types accept an operand specifying the width of the integer,
    so a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp> is a signed
    32-bit integer, and an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    _BitInt(32)</samp> is an unsigned 32-bit integer. Bit-precise integer types do
    not require their width to be a power of two; the maximum width supported is specified
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp> (which
    must be at least the same as the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type is typically
    assigned the natural width suggested by the architecture of the execution environment
    (for example, 16 bits on a 16-bit architecture and 32 bits on a 32-bit or 64-bit
    architecture). You can specify actual-width integers by using type definitions
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdint.h></samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><inttypes.h></samp> header, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>. These headers also provide
    type definitions for the greatest-width integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">uintmax_t</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>
    type, for example, can represent any value of any signed integer type with the
    possible exceptions of signed bit-precise integer types and of signed extended
    integer types.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](chapter3.xhtml) covers integer types in excruciating detail.  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_B_11">enum</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'An *enumeration*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>,
    allows you to define a type that assigns names (*enumerators*) to integer values
    in cases with an enumerable set of constant values. The following are examples
    of enumerations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t specify a value to the first enumerator with the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operator, the value of its enumeration constant is 0, and each subsequent enumerator
    without an <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> adds 1 to the
    value of the previous enumeration constant. Consequently, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">sun</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">day</samp> enumeration is
    0, <samp class="SANS_TheSansMonoCd_W5Regular_11">mon</samp> is 1, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: You can also assign specific values to each enumerator, as shown by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cardinal_points</samp> enumeration. Using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> with enumerators may produce
    enumeration constants with duplicate values, which can be a problem if you incorrectly
    assume that all the values are unique. The <samp class="SANS_TheSansMonoCd_W5Regular_11">months</samp>
    enumeration sets the first enumerator at 1, and each subsequent enumerator that
    isn’t specifically assigned a value will be incremented by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with C23, you can specify the underlying type of the enumeration.
    For portability and other reasons (Meneide and Pygott 2022), it is always better
    to specify the enumeration type. In the following example, the enumeration constant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a0</samp> can be assigned the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFFFFFFFFFFFFULL</samp> because
    the type is specified as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An omitted type is implementation defined. Visual C++ uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> for the type, and GCC uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Floating-point arithmetic is similar to, and often used as a model for, the
    arithmetic of real numbers. The C language supports a variety of floating-point
    representations including, on most systems, representations in the IEEE Standard
    for Floating-Point Arithmetic (IEEE 754-2019). ISO/IEC 60559:2011 has content
    identical to IEEE 754-2019 but is referenced by the C standard because it is published
    by the same standards organization. The choice of floating-point representation
    is implementation defined. [Chapter 3](chapter3.xhtml) covers floating types in
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C language supports three standard floating types: <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>. The set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    is a subset of the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>;
    the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    is a subset of the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: C23 adds three *decimal floating types* (ISO/IEC TS 18661-2:2015), designated
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>. Respectively,
    these have the decimal32, decimal64, and decimal128 IEC 60559 formats.
  prefs: []
  type: TYPE_NORMAL
- en: The standard floating types and the decimal floating types are collectively
    called the *real floating types*.
  prefs: []
  type: TYPE_NORMAL
- en: There are also three *complex types*, designated as <samp class="SANS_TheSansMonoCd_W5Regular_11">float
    complex</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double complex</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double complex</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The real floating and complex types are collectively called the *floating types*.
    [Figure 2-1](chapter2.xhtml#fig2-1) shows the hierarchy of floating types.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f02001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The hierarchy of
    floating types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Complex types and decimal floating types are not covered in detail in this book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type is a rather
    strange type. The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    (by itself) means “cannot hold any value.” For example, you can use it to indicate
    that a function doesn’t return a value or as the sole parameter of a function
    to indicate that the function takes no arguments. On the other hand, the *derived
    type* <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> means that the
    pointer can reference *any* object.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Derived Types</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Derived types* are constructed from other types. These include function types,
    pointer types, array types, type definitions, structure types, and union types—all
    of which are covered here.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *function type* is derived from the return type and the number and types of
    its parameters. A function can return any complete object type except for an array
    type.
  prefs: []
  type: TYPE_NORMAL
- en: When you declare a function, you use the *function declarator* to specify the
    name of the function and the return type. If the declarator includes a parameter
    type list and a definition, the declaration of each parameter must include an
    identifier, except parameter lists with only a single parameter of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, which needs no identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few function type declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">fprime</samp>, with no parameter
    that returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Next,
    we declare a function <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>
    with no parameters that return a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Finally, we declare two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, each returning <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and taking two parameters
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying parameters with identifiers (as done here with <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>)
    can be problematic if an identifier is a macro. However, providing parameter names
    is good practice for self-documenting code, so omitting the identifiers (as done
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>) is not typically
    recommended.
  prefs: []
  type: TYPE_NORMAL
- en: In a function declaration, specifying parameters is optional. However, failing
    to do so can be problematic. Prior to C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>
    declares a function accepting any number of arguments of any type and returning
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. The same function
    declaration for <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp> in C++
    declares a function accepting no arguments and returning an <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. Starting with C23, a function declarator with an empty parameter list
    declares a prototype for a function that takes no arguments (like it does in C++).
  prefs: []
  type: TYPE_NORMAL
- en: A function type is also known as a *function prototype*. A function prototype
    informs the compiler about the number and types of parameters a function accepts.
    Compilers use this information to verify that the correct number and type of parameters
    are used in the function definition and any calls to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *function definition* provides the actual implementation of the function.
    Consider the following function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type specifier is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>;
    the function declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">max(int
    a, int b)</samp>; and the function body is <samp class="SANS_TheSansMonoCd_W5Regular_11">{return
    a > b ? a : b;}</samp>. The specification of a function type must not include
    any type qualifiers (see “Type Qualifiers” on [page 31](#pg_31)). The function
    body itself uses the conditional operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>), which is explained in [Chapter 4](chapter4.xhtml). This expression
    states that if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is greater
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, return <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>;
    otherwise, return <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *pointer type* is derived from a function or object type called the *referenced
    type*. A pointer type derived from the referenced type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is called a *pointer to* <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    A pointer provides a reference to an entity of the referenced type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three declarations declare a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, and a
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Each pointer is initialized to a null pointer constant. A null pointer constant
    can be specified as an integer constant expression with the value 0, <samp class="SANS_TheSansMonoCd_W5Regular_11">(void
    *)0</samp>, or the predefined constant <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> macro is defined
    in <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>. If a null
    pointer constant is converted to a pointer type, the resulting null pointer is
    guaranteed to compare unequally to a pointer to any object or function.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> constant was
    introduced in C23 and has advantages to using <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    (Gustedt 2022). [Table 2-1](chapter2.xhtml#tab2-1) shows common values for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> and their associated types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Values for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> <samp
    class="SANS_Futura_Std_Book_11">and Their Associated Types</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0L</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">(void *)0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'These different types can have surprising results when invoking a type-generic
    macro with a <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> argument.
    The conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(true
    ? 0 : NULL)</samp> is always defined, regardless of the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>.
    However, the conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(true
    ? 1 : NULL)</samp> is a constraint violation if <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    has type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> argument passed
    as a sentinel value to a variadic function, such as the Portable Operating System
    Interface (POSIX) <samp class="SANS_TheSansMonoCd_W5Regular_11">execl</samp> function,
    which expects a pointer, can have unexpected results. On most modern architectures,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> types have different sizes. If <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    is defined as 0 on such an architecture, an incorrectly sized argument is passed
    to the variadic function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in the chapter, I introduced the address-of (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    and indirection (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>) operators.
    You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator to
    take the address of an object or function. For example, taking the address of
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object results in
    an address with the type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The second declaration declares the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp>
    as a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and initializes
    it to the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. You
    can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator
    on the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp> using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator resolves to
    the actual object <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. Taking
    the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">*ip</samp> using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator retrieves
    the pointer, so these two operations cancel each other out.
  prefs: []
  type: TYPE_NORMAL
- en: The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator converts
    a pointer to a type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> into
    a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. It denotes
    *indirection* and operates only on pointers. If the operand points to a function,
    the result of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    operator is the function designator, and if it points to an object, the result
    is a value of the designated object. For example, if the operand is a pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, the result of the
    indirection operator has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    If the pointer is not pointing to a valid object or function, the behavior is
    undefined.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An *array* is a contiguously allocated sequence of objects that all have the
    same element type. Array types are characterized by their element types and the
    number of elements in the array. Here we declare an array of 11 elements of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">ia</samp>
    and an array of 17 elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">pointer</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> identified by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">afp</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>)
    to identify an element of an array. For example, the following contrived code
    snippet creates the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>
    to demonstrate how to assign values to the elements of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first line declares an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    with a bound of 11\. This allocates sufficient storage to create a string with
    10 characters plus a null character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates 10 times, with the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    ranging from 0 to 9\. Each iteration assigns the result of the expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'0'</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>.
    Following the end of the loop, the null character is copied to the final element
    of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">str[10]</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> now contains the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is automatically converted
    to a pointer to the first member of the array (pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>),
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> has an unsigned integer
    type. The subscript (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>)
    and addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) operators
    are defined so that <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>
    is identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(str</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>.
    When <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is an array object
    (as it is here), the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>
    designates the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>th element
    of the array (counting from 0). Because arrays are indexed starting at 0, the
    array <samp class="SANS_TheSansMonoCd_W5Regular_11">char str[11]</samp> is indexed
    from 0 to 10, with 10 being the last element, as referenced on the last line of
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the operand of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator is the result of a <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    operator, the result is as if the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator were removed and the <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    operator were changed to a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">&str[10]</samp>
    is the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can also declare multidimensional arrays. [Listing 2-5](chapter2.xhtml#Lis2-5)
    declares <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> in the function
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> as a two-dimensional
    3×5 array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, also
    referred to as a *matrix*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: Matrix operations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'More precisely, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is
    an array of three elements, each of which is an array of five elements of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. When you use the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp> ❶ (which is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(arr+i)</samp>), the following
    occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is converted to
    a pointer to the initial array of five elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is scaled to the
    type of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> by multiplying
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> by the size of one array
    of five <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The results from steps 1 and 2 are added.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Indirection is applied to the sum to produce an array of five elements of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: When used in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>
    ❷, that array is converted to a pointer to the first element of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    so <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp> produces an
    object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *structure type* (also known as a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>)
    contains sequentially allocated members. Each member has its own name and may
    have a distinct type—unlike array elements, which must all be of the same type.
    Structures are like record types found in other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Structures are useful for declaring collections of related objects and may be
    used to represent things such as a date, customer, or personnel record. They are
    especially useful for grouping objects that are frequently passed together as
    arguments to a function, so you don’t need to repeatedly pass individual objects
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-6](chapter2.xhtml#Lis2-6) declares a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> with type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct sigrecord</samp> and a pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct sigrecord</samp> named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: A</samp> <samp
    class="I">struct sigrecord</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure has three member objects: <samp class="SANS_TheSansMonoCd_W5Regular_11">signum</samp>
    is an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signame</samp> is an array of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> consisting of 20 elements,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sigdesc</samp> is an array of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> consisting of 100
    elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have defined a structure, you’ll likely want to reference its members.
    You reference members of an object of the structure type by using the structure
    member (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) operator. If you
    have a pointer to a structure, you can reference its members with the structure
    pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>) operator. [Listing
    2-7](chapter2.xhtml#Lis2-7) demonstrates the use of each operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: Referencing structure
    members</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first three lines of [Listing 2-7](chapter2.xhtml#Lis2-7) directly access
    members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> object
    by using the dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) operator.
    We assign the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp>
    object to the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> pointer
    ❶. In the final three lines of the program, we indirectly access the members of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> object by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator through the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> pointer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Union</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Union types* are like structures, except that the memory used by the member
    objects overlaps. Unions provide multiple different ways to look at the same memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-8](chapter2.xhtml#Lis2-8) shows a union that contains a single member
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> that contains
    three bitfields of type <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">significand</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">exponent</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sign</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: Decomposing a</samp>
    <samp class="I">float</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">using
    a</samp> <samp class="I">union</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This allows a (low-level) C programmer to use the entire floating-point value
    and examine (and possibly modify) its constituent parts. This union is not portable
    because implementations may use a different floating-point representation or endianness.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> tests to
    ensure this union matches the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-9](chapter2.xhtml#Lis2-9) shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    n</samp> that contains a member <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    and a union <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> that itself
    contains four members: <samp class="SANS_TheSansMonoCd_W5Regular_11">inode</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fnode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ldnode</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: Saving memory
    with a union</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This structure might be used in a tree, a graph, or some other data structure
    that contains differently typed nodes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    member might contain a value between 0 and 3, which indicates the type of the
    value stored in the structure. It is declared directly in the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    n</samp> because it is common to all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: As with structures, you can access union members via the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator. Using a pointer to a union, you can reference its members with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator. In [Listing 2-9](chapter2.xhtml#Lis2-9),
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp> member is referenced
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>. Code that uses
    this union will typically check the type of the node by examining the value stored
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp> and then accessing
    the value using <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.inode</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.fnode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.ldnode</samp>, depending
    on the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp>.
    Without the union, each node would contain separate storage for all four data
    types. The use of a union allows the same storage to be used for all union members.
    On the x86-64 GCC version 13.2 compiler, using a union saved 16 bytes per node.
  prefs: []
  type: TYPE_NORMAL
- en: Unions are commonly used to describe network or device protocols in cases where
    you do not know in advance which protocol will be used.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Tags</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Tags* are a special naming mechanism for structures, unions, and enumerations.
    For example, the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    in the following structure is a tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By itself, a tag is not a type name and cannot be used to declare a variable
    (Saks 2002). Instead, you must declare variables of this type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The names of unions and enumerations are also tags and not types, meaning that
    they cannot be used alone to declare a variable. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The tags of structures, unions, and enumerations are defined in a separate
    *namespace* from ordinary identifiers. This allows a C program to have both a
    tag and another identifier with the same spelling in the same scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even declare an object <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This may not be good practice, but it is valid C. You can think of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    tags as type names and define an alias for the tag by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This now allows you to declare variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>. The
    tag name in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">union</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    is optional, so you can just dispense with it entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This works fine except in the case of self-referential structures that contain
    pointers to themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: C requires the use of tag types (<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>)
    to include the tag name. The compiler will emit a diagnostic if you do not use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct tnode</samp> in the declaration
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>
    pointers. Consequently, you must declare a tag for the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an alias for the structure using a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> pointers must still
    use the tag name because the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    name is not introduced until after the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    declaration is complete. You can use the same name for the tag and the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>,
    but a common idiom is to name the tag something ugly such as <samp class="SANS_TheSansMonoCd_W5Regular_11">tnode_</samp>
    to encourage programmers to use the type name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define this type before the structure so that you can use it to
    declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">right</samp> members that refer to other
    objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">tnode</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Type definitions can improve code readability beyond their use with structures.
    For example, given the following type definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'these declarations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp>
    function all specify the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The last two declarations are clearly easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Qualifiers</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the types examined so far have been unqualified types. You can qualify
    types by using one or more of the following qualifiers: <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>.
    Each of these qualifiers changes behaviors when accessing objects of the qualified
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: The qualified and unqualified versions of types can be used interchangeably
    as arguments to functions, return values from functions, and structure and union
    members.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp> *type qualifier,
    available since C11, supports concurrent programs.*'
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">const</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    qualifier (<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    types) are not assignable but can have constant initializers. This means the compiler
    can place objects with <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    types in read-only memory, and any attempt to write to them will result in a runtime
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to accidentally convince your compiler to change a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object for you. In the following example, we take the address of a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and tell the compiler
    that it’s actually a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: C does not allow you to cast away the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    if the original was declared as a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object. This code might appear to work, but it’s defective and may fail later.
    For example, the compiler might place the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object in read-only memory, causing a memory fault when trying to store a value
    in the object at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'C allows you to modify an object that is referenced by a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    pointer by casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    away, provided that the original object was not declared <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Be careful not to pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    pointer to a function that modifies the object.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">volatile</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects are given a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    type to allow for processes that are *extrinsic* to the compiler. The values stored
    in these objects may change without the knowledge of the compiler, or a write
    may synchronize externally. For example, every time the value from a real-time
    clock is read, it may change, even if the value has not been written to by the
    C program. Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    type lets the compiler know that the value may change without its knowledge and
    ensures that every access to the real-time clock occurs. Otherwise, an access
    to the real-time clock may be optimized away or replaced by a previously read
    and cached value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified type
    can be used to access memory-mapped registers, which are accessed through an address
    just like any other memory. Input/output (I/O) devices often have memory-mapped
    registers, where you can write to, or read from, a specific address to set or
    retrieve information or data. Each read and write operation must occur, even if
    the compiler can see no reason for it. Declaring an object as <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>
    ensures that each read or write of that object at runtime occurs the same number
    of times and in the same order as indicated by the source code. For example, if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp> is defined as a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the compiler must generate instructions to read the value from <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>
    and then write this value back to <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>
    in the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> qualification,
    the compiler would see this as a no-op (a programming statement that does nothing)
    and might eliminate both the read and the write. Reads and writes of volatile
    memory are touched exactly once. A volatile operation cannot be eliminated or
    fused with a subsequent one, even if the compiler believes it’s useless. A volatile
    operation cannot be speculated, even if the compiler can undo or otherwise make
    that speculation benign.
  prefs: []
  type: TYPE_NORMAL
- en: Objects with <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    types are used when a compiler is not aware of external interactions. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified types
    can be used for memory shared with untrusted code to avoid time-of-check to time-of-use
    (ToCToU) vulnerabilities. Such types are used to access objects from a signal
    handler and with <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp> (refer to the C standard
    for information on signal handlers and <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp>). Unlike Java and other
    programming languages, <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    types should not be used in C for synchronization between threads.
  prefs: []
  type: TYPE_NORMAL
- en: Memory-mapped I/O ports are modeled by a <samp class="SANS_TheSansMonoCd_W5Regular_11">static
    volatile</samp>–qualified objects model. Memory-mapped input ports such as a real-time
    clock are modeled by <samp class="SANS_TheSansMonoCd_W5Regular_11">static const
    volatile</samp>–qualified objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    volatile</samp>–qualified object models a variable that can be altered by a separate
    thread. The meaning of the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    storage-class specifier is explained later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">restrict</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified pointer
    is used to promote optimization. Objects indirectly accessed through a pointer
    frequently cannot be fully optimized because of potential aliasing, which occurs
    when more than one pointer refers to the same object. Aliasing can inhibit optimizations
    because the compiler can’t tell whether an object can change values when another
    apparently unrelated object is modified, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function copies <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    bytes from the storage referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    to the storage referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>.
    The function parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> are both <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified
    pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Because both <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">q</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified
    pointers, the compiler can assume that an object accessed through one of the pointer
    parameters is not also accessed through the other. The compiler can make this
    assessment based solely on the parameter declarations without analyzing the function
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Although using <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified
    pointers can result in more efficient code, you must ensure that the pointers
    do not refer to overlapping memory to prevent undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Scope</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects, functions, macros, and other C language identifiers have *scope* that
    delimits the contiguous region where they can be accessed. C has four types of
    scope: file, block, function prototype, and function.'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of an object or function identifier is determined by where it is declared.
    If the declaration is outside any block or parameter list, the identifier has
    *file scope*, meaning its scope is the entire text file in which it appears as
    well as any included files.
  prefs: []
  type: TYPE_NORMAL
- en: If the declaration appears inside a block or within the list of parameters,
    it has *block scope*, meaning that the identifier is accessible only from within
    the block. The identifiers for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> from [Listing 2-4](chapter2.xhtml#Lis2-4)
    have block scope and can be referenced only from within the code block in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function in which they’re
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: If the declaration appears within the list of parameter declarations in a function
    prototype (not part of a function definition), the identifier has *function prototype
    scope*, which terminates at the end of the function declarator. *Function scope*
    is the area between the opening <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>of
    a function definition and its closing}. A label name is the only kind of identifier
    that has function scope. *Labels* are identifiers followed by a colon, and they
    identify a statement in the same function to which control may be transferred.
    ([Chapter 5](chapter5.xhtml) covers labels and control transfer.)
  prefs: []
  type: TYPE_NORMAL
- en: Scopes also can be *nested*, with *inner* and *outer* scopes. For example, you
    can define a block scope inside another block scope, and every block scope is
    defined within a file scope. The inner scope has access to the outer scope, but
    not vice versa. As the name implies, any inner scope must be completely contained
    within any outer scope that encompasses it.
  prefs: []
  type: TYPE_NORMAL
- en: If you declare the same identifier in both an inner scope and an outer scope,
    the identifier declared in the outer scope is *hidden* (also known as *shadowed*)
    by the identifier declared in the inner scope. Referencing the identifier from
    the inner scope will refer to the object in the inner scope; the object in the
    outer scope is hidden and cannot be referenced by its name. The easiest way to
    prevent this from becoming a problem is to use different names. [Listing 2-10](chapter2.xhtml#Lis2-10)
    demonstrates different scopes and how identifiers declared in inner scopes can
    hide identifiers declared in outer scopes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Identifiers declared
    in inner scopes hiding identifiers declared in outer scopes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing wrong with this code, provided the comments accurately describe
    your intent. However, it’s better to use different names for different identifiers
    to avoid confusion, which leads to bugs. Using short names such as <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is fine for identifiers
    with small scopes. Identifiers in large scopes should have longer, descriptive
    names that are unlikely to be hidden in nested scopes. Some compilers will warn
    about hidden identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Storage Duration</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects have a storage duration that determines their lifetime. Four storage
    durations are available: automatic, static, thread, and allocated. You’ve already
    seen that objects declared within a block or as a function parameter have automatic
    storage duration. The lifetime of these objects starts when the block in which
    they’re declared begins execution and ends when execution of this block completes.
    If the block is entered recursively, a new object is created each time the block
    is entered, and each object has its own storage.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Scope and lifetime are entirely different concepts. Scope applies to identifiers,
    whereas lifetime applies to objects. The scope of an identifier is the code region
    where the object denoted by the identifier can be accessed by its name. The lifetime
    of an object is the period for which the object exists.*'
  prefs: []
  type: TYPE_NORMAL
- en: Objects declared in file scope have *static* storage duration. The lifetime
    of those objects is the entire execution of the program, and their stored value
    is initialized prior to program startup.
  prefs: []
  type: TYPE_NORMAL
- en: '*Thread* storage duration is used in concurrent programming and is not covered
    in this book. *Allocated* storage duration involves dynamically allocated memory
    and is discussed in [Chapter 6](chapter6.xhtml). Finally, as described in the
    next section, a storage-class specifier can determine or influence storage duration.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Storage Class</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can specify the storage class of an object or functions using storage-class
    specifiers. For C23, these include <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class
    specifier is new in C23, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    storage-class specifier is significantly changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Storage-class specifiers specify various properties of identifiers and declared
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Storage duration: <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    in block scope, <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linkage: <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    in file scope, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Value: <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type: <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a few exceptions, only one storage-class specifier is allowed for each
    declaration. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    may appear with all the others except <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">static</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> storage-class
    specifier is used to specify both storage duration and linkage.
  prefs: []
  type: TYPE_NORMAL
- en: File scope identifiers specified as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>, or functions
    specified as static, have <samp class="SANS_TheSansMonoCd_W5Regular_11">internal</samp>
    linkage.
  prefs: []
  type: TYPE_NORMAL
- en: You can also declare a variable with block scope to have static storage duration
    by using the storage-class specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>,
    as shown in the counting example in [Listing 2-11](chapter2.xhtml#Lis2-11). These
    objects persist after the function has exited.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: A counting example</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This program outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">1 2 3 4 5</samp>.
    The static variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    is initialized to 0 once at program startup and incremented each time the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">increment</samp> function is called. The
    lifetime of <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> is the
    entire execution of the program, and it will retain its last-stored value throughout
    its lifetime. You could achieve the same behavior by declaring <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    with file scope. However, it’s good software engineering practice to limit the
    scope of an object whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">extern</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier specifies
    static storage duration and external linkage. It can be used with function and
    object declarations in both file and block scope (but not function parameter lists).
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> is specified for
    the redeclaration of an identifier that has already been declared with internal
    linkage, the linkage remains internal. Otherwise (if the prior declaration was
    external, has no linkage, or is not in scope), the linkage is external.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">thread_local</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An object whose identifier is declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>
    storage-class specifier has *thread storage duration*. Its initializer is evaluated
    prior to program execution, its lifetime is the entire execution of the thread
    for which it is created, and its stored value is initialized with the previously
    determined value when the thread is started. There is a distinct object per thread,
    and use of the declared name in an expression refers to the object associated
    with the thread evaluating the expression. (The topic of threading is beyond the
    scope of this book.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">constexpr</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A scalar object declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    storage-class specifier is a constant and has its value permanently fixed at translation
    time. The <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class
    specifier may appear with <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>.
    If not already present, a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    qualification is implicitly added to the object’s type. The resulting object cannot
    be modified at runtime in any way. The compiler can then use this value in any
    other constant expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the constant expression used for the initializer of such a constant
    is checked at compile time. Before the introduction of <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    in C23, a very large object constant might be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The initializer may or may not fit into <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>;
    a diagnostic is not required. In C23, this same object can be declared using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now, a diagnostic is required on implementations where <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    has a width of 32 or less.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static objects must be initialized with a constant value and not a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic constant expressions are allowed in initializers. Constant values
    are literal constants (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> members, a scalar object
    declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    storage-class specifier, and the result of operators such as <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> (provided the operand
    does not have a variable-length array type). Unfortunately, <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    objects are not constant values. Starting with C23, an implementation may accept
    other forms of constant expressions; it is implementation defined whether they
    are integer constant expressions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">register</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp> storage-class
    specifier suggests that access to an object be as fast as possible. The extent
    to which such suggestions are effective is implementation defined. Frequently,
    compilers can make better decisions about register allocation and ignore these
    programmer suggestions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>
    storage class can be used only for an object that never has its address taken.
    A compiler can treat any register declaration simply as an <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    declaration. However, whether addressable storage is used, the address of any
    part of an object declared with a storage-class specifier register cannot be computed,
    either explicitly by use of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator or implicitly by converting an array name to a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">typedef</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> storage-class
    specifier defines an identifier to be a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    name that denotes the type specified for the identifier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    storage-class specifier was discussed earlier in the “Type Definitions” box.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">auto</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    specifier was allowed only for objects declared at block scope (except function
    parameter lists). It indicates automatic storage duration and no linkage, which
    are the defaults for these kinds of declarations.
  prefs: []
  type: TYPE_NORMAL
- en: C23 introduced type inference into the C language by expanding the definition
    of the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage-class
    specifier. Prior to C23, declaring a variable in C requires the user to name a
    type. However, when the declaration includes an initializer, the type can be derived
    directly from the type of the expression used to initialize the variable. This
    has been a C++ feature since 2011.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier has similar behavior to C++ in that it allows the type to be inferred
    from the type of the assignment value. Take the following file scope definitions,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the integer literal <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    has an implicit type of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    these declarations are interpreted as if they had been written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Effectively, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. Type inference
    is extremely useful when implementing or invoking type-generic macros, as we’ll
    see in [Chapter 9](chapter9.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">typeof Operators</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operators <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operators can operate on an expression or a type name and yield the type of their
    operand. If the type of the operand is a variably modified type, the operand is
    evaluated; otherwise, the operand is not evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier both perform automatic type inference. They can both be used to
    determine the type of expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier is commonly used to declare initialized variables where the type
    can be inferred from the initial value. However, to form a derived type, you must
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier cannot be used with <samp class="SANS_TheSansMonoCd_W5Regular_11">_Generic</samp>
    (described in [Chapter 9](chapter9.xhtml)) and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    (described later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator is the nonatomic, unqualified version of the type that would result from
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator preserves
    all qualifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator is
    like the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator,
    which executes the expression in an unevaluated context to understand the final
    type. You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator anywhere you can use a type name. The following example illustrates the
    use of both <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: At the first use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator ❶, the operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>,
    which has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">const int</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operator
    strips the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier,
    resulting in just plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    This use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator is illustrative and not meant for production code. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator is used again on operand <samp class="SANS_TheSansMonoCd_W5Regular_11">asi</samp>
    ❷, which has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">const _Atomic
    int</samp>. All qualifiers are once again stripped, resulting in a plain <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier at ❸ includes another <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operand is itself a <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier, the operand is evaluated before evaluating the current <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator. This evaluation happens recursively until a <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier is no longer the operand. In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier at ❸ does nothing and can be omitted. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator at ❹ is evaluated before the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator at ❸ and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator
    at ❸ is now evaluated and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    _Atomic int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator at ❺ returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    array of four <samp class="SANS_TheSansMonoCd_W5Regular_11">const char</samp>
    pointers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator at ❻ strips the qualifier and returns an array of four <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    char</samp> pointers. The qualifiers, in this case, are stripped only from the
    array and not the element types the array contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function
    is equivalent but doesn’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator to refer to a macro parameter to construct objects with the required
    types without specifying the type names explicitly as macro arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Alignment</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Object types have alignment requirements that place restrictions on the addresses
    at which objects of that type may be allocated. An *alignment* represents the
    number of bytes between successive addresses at which a given object can be allocated.
    Central processing units (CPUs) may have different behavior when accessing aligned
    data (for example, where the data address is a multiple of the data size) versus
    unaligned data.
  prefs: []
  type: TYPE_NORMAL
- en: Some machine instructions can perform multibyte accesses on nonword boundaries,
    but with a performance penalty. A *word* is a natural, fixed-sized unit of data
    handled by the instruction set or the hardware of the processor. Some platforms
    cannot access unaligned memory. Alignment requirements may depend on the CPU word
    size (typically, 16, 32, or 64 bits).
  prefs: []
  type: TYPE_NORMAL
- en: Generally, C programmers need not concern themselves with alignment requirements,
    because the compiler chooses suitable alignments for its various types. However,
    on rare occasions, you might need to override the compiler’s default choices—for
    example, to align data on the boundaries of the memory cache lines that must start
    at power-of-two address boundaries or to meet other system-specific requirements.
    Traditionally, these requirements were met by linker commands or similar operations
    involving other nonstandard facilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'C11 introduced a simple, forward-compatible mechanism for specifying alignments.
    Alignments are represented as values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>.
    Every valid alignment value is a nonnegative integral power of two. An object
    type imposes a default alignment requirement on every object of that type: a stricter
    alignment (a larger power of two) can be requested using the alignment specifier
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">alignas</samp>). You can include
    an alignment specifier in a declaration. [Listing 2-12](chapter2.xhtml#Lis2-12)
    uses the alignment specifier to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp>
    is properly aligned (<samp class="SANS_TheSansMonoCd_W5Regular_11">bad_buff</samp>
    may have incorrect alignment for member-access expressions).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-12: Use of the</samp>
    <samp class="I">alignas</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">keyword</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Although <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp> has
    proper alignment to be accessed through an lvalue of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    S</samp>, this program still has undefined behavior. This undefined behavior stems
    from the underlying object <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp>
    being declared as an array of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and being accessed through an lvalue of a different type. The cast
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">(struct S *)</samp>, like any
    pointer cast, doesn’t change the effective type of the storage allocated to each
    array. Because it is an established practice to use areas of character type for
    low-level storage management, I co-authored a paper to make such code conforming
    in a future revision of the C standard (Seacord et al. 2024).
  prefs: []
  type: TYPE_NORMAL
- en: Alignments are ordered from weaker to stronger (also called *stricter*) alignments.
    Stricter alignments have larger alignment values. An address that satisfies an
    alignment requirement also satisfies any valid, weaker alignment requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Alignment of dynamically allocated memory is covered in [Chapter 6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variably Modified Types</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variably modified types (VMTs) define a base type and an extent (number of elements),
    which is determined at runtime. VMTs are a mandatory feature of C23.
  prefs: []
  type: TYPE_NORMAL
- en: 'VMTs can be used as function parameters. Remember from earlier in this chapter
    that, when used in an expression, an array is converted to a pointer to the first
    element of the array. This means that we must add an explicit parameter to specify
    the size of the array—for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    parameter in the signature for <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When you call such a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    should accurately represent the size of the array referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>.
    Undefined behavior results if this size is larger than the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'When declaring a function to take an array as an argument that specifies a
    size, we must declare the size of the array before referencing the size in the
    array declaration. We could, for example, modify the signature for the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function as follows to take the number of elements <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    and an array of at least <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For arrays of character type, the number of elements is equal to the size. In
    this function signature, <samp class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp>
    is a variably modified type because <samp class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp>
    depends on the runtime value of <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve changed the order of the parameters so that the size parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    is declared before we use it in the array declaration. The array argument <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is still adjusted to a pointer,
    and no storage is allocated because of this declaration (except for the pointer
    itself). When calling this function, you must declare the actual storage for the
    array referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> and
    ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is a valid
    size for it. Just like a non-VMT parameter, the actual array storage may be a
    fixed-size array, variable-length array (covered in [Chapter 6](chapter6.xhtml)),
    or dynamically allocated storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'VMTs can generalize your functions, making them more useful. For example, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp> function sums
    all the values in a two-dimensional array. The following version of this function
    accepts a matrix with a fixed column size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: When passing a multidimensional array to a function, the number of elements
    in the initial dimension of the array (the rows) is lost and needs to be passed
    in as an argument. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp>
    parameter provides this information in this example. You can call this function
    to sum the values of any matrix with exactly four columns, as shown in [Listing
    2-13](chapter2.xhtml#Lis2-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-13: Summing matrices
    with four columns</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is fine until you need to sum the values of a matrix that does not have
    four columns. For example, changing <samp class="SANS_TheSansMonoCd_W5Regular_11">m3</samp>
    to have five columns would result in a warning such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: To accept this argument, you would have to write a new function with a signature
    that matches the new dimensions of the multidimensional array. The problem with
    this approach, then, is that it fails to generalize sufficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of doing that, we can rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp>
    function to use a VMT, as shown in [Listing 2-14](chapter2.xhtml#Lis2-14). This
    change allows us to call <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp>
    with matrices of any dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-14: Using a VMT as
    a function parameter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler performs the matrix indexing ❶. Without VMTs, this would require
    either manual indexing or double indirection, which are both error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Again, no storage is allocated by either the function declaration or the function
    definition. As with a non-VMT parameter, you need to allocate the storage for
    the matrix separately, and its dimensions must match those passed to the function
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">cols</samp>
    arguments. Failing to do so can result in undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Attributes</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with C23, you can use *attributes* to associate additional information
    with a declaration, statement, or type. This information can be used by the implementation
    to improve diagnostics, improve performance, or modify the behavior of the program
    in other ways. A comma-delimited list of zero or more attributes is specified
    within a pair of double square brackets, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">[[foo]]</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">[[foo, bar]]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarations attributes are specified in two ways. If the attribute specifier
    is at the start of a declaration, the attributes are applied to all declarations
    in the declaration group. Otherwise, the attributes are applied to the declaration
    to the immediate left of the attribute specifier. For example, in the following
    declaration group, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    attribute is applied to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'While in the second declaration group, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> attributes are applied
    only to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: C23 defines several attributes that apply to declarations, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp> attribute is used with
    function declarations to denote that the value returned by the function is expected
    to be used within an expression or initializer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>
    attribute is used with the declaration of a function or a type to denote that
    use of the function or type should be diagnosed as discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to standard attributes, the implementation may provide nonportable
    attributes. Such attributes are also specified within double square brackets,
    but they include a vendor prefix to distinguish between attributes from different
    vendors. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[clang::overloadable]]</samp>
    attribute is used on a function declaration to specify that it can use C++-style
    function overloading in C, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[gnu::packed]]</samp>
    attribute is used on a structure declaration to specify that the member declarations
    of the structure should avoid using padding between member declarations whenever
    possible for a more space-efficient layout. Vendors typically use their own prefixes,
    and they may use whatever prefixes they choose. For example, Clang implements
    many attributes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gnu</samp>
    prefix for improved compatibility with GCC. Your compiler should ignore unknown
    attributes, although they may still be diagnosed so you know that the attribute
    has no effect. Refer to your compiler’s documentation for the full list of supported
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about objects and functions and how they differ.
    You learned how to declare objects and functions, take the addresses of objects,
    and dereference those object pointers. You also learned about most of the object
    types available to C programmers as well as derived types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll return to these types in later chapters to further explore how they can
    be best used to implement your designs. In the next chapter, I provide detailed
    information about the two kinds of arithmetic types: integers and floating-point.'
  prefs: []
  type: TYPE_NORMAL
