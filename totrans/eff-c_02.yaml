- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OBJECTS,
    FUNCTIONS, AND TYPES</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">对象、函数和类型</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In this chapter, you’ll learn about objects, functions, and types. We’ll examine
    how to declare variables (objects with named identifiers) and functions, take
    the addresses of objects, and dereference those object pointers. Each object or
    function instance has a type. You’ve already seen some types that are available
    to C programmers. The first thing you’ll learn in this chapter is one of the last
    things that I learned: every type in C is either an object type or a function
    type.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习对象、函数和类型。我们将探讨如何声明变量（具有命名标识符的对象）和函数，获取对象的地址，并解引用这些对象指针。每个对象或函数实例都有一个类型。你已经看到了一些C程序员可以使用的类型。本章中你将学到的第一件事，恰恰是我最后学到的：C中的每个类型都是对象类型或函数类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Entities</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">实体</samp>
- en: An *object* is storage in which you can represent values. To be precise, an
    object is defined by the C standard (ISO/IEC 9899:2024) as a “region of data storage
    in the execution environment, the contents of which can represent values,” with
    the added note, “when referenced, an object can be interpreted as having a particular
    type.” A variable is an example of an object.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*是用于表示值的存储空间。准确来说，C标准（ISO/IEC 9899:2024）将对象定义为“执行环境中的一个数据存储区域，其内容可以表示值”，并补充说明，“当引用时，对象可以被解释为具有特定类型。”变量就是一个对象的例子。'
- en: '*Variables* have a declared *type* that tells you the kind of object its value
    represents. For example, an object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    contains an integer value. Type is important because the collection of bits that
    represent one type of object can have a different value if interpreted as a different
    type of object. For example, the number 1 is represented in the IEEE Standard
    for Floating-Point Arithmetic by the bit pattern <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3f800000</samp>
    (IEEE 754-2019). But if you were to interpret this same bit pattern as an integer,
    you’d get the value 1,065,353,216 instead of 1.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*有一个声明的*类型*，它告诉你变量值所代表的对象类型。例如，类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的对象包含一个整数值。类型很重要，因为代表某种类型对象的比特集合，如果被解释为另一种类型的对象，可能会得到不同的值。例如，数字1在IEEE浮点运算标准中由比特模式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x3f800000</samp>表示（IEEE 754-2019）。但如果你将这个比特模式解释为一个整数，你会得到值1,065,353,216，而不是1。'
- en: '*Functions* are not objects but do have types. A function type is characterized
    by both its return type and the number and types of its parameters.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*不是对象，但它们有类型。函数类型由其返回类型以及参数的数量和类型来描述。'
- en: The C language also has *pointers*, which can be thought of as an *address*—a
    location in memory where an object or function is stored.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中也有*指针*，它可以被看作是一个*地址*——内存中存储对象或函数的位置。
- en: Just like objects and functions, object pointers and function pointers are different
    things and must not be interchanged. In the following section, you’ll write a
    simple program that attempts to swap the values of two variables to help you better
    understand objects, functions, pointers, and types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对象和函数一样，对象指针和函数指针是不同的东西，不能互换。在接下来的部分中，你将编写一个简单的程序，尝试交换两个变量的值，帮助你更好地理解对象、函数、指针和类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Declaring Variables</samp>
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">声明变量</samp>
- en: When you declare a variable, you assign it a type and provide it a name, or
    *identifier*, by which the variable is referenced. Optionally, you can also *initialize*
    the variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量时，你为它分配一个类型，并提供一个名称或*标识符*，通过该标识符引用该变量。你也可以选择性地*初始化*该变量。
- en: '[Listing 2-1](chapter2.xhtml#Lis2-1) declares two integer objects with initial
    values. This simple program also declares, but doesn’t define, a <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function to swap those values.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-1](chapter2.xhtml#Lis2-1)声明了两个具有初始值的整数对象。这个简单的程序还声明了一个`swap`函数来交换这些值，但没有定义它。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: A program meant
    to swap two integers</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-1：一个用于交换两个整数的程序</samp>
- en: This example program shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function with a single *compound statement* that includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    characters and all the statements between them (also referred to as a *block*).
    We define two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, within the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function. We declare the variables as having the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and initialize them to <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>, respectively. Each
    variable must have a declaration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function then calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function ❷ to try to swap the values of the two integers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function is declared in this program ❶ but not defined. We’ll look at some possible
    implementations of this function later in this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例程序展示了一个包含单个*复合语句*的 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数，该复合语句包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp> 字符以及其中的所有语句（也称为*块*）。我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数内定义了两个变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>。我们将这两个变量声明为类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，并分别初始化为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>。每个变量必须有一个声明。然后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数 ❷ 尝试交换这两个整数的值。<samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数在本程序中声明了
    ❶，但没有定义。我们将在本节后面探讨该函数的一些可能实现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Swapping Values,
    First Attempt</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">交换值，第一次尝试</samp>
- en: Each object has a storage duration that determines its *lifetime*, which is
    the time during program execution for which the object exists, has storage, has
    a constant address, and retains its last-stored value. Objects must not be referenced
    outside their lifetime.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个存储持续时间，决定了它的*生命周期*，即在程序执行过程中，对象存在、占用存储、拥有固定地址并保持最后存储的值的时间。对象不得在其生命周期外被引用。
- en: Local variables such as <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> from [Listing 2-1](chapter2.xhtml#Lis2-1)
    have *automatic storage duration*, meaning that they exist until execution leaves
    the block in which they’re declared. We’re going to try to swap the values stored
    in these two variables. [Listing 2-2](chapter2.xhtml#Lis2-2) shows our first attempt
    to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本地变量，如来自 [列表 2-1](chapter2.xhtml#Lis2-1) 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，具有*自动存储持续时间*，意味着它们存在直到程序执行离开声明它们的块为止。我们将尝试交换这两个变量中存储的值。[列表
    2-2](chapter2.xhtml#Lis2-2) 展示了我们第一次尝试实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数的代码。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: A first attempt
    at implementing the</samp> <samp class="I">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-2：第一次尝试实现</samp> <samp
    class="I">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function is declared
    with two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, that we use to pass arguments
    to this function. C distinguishes between *parameters*, which are objects declared
    as part of the function declaration that acquire a value on entry to the function,
    and *arguments*, which are comma-separated expressions we include in the function
    call expression. We also declare a temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function and initialize it
    to the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. This variable
    is used to temporarily save the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    so that it’s not lost during the swap.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数声明了两个参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，我们用它们来向这个函数传递参数。C 区分
    *参数* 和 *实参*，其中参数是作为函数声明的一部分声明的对象，在进入函数时会获取一个值，而实参是我们在函数调用表达式中传入的以逗号分隔的表达式。我们还在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数中声明了一个临时变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>，其类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，并将其初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    的值。此变量用于临时保存 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 中存储的值，以免在交换过程中丢失。
- en: 'We can now run the generated executable to test the program:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行生成的可执行文件来测试程序：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This result may be surprising. The variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> were initialized to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>,
    respectively. The first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    within the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function
    shows that these two values were swapped, but the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> shows the original
    values unchanged. Let’s examine what happened.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果可能让人感到惊讶。变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 分别被初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>。第一次在 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 调用显示这两个值已被交换，但在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 中的第二次 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    调用则显示原始值未变。让我们看看发生了什么。
- en: C is a *call-by-value* (also called a *pass-by-value*) language, which means
    that when you provide an argument to a function, the value of that argument is
    copied into a distinct variable for use within the function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function assigns the values of the objects you pass as arguments to their respective
    parameters. When the parameter values in the function are changed, the argument
    values in the caller are unaffected because they are distinct objects. Consequently,
    the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> retain their original values
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> during the second
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>. The goal
    of the program was to swap the values of these two objects. By testing the program,
    we’ve discovered it has a bug, or defect.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C 是一种 *按值传递*（也称为 *传值*）语言，这意味着当你向函数提供一个实参时，该实参的值会被复制到一个独立的变量中供函数使用。<samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数将你作为实参传递的对象的值赋给它们各自的参数。当函数中的参数值发生变化时，调用者中的实参值不会受到影响，因为它们是独立的对象。因此，在第二次调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 时，变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 保持其在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    中的原始值。程序的目标是交换这两个对象的值。通过测试程序，我们发现它存在一个 bug 或缺陷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Swapping Values,
    Second Attempt</samp>
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">交换值，第二次尝试</samp>
- en: To repair this bug, we can use pointers to rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function. We use the indirection (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>)
    operator to both declare pointers and dereference them, as shown in [Listing 2-3](chapter2.xhtml#Lis2-3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个 bug，我们可以使用指针重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数。我们使用间接操作符 (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>) 来声明指针并对其解引用，如
    [Listing 2-3](chapter2.xhtml#Lis2-3) 所示。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: The revised</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    using pointers</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: 修改后的</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数使用指针</samp>'
- en: When used in a function declaration or definition, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    acts as part of a pointer declarator indicating that the parameter is a pointer
    to an object or function of a specific type. In the rewritten <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function, we declare two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>, both having the type
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数声明或定义中使用时，<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 作为指针声明符的一部分，表示该参数是指向某种类型的对象或函数的指针。在重写的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数中，我们声明了两个参数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>，它们的类型都是指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针。
- en: 'The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator denotes
    indirection. If its operand has type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    the result of the operation has type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    For example, consider the following assignment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一元操作符 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 表示间接引用。如果其操作数是指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 的指针类型，则操作结果的类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>。例如，考虑以下赋值：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This replaces the value of the pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    with the value of the pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>.
    Now consider the assignment in the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指针 <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> 的值替换为指针 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>
    的值。现在考虑 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数中的赋值操作：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">*pb</samp> operation reads
    the value referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>,
    while the <samp class="SANS_TheSansMonoCd_W5Regular_11">*pa</samp> operation reads
    the location referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>.
    The value referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>
    is then written to the location referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">*pb</samp> 操作读取 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>
    引用的值，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">*pa</samp> 操作读取 <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    引用的位置。然后将 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp> 引用的值写入 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> 引用的位置。
- en: 'When you call the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, you must
    also place an ampersand (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    character before each variable name:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 中调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数时，你还必须在每个变量名前加上一个 &（<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）字符：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> (*address-of*)
    operator generates a pointer to its operand. This change is necessary because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function now accepts
    arguments of type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    instead of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一元操作符 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>（*取地址*）操作符生成其操作数的指针。这个变化是必要的，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数现在接受指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型的指针作为参数，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型。
- en: '[Listing 2-4](chapter2.xhtml#Lis2-4) shows the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    program with comments describing the objects created during execution of this
    code and their values.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-4](chapter2.xhtml#Lis2-4) 显示了整个 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    程序，注释描述了在执行此代码期间创建的对象及其值。'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: A simulated call
    by reference</samp>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-4：模拟的引用调用</samp>
- en: Upon entering the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function block, the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are initialized to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>,
    respectively. The code then takes the addresses of these objects and passes them
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function as arguments.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数块后，变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 分别被初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>。然后，代码获取这些对象的地址，并将它们作为参数传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数。
- en: Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function,
    the parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pb</samp> are now both declared as type
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and contain
    copies of the arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    from the calling function (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>).
    These address copies still refer to the exact same objects, so when the values
    of their referenced objects are swapped in the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function, the contents of the original objects declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    are also swapped. This approach simulates *call by* reference (also known as *pass
    by* reference) by generating object addresses, passing those by value, and then
    dereferencing the copied addresses to access the original objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数内，参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp> 现在都声明为指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型的指针，并包含传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 的调用函数（在本例中为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>）的参数副本。这些地址副本仍然指向完全相同的对象，因此当它们所引用对象的值在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数中交换时，<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    中声明的原始对象的内容也会被交换。这种方法通过生成对象地址、按值传递这些地址，然后解引用复制的地址来访问原始对象，从而模拟了 *按引用调用*（也称为 *按引用传递*）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Object Types</samp>
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">对象类型</samp>
- en: This section introduces object types in C. Specifically, we’ll cover the Boolean
    type, character types, and arithmetic types (including both integer and floating
    types).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 C 中的对象类型。具体来说，我们将涵盖布尔类型、字符类型和算术类型（包括整数类型和浮点类型）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boolean</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">布尔</samp>
- en: A Boolean data type has one of two possible values (<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>) that represent
    the two truth values of logic and Boolean algebra. Objects declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    can store only the values <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型有两个可能的值（<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>），表示逻辑和布尔代数中的两个真值。声明为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> 的对象只能存储 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> 这两个值。
- en: 'The following example declares a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp>
    that takes a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> argument
    and returns a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例声明了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp>
    的函数，该函数接受一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的参数，并返回一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> 类型的值：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_missile</samp> function
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp> function
    and assigns the return value to the Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">armed</samp>.
    This value can then be tested to determine whether the missile is armed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_missile</samp> 函数调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp> 函数，并将返回值赋给布尔变量 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">armed</samp>。然后，可以测试该值以确定导弹是否已准备就绪。
- en: Historically, Boolean values were represented by integers and still behave as
    integers. They can be stored in integer variables and used anywhere integers would
    be valid, including in indexing, arithmetic, parsing, and formatting. C guarantees
    that any two true values will compare equally (which was impossible to achieve
    before the introduction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    type). You should use the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    type to represent Boolean values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，布尔值是通过整数表示的，并且仍然表现得像整数一样。它们可以存储在整数变量中，并可以在任何整数有效的地方使用，包括索引、算术运算、解析和格式化。C
    语言保证任何两个 `true` 值会相等比较（这是在引入 <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    类型之前无法实现的）。你应该使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> 类型来表示布尔值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character</samp>
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符</samp>
- en: 'The C language defines the following character types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. Each compiler implementation defines <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    to have the same alignment, size, range, representation, and behavior as either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. Regardless of the choice made, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is a separate type from the other two and is incompatible with both.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言定义了以下字符类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>。每个编译器实现都将 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    定义为与 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> 具有相同的对齐方式、大小、范围、表示和行为。无论选择哪一种，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 都是一个独立的类型，与其他两个类型不兼容。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type is commonly
    used to represent character data in C language programs. Objects of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> can represent the *basic execution
    character set*—the minimum set of characters required in the execution environment—including
    upper- and lowercase letters, the 10 decimal digits, the space character, punctuation,
    and control characters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type is inappropriate for integer data; use <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> to represent small, signed integer values, and use <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> to represent small, unsigned integer values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型通常用于表示 C 语言程序中的字符数据。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型的对象可以表示 *基本执行字符集* —— 执行环境中所需的最小字符集，包括大小写字母、10
    个十进制数字、空格字符、标点符号和控制字符。<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    类型不适用于整数数据；使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>
    来表示小的有符号整数值，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    来表示小的无符号整数值。
- en: The size of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is always 1 byte, and its width is <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>
    bits. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> macro
    from <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp> defines the
    number of bits in a byte. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>
    macro cannot be less than 8, and on most modern platforms, it is 8.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型的对象大小始终为 1 字节，宽度为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> 位。<samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>
    宏来自 <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>，用于定义一个字节中的位数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> 宏的值不能小于 8，并且在大多数现代平台上，其值为
    8。
- en: The basic execution character set suits the needs of many conventional data
    processing applications, but its lack of non-English letters is an obstacle to
    acceptance by international users. To address this need, the C standards committee
    specified a new wide type to allow large character sets. You can represent the
    characters of a large character set as *wide characters* by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type, which generally takes more space than a basic character. Typically, implementations
    choose 16 or 32 bits to represent a wide character. The C standard library provides
    functions that support both narrow and wide character types. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type was not designed to support Unicode and has consequently fallen out of favor
    for most implementations with the notable exception of Microsoft Visual Studio.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的执行字符集适用于许多常规数据处理应用，但其缺乏非英语字母是国际用户接受的障碍。为了解决这一需求，C 标准委员会规定了一种新的宽字符类型，以允许更大的字符集。你可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 类型将大字符集的字符表示为 *宽字符*，它通常占用比基本字符更多的空间。通常，实施会选择
    16 位或 32 位来表示一个宽字符。C 标准库提供了支持窄字符和宽字符类型的函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型并未设计用来支持 Unicode，因此在大多数实现中已逐渐被弃用，微软 Visual Studio 是一个显著的例外。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arithmetic</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">算术</samp>
- en: C provides several *arithmetic types* that can be used to represent integers,
    enumerators, and floating-point values. [Chapter 3](chapter3.xhtml) covers some
    of these in more detail, but here’s a brief introduction.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C 提供了几种 *算术类型*，可用于表示整数、枚举值和浮点值。[第3章](chapter3.xhtml)详细介绍了其中的一些，但这里简要介绍一下。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">整数</samp>'
- en: '*Signed integer types* can be used to represent negative numbers, positive
    numbers, and zero. The standard signed integer types include <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*带符号整数类型* 可以用于表示负数、正数和零。标准的带符号整数类型包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>。'
- en: 'For each signed integer type, there is a corresponding *unsigned integer type*
    that uses the same amount of storage: <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long
    long int</samp>. The unsigned types can represent positive numbers and zero. These
    unsigned integer types along with type <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    make up the standard unsigned integer types.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种带符号整数类型，都有一个相应的 *无符号整数类型*，它使用相同的存储空间：<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short int</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long int</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long
    long int</samp>。无符号类型可以表示正数和零。这些无符号整数类型以及类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    组成了标准的无符号整数类型。
- en: Except for <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> itself,
    the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> may be omitted
    in the declarations for these types, so you might, for example, declare a type
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 本身外，关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    在这些类型的声明中可以省略，因此你可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp>
    来声明类型，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>。
- en: The signed and unsigned integer types are used to represent integers of various
    widths. Each platform determines the width for each of these types, given some
    constraints. Each type has a minimum representable range. The types are ordered
    by width, guaranteeing that wider types are at least as large as narrower types.
    This means that an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long int</samp> can represent all values that an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> can represent, an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> can represent all values that can be represented by an object of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and so forth. The implementation-defined
    minimum and maximum representable values for integer types are specified in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp> header file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号和无符号整数类型用于表示各种宽度的整数。每个平台确定每种类型的宽度，给定一些约束。每种类型都有一个最小可表示范围。这些类型按宽度排序，确保更宽的类型至少与更窄的类型一样大。这意味着<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>类型的对象可以表示<samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp>类型的对象可以表示的所有值，<samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>类型的对象可以表示的所有值都可以由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型的对象表示，依此类推。整数类型的实现定义的最小和最大可表示值在<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>头文件中指定。
- en: '*Extended integer types* may be provided in addition to the standard integer
    types. They are implementation defined, meaning that their width, precision, and
    behavior are up to the compiler. Extended integer types are typically larger than
    the standard integer types (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">__int128</samp>).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展整数类型*可能会在标准整数类型之外提供。它们是实现定义的，这意味着它们的宽度、精度和行为取决于编译器。扩展整数类型通常比标准整数类型大（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__int128</samp>）。'
- en: In addition to the standard and extended integer types, C23 adds *bit-precise
    integer types*. These types accept an operand specifying the width of the integer,
    so a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp> is a signed
    32-bit integer, and an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    _BitInt(32)</samp> is an unsigned 32-bit integer. Bit-precise integer types do
    not require their width to be a power of two; the maximum width supported is specified
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp> (which
    must be at least the same as the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp>).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准和扩展整数类型外，C23还增加了*比特精确整数类型*。这些类型接受一个操作数来指定整数的宽度，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp>是一个带符号的32位整数，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(32)</samp>则是一个无符号的32位整数。比特精确整数类型不要求它们的宽度是2的幂；支持的最大宽度由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp>指定（其宽度至少与<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp>的宽度相同）。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type is typically
    assigned the natural width suggested by the architecture of the execution environment
    (for example, 16 bits on a 16-bit architecture and 32 bits on a 32-bit or 64-bit
    architecture). You can specify actual-width integers by using type definitions
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdint.h></samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><inttypes.h></samp> header, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>. These headers also provide
    type definitions for the greatest-width integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">uintmax_t</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>
    type, for example, can represent any value of any signed integer type with the
    possible exceptions of signed bit-precise integer types and of signed extended
    integer types.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型通常根据执行环境的架构被赋予自然的宽度（例如，在16位架构上是16位，在32位或64位架构上是32位）。您可以通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stdint.h></samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11"><inttypes.h></samp>头文件中的类型定义（如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>）来指定实际宽度整数。这些头文件还为最大宽度整数类型提供类型定义：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">uintmax_t</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>类型可以表示任何带符号整数类型的值，可能例外的是带符号比特精确整数类型和带符号扩展整数类型。
- en: '[Chapter 3](chapter3.xhtml) covers integer types in excruciating detail.  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_B_11">enum</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](chapter3.xhtml)详细讲解了整数类型。  #### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">enum</samp>'
- en: 'An *enumeration*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>,
    allows you to define a type that assigns names (*enumerators*) to integer values
    in cases with an enumerable set of constant values. The following are examples
    of enumerations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*枚举*，或称<samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>，允许你定义一个类型，在有枚举常量集合的情况下为整数值指定名称（*枚举量*）。以下是枚举的示例：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you don’t specify a value to the first enumerator with the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operator, the value of its enumeration constant is 0, and each subsequent enumerator
    without an <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> adds 1 to the
    value of the previous enumeration constant. Consequently, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">sun</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">day</samp> enumeration is
    0, <samp class="SANS_TheSansMonoCd_W5Regular_11">mon</samp> is 1, and so forth.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: "如果你没有使用<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">=</samp>操作符为第一个枚举量指定值，则其枚举常量的值为0，之后每个没有<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">=</samp>的枚举量将基于前一个枚举常量的值加1。因此，<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">sun</samp>在<\tsamp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >day</samp>枚举中的值为0，<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">mon</samp>的值为1，以此类推。"
- en: You can also assign specific values to each enumerator, as shown by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cardinal_points</samp> enumeration. Using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> with enumerators may produce
    enumeration constants with duplicate values, which can be a problem if you incorrectly
    assume that all the values are unique. The <samp class="SANS_TheSansMonoCd_W5Regular_11">months</samp>
    enumeration sets the first enumerator at 1, and each subsequent enumerator that
    isn’t specifically assigned a value will be incremented by 1.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个枚举量指定特定的值，如<samp class="SANS_TheSansMonoCd_W5Regular_11">cardinal_points</samp>枚举所示。使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>与枚举量可能会导致枚举常量具有重复的值，如果你错误地假设所有值都是唯一的，这可能会成为问题。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">months</samp>枚举将第一个枚举量的值设为1，之后每个未特定赋值的枚举量将递增1。
- en: 'Starting with C23, you can specify the underlying type of the enumeration.
    For portability and other reasons (Meneide and Pygott 2022), it is always better
    to specify the enumeration type. In the following example, the enumeration constant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a0</samp> can be assigned the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFFFFFFFFFFFFULL</samp> because
    the type is specified as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp>:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从C23开始，你可以指定枚举的底层类型。为了移植性和其他原因（Meneide和Pygott 2022），最好始终指定枚举类型。在以下示例中，枚举常量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a0</samp>可以被赋值为<samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFFFFFFFFFFFFULL</samp>，因为类型被指定为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp>：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An omitted type is implementation defined. Visual C++ uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> for the type, and GCC uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略类型，则由实现定义。Visual C++使用<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>作为类型，而GCC则使用<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating</samp>
- en: Floating-point arithmetic is similar to, and often used as a model for, the
    arithmetic of real numbers. The C language supports a variety of floating-point
    representations including, on most systems, representations in the IEEE Standard
    for Floating-Point Arithmetic (IEEE 754-2019). ISO/IEC 60559:2011 has content
    identical to IEEE 754-2019 but is referenced by the C standard because it is published
    by the same standards organization. The choice of floating-point representation
    is implementation defined. [Chapter 3](chapter3.xhtml) covers floating types in
    detail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点运算与实数运算相似，并且常常作为实数运算的模型。C语言支持多种浮点表示，包括大多数系统上采用的IEEE浮点运算标准（IEEE 754-2019）。ISO/IEC
    60559:2011与IEEE 754-2019内容相同，但由于它是由同一标准组织发布的，因此C标准引用了它。浮点表示的选择由实现决定。[第3章](chapter3.xhtml)详细讲解了浮点类型。
- en: 'The C language supports three standard floating types: <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>. The set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    is a subset of the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>;
    the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    is a subset of the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: C语言支持三种标准浮动类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>。类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 的值集是类型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 的值集的子集；类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    的值集是类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> 的值集的子集。
- en: C23 adds three *decimal floating types* (ISO/IEC TS 18661-2:2015), designated
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>. Respectively,
    these have the decimal32, decimal64, and decimal128 IEC 60559 formats.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: C23 添加了三种*十进制浮动类型*（ISO/IEC TS 18661-2:2015），分别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>。这些类型分别对应于十进制32、十进制64和十进制128
    IEC 60559 格式。
- en: The standard floating types and the decimal floating types are collectively
    called the *real floating types*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 标准浮动类型和十进制浮动类型统称为*实数浮动类型*。
- en: There are also three *complex types*, designated as <samp class="SANS_TheSansMonoCd_W5Regular_11">float
    complex</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double complex</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double complex</samp>.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三种*复杂类型*，分别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">float complex</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double complex</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double complex</samp>。
- en: The real floating and complex types are collectively called the *floating types*.
    [Figure 2-1](chapter2.xhtml#fig2-1) shows the hierarchy of floating types.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实数浮动类型和复杂类型统称为*浮动类型*。[图 2-1](chapter2.xhtml#fig2-1)展示了浮动类型的层次结构。
- en: '![](../images/f02001.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f02001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The hierarchy of
    floating types</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-1：浮动类型的层次结构</samp>
- en: Complex types and decimal floating types are not covered in detail in this book.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本书没有详细介绍复杂类型和十进制浮动类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type is a rather
    strange type. The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    (by itself) means “cannot hold any value.” For example, you can use it to indicate
    that a function doesn’t return a value or as the sole parameter of a function
    to indicate that the function takes no arguments. On the other hand, the *derived
    type* <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> means that the
    pointer can reference *any* object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型是一个相当特殊的类型。关键字 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>（单独使用时）表示“不能持有任何值”。例如，你可以使用它来表示一个函数不返回任何值，或者作为函数的唯一参数，表示该函数不接受任何参数。另一方面，*派生类型*
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 表示该指针可以引用*任何*对象。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Derived Types</samp>
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">派生类型</samp>
- en: '*Derived types* are constructed from other types. These include function types,
    pointer types, array types, type definitions, structure types, and union types—all
    of which are covered here.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*派生类型*是由其他类型构造而来的。它们包括函数类型、指针类型、数组类型、类型定义、结构类型和联合类型——所有这些都会在此涵盖。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function</samp>
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">函数</samp>
- en: A *function type* is derived from the return type and the number and types of
    its parameters. A function can return any complete object type except for an array
    type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数类型*由返回类型和参数的数量及类型派生而来。一个函数可以返回任何完整的对象类型，但不能返回数组类型。'
- en: When you declare a function, you use the *function declarator* to specify the
    name of the function and the return type. If the declarator includes a parameter
    type list and a definition, the declaration of each parameter must include an
    identifier, except parameter lists with only a single parameter of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, which needs no identifier.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个函数时，使用 *函数声明符* 来指定函数的名称和返回类型。如果声明符包括参数类型列表和定义，则每个参数的声明必须包含一个标识符，除非参数列表只有一个类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的参数，这种情况不需要标识符。
- en: 'Here are a few function type declarations:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些函数类型声明：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we declare two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">fprime</samp>, with no parameter
    that returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Next,
    we declare a function <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>
    with no parameters that return a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Finally, we declare two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, each returning <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and taking two parameters
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明两个函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">fprime</samp>，它们没有参数，返回一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。接下来，我们声明一个函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>，没有参数，返回一个指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针。最后，我们声明两个函数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>，每个函数都返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 并接受两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型的参数。
- en: Specifying parameters with identifiers (as done here with <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>)
    can be problematic if an identifier is a macro. However, providing parameter names
    is good practice for self-documenting code, so omitting the identifiers (as done
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>) is not typically
    recommended.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 指定带有标识符的参数（如这里的 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）可能会有问题，尤其是当标识符是宏时。然而，为参数提供名称是自文档化代码的好习惯，因此通常不建议省略标识符（就像在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> 中所做的那样）。
- en: In a function declaration, specifying parameters is optional. However, failing
    to do so can be problematic. Prior to C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>
    declares a function accepting any number of arguments of any type and returning
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. The same function
    declaration for <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp> in C++
    declares a function accepting no arguments and returning an <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. Starting with C23, a function declarator with an empty parameter list
    declares a prototype for a function that takes no arguments (like it does in C++).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数声明中，指定参数是可选的。然而，如果不指定，可能会引发问题。在 C23 之前，<samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>
    声明了一个接受任意数量的任意类型参数并返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>
    的函数。相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp> 函数声明在 C++ 中声明了一个接受无参数并返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> 的函数。从 C23 开始，具有空参数列表的函数声明符声明了一个不接受任何参数的函数原型（就像在
    C++ 中一样）。
- en: A function type is also known as a *function prototype*. A function prototype
    informs the compiler about the number and types of parameters a function accepts.
    Compilers use this information to verify that the correct number and type of parameters
    are used in the function definition and any calls to the function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型也被称为 *函数原型*。函数原型向编译器告知函数接受的参数数量和类型。编译器使用这些信息来验证函数定义和任何对函数的调用中使用了正确数量和类型的参数。
- en: 'The *function definition* provides the actual implementation of the function.
    Consider the following function definition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数定义* 提供了函数的实际实现。考虑以下函数定义：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The return type specifier is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>;
    the function declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">max(int
    a, int b)</samp>; and the function body is <samp class="SANS_TheSansMonoCd_W5Regular_11">{return
    a > b ? a : b;}</samp>. The specification of a function type must not include
    any type qualifiers (see “Type Qualifiers” on [page 31](#pg_31)). The function
    body itself uses the conditional operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>), which is explained in [Chapter 4](chapter4.xhtml). This expression
    states that if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is greater
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, return <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>;
    otherwise, return <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '返回类型说明符是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>；函数声明是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">max(int a, int b)</samp>；函数体是 <samp class="SANS_TheSansMonoCd_W5Regular_11">{return
    a > b ? a : b;}</samp>。函数类型的规范不应包含任何类型限定符（见“类型限定符”部分，参见 [第31页](#pg_31)）。函数体本身使用了条件运算符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">? :</samp>），这一运算符在 [第4章](chapter4.xhtml)
    中有解释。该表达式表示，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 大于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>；否则，返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer</samp>
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">指针</samp>
- en: A *pointer type* is derived from a function or object type called the *referenced
    type*. A pointer type derived from the referenced type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is called a *pointer to* <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    A pointer provides a reference to an entity of the referenced type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针类型* 是由称为 *引用类型* 的函数或对象类型派生而来。由引用类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    派生的指针类型称为指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 的指针。指针提供对引用类型实体的引用。'
- en: 'The following three declarations declare a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, and a
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三条声明声明了指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、指向 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 和指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    的指针：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each pointer is initialized to a null pointer constant. A null pointer constant
    can be specified as an integer constant expression with the value 0, <samp class="SANS_TheSansMonoCd_W5Regular_11">(void
    *)0</samp>, or the predefined constant <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> macro is defined
    in <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>. If a null
    pointer constant is converted to a pointer type, the resulting null pointer is
    guaranteed to compare unequally to a pointer to any object or function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指针都初始化为一个空指针常量。空指针常量可以指定为值为 0 的整数常量表达式、<samp class="SANS_TheSansMonoCd_W5Regular_11">(void
    *)0</samp>，或者预定义常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> 宏在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>
    中定义。如果空指针常量被转换为指针类型，则生成的空指针保证与指向任何对象或函数的指针进行比较时不相等。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> constant was
    introduced in C23 and has advantages to using <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    (Gustedt 2022). [Table 2-1](chapter2.xhtml#tab2-1) shows common values for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> and their associated types.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> 常量是在 C23 中引入的，相较于使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>，它具有优势（Gustedt 2022）。[表
    2-1](chapter2.xhtml#tab2-1) 显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    的常见值及其关联类型。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Values for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> <samp
    class="SANS_Futura_Std_Book_11">and Their Associated Types</samp>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-1：</samp> <samp class="SANS_Futura_Std_Book_11">NULL
    的常见值及其关联类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">值</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">类型</samp>
    |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0L</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0L</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">(void *)0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">(void *)0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> |'
- en: 'These different types can have surprising results when invoking a type-generic
    macro with a <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> argument.
    The conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(true
    ? 0 : NULL)</samp> is always defined, regardless of the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>.
    However, the conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(true
    ? 1 : NULL)</samp> is a constraint violation if <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    has type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '这些不同类型在调用具有<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>参数的类型通用宏时可能会产生意想不到的结果。条件表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(true ? 0 : NULL)</samp>始终是定义的，无论<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>的类型是什么。然而，如果<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>的类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>，则条件表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">(true
    ? 1 : NULL)</samp>将违反约束。'
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> argument passed
    as a sentinel value to a variadic function, such as the Portable Operating System
    Interface (POSIX) <samp class="SANS_TheSansMonoCd_W5Regular_11">execl</samp> function,
    which expects a pointer, can have unexpected results. On most modern architectures,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> types have different sizes. If <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    is defined as 0 on such an architecture, an incorrectly sized argument is passed
    to the variadic function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>参数作为哨兵值传递给可变参数函数（例如便携式操作系统接口（POSIX）<samp
    class="SANS_TheSansMonoCd_W5Regular_11">execl</samp>函数，它期望一个指针）可能会产生意外的结果。在大多数现代架构上，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>类型的大小是不同的。如果在这样的架构上将<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>定义为0，那么会将大小不正确的参数传递给可变参数函数。
- en: 'Earlier in the chapter, I introduced the address-of (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    and indirection (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>) operators.
    You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator to
    take the address of an object or function. For example, taking the address of
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object results in
    an address with the type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我介绍了取地址运算符（<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）和间接寻址运算符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>）。你使用<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>运算符来获取对象或函数的地址。例如，获取一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>对象的地址会得到一个指向<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的指针地址：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second declaration declares the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp>
    as a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and initializes
    it to the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. You
    can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator
    on the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个声明声明了变量<samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp>为指向<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的指针，并将其初始化为<i>i</i>的地址。你还可以对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>运算符的结果使用<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>运算符：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp> using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator resolves to
    the actual object <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. Taking
    the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">*ip</samp> using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator retrieves
    the pointer, so these two operations cancel each other out.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>运算符解引用<samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp>将解析为实际对象<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp>。使用<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>运算符取<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*ip</samp>的地址将检索到指针，因此这两个操作相互抵消。
- en: The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator converts
    a pointer to a type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> into
    a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. It denotes
    *indirection* and operates only on pointers. If the operand points to a function,
    the result of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    operator is the function designator, and if it points to an object, the result
    is a value of the designated object. For example, if the operand is a pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, the result of the
    indirection operator has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    If the pointer is not pointing to a valid object or function, the behavior is
    undefined.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一元 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 运算符将指针类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    转换为类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 的值。它表示 *间接寻址*，并且仅适用于指针。如果操作数指向一个函数，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 运算符的结果是函数指示符；如果操作数指向一个对象，结果是该对象的值。例如，如果操作数是指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的指针，则间接寻址运算符的结果是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型。如果指针未指向有效的对象或函数，则行为是未定义的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array</samp>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数组</samp>
- en: 'An *array* is a contiguously allocated sequence of objects that all have the
    same element type. Array types are characterized by their element types and the
    number of elements in the array. Here we declare an array of 11 elements of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">ia</samp>
    and an array of 17 elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">pointer</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> identified by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">afp</samp>:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组* 是一系列按顺序分配的对象，这些对象都具有相同的元素类型。数组类型的特征由其元素类型和数组中元素的数量决定。这里我们声明了一个包含 11 个元素的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型数组，标识为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ia</samp>，以及一个包含
    17 个元素的指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 的指针类型数组，标识为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">afp</samp>：'
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can use square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>)
    to identify an element of an array. For example, the following contrived code
    snippet creates the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>
    to demonstrate how to assign values to the elements of an array:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用方括号（<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>）来标识数组的一个元素。例如，下面的示例代码演示了如何给数组的元素赋值，以创建字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line declares an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    with a bound of 11\. This allocates sufficient storage to create a string with
    10 characters plus a null character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates 10 times, with the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    ranging from 0 to 9\. Each iteration assigns the result of the expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'0'</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>.
    Following the end of the loop, the null character is copied to the final element
    of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">str[10]</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> now contains the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了一个大小为 11 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 数组。这为创建一个包含
    10 个字符加一个空字符的字符串分配了足够的存储空间。<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环迭代 10 次，<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 的值从 0 到 9。每次迭代将表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'0'</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 的结果赋值给 <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>。循环结束后，空字符被复制到数组的最后一个元素
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str[10]</samp>，此时 <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    包含字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>。
- en: In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is automatically converted
    to a pointer to the first member of the array (pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>),
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> has an unsigned integer
    type. The subscript (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>)
    and addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) operators
    are defined so that <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>
    is identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(str</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>.
    When <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is an array object
    (as it is here), the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>
    designates the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>th element
    of the array (counting from 0). Because arrays are indexed starting at 0, the
    array <samp class="SANS_TheSansMonoCd_W5Regular_11">char str[11]</samp> is indexed
    from 0 to 10, with 10 being the last element, as referenced on the last line of
    this example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp> 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    会自动转换为指向数组第一个成员的指针（指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    的指针），而 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 则是无符号整数类型。下标（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>）和加法（<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>）运算符被定义为使得
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp> 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(str</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>
    等价。当 <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> 是一个数组对象（如本例所示）时，表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp> 表示数组的第 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    个元素（从 0 开始计数）。因为数组的下标是从 0 开始的，所以数组 <samp class="SANS_TheSansMonoCd_W5Regular_11">char
    str[11]</samp> 的下标范围是从 0 到 10，其中 10 为最后一个元素，如本例最后一行所示。
- en: 'If the operand of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator is the result of a <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    operator, the result is as if the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator were removed and the <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    operator were changed to a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">&str[10]</samp>
    is the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一元运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 的操作数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    运算符的结果，那么结果就好像是移除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 运算符并将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> 运算符换成了 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    运算符。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">&str[10]</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    是等效的：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also declare multidimensional arrays. [Listing 2-5](chapter2.xhtml#Lis2-5)
    declares <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> in the function
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> as a two-dimensional
    3×5 array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, also
    referred to as a *matrix*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明多维数组。[列表 2-5](chapter2.xhtml#Lis2-5) 在函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    中声明了一个二维 3×5 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 数组，类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，也叫做 *矩阵*。
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: Matrix operations</samp>'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-5：矩阵运算</samp>
- en: 'More precisely, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is
    an array of three elements, each of which is an array of five elements of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. When you use the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp> ❶ (which is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(arr+i)</samp>), the following
    occurs:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 是一个包含三个元素的数组，每个元素又是一个包含五个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型元素的数组。当你使用表达式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp> ❶（等同于 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(arr+i)</samp>）时，发生的情况如下：
- en: 1.  <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is converted to
    a pointer to the initial array of five elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 被转换为指向包含五个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型元素的初始数组的指针，从 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>
    开始。
- en: 2.  <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is scaled to the
    type of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> by multiplying
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> by the size of one array
    of five <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    乘以一个包含五个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 元素的数组的大小，将其缩放到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 的类型。
- en: 3.  The results from steps 1 and 2 are added.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  步骤 1 和步骤 2 的结果被相加。
- en: 4.  Indirection is applied to the sum to produce an array of five elements of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  间接访问应用于总和，生成一个包含五个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型元素的数组。
- en: When used in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>
    ❷, that array is converted to a pointer to the first element of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    so <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp> produces an
    object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当在表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp> ❷ 中使用时，该数组会被转换为指向第一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型元素的指针，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>
    会生成一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">结构体</samp>
- en: A *structure type* (also known as a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>)
    contains sequentially allocated members. Each member has its own name and may
    have a distinct type—unlike array elements, which must all be of the same type.
    Structures are like record types found in other programming languages.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构类型*（也称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>）包含按顺序分配的成员。每个成员都有自己的名称，并且可以有不同的类型——与数组元素不同，数组元素必须都是相同类型。结构体类似于其他编程语言中的记录类型。'
- en: Structures are useful for declaring collections of related objects and may be
    used to represent things such as a date, customer, or personnel record. They are
    especially useful for grouping objects that are frequently passed together as
    arguments to a function, so you don’t need to repeatedly pass individual objects
    separately.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体用于声明一组相关对象的集合，可以用来表示日期、客户或人员记录等。它们尤其在将经常一起作为参数传递给函数的对象进行分组时非常有用，这样你就不需要重复传递单独的对象。
- en: '[Listing 2-6](chapter2.xhtml#Lis2-6) declares a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> with type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct sigrecord</samp> and a pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct sigrecord</samp> named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp>.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-6](chapter2.xhtml#Lis2-6) 声明了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>，其类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    sigrecord</samp>，并且有一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    sigrecord</samp> 的指针，名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp>。'
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: A</samp> <samp
    class="I">struct sigrecord</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-6: A</samp> <samp class="I">struct
    sigrecord</samp>'
- en: 'The structure has three member objects: <samp class="SANS_TheSansMonoCd_W5Regular_11">signum</samp>
    is an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signame</samp> is an array of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> consisting of 20 elements,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sigdesc</samp> is an array of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> consisting of 100
    elements.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体有三个成员对象：<samp class="SANS_TheSansMonoCd_W5Regular_11">signum</samp> 是一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的对象，<samp class="SANS_TheSansMonoCd_W5Regular_11">signame</samp>
    是一个包含 20 个元素的 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型数组，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sigdesc</samp> 是一个包含 100 个元素的 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    类型数组。
- en: Once you have defined a structure, you’ll likely want to reference its members.
    You reference members of an object of the structure type by using the structure
    member (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) operator. If you
    have a pointer to a structure, you can reference its members with the structure
    pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>) operator. [Listing
    2-7](chapter2.xhtml#Lis2-7) demonstrates the use of each operator.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了一个结构体，你可能会想要引用其成员。你可以使用结构体成员（<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>）运算符来引用结构体类型对象的成员。如果你有一个结构体的指针，可以使用结构体指针（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp>）运算符来引用其成员。[列表 2-7](chapter2.xhtml#Lis2-7)
    展示了这两个运算符的使用。
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: Referencing structure
    members</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-7：引用结构体成员</samp>
- en: The first three lines of [Listing 2-7](chapter2.xhtml#Lis2-7) directly access
    members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> object
    by using the dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) operator.
    We assign the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp>
    object to the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> pointer
    ❶. In the final three lines of the program, we indirectly access the members of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> object by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator through the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> pointer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-7](chapter2.xhtml#Lis2-7) 的前三行通过使用点号（<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>）运算符直接访问
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> 对象的成员。我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp>
    对象的地址赋值给 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> 指针 ❶。在程序的最后三行，我们通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> 指针使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    运算符间接访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> 对象的成员。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Union</samp>
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">联合体</samp>
- en: '*Union types* are like structures, except that the memory used by the member
    objects overlaps. Unions provide multiple different ways to look at the same memory.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*联合类型*类似于结构体，不同之处在于成员对象使用的内存是重叠的。联合体提供了多种不同的方式来查看相同的内存。'
- en: '[Listing 2-8](chapter2.xhtml#Lis2-8) shows a union that contains a single member
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> that contains
    three bitfields of type <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">significand</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">exponent</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sign</samp>.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-8](chapter2.xhtml#Lis2-8) 显示了一个联合体，其中包含一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    的单一成员 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>，以及一个包含三个类型为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp> 的位域的 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">significand</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">exponent</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sign</samp>。'
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: Decomposing a</samp>
    <samp class="I">float</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">using
    a</samp> <samp class="I">union</samp>'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-8：使用</samp> <samp class="I">union</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">分解一个</samp> <samp class="I">float</samp>
- en: This allows a (low-level) C programmer to use the entire floating-point value
    and examine (and possibly modify) its constituent parts. This union is not portable
    because implementations may use a different floating-point representation or endianness.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> tests to
    ensure this union matches the implementation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得（低级）C 程序员可以使用整个浮点值并检查（以及可能修改）其组成部分。这个联合体不可移植，因为不同的实现可能使用不同的浮点表示方式或字节序。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> 用于测试以确保该联合体与实现匹配。
- en: '[Listing 2-9](chapter2.xhtml#Lis2-9) shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    n</samp> that contains a member <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    and a union <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> that itself
    contains four members: <samp class="SANS_TheSansMonoCd_W5Regular_11">inode</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fnode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ldnode</samp>.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: Saving memory
    with a union</samp>'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: This structure might be used in a tree, a graph, or some other data structure
    that contains differently typed nodes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    member might contain a value between 0 and 3, which indicates the type of the
    value stored in the structure. It is declared directly in the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    n</samp> because it is common to all nodes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: As with structures, you can access union members via the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator. Using a pointer to a union, you can reference its members with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator. In [Listing 2-9](chapter2.xhtml#Lis2-9),
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp> member is referenced
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>. Code that uses
    this union will typically check the type of the node by examining the value stored
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp> and then accessing
    the value using <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.inode</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.fnode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.ldnode</samp>, depending
    on the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp>.
    Without the union, each node would contain separate storage for all four data
    types. The use of a union allows the same storage to be used for all union members.
    On the x86-64 GCC version 13.2 compiler, using a union saved 16 bytes per node.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Unions are commonly used to describe network or device protocols in cases where
    you do not know in advance which protocol will be used.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Tags</samp>
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Tags* are a special naming mechanism for structures, unions, and enumerations.
    For example, the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    in the following structure is a tag:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By itself, a tag is not a type name and cannot be used to declare a variable
    (Saks 2002). Instead, you must declare variables of this type as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The names of unions and enumerations are also tags and not types, meaning that
    they cannot be used alone to declare a variable. For example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The tags of structures, unions, and enumerations are defined in a separate
    *namespace* from ordinary identifiers. This allows a C program to have both a
    tag and another identifier with the same spelling in the same scope:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can even declare an object <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This may not be good practice, but it is valid C. You can think of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    tags as type names and define an alias for the tag by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.
    Here’s an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This now allows you to declare variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>. The
    tag name in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">union</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    is optional, so you can just dispense with it entirely:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This works fine except in the case of self-referential structures that contain
    pointers to themselves:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: C requires the use of tag types (<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>)
    to include the tag name. The compiler will emit a diagnostic if you do not use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct tnode</samp> in the declaration
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>
    pointers. Consequently, you must declare a tag for the structure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an alias for the structure using a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> pointers must still
    use the tag name because the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    name is not introduced until after the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    declaration is complete. You can use the same name for the tag and the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>,
    but a common idiom is to name the tag something ugly such as <samp class="SANS_TheSansMonoCd_W5Regular_11">tnode_</samp>
    to encourage programmers to use the type name:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can also define this type before the structure so that you can use it to
    declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">right</samp> members that refer to other
    objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">tnode</samp>:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Type definitions can improve code readability beyond their use with structures.
    For example, given the following type definition
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'these declarations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp>
    function all specify the same type:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The last two declarations are clearly easier to read.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Qualifiers</samp>
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the types examined so far have been unqualified types. You can qualify
    types by using one or more of the following qualifiers: <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>.
    Each of these qualifiers changes behaviors when accessing objects of the qualified
    type.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The qualified and unqualified versions of types can be used interchangeably
    as arguments to functions, return values from functions, and structure and union
    members.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp> *type qualifier,
    available since C11, supports concurrent programs.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">const</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    qualifier (<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    types) are not assignable but can have constant initializers. This means the compiler
    can place objects with <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    types in read-only memory, and any attempt to write to them will result in a runtime
    error:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It’s possible to accidentally convince your compiler to change a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object for you. In the following example, we take the address of a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and tell the compiler
    that it’s actually a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: C does not allow you to cast away the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    if the original was declared as a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object. This code might appear to work, but it’s defective and may fail later.
    For example, the compiler might place the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object in read-only memory, causing a memory fault when trying to store a value
    in the object at runtime.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'C allows you to modify an object that is referenced by a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    pointer by casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    away, provided that the original object was not declared <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Be careful not to pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    pointer to a function that modifies the object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">volatile</samp>
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects are given a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    type to allow for processes that are *extrinsic* to the compiler. The values stored
    in these objects may change without the knowledge of the compiler, or a write
    may synchronize externally. For example, every time the value from a real-time
    clock is read, it may change, even if the value has not been written to by the
    C program. Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    type lets the compiler know that the value may change without its knowledge and
    ensures that every access to the real-time clock occurs. Otherwise, an access
    to the real-time clock may be optimized away or replaced by a previously read
    and cached value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对象被赋予 `<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 修饰符类型，以允许编译器外部的*外在*进程操作。这些对象中存储的值可能会在编译器不知道的情况下发生变化，或者写操作可能会进行外部同步。例如，每次读取实时钟表的值时，它可能会发生变化，即使该值没有被
    C 程序写入。使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 修饰符类型让编译器知道该值可能在不知情的情况下发生变化，并确保每次访问实时钟表时都会发生。否则，对实时钟表的访问可能会被优化掉，或者被之前读取并缓存的值替代。
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified type
    can be used to access memory-mapped registers, which are accessed through an address
    just like any other memory. Input/output (I/O) devices often have memory-mapped
    registers, where you can write to, or read from, a specific address to set or
    retrieve information or data. Each read and write operation must occur, even if
    the compiler can see no reason for it. Declaring an object as <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>
    ensures that each read or write of that object at runtime occurs the same number
    of times and in the same order as indicated by the source code. For example, if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp> is defined as a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the compiler must generate instructions to read the value from <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>
    and then write this value back to <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>
    in the assignment:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 修饰符类型可用于访问内存映射寄存器，这些寄存器通过地址像其他内存一样被访问。输入/输出
    (I/O) 设备通常有内存映射寄存器，你可以通过特定地址进行读写以设置或获取信息或数据。每次读写操作必须发生，即使编译器认为没有必要。将对象声明为 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 可确保该对象在运行时的每次读写操作发生次数与源代码中所指示的次数相同，并且顺序一致。例如，如果
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>` 被定义为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>`
    修饰的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`，编译器必须生成指令从 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">port</samp>` 读取值，并将该值写回到 `<samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>`：'
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> qualification,
    the compiler would see this as a no-op (a programming statement that does nothing)
    and might eliminate both the read and the write. Reads and writes of volatile
    memory are touched exactly once. A volatile operation cannot be eliminated or
    fused with a subsequent one, even if the compiler believes it’s useless. A volatile
    operation cannot be speculated, even if the compiler can undo or otherwise make
    that speculation benign.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 修饰符，编译器会将此视为无操作（一个什么也不做的编程语句），并可能会删除读取和写入操作。对
    volatile 内存的读写操作会恰好执行一次。volatile 操作不能被消除或与后续操作合并，即使编译器认为它是无用的。volatile 操作不能被猜测，即使编译器能够撤销或以其他方式使该猜测无害。
- en: Objects with <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    types are used when a compiler is not aware of external interactions. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified types
    can be used for memory shared with untrusted code to avoid time-of-check to time-of-use
    (ToCToU) vulnerabilities. Such types are used to access objects from a signal
    handler and with <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp> (refer to the C standard
    for information on signal handlers and <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp>). Unlike Java and other
    programming languages, <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    types should not be used in C for synchronization between threads.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Memory-mapped I/O ports are modeled by a <samp class="SANS_TheSansMonoCd_W5Regular_11">static
    volatile</samp>–qualified objects model. Memory-mapped input ports such as a real-time
    clock are modeled by <samp class="SANS_TheSansMonoCd_W5Regular_11">static const
    volatile</samp>–qualified objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    volatile</samp>–qualified object models a variable that can be altered by a separate
    thread. The meaning of the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    storage-class specifier is explained later in this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">restrict</samp>
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified pointer
    is used to promote optimization. Objects indirectly accessed through a pointer
    frequently cannot be fully optimized because of potential aliasing, which occurs
    when more than one pointer refers to the same object. Aliasing can inhibit optimizations
    because the compiler can’t tell whether an object can change values when another
    apparently unrelated object is modified, for example.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function copies <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    bytes from the storage referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    to the storage referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>.
    The function parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> are both <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified
    pointers:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Because both <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">q</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified
    pointers, the compiler can assume that an object accessed through one of the pointer
    parameters is not also accessed through the other. The compiler can make this
    assessment based solely on the parameter declarations without analyzing the function
    body.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Although using <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified
    pointers can result in more efficient code, you must ensure that the pointers
    do not refer to overlapping memory to prevent undefined behavior.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Scope</samp>
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects, functions, macros, and other C language identifiers have *scope* that
    delimits the contiguous region where they can be accessed. C has four types of
    scope: file, block, function prototype, and function.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The scope of an object or function identifier is determined by where it is declared.
    If the declaration is outside any block or parameter list, the identifier has
    *file scope*, meaning its scope is the entire text file in which it appears as
    well as any included files.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: If the declaration appears inside a block or within the list of parameters,
    it has *block scope*, meaning that the identifier is accessible only from within
    the block. The identifiers for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> from [Listing 2-4](chapter2.xhtml#Lis2-4)
    have block scope and can be referenced only from within the code block in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function in which they’re
    defined.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: If the declaration appears within the list of parameter declarations in a function
    prototype (not part of a function definition), the identifier has *function prototype
    scope*, which terminates at the end of the function declarator. *Function scope*
    is the area between the opening <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>of
    a function definition and its closing}. A label name is the only kind of identifier
    that has function scope. *Labels* are identifiers followed by a colon, and they
    identify a statement in the same function to which control may be transferred.
    ([Chapter 5](chapter5.xhtml) covers labels and control transfer.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Scopes also can be *nested*, with *inner* and *outer* scopes. For example, you
    can define a block scope inside another block scope, and every block scope is
    defined within a file scope. The inner scope has access to the outer scope, but
    not vice versa. As the name implies, any inner scope must be completely contained
    within any outer scope that encompasses it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: If you declare the same identifier in both an inner scope and an outer scope,
    the identifier declared in the outer scope is *hidden* (also known as *shadowed*)
    by the identifier declared in the inner scope. Referencing the identifier from
    the inner scope will refer to the object in the inner scope; the object in the
    outer scope is hidden and cannot be referenced by its name. The easiest way to
    prevent this from becoming a problem is to use different names. [Listing 2-10](chapter2.xhtml#Lis2-10)
    demonstrates different scopes and how identifiers declared in inner scopes can
    hide identifiers declared in outer scopes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Identifiers declared
    in inner scopes hiding identifiers declared in outer scopes</samp>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing wrong with this code, provided the comments accurately describe
    your intent. However, it’s better to use different names for different identifiers
    to avoid confusion, which leads to bugs. Using short names such as <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is fine for identifiers
    with small scopes. Identifiers in large scopes should have longer, descriptive
    names that are unlikely to be hidden in nested scopes. Some compilers will warn
    about hidden identifiers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Storage Duration</samp>
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects have a storage duration that determines their lifetime. Four storage
    durations are available: automatic, static, thread, and allocated. You’ve already
    seen that objects declared within a block or as a function parameter have automatic
    storage duration. The lifetime of these objects starts when the block in which
    they’re declared begins execution and ends when execution of this block completes.
    If the block is entered recursively, a new object is created each time the block
    is entered, and each object has its own storage.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Scope and lifetime are entirely different concepts. Scope applies to identifiers,
    whereas lifetime applies to objects. The scope of an identifier is the code region
    where the object denoted by the identifier can be accessed by its name. The lifetime
    of an object is the period for which the object exists.*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Objects declared in file scope have *static* storage duration. The lifetime
    of those objects is the entire execution of the program, and their stored value
    is initialized prior to program startup.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '*Thread* storage duration is used in concurrent programming and is not covered
    in this book. *Allocated* storage duration involves dynamically allocated memory
    and is discussed in [Chapter 6](chapter6.xhtml). Finally, as described in the
    next section, a storage-class specifier can determine or influence storage duration.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Storage Class</samp>
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can specify the storage class of an object or functions using storage-class
    specifiers. For C23, these include <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class
    specifier is new in C23, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    storage-class specifier is significantly changed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Storage-class specifiers specify various properties of identifiers and declared
    features:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Storage duration: <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    in block scope, <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linkage: <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    in file scope, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Value: <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type: <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a few exceptions, only one storage-class specifier is allowed for each
    declaration. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    may appear with all the others except <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">static</samp>
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> storage-class
    specifier is used to specify both storage duration and linkage.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: File scope identifiers specified as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>, or functions
    specified as static, have <samp class="SANS_TheSansMonoCd_W5Regular_11">internal</samp>
    linkage.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: You can also declare a variable with block scope to have static storage duration
    by using the storage-class specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>,
    as shown in the counting example in [Listing 2-11](chapter2.xhtml#Lis2-11). These
    objects persist after the function has exited.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: A counting example</samp>'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This program outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">1 2 3 4 5</samp>.
    The static variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    is initialized to 0 once at program startup and incremented each time the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">increment</samp> function is called. The
    lifetime of <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> is the
    entire execution of the program, and it will retain its last-stored value throughout
    its lifetime. You could achieve the same behavior by declaring <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    with file scope. However, it’s good software engineering practice to limit the
    scope of an object whenever possible.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">extern</samp>
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier specifies
    static storage duration and external linkage. It can be used with function and
    object declarations in both file and block scope (but not function parameter lists).
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> is specified for
    the redeclaration of an identifier that has already been declared with internal
    linkage, the linkage remains internal. Otherwise (if the prior declaration was
    external, has no linkage, or is not in scope), the linkage is external.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">thread_local</samp>
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An object whose identifier is declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>
    storage-class specifier has *thread storage duration*. Its initializer is evaluated
    prior to program execution, its lifetime is the entire execution of the thread
    for which it is created, and its stored value is initialized with the previously
    determined value when the thread is started. There is a distinct object per thread,
    and use of the declared name in an expression refers to the object associated
    with the thread evaluating the expression. (The topic of threading is beyond the
    scope of this book.)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">constexpr</samp>
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A scalar object declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    storage-class specifier is a constant and has its value permanently fixed at translation
    time. The <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class
    specifier may appear with <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>.
    If not already present, a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    qualification is implicitly added to the object’s type. The resulting object cannot
    be modified at runtime in any way. The compiler can then use this value in any
    other constant expression.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the constant expression used for the initializer of such a constant
    is checked at compile time. Before the introduction of <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    in C23, a very large object constant might be declared as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The initializer may or may not fit into <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>;
    a diagnostic is not required. In C23, this same object can be declared using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, a diagnostic is required on implementations where <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    has a width of 32 or less.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Static objects must be initialized with a constant value and not a variable:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Arithmetic constant expressions are allowed in initializers. Constant values
    are literal constants (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> members, a scalar object
    declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    storage-class specifier, and the result of operators such as <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> (provided the operand
    does not have a variable-length array type). Unfortunately, <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    objects are not constant values. Starting with C23, an implementation may accept
    other forms of constant expressions; it is implementation defined whether they
    are integer constant expressions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">register</samp>
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp> storage-class
    specifier suggests that access to an object be as fast as possible. The extent
    to which such suggestions are effective is implementation defined. Frequently,
    compilers can make better decisions about register allocation and ignore these
    programmer suggestions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>
    storage class can be used only for an object that never has its address taken.
    A compiler can treat any register declaration simply as an <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    declaration. However, whether addressable storage is used, the address of any
    part of an object declared with a storage-class specifier register cannot be computed,
    either explicitly by use of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator or implicitly by converting an array name to a pointer.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">typedef</samp>
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> storage-class
    specifier defines an identifier to be a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    name that denotes the type specified for the identifier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    storage-class specifier was discussed earlier in the “Type Definitions” box.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">auto</samp>
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    specifier was allowed only for objects declared at block scope (except function
    parameter lists). It indicates automatic storage duration and no linkage, which
    are the defaults for these kinds of declarations.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: C23 introduced type inference into the C language by expanding the definition
    of the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage-class
    specifier. Prior to C23, declaring a variable in C requires the user to name a
    type. However, when the declaration includes an initializer, the type can be derived
    directly from the type of the expression used to initialize the variable. This
    has been a C++ feature since 2011.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier has similar behavior to C++ in that it allows the type to be inferred
    from the type of the assignment value. Take the following file scope definitions,
    for example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Because the integer literal <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    has an implicit type of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    these declarations are interpreted as if they had been written as:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Effectively, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. Type inference
    is extremely useful when implementing or invoking type-generic macros, as we’ll
    see in [Chapter 9](chapter9.xhtml).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">typeof Operators</samp>
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operators <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operators can operate on an expression or a type name and yield the type of their
    operand. If the type of the operand is a variably modified type, the operand is
    evaluated; otherwise, the operand is not evaluated.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier both perform automatic type inference. They can both be used to
    determine the type of expression.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier is commonly used to declare initialized variables where the type
    can be inferred from the initial value. However, to form a derived type, you must
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier cannot be used with <samp class="SANS_TheSansMonoCd_W5Regular_11">_Generic</samp>
    (described in [Chapter 9](chapter9.xhtml)) and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    (described later in this chapter).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator is the nonatomic, unqualified version of the type that would result from
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator preserves
    all qualifiers.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator is
    like the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator,
    which executes the expression in an unevaluated context to understand the final
    type. You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator anywhere you can use a type name. The following example illustrates the
    use of both <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At the first use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator ❶, the operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>,
    which has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">const int</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operator
    strips the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier,
    resulting in just plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    This use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator is illustrative and not meant for production code. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator is used again on operand <samp class="SANS_TheSansMonoCd_W5Regular_11">asi</samp>
    ❷, which has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">const _Atomic
    int</samp>. All qualifiers are once again stripped, resulting in a plain <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier at ❸ includes another <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operand is itself a <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier, the operand is evaluated before evaluating the current <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator. This evaluation happens recursively until a <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier is no longer the operand. In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier at ❸ does nothing and can be omitted. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator at ❹ is evaluated before the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator at ❸ and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator
    at ❸ is now evaluated and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    _Atomic int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator at ❺ returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    array of four <samp class="SANS_TheSansMonoCd_W5Regular_11">const char</samp>
    pointers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator at ❻ strips the qualifier and returns an array of four <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    char</samp> pointers. The qualifiers, in this case, are stripped only from the
    array and not the element types the array contains.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'The following <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function
    is equivalent but doesn’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operators:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator to refer to a macro parameter to construct objects with the required
    types without specifying the type names explicitly as macro arguments.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Alignment</samp>'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Object types have alignment requirements that place restrictions on the addresses
    at which objects of that type may be allocated. An *alignment* represents the
    number of bytes between successive addresses at which a given object can be allocated.
    Central processing units (CPUs) may have different behavior when accessing aligned
    data (for example, where the data address is a multiple of the data size) versus
    unaligned data.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Some machine instructions can perform multibyte accesses on nonword boundaries,
    but with a performance penalty. A *word* is a natural, fixed-sized unit of data
    handled by the instruction set or the hardware of the processor. Some platforms
    cannot access unaligned memory. Alignment requirements may depend on the CPU word
    size (typically, 16, 32, or 64 bits).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Generally, C programmers need not concern themselves with alignment requirements,
    because the compiler chooses suitable alignments for its various types. However,
    on rare occasions, you might need to override the compiler’s default choices—for
    example, to align data on the boundaries of the memory cache lines that must start
    at power-of-two address boundaries or to meet other system-specific requirements.
    Traditionally, these requirements were met by linker commands or similar operations
    involving other nonstandard facilities.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'C11 introduced a simple, forward-compatible mechanism for specifying alignments.
    Alignments are represented as values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>.
    Every valid alignment value is a nonnegative integral power of two. An object
    type imposes a default alignment requirement on every object of that type: a stricter
    alignment (a larger power of two) can be requested using the alignment specifier
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">alignas</samp>). You can include
    an alignment specifier in a declaration. [Listing 2-12](chapter2.xhtml#Lis2-12)
    uses the alignment specifier to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp>
    is properly aligned (<samp class="SANS_TheSansMonoCd_W5Regular_11">bad_buff</samp>
    may have incorrect alignment for member-access expressions).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-12: Use of the</samp>
    <samp class="I">alignas</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">keyword</samp>'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Although <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp> has
    proper alignment to be accessed through an lvalue of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    S</samp>, this program still has undefined behavior. This undefined behavior stems
    from the underlying object <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp>
    being declared as an array of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and being accessed through an lvalue of a different type. The cast
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">(struct S *)</samp>, like any
    pointer cast, doesn’t change the effective type of the storage allocated to each
    array. Because it is an established practice to use areas of character type for
    low-level storage management, I co-authored a paper to make such code conforming
    in a future revision of the C standard (Seacord et al. 2024).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Alignments are ordered from weaker to stronger (also called *stricter*) alignments.
    Stricter alignments have larger alignment values. An address that satisfies an
    alignment requirement also satisfies any valid, weaker alignment requirement.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Alignment of dynamically allocated memory is covered in [Chapter 6](chapter6.xhtml).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variably Modified Types</samp>
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variably modified types (VMTs) define a base type and an extent (number of elements),
    which is determined at runtime. VMTs are a mandatory feature of C23.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'VMTs can be used as function parameters. Remember from earlier in this chapter
    that, when used in an expression, an array is converted to a pointer to the first
    element of the array. This means that we must add an explicit parameter to specify
    the size of the array—for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    parameter in the signature for <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When you call such a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    should accurately represent the size of the array referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>.
    Undefined behavior results if this size is larger than the array.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'When declaring a function to take an array as an argument that specifies a
    size, we must declare the size of the array before referencing the size in the
    array declaration. We could, for example, modify the signature for the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function as follows to take the number of elements <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    and an array of at least <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    elements:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For arrays of character type, the number of elements is equal to the size. In
    this function signature, <samp class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp>
    is a variably modified type because <samp class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp>
    depends on the runtime value of <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: We’ve changed the order of the parameters so that the size parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    is declared before we use it in the array declaration. The array argument <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is still adjusted to a pointer,
    and no storage is allocated because of this declaration (except for the pointer
    itself). When calling this function, you must declare the actual storage for the
    array referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> and
    ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is a valid
    size for it. Just like a non-VMT parameter, the actual array storage may be a
    fixed-size array, variable-length array (covered in [Chapter 6](chapter6.xhtml)),
    or dynamically allocated storage.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'VMTs can generalize your functions, making them more useful. For example, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp> function sums
    all the values in a two-dimensional array. The following version of this function
    accepts a matrix with a fixed column size:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When passing a multidimensional array to a function, the number of elements
    in the initial dimension of the array (the rows) is lost and needs to be passed
    in as an argument. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp>
    parameter provides this information in this example. You can call this function
    to sum the values of any matrix with exactly four columns, as shown in [Listing
    2-13](chapter2.xhtml#Lis2-13).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-13: Summing matrices
    with four columns</samp>'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'This is fine until you need to sum the values of a matrix that does not have
    four columns. For example, changing <samp class="SANS_TheSansMonoCd_W5Regular_11">m3</samp>
    to have five columns would result in a warning such as this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To accept this argument, you would have to write a new function with a signature
    that matches the new dimensions of the multidimensional array. The problem with
    this approach, then, is that it fails to generalize sufficiently.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Instead of doing that, we can rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp>
    function to use a VMT, as shown in [Listing 2-14](chapter2.xhtml#Lis2-14). This
    change allows us to call <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp>
    with matrices of any dimension.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-14: Using a VMT as
    a function parameter</samp>'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The compiler performs the matrix indexing ❶. Without VMTs, this would require
    either manual indexing or double indirection, which are both error prone.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Again, no storage is allocated by either the function declaration or the function
    definition. As with a non-VMT parameter, you need to allocate the storage for
    the matrix separately, and its dimensions must match those passed to the function
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">cols</samp>
    arguments. Failing to do so can result in undefined behavior.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Attributes</samp>
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with C23, you can use *attributes* to associate additional information
    with a declaration, statement, or type. This information can be used by the implementation
    to improve diagnostics, improve performance, or modify the behavior of the program
    in other ways. A comma-delimited list of zero or more attributes is specified
    within a pair of double square brackets, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">[[foo]]</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">[[foo, bar]]</samp>.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarations attributes are specified in two ways. If the attribute specifier
    is at the start of a declaration, the attributes are applied to all declarations
    in the declaration group. Otherwise, the attributes are applied to the declaration
    to the immediate left of the attribute specifier. For example, in the following
    declaration group, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    attribute is applied to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'While in the second declaration group, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> attributes are applied
    only to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: C23 defines several attributes that apply to declarations, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp> attribute is used with
    function declarations to denote that the value returned by the function is expected
    to be used within an expression or initializer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>
    attribute is used with the declaration of a function or a type to denote that
    use of the function or type should be diagnosed as discouraged.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: In addition to standard attributes, the implementation may provide nonportable
    attributes. Such attributes are also specified within double square brackets,
    but they include a vendor prefix to distinguish between attributes from different
    vendors. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[clang::overloadable]]</samp>
    attribute is used on a function declaration to specify that it can use C++-style
    function overloading in C, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[gnu::packed]]</samp>
    attribute is used on a structure declaration to specify that the member declarations
    of the structure should avoid using padding between member declarations whenever
    possible for a more space-efficient layout. Vendors typically use their own prefixes,
    and they may use whatever prefixes they choose. For example, Clang implements
    many attributes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gnu</samp>
    prefix for improved compatibility with GCC. Your compiler should ignore unknown
    attributes, although they may still be diagnosed so you know that the attribute
    has no effect. Refer to your compiler’s documentation for the full list of supported
    attributes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about objects and functions and how they differ.
    You learned how to declare objects and functions, take the addresses of objects,
    and dereference those object pointers. You also learned about most of the object
    types available to C programmers as well as derived types.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll return to these types in later chapters to further explore how they can
    be best used to implement your designs. In the next chapter, I provide detailed
    information about the two kinds of arithmetic types: integers and floating-point.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
