- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINE FOLLOWING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: IN THIS CHAPTER YOU’LL GIVE YOUR ROBOT THE ABILITY TO DETECT AND FOLLOW A LINE
    AUTONOMOUSLY. IT WILL BE ABLE TO IDENTIFY ITS OWN COURSE AND THEN DECIDE EXACTLY
    HOW TO STICK TO IT.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This is a test of both digital recognition and clever programming. It is also
    a classic robotics task that is important for everyone to master, from beginners
    to professionals. By the end of this project you’ll have a fully autonomous robot
    that will be able to stick to a line like glue!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: CREATING A TRACK
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, prior to launching into any project, it is important and useful to
    step back and analyze the task at hand. The aim here is to make your robot follow
    a line. More specifically, you want to make your robot follow a black line on
    a white background, like the one shown in [Figure 7-1](ch07.xhtml#ch07fig1).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f146-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-1** My robot following a black line'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The combination of white and black provides maximum contrast for your robot,
    enabling us to use simple line-following sensors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is create a line for your robot to follow. You can make
    the shape of this track as adventurous as you like. The simplest option is a basic
    loop, but feel free to get creative, as long as the background is white and the
    line is black. I also recommend making the width of the line around 1/4 inch.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways of constructing a track. You could simply grab
    a large piece of paper (at least ledger size, roughly 11 × 17 inches) and draw
    a thick line with a black marker. You could use some black electrical tape on
    white poster board. You can even purchase premade line-following tracks online.
    If you have access to a printer, I recommend printing a track out on letter-size
    paper and assembling it with tape.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve also included the template for a set of tiles you can make into a track
    of any shape in the resources for this book, which you can access on your Windows,
    Mac, or Linux PC:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t done so already, download the software bundle from [*https://nostarch.com/raspirobots/*](https://nostarch.com/raspirobots/)
    onto your personal computer.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the folder where the software is stored, and then open the PDF named
    *track_generator.pdf*. This is a 34-page document that has a variety of 20 × 20
    cm tiles with different lines on them (see [Figure 7-2](ch07.xhtml#ch07fig2)).![image](../images/f147-01.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 7-2** The *track_generator.pdf* document'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Print out whichever lines you want to put together into a track, cut them out,
    and then stick them together to form your own custom track. The first few pages
    of the PDF document show simple paths, such as straight lines and corners, but
    the farther down you scroll, the crazier the paths get!
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For your first track, I recommend keeping it relatively simple. Remember that
    you can always print out more tiles and make a more difficult course for your
    robot in the future.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a simple loop, like the one in [Figure 7-3](ch07.xhtml#ch07fig3),
    print out four copies of Tile Type #2 (the straight line) and four copies of Tile
    Type #3 (the basic corner). You should be able to print these pages specifically
    using the printer dialog box of your PDF reader software. Ensure that each tile
    takes up one letter-size piece of paper.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use scissors to cut around the dotted line of each tile. Then arrange them in
    a loop, as shown in [Figure 7-3](ch07.xhtml#ch07fig3), and use tape along the
    length of the *underside* to join the edges of the tiles together. Your track
    is now complete!
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WARNING
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '*Make sure you don’t tape over the black line when you connect the tiles, as
    this may affect the sensors’ performance. Also try to eliminate any gaps or wrinkles
    between tiles—these can hinder your robot’s movement!*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f148-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-3** My assembled basic line-following track'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: THE THEORY BEHIND LINE FOLLOWING
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to use *infrared* (IR) sensors to make your Raspberry Pi robot follow
    the black line. We used similar technology for obstacle avoidance in [Chapter
    5](ch05.xhtml#ch05), when we used ultrasound for the purpose of detecting objects.
    But instead of sound, in this chapter we’ll use invisible light. Fortunately,
    much of the same theory you learned previously can be applied here too.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Every IR sensor, like the one in [Figure 7-4](ch07.xhtml#ch07fig4), has two
    small bulb-like devices—an infrared transmitter and a receiver, normally arranged
    and positioned closely together. The transmitter is an IR LED that, when triggered,
    fires off a pulse of infrared light. The receiver, an IR photodiode, then waits
    for this transmitted light to return. A *photo­diode* is simply a device that
    uses light to vary an electric current.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f149-01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-4** An IR sensor'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Light interacts differently with different types of surfaces. Most notably,
    light is *reflected* more by a white surface, and almost totally *absorbed* by
    a black surface, enabling the IR sensor to detect black lines on white backgrounds.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in [Figure 7-5](ch07.xhtml#ch07fig5), if an IR sensor module is
    over a white surface, the receiver will detect the reflection of the infrared
    beam emitted by the transmitter. If the sensor is over a black surface, like the
    line of your track, the receiver will not detect the reflection. This difference
    in reflectance allows the sensor module to detect whether or not there is a line
    in front of it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f150-01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-5** The different behavior of IR light as it meets a white versus
    a black surface'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Mounting a single IR sensor onto the bottom of your robot would enable it to
    detect the presence of a black line, but if your robot moved so the sensor was
    no longer directly over the line, it could easily go off-track. With only one
    sensor, there is no easy way for your robot to detect whether it has gone too
    far to the left or right of the line. Instead, we’ll use two IR sensors, both
    mounted on the bottom of your robot at the front, about an inch apart. Two sensors
    will provide a feedback mechanism with a sense of direction. There are four possibilities
    for the outputs of these sensors, each of which will guide the robot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: If both sensors receive a reflected signal and detect white, the robot can assume
    that the line must be in between the sensors. Therefore, the robot should move
    forward in a straight line (see [Figure 7-6](ch07.xhtml#ch07fig6)).![image](../images/f151-01.jpg)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FIGURE 7-6** The robot moves forward when both sensors detect white.'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the left sensor doesn’t receive a reflected signal but the right sensor does,
    this must mean that the left sensor detects the line. This indicates that the
    robot must be veering right, so it should turn left to correct itself, as in [Figure
    7-7](ch07.xhtml#ch07fig7).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the right sensor detects the line but the left sensor doesn’t, the robot
    should correct itself by turning right, as shown at the bottom of [Figure 7-7](ch07.xhtml#ch07fig7).![image](../images/f152-01.jpg)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FIGURE 7-7** The robot turns left or right if one of the sensors detects
    the black line.'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, if neither sensor receives a reflected signal, then they must *both*
    be reading black, as shown in [Figure 7-8](ch07.xhtml#ch07fig8) (this won’t happen
    if you’re using just a basic loop track). What to do next is up to you, but one
    option is simply to make the robot stop. If you experiment with other track layouts—for
    example, a figure 8 shape—you might run into other situations where both sensors
    detect black. In these circumstances you may want your robot to move forward,
    turn, or even reverse—play around to find out what works best!
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](../images/f153-01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-8** The robot stops if both sensors read black.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: USING AN IR SENSOR TO DETECT A LINE
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you start mounting two IR sensors to your Raspberry Pi and configuring
    the code behind a complete line-following robot, let’s wire up just one IR sensor
    and test its line detection response.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The Parts List
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this part of the project you’ll use only one sensor, but make sure to buy
    two, as you’ll need both for the next project!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 2 TCRT5000-based infrared line-following sensor modules
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCRT5000-based line-following sensor modules, like the one shown in [Figure
    7-9](ch07.xhtml#ch07fig9), are very common and available online for less than
    a couple of dollars each. I sourced mine from eBay by searching “TCRT5000 Line
    Follow Module.” The *TCRT5000* part of the sensor name refers to the infrared
    optical sensor, the small black component on the underside of the board.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 TCRT5000 的线路跟踪传感器模块，如[图 7-9](ch07.xhtml#ch07fig9)中所示，非常常见，可以在网上以不到几美元的价格购买。我是通过在
    eBay 上搜索“TCRT5000 线路跟随模块”购买的。传感器名称中的*TCRT5000*部分指的是红外光学传感器，即电路板底部的小黑色组件。
- en: '![image](../images/f154-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f154-01.jpg)'
- en: '**FIGURE 7-9** My TCRT5000 infrared line-following sensor module'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-9** 我的 TCRT5000 红外线跟踪传感器模块'
- en: Make sure to get a line-following *module* like the one in [Figure 7-9](ch07.xhtml#ch07fig9),
    as this means the functionality of the optical sensor has been neatly packaged
    into an easy-to-use component. These boards have a simple set of pins and require
    just three connections (see [Figure 7-10](ch07.xhtml#ch07fig10)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保获取像[图 7-9](ch07.xhtml#ch07fig9)中所示的线路跟踪*模块*，因为这意味着光学传感器的功能已经被整齐地封装成一个易于使用的组件。这些板有一组简单的引脚，只需要三个连接（参见[图
    7-10](ch07.xhtml#ch07fig10)）。
- en: '![image](../images/f154-02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f154-02.jpg)'
- en: '**FIGURE 7-10** Pinout of a TCRT5000 IR sensor module'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-10** TCRT5000 红外传感器模块的引脚图'
- en: The infrared diode is housed inside the small black component and emits an infrared
    ray continuously when the module is connected to power. If the light is not reflected
    back into the sensor, it means a black line must be present and the output pin
    (OUT) of the module goes low (that is, it drops the voltage). This simple digital
    logic is ideal and, better still, the module can be powered natively from the
    Pi’s 3.3 V. This saves us from having to use a voltage divider circuit as we did
    for the ultrasonic distance sensor in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 红外二极管被封装在小黑色组件内部，并在模块连接电源时持续发射红外光。如果光线没有反射回传感器，说明必须存在一条黑线，并且模块的输出引脚（OUT）会变低（即电压下降）。这种简单的数字逻辑非常理想，更棒的是，模块可以通过
    Pi 的 3.3 V 电源供电。这样我们就不必像在[第 5 章](ch05.xhtml#ch05)中为超声波距离传感器所做的那样使用电压分压电路了。
- en: '**NOTE**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Remember that you don’t need to disconnect any of your previous circuits,
    but I won’t show those connections here.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住，您无需断开之前的任何电路，但我不会在这里显示这些连接。*'
- en: Wiring Up Your TCRT5000 Line-Following Sensor Module
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接线您的 TCRT5000 线路跟踪传感器模块
- en: 'Disconnect your Pi from power and wire up your sensor by following these instructions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 断开树莓派的电源，并按照以下说明连接您的传感器：
- en: Use an F-F jumper wire to connect the VCC pin of your TCRT5000 module to physical
    pin 1 of your Raspberry Pi. This is the +3.3 V connection and provides power to
    the sensor.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一根 F-F 跳线将 TCRT5000 模块的 VCC 引脚连接到树莓派的物理引脚 1。这是 +3.3 V 连接，提供传感器的电源。
- en: Use another jumper wire to connect the GND pin of your module to the common
    ground rail on your breadboard. So far, your wiring should look like [Figure 7-11](ch07.xhtml#ch07fig11).![image](../images/f155-01.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一根跳线将模块的 GND 引脚连接到面包板上的公共接地轨道。到目前为止，您的接线应该像[图 7-11](ch07.xhtml#ch07fig11)所示。![image](../images/f155-01.jpg)
- en: '**FIGURE 7-11** Line-following sensor connected to +3.3 V and GND'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 7-11** 线路跟踪传感器连接到 +3.3 V 和 GND'
- en: Use another jumper wire to connect the data output pin of your sensor (OUT)
    to physical pin 21 on your Raspberry Pi. This is BCM 9\. Your complete circuit
    should look like [Figure 7-12](ch07.xhtml#ch07fig12).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一根跳线将传感器的数据输出引脚（OUT）连接到树莓派的物理引脚 21。这是 BCM 9。您的完整电路应该像[图 7-12](ch07.xhtml#ch07fig12)所示。
- en: '![image](../images/f156-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f156-01.jpg)'
- en: '**FIGURE 7-12** Completed breadboard diagram with your TCRT5000 line-following
    sensor module wired up and in place'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-12** 完整的面包板电路图，展示了您的 TCRT5000 线路跟踪传感器模块已经接线并就位'
- en: Programming Your Raspberry Pi to Detect a Line
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编程您的树莓派以检测线路
- en: 'Now that you have a line sensor connected to your Raspberry Pi, let’s write
    some code to test its line detection response. Connect your Pi to power via a
    wall outlet, boot it up and move into your code folder, and then enter the following
    to create and open a test program called *line_test.py*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将线路传感器连接到树莓派，让我们编写一些代码来测试其线路检测响应。通过墙壁插座为树莓派供电，启动它并进入代码文件夹，然后输入以下命令创建并打开一个名为*line_test.py*的测试程序：
- en: pi@raspberrypi:~/robot $ nano line_test.py
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano line_test.py
- en: Add the code in [Listing 7-1](ch07.xhtml#ch07list1), which will test your TCRT5000
    module. The purpose of this program is to simply output to the terminal to inform
    the user whether the module has detected a line.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加[清单7-1](ch07.xhtml#ch07list1)中的代码，这将测试你的TCRT5000模块。该程序的目的是仅仅输出到终端，告知用户模块是否检测到了一条线。
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**LISTING 7-1** Detecting a line'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7-1** 检测一条线'
- en: After importing the usual libraries, we set up the line sensor as a digital
    input on BCM 9 ➊.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入常用库之后，我们将线传感器设置为BCM 9上的数字输入 ➊。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The TCRT5000 has a detection distance between 1 mm and 8 mm. If the line is
    farther away from the sensor than this, it is likely to give false positives or
    negatives.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*TCRT5000的检测距离在1毫米到8毫米之间。如果线条距离传感器太远，它可能会出现误报或漏报。*'
- en: We then start an infinite `while True` loop containing the logic of the program.
    At ➋ we use an `if` statement to detect whether the line sensor is active. If
    it *isn’t* active, it must mean the infrared reflection has not returned and therefore
    the emitted rays have been absorbed by the black line. Thus, the line has been
    detected, and we indicate this to the user with the `print()` statement inside
    the `if` statement.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始一个无限的`while True`循环，包含程序的逻辑。在 ➋ 处，我们使用`if`语句来检测线传感器是否处于活动状态。如果它*没有*处于活动状态，必须意味着红外反射没有返回，因此发射的光线已经被黑线吸收。所以，线条已经被检测到，并且我们通过`if`语句内的`print()`语句告知用户。
- en: Any other scenario would mean that the line sensor is active and therefore is
    *not* detecting a line. The `else` statement ➌ catches this alternative scenario
    and outputs to the user that a line has not been detected. The program then waits
    for a fifth of a second and loops back around.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他情况都意味着线传感器是活动的，因此*没有*检测到一条线。`else`语句 ➌ 捕获了这种替代情况，并输出到用户，告知没有检测到线。程序随后等待五分之一秒并重新开始循环。
- en: 'Running Your Program: Detect a Line!'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：检测一条线！
- en: 'After saving your program, grab a piece of your track to test out your sensor.
    To run the program, enter:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 保存程序后，拿一段轨道来测试你的传感器。要运行程序，输入：
- en: pi@raspberrypi:~/robot $ python3 line_test.py
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 line_test.py
- en: 'While there is nothing within range of the sensor, it may produce erratic results
    that will be displayed in the terminal. Bring your piece of track up to the module
    and move the line over the sensor. You should notice that as you move the piece,
    the terminal output will change to `Line detected`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当传感器周围没有任何物体时，可能会产生不稳定的结果，这些结果会显示在终端中。将你的轨道带到模块上并移动线条到传感器上。你应该会注意到，随着你移动轨道，终端输出会变化为`Line
    detected`：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: My particular sensor also has an LED on the top that changes state when the
    line comes into view.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我的传感器上也有一个LED灯，当线条出现在视野中时，它会改变状态。
- en: If you’re having issues with your module and it’s not detecting the line very
    well, you can try a few things. First, try to limit inter­ference from other light
    sources by turning the lights off. Alternatively, some TCRT5000 modules have an
    on-board potentiometer to adjust their sensitivity. This usually looks like a
    piece of blue/white plastic with a place to insert a screwdriver. Use an appropriate
    screwdriver or other implement to twist this potentio­meter to see if it improves
    your readings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到模块问题，且它没有很好地检测到线条，可以尝试几种方法。首先，尝试通过关闭灯光来限制来自其他光源的干扰。或者，一些TCRT5000模块上有一个内置的电位器，用于调整灵敏度。这个电位器通常看起来像一块蓝白色的塑料，上面有一个可以插入螺丝刀的地方。使用合适的螺丝刀或其他工具来旋转这个电位器，看看是否能改善你的读数。
- en: MAKE YOUR ROBOT FOLLOW A LINE AUTONOMOUSLY
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让你的机器人自主跟踪一条线
- en: When your sensor is successfully detecting the line, it’s time to give your
    robot the ability to follow the track.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的传感器成功检测到线条时，就该给你的机器人增加跟踪轨迹的能力了。
- en: By the end of this project, you’ll have connected up a second sensor and programmed
    the logic behind a fully autonomous program, giving you a line-following robot.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目结束时，你将连接上第二个传感器，并编写完整的自主程序逻辑，打造一台能够跟踪线路的机器人。
- en: Wiring Up the Second TCRT5000 Line-Following Sensor Module
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接第二个TCRT5000线跟踪传感器模块
- en: You’ve already wired up the first TCRT5000 module, so now you only need to wire
    up the second one. If you don’t have the first one connected, flip back a few
    pages and follow the wiring guide in the previous project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经连接了第一个TCRT5000模块，现在只需连接第二个模块。如果第一个模块没有连接，请翻回几页，按照之前项目中的接线指南进行操作。
- en: 'The process for connecting your second sensor is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 连接第二个传感器的过程如下：
- en: Take a F-F jumper wire and connect the VCC pin of your second TCRT5000 module
    to physical pin 17 on your Raspberry Pi. This is another +3.3 V pin and will power
    the sensor.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, use a jumper wire to connect the GND pin of the new module to the common
    ground rail on your breadboard.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a wire to connect the data output pin of your second sensor (OUT) to physical
    pin 23 on your Pi. This is BCM 11\. The wiring for the second sensor, with the
    first sensor omitted, should look like [Figure 7-13](ch07.xhtml#ch07fig13).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f158-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-13** Second line-following sensor connected to power, ground, and
    data'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: With both line-following sensors connected, your breadboard should look something
    like [Figure 7-14](ch07.xhtml#ch07fig14).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f159-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-14** Both line-following sensors connected to the Raspberry Pi'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Mounting Your Sensors
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you need to mount your TCRT5000 modules onto the underside of the front
    of your robot.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: To avoid having to change the code demos later, make sure that the TCRT5000
    module you wired up *first* (the one connected to BCM 9) is on the *left side*
    of your robot, and the *second* TCRT5000 module (connected to BCM 11) is on the
    *right side* of your robot.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: You can mount these sensors to your chassis in whatever way you like. If you’re
    using a LEGO-based robot like mine, I recommend attaching two small stalks made
    of 2×2 LEGO blocks to the bottom of your chassis; mine are roughly four blocks
    deep. You can then also use sticky tack to affix your modules onto the bottom
    of the stalks as I have done (see [Figure 7-15](ch07.xhtml#ch07fig15)). I have
    routed the wires for the sensors through the gap in the middle of my LEGO chassis.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f160-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-15** My IR sensors, mounted on LEGO stalks on the underside of my
    robot'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: When mounting the modules, bear in mind that the optimal range from the optical
    sensor to the ground is between 1 mm and 8 mm. Also remember that the wider the
    gap between them, the more your robot will stray left or right before it corrects
    itself. For reference, mine are only an inch or two apart from each other and
    placed on either side of the front stabilizer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Programming Your Robot to Follow a Line
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With both your sensors wired up and mounted in place, it’s time to write the
    code that will allow your robot to follow a line.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up a new program using Nano and call it *line_follower.py* as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: pi@raspberrypi:~/robot $ nano line_follower.py
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 7-2](ch07.xhtml#ch07list2) takes the theory and process
    behind line following we discussed previously and puts it all into practice. Take
    a moment to look over the code before you move on to the explanation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**LISTING 7-2** Following a line'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The code here follows the same logical layout as previous projects in this book.
    We import `gpiozero`, then initiate a constant called `SPEED` and set it to 0.25
    ➊. This value, which represents the speed of your robot throughout the program,
    can be set to anything between 0 and 1.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code for the first time, you’ll discover that the speed at
    which your robot is traveling has a huge influence on its line-following ability.
    By defining a constant at the start of the program, you can easily tweak this
    setting without rifling through all of the rest of your code later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ we set up the first TCRT5000 sensor as a digital input and assign it to
    the variable `left`. Then we repeat the process for the second line-following
    sensor, assigning it to the variable `right`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'We then begin an infinite `while True` loop that contains the main logic of
    the program: a series of `if` statements. This is where the line-following theory
    is implemented.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The code at ➌ deals with the scenario in which both sensors are active and therefore
    both reading white. With no line detected, the program assumes that the line is
    directly underneath and between the sensors, and the robot proceeds forward at
    its given speed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Next, an `elif` statement ➍ catches the case when the left sensor is off and
    thus detecting black, but the right sensor is active and thus detecting white.
    In this scenario, we need to execute a corrective maneuver to turn the robot right.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Then, an almost identical `elif` statement ➎ accounts for when the right sensor
    detects the black line. The corrective maneuver turns the robot left this time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at ➏ we use an `else` statement to deal with the only option left:
    neither sensor is active and therefore both are reading black. The exact behavior
    of your robot after this is up to you to define. In my code I have decided to
    stop its movement.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Running Your Program: Make Your Robot Follow a Line!'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With your line-following program now complete, connect your robot to battery
    power and place it on the test track you created earlier. For the best results,
    ensure that the black line is directly underneath your robot and between the two
    TCRT5000 sensors (see [Figure 7-16](ch07.xhtml#ch07fig16)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f162-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7-16** My robot in place, ready to follow the line'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your program with this command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: pi@raspberrypi:~/robot $ python3 line_follower.py
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Your robot should now be moving around your track completely autonomously and
    sticking to the black line with no trouble at all. Admire your work as the robot
    scuttles around in an endless loop!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '*You may find that you need to stick your track down to the floor so that the
    wheels of your robot don’t move it around. If this is the case, just use some
    tape to securely and nonpermanently fix it in place.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: EXPERIMENTING WITH LINE FOLLOWING
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Line following is a classic lesson in robotics, but as you can probably tell,
    it can take a serious amount of tweaking and hacking to improve the effectiveness
    and results. You’ll probably have already noticed that you can alter many different
    factors to change the performance of your line follower. Here are some of my suggestions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 线路跟踪是机器人学中的经典课程，但正如你可能已经察觉到的，它可能需要大量的调整和修改才能提高效果和结果。你可能已经注意到，你可以通过改变许多不同的因素来改变线路跟踪器的性能。以下是我的一些建议。
- en: Change the Track
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 改变赛道
- en: While a simple loop is a great first-time test bed, it quickly becomes boring.
    To challenge your robot, try creating a more adventurous track. Use tighter corners,
    longer straights, and more advanced geometries! You can even get inspiration for
    new layouts from real race tracks—for example, the Monaco Grand Prix circuit in
    [Figure 7-17](ch07.xhtml#ch07fig17).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的回路是一个很好的初次测试平台，但它很快就会变得无聊。为了挑战你的机器人，试着创造一个更具冒险性的赛道。使用更紧的转弯、更长的直线和更复杂的几何形状！你甚至可以从真实的赛道中获得灵感——例如，见图
    7-17 中的摩纳哥大奖赛赛道（[Figure 7-17](ch07.xhtml#ch07fig17)）。
- en: '![Image](../images/f163-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f163-01.jpg)'
- en: '**FIGURE 7-17** The Monaco Grand Prix circuit represented as a black line that
    your robot could follow'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-17** 摩纳哥大奖赛赛道表示为一条黑线，你的机器人可以沿着这条线行驶'
- en: Change the Speed
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 改变速度
- en: The faster your robot is moving around the track, the less time it has to react
    to the information that the TCRT5000 sensors provide. At faster speeds, you may
    find that your robot drifts away from the line. You can change its speed by going
    back into the program and editing the `SPEED` constant defined at the top of the
    code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人在赛道上行驶得越快，它对TCRT5000传感器提供的信息反应的时间就越少。在更快的速度下，你可能会发现机器人会偏离线路。你可以通过进入程序，编辑代码顶部定义的`SPEED`常量来改变机器人的速度。
- en: You may also find that you want to change the speed of your line follower for
    different movements. For example, your robot may perform better if it goes around
    corners slower. You could add this functionality into the program by creating
    another constant called `CORNER_SPEED` and using it in the functions for turning
    left and right.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能会发现，你想要为不同的动作调整线路跟踪器的速度。例如，当机器人绕过转弯时，可能需要慢一点。你可以通过在程序中创建另一个常量`CORNER_SPEED`并将其应用到左右转弯的函数中来实现这一功能。
- en: As you fine-tune the speed of your line-following robot, time it as it goes
    around the track. See how fast you can get it to accurately follow the line. You
    could even race against some friends and have a line-following racing tournament
    to see whose code is best.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你微调你的线路跟踪机器人速度时，计时它绕赛道行驶的时间。看看你能让它多快地精确跟踪线路。你甚至可以和朋友们比赛，举办一场线路跟踪竞赛，看看谁的代码最好。
- en: Change the Position of Your Sensors
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 改变传感器的位置
- en: The farther apart the IR sensors are, the more your robot will stray from the
    line before executing a corrective maneuver. This could potentially lead to your
    robot fish-tailing along the line in a zigzag pattern. Experiment with moving
    the modules closer together to see how this affects how well your line follower
    operates.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 红外传感器之间的距离越远，你的机器人偏离线路的距离就越大，直到执行修正动作。这可能会导致你的机器人沿着线路呈之字形打滑。试着将模块放得更近，看看这会如何影响你的线路跟踪器的表现。
- en: You should find that the closer together the modules are, the more the robot
    will turn left and right to get back on track. This will mean that your robot
    follows the line more accurately, but at what cost? Does it affect the speed at
    which it can complete the course? Play around and find out!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会发现，当模块放得更近时，机器人会更多地左右转动以重新回到轨道。这意味着你的机器人会更精确地跟踪线路，但这会有什么代价呢？它是否会影响机器人完成赛道的速度？动动脑筋，试试看吧！
- en: Add More Sensors
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多传感器
- en: If you want to take this even further, add more line-following sensors. Just
    like with obstacle avoidance, the more information your robot has about its position,
    the more intelligent the program behind it can be. If you can add a third, fourth,
    or even fifth TCRT5000 module, then you can judge the degree by which your robot
    has strayed from the line. You could then use this information to change the magnitude
    of course corrections. For example, if the robot is far away from the line, it
    could execute a faster corrective maneuver.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: SUMMARY
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you’ve given your robot the ability to autonomously follow a
    line. We have covered everything from the theory of line following to the sensors
    you need and the code behind them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter I’ll show you how to use the official Raspberry Pi Camera
    Module to recognize and follow a colored ball!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
