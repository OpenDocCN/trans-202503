- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: LINE FOLLOWING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪线
- en: IN THIS CHAPTER YOU’LL GIVE YOUR ROBOT THE ABILITY TO DETECT AND FOLLOW A LINE
    AUTONOMOUSLY. IT WILL BE ABLE TO IDENTIFY ITS OWN COURSE AND THEN DECIDE EXACTLY
    HOW TO STICK TO IT.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将赋予机器人检测并自动跟随一条线的能力。它将能够识别自己的路径，然后决定如何精确地坚持走下去。
- en: This is a test of both digital recognition and clever programming. It is also
    a classic robotics task that is important for everyone to master, from beginners
    to professionals. By the end of this project you’ll have a fully autonomous robot
    that will be able to stick to a line like glue!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次对数字识别和巧妙编程的测试。它也是一个经典的机器人任务，对于每个人来说，从初学者到专业人士都很重要。完成这个项目后，你将拥有一个完全自主的机器人，它将能够像胶水一样坚持沿着线行驶！
- en: CREATING A TRACK
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建轨道
- en: As usual, prior to launching into any project, it is important and useful to
    step back and analyze the task at hand. The aim here is to make your robot follow
    a line. More specifically, you want to make your robot follow a black line on
    a white background, like the one shown in [Figure 7-1](ch07.xhtml#ch07fig1).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在开始任何项目之前，重要且有用的是退后一步，分析当前的任务。这里的目标是让你的机器人沿着一条线行驶。更具体地说，你希望让机器人沿着一个白色背景上的黑色线条行驶，像[图
    7-1](ch07.xhtml#ch07fig1)中所示的那样。
- en: '![image](../images/f146-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f146-01.jpg)'
- en: '**FIGURE 7-1** My robot following a black line'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-1** 我的机器人沿着黑线行驶'
- en: The combination of white and black provides maximum contrast for your robot,
    enabling us to use simple line-following sensors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 白色和黑色的组合提供了最大的对比度，帮助你的机器人使用简单的跟踪传感器。
- en: The first thing to do is create a line for your robot to follow. You can make
    the shape of this track as adventurous as you like. The simplest option is a basic
    loop, but feel free to get creative, as long as the background is white and the
    line is black. I also recommend making the width of the line around 1/4 inch.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是为你的机器人创建一条它可以跟随的线。你可以随意设计轨道的形状，最简单的选项是一个基本的环形，但只要背景是白色的，线条是黑色的，尽管发挥创意。我还建议将线条的宽度设定为大约
    1/4 英寸。
- en: There are many different ways of constructing a track. You could simply grab
    a large piece of paper (at least ledger size, roughly 11 × 17 inches) and draw
    a thick line with a black marker. You could use some black electrical tape on
    white poster board. You can even purchase premade line-following tracks online.
    If you have access to a printer, I recommend printing a track out on letter-size
    paper and assembling it with tape.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建轨道有很多不同的方法。你可以简单地拿一大张纸（至少是账单大小，大约 11 × 17 英寸），用黑色马克笔画上一条粗线。你也可以用一些黑色电工胶带贴在白色海报板上。你甚至可以在线购买现成的跟踪轨道。如果你有打印机，我建议在信纸大小的纸上打印出轨道，然后用胶带把它们拼接起来。
- en: 'I’ve also included the template for a set of tiles you can make into a track
    of any shape in the resources for this book, which you can access on your Windows,
    Mac, or Linux PC:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在本书的资源中提供了一个模板，供你制作成任意形状的轨道，你可以在 Windows、Mac 或 Linux 电脑上访问：
- en: If you haven’t done so already, download the software bundle from [*https://nostarch.com/raspirobots/*](https://nostarch.com/raspirobots/)
    onto your personal computer.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，下载软件包到你的个人电脑，网址是 [*https://nostarch.com/raspirobots/*](https://nostarch.com/raspirobots/)。
- en: Navigate to the folder where the software is stored, and then open the PDF named
    *track_generator.pdf*. This is a 34-page document that has a variety of 20 × 20
    cm tiles with different lines on them (see [Figure 7-2](ch07.xhtml#ch07fig2)).![image](../images/f147-01.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到存储软件的文件夹，然后打开名为*track_generator.pdf*的 PDF 文件。这是一个34页的文档，包含了许多20 × 20厘米的瓷砖，上面有不同的线条（见[图
    7-2](ch07.xhtml#ch07fig2)）。![image](../images/f147-01.jpg)
- en: '**FIGURE 7-2** The *track_generator.pdf* document'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 7-2** *track_generator.pdf* 文档'
- en: Print out whichever lines you want to put together into a track, cut them out,
    and then stick them together to form your own custom track. The first few pages
    of the PDF document show simple paths, such as straight lines and corners, but
    the farther down you scroll, the crazier the paths get!
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出你想要拼接成轨道的线条，剪下来，然后把它们粘在一起，组成你自己的自定义轨道。PDF 文档的前几页展示了简单的路径，如直线和拐角，但往下滚动，你会看到越来越复杂的路径！
- en: For your first track, I recommend keeping it relatively simple. Remember that
    you can always print out more tiles and make a more difficult course for your
    robot in the future.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于你的第一个轨道，我建议保持相对简单。记住，你可以随时打印出更多瓷砖，并在未来为你的机器人设计一个更难的课程。
- en: 'To create a simple loop, like the one in [Figure 7-3](ch07.xhtml#ch07fig3),
    print out four copies of Tile Type #2 (the straight line) and four copies of Tile
    Type #3 (the basic corner). You should be able to print these pages specifically
    using the printer dialog box of your PDF reader software. Ensure that each tile
    takes up one letter-size piece of paper.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个简单的环形轨道，像[图7-3](ch07.xhtml#ch07fig3)所示那样，打印出四份瓷砖类型#2（直线）和四份瓷砖类型#3（基本转角）。你应该能够通过PDF阅读器软件的打印对话框专门打印这些页面。确保每块瓷砖占用一张信纸大小的纸张。
- en: Use scissors to cut around the dotted line of each tile. Then arrange them in
    a loop, as shown in [Figure 7-3](ch07.xhtml#ch07fig3), and use tape along the
    length of the *underside* to join the edges of the tiles together. Your track
    is now complete!
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用剪刀沿着每块瓷砖的虚线剪开。然后按照[图7-3](ch07.xhtml#ch07fig3)所示将它们排列成环形，并沿着*底面*的长度使用胶带将瓷砖的边缘连接在一起。你的轨道现在已经完成！
- en: WARNING
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '*Make sure you don’t tape over the black line when you connect the tiles, as
    this may affect the sensors’ performance. Also try to eliminate any gaps or wrinkles
    between tiles—these can hinder your robot’s movement!*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保在连接瓷砖时不要把胶带贴在黑线上的位置，因为这可能会影响传感器的性能。同时尽量消除瓷砖之间的任何缝隙或褶皱——这些都会妨碍机器人运动！*'
- en: '![image](../images/f148-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f148-01.jpg)'
- en: '**FIGURE 7-3** My assembled basic line-following track'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-3** 我组装的基本跟踪轨道'
- en: THE THEORY BEHIND LINE FOLLOWING
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪线路背后的理论
- en: We’re going to use *infrared* (IR) sensors to make your Raspberry Pi robot follow
    the black line. We used similar technology for obstacle avoidance in [Chapter
    5](ch05.xhtml#ch05), when we used ultrasound for the purpose of detecting objects.
    But instead of sound, in this chapter we’ll use invisible light. Fortunately,
    much of the same theory you learned previously can be applied here too.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*红外*（IR）传感器让你的Raspberry Pi机器人跟踪黑色线条。在[第5章](ch05.xhtml#ch05)中，我们使用类似的技术来避障，当时我们使用超声波来检测物体。但在这一章，我们将使用不可见的光线，而不是声音。幸运的是，你之前学到的很多理论也可以在这里应用。
- en: Every IR sensor, like the one in [Figure 7-4](ch07.xhtml#ch07fig4), has two
    small bulb-like devices—an infrared transmitter and a receiver, normally arranged
    and positioned closely together. The transmitter is an IR LED that, when triggered,
    fires off a pulse of infrared light. The receiver, an IR photodiode, then waits
    for this transmitted light to return. A *photo­diode* is simply a device that
    uses light to vary an electric current.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IR传感器，如[图7-4](ch07.xhtml#ch07fig4)中的传感器，都有两个小的灯泡状装置——一个红外发射器和一个接收器，通常安排并紧密地放置在一起。发射器是一个IR
    LED，当被触发时，会发射一个红外光脉冲。接收器是一个IR光电二极管，等待接收到发射的光。*光电二极管*只是一个利用光线改变电流的装置。
- en: '![image](../images/f149-01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f149-01.jpg)'
- en: '**FIGURE 7-4** An IR sensor'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-4** 一个IR传感器'
- en: Light interacts differently with different types of surfaces. Most notably,
    light is *reflected* more by a white surface, and almost totally *absorbed* by
    a black surface, enabling the IR sensor to detect black lines on white backgrounds.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 光与不同类型的表面之间的相互作用是不同的。最明显的是，光在白色表面上*反射*更多，而在黑色表面上几乎完全被*吸收*，这使得IR传感器能够检测到白色背景上的黑色线条。
- en: As depicted in [Figure 7-5](ch07.xhtml#ch07fig5), if an IR sensor module is
    over a white surface, the receiver will detect the reflection of the infrared
    beam emitted by the transmitter. If the sensor is over a black surface, like the
    line of your track, the receiver will not detect the reflection. This difference
    in reflectance allows the sensor module to detect whether or not there is a line
    in front of it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图7-5](ch07.xhtml#ch07fig5)所示，如果IR传感器模块位于白色表面上，接收器将检测到发射器发出的红外光束的反射。如果传感器位于黑色表面上，比如你的轨道上的线，接收器将无法检测到反射。反射率的差异使得传感器模块能够检测到前方是否有线条。
- en: '![image](../images/f150-01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f150-01.jpg)'
- en: '**FIGURE 7-5** The different behavior of IR light as it meets a white versus
    a black surface'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-5** 红外光遇到白色与黑色表面的不同表现'
- en: 'Mounting a single IR sensor onto the bottom of your robot would enable it to
    detect the presence of a black line, but if your robot moved so the sensor was
    no longer directly over the line, it could easily go off-track. With only one
    sensor, there is no easy way for your robot to detect whether it has gone too
    far to the left or right of the line. Instead, we’ll use two IR sensors, both
    mounted on the bottom of your robot at the front, about an inch apart. Two sensors
    will provide a feedback mechanism with a sense of direction. There are four possibilities
    for the outputs of these sensors, each of which will guide the robot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个红外传感器安装在机器人底部，可以让它检测到黑色线条的存在，但如果机器人移动使得传感器不再直接位于线条上，它很容易偏离轨道。只有一个传感器，机器人无法轻松地检测自己是否已经偏离了线条的左侧或右侧。因此，我们将使用两个红外传感器，分别安装在机器人底部的前方，约一英寸的间距。两个传感器将提供一个反馈机制，帮助机器人判断方向。这些传感器的输出有四种可能，每种情况都会指导机器人。
- en: If both sensors receive a reflected signal and detect white, the robot can assume
    that the line must be in between the sensors. Therefore, the robot should move
    forward in a straight line (see [Figure 7-6](ch07.xhtml#ch07fig6)).![image](../images/f151-01.jpg)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个传感器都接收到反射信号并且检测到白色，机器人可以认为线条位于两个传感器之间。因此，机器人应沿直线向前移动（见[图 7-6](ch07.xhtml#ch07fig6)）。![image](../images/f151-01.jpg)
- en: '**FIGURE 7-6** The robot moves forward when both sensors detect white.'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 7-6** 当两个传感器都检测到白色时，机器人向前移动。'
- en: If the left sensor doesn’t receive a reflected signal but the right sensor does,
    this must mean that the left sensor detects the line. This indicates that the
    robot must be veering right, so it should turn left to correct itself, as in [Figure
    7-7](ch07.xhtml#ch07fig7).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果左侧传感器没有接收到反射信号，而右侧传感器接收到了，这就意味着左侧传感器检测到了线条。这表明机器人可能偏离了轨道向右，因此应该向左转以纠正自己，如[图
    7-7](ch07.xhtml#ch07fig7)所示。
- en: If the right sensor detects the line but the left sensor doesn’t, the robot
    should correct itself by turning right, as shown at the bottom of [Figure 7-7](ch07.xhtml#ch07fig7).![image](../images/f152-01.jpg)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果右侧传感器检测到线条而左侧传感器没有，机器人应该通过向右转来纠正自己，如[图 7-7](ch07.xhtml#ch07fig7)底部所示。![image](../images/f152-01.jpg)
- en: '**FIGURE 7-7** The robot turns left or right if one of the sensors detects
    the black line.'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 7-7** 如果其中一个传感器检测到黑色线条，机器人会向左或向右转动。'
- en: Finally, if neither sensor receives a reflected signal, then they must *both*
    be reading black, as shown in [Figure 7-8](ch07.xhtml#ch07fig8) (this won’t happen
    if you’re using just a basic loop track). What to do next is up to you, but one
    option is simply to make the robot stop. If you experiment with other track layouts—for
    example, a figure 8 shape—you might run into other situations where both sensors
    detect black. In these circumstances you may want your robot to move forward,
    turn, or even reverse—play around to find out what works best!
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果两个传感器都没有收到反射信号，那么它们*都*应该检测到黑色，如[图 7-8](ch07.xhtml#ch07fig8)所示（如果你使用的是基础的环形轨道，这种情况不会发生）。接下来该做什么由你决定，但一个选择是让机器人停止。如果你尝试其他轨道布局——例如，数字
    8 形状——你可能会遇到两个传感器都检测到黑色的情况。在这种情况下，你可能希望机器人前进、转弯，甚至倒退——试试看，找到最合适的方案！
- en: '![image](../images/f153-01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f153-01.jpg)'
- en: '**FIGURE 7-8** The robot stops if both sensors read black.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-8** 如果两个传感器都检测到黑色，机器人会停止。'
- en: USING AN IR SENSOR TO DETECT A LINE
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用红外传感器检测线条
- en: Before you start mounting two IR sensors to your Raspberry Pi and configuring
    the code behind a complete line-following robot, let’s wire up just one IR sensor
    and test its line detection response.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始将两个红外传感器安装到树莓派并配置完整的跟线机器人代码之前，让我们先连接一个红外传感器并测试它的线条检测反应。
- en: The Parts List
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部件清单
- en: For this part of the project you’ll use only one sensor, but make sure to buy
    two, as you’ll need both for the next project!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目部分，你只需要使用一个传感器，但请确保购买两个，因为下一个项目中你会需要两个！
- en: 2 TCRT5000-based infrared line-following sensor modules
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个基于 TCRT5000 的红外线跟踪传感器模块
- en: Jumper wires
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: TCRT5000-based line-following sensor modules, like the one shown in [Figure
    7-9](ch07.xhtml#ch07fig9), are very common and available online for less than
    a couple of dollars each. I sourced mine from eBay by searching “TCRT5000 Line
    Follow Module.” The *TCRT5000* part of the sensor name refers to the infrared
    optical sensor, the small black component on the underside of the board.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 TCRT5000 的线路跟踪传感器模块，如[图 7-9](ch07.xhtml#ch07fig9)中所示，非常常见，可以在网上以不到几美元的价格购买。我是通过在
    eBay 上搜索“TCRT5000 线路跟随模块”购买的。传感器名称中的*TCRT5000*部分指的是红外光学传感器，即电路板底部的小黑色组件。
- en: '![image](../images/f154-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f154-01.jpg)'
- en: '**FIGURE 7-9** My TCRT5000 infrared line-following sensor module'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-9** 我的 TCRT5000 红外线跟踪传感器模块'
- en: Make sure to get a line-following *module* like the one in [Figure 7-9](ch07.xhtml#ch07fig9),
    as this means the functionality of the optical sensor has been neatly packaged
    into an easy-to-use component. These boards have a simple set of pins and require
    just three connections (see [Figure 7-10](ch07.xhtml#ch07fig10)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保获取像[图 7-9](ch07.xhtml#ch07fig9)中所示的线路跟踪*模块*，因为这意味着光学传感器的功能已经被整齐地封装成一个易于使用的组件。这些板有一组简单的引脚，只需要三个连接（参见[图
    7-10](ch07.xhtml#ch07fig10)）。
- en: '![image](../images/f154-02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f154-02.jpg)'
- en: '**FIGURE 7-10** Pinout of a TCRT5000 IR sensor module'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-10** TCRT5000 红外传感器模块的引脚图'
- en: The infrared diode is housed inside the small black component and emits an infrared
    ray continuously when the module is connected to power. If the light is not reflected
    back into the sensor, it means a black line must be present and the output pin
    (OUT) of the module goes low (that is, it drops the voltage). This simple digital
    logic is ideal and, better still, the module can be powered natively from the
    Pi’s 3.3 V. This saves us from having to use a voltage divider circuit as we did
    for the ultrasonic distance sensor in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 红外二极管被封装在小黑色组件内部，并在模块连接电源时持续发射红外光。如果光线没有反射回传感器，说明必须存在一条黑线，并且模块的输出引脚（OUT）会变低（即电压下降）。这种简单的数字逻辑非常理想，更棒的是，模块可以通过
    Pi 的 3.3 V 电源供电。这样我们就不必像在[第 5 章](ch05.xhtml#ch05)中为超声波距离传感器所做的那样使用电压分压电路了。
- en: '**NOTE**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Remember that you don’t need to disconnect any of your previous circuits,
    but I won’t show those connections here.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住，您无需断开之前的任何电路，但我不会在这里显示这些连接。*'
- en: Wiring Up Your TCRT5000 Line-Following Sensor Module
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接线您的 TCRT5000 线路跟踪传感器模块
- en: 'Disconnect your Pi from power and wire up your sensor by following these instructions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 断开树莓派的电源，并按照以下说明连接您的传感器：
- en: Use an F-F jumper wire to connect the VCC pin of your TCRT5000 module to physical
    pin 1 of your Raspberry Pi. This is the +3.3 V connection and provides power to
    the sensor.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一根 F-F 跳线将 TCRT5000 模块的 VCC 引脚连接到树莓派的物理引脚 1。这是 +3.3 V 连接，提供传感器的电源。
- en: Use another jumper wire to connect the GND pin of your module to the common
    ground rail on your breadboard. So far, your wiring should look like [Figure 7-11](ch07.xhtml#ch07fig11).![image](../images/f155-01.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一根跳线将模块的 GND 引脚连接到面包板上的公共接地轨道。到目前为止，您的接线应该像[图 7-11](ch07.xhtml#ch07fig11)所示。![image](../images/f155-01.jpg)
- en: '**FIGURE 7-11** Line-following sensor connected to +3.3 V and GND'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 7-11** 线路跟踪传感器连接到 +3.3 V 和 GND'
- en: Use another jumper wire to connect the data output pin of your sensor (OUT)
    to physical pin 21 on your Raspberry Pi. This is BCM 9\. Your complete circuit
    should look like [Figure 7-12](ch07.xhtml#ch07fig12).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一根跳线将传感器的数据输出引脚（OUT）连接到树莓派的物理引脚 21。这是 BCM 9。您的完整电路应该像[图 7-12](ch07.xhtml#ch07fig12)所示。
- en: '![image](../images/f156-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f156-01.jpg)'
- en: '**FIGURE 7-12** Completed breadboard diagram with your TCRT5000 line-following
    sensor module wired up and in place'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-12** 完整的面包板电路图，展示了您的 TCRT5000 线路跟踪传感器模块已经接线并就位'
- en: Programming Your Raspberry Pi to Detect a Line
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编程您的树莓派以检测线路
- en: 'Now that you have a line sensor connected to your Raspberry Pi, let’s write
    some code to test its line detection response. Connect your Pi to power via a
    wall outlet, boot it up and move into your code folder, and then enter the following
    to create and open a test program called *line_test.py*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将线路传感器连接到树莓派，让我们编写一些代码来测试其线路检测响应。通过墙壁插座为树莓派供电，启动它并进入代码文件夹，然后输入以下命令创建并打开一个名为*line_test.py*的测试程序：
- en: pi@raspberrypi:~/robot $ nano line_test.py
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano line_test.py
- en: Add the code in [Listing 7-1](ch07.xhtml#ch07list1), which will test your TCRT5000
    module. The purpose of this program is to simply output to the terminal to inform
    the user whether the module has detected a line.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加[清单7-1](ch07.xhtml#ch07list1)中的代码，这将测试你的TCRT5000模块。该程序的目的是仅仅输出到终端，告知用户模块是否检测到了一条线。
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**LISTING 7-1** Detecting a line'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7-1** 检测一条线'
- en: After importing the usual libraries, we set up the line sensor as a digital
    input on BCM 9 ➊.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入常用库之后，我们将线传感器设置为BCM 9上的数字输入 ➊。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The TCRT5000 has a detection distance between 1 mm and 8 mm. If the line is
    farther away from the sensor than this, it is likely to give false positives or
    negatives.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*TCRT5000的检测距离在1毫米到8毫米之间。如果线条距离传感器太远，它可能会出现误报或漏报。*'
- en: We then start an infinite `while True` loop containing the logic of the program.
    At ➋ we use an `if` statement to detect whether the line sensor is active. If
    it *isn’t* active, it must mean the infrared reflection has not returned and therefore
    the emitted rays have been absorbed by the black line. Thus, the line has been
    detected, and we indicate this to the user with the `print()` statement inside
    the `if` statement.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始一个无限的`while True`循环，包含程序的逻辑。在 ➋ 处，我们使用`if`语句来检测线传感器是否处于活动状态。如果它*没有*处于活动状态，必须意味着红外反射没有返回，因此发射的光线已经被黑线吸收。所以，线条已经被检测到，并且我们通过`if`语句内的`print()`语句告知用户。
- en: Any other scenario would mean that the line sensor is active and therefore is
    *not* detecting a line. The `else` statement ➌ catches this alternative scenario
    and outputs to the user that a line has not been detected. The program then waits
    for a fifth of a second and loops back around.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他情况都意味着线传感器是活动的，因此*没有*检测到一条线。`else`语句 ➌ 捕获了这种替代情况，并输出到用户，告知没有检测到线。程序随后等待五分之一秒并重新开始循环。
- en: 'Running Your Program: Detect a Line!'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：检测一条线！
- en: 'After saving your program, grab a piece of your track to test out your sensor.
    To run the program, enter:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 保存程序后，拿一段轨道来测试你的传感器。要运行程序，输入：
- en: pi@raspberrypi:~/robot $ python3 line_test.py
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 line_test.py
- en: 'While there is nothing within range of the sensor, it may produce erratic results
    that will be displayed in the terminal. Bring your piece of track up to the module
    and move the line over the sensor. You should notice that as you move the piece,
    the terminal output will change to `Line detected`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当传感器周围没有任何物体时，可能会产生不稳定的结果，这些结果会显示在终端中。将你的轨道带到模块上并移动线条到传感器上。你应该会注意到，随着你移动轨道，终端输出会变化为`Line
    detected`：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: My particular sensor also has an LED on the top that changes state when the
    line comes into view.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我的传感器上也有一个LED灯，当线条出现在视野中时，它会改变状态。
- en: If you’re having issues with your module and it’s not detecting the line very
    well, you can try a few things. First, try to limit inter­ference from other light
    sources by turning the lights off. Alternatively, some TCRT5000 modules have an
    on-board potentiometer to adjust their sensitivity. This usually looks like a
    piece of blue/white plastic with a place to insert a screwdriver. Use an appropriate
    screwdriver or other implement to twist this potentio­meter to see if it improves
    your readings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到模块问题，且它没有很好地检测到线条，可以尝试几种方法。首先，尝试通过关闭灯光来限制来自其他光源的干扰。或者，一些TCRT5000模块上有一个内置的电位器，用于调整灵敏度。这个电位器通常看起来像一块蓝白色的塑料，上面有一个可以插入螺丝刀的地方。使用合适的螺丝刀或其他工具来旋转这个电位器，看看是否能改善你的读数。
- en: MAKE YOUR ROBOT FOLLOW A LINE AUTONOMOUSLY
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让你的机器人自主跟踪一条线
- en: When your sensor is successfully detecting the line, it’s time to give your
    robot the ability to follow the track.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的传感器成功检测到线条时，就该给你的机器人增加跟踪轨迹的能力了。
- en: By the end of this project, you’ll have connected up a second sensor and programmed
    the logic behind a fully autonomous program, giving you a line-following robot.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目结束时，你将连接上第二个传感器，并编写完整的自主程序逻辑，打造一台能够跟踪线路的机器人。
- en: Wiring Up the Second TCRT5000 Line-Following Sensor Module
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接第二个TCRT5000线跟踪传感器模块
- en: You’ve already wired up the first TCRT5000 module, so now you only need to wire
    up the second one. If you don’t have the first one connected, flip back a few
    pages and follow the wiring guide in the previous project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经连接了第一个TCRT5000模块，现在只需连接第二个模块。如果第一个模块没有连接，请翻回几页，按照之前项目中的接线指南进行操作。
- en: 'The process for connecting your second sensor is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 连接第二个传感器的过程如下：
- en: Take a F-F jumper wire and connect the VCC pin of your second TCRT5000 module
    to physical pin 17 on your Raspberry Pi. This is another +3.3 V pin and will power
    the sensor.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿一根 F-F 跳线，将第二个 TCRT5000 模块的 VCC 引脚连接到 Raspberry Pi 上的物理引脚 17。这是另一个 +3.3 V 引脚，将为传感器提供电源。
- en: Now, use a jumper wire to connect the GND pin of the new module to the common
    ground rail on your breadboard.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用一根跳线将新模块的 GND 引脚连接到面包板上的公共地轨。
- en: Use a wire to connect the data output pin of your second sensor (OUT) to physical
    pin 23 on your Pi. This is BCM 11\. The wiring for the second sensor, with the
    first sensor omitted, should look like [Figure 7-13](ch07.xhtml#ch07fig13).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一根电线将第二个传感器的数据输出引脚（OUT）连接到 Raspberry Pi 的物理引脚 23。这是 BCM 11。第二个传感器的接线（省略第一个传感器）应类似于[图
    7-13](ch07.xhtml#ch07fig13)所示。
- en: '![image](../images/f158-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f158-01.jpg)'
- en: '**FIGURE 7-13** Second line-following sensor connected to power, ground, and
    data'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-13** 第二个线路跟踪传感器连接到电源、地和数据'
- en: With both line-following sensors connected, your breadboard should look something
    like [Figure 7-14](ch07.xhtml#ch07fig14).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个线路跟踪传感器连接后，你的面包板应该像[图 7-14](ch07.xhtml#ch07fig14)一样。
- en: '![image](../images/f159-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f159-01.jpg)'
- en: '**FIGURE 7-14** Both line-following sensors connected to the Raspberry Pi'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-14** 两个线路跟踪传感器连接到 Raspberry Pi'
- en: Mounting Your Sensors
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装你的传感器
- en: Now you need to mount your TCRT5000 modules onto the underside of the front
    of your robot.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将 TCRT5000 模块安装到机器人前部的底面。
- en: To avoid having to change the code demos later, make sure that the TCRT5000
    module you wired up *first* (the one connected to BCM 9) is on the *left side*
    of your robot, and the *second* TCRT5000 module (connected to BCM 11) is on the
    *right side* of your robot.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免以后修改代码示例，确保你首先连接的 TCRT5000 模块（连接到 BCM 9 的那个）位于机器人*左侧*，第二个 TCRT5000 模块（连接到
    BCM 11 的那个）位于机器人*右侧*。
- en: You can mount these sensors to your chassis in whatever way you like. If you’re
    using a LEGO-based robot like mine, I recommend attaching two small stalks made
    of 2×2 LEGO blocks to the bottom of your chassis; mine are roughly four blocks
    deep. You can then also use sticky tack to affix your modules onto the bottom
    of the stalks as I have done (see [Figure 7-15](ch07.xhtml#ch07fig15)). I have
    routed the wires for the sensors through the gap in the middle of my LEGO chassis.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据自己的需求将这些传感器安装到底盘上。如果你使用的是像我一样的 LEGO 机器人，建议将两个由 2×2 LEGO 块组成的小支架固定到底盘底部；我的支架大约有四个块高。你还可以使用粘性胶将模块固定在支架底部，就像我做的那样（见[图
    7-15](ch07.xhtml#ch07fig15)）。我已经将传感器的电线穿过 LEGO 底盘中间的空隙。
- en: '![image](../images/f160-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f160-01.jpg)'
- en: '**FIGURE 7-15** My IR sensors, mounted on LEGO stalks on the underside of my
    robot'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-15** 我安装在 LEGO 支架上的红外传感器，位于机器人底部'
- en: When mounting the modules, bear in mind that the optimal range from the optical
    sensor to the ground is between 1 mm and 8 mm. Also remember that the wider the
    gap between them, the more your robot will stray left or right before it corrects
    itself. For reference, mine are only an inch or two apart from each other and
    placed on either side of the front stabilizer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安装模块时，请记住，从光学传感器到地面的最佳距离范围为 1 毫米至 8 毫米。同时还要记住，它们之间的间隙越大，你的机器人偏离线路的幅度就越大，直到它纠正自己。作为参考，我的传感器彼此之间仅相隔一到两英寸，并且分别放置在前部稳定器的两侧。
- en: Programming Your Robot to Follow a Line
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编程让你的机器人沿线行驶
- en: With both your sensors wired up and mounted in place, it’s time to write the
    code that will allow your robot to follow a line.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的传感器都已连接并安装到位时，接下来是编写代码，让你的机器人能够沿着线路行驶。
- en: 'Open up a new program using Nano and call it *line_follower.py* as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Nano 打开一个新的程序，并命名为 *line_follower.py*，如下所示：
- en: pi@raspberrypi:~/robot $ nano line_follower.py
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano line_follower.py
- en: The code in [Listing 7-2](ch07.xhtml#ch07list2) takes the theory and process
    behind line following we discussed previously and puts it all into practice. Take
    a moment to look over the code before you move on to the explanation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-2](ch07.xhtml#ch07list2)中的代码将我们之前讨论的线路跟踪的理论和过程付诸实践。在继续讲解之前，花点时间查看一下代码。'
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**LISTING 7-2** Following a line'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 7-2** 沿线路行驶'
- en: The code here follows the same logical layout as previous projects in this book.
    We import `gpiozero`, then initiate a constant called `SPEED` and set it to 0.25
    ➊. This value, which represents the speed of your robot throughout the program,
    can be set to anything between 0 and 1.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码遵循与本书中之前项目相同的逻辑布局。我们导入`gpiozero`，然后初始化一个常量`SPEED`，并将其设置为0.25 ➊。这个值表示机器人在整个程序中的速度，可以设置为0到1之间的任何值。
- en: When you run this code for the first time, you’ll discover that the speed at
    which your robot is traveling has a huge influence on its line-following ability.
    By defining a constant at the start of the program, you can easily tweak this
    setting without rifling through all of the rest of your code later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行这段代码时，你会发现机器人行驶速度对其循迹能力有巨大影响。通过在程序开始时定义一个常量，你可以轻松地调整这个设置，而无需在后续的代码中翻找。
- en: At ➋ we set up the first TCRT5000 sensor as a digital input and assign it to
    the variable `left`. Then we repeat the process for the second line-following
    sensor, assigning it to the variable `right`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处，我们将第一个TCRT5000传感器设置为数字输入，并将其赋值给变量`left`。然后我们对第二个循迹传感器执行相同操作，将其赋值给变量`right`。
- en: 'We then begin an infinite `while True` loop that contains the main logic of
    the program: a series of `if` statements. This is where the line-following theory
    is implemented.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始一个无限的`while True`循环，包含程序的主要逻辑：一系列的`if`语句。这里就是实现循迹理论的地方。
- en: The code at ➌ deals with the scenario in which both sensors are active and therefore
    both reading white. With no line detected, the program assumes that the line is
    directly underneath and between the sensors, and the robot proceeds forward at
    its given speed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处的代码处理了两传感器都活跃并且都读取到白色的情况。在没有检测到黑线的情况下，程序假设黑线就在传感器下方，并且机器人按照给定速度向前行驶。
- en: Next, an `elif` statement ➍ catches the case when the left sensor is off and
    thus detecting black, but the right sensor is active and thus detecting white.
    In this scenario, we need to execute a corrective maneuver to turn the robot right.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个`elif`语句 ➍ 捕捉到左传感器关闭并检测到黑色，而右传感器活跃并检测到白色的情况。在这种情况下，我们需要执行纠正操作，使机器人右转。
- en: Then, an almost identical `elif` statement ➎ accounts for when the right sensor
    detects the black line. The corrective maneuver turns the robot left this time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，几乎相同的`elif`语句 ➎ 处理右传感器检测到黑线的情况。这时，纠正操作使机器人左转。
- en: 'Finally, at ➏ we use an `else` statement to deal with the only option left:
    neither sensor is active and therefore both are reading black. The exact behavior
    of your robot after this is up to you to define. In my code I have decided to
    stop its movement.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在➏处我们使用`else`语句处理剩下的唯一选项：两个传感器都不活跃，因此都读取为黑色。机器人在此之后的具体行为由你来定义。在我的代码中，我决定停止它的运动。
- en: 'Running Your Program: Make Your Robot Follow a Line!'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：让你的机器人沿线行驶！
- en: With your line-following program now complete, connect your robot to battery
    power and place it on the test track you created earlier. For the best results,
    ensure that the black line is directly underneath your robot and between the two
    TCRT5000 sensors (see [Figure 7-16](ch07.xhtml#ch07fig16)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着你的循迹程序完成，将机器人连接到电池电源，并将其放置在你先前创建的测试轨道上。为了获得最佳效果，确保黑线正好位于机器人下方，并且在两个TCRT5000传感器之间（参见[图7-16](ch07.xhtml#ch07fig16)）。
- en: '![image](../images/f162-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f162-01.jpg)'
- en: '**FIGURE 7-16** My robot in place, ready to follow the line'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-16** 我的机器人就位，准备沿线行驶'
- en: 'Run your program with this command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: pi@raspberrypi:~/robot $ python3 line_follower.py
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 line_follower.py
- en: Your robot should now be moving around your track completely autonomously and
    sticking to the black line with no trouble at all. Admire your work as the robot
    scuttles around in an endless loop!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人现在应该能够完全自主地沿着轨道行驶，并且毫无问题地跟随黑线。看着机器人在无尽的循环中快速穿行，欣赏你的成果吧！
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may find that you need to stick your track down to the floor so that the
    wheels of your robot don’t move it around. If this is the case, just use some
    tape to securely and nonpermanently fix it in place.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会发现需要将轨道粘贴到地板上，以防止机器人轮子将其移位。如果是这种情况，只需用胶带将轨道固定好，确保稳固且不永久性固定。*'
- en: EXPERIMENTING WITH LINE FOLLOWING
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 循迹实验
- en: Line following is a classic lesson in robotics, but as you can probably tell,
    it can take a serious amount of tweaking and hacking to improve the effectiveness
    and results. You’ll probably have already noticed that you can alter many different
    factors to change the performance of your line follower. Here are some of my suggestions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 线路跟踪是机器人学中的经典课程，但正如你可能已经察觉到的，它可能需要大量的调整和修改才能提高效果和结果。你可能已经注意到，你可以通过改变许多不同的因素来改变线路跟踪器的性能。以下是我的一些建议。
- en: Change the Track
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 改变赛道
- en: While a simple loop is a great first-time test bed, it quickly becomes boring.
    To challenge your robot, try creating a more adventurous track. Use tighter corners,
    longer straights, and more advanced geometries! You can even get inspiration for
    new layouts from real race tracks—for example, the Monaco Grand Prix circuit in
    [Figure 7-17](ch07.xhtml#ch07fig17).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的回路是一个很好的初次测试平台，但它很快就会变得无聊。为了挑战你的机器人，试着创造一个更具冒险性的赛道。使用更紧的转弯、更长的直线和更复杂的几何形状！你甚至可以从真实的赛道中获得灵感——例如，见图
    7-17 中的摩纳哥大奖赛赛道（[Figure 7-17](ch07.xhtml#ch07fig17)）。
- en: '![Image](../images/f163-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f163-01.jpg)'
- en: '**FIGURE 7-17** The Monaco Grand Prix circuit represented as a black line that
    your robot could follow'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-17** 摩纳哥大奖赛赛道表示为一条黑线，你的机器人可以沿着这条线行驶'
- en: Change the Speed
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 改变速度
- en: The faster your robot is moving around the track, the less time it has to react
    to the information that the TCRT5000 sensors provide. At faster speeds, you may
    find that your robot drifts away from the line. You can change its speed by going
    back into the program and editing the `SPEED` constant defined at the top of the
    code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人在赛道上行驶得越快，它对TCRT5000传感器提供的信息反应的时间就越少。在更快的速度下，你可能会发现机器人会偏离线路。你可以通过进入程序，编辑代码顶部定义的`SPEED`常量来改变机器人的速度。
- en: You may also find that you want to change the speed of your line follower for
    different movements. For example, your robot may perform better if it goes around
    corners slower. You could add this functionality into the program by creating
    another constant called `CORNER_SPEED` and using it in the functions for turning
    left and right.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能会发现，你想要为不同的动作调整线路跟踪器的速度。例如，当机器人绕过转弯时，可能需要慢一点。你可以通过在程序中创建另一个常量`CORNER_SPEED`并将其应用到左右转弯的函数中来实现这一功能。
- en: As you fine-tune the speed of your line-following robot, time it as it goes
    around the track. See how fast you can get it to accurately follow the line. You
    could even race against some friends and have a line-following racing tournament
    to see whose code is best.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你微调你的线路跟踪机器人速度时，计时它绕赛道行驶的时间。看看你能让它多快地精确跟踪线路。你甚至可以和朋友们比赛，举办一场线路跟踪竞赛，看看谁的代码最好。
- en: Change the Position of Your Sensors
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 改变传感器的位置
- en: The farther apart the IR sensors are, the more your robot will stray from the
    line before executing a corrective maneuver. This could potentially lead to your
    robot fish-tailing along the line in a zigzag pattern. Experiment with moving
    the modules closer together to see how this affects how well your line follower
    operates.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 红外传感器之间的距离越远，你的机器人偏离线路的距离就越大，直到执行修正动作。这可能会导致你的机器人沿着线路呈之字形打滑。试着将模块放得更近，看看这会如何影响你的线路跟踪器的表现。
- en: You should find that the closer together the modules are, the more the robot
    will turn left and right to get back on track. This will mean that your robot
    follows the line more accurately, but at what cost? Does it affect the speed at
    which it can complete the course? Play around and find out!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会发现，当模块放得更近时，机器人会更多地左右转动以重新回到轨道。这意味着你的机器人会更精确地跟踪线路，但这会有什么代价呢？它是否会影响机器人完成赛道的速度？动动脑筋，试试看吧！
- en: Add More Sensors
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多传感器
- en: If you want to take this even further, add more line-following sensors. Just
    like with obstacle avoidance, the more information your robot has about its position,
    the more intelligent the program behind it can be. If you can add a third, fourth,
    or even fifth TCRT5000 module, then you can judge the degree by which your robot
    has strayed from the line. You could then use this information to change the magnitude
    of course corrections. For example, if the robot is far away from the line, it
    could execute a faster corrective maneuver.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步提升，可以添加更多的线路跟踪传感器。就像避障一样，机器人对于自身位置的信息越多，背后的程序就越智能。如果你能够添加第三、第四甚至第五个TCRT5000模块，那么你就可以判断机器人偏离线路的程度。然后，你可以利用这些信息来调整修正动作的幅度。例如，如果机器人偏离线路较远，它可以执行更快速的修正操作。
- en: SUMMARY
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you’ve given your robot the ability to autonomously follow a
    line. We have covered everything from the theory of line following to the sensors
    you need and the code behind them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你已经赋予了你的机器人自主跟踪一条线路的能力。我们涵盖了从线路跟踪的理论到所需传感器以及它们背后的代码的所有内容。
- en: In the next chapter I’ll show you how to use the official Raspberry Pi Camera
    Module to recognize and follow a colored ball!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将向你展示如何使用官方的树莓派相机模块来识别和跟踪一个彩色球！
