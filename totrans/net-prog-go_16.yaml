- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Data Serialization
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据序列化
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: A sizable portion of our work as developers involves integrating our network
    services with existing services, including legacy or third-party ones implemented
    in languages other than Go. These services must communicate by exchanging bytes
    of data in a way that is meaningful to both the sender and receiver, despite the
    different programming languages they’re using. To do this, the sender converts
    data into bytes using a standard format and transfers the bytes over the network
    to the receiver. If the receiver understands the format used by the sender, it
    can convert the bytes back into structured data. This process of transforming
    structured data into successive bytes is known as *data serialization*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们的工作很大一部分是将我们的网络服务与现有服务进行集成，包括用其他编程语言实现的遗留服务或第三方服务。这些服务必须通过交换数据字节进行通信，这种通信方式对发送方和接收方都能理解，尽管他们使用的是不同的编程语言。为此，发送方使用标准格式将数据转换为字节，并通过网络将字节传输给接收方。如果接收方理解发送方使用的格式，它就能将字节转换回结构化数据。这个将结构化数据转化为连续字节的过程称为*数据序列化*。
- en: Services can use data serialization to convert structured data to a series of
    bytes suitable for transport over a network or for persistence to storage. No
    matter whether the serialized data came from a network or disk, any code that
    understands the serialization format should be able to deserialize it to reconstruct
    a clone of the original object.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以使用数据序列化将结构化数据转换为适合在网络上传输或持久化到存储的字节序列。无论序列化的数据来自网络还是磁盘，任何理解该序列化格式的代码都应该能够反序列化这些数据，恢复出原始对象的副本。
- en: While writing this chapter, I initially struggled to explain the concept of
    data serialization. Then I realized we serialize data as we speak. Electrical
    impulses in my brain form words. My brain instructs my voice box to *serialize*
    these words into sound waves, which travel through the air and reach your ear.
    The sound waves vibrate your eardrum, which in turn transmits the vibrations to
    your inner ear. Hair-like structures in your inner ear deserialize these vibrations
    into electrical signals that your brain interprets as the original words I formed
    in my brain. We’ve just communicated using the serialization format of English,
    since it’s a format we both understand.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这章时，我一开始很难解释数据序列化的概念。后来我意识到，我们在说话时其实就是在序列化数据。大脑中的电信号形成单词，然后大脑指示声带将这些单词*序列化*为声波，这些声波穿过空气到达你的耳朵。声波使你的耳膜振动，进而将振动传递到内耳。内耳中的类毛结构将这些振动反序列化为电信号，这些电信号被你的大脑解释为我大脑中形成的原始单词。我们刚刚使用英语这种序列化格式进行了交流，因为这是我们都能理解的格式。
- en: You already have a bit of experience serializing data in your Go code too. The
    type-length-value binary encoding you learned in Chapter 4 and the JavaScript
    Object Notation (JSON) you posted over HTTP in Chapter 8 are examples of translating
    objects into well-known data serialization formats. We also PEM-encoded the certificates
    and private keys in Chapter 11 for persistence to disk.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 Go 代码中也已经有了一些序列化数据的经验。你在第 4 章学到的类型-长度-值二进制编码，以及在第 8 章通过 HTTP 发送的 JavaScript
    对象表示法（JSON），都是将对象转化为众所周知的数据序列化格式的例子。在第 11 章中，我们还对证书和私钥进行了 PEM 编码，以便将其持久化到磁盘中。
- en: 'This chapter will take a deeper dive into using data serialization for the
    purposes of storing data or sending between systems, which can make it accessible
    to services written in other languages. We could cover many data serialization
    formats, but we’ll focus on the three that get the most use in Go network programming:
    JSON, protocol buffers, and Gob. We’ll also spend some time on how to execute
    code on remote machines using a framework named gRPC. By the end of this chapter,
    you will know how to serialize data for storage or transmission and decode that
    data into meaningful data structures. You should be able to use techniques in
    this chapter to build services that can exchange complex data over a network or
    write code to communicate with existing network services.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨如何使用数据序列化来存储数据或在系统之间传输数据，这使得数据可以被用其他语言编写的服务访问。我们可以讨论许多数据序列化格式，但我们将重点讨论
    Go 网络编程中最常用的三种格式：JSON、协议缓冲区（protocol buffers）和 Gob。我们还将花一些时间介绍如何使用一个名为 gRPC 的框架在远程机器上执行代码。到本章结束时，你将知道如何序列化数据以便存储或传输，并能够将这些数据解码成有意义的数据结构。你应该能够使用本章中的技术构建可以通过网络交换复杂数据的服务，或者编写代码与现有的网络服务进行通信。
- en: Serializing Objects
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化对象
- en: Objects or structured data cannot traverse a network connection as is. In other
    words, you cannot pass in an object to `net.Conn`’s `Write` method, since it accepts
    only a byte slice. Therefore, you need to serialize the object to a byte slice,
    which you can then pass to the `Write` method. Thankfully, Go makes this easy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对象或结构化数据不能直接通过网络连接传输。换句话说，不能将对象传递给`net.Conn`的`Write`方法，因为它只接受字节切片。因此，你需要将对象序列化为字节切片，然后才能传递给`Write`方法。幸运的是，Go让这个过程变得很简单。
- en: Go’s standard library includes excellent support for popular data serialization
    formats in its `encoding` package. You’ve already used `encoding/binary` to serialize
    numbers into byte sequences, `encoding/json` to serialize objects into JSON for
    submission over HTTP, and `encoding/pem` to serialize TLS certificates and private
    keys to files. (Anytime you encounter a function or method whose name includes
    *encode* or *marshal*, it likely serializes data. Likewise, *decode* and *unmarshal*
    are synonymous with deserializing data.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go的标准库在其`encoding`包中对流行的数据序列化格式提供了出色的支持。你已经使用了`encoding/binary`将数字序列化为字节序列，使用`encoding/json`将对象序列化为JSON以便通过HTTP提交，使用`encoding/pem`将TLS证书和私钥序列化为文件。（每当你遇到一个函数或方法，其名称中包含*encode*或*marshal*时，它可能会进行数据序列化。同样，*decode*和*unmarshal*与反序列化数据是同义词。）
- en: 'This section will build an application that serializes data into three binary
    encoding formats: JSON, protocol buffers, and Gob. Since I often have trouble
    keeping track of housework, the application will document chores to do around
    the house. The application’s state will persist between executions because you
    don’t want it to forget the chores when it exits. You’ll serialize each task to
    a file and use your app to update it as needed.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将构建一个应用程序，将数据序列化为三种二进制编码格式：JSON、协议缓冲区和Gob。由于我常常难以记住家务，所以这个应用程序将记录需要做的家务。应用程序的状态将在执行之间持久化，因为你不希望它在退出时忘记家务。你将把每个任务序列化到文件中，并使用你的应用程序根据需要更新它。
- en: To keep this program simple, you need a description of the chore and a way to
    determine whether it’s complete. [Listing 12-1](#listing12-1) defines a new package
    with a type that represents a household chore.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持程序简洁，你需要一个家务的描述，并且有一种方法来确定它是否已完成。[列表12-1](#listing12-1)定义了一个新的包，其中包含一个表示家庭家务的类型。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 12-1: A type to represent a household chore (*housework/housework.go*)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12-1：表示家庭家务的类型（*housework/housework.go*）
- en: Go’s JSON and Gob encoding packages can serialize exported struct fields only,
    so you define `Chore` as a struct, making sure to export its fields. The `Complete`
    field’s value will be `true` if you’ve completed the chore. The `Description`
    field is the human-readable description of the chore.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go的JSON和Gob编码包只能序列化导出的结构体字段，因此你将`Chore`定义为一个结构体，并确保其字段是导出的。如果你已经完成了家务，`Complete`字段的值将为`true`。`Description`字段是家务的可读描述。
- en: You could use struct tags to instruct the encoders on how to treat each field,
    if necessary. For example, you could place the struct tag `` `json:"-"` `` on
    the `Complete` field to tell Go’s JSON encoder to ignore this field instead of
    encoding it. Since you’re perfectly happy to pass along all field values, you
    omit struct tags.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以使用结构体标签来指示编码器如何处理每个字段。例如，你可以在`Complete`字段上添加结构体标签`` `json:"-"` ``，告诉Go的JSON编码器忽略该字段，而不是对其进行编码。由于你完全愿意传递所有字段的值，因此可以省略结构体标签。
- en: Once you’ve defined a chore structure, you can use it in an application that
    tracks chores on the command line. This application should show a list of chores
    and their status, allow you to add chores to the list, and mark chores as complete.
    [Listing 12-2](#listing12-2) includes the initial code for this housework application,
    including its command line usage details.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了家务结构体，你可以在一个应用程序中使用它，跟踪命令行上的家务。这个应用程序应该显示家务的列表及其状态，允许你将家务添加到列表中，并标记家务为已完成。[列表12-2](#listing12-2)包括该家务应用程序的初始代码，其中包括其命令行使用细节。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 12-2: Initial housework application code (*cmd/housework.go*)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12-2：初始家务应用代码（*cmd/housework.go*）
- en: 'This bit of code sets up the command line arguments and their usage 2: you
    can specify the `add` argument, followed by a comma-separated list of chores to
    add to the list, or you can pass the argument `complete` and a chore number to
    mark the chore as complete. In the absence of command line options, the app will
    display the current list of chores.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了命令行参数及其用法2：你可以指定`add`参数，后跟以逗号分隔的任务列表来添加任务，或者你可以传递`complete`参数和任务编号来标记任务为完成。如果没有命令行选项，应用程序将显示当前的任务列表。
- en: Since the ultimate purpose of this application is to demonstrate data serialization,
    you’ll use multiple serialization formats to store the data. This should show
    you how easy it is to switch between various formats. To prepare for that, you
    include `import` statements for those formats 1. This will make it easier for
    you to switch between the formats later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此应用程序的最终目的是演示数据序列化，你将使用多种序列化格式来存储数据。这将向你展示如何轻松地在不同格式之间切换。为此，你包括了这些格式的`import`语句1。这将使你以后更容易在这些格式之间切换。
- en: Let’s write the code to load chores from storage (see [Listing 12-3](#listing12-3)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码从存储中加载任务（参见[列表 12-3](#listing12-3)）。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 12-3: Deserializing chores from a file (*cmd/housework.go*)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-3：从文件中反序列化任务 (*cmd/housework.go*)
- en: This function returns a slice of pointers to `housework.Chore` structs from
    [Listing 12-1](#listing12-1). If the data file does not exist 1, you exit early,
    returning an empty slice. This default case will occur when you first run the
    application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个指向`housework.Chore`结构体的指针切片，来自[列表 12-1](#listing12-1)。如果数据文件不存在1，你将提前退出并返回一个空切片。这个默认情况会在你第一次运行应用程序时发生。
- en: If the app finds a data file, you open it 2 and pass it along to the storage’s
    `Load` function 3, which expects an `io.Reader`. You used the same pattern of
    accepting an interface and returning a concrete type in previous chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序找到数据文件，你将打开它2，并将其传递给存储的`Load`函数3，后者期望一个`io.Reader`。你在前几章中使用了相同的接受接口并返回具体类型的模式。
- en: '[Listing 12-4](#listing12-4) defines a function that flushes the chores in
    memory to your storage for persistence.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-4](#listing12-4)定义了一个函数，用于将内存中的任务刷新到存储中以便持久化。'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 12-4: Flushing chores to the storage (*cmd/housework.go*)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-4：将任务刷新到存储中 (*cmd/housework.go*)
- en: Here, you create a new file or truncate the existing file 1 and pass the file
    pointer and slice of chores to the storage’s `Flush` function 2. This function
    accepts an `io.Writer` and your slice. There’s certainly room for improvement
    in the way you handle the existing serialized file. But for the purposes of demonstration,
    this will suffice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建一个新文件或截断现有文件1，并将文件指针和任务切片传递给存储的`Flush`函数2。该函数接受一个`io.Writer`和你的切片。你处理现有序列化文件的方式当然还有改进的空间。但为了演示的目的，这样已经足够。
- en: You need a way to display the chores on the command line. [Listing 12-5](#listing12-5)
    adds such a function to your application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一种在命令行上显示任务的方式。[列表 12-5](#listing12-5)向你的应用程序添加了这样一个函数。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 12-5: Printing the list of chores to standard output (*cmd/housework.go*)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-5：将任务列表打印到标准输出 (*cmd/housework.go*)
- en: First, you load the list of chores from storage 1. If there are no chores in
    your list, you simply print as much to standard output. Otherwise, you print a
    header and the list of chores, which looks something like this (see [Listing 12-6](#listing12-6)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你从存储中加载任务列表1。如果你的列表中没有任务，你只需将其打印到标准输出。否则，你将打印一个标题和任务列表，类似于这样（参见[列表 12-6](#listing12-6)）。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 12-6: Example output of the list function with three chores in the
    list'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-6：任务列表函数的示例输出，列表中有三个任务
- en: The first column represents the chore number. You can reference this number
    to mark the chore complete, which will add an X between its brackets in the second
    column. The third column describes the chore.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列表示任务编号。你可以参考此编号来标记任务为完成，这将在第二列的方括号之间添加一个 X。第三列描述了该任务。
- en: '[Listing 12-7](#listing12-7) implements the `add` function, which allows you
    to add chores to the list.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-7](#listing12-7)实现了`add`函数，允许你向列表中添加任务。'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 12-7: Adding chores to the list (*cmd/housework.go*)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-7：向任务列表中添加任务 (*cmd/housework.go*)
- en: Unlike a long-running service, this application’s lifetime starts when you execute
    it on the command line and ends when it completes whatever task you ask it to
    perform. Therefore, because you want your list of chores to persist between executions
    of the application, you need to store the chore state on disk. In other words,
    you retrieve the chores from storage 1, modify them, and flush the changes to
    storage 3. The changes persist until the next time you run the app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与长时间运行的服务不同，这个应用程序的生命周期从你在命令行执行它时开始，到你要求它完成任务时结束。因此，因为你希望家务任务列表在应用程序执行之间得以持久化，你需要将家务任务的状态存储在磁盘上。换句话说，你从存储中检索家务任务，修改它们，然后将更改刷新到存储中。更改将持续存在，直到下次运行应用程序时。
- en: You want the option to add more than one chore at a time, so you split the incoming
    chore description by commas 2 and append each chore to the slice. Granted, this
    keeps you from using commas in individual chore descriptions, so the members of
    your household will have to keep their requests short (which isn’t all bad, in
    my opinion). As an exercise, figure out a way around this limitation. One approach
    may be to use a different delimiter, but keep in mind, whatever you choose as
    a delimiter may have significance on the command line. Another approach may be
    to add support for quoted strings containing commas.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望能够一次添加多个家务任务，因此你通过逗号将传入的家务描述进行分割，并将每个家务任务添加到切片中。当然，这样做会使你不能在单个家务描述中使用逗号，因此家庭成员必须将他们的请求简短些（我个人认为这也不全是坏事）。作为练习，想想如何解决这个限制。一个方法是使用不同的分隔符，但请记住，选择的分隔符在命令行中可能有特殊意义。另一种方法是支持包含逗号的带引号字符串。
- en: 'The last piece of this puzzle is my favorite part about working on chores:
    marking them as complete (see [Listing 12-8](#listing12-8)).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这块拼图的最后一部分是我最喜欢的关于处理家务任务的部分：将它们标记为完成（见[列表12-8](#listing12-8)）。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 12-8: Marking a chore as complete (*cmd/housework.go*)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12-8：标记家务任务为完成（*cmd/housework.go*）
- en: The `complete` function accepts the command line argument representing the chore
    you want to complete and converts it to an integer. I find I’m more efficient
    if I perform tasks one by one, so I’ll have you mark only one complete at a time.
    You then load the chores from storage and make sure the integer is within range.
    If so, you mark the chore complete. Since you’re numbering chores starting with
    1 when displaying the list, you need to account for placement in the slice by
    subtracting 1 1. Finally, you flush the chores to storage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`complete`函数接受代表你想完成的家务任务的命令行参数，并将其转换为整数。我发现如果我一个个任务地完成，效率会更高，所以我让你一次只标记一个任务完成。然后，你从存储中加载家务任务，确保整数在有效范围内。如果是，你就将该家务任务标记为完成。由于你在显示列表时是从1开始编号家务任务，所以需要通过减去1来调整切片中的位置。最后，你将家务任务刷新到存储中。'
- en: Now, let’s tie everything together by implementing the app’s `main` function
    in [Listing 12-9](#listing12-9).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过实现应用程序的`main`函数来将一切连接在一起，参见[列表12-9](#listing12-9)。
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 12-9: The main logic of the housework application (*cmd/housework.go*)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12-9：家务应用程序的主要逻辑（*cmd/housework.go*）
- en: You’ve put as much logic in the previous functions as possible, so this `main`
    function is quite minimal. You check the first argument to determine whether it’s
    an expected subcommand. If so, you call the appropriate function. You call the
    `list` function if `err` is still nil after accounting for the optional subcommand
    and its arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经尽可能地将逻辑放入之前的函数中，因此这个`main`函数相当简洁。你检查第一个参数，以确定它是否是预期的子命令。如果是，你调用相应的函数。如果在考虑了可选子命令及其参数后，`err`依然为nil，则调用`list`函数。
- en: All that’s left to do now is implement the storage `Load` and `Flush` functions
    for JSON, Gob, and protocol buffers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是为JSON、Gob和协议缓冲区实现存储的`Load`和`Flush`函数。
- en: JSON
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON
- en: JSON is a common, human-readable, text-based data serialization format that
    uses key-value pairs and arrays to represent complex data structures. Most contemporary
    languages offer official library support for JSON, which is one reason it’s the
    customary encoding format for RESTful APIs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种常见的、人类可读的基于文本的数据序列化格式，使用键值对和数组表示复杂的数据结构。大多数现代编程语言都提供对JSON的官方库支持，这也是它成为RESTful
    API常用编码格式的原因之一。
- en: JSON’s types include strings, Booleans, numbers, arrays, key-value objects,
    and nil values specified by the keyword *null*. JSON numbers do not differentiate
    between floating-points and integers. You can read more about Go’s JSON implementation
    at [https://blog.golang.org/json](https://blog.golang.org/json).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 的类型包括字符串、布尔值、数字、数组、键值对对象和由关键字 *null* 指定的 nil 值。JSON 数字不区分浮点数和整数。你可以在 [https://blog.golang.org/json](https://blog.golang.org/json)
    阅读更多关于 Go 中 JSON 实现的内容。
- en: Let’s look at what the contents of the *housework.db* file would be if we JSON-encoded
    the chores from [Listing 12-6](#listing12-6). I’ve formatted the JSON for easier
    reading in [Listing 12-10](#listing12-10), though you could use the encoder’s
    `SetIndent` method to do it for you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们将[示例 12-6](#listing12-6)中的家务事序列化为 JSON，*housework.db* 文件的内容会是什么样子。我已经在[示例
    12-10](#listing12-10)中将 JSON 格式化为便于阅读的方式，尽管你也可以使用编码器的 `SetIndent` 方法来完成此操作。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 12-10: Formatted contents of the *housework.db* file after serializing
    the chores to JSON'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-10：将家务事序列化为 JSON 后的 *housework.db* 文件格式化内容
- en: As you can see, the JSON is an array of objects 1, and each object 2 includes
    `Complete` and `Description` fields and corresponding values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，JSON 是一个包含对象的数组 1，每个对象 2 包含 `Complete` 和 `Description` 字段及其相应的值。
- en: '[Listing 12-11](#listing12-11) details the JSON storage implementation using
    Go’s `encoding/json` package.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-11](#listing12-11) 详细介绍了使用 Go 的 `encoding/json` 包实现的 JSON 存储。'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 12-11: JSON storage implementation (*json/housework.go*)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-11：JSON 存储实现 (*json/housework.go*)
- en: The `Load` function passes the `io.Reader` to the `json.NewDecoder` function
    1 and returns a decoder. You then call the decoder’s `Decode` method, passing
    it a pointer to the `chores` slice. The decoder reads JSON from the `io.Reader`,
    deserializes it, and populates the `chores` slice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Load` 函数将 `io.Reader` 传递给 `json.NewDecoder` 函数 1，并返回一个解码器。然后，你调用解码器的 `Decode`
    方法，并传入指向 `chores` 切片的指针。解码器从 `io.Reader` 读取 JSON，进行反序列化，并填充 `chores` 切片。'
- en: The `Flush` function accepts an `io.Writer` and a `chores` slice. It then passes
    the `io.Writer` to the `json.NewEncoder` function 2, which returns an encoder.
    You pass the `chores` slice to the encoder’s `Encode` function, which serializes
    the `chores` slice into JSON and writes it to the `io.Writer`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flush` 函数接受一个 `io.Writer` 和一个 `chores` 切片。然后它将 `io.Writer` 传递给 `json.NewEncoder`
    函数 2，后者返回一个编码器。你将 `chores` 切片传递给编码器的 `Encode` 方法，该方法将 `chores` 切片序列化为 JSON 并写入
    `io.Writer`。'
- en: Now that you’ve implemented a JSON package that can serve as storage for your
    application, let’s try it out in [Listing 12-12](#listing12-12).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经实现了一个可以作为应用存储的 JSON 包，我们来在[示例 12-12](#listing12-12)中试试它。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 12-12: Testing the housework application with JSON storage on the command
    line'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-12：在命令行上测试带有 JSON 存储的家务应用
- en: Your first execution of the app lets you know you have nothing in your list
    of chores. You then add three comma-separated chores and complete the second one.
    Looks good. Notice also that the *housework.db* file contains readable JSON (to
    see this on Windows, use the `type` command instead of `cat`). Let’s modify this
    application to use a binary encoding format native to Go.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你第一次运行应用时，会发现你的家务列表是空的。然后，你添加了三个逗号分隔的家务事，并完成了第二个。看起来不错。还要注意，*housework.db* 文件包含可读的
    JSON（在 Windows 上查看时，使用 `type` 命令而不是 `cat`）。让我们修改这个应用，改用 Go 原生的二进制编码格式。
- en: Gob
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gob
- en: '*Gob*, as in “gobs of binary data,” is a binary serialization format native
    to Go. Engineers on the Go team developed Gob to combine the efficiency of protocol
    buffers, arguably the most popular binary serialization format, with JSON’s ease
    of use. For example, protocol buffers don’t let us simply instantiate a new encoder
    and throw data structures at it, as you did in the JSON example in [Listing 12-11](#listing12-11).
    On the other hand, Gob functions much the same way as the JSON encoder, in that
    Gob can intelligently infer an object’s structure and serialize it.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gob*（“大量二进制数据”的缩写）是 Go 的原生二进制序列化格式。Go 团队的工程师们开发了 Gob，旨在将协议缓冲（可能是最流行的二进制序列化格式）的高效性与
    JSON 的易用性结合起来。例如，协议缓冲不允许我们像在[示例 12-11](#listing12-11)中的 JSON 示例那样，简单地实例化一个新的编码器并将数据结构传递给它。另一方面，Gob
    的工作方式与 JSON 编码器非常相似，它可以智能地推断对象的结构并进行序列化。'
- en: If you’re interested in exploring the motivation and finer points of Gob, give
    Rob Pike’s “Gobs of Data” blog post a read ([https://blog.golang.org/gob](https://blog.golang.org/gob)).
    In the meantime, let’s implement our storage backend in Gob (see [Listing 12-13](#listing12-13)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣探索 Gob 的动机和细节，建议阅读 Rob Pike 的《Gobs of Data》博客文章（[https://blog.golang.org/gob](https://blog.golang.org/gob)）。与此同时，我们来实现一个基于
    Gob 的存储后端（参见 [Listing 12-13](#listing12-13)）。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 12-13: Gob storage implementation (*gob/housework.go*)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-13：Gob 存储实现 (*gob/housework.go*)
- en: If you’re looking at this code and observing that it replaces all occurrences
    of `json` from [Listing 12-11](#listing12-11) with `gob`, you’re not wrong. In
    Go, Gob is as easy to use as JSON, since it infers what it needs to encode from
    the object itself. You’ll see how this differs from protocol buffers in the next
    section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这段代码，并注意到它将 [Listing 12-11](#listing12-11) 中所有出现的 `json` 替换为 `gob`，你并没有错。在
    Go 中，使用 Gob 就像使用 JSON 一样简单，因为它会根据对象本身推断出需要编码的内容。你将在下一节看到，这与协议缓冲区（protocol buffers）有何不同。
- en: All that’s left to do is swap out the JSON storage implementation for the Gob
    one by modifying the imports from [Listing 12-2](#listing12-2) ([Listing 12-14](#listing12-14)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是通过修改 [Listing 12-2](#listing12-2) 中的导入来将 JSON 存储实现替换为 Gob 实现（参见 [Listing
    12-14](#listing12-14)）。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 12-14: Swapping the JSON storage package for the Gob storage package
    (*cmd/housework.go*)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-14：将 JSON 存储包替换为 Gob 存储包 (*cmd/housework.go*)
- en: Comment out the JSON storage package import 1 in [Listing 12-2](#listing12-2)
    and uncomment the Gob storage package one 2.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉 [Listing 12-2](#listing12-2) 中的 JSON 存储包导入 1，并取消注释 Gob 存储包导入 2。
- en: Since your current *housework.db* file contains JSON, it isn’t compatible with
    Gob. Therefore, the housework application will throw an error when attempting
    to decode it using Gob. Remove the *housework.db* file and retest the application
    (see [Listing 12-15](#listing12-15)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你当前的 *housework.db* 文件包含 JSON 格式，因此与 Gob 不兼容。因此，尝试使用 Gob 解码时，housework 应用程序将抛出错误。删除
    *housework.db* 文件并重新测试应用程序（参见 [Listing 12-15](#listing12-15)）。
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 12-15: Testing the housework application with Gob storage on the command
    line'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-15：在命令行上测试使用 Gob 存储的 housework 应用程序
- en: Everything still works as expected. Using the `hexdump` tool, you can see that
    the *housework.db* file now includes binary data. It’s certainly not human-readable
    as JSON was in [Listing 12-12](#listing12-12), but Go happily deserializes the
    Gob-encoded data, even though it’s harder for us to make sense of it. (My Windows
    friends can find a `hexdump` binary at *https://www.di-mgt.com.au/hexdump-for-windows.html*,
    though you’ll have to use the `-C` flag to get the same effect.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一切仍按预期工作。使用 `hexdump` 工具，你可以看到 *housework.db* 文件现在包含了二进制数据。虽然它不像 [Listing 12-12](#listing12-12)
    中的 JSON 那样可读，但 Go 会愉快地反序列化 Gob 编码的数据，尽管我们很难理解它。（我的 Windows 朋友可以在 *https://www.di-mgt.com.au/hexdump-for-windows.html*
    找到 `hexdump` 的二进制文件，尽管你需要使用 `-C` 标志才能看到相同的效果。）
- en: If you are communicating with other Go services that support Gob, I recommend
    you use Gob over JSON. Go’s `encoding/gob` is more performant than `encoding/json`.
    Gob encoding is also more succinct, in that Gob uses less data to represent objects
    than JSON does. This can make a difference when storing or transmitting serialized
    data
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与其他支持 Gob 的 Go 服务进行通信，我建议你使用 Gob 而不是 JSON。Go 的 `encoding/gob` 比 `encoding/json`
    更高效。Gob 编码也更简洁，因为 Gob 使用比 JSON 更少的数据来表示对象。当存储或传输序列化数据时，这一点可能会带来差异。
- en: Now that you have a taste for serializing data using `encoding/json` and `encoding/gob`,
    let’s add protocol buffer support to your storage backend.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经体验了使用 `encoding/json` 和 `encoding/gob` 来序列化数据，我们来为你的存储后端添加协议缓冲区支持。
- en: Protocol Buffers
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议缓冲区（Protocol Buffers）
- en: Like Gob, *protocol buffers* use binary encoding to store or exchange information
    across various platforms. It’s faster and more succinct than Go’s JSON encoding.
    Unlike Gob and like JSON, protocol buffers are language neutral and enjoy wide
    support among popular programming languages. This makes them ideally suited for
    using in Go-based services that you hope to integrate with services written in
    other programming languages. This chapter assumes you’re using the *proto3* version
    of the format.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Gob 一样，*协议缓冲区*使用二进制编码来存储或交换跨平台的信息。它比 Go 的 JSON 编码更快、更简洁。与 Gob 不同，像 JSON 一样，协议缓冲区是语言中立的，并且在流行的编程语言中得到了广泛支持。这使得它们非常适合在基于
    Go 的服务中使用，尤其是当你希望与其他编程语言编写的服务集成时。本章假设你使用的是 *proto3* 版本的格式。
- en: Protocol buffers use a definition file, conventionally suffixed with *.proto*,
    to define messages. *Messages* describe the structured data you want to serialize
    for storage or transmission. For example, a protocol buffer message representing
    the `Chore` type looks like the definition in [Listing 12-16](#listing12-16).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区使用定义文件，通常以*.proto*为后缀，来定义消息。*消息*描述了你想要序列化以便存储或传输的结构化数据。例如，表示`Chore`类型的协议缓冲区消息如下所示，在[Listing
    12-16](#listing12-16)中有定义。
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 12-16: Protocol buffer message definition representing a `Chore` type'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-16：表示`Chore`类型的协议缓冲区消息定义
- en: 'You define a new message by using the `message` keyword, followed by the unique
    name of the message. Convention dictates you use Pascal case. (*Pascal casing*
    is a style of code formatting in which you concatenate capitalized words: *ThisIsPascalCasing*.)
    You then add fields to the `Chore` message. Each field definition includes a type,
    a snake-cased name, and a field number unique to the message. (*Snake casing*
    is like Pascal casing except the first word is lowercase: *thisIsSnakeCasing*.)
    The field’s type and number identify the field in the binary payload, so these
    must not change once used or you’ll break backward compatibility. However, it’s
    fine to add new messages and message fields to an existing *.proto* file.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用`message`关键字定义一个新的消息，后跟消息的唯一名称。惯例是使用 Pascal 大小写（*Pascal casing*），它是一种代码格式化风格，其中将单词首字母大写并连接在一起：*ThisIsPascalCasing*。然后，你可以为`Chore`消息添加字段。每个字段定义包括类型、一个蛇形命名（*snake
    casing*）的名称和一个该消息唯一的字段编号。蛇形命名就像 Pascal 大小写，只不过第一个单词是小写的：*thisIsSnakeCasing*。字段的类型和编号标识了二进制负载中的字段，因此一旦使用，这些字段不得更改，否则会破坏向后兼容性。然而，可以向现有的*.proto*文件中添加新的消息和消息字段。
- en: Speaking of backward compatibility, it’s a good practice to treat your protocol
    buffer definitions as you would an API. If third parties use your protocol buffer
    definition to communicate with your service, consider versioning your definition;
    this allows you to create new versions anytime you need to break backward compatibility.
    Your development can move forward with the latest version while clients continue
    to use the previous version until they’re ready to target the latest version.
    You’ll see one method of versioning the protocol buffer definitions later in this
    section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 说到向后兼容性，最佳实践是将协议缓冲区定义当作 API 来处理。如果第三方使用你的协议缓冲区定义与服务进行通信，考虑为你的定义进行版本控制；这样，你就可以在需要打破向后兼容性时创建新版本。你的开发可以继续进行最新版本，而客户端则可以继续使用之前的版本，直到他们准备好升级到最新版本。你将在本节稍后看到一种协议缓冲区定义版本控制的方法。
- en: 'You’ll have to compile the *.proto* file to generate Go code from it. This
    code allows you to serialize and deserialize the messages defined in the *.proto*
    file. Third parties that want to exchange messages with you can use the same *.proto*
    file to generate code for their target programming language. The resulting code
    can exchange messages with you too. Therefore, before you can start using protocol
    buffers in earnest, you must install the protocol buffer compiler and its Go generation
    module. Your operating system’s package manager may allow you to easily install
    the protocol buffer compiler. For example, on Debian 10, run the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要编译*.proto*文件以生成 Go 代码。该代码允许你序列化和反序列化在*.proto*文件中定义的消息。希望与你交换消息的第三方可以使用相同的*.proto*文件为其目标编程语言生成代码。生成的代码也可以与你交换消息。因此，在你开始认真使用协议缓冲区之前，必须安装协议缓冲区编译器及其
    Go 生成模块。你的操作系统的包管理器可能允许你轻松安装协议缓冲区编译器。例如，在 Debian 10 上，运行以下命令：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On macOS with Homebrew, run this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上使用 Homebrew，运行以下命令：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On Windows, download the latest protocol buffer compiler ZIP file from [https://github.com/protocolbuffers/protobuf/releases/](https://github.com/protocolbuffers/protobuf/releases/),
    extract it, and add its *bin* subdirectory to your `PATH`. You should now be able
    to run the *protoc* binary on your command line.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，从[https://github.com/protocolbuffers/protobuf/releases/](https://github.com/protocolbuffers/protobuf/releases/)下载最新的协议缓冲区编译器
    ZIP 文件，解压后将其*bin*子目录添加到你的`PATH`中。现在你应该能够在命令行上运行*protoc*二进制文件了。
- en: 'A simple `go get` will install the protocol buffer’s Go generator on your system.
    Make sure you have the resulting *protoc-gen-go* binary in your `PATH` or *protoc*
    won’t recognize the plug-in:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`go get`命令将会在你的系统上安装协议缓冲区的 Go 生成器。确保你将生成的*protoc-gen-go*二进制文件添加到`PATH`中，否则*protoc*无法识别该插件：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that you’ve installed the protocol buffer compiler and Go generation module,
    let’s create a new *.proto* file for your housework application (see [Listing
    12-17](#listing12-17)). You’ll create this file in *housework/v1/housework.proto*.
    The `v1` in the path stands for *version 1* and allows you to introduce future
    versions of this package.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了协议缓冲区编译器和Go生成模块，让我们为你的家务应用创建一个新的*.proto*文件（见[清单12-17](#listing12-17)）。你将在*housework/v1/housework.proto*中创建这个文件。路径中的`v1`表示*版本1*，并允许你在将来引入该包的不同版本。
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 12-17: Protocol buffer definition for your housework application (*housework/v1/housework.proto*)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-17：你家务应用的协议缓冲区定义（*housework/v1/housework.proto*）
- en: First, you specify that you’re using the proto3 syntax 1 and that you want any
    generated code to have the package name `housework`2. Next, you add a `go_package`
    option 3 with the full import path of the generated module. Then you define the
    `Chore` message and a second message named `Chores` that represents a collection
    of `Chore` messages based on the `repeated` field type 4.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你指定使用proto3语法1，并希望生成的任何代码都使用`housework`作为包名2。接着，你添加一个`go_package`选项3，指定生成模块的完整导入路径。然后你定义`Chore`消息，以及第二个消息`Chores`，它表示一个基于`repeated`字段类型4的`Chore`消息集合。
- en: 'Now, let’s compile the *.proto* file to Go code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将*.proto*文件编译成Go代码：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You call *protoc* with flags indicating you want to generate Go code 1 from
    the *housework/v1/housework.proto* file you created in [Listing 12-17](#listing12-17)
    and output the generated code to the *.proto* file’s current directory, with relative
    paths 2.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用带有标志的*protoc*命令，表明你希望从[清单12-17](#listing12-17)中创建的*housework/v1/housework.proto*文件生成Go代码，并将生成的代码输出到*.proto*文件的当前目录，使用相对路径2。
- en: 'If you receive the following error indicating *protoc* cannot find the *protoc-gen-go*
    binary, make sure *protoc-gen-go*’s location (likely *$GOPATH/bin*) is in your
    `PATH` environment variable:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到以下错误，提示*protoc*找不到*protoc-gen-go*二进制文件，请确保*protoc-gen-go*的路径（可能是*$GOPATH/bin*）已加入到`PATH`环境变量中：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If *protoc* is happy with the *.proto* file and successfully generated the
    Go code, you’ll find that a new file named *housework/v1/housework.pb.go* exists
    with these first few lines, though the version numbers may differ. I’ll use the
    `head` command on Linux/macOS to print the first seven lines:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*protoc*对*.proto*文件没有问题，并成功生成了Go代码，你会发现一个名为*housework/v1/housework.pb.go*的新文件，虽然版本号可能有所不同。我将在Linux/macOS上使用`head`命令打印出前七行：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As the comments indicate, you shouldn’t edit this module. Instead, make any
    necessary changes to the *.proto* file and recompile it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如注释所示，你不应编辑此模块。相反，应对*.proto*文件进行必要的修改并重新编译。
- en: Now that you’ve generated a Go module from the *.proto* file, you can put it
    to effective use in [Listing 12-18](#listing12-18) by implementing your storage
    backend with protocol buffers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经从*.proto*文件生成了一个Go模块，可以通过在[清单12-18](#listing12-18)中实现协议缓冲区存储后端来有效利用它。
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 12-18: Protocol buffers storage implementation (*protobuf/housework.go*)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-18：协议缓冲区存储实现（*protobuf/housework.go*）
- en: Instead of relying on the `housework` package from [Listing 12-1](#listing12-1),
    as you did when working with JSON and Gob, you import version 1 of the *protoc*-generated
    package, which you also named `housework`1. The generated `Chores` type 2 is a
    struct with a `Chores` field, which itself is a slice of `Chore` pointers. Also,
    Go’s protocol buffers package doesn’t implement encoders and decoders. Therefore,
    you must marshal objects to bytes, write them to the `io.Writer`, and unmarshal
    bytes from the `io.Reader` yourself.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再像使用JSON和Gob时那样依赖[清单12-1](#listing12-1)中的`housework`包，而是导入*protoc*生成的版本1包，你也将其命名为`housework`。生成的`Chores`类型是一个结构体，包含一个`Chores`字段，`Chores`本身是`Chore`指针的切片。此外，Go的协议缓冲区包并未实现编码器和解码器。因此，你需要手动将对象序列化为字节，写入到`io.Writer`中，并从`io.Reader`中反序列化字节。
- en: Revisit the code in [Listing 12-2](#listing12-2) and plug in the protocol buffers
    implementation with the two simple changes shown in [Listing 12-19](#listing12-19).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[清单12-2](#listing12-2)中的代码，并插入协议缓冲区实现，只需做出[清单12-19](#listing12-19)中显示的两个简单更改。
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 12-19: Swapping the JSON storage package for the `protobuf` storage
    package (*cmd/housework.go*)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-19：将JSON存储包替换为`protobuf`存储包（*cmd/housework.go*）
- en: You replace the housework package from [Listing 12-1](#listing12-1) with your
    generated package 1, make sure to comment out the `json` and `gob` imports, and
    uncomment the `protobuf` storage import 2. The actual functionality of the housework
    application remains unchanged.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从[清单 12-1](#listing12-1)中替换掉家务包，改为你生成的包1，确保注释掉 `json` 和 `gob` 导入，取消注释 `protobuf`
    存储导入2。家务应用的实际功能保持不变。
- en: Transmitting Serialized Objects
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输序列化对象
- en: 'Although you may sometimes need to serialize and store objects locally, you’re
    more likely to build a network service that serializes data. For example, an online
    store may have a web service that communicates with inventory, user accounting,
    billing, shipping, and notification services to facilitate customer orders. If
    these services ran on the same server, you’d have to buy a larger server to scale
    the online store as business grows. Another approach would be to run each service
    on its own server and increase the number of servers. But then you’d have a new
    problem: how can you share data among services when they no longer reside on a
    single server and so can’t access the same memory?'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时你可能需要序列化并本地存储对象，但你更有可能构建一个序列化数据的网络服务。例如，一个在线商店可能会有一个 web 服务，和库存、用户账户、账单、运输和通知服务进行通信，以便促进客户订单。如果这些服务都运行在同一台服务器上，你就需要购买更大的服务器，以便随着业务增长来扩展在线商店。另一种方法是将每个服务都运行在独立的服务器上，并增加服务器的数量。但这样你会面临一个新问题：当这些服务不再位于同一台服务器上，无法访问相同的内存时，你该如何在它们之间共享数据？
- en: Large technology companies facilitate this with *remote procedure calls (RPCs)*,
    a technique by which a client can transparently call a subroutine on a server
    as if the call were local. From your application’s perspective, RPC services take
    code that appears to run locally and distribute it over a network. Your code may
    call a function that transparently relays a message to a server. The server would
    locally execute the function, then respond with the results, which your code receives
    as the function’s return value. As far as your code is concerned, the function
    call is local, despite RPC’s transparent interaction with the server. This approach
    allows you to scale services across servers while abstracting the details away
    from your code. In other words, your code functions the same no matter whether
    the function call runs on the same computer or on one over the network.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 大型科技公司通过 *远程过程调用 (RPC)* 来简化这个过程，RPC 是一种技术，客户端可以透明地调用服务器上的子程序，就像这个调用是本地的一样。从应用程序的角度来看，RPC
    服务将看似本地运行的代码分发到网络上。你的代码可能会调用一个函数，该函数透明地将消息转发到服务器。服务器会在本地执行该函数，然后返回结果，代码收到这些结果作为函数的返回值。就你的代码而言，函数调用是本地的，尽管
    RPC 与服务器的交互是透明的。这种方法允许你在服务器之间扩展服务，同时将细节抽象化，不需要在代码中处理。换句话说，无论函数调用是在同一台计算机上执行，还是在网络上的另一台计算机上执行，你的代码的表现都一样。
- en: Most companies now implement RPC with *gRPC*, a cross-platform framework that
    leverages HTTP/2 and protocol buffers. Let’s use it here to build something more
    sophisticated than an app to keep track of the housework you have yet to do. You’ll
    write a service that can send tasks to Rosie, the robotic maid from the classic
    animated series *The Jetsons*, who can take over your domestic responsibilities.
    Granted, she won’t be available until the year 2062, but you can get a head start
    on the code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数公司都使用 *gRPC* 来实现 RPC，这是一个跨平台框架，利用了 HTTP/2 和协议缓冲区。我们在这里使用它来构建比一个记录你尚未做的家务的应用程序更复杂的东西。你将编写一个服务，能够将任务发送给
    Rosie，这个来自经典动画系列 *杰森一家* 的机器人女佣，她能接管你的家务责任。当然，她要到 2062 年才能问世，但你可以提前开始编写代码。
- en: Connecting Services with gRPC
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 gRPC 连接服务
- en: The gRPC framework is a collection of libraries that abstracts many of the RPC
    implementation details. It is platform neutral and programming-language agnostic;
    you can use it to integrate a Go service running on Windows with a Rust service
    running on Linux, for example. Now that you know how to work with protocol buffers,
    you have the foundation needed to add gRPC support to your application. You’ll
    reuse the *.proto* file from the previous section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 框架是一个库集合，抽象了许多 RPC 实现的细节。它是平台中立的，并且对编程语言无关；例如，你可以使用它将运行在 Windows 上的 Go
    服务与运行在 Linux 上的 Rust 服务集成。现在你已经知道如何使用协议缓冲区，你有了向你的应用程序添加 gRPC 支持所需的基础。你将复用上一节中的
    *.proto* 文件。
- en: 'First, make sure your gRPC package is up-to-date:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你的 gRPC 包是最新的：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, get the appropriate module for generating gRPC Go code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，获取生成 gRPC Go 代码所需的模块：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The protocol buffer compiler includes a gRPC module. This module will output
    Go code that lets you easily add gRPC support. First, you need to add definitions
    to the *.proto* file. [Listing 12-20](#listing12-20) defines a new service and
    two additional messages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区编译器包含一个gRPC模块。此模块将输出Go代码，使你可以轻松添加gRPC支持。首先，你需要向*.proto*文件中添加定义。[Listing
    12-20](#listing12-20)定义了一个新服务和两个额外的消息。
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 12-20: Additional definitions to support a gRPC RobotMaid service (*housework/v1/housework.proto*)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-20：支持gRPC RobotMaid服务的附加定义（*housework/v1/housework.proto*）
- en: 'The service needs to support the same three calls you used on the command line:
    `add`, `complete`, and `list`. You define a new service named `RobotMaid`, then
    add three RPC methods to it. These RPC methods correspond to the functions defined
    in Listings 12-5, 12-7, and 12-8 for use on the command line: the `list`, `add`,
    and `complete` functions, respectively. Instead of calling these functions locally,
    you’ll call the corresponding method on the `RobotMaid` to execute these commands
    via RPC. You prefix each method with the `rpc` keyword and follow this with the
    Pascal-cased method name. Next, you write the request message type in parentheses,
    the `returns` keyword, and the return message type in parentheses 1.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务需要支持你在命令行中使用的相同三种调用：`add`、`complete`和`list`。你定义了一个名为`RobotMaid`的新服务，然后向其添加了三个RPC方法。这些RPC方法分别对应于Listing
    12-5、12-7和12-8中定义的函数，用于命令行：分别是`list`、`add`和`complete`函数。你将不再在本地调用这些函数，而是通过RPC调用`RobotMaid`上的相应方法来执行这些命令。你将每个方法前缀加上`rpc`关键字，并跟随Pascal命名法的函数名。接下来，你在括号中编写请求消息类型，使用`returns`关键字，并在括号中编写返回消息类型1。
- en: The `List` method doesn’t require any user input, but as in the command line
    application, you still must provide a request message type for it, even if it’s
    nil. In gRPC, the message type equivalent to nil is an empty message, which you
    call `Empty`3.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`方法不需要任何用户输入，但与命令行应用程序中的情况一样，你仍然必须为它提供一个请求消息类型，即使它是nil。在gRPC中，等同于nil的消息类型是一个空消息，你称之为`Empty`3。'
- en: Until you’ve had the opportunity to add proper artificial intelligence (AI)
    to the robot, you’ll need to tell Rosie when her current chore is complete so
    she can move on to the next one. For this, you add a new message that informs
    her of the completed chore number 2. Since you expect feedback from Rosie, you
    also add a response message that contains a string.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在你有机会为机器人添加适当的人工智能（AI）之前，你需要告诉Rosie当前的家务活已完成，以便她可以继续下一个任务。为此，你添加了一个新消息，通知她已完成的家务活编号2。由于你期望从Rosie那里获得反馈，你还添加了一个响应消息，包含一个字符串。
- en: 'Now compile the *.proto* file to use the new service and messages. Tell *protoc*
    to use the *protoc**-gen-go-grpc* binary, which must also be in your `PATH` environment
    variable, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译*.proto*文件，以使用新的服务和消息。告诉*protoc*使用*protoc-gen-go-grpc*二进制文件，它也必须位于你的`PATH`环境变量中，如下所示：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `--go-grpc_out` flag 1 invokes the *protoc-gen-go-grpc* binary to add gRPC
    support to the generated code. This binary generates the relevant gRPC service
    code for you and writes gRPC-specific code to the *housework/v1/housework_grpc.pb.go*
    file since you told *protoc-gen-go-grpc* to use relative paths 2. You can now
    use the generated code to build a gRPC server and client.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`--go-grpc_out`标志1调用了*protoc-gen-go-grpc*二进制文件，为生成的代码添加gRPC支持。该二进制文件为你生成相关的gRPC服务代码，并将gRPC特定的代码写入*housework/v1/housework_grpc.pb.go*文件，因为你告诉*protoc-gen-go-grpc*使用相对路径2。现在，你可以使用生成的代码来构建gRPC服务器和客户端。'
- en: Creating a TLS-Enabled gRPC Server
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个启用TLS的gRPC服务器
- en: Now let’s implement a gRPC client and server. By default, gRPC requires a secure
    connection, so you’ll add TLS support to your server. You’ll use the server’s
    *cert.pem* and *key.pem* files created in the preceding chapter for your gRPC
    server and pin the server’s certificate to your client. See the “Generating Certificates
    for Authentication” section on page 256 for details.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个gRPC客户端和服务器。默认情况下，gRPC需要安全连接，因此你需要为服务器添加TLS支持。你将使用上一章中创建的服务器的*cert.pem*和*key.pem*文件作为你的gRPC服务器，并将服务器的证书固定到客户端。有关详细信息，请参阅第256页的“生成用于身份验证的证书”部分。
- en: 'You’ll leverage the Go code generated by your *.proto* file to define a new
    `RobotMaid` client and server and use the client to communicate with the server
    over the network using gRPC. First, let’s create the server portion of your robot
    maid. The `RobotMaidServer` interface generated from your *.proto* file looks
    like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你将利用通过 *.proto* 文件生成的 Go 代码来定义一个新的 `RobotMaid` 客户端和服务器，并使用客户端通过网络与服务器进行 gRPC
    通信。首先，让我们创建你机器人女仆的服务器部分。由你的 *.proto* 文件生成的 `RobotMaidServer` 接口如下所示：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You’ll implement this interface in [Listing 12-21](#listing12-21) by creating
    a new type named `Rosie`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[清单 12-21](#listing12-21)中通过创建一个名为 `Rosie` 的新类型来实现这个接口。
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 12-21: Building a `RobotMaid`-compatible type named `Rosie` (*server/rosie.go*)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-21：构建一个与 `RobotMaid` 兼容的类型，命名为 `Rosie` (*server/rosie.go*)
- en: The new `Rosie` struct keeps its list of chores in memory 1, guarded by a mutex,
    since more than one client can concurrently use the service. The `Add`, `Complete`,
    and `List` methods all return either a response message type 2 or an error, both
    of which ultimately make their way back to the client. The `Service` method returns
    a pointer to a new `housework.RobotMaidService` instance 3 where `Rosie`’s `Add`,
    `Complete`, and `List` methods map to their corresponding method on the new instance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Rosie` 结构体将它的家务列表保存在内存中 1，并由互斥锁保护，因为多个客户端可以同时使用该服务。`Add`、`Complete` 和 `List`
    方法都返回一个响应消息类型 2 或错误，两者最终都会返回给客户端。`Service` 方法返回指向一个新的 `housework.RobotMaidService`
    实例的指针 3，`Rosie` 的 `Add`、`Complete` 和 `List` 方法会映射到新实例的相应方法。
- en: Now, let’s set up a new gRPC server instance by using the `Rosie` struct ([Listing
    12-22](#listing12-22)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用 `Rosie` 结构体来设置一个新的 gRPC 服务器实例 ([清单 12-22](#listing12-22))。
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 12-22: Creating a new gRPC server using `Rosie` (*server/server.go*)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-22：使用 `Rosie` 创建一个新的 gRPC 服务器 (*server/server.go*)
- en: First, you retrieve a new server instance 1. You pass it and a new `*housework.RobotMaidService`
    from `Rosie`’s `Service`3 method to the `RegisterRobotMaidServer` function 2 in
    the generated gRPC code. This registers `Rosie`’s `RobotMaidService` implementation
    with the gRPC server. You must do this before you call the server’s `Serve` method
    4. You then load the server’s key pair and create a new TLS listener 5, which
    you pass to the server when calling `Serve`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你获取一个新的服务器实例 1。你将它和来自 `Rosie` 的 `Service`3 方法返回的新 `*housework.RobotMaidService`
    传递给生成的 gRPC 代码中的 `RegisterRobotMaidServer` 函数 2。这将 `Rosie` 的 `RobotMaidService`
    实现注册到 gRPC 服务器上。在调用服务器的 `Serve` 方法 4 之前，必须执行此操作。然后，你加载服务器的密钥对并创建一个新的 TLS 监听器 5，调用
    `Serve` 时将其传递给服务器。
- en: Now that you have a gRPC server implementation, let’s work on the client.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个 gRPC 服务器实现，让我们来处理客户端部分。
- en: Creating a gRPC Client to Test the Server
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 gRPC 客户端来测试服务器
- en: The client-side code isn’t much different from what you wrote in the “Serializing
    Objects” section on page 270. The main difference is that you need to instantiate
    a new gRPC client and modify the `add`, `complete`, and `list` functions to use
    it. Remember, you can implement the client portion in a separate programming language
    if the programming language offers `protobuf` support. You can generate code for
    your target language from your *.proto* file with the expectation it will work
    seamlessly with your server in [Listing 12-22](#listing12-22).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码与你在第 270 页“对象序列化”部分编写的代码差别不大。主要的区别是你需要实例化一个新的 gRPC 客户端，并修改 `add`、`complete`
    和 `list` 函数来使用它。记住，如果编程语言支持 `protobuf`，你可以用它来实现客户端部分，并且可以为目标语言从 *.proto* 文件生成代码，期望它能与[清单
    12-22](#listing12-22)中的服务器无缝协作。
- en: '[Listing 12-23](#listing12-23) details the changes to [Listing 12-2](#listing12-2)
    necessary to add gRPC support to the housework application.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-23](#listing12-23)详细说明了[清单 12-2](#listing12-2)中对家务应用程序添加 gRPC 支持所需的更改。'
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 12-23: Initial gRPC client code for our housework application (*client/client.go*)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-23：我们的家务应用程序的初始 gRPC 客户端代码 (*client/client.go*)
- en: Aside from all the new imports 1234, you add flags for the gRPC server address
    5 and its certificate 6.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有新的导入 1234，你还添加了 gRPC 服务器地址 5 和证书 6 的标志。
- en: '[Listing 12-24](#listing12-24) uses the gRPC client to list the current chores.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-24](#listing12-24)使用 gRPC 客户端列出当前的家务。'
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 12-24: Using the gRPC client to list the current chores (*client/client.go*)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-24：使用 gRPC 客户端列出当前家务 (*client/client.go*)
- en: This code is quite like [Listing 12-5](#listing12-5), except you’re asking the
    gRPC client for the list of chores, which retrieves them from the server. You
    need to pass along an empty message to make gRPC happy 1.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[清单12-5](#listing12-5)非常相似，唯一不同的是你请求gRPC客户端获取任务列表，客户端从服务器中检索这些任务。你需要传递一个空的消息，以让gRPC正常工作1。
- en: '[Listing 12-25](#listing12-25) uses the gRPC client to add new chores to the
    gRPC server’s chores.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单12-25](#listing12-25)使用gRPC客户端将新任务添加到gRPC服务器的任务列表中。'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 12-25: Adding new chores using the gRPC client (*client/client.go*)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-25：使用gRPC客户端添加新任务（*client/client.go*）
- en: As you did in the previous section, you parse the comma-separated list of chores.
    Instead of flushing these chores to disk, you pass them along to the gRPC client.
    The gRPC client transparently sends them to the gRPC server and returns the response
    to you. Since you know `Rosie` returns a non-nil error when the `Add` call fails,
    you return the error 1 as the result of the `add` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在前一节中那样，你解析了逗号分隔的任务列表。不同的是，这些任务并没有被刷新到磁盘，而是被传递给了gRPC客户端。gRPC客户端透明地将它们发送到gRPC服务器，并将响应返回给你。由于你知道当`Add`调用失败时`Rosie`会返回一个非nil的错误，因此你将错误1作为`add`函数的返回值。
- en: In [Listing 12-26](#listing12-26), you write the code to mark chores complete.
    Doing this over gRPC requires a bit less code than [Listing 12-8](#listing12-8)
    since most of the logic is in the server.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单12-26](#listing12-26)中，你编写了标记任务完成的代码。通过gRPC执行这项操作比[清单12-8](#listing12-8)的代码少一些，因为大部分逻辑都在服务器端。
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 12-26: Marking chores complete by using the gRPC client (*client/client.go*)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-26：使用gRPC客户端标记任务完成（*client/client.go*）
- en: Notice the *protoc-gen-go* module, which converts the snake-cased `chore_number`
    field in [Listing 12-20](#listing12-20) to Pascal case in the generated Go code
    1. You must also convert the `int` returned by `strconv.Atoi` to an `int32` before
    assigning it to the complete request message’s chore number since `ChoreNumber`
    is an `int32`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*protoc-gen-go*模块，它将[清单12-20](#listing12-20)中的蛇形命名的`chore_number`字段转换为Pascal命名法，生成Go代码1。你还必须在将其赋值给完整请求消息的任务编号之前，将`strconv.Atoi`返回的`int`转换为`int32`，因为`ChoreNumber`是`int32`类型。
- en: '[Listing 12-27](#listing12-27) creates a new gRPC connection and pins the server’s
    certificate to its TLS configuration.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单12-27](#listing12-27)创建了一个新的gRPC连接，并将服务器的证书固定到其TLS配置中。'
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 12-27: Creating a new gRPC connection using TLS and certificate pinning
    (*client/client.go*)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-27：使用TLS和证书固定创建一个新的gRPC连接（*client/client.go*）
- en: On the client side, you first create a new gRPC network connection 1 and then
    use the network connection to instantiate a new gRPC client. For most use cases,
    you can simply pass the address to `grpc.Dial`. But you want to pin the server’s
    certificate to the client connection. Therefore, you need to explicitly pass in
    a `grpc.DialOption` with the appropriate TLS credentials. This involves using
    the `grpc.WithTransportCredentials` function 2 to return the `grpc.DialOption`
    and the `credentials.NewTLS` function 3 to create the transport credentials from
    your TLS configuration. The result is a gRPC network connection that speaks TLS
    with the server and authenticates the server by using the pinned certificate.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，你首先创建一个新的gRPC网络连接1，然后使用该网络连接实例化一个新的gRPC客户端。对于大多数用例，你可以简单地将地址传递给`grpc.Dial`。但你希望将服务器的证书固定到客户端连接中。因此，你需要明确传递一个`grpc.DialOption`，并附上适当的TLS凭证。这涉及使用`grpc.WithTransportCredentials`函数2来返回`grpc.DialOption`，并使用`credentials.NewTLS`函数3来根据你的TLS配置创建传输凭证。结果是一个gRPC网络连接，它与服务器进行TLS通信，并通过使用固定的证书来验证服务器。
- en: You use this gRPC network connection to instantiate a new gRPC client in [Listing
    12-28](#listing12-28).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[清单12-28](#listing12-28)中使用这个gRPC网络连接实例化了一个新的gRPC客户端。
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 12-28: Instantiating a new gRPC client and making calls (*client/client.go*)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-28：实例化一个新的gRPC客户端并进行调用（*client/client.go*）
- en: Aside from instantiating a new gRPC client from the gRPC network connection
    1, this bit of code doesn’t vary much from [Listing 12-9](#listing12-9). The difference,
    of course, lies in the fact that any interaction with the list of chores transparently
    takes place over a TLS connection to the gRPC server.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从gRPC网络连接1实例化一个新的gRPC客户端外，这段代码与[清单12-9](#listing12-9)的差异不大。区别当然在于，任何与任务列表的交互都透明地通过TLS连接与gRPC服务器进行。
- en: 'Give it a try. In one terminal, start the server:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。在一个终端中启动服务器：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And in another terminal, run the client:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，运行客户端：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Of course, restarting the server wipes out the list of chores. I’ll leave it
    as an exercise for you to implement persistence on the server. One approach is
    to have the server load the chores from and flush chores to disk as you did earlier
    in this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，重启服务器会清空任务列表。我将这作为练习留给你，去实现服务器上的持久化存储。一个方法是让服务器从磁盘加载任务并将任务刷新到磁盘，就像你在本章之前所做的那样。
- en: What You’ve Learned
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你所学到的
- en: Data serialization allows you to exchange data in a platform-neutral and language-neutral
    way. You can also serialize data for long-term storage, retrieve and deserialize
    the data, and pick up where your application left off.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 数据序列化允许你以平台中立和语言中立的方式交换数据。你还可以序列化数据进行长期存储，检索并反序列化数据，然后继续从应用程序上次停止的地方开始。
- en: JSON is arguably the most popular text-based data serialization format. Contemporary
    programming languages offer good support for JSON, which is one reason for its
    ubiquity in RESTful APIs. Go offers good support for binary-based data serialization
    formats as well, including Gob, which is nearly a drop-in replacement for JSON.
    Gob is Go’s native binary data serialization format, and it’s designed to be efficient
    and easy to use.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 可以说是最流行的基于文本的数据序列化格式。现代编程语言提供对 JSON 的良好支持，这也是它在 RESTful API 中无处不在的原因之一。Go
    也提供对基于二进制的数据序列化格式的良好支持，包括 Gob，它几乎可以替代 JSON。Gob 是 Go 的本地二进制数据序列化格式，旨在高效且易于使用。
- en: If you’re looking for a binary data serialization format with wider support,
    consider protocol buffers. Google designed protocol buffers to facilitate the
    exchange of serialized binary data across its supported platforms and programming
    languages. Many contemporary programming languages currently offer support for
    protocol buffers. Although protocol buffers aren’t the same drop-in replacement
    in Go as Gob is for JSON, Go has excellent protocol buffer support, nonetheless.
    You first need to add definitions that define the data structures you intend to
    serialize in a *.proto* file. You then use the protocol buffer compiler and its
    Go module to generate Go code that corresponds to your defined data structures.
    Finally, you use the generated code to serialize your data structures into protocol
    buffer-formatted binary data and deserialize that binary data back into your data
    structures.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在寻找一个支持更广泛的二进制数据序列化格式，可以考虑协议缓冲区。Google 设计协议缓冲区是为了方便其支持的平台和编程语言之间交换序列化的二进制数据。许多现代编程语言目前都提供对协议缓冲区的支持。尽管协议缓冲区不像
    Gob 对 JSON 那样是 Go 的直接替代品，但 Go 仍然对协议缓冲区提供了出色的支持。你首先需要在 *.proto* 文件中添加定义，定义你打算序列化的数据结构。然后，使用协议缓冲区编译器及其
    Go 模块生成与定义的数据结构对应的 Go 代码。最后，使用生成的代码将数据结构序列化为协议缓冲区格式的二进制数据，并将该二进制数据反序列化回你的数据结构。
- en: The gRPC framework is a high-performance, platform-neutral standard for making
    distributed function calls across a network. The *RPC* in *gRPC* stands for *remote
    procedure call*, which is a technique for transparently calling a function on
    a remote system and receiving the result as if you had executed the function on
    your local system. gRPC uses protocol buffers as its underlying data serialization
    format. Go’s protocol buffer module allows you to easily add gRPC support by defining
    services in your *.proto* file and leveraging the generated code. This lets you
    quickly and efficiently stand up distributed services or integrate with existing
    gRPC services.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 框架是一个高性能、平台中立的标准，用于在网络上进行分布式函数调用。*gRPC* 中的 *RPC* 代表 *远程过程调用*，这是一种透明地在远程系统上调用函数并接收结果的技术，就像你在本地系统上执行该函数一样。gRPC
    使用协议缓冲区作为其底层数据序列化格式。Go 的协议缓冲区模块允许你通过在 *.proto* 文件中定义服务并利用生成的代码，轻松地添加 gRPC 支持。这使得你能够快速高效地搭建分布式服务或与现有的
    gRPC 服务进行集成。
