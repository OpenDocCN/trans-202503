- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SHORTEST PATHS IN WEIGHTED GRAPHS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter generalizes what we learned in [Chapter 5](ch05.xhtml) about finding
    shortest paths. In [Chapter 5](ch05.xhtml), our focus was on finding the minimum
    number of moves needed to solve a problem. Now, what if we care not about the
    minimum number of moves but about the minimum amount of time or distance? Think
    about using a GPS app to get home. Maybe there’s a route to get home using only
    one street that takes 10 minutes. Maybe there’s another way that involves using
    three streets that takes only eight minutes in total. We might prefer using the
    three streets, since they save us time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll learn *Dijkstra’s algorithm* for finding shortest paths
    in weighted graphs. We’ll use it to determine the number of mice that can escape
    a maze within a time limit and the number of shortest paths between someone’s
    home and their grandma’s house. I chose that grandma example in particular to
    reprise a discovery we made in [Chapter 5](ch05.xhtml): that, suitably modified,
    algorithms such as BFS and Dijkstra’s can do much more than “find the shortest
    path.” We’re learning algorithms—deservedly famous ones—but also stocking up on
    flexible problem-solving tools. Let’s go!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: Mice Maze'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is UVa problem `1112`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A maze consists of cells and passages. Each passage leads from some cell *a*
    to some other cell *b*, and it takes *t* time units to walk the passage. For example,
    it may take 5 time units to walk from Cell 2 to Cell 4\. Now for the passage going
    the other way: it may take 70 time units to walk from Cell 4 to Cell 2, or there
    may be no passage at all from Cell 4 to Cell 2—the *a* *→* *b* and *b* *→* *a*
    passages are independent. One of the cells of the maze is designated as the exit
    cell.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lab mouse in each cell, including the exit cell. The mice have been
    trained to walk to the exit cell in as little time as possible. Our task is to
    determine the number of mice that can reach the exit cell within a specified time
    limit.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first line of input gives the number of test cases and is followed by a
    blank line. There’s also a blank line between each pair of test cases. Each test
    case consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of cells in the maze. Cells are numbered 1
    to *n*; *n* is at most 100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *e*, the exit cell. *e* is between 1 and *n*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *t*, the integer time limit for the mice to get to the exit
    cell. *t* is at least zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *m*, the number of passages in the maze.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, each describing a passage in the maze. Each such line contains three
    integers: the first cell *a* (between 1 and *n*), the second cell *b* (between
    1 and *n*), and the time (at least zero) it takes to walk from *a* to *b*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For each test case, output the number of mice that reach the exit cell *e* within
    the time limit *t*. The output for each test case is separated from the next by
    a blank line.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test cases—for our code, not the mice—is three
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Moving On from BFS*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are key similarities between the Mice Maze problem and the three problems
    in [Chapter 5](ch05.xhtml). We can model the Mice Maze as a graph, where the nodes
    are the maze cells and the edges are the passages. The graph is directed (as in
    the Rope Climb problem), because a passage from Cell *a* to Cell *b* tells us
    nothing about the possible passage from *b* to *a*.
  prefs: []
  type: TYPE_NORMAL
- en: The workhorse for the three problems in [Chapter 5](ch05.xhtml) was breadth-first
    search. The killer feature of BFS is that it finds shortest paths. Not coincidentally,
    we want shortest paths for our Mice Maze, too. They’ll let us determine how long
    it takes each mouse to reach the exit cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, all this talk of similarities is obscuring a crucial difference: the
    Mice Maze graph is *weighted*: on each edge, we have an arbitrary integer giving
    the time required to traverse that edge. See [Figure 6-1](ch06.xhtml#ch06fig01)
    for an example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: The Mice Maze graph*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that the exit cell is Cell 4\. What’s the minimum amount of time
    taken by the mouse in Cell 1 to get to Cell 4? There’s an edge directly from Cell
    1 to Cell 4, so if we were counting edges (as in BFS), then the answer would be
    `1`. However, we are not interested in the number of edges here: instead, we want
    the shortest path in terms of the sum of its edge weights. The weight of the 1
    *→* 4 edge is 45\. That is not the shortest path. The shortest path from Cell
    1 to Cell 4 is the three-edge path that goes from Cell 1 to Cell 3 (six units
    of time), then from Cell 3 to Cell 2 (two units of time), and finally from Cell
    2 to Cell 4 (nine units of time). That’s 6 + 2 + 9 = 17 in all. It is because
    of this focus on edge weights, not edge counts, that BFS is out of its element
    here and we’ll need a different algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hold on, though: there were some weighted graphs in [Chapter 5](ch05.xhtml),
    and we used BFS on those. What gives? Look back at [Figure 5-6](ch05.xhtml#ch05fig06),
    a Rope Climb graph where some of the edges had weight 1 and others had weight
    0\. We managed to use a variant of BFS there, but only because the edge weights
    were so constrained. Now look back at [Figure 5-7](ch05.xhtml#ch05fig07), a Book
    Translation graph. That’s a full-blown weighted graph with arbitrary edge weights.
    We managed to use BFS there, too, but that’s because the primary distance measure
    was the number of edges. Once a node’s edge distance was determined by BFS, only
    then did the edge weights come into play, helping us add the node as cheaply as
    possible.'
  prefs: []
  type: TYPE_NORMAL
- en: However, in no way does the Mice Maze have anything to do with the number of
    edges. A path from *a* to *b* might have 100 edges and a total time of 5 units.
    A different path from *a* to *b* might have only 1 edge with a time of 80 units.
    BFS would discover that second path, when what we want is the first.
  prefs: []
  type: TYPE_NORMAL
- en: '*Finding Shortest Paths in Weighted Graphs*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'BFS operates by progressively identifying nodes that are further and further
    away, in terms of edge count, from the starting node. The algorithm that I’ll
    present in this section operates similarly: it identifies the shortest path for
    nodes further and further away, in terms of total edge weight, from the starting
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: BFS organizes its work in rounds, where the nodes discovered in the next round
    are one edge more distant than the nodes in the current round. We aren’t going
    to be able to use that rounds idea to find shortest paths in weighted graphs,
    because the shortest paths that we discover most recently are not necessarily
    those that will help us find the shortest path for a new node. We’ll have to work
    a little harder to find the next shortest path.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, let’s find the shortest paths from Node 1 to each node in the
    graph using [Figure 6-1](ch06.xhtml#ch06fig01). That will tell us how long it
    takes the mouse in cell 1 to get to the exit cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each node, we’ll maintain two pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '***done***   This is a true/false variable. If it’s false, it means that we
    haven’t found the shortest path for this node yet; if it’s true, then we have.
    Once a node’s *done* value is true, we’re done with it: its shortest path will
    never change again.'
  prefs: []
  type: TYPE_NORMAL
- en: '***min_time***   This is the shortest path distance from the starting node
    to this node, in terms of total time, using a path whose other nodes are all done.
    As more and more nodes become done, *min_time* can decrease, because we have more
    options for paths to this node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shortest path from Node 1 to Node 1 is 0: there’s nowhere to go and no
    edge to take. Let’s start there, with a *min_time* for Node 1 of 0 and no *min_time*
    information for the other nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | false | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | false |  |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | false |  |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | false |  |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | false |  |'
  prefs: []
  type: TYPE_TB
- en: 'We next set Node 1 to done, and then we set the *min_time* for each other node
    based on the edge weights from Node 1\. Here’s our next snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | true | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | false | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | false | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | false | 45 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | false | 7 |'
  prefs: []
  type: TYPE_TB
- en: 'Now, here’s a claim that’s at the heart of what we’re doing here: the shortest
    path from Node 1 to Node 3 is 6, and there’s no way we can ever do better than
    6\. I chose Node 3 in my claim because it has the smallest *min_time* value of
    any node that is not done.'
  prefs: []
  type: TYPE_NORMAL
- en: Claiming that the answer is 6 right now might seem brazen. What if there were
    some other path to Node 3 that was shorter, maybe another path that goes through
    some other nodes before eventually making its way to Node 3?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s why that can’t happen, and why our claim of 6 is safe. Imagine that
    there were some shorter path *p* from Node 1 to Node 3\. That path must start
    at Node 1 and leave Node 1 on some edge *e*. Then it must take zero or more other
    edges and arrive at Node 3\. Check it out: *e* already takes at least 6 time units,
    because 6 is the minimum time it takes to go from Node 1 to some other node. Any
    other edges that are on *p* only add to this, so there’s no way that *p* could
    have a total time of less than 6 units!'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, Node 3 is done: we know its shortest path. Now we will have to use Node
    3 to check whether we can improve any of the shortest paths for nodes that are
    not yet done. Remember that the *min_time* values give the shortest path using
    done nodes. It takes 6 time units to get to Node 3, and there’s an edge from Node
    3 to Node 2 that takes 2 time units, so we now have a way to get from Node 1 to
    Node 2 in only 8 time units. We therefore update the *min_time* value for Node
    2 from 12 to 8\. Here’s where that leaves us:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | true | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | false | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | true | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | false | 45 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | false | 7 |'
  prefs: []
  type: TYPE_TB
- en: 'Nodes 2, 4, and 5 are not yet done. Which one can we doneify now? The answer
    is Node 5: it’s got the minimum *min_time*. Can we use Node 5 to update any of
    our other shortest paths? Node 5 does have an outgoing edge to Node 2, but getting
    from Node 1 to Node 5 (7 time units) and then taking the edge from Node 5 to Node
    2 (21 time units) takes more time (7 + 21 = 28) than our old path from Node 1
    to Node 2 (8 time units). So we leave Node 2’s *min_time* alone. The only change
    in the next snapshot, then, is to set Node 5 to done.'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | true | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | false | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | true | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | false | 45 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | true | 7 |'
  prefs: []
  type: TYPE_TB
- en: 'There are two nodes to go. Node 2 has a *min_time* of 8, and Node 4 has a *min_time*
    of 45\. As always, we choose the smaller, finalizing the shortest path distance
    from Node 1 to Node 2 as 8\. Again, there can be no shorter path to Node 2 than
    8\. Any shorter path *p* from Node 1 to Node 2 must begin with some done nodes
    and will at some point cross for the first time on an edge from a done node to
    one that is not done. Call that edge *x* *→* *y*, where *x* is done and *y* is
    not. So that’s how *p* gets from Node 1 to Node *y*. It can then do whatever it
    wants to get from Node *y* to Node 2 . . . but it’s all frivolous. Getting from
    Node 1 to Node *y* already takes at least 8 time units: if it were less, then
    *y*’s *min_time* value would be less than 8 and we’d have chosen to set *y* to
    done rather than Node 2\. Whatever *p* does to get from Node *y* to Node 2 can
    only add even more time. So *p* can’t be shorter than 8.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding Node 2 gives us two edges to check for shorter paths. There’s an edge
    from Node 2 to Node 1, but that won’t help us because Node 1 is already done.
    There’s an edge of 9 time units from Node 2 to Node 4\. That one does help us!
    Getting from Node 1 to Node 2 takes 8 time units, and then the 2 *→* 4 edge takes
    9 time units, for a total of 17 time units. That’s better than our old path from
    Node 1 to Node 4 that took 45 time units. Here’s the next snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | true | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | true | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | true | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | false | 17 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | true | 7 |'
  prefs: []
  type: TYPE_TB
- en: 'There’s only one node, Node 4, that’s not done. As all other nodes are done,
    we’ve found all of their shortest paths. Node 4, therefore, can’t help us find
    any new, shorter paths. We can set Node 4 to done and conclude:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | true | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | true | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | true | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | true | 17 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | true | 7 |'
  prefs: []
  type: TYPE_TB
- en: It takes 17 time units for the mouse in Cell 1 to get to the exit cell 4\. We
    could repeat the process for each other node to find out how long each other mouse
    takes to get to the exit cell, then count the mice that get there in time.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is known as Dijkstra’s algorithm, after Edsger W. Dijkstra, a
    pioneering and influential computer scientist. Given a starting node *s* and a
    weighted graph, it calculates the shortest path from *s* to each node in the graph.
    It’s exactly what we need to solve the Mice Maze problem. Let’s read the input
    to build the graph and then see how Dijkstra’s algorithm can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '*Building the Graph*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With all of your experience building trees and graphs to this point, there won’t
    be many surprises here. We’ll build the graph like we built it for the Book Translation
    problem in the previous chapter (see “Building the Graph” on [page 189](ch05.xhtml#sec79)).
    The only difference is that the graphs there were undirected and our graphs here
    are directed. In more good news, we’re given the node numbers directly and don’t
    have to map between language names and integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just so we have something on which to test, here’s an input corresponding to
    [Figure 6-1](ch06.xhtml#ch06fig01):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That `12` ➊ gives the time limit for the mice to get to the exit. (You can verify
    that three mice can get to the exit within this time limit; those mice are the
    ones in Cells 2, 3, and 4.)
  prefs: []
  type: TYPE_NORMAL
- en: As in Book Translation, we’ll use an adjacency list representation of the graph.
    Each edge maintains the cell to which it points, the length of time required to
    walk the edge, and a next pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the needed constant and `typedef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The graphs are read by the `main` function in [Listing 6-1](ch06.xhtml#ch06ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-1: The* main *function for building the graph*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The input specification says that a blank line follows the number of test cases
    and that a blank line sits between each pair of test cases. However, using `scanf`,
    we don’t have to worry about that: when reading a number, `scanf` skips leading
    whitespace (including newlines) that it encounters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do for each test case is to clear the adjacency list by
    setting each cell’s edge list to `NULL` ➊. Not doing that results in a horrible
    bug where each test case includes edges from prior test cases. (I would know:
    I made that mistake, and three hours later it was three hours later.) It’s our
    responsibility to clear things for each test case!'
  prefs: []
  type: TYPE_NORMAL
- en: Upon initializing each edge, we add it to the linked list for `from_cell` ➋.
    We don’t add anything to the linked list for `to_cell`, because the graph is directed
    (not undirected).
  prefs: []
  type: TYPE_NORMAL
- en: The problem requires that we find the shortest path from each cell to the exit
    cell. For each cell, then, we call `find_time` ➌, a helper function that implements
    Dijkstra’s algorithm. We’ll write that function next. Given a starting cell `i`
    and target cell `exit_cell`, it returns `-1` if there’s no path at all or else
    returns the shortest path time. Each cell that takes `time_limit` units of time
    or less to get to the exit cell results in `total` being incremented by one ➍.
    Once each cell’s shortest path has been considered, `total` is output.
  prefs: []
  type: TYPE_NORMAL
- en: '*Implementing Dijkstra’s Algorithm*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to implement Dijkstra’s algorithm, following the outline provided
    in “Finding Shortest Paths in Weighted Graphs” on [page 200](ch06.xhtml#sec84).
    Here’s the signature for the function that we’ll implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The four parameters correspond to the adjacency list, number of cells, starting
    cell, and exit cell, respectively. Dijkstra’s algorithm will calculate the shortest
    path time from the starting cell to all other cells, including the exit cell.
    Once we’re done, we can return the shortest path time to the exit cell. That may
    seem extravagant, calculating the shortest path to all cells only to throw everything
    away except the shortest path to the exit cell. There are various optimizations
    that we can perform, and we’ll turn to those in the next subsection. For now,
    let’s settle in with a working, unadorned implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of Dijkstra’s algorithm is implemented by two nested `for` loops.
    The outer `for` loop runs once per cell; each iteration sets one cell to done
    and updates shortest paths using that new cell. The inner `for` loop is a minimum
    computation: it finds the cell whose `min_time` value, among all cells that are
    not done, is minimum. See [Listing 6-2](ch06.xhtml#ch06ex02) for the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-2: The shortest path to the exit cell using Dijkstra’s algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the `done` array is to indicate whether each cell is done: a
    `0` means “not done” and a `1` means “done.” The purpose of the `min_times` array
    is to store the shortest path distance from the starting cell to each cell.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a `for` loop ➊ to initialize these two arrays: it sets all `done` values
    to `0` (false) and `min_times` values to `-1` (not found). We then set `min_times`
    for `from_cell` to `0` ➋ to indicate that the shortest path distance from the
    starting cell to itself is zero.'
  prefs: []
  type: TYPE_NORMAL
- en: The `found` variable tracks whether a new cell can be discovered by Dijkstra’s
    algorithm. On each iteration of the outer `for` loop, it starts off as `0` (false)
    ➌ and gets set to `1` (true) if a cell can be found—but how could a cell not be
    found? For example, earlier in this chapter, we found all of the cells. However,
    there may be graphs where there is *no* path between a starting cell and some
    other cell. On those graphs, there will be cells that Dijkstra’s algorithm does
    not find; when no new cell can be found, it’s time to stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we arrive at the inner `for` loop ➍, whose task is to identify the cell
    whose shortest path will be found next. This loop will leave `min_time_index`
    with the index of the cell whose shortest path has been found and `min_time` with
    the shortest path time itself. The eligible cells are those that are both not
    done and have a `min_times` value that’s at least `0` (that is, not `-1`) ➎. We
    need the cell to be not done, because done cells already have their shortest paths
    finalized. We also need the `min_times` value to be at least `0`: if it’s `-1`,
    then the cell hasn’t been found yet, so we have no idea what its shortest path
    is. If we had no eligible cell yet or the current cell has a shorter path than
    our shortest thus far ➏, we update `min_time` and `min_time_index` and set `found`
    to `1` to flag that we successfully found a cell.'
  prefs: []
  type: TYPE_NORMAL
- en: If no cell was found, then we stop ➐. Otherwise, we set the identified cell
    to done and loop through its outgoing edges to find shorter paths. For each edge
    `e`, we check whether the cell provides a shorter path to `e->to_cell` ➑. That
    possible shorter path is `min_time` (the time taken to get from `from_cell` to
    `min_time_index`) plus the time taken to walk edge `e` (from `min_time_index`
    to `e->to_cell`).
  prefs: []
  type: TYPE_NORMAL
- en: When looking at edge `e`, shouldn’t we first be verifying that `e->to_cell`
    is not done before checking whether we’ve found a shorter path ➑? Although we
    could add that check, it would have no effect. Done cells already have their finalized
    shortest paths; there’s no way that some shorter path can be found.
  prefs: []
  type: TYPE_NORMAL
- en: Having computed shortest paths to all cells, we’ve certainly computed the shortest
    path to the exit cell. The final thing to do is return that time ➒.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a wrap! Go ahead and submit to the judge. The code should pass all of
    the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '*Two Optimizations*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a few things that can be done to speed up Dijkstra’s algorithm. The
    most widely applicable and dramatic speedup is wrought by a data structure called
    a *heap*. In our current implementation, it’s very expensive to find the next
    node to set to done, as we need to scan through all nodes that are not done to
    find the one with the shortest path. A heap uses a tree to convert this slow,
    linear search into a fast search. As heaps are useful in many contexts beyond
    Dijkstra’s algorithm, I’ll discuss them later, in [Chapter 8](ch08.xhtml). Here,
    I’ll offer a couple of optimizations more specific to the Mice Maze problem.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that as soon as a cell is done, we never change its shortest path again.
    As such, once we set the exit cell to done, we have its shortest path. After that,
    there’s no reason to find shortest paths for other cells. We may as well terminate
    Dijkstra’s algorithm early.
  prefs: []
  type: TYPE_NORMAL
- en: We can still do better, though. For a maze of *n* cells, we invoke Dijkstra’s
    algorithm *n* times, once for each cell. For Cell 1, we compute all shortest paths—and
    then keep only the shortest path to the exit cell. We do the same for Cell 2,
    Cell 3, and so on, throwing out all of the shortest paths we found except for
    those that involve the exit cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, consider running Dijkstra’s algorithm just once, with the exit cell
    as the starting cell. Dijkstra’s algorithm would then find the shortest path from
    the exit cell to Cell 1, the exit cell to Cell 2, and so on. However, that’s not
    quite what we want, because the graph is directed: the shortest path from the
    exit cell to Cell 1 is *not* necessarily the shortest path from Cell 1 to the
    exit cell.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here again is [Figure 6-1](ch06.xhtml#ch06fig01):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch06fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we discovered earlier, the shortest path from Cell 1 to Cell 4 is 17, but
    the shortest path from Cell 4 to Cell 1 is 36.
  prefs: []
  type: TYPE_NORMAL
- en: The shortest path from Cell 1 to Cell 4 uses the edges 1 *→* 3, 3 *→* 2, and
    2 *→* 4\. If we intend on starting Dijkstra’s algorithm from Cell 4, then we need
    it to find edges 4 *→* 2, 2 *→* 3, and 3 *→* 1\. Each of these edges is the *reverse*
    of an edge in the original graph. [Figure 6-2](ch06.xhtml#ch06fig02) shows the
    *reversed graph*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: A reversed version of the graph in [Figure 6-1](ch06.xhtml#ch06fig01)*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can run Dijkstra’s algorithm—just one invocation of it!—from Cell 4 to
    recover shortest paths to all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of implementation, we would need to produce the reversed graph instead
    of the original graph. This can be done in the `main` function ([Listing 6-1](ch06.xhtml#ch06ex01)),
    when reading the graph. Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'we want this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That is, the edge now points to `from_cell`, and it gets added to the linked
    list for `to_cell`. If you make this change and adapt the code so that it invokes
    Dijkstra’s algorithm just once (from the exit cell), you’ll end up with a much
    faster program. Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra’s Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm takes over where BFS leaves off. BFS finds shortest paths
    in terms of numbers of edges in an unweighted graph; Dijkstra’s algorithm finds
    shortest paths in terms of edge weights in a weighted graph.
  prefs: []
  type: TYPE_NORMAL
- en: Like BFS, Dijkstra’s algorithm takes a starting node, and it finds shortest
    paths from there to each node in the graph. Like BFS, it then solves the *single-source
    shortest-paths* problem, except on weighted graphs rather than unweighted graphs.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, Dijkstra’s algorithm *can* find shortest paths in unweighted graphs,
    too. Just take the unweighted graph and give each edge a weight of one. Now, when
    Dijkstra’s algorithm finds the shortest paths, it will have minimized the number
    of edges in the path, precisely what BFS does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why not hammer every shortest-path problem, unweighted or weighted, with Dijkstra’s
    algorithm, then? Indeed, there are problems where it’s difficult to decide between
    BFS and Dijkstra’s algorithm. For example, I suspect that many people would have
    chosen Dijkstra’s algorithm over (modified) BFS to solve the Rope Climb problem
    in [Chapter 5](ch05.xhtml). When the task is clearly to minimize the number of
    moves, BFS should still get the call: it’s generally easier to implement than
    Dijkstra’s algorithm and runs a little faster, too. By no means, however, is Dijkstra’s
    algorithm slow.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Runtime of Dijkstra’s Algorithm*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s characterize the runtime of Dijkstra’s algorithm as seen in [Listing 6-2](ch06.xhtml#ch06ex02).
    We’ll use *n* to refer to the number of nodes in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization loop ➊ iterates *n* times, doing a constant number of steps
    per iteration, so it does total work proportional to *n*. The next bit of initialization
    ➋ is a single step. Whether we say that the initialization takes *n* steps or
    *n* + 1 steps changes nothing, so we’ll ignore this 1 and say that it takes *n*
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: The real work done by Dijkstra’s algorithm starts now. Its outer `for` loop
    iterates up to *n* times. For each such iteration, the inner `for` loop does *n*
    iterations to find the next node. The inner `for` loop, then, iterates a total
    of *n*² times. Each such iteration does a constant amount of work, so the inner
    `for` loop does total work proportional to *n*².
  prefs: []
  type: TYPE_NORMAL
- en: The other work that Dijkstra’s algorithm does is to iterate through the edges
    of each node. There are a total of *n* nodes, so certainly each node has no more
    than *n* edges leaving it. We therefore take *n* steps to iterate through the
    edges of one node, and we have to do this for each of the *n* nodes. That’s another
    *n*² steps.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing, we’ve got *n* work in the initialization, *n*² work in the inner
    `for` loop, and *n*² work checking the edges. The biggest exponent there is 2,
    so this is an *O*(*n*²), or quadratic, algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml), we sneezed at a quadratic-time algorithm for Unique
    Snow-flakes, tossing it away in favor of a linear-time algorithm. In that sense,
    the implementation of Dijkstra’s algorithm that we have developed is not too impressive.
    In another sense, though, it is, because in *n*² time it’s solving not one but
    *n* problems, one for each shortest path from the starting node.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve chosen to present Dijkstra’s algorithm in this book, but there are many
    other shortest-paths algorithms. Some find the shortest path between all pairs
    of nodes in the graph in one fell swoop. Doing so solves the *all-pairs shortest-paths*
    problem. One such algorithm is called the *Floyd–Warshall algorithm*, and it runs
    in *O*(*n*³) time. Interestingly, we can find all-pairs shortest paths with Dijkstra’s
    algorithm, too, and just as quickly. We can run Dijkstra’s algorithm *n* times,
    once from each starting node. That’s *n* invocations of an *n*² algorithm, for
    a total of *O*(*n*³) work.
  prefs: []
  type: TYPE_NORMAL
- en: Weighted or unweighted, single-source or all-pairs, Dijkstra’s algorithm can
    do it. Is it simply unstoppable? Negative!
  prefs: []
  type: TYPE_NORMAL
- en: '*Negative-Weight Edges*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve made an implicit assumption to this point in the chapter: edge weights
    are nonnegative. In the Mice Maze, for example, edge weights represent times to
    walk edges; walking an edge surely can’t cause time to go backward, so no edge
    weight was negative. Similarly, in many other graphs, edges with negative weights
    don’t arise simply because they don’t make sense. For example, consider a graph
    where the nodes are cities and edges are flight costs between cities. No airline
    is going to pay us for taking their flights, so each edge will be a nonnegative
    dollar cost.'
  prefs: []
  type: TYPE_NORMAL
- en: Now consider a game in which some moves give us points, and other moves take
    points away. Those latter moves correspond to *negative-weight edges*. Thus negative-weight
    edges do appear from time to time. How does Dijkstra’s algorithm respond? Let’s
    find out using the sample graph in [Figure 6-3](ch06.xhtml#ch06fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: A graph with a negative-weight edge*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to find shortest paths from Node A. As always, Dijkstra’s algorithm
    begins by assigning a shortest path of 0 to Node A and setting Node A to done.
    The distance to B from A is 3, the distance to C from A is 5, but the distance
    to D from A is not defined (and has been left blank):'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | true | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| B | false | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| C | false | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| D | false |  |'
  prefs: []
  type: TYPE_TB
- en: 'Dijkstra’s algorithm then decides to finalize the shortest path to Node B at
    3, and it sets B to done. It also updates the shortest path to D:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | true | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| B | true | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| C | false | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| D | false | 4 |'
  prefs: []
  type: TYPE_TB
- en: 'By virtue of B being done, we’re claiming that 3 is the shortest path from
    A to B, but that spells trouble, because 3 is *not* the shortest path that we
    can find from A to B. The shortest path is *A* *→* *C* *→* *B*, with a total weight
    of –495\. For kicks, let’s continue under these fishy circumstances and see what
    Dijkstra’s algorithm would do anyway. The next node that’s done is D:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | true | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| B | true | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| C | false | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| D | true | 4 |'
  prefs: []
  type: TYPE_TB
- en: 'That shortest path to D is wrong, too! It should be –494\. As all nodes are
    done except for C, there’s nothing that C can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | true | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| B | true | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| C | true | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| D | true | 4 |'
  prefs: []
  type: TYPE_TB
- en: Even if we let Dijkstra’s algorithm change the shortest path to B here, from
    3 to –495, then the shortest path to D will still be wrong. We’d have to somehow
    process B again, even though B is done. We’d need some way of saying, “Hey, I
    know that I said B was done, but I’m changing my mind.” In any event, the classical
    Dijkstra’s algorithm as I’ve presented it gets this example wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In general, Dijkstra’s algorithm does not work when graph edges can be negative.
    For that, you may wish to explore the *Bellman–Ford algorithm* or the aforementioned
    Floyd–Warshall algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed here with another problem where we don’t have to worry about negative-weight
    edges. We’ll use Dijkstra’s algorithm again, or, rather, we’ll adapt Dijkstra’s
    algorithm to solve a new kind of problem about shortest paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Grandma Planner'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we’ll be asked for not only the shortest path distance but also further
    information about the shortest paths. This problem is just such an example.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `saco08p3`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bruce is planning a trip to his grandma’s house. There are *n* towns, numbered
    1 to *n*. Bruce starts in Town 1, and his grandma lives in Town *n*. Between each
    pair of towns is a road, and we’re given the length (distance) of each road.
  prefs: []
  type: TYPE_NORMAL
- en: Bruce wishes to arrive at his grandma’s with a box of cookies, so he must buy
    it along the way. Some of the towns have cookie stores; Bruce is required to hit
    at least one of these cookie towns on his way to his grandma’s.
  prefs: []
  type: TYPE_NORMAL
- en: Our task is twofold. First, we must determine the minimum distance needed for
    Bruce to get from his starting point to his grandma’s house, picking up a box
    of cookies along the way. That minimum distance does not tell us how many options
    Bruce has for getting to his grandma’s. Maybe there’s only one way that he can
    do it, with all other routes requiring greater distance, or maybe there are several
    routes all with the same minimum distance. So, second, we’re asked to determine
    the number of these minimum-distance routes.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of towns. Towns are numbered 1 to *n*. There
    are between 2 and 700 towns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each containing *n* integers. The first of these lines gives the
    road distance from Town 1 to each town (Town 1, then Town 2, and so on); the second
    of these lines gives the road distance from Town 2 to each town; and so on. The
    distance from a town to itself is zero; each other distance is at least one. The
    distance from Town *a* to Town *b* is the same as the distance from Town *b* to
    Town *a*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *m*, the number of towns that have a cookie store. *m* is
    at least one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *m* integers, each giving the number of a town with a cookie
    store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Output the following on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum distance to get from Town 1 to Town *n* (picking up a box of cookies
    along the way)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of minimum-distance routes, mod 1,000,000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time limit for solving the test case is one second.
  prefs: []
  type: TYPE_NORMAL
- en: '*Adjacency Matrix*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The way that the graph is represented here differs from that of the Mice Maze
    and that of the Book Translation problem in [Chapter 5](ch05.xhtml). In those
    two problems, each edge was supplied as one node, the other node, and the edge
    weight. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This means that there’s an edge from Node 1 to Node 2 with weight 12.
  prefs: []
  type: TYPE_NORMAL
- en: In the Grandma Planner problem, the graph is presented as an *adjacency matrix*,
    which is a two-dimensional array of numbers where a given row, column coordinate
    gives us the weight of the edge at that row and column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `4` at the top tells us that there are four towns. The next four lines
    are the adjacency matrix. Let’s focus on the first of those lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This single line gives all of the edges leaving Town 1\. There’s an edge from
    Town 1 to Town 1 of weight `0`, from Town 1 to Town 2 of weight `3`, from Town
    1 to Town 3 of weight `8`, and from Town 1 to Town 4 of weight `2`.
  prefs: []
  type: TYPE_NORMAL
- en: The next line,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: does similarly for Town 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there’s an edge between any pair of towns; that is, there are no
    missing edges. Such a graph is called a *complete graph*.
  prefs: []
  type: TYPE_NORMAL
- en: This adjacency matrix has some redundancy. For example, it says in row 1, column
    3 that there’s an edge from Town 1 to Town 3 of weight `8`. However, since the
    problem specifies that the road from Town *a* to Town *b* is the same distance
    as that of the road from Town *b* to Town *a*, we see this `8` again in row 3,
    column 1\. (We’re therefore dealing with undirected graphs.) We also have `0`’s
    along the diagonal, which explicitly state that the distance from some town to
    itself is zero. We’ll just ignore those.
  prefs: []
  type: TYPE_NORMAL
- en: '*Building the Graph*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This problem is ultimately going to demand our creativity not once, but twice.
    First, we’ll need to force our paths through a town with a cookie store. Among
    those paths, we want the shortest one. Second, we’ll need to keep track not only
    of the shortest path but also of the number of ways we can realize that shortest
    path. Double the fun, I say!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by reading the test case from the input and building the graph.
    We’re well positioned to do that at this point. With our graph in hand, we’ll
    then be ready for what lies ahead.
  prefs: []
  type: TYPE_NORMAL
- en: The plan is to read the adjacency matrix, building our adjacency lists as we
    go. We’ll have to keep track of the town indices ourselves, since the adjacency
    matrix doesn’t explicitly provide them.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to read in and use the adjacency matrix directly, avoiding the
    adjacency list representation altogether. Each row *i* gives the distance to each
    town, so we could just loop through row *i* in Dijkstra’s algorithm instead of
    looping through *i*’s adjacency list. Since the graph is complete, we wouldn’t
    even have to waste time skipping over edges that don’t exist. We’ll use adjacency
    lists here, however, for continuity with what we’ve already done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a constant and `edge` struct that we’ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code for reading the graph is given in [Listing 6-3](ch06.xhtml#ch06ex03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-3: The* main *function for building the graph*'
  prefs: []
  type: TYPE_NORMAL
- en: After reading the number of towns, we use a double `for` loop to read the adjacency
    matrix. Each iteration of the outer `for` loop ➊ is responsible for reading one
    row, specifically, the row for `from_town`. To read that row, we have an inner
    `for` loop, which reads one `length` value for each `to_town`. So now we know
    where the edge starts, where the edge ends, and the length of the edge. We then
    want to add the edge, but only if it’s not one of those 0-weight edges that go
    from a town back to itself. If the edge is between distinct towns ➋, then we add
    it to the adjacency list for `from_town`. Because the graph is undirected, we
    must also ensure that eventually this edge is added to the adjacency list for
    `to_town`. We had to do that explicitly in [Listing 5-16](ch05.xhtml#ch05ex016)
    when solving the Book Translation problem. We don’t have to do that here, though,
    because it’ll get added later without us doing anything special when we process
    the row for `to_town`. For example, if `from_town` is `1` and `to_town` is `2`,
    then the 1 *→* 2 edge will be added now. Later, when `from_town` is `2` and `to_town`
    is `1`, then the 2 *→* 1 edge will be added.
  prefs: []
  type: TYPE_NORMAL
- en: All that’s left is to read the information about which towns have cookie stores,
    starting with the number of such towns ➌. To keep track of these towns, we use
    array `store`, where `store[i]` is `1` (true) if Town `i` has a cookie store and
    `0` (false) if it does not.
  prefs: []
  type: TYPE_NORMAL
- en: '*Working Through a Weird Test Case*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s get a feel for the problem by working through the test case from “Adjacency
    Matrix” on [page 214](ch06.xhtml#sec91). The corresponding graph is provided in
    [Figure 6-4](ch06.xhtml#ch06fig04), where **c** represents a cookie town.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: The grandma graph*'
  prefs: []
  type: TYPE_NORMAL
- en: Bruce starts in Town 1 and has to get to Town 4\. Town 2 is the only town with
    a cookie store. What’s the shortest-distance path? While it’s true that Bruce
    can zip from Town 1 directly to Town 4 along the edge of distance 2, that isn’t
    a feasible solution to the problem. Remember that we need to ensure that a town
    with a cookie store is included in any proposed shortest path. For this particular
    graph, this means that we must include Town 2\. (In other test cases, there could
    be multiple towns that have cookie stores; what we’d need to do is include one
    or more of them.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a path from Town 1 to Town 4 that *is* feasible: 1 *→* 2 (distance 3)
    *→* 4 (distance 1). That’s a total distance of 4, and it is indeed a shortest
    path from Town 1 to Town 4 that passes through Town 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s not the only optimal path, though. There’s one more, and here it is:
    1 *→* 4 (distance 2) *→* 2 (distance 1) *→* 4 (distance 1). What’s a little weird
    about this path is that we visit Town 4, grandma’s house, *twice*. We start by
    going from Town 1 to Town 4, but we cannot end the path there because we don’t
    have the box of cookies yet. Then we go from Town 4 to Town 2, where we pick up
    the box of cookies. Finally, we go from Town 2 to Town 4, which is our second
    visit to Town 4, but this time we arrive with the box of cookies, and so we have
    a feasible path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It does seem that this path is cyclic, since we get to Town 4 once and then
    get to Town 4 again. Viewed in a different light, however, there is no cycle at
    all. When we visited Town 4 the first time, we had no box of cookies; when we
    visited Town 4 again, we had a box of cookies. These two visits are therefore
    not repeats: it’s true that Town 4 was visited twice, but it is also true that
    the state (not carrying a box of cookies versus carrying a box of cookies) differs
    each time.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we see that the same town can’t possibly be visited more than twice. If
    a town is visited three times, for example, then two of those visits must be in
    the same state. Perhaps Visit 1 and Visit 2 were both in the “not carrying a box
    of cookies” state. Then that really is a cycle, and it costs us some distance
    to traverse the cycle, so removing it gives a shorter path.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not sufficient, then, to know which town we’re in. We also need to know
    whether or not a box of cookies has been picked up.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve wrestled with this kind of problem once before, when solving Rope Climb
    in [Chapter 5](ch05.xhtml). There, we discussed adding a second rope to produce
    a more suitable model of the problem. We’re going to reprise that idea here, by
    adding a state that tells us whether or not a box of cookies is being carried.
    In State 0, no box of cookies is being carried; in State 1, a box of cookies is
    being carried. A feasible path, then, is any path that arrives at grandma’s house
    in State 1\. Arriving at grandma’s house in State 0 cannot be the end of a feasible
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 6-5](ch06.xhtml#ch06fig05), which introduces a cookie
    state to [Figure 6-4](ch06.xhtml#ch06fig04). Again, **c** represents a cookie
    town. The edges with no arrows are undirected, but now we have some directed edges,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: A grandma graph with a cookie state*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we do to create this graph:'
  prefs: []
  type: TYPE_NORMAL
- en: Add four new town nodes, one for each original town in the graph. The original
    nodes are in State 0; the new nodes are in Sate 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep all of the original edges, except for those leaving Town 2 (the town with
    the cookie store). If we reach Town 2 in State 0, then we’ve transitioned to State
    1, so the only edge leaving (2,0) is the directed edge to (2,1). It’s a 0-weight
    edge, because changing state takes no time. While Dijkstra’s algorithm can’t be
    trusted on graphs with negative-weight edges (see “Negative-Weight Edges” on [page
    211](ch06.xhtml#sec89)), 0-weight edges are okay.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect nodes in State 1 using exactly the same edges that originally connected
    nodes in State 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we’re in State 0 and reach a town with a cookie store, we buy a box of
    cookies and end up in State 1\. Once we’re in State 1, the graph gives us no way
    to return to State 0, because there’s no way to lose the box of cookies.
  prefs: []
  type: TYPE_NORMAL
- en: We start in Town 1, State 0\. We must arrive in Town 4, State 1\. This requires
    that we eventually move from State 0 to State 1 and then go to Town 4 using the
    State-1 edges. When there are multiple towns with cookie stores, the problem becomes
    increasingly tricky, because then we have to choose exactly which cookie town
    takes us from State 0 to State 1\. Well, it might be tricky for us, but not for
    Dijkstra’s algorithm, because we’re just asking for a shortest path in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 1: Shortest Paths*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we’ve talked about how to model the problem as a graph and find the
    shortest path distance, but not how to find the *number* of shortest paths. I’ll
    take these two subtasks in turn. At the end of this subsection, we’ll have solved
    half of the problem, correctly printing the shortest path distance. We won’t be
    printing anything for the number of paths, though, so we’ll still fail all of
    the test cases. Don’t worry: in the next subsection, we’ll work out how to coax
    the number of paths out of our code, too. It’s Dijkstra time!'
  prefs: []
  type: TYPE_NORMAL
- en: With our new model (using the States 0 and 1), the graph that we read from the
    input no longer corresponds to the graph that we’ll explore with Dijkstra’s algorithm.
    One idea is to produce the adjacency list representation of the new graph from
    the adjacency list for the original graph. That is, start with an empty graph
    that has twice the number of nodes and add all of the required edges. That can
    be done, but I think it’s easier to leave the graph alone, logically adding the
    state to the code for Dijkstra’s algorithm. (When solving the Rope Climb problem
    in [Chapter 5](ch05.xhtml), we didn’t have much of a choice of what to do, because
    the input did not contain a graph.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write the function with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `adj_list` is the adjacency list, `num_towns` is the number of towns (and
    the number of grandma’s town), and `store` tells us for any given `i` whether
    town `i` has a cookie store.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll proceed just as we did with the Mice Maze ([Listing 6-2](ch06.xhtml#ch06ex02)).
    At each step, however, we ask what effect the state has on our code and we make
    appropriate modifications. Let’s walk through the code, which is given in [Listing
    6-4](ch06.xhtml#ch06ex04). Compare this code to [Listing 6-2](ch06.xhtml#ch06ex02)
    to highlight the similarities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-4: The shortest path to grandma’s using Dijkstra’s algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: Right from the start, we see the influence of the state on our arrays, as `done`
    and `min_distances` are now two-dimensional arrays. The first dimension is indexed
    by the town number, and the second is indexed by the state. In our initialization
    ➊, we’re careful to initialize the elements of both states.
  prefs: []
  type: TYPE_NORMAL
- en: Our starting point is Town 1, State 0, so that’s the distance that we initialize
    to `0` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we want to continue running Dijkstra’s algorithm until no new nodes
    can be found. We have `num_towns` towns, but each one exists in both State 0 and
    State 1, so we have a maximum of `num_towns * 2` nodes to find ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nested `state` and `j` loops together find the next node. When these loops
    are done ➍, two important variables will be set: `min_town_index` gives the index
    of the town, and `min_state_index` gives the index of the state.'
  prefs: []
  type: TYPE_NORMAL
- en: Our next step depends on which state we’re in and whether the town has a cookie
    store. If we’re in State 0 and at a town with a cookie store ➎, then we ignore
    `adj_list` and consider only the transition to State 1\. Remember that the transition
    from `[min_town_index][0]` to `[min_town_index][1]` has distance `0`, so our new
    path to `[min_town_index][1]` has the same distance as the shortest path to `[min_town_index][0]`.
    In typical Dijkstra fashion, we update the shortest path if our new path is shorter.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we’re in State 0 but not at a town with a cookie store, or we’re
    in State 1\. The available edges here are exactly those in the input graph from
    the current town, so we examine all edges from `min_town_index` ➏. Now we’re in
    Mice Maze territory, looking for new shorter paths using edge `e`. Just be careful
    to use `min_state_index` everywhere, since none of these edges changes the state.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing to do is print the shortest path distance ➐. We use `num_towns`
    as the first index (that’s grandma’s town) and `1` as the second index (so that
    a box of cookies is being carried).
  prefs: []
  type: TYPE_NORMAL
- en: If you run our program on the test case from “Adjacency Matrix” on [page 214](ch06.xhtml#sec91),
    you should get the correct output of `4`. Indeed, for any test case, we’ll output
    the shortest path. Now, let’s move on to the number of shortest paths.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 2: Number of Shortest Paths*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It takes just a few changes to beef up Dijkstra’s algorithm so that it finds
    not only the shortest path distance, but also the number of shortest paths. Those
    changes are subtle, so I’ll begin by working a few steps of an example to give
    you some intuition about why what we’re doing makes sense. I’ll then show the
    new code before giving a more detailed correctness argument.
  prefs: []
  type: TYPE_NORMAL
- en: Working Through an Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s trace Dijkstra’s algorithm on [Figure 6-5](ch06.xhtml#ch06fig05) from
    node (1,0). In addition to tracking whether each node is done and the minimum
    distance to each node, we’ll also keep *num_paths*, giving the number of shortest
    paths of minimum distance to the node. We’ll see that those paths counted by *num_paths*
    get thrown away whenever a shorter path is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we initialize the state for the starting node (1, 0). We set its
    minimum distance to 0 and set it to be done. As there’s exactly one path of distance
    0 from the starting node to itself (the path of no edges), we set its number of
    paths to 1\. We use the edges from the starting node to initialize the other nodes,
    and we set each of them to have one path (the path from the starting node). This
    gives us our first snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (1,0) | true | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (2,0) | false | 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (3,0) | false | 8 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (4,0) | false | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (1,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (2,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (3,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (4,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Now what? Well, as always with Dijkstra’s algorithm, we scan through the nodes
    that are not done and choose one with minimum *min_distance* value. We therefore
    choose node (4,0). Dijkstra’s algorithm guarantees that this node has its shortest
    path set, so we can set it to done. Then, we must check the edges leaving (4,0)
    to see whether we can find shorter paths to other nodes. We can indeed find a
    shorter path to (3,0): before it was 8, but now it’s 7, because we can get to
    (4,0) with distance 2, and then from (4,0) to (3,0) with distance 5\. What do
    we put for the number of shortest paths to (3,0)? Well, it used to be 1, so it’s
    tempting to make it 2\. However, 2 is wrong, because that would count the path
    of distance 8, and that’s no longer a shortest path. The answer is 1, because
    there’s only one path of distance 7.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s an edge from (4,0) to (2,0) that we shouldn’t dismiss too quickly. The
    old shortest path to (2,0) was 3\. What does the edge from (4,0) to (2,0) do for
    us? Does it give us a shorter path? Well, the distance to (4,0) is 2, and the
    edge from (4,0) to (2,0) has distance 1, so we have a new way to get to (2,0)
    with distance 3\. That’s not a shorter path, but it is *another* shortest path!
    That is, getting to (4,0) and then using the edge to (2,0) gives us new ways to
    get to (2,0). The number of new ways is the number of shortest paths to (4,0),
    which is just one. That gives us 1 + 1 = 2 shortest paths to get to (2,0).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all summarized in the next snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (1,0) | true | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (2,0) | false | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| (3,0) | false | 7 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (4,0) | true | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (1,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (2,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (3,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (4,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'The next node that’s done is (2,0). There’s an edge of weight 0 from (2,0)
    to (2,1), and it takes distance 3 to get to (2,0), so we have a shortest path
    of distance 3 to (2,1) as well. There are two ways to get to (2,0) with that minimum
    distance, so there are two ways to get to (2,1) as well. Here’s what we’ve got
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (1,0) | true | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (2,0) | true | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| (3,0) | false | 7 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (4,0) | true | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (1,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (2,1) | false | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| (3,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| (4,1) | false |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'The next node that’s done is (2,1), and it is this node that finds the shortest
    path distance to our destination (4,1). There are two shortest paths to (2,1),
    so there are two shortest paths to (4,1) as well. Node (2,1) also finds new shortest
    paths to (1,1) and (3,1). Here’s what we’ve got now:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (1,0) | true | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (2,0) | true | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| (3,0) | false | 7 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (4,0) | true | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| (1,1) | false | 6 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| (2,1) | true | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| (3,1) | false | 5 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| (4,1) | false | 4 | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'Node (4,1) is the next one out, so we have our answer: the shortest path is
    4 and the number of shortest paths is 2\. (In our code we won’t have a stopping
    criterion here at the destination, so Dijkstra’s algorithm would keep going, finding
    shortest paths and number of shortest paths for other nodes. I encourage you to
    persevere with this example until the end.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s how the algorithm works. It can be summarized by two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**   Suppose that we use Node *u* to find a shorter path to Node *v*.
    Then the number of shortest paths to *v* is the number of shortest paths to *u*.
    (All of the old paths to *v* are invalidated and no longer count, because we now
    know that they are not shortest paths.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2**   Suppose that we use Node *u* to find a path to Node *v* that’s
    the same distance as the current shortest path to *v*. Then the number of paths
    to *v* is the number of shortest paths that we already had for *v*, plus the number
    of shortest paths to *u*. (All of the old paths to *v* still count.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we focus on some node *n* and watch what happens to its minimum
    distance and number of shortest paths as it runs. We don’t know what the shortest
    path to *n* will be: we might have its shortest path now, or Dijkstra’s algorithm
    might find a shorter one later. If we have its shortest path now, then we had
    better accumulate the number of shortest paths to *n*, since we may ultimately
    need that value to compute the number of shortest paths for other nodes. If we
    don’t have its shortest path now, then in retrospect we’ll have pointlessly accumulated
    its number of shortest paths. That’s okay, though, because we’ll just reset the
    number of shortest paths anyway when we find a shorter path.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To solve this task, we can start with [Listing 6-4](ch06.xhtml#ch06ex04) and
    make the changes necessary to find the number of shortest paths. The updated code
    is given in [Listing 6-5](ch06.xhtml#ch06ex05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-5: The shortest path and number of shortest paths to grandma’s*'
  prefs: []
  type: TYPE_NORMAL
- en: I added a `num_paths` array that tracks the number of paths that we’ve found
    for each node ➊ and set all of its elements to `0` ➋. The only nonzero element
    in `num_paths` is for our starting node (1,0), which has one path of distance
    0 (the path that begins at the starting node and follows no edges) ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining new work is to update `num_paths`. As we’ve discussed, there are
    two cases. If we find a shorter path, then the old number of paths no longer counts.
    If we find another way to reach a node using its current path distance, then we
    add to the old number of paths. It’s that second case that can trip us up if we’re
    not careful, because we need to include an equality check in addition to a greater-than
    check ➍. If we used exactly the code that we’ve used throughout the chapter,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: then the number of paths to a node would only be updated when a shorter path
    was found; there would be no way to accumulate shortest paths from multiple sources.
    Instead, we use `>=` rather than `>`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: so that we can find more shortest paths, even if the shortest path itself does
    not change.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can implement exactly the two cases that we’ve discussed for updating
    the number of paths. We have to do these cases twice, because there are two places
    in the code where Dijkstra’s algorithm can find shortest paths. The first addition
    ➎ is to the code that follows a 0-weight edge from State 0\. If the shortest path
    is the same as before, we add; if there’s now a new shorter path, we reset. The
    second addition of essentially the same code ➐ is added to the code for looping
    through the edges leaving the current node. In both cases, we use the mod operator
    ➏ ➑ to keep us under 1,000,000 shortest paths.
  prefs: []
  type: TYPE_NORMAL
- en: The final required change is to update the `printf` call at the end ➒, now also
    printing the number of shortest paths to grandma’s.
  prefs: []
  type: TYPE_NORMAL
- en: You’re ready to submit to the judge. Let’s discuss a little bit about correctness
    before we wrap up for good.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm Correctness
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are no negative-weight edges in our Grandma Planner graphs, so we know
    that Dijkstra’s algorithm will correctly find all shortest path distances. There
    are some 0-weight edges—one from each cookie town in State 0 to the corresponding
    town in State 1—but Dijkstra’s algorithm copes just fine with those when finding
    shortest paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we must carefully think through the implications of 0-weight edges
    on finding the *number* of shortest paths. If we allow arbitrary 0-weight edges,
    then there may be an *infinite* number of shortest paths. Take a look at [Figure
    6-6](ch06.xhtml#ch06fig06), where we have 0-weight edges from A to B, B to C,
    and C to A. The shortest path from A to C, for example, is 0, and we have an infinite
    number of such paths: A *→* B *→* C, A *→* B *→* C *→* A *→* B *→* C, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: A graph with an infinite number of shortest paths*'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, cycles of 0-weight edges cannot actually present themselves in Grandma
    Planner graphs. Remember that all road distances are at least one. Suppose that
    there were a 0-weight edge from Node *u* to Node *v*. This means that *u* is in
    State 0 and *v* is in State 1\. We can never get from *v* back to *u*, because
    our graphs provide no way to move from State 1 back to State 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll end by arguing the following: once a node is set to done, we have found
    its total number of shortest paths. Consider a run of our algorithm where it gives
    the wrong number of shortest paths. Our algorithm hums along, finding shortest
    paths and the number of shortest paths . . . and then, boom, it makes a mistake
    for the first time. It sets some node *n* to done, but it’s missed finding some
    of its shortest paths. We need to argue that this mistake cannot arise.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that some shortest paths to *n* end with some edge *m* *→* *n*. If *m*
    *→* *n* has a weight greater than 0, then the shortest path to *m* is shorter
    than the shortest path to *n*. (It’s the shortest path to *n* minus the weight
    of *m* *→* *n*.) Dijkstra’s algorithm works by finding nodes that are further
    and further from the starting node, so Node *m* must be done by this point. When
    Dijkstra’s algorithm set *m* to done, it would have gone through all edges from
    *m*, including *m* *→* *n*. Since *m*’s number of paths was set correctly (*m*
    is done, and Dijkstra’s algorithm hadn’t made its mistake yet), Dijkstra’s algorithm
    includes all of those paths in *n*’s path count.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if *m* *→* *n* is a 0-weight edge? We need *m* to be done before *n*;
    otherwise, *m*’s number of paths cannot be trusted when exploring the edges that
    leave *m*. We know that 0-weight edges go from a node in State 0 to a node in
    State 1, so *m* must be in State 0 and *n* must be in State 1\. The shortest path
    to *m* must be the same as the shortest path to *n*, since the 0-weight edge adds
    nothing to *m*’s shortest path. At some point, then, at the time when *m* and
    *n* are not done, Dijkstra’s algorithm will have to choose which of the two to
    next set to done. It had better choose *m*; and it will, because, as I’ve written
    the code, when there is a tie it chooses a node from State 0 rather than State
    1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to tread lightly: we’re really getting away with something here. Here’s
    a test case that exemplifies why we have to process State-0 nodes before State-1
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Trace our modified Dijkstra’s algorithm on this example. If you have a choice
    of which node to next set to done, choose one from State 0\. If you do that, you’ll
    get the correct answer: a shortest path distance of four and four shortest paths.
    Then, trace the algorithm again, only this time break ties by choosing a node
    from State 1\. You’ll still get the correct shortest path distance of four, because
    Dijkstra’s algorithm is not sensitive to how ties are broken. But our modified
    Dijkstra’s algorithm is, witnessed by the fact that you should get two shortest
    paths rather than four.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm is designed to find shortest paths in graphs. We’ve seen
    in this chapter how to model a problem instance as a suitable weighted graph and
    then use Dijkstra’s algorithm. Moreover, Dijkstra’s algorithm, like BFS in [Chapter
    5](ch05.xhtml), can serve as a guide for solving related but distinct problems.
    In the Grandma Planner problem, we found the number of shortest paths by a suitable
    modification to Dijkstra’s algorithm. We didn’t have to start from scratch. We’re
    not always literally going to be asked for the shortest path. If Dijkstra’s algorithm
    were resolute, finding shortest paths and nothing else, then it would offer no
    help when contexts shift. Indeed, we’d have learned a powerful algorithm, but
    one of an all-or-nothing flavor. Fortunately, Dijkstra’s algorithm applies more
    broadly. If you continue with graph algorithms beyond what I’ve included in this
    book, you’ll likely see ideas from Dijkstra’s algorithm appear again. While there
    may be millions of problems out there, there are far fewer algorithms. The best
    algorithms are often the ones that rest on ideas so flexible that they can ooze
    beyond their intended purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mice Maze is originally from the 2001 Southwestern Europe Regional Contest.
    Grandma Planner is originally from the 2008 South African Programming Olympiad,
    Final Round.
  prefs: []
  type: TYPE_NORMAL
- en: For more about graph search and its many applications to competitive programming
    problems, I recommend *Competitive Programming 4* by Steven Halim and Felix Halim
    (2020).
  prefs: []
  type: TYPE_NORMAL
