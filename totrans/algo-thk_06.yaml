- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SHORTEST PATHS IN WEIGHTED GRAPHS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: This chapter generalizes what we learned in [Chapter 5](ch05.xhtml) about finding
    shortest paths. In [Chapter 5](ch05.xhtml), our focus was on finding the minimum
    number of moves needed to solve a problem. Now, what if we care not about the
    minimum number of moves but about the minimum amount of time or distance? Think
    about using a GPS app to get home. Maybe there’s a route to get home using only
    one street that takes 10 minutes. Maybe there’s another way that involves using
    three streets that takes only eight minutes in total. We might prefer using the
    three streets, since they save us time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll learn *Dijkstra’s algorithm* for finding shortest paths
    in weighted graphs. We’ll use it to determine the number of mice that can escape
    a maze within a time limit and the number of shortest paths between someone’s
    home and their grandma’s house. I chose that grandma example in particular to
    reprise a discovery we made in [Chapter 5](ch05.xhtml): that, suitably modified,
    algorithms such as BFS and Dijkstra’s can do much more than “find the shortest
    path.” We’re learning algorithms—deservedly famous ones—but also stocking up on
    flexible problem-solving tools. Let’s go!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: Mice Maze'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is UVa problem `1112`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A maze consists of cells and passages. Each passage leads from some cell *a*
    to some other cell *b*, and it takes *t* time units to walk the passage. For example,
    it may take 5 time units to walk from Cell 2 to Cell 4\. Now for the passage going
    the other way: it may take 70 time units to walk from Cell 4 to Cell 2, or there
    may be no passage at all from Cell 4 to Cell 2—the *a* *→* *b* and *b* *→* *a*
    passages are independent. One of the cells of the maze is designated as the exit
    cell.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lab mouse in each cell, including the exit cell. The mice have been
    trained to walk to the exit cell in as little time as possible. Our task is to
    determine the number of mice that can reach the exit cell within a specified time
    limit.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first line of input gives the number of test cases and is followed by a
    blank line. There’s also a blank line between each pair of test cases. Each test
    case consists of the following lines:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of cells in the maze. Cells are numbered 1
    to *n*; *n* is at most 100.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *e*, the exit cell. *e* is between 1 and *n*.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *t*, the integer time limit for the mice to get to the exit
    cell. *t* is at least zero.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *m*, the number of passages in the maze.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, each describing a passage in the maze. Each such line contains three
    integers: the first cell *a* (between 1 and *n*), the second cell *b* (between
    1 and *n*), and the time (at least zero) it takes to walk from *a* to *b*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For each test case, output the number of mice that reach the exit cell *e* within
    the time limit *t*. The output for each test case is separated from the next by
    a blank line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出在时间限制*t*内到达出口单元格*e*的老鼠数量。每个测试用例的输出之间由一个空行分隔。
- en: The time limit for solving the test cases—for our code, not the mice—is three
    seconds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制——是针对我们的代码，而不是老鼠——是三秒钟。
- en: '*Moving On from BFS*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从BFS继续*'
- en: There are key similarities between the Mice Maze problem and the three problems
    in [Chapter 5](ch05.xhtml). We can model the Mice Maze as a graph, where the nodes
    are the maze cells and the edges are the passages. The graph is directed (as in
    the Rope Climb problem), because a passage from Cell *a* to Cell *b* tells us
    nothing about the possible passage from *b* to *a*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 老鼠迷宫问题与第[5章](ch05.xhtml)中的三个问题有一些关键的相似之处。我们可以将老鼠迷宫建模为一个图，其中节点是迷宫单元格，边是通道。这个图是有向的（就像绳索攀爬问题那样），因为从单元格*a*到单元格*b*的通道并不能告诉我们从*b*到*a*的通道是否存在。
- en: The workhorse for the three problems in [Chapter 5](ch05.xhtml) was breadth-first
    search. The killer feature of BFS is that it finds shortest paths. Not coincidentally,
    we want shortest paths for our Mice Maze, too. They’ll let us determine how long
    it takes each mouse to reach the exit cell.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.xhtml)中的三个问题的核心算法是广度优先搜索（BFS）。BFS的杀手特性是它能够找到最短路径。巧合的是，我们在老鼠迷宫中也需要最短路径。它们能帮助我们确定每只老鼠到达出口单元格所需的时间。'
- en: 'However, all this talk of similarities is obscuring a crucial difference: the
    Mice Maze graph is *weighted*: on each edge, we have an arbitrary integer giving
    the time required to traverse that edge. See [Figure 6-1](ch06.xhtml#ch06fig01)
    for an example.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有关于相似性的讨论掩盖了一个关键的区别：老鼠迷宫图是*加权的*：每条边上都有一个任意的整数，表示穿越该边所需的时间。具体例子请参见[图6-1](ch06.xhtml#ch06fig01)。
- en: '![Image](../images/ch06fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/ch06fig01.jpg)'
- en: '*Figure 6-1: The Mice Maze graph*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：老鼠迷宫图*'
- en: 'Let’s say that the exit cell is Cell 4\. What’s the minimum amount of time
    taken by the mouse in Cell 1 to get to Cell 4? There’s an edge directly from Cell
    1 to Cell 4, so if we were counting edges (as in BFS), then the answer would be
    `1`. However, we are not interested in the number of edges here: instead, we want
    the shortest path in terms of the sum of its edge weights. The weight of the 1
    *→* 4 edge is 45\. That is not the shortest path. The shortest path from Cell
    1 to Cell 4 is the three-edge path that goes from Cell 1 to Cell 3 (six units
    of time), then from Cell 3 to Cell 2 (two units of time), and finally from Cell
    2 to Cell 4 (nine units of time). That’s 6 + 2 + 9 = 17 in all. It is because
    of this focus on edge weights, not edge counts, that BFS is out of its element
    here and we’ll need a different algorithm.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设出口单元格是单元格4。单元格1到单元格4所需的最短时间是多少？单元格1到单元格4之间有一条直接的边，所以如果我们在计算边的数量（如BFS中那样），答案将是`1`。然而，我们这里不关心边的数量：我们更关心的是以边的权重总和来衡量的最短路径。1
    *→* 4边的权重是45，这不是最短路径。单元格1到单元格4的最短路径是这样的一条三边路径：从单元格1到单元格3（花费6个时间单位），再从单元格3到单元格2（花费2个时间单位），最后从单元格2到单元格4（花费9个时间单位）。这总共是6
    + 2 + 9 = 17个时间单位。正因为如此，BFS在这种情况下就不适用了，我们需要采用不同的算法。
- en: 'Hold on, though: there were some weighted graphs in [Chapter 5](ch05.xhtml),
    and we used BFS on those. What gives? Look back at [Figure 5-6](ch05.xhtml#ch05fig06),
    a Rope Climb graph where some of the edges had weight 1 and others had weight
    0\. We managed to use a variant of BFS there, but only because the edge weights
    were so constrained. Now look back at [Figure 5-7](ch05.xhtml#ch05fig07), a Book
    Translation graph. That’s a full-blown weighted graph with arbitrary edge weights.
    We managed to use BFS there, too, but that’s because the primary distance measure
    was the number of edges. Once a node’s edge distance was determined by BFS, only
    then did the edge weights come into play, helping us add the node as cheaply as
    possible.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但稍等：第[5章](ch05.xhtml)中也有一些加权图，我们在其中使用了BFS。怎么回事？回顾[图5-6](ch05.xhtml#ch05fig06)，这是一个绳索攀爬图，其中有些边的权重是1，有些边的权重是0。我们能够在这里使用BFS，原因仅仅是边的权重受到严格限制。现在回头看看[图5-7](ch05.xhtml#ch05fig07)，这是一个书籍翻译图。这是一个完全加权的图，边的权重是任意的。我们在这里也能使用BFS，但那是因为主要的距离度量是边的数量。一旦BFS确定了一个节点的边的距离，只有在此之后，边的权重才会发挥作用，帮助我们以尽可能低的成本添加节点。
- en: However, in no way does the Mice Maze have anything to do with the number of
    edges. A path from *a* to *b* might have 100 edges and a total time of 5 units.
    A different path from *a* to *b* might have only 1 edge with a time of 80 units.
    BFS would discover that second path, when what we want is the first.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '*Finding Shortest Paths in Weighted Graphs*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'BFS operates by progressively identifying nodes that are further and further
    away, in terms of edge count, from the starting node. The algorithm that I’ll
    present in this section operates similarly: it identifies the shortest path for
    nodes further and further away, in terms of total edge weight, from the starting
    node.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: BFS organizes its work in rounds, where the nodes discovered in the next round
    are one edge more distant than the nodes in the current round. We aren’t going
    to be able to use that rounds idea to find shortest paths in weighted graphs,
    because the shortest paths that we discover most recently are not necessarily
    those that will help us find the shortest path for a new node. We’ll have to work
    a little harder to find the next shortest path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, let’s find the shortest paths from Node 1 to each node in the
    graph using [Figure 6-1](ch06.xhtml#ch06fig01). That will tell us how long it
    takes the mouse in cell 1 to get to the exit cell.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'For each node, we’ll maintain two pieces of information:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '***done***   This is a true/false variable. If it’s false, it means that we
    haven’t found the shortest path for this node yet; if it’s true, then we have.
    Once a node’s *done* value is true, we’re done with it: its shortest path will
    never change again.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '***min_time***   This is the shortest path distance from the starting node
    to this node, in terms of total time, using a path whose other nodes are all done.
    As more and more nodes become done, *min_time* can decrease, because we have more
    options for paths to this node.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The shortest path from Node 1 to Node 1 is 0: there’s nowhere to go and no
    edge to take. Let’s start there, with a *min_time* for Node 1 of 0 and no *min_time*
    information for the other nodes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| 1 | false | 0 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| 2 | false |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| 3 | false |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| 4 | false |  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| 5 | false |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: 'We next set Node 1 to done, and then we set the *min_time* for each other node
    based on the edge weights from Node 1\. Here’s our next snapshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| 1 | true | 0 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| 2 | false | 12 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| 3 | false | 6 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| 4 | false | 45 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| 5 | false | 7 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: 'Now, here’s a claim that’s at the heart of what we’re doing here: the shortest
    path from Node 1 to Node 3 is 6, and there’s no way we can ever do better than
    6\. I chose Node 3 in my claim because it has the smallest *min_time* value of
    any node that is not done.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Claiming that the answer is 6 right now might seem brazen. What if there were
    some other path to Node 3 that was shorter, maybe another path that goes through
    some other nodes before eventually making its way to Node 3?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声称答案是 6 似乎有些大胆。如果存在另一条更短的路径到达节点 3，或者是通过一些其他节点最终到达节点 3 的路径呢？
- en: 'Here’s why that can’t happen, and why our claim of 6 is safe. Imagine that
    there were some shorter path *p* from Node 1 to Node 3\. That path must start
    at Node 1 and leave Node 1 on some edge *e*. Then it must take zero or more other
    edges and arrive at Node 3\. Check it out: *e* already takes at least 6 time units,
    because 6 is the minimum time it takes to go from Node 1 to some other node. Any
    other edges that are on *p* only add to this, so there’s no way that *p* could
    have a total time of less than 6 units!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么那种情况不可能发生，以及为什么我们可以确定 6 是正确答案的原因。假设从节点 1 到节点 3 存在一条更短的路径 *p*。这条路径必须从节点
    1 开始，并通过某个边 *e* 离开节点 1。然后它必须经过零个或多个其他边，并到达节点 3。仔细想想：*e* 已经至少需要 6 时间单位，因为 6 是从节点
    1 到其他节点所需的最短时间。路径 *p* 上的任何其他边只会增加这个时间，因此不可能存在总时间少于 6 单位的路径 *p*！
- en: 'So, Node 3 is done: we know its shortest path. Now we will have to use Node
    3 to check whether we can improve any of the shortest paths for nodes that are
    not yet done. Remember that the *min_time* values give the shortest path using
    done nodes. It takes 6 time units to get to Node 3, and there’s an edge from Node
    3 to Node 2 that takes 2 time units, so we now have a way to get from Node 1 to
    Node 2 in only 8 time units. We therefore update the *min_time* value for Node
    2 from 12 to 8\. Here’s where that leaves us:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，节点 3 已完成：我们知道它的最短路径。现在我们需要使用节点 3 来检查是否能够改善任何尚未完成的节点的最短路径。请记住，*最短时间* 值是通过已完成节点计算的最短路径。到达节点
    3 需要 6 时间单位，并且从节点 3 到节点 2 有一条边，花费 2 时间单位，因此我们现在有了一条从节点 1 到节点 2 仅需 8 时间单位的路径。因此，我们将节点
    2 的 *最短时间* 值从 12 更新为 8。以下是当前的状态：
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | false | 8 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | false | 45 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 45 |'
- en: '| 5 | false | 7 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 5 | false | 7 |'
- en: 'Nodes 2, 4, and 5 are not yet done. Which one can we doneify now? The answer
    is Node 5: it’s got the minimum *min_time*. Can we use Node 5 to update any of
    our other shortest paths? Node 5 does have an outgoing edge to Node 2, but getting
    from Node 1 to Node 5 (7 time units) and then taking the edge from Node 5 to Node
    2 (21 time units) takes more time (7 + 21 = 28) than our old path from Node 1
    to Node 2 (8 time units). So we leave Node 2’s *min_time* alone. The only change
    in the next snapshot, then, is to set Node 5 to done.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 2、4 和 5 尚未完成。现在我们能将哪个节点标记为完成呢？答案是节点 5：它的 *最短时间* 最小。我们能否利用节点 5 更新其他最短路径？节点
    5 确实有一条指向节点 2 的边，但从节点 1 到节点 5 需要 7 时间单位，然后再从节点 5 到节点 2 需要 21 时间单位，总共需要的时间（7 +
    21 = 28）比我们原来的从节点 1 到节点 2 的路径（8 时间单位）要长。所以我们不会改变节点 2 的 *最短时间*。因此，下一次更新的唯一变化是将节点
    5 标记为完成。
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | false | 8 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | false | 45 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 45 |'
- en: '| 5 | true | 7 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 5 | true | 7 |'
- en: 'There are two nodes to go. Node 2 has a *min_time* of 8, and Node 4 has a *min_time*
    of 45\. As always, we choose the smaller, finalizing the shortest path distance
    from Node 1 to Node 2 as 8\. Again, there can be no shorter path to Node 2 than
    8\. Any shorter path *p* from Node 1 to Node 2 must begin with some done nodes
    and will at some point cross for the first time on an edge from a done node to
    one that is not done. Call that edge *x* *→* *y*, where *x* is done and *y* is
    not. So that’s how *p* gets from Node 1 to Node *y*. It can then do whatever it
    wants to get from Node *y* to Node 2 . . . but it’s all frivolous. Getting from
    Node 1 to Node *y* already takes at least 8 time units: if it were less, then
    *y*’s *min_time* value would be less than 8 and we’d have chosen to set *y* to
    done rather than Node 2\. Whatever *p* does to get from Node *y* to Node 2 can
    only add even more time. So *p* can’t be shorter than 8.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding Node 2 gives us two edges to check for shorter paths. There’s an edge
    from Node 2 to Node 1, but that won’t help us because Node 1 is already done.
    There’s an edge of 9 time units from Node 2 to Node 4\. That one does help us!
    Getting from Node 1 to Node 2 takes 8 time units, and then the 2 *→* 4 edge takes
    9 time units, for a total of 17 time units. That’s better than our old path from
    Node 1 to Node 4 that took 45 time units. Here’s the next snapshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| 1 | true | 0 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| 2 | true | 8 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| 3 | true | 6 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| 4 | false | 17 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| 5 | true | 7 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: 'There’s only one node, Node 4, that’s not done. As all other nodes are done,
    we’ve found all of their shortest paths. Node 4, therefore, can’t help us find
    any new, shorter paths. We can set Node 4 to done and conclude:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| 1 | true | 0 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| 2 | true | 8 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| 3 | true | 6 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| 4 | true | 17 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| 5 | true | 7 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: It takes 17 time units for the mouse in Cell 1 to get to the exit cell 4\. We
    could repeat the process for each other node to find out how long each other mouse
    takes to get to the exit cell, then count the mice that get there in time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is known as Dijkstra’s algorithm, after Edsger W. Dijkstra, a
    pioneering and influential computer scientist. Given a starting node *s* and a
    weighted graph, it calculates the shortest path from *s* to each node in the graph.
    It’s exactly what we need to solve the Mice Maze problem. Let’s read the input
    to build the graph and then see how Dijkstra’s algorithm can be implemented.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '*Building the Graph*'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With all of your experience building trees and graphs to this point, there won’t
    be many surprises here. We’ll build the graph like we built it for the Book Translation
    problem in the previous chapter (see “Building the Graph” on [page 189](ch05.xhtml#sec79)).
    The only difference is that the graphs there were undirected and our graphs here
    are directed. In more good news, we’re given the node numbers directly and don’t
    have to map between language names and integers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你到目前为止构建树和图的经验，这里不会有太多惊讶。我们将像在上一章的书籍翻译问题中一样构建图（见[第189页](ch05.xhtml#sec79)中的“构建图”）。唯一的不同是，之前的图是无向图，而我们这里的图是有向图。好消息是，我们直接给出了节点编号，而不需要在语言名称和整数之间进行映射。
- en: 'Just so we have something on which to test, here’s an input corresponding to
    [Figure 6-1](ch06.xhtml#ch06fig01):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便测试，这里提供了一个输入，对应于[图 6-1](ch06.xhtml#ch06fig01)：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That `12` ➊ gives the time limit for the mice to get to the exit. (You can verify
    that three mice can get to the exit within this time limit; those mice are the
    ones in Cells 2, 3, and 4.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该`12` ➊ 给出了老鼠到达出口的时间限制。（你可以验证，三只老鼠可以在这个时间限制内到达出口；这三只老鼠分别位于单元2、3和4。）
- en: As in Book Translation, we’ll use an adjacency list representation of the graph.
    Each edge maintains the cell to which it points, the length of time required to
    walk the edge, and a next pointer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 和书籍翻译问题一样，我们将使用图的邻接表表示法。每条边包含指向的单元、行走该边所需的时间以及下一个指针。
- en: 'Here’s the needed constant and `typedef`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所需的常量和`typedef`：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The graphs are read by the `main` function in [Listing 6-1](ch06.xhtml#ch06ex01).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图表由`main`函数读取，见[列表 6-1](ch06.xhtml#ch06ex01)。
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-1: The* main *function for building the graph*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1：用于构建图的* main *函数*'
- en: 'The input specification says that a blank line follows the number of test cases
    and that a blank line sits between each pair of test cases. However, using `scanf`,
    we don’t have to worry about that: when reading a number, `scanf` skips leading
    whitespace (including newlines) that it encounters.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输入规范说在测试用例数量后会有一个空行，每对测试用例之间也有一个空行。然而，使用`scanf`时我们无需担心这一点：当读取数字时，`scanf`会跳过它遇到的所有前导空白（包括换行符）。
- en: 'The first thing we do for each test case is to clear the adjacency list by
    setting each cell’s edge list to `NULL` ➊. Not doing that results in a horrible
    bug where each test case includes edges from prior test cases. (I would know:
    I made that mistake, and three hours later it was three hours later.) It’s our
    responsibility to clear things for each test case!'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个测试用例做的第一件事是通过将每个单元的边表设置为`NULL` ➊来清空邻接表。如果不这么做，会导致一个可怕的bug，其中每个测试用例都会包含前一个测试用例的边。（我知道，因为我犯过这个错误，结果三小时后才发现。）我们有责任为每个测试用例清空数据！
- en: Upon initializing each edge, we add it to the linked list for `from_cell` ➋.
    We don’t add anything to the linked list for `to_cell`, because the graph is directed
    (not undirected).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化每个边时，我们将其添加到`from_cell`的链表中 ➋。我们不会向`to_cell`的链表添加任何内容，因为图是有向图（不是无向图）。
- en: The problem requires that we find the shortest path from each cell to the exit
    cell. For each cell, then, we call `find_time` ➌, a helper function that implements
    Dijkstra’s algorithm. We’ll write that function next. Given a starting cell `i`
    and target cell `exit_cell`, it returns `-1` if there’s no path at all or else
    returns the shortest path time. Each cell that takes `time_limit` units of time
    or less to get to the exit cell results in `total` being incremented by one ➍.
    Once each cell’s shortest path has been considered, `total` is output.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题要求我们找到每个单元到出口单元的最短路径。因此，对于每个单元，我们调用`find_time` ➌，它是一个实现了Dijkstra算法的辅助函数。我们接下来会编写这个函数。给定起始单元`i`和目标单元`exit_cell`，如果没有路径，它返回`-1`，否则返回最短路径时间。每个到达出口单元需要`time_limit`单位时间或更少的单元，都会使得`total`增加1
    ➍。一旦考虑完每个单元的最短路径，`total`就会被输出。
- en: '*Implementing Dijkstra’s Algorithm*'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*实现Dijkstra算法*'
- en: 'Now it’s time to implement Dijkstra’s algorithm, following the outline provided
    in “Finding Shortest Paths in Weighted Graphs” on [page 200](ch06.xhtml#sec84).
    Here’s the signature for the function that we’ll implement:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实现Dijkstra算法的时候了，按照“加权图中寻找最短路径”部分提供的概要来实现，见[第200页](ch06.xhtml#sec84)。这是我们将要实现的函数签名：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The four parameters correspond to the adjacency list, number of cells, starting
    cell, and exit cell, respectively. Dijkstra’s algorithm will calculate the shortest
    path time from the starting cell to all other cells, including the exit cell.
    Once we’re done, we can return the shortest path time to the exit cell. That may
    seem extravagant, calculating the shortest path to all cells only to throw everything
    away except the shortest path to the exit cell. There are various optimizations
    that we can perform, and we’ll turn to those in the next subsection. For now,
    let’s settle in with a working, unadorned implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of Dijkstra’s algorithm is implemented by two nested `for` loops.
    The outer `for` loop runs once per cell; each iteration sets one cell to done
    and updates shortest paths using that new cell. The inner `for` loop is a minimum
    computation: it finds the cell whose `min_time` value, among all cells that are
    not done, is minimum. See [Listing 6-2](ch06.xhtml#ch06ex02) for the code.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 6-2: The shortest path to the exit cell using Dijkstra’s algorithm*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the `done` array is to indicate whether each cell is done: a
    `0` means “not done” and a `1` means “done.” The purpose of the `min_times` array
    is to store the shortest path distance from the starting cell to each cell.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a `for` loop ➊ to initialize these two arrays: it sets all `done` values
    to `0` (false) and `min_times` values to `-1` (not found). We then set `min_times`
    for `from_cell` to `0` ➋ to indicate that the shortest path distance from the
    starting cell to itself is zero.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The `found` variable tracks whether a new cell can be discovered by Dijkstra’s
    algorithm. On each iteration of the outer `for` loop, it starts off as `0` (false)
    ➌ and gets set to `1` (true) if a cell can be found—but how could a cell not be
    found? For example, earlier in this chapter, we found all of the cells. However,
    there may be graphs where there is *no* path between a starting cell and some
    other cell. On those graphs, there will be cells that Dijkstra’s algorithm does
    not find; when no new cell can be found, it’s time to stop.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we arrive at the inner `for` loop ➍, whose task is to identify the cell
    whose shortest path will be found next. This loop will leave `min_time_index`
    with the index of the cell whose shortest path has been found and `min_time` with
    the shortest path time itself. The eligible cells are those that are both not
    done and have a `min_times` value that’s at least `0` (that is, not `-1`) ➎. We
    need the cell to be not done, because done cells already have their shortest paths
    finalized. We also need the `min_times` value to be at least `0`: if it’s `-1`,
    then the cell hasn’t been found yet, so we have no idea what its shortest path
    is. If we had no eligible cell yet or the current cell has a shorter path than
    our shortest thus far ➏, we update `min_time` and `min_time_index` and set `found`
    to `1` to flag that we successfully found a cell.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: If no cell was found, then we stop ➐. Otherwise, we set the identified cell
    to done and loop through its outgoing edges to find shorter paths. For each edge
    `e`, we check whether the cell provides a shorter path to `e->to_cell` ➑. That
    possible shorter path is `min_time` (the time taken to get from `from_cell` to
    `min_time_index`) plus the time taken to walk edge `e` (from `min_time_index`
    to `e->to_cell`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: When looking at edge `e`, shouldn’t we first be verifying that `e->to_cell`
    is not done before checking whether we’ve found a shorter path ➑? Although we
    could add that check, it would have no effect. Done cells already have their finalized
    shortest paths; there’s no way that some shorter path can be found.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Having computed shortest paths to all cells, we’ve certainly computed the shortest
    path to the exit cell. The final thing to do is return that time ➒.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: That’s a wrap! Go ahead and submit to the judge. The code should pass all of
    the test cases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '*Two Optimizations*'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a few things that can be done to speed up Dijkstra’s algorithm. The
    most widely applicable and dramatic speedup is wrought by a data structure called
    a *heap*. In our current implementation, it’s very expensive to find the next
    node to set to done, as we need to scan through all nodes that are not done to
    find the one with the shortest path. A heap uses a tree to convert this slow,
    linear search into a fast search. As heaps are useful in many contexts beyond
    Dijkstra’s algorithm, I’ll discuss them later, in [Chapter 8](ch08.xhtml). Here,
    I’ll offer a couple of optimizations more specific to the Mice Maze problem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Recall that as soon as a cell is done, we never change its shortest path again.
    As such, once we set the exit cell to done, we have its shortest path. After that,
    there’s no reason to find shortest paths for other cells. We may as well terminate
    Dijkstra’s algorithm early.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We can still do better, though. For a maze of *n* cells, we invoke Dijkstra’s
    algorithm *n* times, once for each cell. For Cell 1, we compute all shortest paths—and
    then keep only the shortest path to the exit cell. We do the same for Cell 2,
    Cell 3, and so on, throwing out all of the shortest paths we found except for
    those that involve the exit cell.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, consider running Dijkstra’s algorithm just once, with the exit cell
    as the starting cell. Dijkstra’s algorithm would then find the shortest path from
    the exit cell to Cell 1, the exit cell to Cell 2, and so on. However, that’s not
    quite what we want, because the graph is directed: the shortest path from the
    exit cell to Cell 1 is *not* necessarily the shortest path from Cell 1 to the
    exit cell.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Here again is [Figure 6-1](ch06.xhtml#ch06fig01):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch06fig01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: As we discovered earlier, the shortest path from Cell 1 to Cell 4 is 17, but
    the shortest path from Cell 4 to Cell 1 is 36.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The shortest path from Cell 1 to Cell 4 uses the edges 1 *→* 3, 3 *→* 2, and
    2 *→* 4\. If we intend on starting Dijkstra’s algorithm from Cell 4, then we need
    it to find edges 4 *→* 2, 2 *→* 3, and 3 *→* 1\. Each of these edges is the *reverse*
    of an edge in the original graph. [Figure 6-2](ch06.xhtml#ch06fig02) shows the
    *reversed graph*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: A reversed version of the graph in [Figure 6-1](ch06.xhtml#ch06fig01)*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Now we can run Dijkstra’s algorithm—just one invocation of it!—from Cell 4 to
    recover shortest paths to all nodes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of implementation, we would need to produce the reversed graph instead
    of the original graph. This can be done in the `main` function ([Listing 6-1](ch06.xhtml#ch06ex01)),
    when reading the graph. Instead of:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'we want this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That is, the edge now points to `from_cell`, and it gets added to the linked
    list for `to_cell`. If you make this change and adapt the code so that it invokes
    Dijkstra’s algorithm just once (from the exit cell), you’ll end up with a much
    faster program. Give it a try!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra’s Algorithm
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm takes over where BFS leaves off. BFS finds shortest paths
    in terms of numbers of edges in an unweighted graph; Dijkstra’s algorithm finds
    shortest paths in terms of edge weights in a weighted graph.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Like BFS, Dijkstra’s algorithm takes a starting node, and it finds shortest
    paths from there to each node in the graph. Like BFS, it then solves the *single-source
    shortest-paths* problem, except on weighted graphs rather than unweighted graphs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, Dijkstra’s algorithm *can* find shortest paths in unweighted graphs,
    too. Just take the unweighted graph and give each edge a weight of one. Now, when
    Dijkstra’s algorithm finds the shortest paths, it will have minimized the number
    of edges in the path, precisely what BFS does.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Why not hammer every shortest-path problem, unweighted or weighted, with Dijkstra’s
    algorithm, then? Indeed, there are problems where it’s difficult to decide between
    BFS and Dijkstra’s algorithm. For example, I suspect that many people would have
    chosen Dijkstra’s algorithm over (modified) BFS to solve the Rope Climb problem
    in [Chapter 5](ch05.xhtml). When the task is clearly to minimize the number of
    moves, BFS should still get the call: it’s generally easier to implement than
    Dijkstra’s algorithm and runs a little faster, too. By no means, however, is Dijkstra’s
    algorithm slow.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '*Runtime of Dijkstra’s Algorithm*'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s characterize the runtime of Dijkstra’s algorithm as seen in [Listing 6-2](ch06.xhtml#ch06ex02).
    We’ll use *n* to refer to the number of nodes in the graph.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The initialization loop ➊ iterates *n* times, doing a constant number of steps
    per iteration, so it does total work proportional to *n*. The next bit of initialization
    ➋ is a single step. Whether we say that the initialization takes *n* steps or
    *n* + 1 steps changes nothing, so we’ll ignore this 1 and say that it takes *n*
    steps.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The real work done by Dijkstra’s algorithm starts now. Its outer `for` loop
    iterates up to *n* times. For each such iteration, the inner `for` loop does *n*
    iterations to find the next node. The inner `for` loop, then, iterates a total
    of *n*² times. Each such iteration does a constant amount of work, so the inner
    `for` loop does total work proportional to *n*².
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The other work that Dijkstra’s algorithm does is to iterate through the edges
    of each node. There are a total of *n* nodes, so certainly each node has no more
    than *n* edges leaving it. We therefore take *n* steps to iterate through the
    edges of one node, and we have to do this for each of the *n* nodes. That’s another
    *n*² steps.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing, we’ve got *n* work in the initialization, *n*² work in the inner
    `for` loop, and *n*² work checking the edges. The biggest exponent there is 2,
    so this is an *O*(*n*²), or quadratic, algorithm.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml), we sneezed at a quadratic-time algorithm for Unique
    Snow-flakes, tossing it away in favor of a linear-time algorithm. In that sense,
    the implementation of Dijkstra’s algorithm that we have developed is not too impressive.
    In another sense, though, it is, because in *n*² time it’s solving not one but
    *n* problems, one for each shortest path from the starting node.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: I’ve chosen to present Dijkstra’s algorithm in this book, but there are many
    other shortest-paths algorithms. Some find the shortest path between all pairs
    of nodes in the graph in one fell swoop. Doing so solves the *all-pairs shortest-paths*
    problem. One such algorithm is called the *Floyd–Warshall algorithm*, and it runs
    in *O*(*n*³) time. Interestingly, we can find all-pairs shortest paths with Dijkstra’s
    algorithm, too, and just as quickly. We can run Dijkstra’s algorithm *n* times,
    once from each starting node. That’s *n* invocations of an *n*² algorithm, for
    a total of *O*(*n*³) work.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Weighted or unweighted, single-source or all-pairs, Dijkstra’s algorithm can
    do it. Is it simply unstoppable? Negative!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '*Negative-Weight Edges*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve made an implicit assumption to this point in the chapter: edge weights
    are nonnegative. In the Mice Maze, for example, edge weights represent times to
    walk edges; walking an edge surely can’t cause time to go backward, so no edge
    weight was negative. Similarly, in many other graphs, edges with negative weights
    don’t arise simply because they don’t make sense. For example, consider a graph
    where the nodes are cities and edges are flight costs between cities. No airline
    is going to pay us for taking their flights, so each edge will be a nonnegative
    dollar cost.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Now consider a game in which some moves give us points, and other moves take
    points away. Those latter moves correspond to *negative-weight edges*. Thus negative-weight
    edges do appear from time to time. How does Dijkstra’s algorithm respond? Let’s
    find out using the sample graph in [Figure 6-3](ch06.xhtml#ch06fig03).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: A graph with a negative-weight edge*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to find shortest paths from Node A. As always, Dijkstra’s algorithm
    begins by assigning a shortest path of 0 to Node A and setting Node A to done.
    The distance to B from A is 3, the distance to C from A is 5, but the distance
    to D from A is not defined (and has been left blank):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| A | true | 0 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| B | false | 3 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| C | false | 5 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| D | false |  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: 'Dijkstra’s algorithm then decides to finalize the shortest path to Node B at
    3, and it sets B to done. It also updates the shortest path to D:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| A | true | 0 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| B | true | 3 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| C | false | 5 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| D | false | 4 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: 'By virtue of B being done, we’re claiming that 3 is the shortest path from
    A to B, but that spells trouble, because 3 is *not* the shortest path that we
    can find from A to B. The shortest path is *A* *→* *C* *→* *B*, with a total weight
    of –495\. For kicks, let’s continue under these fishy circumstances and see what
    Dijkstra’s algorithm would do anyway. The next node that’s done is D:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| A | true | 0 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| B | true | 3 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| C | false | 5 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| D | true | 4 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: 'That shortest path to D is wrong, too! It should be –494\. As all nodes are
    done except for C, there’s nothing that C can do:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| A | true | 0 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| B | true | 3 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| C | true | 5 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| D | true | 4 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: Even if we let Dijkstra’s algorithm change the shortest path to B here, from
    3 to –495, then the shortest path to D will still be wrong. We’d have to somehow
    process B again, even though B is done. We’d need some way of saying, “Hey, I
    know that I said B was done, but I’m changing my mind.” In any event, the classical
    Dijkstra’s algorithm as I’ve presented it gets this example wrong.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In general, Dijkstra’s algorithm does not work when graph edges can be negative.
    For that, you may wish to explore the *Bellman–Ford algorithm* or the aforementioned
    Floyd–Warshall algorithm.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed here with another problem where we don’t have to worry about negative-weight
    edges. We’ll use Dijkstra’s algorithm again, or, rather, we’ll adapt Dijkstra’s
    algorithm to solve a new kind of problem about shortest paths.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Grandma Planner'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we’ll be asked for not only the shortest path distance but also further
    information about the shortest paths. This problem is just such an example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `saco08p3`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bruce is planning a trip to his grandma’s house. There are *n* towns, numbered
    1 to *n*. Bruce starts in Town 1, and his grandma lives in Town *n*. Between each
    pair of towns is a road, and we’re given the length (distance) of each road.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Bruce wishes to arrive at his grandma’s with a box of cookies, so he must buy
    it along the way. Some of the towns have cookie stores; Bruce is required to hit
    at least one of these cookie towns on his way to his grandma’s.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Our task is twofold. First, we must determine the minimum distance needed for
    Bruce to get from his starting point to his grandma’s house, picking up a box
    of cookies along the way. That minimum distance does not tell us how many options
    Bruce has for getting to his grandma’s. Maybe there’s only one way that he can
    do it, with all other routes requiring greater distance, or maybe there are several
    routes all with the same minimum distance. So, second, we’re asked to determine
    the number of these minimum-distance routes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of towns. Towns are numbered 1 to *n*. There
    are between 2 and 700 towns.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each containing *n* integers. The first of these lines gives the
    road distance from Town 1 to each town (Town 1, then Town 2, and so on); the second
    of these lines gives the road distance from Town 2 to each town; and so on. The
    distance from a town to itself is zero; each other distance is at least one. The
    distance from Town *a* to Town *b* is the same as the distance from Town *b* to
    Town *a*.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *m*, the number of towns that have a cookie store. *m* is
    at least one.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *m* integers, each giving the number of a town with a cookie
    store.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Output the following on a single line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The minimum distance to get from Town 1 to Town *n* (picking up a box of cookies
    along the way)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A space
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of minimum-distance routes, mod 1,000,000
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time limit for solving the test case is one second.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '*Adjacency Matrix*'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The way that the graph is represented here differs from that of the Mice Maze
    and that of the Book Translation problem in [Chapter 5](ch05.xhtml). In those
    two problems, each edge was supplied as one node, the other node, and the edge
    weight. For example, consider the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This means that there’s an edge from Node 1 to Node 2 with weight 12.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In the Grandma Planner problem, the graph is presented as an *adjacency matrix*,
    which is a two-dimensional array of numbers where a given row, column coordinate
    gives us the weight of the edge at that row and column.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample test case:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `4` at the top tells us that there are four towns. The next four lines
    are the adjacency matrix. Let’s focus on the first of those lines:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This single line gives all of the edges leaving Town 1\. There’s an edge from
    Town 1 to Town 1 of weight `0`, from Town 1 to Town 2 of weight `3`, from Town
    1 to Town 3 of weight `8`, and from Town 1 to Town 4 of weight `2`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The next line,
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: does similarly for Town 2, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there’s an edge between any pair of towns; that is, there are no
    missing edges. Such a graph is called a *complete graph*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: This adjacency matrix has some redundancy. For example, it says in row 1, column
    3 that there’s an edge from Town 1 to Town 3 of weight `8`. However, since the
    problem specifies that the road from Town *a* to Town *b* is the same distance
    as that of the road from Town *b* to Town *a*, we see this `8` again in row 3,
    column 1\. (We’re therefore dealing with undirected graphs.) We also have `0`’s
    along the diagonal, which explicitly state that the distance from some town to
    itself is zero. We’ll just ignore those.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '*Building the Graph*'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This problem is ultimately going to demand our creativity not once, but twice.
    First, we’ll need to force our paths through a town with a cookie store. Among
    those paths, we want the shortest one. Second, we’ll need to keep track not only
    of the shortest path but also of the number of ways we can realize that shortest
    path. Double the fun, I say!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by reading the test case from the input and building the graph.
    We’re well positioned to do that at this point. With our graph in hand, we’ll
    then be ready for what lies ahead.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The plan is to read the adjacency matrix, building our adjacency lists as we
    go. We’ll have to keep track of the town indices ourselves, since the adjacency
    matrix doesn’t explicitly provide them.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to read in and use the adjacency matrix directly, avoiding the
    adjacency list representation altogether. Each row *i* gives the distance to each
    town, so we could just loop through row *i* in Dijkstra’s algorithm instead of
    looping through *i*’s adjacency list. Since the graph is complete, we wouldn’t
    even have to waste time skipping over edges that don’t exist. We’ll use adjacency
    lists here, however, for continuity with what we’ve already done.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a constant and `edge` struct that we’ll use:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code for reading the graph is given in [Listing 6-3](ch06.xhtml#ch06ex03).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 6-3: The* main *function for building the graph*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: After reading the number of towns, we use a double `for` loop to read the adjacency
    matrix. Each iteration of the outer `for` loop ➊ is responsible for reading one
    row, specifically, the row for `from_town`. To read that row, we have an inner
    `for` loop, which reads one `length` value for each `to_town`. So now we know
    where the edge starts, where the edge ends, and the length of the edge. We then
    want to add the edge, but only if it’s not one of those 0-weight edges that go
    from a town back to itself. If the edge is between distinct towns ➋, then we add
    it to the adjacency list for `from_town`. Because the graph is undirected, we
    must also ensure that eventually this edge is added to the adjacency list for
    `to_town`. We had to do that explicitly in [Listing 5-16](ch05.xhtml#ch05ex016)
    when solving the Book Translation problem. We don’t have to do that here, though,
    because it’ll get added later without us doing anything special when we process
    the row for `to_town`. For example, if `from_town` is `1` and `to_town` is `2`,
    then the 1 *→* 2 edge will be added now. Later, when `from_town` is `2` and `to_town`
    is `1`, then the 2 *→* 1 edge will be added.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: All that’s left is to read the information about which towns have cookie stores,
    starting with the number of such towns ➌. To keep track of these towns, we use
    array `store`, where `store[i]` is `1` (true) if Town `i` has a cookie store and
    `0` (false) if it does not.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '*Working Through a Weird Test Case*'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s get a feel for the problem by working through the test case from “Adjacency
    Matrix” on [page 214](ch06.xhtml#sec91). The corresponding graph is provided in
    [Figure 6-4](ch06.xhtml#ch06fig04), where **c** represents a cookie town.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig04.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: The grandma graph*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Bruce starts in Town 1 and has to get to Town 4\. Town 2 is the only town with
    a cookie store. What’s the shortest-distance path? While it’s true that Bruce
    can zip from Town 1 directly to Town 4 along the edge of distance 2, that isn’t
    a feasible solution to the problem. Remember that we need to ensure that a town
    with a cookie store is included in any proposed shortest path. For this particular
    graph, this means that we must include Town 2\. (In other test cases, there could
    be multiple towns that have cookie stores; what we’d need to do is include one
    or more of them.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a path from Town 1 to Town 4 that *is* feasible: 1 *→* 2 (distance 3)
    *→* 4 (distance 1). That’s a total distance of 4, and it is indeed a shortest
    path from Town 1 to Town 4 that passes through Town 2.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s not the only optimal path, though. There’s one more, and here it is:
    1 *→* 4 (distance 2) *→* 2 (distance 1) *→* 4 (distance 1). What’s a little weird
    about this path is that we visit Town 4, grandma’s house, *twice*. We start by
    going from Town 1 to Town 4, but we cannot end the path there because we don’t
    have the box of cookies yet. Then we go from Town 4 to Town 2, where we pick up
    the box of cookies. Finally, we go from Town 2 to Town 4, which is our second
    visit to Town 4, but this time we arrive with the box of cookies, and so we have
    a feasible path.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'It does seem that this path is cyclic, since we get to Town 4 once and then
    get to Town 4 again. Viewed in a different light, however, there is no cycle at
    all. When we visited Town 4 the first time, we had no box of cookies; when we
    visited Town 4 again, we had a box of cookies. These two visits are therefore
    not repeats: it’s true that Town 4 was visited twice, but it is also true that
    the state (not carrying a box of cookies versus carrying a box of cookies) differs
    each time.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Now we see that the same town can’t possibly be visited more than twice. If
    a town is visited three times, for example, then two of those visits must be in
    the same state. Perhaps Visit 1 and Visit 2 were both in the “not carrying a box
    of cookies” state. Then that really is a cycle, and it costs us some distance
    to traverse the cycle, so removing it gives a shorter path.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: It’s not sufficient, then, to know which town we’re in. We also need to know
    whether or not a box of cookies has been picked up.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We’ve wrestled with this kind of problem once before, when solving Rope Climb
    in [Chapter 5](ch05.xhtml). There, we discussed adding a second rope to produce
    a more suitable model of the problem. We’re going to reprise that idea here, by
    adding a state that tells us whether or not a box of cookies is being carried.
    In State 0, no box of cookies is being carried; in State 1, a box of cookies is
    being carried. A feasible path, then, is any path that arrives at grandma’s house
    in State 1\. Arriving at grandma’s house in State 0 cannot be the end of a feasible
    path.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 6-5](ch06.xhtml#ch06fig05), which introduces a cookie
    state to [Figure 6-4](ch06.xhtml#ch06fig04). Again, **c** represents a cookie
    town. The edges with no arrows are undirected, but now we have some directed edges,
    too.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig05.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: A grandma graph with a cookie state*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we do to create this graph:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Add four new town nodes, one for each original town in the graph. The original
    nodes are in State 0; the new nodes are in Sate 1.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep all of the original edges, except for those leaving Town 2 (the town with
    the cookie store). If we reach Town 2 in State 0, then we’ve transitioned to State
    1, so the only edge leaving (2,0) is the directed edge to (2,1). It’s a 0-weight
    edge, because changing state takes no time. While Dijkstra’s algorithm can’t be
    trusted on graphs with negative-weight edges (see “Negative-Weight Edges” on [page
    211](ch06.xhtml#sec89)), 0-weight edges are okay.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect nodes in State 1 using exactly the same edges that originally connected
    nodes in State 0.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we’re in State 0 and reach a town with a cookie store, we buy a box of
    cookies and end up in State 1\. Once we’re in State 1, the graph gives us no way
    to return to State 0, because there’s no way to lose the box of cookies.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: We start in Town 1, State 0\. We must arrive in Town 4, State 1\. This requires
    that we eventually move from State 0 to State 1 and then go to Town 4 using the
    State-1 edges. When there are multiple towns with cookie stores, the problem becomes
    increasingly tricky, because then we have to choose exactly which cookie town
    takes us from State 0 to State 1\. Well, it might be tricky for us, but not for
    Dijkstra’s algorithm, because we’re just asking for a shortest path in a graph.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 1: Shortest Paths*'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we’ve talked about how to model the problem as a graph and find the
    shortest path distance, but not how to find the *number* of shortest paths. I’ll
    take these two subtasks in turn. At the end of this subsection, we’ll have solved
    half of the problem, correctly printing the shortest path distance. We won’t be
    printing anything for the number of paths, though, so we’ll still fail all of
    the test cases. Don’t worry: in the next subsection, we’ll work out how to coax
    the number of paths out of our code, too. It’s Dijkstra time!'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: With our new model (using the States 0 and 1), the graph that we read from the
    input no longer corresponds to the graph that we’ll explore with Dijkstra’s algorithm.
    One idea is to produce the adjacency list representation of the new graph from
    the adjacency list for the original graph. That is, start with an empty graph
    that has twice the number of nodes and add all of the required edges. That can
    be done, but I think it’s easier to leave the graph alone, logically adding the
    state to the code for Dijkstra’s algorithm. (When solving the Rope Climb problem
    in [Chapter 5](ch05.xhtml), we didn’t have much of a choice of what to do, because
    the input did not contain a graph.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write the function with the following signature:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `adj_list` is the adjacency list, `num_towns` is the number of towns (and
    the number of grandma’s town), and `store` tells us for any given `i` whether
    town `i` has a cookie store.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll proceed just as we did with the Mice Maze ([Listing 6-2](ch06.xhtml#ch06ex02)).
    At each step, however, we ask what effect the state has on our code and we make
    appropriate modifications. Let’s walk through the code, which is given in [Listing
    6-4](ch06.xhtml#ch06ex04). Compare this code to [Listing 6-2](ch06.xhtml#ch06ex02)
    to highlight the similarities.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 6-4: The shortest path to grandma’s using Dijkstra’s algorithm*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Right from the start, we see the influence of the state on our arrays, as `done`
    and `min_distances` are now two-dimensional arrays. The first dimension is indexed
    by the town number, and the second is indexed by the state. In our initialization
    ➊, we’re careful to initialize the elements of both states.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Our starting point is Town 1, State 0, so that’s the distance that we initialize
    to `0` ➋.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: As always, we want to continue running Dijkstra’s algorithm until no new nodes
    can be found. We have `num_towns` towns, but each one exists in both State 0 and
    State 1, so we have a maximum of `num_towns * 2` nodes to find ➌.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The nested `state` and `j` loops together find the next node. When these loops
    are done ➍, two important variables will be set: `min_town_index` gives the index
    of the town, and `min_state_index` gives the index of the state.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Our next step depends on which state we’re in and whether the town has a cookie
    store. If we’re in State 0 and at a town with a cookie store ➎, then we ignore
    `adj_list` and consider only the transition to State 1\. Remember that the transition
    from `[min_town_index][0]` to `[min_town_index][1]` has distance `0`, so our new
    path to `[min_town_index][1]` has the same distance as the shortest path to `[min_town_index][0]`.
    In typical Dijkstra fashion, we update the shortest path if our new path is shorter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we’re in State 0 but not at a town with a cookie store, or we’re
    in State 1\. The available edges here are exactly those in the input graph from
    the current town, so we examine all edges from `min_town_index` ➏. Now we’re in
    Mice Maze territory, looking for new shorter paths using edge `e`. Just be careful
    to use `min_state_index` everywhere, since none of these edges changes the state.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The final thing to do is print the shortest path distance ➐. We use `num_towns`
    as the first index (that’s grandma’s town) and `1` as the second index (so that
    a box of cookies is being carried).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: If you run our program on the test case from “Adjacency Matrix” on [page 214](ch06.xhtml#sec91),
    you should get the correct output of `4`. Indeed, for any test case, we’ll output
    the shortest path. Now, let’s move on to the number of shortest paths.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 2: Number of Shortest Paths*'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It takes just a few changes to beef up Dijkstra’s algorithm so that it finds
    not only the shortest path distance, but also the number of shortest paths. Those
    changes are subtle, so I’ll begin by working a few steps of an example to give
    you some intuition about why what we’re doing makes sense. I’ll then show the
    new code before giving a more detailed correctness argument.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Working Through an Example
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s trace Dijkstra’s algorithm on [Figure 6-5](ch06.xhtml#ch06fig05) from
    node (1,0). In addition to tracking whether each node is done and the minimum
    distance to each node, we’ll also keep *num_paths*, giving the number of shortest
    paths of minimum distance to the node. We’ll see that those paths counted by *num_paths*
    get thrown away whenever a shorter path is found.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we initialize the state for the starting node (1, 0). We set its
    minimum distance to 0 and set it to be done. As there’s exactly one path of distance
    0 from the starting node to itself (the path of no edges), we set its number of
    paths to 1\. We use the edges from the starting node to initialize the other nodes,
    and we set each of them to have one path (the path from the starting node). This
    gives us our first snapshot:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| (1,0) | true | 0 | 1 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| (2,0) | false | 3 | 1 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| (3,0) | false | 8 | 1 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| (4,0) | false | 2 | 1 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| (1,1) | false |  |  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| (2,1) | false |  |  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| (3,1) | false |  |  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| (4,1) | false |  |  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: 'Now what? Well, as always with Dijkstra’s algorithm, we scan through the nodes
    that are not done and choose one with minimum *min_distance* value. We therefore
    choose node (4,0). Dijkstra’s algorithm guarantees that this node has its shortest
    path set, so we can set it to done. Then, we must check the edges leaving (4,0)
    to see whether we can find shorter paths to other nodes. We can indeed find a
    shorter path to (3,0): before it was 8, but now it’s 7, because we can get to
    (4,0) with distance 2, and then from (4,0) to (3,0) with distance 5\. What do
    we put for the number of shortest paths to (3,0)? Well, it used to be 1, so it’s
    tempting to make it 2\. However, 2 is wrong, because that would count the path
    of distance 8, and that’s no longer a shortest path. The answer is 1, because
    there’s only one path of distance 7.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: There’s an edge from (4,0) to (2,0) that we shouldn’t dismiss too quickly. The
    old shortest path to (2,0) was 3\. What does the edge from (4,0) to (2,0) do for
    us? Does it give us a shorter path? Well, the distance to (4,0) is 2, and the
    edge from (4,0) to (2,0) has distance 1, so we have a new way to get to (2,0)
    with distance 3\. That’s not a shorter path, but it is *another* shortest path!
    That is, getting to (4,0) and then using the edge to (2,0) gives us new ways to
    get to (2,0). The number of new ways is the number of shortest paths to (4,0),
    which is just one. That gives us 1 + 1 = 2 shortest paths to get to (2,0).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all summarized in the next snapshot:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| (1,0) | true | 0 | 1 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| (2,0) | false | 3 | 2 |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| (3,0) | false | 7 | 1 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| (4,0) | true | 2 | 1 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| (1,1) | false |  |  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| (2,1) | false |  |  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| (3,1) | false |  |  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| (4,1) | false |  |  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: 'The next node that’s done is (2,0). There’s an edge of weight 0 from (2,0)
    to (2,1), and it takes distance 3 to get to (2,0), so we have a shortest path
    of distance 3 to (2,1) as well. There are two ways to get to (2,0) with that minimum
    distance, so there are two ways to get to (2,1) as well. Here’s what we’ve got
    now:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| (1,0) | true | 0 | 1 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| (2,0) | true | 3 | 2 |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| (3,0) | false | 7 | 1 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| (4,0) | true | 2 | 1 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| (1,1) | false |  |  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| (2,1) | false | 3 | 2 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| (3,1) | false |  |  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| (4,1) | false |  |  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: 'The next node that’s done is (2,1), and it is this node that finds the shortest
    path distance to our destination (4,1). There are two shortest paths to (2,1),
    so there are two shortest paths to (4,1) as well. Node (2,1) also finds new shortest
    paths to (1,1) and (3,1). Here’s what we’ve got now:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| (1,0) | true | 0 | 1 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| (2,0) | true | 3 | 2 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| (3,0) | false | 7 | 1 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| (4,0) | true | 2 | 1 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| (1,1) | false | 6 | 2 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| (2,1) | true | 3 | 2 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| (3,1) | false | 5 | 2 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| (4,1) | false | 4 | 2 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: 'Node (4,1) is the next one out, so we have our answer: the shortest path is
    4 and the number of shortest paths is 2\. (In our code we won’t have a stopping
    criterion here at the destination, so Dijkstra’s algorithm would keep going, finding
    shortest paths and number of shortest paths for other nodes. I encourage you to
    persevere with this example until the end.)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s how the algorithm works. It can be summarized by two rules:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**   Suppose that we use Node *u* to find a shorter path to Node *v*.
    Then the number of shortest paths to *v* is the number of shortest paths to *u*.
    (All of the old paths to *v* are invalidated and no longer count, because we now
    know that they are not shortest paths.)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2**   Suppose that we use Node *u* to find a path to Node *v* that’s
    the same distance as the current shortest path to *v*. Then the number of paths
    to *v* is the number of shortest paths that we already had for *v*, plus the number
    of shortest paths to *u*. (All of the old paths to *v* still count.)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we focus on some node *n* and watch what happens to its minimum
    distance and number of shortest paths as it runs. We don’t know what the shortest
    path to *n* will be: we might have its shortest path now, or Dijkstra’s algorithm
    might find a shorter one later. If we have its shortest path now, then we had
    better accumulate the number of shortest paths to *n*, since we may ultimately
    need that value to compute the number of shortest paths for other nodes. If we
    don’t have its shortest path now, then in retrospect we’ll have pointlessly accumulated
    its number of shortest paths. That’s okay, though, because we’ll just reset the
    number of shortest paths anyway when we find a shorter path.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To solve this task, we can start with [Listing 6-4](ch06.xhtml#ch06ex04) and
    make the changes necessary to find the number of shortest paths. The updated code
    is given in [Listing 6-5](ch06.xhtml#ch06ex05).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-5: The shortest path and number of shortest paths to grandma’s*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: I added a `num_paths` array that tracks the number of paths that we’ve found
    for each node ➊ and set all of its elements to `0` ➋. The only nonzero element
    in `num_paths` is for our starting node (1,0), which has one path of distance
    0 (the path that begins at the starting node and follows no edges) ➌.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The remaining new work is to update `num_paths`. As we’ve discussed, there are
    two cases. If we find a shorter path, then the old number of paths no longer counts.
    If we find another way to reach a node using its current path distance, then we
    add to the old number of paths. It’s that second case that can trip us up if we’re
    not careful, because we need to include an equality check in addition to a greater-than
    check ➍. If we used exactly the code that we’ve used throughout the chapter,
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: then the number of paths to a node would only be updated when a shorter path
    was found; there would be no way to accumulate shortest paths from multiple sources.
    Instead, we use `>=` rather than `>`
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: so that we can find more shortest paths, even if the shortest path itself does
    not change.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Now we can implement exactly the two cases that we’ve discussed for updating
    the number of paths. We have to do these cases twice, because there are two places
    in the code where Dijkstra’s algorithm can find shortest paths. The first addition
    ➎ is to the code that follows a 0-weight edge from State 0\. If the shortest path
    is the same as before, we add; if there’s now a new shorter path, we reset. The
    second addition of essentially the same code ➐ is added to the code for looping
    through the edges leaving the current node. In both cases, we use the mod operator
    ➏ ➑ to keep us under 1,000,000 shortest paths.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The final required change is to update the `printf` call at the end ➒, now also
    printing the number of shortest paths to grandma’s.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: You’re ready to submit to the judge. Let’s discuss a little bit about correctness
    before we wrap up for good.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm Correctness
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are no negative-weight edges in our Grandma Planner graphs, so we know
    that Dijkstra’s algorithm will correctly find all shortest path distances. There
    are some 0-weight edges—one from each cookie town in State 0 to the corresponding
    town in State 1—but Dijkstra’s algorithm copes just fine with those when finding
    shortest paths.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we must carefully think through the implications of 0-weight edges
    on finding the *number* of shortest paths. If we allow arbitrary 0-weight edges,
    then there may be an *infinite* number of shortest paths. Take a look at [Figure
    6-6](ch06.xhtml#ch06fig06), where we have 0-weight edges from A to B, B to C,
    and C to A. The shortest path from A to C, for example, is 0, and we have an infinite
    number of such paths: A *→* B *→* C, A *→* B *→* C *→* A *→* B *→* C, and so on.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig06.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: A graph with an infinite number of shortest paths*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, cycles of 0-weight edges cannot actually present themselves in Grandma
    Planner graphs. Remember that all road distances are at least one. Suppose that
    there were a 0-weight edge from Node *u* to Node *v*. This means that *u* is in
    State 0 and *v* is in State 1\. We can never get from *v* back to *u*, because
    our graphs provide no way to move from State 1 back to State 0.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll end by arguing the following: once a node is set to done, we have found
    its total number of shortest paths. Consider a run of our algorithm where it gives
    the wrong number of shortest paths. Our algorithm hums along, finding shortest
    paths and the number of shortest paths . . . and then, boom, it makes a mistake
    for the first time. It sets some node *n* to done, but it’s missed finding some
    of its shortest paths. We need to argue that this mistake cannot arise.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that some shortest paths to *n* end with some edge *m* *→* *n*. If *m*
    *→* *n* has a weight greater than 0, then the shortest path to *m* is shorter
    than the shortest path to *n*. (It’s the shortest path to *n* minus the weight
    of *m* *→* *n*.) Dijkstra’s algorithm works by finding nodes that are further
    and further from the starting node, so Node *m* must be done by this point. When
    Dijkstra’s algorithm set *m* to done, it would have gone through all edges from
    *m*, including *m* *→* *n*. Since *m*’s number of paths was set correctly (*m*
    is done, and Dijkstra’s algorithm hadn’t made its mistake yet), Dijkstra’s algorithm
    includes all of those paths in *n*’s path count.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if *m* *→* *n* is a 0-weight edge? We need *m* to be done before *n*;
    otherwise, *m*’s number of paths cannot be trusted when exploring the edges that
    leave *m*. We know that 0-weight edges go from a node in State 0 to a node in
    State 1, so *m* must be in State 0 and *n* must be in State 1\. The shortest path
    to *m* must be the same as the shortest path to *n*, since the 0-weight edge adds
    nothing to *m*’s shortest path. At some point, then, at the time when *m* and
    *n* are not done, Dijkstra’s algorithm will have to choose which of the two to
    next set to done. It had better choose *m*; and it will, because, as I’ve written
    the code, when there is a tie it chooses a node from State 0 rather than State
    1.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to tread lightly: we’re really getting away with something here. Here’s
    a test case that exemplifies why we have to process State-0 nodes before State-1
    nodes:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Trace our modified Dijkstra’s algorithm on this example. If you have a choice
    of which node to next set to done, choose one from State 0\. If you do that, you’ll
    get the correct answer: a shortest path distance of four and four shortest paths.
    Then, trace the algorithm again, only this time break ties by choosing a node
    from State 1\. You’ll still get the correct shortest path distance of four, because
    Dijkstra’s algorithm is not sensitive to how ties are broken. But our modified
    Dijkstra’s algorithm is, witnessed by the fact that you should get two shortest
    paths rather than four.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm is designed to find shortest paths in graphs. We’ve seen
    in this chapter how to model a problem instance as a suitable weighted graph and
    then use Dijkstra’s algorithm. Moreover, Dijkstra’s algorithm, like BFS in [Chapter
    5](ch05.xhtml), can serve as a guide for solving related but distinct problems.
    In the Grandma Planner problem, we found the number of shortest paths by a suitable
    modification to Dijkstra’s algorithm. We didn’t have to start from scratch. We’re
    not always literally going to be asked for the shortest path. If Dijkstra’s algorithm
    were resolute, finding shortest paths and nothing else, then it would offer no
    help when contexts shift. Indeed, we’d have learned a powerful algorithm, but
    one of an all-or-nothing flavor. Fortunately, Dijkstra’s algorithm applies more
    broadly. If you continue with graph algorithms beyond what I’ve included in this
    book, you’ll likely see ideas from Dijkstra’s algorithm appear again. While there
    may be millions of problems out there, there are far fewer algorithms. The best
    algorithms are often the ones that rest on ideas so flexible that they can ooze
    beyond their intended purpose.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mice Maze is originally from the 2001 Southwestern Europe Regional Contest.
    Grandma Planner is originally from the 2008 South African Programming Olympiad,
    Final Round.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: For more about graph search and its many applications to competitive programming
    problems, I recommend *Competitive Programming 4* by Steven Halim and Felix Halim
    (2020).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
