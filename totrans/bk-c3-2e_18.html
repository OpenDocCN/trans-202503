<html><head></head><body>
<h2 class="h2" id="ch18"><a id="page_225"/><strong>18</strong></h2>
<p class="h2a"><strong>BLEND MODES, FILTER EFFECTS, AND MASKING</strong></p>
<div class="image"><img alt="Image" src="graphics/common-01.jpg"/></div>
<p class="noindentt">The majority of today’s browsers—desktop and mobile—support the <em>Scalable Vector Graphics (SVG)</em> format. SVG differs from image formats such as GIF, JPEG, and PNG (known as bitmap images), as SVG is made up of a markup language</p>
<p class="noindent">(similar to HTML) that describes points, or vectors, rather than the grids of pixels that make up bitmap images. One advantage that SVG has over bitmap images is that, as a vector format, it scales well to fit screens of any resolution. In addition to this, the SVG format offers a built-in array of rich graphical effects previously available only in image-editing software such as Photoshop, GIMP, and Sketch.</p>
<p class="indent">Until recently, however, using those graphical effects in browsers wasn’t practical; live image effects are computationally intensive, and using them on the Web would have negatively affected performance. Today, however, browsers have become much faster and more capable, with almost all rendering graphics directly on the device’s GPU. This advance allows for the hardware-accelerated display of transformations and animations and unlocks the potential to use the rich graphical effects of SVG.</p>
<p class="indent"><a id="page_226"/>As browsers implemented SVG graphics effects, it became somewhat of a no-brainer to also give other web technologies access to them. So, in this chapter, you’ll learn about three features that make SVG’s graphical potential available to CSS: <em>blend modes</em>, <em>filter effects</em>, and <em>masking</em>. These nondestructive effects only alter the way images are displayed on the page; they don’t modify the source images.</p>
<p class="note"><strong><small>NOTE</small></strong><br/><em>Many SVG effects involve variations of color, which are very difficult to portray in black and white. I strongly encourage you to see examples of the effects yourself at</em> <a href="http://thebookofcss3.com/">http://thebookofcss3.com/</a>.</p>
<h3 class="h3" id="ch18leve1sec236"><strong>Blend Modes</strong></h3>
<p class="noindent">If you’ve used professional-grade image-editing software like Photoshop or GIMP, you may already be familiar with blend modes. Blend modes are a way to mix an image into a solid color or another image so the two appear merged or blended.</p>
<p class="indent">Various blend modes are available, each of which blends images in different ways, according to various algorithms. The available modes in CSS are defined in the Compositing and Blending Module (<em><a href="http://www.w3.org/TR/compositing-1/">http://www.w3.org/TR/compositing-1/</a></em>). I can’t cover all of the modes in detail due to a lack of space, so I’ll concentrate on three:</p>
<p class="bq"><strong>Screen</strong> In this mode, whites remain white, whereas black lets the background color show through. As a result of applying this mode, images tend to become lighter.</p>
<p class="bq"><strong>Multiply</strong> This mode tends to produce darker images. Blacks remain black, whereas whites let the background color pass through.</p>
<p class="bq"><strong>Overlay</strong> The Overlay mode strikes a balance between the Screen and Multiply modes. Highlights and shadows are preserved, increasing contrast.</p>
<p class="indent">The remaining blend modes are generally variations on these three. You can read a full explanation of each in the spec or see a good visual introduction on <em><a href="http://dev.opera.com/articles/getting-to-know-css-blend-modes/">http://dev.opera.com/articles/getting-to-know-css-blend-modes/</a></em>.</p>
<h4 class="h4" id="ch18leve1sec237"><strong><em>background-blend-mode</em></strong></h4>
<p class="noindent">The <code>background-blend-mode</code> property is used to blend the background layers of an element; for example, you might use it to blend the background color with the background image. This property works solely in the context of the element: Only the background layers are blended; the element itself doesn’t blend with any part of the page below it. The property requires as a value the keyword of the blend mode you want to use, such as <code>screen</code>, <code>multiply</code>, or <code>overlay</code>. For example, here’s how to apply the Multiply blend mode:</p>
<pre class="programs"><span class="codeitalic">E</span> { background-blend-mode: multiply; }</pre>
<p class="indent"><a id="page_227"/>The default value of <code>background-blend-mode</code> is <code>normal</code>, which leaves the background layer unblended.</p>
<h5 class="h5" id="ch18leve1sec238"><strong>Blending an Image and a Color</strong></h5>
<p class="noindent">The simplest way to show how background blend modes work is to blend a background image with a background color. The following listing has an element with a background image and color applied and is set to use the Screen blend mode:</p>
<pre class="programs"><span class="codeitalic">E</span> {<br/>    background: url('foo.png') #f00;<br/>    background-blend-mode: screen;<br/>}</pre>
<p class="indent"><a href="ch18.html#ch18fig1">Figure 18-1</a> shows the result of this and other blend modes. Image (A) at top left has no blend mode applied and is provided as a reference. The other images each have a different blend mode keyword applied, namely <code>screen</code> (B), <code>multiply</code> (C), and <code>overlay</code> (D). (Note that in this case the Overlay mode just puts a solid color over the image, which is far from ideal; Overlay blend modes are much more useful when blending two images.)</p>
<div class="image"><img alt="Image" src="graphics/f18-01.jpg"/></div>
<p class="figuret"><a id="ch18fig1"/><em>Figure 18-1: Comparing different blend modes applied to a source image</em></p>
<h5 class="h5" id="ch18leve1sec239"><strong>Blending Two Images</strong></h5>
<p class="noindent">In addition to blending a background image layer with a color layer, you can also blend a background image layer with other background image layers. To do so, apply multiple background images (as discussed in <a href="ch08.html#ch08">Chapter 8</a>) and then set the blend mode as before:</p>
<pre class="programs"><span class="codeitalic">E</span> {<br/>    background-color: transparent;<br/>    background-image: url('foo.png'), url('bar.png');<br/>    background-blend-mode: multiply;<br/>}</pre>
<p class="indent"><a id="page_228"/><a href="ch18.html#ch18fig2">Figure 18-2</a> shows examples of blending two images. Each image has different blend mode keywords applied. From left to right, these are <code>screen</code>, <code>multiply</code>, and <code>overlay</code>. (If you’re looking at the example files using a desktop browser, hover your mouse over the elements to show the two different background images that I’ve used.)</p>
<div class="image"><img alt="Image" src="graphics/f18-02.jpg"/></div>
<p class="figuret"><a id="ch18fig2"/><em>Figure 18-2: Blending multiple background image layers</em></p>
<p class="indent">Notice that I’ve set a transparent background color on the element. If I hadn’t, the <code>multiply</code> keyword would have made the lower background image layer blend with the background color and then blend with the other image layer, creating a different effect than what I intended.</p>
<h5 class="h5" id="ch18leve1sec240"><strong>Multiple Blend Modes</strong></h5>
<p class="noindent">Since you can add multiple background images to an element, it follows that you can apply a blend mode to each layer. To do so, you need only list the required blend modes in a comma-separated list of values.</p>
<p class="indent">In the following code, the element has three background layers: two images and a color. I’ve applied two blend mode keywords: Multiply mode will be used to blend the background color with <em>foo.png</em>; the result will be blended with <em>bar.png</em> using the Screen blend mode.</p>
<pre class="programs"><span class="codeitalic">E</span> {<br/>    background-color: #f00;<br/>    background-image: url('foo.png'), url('bar.png');<br/>    background-blend-mode: multiply, screen;<br/>}</pre>
<p class="note"><strong><small>NOTE</small></strong><br/><em>As with the other multiple background properties, having fewer values on the</em> <code><em>background-blend-mode</em></code> <em>property than there are background layers will make the value list loop.</em></p>
<p class="indent">Varying the blend modes can produce dramatically different results. For example, <a href="ch18.html#ch18fig3">Figure 18-3</a> shows a number of combinations applied to different elements with identical background layers. The element on the left uses the Screen mode on the top image layer and Multiply mode on the lower; the element in the middle uses Multiply mode on the upper image layer and Overlay on the lower; and on the right, Overlay mode is applied on the upper and Screen on the lower. As you can see, the results are quite different.</p>
<div class="image"><a id="page_229"/><img alt="Image" src="graphics/f18-03.jpg"/></div>
<p class="figuret"><a id="ch18fig3"/><em>Figure 18-3: Applying multiple blend modes in different combinations</em></p>
<h4 class="h4" id="ch18leve1sec241"><strong><em>mix-blend-mode</em></strong></h4>
<p class="noindent">Although blending background layers is undoubtedly useful, the real power lies in blending one element with another. In CSS3, you do this with the <code>mix-blend-mode</code> property. When applied to an element, this property blends the content of the element with the content and background of any elements that are directly behind it on the screen.</p>
<p class="indent">To understand how this differs from <code>background-blend-mode</code>, let’s see a quick example. In the following listing, I apply a background image to element <code><em>E</em></code> and the Multiply blend mode to element <code><em>F</em></code>, nested inside <code><em>E</em></code>:</p>
<pre class="programs"><span class="codeitalic">E</span> { background-image: url('foo.png'); }<br/><span class="codeitalic">F</span> { mix-blend-mode: multiply; }</pre>
<p class="indent"><a href="ch18.html#ch18fig4">Figure 18-4</a> shows the result, along with other blend modes for comparison. The element at top left (A) has no blend mode applied and is used as a reference; the remaining three each have blend mode keywords applied: <code>screen</code> (B), <code>multiply</code> (C), and <code>overlay</code> (D).</p>
<div class="image"><img alt="Image" src="graphics/f18-04.jpg"/></div>
<p class="figuret"><a id="ch18fig4"/><em>Figure 18-4: Different blend modes applied to the text element, mixed with the background of its parent</em></p>
<h5 class="h5" id="ch18leve1sec242"><a id="page_230"/><strong><em>isolation</em></strong></h5>
<p class="noindent">When using <code>mix-blend-mode</code>, be aware that it will blend with <em>every</em> visual element drawn behind it on the screen, which can cause unintended consequences. For example, say you have the following markup structure, in which an <code>img</code> element is nested inside a <code>div</code>, inside the <code>body</code>:</p>
<pre class="programs">&lt;body&gt;<br/>    &lt;div&gt;<br/>        &lt;img src="foo.jpg"&gt;<br/>    &lt;/div&gt;<br/>&lt;/body&gt;</pre>
<p class="indent">Now you set a background image on the <code>body</code> and the <code>mix-blend-mode</code> property on the <code>img</code>:</p>
<pre class="programs">body { background-image: url('bunny.png'); }<br/>img { mix-blend-mode: screen; }</pre>
<p class="indent">In this case, the <code>img</code> will blend with the body because the <code>div</code> is transparent, as shown in the example on the left of <a href="ch18.html#ch18fig5">Figure 18-5</a>.</p>
<div class="image"><img alt="Image" src="graphics/f18-05.jpg"/></div>
<p class="figuret"><a id="ch18fig5"/><em>Figure 18-5: Isolating an element to set a new stacking context</em></p>
<p class="indent">If the result isn’t exactly what you want, you can make an element create a new stacking context,<sup><a id="footnote_2"/><a href="footnote.html#footnote2">1</a></sup> similar to the way setting <code>position: relative</code> on an element resets the coordinates for absolute positioning. When blending, this process is called <em>isolating</em> the element, and you use the <code>isolation</code> property:</p>
<pre class="programs"><span class="codeitalic">E</span> { isolation: <span class="codeitalic">isolation-mode</span>; }</pre>
<p class="indent">The default value is <code>auto</code>, but to create the new stacking context, you must use the alternate value, <code>isolate</code>:</p>
<pre class="programs">div { isolation: isolate; }</pre>
<p class="indent"><a id="page_231"/>You can see the difference in the example on the right of <a href="ch18.html#ch18fig5">Figure 18-5</a>. The <code>div</code> is isolated and a new stacking context created, so the <code>img</code> is blended only with the transparent parent. As a result, you don’t see the background image of the <code>body</code> as in the example on the left.</p>
<h3 class="h3" id="ch18leve1sec243"><strong>Filter Effects</strong></h3>
<p class="noindent">Like blend modes, filters are a common part of professional image-editing software. Filters are used to change an element’s appearance before it reaches the page, and unlike blend modes, they don’t rely on the interaction of two components. CSS filters are defined in the CSS Filter Effects Module (<em><a href="http://www.w3.org/TR/filter-effects-1/">http://www.w3.org/TR/filter-effects-1/</a></em>) and are applied using the <code>filter</code> property, shown here:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: <span class="codeitalic">function</span>; }</pre>
<p class="indent">The <code><em>function</em></code> value is at least one of a range of nine filter effect functions. Each accepts a single argument, except when a series of arguments is required (in a space-separated list). I discuss each one here.</p>
<h4 class="h4" id="ch18leve1sec244"><strong><em>blur()</em></strong></h4>
<p class="noindent">Applies a blur effect to an element. The argument for the <code>blur()</code> function is a unit of length that controls the radius of the blur. The effect is called <em>Gaussian blur</em>—a kind of image smoothing that reduces noise in the image. The higher the radius value, the greater the blur effect. For example, to create a blur of radius 10px, you use this code:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: blur(10px); }</pre>
<p class="indent">You can see the blur effect in action in <a href="ch18.html#ch18fig6">Figure 18-6</a>. The unfiltered image is on the left; the <code>blur()</code> filter has been applied to the image on the right.</p>
<div class="image"><img alt="Image" src="graphics/f18-06.jpg"/></div>
<p class="figuret"><a id="ch18fig6"/><em>Figure 18-6: Applying a Gaussian blur filter</em></p>
<h4 class="h4" id="ch18leve1sec245"><a id="page_232"/><strong><em>brightness() and contrast()</em></strong></h4>
<p class="noindent">The <code>brightness()</code> function changes the brightness of an element, whereas the <code>contrast()</code> function increases or decreases the contrast between the dark and light of an element. Both functions take a percentage as an argument. Here’s an example:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: brightness(50%); }<br/><span class="codeitalic">E</span> { filter: contrast(50%); }</pre>
<p class="indent">In both cases, an argument of <code>100%</code> leaves the element unchanged. An argument of <code>0%</code> for <code>brightness()</code> makes the element fully black, and <code>0%</code> for <code>contrast()</code> makes the element fully gray. You can use values in excess of <code>100%</code> to increase the brightness and contrast as necessary.</p>
<p class="note"><strong><small>NOTE</small></strong><br/><em>You can also use a number for this function, with</em> <code><em>1</em></code> <em>being equivalent to</em> <code><em>100%</em></code>, <code><em>1.5</em></code> <em>to</em> <code><em>150%</em></code><em>, and so on. The same applies to all other functions that accept percentage values.</em></p>
<p class="indent"><a href="ch18.html#ch18fig7">Figure 18-7</a> shows examples of both functions. The first image has no filter applied and is shown as a reference. The middle image has the <code>brightness()</code> function applied, and the image on the right has <code>contrast()</code>—each function has an argument of <code>50%</code>.</p>
<div class="image"><img alt="Image" src="graphics/f18-07.jpg"/></div>
<p class="figuret"><a id="ch18fig7"/><em>Figure 18-7: Adjusting brightness and contrast with CSS filter effects</em></p>
<h4 class="h4" id="ch18leve1sec246"><strong><em>grayscale(), sepia(), and saturate()</em></strong></h4>
<p class="noindent">The next three functions all deal with color. The <code>grayscale()</code> function gives you a way to replace colors with shades of gray so you can convert images to black and white. The <code>sepia()</code> toning function is similar to <code>grayscale()</code>, except it uses a gold tint to produce a vintage photo effect. Finally, the <code>saturate()</code> function controls the color intensity.</p>
<p class="indent">Each of the functions accepts a percentage value as an argument:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: grayscale(100%); }<br/><span class="codeitalic">E</span> { filter: sepia(100%); }<br/><span class="codeitalic">E</span> { filter: saturate(200%); }</pre>
<p class="indent">A value of <code>100%</code> for the <code>grayscale()</code> function makes an image completely black and white. Passing <code>100%</code> to the <code>sepia()</code> function makes an image fully sepia toned. In the case of both functions, a value of <code>0%</code> leaves the image unchanged, whereas values greater than <code>100%</code> are treated as <code>100%</code>.</p>
<p class="indent"><a id="page_233"/>The <code>saturate()</code> function also accepts a percentage as an argument, but it works differently from <code>grayscale()</code> and <code>sepia()</code>. A value of <code>0%</code> makes an image appear fully unsaturated—or grayscale—whereas values greater than <code>100%</code> oversaturate the image.</p>
<p class="note"><strong><small>NOTE</small></strong><br/><em>To see these functions in action, view example file 18-a on this book’s companion website</em> (<a href="http://thebookofcss3.com/">http://thebookofcss3.com/</a>).</p>
<h4 class="h4" id="ch18leve1sec247"><strong><em>hue-rotate()</em></strong></h4>
<p class="noindent">The prosaically named <code>hue-rotate()</code> function is used to rotate the hue of an element. Recall from “<a href="ch10.html#ch10leve1sec119">Hue, Saturation, Lightness</a>” on <a href="ch10.html#page_116">page 116</a> that color hue is calculated from an angle around the axis of the color wheel. Therefore, the required argument to the <code>hue-rotate()</code> function is a degree, like this:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: hue-rotate(45deg); }</pre>
<p class="indent">Applying <code>hue-rotate()</code> actually shifts the hue of all colors in an element around the color wheel by the same amount. To see this function in action, view example file 18-b on this book’s website.</p>
<h4 class="h4" id="ch18leve1sec248"><strong><em>opacity()</em></strong></h4>
<p class="noindent">The <code>opacity()</code> function works the same as the <code>opacity</code> property introduced in <a href="ch10.html#ch10">Chapter 10</a>. The function accepts a percentage value as an argument, with <code>0%</code> equal to fully transparent and <code>100%</code> equal to fully opaque:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: opacity(25%); }</pre>
<p class="indent">Values greater than <code>100%</code> are treated as <code>100%</code>.</p>
<p class="indent">If the result of the <code>opacity()</code> function is identical to that of the <code>opacity</code> property, why bother using it at all? Because you can combine it with the other filter effect functions, as you’ll see shortly in “<a href="ch18.html#ch18leve1sec250">Multiple Filter Effect Functions</a>” on <a href="ch18.html#page_234">page 234</a>.</p>
<h4 class="h4" id="ch18leve1sec249"><strong><em>drop-shadow()</em></strong></h4>
<p class="noindent">At first, the <code>drop-shadow()</code> function may seem to be the same as the <code>box-shadow</code> property, introduced in <a href="ch09.html#ch09">Chapter 9</a>. Indeed, it even takes the same values as arguments: an x-offset, y-offset, blur radius, and shadow color. Here’s an example:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: drop-shadow(5px 5px 3px gray); }</pre>
<p class="indent">The biggest difference between the two is that the <code>drop-shadow()</code> function is aware of any alpha value (opacity) in the target element. You can see the difference clearly in <a href="ch18.html#ch18fig8">Figure 18-8</a>. The target image has a transparent background, so in the image at left (which has the <code>drop-shadow()</code> function applied), the drop box follows the outline of the image. The image on the <a id="page_234"/>right, however, has the <code>box-shadow</code> property applied. Because the <code>box-shadow</code> property doesn’t care about alpha transparency, the shadow follows only the outline of the box.</p>
<div class="image"><img alt="Image" src="graphics/f18-08.jpg"/></div>
<p class="figuret"><a id="ch18fig8"/><em>Figure 18-8: Comparing the</em> <code><em>drop-shadow()</em></code> <em>filter (left) with the</em> <code><em>box-shadow</em></code> <em>property (right)</em></p>
<h4 class="h4" id="ch18leve1sec250"><em><strong>Multiple Filter Effect Functions</strong></em></h4>
<p class="noindent">You can apply multiple filter effect functions to an element by simply listing them in a space-separated list. For example, you could add both blur and a drop shadow to an element:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: blur(5px) drop-shadow(5px 5px 3px gray); }</pre>
<p class="indent">The order in which you list the functions is important, as that’s the order in which they’ll be applied. For example, in this next listing two filter effects are applied, but I’ve changed the order: in the first, the <code>gray-scale()</code> function is applied before <code>sepia()</code>, and in the second, I’ve reversed it:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: sepia(100%) gray-scale(100%); }<br/><span class="codeitalic">E</span> { filter: gray-scale(100%) sepia(100%); }</pre>
<p class="indent">In the first example, the <code>sepia()</code> function will be applied and then <code>grayscale()</code>, so all the colors of the <code>sepia()</code> filter effect will be converted to grayscale. In the second, the <code>grayscale()</code> function will be applied and then <code>sepia()</code>, so the colors of the <code>sepia()</code> filter effect will show. Example file 18-c on this book’s website shows how this appears.</p>
<p class="indent">Like CSS Transforms (introduced in <a href="ch12.html#ch12">Chapter 12</a>), when you list multiple functions in the <code>filter</code> property, any functions not in the list will have their values returned to the default. For example, in the following listing, the element loses its <code>sepia()</code> filter effect on hover:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: sepia(100%) blur(2px); }<br/><span class="codeitalic">E</span>:hover { filter: blur(5px); }</pre>
<h4 class="h4" id="ch18leve1sec251"><a id="page_235"/><strong><em>Filters in SVG</em></strong></h4>
<p class="noindent">Recall that CSS filter effects are simply shorthand for SVG filter presets. The Filter Effects Module shows the markup equivalents for all of the CSS functions. For example, the SVG markup for the <code>blur()</code> filter looks like the following (the <code><em>blur-radius</em></code> value is a unitless number):</p>
<pre class="programs">&lt;filter&gt;<br/>    &lt;feGaussianBlur stdDeviation="<span class="codeitalic">blur-radius</span>" /&gt;<br/>&lt;/filter&gt;</pre>
<p class="indent">You can create your own filters in SVG and apply them in CSS by using an ID reference. The first step is to add an ID value to your filter:</p>
<pre class="programs">&lt;filter id="blur"&gt;…&lt;/filter&gt;</pre>
<p class="indent">Then refer to it in your CSS using the <code>url()</code> notation, containing the ID reference, as a value for the <code>filter</code> property. If your SVG is in line with the markup in your document, you need only the ID reference:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: url('#blur'); }</pre>
<p class="indent">If your SVG is in an external asset file (say, <em>filters.svg</em>), state the path to that file followed by the ID reference:</p>
<pre class="programs"><span class="codeitalic">E</span> { filter: url('filters.svg#blur'); }</pre>
<p class="indent">Unlike CSS filter effects, this technique only works for a single filter. To apply multiple filters to an element, you have to combine them in the SVG markup first.</p>
<h3 class="h3" id="ch18leve1sec252"><strong>Masking</strong></h3>
<p class="noindent">Masking is a technique in which certain parts of an element are hidden from view. There are two approaches <code>to masking:</code> clipping, where the area that’s hidden is set by a polygonal shape that’s overlaid on an element, and image masking, where an image’s alpha channel is used to set the hidden area.</p>
<h4 class="h4" id="ch18leve1sec253"><strong><em>Clipping</em></strong></h4>
<p class="noindent">Clipping is the simplest form of masking. When clipping, a shape is laid over an image and any parts of the element that are behind the shape will be shown, while any parts outside the boundaries of the shape will be hidden. The boundary of the shape is called the <em>clip path</em> and is created with the <code>clip-path</code> property:</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: <span class="codeitalic">shape</span>; }</pre>
<p class="indent"><a id="page_236"/>The <code><em>shape</em></code> can be one of four basic types, each of which is represented by a function: <code>circle()</code>, <code>ellipse()</code>, <code>inset()</code> (for rectangles), and <code>polygon()</code>. Each function takes a number of arguments, which define the clip path. For example, to create a circle, you supply three arguments to the <code>circle()</code> function, using a syntax like that for radial gradients (see <a href="ch11.html#ch11">Chapter 11</a>):</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: circle(<span class="codeitalic">r</span> at <span class="codeitalic">cx cy</span>); }</pre>
<p class="indent">The <code><em>r</em></code> represents the radius of the circle, and <code><em>cx</em></code> and <code><em>cy</em></code> are the coordinates of its center. So to clip an element to a 100px circle positioned at the center of the target, you use these values:</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: circle(100px at 50% 50%); }</pre>
<p class="indent">The <code>ellipse()</code> function is very similar, requiring only an extra argument to set the radii of the ellipse:</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: ellipse(<span class="codeitalic">rx ry</span> at c<span class="codeitalic">x</span> c<span class="codeitalic">y</span>); }</pre>
<p class="indent">Here <code><em>rx</em></code> is used to represent the <em>x</em>-axis of the radius, and <code><em>ry</em></code> the <em>y</em>-axis. To create an ellipse with a radius of 50px and 100px, again at the center of the target, you use these values:</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: ellipse(50px 100px at 50% 50%); }</pre>
<p class="indent">To see how these appear in practice, take a look at <a href="ch18.html#ch18fig9">Figure 18-9</a>. The example on the left uses the <code>circle()</code> function with the values used earlier, and on the right, <code>ellipse()</code>, also with the values used earlier.</p>
<div class="image"><img alt="Image" src="graphics/f18-09.jpg"/></div>
<p class="figuret"><a id="ch18fig9"/><em>Figure 18-9: Function values for the</em> <code><em>clip-path</em></code> <em>property:</em> <code><em>circle()</em></code> <em>(left) and</em> <code><em>ellipse()</em></code> <em>(right)</em></p>
<p class="indent">As mentioned earlier, the <code>inset()</code> function is used to create a rectangle that is inset from the border of the element to which it is applied. It can accept up to 12 (!) arguments. The first four arguments set the distance that each side of the rectangle is offset—just like the <code>border-image-slice</code> property <a id="page_237"/>(see <a href="ch09.html#ch09">Chapter 9</a>). So a single value will set the offset distance equally on all sides; if two values are supplied, the first will set the top and bottom and the second the left and right; and so on.</p>
<p class="indent">If we were to use all four values, the syntax would look like this:</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: inset(<span class="codeitalic">o1 o2 o3 o4</span>); }</pre>
<p class="indent">Each <code><em>o*</em></code> represents an offset value (the top, right, bottom and left, respectively).</p>
<p class="indent">In its simplest format, a single value would create four equal offsets, as in this case, where each offset value is 2em:</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: inset(2em); }</pre>
<p class="indent">You can also round the corners of the clip path, which is where the remaining arguments come in. Following the <code>round</code> keyword, you can use syntax identical to that of the <code>border-radius</code> property (see <a href="ch09.html#ch09">Chapter 9</a>) to define a radius for each corner—with up to eight values for fine control. To prevent my having to repeat the explanation of the <code>border-radius</code> short-hand here, this example shows how you’d set a radius of 20px on each corner of the inset rectangle defined earlier:</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: inset(2em round 20px); }</pre>
<p class="indent">See the result in <a href="ch18.html#ch18fig10">Figure 18-10</a>. The example on the left shows a rectangle with right-angled corners, and on the right, a rectangle with rounded corners.</p>
<div class="image"><img alt="Image" src="graphics/f18-10.jpg"/></div>
<p class="figuret"><a id="ch18fig10"/><em>Figure 18-10: The</em> <code><em>inset()</em></code> <em>function without (left) and with (right) border radius values</em></p>
<p class="indent">You can use the <code>polygon()</code> function to create more complex clip paths. This function takes an unlimited number of arguments, in pairs, in a comma-separated list. Each pair creates a coordinate value, and the full set of coordinates is used to draw the required clip shape. As a very simple example, this syntax defines the three points of a triangle:</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: polygon(0% 100%, 100% 0%, 0% 0%); }</pre>
<p class="indent"><a id="page_238"/>The triangle’s points are at the left top, left bottom, and right top of the target element. You can see how this is clipped in <a href="ch18.html#ch18fig11">Figure 18-11</a>.</p>
<div class="image"><img alt="Image" src="graphics/f18-11.jpg"/></div>
<p class="figuret"><a id="ch18fig11"/><em>Figure 18-11: A triangular clip path made with the</em> <code><em>polygon()</em></code> <em>function</em></p>
<p class="note"><strong><small>NOTE</small></strong><br/><em>Clipping an element only changes its visual appearance—the dimensions and box model of the element that’s clipped will be unmodified. For a suggestion of how this may change in the future, see “<a href="ch19.html#ch19leve1sec263">Shapes</a>” on <a href="ch19.html#page_246">page 246</a>.</em></p>
<h5 class="h5" id="ch18leve1sec254"><strong>Implementation of clip-path in Safari</strong></h5>
<p class="noindent">The <code>clip-path</code> property was implemented in Safari 7, with a vendor prefix, but using a now-outdated version of the syntax (the updated syntax was implemented in Safari 8). The <code>polygon()</code> function works in the same way, but the others are slightly different; for example, the <code>circle()</code> function looks slightly different, requiring three comma-separated arguments:</p>
<pre class="programs"><span class="codeitalic">E</span> { -webkit-clip-path: circle(<span class="codeitalic">cx</span>, <span class="codeitalic">cy</span>, <span class="codeitalic">r</span>); }</pre>
<p class="indent">Similarly, the <code>ellipse()</code> function accepts four arguments:</p>
<pre class="programs"><span class="codeitalic">E</span> { -webkit-clip-path: circle(<span class="codeitalic">cx</span>, <span class="codeitalic">cy</span>, <span class="codeitalic">rx</span>, <span class="codeitalic">ry</span>); }</pre>
<p class="indent">The <code>inset()</code> function is known as <code>inset-rectangle()</code>, and it requires a minimum of four comma-separated values to represent the offset distances:</p>
<pre class="programs"><span class="codeitalic">E</span> { -webkit-clip-path: inset-rectangle(<span class="codeitalic">o1</span>, <span class="codeitalic">o2</span>, <span class="codeitalic">o3</span>, <span class="codeitalic">o4</span>); }</pre>
<p class="indent"><a id="page_239"/>You can round the corners, but the values must be the same for each corner—you can’t set an individual value per corner. You can, however, set <em>x</em>-axis and <em>y</em>-axis values to make irregular radii:</p>
<pre class="programs"><span class="codeitalic">E</span> { -webkit-clip-path: inset-rectangle(<span class="codeitalic">o1</span>, <span class="codeitalic">o2</span>, <span class="codeitalic">o3</span>, <span class="codeitalic">o4</span>, <span class="codeitalic">rx</span>, <span class="codeitalic">ry</span>); }</pre>
<p class="indent">The biggest difference from the standard is in the <code>rectangle()</code> function; this was originally defined in the spec but has since been pushed back to a future version. The <code>rectangle()</code> function also lets you create rectangular clipping shapes but using coordinates rather than offset values. It accepts up to six arguments:</p>
<pre class="programs"><span class="codeitalic">E</span> { -webkit-clip-path: rectangle(<span class="codeitalic">x</span>, <span class="codeitalic">y</span>, <span class="codeitalic">w</span>, <span class="codeitalic">h</span>, <span class="codeitalic">rx</span>, <span class="codeitalic">ry</span>); }</pre>
<p class="indent">The first four arguments are required: <code><em>x</em></code> and <code><em>y</em></code> set the <em>x</em>- and <em>y</em>- coordinates of the top-left corner of the shape, relative to the top-left corner of the target element; and <code><em>w</em></code> and <code><em>h</em></code> set the width and height, respectively, of the shape. The optional <code><em>rx</em></code> and <code><em>ry</em></code> arguments can be used to set the border-radius of all corners of the clip path. (You can use one value to make an equal radius, but you can’t set each corner individually.)</p>
<p class="indent"><a href="ch18.html#ch18fig12">Figure 18-12</a> shows how these six values set the clipping area of an image.</p>
<div class="image"><img alt="Image" src="graphics/f18-12.jpg"/></div>
<p class="figuret"><a id="ch18fig12"/><em>Figure 18-12: Six values for the</em> <code><em>rectangle()</em></code> <em>shape function that set the clipping area</em></p>
<p class="indent"><a id="page_240"/>If we combine these options as shown in the following listing, we would create a clip path 10px from the top left of the element it’s set on, with a width of 50 percent, a height of 100px, and corners with a radius of 20px on both axes. <a href="ch18.html#ch18fig13">Figure 18-13</a> shows what this would look like.</p>
<pre class="programs"><span class="codeitalic">E</span> { -webkit-clip-path: rectangle(10px, 10px, 50%, 100px, 20px); }</pre>
<div class="image"><img alt="Image" src="graphics/f18-13.jpg"/></div>
<p class="figuret"><a id="ch18fig13"/><em>Figure 18-13: A rectangle made with the</em> <code><em>rectangle()</em></code> <em>function of</em> <code><em>-webkit-clip-path</em></code></p>
<h5 class="h5" id="ch18leve1sec255"><strong>Animating Clip Paths</strong></h5>
<p class="noindent">Because clip paths are defined using coordinates, animating them to create impressive effects is easy. For example, you can take the triangle polygon defined in the previous section and transition it on hover:</p>
<pre class="programs"><span class="codeitalic">E</span> {<br/>   clip-path: polygon(0% 0%, 0% 100%, 100% 0%);<br/>   transition: clip-path 1s;<br/>}<br/><span class="codeitalic">E</span>:hover { clip-path: polygon(100% 100%, 0% 100%, 100% 0%); }</pre>
<p class="indent">In this animation, two points of the triangle stay in the same position, while the third switches to the corner diagonally opposite. This is animated with a transition, causing the effect you see in example file 18-d.</p>
<h5 class="h5" id="ch18leve1sec256"><strong>Clip Paths in SVG</strong></h5>
<p class="noindent"><a id="page_241"/>You can also create clip paths in SVG and apply them to an element using CSS. To do so, you first define your clip path markup and then assign it a unique ID. For example, the following listing creates a circular clip path using the <code>clipPath</code> element at the center of the element, with a radius half the width and height. It has an ID of <code>clipping</code>.</p>
<pre class="programs">&lt;defs&gt;<br/>    &lt;clipPath id="clipping"&gt;<br/>        &lt;circle cx="0.5" cy="0.5" r="0.5" /&gt;<br/>    &lt;/clipPath&gt;<br/>&lt;/defs&gt;</pre>
<p class="indent">Once defined, I apply this clip path to my element using the <code>clip-path</code> property, with a value equal to the <code>url()</code> notation containing the ID of the clip path:</p>
<pre class="programs"><span class="codeitalic">E</span> { clip-path: url('#clipping'); }</pre>
<p class="indent">Unfortunately, this method has drawbacks. For one, as of this writing, it only works in Firefox. Also, you can’t animate these shapes without using JavaScript.</p>
<h4 class="h4" id="ch18leve1sec257"><strong><em>Image Masking</em></strong></h4>
<p class="noindent">In addition to clipping an element with geometric shapes, you can also mask one image with another, using the alpha value of the mask to determine how much of the target will be visible. (This process is similar to the way blend modes work, except that it uses alpha rather than black and white.) The mask is applied using the <code>mask</code> property, which takes these values:</p>
<pre class="programs"><span class="codeitalic">E</span> { mask: <span class="codeitalic">image position</span> / <span class="codeitalic">size</span>; }</pre>
<p class="indent">The <code><em>image</em></code> value is the <code>url()</code> notation with a path to the image to be used as a mask. The properties <code><em>position</em></code> and <code><em>size</em></code> work the same as the <code>background-position</code> and <code>background-size</code> properties (see <a href="ch08.html#ch08">Chapter 8</a>). For example, the following code will set an image called <em>mask.png</em> at the center of an element, with the mask filling the width of the parent while maintaining its original aspect ratio:</p>
<pre class="programs"><span class="codeitalic">E</span> { mask: url('mask.png') 50% 50% / 100% auto; }</pre>
<p class="indent"><a href="ch18.html#ch18fig14">Figure 18-14</a> shows the three steps in masking. The target image is on the left; the image to be used as a mask is in the middle; and the mask applied to the target is on the right.</p>
<div class="image"><img alt="Image" src="graphics/f18-14.jpg"/></div>
<p class="figuret"><a id="ch18fig14"/><em>Figure 18-14: The three steps of image masking</em></p>
<p class="note"><a id="page_242"/><strong><small>NOTE</small></strong><br/><em>This is a simple mask. The syntax is much more flexible than this, although a bit too complicated to explore in detail in this book.</em></p>
<p class="indent">The <code>mask</code> property is shorthand for a whole range of subproperties, including <code>mask-image</code>, <code>mask-position</code>, and <code>mask-size</code>. You can use many more properties in addition to these, and the full <code>mask</code> shorthand looks like this:</p>
<pre class="programs"><span class="codeitalic">E</span> { mask: <span class="codeitalic">image mode position</span> / <span class="codeitalic">size repeat origin clip composite</span>; }</pre>
<p class="indent">Let’s take a brief walk through the unfamiliar properties. The <code>mask-mode</code> property determines whether the mask should work on the default alpha channel or through <em>luminance</em> (lightness); <code>mask-repeat</code> tiles the mask image just as <code>background-repeat</code>; <code>mask-origin</code> and <code>mask-clip</code> also work like their background equivalents (<code>background-origin</code> and <code>background-clip</code> in <a href="ch08.html#ch08">Chapter 8</a>); and <code>mask-composite</code> controls how multiple <code>mask-image</code> values should interact if they overlap.</p>
<h4 class="h4" id="ch18leve1sec258"><strong><em>Border Masking</em></strong></h4>
<p class="noindent">In <a href="ch09.html#ch09">Chapter 9</a>, I introduced the <code>border-image</code> property, which is used to apply images to the borders of an element. You can use the same basic method of slicing an image that we discussed in that context to apply a mask to the border of an element.</p>
<p class="indent">The properties involved in border masking are <code>mask-border-source</code>, <code>mask-border-slice</code>, <code>mask-border-repeat</code>, <code>mask-border-width,</code> and <code>mask-border-output</code>. Each can be included in the <code>mask-border</code> shorthand, and each is identical in function to their <code>border-image-*</code> counterpart. For example, to set an image <em>mask.png,</em> with slices of 40px each, which repeats along each side of an element, you use this syntax:</p>
<pre class="programs"><span class="codeitalic">E</span> { mask-border: url('mask.png') 40px repeat; }</pre>
<p class="indent">Unfortunately, as of this writing no browser supports this in accordance with the spec (though Chrome and Safari support a similar but outdated property called <code>-webkit-mask-box-image</code>), so I won’t spend any more time discussing border masking.</p>
<h4 class="h4" id="ch18leve1sec259"><strong><em>Masking in SVG</em></strong></h4>
<p class="noindent">You can use SVG to mask images, much as you might clip them. To do so, you define the mask in markup and then apply it using a CSS property (<code>mask</code>). For example, the following listing creates a mask of a black box with a white ellipse in the center:</p>
<pre class="programs">&lt;defs&gt;<br/>    &lt;mask id="masking"&gt;<br/>        &lt;rect y="0.3" width="1" height=".7" fill="black" /&gt;<br/>        &lt;circle cx=".5" cy=".5" r=".35" fill="white" /&gt;<br/>    &lt;/mask&gt;<br/>&lt;/defs&gt;</pre>
<p class="indent"><a id="page_243"/>The next step is to apply the mask to the target element, using the <code>mask</code> property with a <code>url()</code> notation containing the ID of the <code>mask</code> element (<code>masking</code>):</p>
<pre class="programs"><span class="codeitalic">E</span> { mask: url('#masking'); }</pre>
<p class="note"><strong><small>NOTE</small></strong><br/><em>For a more in-depth look at masking in SVG and CSS, see Dirk Schulze’s “CSS</em> <em>Masking”</em> (<a href="http://www.html5rocks.com/en/tutorials/masking/adobe/">http://www.html5rocks.com/en/tutorials/masking/adobe/</a>).</p>
<h3 class="h3" id="ch18leve1sec260"><strong>Combining Filter Effects and Masking</strong></h3>
<p class="noindent">Should you want to combine filter effects with masking on the same element, it’s important to know that they will be applied in a specific order: filter effects are applied first, followed by clipping, then masking, and finally opacity. To see the consequence of this order, consider the following listing that applies a drop shadow filter and circular clipping path to an element:</p>
<pre class="programs"><span class="codeitalic">E</span> {<br/>    clip-path: circle(50% at 50% 50%);<br/>    filter: drop-shadow(5px 5px black);<br/>}</pre>
<p class="indent">In this code, the effects are applied to the image in this order: first, the drop shadow is applied; then the image with the drop shadow applied is clipped into a circle. To avoid the clipping of the drop shadow, you can apply the filter effect to a parent element:</p>
<pre class="programs"><span class="codeitalic">D</span> { filter: drop-shadow(5px 5px black); } <span class="codeitalic">/* parent */</span> <br/><span class="codeitalic">E</span> { clip-path: circle(50% at 50% 50%); } <span class="codeitalic">/* child */</span> </pre>
<p class="indent">This works because of the way browsers parse the DOM for rendering. The clipping of the child element will occur before the filter effect that is inherited from the parent. (<a href="ch18.html#ch18fig15">Figure 18-15</a> compares the two methods.)</p>
<div class="image"><img alt="Image" src="graphics/f18-15.jpg"/></div>
<p class="figuret"><a id="ch18fig15"/><em>Figure 18-15: Comparing rendering order of graphical CSS effects</em></p>
<h3 class="h3" id="ch18leve1sec261"><a id="page_244"/><strong>Summary</strong></h3>
<p class="noindent">Blend modes, filter effects, and masking provide access to web browser features that were previously found only in professional photo-imaging software. Each is useful on its own, but combine them and designers and developers get a whole new way to approach visual design on the Web.</p>
<p class="indent">The ability to use graphical effects like these comes thanks to the widespread implementation of SVG. The markup that describes an SVG image is already closely tied with HTML (it can be dropped into HTML and will be parsed as part of the document), and in the future you should see SVG and CSS become much more closely tied—we’ve seen that with the graphical effects in this chapter, and modules currently in development also describe a shared implementation of the animation properties described in <a href="ch14.html#ch14">Chapter 14</a>.</p>
<h3 class="h3" id="ch18leve1sec262"><strong>Blend Modes, Filter Effects, and Masking: Browser Support</strong></h3>
<table border="0" cellpadding="0" cellspacing="0" class="all" width="100%">
<tr>
<td class="table2" valign="top"><p class="table"/></td>
<td class="table2" valign="top"><p class="table"><strong>Chrome</strong></p></td>
<td class="table2" valign="top"><p class="table"><strong>Firefox</strong></p></td>
<td class="table2" valign="top"><p class="table"><strong>Safari</strong></p></td>
<td class="table2" valign="top"><p class="table"><strong>IE</strong></p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>background-blend-mode</code></p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Safari 8</p></td>
<td class="table" valign="top"><p class="table">No</p></td>
</tr>
<tr>
<td class="table4" valign="top"><p class="table"><code>mix-blend-mode</code></p></td>
<td class="table4" valign="top"><p class="table">No<sup><a id="footnote_41a"/><a href="ch18.html#footnote41a">*</a></sup></p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Safari 8</p></td>
<td class="table4" valign="top"><p class="table">No</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>isolation</code></p></td>
<td class="table" valign="top"><p class="table">No<a href="ch18.html#footnote41a">*</a></p></td>
<td class="table" valign="top"><p class="table">No</p></td>
<td class="table" valign="top"><p class="table">Safari 8</p></td>
<td class="table" valign="top"><p class="table">No</p></td>
</tr>
<tr>
<td class="table4" valign="top"><p class="table"><code>filter</code></p></td>
<td class="table4" valign="top"><p class="table">Yes<sup><a id="footnote_42a"/><a href="ch18.html#footnote42a">†</a></sup></p></td>
<td class="table4" valign="top"><p class="table">No<sup><a id="footnote_43a"/><a href="ch18.html#footnote43a">‡</a></sup></p></td>
<td class="table4" valign="top"><p class="table">Yes<sup><a href="ch18.html#footnote42a">†</a></sup></p></td>
<td class="table4" valign="top"><p class="table">No</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>clip-path</code></p></td>
<td class="table" valign="top"><p class="table">Yes<a href="ch18.html#footnote41a">*</a></p></td>
<td class="table" valign="top"><p class="table">No</p></td>
<td class="table" valign="top"><p class="table">Safari 8<sup><a id="footnote_44a"/><a href="ch18.html#footnote44a">§</a></sup></p></td>
<td class="table" valign="top"><p class="table">No</p></td>
</tr>
<tr>
<td class="table4" valign="top"><p class="table"><code>mask</code></p></td>
<td class="table4" valign="top"><p class="table">Yes<sup><a href="ch18.html#footnote42a">†</a></sup></p></td>
<td class="table4" valign="top"><p class="table">No</p></td>
<td class="table4" valign="top"><p class="table">Yes<sup><a href="ch18.html#footnote42a">†</a></sup></p></td>
<td class="table4" valign="top"><p class="table">No</p></td>
</tr>
</table>
<p class="footnote"><a id="footnote41a"/><a href="ch18.html#footnote_41a">*</a> Implemented but off by default</p>
<p class="footnote"><a id="footnote42a"/><a href="ch18.html#footnote_42a">†</a> With vendor prefix</p>
<p class="footnote"><a id="footnote43a"/><a href="ch18.html#footnote_43a">‡</a> Can use filters defined in SVG</p>
<p class="footnote"><a id="footnote44a"/><a href="ch18.html#footnote_44a">§</a> With vendor prefix; implemented with outdated syntax in Safari 7</p>
</body></html>