- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Dependencies
  prefs: []
  type: TYPE_NORMAL
- en: In March 2016, thousands of JavaScript projects began failing to compile when
    a single package, `left-pad`, disappeared. The `left-pad` was a library with a
    single method that simply left-padded a string to a specific character width.
    Several foundational JavaScript libraries depended on `left-pad`. In turn, many
    projects depended on these libraries. Thanks to the viral nature of transitive
    dependencies, thousands and thousands of open source and commercial codebases
    had a critical dependency on this fairly trivial library. When the package was
    removed from NPM (JavaScript’s Node Package Manager), a lot of programmers had
    a rough day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a dependency on existing code seems like a simple decision. Don’t repeat
    yourself (DRY) is a commonly taught principle. Why should we all write our own
    `left-pad`? Database drivers, application frameworks, machine learning packages—there
    are many examples of libraries you should not write from scratch. But dependencies
    bring risk: incompatible changes, circular dependencies, version conflicts, and
    lack of control. You must consider these risks and how to mitigate them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the basics of dependency management and talk about
    every engineer’s nightmare: dependency hell.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Management Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can talk about problems and best practices, we must introduce you
    to common dependency and versioning concepts.
  prefs: []
  type: TYPE_NORMAL
- en: A *dependency* is code that your code relies on. The time at which a dependency
    is needed—during compilation, testing, or runtime—is called its *scope*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies are declared in package management or build files: Java’s Gradle
    or Maven configs, Python’s *setup.py* or *requirements.txt*, and JavaScript’s
    NPM *package.json*. Here is a snippet of a Java project’s *build.gradle* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The project depends on version 4.3.6 of an HTTP client library and version
    1.7.2 of an SLF4J application programming interface (API) library. Each dependency
    is declared with a `compile` scope, meaning the dependencies are needed to compile
    the code. Each package has a version defined: 4.3.6 for `httpclient` and 1.7.2
    for `slf4j`. Versioned packages are used to control when dependencies change and
    to resolve conflicts when different versions of the same package appear (more
    on this later).'
  prefs: []
  type: TYPE_NORMAL
- en: A good versioning scheme has versions that are
  prefs: []
  type: TYPE_NORMAL
- en: Unique Versions should never be reused. Artifacts get distributed, cached, and
    pulled by automated workflows. Never republish changed code under an existing
    version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comparable Versions should help humans and tools reason about version precedence.
    *Precedence* is used to resolve conflicts when a build depends on multiple versions
    of the same artifact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Informative Versions differentiate between prereleased and released code, associate
    build numbers to artifacts, and set stability and compatibility expectations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git hashes or “marketing-related” versions like Android OS’s dessert series
    (Android Cupcake, Android Froyo) or Ubuntu’s alliterative animals (Trusty Tahr,
    Disco Dingo) satisfy the uniqueness property, but they are not comparable or informative.
    Similarly, a monotonically increasing version number (1, 2, 3) is both unique
    and comparable, but not terribly informative.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The packages in the previous example use a versioning scheme called *semantic
    versioning* *(SemVer)*, one of the most commonly used versioning schemes. The
    official SemVer specification is available at [https://semver.org/](https://semver.org/).
    The spec defines three numbers: the major, minor, and patch version (sometimes
    called the *micro version*). Version numbers are combined into a single MAJOR.MINOR.PATCH
    version number. The `httpclient` version 4.3.6 has a major, minor, and patch of
    4, 3, and 6, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versions are unique, comparable, and informative. Each version number
    is used once and can be compared by going left to right (2.13.7 is before 2.14.1).
    They provide information about compatibility between different versions and can
    optionally encode release candidate or build number information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Major version 0, considered “prerelease,” is intended for fast iteration; no
    compatibility guarantees are made. Developers can change APIs in ways that break
    older code, like adding a new required parameter or deleting a public method.
    Starting with major version 1, a project is expected to guarantee the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Patch versions are incremented for backward-compatible bug fixes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minor versions are incremented for backward-compatible features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major versions are incremented for backward-incompatible changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SemVer also defines prerelease versions by appending a `-` character after the
    patch version. Dot-separated alphanumeric sequences are used for prerelease identifiers
    (2.13.7-alpha.2). Prereleases can make breaking changes without bumping the major
    version. Many projects use *release candidate (RC)* builds. Early adopters can
    find bugs in RCs before the official release. RC prerelease versions have incremental
    identifiers, such as 3.0.0-rc.1\. The final RC is then promoted to the release
    version by re-releasing it without an RC suffix. All prereleased versions are
    superseded by the final release (3.0.0 in our example). See Chapter 8 for more
    on release management mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build numbers are appended after both the version and prerelease metadata:
    2.13.7-alpha.2+1942\. Including a build number helps developers and tools find
    the build logs for any version that was compiled.'
  prefs: []
  type: TYPE_NORMAL
- en: SemVer’s scheme also allows for *wildcard* version ranges (2.13.*). Since SemVer
    promises compatibility across minor and patch versions, builds should continue
    to work even as updated versions with bug fixes and new features are automatically
    pulled in.
  prefs: []
  type: TYPE_NORMAL
- en: Transitive Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Package management or build files show a project’s direct dependencies, but
    direct dependencies are only a subset of what build or packaging systems actually
    use. Dependencies usually depend on other libraries, which become *transitive
    dependencies*. A dependency report shows the fully resolved *dependency tree*
    (or *dependency graph*). Most build and packaging systems can produce dependency
    reports. Continuing the previous example, here’s the `gradle dependencies` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency tree shows the dependencies that the build system is actually
    using when it compiles the project. The report is several layers deep. Dependencies
    of dependencies of dependencies get pulled in, and so on. The `httpclient` library
    pulls in three transitive dependencies: `httpcore`, `commons-logging`, and `commons-codec`.
    The project does not depend directly on these libraries, but through `httpclient`,
    it does.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding transitive dependencies is a critical part of dependency management.
    Adding a single dependency seems like a small change, but if that library depends
    on 100 others, your code now depends on 101 libraries. Any change in any dependency
    can affect your program. Make sure you know how to get information like the dependency
    tree in our examples so you can debug dependency conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Hell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ask any software engineer about dependency hell, and you’ll get a tale of woe.
    Conflicting versions of the same library, or an incompatible library upgrade,
    can break builds and cause runtime failures. The most common dependency hell culprits
    are circular dependencies, diamond dependencies, and version conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous dependency report was simple. A more realistic report will show
    version conflicts, and give you a glimpse of dependency hell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This tree shows three direct dependencies: `annotations`, `zookeeper`, and
    `util`. The libraries all depend on other libraries; these are their transitive
    dependencies. Two versions of `slf4j-api` appear in the report. The `util` depends
    on `slf4j-api` version 1.7.21, but `zookeeper` depends on `slf4j-api` version
    1.6.1.'
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies form a *diamond dependency*, illustrated in [Figure 5-1](#figure5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](image_fi/501836c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: A diamond dependency'
  prefs: []
  type: TYPE_NORMAL
- en: 'A project can’t use two library versions simultaneously, so the build system
    must pick one. In a Gradle dependency report, version choices are shown with annotations
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `1.6.1 -> 1.7.21` means that `slf4j-api` was upgraded to 1.7.21 across the
    whole project to resolve the version conflict. Zookeeper might not work correctly
    with a different version of `slf4j-api`, especially since a related dependency,
    `slf4j-log4j12`, did not get upgraded. The upgrade *should* work, since Zookeeper
    dependency’s major version number remains unchanged (SemVer guarantees backward
    compatibility within the same major version). In reality, compatibility is aspirational.
    Projects often set version numbers without compatibility checks, and even automation
    can’t fully guarantee compatibility. Incompatible changes slip into minor or patch
    releases, wreaking havoc on your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Even nastier are *circular dependencies* (or *cyclic dependencies*), where a
    library transitively depends on itself (A depends on B, which depends on C, which
    depends on A, shown in [Figure 5-2](#figure5-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](image_fi/501836c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: A circular dependency'
  prefs: []
  type: TYPE_NORMAL
- en: 'Circular dependencies create a chicken and egg problem: upgrading one library
    breaks the other. Utility or helper projects commonly appear in circular dependencies.
    For example, a natural language processing (NLP) library depends on a utility
    library for a string parsing function; unwittingly, another developer adds the
    NLP library as a utility dependency for a word-stemming utility method.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Dependency Hell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will absolutely stumble into dependency hell. Dependencies are unavoidable,
    but every new dependency comes with a cost. Ask yourself if a dependency’s value
    outweighs its cost.
  prefs: []
  type: TYPE_NORMAL
- en: Do you really need the functionality?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well maintained is the dependency?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How easy would it be for you to fix the dependency if something went wrong?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How mature is the dependency?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How frequently does the dependency introduce backward-incompatible changes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well do you, your team, and your organization understand the dependency?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How easy is it to write the code yourself?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is the code licensed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the ratio of code you use versus code you don’t use in the dependency?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you do decide to add dependencies, use the following best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Isolate Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don’t have to leave dependency management to build and package systems.
    Dependent code can also be copied, vendored, or shaded. Copying code into your
    project trades dependency management automation for more isolation (stability).
    You’ll be able to pick and choose exactly what code you use, but you’ll have to
    manage the code copying.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers are raised on the DRY philosophy, which discourages code duplication.
    Be pragmatic; don’t be afraid to copy code if it helps you avoid a big or unstable
    dependency (and the software license allows it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Copying code works best on small, stable code fragments. Manually copying entire
    libraries has drawbacks: version history can be lost, and you must recopy code
    every time you update it. *Vendor* code using vendor tools to manage history and
    updates when embedding entire libraries in your codebase. Vendor folders contain
    complete library copies. Tools like git-subtree and `git-vendor` help manage vendor
    folders in your codebase. Some packaging systems, like Go, even have built-in
    support for vendor folders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency *shading* can also isolate dependencies. Shading automatically relocates
    a dependency into a different namespace to avoid conflicts: `some.package.space`
    becomes `shaded.some.package.space`. This is a friendly way to keep libraries
    from forcing their dependencies on applications. Shading comes from the Java ecosystem,
    but the concept applies broadly. Other languages like Rust use similar techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Shading is an advanced technique and should be used sparingly. Never expose
    a shaded dependency’s objects in public APIs; doing so means developers will have
    to create objects in the shaded package space (`shaded.some.package.space.Class`).
    Shading is meant to hide a dependency’s existence; creating an object that’s been
    shaded is tricky, and sometimes impossible, for library users. Also, beware that
    shaded dependencies can confuse developers since package names differ in the build
    artifact. We recommend only shading dependencies when you are creating a library
    with widely used dependencies that are likely to create conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Deliberately Add Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Explicitly declare as dependencies all libraries you use. Don’t use methods
    and classes from transitive dependencies, even if it seems to work. Libraries
    are free to change their dependencies even in patch-level version bumps. Your
    code will stop working if a transitive dependency that you depend on gets dropped
    during an upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: A project that depends only on the `httpclient` library (from the earlier example)
    should not explicitly use classes in `httpcore`, `commons-logging`, and `commons-codec`
    (`httpclient`’s dependencies); if it does, it should declare a direct dependency
    on the libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t rely solely on the IDE for dependency management. Declare your dependencies
    explicitly in build files. IDEs often store dependencies in their own project
    configurations, which build machinery doesn’t look at. Inconsistency between your
    IDE and build files will make code work in the IDE but not when actually building
    your code, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Pin Versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Explicitly set every dependency’s version number, a practice called *version
    pinning*. Unpinned versions will be decided by the build or package management
    system for you. Leaving your fate to the build system is a bad idea. Your code
    will destabilize when dependency versions change during consecutive builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a list of Go library dependencies with
    pinned versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For contrast, this snippet of Apache Airflow’s dependencies uses three different
    version management strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `requests-oauthlib` library is explicitly pinned to 1.1.0\. The `Flask-OAuthlib`
    dependency is set to any version greater than or equal to 0.9.1\. And the `oauthlib`
    library is extremely specific: 1.1.2 or newer, but not above 3.0.0, but also not
    2.0.3, 2.0.4, or 2.0.5\. Versions 2.0.3 to 2.0.5 are excluded due to known bugs
    or incompatibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Bounding the version range is a compromise between an unbounded range and a
    fully pinned version. The dependency resolution system is free to resolve conflicts
    and update dependencies, but exposure to breaking changes is limited. But any
    unpinned versions will pull in more than the latest bug fixes; they’ll pull in
    the latest bugs, behavior, or even incompatible changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you pin your direct dependencies, transitive dependencies might still
    have wildcards. Transitive dependency versions can be pinned by generating a complete
    manifest of all resolved dependencies and their versions. Dependency manifests
    go by many names: you freeze requirements in Python, generate *Gemfile.lock*s
    in Ruby, and create *Cargo.lock*s in Rust. Build systems use manifests to produce
    identical results on every execution. Manifests are regenerated explicitly by
    developers when they want to change a version. Committing manifests alongside
    the rest of your code allows you to explicitly track changes to any of the dependencies,
    giving you the opportunity to prevent potential problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Scope Dependencies Narrowly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dependency scope, discussed earlier, defines when in the build lifecycle a
    dependency is used. Scoping has a hierarchy: compile-time dependencies are used
    during runtime, but runtime dependencies are not used to compile code, only to
    run it. Test dependencies are only pulled in for test execution and are not necessary
    for normal use of the published code.'
  prefs: []
  type: TYPE_NORMAL
- en: Use the narrowest possible scope for each dependency. Declaring all dependencies
    with compile-time scoping will work but is bad practice. Narrow scoping will help
    avoid conflicts and reduce runtime binary sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Protect Yourself from Circular Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never introduce circular dependencies. Circular dependencies lead to strange
    build system behavior and deployment ordering problems. Builds will appear to
    work and then fail suddenly, and applications will have elusive and sporadic bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Protect yourself using build tools. Many build systems have built-in circular
    dependency detectors that will alert you when a cycle is detected. If your build
    system doesn’t protect against circular dependencies, there are usually plug-ins
    that can help.
  prefs: []
  type: TYPE_NORMAL
- en: Do’s and Don’ts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| **Do’s** | **Don’ts** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **DO** use semantic versioning.  | **DON’T** use Git hashes as version numbers.  |'
  prefs: []
  type: TYPE_TB
- en: '| **DO** pin dependency version ranges.  | **DON’T** add dependencies unless
    the value exceeds the cost.  |'
  prefs: []
  type: TYPE_TB
- en: '| **DO** use dependency report tools for transitive dependencies.  | **DON’T**
    use transitive dependencies directly.  |'
  prefs: []
  type: TYPE_TB
- en: '| **DO** be skeptical when adding new dependencies.  | **DON’T** introduce
    circular dependencies.  |'
  prefs: []
  type: TYPE_TB
- en: '| **DO** scope your dependencies.  |  |'
  prefs: []
  type: TYPE_TB
- en: Level Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem of dependency conflicts and incompatible changes is pervasive; the
    general term for it is *dependency hell* (and many ecosystems have their own versions—DLL
    hell, JAR hell, “Any time I have to touch pip”). Though dependency management
    is complex, there are not many books on the subject; ecosystem-specific discussions
    and explanations are plentiful online. For a historical perspective, take a look
    at the Wikipedia article on dependency hell and the references therein.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://semver.org/](https://semver.org/) for a compact and readable spec
    on semantic versioning. Python has a similar scheme, defined at [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/).
    Both of these versioning schemes are in heavy use and worth learning. There are
    many others, and it’s not uncommon to encounter artifacts using different versioning
    schemes within the same project. Following the Pareto principle, we don’t recommend
    you dig into version semantics too deep when you are starting out unless it’s
    an explicit part of your job or you need more information to solve a concrete
    problem. The contents of this chapter should be sufficient for most day-to-day
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the versioning concepts in this chapter apply to both libraries and
    service APIs. We talk more about API versioning in Chapter 11.
  prefs: []
  type: TYPE_NORMAL
