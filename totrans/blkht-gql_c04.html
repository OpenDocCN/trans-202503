<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 4: Reconnaissance</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c77cce49-9403-4fd1-99ba-33d115574b0c" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_71" title="71"/><a class="XrefDestination" id="4"/><span class="XrefDestination" id="xref-502840c04-001"/>4</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="reconnaissance"/><span class="XrefDestination" id="xref-502840c04-002"/>Reconnaissance</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">All security tests start with a <em>reconnaissance phase</em>. In this phase, we attempt to collect as much information as possible about our target. This information will prepare us to make informed decisions about how to attack the application and increase our chances of success.</p>
<p>You might be asking yourself, what is there to know about GraphQL, seeing as it’s just an API layer? You’ll learn that we can gather a lot of information, through experimentation and the use of specialized tooling, about the application running behind a GraphQL API, as well as the GraphQL implementation itself. While the GraphQL query structure is consistent across all GraphQL implementations, irrespective of the programming language they are written in, you will likely see differences in the available operations, fields, arguments, directives, security controls, responses to specially crafted queries, and so on.</p>
<p><span epub:type="pagebreak" id="Page_72" title="72"/>Here are a few key questions we should strive to answer during our reconnaissance phase: Does the web server even have a GraphQL API? On which endpoint is GraphQL configured to receive queries? What language is the GraphQL implementation written in? What implementation of GraphQL is running on the target server? Is the implementation known to be vulnerable to certain attacks? What types of defenses exist for the specific GraphQL implementation? What are some of the out-of-the-box default configuration settings of this implementation? Does the GraphQL server have any additional security protection layers in place? Being able to answer these questions will allow us to plan a more focused attack against our target server and uncover gaps in its defense.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Throughout this chapter, as well as the following ones, we will use the DVGA as our target vulnerable application. You should already have it running as part of the GraphQL security lab we built in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502840c04-0001"><a class="XrefDestination" id="DetectingGraphQL"/><span class="XrefDestination" id="xref-502840c04-003"/>Detecting GraphQL</h2>
<p class="BodyFirst">To detect GraphQL in a penetration test, it’s important to first familiarize yourself with the GraphQL server implementations that exist in the wild today. GraphQL has many implementations written in a variety of programming languages, each of which could have different default configurations or known weaknesses. <a href="#table4-1" id="tableanchor4-1">Table 4-1</a> lists several GraphQL implementations and the languages in which they are written.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-1">Table 4-1</a>: GraphQL Server Implementations and Their Programming Languages</p></figcaption>
<table border="1" id="table-502840c04-0001">
<thead>
<tr>
<td><b>Server implementation</b></td>
<td><b>Language</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Apollo</td>
<td>TypeScript</td>
</tr>
<tr>
<td>Graphene</td>
<td>Python</td>
</tr>
<tr>
<td>Yoga</td>
<td>TypeScript</td>
</tr>
<tr>
<td>Ariadne </td>
<td>Python</td>
</tr>
<tr>
<td>graphql-ruby </td>
<td>Ruby</td>
</tr>
<tr>
<td>graphql-php</td>
<td>PHP</td>
</tr>
<tr>
<td>graphql-go</td>
<td>Go</td>
</tr>
<tr>
<td>graphql-java</td>
<td>Java</td>
</tr>
<tr>
<td>Sangria</td>
<td>Scala</td>
</tr>
<tr>
<td>Juniper</td>
<td>Rust</td>
</tr>
<tr>
<td>HyperGraphQL</td>
<td>Java</td>
</tr>
<tr>
<td>Strawberry</td>
<td>Python</td>
</tr>
<tr>
<td>Tartiflette</td>
<td>Python</td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" id="Page_73" title="73"/>These are some of the most popular implementations in use today, as well as more niche implementations, such as Sangria for Scala, Juniper for Rust, and HyperGraphQL for Java. Later in this chapter, we will discuss how to distinguish between them during a penetration test.</p>
<p>Detection of GraphQL APIs can be done in several ways: either manually, which is typically harder to scale if you have more than a few hosts on a network, or automatically, using various web scanners. The advantage of using web-scanning tools is that they are scalable. They are threaded, and often have the ability to read external files as program input, such as text files with a list of hostnames to scan. These tools already have the logic to detect web interfaces built into them, and using scripting languages (such as Bash or Python), you can programmatically run them against hundreds of IP addresses or subdomains. In this chapter, we will use popular scanners such as Nmap, as well as GraphQL-oriented scanning tools, such as Graphw00f, for reconnaissance.</p>
<h3 id="h2-502840c04-0001"><a class="XrefDestination" id="CommonGraphQLEndpoints"/><span class="XrefDestination" id="xref-502840c04-004"/>Common Endpoints</h3>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, we highlighted some of the differences between REST and GraphQL APIs. One of these differences, relevant to the reconnaissance phase, is that a GraphQL API endpoint is typically static, and most commonly <em>/graphql</em>.</p>
<p>However, although <em>/graphql</em> is often the default GraphQL endpoint, the GraphQL implementation can be reconfigured to use a completely different path. In those cases, what can we do to detect it? One way is to manually attempt a few common alternative paths to the GraphQL API, such as versioned endpoints:</p>
<ol class="none">
<li><em>/v1/graphql</em></li>
<li><em>/v2/graphql</em></li>
<li><em>/v3/graphql</em></li>
</ol>
<p>You’ll typically see these versioned API endpoints when the application needs to support multiple versions of its API, either for backward compatibility or for the introduction of a new feature in a way that doesn’t conflict with the stable API version that customers might still be using.</p>
<p>Another way to find a GraphQL implementation is through IDEs, such as GraphQL Playground or GraphiQL Explorer, which we used in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> to experiment with GraphQL queries. When either of these interfaces is enabled, it often uses an additional, dedicated endpoint. This means GraphQL can potentially exist under the following endpoints as well:</p>
<ol class="none">
<li><em>/graphiql</em></li>
<li><em>/playground</em></li>
</ol>
<p>If these endpoints happen to also be versioned, they may have a version number prepended to their path, such as <em>/v1/graphiql</em>, <em>/v2/graphiql</em>, <em>/v1/playground</em>, <em>/v2/playground</em>, and so on.</p>
<p><span epub:type="pagebreak" id="Page_74" title="74"/><a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a> shows how Graphene, a Python-based implementation of GraphQL, can expose two endpoints, one for GraphQL, and the other for GraphiQL Explorer, which is built into Graphene:</p>
<pre><code>app.add_url_rule('/graphql', view_func=GraphQLView.as_view(
  'graphql',
  schema=schema
))

app.add_url_rule('/graphiql', view_func=GraphQLView.as_view(
  'graphiql',
  schema = schema,
  graphiql = True
))</code></pre>
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: Graphene’s endpoint definition</p>
<p>Graphene defines the <em>/graphql</em> endpoint as its main GraphQL query endpoint. It then defines <em>/graphiql</em> as a second endpoint that GraphiQL Explorer will query against. Lastly, it enables the GraphiQL Explorer interface. The GraphQL server will render the IDE to the client when it browses to the <em>/graphiql</em> endpoint.</p>
<p>Keep in mind that each endpoint could have different security settings. One could be stricter than the other, for example. When you find two endpoints serving GraphQL queries on the same target host, you will want to test them separately.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	In this book’s GitHub repository, you can find a more comprehensive list of common GraphQL endpoints: <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch04/common-graphql-endpoints.txt">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch04/common-graphql-endpoints.txt</a>. You can use this as a wordlist file when you need to scan for GraphQL servers during a penetration test or a bug bounty hunt.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The most important takeaway here is that, while the GraphQL endpoint is typically located at a predictable path, the developer can still customize it to fit their needs, perhaps in an attempt to hide it from curious eyes or to simply conform to internal application deployment standards.</p>
<h3 id="h2-502840c04-0002"><a class="XrefDestination" id="CommonGraphQLResponses"/><span class="XrefDestination" id="xref-502840c04-005"/>Common Responses</h3>
<p class="BodyFirst">Now that you have an idea of the endpoints from which GraphQL typically receives queries, the next step is to learn how GraphQL APIs respond to packets. GraphQL is fairly easy to identify on a network. This is particularly helpful whenever you are performing a zero-knowledge penetration test or bug bounty hunt.</p>
<p>The GraphQL specification describes how a query response structure should be formatted. This allows API consumers to expect a predetermined format when they parse the GraphQL response. The following excerpt from the GraphQL specification describes how the response to a query should look:</p>
<blockquote class="blockquote">
<p class="Blockquote">If the operation is a query, the result of the operation is the result of executing the operation’s top-level selection set with the query root operation type.</p>
<p class="Blockquote"><span epub:type="pagebreak" id="Page_75" title="75"/>An initial value may be provided when executing a query operation:</p>
<p class="Blockquote"><code>ExecuteQuery(</code><var>query</var><code>, </code><var>schema</var><code>, </code><var>variableValues</var><code>, </code><var>initialValue</var><code>)</code></p>
<ol class="decimal">
<li value="1">Let <code>queryType</code> be the root <code>Query</code> type in the schema.</li>
<li value="2">Assert: <code>queryType</code> is an <code>Object</code> type.</li>
<li value="3">Let <code>selectionSet</code> be the top-level selection set in the query.</li>
<li value="4">Let <code>data</code> be the result of running <code>ExecuteSelectionSet(selectionSet, queryType, initialValue, variableValues)</code> normally (allowing parallelization).</li>
<li value="5">Let <code>errors</code> be any field errors produced while executing the selection set.</li>
<li value="6">Return an unordered map containing data and errors.</li>
</ol>
</blockquote>
<p>In practice, this means a GraphQL API will return a <code>data</code> JSON field when there is a result to return to a client’s query. It will also return an <code>errors</code> JSON field whenever errors occur during the execution of a client query.</p>
<p>Knowing these two pieces of information ahead of time is valuable. To put it simply, we now have two conditions that a response must meet before we can say that it came from a GraphQL API:</p>
<ol class="decimal">
<li value="1">A valid query response should <em>always</em> have the <code>data</code> field populated with query response information.</li>
<li value="2">An invalid query response should<em> always</em> have the <code>errors</code> field populated with information about what went wrong.</li>
</ol>
<p>Now we can leverage these as part of scanning and detection logic to automate the discovery of GraphQL servers on a network. All we need to do is send a valid or malformed query and observe the response we receive.</p>
<p>Let’s run a simple GraphQL query using the HTTP POST method against the DVGA to see these response structures in action. Open the Altair GraphQL client and ensure that the address bar has the <em>http://localhost:5013/graphql</em> address set; then run the following query by entering it in Altair’s left pane:</p>
<pre><code><b>query {</b>
<b>  pastes {</b>
<b>    id</b>
<b>  }</b>
<b>}</b></code></pre>
<p>Next, click the play button to send the query to the GraphQL server. This should return the <code>id</code> field of the <code>pastes</code> object. You should be able to see a response similar to the following output:</p>
<pre><code> "data": {
     "pastes": [
      {
<span epub:type="pagebreak" id="Page_76" title="76"/>         "id": "1"
      }
    ]
  }</code></pre>
<p>As you can see, GraphQL returns the query response as part of the <code>data</code> JSON field, exactly as described in the GraphQL specification. We get the <code>pastes</code> object and the <code>id</code> field we specified in the query. Don’t worry if you see a different <code>id</code> string returned in your lab than the one shown here; this is expected.</p>
<p>Now, let’s run another query to explore what happens when an invalid query is sent to GraphQL. This will demonstrate that the <code>errors</code> JSON field is returned by the GraphQL server when it encounters issues during query execution. The following query is malformed, and GraphQL won’t be able to process it. Run it in Altair and observe the response:</p>
<pre><code><b>query {</b>
<b>  badfield {</b>
<b>    id</b>
<b>  }</b>
<b>}</b></code></pre>
<p>Notice that we specify a top-level field with the name of <code>badfield</code>. Because this field does not exist, the GraphQL server can’t fulfill the query. The GraphQL response can be seen here:</p>
<pre><code>{
   "errors": [
    {
       "message": "Cannot query field \"badfield\" on type \"Query\".",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ]
    },
  ]
}</code></pre>
<p>As you can see, the GraphQL server isn’t able to process our query successfully. It returns a response containing the <code>errors</code> JSON field. The <code>message</code> JSON field indicates to us that the server couldn’t query the field named <code>badfield</code>, because it does not exist in the GraphQL schema.</p>
<h3 id="h2-502840c04-0003"><a class="XrefDestination" id="DetectingGraphQLbyUsingNmapScans"/><span class="XrefDestination" id="xref-502840c04-006"/>Nmap Scans</h3>
<p class="BodyFirst">Imagine that you need to conduct a penetration test against a network containing thousands of hosts; it would be fairly difficult to manually go through each host to find ones that are potentially serving interesting content, such as an API or a vulnerable commercial application. In these cases, penetration testers often use web application scanners or custom scripts to <span epub:type="pagebreak" id="Page_77" title="77"/>automatically grab information from the hosts. For example, information such as the <code>&lt;title&gt;</code> HyperText Markup Language (HTML) tag, the entire <code>&lt;body&gt;</code> tag, and even the <code>server</code> HTTP response header could all hint at specific applications that the remote server is running.</p>
<p>It’s important to note that web applications may not always have a user interface, meaning they may not serve any HTML content related to the application or even expose HTTP headers by which we can detect them. They will often act as standalone API servers that expose data only through designated APIs. So, how can we detect GraphQL in those cases? Luckily, GraphQL APIs often return predictable responses under certain conditions, such as the HTTP method in use or the payload sent to the server. <a href="#listing4-2" id="listinganchor4-2">Listing 4-2</a> shows a common GraphQL response returned when a client makes a GET request.</p>
<pre><code># <b>curl -X GET http://localhost:5013/graphql</b>

{"errors":[{"message":"Must provide query string."}]}</code></pre>
<p class="CodeListingCaption"><a id="listing4-2">Listing 4-2</a>: A GraphQL response to an HTTP GET request</p>
<p>The string <code>Must provide query string</code> is often used in GraphQL implementations, such as Python- and Node.js-based ones. (Keep in mind that GET-based queries are often not supported by GraphQL servers. Rest assured: we have many other ways of detecting GraphQL should we run into such a situation.)</p>
<p>With this information, we now have the ability to automate a scan and pick up any other GraphQL servers that may exist on a network. <a href="#listing4-3" id="listinganchor4-3">Listing 4-3</a> shows how to do this with Nmap, using the <em>http-grep </em>NSE script, which uses pattern matching to look for keywords in a given web page.</p>
<pre><code># <b>nmap -p 5013 -sV --script=http-grep</b>
<b>--script-args='match="Must provide query string", </b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span><b> http-grep.url="/graphql"' localhost </b><span aria-label="annotation2" class="CodeAnnotationCode">❷</span>

PORT     STATE SERVICE VERSION
5013/tcp open  http    Werkzeug httpd
| http-grep:
|   (1) http://localhost:5013/graphql:
|       (1) User Pattern 1:
|       + Must provide query string</code></pre>
<p class="CodeListingCaption"><a id="listing4-3">Listing 4-3</a>: A GraphQL response to word-matching using Nmap’s <em>http-grep</em></p>
<p>At <span aria-label="annotation1" class="CodeAnnotation">❶</span> we specify a script argument to <em>http-grep</em> called <code>match</code> with a value of <code>Must</code> <code>provide</code> <code>query</code> <code>string</code> (the message we received in our GraphQL response). At <span aria-label="annotation2" class="CodeAnnotation">❷</span> we define another argument, called <code>http-grep.url</code>, with a value of <code>/graphql</code>, which instructs Nmap to search a specific page within the web application. Under the hood, Nmap will make an HTTP GET request to <code>localhost</code> and use the argument string value we defined as the pattern for its search within the text it extracts from the web server’s response. In its output, Nmap shows that a pattern was found on the web page and indicates the string for which it found a match.</p>
<p><span epub:type="pagebreak" id="Page_78" title="78"/>You may have noticed that we’re passing a specific port to Nmap (<code>-p</code>)—namely, port <code>5013</code>. Like any web server, GraphQL servers could run on any port, but a few are quite common, such as 80–89, 443, 4000–4005, 8443, 8000, and 8080. We recommend scanning both common and uncommon port ranges when possible.</p>
<h3 id="h2-502840c04-0004"><a class="XrefDestination" id="DetectingGraphQLbyIts__typenameField"/><span class="XrefDestination" id="xref-502840c04-007"/>The __typename Field</h3>
<p class="BodyFirst">So far, we’ve known exactly which fields to ask for in our queries, such as <code>pastes</code> with a selection set of <code>id</code>, as we requested earlier. You might be wondering, what if we don’t know what fields exist on the GraphQL API? How can we go about identifying GraphQL without this information? Luckily, there is a quick way to query GraphQL and return a valid response without knowing anything about the application’s schema.</p>
<p><em>Meta-fields</em> are built-in fields that GraphQL APIs expose to clients. One example is <code>__schema</code> (part of introspection in GraphQL). Another example of a meta-field is <code>__typename</code>. When used, it returns the name of the object type being queried. <a href="#listing4-4" id="listinganchor4-4">Listing 4-4</a> shows a query that uses this meta-field.</p>
<pre><code>query {
  pastes {
    __typename
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-4">Listing 4-4</a>: A GraphQL query with the <code>__typename</code> meta-field</p>
<p>When you run this query with Altair, the response will be the name of the <code>pastes</code> object type:</p>
<pre><code>  "data": {
    "pastes": [
      {
        "__typename": "PasteObject"
      }
    ]
  }</code></pre>
<p>As you can see, GraphQL tells us that the <code>pastes</code> object’s type name is <code>PasteObject</code>. The real hack here is that the <code>__typename</code> meta-field can be used against the query root type as well, as shown in <a href="#listing4-5" id="listinganchor4-5">Listing 4-5</a>.</p>
<pre><code>query {
  __typename
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-5">Listing 4-5</a>: A GraphQL meta-field used with the query root type</p>
<p>This query uses <code>__typename</code> to describe the query root type and will work against pretty much any GraphQL implementation, since <code>__typename</code> is part of the official specification.</p>
<p><span epub:type="pagebreak" id="Page_79" title="79"/>When you’re attempting to query GraphQL from the command line, GraphQL servers expect a certain request structure. For HTTP GET-based queries, a request should have the following HTTP query parameters:</p>
<ul class="disc">
<li><code>query</code> for the GraphQL query (mandatory parameter).</li>
<li><code>operationName</code> for the operation name, used when multiple queries are sent in a single document. This parameter tells the GraphQL server which specific operation to run when more than one is present (optional parameter).</li>
<li><code>variables</code> for query variables (optional parameter).</li>
</ul>
<p>For HTTP POST-based queries, the same parameters should be passed in the HTTP body in JSON.</p>
<p>When GraphQL servers accept queries using GET, you can pass the <code>query</code> parameter along with the GraphQL query (in this case, the query <code>{__typename}</code>) by using shorthand syntax. With this in mind, we can automate the detection of GraphQL by using Nmap fairly easily. <a href="#listing4-6" id="listinganchor4-6">Listing 4-6</a> shows how to run a <code>__typename</code> query with Nmap.</p>
<pre><code># <b>nmap -p 5013 -sV --script=http-grep --script-args='match="__typename",</b>
<b>http-grep.url="/graphql?query=\{__typename\}"' localhost</b>

PORT     STATE SERVICE VERSION
5013/tcp open  http    Werkzeug httpd
| http-grep:
|   (1) http://localhost:5013/graphql?query=\{__typename\}:
|     (1) User Pattern 1:
|_      + __typename</code></pre>
<p class="CodeListingCaption"><a id="listing4-6">Listing 4-6</a>: Detecting GraphQL by using GET-based queries with Nmap</p>
<p>In this example, the Nmap script <em>http-grep</em> uses the GET method under the hood to do its work.</p>
<p>If you have more than a handful of hosts to scan, you may want to leverage Nmap’s <code>-iL</code> flag to point to a file that contains a list of hostnames, as shown in <a href="#listing4-7" id="listinganchor4-7">Listing 4-7</a>.</p>
<pre><code># <b>nmap -p 5013 -iL hosts.txt -sV --script=http-grep</b>
<b>--script-args='match="__typename", http-grep.url="/graphql?query=\{__typename\}"'</b></code></pre>
<p class="CodeListingCaption"><a id="listing4-7">Listing 4-7</a>: Scanning multiple targets defined in a file with Nmap</p>
<p>The <em>hosts.txt</em> file in this example would contain IP addresses or Domain Name System (DNS) hostnames listed on separate lines.</p>
<p>If the GraphQL server does not support GET-based queries, we can use cURL and the <code>__typename</code> field to make a POST request to detect GraphQL, as shown in <a href="#listing4-8" id="listinganchor4-8">Listing 4-8</a>.</p>
<pre><code># <b>curl -X POST http://localhost:5013/graphql -d '{"query":"{__typename }"}'</b>
<b>-H "Content-Type: application/json"</b></code></pre>
<p class="CodeListingCaption"><a id="listing4-8">Listing 4-8</a>: Sending a POST-based query using cURL</p>
<p><span epub:type="pagebreak" id="Page_80" title="80"/>To use this detection method against a list of hosts, you can use Bash scripting, as shown in <a href="#listing4-9" id="listinganchor4-9">Listing 4-9</a>.</p>
<pre><code># <b>for host in $(cat hosts.txt); do</b>
<b>     curl -X POST "$host" -d '{"query":"{__typename }"}' -H "Content-Type: application/json"</b>
<b>done</b></code></pre>
<p class="CodeListingCaption"><a id="listing4-9">Listing 4-9</a>: A Bash script to automate a POST-based GraphQL detection using cURL</p>
<p>The <em>hosts.txt</em> file in this example would contain a list of full target URLs on separate lines (including their protocol schemes, domains, ports, and endpoints).</p>
<h3 id="h2-502840c04-0005"><a class="XrefDestination" id="DetectingGraphQLwithGraphw00f"/><span class="XrefDestination" id="xref-502840c04-008"/>Graphw00f</h3>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, we briefly discussed Graphw00f, a GraphQL tool based on Python for detecting GraphQL and performing implementation-level fingerprinting. In this section, we will use it to detect DVGA in our lab, walking you through how it does its detection magic.</p>
<p>We mentioned earlier in this chapter that GraphQL servers are found at the endpoint <em>/graphql</em> by default. When this is not the case, we might need an automated way to iterate through known endpoints in order to figure out where queries are served from. Graphw00f allows you to specify a custom list of endpoints when running a scan. If you don’t provide a list, Graphw00f will use its hardcoded list of common endpoints whenever it is tasked with detecting GraphQL, as shown in <a href="#listing4-10" id="listinganchor4-10">Listing 4-10</a>.</p>
<pre><code>def possible_graphql_paths():
    return [
        '/graphql',
<var class="bold">        </var><var>--snip--</var>
        '/console',
        '/playground',
        '/gql',
        '/query',
<var>        --snip--</var>
    ]</code></pre>
<p class="CodeListingCaption"><a id="listing4-10">Listing 4-10</a>: A list of common GraphQL endpoints in Graphw00f’s source code</p>
<p>To see Graphw00f in action, open your terminal and execute the command in <a href="#listing4-11" id="listinganchor4-11">Listing 4-11</a>. We use command line parameters <code>-t</code> (target) and <code>-d</code> (detection). The <code>-t</code> flag in this case will be the remote URL <em>http://localhost:5013</em>, and the <code>-d</code> flag will turn on detection mode, which indicates to Graphw00f that it should run a GraphQL detection check against the target URL. If you have questions about Graphw00f’s arguments, use the <code>-h</code> flag to read more about its options.</p>
<pre><code># <b>cd ~/graphw00f</b>
# <b>python3 main.py -d -t http://localhost:5013</b>

                      graphw00f
          The fingerprinting tool for GraphQL

<span epub:type="pagebreak" id="Page_81" title="81"/> [*] Checking http://localhost:5013/
 [*] Checking http://localhost:5013/graphql
 [!] Found GraphQL at http://localhost:5013/graphql</code></pre>
<p class="CodeListingCaption"><a id="listing4-11">Listing 4-11</a>: A GraphQL detection with Graphw00f</p>
<p>Run in detect mode, Graphw00f iterates through various web paths. It checks for the existence of GraphQL in the main web root folder and the <em>/graphql</em> folder. Then it signals to us that it found GraphQL under<em> /graphql </em>based on the HTTP response heuristics we discussed earlier.</p>
<p>To use your own list of endpoints, you can pass the <code>-w</code> (wordlist) flag and point it at a file containing your endpoints, as shown in <a href="#listing4-12" id="listinganchor4-12">Listing 4-12</a>.</p>
<pre><code># <b>cat wordlist.txt</b>

/app/graphql
/dev/graphql
/v5/graphql

# <b>python3 main.py -d -t http://localhost:5013 -w wordlist.txt</b>

[*] Checking http://localhost:5013/app/graphql
[*] Checking http://localhost:5013/dev/graphql
[*] Checking http://localhost:5013/v5/graphql</code></pre>
<p class="CodeListingCaption"><a id="listing4-12">Listing 4-12</a>: Using a custom endpoint list with Graphw00f</p>
<h2 id="h1-502840c04-0002"><a class="XrefDestination" id="DetectingGraphiQLExplorerandGraphQLPlayground"/><span class="XrefDestination" id="xref-502840c04-009"/>Detecting GraphiQL Explorer and GraphQL Playground</h2>
<p class="BodyFirst">The GraphiQL Explorer and GraphQL Playground IDEs are built using the JavaScript library React. Yet when performing reconnaissance, we will often rely on tools that are incapable of rendering web pages containing JavaScript, such as command line HTTP clients like cURL or web application scanners like Nikto. In the process, we might miss interesting web interfaces.</p>
<p>In general, you’ll find it beneficial to look for any signs of web interfaces available on the network, such as administration, debugging, or configuration panels, all of which are great candidates to hack. These panels tend to be data rich and often become a way to pivot to other networks or to escalate privileges. They also tend to be far less hardened than publicly facing applications. Companies assume that the external space (the internet) is riskier than the internal space (the corporate network). As such, they often have guidelines for securing publicly facing servers and applications via aggressive patching policies, configuration reviews, and frequent vulnerability scanning. Unfortunately, internal applications rarely get the same treatment, which often makes them an easier target for hackers.</p>
<p>An interesting and often overlooked technique to scan for graphical web interfaces is through the use of tools such as headless browsers. <em>Headless browsers</em> are fully functional command line web browsers that the user can program for a variety of purposes, such as retrieving page <span epub:type="pagebreak" id="Page_82" title="82"/>contents, submitting forms, or simulating real user behavior on a web page. For example, the headless browsers Selenium and PhantomJS can be handy when you need to render web pages containing JavaScript code.</p>
<p>One security tool in particular has incorporated a headless browser to solve this gap:<em> EyeWitness</em>. This web scanner is capable of taking screenshots of web pages by leveraging the Selenium headless browser driver engine behind the scenes. EyeWitness then generates a nice report, along with a screen capture of the page.</p>
<h3 id="h2-502840c04-0006"><a class="XrefDestination" id="ScanningforGraphicalInterfaceswithEyeWitness"/><span class="XrefDestination" id="xref-502840c04-010"/>Scanning for Graphical Interfaces with EyeWitness</h3>
<p class="BodyFirst">Since the two GraphQL IDEs use JavaScript code, we need a capable scanner to help us identify them when we perform network-wide scans. Let’s use EyeWitness to identify these graphical interfaces.</p>
<p>EyeWitness offers many options for customizing its scanner behavior, and you can see them by running the tool with the <code>-h</code> option. To detect GraphQL IDE panels, we’ll use the <code>--web</code> option, which will attempt a screen capture of the scanned site with the headless browser engine, together with the <code>--single</code> option, which is suitable when you need to scan only a single target URL. We will then use the <code>-d</code> flag to indicate to EyeWitness the folder in which it should dump the report (in this case, the <em>dvga-report</em> folder). <a href="#listing4-13" id="listinganchor4-13">Listing 4-13</a> puts everything together.</p>
<pre><code># <b>eyewitness --web --single http://localhost:5013/graphiql -d dvga-report</b>

Attempting to screenshot http://localhost:5013/graphiql

 [*] Done! Report written in the dvga-report folder!
 Would you like to open the report now? [Y/n]</code></pre>
<p class="CodeListingCaption"><a id="listing4-13">Listing 4-13</a>: The runtime output of EyeWitness</p>
<p>In the output, EyeWitness indicates that it saved the collected web page source files in the <em>dvga-report</em> folder and asks us whether to open the report. Press Y and ENTER to open a web browser displaying the HTML report, including the screenshot it took during the scan. <a href="#figure4-1" id="figureanchor4-1">Figure 4-1</a> shows the report.</p>
<figure>
<img alt="" class="" src="image_fi/502840c04/f04001.png"/>
<figcaption><p><a id="figure4-1">Figure 4-1</a>: An HTML report produced by EyeWitness</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_83" title="83"/>Additionally, the <em>dvga-report</em> will contain several folders, as shown here:</p>
<pre><code># <b>ls -l dvga-report/</b>
total 112
-rw-r--r-- 1 kali kali 95957 Dec 15 15:19 jquery.min.js
-rw-r--r-- 1 kali kali  2356 Feb 11 15:10 report.html
drwxr-xr-x 2 kali kali  4096 Feb 11 15:09 screens
drwxr-xr-x 2 kali kali  4096 Feb 11 15:09 source
-rw-r--r-- 1 kali kali   684 Feb 11 15:09 style.css</code></pre>
<p>The <em>report.html</em> file includes information about the target, such as the HTTP response headers it sent back to the client, a screen capture of the application running on the target, and a link to the web page’s source code. While you can visually identify the GraphiQL IDE by using the screen capture taken by EyeWitness, you can also confirm your finding by searching the <em>source</em> folder, where the source code files reside. Run the command shown in <a href="#listing4-14" id="listinganchor4-14">Listing 4-14</a> to search for any GraphiQL Explorer or GraphQL Playground strings within the source code.</p>
<pre><code># <b>grep -Hnio "graphiql|graphql-playground" dvga-report/source/*</b>
source/http.localhost.5013.graphiql.txt:18:graphiql
source/http.localhost.5013.graphiql.txt:18:graphiql
source/http.localhost.5013.graphiql.txt:18:graphiql</code></pre>
<p class="CodeListingCaption"><a id="listing4-14">Listing 4-14</a>: Keyword matches in the web page source code</p>
<p>Let’s break down the command to explain what’s happening here. We run a case-insensitive search using <code>grep</code> by passing it the <code>i</code> flag to find any instances of the words <em>graphql</em> or <em>graphql-playground</em> in the <em>source</em> folder. Using the <code>-H</code> flag, we tell <code>grep</code> to print the names of files containing any pattern matches. The <code>-n</code> flag indicates the line number at which the match is located (in this case, 18). The <code>-o</code> flag prints only the parts of matching lines that yielded positive results. As you can see, the search found multiple instances of the string <em>graphiql </em>at line number 18.</p>
<p>EyeWitness can run the same type of scan against a list of URLs, as opposed to a single URL, using the <code>-f</code> (file) flag. When you use this flag, EyeWitness will expect a text file containing a list of target URLs to scan. <a href="#listing4-15" id="listinganchor4-15">Listing 4-15</a> shows how to write a single URL (<em>http://localhost:5013/graphiql</em>) to a text file (<em>urls.txt</em>) and pass it on to EyeWitness as its custom URL list.</p>
<pre><code># <b>echo 'http://localhost:5013/graphiql' &gt; urls.txt</b>
# <b>eyewitness --web -f urls.txt -d dvga-report</b>

Starting Web Requests (1 Hosts)
Attempting to screenshot http://localhost:5013/graphiql
Finished in 8 seconds

[*] Done! Report written in the dvga-report folder!</code></pre>
<p class="CodeListingCaption"><a id="listing4-15">Listing 4-15</a>: Scanning multiple URLs with EyeWitness</p>
<p><span epub:type="pagebreak" id="Page_84" title="84"/>EyeWitness iterates over the URLs specified in the file, scans them, and saves its output into the <em>dvga-report</em> folder for further inspection.</p>
<p>In this example, we used a file that contains only a single URL. Often, you may want to search for any additional web paths beyond the <em>/graphql</em> endpoint to check whether GraphQL lives in an alternative location, particularly one that’s obscure. You could create a list of URLs to use with EyeWitness in multiple ways. The first option is to use the list of common GraphQL endpoints mentioned in <span class="xref" itemid="xref_target_“Common Endpoints” on page 73">“Common Endpoints” on page 73</span>.</p>
<p>Alternatively, use one of Kali’s built-in directory wordlists, located at <em>/usr/share/wordlists</em>. One such example is the <em>dirbuster</em> wordlist. EyeWitness needs full URLs, and this wordlist contains only web paths, so we’d first need to format it using a Bash script, as shown in <a href="#listing4-16" id="listinganchor4-16">Listing 4-16</a>.</p>
<pre><code># <b>for i in $(cat /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt);</b>
<b>do echo http://localhost:5013/$i &gt;&gt; urls.txt; done</b>

#<b> cat urls.txt</b>

http://localhost:5013/api
http://localhost:5013/apis
http://localhost:5013/apidocs
http://localhost:5013/apilist</code></pre>
<p class="CodeListingCaption"><a id="listing4-16">Listing 4-16</a>: Using Bash and a directory wordlist to build a list of URLs</p>
<p>This Bash <code>for</code> loop ensures that the directories in the wordlist <em>directory-list-2.3-small.txt</em> are appended to our target host (<em>http://localhost:5013</em>) so EyeWitness can use them in its scan. All that’s left is to run EyeWitness with our new wordlist file, <em>urls.txt</em>.</p>
<h3 id="h2-502840c04-0007"><a class="XrefDestination" id="AttemptingaQueryUsingGraphicalClients"/><span class="XrefDestination" id="xref-502840c04-011"/>Attempting a Query Using Graphical Clients</h3>
<p class="BodyFirst">Finding instances of GraphiQL Explorer or GraphQL Playground in a penetration test doesn’t guarantee that the GraphQL API itself will allow you to make unauthorized queries. Because both GraphiQL Explorer and GraphQL Playground are simply frontend interfaces to a GraphQL API, they are effectively HTTP clients that interact with a GraphQL server.</p>
<p>In some cases, these graphical interfaces might fail to query the API for multiple reasons. An authentication or authorization layer might be implemented in the GraphQL API that prevents unauthorized queries. The API might also restrict queries based on client properties, such as geographical location or an IP address–based allow list. Client-side mitigations could also prevent clients from running queries through GraphiQL Explorer or GraphQL Playground.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The specification doesn’t describe how to implement security measures in GraphQL or whether authorization and authentication should exist at the GraphQL layer. <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> covers how to identify these mechanisms when they are implemented in GraphQL and how to test them in black-box penetration tests.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" id="Page_85" title="85"/>To confirm that we can use the interface to query the GraphQL server, we will need to send some form of an unauthenticated GraphQL query. The query must be one that will work on any GraphQL API. Think of this query as a way to confirm that the remote GraphQL API is accepting unauthenticated queries from clients. We might call it a <em>canary</em> <em>GraphQL query</em>.</p>
<p>Open the Firefox web browser in your lab machine and navigate to <b><i>http://localhost:5013/</i></b> to access the DVGA. You should see the DVGA’s main page. Next, browse to the GraphiQL Explorer panel we discovered earlier at <em>http://localhost:5013/graphiql</em>. You will notice that we get an immediate error, indicating that our access was rejected, with the message <code>400</code> <code>Bad</code> <code>Request:</code> <code>GraphiQL</code> <code>Access</code> <code>Rejected</code>, as shown in <a href="#figure4-2" id="figureanchor4-2">Figure 4-2</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c04/f04002.png"/>
<figcaption><p><a id="figure4-2">Figure 4-2</a>: The GraphiQL Explorer rejecting client access</p></figcaption>
</figure>
<p>As hackers, it’s important to look at how things work under the hood. Click the <b>Docs</b> button located at the top right of the window. You should see an error message, <code>No Schema Available</code>. This error means that GraphiQL Explorer wasn’t able to retrieve schema information from the API. Because GraphiQL Explorer automatically sends an introspection query to the GraphQL API to populate the documentation section with schema information on every page load, it relies on this documentation being available.</p>
<p>You can see this behavior by using the Developer Tools in Firefox. Press SHIFT-F9 or right-click anywhere in the web page and select <b>Inspect Element</b> to open the Developer Tools console. Click the <b>Network</b> tab; then reload the page by pressing F5.</p>
<p>You should be able to see a POST request sent to the <em>/graphiql </em>endpoint. <a href="#figure4-3" id="figureanchor4-3">Figure 4-3</a> shows this introspection query.</p>
<span epub:type="pagebreak" id="Page_86" title="86"/><figure>
<img alt="" class="keyline" src="image_fi/502840c04/f04003.png"/>
<figcaption><p><a id="figure4-3">Figure 4-3</a>: A GraphiQL Explorer introspection query shown in Firefox Developer Tools</p></figcaption>
</figure>
<p>If the introspection query was successfully sent, what could possibly be rejecting our access to GraphiQL Explorer? Let’s continue to explore the Developer Tools in Firefox for clues. Click the <b>Storage</b> tab, shown in <a href="#figure4-4" id="figureanchor4-4">Figure 4-4</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c04/f04004.png"/>
<figcaption><p><a id="figure4-4">Figure 4-4</a>: The Developer Tools Storage tab in Firefox</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_87" title="87"/>The Storage tab gives us a view of the HTTP cookies that were set up by the application, as well as access to the browser’s local and session storage. On the left pane, click the <b>Cookies</b> drop-down menu and select <b>http://localhost:5013</b> to see the specific cookies for the domain, as shown in <a href="#figure4-5" id="figureanchor4-5">Figure 4-5</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c04/f04005.png"/>
<figcaption><p><a id="figure4-5">Figure 4-5</a>: HTTP cookies</p></figcaption>
</figure>
<p>You’ll notice that, in the right pane, we have two keys set in our HTTP cookies: <code>env</code> and <code>session</code>. The <code>env</code> key in particular is interesting, because it appears to have the string <code>graphiql:disable</code> set as its value. As hackers, this should ring a bell or two. Is it possible that this cookie value is responsible for GraphiQL Explorer’s denying access? We can find out by tampering with its value.</p>
<p>Double-click the text <code>graphiql:disable</code>, which will allow you to modify it; then simply remove <code>disable</code> and replace it with <code class="bold">enable</code>. Next, refresh the web page. You’ll notice that we no longer see the rejection message in GraphiQL Explorer. To confirm that tampering with the cookie actually works, attempt to run a GraphQL query. You should be able to get a response from the GraphQL API! This is an example of a weak client-side security control that can easily be circumvented.</p>
<p>Developers often create web applications with the mindset that clients are to be trusted, but not everyone will play by the rules. Threat actors who are interested in finding loopholes will tamper with applications and attempt to defeat any countermeasures in place. It’s important to remember that anything an attacker can directly control can potentially be circumvented. Yet controls implemented on the client are not a rare thing to see; you may find applications implementing input validation or file upload validation only on the client side. These can often be bypassed. In <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, you’ll learn more about defeating GraphQL authorization and authentication mechanisms.</p>
<h2 id="h1-502840c04-0003"><a class="XrefDestination" id="QueryingGraphQLbyUsingIntrospection"/><span class="XrefDestination" id="xref-502840c04-012"/>Querying GraphQL by Using Introspection</h2>
<p class="BodyFirst">Introspection is one of GraphQL’s key features, as it provides information about the various types and fields the GraphQL schema supports. A self-documenting API is very useful for anyone who needs to consume it, such as third-party businesses or other clients.</p>
<p><span epub:type="pagebreak" id="Page_88" title="88"/>As hackers, one of the first things we want to test when we run into a GraphQL application is whether its introspection mechanism is enabled. Many GraphQL implementations enable introspection by default. Some implementations might have an option to disable introspection, but others might not. For example, the Python GraphQL implementation Graphene does not provide the option to disable introspection. To do so, the consumer would have to dig into the code and identify ways to prevent introspection queries from being processed. On the other hand, the GraphQL PHP implementation graphql-php enables introspection by default but also documents how to completely disable this feature. <a href="#table4-2" id="tableanchor4-2">Table 4-2</a> shows the state of introspection in some of the popular GraphQL server implementations.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-2">Table 4-2</a>: The State of Introspection in GraphQL Implementations</p></figcaption>
<table border="1" id="table-502840c04-0002">
<thead>
<tr>
<td><b>Language</b></td>
<td><b>Implementation </b></td>
<td><b>Introspection configuration</b></td>
<td><b>Disable introspection option</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Python</td>
<td>Graphene</td>
<td>Enabled by default</td>
<td>Not available</td>
</tr>
<tr>
<td>Python</td>
<td>Ariadne</td>
<td>Enabled by default</td>
<td>Available</td>
</tr>
<tr>
<td>PHP</td>
<td>graphql-php</td>
<td>Enabled by default</td>
<td>Available</td>
</tr>
<tr>
<td>Go</td>
<td>graphql-go</td>
<td>Enabled by default</td>
<td>Not available</td>
</tr>
<tr>
<td>Ruby</td>
<td>graphql-ruby</td>
<td>Enabled by default</td>
<td>Available</td>
</tr>
<tr>
<td>Java</td>
<td>graphql-java</td>
<td>Enabled by default</td>
<td>Not available</td>
</tr>
</tbody>
</table>
</figure>
<p>Any default setting that directly impacts security is always good news for hackers. Application maintainers rarely change these default settings. (Some maintainers may not even be aware of them.) In <a href="#table4-2">Table 4-2</a>, you can see that in some cases—such as in graphql-go, graphql-java, and Graphene—introspection can be disabled only if the application maintainers code the solution into the GraphQL API themselves; there is no official, vendor-vetted solution to disable it.</p>
<p>While opinions on this matter vary, especially in security circles, introspection in GraphQL is widely considered a feature and not a vulnerability. Companies that adopt GraphQL may choose to keep it enabled, while others may disable it to avoid disclosing information that could be leveraged in attacks. If no external consumers integrate with a GraphQL API, it’s possible that developers could disable introspection altogether without impacting normal application flows.</p>
<p>Depending on your target, the response to an introspection query could be fairly large. Also, if you’re attacking a target with a mature security program, these queries may be monitored for any attempts from untrusted clients, such as those in new geographical locations or with new IP addresses.</p>
<p>To experiment with the introspection query by using our vulnerable server, open the Altair client in your lab and ensure that the address bar is set to <em>http://localhost:5013/graphql</em>. Next, enter the introspection query shown in <a href="#listing4-17" id="listinganchor4-17">Listing 4-17</a> and execute it in Altair.</p>
<pre><code><span epub:type="pagebreak" id="Page_89" title="89"/><b>query {</b>
<b>  __schema {</b>
<b>    types {</b>
<b>      name</b>
<b>    }</b>
<b>  }</b>
<b>}</b></code></pre>
<p class="CodeListingCaption"><a id="listing4-17">Listing 4-17</a>: An introspection query in its simplest form</p>
<p>This query uses the meta-field <code>__schema</code>, which is the type name of the GraphQL schema introspection system. It then requests the <code>name</code> of all <code>types</code> available in the GraphQL server. The following output shows the server’s response to the query:</p>
<pre><code>{
  "data": {
    "__schema": {
      "types": [
<var>--snip--</var>
        {
          "name": "PasteObject"
        },
        {
          "name": "CreatePaste"
        },
        {
          "name": "DeletePaste"
        },
        {
          "name": "UploadPaste"
        },
        {
          "name": "ImportPaste"
        },
<var>--snip--</var>
      ]
    }
  }
}</code></pre>
<p>While we receive a valid response, this query in its current form gives us only a partial view of the features available through the API. The response is missing key information, such as query and mutation names, information about which queries allow arguments to be passed by clients, the data types of arguments (such as scalar types like <code>String</code><code/> and <code>Boolean</code><code/>), and so on. These are important, because queries that accept arguments could be prone to vulnerabilities, such as injections, server-side request forgeries, and so on.</p>
<p>We can craft a more specialized introspection query that would give us more data about the target application’s schema. A useful introspection query is one that will give us information on the entry points into the application, such as queries, mutations, subscriptions, and the type of data <span epub:type="pagebreak" id="Page_90" title="90"/>that can be injected into them. Consider the introspection query shown in <a href="#listing4-18" id="listinganchor4-18">Listing 4-18</a>.</p>
<pre><code>query IntrospectionQuery {
   __schema {
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> queryType { name }
    mutationType { name }
    subscriptionType { name }
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> types {
      kind
      name
    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> fields {
       name
        <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> args {
          name
        }
      }
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-18">Listing 4-18</a>: A more useful introspection query</p>
<p>The introspection query in <a href="#listing4-18">Listing 4-18</a> gives us a bit more insight into the API. At <span aria-label="annotation1" class="CodeAnnotation">❶</span> we get the <code>name</code> of all queries (<code>queryType</code>), mutations (<code>mutationType</code>), and subscriptions (<code>subscriptionType</code>) available in the GraphQL API. These names are typically self-explanatory, to make it easier for clients to use the API, so knowing these query names gives us an idea of the information we could receive.</p>
<p>At <span aria-label="annotation2" class="CodeAnnotation">❷</span> we get all the <code>types</code> in the schema, along with their <code>kind</code> (such as an object) and name (such as <code>PasteObject</code>). At <span aria-label="annotation3" class="CodeAnnotation">❸</span> we get the <code>fields</code> along with the <code>name</code> of each one, which will allow us to know the types of fields we can fetch when we use different GraphQL objects. Next, we get the arguments (<code>args</code>) of these fields along with their <code>name</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Arguments could be any information the API is expecting the client to supply when it queries the API (typically, dynamic data). For example, when a client creates a new paste, it will supply an arbitrary <code>title</code> argument and a <code>content</code> argument containing the body of the paste, which might be a code snippet or other text.</p>
<p>In penetration tests, you may want to run an introspection query against an entire network, assuming a GraphQL server may be present. In this case, you would either need to write your own script or use the Nmap NSE script <em>graphql-introspection.nse</em> we installed in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. This script is simple: it queries GraphQL by using the <code>__schema</code> meta-field to determine if it’s fetchable.</p>
<p>Say you have a list of IP addresses in a text file such as <em>hosts.txt</em>. Using Nmap’s <code>-iL</code> flag, you can tell Nmap to use it as its list of targets. Using the <code>--script</code> flag, you can then tell Nmap to run the <em>graphql-introspection</em> NSE script against any host that has port <code>5013</code> open (<code>-p</code> flag). The <code>-sV</code> flag performs a service and version scan. The command in <a href="#listing4-19" id="listinganchor4-19">Listing 4-19</a> shows how this is accomplished.</p>
<pre><code><span epub:type="pagebreak" id="Page_91" title="91"/># <b>nmap --script=graphql-introspection -iL hosts.txt -sV -p 5013</b>

PORT     STATE SERVICE VERSION
5013/tcp open  http    Ajenti http control panel
| graphql-introspection:
|   VULNERABLE:
|   GraphQL Server allows Introspection queries at endpoint:
|   Endpoint: /graphql is vulnerable to introspection queries!
|     State: VULNERABLE
|       Checks if GraphQL allows Introspection Queries.
|
|     References:
|_      https://graphql.org/learn/introspection/</code></pre>
<p class="CodeListingCaption"><a id="listing4-19">Listing 4-19</a>: A GraphQL introspection detection with the Nmap NSE</p>
<p>Using <code>nmap</code> to detect when introspection is enabled is just the first step. The next step is to extract all possible schema information by using a more robust query.</p>
<p>In the book’s GitHub repository, you can find a comprehensive introspection query that, when executed, will extract a lot of useful information about the target’s schema: <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt</a>. This query will return information such as queries, mutations, and subscriptions names, with the arguments they accept; names of objects and fields, along with their types; names and descriptions of GraphQL directives; and object relationships. If you run that query in Altair, the server should return a fairly large response, as shown in <a href="#figure4-6" id="figureanchor4-6">Figure 4-6</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c04/f04006.png"/>
<figcaption><p><a id="figure4-6">Figure 4-6</a>: An introspection in Altair</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_92" title="92"/>The response is large enough (containing approximately 2,000 lines) that it would be challenging for any human to go through it manually and make sense of it without investing a significant amount of time. This is where GraphQL visualizers such as <em>GraphQL Voyager</em> come in handy.</p>
<h3 id="h2-502840c04-0008"><a class="XrefDestination" id="VisualizingIntrospectionwithGraphQLVoyager"/><span class="XrefDestination" id="xref-502840c04-013"/>Visualizing Introspection with GraphQL Voyager</h3>
<p class="BodyFirst">GraphQL Voyager, which can be found at either <a class="LinkURL" href="https://ivangoncharov.github.io/graphql-voyager">https://ivangoncharov.github.io/graphql-voyager</a> or <a class="LinkURL" href="http://lab.blackhatgraphql.com:9000">http://lab.blackhatgraphql.com:9000</a>, is an open source tool that processes either introspection query responses or GraphQL SDL files and visualizes them, making it easy to identify the various queries, mutations, and subscriptions and the relationships between them.</p>
<p>The tool’s introspection query option is most suitable for scenarios such as black-box penetration tests, in which the application’s code base is not accessible to us. The SDL option is useful when we might have direct access to the GraphQL schema files, such as during a white-box penetration test in which the company provides us with full access to the source code.</p>
<p>Try visualizing the introspection query response you just received in Altair and importing it into GraphQL Voyager. Copy the response and then open your browser and navigate to GraphQL Voyager. Click the <b>Change Schema</b> button located at the top-left corner. Select the <b>Introspection</b> tab, paste in the response, and click the <b>Display</b> button. You should see a visualization similar to the one shown in <a href="#figure4-7" id="figureanchor4-7">Figure 4-7</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502840c04/f04007.png"/>
<figcaption><p><a id="figure4-7">Figure 4-7</a>: The schema view in Voyager</p></figcaption>
</figure>
<p>The visualization we receive from Voyager represents the queries, mutations, and subscriptions available in our target application and how they relate to the different objects and fields that exist in the schema.</p>
<p>Under Query, you can see that the application supports 12 queries. The arrows in the view represent the mapping between these queries and the schema objects. For example, when you use the <code>pastes</code> query, it will return an array of <code>[PasteObject]</code> objects, which is also the reason you’re seeing an <span epub:type="pagebreak" id="Page_93" title="93"/>arrow pointing to the <code>PasteObject</code> table. The <code>system</code> queries (update, diagnostics, debug, and health) are not tied to any other schema objects; they simply return a string whenever you use them.</p>
<p>You can also see that we have relationships (edges) between fields. For example, the <code>owner</code> field in the <code>PasteObject</code> object is linked to <code>OwnerObject</code>, and the <code>paste</code> field in <code>OwnerObject</code> is linked back to <code>PasteObject</code>. This circular condition could lead to DoS conditions, as you will learn in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	You can toggle between the Query view, Mutation view, and Subscription view by using the drop-down menu at the bottom of Voyager.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Now that we’ve experimented with visualizing an introspection response in Voyager, let’s do the same with SDL files. Voyager accepts SDL files and can process them just as well as it does introspection responses. To see this in action, click the <b>Change Schema</b> button located at the top-left corner in Voyager, select the <b>SDL</b> tab, and paste in the SDL file located at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch04/sdl.graphql">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch04/sdl.graphql</a>. Then click the <b>Display</b> button. You should see a similar visualization to the one generated in the Introspection tab.</p>
<h3 id="h2-502840c04-0009"><a class="XrefDestination" id="GeneratingIntrospectionDocumentationwithSpectaQL"/><span class="XrefDestination" id="xref-502840c04-014"/>Generating Introspection Documentation with SpectaQL</h3>
<p class="BodyFirst"><em>SpectaQL</em> (<a class="LinkURL" href="https://github.com/anvilco/spectaql">https://github.com/anvilco/spectaql</a>) is an open source project that allows you to generate static documentation based on an SDL file. The document that gets generated will include information about how to construct queries, mutations, and subscriptions; the different types; and their fields. We’ve hosted an example SpectaQL-generated schema of DVGA at <a class="LinkURL" href="http://lab.blackhatgraphql.com:9001">http://lab.blackhatgraphql.com:9001</a> so you can see how SpectaQL looks when it’s functional.</p>
<h3 id="h2-502840c04-0010"><a class="XrefDestination" id="ExploringDisabledIntrospection"/><span class="XrefDestination" id="xref-502840c04-015"/>Exploring Disabled Introspection</h3>
<p class="BodyFirst">At some point, you’ll probably encounter a GraphQL API that has introspection disabled. To see what this looks like, let’s use one of the neat features of our vulnerable GraphQL server: turning on its hardened mode.</p>
<p>The DVGA works in two modes, a Beginner mode and an Expert (hardened) mode. Both versions are vulnerable; the only difference is that the Expert mode has a few security mechanisms to protect the application from any dangerous queries.</p>
<p>To change the application’s mode, open the Altair client and ensure that the address points to <em>http://localhost:5013/graphql</em>. In the left sidebar, click the Set Headers icon, which looks like a small sun symbol. Set <b>Header Key</b> to <b>X-DVGA-MODE</b> and set <b>Header Value</b> to <b>Expert</b>. This HTTP header set instructs DVGA to perform security checks on any incoming queries that include the headers as part of the request. Alternatively, you can toggle on Expert mode from within DVGA’s web interface by using the drop-down menu located at the top-right corner (the cubes icon).</p>
<p><span epub:type="pagebreak" id="Page_94" title="94"/>Now attempt a simple introspection query using Altair:</p>
<pre><code><b>query {</b>
<b>   __schema {</b>
<b>     __typename</b>
<b>   }</b>
<b>}</b></code></pre>
<p>You should see an error response indicating that introspection is disabled, causing the query to fail (<a href="#listing4-20" id="listinganchor4-20">Listing 4-20</a>).</p>
<pre><code>{
  "errors": [
    {
      "message": "400 Bad Request: Introspection is Disabled",
      "locations": [
        {
          "line": 2,
          "column": 7
        }
      ],
      "path": [
        "__schema"
      ]
    }
  ],
  "data": null
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-20">Listing 4-20</a>: An error returned when introspection is disabled</p>
<p>In cases like this one, you’ll need a plan B. In <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, you’ll learn how to discover information about the GraphQL application even if introspection data isn’t available.</p>
<h2 id="h1-502840c04-0004"><a class="XrefDestination" id="FingerprintingGraphQL"/><span class="XrefDestination" id="xref-502840c04-016"/>Fingerprinting GraphQL</h2>
<p class="BodyFirst">Earlier in this chapter, we highlighted the many GraphQL implementations available. How can we tell which one is running on the server we’re trying to hack? The answer is <em>server</em> <em>fingerprinting</em>, the operation of identifying information about the target’s running services and their versions. For example, a common and simple technique for fingerprinting web servers is to make an HTTP HEAD request using a tool like cURL and observe the HTTP response headers that are returned.</p>
<p>Once we know the specific technology and version running an application, we can perform a more accurate vulnerability assessment against the service. For example, we can look for publicly available exploits to run against the target’s version or read the software’s documentation to identify weaknesses.</p>
<p><span epub:type="pagebreak" id="Page_95" title="95"/>Popular web servers such as Apache or Nginx are great examples of services that are easy to fingerprint, since both typically set the <code>server</code> HTTP response header when a client makes a request to them. <a href="#listing4-21" id="listinganchor4-21">Listing 4-21</a> shows an example of how the web server behind the Apache Software Foundation website identifies itself by using the <code>server</code> header:</p>
<pre><code># <b>curl -I https://apache.org/</b>

HTTP/2 200
server: Apache
vary: Accept-Encoding
content-length: 73190</code></pre>
<p class="CodeListingCaption"><a id="listing4-21">Listing 4-21</a>: The Apache web server fingerprinting using a HEAD request</p>
<p>As expected, the Apache Software Foundation’s website is, in fact, running on the Apache web server. (It would have been a little odd if this were not the case!)</p>
<p>Fingerprinting services in a penetration test won’t always be this easy; sometimes accurate fingerprinting requires looking closely at the details, as not all software self-identifies, including GraphQL servers. The techniques used to fingerprint GraphQL implementations are relatively new in the security industry. We (the authors of this book) have developed several strategies for doing so, based on our research, and incorporated them into Graphw00f.</p>
<p>GraphQL fingerprinting relies on the observation of various discrepancies between implementations of GraphQL servers. Here are a few examples:</p>
<ul class="disc">
<li>Inconsistencies in error messages</li>
<li>Inconsistencies in response outputs to malformed GraphQL queries</li>
<li>Inconsistencies in response outputs to properly structured queries</li>
<li>Inconsistencies in response outputs to queries deviating from the GraphQL specification</li>
</ul>
<p>Using all four of these factors, we can uniquely identify the implementation behind a GraphQL-backed application.</p>
<p>Let’s examine how two GraphQL server implementations respond to a malformed query. This query, shown in <a href="#listing4-22" id="listinganchor4-22">Listing 4-22</a>, introduces an additional <code>y</code> character in the word <code>queryy</code>, which is not compliant with the GraphQL specification. We want to see how two GraphQL implementations respond to it. The first implementation is Sangria, a Scala-based GraphQL server.</p>
<pre><code>queryy {
   __typename
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-22">Listing 4-22</a>: A malformed GraphQL query</p>
<p><span epub:type="pagebreak" id="Page_96" title="96"/><a href="#listing4-23" id="listinganchor4-23">Listing 4-23</a> shows Sangria’s response to the malformed query.</p>
<pre><code>{
  "syntaxError": "Syntax error while parsing GraphQL query.
  Invalid input \"queryy\", expected ExecutableDefinition or
  TypeSystemDefinition (line 1, column 1):\nqueryy {\n^",
  "locations": [
    {
      "line": 1,
      "column": 1
    }
  ]
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-23">Listing 4-23</a>: Sangria’s response to the malformed query</p>
<p>The second implementation is HyperGraphQL, a Java-based GraphQL server. <a href="#listing4-24" id="listinganchor4-24">Listing 4-24</a> shows how it responds to the malformed query.</p>
<pre><code>{
  "extensions": {},
  "errors": [
    {
      "message": "Validation error of type InvalidSyntax: Invalid query syntax.",
      "locations": [
        {
          "line": 0,
          "column": 0,
          "sourceName": null
        }
      ],
      "description": "Invalid query syntax.",
      "validationErrorType": "InvalidSyntax",
      "queryPath": null,
      "errorType": "ValidationError",
      "extensions": null,
      "path": null
    }
  ]
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-24">Listing 4-24</a>: HyperGraphQL’s response to the malformed query</p>
<p>As you can observe, the two responses are different in every possible way, and we can distinguish between these implementations based solely on their responses.</p>
<p>Next, we’ll attempt the same malformed query in our lab against the DVGA to see the kind of response we get. Open the Altair client and send the GraphQL query. You should see output similar to <a href="#figure4-8" id="figureanchor4-8">Figure 4-8</a>.</p>
<p>As you can see, the output is different from both the Sangria and HyperGraphQL responses. This is because DVGA is based on Graphene, a Python GraphQL implementation.</p>
<span epub:type="pagebreak" id="Page_97" title="97"/><figure>
<img alt="" class="keyline" src="image_fi/502840c04/f04008.png"/>
<figcaption><p><a id="figure4-8">Figure 4-8</a>: Sending a malformed query with Altair</p></figcaption>
</figure>
<p>Running queries manually and analyzing the discrepancies between implementations doesn’t really scale well, which is why we built a server fingerprinting capability into Graphw00f. In the next section, we’ll use it for server fingerprinting purposes.</p>
<h3 id="h2-502840c04-0011"><a class="XrefDestination" id="DetectingServerswithGraphw00f"/><span class="XrefDestination" id="xref-502840c04-017"/>Detecting Servers with Graphw00f</h3>
<p class="BodyFirst">Graphw00f is currently the only tool available for GraphQL server fingerprinting. It can detect many of the popular GraphQL server implementations and provide meaningful information whenever it successfully fingerprints a server.</p>
<p>In your lab, open the terminal emulator. If you enter the <em>graphw00f</em> directory and run <code>python3 main.py -l</code>, you’ll see that Graphw00f is capable of fingerprinting over 24 GraphQL implementations. This list comprises the majority of GraphQL targets currently in use.</p>
<p>Let’s use it to fingerprint the DVGA. We’ll run Graphw00f with the <code>-f</code> flag to enable fingerprint mode and the <code>-t</code> flag to specify the target (<a href="#listing4-25" id="listinganchor4-25">Listing 4-25</a>). You could combine the <code>-f</code> flag with the <code>-d</code> flag (covered earlier in this chapter) if you wanted to detect GraphQL and fingerprint at the same time. Here, we’ll use the <code>-f</code> flag on its own, as we already know the path to GraphQL on the server.</p>
<pre><code># <b>cd ~/graphw00f</b>
# <b>python3 main.py -f -t http://localhost:5013/graphql</b>

  [*] Checking if GraphQL is available at http://localhost:5013/graphql...
  [!] Found GraphQL.
  [*] Attempting to fingerprint...
<span epub:type="pagebreak" id="Page_98" title="98"/>  [*] Discovered GraphQL Engine: (Graphene)
  [!] Attack Surface Matrix: https://github.com/nicholasaleks
  /graphql-threat-matrix/blob/master/implementations/graphene.md
  [!] Technologies: Python
  [!] Homepage: https://graphene-python.org
  [*] Completed.</code></pre>
<p class="CodeListingCaption"><a id="listing4-25">Listing 4-25</a>: The fingerprinting of a GraphQL server</p>
<p>The tool first checks whether the target is, in fact, a GraphQL server. It does so by sending a few queries and inspecting their responses against its own database of signatures. As you can see, it is able to discover a GraphQL server running on Graphene and provides us with an attack surface matrix link. The <em>attack surface matrix </em>is essentially knowledge about the security posture of the various GraphQL implementations that Graphw00f can fingerprint. Graphw00f uses the GraphQL Threat Matrix we discussed in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> as its implementation security posture database.</p>
<p>Since we now know that DVGA runs Graphene, we need to analyze Graphene’s weaknesses to determine which attacks we can run against this specific implementation. Some implementations have been around longer than others. Thus, they are more mature, stable, and offer more security features than others. This is why knowing the backend implementation is an advantage when we hack a GraphQL target.</p>
<h3 id="h2-502840c04-0012"><a class="XrefDestination" id="AnalyzingResultsinGraphw00f"/><span class="XrefDestination" id="xref-502840c04-018"/>Analyzing Results</h3>
<p class="BodyFirst">Take a look at the attack surface threat matrix, which provides information about the implementation’s default behavior and the security controls available for it (for example, the settings that are enabled by default, the security controls that exist, and other useful features we can leverage for hacking purposes). <a href="#figure4-9" id="figureanchor4-9">Figure 4-9</a> shows the attack surface matrix for Graphene. You can also find it on GitHub at <a class="LinkURL" href="https://github.com/nicholasaleks/graphql-threat-matrix/blob/master/implementations/graphene.md">https://github.com/nicholasaleks/graphql-threat-matrix/blob/master/implementations/graphene.md</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c04/f04009.png"/>
<figcaption><p><a id="figure4-9">Figure 4-9</a>: Graphene’s attack surface matrix</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_99" title="99"/>The table under Security Considerations shows various GraphQL features and whether they are available in Graphene. If they do exist, the table lists whether they are enabled or disabled by default. Some of the items in the table are security controls, while others are native GraphQL features:</p>
<ul class="disc">
<li><em>Field Suggestions</em> informs a client whenever they send a query with a spelling mistake and suggests alternative options. This can be leveraged for information disclosure.</li>
<li><em>Query Depth Limit</em> is a security control to prevent DoS attacks that may abuse conditions such as cyclical node relationships in schemas.</li>
<li><em>Query Cost Analysis</em> is a security control to prevent DoS attacks that stem from computationally complex queries.</li>
<li><em>Automatic Persisted Queries</em> is a caching mechanism. It allows the client to pass a hash representing a query as a way to save bandwidth and can be used as a security control with an allow list of safe queries.</li>
<li><em>Introspection </em>provides access to information about queries, mutations, subscriptions, fields, objects, and so on through the __<code>schema</code> meta-field. This can be abused to disclose information about the application’s schema.</li>
<li><em>Debug Mode </em>is a mode in GraphQL that provides additional information in the response for debugging purposes. This can potentially introduce information disclosure issues.</li>
<li><em>Batch Requests</em> is a feature that provides clients with the ability to send a sequence of queries in a single HTTP request. Batch queries are a great vector for DoS attacks.</li>
</ul>
<p>In later chapters, you’ll learn how each of these features can make our hacking lives easier (or harder).</p>
<h2 id="h1-502840c04-0005"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-502840c04-019"/>Summary</h2>
<p class="BodyFirst">In this chapter, you learned the art of performing reconnaissance against GraphQL servers by using a variety of security tools. We discussed how to detect and fingerprint GraphQL servers deployed in standard and nonstandard locations, as well as how to find GraphQL IDE clients by using the EyeWitness security tool. We also visualized an introspection query and SDL files by using GraphQL Voyager to better understand queries, mutations, and object relationships.</p>
</section>
</body>
</html>