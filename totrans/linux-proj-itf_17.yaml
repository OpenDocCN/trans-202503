- en: Chapter 17. Access Control Lists
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 17 章。访问控制列表
- en: '[File Permissions](ch15.html#file_permissions "File Permissions") described
    the traditional UNIX (and Linux) file permissions scheme. For many applications,
    this scheme is sufficient. However, some applications need finer control over
    the permissions granted to specific users and groups. To meet this requirement,
    many UNIX systems implement an extension to the traditional UNIX file permissions
    model known as *access control lists* (ACLs). ACLs allow file permissions to be
    specified per user or per group, for an arbitrary number of users and groups.
    Linux provides ACLs from kernel 2.6 onward.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[文件权限](ch15.html#file_permissions "文件权限")描述了传统的 UNIX（和 Linux）文件权限方案。对于许多应用程序来说，这个方案已足够。然而，一些应用程序需要对授予特定用户和组的权限进行更精细的控制。为满足这一需求，许多
    UNIX 系统在传统 UNIX 文件权限模型的基础上实现了一种扩展，称为*访问控制列表*（ACL）。ACL 允许按用户或组指定文件权限，支持任意数量的用户和组。Linux
    从内核 2.6 开始提供对 ACL 的支持。'
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Support for ACLs is optional for each file system, and is controlled by kernel
    configuration options under the *File systems* menu. *Reiserfs* support for ACLs
    has been available since kernel 2.6.7.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对 ACL 的支持对于每个文件系统来说是可选的，且由内核配置选项控制，位于*文件系统*菜单下。*Reiserfs* 对 ACL 的支持自内核 2.6.7
    起可用。
- en: In order to be able to create ACLs on an *ext2*, *ext3*, *ext4*, or *Reiserfs*
    file system, the file system must be mounted with the *mount -o acl* option.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在*ext2*、*ext3*、*ext4* 或 *Reiserfs* 文件系统上创建 ACL，必须使用 *mount -o acl* 选项挂载该文件系统。
- en: ACLs have never been formally standardized for UNIX systems. An attempt was
    made to do this in the form of the POSIX.1e and POSIX.2c draft standards, which
    aimed to specify, respectively, the application program interface (API) and the
    shell commands for ACLs (as well as other features, such as capabilities). Ultimately,
    this standardization attempt foundered, and these draft standards were withdrawn.
    Nevertheless, many UNIX implementations (including Linux) base their ACL implementations
    on these draft standards (usually on the final version, *Draft 17*). However,
    because there are many variations across ACL implementations (in part springing
    from the incompleteness of the draft standards), writing portable programs that
    use ACLs presents some difficulties.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ACL 在 UNIX 系统中从未正式标准化。曾尝试通过 POSIX.1e 和 POSIX.2c 草案标准来实现这一点，分别旨在规范 ACL 的应用程序接口（API）和
    Shell 命令（以及其他功能，如能力）。最终，这一标准化尝试失败了，这些草案标准被撤回。然而，许多 UNIX 实现（包括 Linux）将它们的 ACL 实现基于这些草案标准（通常是最终版本，*草案
    17*）。然而，由于各 ACL 实现之间存在许多差异（部分源于草案标准的不完整性），编写使用 ACL 的可移植程序会遇到一些困难。
- en: This chapter provides a description of ACLs and a brief tutorial on their use.
    It also describes some of the library functions used for manipulating and retrieving
    ACLs. We won’t go into detail on all of these functions because there are so many
    of them. (For the details, see the manual pages.)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了 ACL 的描述，并简要介绍了其使用教程。它还描述了用于操作和检索 ACL 的一些库函数。由于函数众多，我们不会对所有函数进行详细讨论。（详细信息，请参见手册页。）
- en: Overview
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: An ACL is a series of ACL entries, each of which defines the file permissions
    for an individual user or group of users (see [Figure 17-1](ch17.html#an_access_control_list
    "Figure 17-1. An access control list")).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ACL 是一系列 ACL 条目，每个条目定义了单个用户或用户组的文件权限（见 [图 17-1](ch17.html#an_access_control_list
    "图 17-1. 访问控制列表")）。
- en: '![An access control list](figs/web/17-1_ACL-ACL.png.jpg)Figure 17-1. An access
    control list'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![访问控制列表](figs/web/17-1_ACL-ACL.png.jpg)图 17-1. 访问控制列表'
- en: ACL entries
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ACL 条目
- en: 'Each ACL entry consists of the following parts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 ACL 条目由以下部分组成：
- en: a *tag type*, which indicates whether this entry applies to a user, to a group,
    or to some other category of user;
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*标签类型*，指示该条目适用于用户、组或其他某类用户；
- en: an optional *tag qualifier*, which identifies a specific user or group (i.e.,
    a user ID or a group ID); and
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的*标签限定符*，它标识特定的用户或组（即用户 ID 或组 ID）；以及
- en: a *permission set*, which specifies the permissions (read, write, and execute)
    that are granted by the entry.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*权限集*，指定了条目授予的权限（读取、写入和执行）。
- en: 'The tag type has one of the following values:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 标签类型有以下几种值：
- en: '`ACL_USER_OBJ`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_USER_OBJ`'
- en: This entry specifies the permissions granted to the file owner. Each ACL contains
    exactly one `ACL_USER_OBJ` entry. This entry corresponds to the traditional file
    *owner* (*user*) permissions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本条目指定授予文件所有者的权限。每个ACL包含一个`ACL_USER_OBJ`条目。此条目对应传统文件*所有者*（*用户*）权限。
- en: '`ACL_USER`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_USER`'
- en: This entry specifies the permissions granted to the user identified by the tag
    qualifier. An ACL may contain zero or more `ACL_USER` entries, but at most one
    `ACL_USER` entry may be defined for a particular user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本条目指定授予由标签限定符标识的用户的权限。一个ACL可以包含零个或多个`ACL_USER`条目，但每个特定用户最多只能定义一个`ACL_USER`条目。
- en: '`ACL_GROUP_OBJ`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_GROUP_OBJ`'
- en: This entry specifies permissions granted to the file group. Each ACL contains
    exactly one `ACL_GROUP_OBJ` entry. This entry corresponds to the traditional file
    *group* permissions, unless the ACL also contains an `ACL_MASK` entry.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本条目指定授予文件组的权限。每个ACL必须包含一个`ACL_GROUP_OBJ`条目。除非ACL还包含`ACL_MASK`条目，否则此条目对应传统的文件*组*权限。
- en: '`ACL_GROUP`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_GROUP`'
- en: This entry specifies the permissions granted to the group identified by the
    tag qualifier. An ACL may contain zero or more `ACL_GROUP` entries, but at most
    one `ACL_GROUP` entry may be defined for a particular group.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本条目指定了授予由标签限定符标识的组的权限。一个ACL可以包含零个或多个`ACL_GROUP`条目，但每个组最多只能定义一个`ACL_GROUP`条目。
- en: '`ACL_MASK`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_MASK`'
- en: This entry specifies the maximum permissions that may be granted by `ACL_USER`,
    `ACL_GROUP_OBJ`, and `ACL_GROUP` entries. An ACL contains at most one `ACL_MASK`
    entry. If the ACL contains `ACL_USER` or `ACL_GROUP` entries, then an `ACL_MASK`
    entry is mandatory. We say more about this tag type shortly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本条目指定了`ACL_USER`、`ACL_GROUP_OBJ`和`ACL_GROUP`条目可以授予的最大权限。一个ACL最多只能包含一个`ACL_MASK`条目。如果ACL中包含`ACL_USER`或`ACL_GROUP`条目，则`ACL_MASK`条目是必须的。我们稍后会详细介绍这种标签类型。
- en: '`ACL_OTHER`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_OTHER`'
- en: This entry specifies the permissions that are granted to users that don’t match
    any other ACL entry. Each ACL contains exactly one `ACL_OTHER` entry. This entry
    corresponds to the traditional file *other* permissions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本条目指定授予未与其他ACL条目匹配的用户的权限。每个ACL包含一个`ACL_OTHER`条目。此条目对应传统文件*其他*权限。
- en: The tag qualifier is employed only for `ACL_USER` and `ACL_GROUP` entries. It
    specifies either a user ID or a group ID.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 标签限定符仅用于`ACL_USER`和`ACL_GROUP`条目。它指定一个用户ID或组ID。
- en: Minimal and extended ACLs
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最小ACL和扩展ACL
- en: 'A *minimal* ACL is one that is semantically equivalent to the traditional file
    permission set. It contains exactly three entries: one of each of the types `ACL_USER_OBJ`,
    `ACL_GROUP_OBJ`, and `ACL_OTHER`. An *extended* ACL is one that additionally contains
    `ACL_USER`, `ACL_GROUP`, and `ACL_MASK` entries.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*最小*ACL是与传统文件权限集语义等价的ACL。它包含恰好三个条目：`ACL_USER_OBJ`、`ACL_GROUP_OBJ`和`ACL_OTHER`各一个。*扩展*ACL是除了包含这些条目外，还包含`ACL_USER`、`ACL_GROUP`和`ACL_MASK`条目的ACL。'
- en: One reason for drawing a distinction between minimal ACLs and extended ACLs
    is that the latter provide a semantic extension to the traditional permissions
    model. Another reason concerns the Linux implementation of ACLs. ACLs are implemented
    as *system* extended attributes ([Chapter 16](ch16.html "Chapter 16. Extended
    Attributes")). The extended attribute used for maintaining a file access ACL is
    named *system.posix_acl_access*. This extended attribute is required only if the
    file has an extended ACL. The permissions information for a minimal ACL can be
    (and is) stored in the traditional file permission bits.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 区分最小ACL和扩展ACL的一个原因是，扩展ACL为传统权限模型提供了语义上的扩展。另一个原因涉及Linux中ACL的实现。ACL作为*系统*扩展属性实现（参见[第16章](ch16.html
    "第16章 扩展属性")）。用于维护文件访问ACL的扩展属性名为*system.posix_acl_access*。只有当文件具有扩展ACL时，才需要此扩展属性。最小ACL的权限信息可以（且通常会）存储在传统的文件权限位中。
- en: ACL Permission-Checking Algorithm
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACL权限检查算法
- en: 'Permission checking on a file that has an ACL is performed in the same circumstances
    as for the traditional file permissions model ([Permission-Checking Algorithm](ch15.html#permission-checking_algorithm
    "Permission-Checking Algorithm")). Checks are performed in the following order,
    until one of the criteria is matched:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对具有ACL的文件进行权限检查的方式与传统文件权限模型中的检查方式相同（参见[权限检查算法](ch15.html#permission-checking_algorithm
    "权限检查算法")）。检查按以下顺序执行，直到匹配其中一个标准：
- en: If the process is privileged, all access is granted. There is one exception
    to this statement, analogous to the traditional permissions model described in
    [Permission-Checking Algorithm](ch15.html#permission-checking_algorithm "Permission-Checking
    Algorithm"). When executing a file, a privileged process is granted execute permission
    only if that permission is granted via at least one of the ACL entries on the
    file.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程具有特权，则授予所有访问权限。对此声明有一个例外，类似于 [权限检查算法](ch15.html#permission-checking_algorithm
    "权限检查算法") 中描述的传统权限模型。当执行文件时，特权进程只有在通过文件上的至少一个 ACL 条目授予执行权限时，才会获得执行权限。
- en: If the effective user ID of the process matches the owner (user ID) of the file,
    then the process is granted the permissions specified in the `ACL_USER_OBJ` entry.
    (To be strictly accurate, on Linux, it is the process’s file-system IDs, rather
    than its effective IDs, that are used for the checks described in this section,
    as described in Section 9.5.)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程的有效用户 ID 与文件的所有者（用户 ID）匹配，则进程会被授予 `ACL_USER_OBJ` 条目中指定的权限。（严格来说，在 Linux
    上，进行此处描述的检查时，使用的是进程的文件系统 ID，而不是有效 ID，正如第 9.5 节中所述。）
- en: If the effective user ID of the process matches the tag qualifier in one of
    the `ACL_USER` entries, then the process is granted the permissions specified
    in that entry, masked (ANDed) against the value of the `ACL_MASK` entry.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程的有效用户 ID 与某个 `ACL_USER` 条目的标签限定符匹配，则进程会被授予该条目中指定的权限，并与 `ACL_MASK` 条目中的值进行掩码（与运算）。
- en: 'If one of the process’s group IDs (i.e., the effective group ID or any of the
    supplementary group IDs) matches the file group (this corresponds to the `ACL_GROUP_OBJ`
    entry) or the tag qualifier of any of the `ACL_GROUP` entries, then access is
    determined by checking each of the following, until a match is found:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程的某个组 ID（即有效组 ID 或任何附加组 ID）与文件的组匹配（这对应于 `ACL_GROUP_OBJ` 条目），或者与任何 `ACL_GROUP`
    条目的标签限定符匹配，则通过检查以下每项内容来确定访问权限，直到找到匹配项为止：
- en: If one of the process’s group IDs matches the file group, and the `ACL_GROUP_OBJ`
    entry grants the requested permissions, then this entry determines the access
    granted to the file. The granted access is restricted by masking (ANDing) against
    the value in the `ACL_MASK` entry, if present.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程的某个组 ID 与文件的组匹配，并且 `ACL_GROUP_OBJ` 条目授予请求的权限，则该条目决定授予文件的访问权限。授予的访问权限会受到
    `ACL_MASK` 条目中值的掩码（与运算）的限制（如果存在的话）。
- en: If one of the process’s group IDs matches the tag qualifier in an `ACL_GROUP`
    entry for the file, and that entry grants the requested permissions, then this
    entry determines the permissions granted. The granted access is restricted by
    masking (ANDing) against the value in the `ACL_MASK` entry.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程的某个组 ID 与文件的某个 `ACL_GROUP` 条目的标签限定符匹配，并且该条目授予请求的权限，则该条目决定授予的权限。授予的访问权限会受到
    `ACL_MASK` 条目中值的掩码（与运算）的限制。
- en: Otherwise, access is denied.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，访问被拒绝。
- en: Otherwise, the process is granted the permissions specified in the `ACL_OTHER`
    entry.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，进程将被授予 `ACL_OTHER` 条目中指定的权限。
- en: 'We can clarify the rules relating to group IDs with some examples. Suppose
    we have a file whose group ID is 100, and that file is protected by the ACL shown
    in [Figure 17-1](ch17.html#an_access_control_list "Figure 17-1. An access control
    list"). If a process whose group ID is 100 makes the call *access(file, R_OK)*,
    then that call would succeed (i.e., return 0). (We describe *access()* in [Checking
    File Accessibility: *access()*](ch15.html#checking_file_accessibility_colon_access
    "Checking File Accessibility: access()").) On the other hand, even though the
    `ACL_GROUP_OBJ` entry grants all permissions, the call *access(file, R_OK | W_OK
    | X_OK)* would fail (i.e., return -1, with *errno* set to `EACCES`) because the
    `ACL_GROUP_OBJ` permissions are masked (ANDed) against the `ACL_MASK` entry, and
    this entry denies execute permission.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一些例子来澄清与组 ID 相关的规则。假设我们有一个组 ID 为 100 的文件，并且该文件由图 [17-1](ch17.html#an_access_control_list
    "图 17-1. 访问控制列表") 中所示的 ACL 保护。如果一个组 ID 为 100 的进程调用 *access(file, R_OK)*，则该调用会成功（即返回
    0）。（我们在 [检查文件可访问性：*access()*](ch15.html#checking_file_accessibility_colon_access
    "检查文件可访问性：access()") 中描述了 *access()。）另一方面，即使 `ACL_GROUP_OBJ` 条目授予所有权限，调用 *access(file,
    R_OK | W_OK | X_OK)* 也会失败（即返回 -1，*errno* 设置为 `EACCES`），因为 `ACL_GROUP_OBJ` 权限与
    `ACL_MASK` 条目进行掩码（与运算），而该条目拒绝了执行权限。
- en: As another example using [Figure 17-1](ch17.html#an_access_control_list "Figure 17-1. An
    access control list"), suppose we have a process that has a group ID of 102 and
    that also contains the group ID 103 in its supplementary group IDs. For this process,
    the calls *access*(*file*, *R*_*OK*) and *access*(*file*, *W*_*OK*) would both
    succeed, since they would match the `ACL_GROUP` entries for the group IDs 102
    and 103, respectively. On the other hand, the call *access*(*file*, *R*_*OK* |
    *W*_*OK*) would fail because there is no matching `ACL_GROUP` entry that grants
    both read and write permissions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用[图 17-1](ch17.html#an_access_control_list "图 17-1. 访问控制列表")的另一个例子，假设我们有一个进程，它的组
    ID 为 102，并且在其附加组 ID 中还包含组 ID 103。对于该进程，*access*(*file*, *R*_*OK*) 和 *access*(*file*,
    *W*_*OK*) 都会成功，因为它们分别与组 ID 102 和 103 的 `ACL_GROUP` 条目匹配。另一方面，*access*(*file*,
    *R*_*OK* | *W*_*OK*) 会失败，因为没有匹配的 `ACL_GROUP` 条目同时授予读取和写入权限。
- en: Long and Short Text Forms for ACLs
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACL 的长文本形式和短文本形式
- en: 'When manipulating ACLs using the *setfacl* and *getfacl* commands (described
    in a moment) or certain ACL library functions, we specify textual representations
    of the ACL entries. Two formats are permitted for these textual representations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 *setfacl* 和 *getfacl* 命令（稍后会介绍）或某些 ACL 库函数时，我们指定 ACL 条目的文本表示形式。这些文本表示形式允许两种格式：
- en: '*Long text form* ACLs contain one ACL entry per line, and may include comments,
    which are started by a `#` character and continue to the end-of-line. The *getfacl*
    command displays ACLs in long text form. The *setfacl -M acl-file* option, which
    takes an ACL specification from a file, expects the specification to be in long
    text form.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*长文本形式* 的 ACL 每行包含一个 ACL 条目，并且可以包含注释，注释以 `#` 字符开头并持续到行尾。*getfacl* 命令以长文本形式显示
    ACL。*setfacl -M acl-file* 选项，接受来自文件的 ACL 规范，要求该规范为长文本形式。'
- en: '*Short text form* ACLs consist of a sequence of ACL entries separated by commas.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简短文本形式* 的 ACL 由一系列 ACL 条目组成，各条目之间用逗号分隔。'
- en: 'In both forms, each ACL entry consists of three parts separated by colons:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种形式中，每个 ACL 条目由三个部分组成，部分之间用冒号分隔：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *tag-type* is one of the values shown in the first column of [Table 17-1](ch17.html#interpretation_of_acl_entry_text_forms
    "Table 17-1. Interpretation of ACL entry text forms"). The *tag-type* may optionally
    be followed by a *tag-qualifier*, which identifies a user or group, either by
    name or numeric identifier. The *tag-qualifier* is present only for `ACL_USER`
    and `ACL_GROUP` entries.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签类型* 是 [表 17-1](ch17.html#interpretation_of_acl_entry_text_forms "表 17-1.
    ACL 条目文本形式的解释") 中第一列所示的值之一。*标签类型* 后面可以选择跟一个 *标签限定符*，用于标识一个用户或组，可以是名称或数字标识符。*标签限定符*
    仅在 `ACL_USER` 和 `ACL_GROUP` 条目中存在。'
- en: 'The following are all short text form ACLs corresponding to a traditional permissions
    mask of 0650:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与传统权限掩码 0650 对应的所有简短文本形式的 ACL：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following short text form ACL includes two named users, a named group,
    and a mask entry:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简短的文本形式的 ACL，包括两个命名用户、一个命名组和一个掩码条目：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Table 17-1. Interpretation of ACL entry text forms
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-1. ACL 条目文本形式的解释
- en: '| Tag text forms | Tag qualifier present? | Corresponding tag type | Entry
    for |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 标签文本形式 | 是否存在标签限定符？ | 对应标签类型 | 条目对应 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `u, user` | N | `ACL_USER_OBJ` | File owner (user) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `u, user` | N | `ACL_USER_OBJ` | 文件所有者（用户） |'
- en: '| `u, user` | Y | `ACL_USER` | Specified user |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `u, user` | Y | `ACL_USER` | 指定的用户 |'
- en: '| `g, group` | N | `ACL_GROUP_OBJ` | File group |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `g, group` | N | `ACL_GROUP_OBJ` | 文件组 |'
- en: '| `g, group` | Y | `ACL_GROUP` | Specified group |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `g, group` | Y | `ACL_GROUP` | 指定的组 |'
- en: '| `m, mask` | N | `ACL_MASK` | Mask for group class |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `m, mask` | N | `ACL_MASK` | 组类的掩码 |'
- en: '| `o, other` | N | `ACL_OTHER` | Other users |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `o, other` | N | `ACL_OTHER` | 其他用户 |'
- en: The `ACL_MASK` Entry and the ACL Group Class
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ACL_MASK` 条目与 ACL 组类'
- en: If an ACL contains `ACL_USER` or `ACL_GROUP` entries, then it must contain an
    `ACL_MASK` entry. If the ACL doesn’t contain any `ACL_USER` or `ACL_GROUP` entries,
    then the `ACL_MASK` entry is optional.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ACL 包含 `ACL_USER` 或 `ACL_GROUP` 条目，则必须包含一个 `ACL_MASK` 条目。如果 ACL 不包含任何 `ACL_USER`
    或 `ACL_GROUP` 条目，则 `ACL_MASK` 条目是可选的。
- en: The `ACL_MASK` entry acts as an upper limit on the permissions granted by ACL
    entries in the so-called *group class*. The group class is the set of all `ACL_USER`,
    `ACL_GROUP`, and `ACL_GROUP_OBJ` entries in the ACL.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_MASK` 条目作为 ACL 条目中授予的权限的上限，适用于所谓的 *组类*。组类是 ACL 中所有 `ACL_USER`、`ACL_GROUP`
    和 `ACL_GROUP_OBJ` 条目的集合。'
- en: 'The purpose of the `ACL_MASK` entry is to provide consistent behavior when
    running ACL-unaware applications. As an example of why the mask entry is needed,
    suppose that the ACL on a file includes the following entries:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_MASK`条目的目的是在运行不支持ACL的应用程序时提供一致的行为。为了说明为何需要掩码条目，假设文件上的ACL包含以下条目：'
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now suppose that a program executes the following *chmod()* call on this file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设一个程序对这个文件执行以下的*chmod()*调用：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In an ACL-unaware application, this means “Deny access to everyone except the
    file owner.” These semantics should hold even in the presence of ACLs. In the
    absence of an `ACL_MASK` entry, this behavior could be implemented in various
    ways, but there are problems with each approach:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个不支持ACL的应用程序中，这意味着“拒绝除了文件所有者之外的所有人访问”。即使在存在ACL的情况下，这些语义也应当成立。在没有`ACL_MASK`条目的情况下，这种行为可以通过多种方式实现，但每种方法都有问题：
- en: Simply modifying the `ACL_GROUP_OBJ` and `ACL_USER_OBJ` entries to have the
    mask `---` would be insufficient, since the user *paulh* and the group *teach*
    would still have some permissions on the file.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅仅修改`ACL_GROUP_OBJ`和`ACL_USER_OBJ`条目为掩码`---`是不够的，因为用户*paulh*和组*teach*仍然会对文件有某些权限。
- en: 'Another possibility would be to apply the new group and other permission settings
    (i.e., all permissions disabled) to all of the `ACL_USER`, `ACL_GROUP`, `ACL_GROUP_OBJ`,
    and `ACL_OTHER` entries in the ACL:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种可能性是将新的组和其他权限设置（即所有权限禁用）应用到ACL中的所有`ACL_USER`、`ACL_GROUP`、`ACL_GROUP_OBJ`和`ACL_OTHER`条目：
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The problem with this approach is that the ACL-unaware application would thereby
    inadvertently destroy the file permission semantics established by ACL-aware applications,
    since the following call (for example) would not restore the `ACL_USER` and `ACL_GROUP`
    entries of the ACL to their former states:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，不支持ACL的应用程序因此会不小心破坏由支持ACL的应用程序建立的文件权限语义，因为以下的调用（例如）不会恢复`ACL_USER`和`ACL_GROUP`条目的ACL至它们原来的状态：
- en: '[PRE6]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To avoid these problems, we might consider making the `ACL_GROUP_OBJ` entry
    the limiting set for all `ACL_USER` and `ACL_GROUP` entries. However, this would
    mean that the `ACL_GROUP_OBJ` permissions would always need to be set to the union
    of all permissions allowed in all `ACL_USER` and `ACL_GROUP` entries. This would
    conflict with the use of the `ACL_GROUP_OBJ` entry for determining the permissions
    accorded to the file group.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免这些问题，我们可以考虑将`ACL_GROUP_OBJ`条目作为所有`ACL_USER`和`ACL_GROUP`条目的限制集。然而，这意味着`ACL_GROUP_OBJ`权限总是需要设置为所有`ACL_USER`和`ACL_GROUP`条目中允许的所有权限的并集。这会与使用`ACL_GROUP_OBJ`条目来确定文件组所赋予的权限发生冲突。
- en: 'The `ACL_MASK` entry was devised to solve these problems. It provides a mechanism
    that allows the traditional meanings of *chmod()* operations to be implemented,
    without destroying the file permission semantics established by ACL-aware applications.
    When an ACL has an `ACL_MASK` entry:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_MASK`条目被设计用来解决这些问题。它提供了一种机制，允许在不破坏由支持ACL的应用程序建立的文件权限语义的前提下，实现传统的*chmod()*操作的含义。当一个ACL有`ACL_MASK`条目时：'
- en: all changes to traditional group permissions via *chmod()* change the setting
    of the `ACL_MASK` entry (rather than the `ACL_GROUP_OBJ` entry); and
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有通过*chmod()*对传统组权限的修改都会改变`ACL_MASK`条目的设置（而不是`ACL_GROUP_OBJ`条目）；并且
- en: a call to *stat()* returns the `ACL_MASK` permissions (instead of the `ACL_GROUP_OBJ`
    permissions) in the group permission bits of the *st_mode* field ([Figure 15-1](ch15.html#layout_of_st_underscore_mode_bit_mask
    "Figure 15-1. Layout of st_mode bit mask"), in [Device IDs and i-node number](ch15.html#device_ids_and_i-node_number-id1
    "Device IDs and i-node number")).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对*stat()*的调用会返回`ACL_MASK`权限（而不是`ACL_GROUP_OBJ`权限），并在*st_mode*字段的组权限位中显示（[图15-1](ch15.html#layout_of_st_underscore_mode_bit_mask
    "图15-1. st_mode位掩码布局")，在[设备ID和i节点号](ch15.html#device_ids_and_i-node_number-id1
    "设备ID和i节点号")中）。
- en: 'While the `ACL_MASK` entry provides a way of preserving ACL information in
    the face of ACL-unaware applications, the reverse is not guaranteed. The presence
    of ACLs overrides the effect of traditional operations on file group permissions.
    For example, suppose that we have placed the following ACL on a file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ACL_MASK`条目提供了一种在面对不支持ACL的应用程序时保存ACL信息的方式，但反过来则无法保证。ACL的存在会覆盖传统操作对文件组权限的影响。例如，假设我们在文件上放置了以下ACL：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we then execute the command *chmod g+rw* on this file, the ACL becomes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们随后对这个文件执行命令*chmod g+rw*，ACL会变成：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, group still has no access to the file. One workaround for this
    is to modify the ACL entry for group to grant all permissions. Consequently, group
    will then always obtain whatever permissions are granted to the `ACL_MASK` entry.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，组仍然没有访问文件的权限。解决此问题的一种方法是修改组的ACL条目，授予所有权限。结果，组将始终获得与`ACL_MASK`条目授予的权限相同的权限。
- en: The *getfacl* and *setfacl* Commands
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*getfacl*和*setfacl*命令'
- en: From the shell, we can use the *getfacl* command to view the ACL on a file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从shell中，我们可以使用*getfacl*命令查看文件的ACL。
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From the output of the *getfacl* command, we see that the new file is created
    with a minimal ACL. When displaying the text form of this ACL, *getfacl* precedes
    the ACL entries with three lines showing the name and ownership of the file. We
    can prevent these lines from being displayed by specifying the *--omit-header*
    option.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从*getfacl*命令的输出中，我们可以看到新创建的文件具有最小的ACL。当显示该ACL的文本形式时，*getfacl*会在ACL条目前显示三行，内容为文件的名称和所有权。我们可以通过指定*--omit-header*选项来防止这些行被显示。
- en: Next, we demonstrate that changes to a file’s permissions using the traditional
    *chmod* command are carried through to the ACL.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们演示使用传统的*chmod*命令修改文件权限时，这些更改会反映到ACL中。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The *setfacl* command modifies a file ACL. Here, we use the *setfacl -m* command
    to add an `ACL_USER` and an `ACL_GROUP` entry to the ACL:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*setfacl*命令修改文件ACL。这里，我们使用*setfacl -m*命令将`ACL_USER`和`ACL_GROUP`条目添加到ACL中：'
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *setfacl -m* option modifies existing ACL entries, or adds new entries if
    corresponding entries with the given tag type and qualifier do not already exist.
    We can additionally use the *-R* option to recursively apply the specified ACL
    to all of the files in a directory tree.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*setfacl -m*选项用于修改现有的ACL条目，或者在没有对应标签类型和限定符的条目时添加新的条目。我们还可以使用*-R*选项递归地将指定的ACL应用到目录树中的所有文件。'
- en: From the output of the *getfacl* command, we can see that *setfacl* automatically
    created an `ACL_MASK` entry for this ACL.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从*getfacl*命令的输出中，我们可以看到*setfacl*为此ACL自动创建了一个`ACL_MASK`条目。
- en: 'The addition of the `ACL_USER` and `ACL_GROUP` entries converts this ACL into
    an extended ACL, and *ls* -*l* indicates this fact by appending a plus sign (+)
    after the traditional file permissions mask:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACL_USER`和`ACL_GROUP`条目的添加将此ACL转换为扩展ACL，*ls* - *l*通过在传统文件权限掩码后附加一个加号（+）来指示这一事实：'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We continue by using *setfacl* to disable all permissions except execute on
    the `ACL_MASK` entry, and then view the ACL once more with *getfacl*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用*setfacl*来禁用除了执行权限以外的所有权限，针对`ACL_MASK`条目，然后使用*getfacl*再次查看ACL：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `#effective:` comments that *getfacl* prints after the entries for the user
    *paulh* and the file group (`group::`) inform us that after masking (ANDing) against
    the `ACL_MASK` entry, the permissions granted by each of these entries will actually
    be less than those specified in the entry.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*getfacl*在用户*paulh*和文件组（`group::`）的条目后打印的`#effective:`注释告诉我们，在对`ACL_MASK`条目进行掩码（与运算）后，这些条目授予的权限实际上会低于条目中指定的权限。'
- en: 'We then use *ls -l* to once more view the traditional permission bits of the
    file. We see that the displayed group class permission bits reflect the permissions
    in the `ACL_MASK` entry (`--x`), rather than those in the `ACL_GROUP` entry (`r-x`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用*ls -l*再次查看文件的传统权限位。我们看到，显示的组类权限位反映了`ACL_MASK`条目中的权限（`--x`），而不是`ACL_GROUP`条目中的权限（`r-x`）：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The *setfacl -x* command can be used to remove entries from an ACL. Here, we
    remove the entries for the user *paulh* and the group *teach* (no permissions
    are specified when removing entries):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*setfacl -x*命令可用于从ACL中删除条目。在这里，我们删除了用户*paulh*和组*teach*的条目（删除条目时不指定权限）：'
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that during the above operation, *setfacl* automatically adjusted the
    mask entry to be the union of all of the group class entries. (There was just
    one such entry: `ACL_GROUP_OBJ`.) If we want to prevent such adjustment, then
    we must specify the *-n* option to *setfacl*.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述操作中，*setfacl*会自动调整掩码条目，使其成为所有组类条目的并集。（这里只有一个这样的条目：`ACL_GROUP_OBJ`。）如果我们希望防止这种调整，则必须为*setfacl*指定*-n*选项。
- en: Finally, we note that the *setfacl -b* option can be used to remove all extended
    entries from an ACL, leaving just the minimal (i.e., user, group, and other) entries.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们注意到可以使用*setfacl -b*选项来删除ACL中的所有扩展条目，仅保留最小的条目（即用户、组和其他）。
- en: Default ACLs and File Creation
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认ACL和文件创建
- en: 'In the discussion of ACLs so far, we have been describing *access* ACLs. As
    its name implies, an access ACL is used in determining the permissions that a
    process has when accessing the file associated with the ACL. We can create a second
    type of ACL on directories: a *default* ACL.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在目前对ACL的讨论中，我们描述的是*访问*ACL。顾名思义，访问ACL用于确定进程在访问与该ACL关联的文件时所具有的权限。我们还可以在目录上创建第二种类型的ACL：*默认*ACL。
- en: A default ACL plays no part in determining the permissions granted when accessing
    the directory. Instead, its presence or absence determines the ACL(s) and permissions
    that are placed on files and subdirectories that are created in the directory.
    (A default ACL is stored as an extended attribute named *system.posix_acl_default*.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认ACL在确定访问目录时所授予的权限中不起作用。相反，默认ACL的存在或缺失决定了在该目录中创建的文件和子目录所设置的ACL和权限。（默认ACL作为名为*system.posix_acl_default*的扩展属性存储。）
- en: To view and set the default ACL of a directory, we use the *-d* option of the
    *getfacl* and *setfacl* commands.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看和设置目录的默认ACL，我们使用*getfacl*和*setfacl*命令的*-d*选项。
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can remove a default ACL from a directory using the *setfacl -k* option.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*setfacl -k*选项从目录中移除默认ACL。
- en: 'If a directory has a default ACL, then:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个目录有默认ACL，则：
- en: A new subdirectory created in this directory inherits the directory’s default
    ACL as its default ACL. In other words, default ACLs propagate down through a
    directory tree as new subdirectories are created.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此目录中创建的新子目录会继承该目录的默认ACL作为其默认ACL。换句话说，默认ACL会在通过创建新的子目录时沿着目录树传播。
- en: 'A new file or subdirectory created in this directory inherits the directory’s
    default ACL as its access ACL. The ACL entries that correspond to the traditional
    file permission bits are masked (ANDed) against the corresponding bits of the
    *mode* argument in the system call (*open(), mkdir()*, and so on) used to create
    the file or subdirectory. By “corresponding ACL entries,” we mean:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该目录中创建的新文件或子目录会继承该目录的默认ACL作为其访问ACL。与传统文件权限位相对应的ACL条目将与用于创建文件或子目录的系统调用（*open(),
    mkdir()*等）中的*mode*参数相对应的位进行掩码（按位与）。所谓的“对应ACL条目”是指：
- en: '`ACL_USER_OBJ`;'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACL_USER_OBJ`；'
- en: '`ACL_MASK` or, if `ACL_MASK` is absent, then `ACL_GROUP_OBJ`; and'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACL_MASK` 或如果`ACL_MASK`缺失，则为`ACL_GROUP_OBJ`；并且'
- en: '`ACL_OTHER`.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACL_OTHER`。'
- en: 'When a directory has a default ACL, the process umask ([The Process File Mode
    Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo "The
    Process File Mode Creation Mask: umask()")) doesn’t play a part in determining
    the permissions in the entries of the access ACL of a new file created in that
    directory.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个目录有默认ACL时，进程umask（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "进程文件模式创建掩码：umask()")）在确定新创建文件的访问ACL条目的权限时不发挥作用。
- en: 'As an example of how a new file inherits its access ACL from the parent directory’s
    default ACL, suppose we used the following *open()* call to create a new file
    in the directory created above:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为新文件如何从父目录的默认ACL继承其访问ACL的示例，假设我们使用以下*open()*调用在上面创建的目录中创建了一个新文件：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The new file would have the following access ACL:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件将具有以下访问ACL：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If a directory doesn’t have a default ACL, then:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个目录没有默认ACL，则：
- en: New subdirectories created in this directory also do not have a default ACL.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此目录中创建的新子目录同样没有默认ACL。
- en: 'The permissions of the new file or directory are set following the traditional
    rules ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")): the file permissions are set
    to the value in the *mode* argument (given to *open()*, *mkdir()*, and so on),
    less the bits that are turned off by the process umask. This results in a minimal
    ACL on the new file.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新文件或目录的权限是根据传统规则设置的（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "进程文件模式创建掩码：umask()")）：文件权限设置为*mode*参数中的值（传递给*open()*, *mkdir()*等），减去进程umask关闭的位。这将导致新文件具有最小的ACL权限。
- en: ACL Implementation Limits
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACL 实现限制
- en: 'The various file-system implementations impose limits on the number of entries
    in an ACL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 各种文件系统实现对ACL中的条目数量施加了限制：
- en: On *ext2*, *ext3*, and *ext4*, the total number of ACLs on a file is governed
    by the requirement that the bytes in all of the names and values of a file’s extended
    attributes must be contained in a single logical disk block ([Extended Attribute
    Implementation Details](ch16.html#extended_attribute_implementation_detail "Extended
    Attribute Implementation Details")). Each ACL entry requires 8 bytes, so that
    the maximum number of ACL entries for a file is somewhat less (because of some
    overhead for the name of the extended attribute for the ACL) than one-eighth of
    the block size. Thus, a 4096-byte block size allows for a maximum of around 500
    ACL entries. (Kernels before 2.6.11 imposed an arbitrary limitation of 32 entries
    for ACLs on *ext2* and *ext3*.)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *ext2*、*ext3* 和 *ext4* 上，文件的 ACL 总数由以下要求决定：文件的所有扩展属性名称和值的字节必须包含在一个逻辑磁盘块中（[扩展属性实现细节](ch16.html#extended_attribute_implementation_detail
    "扩展属性实现细节")）。每个 ACL 条目需要 8 字节，因此文件的最大 ACL 条目数稍微少于（由于 ACL 的扩展属性名称的额外开销）块大小的八分之一。因此，4096
    字节的块大小允许最大约 500 个 ACL 条目。（2.6.11 版本之前的内核对 *ext2* 和 *ext3* 上的 ACL 强制限制为 32 条目。）
- en: On *XFS*, an ACL is limited to 25 entries.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *XFS* 上，ACL 被限制为 25 条目。
- en: On *Reiserfs* and *JFS*, ACLs can contain up to 8191 entries. This limit is
    a consequence of the size limitation (64 kB) imposed by the VFS on the value of
    an extended attribute ([Extended Attribute Implementation Details](ch16.html#extended_attribute_implementation_detail
    "Extended Attribute Implementation Details")).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Reiserfs* 和 *JFS* 上，ACL 最多可以包含 8191 条目。这个限制是由于 VFS 对扩展属性值的大小限制（64 kB）所导致的（[扩展属性实现细节](ch16.html#extended_attribute_implementation_detail
    "扩展属性实现细节")）。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, *Btrfs* limits ACLs to around 500 entries. However,
    since *Btrfs* was still under heavy development, this limit may change.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，*Btrfs* 将 ACL 限制为大约 500 条目。然而，由于 *Btrfs* 仍在积极开发中，这一限制可能会发生变化。
- en: 'Although most of the above file systems allow large numbers of entries to be
    created in an ACL, this should be avoided for the following reasons:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述大多数文件系统允许在 ACL 中创建大量条目，但应避免这样做，原因如下：
- en: The maintenance of lengthy ACLs becomes a complex and potentially error-prone
    system administration task.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间维护 ACL 会成为一个复杂且可能容易出错的系统管理任务。
- en: The amount of time required to scan the ACL for the matching entry (or matching
    entries in the case of group ID checks) increases linearly with the number of
    ACL entries.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描 ACL 以查找匹配项（或在进行组 ID 检查时匹配项）所需的时间，随着 ACL 条目的数量增加而线性增长。
- en: 'Generally, we can keep the number of ACL entries on a file down to a reasonable
    number by defining suitable groups in the system group file ([The Group File:
    `/etc/group`](ch08.html#the_group_file_colon__solidus_etc_solidu "The Group File:
    /etc/group")) and using those groups within the ACL.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以通过在系统组文件中定义合适的组（[组文件：`/etc/group`](ch08.html#the_group_file_colon__solidus_etc_solidu
    "组文件：/etc/group")）并在 ACL 中使用这些组，来将文件中的 ACL 条目数量保持在合理范围内。
- en: The ACL API
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACL API
- en: The POSIX.1e draft standard defined a large suite of functions and data structures
    for manipulating ACLs. Since they are so numerous, we won’t attempt to describe
    the details of all of these functions. Instead, we provide an overview of their
    usage and conclude with an example program.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX.1e 草案标准定义了一套庞大的函数和数据结构，用于操作 ACL。由于它们数量众多，我们不会尝试描述所有这些函数的细节。相反，我们提供其使用概述，并以一个示例程序作为结尾。
- en: Programs that use the ACL API should include `<sys/acl.h>`. It may also be necessary
    to include `<acl/libacl.h>` if the program makes use of various Linux extensions
    to the POSIX.1e draft standard. (A list of the Linux extensions is provided in
    the *acl(5)* manual page.) Programs using this API must be compiled with the *-lacl*
    option, in order to link against the *libacl* library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ACL API 的程序应包括 `<sys/acl.h>`。如果程序使用了 POSIX.1e 草案标准的各种 Linux 扩展，可能还需要包含 `<acl/libacl.h>`。（有关
    Linux 扩展的列表，请参见 *acl(5)* 手册页。）使用该 API 的程序必须使用 *-lacl* 选项进行编译，以便与 *libacl* 库进行链接。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As already noted, on Linux, ACLs are implemented using extended attributes,
    and the ACL API is implemented as a set of library functions that manipulate user-space
    data structures, and, where necessary, make calls to *getxattr()* and *setxattr()*
    to retrieve and modify the on-disk *system* extended attribute that holds the
    ACL representation. It is also possible (though not recommended) for an application
    to use *getxattr()* and *setxattr()* to manipulate ACLs directly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 Linux 上，ACL 是通过扩展属性实现的，ACL API 作为一组库函数实现，操作用户空间数据结构，并在必要时调用 *getxattr()*
    和 *setxattr()* 来检索和修改存储 ACL 表示的磁盘上的 *system* 扩展属性。应用程序也可以（尽管不推荐）直接使用 *getxattr()*
    和 *setxattr()* 来操作 ACL。
- en: Overview
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 概述
- en: The functions that constitute the ACL API are listed in the *acl(5)* manual
    page. At first sight, this plethora of functions and data structures can seem
    bewildering. [Figure 17-2](ch17.html#relationship_between_acl_library_functio
    "Figure 17-2. Relationship between ACL library functions and data structures")
    provides an overview of the relationship between the various data structures and
    indicates the use of many of the ACL functions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 组成 ACL API 的函数列在 *acl(5)* 手册页中。乍一看，这些众多的函数和数据结构可能会让人感到困惑。[图 17-2](ch17.html#relationship_between_acl_library_functio
    "图 17-2. ACL 库函数与数据结构之间的关系") 提供了各个数据结构之间关系的概览，并指出了许多 ACL 函数的使用。
- en: '![Relationship between ACL library functions and data structures](figs/web/17-2_ACL-ACL-API.png.jpg)Figure 17-2. Relationship
    between ACL library functions and data structures'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![ACL 库函数与数据结构之间的关系](figs/web/17-2_ACL-ACL-API.png.jpg)图 17-2. ACL 库函数与数据结构之间的关系'
- en: 'From [Figure 17-2](ch17.html#relationship_between_acl_library_functio "Figure 17-2. Relationship
    between ACL library functions and data structures"), we can see that the ACL API
    considers an ACL as a hierarchical object:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [图 17-2](ch17.html#relationship_between_acl_library_functio "图 17-2. ACL 库函数与数据结构之间的关系")
    中，我们可以看到 ACL API 将 ACL 视为一个层次化对象：
- en: An ACL consists of one or more ACL entries.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 ACL 由一个或多个 ACL 条目组成。
- en: Each ACL entry consists of a tag type, an optional tag qualifier, and a permission
    set.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 ACL 条目由一个标签类型、一个可选的标签限定符和一个权限集组成。
- en: We now look briefly at the various ACL functions. In most cases, we don’t describe
    the error returns from each function. Functions that return an integer (*status*)
    typically return 0 on success and -1 on error. Functions that return a handle
    (pointer) return `NULL` on error. Errors can be diagnosed using *errno* in the
    usual manner.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要地介绍一下各种 ACL 函数。在大多数情况下，我们不描述每个函数的错误返回值。返回整数（*status*）的函数通常在成功时返回 0，出错时返回
    -1。返回句柄（指针）的函数在出错时返回 `NULL`。可以通过常规方式使用 *errno* 来诊断错误。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A *handle* is an abstract term for some technique used to refer to an object
    or data structure. The representation of a handle is private to the API implementation.
    It may be, for example, a pointer, an array index, or a hash key.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*handle* 是指用于引用对象或数据结构的某种技术的抽象术语。句柄的表示方式对 API 实现是私有的。例如，它可以是指针、数组索引或哈希键。'
- en: Fetching a file’s ACL into memory
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将文件的 ACL 获取到内存中
- en: The *acl_get_file()* function retrieves a copy of the ACL of the file identified
    by *pathname*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_get_file()* 函数用于检索由 *pathname* 标识的文件的 ACL 副本。'
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function retrieves either the access ACL or the default ACL, depending
    on whether *type* is specified as `ACL_TYPE_ACCESS` or `ACL_TYPE_DEFAULT`. As
    its function result, *acl_get_file()* returns a handle (of type *acl_t*) for use
    with other ACL functions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数根据 *type* 是否指定为 `ACL_TYPE_ACCESS` 或 `ACL_TYPE_DEFAULT`，检索访问 ACL 或默认 ACL。作为其函数结果，*acl_get_file()*
    返回一个句柄（类型为 *acl_t*），供其他 ACL 函数使用。
- en: Retrieving entries from an in-memory ACL
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从内存中的 ACL 中检索条目
- en: The *acl_get_entry()* function returns a handle (of type *acl_entry_t*) referring
    to one of the ACL entries within the in-memory ACL referred to by its *acl* argument.
    This handle is returned in the location pointed to by the final function argument.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_get_entry()* 函数返回一个句柄（类型为 *acl_entry_t*），该句柄指向由 *acl* 参数引用的内存中 ACL 中的一个条目。此句柄返回到最后一个函数参数指向的位置。'
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The *entry_id* argument determines which entry’s handle is returned. If *entry_id*
    is specified as `ACL_FIRST_ENTRY`, then a handle for the first entry in the ACL
    is returned. *If entry_id* is specified as `ACL_NEXT_ENTRY`, then a handle is
    returned for the entry following the last ACL entry that was retrieved. Thus,
    we can loop through all of the entries in an ACL by specifying *type* as `ACL_FIRST_ENTRY`
    in the first call to *acl_get_entry()* and specifying *type* as `ACL_NEXT_ENTRY`
    in subsequent calls.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*entry_id* 参数决定返回哪个条目的句柄。如果 *entry_id* 被指定为 `ACL_FIRST_ENTRY`，则返回 ACL 中第一个条目的句柄。如果
    *entry_id* 被指定为 `ACL_NEXT_ENTRY`，则返回在上一个获取的 ACL 条目之后的条目的句柄。因此，我们可以通过在第一次调用 *acl_get_entry()*
    时指定 *type* 为 `ACL_FIRST_ENTRY`，并在随后的调用中将 *type* 指定为 `ACL_NEXT_ENTRY`，来遍历 ACL 中的所有条目。'
- en: The *acl_get_entry()* function returns 1 if it successfully fetches an ACL entry,
    0 if there are no more entries, or -1 on error.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_get_entry()* 函数返回 1 如果成功获取了一个 ACL 条目，返回 0 如果没有更多条目，或者返回 -1 如果发生错误。'
- en: Retrieving and modifying attributes in an ACL entry
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取和修改 ACL 条目中的属性
- en: The *acl_get_tag_type()* and *acl_set_tag_type()* functions retrieve and modify
    the tag type in the ACL entry referred to by their *entry* argument.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_get_tag_type()* 和 *acl_set_tag_type()* 函数用于获取和修改其 *entry* 参数所引用的 ACL 条目中的标签类型。'
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *tag_type* argument has the type *acl_type_t* (an integer type), and has
    one of the values `ACL_USER_OBJ`, `ACL_USER`, `ACL_GROUP_OBJ`, `ACL_GROUP`, `ACL_OTHER`,
    or `ACL_MASK`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*tag_type* 参数的类型是 *acl_type_t*（整数类型），并且它的值之一为 `ACL_USER_OBJ`、`ACL_USER`、`ACL_GROUP_OBJ`、`ACL_GROUP`、`ACL_OTHER`
    或 `ACL_MASK`。'
- en: 'The *acl_get_qualifier()* and *acl_set_qualifier()* functions retrieve and
    modify the tag qualifier in the ACL entry referred to by their *entry* argument.
    Here is an example, in which we assume that we have already determined that this
    is an `ACL_USER` entry by inspecting the tag type:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_get_qualifier()* 和 *acl_set_qualifier()* 函数用于获取和修改其 *entry* 参数所引用的 ACL
    条目中的标签限定符。以下是一个示例，我们假设通过检查标签类型已经确定这是一个 `ACL_USER` 条目：'
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The tag qualifier is valid only if the tag type of this entry is `ACL_USER`
    or `ACL_GROUP`. In the former case, *qualp* is a pointer to a user ID (*uid_t
    **); in the latter case, it is a pointer to a group ID (*gid_t **).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 标签限定符仅在该条目的标签类型为 `ACL_USER` 或 `ACL_GROUP` 时有效。在前者情况下，*qualp* 是指向用户 ID (*uid_t*)
    的指针；在后者情况下，*qualp* 是指向组 ID (*gid_t*) 的指针。
- en: The *acl_get_permset()* and *acl_set_permset()* functions retrieve and modify
    the permission set in the ACL entry referred to by their *entry* argument.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_get_permset()* 和 *acl_set_permset()* 函数用于获取和修改其 *entry* 参数所引用的 ACL 条目中的权限集。'
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The *acl_permset_t* data type is a handle referring to a permission set.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_permset_t* 数据类型是一个指向权限集的句柄。'
- en: 'The following functions are used to manipulate the contents of a permission
    set:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于操作权限集的内容：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In each of these calls, *perm* is specified as `ACL_READ`, `ACL_WRITE`, or
    `ACL_EXECUTE`, with the obvious meanings. These functions are used as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些调用中，*perm* 被指定为 `ACL_READ`、`ACL_WRITE` 或 `ACL_EXECUTE`，其含义显而易见。这些函数的使用方式如下：
- en: The *acl_get_perm()* function returns 1 (true) if the permission specified in
    *perm* is enabled in the permission set referred to by *permset*, or 0 if it is
    not. This function is a Linux extension to the POSIX.1e draft standard.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*acl_get_perm()* 函数返回 1（true）如果 *perm* 中指定的权限在 *permset* 所引用的权限集中被启用，返回 0 如果未启用。此函数是对
    POSIX.1e 草案标准的 Linux 扩展。'
- en: The *acl_add_perm()* function adds the permission specified in *perm* to the
    permission set referred to by *permset*.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*acl_add_perm()* 函数将 *perm* 中指定的权限添加到 *permset* 所引用的权限集。'
- en: The *acl_delete_perm()* function removes the permission specified in *perm*
    from the permission set referred to by *permset*. (It is not an error to remove
    a permission if it is not present in the set.)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*acl_delete_perm()* 函数从 *permset* 所引用的权限集中删除 *perm* 中指定的权限。（如果权限集没有该权限，删除该权限并不算错误。）'
- en: The *acl_clear_perms()* function removes all permissions from the permission
    set referred to by *permset*.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*acl_clear_perms()* 函数移除 *permset* 所引用的权限集中的所有权限。'
- en: Creating and deleting ACL entries
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建和删除 ACL 条目
- en: The *acl_create_entry()* function creates a new entry in an existing ACL. A
    handle referring to the new entry is returned in the location pointed to by the
    second function argument.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_create_entry()* 函数在现有 ACL 中创建一个新条目。一个指向新条目的句柄会通过第二个函数参数返回。'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The new entry can then be populated using the functions described previously.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 新条目可以通过之前描述的函数进行填充。
- en: The *acl_delete_entry()* function removes an entry from an ACL.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_delete_entry()* 函数从 ACL 中移除一个条目。'
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Updating a file’s ACL
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新文件的 ACL
- en: The *acl_set_file()* function is the converse of *acl_get_file()*. It updates
    the on-disk ACL with the contents of the in-memory ACL referred to by its *acl*
    argument.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_set_file()* 函数是 *acl_get_file()* 的反向操作。它使用内存中由 *acl* 参数所指的 ACL 内容更新磁盘上的
    ACL。'
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The *type* argument is either `ACL_TYPE_ACCESS`, to update the access ACL, or
    `ACL_TYPE_DEFAULT`, to update a directory’s default ACL.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*type* 参数可以是 `ACL_TYPE_ACCESS`，用于更新访问 ACL，或 `ACL_TYPE_DEFAULT`，用于更新目录的默认 ACL。'
- en: Converting an ACL between in-memory and text form
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在内存和文本形式之间转换 ACL
- en: The *acl_from_text()* function translates a string containing a long or short
    text form ACL into an in-memory ACL, and returns a handle that can be used to
    refer to the ACL in subsequent function calls.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_from_text()* 函数将包含长文本形式或短文本形式的 ACL 字符串转换为内存中的 ACL，并返回一个可以在后续函数调用中引用的句柄。'
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The *acl_to_text()* function performs the reverse conversion, returning a long
    text form string corresponding to the ACL referred to by its *acl* argument.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_to_text()* 函数执行反向转换，返回一个长文本字符串，对应其 *acl* 参数所指代的 ACL。'
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the *len* argument is not specified as `NULL`, then the buffer it points
    to is used to return the length of the string returned as the function result.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *len* 参数未指定为 `NULL`，则它指向的缓冲区用于返回作为函数结果返回的字符串的长度。
- en: Other functions in the ACL API
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ACL API 中的其他函数
- en: The following paragraphs describe several other commonly used ACL functions
    that are not shown in [Figure 17-2](ch17.html#relationship_between_acl_library_functio
    "Figure 17-2. Relationship between ACL library functions and data structures").
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下段落描述了几个常用的 ACL 函数，这些函数未在 [图 17-2](ch17.html#relationship_between_acl_library_functio
    "图 17-2. ACL 库函数与数据结构的关系") 中显示。
- en: The *acl_calc_mask(&acl)* function calculates and sets the permissions in the
    `ACL_MASK` entry of the in-memory ACL whose handle is pointed to by its argument.
    Typically, we use this function whenever we create or modify an ACL. The `ACL_MASK`
    permissions are calculated as the union of the permissions in all `ACL_USER`,
    `ACL_GROUP`, and `ACL_GROUP_OBJ` entries. A useful property of this function is
    that it creates the `ACL_MASK` entry if it doesn’t already exist. This means that
    if we add `ACL_USER` and `ACL_GROUP` entries to a previously minimal ACL, then
    we can use this function to ensure the creation of the `ACL_MASK` entry.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_calc_mask(&acl)* 函数计算并设置内存中由其参数指向的 ACL 的 `ACL_MASK` 条目的权限。通常，每当我们创建或修改
    ACL 时都会使用此函数。`ACL_MASK` 的权限是所有 `ACL_USER`、`ACL_GROUP` 和 `ACL_GROUP_OBJ` 条目权限的并集。此函数的一个有用特性是，如果
    `ACL_MASK` 条目不存在，它会创建该条目。这意味着如果我们向一个先前最小的 ACL 中添加了 `ACL_USER` 和 `ACL_GROUP` 条目，我们可以使用此函数确保创建
    `ACL_MASK` 条目。'
- en: 'The *acl_valid(acl)* function returns 0 if the ACL referred to by its argument
    is valid, or -1 otherwise. An ACL is valid if all of the following are true:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_valid(acl)* 函数如果其参数所指的 ACL 有效，则返回 0；否则返回 -1。ACL 是有效的，当且仅当以下所有条件成立：'
- en: the `ACL_USER_OBJ`, `ACL_GROUP_OBJ`, and `ACL_OTHER` entries appear exactly
    once;
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACL_USER_OBJ`、`ACL_GROUP_OBJ` 和 `ACL_OTHER` 条目只出现一次；'
- en: there is an `ACL_MASK` entry if any `ACL_USER` or `ACL_GROUP` entries are present;
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在任何 `ACL_USER` 或 `ACL_GROUP` 条目，则会有一个 `ACL_MASK` 条目；
- en: there is at most one `ACL_MASK` entry;
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至多只有一个 `ACL_MASK` 条目；
- en: each `ACL_USER` entry has a unique user ID; and
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `ACL_USER` 条目都有一个唯一的用户 ID；
- en: each `ACL_GROUP` entry has a unique group ID.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`ACL_GROUP`条目都有一个唯一的组ID。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *acl_check()* and *acl_error()* functions (the latter is a Linux extension)
    are alternatives to *acl_valid()* that are less portable, but provide a more precise
    description of the error in a malformed ACL. See the manual pages for details.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_check()* 和 *acl_error()* 函数（后者是 Linux 扩展）是 *acl_valid()* 的替代方案，尽管它们的可移植性较差，但提供了对格式错误的
    ACL 更精确的错误描述。详见手册页面。'
- en: The *acl_delete_def_file(pathname)* function removes the default ACL on the
    directory referred to by *pathname*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_delete_def_file(pathname)* 函数移除由 *pathname* 指定的目录的默认 ACL。'
- en: The *acl_init(count)* function creates a new, empty ACL structure that initially
    contains space for at least *count* ACL entries. (The *count* argument is a hint
    to the system about intended usage, not a hard limit.) A handle for the new ACL
    is returned as the function result.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_init(count)* 函数创建一个新的空的 ACL 结构，最初包含足够空间以容纳至少 *count* 个 ACL 条目。（*count*
    参数是对系统的使用提示，而不是硬性限制。）该函数返回新 ACL 的句柄。'
- en: The *acl_dup(acl)* function creates a duplicate of the ACL referred to by *acl*
    and returns a handle for the duplicate ACL as its function result.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_dup(acl)* 函数创建一个与 *acl* 所引用的 ACL 相同的副本，并返回该副本的句柄作为其函数结果。'
- en: The *acl_free(handle)* function frees memory allocated by other ACL functions.
    For example, we must use *acl_free()* to free memory allocated by calls to *acl_from_text()*,
    *acl_to_text()*, *acl_get_file()*, *acl_init()*, and *acl_dup()*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl_free(handle)* 函数释放由其他 ACL 函数分配的内存。例如，我们必须使用 *acl_free()* 来释放由调用 *acl_from_text()*、*acl_to_text()*、*acl_get_file()*、*acl_init()*
    和 *acl_dup()* 分配的内存。'
- en: Example program
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 17-1](ch17.html#display_the_access_or_default_acl_on_a_f "Example 17-1. Display
    the access or default ACL on a file") demonstrates the use of some of the ACL
    library functions. This program retrieves and displays the ACL on a file (i.e.,
    it provides a subset of the functionality of the *getfacl* command). If the *-d*
    command-line option is specified, then the program displays the default ACL (of
    a directory) instead of the access ACL.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-1](ch17.html#display_the_access_or_default_acl_on_a_f "示例 17-1. 显示文件的访问或默认
    ACL") 演示了某些 ACL 库函数的使用。此程序检索并显示文件上的 ACL（即，它提供了 *getfacl* 命令的子集功能）。如果指定了 *-d* 命令行选项，则程序显示的是默认
    ACL（目录的 ACL），而不是访问 ACL。'
- en: 'Here is an example of the use of this program:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此程序的示例：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code distribution of this book also includes a program, `acl/acl_update.c`,
    that performs updates on an ACL (i.e., it provides a subset of the functionality
    of the *setfacl* command).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的源代码分发版还包括一个程序 `acl/acl_update.c`，用于更新 ACL（即它提供了 *setfacl* 命令的子集功能）。
- en: Example 17-1. Display the access or default ACL on a file
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-1. 显示文件的访问或默认 ACL
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: From version 2.6 onward, Linux supports ACLs. ACLs extend the traditional UNIX
    file permissions model, allowing file permissions to be controlled on a per-user
    and per-group basis.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.6 版本开始，Linux 支持 ACL。ACL 扩展了传统的 UNIX 文件权限模型，允许在用户和组级别上控制文件权限。
- en: Further information
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: The final versions (*Draft 17*) of the draft POSIX.1e and POSIX.2c standards
    are available online at [http://wt.tuxomania.net/publications/posix.1e/](http://wt.tuxomania.net/publications/posix.1e/).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 草案 POSIX.1e 和 POSIX.2c 标准的最终版本（*草案 17*）可以在线获取，网址为 [http://wt.tuxomania.net/publications/posix.1e/](http://wt.tuxomania.net/publications/posix.1e/)。
- en: The *acl(5)* manual page gives an overview of ACLs and some guidance on the
    portability of the various ACL library functions implemented on Linux.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*acl(5)* 手册页概述了 ACL 及其在 Linux 上实现的各种 ACL 库函数的可移植性指南。'
- en: Details of the Linux implementation of ACLs and extended attributes can be found
    in [Grünbacher, 2003]. Andreas Grünbacher maintains a web site containing information
    about ACLs at [http://acl.bestbits.at/](http://acl.bestbits.at/).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Linux 中 ACL 和扩展属性的实现细节可以参见 [Grünbacher, 2003]。Andreas Grünbacher 维护了一个包含有关
    ACL 信息的网站：[http://acl.bestbits.at/](http://acl.bestbits.at/)。
- en: Exercise
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Write a program that displays the permissions from the ACL entry that corresponds
    to a particular user or group. The program should take two command-line arguments.
    The first argument is either of the letters *u* or *g*, indicating whether the
    second argument identifies a user or group. (The functions defined in [Example 8-1](ch08.html#functions_to_convert_user_and_group_ids
    "Example 8-1. Functions to convert user and group IDs to and from user and group
    names"), in [Example program](ch08.html#example_program-id5 "Example program"),
    can be used to allow the second command-line argument to be specified numerically
    or as a name.) If the ACL entry that corresponds to the given user or group falls
    into the group class, then the program should additionally display the permissions
    that would apply after the ACL entry has been modified by the ACL mask entry.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，显示与特定用户或组对应的 ACL 条目的权限。该程序应接受两个命令行参数。第一个参数是 *u* 或 *g* 中的一个字母，表示第二个参数是用户还是组。（[示例
    8-1](ch08.html#functions_to_convert_user_and_group_ids "示例 8-1. 将用户和组 ID 转换为用户和组名称的函数")
    中定义的函数可以用来允许第二个命令行参数以数字或名称形式指定。）如果与给定用户或组对应的 ACL 条目属于组类，则程序应额外显示 ACL 条目被 ACL 掩码条目修改后的适用权限。
