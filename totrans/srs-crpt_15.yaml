- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: QUANTUM AND POST-QUANTUM
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 量子与后量子
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Previous chapters focused on cryptography today, but in this chapter I’ll examine
    the future of cryptography over a time horizon of, say, a century or more—one
    in which *quantum computers* exist. Quantum computers are computers that leverage
    phenomena from quantum physics in order to run different kinds of algorithms than
    the ones we’re used to. Quantum computers don’t exist yet and look very hard to
    build, but if they do exist one day, then they’ll have the potential to break
    RSA, Diffie–Hellman, and elliptic curve cryptography—that is, all the public-key
    crypto deployed or standardized as of this writing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节主要关注当今的密码学，但在本章中，我将探讨密码学的未来，时间跨度大约是一个世纪或更长——一个*量子计算机*存在的时代。量子计算机是利用量子物理现象来运行不同类型算法的计算机，区别于我们习惯的算法。量子计算机目前还不存在，看起来也很难建造，但如果有一天它们存在，那么它们将有潜力突破RSA、Diffie–Hellman和椭圆曲线密码学——也就是本文所提到的所有已经部署或标准化的公钥加密算法。
- en: To insure against the risk posed by quantum computers, crypto­graphy researchers
    have developed alternative public-key crypto algorithms called *post-quantum*
    algorithms that would resist quantum computers. In 2015, the NSA called for a
    transition to quantum-resistant algorithms designed to be safe even in the face
    of quantum computers, and in 2017 the US standardization agency NIST began a process
    that will eventually standardize post-quantum algorithms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对量子计算机带来的风险，密码学研究人员开发了替代性的公钥加密算法，这些算法被称为*后量子*算法，能够抵抗量子计算机的攻击。2015年，NSA（美国国家安全局）呼吁转向量子抗性算法，这些算法旨在即使在面对量子计算机时也能保持安全，2017年，美国标准化机构NIST开始了一个过程，最终将标准化后量子算法。
- en: This chapter will thus give you a nontechnical overview of the principles behind
    quantum computers as well as a glimpse of post-quantum algorithms. There’s some
    math involved, but nothing more than basic arithmetic and linear algebra, so don’t
    be scared by the unusual notations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您提供量子计算机背后的原理的非技术性概述，并简要介绍后量子算法。虽然涉及一些数学内容，但仅限于基础算术和线性代数，因此不要被这些不常见的符号吓到。
- en: How Quantum Computers Work
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量子计算机的工作原理
- en: Quantum computing is a model of computing that uses quantum physics to compute
    differently and do things that classical computers can’t, such as breaking RSA
    and elliptic curve cryptography efficiently. But a quantum computer is not a super-fast
    normal computer. In fact, quantum computers can’t solve any problem that is too
    hard for a classical computer, such as brute force search or **NP**-complete problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算是一种利用量子物理进行不同计算的计算模型，它能够完成经典计算机无法做到的事情，比如高效破解RSA和椭圆曲线密码学。但量子计算机并不是一种超快的普通计算机。事实上，量子计算机无法解决任何经典计算机无法解决的问题，比如暴力破解或**NP**-完全问题。
- en: 'Quantum computers are based on quantum mechanics, the branch of physics that
    studies the behavior of subatomic particles, which behave truly randomly. Unlike
    classical computers, which operate on bits that are either 0 or 1, quantum computers
    are based on *quantum bits* (or *qubits*), which can be both 0 and 1 simultaneously—a
    state of ambiguity called *superposition*. Physicists discovered that in this
    microscopic world, particles such as electrons and photons behave in a highly
    counterintuitive way: before you observe an electron, the electron is not at a
    definite location in space, but in several locations at the same time (that is,
    in a state of superposition). But once you observe it—an operation called *measurement*
    in quantum physics—then it stops at a fixed, random location and is no longer
    in superposition. This quantum magic is what enables the creation of qubits in
    a quantum computer.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算机基于量子力学，量子力学是研究亚原子粒子行为的物理学分支，而这些粒子的行为是真正随机的。与操作0或1的经典计算机不同，量子计算机基于*量子比特*（或*量子位*），它们可以同时是0和1——这种状态叫做*叠加*。物理学家发现，在这个微观世界中，电子和光子等粒子表现出一种极其反直觉的方式：在你观察电子之前，它并不位于空间的某个确定位置，而是同时位于多个位置（也就是处于叠加状态）。但是，一旦你观察它——这在量子物理中叫做*测量*——它就会停留在一个固定的、随机的位置，并不再处于叠加状态。这种量子魔力使得量子计算机能够创建量子位。
- en: 'But quantum computers only work because of a crazier phenomenon called *entanglement*:
    two particles can be connected (entangled) in a way that observing the value of
    one gives the value of the other, even if the two particles are widely separated
    (kilometers or even light-years away from each other). This behavior is illustrated
    by the *Einstein–Podolsky–Rosen (EPR)* *paradox* and is the reason why Albert
    Einstein initially dismissed quantum mechanics. (See *[https://plato.stanford.edu/entries/qt-epr/](https://plato.stanford.edu/entries/qt-epr/)*
    for an in-depth explanation of why.)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但量子计算机之所以能够工作，是因为一个更为疯狂的现象，称为*纠缠*：两个粒子可以以一种方式连接（纠缠），使得观察其中一个粒子的值能够得出另一个粒子的值，即使这两个粒子相距遥远（可能相隔数公里甚至光年）。这种行为通过*爱因斯坦–波多尔斯基–罗森（EPR）*
    *悖论*得以说明，这也是阿尔伯特·爱因斯坦最初否定量子力学的原因。（详见 *[https://plato.stanford.edu/entries/qt-epr/](https://plato.stanford.edu/entries/qt-epr/)*，了解其深入解释。）
- en: To best explain how a quantum computer works, we should distinguish the actual
    quantum computer (the hardware, composed of quantum bits) from quantum algorithms
    (the software that runs on it, composed of *quantum gates*). The next two sections
    discuss these two notions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地解释量子计算机的工作原理，我们应当区分实际的量子计算机（由量子比特组成的硬件）和量子算法（在其上运行的软件，由*量子门*组成）。接下来的两部分将讨论这两个概念。
- en: '*Quantum Bits*'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*量子比特*'
- en: Quantum bits (qubits), or groups thereof, are characterized with numbers called
    *amplitudes*, which are akin to probabilities but aren’t *exactly* probabilities.
    Whereas a probability is a number between 0 and 1, an amplitude is a complex number
    of the form *a* + *b* × *i*, or simply *a* + *bi*, where *a* and *b* are real
    numbers, and *i* is an *imaginary unit*. The number *i* is used to form *imaginary
    numbers*, which are of the form *bi*, with *b* a real number. When *i* is multiplied
    by a real number, we get another imaginary number, and when it is multiplied by
    itself it gives –1; that is *i*² = –1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特（qubits）或其组合由称为*幅度*的数字来描述，这些幅度类似于概率，但并不*完全*是概率。概率是介于0和1之间的数字，而幅度是一个形如*a*
    + *b* × *i*（或简单地说是*a* + *bi*）的复数，其中*a*和*b*是实数，*i*是*虚数单位*。数字*i*用于形成*虚数*，其形式为*bi*，其中*b*为实数。当*i*与实数相乘时，我们得到另一个虚数，而当*i*与自己相乘时，结果为-1；也就是说*i*²
    = -1。
- en: Unlike real numbers, which can be seen as belonging to a line (see [Figure 14-1](ch14.xhtml#ch14fig1)),
    *complex numbers* can be seen as belonging to a plane (a space with two dimensions),
    as shown in [Figure 14-2](ch14.xhtml#ch14fig2). Here, the x-axis in the figure
    corresponds to the *a* in *a* + *bi*, the y-axis corresponds to the *b*, and the
    dotted lines correspond to the real and imaginary part of each number. For example,
    the vertical dotted line going from the point 3 + 2*i* down to 3 is two units
    long (the 2 in the imaginary part 2*i*).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与实数不同，实数可以看作属于一条直线（见[图14-1](ch14.xhtml#ch14fig1)），*复数*可以看作属于一个平面（一个二维空间），如[图14-2](ch14.xhtml#ch14fig2)所示。这里，图中的x轴对应于*a*
    + *bi*中的*a*，y轴对应于*b*，虚线对应于每个数字的实部和虚部。例如，从点3 + 2*i*垂直向下到3的虚线长为2（即虚部2*i*中的2）。
- en: '![image](../images/f14-01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f14-01.jpg)'
- en: '*Figure 14-1: View of real numbers as points on an infinite straight line*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：实数作为无限直线上的点的展示*'
- en: '![image](../images/f14-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f14-02.jpg)'
- en: '*Figure 14-2: A view of complex numbers as points in a two-dimensional space*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：复数作为二维空间中的点的展示*'
- en: As you can see in [Figure 14-2](ch14.xhtml#ch14fig2), you can use the Pythagorean
    theorem to compute the length of the line going from the origin (0) to the point
    *a* + *bi* by viewing this line as the diagonal of a triangle. The length of this
    diagonal is equal to the square root of the sum of the squared coordinates of
    the point, or √(*a*² + *b*²), which we call the *modulus* of the complex number
    *a* + *bi*. We denote the modulus as |*a* + *bi*| and can use it as the length
    of a complex number.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图14-2](ch14.xhtml#ch14fig2)中所见，你可以利用毕达哥拉斯定理计算从原点（0）到点*a* + *bi*的线段长度，方法是将这条线看作一个三角形的对角线。这条对角线的长度等于该点坐标平方和的平方根，即√(*a*²
    + *b*²)，我们称其为复数*a* + *bi*的*模*。我们用|*a* + *bi*|表示模，并可以将其作为复数的长度。
- en: In a quantum computer, registers consist of 1 or more qubits in a state of superposition
    characterized by a set of such complex numbers. But as we’ll see, these complex
    numbers—the amplitudes—can’t be any numbers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子计算机中，寄存器由1个或多个量子比特组成，这些量子比特处于由一组这样的复数组成的叠加状态中。但正如我们将看到的，这些复数——幅度——不能是任意的数字。
- en: Amplitudes of a Single Qubit
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单个量子比特的幅度
- en: A single qubit is characterized by two amplitudes that I’ll call α (alpha) and
    β (beta). We can then express a qubit’s state as α |0〉 + β |1〉, where the “| 〉”
    notation is used to denote vectors in a quantum state. This notation then means
    that when you observe this qubit it will appear as 0 with a probability |α|² and
    1 with a probability |β|². Of course, in order for these to be actual probabilities,
    |α|² and |β|² must be numbers between 0 and 1, and |α|² + |β|² must be equal to
    1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的量子比特由两个振幅组成，分别称为 α（alpha）和 β（beta）。我们可以将量子比特的状态表示为 α |0〉 + β |1〉，其中“| 〉”符号用于表示量子态中的向量。这种表示意味着，当你观察这个量子比特时，它出现0的概率为
    |α|²，出现1的概率为 |β|²。当然，为了让这些成为实际的概率，|α|² 和 |β|² 必须是介于 0 和 1 之间的数字，并且 |α|² + |β|²
    必须等于 1。
- en: 'For example, say we have the qubit ![image](../images/psi.jpg) (psi) with amplitudes
    of α = 1/√2 and β = 1/√2. We can express this as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个量子比特 ![image](../images/psi.jpg)（psi），其振幅为 α = 1/√2 和 β = 1/√2。我们可以将其表示为以下形式：
- en: '![image](../images/f0254-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0254-01.jpg)'
- en: 'This notation means that in the qubit ![image](../images/psi.jpg), the value
    0 has an amplitude of 1/√2, and the value 1 has the same amplitude, 1/√2. To get
    the actual probability from the amplitudes, we compute the modulus of 1/√2 (which
    is equal to 1/√2, because it has no imaginary part), then square it: (1/√2)² =
    1/2\. That is, if you observe the qubit ![image](../images/psi.jpg), you’ll have
    a 1/2 chance of seeing a 0, and the same chance of seeing a 1.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表示意味着在量子比特 ![image](../images/psi.jpg) 中，值0的振幅为1/√2，而值1的振幅也为1/√2。为了从振幅中得到实际的概率，我们计算1/√2的模（它等于1/√2，因为它没有虚部），然后将其平方：(1/√2)²
    = 1/2。也就是说，如果你观察量子比特 ![image](../images/psi.jpg)，你有1/2的机会看到0，同样也有1/2的机会看到1。
- en: Now consider the qubit Φ (phi), where
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑量子比特 Φ（phi），其中
- en: '![image](../images/f0254-02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0254-02.jpg)'
- en: 'The qubit Φ is fundamentally distinct from ![image](../images/psi.jpg) because
    unlike ![image](../images/psi.jpg), where amplitudes have equal values, the qubit
    Φ has distinct amplitudes of α = *i*/√2 (a positive imaginary number) and β =
    –1/√2 (a negative real number). If, however, you observe Φ, the chance of your
    seeing a 0 or 1 is 1/2, the same as it is with ![image](../images/psi.jpg). Indeed,
    we can compute the probability of seeing a 0 as follows, based on the preceding
    rules:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特 Φ 与 ![image](../images/psi.jpg) 本质上是不同的，因为与 ![image](../images/psi.jpg)
    中的振幅相等不同，量子比特 Φ 的振幅为 α = *i*/√2（一个正的虚数）和 β = –1/√2（一个负的实数）。然而，如果你观察 Φ，看到0或1的机会是1/2，与
    ![image](../images/psi.jpg) 相同。事实上，我们可以根据之前的规则计算出看到0的概率：
- en: '![image](../images/f0254-03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0254-03.jpg)'
- en: '**NOTE**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because* α = i/√2, α *can be written as* a + bi *with* a = 0 *and* b = 1/√2,
    *and computing* |α| = √(a² + b²) *yields* 1/√2.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为* α = i/√2，α *可以写成* a + bi *形式，其中* a = 0 *且* b = 1/√2，*并且计算* |α| = √(a²
    + b²) *得到* 1/√2。'
- en: 'The upshot is that different qubits can behave similarly to an observer (with
    the same probability of seeing a 0 for both qubits) but have different amplitudes.
    This tells us that the actual probabilities of seeing a 0 or a 1 only partially
    characterize a qubit; just as when you observe the shadow of an object on a wall,
    the shape of the shadow will give you an idea of the object’s width and height,
    but not of its depth. In the case of qubits, this hidden dimension is the value
    of its amplitude: Is it positive or negative? Is it a real number or an imaginary
    number?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，不同的量子比特对观察者的表现可能相似（两个量子比特看到0的概率相同），但它们的振幅不同。这告诉我们，实际观察到0或1的概率仅部分地描述了一个量子比特；就像你观察墙上的物体影子时，影子的形状能让你了解物体的宽度和高度，但无法了解其深度。对于量子比特而言，这个隐藏的维度就是它的振幅值：它是正数还是负数？是实数还是虚数？
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To simplify notations, a qubit is often simply written as its pair of amplitudes*
    (α, β). *Our previous example can then be written* |![image](../images/psi.jpg)〉
    = (1/√2, 1/√2).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简化符号，量子比特通常仅写作其振幅对*（α, β）。*我们之前的例子可以写作* |![image](../images/psi.jpg)〉 =
    (1/√2, 1/√2)。'
- en: Amplitudes of Groups of Qubits
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 量子比特组的振幅
- en: 'We’ve explored single qubits, but how do we understand multiple qubits? For
    example, a *quantum byte* can be formed with 8 qubits, when put into a state where
    the quantum states of these 8 qubits are somehow connected to each other (we say
    that the qubits are entangled, which is a complex physical phenomenon). Such a
    quantum byte can be described as follows, where the αs are the amplitudes associated
    with each of the 256 possible values of the group of 8 qubits:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了单个量子比特，但如何理解多个量子比特呢？例如，一个*量子字节*可以由8个量子比特组成，当这8个量子比特的量子态相互联系时（我们称这些量子比特是纠缠的，这是一种复杂的物理现象）。这样的量子字节可以如下描述，其中α是与这8个量子比特的256个可能值对应的幅度：
- en: '![image](../images/f0255-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0255-01.jpg)'
- en: Note that we must have |α[0]|² + |α[1]|² + … + |α[255]|² = 1, so that all probabilities
    sum to 1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须有|α[0]|² + |α[1]|² + … + |α[255]|² = 1，确保所有概率的总和为1。
- en: Our group of 8 qubits can be viewed as a set of 2⁸ = 256 amplitudes, because
    it has 256 possible configurations, each with its own amplitude. In physical reality,
    however, you’d only have eight physical objects, not 256\. The 256 amplitudes
    are an implicit characteristic of the group of 8 qubits; each of these 256 numbers
    can take any of infinitely many different values. Generalizing, a group of *n*
    qubits is characterized by a set of 2^(*n*) complex numbers, a number that grows
    exponentially with the numbers of qubits.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的8个量子比特可以视为一组2⁸ = 256个幅度，因为它有256种可能的配置，每种配置都有其对应的幅度。然而，在物理现实中，你只有8个物理对象，而不是256个。256个幅度是这8个量子比特的一个隐式特性；这些256个数字中的每一个可以取任意数量的不同值。泛化来说，一组*n*个量子比特由一组2^(*n*)个复数组成，这个数字随着量子比特数量的增加而指数级增长。
- en: 'This encoding of exponentially many high-precision complex numbers is a core
    reason why a classical computer can’t simulate a quantum computer: in order to
    do so, it would need an unfathomably high amount of memory (of size around 2^(*n*))
    to store the same amount of information contained in only *n* qubits.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对大量高精度复数的编码是经典计算机无法模拟量子计算机的核心原因：为了做到这一点，经典计算机需要一个无法估量的巨大内存量（大小大约为2^(*n*)），来存储仅由*n*个量子比特所包含的相同信息。
- en: '*Quantum Gates*'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*量子门*'
- en: The concepts of amplitude and quantum gates are unique to quantum computing.
    Whereas a classical computer uses registers, memory, and a microprocessor to perform
    a sequence of instructions on data, a quantum computer transforms a group of qubits
    reversibly by applying a series of quantum gates, and then measures the value
    of one or more qubits. Quantum computers promise more computing power because
    with only *n* qubits, they can process 2^(*n*) numbers (the qubits’ amplitudes).
    This property has profound implications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幅度和量子门的概念是量子计算的独特之处。与经典计算机使用寄存器、内存和微处理器来执行一系列数据指令不同，量子计算机通过应用一系列量子门反向转换一组量子比特，然后测量一个或多个量子比特的值。量子计算机承诺提供更强的计算能力，因为仅用*n*个量子比特，它们就可以处理2^(*n*)个数字（量子比特的幅度）。这一特性具有深远的意义。
- en: From a mathematical standpoint, quantum algorithms are essentially a circuit
    of *quantum gates* that transforms a set of complex numbers (the amplitudes) before
    a final measurement where the value of 1 or more qubits is observed (see [Figure
    14-3](ch14.xhtml#ch14fig3)). You’ll also see quantum algorithms referred to as
    *quantum gate arrays* or *quantum circuits*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，量子算法本质上是一个*量子门*的电路，它在最终测量之前将一组复数（幅度）进行转换，在最终测量中会观察到一个或多个量子比特的值（见[图14-3](ch14.xhtml#ch14fig3)）。你也会看到量子算法被称为*量子门阵列*或*量子电路*。
- en: '![image](../images/f14-03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f14-03.jpg)'
- en: '*Figure 14-3: Principle of a quantum algorithm*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：量子算法原理*'
- en: Quantum Gates as Matrix Multiplications
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 量子门作为矩阵乘法
- en: 'Unlike the Boolean gates of a classical computer (AND, XOR, and so on), a quantum
    gate acts on a group of amplitudes just as a matrix acts when multi­plied with
    a vector. For example, in order to apply the simplest quantum gate, the *identity*
    gate, to the qubit Φ, we see *I* as a 2 × 2 matrix and multiply it with the column
    vector consisting of the two amplitudes of Φ, as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典计算机的布尔门（如与门、异或门等）不同，量子门作用于一组幅度，就像矩阵在与向量相乘时的作用一样。例如，为了对量子比特Φ应用最简单的量子门——*恒等*门，我们将*I*视为一个2
    × 2矩阵，并将其与包含Φ的两个幅度的列向量相乘，如下所示：
- en: '![image](../images/f0256-01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0256-01.jpg)'
- en: The result of this matrix–vector multiplication is another column vector with
    two elements, where the top value is equal to the dot product of the *I* matrix’s
    first line with the input vector (the result of adding the product of the first
    elements 1 and *i*/√2 to the product of the second elements 0 and –1/√2), and
    likewise for the bottom value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该矩阵–向量乘法的结果是另一个包含两个元素的列向量，其中顶部的值等于*I*矩阵的第一行与输入向量的点积（即第一元素1与*i*/√2的乘积加上第二元素0与–1/√2的乘积），底部值同理。
- en: '**NOTE**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In practice, a quantum computer wouldn’t explicitly compute matrix–vector
    multiplications because the matrices would be way too large. (That’s why quantum
    computing can’t be simulated by a classical computer.) Instead, a quantum computer
    would transform qubits as physical particles through physical transformations
    that are equivalent to a matrix multiplication. Confused? Here’s what Richard
    Feynman had to say: “If you are not completely confused by quantum mechanics,
    you do not understand it.”*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，量子计算机不会显式计算矩阵–向量乘法，因为矩阵会非常大。（这也是为什么量子计算不能被经典计算机模拟的原因。）相反，量子计算机会通过物理转换来变换量子比特，物理转换等价于矩阵乘法。困惑吗？理查德·费曼曾经说过：“如果你对量子力学不完全困惑，那你就不理解它。”*'
- en: The Hadamard Quantum Gate
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 哈达玛量子门
- en: 'The only quantum gate we’ve seen so far, the identity gate *I*, is pretty useless
    because it doesn’t do anything and leaves a qubit unchanged. Now we’re going to
    see one of the most useful quantum gates, called the *Hadamard gate*, usually
    denoted *H*. The Hadamard gate is defined as follows (note the negative value
    in the bottom-right position):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的唯一量子门是单位矩阵*I*，它几乎没什么用，因为它不做任何操作，保持量子比特不变。现在我们将看到一个最有用的量子门，叫做*哈达玛门*，通常表示为*H*。哈达玛门的定义如下（请注意右下角的负值）：
- en: '![image](../images/f0256-02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0256-02.jpg)'
- en: 'Let’s see what happens if we apply this gate to the qubit |![image](../images/psi.jpg)〉
    = (1/√2, 1/√2):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们将这个门应用于量子比特|![image](../images/psi.jpg)〉 = (1/√2, 1/√2)时会发生什么：
- en: '![image](../images/f0257-01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0257-01.jpg)'
- en: 'By applying the Hadamard gate *H* to |![image](../images/psi.jpg)〉, we obtain
    the qubit |0〉 for which the value |0〉 has amplitude 1, and |1〉 has amplitude 0\.
    This tells us that the qubit will behave deterministically: that is, if you observe
    this qubit, you would always see a 0 and never a 1\. In other words, we’ve lost
    the randomness of the initial qubit |![image](../images/psi.jpg)〉.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将哈达玛门*H*应用于|![image](../images/psi.jpg)〉，我们得到量子比特|0〉，其值|0〉的振幅为1，|1〉的振幅为0。这告诉我们该量子比特将表现出确定性：也就是说，如果你观察这个量子比特，你总是会看到0，而不会看到1。换句话说，我们已经失去了初始量子比特|![image](../images/psi.jpg)〉的随机性。
- en: What happens if we apply the Hadamard gate again to the qubit |0〉?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次对量子比特|0〉应用哈达玛门，会发生什么？
- en: '![image](../images/f0257-02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0257-02.jpg)'
- en: This brings us back to the qubit |![image](../images/psi.jpg)〉 and a randomized
    state. Indeed, the Hadamard gate is often used in quantum algorithms to go from
    a deterministic state to a uniformly random one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带回到量子比特|![image](../images/psi.jpg)〉和一个随机化的状态。实际上，哈达玛门常用于量子算法中，用来将一个确定性状态转化为均匀随机的状态。
- en: Not All Matrices are Quantum Gates
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 并非所有矩阵都是量子门
- en: Although quantum gates can be seen as matrix multiplications, not all matrices
    correspond to quantum gates. Recall that a qubit consists of the complex numbers
    α and β and the amplitudes of the qubit, such that they satisfy the condition
    |α|² + |β|² = 1\. If after multiplying a qubit by a matrix we get two amplitudes
    that don’t match this condition, the result can’t be a qubit. Quantum gates can
    only correspond to matrices that preserve the property |α|² + |β|² = 1, and matrices
    that satisfy this condition are called *unitary matrices*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管量子门可以看作是矩阵乘法，但并不是所有的矩阵都对应于量子门。回想一下，量子比特由复数α和β组成，并且量子比特的振幅满足条件|α|² + |β|² =
    1。如果在将量子比特与矩阵相乘后，我们得到的两个振幅不满足这个条件，那么结果就不能是量子比特。量子门只能对应于那些保持|α|² + |β|² = 1性质的矩阵，这样的矩阵被称为*单位矩阵*。
- en: Unitary matrices (and quantum gates by definition) are *invertible*, meaning
    that given the result of an operation, you can compute back the original qubit
    by applying the *inverse* matrix. This is the reason why quantum computing is
    said to be a kind of *reversible computing*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵（以及量子门的定义）是*可逆*的，这意味着给定一个操作的结果，你可以通过应用*逆*矩阵计算回原始的量子比特。这也是为什么量子计算被称为一种*可逆计算*的原因。
- en: Quantum Speed-Up
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量子加速
- en: A *quantum speed-up* occurs when a problem can be solved faster by a quantum
    computer than by a classical one. For example, in order to search for an item
    among *n* items of an unordered list on a classical computer, you need on average
    *n*/2 operations, because you need to look at each item in the list before finding
    the one you’re looking for. (On average, you’ll find that item after searching
    half of the list.) No classical algorithm can do better than *n*/2\. However,
    a quantum algorithm exists to search for an item in only about √*n* operations,
    which is orders of magnitude smaller than *n*/2\. For example, if *n* is equal
    to 1000000, then *n*/2 is 500000, whereas √*n* is 1000.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*量子加速*指的是一个问题能通过量子计算机比经典计算机更快地解决。例如，在经典计算机上查找一个无序列表中的 *n* 个项目时，平均需要 *n*/2 次操作，因为你需要查看列表中的每一项，直到找到你要找的项。（平均来说，你会在搜索列表一半时找到目标项。）没有任何经典算法能够比
    *n*/2 更快。然而，量子算法能够在大约 √*n* 次操作中完成搜索，这比 *n*/2 要小得多。例如，如果 *n* 为 1000000，则 *n*/2
    为 500000，而 √*n* 为 1000。'
- en: We attempt to quantify the difference between quantum and classical algorithms
    in terms of *time complexity*, which is represented by *O*() notation. In the
    previous example, the quantum algorithm runs in time *O*(√*n*) but the classical
    algorithm can’t be faster than *O*(*n*). Because the difference in time complexity
    here is due to the square exponent, we call this *quadratic* *speed-up*. But while
    such a speed-up will likely make a difference, there are much more powerful ones.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图通过 *时间复杂度* 来量化量子算法和经典算法之间的差异，时间复杂度用 *O*() 符号表示。在前面的例子中，量子算法的时间复杂度是 *O*(√*n*)，而经典算法的时间复杂度则不可能快于
    *O*(*n*)。由于这里时间复杂度的差异来自于平方指数，我们称这种加速为 *二次* *加速*。虽然这种加速可能带来一定的差异，但还有更强大的加速方式。
- en: '*Exponential Speed-Up and Simon’s Problem*'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*指数加速与西蒙问题*'
- en: '*Exponential speed-ups* are the Holy Grail of quantum computing. They occur
    when a task that takes an exponential amount of time on a classical computer,
    such as *O*(2^(*n*)), can be performed on a quantum computer with polynomial complexity—namely
    *O*(*n*^(*k*)) for some fixed number *k*. This exponential speed-up can turn a
    practically impossible task into a possible one. (Recall from [Chapter 9](ch09.xhtml#ch9)
    that cryptographers and complexity theorists associate exponential time with the
    impossible, and they associate polynomial time with the practical.)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数加速*是量子计算的圣杯。当在经典计算机上需要指数时间（如 *O*(2^(*n*))) 才能完成的任务，在量子计算机上却能以多项式复杂度完成——即以
    *O*(*n*^(*k*)) 的时间复杂度完成，其中 *k* 为某个固定常数。这种指数加速能将一个几乎不可能完成的任务转变为可行的任务。（回忆一下[第9章](ch09.xhtml#ch9)，密码学家和复杂性理论家将指数时间与不可能的任务相关联，而将多项式时间与实际可行的任务相关联。）'
- en: The poster child of exponential speed-ups is *Simon’s problem*. In this computational
    problem, a function, **f**(), transforms *n*-bit strings to *n*-bit strings, such
    that the output of **f**() looks random except that there is a value, *m*, such
    that any two values *x*, *y* that satisfies **f**(*x*) = **f**(*y*), then *y*
    = *x* ⊕ *m*. The way to solve this problem is to find *m*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 指数加速的代表性问题是 *西蒙问题*。在这个计算问题中，一个函数 **f**() 将 *n* 位的字符串转换为 *n* 位的字符串，使得 **f**()
    的输出看起来是随机的，除了有一个值 *m*，使得任何满足 **f**(*x*) = **f**(*y*) 的两个值 *x* 和 *y*，都有 *y* = *x*
    ⊕ *m*。解决这个问题的方法是找到 *m*。
- en: The route to take when solving Simon’s problem with a classical algorithm boils
    down to finding a collision, which takes approximately 2^(*n*/2) queries to **f**().
    However, a quantum algorithm (shown in [Figure 14-4](ch14.xhtml#ch14fig4)) can
    solve Simon’s problem in approximately *n* queries, with the extremely efficient
    time complexity of *O*(*n*).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用经典算法解决西蒙问题的路线归结为找到一个碰撞，这大约需要 2^(*n*/2) 次查询 **f**()。然而，量子算法（如[图 14-4](ch14.xhtml#ch14fig4)所示）能够在大约
    *n* 次查询内解决西蒙问题，且其极高效的时间复杂度为 *O*(*n*)。
- en: '![image](../images/f14-04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f14-04.jpg)'
- en: '*Figure 14-4: The circuit of the quantum algorithm that solves Simon’s problem
    efficiently*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：解决西蒙问题的量子算法电路*'
- en: As you can see in [Figure 14-4](ch14.xhtml#ch14fig4), you initialize 2*n* qubits
    to |0〉, apply Hadamard gates (*H*) to the first *n* qubits, then apply the gate
    *Q***f** to the two groups of all *n* qubits. Given two *n*-qubit groups *x* and
    *y*, the gate *Q***f** transforms the quantum state |*x*〉|*y*〉 to the state |*x*〉|**f**(*x*)
    ⊕ *y*〉. That is, it computes the function **f**() on the quantum state reversibly,
    because you can go from the new state to the old one by computing **f**(*x*) and
    XORing it to **f**(*x*) ⊕ *y*. (Unfortunately, explaining why all of this works
    is beyond the scope of this book.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 14-4](ch14.xhtml#ch14fig4)中看到的那样，你将2*n*个量子比特初始化为|0〉，对前*n*个量子比特应用Hadamard门（*H*），然后对两组*n*量子比特应用*Q***f**门。给定两个*n*量子比特组*x*和*y*，*Q***f**门将量子态|*x*〉|*y*〉转换为|*x*〉|**f**(*x*)
    ⊕ *y*〉。也就是说，它对量子态**f**(*)进行可逆计算，因为你可以通过计算**f**(*x*)并与**f**(*x*) ⊕ *y*进行异或运算来从新状态回到旧状态。（不幸的是，解释为什么这一切有效超出了本书的范围。）
- en: The exponential speed-up for Simon’s problem can be used against symmetric ciphers
    only in very specific cases, but in the next section you’ll see some real crypto-killer
    applications of quantum computing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对Simon问题的指数加速只能在非常特定的情况下对称加密算法起作用，但在接下来的部分，你将看到量子计算的真正“杀手级”加密应用。
- en: '*The Threat of Shor’s Algorithm*'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Shor算法的威胁*'
- en: In 1995, AT&T researcher Peter Shor published an eye-opening article titled
    “Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on
    a Quantum Computer.” *Shor’s algorithm* is a quantum algorithm that causes an
    exponential speed-up when solving the factoring, discrete logarithm (DLP), and
    elliptic curve discrete logarithm (ECDLP) problems. You can’t solve these problems
    with a classical computer, but you could with a quantum computer. That means that
    you could use a quantum computer to solve any cryptographic algorithm that relies
    on those problems, including RSA, Diffie–Hellman, elliptic curve crypto­graphy,
    and all currently deployed public-key cryptography mechanisms. In other words,
    you could reduce the security of RSA or elliptic curve crypto­graphy to that of
    Caesar’s cipher. (Shor might as well have titled his article “Breaking All Public-Key
    Crypto on a Quantum Computer.”) Shor’s algorithm has been called “one of the major
    scientific achievements of the late 20th century” by renowned complexity theorist
    Scott Aaronson.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，AT&T的研究员Peter Shor发表了一篇开创性的文章，题为“在量子计算机上进行素因数分解和离散对数的多项式时间算法”。*Shor的算法*是一种量子算法，在解决因式分解、离散对数（DLP）和椭圆曲线离散对数（ECDLP）问题时能够实现指数级的加速。你无法使用经典计算机解决这些问题，但你可以用量子计算机来解决。这意味着你可以使用量子计算机解决任何依赖这些问题的密码算法，包括RSA、Diffie-Hellman、椭圆曲线密码学以及所有当前部署的公钥密码学机制。换句话说，你可以将RSA或椭圆曲线密码学的安全性降低到凯撒密码的水平。（Shor也可以将他的文章标题定为“在量子计算机上破解所有公钥密码学”）Shor的算法被著名的复杂性理论学家Scott
    Aaronson称为“20世纪末期的主要科学成就之一”。
- en: Shor’s algorithm actually solves a more general class of problems than factoring
    and discrete logarithms. Specifically, if a function **f**() is *periodic*—that
    is, if there’s a ω (the period) such that **f**(*x* + ω) = **f**(*x*) for any
    *x*, Shor’s algorithm will efficiently find ω. (This looks very similar to Simon’s
    problem discussed previously, and indeed Simon’s algorithm was a major inspiration
    for Shor’s algorithm.) The ability of Shor’s algorithm to efficiently compute
    the period of a function is important to cryptographers because that ability can
    be used to attack public-key cryptography, as I’ll discuss next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Shor的算法实际上解决了一类比因式分解和离散对数更为广泛的问题。具体来说，如果一个函数**f**(*)是*周期性的*——即，如果存在一个ω（周期），使得对于任何*x*都有**f**(*x*
    + ω) = **f**(*x*)，那么Shor的算法将有效地找到ω。（这看起来与前面讨论的Simon问题非常相似，事实上Simon的算法是Shor算法的一个重要灵感来源。）Shor算法高效计算函数周期的能力对密码学家来说非常重要，因为这种能力可以用于攻击公钥密码学，正如我接下来会讨论的那样。
- en: A discussion of the details of how Shor’s algorithm achieves its speed-up is
    far too technical for this book, but in this section I’ll show how you could use
    Shor’s algorithm to attack public-key cryptography. Let’s see how Shor’s algorithm
    could be used to solve the factoring and discrete logarithm problems (as discussed
    in [Chapter 9](ch09.xhtml#ch9)), which are respectively the hard problems behind
    RSA and Diffie–Hellman.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论Shor算法如何实现其加速的细节对于本书来说过于技术化，但在这一节中，我将展示如何使用Shor算法攻击公钥密码学。我们来看看Shor的算法如何用来解决因式分解和离散对数问题（如[第9章](ch09.xhtml#ch9)所讨论的），这分别是RSA和Diffie-Hellman背后的难题。
- en: '*Shor’s Algorithm Solves the Factoring Problem*'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Shor 算法解决因式分解问题*'
- en: Say you want to factor a large number, *N* = *pq*. It’s easy to factor *N* if
    you can compute the period of *a*^(*x*) mod *N*, a task that is hard to do with
    a classical computer but easy to do on a quantum one. You first pick a random
    number *a* less than *N*, and ask Shor’s algorithm to find the period ω of the
    function **f**(*x*) = *a*^(*x*) mod *N*. Once you’ve found the period, you’ll
    have *a*^(*x*) mod *N* = *a*^(*x* + ω) mod *N* (that is, *a*^(*x*) mod *N* = *a*^x*a*^ω
    mod *N*), which means that *a*^ω mod *N* = 1, or *a*^ω – 1 mod *N* = 0\. In other
    words, *a*^ω – 1 is a multiple of *N*, or *a*^(ω – 1) = *kN* for some unknown
    number *k*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想因式分解一个大数 *N* = *pq*。如果你能计算出 *a*^(*x*) mod *N* 的周期，那么分解 *N* 就变得容易了。这个任务在经典计算机上很难做到，但在量子计算机上却很容易。你首先选择一个小于
    *N* 的随机数 *a*，然后让 Shor 算法找到函数 **f**(*x*) = *a*^(*x*) mod *N* 的周期 ω。找到周期后，你会得到 *a*^(*x*)
    mod *N* = *a*^(*x* + ω) mod *N*（即，*a*^(*x*) mod *N* = *a*^x *a*^ω mod *N*），这意味着
    *a*^ω mod *N* = 1，或者 *a*^ω – 1 mod *N* = 0。换句话说，*a*^ω – 1 是 *N* 的倍数，或者 *a*^(ω
    – 1) = *kN*，其中 *k* 是一个未知的数值。
- en: The key observation here is that you can easily factor the number *a*^(ω – 1)
    as the product of two terms, where *a*^(ω – 1) = (*a*^(ω / 2) – 1)(*a*^(ω / 2)
    + 1). You can then compute the greatest common divisor (GCD) between (*a*^(ω /
    2) – 1) and *N*, and check to see if you’ve obtained a nontrivial factor of *N*
    (that is, a value other than 1 or *N*). If not, you can just rerun the same algorithm
    with another value of *a*. After a few trials, you’ll get a factor of *N*. You’ve
    now recovered the private RSA key from its public key, which allows you to decrypt
    messages or forge signatures.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键观察是，你可以轻松地将数字 *a*^(ω – 1) 因式分解为两个项的乘积，其中 *a*^(ω – 1) = (*a*^(ω / 2) – 1)(*a*^(ω
    / 2) + 1)。然后，你可以计算 (*a*^(ω / 2) – 1) 和 *N* 之间的最大公约数（GCD），并检查是否已经找到了 *N* 的一个非平凡因子（即，除了
    1 或 *N* 之外的值）。如果没有，你可以使用另一个值 *a* 再次运行相同的算法。经过几次试验，你将找到 *N* 的一个因子。你现在已经从公钥恢复了私钥，这使得你可以解密消息或伪造签名。
- en: But just how easy is this computation? Note that the best classical algorithm
    to use to factor a number *N* runs in time exponential in *n*, the bit length
    of *N* (that is, *n* = log[2] *N*). However, Shor’s algorithm runs in time *polynomial*
    in *n*—namely, *O*(*n*²(log *n*)(log log *n*)). This means that if we had a quantum
    computer, we could run Shor’s algorithm and see the result within a reasonable
    amount of time (days? weeks? months, maybe?) instead of thousands of years.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个计算到底有多简单呢？请注意，经典算法中用于因式分解一个数 *N* 的最佳算法，运行时间是指数级别的，取决于 *N* 的位长 *n*（即，*n*
    = log[2] *N*）。然而，Shor 算法的运行时间是 *n* 的多项式时间——即 *O*(*n*²(log *n*)(log log *n*)）。这意味着，如果我们有一台量子计算机，我们可以运行
    Shor 算法，并在合理的时间内（几天？几周？也许几个月？）看到结果，而不是几千年。
- en: '*Shor’s Algorithm and the Discrete Logarithm Problem*'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Shor 算法与离散对数问题*'
- en: The challenge in the discrete logarithm problem is to find *y*, given *y* =
    *g*^(*x*) mod *p*, for some known numbers *g* and *p*. Solving this problem takes
    an exponential amount of time on a classical computer, but Shor’s algorithm lets
    you find *y* easily thanks to its efficient period-finding technique.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 离散对数问题的挑战在于给定 *y* = *g*^(*x*) mod *p*，找出 *y* 的值，其中 *g* 和 *p* 是已知的数值。解决这个问题在经典计算机上需要指数时间，但
    Shor 算法通过其高效的周期查找技术使得你可以轻松找到 *y*。
- en: For example, consider the function **f**(*a*, *b*) = *g*^(*a*)*y*^(*b*). Say
    we want to find the period of this function, the numbers ω and ω′, such that **f**(*a*
    + ω, *b* + ω′) = **f**(*a*, *b*) for any *a* and *b*. The solution we seek is
    then *x* = –ω / ω′ modulo *q*, the order of *g*, which is a known parameter. The
    equality **f**(*a* + ω, *b* + ω′) = **f**(*a*, *b*) implies *g*^ω*y*^(ω′) mod
    *p* = 1\. By substituting *y* with *g*^(*x*), we have *g*^(ω + xω′) mod *p* =
    1, which is equivalent to ω + *x*ω′ mod *q* = 0, from which we derive *x* = –
    ω / ω′.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑函数 **f**(*a*, *b*) = *g*^(*a*)*y*^(*b*)。假设我们想找到该函数的周期，即数字 ω 和 ω′，使得 **f**(*a*
    + ω, *b* + ω′) = **f**(*a*, *b*) 对任意 *a* 和 *b* 成立。那么，我们寻求的解是 *x* = –ω / ω′ 模 *q*，其中
    *g* 的阶 *q* 是已知的参数。等式 **f**(*a* + ω, *b* + ω′) = **f**(*a*, *b*) 暗示 *g*^ω *y*^(ω′)
    mod *p* = 1。通过将 *y* 替换为 *g*^(*x*)，我们得到 *g*^(ω + xω′) mod *p* = 1，等价于 ω + *x*ω′
    mod *q* = 0，从而得到 *x* = –ω / ω′。
- en: Again, the overall complexity is *O*(*n*²(log *n*)(log log *n*)), with *n* the
    bit length of *p*. This algorithm generalizes to find discrete logarithms in any
    commutative group, not just the group of numbers modulo a prime number.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，整体复杂度为 *O*(*n*²(log *n*)(log log *n*))，其中 *n* 是 *p* 的位长。该算法可以推广到求解任何交换群中的离散对数，而不仅仅是质数模数的数值群。
- en: '*Grover’s Algorithm*'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Grover 算法*'
- en: After Shor’s algorithm exponential speed-up for factoring, another important
    form of quantum speed-up is the ability to search among *n* items in time proportional
    to the square root of *n*, whereas any classical algorithm would take time proportional
    to *n*. This quadratic speed-up is possible thanks to *Grover’s algorithm*, a
    quantum algorithm discovered in 1996 (after Shor’s algorithm). I won’t cover the
    internals of Grover’s algorithm because they’re essentially a bunch of Hadamard
    gates, but I’ll explain what kind of problem Grover solves and its potential impact
    on cryptographic security. I’ll also show why you can salvage a symmetric crypto
    algorithm from quantum computers by doubling the key or hash value size, whereas
    asymmetric algorithms are destroyed for good.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Shor 算法实现因式分解的指数级加速之后，量子加速的另一重要形式是能够在时间上与 *n* 的平方根成比例地在 *n* 个项目中进行搜索，而任何经典算法都需要与
    *n* 成比例的时间。这种二次加速得益于 *格罗弗算法*，这是一种在 1996 年（Shor 算法之后）发现的量子算法。我不会深入讲解格罗弗算法的内部原理，因为它基本上就是一堆
    Hadamard 门，但我会解释格罗弗算法能解决什么样的问题，以及它对加密安全性的潜在影响。我还将展示为什么通过将对称加密算法的密钥或哈希值大小翻倍，你可以从量子计算机中“拯救”它，而非对称算法则无法挽救。
- en: Think of Grover’s algorithm as a way to find the value *x* among *n* possible
    values, such that **f**(*x*) = 1, and where **f**(*x*) = 0 for most other values.
    If *m* values of *x* satisfy **f**(*x*) = 1, Grover will find a solution in time
    *O*(√(*n* / *m*)); that is, in time proportional to the square root of *n* divided
    by *m*. In comparison, a classical algorithm can’t do better than *O*(*n* / *m*).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将格罗弗算法看作是一种在 *n* 个可能值中找到值 *x* 的方法，使得 **f**(*x*) = 1，而对于其他大多数值，**f**(*x*) = 0。如果有
    *m* 个 *x* 满足 **f**(*x*) = 1，格罗弗算法将以时间 *O*(√(*n* / *m*)) 找到解决方案；也就是说，所需时间与 *n*
    除以 *m* 的平方根成比例。相比之下，经典算法的最优时间为 *O*(*n* / *m*)。
- en: 'Now consider the fact that **f**() can be any function. It could be, for example,
    “**f**(*x*) = 1 if and only if *x* is equal to the unknown secret key *K* such
    that **E**(*K*, *P*) = *C*” for some known plaintext *P* and ciphertext *C*, and
    where **E**() is some encryption function. In practice, this means that if you’re
    looking for a 128-bit AES key with a quantum computer, you’ll find the key in
    time proportional to 2^(64), rather than 2^(128) if you had only classical computers.
    You would need a large enough plaintext to ensure the uniqueness of the key. (If
    the plaintext and ciphertext are, say, 32 bits, many candidate keys would map
    that plaintext to that ciphertext.) The complexity 2^(64) is much smaller than
    2^(128), meaning that a secret key would be much easier to recover. But there’s
    an easy solution: to restore 128-bit security, just use 256-bit keys! Grover’s
    algorithm will then reduce the complexity of searching a key to “only” 2^(256
    / 2) = 2^(128) operations.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑到 **f**() 可以是任何函数。例如，它可以是“**f**(*x*) = 1 当且仅当 *x* 等于未知的秘密密钥 *K*，使得 **E**(*K*,
    *P*) = *C*”，其中 *P* 是已知的明文，*C* 是已知的密文，**E**() 是某种加密函数。实际上，这意味着，如果你使用量子计算机寻找一个 128
    位的 AES 密钥，你将在时间上与 2^(64) 成比例地找到密钥，而不是像仅使用经典计算机时那样需要 2^(128) 的时间。你需要足够大的明文来确保密钥的唯一性。（如果明文和密文都是
    32 位，许多候选密钥可能将这个明文映射到这个密文。）复杂度 2^(64) 远小于 2^(128)，这意味着恢复一个秘密密钥要容易得多。但有一个简单的解决方案：为了恢复
    128 位的安全性，只需使用 256 位的密钥！这样，格罗弗算法将把搜索密钥的复杂度减少到“仅” 2^(256 / 2) = 2^(128) 次操作。
- en: Grover’s algorithm can also find preimages of hash functions (a notion discussed
    in [Chapter 6](ch06.xhtml#ch6)). To find a preimage of some value *h*, the **f**()
    function is defined as “**f**(*x*) = 1 if and only if **Hash**(*x*) = *h*, otherwise
    **f**(*x*) = 0.” Grover thus gets you preimages of *n*-bit hashes at the cost
    of the order of 2^(*n*/2) operations. As with encryption, to ensure 2^(*n*) *post-quantum*
    security, just use hash values twice as large, since Grover’s algorithm will find
    a preimage of a 2*n*-bit value in at least 2^(*n*) operations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 格罗弗算法还可以找到哈希函数的前像（这是在[第6章](ch06.xhtml#ch6)中讨论的一个概念）。为了找到某个值 *h* 的前像，**f**()
    函数被定义为“**f**(*x*) = 1 当且仅当 **Hash**(*x*) = *h*，否则 **f**(*x*) = 0。”因此，格罗弗算法可以在大约
    2^(*n*/2) 次操作的代价下找到 *n* 位哈希的前像。与加密类似，为了确保 2^(*n*) 的 *后量子* 安全性，只需使用大小为两倍的哈希值，因为格罗弗算法将在至少
    2^(*n*) 次操作中找到 2*n* 位值的前像。
- en: The bottom line is that you can salvage symmetric crypto algorithms from quantum
    computers by doubling the key or hash value size, whereas asymmetric algorithms
    are destroyed for good.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结论是，你可以通过将对称加密算法的密钥或哈希值大小翻倍，从量子计算机中“拯救”对称加密算法，而非对称算法则无法挽救。
- en: '**NOTE**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There is a quantum algorithm that finds hash function collisions in time*
    O(2^(n/3)), *instead of* O(2^(n/2)), *as with the classic birthday attack. This
    would suggest that quantum computers can outperform classical computers for finding
    hash function collisions, except that the* O(2^(n/3)*)-time quantum algorithm
    also requires* O(2^(n/3)) *space, or memory, in order to run. Give* O(2^(n/3))
    *worth of computer space to a classic algorithm and it can run a parallel collision
    search algorithm with a collision time of only* O(2^(n/6)), *which is much faster
    than the* O(2^(n/3)) *quantum algorithm. (For details of this attack, see “Cost
    Analysis of Hash Collisions” by Daniel J. Bernstein at* [http://cr.yp.to/papers.html#collisioncost](http://cr.yp.to/papers.html#collisioncost).)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一种量子算法可以在时间* O(2^(n/3)) *内找到哈希函数的碰撞，* *而不是* O(2^(n/2))，* *就像经典的生日攻击那样。这表明量子计算机在寻找哈希函数碰撞方面可能优于经典计算机，*
    *除非是* O(2^(n/3)) *时间的量子算法还需要* O(2^(n/3)) *的空间或内存来运行。给经典算法提供* O(2^(n/3)) *的计算空间，它可以运行一个并行碰撞搜索算法，碰撞时间仅为*
    O(2^(n/6))，* *比* O(2^(n/3)) *的量子算法快得多。 (有关此攻击的详细信息，请参见 Daniel J. Bernstein 的《哈希碰撞的成本分析》
    [http://cr.yp.to/papers.html#collisioncost](http://cr.yp.to/papers.html#collisioncost)。)'
- en: Why Is It So Hard to Build a Quantum Computer?
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么构建量子计算机如此困难？
- en: Although quantum computers can in principle be built, we don’t know how hard
    it will be or when that might happen, if at all. And so far, it looks really hard.
    As of early 2017, the record holder is a machine that is able to keep 14 (fourteen!)
    qubits stable for only a few milliseconds, whereas we’d need to keep millions
    of qubits stable for weeks in order to break any crypto. The point is, we’re not
    there yet.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管量子计算机在理论上是可以构建的，但我们不知道它会有多难，或者它何时能够实现，甚至是否能实现。到目前为止，看起来真的非常困难。截止到2017年初，记录保持者是一台能够将14（十四！）个量子比特稳定保持几毫秒的机器，而我们需要将数百万个量子比特稳定保持几周才能破解任何加密。关键是，我们还没有做到这一点。
- en: Why is it so hard to build a quantum computer? Because you need extremely small
    things to play the role of qubits—about the size of electrons or photons. And
    because qubits must be so small, they’re also extremely fragile.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么构建量子计算机如此困难？因为你需要极小的物体来充当量子比特——大约是电子或光子的大小。由于量子比特必须如此微小，它们也极其脆弱。
- en: Qubits must also be kept at extremely low temperatures (close to absolute zero)
    in order to remain stable. But even at such a freezing temperature, the state
    of the qubits decays, and they eventually become useless. As of this writing,
    we don’t yet know how to make qubits that will last for more than a couple of
    seconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特必须保持在极低的温度（接近绝对零度），以保持稳定性。但是即使在如此寒冷的温度下，量子比特的状态也会衰退，最终变得无用。到目前为止，我们还不知道如何制造能保持超过几秒钟的量子比特。
- en: Another challenge is that qubits can be affected by the environment, such as
    heat and magnetic fields, which can create noise in the system, and hence computation
    errors. In theory, it’s possible to deal with these errors (as long as the error
    rate isn’t too high), but it’s hard to do so. Correcting qubits’ errors requires
    specific techniques called quantum error-correcting codes, which in turn require
    additional qubits and a low enough rate of error. But we don’t know how to build
    systems with such a low error rate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是量子比特可能会受到环境的影响，比如热量和磁场，这些因素会在系统中产生噪声，从而导致计算错误。理论上，我们可以处理这些错误（只要错误率不是太高），但实际上非常困难。修正量子比特的错误需要特定的技术，称为量子错误纠正码，这些技术又需要额外的量子比特和足够低的错误率。但我们不知道如何构建具有如此低错误率的系统。
- en: 'At the moment, there are two main approaches to forming qubits, and therefore
    to building quantum computers: superconducting circuits and ion traps. Using *superconducting
    circuits* is the approach championed by labs at Google and IBM. It’s based on
    forming qubits as tiny electrical circuits that rely on quantum phenomena from
    superconductor materials, where charge carriers are pairs of electrons. Qubits
    made of superconducting circuits need to be kept at temperatures close to absolute
    zero, and they have a very short lifetime. The record as of this writing is nine
    qubits kept stable for a few microseconds.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，形成量子比特并因此构建量子计算机的主要方法有两种：超导电路和离子阱。使用*超导电路*是谷歌和IBM实验室主张的方法。它基于将量子比特形成为依赖于超导材料量子现象的微小电路，其中电荷载体是电子对。由超导电路制成的量子比特需要保持在接近绝对零度的温度下，并且它们的寿命非常短。截止目前，保持稳定的量子比特数量最多为九个，并且稳定时间仅为几微秒。
- en: '*Ion traps*, or trapped ions, are made up of ions (charged atoms) and are manipulated
    using lasers in order to prepare the qubits in specific initial states. Using
    ion traps was one of the first approaches to building qubits, and they tend to
    be more stable than superconducting circuits. The record as of this writing is
    14 qubits stable for a few milliseconds. But ion traps are slower to operate and
    seem harder to scale than superconducting circuits.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*离子阱*，即被困离子，由带电的原子组成，使用激光操控以将量子比特准备为特定的初始状态。使用离子阱是构建量子比特的最早方法之一，且它们通常比超导电路更稳定。截止目前的纪录是14个量子比特在几毫秒内保持稳定。但离子阱操作较慢，且在扩展性上似乎不如超导电路。'
- en: Building a quantum computer is really a moonshot effort. The challenge comes
    down to 1) building a system with a handful of qubits that is stable, fault tolerant,
    and capable of applying basic quantum gates, and 2) scaling such a system to thousands
    or millions of qubits to make it useful. From a purely physical standpoint, and
    to the best of our knowledge, there is nothing to prevent the creation of large
    fault-tolerant quantum computers. But many things are possible in theory and prove
    hard or too costly to realize in practice (like secure computers). Of course,
    the future will tell who is right—the quantum optimists (who sometimes predict
    a large quantum computer in ten years) or the quantum skeptics (who argue that
    the human race will never see a quantum computer).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构建量子计算机真的是一项雄心勃勃的任务。挑战在于：1）构建一个具有少量量子比特的系统，该系统稳定、容错并能够应用基本的量子门操作；2）将这样的系统扩展到数千或数百万个量子比特，以使其变得实用。从纯物理学角度来看，根据我们目前的知识，并没有什么能阻止构建大型容错量子计算机的出现。但许多事情在理论上是可能的，却在实践中证明难以实现或成本过高（例如安全计算机）。当然，未来将证明谁是对的——量子乐观主义者（他们有时预测十年内会有大型量子计算机）还是量子怀疑论者（他们认为人类永远不会看到量子计算机的诞生）。
- en: Post-Quantum Cryptographic Algorithms
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后量子加密算法
- en: The field of *post-quantum cryptography* is about designing public-key algorithms
    that cannot be broken by a quantum computer; that is, they would be quantum safe
    and able to replace RSA and elliptic curve–based algorithms in a future where
    off-the-shelf quantum computers could break 4096-bit RSA moduli in a snap.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*后量子密码学*领域致力于设计无法被量子计算机破解的公钥算法；也就是说，它们将是量子安全的，并能够在量子计算机可以轻松破解4096位RSA模数的未来，取代RSA和基于椭圆曲线的算法。'
- en: Such algorithms should not rely on a hard problem known to be efficiently solvable
    by Shor’s algorithm, which kills the hardness in factoring and discrete logarithm
    problems. Symmetric algorithms such as block ciphers and hash functions would
    lose only half their theoretical security in the face of a quantum computer but
    would not be badly broken as RSA. They might constitute the basis for a post-quantum
    scheme.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法不应依赖于已知可以通过 Shor 算法高效求解的难题，因为 Shor 算法破坏了因式分解和离散对数问题的难度。对称算法，如分组密码和哈希函数，在面对量子计算机时，理论安全性只会降低一半，但不会像
    RSA 那样被彻底破解。它们可能构成后量子方案的基础。
- en: 'In the following sections, I explain the four main types of post-quantum algorithms:
    code-based, lattice-based, multivariate, and hash-based. Of these, hash-based
    is my favorite because of its simplicity and strong security guarantees.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几节中，我将解释四种主要的后量子算法类型：基于编码的、基于格的、多变量的和基于哈希的。其中特别喜欢基于哈希的，因为它简单且具有强大的安全保障。
- en: '*Code-Based Cryptography*'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基于编码的加密学*'
- en: Code-based post-quantum cryptographic algorithms are based on *error-correcting
    codes*, which are techniques designed to transmit bits over a noisy channel. The
    basic theory of error-correcting codes dates back to the 1950s. The first code-based
    encryption scheme (the *McEliece* cryptosystem) was developed in 1978 and is still
    unbroken. Code-based crypto schemes can be used for both encryption and signatures.
    Their main limitation is the size of their public key, which is typically on the
    order of a hundred kilobytes. But is that really a problem when the average size
    of a web page is around two megabytes?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 基于编码的后量子加密算法基于*纠错码*，这是一种旨在通过噪声信道传输比特的技术。纠错码的基本理论可以追溯到20世纪50年代。第一个基于编码的加密方案（*McEliece*
    加密系统）于1978年开发，至今未被攻破。基于编码的加密方案既可用于加密也可用于签名。它们的主要限制是公钥的大小，通常在几百千字节的数量级。但当网页的平均大小约为两兆字节时，这真的是个问题吗？
- en: 'Let me first explain what error-correcting codes are. Say you want to transmit
    a sequence of bits as a sequence of (say) 3-bit words, but the transmission is
    unreliable and you’re concerned that 1 or more bits may be incorrectly transmitted:
    you send 010, but the receiver gets 011\. One simple way to address this would
    be to use a very basic error-correction code: instead of transmitting 010 you
    would transmit 000111000 (repeating each bit three times), and the receiver would
    decode the received word by taking the majority value for each of the three bits.
    For example, 100110111 would be decoded to 011 because that pattern appears twice.
    But as you can see, this particular error-correcting code would allow a receiver
    to correct only up to one error per 3-bit chunk, because if two errors occur in
    the same 3-bit chunk, the majority value would be the wrong one.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我首先解释一下什么是纠错码。假设你想要将一串比特作为一系列（假设是）3比特的字传输，但传输不可靠，你担心一个或多个比特可能会被错误传输：你发送的是010，但接收方收到的是011。解决这个问题的一种简单方法是使用一个非常基础的纠错码：你不直接传输010，而是传输000111000（每个比特重复三次），接收方通过取每组三个比特的多数值来解码接收到的字。例如，100110111会被解码为011，因为该模式出现了两次。但正如你所看到的，这种特定的纠错码只允许接收方在每个3比特块中最多纠正一个错误，因为如果在同一个3比特块中发生两个错误，多数值将是错误的。
- en: '*Linear codes* are an example of less trivial error-correcting codes. In the
    case of linear codes, a word to encode is seen as an *n*-bit vector *v*, and encoding
    consists of multiplying *v* with an *m* × *n* matrix *G* to compute the code word
    *w* = *vG*. (In this example, *m* is greater than *n*, meaning that the code word
    is longer than the original word.) The value *G* can be structured such that for
    a given number *t*, any *t*-bit error in *w* allows the recipient to recover the
    correct *v*. In other words, *t* is the maximum number of errors that can be corrected.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性码*是较为复杂的纠错码的一种例子。在线性码的情况下，待编码的字被视为一个*n*比特的向量*v*，而编码则是将*v*与一个*m* × *n*的矩阵*G*相乘，计算出码字*w*
    = *vG*。（在这个例子中，*m*大于*n*，意味着码字比原始字更长。）矩阵*G*可以被构造为一种结构，使得对于给定的数字*t*，*w*中的任何*t*比特错误都能使接收方恢复出正确的*v*。换句话说，*t*是可以被纠正的最大错误数量。'
- en: In order to encrypt data using linear codes, the McEliece cryptosystem constructs
    *G* as a secret combination of three matrices, and encrypts by computing *w* =
    *vG* plus some random value, *e*, which is a fixed number of 1 bit. Here, *G*
    is the public key, and the private key is composed of the matrices *A*, *B*, and
    *C* such that *G* = *ABC.* Knowing *A*, *B*, and *C* allows one to decode a message
    reliably and retrieve *w*. (You’ll find the decoding step described online.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用线性码进行数据加密，McEliece加密系统将*G*构造为三个矩阵的秘密组合，并通过计算*w* = *vG*加上一些随机值*e*（这是一个固定的1比特数字）来进行加密。这里，*G*是公钥，私钥由矩阵*A*、*B*和*C*组成，使得*G*
    = *ABC*。知道*A*、*B*和*C*可以可靠地解码消息并恢复*w*。（你可以在线查阅解码步骤的详细描述。）
- en: The security of the McEliece encryption scheme relies on the hardness of decoding
    a linear code with insufficient information, a problem known to be **NP**-complete
    and therefore out of reach of quantum computers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: McEliece加密方案的安全性依赖于解码线性码所需的信息不足的困难，这个问题被称为**NP**完全问题，因此超出了量子计算机的解码能力。
- en: '*Lattice-Based Cryptography*'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基于格点的加密学*'
- en: '*Lattices* are mathematical structures that essentially consist of a set of
    points in an *n*-dimensional space, with some periodic structure. For example,
    in dimension two (*n* = 2), a lattice can be viewed as the set of points shown
    in [Figure 14-5](ch14.xhtml#ch14fig5).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*格点*是数学结构，基本上由一组位于*n*维空间中的点组成，并具有某种周期性结构。例如，在二维空间（*n* = 2）中，格点可以被视为[图14-5](ch14.xhtml#ch14fig5)所示的点集。'
- en: '![image](../images/f14-05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f14-05.jpg)'
- en: '*Figure 14-5: Points of a two-dimensional lattice, where* v *and* w *are basis
    vectors of the lattice, and* s *is the closest vector to the star-shaped point*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：二维格点的点，其中* v *和* w *是格点的基向量，* s *是最接近星形点的向量*'
- en: Lattice theory has led to deceptively simple cryptography schemes. I’ll give
    you the gist of it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 格点理论催生了看似简单的加密方案。我将给你简要介绍一下。
- en: A first hard problem found in lattice-based crypto is known as *short integer*
    *solution* (SIS). SIS consists of finding the secret vector *s* of *n* numbers
    given (*A*, *b*) such that *b* = *As* mod *q*, where *A* is a random *m* × *n*
    matrix and *q* is a prime number.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 基于格的加密中的第一个困难问题被称为 *短整数解*（SIS）。SIS 的问题是给定 (*A*，*b*)，找出 *n* 个数字的秘密向量 *s*，使得 *b*
    = *As* mod *q*，其中 *A* 是一个随机的 *m* × *n* 矩阵，*q* 是素数。
- en: The second hard problem in lattice-based cryptography is called *learning* *with
    errors* (LWE). LWE consists of finding the secret vector *s* of *n* numbers given
    (*A*, *b*), where *b* = *As* + *e* mod *q*, with *A* being a random *m* × *n*
    matrix, *e* a random vector of noise, and *q* a prime number. This problem looks
    a lot like noisy decoding in code-based cryptography.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于格的加密中的第二个困难问题称为 *带错误学习*（LWE）。LWE 的问题是给定 (*A*，*b*)，找出 *n* 个数字的秘密向量 *s*，其中 *b*
    = *As* + *e* mod *q*，*A* 是一个随机的 *m* × *n* 矩阵，*e* 是一个随机的噪声向量，*q* 是素数。这个问题看起来很像在基于编码的密码学中进行噪声解码。
- en: SIS and LWE are somewhat equivalent, and can be restated as instances of the
    *closest vector problem (CVP)* on a lattice, or the problem of finding the vector
    in a lattice closest to a given point, by combining a set of basis vectors. The
    dotted vector *s* in [Figure 14-5](ch14.xhtml#ch14fig5) shows how we would find
    the closest vector to the star-shaped point by combining the basis vectors *v*
    and *w*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SIS 和 LWE 在某种程度上是等价的，可以通过将一组基向量组合来重新表述为 *最近向量问题（CVP）* 在格上的实例，即在格中找到距离给定点最近的向量。[图14-5](ch14.xhtml#ch14fig5)中的虚线向量
    *s* 显示了我们如何通过组合基向量 *v* 和 *w* 来找到最接近星形点的向量。
- en: CVP and other lattice problems are believed to be hard both for classical and
    quantum computers. But this doesn’t directly transfer to secure cryptosystems,
    because some problems are only hard in the worst case (that is, for their hardest
    instance) rather than the average case (which is what we need for crypto). Furthermore,
    while finding the exact solution to CVP is hard, finding an approximation of the
    solution can be considerably easier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CVP 和其他格问题被认为对于经典计算机和量子计算机都很困难。但这并不直接转化为安全的加密系统，因为有些问题仅在最坏情况下（即它们的最难实例）才困难，而不是在平均情况下（这对于加密来说是需要的）。此外，虽然找到
    CVP 的精确解很困难，但找到一个近似解可能要容易得多。
- en: '*Multivariate Cryptography*'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*多元密码学*'
- en: '*Multivariate cryptography* is about building cryptographic schemes that are
    as hard to break as it is to solve systems of multivariate equations, or equations
    involving multiple unknowns. Consider, for example, the following system of equations
    involving four unknowns *x*[1], *x*[2], *x*[3], *x*[4]:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*多元密码学* 旨在构建加密方案，其破解难度与解决多元方程组或涉及多个未知数的方程组的难度相当。例如，考虑以下涉及四个未知数 *x*[1]、*x*[2]、*x*[3]、*x*[4]
    的方程组：'
- en: '![image](../images/f0265-01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0265-01.jpg)'
- en: These equations consist of the sum of terms that are either a single unknown,
    such as *x*[4] (or terms of degree one), or the product of two unknown values,
    such as *x*[2]*x*[3] (terms of degree two or *quadratic* terms). To solve this
    system, we need to find the values of *x*[1], *x*[2], *x*[3], *x*[4] that satisfy
    all four equations. Equations may be over all real numbers, integers only, or
    over finite sets of numbers. In cryptography, however, equations are typically
    over numbers modulo some prime numbers, or over binary values (0 and 1).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程包含的是单个未知数的和，例如 *x*[4]（或一次项），或者是两个未知数的乘积，例如 *x*[2]*x*[3]（二次项或 *二次* 项）。为了求解这个方程组，我们需要找到满足所有四个方程的
    *x*[1]、*x*[2]、*x*[3]、*x*[4] 的值。方程可能是在所有实数、仅在整数范围内，或者在有限的数集上。在密码学中，方程通常是在某些素数的模数下，或者是在二进制值（0
    和 1）下。
- en: The problem here is to find a solution that is **NP**-hard given a *random*
    quadratic system of equations. This hard problem, known as *multivariate quadratics
    (MQ) equations*, is therefore a potential basis for post-quantum systems because
    quantum computers won’t solve **NP**-hard problems efficiently.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，在给定一个 *随机* 二次方程组的情况下，找到一个 **NP**-困难的解。这个困难的问题，称为 *多元二次方程（MQ）*，因此是后量子系统的潜在基础，因为量子计算机无法有效解决
    **NP**-困难问题。
- en: 'Unfortunately, building a cryptosystem on top on MQ isn’t so straightforward.
    For example, if we were to use MQ for signatures, the private key might consist
    of three systems of equations, *L*[1], *N*, and *L*[2], which when combined in
    this order would give another system of equations that we’ll call *P*, the public
    key. Applying the transformations *L*[1], *N*, and *L*[2] consecutively (that
    is, transforming a group of values as per the system of equations) is then equivalent
    to applying *P* by transforming *x*[1], *x*[2], *x*[3], *x*[4] to *y*[1], *y*[2],
    *y*[3], *y*[4], defined as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在MQ基础上构建加密系统并非易事。例如，如果我们要使用MQ进行签名，私钥可能由三个方程组组成，*L*[1]、*N* 和 *L*[2]，当按此顺序组合时，得到另一个方程组，我们称之为
    *P*，即公钥。依次应用变换 *L*[1]、*N* 和 *L*[2]（即按照方程组变换一组值）相当于通过变换 *x*[1]、*x*[2]、*x*[3]、*x*[4]
    到 *y*[1]、*y*[2]、*y*[3]、*y*[4] 来应用 *P*，其定义如下：
- en: '![image](../images/f0265-02.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0265-02.jpg)'
- en: In such a cryptosystem, *L*[1], *N*, and *L*[2] are chosen such that *L*[1]
    and *L*[2] are linear transformations (that is, having equations where terms are
    only added, not multiplied) that are invertible, and where *N* is a quadratic
    system of equations that is also invertible. This makes the combination of the
    three a quadratic system that’s also invertible, but whose inverse is hard to
    determine without knowing the inverses of *L*[1], *N*, and *L*[2].
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的加密系统中，*L*[1]、*N* 和 *L*[2] 的选择是这样的：*L*[1] 和 *L*[2] 是线性变换（即方程中只有加法，而没有乘法），且是可逆的；而
    *N* 是一个二次方程系统，也具有可逆性。这使得三者的组合是一个可逆的二次方程系统，但其逆矩阵在不知道 *L*[1]、*N* 和 *L*[2] 的逆的情况下很难求出。
- en: Computing a signature then consists of computing the inverses of *L*[1], *N*,
    and *L*[2] applied to some message, *M*, seen as a sequence of variables, *x*[1],
    *x*[2], … .
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 计算签名的过程就是计算 *L*[1]、*N* 和 *L*[2] 的逆矩阵，然后应用到某条消息 *M* 上，*M* 被视为一组变量 *x*[1]、*x*[2]、……。
- en: '*S* = *L*[2]^(−1)(*N*^(−1)(*L*[1]^(−1)(*M*)))'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*S* = *L*[2]^(−1)(*N*^(−1)(*L*[1]^(−1)(*M*)))'
- en: Verifying a signature then consists of verifying that *P*(*S*) = *M*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 验证签名的过程就是验证 *P*(*S*) = *M*。
- en: Attackers could break such a cryptosystem if they manage to compute the inverse
    of *P*, or to determine *L*[1], *N*, and *L*[2] from *P*. The actual hardness
    of solving such problems depends on the parameters of the scheme, such as the
    number of equations used, the size and type of the numbers, and so on. But choosing
    secure parameters is hard, and more than one multivariate scheme considered safe
    has been broken.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者如果能计算出 *P* 的逆矩阵，或者从 *P* 中确定 *L*[1]、*N* 和 *L*[2]，就能够破坏这种加密系统。解决这些问题的实际难度取决于方案的参数，比如使用的方程数量、数字的大小和类型等。但选择安全的参数是困难的，且曾经有多个被认为安全的多变量方案被攻破。
- en: Multivariate cryptography isn’t used in major applications due to concerns about
    the scheme’s security and because it’s often slow or requires tons of memory.
    A practical benefit of multivariate signature schemes, however, is that it produces
    short signatures.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 多变量密码学在主要应用中并未得到广泛使用，原因是对该方案的安全性存在担忧，并且它通常速度较慢或需要大量内存。然而，多变量签名方案的一个实际好处是它能生成较短的签名。
- en: '*Hash-Based Cryptography*'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基于哈希的密码学*'
- en: Unlike the previous schemes, hash-based cryptography is based on the well-established
    security of cryptographic hash functions rather than on the hardness of mathematical
    problems. Because quantum computers cannot break hash functions, they cannot break
    anything that relies on the difficulty of finding collisions, which is the key
    idea of hash function–based signature schemes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方案不同，基于哈希的密码学依赖于密码学哈希函数的安全性，而不是数学问题的难度。由于量子计算机无法破解哈希函数，因此它们无法破解任何依赖于找到哈希冲突难度的系统，而这是基于哈希函数的签名方案的核心思想。
- en: 'Hash-based cryptographic schemes are pretty complex, so we’ll just take a look
    at their simplest building block: the one-time signature, a trick discovered around
    1979, and known as *Winternitz one-time signature* (*WOTS*), after its inventor.
    Here “one-time” means that a private key can be used to sign only one message;
    otherwise, the signature scheme becomes insecure. (WOTS can be combined with other
    methods to sign multiple messages, as you’ll see in the subsequent section.)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基于哈希的加密方案相当复杂，因此我们将仅关注它们最简单的构建块：一次性签名，这一技巧大约在1979年被发现，并以发明者命名为 *Winternitz 一次性签名*（*WOTS*）。这里的“一次性”意味着私钥只能用来签名一条消息；否则，签名方案将变得不安全。（*WOTS*
    可以与其他方法结合使用，以签署多条消息，正如你将在后续部分看到的那样。）
- en: But first, let’s see how WOTS works. Say you want to sign a message viewed as
    a number between 0 and *w* – 1, where *w* is some parameter of the scheme. The
    private key is a random string, *K*. To sign a message, *M*, with 0 ≤ *M* < *w*,
    you compute **Hash**(**Hash**(…(**Hash**(*K*))), where the hash function **Hash**
    is repeated *M* times. We denote this value as **Hash**^(*M*)(*K*). The public
    key is **Hash**^(*w*)(*K*), or the result of *w* nested iterations of **Hash**,
    starting from *K*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看WOTS是如何工作的。假设你想签署一个被视为0到*w* – 1之间的数字的消息，其中*w*是方案的某个参数。私钥是一个随机字符串，*K*。要签署消息*M*，其中0
    ≤ *M* < *w*，你需要计算**Hash**(**Hash**(…(**Hash**(*K*)))，其中哈希函数**Hash**重复*M*次。我们将这个值表示为**Hash**^(*M*)(*K*)。公钥是**Hash**^(*w*)(*K*)，或者说是从*K*开始的*w*次嵌套**Hash**迭代的结果。
- en: A WOTS signature, *S*, is verified by checking that **Hash**^(*w* – *M*)(*S*)
    is equal to the public key **Hash**^(*w*)(*K*). Note that *S* is *K* after *M*
    applications of **Hash**, so if we do another *w* – *M* applications of **Hash**,
    we’ll get a value equal to *K* hashed *M* + (*w* – *M*) = *w* times, which is
    the public key.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个WOTS签名，*S*，通过检查**Hash**^(*w* – *M*)(*S*)是否等于公钥**Hash**^(*w*)(*K*)来验证。注意，*S*是经过*M*次应用**Hash**后的*K*，因此如果我们再进行*w*
    – *M*次应用**Hash**，我们会得到一个等于*K*哈希*M* + (*w* – *M*) = *w*次的值，即公钥。
- en: 'This scheme looks rather dumb, and it has significant limitations:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案看起来相当愚蠢，而且有显著的局限性：
- en: '**Signatures can be forged**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名可能会被伪造**'
- en: From **Hash**^(*M*)(*K*), the signature of *M*, you can compute **Hash**(**Hash**^(*M*)(*K*))
    = **Hash**^(*M* + 1)(*K*), which is a valid signature of the message *M* + 1\.
    This problem can be fixed by signing not only *M*, but also *w* – *M*, using a
    second key.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Hash**^(*M*)(*K*)，即*M*的签名，你可以计算**Hash**(**Hash**^(*M*)(*K*)) = **Hash**^(*M*
    + 1)(*K*)，这是*M* + 1的有效签名。这个问题可以通过不仅签署*M*，还签署*w* – *M*，并使用第二个密钥来解决。
- en: '**It only works for short messages**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**它仅适用于短消息**'
- en: 'If messages are 8 bits long, there are up to 2⁸ – 1 = 255 possible messages,
    so you’ll have to compute **Hash** up to 255 times in order to create a signature.
    That might work for short messages, but not for longer ones: for example, with
    128-bit messages, signing the message 2^(128) – 1 would take forever. A workaround
    is to split longer messages into shorter ones.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息长度为8位，则最多有2⁸ – 1 = 255个可能的消息，因此你需要计算**Hash**最多255次才能生成签名。这可能适用于短消息，但不适用于较长的消息：例如，对于128位的消息，签署消息2^(128)
    – 1将需要永远的时间。一个解决方法是将较长的消息拆分为较短的消息。
- en: '**It works only once**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**它只能使用一次**'
- en: If a private key is used to sign more than one message, an attacker can recover
    enough information to forge a signature. For example, if *w* = 8 and you sign
    the numbers 1 and 7 using the preceding trick to avoid trivial forgeries, the
    attacker gets **Hash**¹(*K*) and **Hash**⁷(*K**′*) as a signature of 1, and **Hash**⁷(*K*)
    and **Hash**¹(*K**′*) as a signature of 7\. From these values, the attacker can
    compute **Hash**^(*x*)(*K*) and **Hash**^(*x*)(*K**′*) for any *x* in [1;7] and
    thus forge a signature on behalf of the owner of *K* and *K**′*. There is no simple
    way to fix this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个私钥用于签署多个消息，攻击者可以恢复足够的信息来伪造签名。例如，如果*w* = 8并且你使用前面的方法签署数字1和7，以避免简单的伪造，攻击者将获得**Hash**¹(*K*)和**Hash**⁷(*K**′*)作为签名1的签名，以及**Hash**⁷(*K*)和**Hash**¹(*K**′*)作为签名7的签名。通过这些值，攻击者可以计算出**Hash**^(*x*)(*K*)和**Hash**^(*x*)(*K**′*)，其中*x*在[1;7]范围内，从而伪造代表*K*和*K**′*的签名。没有简单的方法来解决这个问题。
- en: State-of-the-art hash-based schemes rely on more complex versions of WOTS, combined
    with tree data structures and sophisticated techniques designed to sign different
    messages with different keys. Unfortunately, the resulting schemes produce large
    signatures (on the order of dozens of kilobytes, as with SPHINCS, a state-of-the-art
    scheme at the time of this writing), and they sometimes have a limit on the number
    of messages they can sign.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 先进的基于哈希的方案依赖于更复杂版本的WOTS，结合树形数据结构和复杂的技术，旨在用不同的密钥签署不同的消息。不幸的是，结果产生的签名很大（大约几十千字节，如SPHINCS一样，SPHINCS是本文写作时的一个先进方案），而且有时会限制它们能够签署的消息数量。
- en: How Things Can Go Wrong
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误可能发生的方式
- en: Post-quantum cryptography may be fundamentally stronger than RSA or elliptic
    curve cryptography, but it’s not infallible or omnipotent. Our understanding of
    the security of post-quantum schemes and their implementations is more limited
    than for not-post-quantum cryptography, which brings with it increased risk, as
    summarized in the following sections.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 后量子密码学可能比RSA或椭圆曲线加密更强大，但它并不是无懈可击或全能的。我们对后量子方案及其实现的安全性理解，远不如非后量子加密那么深入，这带来了增加的风险，以下部分将总结这些风险。
- en: '*Unclear Security Level*'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*不清晰的安全级别*'
- en: Post-quantum schemes can appear deceptively strong yet prove insecure against
    both quantum and classical attacks. Lattice-based algorithms, such as the ring-LWE
    family of computational problems (versions of the LWE problem that work with polynomials),
    are sometimes problematic. Ring-LWE is attractive for cryptographers because it
    can be leveraged to build crypto­systems that are in principle as hard to break
    as it is to solve the hardest instances of Ring-LWE problems, which can be **NP**-hard.
    But when security looks too good to be true, it often is.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 后量子方案可能看起来非常强大，但在量子攻击和经典攻击面前，仍然可能不安全。基于格的算法，如环-LWE家族的计算问题（LWE问题的多项式版本），有时存在问题。环-LWE对密码学家具有吸引力，因为它可以用来构建加密系统，在原则上，这些系统的破解难度与解决最难的环-LWE问题一样大，而环-LWE问题可以是**NP**-难的。但当安全性看起来过于完美时，通常并非如此。
- en: One problem with security proofs is that they are often asymptotic, meaning
    that they’re true only for a large number of parameters such as the dimension
    of the underlying lattice. However, in practice, a much smaller number of parameters
    is used.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性证明的一个问题是，它们通常是渐近的，这意味着它们只对大数量的参数（如基础格的维度）有效。然而，在实际操作中，使用的参数数量要小得多。
- en: Even when a lattice-based scheme looks to be as hard to break as some **NP**-hard
    problem, its security remains hard to quantify. In the case of lattice-based algorithms,
    we rarely have a clear picture of the best attacks against them and the cost of
    such an attack in terms of computation or hardware, because of our lack of understanding
    of these recent constructions. This uncertainty makes lattice-based schemes harder
    to compare against better-understood constructions such as RSA, and this scares
    potential users. However, researchers have been making progress on this front
    and hopefully in a few years, lattice problems will be as well understood as RSA.
    (For more technical details on the Ring-LWE problem, read Peikert’s excellent
    survey at *[https://eprint.iacr.org/2016/351/](https://eprint.iacr.org/2016/351/)*.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个基于格的方案看起来像是一个**NP**-难题一样难以破解，其安全性仍然难以量化。对于基于格的算法来说，我们很少能清楚地了解对它们的最佳攻击方式，以及这种攻击在计算或硬件方面的成本，因为我们对这些最新构造的理解不足。这种不确定性使得基于格的方案比那些更为理解的构造（如RSA）更难进行比较，这让潜在的用户感到害怕。然而，研究人员在这一方面已有进展，且希望在几年内，基于格的问题能像RSA一样被理解。（有关Ring-LWE问题的更多技术细节，请阅读Peikert的精彩综述，见
    *[https://eprint.iacr.org/2016/351/](https://eprint.iacr.org/2016/351/)*。）
- en: '*Fast Forward: What Happens if It’s Too Late?*'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*快进：如果为时已晚，会发生什么？*'
- en: 'Imagine this CNN headline: April 2, 2048: “ACME, Inc. reveals its secretly
    built quantum computer, launches break-crypto-as-a-service platform.” Okay, RSA
    and elliptic curve crypto are screwed. Now what?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这个CNN头条：2048年4月2日：“ACME公司揭露其秘密建造的量子计算机，推出破解加密即服务平台。”好吧，RSA和椭圆曲线加密完蛋了。那接下来怎么办？
- en: The bottom line is that post-quantum encryption is way more critical than post-quantum
    signatures. Let’s look at the case of signatures first. If you were still using
    RSA-PSS or ECDSA as a signature scheme, you could just issue new signatures using
    a post-quantum signature scheme in order to restore your signatures’ trust. You
    would revoke your older, quantum-unsafe public keys and compute fresh signatures
    for every message you had signed. After a bit of work, you’d be fine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，后量子加密比后量子签名更为关键。让我们先看签名的情况。如果你仍在使用RSA-PSS或ECDSA作为签名方案，你可以通过使用后量子签名方案重新签发新签名，以恢复签名的信任。你将撤销旧的、对量子攻击不安全的公钥，并为每一条你签署过的消息计算新的签名。做一点工作后，你会没事的。
- en: You would only need to panic if you were encrypting data using quantum-
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你使用量子加密数据时，才需要恐慌——
- en: unsafe schemes, such as RSA-OAEP. In this case all transmitted ciphertext could
    be compromised. Obviously, it would be pointless to encrypt that plaintext again
    with a post-quantum algorithm since your data’s confidentiality is already gone.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全的方案，例如 RSA-OAEP。在这种情况下，所有传输的密文都可能被泄露。显然，再用量子后算法对该明文进行加密是毫无意义的，因为数据的机密性已经丧失。
- en: But what about key agreement, with Diffie–Hellman (DH) and its elliptic curve
    counterpart (ECDH)?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Diffie–Hellman（DH）及其椭圆曲线版本（ECDH）的密钥协商呢？
- en: 'Well, at first glance, the situation looks to be as bad as with encryption:
    attackers who’ve collected public keys *g*^(*a*) and *g*^(*b*) could use their
    shiny new quantum computer to compute the secret exponent *a* or *b* and compute
    the shared secret *g*^(*ab*), and then derive from it the keys used to encrypt
    your traffic. But in practice, Diffie–Hellman isn’t always used in such a simplistic
    fashion. The actual session keys used to encrypt your data may be derived from
    both the Diffie–Hellman shared secret and some internal state of your system.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，情况似乎与加密一样糟糕：攻击者收集了公钥 *g*^(*a*) 和 *g*^(*b*)，他们可以利用崭新的量子计算机计算出秘密指数 *a* 或
    *b*，进而计算出共享秘密 *g*^(*ab*)，然后从中推导出用于加密流量的密钥。但实际上，Diffie–Hellman 并不总是以这种简单的方式使用。实际用于加密数据的会话密钥可能是从
    Diffie–Hellman 共享秘密和系统的某些内部状态一起推导出来的。
- en: For example, that’s how state-of-the-art mobile messaging systems work, thanks
    to a protocol pioneered with the Signal application. When you send a new message
    to a peer with Signal, a new Diffie–Hellman shared secret is computed and combined
    with some internal secrets that depend on the previous messages sent within that
    session (which can span long periods of time). Such advanced use of Diffie–Hellman
    makes the work of an attacker much harder, even one with a quantum computer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这就是现代移动消息系统如何工作的原因，得益于 Signal 应用程序开创的协议。当你通过 Signal 向一个对等方发送新消息时，会计算出一个新的
    Diffie–Hellman 共享秘密，并将其与一些依赖于该会话中先前发送的消息的内部秘密结合（该会话可以跨越较长时间）。这种 Diffie–Hellman
    的高级使用使得攻击者的工作更加困难，即使他拥有量子计算机。
- en: '*Implementation Issues*'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*实现问题*'
- en: In practice, post-quantum schemes will be code, not algorithms; that is, software
    running on some physical processor. And however strong the algorithms may be on
    paper, they won’t be immune to implementation errors, software bugs, or side-channel
    attacks. An algorithm may be completely post-quantum in theory but may still be
    broken by a simple classical computer program because a programmer forgot to enter
    a semicolon.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，量子后方案将是代码，而不是算法；也就是说，它们是在某个物理处理器上运行的软件。无论这些算法在纸面上多么强大，它们都无法免于实现错误、软件漏洞或侧信道攻击。一个算法在理论上可能是完全的量子后方案，但仍然可能被一个简单的经典计算机程序破解，因为程序员忘记输入了一个分号。
- en: Furthermore, schemes such as code-based and lattice-based algorithms rely heavily
    on mathematical operations, the implementation of which uses a variety of tricks
    to make those operations as fast as possible. But by the same token, the complexity
    of the code in these algorithms makes implementation more vulnerable to side-channel
    attacks, such as timing attacks, which infer information about secret values based
    on measurement of execution times. In fact, such attacks have already been applied
    to code-based encryption (see *[https://eprint.iacr.org/2010/479/](https://eprint.iacr.org/2010/479/)*)
    and to lattice-based signature schemes (see *[https://eprint.iacr.org/2016/300/](https://eprint.iacr.org/2016/300/)*).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像基于代码和基于格的算法这样的方案在很大程度上依赖于数学运算，这些运算的实现使用了各种技巧，以使这些操作尽可能快速。但同样，这些算法中的代码复杂性使得实现更容易受到侧信道攻击的威胁，例如时序攻击，通过测量执行时间推断关于秘密值的信息。事实上，这种攻击已经应用于基于代码的加密（见
    *[https://eprint.iacr.org/2010/479/](https://eprint.iacr.org/2010/479/)*）和基于格的签名方案（见
    *[https://eprint.iacr.org/2016/300/](https://eprint.iacr.org/2016/300/)*）。
- en: The upshot is that, ironically, post-quantum schemes will be less secure in
    practice at first than non-post-quantum ones, due to vulnerabilities in their
    implementations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，具有讽刺意味的是，量子后方案在实践中一开始将比非量子后方案更不安全，因为它们的实现存在漏洞。
- en: Further Reading
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn the basics of quantum computation, read the classic *Quantum Computation
    and Quantum Information* by Nielsen and Chuang (Cambridge, 2000). Aaronson’s *Quantum
    Computing Since Democritus* (Cambridge, 2013), a less technical and more entertaining
    read, covers more than quantum computing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习量子计算的基础知识，可以阅读Nielsen和Chuang所著的经典教材《*Quantum Computation and Quantum Information*》（剑桥大学出版社，2000年）。Aaronson的《*Quantum
    Computing Since Democritus*》（剑桥大学出版社，2013年）是一本更具娱乐性的非技术读物，内容涉及的范围不仅限于量子计算。
- en: Several software simulators will allow you to experiment with quantum computing.
    The Quantum Computing Playground at *[http://www.quantumplayground.net/](http://www.quantumplayground.net/)*
    is particularly well designed, with a simple programming language and intuitive
    visualizations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 多款软件模拟器可以让你尝试量子计算。*Quantum Computing Playground*（[http://www.quantumplayground.net/](http://www.quantumplayground.net/)）设计尤为出色，采用简单的编程语言和直观的可视化效果。
- en: For the latest research in post-quantum cryptography, see *[https://pqcrypto.org/](https://pqcrypto.org/)*
    and the associated conference PQCrypto.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有关后量子密码学的最新研究，请访问*[https://pqcrypto.org/](https://pqcrypto.org/)*以及相关的会议PQCrypto。
- en: The coming years promise to be particularly exciting for post-quantum crypto
    thanks to NIST’s Post-Quantum Crypto Project, a community effort to develop the
    future post-quantum standard. Be sure to check the project’s website *[http://csrc.nist.gov/groups/ST/post-quantum-crypto/](http://csrc.nist.gov/groups/ST/post-quantum-crypto/)*
    for the related algorithms, research papers, and workshops.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 未来几年将是后量子密码学特别令人兴奋的时期，这得益于NIST的后量子密码学项目，这是一个致力于开发未来后量子标准的社区合作项目。一定要查看该项目的官方网站*[http://csrc.nist.gov/groups/ST/post-quantum-crypto/](http://csrc.nist.gov/groups/ST/post-quantum-crypto/)*，了解相关算法、研究论文和研讨会。
