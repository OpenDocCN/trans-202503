- en: '[11](nsp-boxall502581-0008.xhtml#rch11)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[11](nsp-boxall502581-0008.xhtml#rch11)'
- en: AVR and the SPI Bus
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AVR和SPI总线
- en: '![](images/nsp-boxall502581-ct.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-boxall502581-ct.jpg)'
- en: We can loosely define a *bus* as a connection between two devices that allows
    us to send data from one device to the other. For example, there are several types
    of data buses that can connect your AVR microcontroller to a sensor or display
    device. This chapter introduces the *serial peripheral interface (SPI) bus* ,
    which we use to send bytes of data directly between a primary device and one or
    more secondary devices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以宽泛地将*总线*定义为连接两个设备的连接，允许我们将数据从一个设备发送到另一个设备。例如，有几种类型的数据总线可以将您的AVR微控制器连接到传感器或显示设备。本章介绍了*串行外设接口(SPI)总线*，我们用它来直接在主设备和一个或多个从设备之间发送数据字节。
- en: 'In this chapter, you will learn how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: • Implement the SPI bus with AVR microcontrollers.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用AVR微控制器实现SPI总线。
- en: • Read SPI device data sheets in order to write matching code.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 阅读SPI设备数据表以便编写匹配的代码。
- en: • Add a reset button to your projects.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 向您的项目添加复位按钮。
- en: • Use two different SPI-based devices in the same project.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在同一个项目中使用两个不同的基于SPI的设备。
- en: Along the way, you’ll also learn how to use 74HC595 shift register ICs to increase
    the number of available digital output pins, display eight-digit numbers with
    a MAX7219 LED display driver IC, and measure voltages with the MCP3008 ADC IC.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，您还将学习如何使用74HC595移位寄存器IC来增加可用的数字输出引脚数量，使用MAX7219 LED显示驱动器IC显示八位数字，以及使用MCP3008
    ADC IC测量电压。
- en: '[How Buses Work](nsp-boxall502581-0008.xhtml#rah1301)'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总线工作原理](nsp-boxall502581-0008.xhtml#rah1301)'
- en: 'The SPI bus enables communication between AVR microcontrollers and many popular
    parts and sensors. It works similarly to the USART that we used in [Chapters 4](nsp-boxall502581-0014.xhtml#ch04)
    and [9](nsp-boxall502581-0019.xhtml#ch09) , in that it transmits data in serial
    fashion from the microcontroller using one wire and to the microcontroller using
    another. However, the SPI bus also uses a third connection: a *clock line* , which
    carries an electrical signal that turns on and off at a constant frequency. Every
    time the clock changes state from high to low or low to high, a bit of data (an
    *on* or *off* ) is sent along the data line either from or to the microcontroller.
    The clock signal synchronizes with the data signal, allowing for fast and accurate
    data transmission.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SPI总线使AVR微控制器与许多流行的部件和传感器之间进行通信。它的工作原理类似于我们在[第4章](nsp-boxall502581-0014.xhtml#ch04)和[第9章](nsp-boxall502581-0019.xhtml#ch09)中使用的USART，通过一个线路从微控制器传输数据，通过另一个线路传输数据到微控制器。但是，SPI总线还使用第三条连接：*时钟线*，它携带一个电信号，以恒定频率开关。每当时钟从高电平变为低电平或低电平变为高电平时，数据位（*开*或*关*）通过数据线从或向微控制器发送。时钟信号与数据信号同步，允许快速而准确的数据传输。
- en: We can demonstrate the changing states of the data and clock lines using a DSO.
    For example, consider [Figure 11-1](nsp-boxall502581-0021.xhtml#f11001) , which
    shows a byte of data traveling along the SPI bus.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用DSO演示数据和时钟线的状态变化。例如，参考[图11-1](nsp-boxall502581-0021.xhtml#f11001)，显示了沿SPI总线传输的一个字节数据。
- en: '![Screen capture from a digital storage oscilloscope showing the two channels
    of the SPI bus, and the electrical representation of a byte of data on the SPI
    bus](images/nsp-boxall502581-f11001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![数字存储示波器的屏幕截图，显示SPI总线的两个通道和SPI总线上字节数据的电气表示](images/nsp-boxall502581-f11001.jpg)'
- en: 'Figure 11-1: A DSO showing a byte of data traveling on the SPI bus'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：显示沿SPI总线传输的一个字节数据的DSO
- en: In [Figure 11-1](nsp-boxall502581-0021.xhtml#f11001) , the upper waveform (marked
    1 in the left margin) is the clock signal, which is activated when we use the
    SPI bus. The signal starts at 0 V, moves up to 5 V, then returns to 0 V, repeating
    this pattern if data is being transferred. The lower waveform (marked 2) represents
    the data, with a 1 being a 5 V signal and a 1 being a 0 V signal. From right to
    left, the data being sent is 10110110.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图11-1](nsp-boxall502581-0021.xhtml#f11001)中，上部波形（左边缘标有1）是时钟信号，在使用SPI总线时激活。信号从0
    V开始，上升到5 V，然后返回0 V，如果正在传输数据，则重复此模式。下部波形（标有2）表示数据，其中1是5 V信号，0是0 V信号。从右到左发送的数据是10110110。
- en: 'The SPI bus can send and receive data simultaneously and at different speeds,
    depending on the microcontroller or SPI-based device used. Communication with
    the SPI bus uses a *main–secondary* configuration: the AVR acts as the *main*
    and determines which device (the *secondary* ) it will communicate with at a given
    time.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 总线可以同时发送和接收数据，并且可以根据所使用的微控制器或基于 SPI 的设备以不同的速度进行通信。与 SPI 总线的通信采用*主从*配置：AVR
    充当*主设备*，并确定在给定时间将与哪个设备（*从设备*）进行通信。
- en: In this book we’ll use the ATmega328P-PU microcontroller for projects that use
    the SPI bus, since the ATtiny85 doesn’t have enough memory or output pins to run
    those projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 ATmega328P-PU 微控制器进行使用 SPI 总线的项目，因为 ATtiny85 的内存或输出引脚不足以运行这些项目。
- en: '[Pin Connections and Voltages](nsp-boxall502581-0008.xhtml#rbh1301)'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[引脚连接和电压](nsp-boxall502581-0008.xhtml#rbh1301)'
- en: 'Each SPI device uses four pins to communicate with a main:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 SPI 设备使用四个引脚与主设备进行通信：
- en: • MOSI (main out, secondary in)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • MOSI（主输出，从输入）
- en: • MISO (main in, secondary out)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • MISO（主输入，从输出）
- en: • SCK (clock)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • SCK（时钟）
- en: • SS (secondary select, also known as “latch”)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • SS（从选择，也称为“锁存”）
- en: These SPI pins connect to your microcontroller as shown in [Figure 11-2](nsp-boxall502581-0021.xhtml#f11002)
    .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 SPI 引脚与微控制器的连接如 [图 11-2](nsp-boxall502581-0021.xhtml#f11002) 所示。
- en: '![Diagram showing how a main and secondary device are connected using the SPI
    bus](images/nsp-boxall502581-f11002.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![示意图，展示主设备和从设备如何通过 SPI 总线连接](images/nsp-boxall502581-f11002.jpg)'
- en: 'Figure 11-2: Typical AVR-to-SPI device connection'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：典型的 AVR 到 SPI 设备连接
- en: The SS pin on the SPI main device is labeled PBx in [Figure 11-2](nsp-boxall502581-0021.xhtml#f11002)
    ; you can use any free GPIO pin, but to keep things simple it’s good to use a
    free pin on PORTB as the connection will be close to the SPI pins. Different manufacturers
    often use their own terminology for the SPI bus connections, but this should be
    easy to interpret after a quick examination.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 主设备上的 SS 引脚在 [图 11-2](nsp-boxall502581-0021.xhtml#f11002) 中标记为 PBx；您可以使用任何空闲的
    GPIO 引脚，但为了简便，最好使用 PORTB 上的空闲引脚，因为该连接会靠近 SPI 引脚。不同的制造商通常会使用自己独特的术语来描述 SPI 总线连接，但在快速检查后，这应该容易理解。
- en: Since our AVR runs on 5 V in the following projects, your SPI device must also
    operate at or tolerate operating at 5 V, so be sure to check this with the seller
    or manufacturer before use. If you simply must use an SPI device that operates
    at a reduced voltage, such as 3.3 V, you can use a *level converter* like PMD
    Way part number 441079, shown in [Figure 11-3](nsp-boxall502581-0021.xhtml#f11003)
    . A level converter can convert a 5 V digital signal to a 3.3 V signal, and vice
    versa.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 AVR 在以下项目中运行于 5 V 电压，因此您的 SPI 设备必须也能在 5 V 下运行或承受 5 V 操作，请在使用前务必向卖家或制造商确认。如果您必须使用在较低电压下工作的
    SPI 设备（如 3.3 V），可以使用如 PMD Way 编号 441079 的*电平转换器*，如 [图 11-3](nsp-boxall502581-0021.xhtml#f11003)
    所示。电平转换器可以将 5 V 数字信号转换为 3.3 V 信号，反之亦然。
- en: '![Photo of a level converter](images/nsp-boxall502581-f11003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![电平转换器的照片](images/nsp-boxall502581-f11003.jpg)'
- en: 'Figure 11-3: PMD Way part number 441079'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：PMD Way 编号 441079
- en: 'This is a four-channel level converter board, meaning it can convert four independent
    electrical signals on the one board. To use a level converter, wire it between
    the four wires on the SPI bus: place the 5 V wires on the HV pads and the matching
    lower voltage wires on the LV pads and connect GND of both sides to the board.
    Remember to disconnect your USBasp programmer from your projects once you’ve uploaded
    the code, as the programmer’s pins share the SPI pins and can sometimes cause
    interruptions to the data flow between the microcontroller and the SPI-based device.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个四通道电平转换器板，意味着它可以在同一板上转换四个独立的电气信号。使用电平转换器时，将它连接到 SPI 总线的四根线路之间：将 5 V 线路连接到
    HV 引脚，将匹配的较低电压线路连接到 LV 引脚，并将两侧的 GND 引脚连接到板上。上传代码后，请记得断开您的 USBasp 编程器与项目的连接，因为编程器的引脚与
    SPI 引脚共享，有时会干扰微控制器与基于 SPI 的设备之间的数据流。
- en: '[Implementing the SPI Bus](nsp-boxall502581-0008.xhtml#rbh1302)'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[实现 SPI 总线](nsp-boxall502581-0008.xhtml#rbh1302)'
- en: Next, let’s examine how to implement the SPI bus in our code and how to make
    the hardware connections. I’ll show you some parameters of an example SPI part
    being used, then how to adjust the SPI Control Register (SPCR) shown in [Figure
    11-4](nsp-boxall502581-0021.xhtml#f11004) to activate the SPI bus to our required
    parameters. In the following projects, I’ll also show you how this is done for
    various other SPI parts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们研究如何在代码中实现 SPI 总线，以及如何进行硬件连接。我将向你展示一个示例 SPI 部件的参数，然后展示如何调整 [图 11-4](nsp-boxall502581-0021.xhtml#f11004)
    中显示的 SPI 控制寄存器（SPCR），以激活 SPI 总线并设置为我们需要的参数。在接下来的项目中，我还将向你展示如何为各种其他 SPI 部件进行相应操作。
- en: '![Image of the SPI control register from the microcontroller’s data sheet](images/nsp-boxall502581-f11004.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![来自微控制器数据手册的 SPI 控制寄存器图像](images/nsp-boxall502581-f11004.jpg)'
- en: 'Figure 11-4: SPCR diagram from the ATmega328P-PU data sheet'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4：来自 ATmega328P-PU 数据手册的 SPCR 图
- en: Leave SPIE as 0, as we’re not working with interrupts, and set SPE to 1 to enable
    the SPI bus. Next, consider the DORD bit, which determines whether the byte of
    data is sent with the MSB (most significant bit, bit 7 of the byte) or the LSB
    (least significant bit, bit 0 of the byte) first. You’ll need to determine the
    direction from the secondary’s data sheet, which will include a timing diagram
    like the one in [Figure 11-5](nsp-boxall502581-0021.xhtml#f11005) , or the supplier.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将 SPIE 保持为 0，因为我们不使用中断，并将 SPE 设置为 1 以启用 SPI 总线。接下来，考虑 DORD 位，它决定数据字节是先发送 MSB（最高有效位，字节的第
    7 位）还是 LSB（最低有效位，字节的第 0 位）。你需要根据从设备的数据手册来确定方向，手册中通常会包含像 [图 11-5](nsp-boxall502581-0021.xhtml#f11005)
    这样的时序图，或者提供商会提供相应的说明。
- en: '![SPI bus timing diagram for the MAX7219 LED display controller IC](images/nsp-boxall502581-f11005.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![MAX7219 LED 显示控制器 IC 的 SPI 总线时序图](images/nsp-boxall502581-f11005.jpg)'
- en: 'Figure 11-5: Example timing diagram for an SPI device (the MAX7219)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-5：SPI 设备（MAX7219）的示例时序图
- en: Review the timing diagram’s DIN line. The data travels down the bus with the
    MSB first. If D0 were at the start of the line, the LSB would be first. Set DORD
    to 1 for LSB first, to 0 for MSB first.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查看时序图中的 DIN 线。数据沿总线传输，MSB（最高有效位）先传输。如果 D0 在线的起始位置，则 LSB（最低有效位）会先传输。将 DORD 设置为
    1 时表示 LSB 先传输，设置为 0 时表示 MSB 先传输。
- en: 'Returning to the SPCR, set MSTR to 1 to enable the microcontroller as the main
    device, and 0 if you need to enable the microcontroller as the secondary device.
    For all our projects we’ll use 1\. Next, set CPOL to match the polarity of the
    clock (SCK) signal in the SPI bus when idle (that is, before and after data is
    carried on the bus): 0 for a low signal or 1 for a high signal. Again, you can
    get this information from the timing diagram: in [Figure 11-5](nsp-boxall502581-0021.xhtml#f11005)
    the CLK (or clock/SCK) line is low when not in use, then rises when the first
    bit of data arrives, then alternates repeatedly until the data transmission has
    finished and it falls low again, so for this device you’d set it to 0.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 SPCR，设置 MSTR 为 1，以启用微控制器作为主设备，如果需要启用微控制器作为从设备，则设置为 0。对于我们所有的项目，我们将使用 1。接下来，设置
    CPOL 以匹配 SPI 总线中时钟（SCK）信号在空闲时的极性（即在数据传输前后）：0 为低信号，1 为高信号。同样，你可以从时序图中获得此信息：在 [图
    11-5](nsp-boxall502581-0021.xhtml#f11005) 中，CLK（或时钟/SCK）线在未使用时为低电平，然后在数据的第一位到达时上升，随后交替变化直到数据传输完成，再次降到低电平，因此对于此设备，你应该将其设置为
    0。
- en: CPHA, the clock-phase bit, determines whether the data is sampled at the start
    or the end of the clock bit. For example, review the CLK and DIN lines of [Figure
    11-5](nsp-boxall502581-0021.xhtml#f11005) . The data is sampled at the start of
    the clock bit, as the clock rises at the start time of the data bits. In this
    case you would set CPHA to 0\. If the data bit started as the clock bit ended,
    CPHA would be 1.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CPHA，即时钟相位位，决定数据是采样在时钟位的开始还是结束。例如，查看 [图 11-5](nsp-boxall502581-0021.xhtml#f11005)
    中的 CLK 和 DIN 线。数据在时钟位的开始处被采样，因为时钟信号在数据位的开始时上升。在这种情况下，你应将 CPHA 设置为 0。如果数据位在时钟位结束时开始，CPHA
    应为 1。
- en: Finally, you’ll use the last two bits, SPR1 and SPR0, in conjunction to set
    the speed of the clock and matching data signals on the SPI bus. Set both to 0
    for maximum speed in relation to the microcontroller. Also set the AVR output
    pin connected to your SPI device’s SS pin as an output using a `DDR` `x` function,
    then set that pin to high using the typical `PORT` `x` function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将使用最后两个比特，SPR1 和 SPR0，结合起来设置时钟速度以及 SPI 总线上的数据匹配信号。将这两个比特设置为 0，以获得相对于微控制器的最大速度。同时，使用
    `DDR` `x` 函数将连接到 SPI 设备 SS 引脚的 AVR 输出引脚设置为输出，然后使用典型的 `PORT` `x` 函数将该引脚设置为高电平。
- en: '[Sending Data](nsp-boxall502581-0008.xhtml#rbh1303)'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you’ve initialized your SPI bus, it should be ready to receive and
    send data. We’ll practice sending data first, then examine receiving data later
    in this chapter. To send a byte of data to the SPI device, you need to do four
    things (all of which we’ll do in the [next project](nsp-boxall502581-0021.xhtml#pro44)
    ):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: • Set the SS pin low using a `PORT` `x` command.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Place the byte of data you wish to send into the SPDR register.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Wait for the transmission to finish using `while(!(SPSR & (1<<SPIF)));` .
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Set the SS pin high using a `PORT` `x` command.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may seem a little complicated, but with practice and the right information
    from part suppliers, it’s easy. I’ll explain everything you need to know to build
    our SPI bus projects, the first of which harnesses a particularly useful shift
    register IC.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 44: Using the 74HC595 Shift Register](nsp-boxall502581-0008.xhtml#rpro44)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: When your AVR-based project doesn’t have enough digital output pins, you can
    connect one or more *shift registers* and still have plenty of output pins for
    use on the AVR itself. A shift register is an integrated circuit with eight digital
    output pins that we can control by sending a byte of data to the IC via the SPI
    bus. The projects in this chapter will use the 74HC595 shift register, as shown
    in [Figure 11-6](nsp-boxall502581-0021.xhtml#f11006) .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a 74HC595 shift register integrated circuit](images/nsp-boxall502581-f11006.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: The 74HC595 shift register IC'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The 74HC595 shift register has eight digital outputs that operate in the same
    way as your AVR’s digital outputs, as shown in [Figure 11-7](nsp-boxall502581-0021.xhtml#f11007)
    .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the 74HC595 shift register IC](images/nsp-boxall502581-f11007.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: The 74HC595 schematic symbol'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-1](nsp-boxall502581-0021.xhtml#tab1101) gives details on how to connect
    the shift register to the microcontroller.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 11-1 : 74HC595 Connections |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| Pin | Connection |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| 16 | 5 V positive power supply |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| 8 | GND |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| QA to QH (15, 1–7) | Digital outputs 0 to 7 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| 10 | 5 V positive power supply |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| 11 | SPI bus clock |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| 12 | SPI SS |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| 13 | GND |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| 14 | SPI data in |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| 9 | SPI data out |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: 'The principle behind the shift register is simple: we send 1 byte of data (8
    bits) to the shift register, which turns the matching eight outputs on or off
    based on that byte of data. The bits representing the byte match the output pins
    in order from highest to lowest. Therefore, the MSB of the data represents output
    pin 7 of the shift register, while the LSB represents output pin 0\. For example,
    if we send the byte `0b10000110` to the shift register via the SPI bus, it will
    turn on outputs 7, 2, and 1 and will turn off outputs 0 and 3–6 until the shift
    register receives the next byte of data, or we turn the power off.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Once you send a new byte of data to the shift register, it sends the previous
    byte of data out via SPI pin 9, the data out pin. Thus, you can harness two or
    more, sending multiple bytes of data in one operation to control multiple shift
    registers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你向移位寄存器发送了新的数据字节，它会通过SPI引脚9（数据输出引脚）将前一个数据字节发送出去。因此，你可以通过一次操作发送多个字节的数据来控制多个移位寄存器。
- en: Note You can usually draw up to 20 mA of current from an output pin, and the
    total current drawn from an entire 74HC595 shouldn’t exceed 75 mA.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你通常可以从输出引脚拉取最多20 mA的电流，整个74HC595所消耗的总电流不应超过75 mA。
- en: You get an extra eight digital output pins for every shift register attached
    to the SPI bus. This makes shift registers very convenient when you want to control
    lots of LEDs or other devices. In this project, we’ll use it to control a seven-segment
    numeric LED display.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每连接一个移位寄存器到SPI总线，你就会获得额外的八个数字输出引脚。当你需要控制大量LED或其他设备时，移位寄存器非常方便。在这个项目中，我们将使用它来控制一个七段数码LED显示器。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1304)'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh1304)'
- en: 'To build your display circuit, you’ll need the following hardware:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建你的显示电路，你需要以下硬件：
- en: • USBasp programmer
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • 5 V breadboard power supply
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 5 V 面包板电源
- en: • ATmega328P-PU microcontroller
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • One 74HC595 shift register IC
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个74HC595移位寄存器IC
- en: • One common-cathode seven-segment LED display
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个共阴极七段LED显示屏
- en: • Eight 560 Ω resistors (R1–R8)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 八个560 Ω电阻（R1–R8）
- en: • Jumper wires
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: Assemble your circuit as shown in [Figure 11-8](nsp-boxall502581-0021.xhtml#f11008)
    .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图11-8](nsp-boxall502581-0021.xhtml#f11008)所示组装你的电路。
- en: '![Schematic diagram for Project 44](images/nsp-boxall502581-f11008.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![项目44的原理图](images/nsp-boxall502581-f11008.jpg)'
- en: 'Figure 11-8: Schematic for [Project 44](nsp-boxall502581-0021.xhtml#pro44)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-8：[项目44](nsp-boxall502581-0021.xhtml#pro44)的原理图
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1305)'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh1305)'
- en: Open a terminal window, navigate to the *Project 44* subfolder of this book’s
    *Chapter 11* folder, and enter the command `make flash` to compile and upload
    the data as usual. Don’t forget to disconnect the programmer once you’ve uploaded
    it to the microcontroller. After a moment, the digits 0 to 9 should show in ascending
    order on the LED display, and then repeat.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到本书*第11章*文件夹中的*项目44*子文件夹，然后输入命令`make flash`进行编译并上传数据，和往常一样。上传到微控制器后，别忘了断开编程器。稍等片刻，LED显示器上应该会按顺序显示从0到9的数字，然后重复。
- en: 'Let’s examine the code to see how this works:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看代码，看看它是如何工作的：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code contains a couple of custom functions, the first being `setupSPI()`
    ❶. We use this function to initialize the SPI bus and set the SS pin to high,
    then set the SPCR register as explained earlier in this chapter. We set the DORD
    bit in the SPCR register to 1, as we need to send data to the 74HC595 with the
    LSB first. We can see the requirement to use the 56LSB first from the timing diagram
    in the 74HC595’s data sheet, shown in [Figure 11-9](nsp-boxall502581-0021.xhtml#f11009)
    : Q [A] (the first output pin) is the first to be set high.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包含几个自定义函数，第一个是`setupSPI()` ❶。我们使用这个函数来初始化SPI总线，并将SS引脚设置为高电平，然后按照本章前面解释的内容设置SPCR寄存器。我们将SPCR寄存器中的DORD位设置为1，因为我们需要按LSB优先的顺序向74HC595发送数据。我们可以从74HC595的数据手册中的时序图中看到需要使用56LSB优先的要求，如[图11-9](nsp-boxall502581-0021.xhtml#f11009)所示：Q
    [A]（第一个输出引脚）是第一个被设置为高电平的。
- en: '![Timing diagram for the 74HC595](images/nsp-boxall502581-f11009.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![74HC595的时序图](images/nsp-boxall502581-f11009.jpg)'
- en: 'Figure 11-9: The 74HC595’s timing diagram'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-9：74HC595的时序图
- en: We also need to determine what value to use for the CPOL bit. We set this to
    0, since the polarity of the clock signal is low, or off, when idle.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确定CPOL位的值。我们将其设置为0，因为时钟信号的极性在空闲时为低电平，或关闭。
- en: The final bit to consider is CPHA, the clock-phase bit mentioned earlier. If
    you refer to the diagram again and compare the RCLK timing and signals to any
    of the Q outputs, you’ll see that they both change from low to high at the same
    time. Therefore, the data is sampled at the start, so we set CPHA to 0\. The final
    bits (1 and 0) we leave as 0 to set the SPI bus for maximum possible speed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要考虑的是CPHA，即前面提到的时钟相位位。如果你再次参考图示并比较RCLK时序与任何Q输出，你会发现它们同时从低变高。因此，数据在开始时被采样，所以我们将CPHA设置为0。最后的两个位（1和0）我们将其设置为0，以便将SPI总线设置为最大可能速度。
- en: Our second custom function, `dispNumSR()` ❷, accepts an integer between 0 and
    9 and shows this on the LED display. It first sets the SS pin low ❸, then determines
    which matching byte of data for the digit to display using a `switch...case` statement.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个自定义函数，`dispNumSR()` ❷，接受一个介于0和9之间的整数，并在LED显示器上显示它。 它首先将SS引脚置低 ❸，然后使用 `switch...case`
    语句确定要显示的数字的匹配数据字节。
- en: The microcontroller sends each byte of data with the LSB first. The bits match
    the eight outputs on the 74HC595, which we wire to the LED display segments A−G
    and the decimal point, respectively, as shown in [Figure 11-8](nsp-boxall502581-0021.xhtml#f11008)
    . This byte of data is then placed in the SPDR register in each matching `case`
    statement. The code waits for the transfer to finish ❹, then sets the SS pin high
    to complete the data transmission.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器将每个数据字节的最低位优先发送。 位对应于74HC595上的八个输出，我们将其连接到LED显示器段A-G和小数点，如 [图11-8](nsp-boxall502581-0021.xhtml#f11008)
    所示。 该数据字节然后在每个匹配的 `case` 语句中放入SPDR寄存器。 代码等待传输完成 ❹，然后将SS引脚置高以完成数据传输。
- en: The main loop of code ❺ simply sets up PORTB as outputs, as it contains the
    pins we need for all four SPI bus connections, then calls the `setupSPI()` function
    to set up the SPI bus as described earlier. It then sends the numbers 0 to 9 to
    the LED display.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主循环 ❺ 简单地将PORTB设置为输出，因为它包含我们需要的所有四个SPI总线连接引脚，然后调用 `setupSPI()` 函数设置SPI总线，如前所述。
    然后，它向LED显示器发送数字0到9。
- en: The decimal point in our project is connected, but not in use. You can turn
    it on and off with the last bit of the byte sent to the shift register. For a
    challenge, try modifying the `dispNumSR()` function to accept a second variable
    to turn the decimal point on or off.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中的小数点已连接，但未使用。 您可以使用发送到移位寄存器的字节的最后一位打开和关闭它。 为了挑战自己，请尝试修改 `dispNumSR()` 函数以接受第二个变量以控制小数点的开关。
- en: Now that you know how to control a single device with the SPI bus, let’s try
    using it to control two devices at the same time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何使用SPI总线控制单个设备，让我们尝试同时控制两个设备。
- en: '[Project 45: Using Two 74HC595 Shift Registers](nsp-boxall502581-0008.xhtml#rpro45)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目45：使用两个74HC595移位寄存器](nsp-boxall502581-0008.xhtml#rpro45)'
- en: Using two or more shift registers is an inexpensive and simple way to control
    many more digital outputs with your AVR. As an example, this project uses two
    74HC595 shift registers to show double-digit numbers via two LED displays.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个或更多移位寄存器是控制 AVR 的许多数字输出的廉价且简单的方法。 例如，该项目使用两个74HC595移位寄存器通过两个LED显示器显示双位数。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1306)'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh1306)'
- en: 'To build your display circuit, you’ll need the following hardware:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建您的显示电路，您将需要以下硬件：
- en: • USBasp programmer
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 程序员
- en: • Solderless breadboard
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • 5 V breadboard power supply
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 5 V 面包板电源
- en: • ATmega328P-PU microcontroller
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • Two 74HC595 shift registers
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个74HC595移位寄存器
- en: • Two common-cathode seven-segment LED displays
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个共阴七段LED显示器
- en: • 16 560 Ω resistors (R1–R16)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 16个 560 Ω 电阻（R1-R16）
- en: • Jumper wires
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线线
- en: Assemble your circuit as shown in [Figure 11-10](nsp-boxall502581-0021.xhtml#f11010)
    .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图11-10](nsp-boxall502581-0021.xhtml#f11010) 所示，组装您的电路。
- en: '![Schematic diagram for Project 45](images/nsp-boxall502581-f11010.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![项目45的原理图](images/nsp-boxall502581-f11010.jpg)'
- en: 'Figure 11-10: Schematic for [Project 45](nsp-boxall502581-0021.xhtml#pro45)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-10：[项目45](nsp-boxall502581-0021.xhtml#pro45) 的原理图
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1307)'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh1307)'
- en: Open a terminal window, navigate to the *Project 45* subfolder of this book’s
    *Chapter 11* folder, and enter the command `make flash` to compile and upload
    the data as usual. After a moment or two the numbers 0 through 99 should appear
    in ascending order on the LED displays, then repeat.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到本书 *第11章* 文件夹的 *Project 45* 子文件夹，并输入命令 `make flash` 编译和上传数据。 几秒钟后，LED显示器上应显示从0到99的数字，然后重复。
- en: 'Let’s see how this works:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code for this dual-digit version is similar to that of [Project 44](nsp-boxall502581-0021.xhtml#pro44)
    , except that since we have two shift registers to control, it sends two bytes
    of data at once. This time, the `dispNumSR()` function ❶ accepts a number between
    0 and 99, then divides the number using division and modulo ❸ in order to treat
    each digit separately and store them in the `leftDigit` and `rightDigit` variables.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个双数字版本的代码与 [项目 44](nsp-boxall502581-0021.xhtml#pro44) 类似，唯一不同的是由于我们需要控制两个移位寄存器，因此它一次发送两个字节的数据。这一次，`dispNumSR()`
    函数 ❶ 接受 0 到 99 之间的数字，然后通过除法和取模操作 ❸ 将数字拆分为单独的每一位，并将其存储在 `leftDigit` 和 `rightDigit`
    变量中。
- en: Next, the required operation for sending SPI data begins. We set the SS pin
    low ❹, then send out the byte of data that represents the digit 0 to 9 as specified
    in the `digitData` array ❷ for the right-hand digit to the shift register ❺. After
    waiting ❻ for the byte to be transferred, we send the byte of data for the left-hand
    digit in the same manner. After we’ve finished waiting for the transmission to
    complete, the code sets the SS pin high ❼ to complete the data transmission. The
    SS pins of both shift registers are connected, so we only need one digital output
    to control them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，发送 SPI 数据的操作开始。我们将 SS 引脚设置为低电平 ❹，然后将表示数字 0 到 9 的字节（如 `digitData` 数组 ❷ 中指定）发送到移位寄存器
    ❺ 中的右侧数字。等待 ❻ 字节传输完成后，我们以相同的方式发送左侧数字的字节数据。待传输完成后，代码将 SS 引脚设置为高电平 ❼，以完成数据传输。两个移位寄存器的
    SS 引脚连接在一起，因此我们只需一个数字输出即可控制它们。
- en: The byte for the second (ones) digit is sent first, as it is the second shift
    register—the byte sits in the first shift register, then the byte for the tens
    digit is sent, which pushes the first byte into the second shift register. That
    means the first shift register contains the data for the tens digit, and the second
    shift register contains the data for the ones digit. Once the SS pin is set high,
    the shift registers’ outputs activate, and the LED displays begin showing the
    numbers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个（个位）数字的字节先被发送，因为它位于第二个移位寄存器——该字节首先放入第一个移位寄存器，然后个位字节发送后，将十位字节推入第二个移位寄存器。也就是说，第一个移位寄存器包含十位数字的数据，第二个移位寄存器包含个位数字的数据。一旦
    SS 引脚被设置为高电平，移位寄存器的输出就会被激活，LED 显示屏开始显示数字。
- en: Although this project controlled LED displays, you now have the necessary skills
    to use multiple shift registers to expand your AVR’s outputs in other cases. If
    you need to control larger numerical displays—up to eight digits—the next project
    is for you.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个项目控制的是 LED 显示屏，但你现在已经具备了使用多个移位寄存器来扩展 AVR 输出端口的技能。在其他情况下，如果你需要控制更大的数字显示屏——最多可显示八位数字——下一个项目将非常适合你。
- en: '[Project 46: Using the MAX7219 LED Driver IC](nsp-boxall502581-0008.xhtml#rpro46)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 46：使用 MAX7219 LED 驱动 IC](nsp-boxall502581-0008.xhtml#rpro46)'
- en: 'When you need to use more than two seven-segment numerical displays for a project,
    the wiring and related controls can become quite complex. Thankfully, there’s
    a solution for this: the Maxim MAX7219 LED driver IC, a popular IC that can control
    up to 64 LEDs at once. In turn, we can use these LEDs to simultaneously display
    eight numerical digits with only four control wires via the SPI bus. This project
    shows how to use this display module.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要为一个项目使用两个以上的七段数字显示屏时，接线和相关控制可能会变得相当复杂。幸运的是，有一个解决方案：Maxim MAX7219 LED 驱动
    IC，这是一款流行的 IC，可以同时控制多达 64 个 LED。反过来，我们可以使用这些 LED，通过 SPI 总线只需四根控制线，就能同时显示八个数字。这个项目展示了如何使用该显示模块。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1308)'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件部分](nsp-boxall502581-0008.xhtml#rbh1308)'
- en: The MAX7219 is available in both through-hole ( [Figure 11-11](nsp-boxall502581-0021.xhtml#f11011)
    ) and surface-mount ( [Figure 11-12](nsp-boxall502581-0021.xhtml#f11012) ) package
    types.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: MAX7219 提供两种封装类型：穿孔式（[图 11-11](nsp-boxall502581-0021.xhtml#f11011)）和表面贴装式（[图
    11-12](nsp-boxall502581-0021.xhtml#f11012)）。
- en: '![Photo of a through-hole MAX7219](images/nsp-boxall502581-f11011.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![穿孔式 MAX7219 照片](images/nsp-boxall502581-f11011.jpg)'
- en: 'Figure 11-12: The MAX7219 in a surface-mount package type'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-12：表面贴装类型的 MAX7219
- en: '![Photo of a surface-mount MAX7219](images/nsp-boxall502581-f11012.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![表面贴装 MAX7219 照片](images/nsp-boxall502581-f11012.jpg)'
- en: 'Figure 11-11: The MAX7219 in a through-hole package type'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-11：穿孔式类型的 MAX7219
- en: The through-hole version is most useful when working with a solderless breadboard
    or making your own hand-assembled printed circuit board (PCB). If you have trouble
    finding a MAX7219, the Allegro AS1107 is a drop-in replacement.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 穿孔版本在使用无焊面包板或制作自制手工焊接的印刷电路板（PCB）时最为实用。如果您难以找到MAX7219，Allegro AS1107是一个直接替代品。
- en: If you’re looking to control large numerical displays, you can easily find them
    preassembled, usually with four to eight digits fitted to a module with the MAX7219\.
    For this project we’ll use an eight-digit module, as shown in [Figure 11-13](nsp-boxall502581-0021.xhtml#f11013)
    .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想控制大型数字显示屏，您可以轻松找到预先组装的模块，通常带有四到八个数字，且配备MAX7219模块。对于本项目，我们将使用一个八位模块，如[图11-13](nsp-boxall502581-0021.xhtml#f11013)所示。
- en: '![Photo of an eight-digit LED module with a MAX7219](images/nsp-boxall502581-f11013.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![带有MAX7219的八位LED模块照片](images/nsp-boxall502581-f11013.jpg)'
- en: 'Figure 11-13: An eight-digit LED module'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-13：八位LED模块
- en: These modules use the surface-mount version of the MAX7219, which is soldered
    onto the rear of the module’s PCB. The modules usually include some inline header
    pins to allow for attaching control wires. If you haven’t already done so, solder
    these pins to your module as shown in [Figure 11-14](nsp-boxall502581-0021.xhtml#f11014)
    .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块使用MAX7219的表面贴装版本，焊接在模块PCB的背面。模块通常包括一些内联排针，以便连接控制线。如果您还没有做，请按照[图11-14](nsp-boxall502581-0021.xhtml#f11014)所示将这些排针焊接到模块上。
- en: '![Photo of the header pins soldered to the eight-digit LED module](images/nsp-boxall502581-f11014.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![焊接到八位LED模块的排针照片](images/nsp-boxall502581-f11014.jpg)'
- en: 'Figure 11-14: Connecting inline header pins'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-14：连接内联排针
- en: 'To build your circuit, you’ll need the following hardware:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建电路，您需要以下硬件：
- en: • USBasp programmer
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp编程器
- en: • Solderless breadboard
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • 5 V breadboard power supply
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 5 V面包板电源
- en: • ATmega328P-PU microcontroller
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU微控制器
- en: • MAX7219 eight-digit module
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • MAX7219八位模块
- en: • 470 μF 16 V electrolytic capacitor
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 470 μF 16 V电解电容器
- en: • Jumper wires
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: Assemble your circuit as shown in [Figure 11-15](nsp-boxall502581-0021.xhtml#f11015)
    .
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图11-15](nsp-boxall502581-0021.xhtml#f11015)所示，组装您的电路。
- en: '![Schematic diagram for Project 46](images/nsp-boxall502581-f11015.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![项目46的原理图](images/nsp-boxall502581-f11015.jpg)'
- en: 'Figure 11-15: Schematic for [Project 46](nsp-boxall502581-0021.xhtml#pro46)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-15：项目[46](nsp-boxall502581-0021.xhtml#pro46)的原理图
- en: As you construct your circuit to follow the schematic, connect your display
    module as shown in [Table 11-2](nsp-boxall502581-0021.xhtml#tab1102) .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按照原理图构建电路时，按照[表11-2](nsp-boxall502581-0021.xhtml#tab1102)所示连接显示模块。
- en: '| Table 11-2 : ATmega328P-PU to MAX7219 Connections |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 表11-2：ATmega328P-PU与MAX7219的连接 |'
- en: '| --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| ATmega328P-PU | MAX7219 module |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| ATmega328P-PU | MAX7219模块 |'
- en: '| --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 7 | V [cc] |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 7 | V [cc] |'
- en: '| 8 | GND |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 8 | GND |'
- en: '| 17 | DIN |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 17 | DIN |'
- en: '| 14 | SS |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 14 | SS |'
- en: '| 19 | CLK |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 19 | CLK |'
- en: Note that the display may quickly draw and stop drawing current, which sometimes
    will affect the power supply voltage. Therefore, we use a 470 μF electrolytic
    capacitor to keep the 5 V power smooth. You can review capacitor types in [Chapter
    2](nsp-boxall502581-0012.xhtml#ch02) .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，显示屏可能会快速绘制并停止绘制电流，这有时会影响电源电压。因此，我们使用一个470 μF的电解电容器来保持5 V电源平稳。您可以在[第2章](nsp-boxall502581-0012.xhtml#ch02)复习电容器的类型。
- en: Before we dive into the code, let’s consider the parameters required for the
    SPI setup via the SPCR register. From the timing diagram for the MAX7219 in [Figure
    11-5](nsp-boxall502581-0021.xhtml#f11005) , we can see that we should set the
    DORD bit to 0, as the MAX7219 requires data sent LSB first. We’ll set the CPOL
    bit to 0, as the clock signal is low at the start of data transmission, and we’ll
    set the CPHA bit to 0 too, as the clock signal’s polarity is low at idle.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，让我们考虑一下通过SPCR寄存器设置SPI所需的参数。从[图11-5](nsp-boxall502581-0021.xhtml#f11005)的MAX7219时序图中，我们可以看到，我们应该将DORD位设置为0，因为MAX7219需要首先发送LSB数据。我们将CPOL位设置为0，因为时钟信号在数据传输开始时为低电平，我们还将CPHA位设置为0，因为时钟信号的极性在空闲时为低电平。
- en: Now we need to explore how to control the MAX7219\. Every time we want the IC
    to do something, we must send two bytes of data. The first byte is the address
    of a control register (other ICs have registers just as the microcontroller does),
    and the second byte is the value to be stored in that register. This could be
    setup configuration such as display brightness, or the value that represents a
    number to display on a certain digit.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The possible values for each register are described in the MAX7219 using hexadecimal
    numbers (base-16), so we’ll use them to save effort. You can store hexadecimal
    numbers in `char` variable types. For your own reference and research, you may
    wish to download and review the MAX7219’s data sheet from [https://www.maximintegrated.com/en/products/power/display-power-control/MAX7219.html](https://www.maximintegrated.com/en/products/power/display-power-control/MAX7219.html)
    .
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1309)'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the [Project 46](nsp-boxall502581-0021.xhtml#pro46)
    subfolder of this book’s [Chapter 11](nsp-boxall502581-0021.xhtml#ch11) folder,
    and enter the command `make flash` to compile and upload the data as usual. After
    a moment or two the display should show eight zeros, then count upward until it
    gets to 9,999,999, then repeat.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this is done:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To save time, we use a custom function, `writeMAX7219(` `char hexdata1` `,`
    `char hexdata2` `)` ❶, to send two hexadecimal bytes of data to the IC via the
    SPI bus. This function sets the SS pin low, assigns the first byte of data to
    the SPDR register, waits for transmission to finish, then repeats the process
    for the second byte and the sets the SS pin high again. After setting up the SPI
    bus, we initialize the MAX7219 by placing values in four configuration registers
    using another custom function, `initMAX7219()` ❸.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Before writing any digits to the display, we introduce the `blankMAX7219()`
    function ❷ to be sure we clear the display between writes. Without this function,
    if we were to, say, write 32,785 to the display and then write 45, the display
    would show 32,745.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'To show a digit on the display, we use `writeMAX7219()` to send two bytes of
    data. The first byte of data is the digit location, from right to left (locations
    0 to 7). The address for each digit location is conveniently the same as the location
    plus 1; for example, the address for digit 5 is `0x06` in hexadecimal. The second
    byte of data is the actual number to display. To display the number nine on the
    leftmost digit of our module, for instance, we’d send `0x08` then `0x09` , as
    follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use decimal numbers or integer variables if convenient:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can view the address map for the digit locations in Table 2 of the MAX7219
    data sheet and the characters you can display in Table 5.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve set up out `writeMAX7219()` function to easily write data to
    the MAX7219, we harness this function within another function: `dispMAX7219(uint8_t
    digit, uint8_t number, uint8_t dp)` ❹. We use this to display digits in locations
    with or without the decimal point. Set `dp` to 1 to show the decimal point, or
    0 to not show it. For example, to display the number 3 without the decimal point
    on the rightmost digit of the module, we would use:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好`writeMAX7219()`函数来轻松地将数据写入MAX7219，我们将在另一个函数中使用这个函数：`dispMAX7219(uint8_t
    digit, uint8_t number, uint8_t dp)` ❹。我们用它来在有无小数点的位置显示数字。将`dp`设置为1以显示小数点，或者设置为0以不显示。例如，要在模块的最右侧数字上显示没有小数点的数字3，我们将使用：
- en: '[PRE5]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The decimal point is activated by adding 128 (which is `0xF0` in hexadecimal)
    to the byte representing the number to display ❺.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 小数点通过向表示数字的字节添加128（即十六进制的`0xF0`）来激活❺。
- en: All the custom functions mentioned so far build up to our final function, `numberMAX7219(`
    `uint32_t value` `)` ❻, which accepts an integer between 0 and 99,999,999 and
    shows it on our display module. This function uses modulo and division to break
    down the whole number into separate digits and places them in an array. It then
    runs through the array and sends each digit to the display.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止提到的所有自定义函数都为我们最终的函数`numberMAX7219(` `uint32_t value` `)` ❻做了铺垫，该函数接受一个0到99,999,999之间的整数并在我们的显示模块上显示出来。该函数使用取模和除法将整个数字分解为单独的数字，并将它们放入数组中。然后，它遍历数组并将每个数字发送到显示器。
- en: At the start of the function, we fill the array with the number 15 ❼. This is
    because sending a 15 as the number value to the MAX7219 causes the IC to blank
    the digit being addressed, allowing us to avoid displaying leading zeros for unused
    digits. Finally, the main loop of code ❽ sets up the interface pins used for SPI
    as outputs, and successively displays the numbers 0 through 99,999,999 on the
    LED display.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的开始，我们用数字15填充数组❼。这是因为将15作为数字值发送给MAX7219会使IC清空被寻址的数字，从而避免显示未使用的数字的前导零。最后，代码的主循环❽设置了用于SPI的接口引脚为输出，并依次在LED显示屏上显示数字0到99,999,999。
- en: This may seem like a lot of work, but now that you have the tools to easily
    drive these larger numerical displays, you can reuse the functions in your own
    projects. If you enjoy a challenge, why not write your own MAX7219 library? In
    the meantime, to set the stage for later projects, I’d like to introduce a new
    addition to your AVR circuitry.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能是一项大工程，但既然你已经掌握了轻松驱动这些较大数字显示器的工具，你可以在自己的项目中重用这些功能。如果你喜欢挑战，为什么不自己编写一个MAX7219库呢？与此同时，为了为后续项目做准备，我想介绍一下你AVR电路中的一个新组件。
- en: '[Project 47: Adding a Reset Button](nsp-boxall502581-0008.xhtml#rpro47)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目47：添加复位按钮](nsp-boxall502581-0008.xhtml#rpro47)'
- en: In future projects in this book and in your own creations, there will come a
    time when you need to literally reset a project so it starts operating again in
    the same manner as when first turned on. To enable this, your projects will need
    a reset button, which we’ll construct now. Reset buttons save time and are much
    more convenient than disconnecting then reconnecting the power supply.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的未来项目以及你自己的创作中，会有需要将项目复位的时刻，以便它能够像第一次开机时那样重新开始操作。为了实现这一点，你的项目将需要一个复位按钮，我们现在就来构建它。复位按钮节省时间，比断开电源再重新连接方便得多。
- en: 'To add reset buttons to your AVR projects, you will need the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的AVR项目中添加复位按钮，你将需要以下组件：
- en: • Pushbutton
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 按钮
- en: • 10 kΩ resistor
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 10 kΩ电阻
- en: • Jumper wires
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: The reset button circuit for the ATtiny85 is shown in [Figure 11-16](nsp-boxall502581-0021.xhtml#f11016)
    .
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ATtiny85的复位按钮电路见[图11-16](nsp-boxall502581-0021.xhtml#f11016)。
- en: '![Schematic diagram for adding a reset button to an ATtiny85 microcontroller](images/nsp-boxall502581-f11016.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![为ATtiny85微控制器添加复位按钮的电路图](images/nsp-boxall502581-f11016.jpg)'
- en: 'Figure 11-16: Reset button circuit for the ATtiny85'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-16：ATtiny85的复位按钮电路
- en: '[Figure 11-17](nsp-boxall502581-0021.xhtml#f11017) shows the reset button circuit
    for the ATmega328P-PU.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-17](nsp-boxall502581-0021.xhtml#f11017)显示了ATmega328P-PU的复位按钮电路。'
- en: '![Schematic diagram for adding a reset button to an ATmega328P-PU microcontroller](images/nsp-boxall502581-f11017.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![为ATmega328P-PU微控制器添加复位按钮的电路图](images/nsp-boxall502581-f11017.jpg)'
- en: 'Figure 11-17: Reset button circuit for the ATmega328P-PU'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-17：ATmega328P-PU的复位按钮电路
- en: If you are comparing this to the buttons discussed in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03)
    , notice the difference in the wiring. This button configuration, in which the
    connection of the resistor between the 5 V and RESET pins keeps the pin in a high
    state for normal operation, is called a *pullup* configuration. When the user
    presses the button, the RESET pin is set to a low state as the button directly
    connects the pin to GND.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'We know to use this pullup configuration thanks to the part’s schematic symbol
    in the data sheet: there’s a solid bar over the RESET pin’s label, unlike the
    labels for the other pins. This bar means that the default input for this pin
    for normal operation is high, and whatever function the pin is used for will be
    activated when it is set to low.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to add any code to your project to allow for the reset button—it’s
    a simple hardware addition. With the button set up, let’s move on to controlling
    two different SPI devices and learning how to receive data from the SPI bus. These
    sections will prepare us for the final project in this chapter, where we’ll create
    a simple digital voltmeter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple SPI Devices on the Same Bus](nsp-boxall502581-0008.xhtml#rah1302)'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use two or more different SPI-based devices on the same SPI bus, and
    doing so only requires one extra digital output pin per device. Simply connect
    all the SCK, MOSI, and MISO pins together, and then connect the SS pins to their
    own digital output pin on the AVR. For example, [Figure 11-18](nsp-boxall502581-0021.xhtml#f11018)
    shows two SPI devices on the one bus, each with its own SS line connected to a
    unique PORTB pin.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing how a main and two secondary devices are connected using
    the SPI bus](images/nsp-boxall502581-f11018.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-18: Two SPI devices connected to one microcontroller'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to communicate with a particular SPI device, just use the
    appropriate SS connection and proceed as normal. We’ll do that in the [next project](nsp-boxall502581-0021.xhtml#pro48)
    , which uses the MAX7219 LED display from [Project 46](nsp-boxall502581-0021.xhtml#pro46)
    along with a new device.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[Receiving Data from the SPI Bus](nsp-boxall502581-0008.xhtml#rah1303)'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained previously, we send a byte of data from the microcontroller to
    the SPI device by placing it in the SPDR register. Receiving a byte of data from
    an SPI device requires two operations: first the SPI device we’re communicating
    with sends a byte of data, then the AVR places this byte in the SPDR register
    for our use.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you can think of the SPI bus as a continuous circle of data, as shown
    in [Figure 11-19](nsp-boxall502581-0021.xhtml#f11019) .
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Image illustrating data flow between an SPI bus device and the microcontroller’s
    SPDR register](images/nsp-boxall502581-f11019.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-19: SPI bus data transfer'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: As a bit of data leaves the microcontroller on its way to the SPI device, a
    bit of data leaves the SPI device and heads back into the SPDR register. When
    you place a full byte of data in the SPDR register, it travels to the SPI device
    and pushes the data out of the SPI device and into the SPDR register.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: This means that when you need a byte of data from the SPI device, you need to
    send a byte of data to that device to “push” the data from the SPI device back
    to the SPDR register. You’ll see how this works in the [following project](nsp-boxall502581-0021.xhtml#pro48)
    .
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 48: Using the MCP3008 ADC IC](nsp-boxall502581-0008.xhtml#rpro48)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Back in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03) , you started to learn
    how to use the AVRs’ built-in ADC pins to measure connected voltages from external
    devices such as potentiometers and temperature sensors. However, if you want to
    use more ADCs, you may have a conflict with the usage of the ADC pins and other
    uses—that is, you may have already planned to use the pins on the microcontroller that
    can be used for ADCs for another purpose. An alternative is to use an external
    ADC IC like the Microchip MCP3008 8-channel ADC IC shown in [Figure 11-20](nsp-boxall502581-0021.xhtml#f11020)
    , which has eight ADC pins.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of an MCP3008 8-channel ADC IC](images/nsp-boxall502581-f11020.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-20: Microchip MCP3008 8-channel ADC IC'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Each of these eight pins can measure between 0 V and 5 V DC, and each returns
    a 10-bit value for measurement. The MCP3008 is easy to use, since it’s connected
    to the SPI bus, and you don’t need to worry about any other non-SPI bus AVR registers
    for setup or control. See the schematic in [Figure 11-21](nsp-boxall502581-0021.xhtml#f11021)
    .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the MCP3008](images/nsp-boxall502581-f11021.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-21: MCP3008 schematic symbol'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: To connect the ATmega328P-PU to the MCP3008, follow the guidelines in [Table
    11-3](nsp-boxall502581-0021.xhtml#tab1103) .
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 11-3 : ATmega328P-PU to MCP3008 Connections |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| ATmega328P-PU | MCP3008 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| 5 V | V [DD] |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| 5 V | V [REF] |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| GND | DGND, AGND |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| 15 | SS |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| 17 | D [IN] |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| 18 | D [OUT] |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| 19 | CLK |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: There are also some extra pins on the MCP3008 to consider. The first is the
    V [REF] , for voltage reference. Our ADC measures analog signals with a 10-bit
    resolution that represents the signal with a number between 0 and 1,023\. In our
    projects we’ll connect the V [REF] pin to the 5 V power supply, which gives our
    ADC a *reference voltage* —the upper limit (where the lower is zero) to the signals
    being measured.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Later, you may wish to measure signals between (for example) 0 and 3 V DC. You
    can then connect the V [REF] pin to a 3 V signal. In that case, the reading would
    be more accurate, since the 1,023 possible values would cover between 0 V and
    3 V, rather than spreading farther out over 0 V and 5 V.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The other eight pins are for ADC channels 0 to 7 and can be connected to signals
    up to 5 V DC. Do not exceed 5 V, as doing so will damage the IC. The negative
    or GND connections for the signals being measured connect to the AGND pin on the
    IC.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll use the MCP3008 to measure signals with one ADC, then
    display the value on our MAX7219 module from [Project 48](nsp-boxall502581-0021.xhtml#pro48)
    . In addition to familiarizing you with the MCP3008, this project serves as a
    great example of using two SPI bus devices with the same microcontroller.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1310)'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Microchip MCP3008 IC
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • MAX7219 eight-digit module
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 470 μF 16 V electrolytic capacitor
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 11-22](nsp-boxall502581-0021.xhtml#f11022)
    . Along with following the schematic, connect your display module as shown in
    [Table 11-2](nsp-boxall502581-0021.xhtml#tab1102) .
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 48](images/nsp-boxall502581-f11022.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-22: Schematic for [Project 48](nsp-boxall502581-0021.xhtml#pro48)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1311)'
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 48* subfolder of this book’s
    *Chapter 11* folder, and enter the command `make flash` to compile and upload
    the data as usual. Since nothing is currently connected to input, we say the ADC
    has a *floating input* . This means the value returned is somewhat random, and
    the display should show random numbers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Now connect something with an output between 0 V and 5 V DC, such as a AA battery
    or your TMP36 temperature sensor from previous projects, to the Signal+/–connections.
    Be sure to connect the positive of the signal or battery to the Signal+ pin on
    the ADC (pin 1) and the negative to GND (also marked as Signal– in the schematic).
    The display should now show the number of millivolts measured by the ADC (1 volt
    equals 1,000 millivolts). If you don’t have a battery or sensor or anything else
    to measure, simply connect the ADC input to the 5 V or GND line and see how close
    it is to 5 V or 0 V, respectively.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: As with all SPI devices, we determine the parameters for SPI bus setup from
    the SPCR register. [Figure 11-23](nsp-boxall502581-0021.xhtml#f11023) shows the
    timing diagram from the MCP3008’s data sheet (available at [https://www.microchip.com/wwwproducts/en/MCP3008/](https://www.microchip.com/wwwproducts/en/MCP3008/)
    ).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![SPI bus timing diagram for the MCP3008](images/nsp-boxall502581-f11023.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-23: Timing diagram for MCP3008'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we should set the DORD bit to 0, as the MCP3008 requires data
    to be sent LSB first. We’ll set the CPOL and CPHA bits to 0 as well, since the
    clock signal is low at the start of data transmission and the polarity of the
    clock signal is low at idle.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to learn how the MCP3008 is controlled. We’ll be using it in its
    simplest form, that of a single-ended ADC (so simply measuring between 0 V and
    V [REF] , in our case 5 V). Every time we want to use the MCP3008, we set the
    SPCR register to `0b01010010` . (If you’re using multiple SPI devices, you will
    need to set SPCR before communicating with each device.)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Next, we send three bytes of data to the MCP3008 so it will return the required
    ADC value to the microcontroller over two bytes. We first place `0b00000001` into
    SPDR as the “start bit” to activate the MCP3008\. Next, we place a configuration
    data byte into SPDR. The first bit is 1 for a single-ended ADC, then the next
    three bits represent, in binary, which ADC to use (0 to 7). As we’re using ADC
    0, we set these three bits to 0\. The last four bits are unused, so we leave them
    as 0.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve sent the configuration byte to the MCP3008, it returns a byte of
    data representing the most significant two bits of the ADC result (bits 0 and
    1 of the byte). As mentioned previously, data moves circularly through the SPI
    bus, so the byte from the MCP3008 is found in the SPDR register. To capture this
    byte of data, we “push” it out by placing an integer variable in SPDR. The remaining
    six bits of the byte will contain random data, so to set them to 0 we use the
    bitwise operation `&` on the captured byte.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need the last eight bits of the ADC result, so we push a random
    byte of data (all 0s is fine) down the SPI bus to receive the byte from the ADC
    by placing 0 in SPDR. After waiting for the transmission to complete, we then
    equate another integer variable to SPDR, which now contains the rest of the ADC
    data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have 2 bytes of data, one containing the top 2 bits (the MSB) and
    the other containing the other 8 bits of data (the LSB), we need to convert them
    into a single value: a 16-bit integer, which we’ll call the *result* . For this,
    we bit-shift the MSB variable 8 bits to the left into the result integer, then
    use bitwise operation `|` to drop the LSB variable into the result. At last, we
    have the 10-bit value of the ADC in one integer variable, which will be between
    0 and 1,023.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the code to see how this works:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this code, we have reused all the MAX7219 functions from [Project 48](nsp-boxall502581-0021.xhtml#pro48)
    to display the ADC value in millivolts. Our main code receives an ADC value, converts
    it to millivolts, then shows it on the MAX7219 display. You should be familiar
    with the basic structure by now.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We also declare a new function, `readMCP3008()` ❶, that returns a 16-bit integer
    containing the value measured by the MCP3008’s first ADC (0). Inside the function
    we define three variables—two 8-bit integers to hold the MSB and LSB of the data
    that the ADC returns and a 16-bit integer to return the full value of the ADC
    measurement—and set the `SPCR` register for the MCP3008 ❷. We then set the SS
    pin low to start the SPI bus as usual.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: After sending the start bit to activate the MCP3008 ❸, we wait for the SPI bus
    transmission to be completed, as always. Following this, we send the configuration
    byte, telling the MCP3008 we want a single-ended ADC result from channel 0\. Once
    we’ve done so, the MCP3008 returns the MSB of the result.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: We store the MSB in the variable `MSB` ❹ and perform the bitwise `&` to remove
    the random unnecessary bits. Then we request the LSB of the data by sending a
    random byte (here, all 0s) ❺, wait for the transmission to end, and store the
    data in `LSB` ❻. After this, we’re finished with the MCP3008, so we remove it
    from the SPI bus by setting the SS pin high ❼.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: We now have the two bytes of data that need to be converted to a single integer
    for return as the value of this function. We do this by shifting the MSB into
    the top eight bits of the return variable `ADCvalue` and dropping in the LSB with
    the `|` function ❽.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a value from the ADC, we move on to the main loop of code,
    assigning the reading from the ADC to a 16-bit integer ❾. However, this value
    falls between 0 and 1,023, so we need to convert it to millivolts (mV). Our V
    [REF] is 5 V, or 5,000 mV. Therefore, we divide 5,000 by 1,024 to determine the
    multiplier to convert this ADC value to mV: 4.8828\. The program then converts
    the ADC value to millivolts ⓿ and sends it to the display.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: At this point you should understand how to implement the SPI bus, including
    how to examine SPI device data sheets to locate the information required to use
    them with your AVR. You’ve also learned how to take advantage of the useful shift
    register IC, the MAX7219 display driver, and the MCP3008 ADC. This knowledge should
    prepare you to use other SPI-based parts for your own projects.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [next chapter](nsp-boxall502581-0022.xhtml#ch12) , you’ll learn how
    to use many more interesting and useful parts with another type of data bus: the
    I ² C.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
