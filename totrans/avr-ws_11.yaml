- en: '[11](nsp-boxall502581-0008.xhtml#rch11)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AVR and the SPI Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can loosely define a *bus* as a connection between two devices that allows
    us to send data from one device to the other. For example, there are several types
    of data buses that can connect your AVR microcontroller to a sensor or display
    device. This chapter introduces the *serial peripheral interface (SPI) bus* ,
    which we use to send bytes of data directly between a primary device and one or
    more secondary devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: • Implement the SPI bus with AVR microcontrollers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Read SPI device data sheets in order to write matching code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Add a reset button to your projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Use two different SPI-based devices in the same project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, you’ll also learn how to use 74HC595 shift register ICs to increase
    the number of available digital output pins, display eight-digit numbers with
    a MAX7219 LED display driver IC, and measure voltages with the MCP3008 ADC IC.
  prefs: []
  type: TYPE_NORMAL
- en: '[How Buses Work](nsp-boxall502581-0008.xhtml#rah1301)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SPI bus enables communication between AVR microcontrollers and many popular
    parts and sensors. It works similarly to the USART that we used in [Chapters 4](nsp-boxall502581-0014.xhtml#ch04)
    and [9](nsp-boxall502581-0019.xhtml#ch09) , in that it transmits data in serial
    fashion from the microcontroller using one wire and to the microcontroller using
    another. However, the SPI bus also uses a third connection: a *clock line* , which
    carries an electrical signal that turns on and off at a constant frequency. Every
    time the clock changes state from high to low or low to high, a bit of data (an
    *on* or *off* ) is sent along the data line either from or to the microcontroller.
    The clock signal synchronizes with the data signal, allowing for fast and accurate
    data transmission.'
  prefs: []
  type: TYPE_NORMAL
- en: We can demonstrate the changing states of the data and clock lines using a DSO.
    For example, consider [Figure 11-1](nsp-boxall502581-0021.xhtml#f11001) , which
    shows a byte of data traveling along the SPI bus.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture from a digital storage oscilloscope showing the two channels
    of the SPI bus, and the electrical representation of a byte of data on the SPI
    bus](images/nsp-boxall502581-f11001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: A DSO showing a byte of data traveling on the SPI bus'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 11-1](nsp-boxall502581-0021.xhtml#f11001) , the upper waveform (marked
    1 in the left margin) is the clock signal, which is activated when we use the
    SPI bus. The signal starts at 0 V, moves up to 5 V, then returns to 0 V, repeating
    this pattern if data is being transferred. The lower waveform (marked 2) represents
    the data, with a 1 being a 5 V signal and a 1 being a 0 V signal. From right to
    left, the data being sent is 10110110.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SPI bus can send and receive data simultaneously and at different speeds,
    depending on the microcontroller or SPI-based device used. Communication with
    the SPI bus uses a *main–secondary* configuration: the AVR acts as the *main*
    and determines which device (the *secondary* ) it will communicate with at a given
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book we’ll use the ATmega328P-PU microcontroller for projects that use
    the SPI bus, since the ATtiny85 doesn’t have enough memory or output pins to run
    those projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Pin Connections and Voltages](nsp-boxall502581-0008.xhtml#rbh1301)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each SPI device uses four pins to communicate with a main:'
  prefs: []
  type: TYPE_NORMAL
- en: • MOSI (main out, secondary in)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • MISO (main in, secondary out)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • SCK (clock)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • SS (secondary select, also known as “latch”)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These SPI pins connect to your microcontroller as shown in [Figure 11-2](nsp-boxall502581-0021.xhtml#f11002)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing how a main and secondary device are connected using the SPI
    bus](images/nsp-boxall502581-f11002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: Typical AVR-to-SPI device connection'
  prefs: []
  type: TYPE_NORMAL
- en: The SS pin on the SPI main device is labeled PBx in [Figure 11-2](nsp-boxall502581-0021.xhtml#f11002)
    ; you can use any free GPIO pin, but to keep things simple it’s good to use a
    free pin on PORTB as the connection will be close to the SPI pins. Different manufacturers
    often use their own terminology for the SPI bus connections, but this should be
    easy to interpret after a quick examination.
  prefs: []
  type: TYPE_NORMAL
- en: Since our AVR runs on 5 V in the following projects, your SPI device must also
    operate at or tolerate operating at 5 V, so be sure to check this with the seller
    or manufacturer before use. If you simply must use an SPI device that operates
    at a reduced voltage, such as 3.3 V, you can use a *level converter* like PMD
    Way part number 441079, shown in [Figure 11-3](nsp-boxall502581-0021.xhtml#f11003)
    . A level converter can convert a 5 V digital signal to a 3.3 V signal, and vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a level converter](images/nsp-boxall502581-f11003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: PMD Way part number 441079'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a four-channel level converter board, meaning it can convert four independent
    electrical signals on the one board. To use a level converter, wire it between
    the four wires on the SPI bus: place the 5 V wires on the HV pads and the matching
    lower voltage wires on the LV pads and connect GND of both sides to the board.
    Remember to disconnect your USBasp programmer from your projects once you’ve uploaded
    the code, as the programmer’s pins share the SPI pins and can sometimes cause
    interruptions to the data flow between the microcontroller and the SPI-based device.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Implementing the SPI Bus](nsp-boxall502581-0008.xhtml#rbh1302)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, let’s examine how to implement the SPI bus in our code and how to make
    the hardware connections. I’ll show you some parameters of an example SPI part
    being used, then how to adjust the SPI Control Register (SPCR) shown in [Figure
    11-4](nsp-boxall502581-0021.xhtml#f11004) to activate the SPI bus to our required
    parameters. In the following projects, I’ll also show you how this is done for
    various other SPI parts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of the SPI control register from the microcontroller’s data sheet](images/nsp-boxall502581-f11004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: SPCR diagram from the ATmega328P-PU data sheet'
  prefs: []
  type: TYPE_NORMAL
- en: Leave SPIE as 0, as we’re not working with interrupts, and set SPE to 1 to enable
    the SPI bus. Next, consider the DORD bit, which determines whether the byte of
    data is sent with the MSB (most significant bit, bit 7 of the byte) or the LSB
    (least significant bit, bit 0 of the byte) first. You’ll need to determine the
    direction from the secondary’s data sheet, which will include a timing diagram
    like the one in [Figure 11-5](nsp-boxall502581-0021.xhtml#f11005) , or the supplier.
  prefs: []
  type: TYPE_NORMAL
- en: '![SPI bus timing diagram for the MAX7219 LED display controller IC](images/nsp-boxall502581-f11005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: Example timing diagram for an SPI device (the MAX7219)'
  prefs: []
  type: TYPE_NORMAL
- en: Review the timing diagram’s DIN line. The data travels down the bus with the
    MSB first. If D0 were at the start of the line, the LSB would be first. Set DORD
    to 1 for LSB first, to 0 for MSB first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the SPCR, set MSTR to 1 to enable the microcontroller as the main
    device, and 0 if you need to enable the microcontroller as the secondary device.
    For all our projects we’ll use 1\. Next, set CPOL to match the polarity of the
    clock (SCK) signal in the SPI bus when idle (that is, before and after data is
    carried on the bus): 0 for a low signal or 1 for a high signal. Again, you can
    get this information from the timing diagram: in [Figure 11-5](nsp-boxall502581-0021.xhtml#f11005)
    the CLK (or clock/SCK) line is low when not in use, then rises when the first
    bit of data arrives, then alternates repeatedly until the data transmission has
    finished and it falls low again, so for this device you’d set it to 0.'
  prefs: []
  type: TYPE_NORMAL
- en: CPHA, the clock-phase bit, determines whether the data is sampled at the start
    or the end of the clock bit. For example, review the CLK and DIN lines of [Figure
    11-5](nsp-boxall502581-0021.xhtml#f11005) . The data is sampled at the start of
    the clock bit, as the clock rises at the start time of the data bits. In this
    case you would set CPHA to 0\. If the data bit started as the clock bit ended,
    CPHA would be 1.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll use the last two bits, SPR1 and SPR0, in conjunction to set
    the speed of the clock and matching data signals on the SPI bus. Set both to 0
    for maximum speed in relation to the microcontroller. Also set the AVR output
    pin connected to your SPI device’s SS pin as an output using a `DDR` `x` function,
    then set that pin to high using the typical `PORT` `x` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending Data](nsp-boxall502581-0008.xhtml#rbh1303)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you’ve initialized your SPI bus, it should be ready to receive and
    send data. We’ll practice sending data first, then examine receiving data later
    in this chapter. To send a byte of data to the SPI device, you need to do four
    things (all of which we’ll do in the [next project](nsp-boxall502581-0021.xhtml#pro44)
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: • Set the SS pin low using a `PORT` `x` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Place the byte of data you wish to send into the SPDR register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Wait for the transmission to finish using `while(!(SPSR & (1<<SPIF)));` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Set the SS pin high using a `PORT` `x` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may seem a little complicated, but with practice and the right information
    from part suppliers, it’s easy. I’ll explain everything you need to know to build
    our SPI bus projects, the first of which harnesses a particularly useful shift
    register IC.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 44: Using the 74HC595 Shift Register](nsp-boxall502581-0008.xhtml#rpro44)'
  prefs: []
  type: TYPE_NORMAL
- en: When your AVR-based project doesn’t have enough digital output pins, you can
    connect one or more *shift registers* and still have plenty of output pins for
    use on the AVR itself. A shift register is an integrated circuit with eight digital
    output pins that we can control by sending a byte of data to the IC via the SPI
    bus. The projects in this chapter will use the 74HC595 shift register, as shown
    in [Figure 11-6](nsp-boxall502581-0021.xhtml#f11006) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a 74HC595 shift register integrated circuit](images/nsp-boxall502581-f11006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: The 74HC595 shift register IC'
  prefs: []
  type: TYPE_NORMAL
- en: The 74HC595 shift register has eight digital outputs that operate in the same
    way as your AVR’s digital outputs, as shown in [Figure 11-7](nsp-boxall502581-0021.xhtml#f11007)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the 74HC595 shift register IC](images/nsp-boxall502581-f11007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: The 74HC595 schematic symbol'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-1](nsp-boxall502581-0021.xhtml#tab1101) gives details on how to connect
    the shift register to the microcontroller.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 11-1 : 74HC595 Connections |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Pin | Connection |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 5 V positive power supply |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | GND |'
  prefs: []
  type: TYPE_TB
- en: '| QA to QH (15, 1–7) | Digital outputs 0 to 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 5 V positive power supply |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | SPI bus clock |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | SPI SS |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | GND |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | SPI data in |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | SPI data out |'
  prefs: []
  type: TYPE_TB
- en: 'The principle behind the shift register is simple: we send 1 byte of data (8
    bits) to the shift register, which turns the matching eight outputs on or off
    based on that byte of data. The bits representing the byte match the output pins
    in order from highest to lowest. Therefore, the MSB of the data represents output
    pin 7 of the shift register, while the LSB represents output pin 0\. For example,
    if we send the byte `0b10000110` to the shift register via the SPI bus, it will
    turn on outputs 7, 2, and 1 and will turn off outputs 0 and 3–6 until the shift
    register receives the next byte of data, or we turn the power off.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you send a new byte of data to the shift register, it sends the previous
    byte of data out via SPI pin 9, the data out pin. Thus, you can harness two or
    more, sending multiple bytes of data in one operation to control multiple shift
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: Note You can usually draw up to 20 mA of current from an output pin, and the
    total current drawn from an entire 74HC595 shouldn’t exceed 75 mA.
  prefs: []
  type: TYPE_NORMAL
- en: You get an extra eight digital output pins for every shift register attached
    to the SPI bus. This makes shift registers very convenient when you want to control
    lots of LEDs or other devices. In this project, we’ll use it to control a seven-segment
    numeric LED display.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1304)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your display circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 74HC595 shift register IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One common-cathode seven-segment LED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Eight 560 Ω resistors (R1–R8)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 11-8](nsp-boxall502581-0021.xhtml#f11008)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 44](images/nsp-boxall502581-f11008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: Schematic for [Project 44](nsp-boxall502581-0021.xhtml#pro44)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1305)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 44* subfolder of this book’s
    *Chapter 11* folder, and enter the command `make flash` to compile and upload
    the data as usual. Don’t forget to disconnect the programmer once you’ve uploaded
    it to the microcontroller. After a moment, the digits 0 to 9 should show in ascending
    order on the LED display, and then repeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the code to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code contains a couple of custom functions, the first being `setupSPI()`
    ❶. We use this function to initialize the SPI bus and set the SS pin to high,
    then set the SPCR register as explained earlier in this chapter. We set the DORD
    bit in the SPCR register to 1, as we need to send data to the 74HC595 with the
    LSB first. We can see the requirement to use the 56LSB first from the timing diagram
    in the 74HC595’s data sheet, shown in [Figure 11-9](nsp-boxall502581-0021.xhtml#f11009)
    : Q [A] (the first output pin) is the first to be set high.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Timing diagram for the 74HC595](images/nsp-boxall502581-f11009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: The 74HC595’s timing diagram'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to determine what value to use for the CPOL bit. We set this to
    0, since the polarity of the clock signal is low, or off, when idle.
  prefs: []
  type: TYPE_NORMAL
- en: The final bit to consider is CPHA, the clock-phase bit mentioned earlier. If
    you refer to the diagram again and compare the RCLK timing and signals to any
    of the Q outputs, you’ll see that they both change from low to high at the same
    time. Therefore, the data is sampled at the start, so we set CPHA to 0\. The final
    bits (1 and 0) we leave as 0 to set the SPI bus for maximum possible speed.
  prefs: []
  type: TYPE_NORMAL
- en: Our second custom function, `dispNumSR()` ❷, accepts an integer between 0 and
    9 and shows this on the LED display. It first sets the SS pin low ❸, then determines
    which matching byte of data for the digit to display using a `switch...case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The microcontroller sends each byte of data with the LSB first. The bits match
    the eight outputs on the 74HC595, which we wire to the LED display segments A−G
    and the decimal point, respectively, as shown in [Figure 11-8](nsp-boxall502581-0021.xhtml#f11008)
    . This byte of data is then placed in the SPDR register in each matching `case`
    statement. The code waits for the transfer to finish ❹, then sets the SS pin high
    to complete the data transmission.
  prefs: []
  type: TYPE_NORMAL
- en: The main loop of code ❺ simply sets up PORTB as outputs, as it contains the
    pins we need for all four SPI bus connections, then calls the `setupSPI()` function
    to set up the SPI bus as described earlier. It then sends the numbers 0 to 9 to
    the LED display.
  prefs: []
  type: TYPE_NORMAL
- en: The decimal point in our project is connected, but not in use. You can turn
    it on and off with the last bit of the byte sent to the shift register. For a
    challenge, try modifying the `dispNumSR()` function to accept a second variable
    to turn the decimal point on or off.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to control a single device with the SPI bus, let’s try
    using it to control two devices at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 45: Using Two 74HC595 Shift Registers](nsp-boxall502581-0008.xhtml#rpro45)'
  prefs: []
  type: TYPE_NORMAL
- en: Using two or more shift registers is an inexpensive and simple way to control
    many more digital outputs with your AVR. As an example, this project uses two
    74HC595 shift registers to show double-digit numbers via two LED displays.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1306)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your display circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 74HC595 shift registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two common-cathode seven-segment LED displays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16 560 Ω resistors (R1–R16)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 11-10](nsp-boxall502581-0021.xhtml#f11010)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 45](images/nsp-boxall502581-f11010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: Schematic for [Project 45](nsp-boxall502581-0021.xhtml#pro45)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1307)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 45* subfolder of this book’s
    *Chapter 11* folder, and enter the command `make flash` to compile and upload
    the data as usual. After a moment or two the numbers 0 through 99 should appear
    in ascending order on the LED displays, then repeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code for this dual-digit version is similar to that of [Project 44](nsp-boxall502581-0021.xhtml#pro44)
    , except that since we have two shift registers to control, it sends two bytes
    of data at once. This time, the `dispNumSR()` function ❶ accepts a number between
    0 and 99, then divides the number using division and modulo ❸ in order to treat
    each digit separately and store them in the `leftDigit` and `rightDigit` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the required operation for sending SPI data begins. We set the SS pin
    low ❹, then send out the byte of data that represents the digit 0 to 9 as specified
    in the `digitData` array ❷ for the right-hand digit to the shift register ❺. After
    waiting ❻ for the byte to be transferred, we send the byte of data for the left-hand
    digit in the same manner. After we’ve finished waiting for the transmission to
    complete, the code sets the SS pin high ❼ to complete the data transmission. The
    SS pins of both shift registers are connected, so we only need one digital output
    to control them.
  prefs: []
  type: TYPE_NORMAL
- en: The byte for the second (ones) digit is sent first, as it is the second shift
    register—the byte sits in the first shift register, then the byte for the tens
    digit is sent, which pushes the first byte into the second shift register. That
    means the first shift register contains the data for the tens digit, and the second
    shift register contains the data for the ones digit. Once the SS pin is set high,
    the shift registers’ outputs activate, and the LED displays begin showing the
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Although this project controlled LED displays, you now have the necessary skills
    to use multiple shift registers to expand your AVR’s outputs in other cases. If
    you need to control larger numerical displays—up to eight digits—the next project
    is for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 46: Using the MAX7219 LED Driver IC](nsp-boxall502581-0008.xhtml#rpro46)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need to use more than two seven-segment numerical displays for a project,
    the wiring and related controls can become quite complex. Thankfully, there’s
    a solution for this: the Maxim MAX7219 LED driver IC, a popular IC that can control
    up to 64 LEDs at once. In turn, we can use these LEDs to simultaneously display
    eight numerical digits with only four control wires via the SPI bus. This project
    shows how to use this display module.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1308)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MAX7219 is available in both through-hole ( [Figure 11-11](nsp-boxall502581-0021.xhtml#f11011)
    ) and surface-mount ( [Figure 11-12](nsp-boxall502581-0021.xhtml#f11012) ) package
    types.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a through-hole MAX7219](images/nsp-boxall502581-f11011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: The MAX7219 in a surface-mount package type'
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a surface-mount MAX7219](images/nsp-boxall502581-f11012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: The MAX7219 in a through-hole package type'
  prefs: []
  type: TYPE_NORMAL
- en: The through-hole version is most useful when working with a solderless breadboard
    or making your own hand-assembled printed circuit board (PCB). If you have trouble
    finding a MAX7219, the Allegro AS1107 is a drop-in replacement.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re looking to control large numerical displays, you can easily find them
    preassembled, usually with four to eight digits fitted to a module with the MAX7219\.
    For this project we’ll use an eight-digit module, as shown in [Figure 11-13](nsp-boxall502581-0021.xhtml#f11013)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of an eight-digit LED module with a MAX7219](images/nsp-boxall502581-f11013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-13: An eight-digit LED module'
  prefs: []
  type: TYPE_NORMAL
- en: These modules use the surface-mount version of the MAX7219, which is soldered
    onto the rear of the module’s PCB. The modules usually include some inline header
    pins to allow for attaching control wires. If you haven’t already done so, solder
    these pins to your module as shown in [Figure 11-14](nsp-boxall502581-0021.xhtml#f11014)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the header pins soldered to the eight-digit LED module](images/nsp-boxall502581-f11014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-14: Connecting inline header pins'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • MAX7219 eight-digit module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 470 μF 16 V electrolytic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 11-15](nsp-boxall502581-0021.xhtml#f11015)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 46](images/nsp-boxall502581-f11015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-15: Schematic for [Project 46](nsp-boxall502581-0021.xhtml#pro46)'
  prefs: []
  type: TYPE_NORMAL
- en: As you construct your circuit to follow the schematic, connect your display
    module as shown in [Table 11-2](nsp-boxall502581-0021.xhtml#tab1102) .
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 11-2 : ATmega328P-PU to MAX7219 Connections |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| ATmega328P-PU | MAX7219 module |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | V [cc] |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | GND |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | DIN |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | SS |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | CLK |'
  prefs: []
  type: TYPE_TB
- en: Note that the display may quickly draw and stop drawing current, which sometimes
    will affect the power supply voltage. Therefore, we use a 470 μF electrolytic
    capacitor to keep the 5 V power smooth. You can review capacitor types in [Chapter
    2](nsp-boxall502581-0012.xhtml#ch02) .
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the code, let’s consider the parameters required for the
    SPI setup via the SPCR register. From the timing diagram for the MAX7219 in [Figure
    11-5](nsp-boxall502581-0021.xhtml#f11005) , we can see that we should set the
    DORD bit to 0, as the MAX7219 requires data sent LSB first. We’ll set the CPOL
    bit to 0, as the clock signal is low at the start of data transmission, and we’ll
    set the CPHA bit to 0 too, as the clock signal’s polarity is low at idle.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to explore how to control the MAX7219\. Every time we want the IC
    to do something, we must send two bytes of data. The first byte is the address
    of a control register (other ICs have registers just as the microcontroller does),
    and the second byte is the value to be stored in that register. This could be
    setup configuration such as display brightness, or the value that represents a
    number to display on a certain digit.
  prefs: []
  type: TYPE_NORMAL
- en: The possible values for each register are described in the MAX7219 using hexadecimal
    numbers (base-16), so we’ll use them to save effort. You can store hexadecimal
    numbers in `char` variable types. For your own reference and research, you may
    wish to download and review the MAX7219’s data sheet from [https://www.maximintegrated.com/en/products/power/display-power-control/MAX7219.html](https://www.maximintegrated.com/en/products/power/display-power-control/MAX7219.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1309)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the [Project 46](nsp-boxall502581-0021.xhtml#pro46)
    subfolder of this book’s [Chapter 11](nsp-boxall502581-0021.xhtml#ch11) folder,
    and enter the command `make flash` to compile and upload the data as usual. After
    a moment or two the display should show eight zeros, then count upward until it
    gets to 9,999,999, then repeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To save time, we use a custom function, `writeMAX7219(` `char hexdata1` `,`
    `char hexdata2` `)` ❶, to send two hexadecimal bytes of data to the IC via the
    SPI bus. This function sets the SS pin low, assigns the first byte of data to
    the SPDR register, waits for transmission to finish, then repeats the process
    for the second byte and the sets the SS pin high again. After setting up the SPI
    bus, we initialize the MAX7219 by placing values in four configuration registers
    using another custom function, `initMAX7219()` ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Before writing any digits to the display, we introduce the `blankMAX7219()`
    function ❷ to be sure we clear the display between writes. Without this function,
    if we were to, say, write 32,785 to the display and then write 45, the display
    would show 32,745.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show a digit on the display, we use `writeMAX7219()` to send two bytes of
    data. The first byte of data is the digit location, from right to left (locations
    0 to 7). The address for each digit location is conveniently the same as the location
    plus 1; for example, the address for digit 5 is `0x06` in hexadecimal. The second
    byte of data is the actual number to display. To display the number nine on the
    leftmost digit of our module, for instance, we’d send `0x08` then `0x09` , as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use decimal numbers or integer variables if convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can view the address map for the digit locations in Table 2 of the MAX7219
    data sheet and the characters you can display in Table 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve set up out `writeMAX7219()` function to easily write data to
    the MAX7219, we harness this function within another function: `dispMAX7219(uint8_t
    digit, uint8_t number, uint8_t dp)` ❹. We use this to display digits in locations
    with or without the decimal point. Set `dp` to 1 to show the decimal point, or
    0 to not show it. For example, to display the number 3 without the decimal point
    on the rightmost digit of the module, we would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The decimal point is activated by adding 128 (which is `0xF0` in hexadecimal)
    to the byte representing the number to display ❺.
  prefs: []
  type: TYPE_NORMAL
- en: All the custom functions mentioned so far build up to our final function, `numberMAX7219(`
    `uint32_t value` `)` ❻, which accepts an integer between 0 and 99,999,999 and
    shows it on our display module. This function uses modulo and division to break
    down the whole number into separate digits and places them in an array. It then
    runs through the array and sends each digit to the display.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the function, we fill the array with the number 15 ❼. This is
    because sending a 15 as the number value to the MAX7219 causes the IC to blank
    the digit being addressed, allowing us to avoid displaying leading zeros for unused
    digits. Finally, the main loop of code ❽ sets up the interface pins used for SPI
    as outputs, and successively displays the numbers 0 through 99,999,999 on the
    LED display.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem like a lot of work, but now that you have the tools to easily
    drive these larger numerical displays, you can reuse the functions in your own
    projects. If you enjoy a challenge, why not write your own MAX7219 library? In
    the meantime, to set the stage for later projects, I’d like to introduce a new
    addition to your AVR circuitry.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 47: Adding a Reset Button](nsp-boxall502581-0008.xhtml#rpro47)'
  prefs: []
  type: TYPE_NORMAL
- en: In future projects in this book and in your own creations, there will come a
    time when you need to literally reset a project so it starts operating again in
    the same manner as when first turned on. To enable this, your projects will need
    a reset button, which we’ll construct now. Reset buttons save time and are much
    more convenient than disconnecting then reconnecting the power supply.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add reset buttons to your AVR projects, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Pushbutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reset button circuit for the ATtiny85 is shown in [Figure 11-16](nsp-boxall502581-0021.xhtml#f11016)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for adding a reset button to an ATtiny85 microcontroller](images/nsp-boxall502581-f11016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-16: Reset button circuit for the ATtiny85'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-17](nsp-boxall502581-0021.xhtml#f11017) shows the reset button circuit
    for the ATmega328P-PU.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for adding a reset button to an ATmega328P-PU microcontroller](images/nsp-boxall502581-f11017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-17: Reset button circuit for the ATmega328P-PU'
  prefs: []
  type: TYPE_NORMAL
- en: If you are comparing this to the buttons discussed in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03)
    , notice the difference in the wiring. This button configuration, in which the
    connection of the resistor between the 5 V and RESET pins keeps the pin in a high
    state for normal operation, is called a *pullup* configuration. When the user
    presses the button, the RESET pin is set to a low state as the button directly
    connects the pin to GND.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know to use this pullup configuration thanks to the part’s schematic symbol
    in the data sheet: there’s a solid bar over the RESET pin’s label, unlike the
    labels for the other pins. This bar means that the default input for this pin
    for normal operation is high, and whatever function the pin is used for will be
    activated when it is set to low.'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to add any code to your project to allow for the reset button—it’s
    a simple hardware addition. With the button set up, let’s move on to controlling
    two different SPI devices and learning how to receive data from the SPI bus. These
    sections will prepare us for the final project in this chapter, where we’ll create
    a simple digital voltmeter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple SPI Devices on the Same Bus](nsp-boxall502581-0008.xhtml#rah1302)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use two or more different SPI-based devices on the same SPI bus, and
    doing so only requires one extra digital output pin per device. Simply connect
    all the SCK, MOSI, and MISO pins together, and then connect the SS pins to their
    own digital output pin on the AVR. For example, [Figure 11-18](nsp-boxall502581-0021.xhtml#f11018)
    shows two SPI devices on the one bus, each with its own SS line connected to a
    unique PORTB pin.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram showing how a main and two secondary devices are connected using
    the SPI bus](images/nsp-boxall502581-f11018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-18: Two SPI devices connected to one microcontroller'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to communicate with a particular SPI device, just use the
    appropriate SS connection and proceed as normal. We’ll do that in the [next project](nsp-boxall502581-0021.xhtml#pro48)
    , which uses the MAX7219 LED display from [Project 46](nsp-boxall502581-0021.xhtml#pro46)
    along with a new device.
  prefs: []
  type: TYPE_NORMAL
- en: '[Receiving Data from the SPI Bus](nsp-boxall502581-0008.xhtml#rah1303)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained previously, we send a byte of data from the microcontroller to
    the SPI device by placing it in the SPDR register. Receiving a byte of data from
    an SPI device requires two operations: first the SPI device we’re communicating
    with sends a byte of data, then the AVR places this byte in the SPDR register
    for our use.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you can think of the SPI bus as a continuous circle of data, as shown
    in [Figure 11-19](nsp-boxall502581-0021.xhtml#f11019) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image illustrating data flow between an SPI bus device and the microcontroller’s
    SPDR register](images/nsp-boxall502581-f11019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-19: SPI bus data transfer'
  prefs: []
  type: TYPE_NORMAL
- en: As a bit of data leaves the microcontroller on its way to the SPI device, a
    bit of data leaves the SPI device and heads back into the SPDR register. When
    you place a full byte of data in the SPDR register, it travels to the SPI device
    and pushes the data out of the SPI device and into the SPDR register.
  prefs: []
  type: TYPE_NORMAL
- en: This means that when you need a byte of data from the SPI device, you need to
    send a byte of data to that device to “push” the data from the SPI device back
    to the SPDR register. You’ll see how this works in the [following project](nsp-boxall502581-0021.xhtml#pro48)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 48: Using the MCP3008 ADC IC](nsp-boxall502581-0008.xhtml#rpro48)'
  prefs: []
  type: TYPE_NORMAL
- en: Back in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03) , you started to learn
    how to use the AVRs’ built-in ADC pins to measure connected voltages from external
    devices such as potentiometers and temperature sensors. However, if you want to
    use more ADCs, you may have a conflict with the usage of the ADC pins and other
    uses—that is, you may have already planned to use the pins on the microcontroller that
    can be used for ADCs for another purpose. An alternative is to use an external
    ADC IC like the Microchip MCP3008 8-channel ADC IC shown in [Figure 11-20](nsp-boxall502581-0021.xhtml#f11020)
    , which has eight ADC pins.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of an MCP3008 8-channel ADC IC](images/nsp-boxall502581-f11020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-20: Microchip MCP3008 8-channel ADC IC'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these eight pins can measure between 0 V and 5 V DC, and each returns
    a 10-bit value for measurement. The MCP3008 is easy to use, since it’s connected
    to the SPI bus, and you don’t need to worry about any other non-SPI bus AVR registers
    for setup or control. See the schematic in [Figure 11-21](nsp-boxall502581-0021.xhtml#f11021)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the MCP3008](images/nsp-boxall502581-f11021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-21: MCP3008 schematic symbol'
  prefs: []
  type: TYPE_NORMAL
- en: To connect the ATmega328P-PU to the MCP3008, follow the guidelines in [Table
    11-3](nsp-boxall502581-0021.xhtml#tab1103) .
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 11-3 : ATmega328P-PU to MCP3008 Connections |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| ATmega328P-PU | MCP3008 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 5 V | V [DD] |'
  prefs: []
  type: TYPE_TB
- en: '| 5 V | V [REF] |'
  prefs: []
  type: TYPE_TB
- en: '| GND | DGND, AGND |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | SS |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | D [IN] |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | D [OUT] |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | CLK |'
  prefs: []
  type: TYPE_TB
- en: There are also some extra pins on the MCP3008 to consider. The first is the
    V [REF] , for voltage reference. Our ADC measures analog signals with a 10-bit
    resolution that represents the signal with a number between 0 and 1,023\. In our
    projects we’ll connect the V [REF] pin to the 5 V power supply, which gives our
    ADC a *reference voltage* —the upper limit (where the lower is zero) to the signals
    being measured.
  prefs: []
  type: TYPE_NORMAL
- en: Later, you may wish to measure signals between (for example) 0 and 3 V DC. You
    can then connect the V [REF] pin to a 3 V signal. In that case, the reading would
    be more accurate, since the 1,023 possible values would cover between 0 V and
    3 V, rather than spreading farther out over 0 V and 5 V.
  prefs: []
  type: TYPE_NORMAL
- en: The other eight pins are for ADC channels 0 to 7 and can be connected to signals
    up to 5 V DC. Do not exceed 5 V, as doing so will damage the IC. The negative
    or GND connections for the signals being measured connect to the AGND pin on the
    IC.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll use the MCP3008 to measure signals with one ADC, then
    display the value on our MAX7219 module from [Project 48](nsp-boxall502581-0021.xhtml#pro48)
    . In addition to familiarizing you with the MCP3008, this project serves as a
    great example of using two SPI bus devices with the same microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1310)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Microchip MCP3008 IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • MAX7219 eight-digit module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 470 μF 16 V electrolytic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 11-22](nsp-boxall502581-0021.xhtml#f11022)
    . Along with following the schematic, connect your display module as shown in
    [Table 11-2](nsp-boxall502581-0021.xhtml#tab1102) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 48](images/nsp-boxall502581-f11022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-22: Schematic for [Project 48](nsp-boxall502581-0021.xhtml#pro48)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1311)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 48* subfolder of this book’s
    *Chapter 11* folder, and enter the command `make flash` to compile and upload
    the data as usual. Since nothing is currently connected to input, we say the ADC
    has a *floating input* . This means the value returned is somewhat random, and
    the display should show random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Now connect something with an output between 0 V and 5 V DC, such as a AA battery
    or your TMP36 temperature sensor from previous projects, to the Signal+/–connections.
    Be sure to connect the positive of the signal or battery to the Signal+ pin on
    the ADC (pin 1) and the negative to GND (also marked as Signal– in the schematic).
    The display should now show the number of millivolts measured by the ADC (1 volt
    equals 1,000 millivolts). If you don’t have a battery or sensor or anything else
    to measure, simply connect the ADC input to the 5 V or GND line and see how close
    it is to 5 V or 0 V, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: As with all SPI devices, we determine the parameters for SPI bus setup from
    the SPCR register. [Figure 11-23](nsp-boxall502581-0021.xhtml#f11023) shows the
    timing diagram from the MCP3008’s data sheet (available at [https://www.microchip.com/wwwproducts/en/MCP3008/](https://www.microchip.com/wwwproducts/en/MCP3008/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![SPI bus timing diagram for the MCP3008](images/nsp-boxall502581-f11023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-23: Timing diagram for MCP3008'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we should set the DORD bit to 0, as the MCP3008 requires data
    to be sent LSB first. We’ll set the CPOL and CPHA bits to 0 as well, since the
    clock signal is low at the start of data transmission and the polarity of the
    clock signal is low at idle.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to learn how the MCP3008 is controlled. We’ll be using it in its
    simplest form, that of a single-ended ADC (so simply measuring between 0 V and
    V [REF] , in our case 5 V). Every time we want to use the MCP3008, we set the
    SPCR register to `0b01010010` . (If you’re using multiple SPI devices, you will
    need to set SPCR before communicating with each device.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we send three bytes of data to the MCP3008 so it will return the required
    ADC value to the microcontroller over two bytes. We first place `0b00000001` into
    SPDR as the “start bit” to activate the MCP3008\. Next, we place a configuration
    data byte into SPDR. The first bit is 1 for a single-ended ADC, then the next
    three bits represent, in binary, which ADC to use (0 to 7). As we’re using ADC
    0, we set these three bits to 0\. The last four bits are unused, so we leave them
    as 0.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve sent the configuration byte to the MCP3008, it returns a byte of
    data representing the most significant two bits of the ADC result (bits 0 and
    1 of the byte). As mentioned previously, data moves circularly through the SPI
    bus, so the byte from the MCP3008 is found in the SPDR register. To capture this
    byte of data, we “push” it out by placing an integer variable in SPDR. The remaining
    six bits of the byte will contain random data, so to set them to 0 we use the
    bitwise operation `&` on the captured byte.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need the last eight bits of the ADC result, so we push a random
    byte of data (all 0s is fine) down the SPI bus to receive the byte from the ADC
    by placing 0 in SPDR. After waiting for the transmission to complete, we then
    equate another integer variable to SPDR, which now contains the rest of the ADC
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have 2 bytes of data, one containing the top 2 bits (the MSB) and
    the other containing the other 8 bits of data (the LSB), we need to convert them
    into a single value: a 16-bit integer, which we’ll call the *result* . For this,
    we bit-shift the MSB variable 8 bits to the left into the result integer, then
    use bitwise operation `|` to drop the LSB variable into the result. At last, we
    have the 10-bit value of the ADC in one integer variable, which will be between
    0 and 1,023.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the code to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we have reused all the MAX7219 functions from [Project 48](nsp-boxall502581-0021.xhtml#pro48)
    to display the ADC value in millivolts. Our main code receives an ADC value, converts
    it to millivolts, then shows it on the MAX7219 display. You should be familiar
    with the basic structure by now.
  prefs: []
  type: TYPE_NORMAL
- en: We also declare a new function, `readMCP3008()` ❶, that returns a 16-bit integer
    containing the value measured by the MCP3008’s first ADC (0). Inside the function
    we define three variables—two 8-bit integers to hold the MSB and LSB of the data
    that the ADC returns and a 16-bit integer to return the full value of the ADC
    measurement—and set the `SPCR` register for the MCP3008 ❷. We then set the SS
    pin low to start the SPI bus as usual.
  prefs: []
  type: TYPE_NORMAL
- en: After sending the start bit to activate the MCP3008 ❸, we wait for the SPI bus
    transmission to be completed, as always. Following this, we send the configuration
    byte, telling the MCP3008 we want a single-ended ADC result from channel 0\. Once
    we’ve done so, the MCP3008 returns the MSB of the result.
  prefs: []
  type: TYPE_NORMAL
- en: We store the MSB in the variable `MSB` ❹ and perform the bitwise `&` to remove
    the random unnecessary bits. Then we request the LSB of the data by sending a
    random byte (here, all 0s) ❺, wait for the transmission to end, and store the
    data in `LSB` ❻. After this, we’re finished with the MCP3008, so we remove it
    from the SPI bus by setting the SS pin high ❼.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the two bytes of data that need to be converted to a single integer
    for return as the value of this function. We do this by shifting the MSB into
    the top eight bits of the return variable `ADCvalue` and dropping in the LSB with
    the `|` function ❽.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a value from the ADC, we move on to the main loop of code,
    assigning the reading from the ADC to a 16-bit integer ❾. However, this value
    falls between 0 and 1,023, so we need to convert it to millivolts (mV). Our V
    [REF] is 5 V, or 5,000 mV. Therefore, we divide 5,000 by 1,024 to determine the
    multiplier to convert this ADC value to mV: 4.8828\. The program then converts
    the ADC value to millivolts ⓿ and sends it to the display.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point you should understand how to implement the SPI bus, including
    how to examine SPI device data sheets to locate the information required to use
    them with your AVR. You’ve also learned how to take advantage of the useful shift
    register IC, the MAX7219 display driver, and the MCP3008 ADC. This knowledge should
    prepare you to use other SPI-based parts for your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [next chapter](nsp-boxall502581-0022.xhtml#ch12) , you’ll learn how
    to use many more interesting and useful parts with another type of data bus: the
    I ² C.'
  prefs: []
  type: TYPE_NORMAL
