<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_2" aria-label="2"/>&#13;
<figure class="co-img"><img id="fig-pg2" class="img70" src="../images/pg2.jpg" alt="" width="691" height="823"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-02.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_3" aria-label="3"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch1">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">A MINIMAL COMPILER</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In this chapter, you’ll write a minimal compiler that can handle only the simplest C programs. You’ll learn how to read a simple assembly program, and you’ll implement four basic compiler passes that you’ll build on throughout the rest of the book. Let’s start by looking at these compiler passes.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-10"/><samp class="SANS_Futura_Std_Bold_B_11">The Four Compiler Passes</samp></h3>&#13;
<p class="TNI">The compiler you write in this chapter will process source code in four stages:</p>&#13;
<ol class="NL">&#13;
<li class="NL">The <i>lexer</i> breaks up the source code into a list of <i>tokens</i>. Tokens are the smallest syntactic units of a program; they include delimiters, arithmetic symbols, keywords, and identifiers. If a program is like a book, tokens are like individual words.</li>&#13;
<li class="NL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_4" aria-label="4"/>The <i>parser</i> converts the list of tokens into an <i>abstract syntax tree (AST)</i>, which represents the program in a form we can easily traverse and analyze.</li>&#13;
<li class="NL">The <i>assembly generation</i> pass converts the AST into assembly. At this stage, we still represent the assembly instructions in a data structure that the compiler can understand, not as text.</li>&#13;
<li class="NL">The <i>code emission</i> pass writes the assembly code to a file so the assembler and linker can turn it into an executable.</li>&#13;
</ol>&#13;
<p class="TX">This is a typical way of structuring a compiler, although the exact stages and intermediate representations vary. It’s also overkill for this chapter—you could compile the programs you’ll handle here in just one pass—but setting up this structure now makes it easier to expand your compiler in future chapters. As you implement more language features, you’ll extend these compiler stages and add a few new ones. Each chapter starts with a current diagram of the compiler’s architecture, including the stages you’ve already implemented and any you need to add. This chapter’s diagram shows the four stages you’re about to implement. In the diagrams for later chapters, new stages will be bolded.</p>&#13;
<p class="TX">Before you start coding, let’s take a quick look at how to compile C to assembly with the C compiler already installed on your system, and how to read assembly programs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-11"/><samp class="SANS_Futura_Std_Bold_B_11">Hello, Assembly!</samp></h3>&#13;
<p class="TNI">The simplest C program looks like <a href="chapter1.xhtml#list1-1">Listing 1-1</a>.</p>&#13;
<a id="list1-1"/>&#13;
<pre><code>int main(void) {&#13;
    return 2;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: A simple program that returns the number 2</samp></p>&#13;
<p class="TX">This program consists of a single function, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, containing a single <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, which returns an integer (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>). Save this program as <i>return_2.c</i>, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command to translate it into assembly:</p>&#13;
<pre><code>$ <b>gcc -S -O -fno-asynchronous-unwind-tables -fcf-protection=none</b> <b>return_2.c</b></code></pre>&#13;
<p class="TX">If you’re using macOS, this command may invoke Clang instead of GCC, but the command line options have the same effect. These options produce fairly readable assembly:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-S</samp> Don’t run the assembler or linker. This makes the compiler emit assembly instead of a binary file.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-O</samp> Optimize the code. This eliminates some instructions we aren’t concerned with right now.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_5" aria-label="5"/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-fno-asynchronous-unwind-tables</samp> Don’t generate the unwind table, which is used for debugging. We don’t need it.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-fcf-protection=none</samp> Disable control-flow protection, a security feature that adds extra instructions we aren’t concerned with. Control-flow protection might already be disabled by default on your system, in which case this option won’t do anything. Skip this option if you’re using an old version of GCC or Clang that doesn’t support it.</p>&#13;
<p class="TX">The result, stored in <i>return_2.s</i>, should look similar to <a href="chapter1.xhtml#list1-2">Listing 1-2</a>.</p>&#13;
<a id="list1-2"/>&#13;
<pre><code>    .globl main&#13;
main:&#13;
    movl    $2, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-2: The program from <a href="chapter1.xhtml#list1-1">Listing 1-1</a> translated into assembly</samp></p>&#13;
<p class="TX">Your <i>.s</i> file might contain a few other lines, but you can safely ignore them for now. The four lines in <a href="chapter1.xhtml#list1-2">Listing 1-2</a> are a complete assembly program. Assembly programs have several kinds of statements. The first line, <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp>, is an <i>assembler directive</i>, a statement that provides directions for the assembler. Assembler directives always start with a period. Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> is a <i>symbol</i>, a name for a memory address. Symbols appear in assembly instructions as well as assembler directives; for example, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp main</samp> jumps to whatever address the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> symbol refers to.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp> directive tells the assembler that <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> is a <i>global</i> symbol. By default, you can use a symbol only in the same assembly file (and therefore the same object file) where it’s defined. But because <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> is global, other object files can refer to it too. The assembler records this fact in a section of the object file called the <i>symbol table</i>, which the linker uses when it links object files together. The symbol table contains information about all the symbols in an object file or executable.</p>&#13;
<p class="TX">On the second line, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> as a <i>label</i> for the code that follows it. Labels consist of a string or number followed by a colon. A label marks the location that a symbol refers to. This particular label defines <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> as the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction on the following line. The assembler doesn’t know this instruction’s final memory address, but it knows what <i>section</i> of the object file it’s in, as well as its offset from the start of that section. (An object file is made up of several sections that hold various kinds of data; there are separate sections for machine instructions, global variables, debug information, and so on. Different sections are loaded into different parts of the program’s address space at runtime.) The address of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> will be in the <i>text section</i>, which contains machine instructions. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> refers to the very first machine instruction in this assembly file, its offset within the text section is 0. The assembler records this offset in the symbol table.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction on the next line is a <i>machine instruction</i>, which appears in the final executable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction in <a href="chapter1.xhtml#list1-2">Listing 1-2</a> moves the value <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> into a <i>register</i>, which is a very small and fast storage slot that has its own name and sits right on the CPU. Here, we move <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> into the register <span role="doc-pagebreak" epub:type="pagebreak" id="pg_6" aria-label="6"/>named EAX, which can hold 32 bits. According to our platform’s calling convention, return values are passed to the caller in EAX (or RAX, the 64-bit equivalent, depending on the return value’s type). Since the caller also knows about this convention, it can retrieve the return value from EAX after the function returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix in <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> indicates that the operands to this instruction are <i>longwords</i>, or 32-bit integers (in x64 assembly, unlike most modern implementations of C, <i>long</i> means 32 bits). A <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction operates on <i>quadwords</i>, or 64-bit integers. I’ll just write <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> when I want to refer to this instruction without specifying its size.</p>&#13;
<p class="TX">Finally, we have another machine instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>, which returns control to the caller. You might see <samp class="SANS_TheSansMonoCd_W5Regular_11">retq</samp> here instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>, since this instruction implicitly operates on a 64-bit return address. I’m skipping a lot of details, including what calling conventions are, who decides on them, and how <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> knows where the caller is. I’ll revisit these when we add function calls in <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>All the assembly listings in this book use AT&amp;T syntax. Elsewhere, you might see x64 assembly written in Intel syntax. They’re two different notations for the same language; the biggest difference is that they put instruction operands in different orders.</i></p>&#13;
<p class="TX">At this point, it’s fair to ask who the caller is, since <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> is the only function in this program. You might also wonder why we need the <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp> directive, since there don’t seem to be any other object files that could contain references to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. The answer is that the linker adds a bit of wrapper code called <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp> to handle setup before <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> runs and teardown after it exits. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">crt</samp> stands for <i>C Runtime</i>.) This wrapper code does the following:</p>&#13;
<ol class="NL">&#13;
<li class="NL">Makes a function call to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. This is why <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> needs to be globally visible; if it isn’t, <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp> can’t call it.</li>&#13;
<li class="NL">Retrieves the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.</li>&#13;
<li class="NL">Invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> system call, passing it the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> handles whatever work needs to happen inside the operating system to terminate the process and turn the return value into an exit code.</li>&#13;
</ol>&#13;
<p class="TX">The bottom line is that you don’t need to worry about process startup or teardown; you can treat <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> like a normal function.</p>&#13;
<p class="TX">The linker also associates each entry in the symbol table with a memory address through a process called <i>symbol resolution</i>. It then performs <i>relocation</i>, updating every place that uses a symbol to use the corresponding address instead. (Actually, the linking process is a lot more complicated than this! If you’d like to learn more, see <span class="Xref">“Additional Resources” on <a href="#pg_21">page 21</a></span>.)</p>&#13;
<p class="TX">To verify that the assembly in <i>return_2.s</i> works, assemble and link it, run it, and check the exit code with the <samp class="SANS_TheSansMonoCd_W5Regular_11">$?</samp> shell operator:</p>&#13;
<pre><code>$ <b>gcc return_2.s -o return_2</b>&#13;
$ <b>./return_2</b>&#13;
$ <b>echo $?</b>&#13;
2</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_7" aria-label="7"/>Note that you can pass an assembly file to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command just like a regular source file. It assumes any input files with a <i>.s</i> extension contain assembly, so it assembles and links those files without trying to compile them first.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-12"/><samp class="SANS_Futura_Std_Bold_B_11">The Compiler Driver</samp></h3>&#13;
<p class="TNI">As you learned in the <span class="Xref-1"><a href="introduction.xhtml">Introduction</a></span>, a compiler isn’t very useful on its own. You also need a <i>compiler driver</i> that calls the preprocessor, compiler, assembler, and linker. So, you’ll write a compiler driver before starting on the compiler itself. It should convert a source file to an executable in three steps:</p>&#13;
<p class="NL1">1. Run this command to preprocess the source file:</p>&#13;
<pre><code><b>gcc -E -P</b> <b><var>INPUT_FILE</var></b> <b>-o</b> <b><var>PREPROCESSED_FILE</var></b></code></pre>&#13;
<p class="ListContinued">This command preprocesses <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">INPUT_FILE</samp> and then writes the result to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-E</samp> option tells GCC to run only the preprocessor, not the later steps of the compilation process. By default, the preprocessor emits <i>linemarkers</i> indicating the original source file, and the starting line number within that source file, for each part of the preprocessed output. (A preprocessed file might include code from multiple source files because of <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directives.) The <samp class="SANS_TheSansMonoCd_W5Regular_11">-P</samp> option tells the preprocessor not to emit linemarkers; our lexer and parser won’t be able to process them. By convention, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp> should have a <i>.i</i> file extension.</p>&#13;
<p class="NL1">2. Compile the preprocessed source file and output an assembly file with a <i>.s</i> extension. You’ll have to stub out this step, since you haven’t written your compiler yet. Delete the preprocessed file when you’re done with it.</p>&#13;
<p class="NL1">3. Assemble and link the assembly file to produce an executable, using this command:</p>&#13;
<pre><code><b>gcc</b> <b><var>ASSEMBLY_FILE</var></b> <b>-o</b> <b><var>OUTPUT_FILE</var></b></code></pre>&#13;
<p class="ListContinued">Delete the assembly file when you’re done with it.</p>&#13;
<p class="TX">Your compiler driver must have a specific command line interface so this book’s test script, <i>test_compiler</i>, can run it. It must be a command line program that accepts a path to a C source file as its only argument. If this command succeeds, it must produce an executable in the same directory as the input file, with the same name (minus the file extension). In other words, if you run <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER /path/to/program.c</samp>, it should produce an executable at <i>/path/to/program</i> and terminate with an exit code of 0. If your compiler fails, the compiler driver should return a nonzero exit code and shouldn’t write any assembly or executable files; that’s how <i>test_compiler</i> verifies that your compiler catches errors in invalid programs. Finally, your <span role="doc-pagebreak" epub:type="pagebreak" id="pg_8" aria-label="8"/>compiler driver should support the following options, which <i>test_compiler</i> uses to test intermediate stages:</p>&#13;
<table class="Basic-Table-ind">&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">--lex</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">Directs it to run the lexer, but stop before parsing</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">--parse</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">Directs it to run the lexer and parser, but stop before assembly generation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">--codegen</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">Directs it to perform lexing, parsing, and assembly generation, but stop before code emission</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">None of these options should produce any output files, and all should terminate with an exit code of 0 if they don’t hit any errors. You might also want to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">-S</samp> option that directs your compiler to emit an assembly file, but not assemble or link it. You’ll need this option to run the tests in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>; it isn’t required for <span class="Xref-1"><a href="part1.xhtml">Parts I</a></span> and <span class="Xref-1"><a href="part2.xhtml">II</a></span>, but it’s useful for debugging.</p>&#13;
<p class="TX">Once you’ve written the compiler driver, you’re ready to start working on the actual compiler. You need to implement the four compiler passes listed at the beginning of the chapter: the lexer, which produces a list of tokens; the parser, which turns those tokens into an abstract syntax tree; the assembly generation pass, which converts the abstract syntax tree into assembly; and the code emission pass, which writes that assembly to a file. Let’s start with the lexer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h1-13"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">The lexer should read in a source file and produce a list of tokens. Before you can start writing the lexer, you need to know what tokens you might encounter. Here are all the tokens in <a href="chapter1.xhtml#list1-1">Listing 1-1</a>:</p>&#13;
<table class="Basic-Table-ind">&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A keyword</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">main</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">An identifier, whose value is “main”</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">(</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">An open parenthesis</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">void</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A keyword</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A close parenthesis</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">{</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">An open brace</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">return</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A keyword</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">2</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A constant, whose value is “2”</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">;</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A semicolon</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">}</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A close brace</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">I’ve used two lexer-specific terms here. An <i>identifier</i> is an ASCII letter or underscore followed by a mix of letters, underscores, and digits. Identifiers are case sensitive. An integer <i>constant</i> consists of one or more digits. (We’ll add character and floating-point constants in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. We won’t implement hexadecimal or octal integer constants in this book.)</p>&#13;
<p class="TX">Note that the identifier and constant in this list of tokens have values, but the other types of tokens don’t. There are many possible identifiers <span role="doc-pagebreak" epub:type="pagebreak" id="pg_9" aria-label="9"/>(for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">variable1</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">my_cool_function</samp>), so each identifier token produced by the lexer must retain its specific name. Likewise, each constant token needs to hold an integer value. By contrast, there’s only one possible <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword, so a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword token doesn’t need to store any extra information. Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> is the only identifier right now, you should build the lexer to support arbitrary identifiers later on. Also note that there are no whitespace tokens. If we were compiling a language like Python, where whitespace is significant, we’d need to include whitespace tokens.</p>&#13;
<p class="TX">You can recognize each token type with a regular expression, or regex. <a href="chapter1.xhtml#tab1-1">Table 1-1</a> gives the corresponding regular expression for each token in Perl Compatible Regular Expressions (PCRE) syntax.</p>&#13;
<p class="TT" id="tab1-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Tokens and Their Regular Expressions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Token</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Regular expression</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">Identifier</samp></p></td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">[a-zA-Z_]\w*\b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">Constant</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+\b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">keyword</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int\b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">keyword</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">void\b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> <samp class="SANS_Futura_Std_Book_11">keyword</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">return\b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">Open parenthesis</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\(</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">Close parenthesis</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">Open brace</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">Close brace</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">Semicolon</samp></p></td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The process of tokenizing a program looks roughly like <a href="chapter1.xhtml#list1-3">Listing 1-3</a>.</p>&#13;
<a id="list1-3"/>&#13;
<pre><code>while input isn't empty:&#13;
    if input starts with whitespace:&#13;
        trim whitespace from start of input&#13;
    else:&#13;
        find longest match at start of input for any regex in <a href="chapter1.xhtml#tab1-1">Table 1-1</a>&#13;
        if no match is found, raise an error&#13;
        convert matching substring into a token&#13;
        remove matching substring from start of input</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3: Converting a string to a sequence of tokens</samp></p>&#13;
<p class="TX">Note that identifiers, keywords, and constants must end at word boundaries, indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>. For example, the first three digits of <samp class="SANS_TheSansMonoCd_W5Regular_11">123;bar</samp> match the regular expression for a constant, and you should convert them into the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">123</samp>. This is because <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> isn’t in the <samp class="SANS_TheSansMonoCd_W5Regular_11">\w</samp> character class, so the boundary between <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> is a word boundary. However, the first three digits of <samp class="SANS_TheSansMonoCd_W5Regular_11">123bar</samp> don’t match the regular expression for a constant, because those digits are followed by more characters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">\w</samp> character class instead of a word boundary. If your lexer sees a string like <samp class="SANS_TheSansMonoCd_W5Regular_11">123bar</samp>, it should raise an error, as the start of the string doesn’t match the regular expression for any token.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_10" aria-label="10"/>Now you’re ready to write your lexer. Here are a few tips to keep in mind:</p>&#13;
<p class="ListHead"><b>Treat keywords like other identifiers.</b></p>&#13;
<p class="ListPlainFirst">The regex for identifiers also matches keywords. Don’t try to simultaneously find the end of the next token and figure out whether it’s a keyword. First, find the end of the token. Then, if it looks like an identifier, check whether it matches any keywords.</p>&#13;
<p class="ListHead"><b>Don’t split on whitespace.</b></p>&#13;
<p class="ListPlainFirst">It isn’t a good idea to start by splitting the string on whitespace, since whitespace isn’t the only boundary between tokens. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">main(void)</samp> has four tokens and no whitespace.</p>&#13;
<p class="ListHead"><b>You only need to support ASCII characters.</b></p>&#13;
<p class="ListPlainFirst">The test programs for this book contain only ASCII characters. The C standard provides a mechanism called <i>universal character names</i> to include non-ASCII characters in identifiers, but we won’t implement them. Many C implementations let you use Unicode characters directly, but you don’t need to support that either.</p>&#13;
<p class="TX-TOP">Once you’ve written your lexer, the next step is testing it.</p>&#13;
<aside class="box" aria-label="box-1"><p class="BoxTitle" id="box-1"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You’ll test your lexer against all the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_1</samp><samp class="SANS_Futura_Std_Book_11">. The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_1/invalid_lex</samp> <samp class="SANS_Futura_Std_Book_11">contain invalid tokens, so they should cause the lexer to fail with an appropriate error message. The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_1/invalid_parse</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_1/valid</samp> <samp class="SANS_Futura_Std_Book_11">contain only valid tokens, so the lexer should process them successfully. Use the following command to test that your lexer fails on the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_1/invalid_lex</samp> <samp class="SANS_Futura_Std_Book_11">and succeeds on everything else:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 1 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This command tests whether the lexer succeeds or fails, but it doesn’t look at what tokens the lexer produces. Consider writing your own tests to validate that it produces the correct list of tokens for valid programs and emits an appropriate error message for invalid ones.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-14"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">Now that you have a list of tokens, you’ll figure out how those tokens are grouped together into language constructs. In most programming languages, including C, this grouping is hierarchical: each language construct <span role="doc-pagebreak" epub:type="pagebreak" id="pg_11" aria-label="11"/>in the program is composed of several simpler constructs. Individual tokens represent the most basic constructs, like variables, constants, and arithmetic operators. Tree data structures are a natural way to express this hierarchical relationship. As I mentioned at the start of this chapter, the parser will accept the list of tokens produced by the lexer and generate a tree representation called an abstract syntax tree. After the parser has created the AST, the assembly generation stage will traverse it to figure out what assembly code to emit.</p>&#13;
<p class="TX">There are two approaches to writing a parser: you can write it by hand, or you can use a <i>parser generator</i> like Bison or ANTLR to produce your parsing code automatically. Using a parser generator is less work, but this book uses a handwritten parser. There are a few reasons for this. Most importantly, handwriting a parser provides you with a solid understanding of how your parser works. It’s easy to use a parser generator without fully understanding the code it produces. Many parser generators also have a steep learning curve, and you’re better off learning general techniques like recursive descent parsing <i>before</i> you spend time mastering specific tools.</p>&#13;
<p class="TX">Handwritten parsers also have some practical advantages over those produced by parser generators: they can be faster and easier to debug, they’re more flexible, and they provide better support for error handling. In fact, both GCC and Clang use handwritten parsers, which shows that writing a parser by hand isn’t just an academic exercise.</p>&#13;
<p class="TX">That said, if you’d rather use a parser generator, that’s fine too. It all depends on what you’re hoping to get out of this book. Note, however, that I won’t talk about how to use those tools, so you’ll have to figure that out on your own. If you go that route, make sure to research what parsing libraries are available in your implementation language of choice.</p>&#13;
<p class="TX">Whichever option you choose, you’ll need to design the abstract syntax tree your parser should produce. Let’s start by taking a look at an example of an AST.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-7"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example Abstract Syntax Tree</samp></h4>&#13;
<p class="TNI">Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement in <a href="chapter1.xhtml#list1-4">Listing 1-4</a>.</p>&#13;
<a id="list1-4"/>&#13;
<pre><code>if (a &lt; b) {&#13;
    return 2 + 2;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-4: A simple</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp></p>&#13;
<p class="TX">The root node of the corresponding AST represents the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. This node has two children:</p>&#13;
<ol class="NL">&#13;
<li class="NL">The condition, <samp class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b</samp></li>&#13;
<li class="NL">The statement body, <samp class="SANS_TheSansMonoCd_W5Regular_11">return 2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2;</samp></li>&#13;
</ol>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_12" aria-label="12"/>Each of these constructs can be broken down further. For example, the condition is a binary operation with three children:</p>&#13;
<ol class="NL">&#13;
<li class="NL">The left operand, variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp></li>&#13;
<li class="NL">The operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp></li>&#13;
<li class="NL">The right operand, variable <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp></li>&#13;
</ol>&#13;
<p class="TX"><a href="#fig1-1">Figure 1-1</a> shows the whole AST for this code snippet, with an <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp> AST node representing the root of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> node representing the condition, and so on.</p>&#13;
<figure class="IMG"><img id="fig1-1" class="img100" src="../images/fig1-1.jpg" alt="" width="1668" height="980"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: An AST for a simple if statement <a href="description-03.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The AST in <a href="#fig1-1">Figure 1-1</a> contains the same information as <a href="chapter1.xhtml#list1-4">Listing 1-4</a>: it shows what actions the program will take, and in what order. But unlike <a href="chapter1.xhtml#list1-4">Listing 1-4</a>, this AST presents that information in a way your compiler can easily work with. In later stages, the compiler will traverse the tree, performing a different action at each type of node it encounters. Your compiler will use this general strategy to accomplish a bunch of different tasks, from resolving variable names to generating assembly.</p>&#13;
<p class="TX">Now let’s look at the AST for the C program from <a href="chapter1.xhtml#list1-1">Listing 1-1</a>. <a href="#fig1-2">Figure 1-2</a> shows this much simpler AST.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_13" aria-label="13"/>&#13;
<figure class="IMG"><img id="fig1-2" class="img50" src="../images/fig1-2.jpg" alt="" width="556" height="809"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: The AST for <a href="chapter1.xhtml#list1-1">Listing 1-1</a> <a href="description-04.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Next, you’ll define the necessary data structures to construct ASTs like <a href="#fig1-2">Figure 1-2</a> in code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-8"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The AST Definition</samp></h4>&#13;
<p class="TNI">This book gives AST descriptions in a language designed for specifying ASTs, the <i>Zephyr Abstract Syntax Description Language (ASDL)</i>. I’m using ASDL here as convenient, programming language–neutral notation. You won’t use ASDL directly in your compiler; instead, you’ll define equivalent data structures in your chosen implementation language. The next few paragraphs include a very brief overview of ASDL. You can find a link to the original paper, which describes the whole language, in <span class="Xref">“Additional Resources” on <a href="#pg_21">page 21</a></span>.</p>&#13;
<p class="TX"><a href="chapter1.xhtml#list1-5">Listing 1-5</a> has the ASDL definition for the tiny subset of C you’ll implement in this chapter (programs like <a href="chapter1.xhtml#list1-1">Listing 1-1</a>).</p>&#13;
<a id="list1-5"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier name, statement body)&#13;
statement = Return(exp)&#13;
exp = Constant(int)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-5: The abstract syntax tree definition for this chapter</samp></p>&#13;
<p class="TX">Each line in <a href="chapter1.xhtml#list1-5">Listing 1-5</a> describes how to build one type of AST node. Note that every AST node in <a href="#fig1-2">Figure 1-2</a> has a corresponding definition in ASDL. The root of this AST is the <samp class="SANS_TheSansMonoCd_W5Regular_11">program</samp> node. At the moment, this node can have exactly one child, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>. A function definition has two children: a function name, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp>, and a function body, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>. Right now, a function consists of a single statement and has no arguments. Later, you’ll add support for function arguments and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_14" aria-label="14"/>more complex function bodies. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp> in this definition are <i>field names</i>, human-friendly labels that don’t change the structure of the AST. Field names are optional in ASDL. When a field name is present, it comes immediately after the field type, like in <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier name</samp>.</p>&#13;
<p class="TX">In ASDL, <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp> is a built-in type that represents function and variable names; they’re basically strings, but we want to distinguish them from string literals like <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello, World!"</samp> because they appear in different parts of an AST. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp> is a built-in type, it has no children. The other child of the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp> node is <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>. Right now, the only kind of statement is a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. This statement has one child: its return value, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>, short for <i>expression</i>. The only <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> at the moment is a constant integer; <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is another built-in ASDL type, so the AST is finished.</p>&#13;
<p class="TX">Of course, <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements aren’t the only statements in C, and constants aren’t the only expressions. In later chapters, we’ll add new constructors to represent the other kinds of statements and expressions. For example, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp> constructor to <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements:</p>&#13;
<pre><code>statement = Return(exp) | If(exp condition, statement then, statement? else)</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">statement?</samp> type indicates an optional statement, since <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements don’t always have an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause. The <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> symbol separates constructors. Here, it tells us that a <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> can be either a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> constructor, or an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp> constructor.</p>&#13;
<p class="TX">Now it’s your turn to implement the AST definition in <a href="chapter1.xhtml#list1-5">Listing 1-5</a> in whatever language you’re using to write your compiler. The standard way to represent ASTs varies between programming languages. If you’re implementing your compiler in a functional language like F#, ML, or Haskell, you can define the AST using algebraic data types. Enums in Rust are basically algebraic data types, so they can also represent ASTs. If you’re using an object-oriented language like Java, you can define an abstract class for each type of node, then define classes that extend or inherit from those abstract classes for each constructor. For example, you might define an <samp class="SANS_TheSansMonoCd_W5Regular_11">Exp</samp> abstract class and <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">BinaryExp</samp> classes that extend it.</p>&#13;
<p class="TX">If you’re still not sure how to write an AST definition, check out <span class="Xref">“Additional Resources” on <a href="#pg_21">page 21</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-9"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Formal Grammar</samp></h4>&#13;
<p class="TNI">An AST has all the information you’ll need in later stages of the compiler. It does not, however, tell you exactly what tokens make up each language construct. For example, nothing in the AST description in <a href="chapter1.xhtml#list1-5">Listing 1-5</a> says that a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement must end with a semicolon or that a function body needs to be enclosed in braces. (This is why it’s called an <i>abstract</i> syntax tree—by contrast, a <i>concrete</i> syntax tree includes every token from the original input.) Once you have an AST, those specific details are irrelevant, so it’s convenient to leave them out. When you’re parsing a sequence of tokens to construct your AST, though, those details matter a lot because they indicate where each language construct begins and ends.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_15" aria-label="15"/>So, in addition to an AST description, you need a set of rules defining how to build a language construct from a list of tokens. This ruleset is called a <i>formal grammar</i>, and it corresponds closely to the AST description. <a href="chapter1.xhtml#list1-6">Listing 1-6</a> defines the formal grammar for C programs like <a href="chapter1.xhtml#list1-1">Listing 1-1</a>.</p>&#13;
<a id="list1-6"/>&#13;
<pre><code>&lt;program&gt; ::= &lt;function&gt;&#13;
&lt;function&gt; ::= "int" &lt;identifier&gt; "(" "void" ")" "{" &lt;statement&gt; "}"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
&lt;exp&gt; ::= &lt;int&gt;&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? A constant token ?</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-6: The formal grammar for this chapter</samp></p>&#13;
<p class="TX">The grammar in <a href="chapter1.xhtml#list1-6">Listing 1-6</a> is in <i>extended Backus-Naur form (EBNF)</i> notation. Each line of this grammar is a <i>production rule</i> that defines how a language construct can be formed from a sequence of other language constructs and tokens. Every symbol that appears on the left-hand side of a production rule (like <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;function&gt;</samp>) is a <i>non-terminal symbol</i>. Individual tokens, like keywords, identifiers, and punctuation, are <i>terminal symbols</i>. All non-terminal symbols are wrapped in angle brackets, and specific tokens (like <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>) are wrapped in quotation marks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;identifier&gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;int&gt;</samp> symbols represent individual identifier and constant tokens, respectively. Since these tokens aren’t fixed strings like the other terminal symbols, we describe each of them using a <i>special sequence</i>: a plain English description of the symbol, wrapped in question marks.</p>&#13;
<p class="TX"><a href="chapter1.xhtml#list1-6">Listing 1-6</a> looks a lot like the AST definition in <a href="chapter1.xhtml#list1-5">Listing 1-5</a>. In fact, it has the same structure; every AST node in <a href="chapter1.xhtml#list1-5">Listing 1-5</a> corresponds to a non-terminal symbol in <a href="chapter1.xhtml#list1-6">Listing 1-6</a>. The only difference is that <a href="chapter1.xhtml#list1-6">Listing 1-6</a> specifies exactly which tokens we’ll find at each node of the tree, which helps us figure out when we need to start processing a new node at the next level down in the AST, and when we’ve finished processing a node and can go back up to its parent on the level above.</p>&#13;
<p class="TX">Just as later chapters will introduce multiple constructors for some AST nodes, they’ll also introduce multiple production rules for the corresponding symbols. For example, here’s how you’ll add a production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;statement&gt;</samp> to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements:</p>&#13;
<pre><code>&lt;statement&gt; ::= "return" &lt;exp&gt; ";" | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]</code></pre>&#13;
<p class="TX">Note that square brackets in EBNF indicate that something is optional, just like question marks in ASDL.</p>&#13;
<p class="TX">You’ll refer to this formal grammar while writing the parser, but you won’t explicitly define these grammar rules anywhere in your compiler.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-10"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Recursive Descent Parsing</samp></h4>&#13;
<p class="TNI">Now that you have an AST definition and a formal grammar, let’s talk about how to actually write the parser. We’ll use a straightforward technique called <i>recursive descent parsing</i>, which uses a different function to parse each <span role="doc-pagebreak" epub:type="pagebreak" id="pg_16" aria-label="16"/>non-terminal symbol and return the corresponding AST node. For example, when the parser expects to encounter the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;statement&gt;</samp> symbol defined in <a href="chapter1.xhtml#list1-6">Listing 1-6</a>, it calls a function to parse that symbol and return the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> AST node from <a href="chapter1.xhtml#list1-5">Listing 1-5</a>. The main parsing function parses the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;program&gt;</samp> symbol, which corresponds to the entire program. With each function call to handle a new symbol, the parser descends to a lower level in the tree. That’s where the <i>descent</i> in recursive descent comes from. (It’s called <i>recursive</i> descent because the grammar rules are often recursive, in which case the functions to process them are too. For example, the operand of an expression could be another expression; we’ll see an example of this in the next chapter.)</p>&#13;
<p class="TX">Let’s walk through one of these parsing functions. The pseudocode in <a href="chapter1.xhtml#list1-7">Listing 1-7</a> demonstrates how to parse a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;statement&gt;</samp> symbol.</p>&#13;
<a id="list1-7"/>&#13;
<pre><code>parse_statement(tokens):&#13;
    expect("return", tokens)&#13;
    return_val = parse_exp(tokens)&#13;
    expect(";", tokens)&#13;
    return Return(return_val)&#13;
&#13;
expect(expected, tokens):&#13;
    actual = take_token(tokens)&#13;
    if actual != expected:&#13;
        fail("Syntax error")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-7: Parsing a statement</samp></p>&#13;
<p class="TX">We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp> function when we expect the list of remaining tokens to start with a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;statement&gt;</samp>. According to <a href="chapter1.xhtml#list1-6">Listing 1-6</a>, a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;statement&gt;</samp> consists of three symbols: the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword, an <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> symbol, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> token. First, we call a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>, to verify that the first token really is a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword. If it is, <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp> discards it so we can move on to the next token. If it isn’t, we report a syntax error in the program. Next, we need to turn the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> symbol into an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node. Since this is a different non-terminal symbol, it should be handled by a separate function, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>, which I haven’t defined here. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> to get the AST node representing the return value; then we call <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp> again to verify that this expression is followed by the last token, a semicolon. Finally, we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> AST node and return it.</p>&#13;
<p class="TX">Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp> removes all the tokens that made up the statement from the <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp> list. After <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp> returns, its caller keeps processing the remaining tokens in <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>. If there are any tokens left after parsing the entire program, that’s a syntax error.</p>&#13;
<p class="TX">Right now, each symbol in the formal grammar has only one production rule. In later chapters, when some symbols have multiple production rules, the parser will need to figure out which production rule to use. It will do this by looking at the first few tokens in the list without removing them. Recursive descent parsers that look ahead a few tokens to figure out which production rule to use are called <i>predictive parsers.</i> The alternative to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label="17"/>predictive parsing is <i>recursive descent with backtracking</i>, which involves trying each production rule in turn until you find one that works.</p>&#13;
<p class="TX">Now you can write your own recursive descent parser. Remember that you’ll need to write one function to parse each non-terminal symbol in <a href="chapter1.xhtml#list1-6">Listing 1-6</a>. Here are a few tips to make it easier:</p>&#13;
<p class="ListHead"><b>Write a pretty-printer.</b></p>&#13;
<p class="ListPlainFirst">A pretty-printer is a function that prints out your AST in a human-readable way. This will make debugging your parser a lot easier. A pretty-printed AST for the program in <a href="chapter1.xhtml#list1-1">Listing 1-1</a> might look like this:</p>&#13;
<pre><code>Program(&#13;
    Function(&#13;
        name="main",&#13;
        body=Return(&#13;
          Constant(2)&#13;
        )&#13;
    )&#13;
)</code></pre>&#13;
<p class="ListHead"><b>Give informative error messages.</b></p>&#13;
<p class="ListPlainFirst">This will also help you debug your parser, and it will make your compiler more user-friendly too. An error message like <samp class="SANS_TheSansMonoCd_W5Regular_11">Expected ";" but found "return"</samp> is a lot more helpful than <samp class="SANS_TheSansMonoCd_W5Regular_11">Fail</samp>.</p>&#13;
<aside class="box" aria-label="box-2"><p class="BoxTitle" id="box-2"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Your parser should fail on the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_1/invalid_parse</samp> <samp class="SANS_Futura_Std_Book_11">and succeed on the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_1/valid.</samp> <samp class="SANS_Futura_Std_Book_11">To test the parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 1 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This command tests only whether the parser succeeds or fails, so you may want to write your own tests to confirm that it produces the correct AST for valid programs and emits an appropriate error for invalid ones.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-15"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">The assembly generation stage should convert the AST into x64 assembly, traversing the AST in roughly the order the program executes to produce the appropriate assembly instructions for each node. First, define an appropriate data structure to represent the assembly program, just like you defined a data structure to represent the AST when you wrote the parser. You’re <span role="doc-pagebreak" epub:type="pagebreak" id="pg_18" aria-label="18"/>adding yet another data structure, instead of writing assembly to a file right away, so that you can modify the assembly code after you’ve generated it. You won’t need to rewrite any assembly in this chapter, but in later chapters you will.</p>&#13;
<p class="TX">I’ll use ASDL again to describe the structure we’ll use to represent assembly. <a href="chapter1.xhtml#list1-8">Listing 1-8</a> has the definition.</p>&#13;
<a id="list1-8"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier name, instruction* instructions)&#13;
instruction = Mov(operand src, operand dst) | Ret&#13;
operand = Imm(int) | Register</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-8: The ASDL definition of an assembly program</samp></p>&#13;
<p class="TX">This looks a lot like the AST definition from the last section! In fact, this <i>is</i> an AST definition, but for assembly programs, not C programs. Every node corresponds to a construct in assembly, like a single instruction, rather than a construct in C, like a statement. I’ll refer to the data structure defined in <a href="chapter1.xhtml#list1-8">Listing 1-8</a> as the <i>assembly AST</i> to distinguish it from the AST defined in <a href="chapter1.xhtml#list1-5">Listing 1-5</a>.</p>&#13;
<p class="TX">Let’s walk through <a href="chapter1.xhtml#list1-8">Listing 1-8</a>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">program</samp> type represents a whole assembly program, which consists of a single <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>. A <samp class="SANS_TheSansMonoCd_W5Regular_11">function _definition</samp> has two fields: the function name and a list of instructions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction*</samp> indicates that this field is a list. The <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp> type has two constructors to represent the two instructions that can appear in our assembly programs: <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction has two operands: it copies the first operand, the source, to the second operand, the destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> instruction doesn’t have any operands. The <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp> type defines the two possible operands to an instruction: a register and an <i>immediate value</i>, or constant. For now, you don’t need to specify which register to operate on, because your generated code will use only EAX. You’ll refer to other registers in later chapters. This stage has a similar structure to the parser: you need a function to handle each type of AST node, which calls other functions to handle that node’s children. <a href="chapter1.xhtml#tab1-2">Table 1-2</a> describes the assembly you should generate for each AST node.</p>&#13;
<p class="TT" id="tab1-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting AST Nodes to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">AST node</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp></p></td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, body)</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(exp)</samp></p></td>&#13;
<td class="Basic-Table TB">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(exp, Register) Ret</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp></p></td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">This translation is pretty straightforward, but there are a couple of things to note. The first is that a single statement results in multiple assembly instructions. The second is that this translation works only if an expression can be represented as a single assembly operand. This is true right <span role="doc-pagebreak" epub:type="pagebreak" id="pg_19" aria-label="19"/>now because the only expression is a constant integer, but it won’t be once we add unary operators in the next chapter. At that point, your compiler will need to generate multiple instructions to calculate an expression and then figure out where that expression is stored in order to copy it into EAX.</p>&#13;
<aside class="box" aria-label="box-3"><p class="BoxTitle" id="box-3"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the assembly generation stage, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 1 --stage codegen</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This command tests that the assembly generation stage can handle every valid program without crashing. It also tests that your compiler rejects each invalid program, although you already confirmed that when you tested the lexer and parser.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h1-16"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">Now that your compiler can generate assembly instructions, the last step is writing those instructions to a file. This file will look a lot like the assembly program in <a href="chapter1.xhtml#list1-2">Listing 1-2</a>, but a couple of details vary by platform. First, if you’re on macOS, you should always add an underscore in front of the function name. For example, emit the label for the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function as <samp class="SANS_TheSansMonoCd_W5Regular_11">_main</samp>. (Don’t add this underscore on Linux.)</p>&#13;
<p class="TX">Second, if you’re on Linux, you’ll need to add this line to the end of the file:</p>&#13;
<pre><code>    .section .note.GNU-stack,"",@progbits</code></pre>&#13;
<p class="TX">This line enables an important security hardening measure: it indicates that your code doesn’t need an <i>executable stack</i>. A region of memory is <i>executable</i> if the processor is permitted to execute machine instructions stored there. The <i>stack</i>, which you’ll learn more about in the next chapter, is a memory region that holds local variables and temporary values. It does not, under normal circumstances, hold machine instructions. Making the stack non-executable is a basic defense against certain security exploits, but this defense can’t be enabled for every program, because a few programs that use certain nonstandard language extensions actually need an executable stack. Including this line in an assembly file signals that it does <i>not</i> require an executable stack, which allows this security measure to be enabled. None of the code we generate in this book will require an executable stack, so we’ll always emit this line. (For more about executable stacks, see <span class="Xref">“Additional Resources” on <a href="#pg_21">page 21</a></span>.)</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_20" aria-label="20"/>The code emission stage should traverse the assembly AST and print each construct it encounters, much like the assembly generation stage traverses the AST from <a href="chapter1.xhtml#list1-5">Listing 1-5</a>. Because the assembly AST corresponds so closely to the final assembly program, the code emission stage will be very simple, even as you add more functionality to the compiler in later chapters.</p>&#13;
<p class="TX"><a href="chapter1.xhtml#tab1-3">Tables 1-3</a>, <a href="chapter1.xhtml#tab1-4">1-4</a>, and <a href="chapter1.xhtml#tab1-5">1-5</a> illustrate how to print each assembly construct.</p>&#13;
<p class="TT" id="tab1-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 1-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Top-Level Assembly Constructs</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp></p></td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_Futura_Std_Book_11">Print out the function definition.<br/>On Linux, add at end of file:</samp></p>&#13;
<pre class="table"><code>   .section .note.GNU-stack,"",@progbits</code></pre>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp></p></td>&#13;
<td class="Basic-Table TBL">&#13;
<pre class="table"><code>   .globl <var>&lt;name&gt;&#13;
&lt;name&gt;</var>:&#13;
    <var>&lt;instructions&gt;</var></code></pre>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab1-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 1-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst&gt;</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp></p></td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab1-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 1-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp></p></td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp></p></td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Make sure to include line breaks between instructions. You should also emit readable, well-formatted assembly code because you’ll spend a lot of time reading this assembly while you debug your compiler. You can make your assembly more readable by indenting every line except for labels, like in <a href="chapter1.xhtml#list1-2">Listing 1-2</a>. Consider including comments in your assembly programs too. A <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp> symbol in assembly comments out the rest of the line, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp> in C.</p>&#13;
<p class="TX">Once you’ve implemented the code emission stage, you’ll be able to compile simple programs like <a href="chapter1.xhtml#list1-1">Listing 1-1</a> into working executables.</p>&#13;
<aside class="box" aria-label="box-4"><p class="BoxTitle" id="box-4"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 1</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_21" aria-label="21"/><samp class="SANS_Futura_Std_Book_11">This compiles each program in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_1/valid</samp><samp class="SANS_Futura_Std_Book_11">, runs the resulting executable, and verifies that it produces the right exit code. It also validates that your compiler rejects each invalid test program, as it did for earlier stages.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-17"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you wrote a compiler that transforms a complete C program into an executable that runs on your computer. You learned how to interpret a program written in x64 assembly, a formal grammar in extended Backus-Naur form, and an AST definition in ASDL. The skills and concepts you learned in this chapter—and the four compiler stages you implemented—are the foundation for everything you’ll do in the rest of the book.</p>&#13;
<p class="TX">In the next chapter, you’ll add support for unary operators to your compiler. Along the way, you’ll learn how assembly programs manage the stack, and you’ll implement a new intermediate representation of the programs you compile to make them easier to analyze, transform, and optimize.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h1-18"/><samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp></h3>&#13;
<p class="TNI">To learn more about a few of the concepts introduced in this chapter, check out the following resources.</p>&#13;
<p class="ListHead"><b>Linkers</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">“Beginner’s Guide to Linkers” by David Drysdale is a good starting point (<i><a href="https://www.lurklurk.org/linkers/linkers.html">https://<wbr/>www<wbr/>.lurklurk<wbr/>.org<wbr/>/linkers<wbr/>/linkers<wbr/>.html</a></i>).</li>&#13;
<li class="ListBullet">Ian Lance Taylor’s 20-part essay on linkers goes into a lot more depth. The first post is at <i><a href="https://www.airs.com/blog/archives/38">https://<wbr/>www<wbr/>.airs<wbr/>.com<wbr/>/blog<wbr/>/archives<wbr/>/38</a></i>, and there’s a table of contents at <i><a href="https://lwn.net/Articles/276782/">https://<wbr/>lwn<wbr/>.net<wbr/>/Articles<wbr/>/276782<wbr/>/</a></i>.</li>&#13;
<li class="ListBullet">“Position Independent Code (PIC) in Shared Libraries,” a blog post by Eli Bendersky, provides an overview of how compilers, linkers, and assemblers work together to produce position-independent code, focusing on 32-bit machines (<i><a href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries">https://<wbr/>eli<wbr/>.thegreenplace<wbr/>.net<wbr/>/2011<wbr/>/11<wbr/>/03<wbr/>/position<wbr/>-independent<wbr/>-code<wbr/>-pic<wbr/>-in<wbr/>-shared<wbr/>-libraries</a></i>).</li>&#13;
<li class="ListBullet">“Position Independent Code (PIC) in Shared Libraries on x64,” also by Eli Bendersky, builds on the previous article, focusing on 64-bit systems (<i><a href="https://eli.thegreenplace.net/2011/11/11/position-independent-code-pic-in-shared-libraries-on-x64">https://<wbr/>eli<wbr/>.thegreenplace<wbr/>.net<wbr/>/2011<wbr/>/11<wbr/>/11<wbr/>/position<wbr/>-independent<wbr/>-code<wbr/>-pic<wbr/>-in<wbr/>-shared<wbr/>-libraries<wbr/>-on<wbr/>-x64</a></i>).</li>&#13;
</ul>&#13;
<p class="ListHead"><b>AST definitions</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">“Abstract Syntax Tree Implementation Idioms” by Joel Jones provides a good overview of how to implement ASTs in various programming languages (<i><a href="https://hillside.net/plop/plop2003/Papers/Jones-ImplementingASTs.pdf">https://<wbr/>hillside<wbr/>.net<wbr/>/plop<wbr/>/plop2003<wbr/>/Papers<wbr/>/Jones<wbr/>-ImplementingASTs<wbr/>.pdf</a></i>).</li>&#13;
<li class="ListBullet"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_22" aria-label="22"/>“The Zephyr Abstract Syntax Description Language” by Daniel Wang, Andrew Appel, Jeff Korn, and Christopher Serra is the original paper on ASDL. It includes examples of AST definitions in a few different languages (<i><a href="https://www.cs.princeton.edu/~appel/papers/asdl97.pdf">https://<wbr/>www<wbr/>.cs<wbr/>.princeton<wbr/>.edu<wbr/>/~appel<wbr/>/papers<wbr/>/asdl97<wbr/>.pdf</a></i>).</li>&#13;
</ul>&#13;
<p class="ListHead"><b>Executable stacks</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">“Executable Stack,” a blog post by Ian Lance Taylor, discusses which programs need executable stacks and describes how Linux systems figure out whether a program’s stack should be executable (<i><a href="https://www.airs.com/blog/archives/518">https://<wbr/>www<wbr/>.airs<wbr/>.com<wbr/>/blog<wbr/>/archives<wbr/>/518</a></i>).</li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>