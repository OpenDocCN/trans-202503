<html><head></head><body><section class="chapter" epub:type="chapter" id="programming" title="Chapter&#xA0;3.&#xA0;Programming"><div class="titlepage"><div><div><h2 class="title">Chapter 3. Programming</h2></div></div></div><p><a class="indexterm" id="iddle1097"/><a class="indexterm" id="iddle1996"/><a class="indexterm" id="iddle2108"/><a class="indexterm" id="iddle2141"/>In this chapter we will look at some basic examples of computer programming. We will look at writing programs to automate various useful tasks in multiple programming languages. Even though we use prebuilt software for the majority of this book, it is useful to be able to create your own programs.</p><div class="sect1" title="Bash Scripting"><div class="titlepage"><div><div><h2 class="title" id="bash_scripting" style="clear: both">Bash Scripting</h2></div></div></div><p>In this section we’ll look at using Bash scripts to run several commands at once. <span class="emphasis"><em>Bash scripts</em></span>, or <span class="emphasis"><em>shell scripts</em></span>, are files that include multiple terminal commands to be run. Any command we can run in a terminal can be run in a script.</p><div class="sect2" title="Ping"><div class="titlepage"><div><div><h3 class="title" id="ping">Ping</h3></div></div></div><p><a class="indexterm" id="iddle1101"/><a class="indexterm" id="iddle1178"/><a class="indexterm" id="iddle1311"/><a class="indexterm" id="iddle1493"/><a class="indexterm" id="iddle1551"/><a class="indexterm" id="iddle1940"/><a class="indexterm" id="iddle2059"/>We’ll call our first script <span class="emphasis"><em>pingscript.sh</em></span>. When it runs, this script will perform a <span class="emphasis"><em>ping sweep</em></span> on our local network that sends Internet Control Message Protocol (ICMP) messages to remote systems to see if they respond.</p><p>We’ll use the ping tool to determine which hosts are reachable on a network. (Although some hosts may not respond to ping requests and may be up despite not being “pingable,” a ping sweep is still a good place to start.) By default, we supply the IP address or hostname to ping. For example, to ping our Windows XP target, enter the bold code in <a class="xref" href="ch03.xhtml#pinging_a_remote_host" title="Example 3-1. Pinging a remote host">Example 3-1</a>.</p><div class="example"><a id="pinging_a_remote_host"/><div class="example-title">Example 3-1. Pinging a remote host</div><div class="example-contents"><pre class="programlisting">root@kali:~/# <span class="strong"><strong>ping 192.168.20.10</strong></span>&#13;
PING 192.168.20.10 (192.168.20.10) 56(84) bytes of data.&#13;
64 bytes from 192.168.20.10: icmp_req=1 ttl=64 time=0.090 ms&#13;
64 bytes from 192.168.20.10: icmp_req=2 ttl=64 time=0.029 ms&#13;
64 bytes from 192.168.20.10: icmp_req=3 ttl=64 time=0.038 ms&#13;
64 bytes from 192.168.20.10: icmp_req=4 ttl=64 time=0.050 ms&#13;
<span class="strong"><strong>^C</strong></span>&#13;
--- 192.168.20.10 ping statistics ---&#13;
4 packets transmitted, 4 received, 0% packet loss, time 2999 ms&#13;
rtt min/avg/max/mdev = 0.029/0.051/0.090/0.024 ms</pre></div></div><p>We can tell from the ping output that the Windows XP target is up and responding to ping probes because we received replies to our ICMP requests. (The trouble with ping is that it will keep running forever unless you stop it with <span class="smaller">ctrl</span>-C.)</p></div><div class="sect2" title="A Simple Bash Script"><div class="titlepage"><div><div><h3 class="title" id="simple_bash_script">A Simple Bash Script</h3></div></div></div><p>Let’s begin writing a simple Bash script to ping hosts on the network. A good place to start is by adding some help information that tells your users how to run your script correctly.</p><a id="pro_id00053"/><pre class="programlisting">#<span class="strong"><strong>!/bin/bash</strong></span>&#13;
<span class="strong"><strong>echo "Usage: ./pingscript.sh [network]"</strong></span>&#13;
<span class="strong"><strong>echo "example: ./pingscript.sh 192.168.20"</strong></span></pre><p>The first line of this script tells the terminal to use the Bash interpreter. The next two lines that begin with <span class="emphasis"><em>echo</em></span> simply tell the user that our ping script will take a command line argument (network), telling the script which network to ping sweep (for example, 192.168.20). The <code class="literal">echo</code> command will simply print the text in quotes.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note01"/>Note</h3><p>This script implies we are working with a class C network, where the first three octets of the IP address make up the network.</p></div><p>After creating the script, use <code class="literal">chmod</code> to make it executable so we can run it.</p><a id="pro_id00054"/><pre class="programlisting">root@kali:~/# <span class="strong"><strong>chmod 744 pingscript.sh</strong></span></pre></div><div class="sect2" title="Running Our Script"><div class="titlepage"><div><div><h3 class="title" id="running_our_script">Running Our Script</h3></div></div></div><p><a class="indexterm" id="iddle1100"/><a class="indexterm" id="iddle1102"/><a class="indexterm" id="iddle1494"/><a class="indexterm" id="iddle1908"/>Previously, when entering Linux commands, we typed the command name at the prompt. The filesystem location of built-in Linux commands as well as pentest tools added to Kali Linux are part of our <code class="literal">PATH</code> environmental variable. The <code class="literal">PATH</code> variable tells Linux which directories to search for executable files. To see which directories are included in our <code class="literal">PATH</code>, enter <span class="strong"><strong><code class="literal">echo $PATH</code></strong></span>.</p><a id="pro_id00055"/><pre class="programlisting">root@kali:~/# <span class="strong"><strong>echo $PATH</strong></span>&#13;
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</pre><p>Notice in the output that the <span class="emphasis"><em>/root</em></span> directory is not listed. That means that we won’t be able to simply enter <code class="literal">pingscript.sh</code> to run our Bash script. Instead we’ll enter <span class="strong"><strong><code class="literal">./pingscript.sh</code></strong></span> to tell the terminal to run the script from our current directory. As shown next, the script prints the usage information.</p><a id="pro_id00056"/><pre class="programlisting">root@kali:~/# <span class="strong"><strong>./pingscript.sh</strong></span>&#13;
Usage: ./pingscript.sh [network]&#13;
example: ./pingscript.sh 192.168.20</pre></div><div class="sect2" title="Adding Functionality with if Statements"><div class="titlepage"><div><div><h3 class="title" id="adding_functionality_with_if_statements">Adding Functionality with if Statements</h3></div></div></div><p>Now let’s add in a bit more functionality with an <code class="literal">if</code> statement, as shown in <a class="xref" href="ch03.xhtml#adding_an_if_statement" title="Example 3-2. Adding an if statement">Example 3-2</a>.</p><div class="example"><a id="adding_an_if_statement"/><div class="example-title">Example 3-2. Adding an <code class="literal">if</code> statement</div><div class="example-contents"><pre class="programlisting">#!/bin/bash&#13;
if [ "$1" == "" ] ❶&#13;
then ❷&#13;
echo "Usage: ./pingscript.sh [network]"&#13;
echo "example: ./pingscript.sh 192.168.20"&#13;
fi ❸</pre></div></div><p>Typically a script needs to print usage information only if the user uses it incorrectly. In this case, the user needs to supply the network to scan as a command line argument. If the user fails to do so, we want to inform the user how to run our script correctly by printing the usage information.</p><p>To accomplish this, we can use an <code class="literal">if</code> statement to see if a condition is met. By using an <code class="literal">if</code> statement, we can have our script echo the usage information only under certain conditions—for example, if the user does not supply a command line argument.</p><p>The <code class="literal">if</code> statement is available in many programming languages, though the syntax varies from language to language. In Bash scripting, an <code class="literal">if</code> statement is used like this: <code class="literal">if [</code><span class="emphasis"><em><code class="literal">condition</code></em></span><code class="literal">]</code>, where <span class="emphasis"><em><code class="literal">condition</code></em></span> is the condition that must be met.</p><p><a class="indexterm" id="iddle1098"/><a class="indexterm" id="iddle1099"/><a class="indexterm" id="iddle1104"/><a class="indexterm" id="iddle1323"/><a class="indexterm" id="iddle1413"/><a class="indexterm" id="iddle1938"/><a class="indexterm" id="iddle2302"/>In the case of our script, we first see whether the first command line argument is null ❶. The symbol <code class="literal">$1</code> represents the first command line argument in a Bash script, and double equal signs (<code class="literal">==</code>) check for equality. After the <code class="literal">if</code> statement, we have a <code class="literal">then</code> statement ❷. Any commands between the <code class="literal">then</code> statement and the <code class="literal">fi</code> (<code class="literal">if</code> backward) ❸ are executed only if the conditional statement is true—in this case, when the first command line argument to the script is null.</p><p>When we run our new script with no command line argument, the <code class="literal">if</code> statement evaluates as true, because the first command line argument is indeed null, as shown here.</p><a id="pro_id00057"/><pre class="programlisting">root@kali:~/# <span class="strong"><strong>./pingscript.sh</strong></span>&#13;
Usage: ./pingscript.sh [network]&#13;
example: ./pingscript.sh 192.168.20</pre><p>As expected we see usage information echoed to the screen.</p></div><div class="sect2" title="A for Loop"><div class="titlepage"><div><div><h3 class="title" id="for_loop">A for Loop</h3></div></div></div><p>If we run the script again with a command line argument, nothing happens. Now let’s add some functionality that is triggered when the user runs the script with the proper arguments, as shown in <a class="xref" href="ch03.xhtml#adding_a_for_loop" title="Example 3-3. Adding a for loop">Example 3-3</a>.</p><div class="example"><a id="adding_a_for_loop"/><div class="example-title">Example 3-3. Adding a <code class="literal">for</code> loop</div><div class="example-contents"><pre class="programlisting">#!/bin/bash&#13;
if [ "$1" == "" ]&#13;
then&#13;
echo "Usage: ./pingscript.sh [network]"&#13;
echo "example: ./pingscript.sh 192.168.20"&#13;
<span class="strong"><strong>else</strong></span> ❶&#13;
<span class="strong"><strong>for x in `seq 1 254`; do</strong></span> ❷&#13;
<span class="strong"><strong>ping -c 1 $1.$x</strong></span>&#13;
<span class="strong"><strong>done</strong></span> ❸&#13;
fi</pre></div></div><p>After our <code class="literal">then</code> statement, we use an <code class="literal">else</code> statement ❶ to instruct the script to run code when the <code class="literal">if</code> statement evaluates as false—in this case, if the user supplies a command line argument. Because we want this script to ping all possible hosts on the local network, we need to loop through the numbers 1 through 254 (the possibilities for the final octet of an IP version 4 address) and run the <code class="literal">ping</code> command against each of these possibilities.</p><p>An ideal way to run through sequential possibilities is with a <code class="literal">for</code> loop ❷. Our <code class="literal">for</code> loop, <code class="literal">for x in `seq 1 254`; do</code>, tells the script to run the code that follows for each number from 1 to 254. This will allow us to run one set of instructions 254 times rather than writing out code for each instance. We denote the end of a <code class="literal">for</code> loop with the instruction <code class="literal">done</code> ❸.</p><p><a class="indexterm" id="iddle1103"/>Inside the <code class="literal">for</code> loop, we want to ping each of the IP addresses in the network. Using ping’s man page, we find that the <code class="literal">-c</code> option will allow us to limit the number of times we ping a host. We set <code class="literal">-c</code> to <code class="literal">1</code> so that each host will be pinged just once.</p><p>To specify which host to ping, we want to concatenate the first command line argument (which denotes the first three octets) with the current iteration of the <code class="literal">for</code> loop. The full command to use is <code class="literal">ping -c 1 $1.$x</code>. Recall that the <code class="literal">$1</code> denotes the first command line argument, and <code class="literal">$x</code> is the current iteration of the <code class="literal">for</code> loop. The first time our <code class="literal">for</code> loop runs, it will ping 192.168.20.1, then 192.168.20.2, all the way to 192.168.20.254. After iteration 254, our <code class="literal">for</code> loop finishes.</p><p>When we run our script with the first three octets of our IP address as the command line argument, the script pings each IP address in the network as shown in <a class="xref" href="ch03.xhtml#running_the_ping_sweep_script" title="Example 3-4. Running the ping sweep script">Example 3-4</a>.</p><div class="example"><a id="running_the_ping_sweep_script"/><div class="example-title">Example 3-4. Running the ping sweep script</div><div class="example-contents"><pre class="programlisting">root@kali:~/# <span class="strong"><strong>./pingscript.sh 192.168.20</strong></span>&#13;
PING 192.168.20.1 (192.168.20.1) 56(84) bytes of data.&#13;
64 bytes from 192.168.20.1: icmp_req=1 ttl=255 time=8.31 ms ❶&#13;
&#13;
--- 192.168.20.1 ping statistics ---&#13;
1 packets transmitted, 1 received, 0% packet loss, time 0ms&#13;
rtt min/avg/max/mdev = 8.317/8.317/8.317/0.000 ms&#13;
PING 192.168.20.2(192.168.20.2) 56(84) bytes of data.&#13;
64 bytes from 192.168.20.2: icmp_req=1 ttl=128 time=166 ms&#13;
&#13;
--- 192.168.20.2 ping statistics ---&#13;
1 packets transmitted, 1 received, 0% packet loss, time 0ms&#13;
rtt min/avg/max/mdev = 166.869/166.869/166.869/0.000 ms&#13;
PING 192.168.20.3 (192.168.20.3) 56(84) bytes of data.&#13;
From 192.168.20.13 icmp_seq=1 Destination Host Unreachable ❷&#13;
&#13;
--- 192.168.20.3 ping statistics ---&#13;
1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>Your results will vary based on the systems in your local network. Based on this output, I can tell that in my network, the host 192.168.20.1 is up, and I received an ICMP reply ❶. On the other hand, the host 192.168.20.3 is not up, so I received a host unreachable notification ❷.</p></div><div class="sect2" title="Streamlining the Results"><div class="titlepage"><div><div><h3 class="title" id="streamlining_the_results">Streamlining the Results</h3></div></div></div><p>All this information printed to screen is not very nice to look at, and anyone who uses our script will need to sift through a lot of information to determine which hosts in the network are up. Let’s add some additional functionality to streamline our results.</p><p><a class="indexterm" id="iddle1238"/><a class="indexterm" id="iddle1452"/>In the previous chapter we covered <code class="literal">grep</code>, which searches for and matches specific patterns. Let’s use <code class="literal">grep</code> to filter the script’s output, as shown in <a class="xref" href="ch03.xhtml#using_grep_to_filter_results" title="Example 3-5. Using grep to filter results">Example 3-5</a>.</p><div class="example"><a id="using_grep_to_filter_results"/><div class="example-title">Example 3-5. Using <code class="literal">grep</code> to filter results</div><div class="example-contents"><pre class="programlisting">#!/bin/bash&#13;
if [ "$1" == "" ]&#13;
then&#13;
echo "Usage: ./pingscript.sh [network]"&#13;
echo "example: ./pingscript.sh 192.168.20"&#13;
else&#13;
for x in `seq 1 254`; do&#13;
ping -c 1 $1.$x | grep "64 bytes" ❶&#13;
done&#13;
fi</pre></div></div><p>Here we look for all instances of the string <code class="literal">64 bytes</code> ❶, which occurs when an ICMP reply is received when pinging a host. If we run the script with this change, we see that only lines that include the text <code class="literal">64 bytes</code> are printed to the screen, as shown here.</p><a id="pro_id00058"/><pre class="programlisting">root@kali:~/# <span class="strong"><strong>./pingscript.sh 192.168.20</strong></span>&#13;
64 bytes from 192.168.20.1: icmp_req=1 ttl=255 time=4.86 ms&#13;
64 bytes from 192.168.20.2: icmp_req=1 ttl=128 time=68.4 ms&#13;
64 bytes from 192.168.20.8: icmp_req=1 ttl=64 time=43.1 ms&#13;
--<span class="emphasis"><em>snip</em></span>--</pre><p>We get indicators only for live hosts; hosts that do not answer are not printed to the screen.</p><p>But we can make this script even nicer to work with. The point of our ping sweep is to get a list of live hosts. By using the <code class="literal">cut</code> command discussed in <a class="xref" href="ch02.xhtml" title="Chapter 2. Using Kali Linux">Chapter 2</a>, we can print the IP addresses of only the live hosts, as shown in <a class="xref" href="ch03.xhtml#using_cut_to_further_filter_results" title="Example 3-6. Using cut to further filter results">Example 3-6</a>.</p><div class="example"><a id="using_cut_to_further_filter_results"/><div class="example-title">Example 3-6. Using <code class="literal">cut</code> to further filter results</div><div class="example-contents"><pre class="programlisting">#!/bin/bash&#13;
if [ "$1" == "" ]&#13;
then&#13;
echo "Usage: ./pingscript.sh [network]"&#13;
echo "example: ./pingscript.sh 192.168.20"&#13;
else&#13;
for x in `seq 1 254`; do&#13;
ping -c 1 $1.$x | grep "64 bytes" | cut -d" " -f4 ❶&#13;
done&#13;
fi</pre></div></div><p>We can use a space as the delimiter and grab the fourth field, our IP address, as shown at ❶.</p><p><a class="indexterm" id="iddle1010"/><a class="indexterm" id="iddle1260"/><a class="indexterm" id="iddle1402"/><a class="indexterm" id="iddle2020"/><a class="indexterm" id="iddle2124"/>Now we run the script again as shown here.</p><a id="pro_id00059"/><pre class="programlisting">root@kali:~/mydirectory# <span class="strong"><strong>./pingscript.sh 192.168.20</strong></span>&#13;
192.168.20.1:&#13;
192.168.20.2:&#13;
192.168.20.8:&#13;
--<span class="emphasis"><em>snip</em></span>--</pre><p>Unfortunately, we see a trailing colon at the end of each line. The results would be clear enough to a user, but if we want to use these results as input for any other programs, we need to delete the trailing colon. In this case, <code class="literal">sed</code> is the answer.</p><p>The <code class="literal">sed</code> command that will delete the final character from each line is <code class="literal">sed 's/.$//'</code>, as shown in <a class="xref" href="ch03.xhtml#using_sed_to_drop_the_trailing_colon" title="Example 3-7. Using sed to drop the trailing colon">Example 3-7</a>.</p><div class="example"><a id="using_sed_to_drop_the_trailing_colon"/><div class="example-title">Example 3-7. Using <code class="literal">sed</code> to drop the trailing colon</div><div class="example-contents"><pre class="programlisting">#!/bin/bash&#13;
if [ "$1" == "" ]&#13;
then&#13;
echo "Usage: ./pingscript.sh [network]"&#13;
echo "example: ./pingscript.sh 192.168.20"&#13;
else&#13;
for x in `seq 1 254`; do&#13;
ping -c 1 $1.$x | grep "64 bytes" | cut -d" " -f4 | <span class="strong"><strong>sed 's/.$//'</strong></span>&#13;
done&#13;
fi</pre></div></div><p>Now when we run the script, everything looks perfect, as shown here.</p><a id="pro_id00060"/><pre class="programlisting">root@kali:~/# <span class="strong"><strong>./pingscript.sh 192.168.20</strong></span>&#13;
192.168.20.1&#13;
192.168.20.2&#13;
192.168.20.8&#13;
--<span class="emphasis"><em>snip</em></span>--</pre><div class="note" title="Note"><h3 class="title"><a id="ch03note02"/>Note</h3><p>Of course, if we want to output the results to a file instead of to the screen, we can use the <code class="literal">&gt;&gt;</code> operator, covered in <a class="xref" href="ch02.xhtml" title="Chapter 2. Using Kali Linux">Chapter 2</a>, to append each live IP address to a file. Try automating other tasks in Linux to practice your Bash scripting skills.</p></div></div></div><div class="sect1" title="Python Scripting"><div class="titlepage"><div><div><h2 class="title" id="python_scripting" style="clear: both">Python Scripting</h2></div></div></div><p>Linux systems typically come with interpreters for other scripting languages such as Python and Perl. Interpreters for both languages are included in Kali Linux. In <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a> through <a class="xref" href="ch19.xhtml" title="Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules">Chapter 19</a>, we’ll use Python to write our own exploit code. For now, let’s write a simple Python script and run it in Kali Linux just to demonstrate the basics of Python scripting.</p><p><a class="indexterm" id="iddle1517"/><a class="indexterm" id="iddle1958"/><a class="indexterm" id="iddle2026"/><a class="indexterm" id="iddle2041"/><a class="indexterm" id="iddle2193"/><a class="indexterm" id="iddle2280"/><a class="indexterm" id="iddle2358"/>For this example we’ll do something similar to our first Netcat example in <a class="xref" href="ch02.xhtml" title="Chapter 2. Using Kali Linux">Chapter 2</a>: We’ll attach to a port on a system and see if the port is listening. A starting point for our script is shown here.</p><a id="pro_id00061"/><pre class="programlisting">#!/usr/bin/python ❶&#13;
ip = raw_input("Enter the ip: ") ❷&#13;
port = input("Enter the port: ") ❸</pre><p>In the previous section, the first line of our script told the terminal to use Bash to interpret the script. We do the same thing here, pointing to the Python interpreter installed on Kali Linux at <span class="emphasis"><em>/usr/bin/python</em></span> ❶.</p><p>We’ll begin by prompting the user for data and recording input into variables. The variables will store the input for use later in the script. To take input from the user, we can use the Python function <code class="literal">raw_input</code> ❷. We want to save our port as an integer, so we use a similar built-in Python function, <code class="literal">input</code>, at ❸. Now we ask the user to input an IP address and a port to test.</p><p>After saving the file, use <code class="literal">chmod</code> to make the script executable before running the script, as shown here.</p><a id="pro_id00062"/><pre class="programlisting">root@kali:~/mydirectory# <span class="strong"><strong>chmod 744 pythonscript.py</strong></span>&#13;
root@kali:~/mydirectory# <span class="strong"><strong>./pythonscript.py</strong></span>&#13;
Enter the ip: 192.168.20.10&#13;
Enter the port: 80</pre><p>When you run the script, you’re prompted for an IP address and a port, as expected.</p><p>Now we will add in some functionality to allow us to use the user’s input to connect to the chosen system on the selected port to see if it is open (<a class="xref" href="ch03.xhtml#adding_port-scanning_functionality" title="Example 3-8. Adding port-scanning functionality">Example 3-8</a>).</p><div class="example"><a id="adding_port-scanning_functionality"/><div class="example-title">Example 3-8. Adding port-scanning functionality</div><div class="example-contents"><pre class="programlisting">#!/usr/bin/python&#13;
import socket ❶&#13;
ip = raw_input("Enter the ip: ")&#13;
port = input("Enter the port: ")&#13;
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ❷&#13;
if s.connect_ex((ip, port)): ❸&#13;
        print "Port", port, "is closed" ❹&#13;
else: ❺&#13;
        print "Port", port, "is open"</pre></div></div><p>To perform networking tasks in Python, we can include a library called <span class="emphasis"><em>socket</em></span> using the command <code class="literal">import socket</code> ❶. The socket library does the heavy lifting for setting up a network socket.</p><p>The syntax for creating a TCP network socket is <code class="literal">socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code>. We set a variable equal to this network socket at ❷.</p><div class="sect2" title="Connecting to a Port"><div class="titlepage"><div><div><h3 class="title" id="connecting_to_a_port">Connecting to a Port</h3></div></div></div><p><a class="indexterm" id="iddle1202"/><a class="indexterm" id="iddle1203"/><a class="indexterm" id="iddle1496"/><a class="indexterm" id="iddle1987"/><a class="indexterm" id="iddle2021"/><a class="indexterm" id="iddle2023"/>When creating a socket to connect to a remote port, the first candidate available from Python is the socket function <code class="literal">connect</code>. However, there is a better candidate for our purposes in the similar function, <code class="literal">connect_ex</code>. According to the Python documentation, <code class="literal">connect_ex</code> is like <code class="literal">connect</code> except that it returns an error code instead of raising an exception if the connection fails. If the connection succeeds, <code class="literal">connect_ex</code> will return the value <code class="literal">0</code>. Because we want to know whether the function can connect to the port, this return value seems ideal to feed into an <code class="literal">if</code> statement.</p></div><div class="sect2" title="if Statements in Python"><div class="titlepage"><div><div><h3 class="title" id="if_statements_in_python">if Statements in Python</h3></div></div></div><p>When building <code class="literal">if</code> statements in Python, we enter <code class="literal">if</code> <span class="emphasis"><em><code class="literal">condition</code></em></span><code class="literal">:</code>. In Python the statements that are part of a conditional <code class="literal">or</code> loop are denoted with indentations rather than ending markers, as we saw in Bash scripting. We can instruct our <code class="literal">if</code> statement to evaluate the returned value of the connection of our TCP socket to the user-defined IP address and port with the command <code class="literal">if s.connect_ex((ip, port)):</code> ❸. If the connection succeeds, <code class="literal">connect_ex</code> will return <code class="literal">0</code>, which will be evaluated by the <code class="literal">if</code> statement as false. If the connection fails, <code class="literal">connect_ex</code> will return a positive integer, or true. Thus, if our <code class="literal">if</code> statement evaluates as true, it stands to reason that the port is closed, and we can present this to the user using the Python <code class="literal">print</code> command at ❹. And, as in the Bash scripting example, if <code class="literal">connect_ex</code> returns <code class="literal">0</code> at ❺, we can use an <code class="literal">else</code> statement (the syntax is <code class="literal">else:</code> in Python) to instead inform the user that the tested port is open.</p><p>Now, run the updated script to test whether TCP port 80 is running on the Windows XP target host as shown here.</p><a id="pro_id00063"/><pre class="programlisting">root@kali:~/# <span class="strong"><strong>./pythonscript.py</strong></span>&#13;
Enter the ip: 192.168.20.10&#13;
Enter the port: 80&#13;
Port 80 is open</pre><p>According to our script, port 80 is open. Now run the script again against port 81.</p><a id="pro_id00064"/><pre class="programlisting">root@kali:~/# <span class="strong"><strong>./pythonscript.py</strong></span>&#13;
Enter the ip: 192.168.20.10&#13;
Enter the port: 81&#13;
Port 81 is closed</pre><p>This time, the script reports that port 81 is closed.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note03"/>Note</h3><p>We will look at checking open ports in <a class="xref" href="ch05.xhtml" title="Chapter 5. Information Gathering">Chapter 5</a>, and we will return to Python scripting when we study exploit development. Kali Linux also has interpreters for the Perl and Ruby languages. We will learn a little bit of Ruby in <a class="xref" href="ch19.xhtml" title="Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules">Chapter 19</a>. It never hurts to know a little bit of multiple languages. If you are up for a challenge, see if you can re-create this script in Perl and Ruby.</p></div></div></div><div class="sect1" title="Writing and Compiling C Programs"><div class="titlepage"><div><div><h2 class="title" id="writing_and_compiling_c_programs" style="clear: both">Writing and Compiling C Programs</h2></div></div></div><p><a class="indexterm" id="iddle1011"/><a class="indexterm" id="iddle1151"/><a class="indexterm" id="iddle1189"/><a class="indexterm" id="iddle1432"/><a class="indexterm" id="iddle1444"/><a class="indexterm" id="iddle1471"/><a class="indexterm" id="iddle1495"/><a class="indexterm" id="iddle1503"/><a class="indexterm" id="iddle1657"/><a class="indexterm" id="iddle1988"/><a class="indexterm" id="iddle1998"/><a class="indexterm" id="iddle2249"/>Time for one more simple programming example, this time in the C programming language. Unlike scripting languages such as Bash and Python, C code must be compiled and translated into machine language that the CPU can understand before it is run.</p><p>Kali Linux includes the GNU Compiler Collection (GCC), which will allow us to compile C code to run on the system. Let’s create a simple C program that says hello to a command line argument, as shown in <a class="xref" href="ch03.xhtml#quotation_markhello_worldquotation_mark" title="Example 3-9. “Hello World” C program">Example 3-9</a>.</p><div class="example"><a id="quotation_markhello_worldquotation_mark"/><div class="example-title">Example 3-9. “Hello World” C program</div><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt; ❶&#13;
int main(int argc, char *argv[]) ❷&#13;
{&#13;
    if(argc &lt; 2) ❸&#13;
    {&#13;
        printf("%s\n", "Pass your name as an argument"); ❹&#13;
        return 0; ❺&#13;
    }&#13;
    else&#13;
    {&#13;
                printf("Hello %s\n", argv[1]); ❻&#13;
                return 0;&#13;
    }&#13;
}</pre></div></div><p>The syntax for C is a bit different from that of Python and Bash. Because our code will be compiled, we don’t need to tell the terminal which interpreter to use at the beginning of our code. First, as with our Python example, we import a C library. In this case we’ll import the <span class="emphasis"><em>stdio</em></span> (short for standard input and output) library, which will allow us to accept input and print output to the terminal. In C, we import <span class="emphasis"><em>stdio</em></span> with the command <code class="literal">#include &lt;stdio.h&gt;</code> ❶.</p><p>Every C program has a function called <code class="literal">main</code> ❷ that is run when the program starts. Our program will take a command line argument, so we pass an integer <code class="literal">argc</code> and a character array <code class="literal">argv</code> to <code class="literal">main</code>. <code class="literal">argc</code> is the argument count, and <code class="literal">argv</code> is the argument vector, which includes any command line arguments passed to the program. This is just standard syntax for C programs that accept command line arguments. (In C, the beginning and end of functions, loops, and so on are denoted by braces <code class="literal">{}</code>.)</p><p>First, our program checks to see if a command line argument is present. The <code class="literal">argc</code> integer is the length of the argument array; if it is less than two (the program name itself and the command line argument), then a command line argument has not been given. We can use an <code class="literal">if</code> statement to check ❸.</p><p>The syntax for <code class="literal">if</code> is also a little different in C. As with our Bash script, if a command line argument is not given, we can prompt the user with usage information ❹. The <code class="literal">printf</code> function allows us to write output to the terminal. Also note that statements in C are finished with a semicolon (<code class="literal">;</code>). Once <a class="indexterm" id="iddle2070"/>we’re through with our program, we use a <code class="literal">return</code> statement ❺ to finish the function <code class="literal">main</code>. If a command line argument is supplied, our <code class="literal">else</code> statement instructs the program to say hello ❻. (Be sure to use braces to close all of your loops and the <code class="literal">main</code> function.)</p><p>Before we can run our program, we need to compile it with GCC as shown here. Save the program as <span class="emphasis"><em>cprogram.c</em></span>.</p><a id="pro_id00065"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>gcc cprogram.c -o cprogram</strong></span></pre><p>Use the <code class="literal">-o</code> option to specify the name for the compiled program and feed your C code to GCC. Now run the program from your current directory. If the program is run with no arguments, you should see usage information as shown here.</p><a id="pro_id00066"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>./cprogram</strong></span>&#13;
Pass your name as an argument</pre><p>If instead we pass it an argument, in this case our name, the program tells us hello.</p><a id="pro_id00067"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>./cprogram georgia</strong></span>&#13;
Hello georgia</pre><div class="note" title="Note"><h3 class="title"><a id="ch03note04"/>Note</h3><p>We will look at another C programming example in <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>, where a little bit of sloppy C coding leads to a buffer overflow condition, which we will exploit.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00015" style="clear: both">Summary</h2></div></div></div><p>In this chapter we’ve looked at simple programs in three different languages. We looked at basic constructs, such as saving information in variables for later use. Additionally, we learned how to use conditionals, such as <code class="literal">if</code> statements, and iterations, such as <code class="literal">for</code> loops, to have the program make decisions based on the provided information. Though the syntax used varies from programming language to programming language, the ideas are the same.</p></div></section></body></html>