<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_147"/>
<h2 class="h2" id="ch08"><strong><span class="big">8</span><br/>DATA TYPES AND DATA STRUCTURES</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent">Understanding the data types and data structures that you encounter as you analyze a binary is foundational to reverse engineering. The data that is being passed into a function is a key to reverse engineering the function’s signature (the number, type, and sequence of parameters required by the function). Beyond that, the data types and data structures declared and utilized within functions provide additional clues to what each function is doing. This reinforces the importance of developing a deep understanding of how data types and data structures are represented and manipulated at the assembly language level.</p>
<p class="indent">In this chapter, we devote significant time to these topics that are so critical to the success of a reverse engineering effort. We demonstrate how to recognize data structures used in a disassembly and to model those structures in Ghidra. We follow with a demonstration of how Ghidra’s rich collection of structure layouts can save you time with your analysis. Since C++ classes are a complex extension of C structures, the chapter concludes with <span epub:type="pagebreak" id="page_148"/>a discussion of reverse engineering compiled C++ programs. So let’s begin our discussion of the manipulation and definition of simple and complex data types and structures found within compiled programs.</p>
<h3 class="h3" id="ch08lev145"><strong>Making Sense of Data</strong></h3>
<p class="noindent">As a reverse engineer, you want to make sense of the data you see in a disassembly. The simplest method for associating a specific data type with a variable is to observe the use of the variable as a parameter to a function that we know something about. During its analysis phase, Ghidra makes every effort to annotate data types when they can be deduced based on a variable’s use with a function for which Ghidra possesses a prototype.</p>
<p class="indent">With imported library functions, Ghidra often will already know the prototype of the function. In such cases, you can easily view the prototype by hovering over the function name in the Listing window or the Symbol Tree window. When Ghidra has no knowledge of a function’s parameter sequence, it should, at a minimum, know the name of the library from which the function was imported (see the <em>Imports</em> folder in the Symbol Tree window). When this happens, your best resources for learning the signature and behavior of the function are any associated man pages or other available API documentation. When all else fails, remember the adage “Google is your friend.”</p>
<p class="indent">The low-hanging fruit in understanding the behavior of binary programs lies in cataloging the library functions that the program calls. A C program that calls the <span class="literal">connect</span> function is creating a network connection. A Windows program that calls <span class="literal">RegOpenKey</span> is accessing the Windows registry. Additional analysis is required, however, to gain an understanding of how and why these functions are called.</p>
<p class="indent">Discovering how a function is called requires learning about the parameters associated with the function. Let’s consider a C program that calls the <span class="literal">connect</span> function as part of retrieving an HTML page. To call <span class="literal">connect</span>, the program needs to know the IP address and destination port of the server that is hosting the page, which is provided by a library function called <span class="literal">getaddrinfo</span>. Ghidra recognizes this as a library function and adds a comment to the call to provide us with additional information in the Listing window, as shown here:</p>
<p class="programs">00010a30  CALL  getaddrinfo    int getaddrinfo(char * __name, c...</p>
<p class="indent">You can obtain more information about this call in several ways. Hovering over the abbreviated comment to the right of the instruction shows that Ghidra has provided the complete function prototype to help you understand the parameters that are being passed in the function call. Hovering over the function name in the Symbol Tree displays the function prototype and variables in a pop-up window. Alternatively, choosing Edit Function from the right-click menu provides the same information in an editable format, as shown in <a href="ch08.xhtml#fig8_1">Figure 8-1</a>. If you want even more information, you can then use the Data Type Manager window to find information on specific parameters such as the <span class="literal">addrinfo</span> data type. If you had clicked <span epub:type="pagebreak" id="page_149"/><span class="literal">getaddrinfo</span> in the preceding listing, you would see that the content shown in <a href="ch08.xhtml#fig8_1">Figure 8-1</a> is replicated within the listing. (This is within a thunk function, which is discussed in “<a href="ch10.xhtml#ch10sb01">Thunk</a>” on <a href="ch10.xhtml#page_212">page 212</a>.)</p>
<div class="image"><img src="Images/fig8-1.jpg" alt="image" width="694" height="640"/></div>
<p class="figcap" id="fig8_1"><em>Figure 8-1: Edit Function window for</em> <span class="codeitalic">getaddrinfo</span> <em>function</em></p>
<p class="indent">Finally, you aren’t required to navigate through the Symbol Tree and Data Type Manager windows to make these observations, as the decompiler has already applied this information in the Decompiler window. If you look at the Decompiler window, you will see that Ghidra has already incorporated member names for the fields contained within the structure (<span class="literal">addrinfo</span>) by using information from loaded type libraries. For the same example, in the following excerpt of code from the decompiler, you can see that the member names <span class="literal">ai_family</span> and <span class="literal">ai_socktype</span> help us understand that <span class="literal">local_48</span> is a structure that is used when getting the information needed for <span class="literal">connect</span>. In this case, the <span class="literal">ai_family</span> assignment indicates that an IPv4 address is being used (<span class="literal">2</span> equates to the symbolic constant <span class="literal">AF_INET</span>), and <span class="literal">ai_socktype</span> indicates the use of a stream socket (<span class="literal">1</span> equates to the symbolic constant <span class="literal">SOCK_STREAM</span>):</p>
<p class="programs">  local_48.ai_family = 2;<br/>
  local_48.ai_socktype = 1;<br/>
  local_10 = getaddrinfo(param_1,"www",&amp;local_48,&amp;local_18);</p>
<span epub:type="pagebreak" id="page_150"/>
<h3 class="h3" id="ch08lev146"><strong>Recognizing Data Structure Use</strong></h3>
<p class="noindent">While primitive data types often fit in a processor’s registers or instruction operands, composite data types such as arrays and structures typically require more complex instruction sequences in order to access the individual data items they contain. Before we can discuss Ghidra’s features for improving the readability of code that utilizes complex data types, we need to review what that code looks like.</p>
<h4 class="h4" id="ch08lev147"><strong><em>Array Member Access</em></strong></h4>
<p class="noindent"><em>Arrays</em> are the simplest composite data structures in terms of memory layout. Traditionally, arrays are contiguous blocks of memory that contain consecutive elements of the same data type (a homogeneous collection). The size of an array is the product of the number of elements in the array and the size of each element. Using C notation, the minimum number of bytes consumed by declaring the integer array</p>
<p class="programs">int array_demo[100];</p>
<p class="noindent">is computed as</p>
<p class="programs">int bytes = 100 * sizeof(int); // or 100 * sizeof(array_demo[0])</p>
<p class="indent">Individual array elements can be accessed by supplying an index value, which may be a variable or a constant, as shown in these valid array references:</p>
<p class="programs"> <span class="ent">➊</span> array_demo[20] = 15;              // fixed index into the array<br/>
    for (int i = 0; i &lt; 100; i++) {<br/>
     <span class="ent">➋</span> array_demo[i] = i;            // varying index into the array</p>
<p class="indent">Assuming, for the sake of example, that <span class="literal">sizeof(int)</span>is 4 bytes, then the first array access <span class="ent">➊</span> accesses the integer value that lies 80 bytes into the array, while the second array access <span class="ent">➋</span> accesses integers at offsets 0, 4, 8, . . . 96 bytes into the array. The offset for the first array access can be computed at compile time as <span class="literal">20 * 4</span>. In most cases, the offset for the second array access must be computed at runtime because the value of the loop counter, <span class="literal">i</span>, is not fixed at compile time. Thus, the product <span class="literal">i * 4</span> is computed on each pass through the loop to determine the exact offset into the array.</p>
<p class="indent">Ultimately, how an array element is accessed depends not only on the type of index used but also on where the array is allocated within the program’s memory space.</p>
<h5 class="h5" id="ch08lev148"><strong>Globally Allocated Arrays</strong></h5>
<p class="noindent">When an array is allocated within the global data area of a program (within the <span class="literal">.data</span> or <span class="literal">.bss</span> section, for example), the compiler knows the base address of the array at compile time, which enables the compiler to compute fixed <span epub:type="pagebreak" id="page_151"/>addresses for any array element that is accessed using a fixed index. Consider the following trivial program, which accesses a global array using both fixed and variable indices.</p>
<p class="programs">int global_array[3];<br/>
int main(int argc, char **argv) {<br/>
    int idx = atoi(argv[1]); //not bounds checked for simplicity<br/>
    global_array[0] = 10;<br/>
    global_array[1] = 20;<br/>
    global_array[2] = 30;<br/>
    global_array[idx] = 40;<br/>
}</p>
<div class="box5">
<p class="boxtitle-c"><strong>WHAT IS C REALLY EXPECTING?</strong></p>
<p class="noindent">For simplicity, we said that C is expecting an integer index as either a variable or a constant. In reality, any expression that can be evaluated to or interpreted as an integer will do. The general guideline is, “anywhere you can use an integer, you can use an expression that evaluates to an integer.” Of course, this is not limited to just integers. C is perfectly happy to evaluate any expression you provide and try to make it work for the variable type expected. What if the values are outside the bounds of the array? You have the makings of numerous exploitable vulnerabilities, of course! Values will be read from or written to the resulting out-of-bounds memory region, or the program will simply crash if the computed target address is not valid within the program.</p>
</div>
<p class="indent">If we disassemble a stripped version of the corresponding binary, the main function contains the following code:</p>
<p class="programs">          ...<br/>
00100657  CALL   atoi<br/>
0010065c  MOV    dword ptr [RBP + local_c],EAX<br/>
0010065f  MOV    dword ptr [DAT_00301018],10<span class="ent">➊</span><br/>
00100669  MOV    dword ptr [DAT_0030101c],20<span class="ent">➋</span><br/>
00100673  MOV    dword ptr [DAT_00301020],30<span class="ent">➌</span><br/>
0010067d  MOV    EAX,dword ptr [RBP + local_c]<br/>
00100680  CDQE<br/>
00100682  LEA    RDX,[RAX*4]<span class="ent">➍</span><br/>
0010068a  LEA    RAX,[DAT_00301018]<span class="ent">➎</span><br/>
00100691  MOV    dword ptr [RDX + RAX*1]=&gt;DAT_00301018,40<span class="ent">➏</span><br/>
          ...</p>
<p class="indent">While this program has only one global variable (the global array), the disassembly lines <span class="ent">➊</span> <span class="ent">➋</span> <span class="ent">➌</span> seem to indicate three global variables: <span class="literal">DAT_00301018</span>, <span class="literal">DAT_0030101c</span>, and <span class="literal">DAT_00301020</span>, respectively. However, the <span class="literal">LEA</span> instruction <span class="ent">➎</span> loads the address of a global variable seen previously <span class="ent">➊</span>. In <span epub:type="pagebreak" id="page_152"/>this context, when combined with the computation of an offset (<span class="literal">RAX*4</span>) <span class="ent">➍</span>, and scaled memory access <span class="ent">➏</span>, <span class="literal">DAT_00301018</span> is most likely the base address of a global array. The annotated operand <span class="literal">=&gt;DAT_00301018</span> <span class="ent">➏</span> provides us with the base of the array into which 40 will be written.</p>
<div class="box5">
<p class="boxtitle-c"><strong>WHAT’S A STRIPPED BINARY?</strong></p>
<p class="noindent">When compilers generate object files, they must include enough information for the linker to be able to do its job. One of the linker’s jobs is to resolve references between object files, such as a call to a function whose body resides in a different file, utilizing information from a compiler-generated symbol. In many cases, the linker combines all of the symbol table information from the object files and includes the consolidated information in the resulting executable file. This information is not necessary for the executable to run properly, but it is very useful from a reverse engineering perspective, as Ghidra (and other tools like debuggers) can use the symbol table information to recover function and global variable names and sizes.</p>
<p class="indent"><em>Stripping</em> a binary means removing portions of an executable file that are not essential to the runtime operation of the binary. This can be accomplished by using the command-line <span class="literal">strip</span> utility to post-process an executable, or by providing build options to the compiler and/or linker (<span class="literal">-s</span> for <span class="literal">gcc</span>/<span class="literal">ld</span>) to have them generate a stripped binary themselves. In addition to symbol table information, <span class="literal">strip</span> can remove any debugging symbol information, such as local variable <span class="literal">names</span> and type information, that were embedded in a binary when it was built. Lacking symbol information, reverse engineering tools must have algorithms for both identifying and naming functions and data.</p>
</div>
<p class="indent">Based on the names assigned by Ghidra, we know that the global array starts with the 12 bytes beginning at address <span class="literal">00301018</span>. During compilation, the compiler used the fixed indices (0, 1, 2) to compute the actual addresses of the corresponding elements in the array (<span class="literal">00301018</span>, <span class="literal">0030101c</span>, and <span class="literal">00301020</span>), which are referenced using the global variables at <span class="ent">➊</span>, <span class="ent">➋</span>, and <span class="ent">➌</span>. Based on the values being moved into these locations, we can surmise that we are moving 32-bit integer (<span class="literal">dword</span>) values into this array. If we navigate to the associated data in the listing, we see the following content:</p>
<p class="programs">        DAT_00301018<br/>
00301018      ??       ??<br/>
00301019      ??       ??<br/>
0030101a      ??       ??<br/>
0030101b      ??       ??<br/>
        DAT_0030101c<br/>
0030101c      ??       ??<br/>
0030101d      ??       ??<br/>
0030101e      ??       ??<br/>
0030101f      ??       ??<br/>
<span epub:type="pagebreak" id="page_153"/>
        DAT_00301020<br/>
00301020      ??       ??<br/>
00301021      ??       ??<br/>
00301022      ??       ??<br/>
00301023      ??       ??</p>
<p class="indent">The question marks indicate that this array is probably allocated within the program’s <span class="literal">.bss</span> section and that no initialization values are present within the file image.</p>
<p class="indent">It is easier to recognize an array in disassembly when it is accessed using variable indices. When constant indices are used to access global arrays, the corresponding array elements appear as global variables in the disassembly. However, the use of variable index values reveals the base address of the array at <span class="ent">➎</span> and the size of the individual elements at <span class="ent">➍</span>, because the offset into the array must be computed using the index. (Such scaling operations are required to convert an integer array index from C to a byte offset for the correct array element in assembly language.)</p>
<p class="indent">Using Ghidra’s type- and array-formatting operations discussed in the previous chapter (Data ▸ Create Array), we can format <span class="literal">DAT_000301018</span> as a three-element integer array, yielding disassembly lines with a named array accessed with indices rather than offsets:</p>
<p class="programs">00100660  MOV    dword ptr [INT_ARRAY_00301018],10<br/>
0010066a  MOV    dword ptr [INT_ARRAY_00301018[1]],20<br/>
00100674  MOV    dword ptr [INT_ARRAY_00301018[2]],30</p>
<p class="indent">The default array name assigned by Ghidra, <span class="literal">INT_ARRAY_00301018</span>, includes the array type as well as the starting address of the array.</p>
<div class="box5">
<p class="boxtitle-c"><strong>UPDATING SYMBOL INFORMATION IN COMMENTS</strong></p>
<p class="noindent">As you begin identifying data types, changing symbol names, and so on, you can make sure that the valuable comments you have added to your listing don’t become outdated, or challenging to follow, by using comment annotations that update automatically. The <span class="literal">Symbol</span> annotation option lets you include references to symbols that will be updated as you change the symbols to accurately reflect your findings. (See “<a href="ch07.xhtml#ch07lev131">Annotations</a>” on <a href="ch07.xhtml#page_132">page 132</a>.)</p>
</div>
<p class="indent">Let’s look at the Decompiler window before (<a href="ch08.xhtml#fig8_2">Figure 8-2</a>) and after (<a href="ch08.xhtml#fig8_3">Figure 8-3</a>) the array has been created. In <a href="ch08.xhtml#fig8_2">Figure 8-2</a>, the important warning on line 2 is another clue that you might be looking at an array, and the assignment of integer values supports the assumption that the array type is integer.</p>
<span epub:type="pagebreak" id="page_154"/>
<div class="image"><img src="Images/fig8-2.jpg" alt="image" width="694" height="349"/></div>
<p class="figcap" id="fig8_2"><em>Figure 8-2: Decompiler view indicating potential array</em></p>
<p class="indent">After the integer array is created, the code in the Decompiler window is updated to use the new array variable, as shown in <a href="ch08.xhtml#fig8_3">Figure 8-3</a>.</p>
<div class="image"><img src="Images/fig8-3.jpg" alt="image" width="693" height="428"/></div>
<p class="figcap" id="fig8_3"><em>Figure 8-3: Decompiler view after declaring array type</em></p>
<h5 class="h5" id="ch08lev149"><strong>Stack-Allocated Arrays</strong></h5>
<p class="noindent">The compiler can’t know the absolute address of an array allocated on the stack as a local variable in a function at compile time, so even accesses that use constant indices require some computation at runtime. Despite the differences, compilers often treat stack-allocated arrays almost identically to globally allocated arrays.</p>
<span epub:type="pagebreak" id="page_155"/>
<p class="indent">The following program is a variation of the previous example that uses a stack-allocated array rather than a global array:</p>
<p class="programs">int main(int argc, char **argv) {<br/>
   int stack_array[3];<br/>
   int idx = atoi(argv[1]); //bounds check omitted for simplicity<br/>
   stack_array[0] = 10;<br/>
   stack_array[1] = 20;<br/>
   stack_array[2] = 30;<br/>
   stack_array[idx] = 40;<br/>
}</p>
<p class="indent">The address at which <span class="literal">stack_array</span> will be allocated is unknown at compile time, so the compiler cannot precompute the address of <span class="literal">stack_array[2]</span> as it did for <span class="literal">global_array[2]</span>. The compiler can, however, compute the relative location of any element within the array. For example, element <span class="literal">stack_array[2]</span> begins at offset <span class="literal">2*sizeof(int)</span> from the beginning of the array, and the compiler is well aware of this at compile time. If the compiler elects to allocate <span class="literal">stack_array</span> at offset <span class="literal">EBP-0x18</span> within the stack frame, it can compute <span class="literal">EBP-0x18+2*sizeof(int)</span>, which reduces to <span class="literal">EBP-0x10</span> at compile time and avoids the need for additional arithmetic at runtime to access <span class="literal">stack_array[2]</span>. This becomes evident in the following listing:</p>
<p class="programs">     undefined main()<br/>
        undefined     AL:1           &lt;RETURN&gt;<br/>
        undefined4    Stack[-0xc]:4  local_c<span class="ent">➊</span><br/>
        undefined4    Stack[-0x10]:4 local_10<br/>
        undefined4    Stack[-0x14]:4 local_14<br/>
        undefined4    Stack[-0x18]:4 local_18<br/>
        undefined4    Stack[-0x1c]:4 local_1c<br/>
        undefined8    Stack[-0x28]:8 local_28<br/>
0010063a  PUSH   RBP<br/>
0010063b  MOV    RBP,RSP<br/>
0010063e  SUB    RSP,0x20<br/>
00100642  MOV<span class="ent">➋</span>  dword ptr [RBP + local_1c],EDI<br/>
00100645  MOV    qword ptr [RBP + local_28],RSI<br/>
00100649  MOV    RAX,qword ptr [RBP + local_28]<br/>
0010064d  ADD    RAX,0x8<br/>
00100651  MOV    RAX,qword ptr [RAX]<br/>
00100654  MOV    RDI,RAX<br/>
00100657  MOV    EAX,0x0<br/>
0010065c  CALL   atoi<br/>
00100661  MOV<span class="ent">➌</span>  dword ptr [RBP + local_c],EAX<br/>
00100664  MOV<span class="ent">➍</span>  dword ptr [RBP + local_18],10<br/>
0010066b  MOV    dword ptr [RBP + local_14],20<br/>
00100672  MOV    dword ptr [RBP + local_10],30<br/>
00100679  MOV    EAX,dword ptr [RBP + local_c]<br/>
0010067c  CDQE<br/>
0010067e  MOV    dword ptr [RBP + RAX*0x4 + -0x10],40<span class="ent">➎</span><br/>
00100686  MOV    EAX,0x0<br/>
0010068b  LEAVE<br/>
0010068c  RET</p>
<span epub:type="pagebreak" id="page_156"/>
<p class="indent">It is even more difficult to detect this array than the global array. This function appears to have six unrelated variables <span class="ent">➊</span> (<span class="literal">local_c</span>, <span class="literal">local_10</span>, <span class="literal">local_14</span>, <span class="literal">local_18</span>, <span class="literal">local_1c</span>, and <span class="literal">local_28</span>), rather than an array of three integers and an integer index variable. Two of these locals (<span class="literal">local_1c</span> and <span class="literal">local_28</span>) are the function’s two parameters, <span class="literal">argc</span> and <span class="literal">argv</span>, being saved for later use <span class="ent">➋</span>.</p>
<p class="indent">The use of constant index values tends to hide the presence of a stack-allocated array, because you see only assignments to separate local variables <span class="ent">➍</span>. Only the multiplication <span class="ent">➎</span> hints at the existence of an array with individual elements that are 4 bytes each. Let’s break down that statement further: <span class="literal">RBP</span> holds the stack frame base pointer address; <span class="literal">RAX*4</span> is the array index (converted by <span class="literal">atoi</span> and stored in <span class="literal">local_c</span> <span class="ent">➌</span>) multiplied by the size of an array element; <span class="literal">-0x10</span> is the offset to the start of the array from <span class="literal">RBP</span>.</p>
<p class="indent">The process to convert local variables to an array is a little different from creating an array in the data section of the listing. Because the stack structure information is associated with the first address in the function, you cannot select a subset of the stack variables. Instead, place the cursor on the variable at the start of the array, <span class="literal">local_18</span>, select the Set Data Type followed by the Array option from the right-click context menu, and then specify the number of elements in the array. Ghidra will display a warning message about conflict with the local variables that we are pulling into the array definition, as shown in <a href="ch08.xhtml#fig8_4">Figure 8-4</a>.</p>
<div class="image"><img src="Images/fig8-4.jpg" alt="image" width="694" height="231"/></div>
<p class="figcap" id="fig8_4"><em>Figure 8-4: Warning about potential conflict when defining stack array</em></p>
<p class="indent">If you proceed, despite the potential conflict, you will see the array in the Listing window, as shown here:</p>
<p class="programs">          ...<br/>
00100664  MOV    dword ptr [RBP + local_18[0]],10<br/>
0010066b  MOV    dword ptr [RBP + local_18[1]],20<br/>
00100672  MOV    dword ptr [RBP + local_18[2]],30<br/>
          ...</p>
<p class="indent">Even after the array is defined, the decompiler listing in <a href="ch08.xhtml#fig8_5">Figure 8-5</a> doesn’t resemble the original source code. The decompiler has omitted the static array assignments because it believes they do not contribute to the result of the function. The call to <span class="literal">atoi</span> and resulting assignment remain because Ghidra can’t compute the side effects of calling <span class="literal">atoi</span>, but Ghidra <span epub:type="pagebreak" id="page_157"/>mistakes the saved result of <span class="literal">atoi</span> as the fourth element of the array (<span class="literal">local_c</span> in the disassembly, and <span class="literal">iVar1</span> in the decompiler listing).</p>
<div class="image"><img src="Images/fig8-5.jpg" alt="image" width="577" height="354"/></div>
<p class="figcap" id="fig8_5"><em>Figure 8-5: Decompiler view of function with all stack variables after array is defined</em></p>
<h5 class="h5" id="ch08lev150"><strong>Heap-Allocated Arrays</strong></h5>
<p class="noindent"><em>Heap-allocated arrays</em> are allocated using a dynamic memory allocation function such as <span class="literal">malloc</span> (C) or <span class="literal">new</span> (C++). From the compiler’s perspective, the primary difference in dealing with a heap-allocated array is that the compiler must generate all references into the array based on the address returned from the memory allocation function. The following C program allocates a small array in the program heap:</p>
<p class="programs">int main(int argc, char **argv) {<br/>
   int *heap_array = (int*)malloc(3 * sizeof(int));<br/>
   int idx = atoi(argv[1]); //bounds check omitted for simplicity<br/>
   heap_array[0] = 10;<br/>
   heap_array[1] = 20;<br/>
   heap_array[2] = 30;<br/>
   heap_array[idx] = 40;<br/>
}</p>
<p class="indent">The corresponding disassembly is a little more complex than the two previous examples:</p>
<p class="programs">     undefined main()<br/>
        undefined     AL:1              &lt;RETURN&gt;<br/>
        undefined8    Stack[-0x10]:8    heap_array<br/>
        undefined4    Stack[-0x14]:4    local_14<br/>
        undefined4    Stack[-0x1c]:4    local_1c<br/>
        undefined8    Stack[-0x28]:8    local_28<br/>
0010068a  PUSH   RBP<br/>
0010068b  MOV    RBP,RSP<br/>
0010068e  SUB    RSP,0x20<br/>
<span epub:type="pagebreak" id="page_158"/>
00100692  MOV    dword ptr [RBP + local_1c],EDI<br/>
00100695  MOV    qword ptr [RBP + local_28],RSI<br/>
00100699  MOV    EDI,0xc<span class="ent">➊</span><br/>
0010069e  CALL    malloc<br/>
001006a3  MOV    qword ptr [RBP + heap_array],RAX<span class="ent">➋</span><br/>
001006a7  MOV    RAX,qword ptr [RBP + local_28]<br/>
001006ab  ADD    RAX,0x8<br/>
001006af  MOV    RAX,qword ptr [RAX]<br/>
001006b2  MOV    RDI,RAX<br/>
001006b5  CALL    atoi<br/>
001006ba  MOV    dword ptr [RBP + local_14],EAX<br/>
001006bd  MOV    RAX,qword ptr [RBP + heap_array]<br/>
001006c1  MOV    dword ptr [RAX],10<span class="ent">➌</span><br/>
001006c7  MOV    RAX,qword ptr [RBP + heap_array]<br/>
001006cb  ADD    RAX,0x4<span class="ent">➍</span><br/>
001006cf  MOV    dword ptr [RAX],20<br/>
001006d5  MOV    RAX,qword ptr [RBP + heap_array]<br/>
001006d9  ADD    RAX,0x8<span class="ent">➎</span><br/>
001006dd  MOV    dword ptr [RAX],30<br/>
001006e3  MOV    EAX,dword ptr [RBP + local_14]<br/>
001006e6  CDQE<br/>
001006e8  LEA    RDX,[RAX*0x4]<span class="ent">➏</span><br/>
001006f0  MOV    RAX,qword ptr [RBP + heap_array]<br/>
001006f4  ADD<span class="ent">➐</span>  RAX,RDX<br/>
001006f7  MOV    dword ptr [RAX],40<br/>
001006fd  MOV    EAX,0x0<br/>
00100702  LEAVE<br/>
00100703  RET</p>
<p class="indent">The starting address of the array (returned from <span class="literal">malloc</span> in the <span class="literal">RAX</span> register) is stored in the local variable <span class="literal">heap_array</span> <span class="ent">➋</span>. In this example, unlike the previous examples, every access to the array begins with reading the contents of <span class="literal">heap_array</span> to obtain the array’s base address. The references to <span class="literal">heap_array[0]</span>, <span class="literal">heap_array[1]</span>, and <span class="literal">heap_array[2]</span> require offsets of 0 <span class="ent">➌</span>, 4 <span class="ent">➍</span>, and 8 bytes <span class="ent">➎</span>, respectively. The variable index array access <span class="literal">heap_array[idx]</span> is implemented with multiple instructions to compute the offset into the array by multiplying the array index by the size of an array element <span class="ent">➏</span>, and adding the result to the base address of the array <span class="ent">➐</span>.</p>
<p class="indent">Heap-allocated arrays have one particularly nice feature: the number of elements allocated to the array can be computed from the total size of the array and the size of each element. The parameter passed to the memory allocation function (<span class="literal">12</span> passed to <span class="literal">malloc</span> <span class="ent">➊</span>) tells you the number of bytes allocated to the array. Dividing this by the size of an element (4 bytes in this example, as observed from the offsets <span class="ent">➌</span> <span class="ent">➍</span> <span class="ent">➎</span> , which step by 4, and the scale factor <span class="ent">➏</span>) tells us the number of elements in the array. In this example, a three-element array was allocated.</p>
<p class="indent">The decompiler was also able to recognize the array, as seen in <a href="ch08.xhtml#fig8_6">Figure 8-6</a>. (The name of the array pointer, <span class="literal">puVar2</span>, indicates that it is a pointer to an unsigned integer using the prefix <span class="literal">pu</span>.)</p>
<span epub:type="pagebreak" id="page_159"/>
<div class="image"><img src="Images/fig8-6.jpg" alt="image" width="576" height="463"/></div>
<p class="figcap" id="fig8_6"><em>Figure 8-6: Decompiler view of heap array function</em></p>
<p class="indent">In this function, unlike the stack-allocated array function, the decompiler listing shows the constant index array assignments, even though it would normally exclude them because the array is not used in other operations or returned from the function. This case is different because the assignments are <em>not</em> just manipulating stack variables: the stack variable is actually a pointer to memory that <span class="literal">malloc</span> requested from the heap. Writing via that variable does not write to the local stack variable but rather uses the stack variable to locate the allocated memory. The program may lose the pointer (address of the start of the heap array) when the function exits, but the values persist in memory. (This particular example is actually a demonstration of a memory leak. While not a good programming practice, it does allow us to demonstrate the concept of a heap array.)</p>
<p class="indent">In conclusion, arrays are easiest to recognize when a variable is used as an index into the array. The array-access operation, which requires the index to be scaled by the size of an array element before adding the resulting offset to the base address of the array, stands out in a disassembly listing.</p>
<h4 class="h4" id="ch08lev151"><strong><em>Structure Member Access</em></strong></h4>
<p class="noindent">C-style structs, referred to here generically as <em>structures</em>, group collections of (often heterogeneous) data items into a composite data type. In source code, the data fields within a structure are accessed by name rather than by index. Unfortunately, these informative field names are converted to numeric offsets by the compiler, so by the time you are looking at a disassembly, structure field access looks remarkably similar to accessing array elements using constant indices.</p>
<span epub:type="pagebreak" id="page_160"/>
<p class="indent">The following structure definition containing five heterogeneous fields will be used in the upcoming examples:</p>
<p class="programs">struct ch8_struct {     //Size  Minimum offset  Default offset<br/>
    int    field1;      //  4       0            0<br/>
    short  field2;      //  2       4            4<br/>
    char   field3;      //  1       6            6<br/>
    int    field4;      //  4       7            8<br/>
    double field5;      //  8       11           16<br/>
};                      // Minimum total size: 19 Default size: 24</p>
<p class="indent">When a compiler encounters a structure definition, the compiler maintains a running total of the number of bytes consumed by the fields of the structure to determine the offset of each field within the structure. The sum of the space required to allocate each field within a structure determines the minimum space required for the structure. However, you should never assume that a compiler utilizes the minimum required space to allocate a structure. By default, compilers align structure fields to memory addresses that allow for the most efficient reading and writing of those fields. For example, 4-byte integer fields will be aligned to offsets that are divisible by four, while 8-byte doubles will be aligned to offsets that are divisible by eight. Depending on the composition of the structure, the compiler may insert padding bytes to meet alignment requirements, meaning the actual size of a structure will be larger than the sum of its component fields. The default offsets and resulting structure size for the sample structure can be seen in the Default offset column in the comments in the preceding structure definition, and they sum to 24 rather than the minimum 19.</p>
<p class="indent">Structures can be packed into the minimum required space by using compiler options to request specific member alignments. Microsoft C/C++ and GNU <span class="literal">gcc</span>/<span class="literal">g++</span> both recognize the <span class="literal">pack</span> pragma for controlling structure field alignment. The GNU compilers additionally recognize the <span class="literal">packed</span> attribute for controlling structure alignment on a per-structure basis. Requesting 1-byte alignment for structure fields causes compilers to squeeze the structure into the minimum required space. The offsets and structure size of the sample structure are found in the Minimum offset column. (Note that some processors perform better when data is aligned according to its type, while other processors may generate exceptions if data is <em>not</em> aligned on specific boundaries.)</p>
<p class="indent">With these facts in mind, let’s look at how structures are treated in compiled code. As with arrays, access to structure members is performed by adding the base address of the structure to the offset of the desired member. However, while array offsets can be computed at runtime from a provided index value (because each element in an array has the same size), structure offsets must be computed at compile time and will turn up in compiled code as fixed offsets into the structure, looking nearly identical to array references that make use of constant indices.</p>
<p class="indent">Creating structures in Ghidra is more involved than creating arrays, so we cover that in the next section, after we show several examples of disassembled and decompiled structures.</p>
<span epub:type="pagebreak" id="page_161"/>
<h5 class="h5" id="ch08lev152"><strong>Globally Allocated Structures</strong></h5>
<p class="noindent">As with globally allocated arrays, the addresses of globally allocated structures are known at compile time. This allows the compiler to compute the address of each member of the structure at compile time and eliminates the need to do any math at runtime. Consider the following program that accesses a globally allocated structure:</p>
<p class="programs">struct ch8_struct global_struct;<br/>
int main() {<br/>
    global_struct.field1 = 10;<br/>
    global_struct.field2 = 20;<br/>
    global_struct.field3 = 30;<br/>
    global_struct.field4 = 40;<br/>
    global_struct.field5 = 50.0;<br/>
}</p>
<p class="indent">If this program is compiled with default structure alignment options, we can expect to see something like the following when we disassemble it:</p>
<p class="programs">     undefined main()<br/>
        undefined     AL:1              &lt;RETURN&gt;<br/>
001005fa  PUSH   RBP<br/>
001005fb  MOV    RBP,RSP<br/>
001005fe  MOV    dword ptr [DAT_00301020],10<br/>
00100608  MOV    word ptr [DAT_00301024],20<br/>
00100611  MOV    byte ptr [DAT_00301026],30<br/>
00100618  MOV    dword ptr [DAT_00301028],40<br/>
00100622  MOVSD  XMM0,qword ptr [DAT_001006c8]<br/>
0010062a  MOVSD  qword ptr [DAT_00301030],XMM0<br/>
00100632  MOV    EAX,0x0<br/>
00100637  POP    RBP<br/>
00100638  RET</p>
<p class="indent">This disassembly contains no math whatsoever to access the members of the structure, and, in the absence of source code, it would not be possible to state with any certainty that a structure is being used at all. Because the compiler has performed all of the offset computations at compile time, this program appears to reference five global variables rather than five fields within a single structure. You should be able to note the similarities with the previous example of globally allocated arrays using constant index values.</p>
<p class="indent">In <a href="ch08.xhtml#fig8_2">Figure 8-2</a>, the uniform offsets coupled with the values allowed us to surmise (accurately) that we were dealing with an array. In this example, we are correct to conclude that we are not dealing with an array because the size of the variables is nonuniform (<span class="literal">dword</span>, <span class="literal">word</span>, <span class="literal">byte</span>, <span class="literal">dword</span>, and <span class="literal">qword</span>, respectively), but we lack sufficient evidence to assert that we are dealing with a struct.</p>
<span epub:type="pagebreak" id="page_162"/>
<h5 class="h5" id="ch08lev153"><strong>Stack-Allocated Structures</strong></h5>
<p class="noindent">Like stack-allocated arrays, stack-allocated structures are challenging to recognize based on stack layout alone, and the decompiler doesn’t provide additional insight. Modifying the preceding program to use a stack-allocated structure, declared in <span class="literal">main</span>, yields the following disassembly:</p>
<p class="programs">     undefined main()<br/>
        undefined     AL:1              &lt;RETURN&gt;<br/>
        undefined8    Stack[-0x18]:8    local_18<br/>
        undefined4    Stack[-0x20]:4    local_20<br/>
        undefined1    Stack[-0x22]:1    local_22<br/>
        undefined2    Stack[-0x24]:2    local_24<br/>
        undefined4    Stack[-0x28]:4    local_28<br/>
001005fa  PUSH   RBP<br/>
001005fb  MOV    RBP,RSP<br/>
001005fe  MOV    dword ptr [RBP + local_28],10<br/>
00100605  MOV    word ptr [RBP + local_24],20<br/>
0010060b  MOV    byte ptr [RBP + local_22],30<br/>
0010060f  MOV    dword ptr [RBP + local_20],40<br/>
00100616  MOVSD  XMM0,qword ptr [DAT_001006b8]<br/>
0010061e  MOVSD  qword ptr [RBP + local_18],XMM0<br/>
00100623  MOV    EAX,0x0<br/>
00100628  POP    RBP<br/>
00100629  RET</p>
<p class="indent">Again, no math is performed to access the structure’s fields since the compiler can determine the relative offsets for each field within the stack frame at compile time, and we are left with the same, potentially misleading picture that five individual variables are being used rather than a single variable that happens to contain five distinct fields. In reality, <span class="literal">local_28</span> should be the start of a 24-byte structure, and each of the other variables should somehow be formatted to reflect the fact that they are fields within the structure.</p>
<h5 class="h5" id="ch08lev154"><strong>Heap-Allocated Structures</strong></h5>
<p class="noindent">Heap-allocated structures reveal much more about the size of the structure and the layout of its fields. When a structure is allocated in the program heap, the compiler has no choice but to generate code to compute the proper field address whenever a field is accessed, because the structure’s address is unknown at compile time. For globally allocated structures, the compiler is able to compute a fixed starting address. For stack-allocated structures, the compiler can compute a fixed relationship between the start of the structure and the frame pointer for the enclosing stack frame. When a structure has been allocated in the heap, the only reference to the structure available to the compiler is the pointer to the structure’s starting address.</p>
<span epub:type="pagebreak" id="page_163"/>
<p class="indent">To demonstrate heap-allocated structures, we modify the sample program to declare a pointer within <span class="literal">main</span> and assign it the address of a block of memory large enough to hold the structure:</p>
<p class="programs">int main() {<br/>
    struct ch8_struct *heap_struct;<br/>
    heap_struct = (struct ch8_struct*)malloc(sizeof(struct ch8_struct));<br/>
    heap_struct-&gt;field1 = 10;<br/>
    heap_struct-&gt;field2 = 20;<br/>
    heap_struct-&gt;field3 = 30;<br/>
    heap_struct-&gt;field4 = 40;<br/>
    heap_struct-&gt;field5 = 50.0;<br/>
}</p>
<p class="indent">Here is the corresponding disassembly:</p>
<p class="programs">     undefined main()<br/>
        undefined     AL:1              &lt;RETURN&gt;<br/>
        undefined8    Stack[-0x10]:8    heap_struct<br/>
0010064a  PUSH   RBP<br/>
0010064b  MOV    RBP,RSP<br/>
0010064e  SUB    RSP,16<br/>
00100652  MOV    EDI,24<span class="ent">➊</span><br/>
00100657  CALL   malloc<br/>
0010065c  MOV    qword ptr [RBP + heap_struct],RAX<br/>
00100660  MOV    RAX,qword ptr [RBP + heap_struct]<br/>
00100664  MOV    dword ptr [RAX],10<span class="ent">➋</span><br/>
0010066a  MOV    RAX,qword ptr [RBP + heap_struct]<br/>
0010066e  MOV    word ptr [RAX + 4],20<span class="ent">➌</span><br/>
00100674  MOV    RAX,qword ptr [RBP + heap_struct]<br/>
00100678  MOV    byte ptr [RAX + 6],30<span class="ent">➍</span><br/>
0010067c  MOV    RAX,qword ptr [RBP + heap_struct]<br/>
00100680  MOV    dword ptr [RAX + 8],40<span class="ent">➎</span><br/>
00100687  MOV    RAX,qword ptr [RBP + heap_struct]<br/>
0010068b  MOVSD  XMM0,qword ptr [DAT_00100728]<br/>
00100693  MOVSD  qword ptr [RAX + 16],XMM0<span class="ent">➏</span><br/>
00100698  MOV    EAX,0x0<br/>
0010069d  LEAVE<br/>
0010069e  RET</p>
<p class="indent">In this example, we can discern the exact size and layout of the structure. The structure size can be inferred to be 24 bytes based on the amount of memory requested from <span class="literal">malloc</span> <span class="ent">➊</span>. The structure contains the following fields at the indicated offsets:</p>
<ul>
<li class="noindent">A 4-byte (<span class="literal">dword</span>) field at offset 0 <span class="ent">➋</span></li>
<li class="noindent">A 2-byte (<span class="literal">word</span>) field at offset 4 <span class="ent">➌</span></li>
<li class="noindent">A 1-byte field at offset 6 <span class="ent">➍</span></li>
<li class="noindent">A 4-byte (<span class="literal">dword</span>) field at offset 8 <span class="ent">➎</span></li>
<li class="noindent">An 8-byte (<span class="literal">qword</span>) field at offset 16 <span class="ent">➏</span></li>
</ul>
<span epub:type="pagebreak" id="page_164"/>
<p class="indent">Based on the use of floating point instructions (<span class="literal">MOVSD</span>), we can further deduce that the <span class="literal">qword</span> field is actually a <span class="literal">double</span>.</p>
<p class="indent">The same program compiled to pack structures with a 1-byte alignment yields the following disassembly:</p>
<p class="programs">0010064a  PUSH    RBP<br/>
0010064e  SUB    RSP,16<br/>
00100652  MOV    EDI,19<br/>
00100657  CALL   malloc<br/>
0010065c  MOV    qword ptr [RBP + local_10],RAX<br/>
00100660  MOV    RAX,qword ptr [RBP + local_10]<br/>
00100664  MOV    dword ptr [RAX],10<br/>
0010066a  MOV    RAX,qword ptr [RBP + local_10]<br/>
0010066e  MOV    word ptr [RAX + 4],20<br/>
00100674  MOV    RAX,qword ptr [RBP + local_10]<br/>
00100678  MOV    byte ptr [RAX + 6],30<br/>
0010067c  MOV    RAX,qword ptr [RBP + local_10]<br/>
00100680  MOV    dword ptr [RAX + 7],40<br/>
00100687  MOV    RAX,qword ptr [RBP + local_10]<br/>
0010068b  MOVSD  XMM0,qword ptr [DAT_00100728] =<br/>
00100693  MOVSD  qword ptr [RAX + 11],XMM0<br/>
00100698  MOV    EAX,0x0<br/>
0010069d  LEAVE<br/>
0010069e  RET</p>
<p class="indent">The only changes are the smaller structure size (now 19 bytes) and the adjusted offsets to account for the realignment of each structure field.</p>
<p class="indent">Regardless of the alignment used when compiling a program, finding structures allocated and manipulated in the program heap is the fastest way to determine the size and layout of a given data structure. However, keep in mind that many functions will not do you the favor of immediately accessing every member of a structure to help you understand the structure’s layout. Instead, you may need to follow the use of the pointer to the structure and make note of the offsets used whenever that pointer is dereferenced, and eventually piece together the complete layout of the structure. In “<a href="ch19.xhtml#ch19lev360">Example 3: Automated Structure Creation</a>” on <a href="ch19.xhtml#page_437">page 437</a>, you’ll see how the decompiler can automate this process for you.</p>
<h5 class="h5" id="ch08lev155"><strong>Arrays of Structures</strong></h5>
<p class="noindent">Some programmers say that the beauty of composite data structures is that they allow you to build arbitrarily complex structures by nesting smaller structures within larger structures: arrays of structures, structures within structures, and structures that contain arrays as members, for example. The preceding discussions regarding arrays and structures apply just as well to such nested types. As an example, consider the following simple program in which <span class="literal">heap_struct</span> points to an array of five <span class="literal">ch8_struct</span> items:</p>
<p class="programs">int main() {<br/>
    int idx = 1;<br/>
    struct ch8_struct *heap_struct;<br/>
<span epub:type="pagebreak" id="page_165"/>
    heap_struct = (struct ch8_struct*)malloc(sizeof(struct ch8_struct) * 5);<br/>
    heap_struct[idx].field1 = 10;<br/>
}</p>
<p class="indent">Underneath the hood, accessing <span class="literal">field1</span> involves multiplying the index value by the size of an array element (in this case, the size of the structure) and then adding the offset to the desired field. The corresponding disassembly is shown here:</p>
<p class="programs">     undefined main()<br/>
        undefined     AL:1              &lt;RETURN&gt;<br/>
        undefined4    Stack[-0xc]:4     idx<br/>
        undefined4    Stack[-0x18]:8    heap_struct<br/>
0010064a  PUSH   RBP<br/>
0010064b  MOV    RBP,RSP<br/>
0010064e  SUB    RSP,16<br/>
00100652  MOV    dword ptr [RBP + idx],1<br/>
00100659  MOV<span class="ent">➊</span>  EDI,120<br/>
0010065e  CALL   malloc<br/>
00100663  MOV    qword ptr [RBP + heap_struct],RAX<br/>
00100667  MOV    EAX,dword ptr [RBP + idx]<br/>
0010066a  MOVSXD RDX,EAX<br/>
0010066d  MOV<span class="ent">➋</span>  RAX,RDX<br/>
00100670  ADD    RAX,RAX<br/>
00100673  ADD    RAX,RDX<br/>
00100676  SHL<span class="ent">➌</span>  RAX,3<br/>
0010067a  MOV    RDX,RAX<br/>
0010067d  MOV    RAX,qword ptr [RBP + heap_struct]<br/>
00100681  ADD<span class="ent">➍</span>  RAX,RDX<br/>
00100684  MOV<span class="ent">➎</span>  dword ptr [RAX],10<br/>
0010068a  MOV    EAX,0<br/>
0010068f  LEAVE<br/>
00100690  RET</p>
<p class="indent">The function allocates 120 bytes <span class="ent">➊</span> in the heap. The array index in <span class="literal">RAX</span> is multiplied by 24 using a series of operations <span class="ent">➋</span>, ending with <span class="literal">SHL RAX, 3</span> <span class="ent">➌</span> before being added to the start address for the array <span class="ent">➍</span>. (If it is not readily apparent to you that the series of operations starting at <span class="ent">➋</span> is equivalent to multiplication by 24, don’t worry. Code sequences such as this are discussed in <a href="ch20.xhtml#ch20">Chapter 20</a>.) Because <span class="literal">field1</span> is the first member of the struct, no additional offset is required in order to generate the final address for the assignment into <span class="literal">field1</span> <span class="ent">➎</span>.</p>
<p class="indent">From these facts, we can deduce the size of an array item (24), the number of items in the array (120 / 24 = 5), and the fact that there is a 4-byte (<span class="literal">dword</span>) field at offset 0 within each array element. This short listing does not offer enough information to draw any conclusions about how the remaining 20 bytes within each structure are allocated to additional fields. The size of the array can be even more easily deduced using the same formula from the decompiler listing in <a href="ch08.xhtml#fig8_7">Figure 8-7</a> (0x18 hex is 24 decimal).</p>
<span epub:type="pagebreak" id="page_166"/>
<div class="image"><img src="Images/fig8-7.jpg" alt="image" width="532" height="331"/></div>
<p class="figcap" id="fig8_7"><em>Figure 8-7: Decompiler view of function with heap-allocated struct array</em></p>
<h3 class="h3" id="ch08lev156"><strong>Creating Structures with Ghidra</strong></h3>
<p class="noindent">In the preceding chapter, you saw how to use Ghidra’s array-aggregation capabilities to collapse long lists of data declarations into a single disassembly line representing an array. The next few sections explore Ghidra’s facilities for improving the readability of code that manipulates structures. Our goal is to move away from cryptic structure references such as <span class="literal">[EDX + 10h]</span> and toward something more readable like <span class="literal">[EDX + ch8_struct.field_e]</span>.</p>
<p class="indent">Whenever you discover that a program is manipulating a data structure, you need to decide whether you want to incorporate structure field names into your disassembly or whether you can make sense of all the numeric offsets sprinkled throughout the listing. In some cases, Ghidra may recognize the use of a structure defined as part of the C standard library or the Windows API and use its knowledge of the exact layout of the structure to convert numeric offsets into symbolic field names. This is the ideal case, as it leaves you with a lot less work to do. We will return to this scenario once you understand a little more about how Ghidra deals with structure definitions in general.</p>
<h4 class="h4" id="ch08lev157"><strong><em>Creating a New Structure</em></strong></h4>
<p class="noindent">When Ghidra has no layout knowledge for a structure, you can create the structure by selecting the data and using the right-click context menu. When you select Data ▸ Create Structure (or use the hotkey <span class="smallcaps">SHIFT</span>-[), you will see the Create Structure window shown in <a href="ch08.xhtml#fig8_8">Figure 8-8</a>. Since you have highlighted a block of data (which could be defined or undefined), Ghidra will try to identify existing structures that have a matching format or the same size. You can select one of the existing structures from the window or create a new structure. In this example, we are using the globally allocated structure sample code discussed previously and are creating a new structure <span epub:type="pagebreak" id="page_167"/>called <span class="literal">ch8_struct</span>. As soon as you click OK, the structure becomes an official type in the Data Type Manager window and the information is propagated to other CodeBrowser windows.</p>
<div class="image"><img src="Images/fig8-8.jpg" alt="image" width="694" height="459"/></div>
<p class="figcap" id="fig8_8"><em>Figure 8-8: Create Structure window</em></p>
<p class="indent">Let’s look at the effect of this creation on the associated CodeBrowser windows, starting with the Listing window. As shown earlier in the chapter, the disassembly listing gives you few hints that you might be dealing with a structure, because the code modifies a series of seemingly unrelated global variables:</p>
<p class="programs">001005fa  PUSH   RBP<br/>
001005fb  MOV    RBP,RSP<br/>
001005fe  MOV    dword ptr [DAT_00301020],10<br/>
00100608  MOV    word ptr [DAT_00301024],20<br/>
00100611  MOV    byte ptr [DAT_00301026],30<br/>
00100618  MOV    dword ptr [DAT_00301028],40<br/>
00100622  MOVSD  XMM0,qword ptr [DAT_001006c8]<br/>
0010062a  MOVSD  qword ptr [DAT_00301030],XMM0<br/>
00100632  MOV    EAX,0<br/>
00100637  POP    RBP<br/>
00100638  RET</p>
<p class="indent">When you navigate to the associated data items, select the range (<span class="literal">00301020</span> through <span class="literal">00301037</span>), and create the associated structure, you see the individual data items in the structure are now associated with a structure called <span class="literal">ch8_struct</span><span class="literal">_00301020</span>, and each item in the structure has the name <span class="literal">field_</span> concatenated with its offset from the first element in the structure.</p>
<span epub:type="pagebreak" id="page_168"/>
<p class="programs">00401035  POP    EBP<br/>
001005fb  MOV    RBP,RSP<br/>
001005fe  MOV    dword ptr [ch8_struct_00301020],10<br/>
00100608  MOV    word ptr [ch8_struct_00301020.field_0x4],20<br/>
00100611  MOV    byte ptr [ch8_struct_00301020.field_0x6],30<br/>
00100618  MOV    dword ptr [ch8_struct_00301020.field_0x8],40<br/>
00100622  MOVSD  XMM0,qword ptr [DAT_001006c8]<br/>
0010062a  MOVSD  qword ptr [ch8_struct_00301020.field_0x10],XMM0<br/>
00100632  MOV    EAX,0<br/>
00100637  POP    RBP<br/>
00100638  RET</p>
<p class="indent">This is just one of the windows that changes with the creation of the structure. Recall that the Decompiler window gave us a helpful warning that we might be working with a structure or array. After we create the structure, the warning disappears and the decompiled code more closely resembles the original C code, as shown in <a href="ch08.xhtml#fig8_9">Figure 8-9</a>.</p>
<div class="image"><img src="Images/fig8-9.jpg" alt="image" width="597" height="356"/></div>
<p class="figcap" id="fig8_9"><em>Figure 8-9: Decompiler view after struct is created</em></p>
<div class="box5">
<p class="boxtitle-c"><strong>STATE OF THE UNION</strong></p>
<p class="noindent">A <em>union</em> is a construct that is similar to a structure. The major difference between structures and unions is that structure fields have unique offsets and their own dedicated memory space, whereas union fields all overlap one another beginning at offset 0. The result is that all union fields share the same memory space. The Union Editor window in Ghidra looks similar to the Structure Editor window, and the functionality is basically the same.</p>
</div>
<span epub:type="pagebreak" id="page_169"/>
<p class="indent">The new structure also now appears as an entry in the Data Type Manager window in the CodeBrowser. <a href="ch08.xhtml#fig8_10">Figure 8-10</a> shows the new entry in the Data Type Manager window and the associated window showing all uses of <span class="literal">ch8_struct</span>.</p>
<div class="image"><img src="Images/fig8-10.jpg" alt="image" width="694" height="399"/></div>
<p class="figcap" id="fig8_10"><em>Figure 8-10: Newly declared structure in Data Type Manager and References windows</em></p>
<h4 class="h4" id="ch08lev158"><strong><em>Editing Structure Members</em></strong></h4>
<p class="noindent">At this point, Ghidra presents the newly created structure as a contiguous collection of undefined bytes with cross-references at each offset accessed by the example program, instead of a collection of defined data types (which you have identified from the size of each item and the way it is being used). To define the type of each field, you can edit the structure from the Listing window by right-clicking and selecting the appropriate Data option. Alternatively, you can edit the structure from within the Data Type Manager by double-clicking the structure.</p>
<p class="indent">If you double-click the newly created structure in the Data Type Manager window (shown in <a href="ch08.xhtml#fig8_10">Figure 8-10</a>), the Structure Editor window (shown in <a href="ch08.xhtml#fig8_11">Figure 8-11</a>) opens to show 24 elements of undefined type, all with a length of 1. To determine the number, sizes, and types of the individual elements within the structure, you could study the disassembly, or you could let the decompiler listing shown earlier in <a href="ch08.xhtml#fig8_9">Figure 8-9</a> provide the answers.</p>
<span epub:type="pagebreak" id="page_170"/>
<div class="image"><img src="Images/fig8-11.jpg" alt="image" width="694" height="602"/></div>
<p class="figcap" id="fig8_11"><em>Figure 8-11: Structure Editor window</em></p>
<p class="indent">The original decompiler listing associated with our newly created structure shows that five items are referenced within the same structure, <span class="literal">ch8_struct</span><span class="literal">_00301020</span>, using field names containing two integers. The first integer represents the offset from the base address of the structure. The second shows the number of bytes used, which is a good indicator of the size of the item. Using this information (and some meaningful field names), you can update the Structure Editor window, as shown in <a href="ch08.xhtml#fig8_12">Figure 8-12</a>. The Byte Offset/Component Bits scroll bar within the Structure Editor provides a visual representation of the structure. When a structure is edited, the Decompiler window (on the left of <a href="ch08.xhtml#fig8_12">Figure 8-12</a>), the Listing window, and other associated windows are also updated.</p>
<p class="indent">Because <span class="literal">field_c</span> is a character, the decompiler converted the integer 30 into the ASCII character represented by 30 (0x1e), which is an unprintable control character (RS). In the Structure Editor, the padding bytes (indicated by the mnemonic <span class="literal">??</span>) have been included for proper field alignment, and the offsets to each field and the overall size (24 bytes) of the structure match the values seen in the earlier examples.</p>
<span epub:type="pagebreak" id="page_171"/>
<div class="image"><img src="Images/fig8-12.jpg" alt="image" width="694" height="526"/></div>
<p class="figcap" id="fig8_12"><em>Figure 8-12: Decompiler and Structure Editor windows after editing structure</em></p>
<h4 class="h4" id="ch08lev159"><strong><em>Applying Structure Layouts</em></strong></h4>
<p class="noindent">You have seen how to use existing structure definitions and create new ones to associate existing memory with a particular memory layout. You have also seen how that association is propagated through the CodeBrowser windows to make the contents clearer. Vague memory references such as <span class="literal">[EBX+8]</span> become more readable by converting numeric structure offsets into symbolic references such as <span class="literal">[EBX+ch8_struct.field_d]</span>, especially because symbolic references can be given meaningful names. Ghidra’s use of a hierarchical notation makes it clear exactly what type of structure, and exactly which field within that structure, is being accessed.</p>
<p class="indent">Ghidra’s library of known structure layouts has been populated with information gathered by parsing common C header files. The layout of a structure defines its total size, the name and size of each field, and the starting offset of each field within the structure. You can use structure layouts even without associated content in the data section, which is especially helpful when dealing with structure pointers.</p>
<p class="indent">Anytime you encounter a memory reference in the form <span class="literal">[reg+N]</span> (for example, <span class="literal">[RAX+0x12]</span>), where <span class="literal">reg</span> is a register name and <span class="literal">N</span> is a small constant, <span class="literal">reg</span> is being used as a pointer and <span class="literal">N</span> represents an offset into the memory that <span class="literal">reg</span> points to. This is a common pattern for structure member access, with <span class="literal">reg</span> pointing to the beginning of the structure and <span class="literal">N</span> selecting the field at structure offset <span class="literal">N</span>. Under some circumstances, Ghidra, with your assistance, can clean up this type of memory reference to reflect both the type <span epub:type="pagebreak" id="page_172"/>of structure being pointed to and the specific field within that structure that is being referenced.</p>
<p class="indent">Let’s look at the 32-bit version of the example from the beginning of the chapter, where we were requesting an HTTP page from a server. The request is made by a function named <span class="literal">get_page</span>. In this version of the binary, Ghidra asserts that the function receives three stack-allocated parameters. These parameters appear in the Listing window as follows:</p>
<p class="programs">     undefined get_page(undefined4 param_1, undefined param_2...<br/>
        undefined     AL:1              &lt;RETURN&gt;<br/>
        undefined4    Stack[0x4]:4      param_1<br/>
        undefined     Stack[0x8]:1      param_2<br/>
        undefined4    Stack[0xc]:4      param_3</p>
<p class="indent">The Decompiler window shows that <span class="literal">param_3</span> is used with some offsets in a call to <span class="literal">connect</span>:</p>
<p class="programs">iVar1=connect(local_14,*(sockaddr **)(param_3+20),*(socklen_t*)(param_3+16));</p>
<p class="indent">Tracing through the calling sequence and the return values from the called functions, we can conclude that <span class="literal">param_3</span> is a pointer to an <span class="literal">addrinfo</span> struct and retype <span class="literal">param_3</span> as an <span class="literal">addrinfo*</span> (using <span class="smallcaps">CTRL-</span>L from the Listing or Decompiler window). The decompiled statement using <span class="literal">param_3</span> will be replaced with the far more informative statement shown here:</p>
<p class="programs">iVar1 = connect(local_14, param_3-&gt;ai_addr, param_3-&gt;ai_addrlen);</p>
<p class="indent">You can see that pointer arithmetic has been replaced by structure field references. Pointer arithmetic in source code is rarely self-explanatory. Any effort you spend updating data types for program variables will be well worth it. You’ll have saved your colleagues the time required to deduce the type of <span class="literal">param_3</span> themselves, and you’ll thank yourself upon returning from two weeks at the beach that you don’t need to reanalyze the code to relearn the type of that variable that you forgot to update.</p>
<h3 class="h3" id="ch08lev160"><strong>C++ Reversing Primer</strong></h3>
<p class="noindent">C++ classes are the object-oriented extensions of C structs, so it is somewhat logical to wrap up our discussion of data structures by reviewing the features of compiled C++ code. Detailed coverage of C++ is beyond the scope of this book. Here, we attempt to cover the highlights and a few of the differences between Microsoft’s C++ compiler and GNU’s <span class="literal">g++.</span></p>
<p class="indent">Remember that a solid, fundamental understanding of the C++ language will assist you greatly in understanding compiled C++. Object-oriented concepts such as inheritance and polymorphism are difficult enough to master at the source level. Attempting to dive into these concepts at the assembly level without understanding them at the source level can be an exercise in frustration.</p>
<span epub:type="pagebreak" id="page_173"/>
<h4 class="h4" id="ch08lev161"><strong><em>The this Pointer</em></strong></h4>
<p class="noindent">The <span class="literal">this</span> pointer is available in all nonstatic C++ member functions. Whenever such a function is called, <span class="literal">this</span> is initialized to point to the object used to invoke the function. Consider the following function calls in C++:</p>
<p class="programs">// object1, object2, and *p_obj are all the same type.<br/>
object1.member_func();<br/>
object2.member_func();<br/>
p_obj-&gt;member_func();</p>
<p class="indent">In the three calls to <span class="literal">member_func</span>, <span class="literal">this</span> takes on the values <span class="literal">&amp;object1</span>, <span class="literal">&amp;object2</span>, and <span class="literal">p_obj</span>, respectively.</p>
<p class="indent">It is easiest to view <span class="literal">this</span> as a hidden first parameter passed in to all non-static member functions. As discussed in <a href="ch06.xhtml#ch06">Chapter 6</a>, the Microsoft C++ compiler utilizes the <span class="literal">thiscall</span> calling convention and passes <span class="literal">this</span> in the <span class="literal">ECX</span> register (x86) or the <span class="literal">RCX</span> register (x86-x64). The GNU <span class="literal">g++</span> compiler treats <span class="literal">this</span> exactly as if it were the first (leftmost) parameter to nonstatic member functions. On 32-bit Linux x86, the address of the object used to invoke the function is pushed as the topmost item on the stack prior to calling the function. On Linux x86-64, <span class="literal">this</span> is passed in the first register parameter, <span class="literal">RDI</span>.</p>
<p class="indent">From a reverse engineering point of view, moving an address into the <span class="literal">ECX</span> register immediately before a function call is a probable indicator of two things. First, the file was compiled using Microsoft’s C++ compiler. Second, the function is possibly a member function. When the same address is passed to two or more functions, we can conclude that those functions all belong to the same class hierarchy.</p>
<p class="indent">Within a function, the use of <span class="literal">ECX</span> prior to initializing it implies that the caller must have initialized <span class="literal">ECX</span> (recall the discussion of <em>liveness</em> from “<a href="ch06.xhtml#ch06sb01">Register-Based Parameters</a>” on <a href="ch06.xhtml#page_113">page 113</a>) and is a possible sign that the function is a member function (though the function may simply use the <span class="literal">fastcall</span> calling convention). Further, when a member function passes <span class="literal">this</span> to additional functions, those functions can be inferred to be members of the same class as well.</p>
<p class="indent">For code compiled using GNU <span class="literal">g++</span>, calls to member functions stand out somewhat less because <span class="literal">this</span> looks a lot like any other first parameter. However, any function that does not take a pointer as its first argument can certainly be ruled out as a member function.</p>
<h4 class="h4" id="ch08lev162"><strong><em>Virtual Functions and Vftables</em></strong></h4>
<p class="noindent"><em>Virtual functions</em> enable polymorphic behavior in C++ programs. For each class (or subclass through inheritance) that contains virtual functions, the compiler generates a table containing pointers to each virtual function in the class. Such tables are called <em>vftables</em> (also <em>vtables</em>). Every instance of a class that contains virtual functions is given an additional data member that points to the class’s vftable. The <em>vftable pointer</em> is allocated as the first data member within the class instance, and when an object is created at runtime, its constructor function sets its vftable pointer to point at the appropriate <span epub:type="pagebreak" id="page_174"/>vftable. When that object invokes a virtual function, the correct function is selected by performing a lookup in the object’s vftable. Thus, vftables are the underlying mechanism that facilitates runtime resolution of calls to virtual functions.</p>
<p class="indent">A few examples may help to clarify the use of vftables. Consider the following C++ class definitions:</p>
<p class="programs">class BaseClass {<br/>
    public:<br/>
        BaseClass();<br/>
     <span class="ent">➊</span> virtual void vfunc1() = 0<span class="ent">➋</span>;<br/>
        virtual void vfunc2();<br/>
        virtual void vfunc3();<br/>
        virtual void vfunc4();<br/>
    private:<br/>
        int x;<br/>
        int y;<br/>
};<br/>
class SubClass : public BaseClass<span class="ent">➌</span> {<br/>
    public:<br/>
        SubClass();<br/>
     <span class="ent">➍</span> virtual void vfunc1();<br/>
        virtual void vfunc3();<br/>
        virtual void vfunc5();<br/>
    private:<br/>
        int z;<br/>
};</p>
<p class="indent">In this case, <span class="literal">SubClass</span> inherits from <span class="literal">BaseClass</span> <span class="ent">➌</span>. <span class="literal">BaseClass</span> contains four virtual functions <span class="ent">➊</span>, while <span class="literal">SubClass</span> contains five <span class="ent">➍</span> (four from <span class="literal">BaseClass</span>, two of which it overrides, plus the new <span class="literal">vfunc5</span>). Within <span class="literal">BaseClass</span>, <span class="literal">vfunc1</span> is a <em>pure virtual function</em>, indicated by <span class="literal">= 0</span> <span class="ent">➋</span> in its declaration. Pure virtual functions have no implementation in their declaring class and <em>must</em> be overridden in a subclass before the class is considered concrete. In other words, there is no function named <span class="literal">BaseClass::vfunc1</span>, and until a subclass provides an implementation, no objects can be instantiated. <span class="literal">SubClass</span> provides such an implementation, so <span class="literal">SubClass</span> objects can be created. In object-oriented terms, <span class="literal">BaseClass::vfunc1</span> is an <em>abstract function</em>, which makes <span class="literal">BaseClass</span> an <em>abstract base class</em> (that is, an incomplete class that cannot be directly instantiated since it is missing an implementation for at least one function).</p>
<p class="indent">At first glance, <span class="literal">BaseClass</span> appears to contain two data members, and <span class="literal">SubClass</span> three data members. Recall, however, that any class that contains virtual functions, either explicitly or because they are inherited, also contains a vftable pointer. As a result, the compiled implementation of <span class="literal">BaseClass</span> has three data members, while instantiated <span class="literal">SubClass</span> objects have four data members. In each case, the first data member is the vftable pointer. Within <span class="literal">SubClass</span>, the vftable pointer is actually inherited from <span class="literal">BaseClass</span> rather than being introduced specifically for <span class="literal">SubClass</span>. You can see this in the simplified memory layout in <a href="ch08.xhtml#fig8_13">Figure 8-13</a>, in which a single <span class="literal">SubClass</span> object has been dynamically allocated. During the creation of the object, the new object’s vftable pointer is initialized to point to the correct vftable (<span class="literal">SubClass</span>’s in this case).</p>
<span epub:type="pagebreak" id="page_175"/>
<div class="image"><img src="Images/fig8-13.jpg" alt="image" width="475" height="350"/></div>
<p class="figcap" id="fig8_13"><em>Figure 8-13: A simple vftable layout</em></p>
<p class="indent">The vftable for <span class="literal">SubClass</span> contains two pointers to functions belonging to <span class="literal">BaseClass</span> (<span class="literal">BaseClass::vfunc2</span> and <span class="literal">BaseClass::vfunc4</span>) because <span class="literal">SubClass</span> does not override either of these functions and instead inherits them from <span class="literal">BaseClass</span>. The vftable for <span class="literal">BaseClass</span> shows how pure virtual functions are handled. Because there is no implementation for the pure virtual function <span class="literal">BaseClass::vfunc1</span>, no address is available to store in the <span class="literal">BaseClass</span> vftable slot for <span class="literal">vfunc1</span>. In such cases, compilers insert the address of an error-handling function, dubbed <span class="literal">purecall</span> in Microsoft libraries and <span class="literal">__cxa_pure_virtual</span> in GNU libraries. In theory, these functions should never be called, but in the event that they are, they cause the program to be terminated abnormally.</p>
<p class="indent">You must account for the vftable pointer when you manipulate classes within Ghidra. Because C++ classes are extensions of C structures, you can use Ghidra’s structure definition features to define the layout of C++ classes. With polymorphic classes, you must include a vftable pointer as the first field within the class as well as account for the vftable pointer in the total size of the object. This is most apparent when observing the dynamic allocation of an object using the <span class="literal">new</span> operator, where the size value passed to <span class="literal">new</span> includes the space needed by all explicitly declared fields in the class (and any superclasses) as well as any space required for a vftable pointer.</p>
<p class="indent">In the following example, a <span class="literal">SubClass</span> object is created dynamically and its address saved in a <span class="literal">BaseClass</span> pointer. The pointer is then passed to a function (<span class="literal">call_vfunc</span>), which uses the pointer to call <span class="literal">vfunc3</span>:</p>
<p class="programs">void call_vfunc(BaseClass *bc) {<br/>
    bc-&gt;vfunc3();<br/>
}<br/>
int main() {<br/>
    BaseClass *bc = new Subclass();<br/>
    call_vfunc(bc);<br/>
}</p>
<span epub:type="pagebreak" id="page_176"/>
<p class="indent">Since <span class="literal">vfunc3</span> is a virtual function and <span class="literal">bc</span> points to a <span class="literal">SubClass</span> object, the compiler must ensure that <span class="literal">SubClass::vfunc3</span> is called. The following disassembly of a 32-bit, Microsoft C++ version of <span class="literal">call_vfunc</span> demonstrates how the virtual function call is resolved:</p>
<p class="programs">     undefined __cdecl call_vfunc(int * bc)<br/>
        undefined     AL:1              &lt;RETURN&gt;<br/>
        int *         Stack[0x4]:4      bc<br/>
004010a0  PUSH   EBP<br/>
004010a1  MOV    EBP,ESP<br/>
004010a3  MOV    EAX,dword ptr [EBP + bc]<br/>
004010a6  MOV<span class="ent">➊</span>  EDX,dword ptr [EAX]<br/>
004010a8  MOV<span class="ent">➋</span>  ECX,dword ptr [EBP + bc]<br/>
004010ab  MOV<span class="ent">➌</span>  EAX,dword ptr [EDX + 8]<br/>
004010ae  CALL<span class="ent">➍</span> EAX<br/>
004010b0  POP    EBP<br/>
004010b1  RET</p>
<p class="indent">The vftable pointer (the address of <span class="literal">SubClass</span>’s vftable) is read from the structure and saved in <span class="literal">EDX</span> <span class="ent">➊</span>. Next, the <span class="literal">this</span> pointer is moved into <span class="literal">ECX</span> <span class="ent">➋</span>. Then, the vftable is indexed to read the third pointer (the address of <span class="literal">SubClass::vfunc3</span> in this case) into the <span class="literal">EAX</span> register <span class="ent">➌</span>. Finally, the virtual function is called <span class="ent">➍</span>.</p>
<p class="indent">The vftable indexing operation <span class="ent">➌</span> looks very much like a structure reference operation. In fact, it is no different, and it is possible to define new structures for the class and its vftable (right-click in the Data Type Manager window) and then use the defined structures (see <a href="ch08.xhtml#fig8_14">Figure 8-14</a>) to make the disassembly and decompilation more readable.</p>
<div class="image"><img src="Images/fig8-14.jpg" alt="image" width="694" height="282"/></div>
<p class="figcap" id="fig8_14"><em>Figure 8-14: Data Manager Window showing new</em> <span class="codeitalic">SubClass</span> <em>and</em> <span class="codeitalic">SubClass_vftable</span></p>
<p class="indent">The Decompiler window with references to the new structures is shown in <a href="ch08.xhtml#fig8_15">Figure 8-15</a>.</p>
<span epub:type="pagebreak" id="page_177"/>
<div class="image"><img src="Images/fig8-15.jpg" alt="image" width="473" height="244"/></div>
<p class="figcap" id="fig8_15"><em>Figure 8-15: Decompiler window reflecting defined structures for</em> <span class="codeitalic">SubClass</span></p>
<p class="indent">A class’s vftable is referenced directly in only two circumstances: within the class constructor(s) and destructor. When you locate a vftable, you can utilize Ghidra’s data cross-referencing capabilities (see <a href="ch09.xhtml#ch09">Chapter 9</a>) to quickly locate all constructors and destructors for the associated class.</p>
<h4 class="h4" id="ch08lev163"><strong><em>The Object Life Cycle</em></strong></h4>
<p class="noindent">Understanding the mechanism by which objects are created and destroyed can help to reveal object hierarchies and nested object relationships as well as quickly identify class constructor and destructor functions.</p>
<div class="box5">
<p class="boxtitle-c"><strong>WHAT’S A CONSTRUCTOR?</strong></p>
<p class="noindent">A <em>class constructor function</em> is an initialization function that is invoked when a new object of that class is created. Constructors provide an opportunity to initialize variables within the class. The inverse of a constructor, a <em>destructor</em>, is called when an object goes out of scope or a dynamically allocated object is explicitly deleted. Destructor functions perform cleanup activities such as releasing resources like open file descriptors and dynamically allocated memory. Properly written destructors mitigate the potential for memory leaks.</p>
</div>
<p class="indent">The storage class of an object determines when its constructor is called.<sup><a id="ch08fn1a" href="footnotes.xhtml#ch08fn1">1</a></sup> For global and statically allocated objects (static storage class), constructors are called during program startup prior to entry into the program’s <span class="literal">main</span> function. Constructors for stack-allocated objects (automatic storage class) are invoked when the object comes into scope within the function in which it is declared. In many cases, this will be immediately <span epub:type="pagebreak" id="page_178"/>upon entry to the function in which it is declared. However, when an object is declared within a nested block statement, its constructor is not invoked until that block is entered, if it is entered at all. When an object is allocated dynamically in the program heap, its creation is a two-step process: the <span class="literal">new</span> operator is invoked to allocate the object’s memory and then the constructor is invoked to initialize the object. Microsoft C++ ensures that the result of <span class="literal">new</span> is not null prior to invoking the constructor, but GNU’s <span class="literal">g++</span> does not.</p>
<div class="box5">
<p class="boxtitle-c"><strong>WHAT’S NEW?</strong></p>
<p class="noindent">The <span class="literal">new</span> operator is used for dynamic memory allocation in C++ in much the same way that <span class="literal">malloc</span> is used in C. It is used to allocate memory from the heap and allows a program to request space as needed during execution. The <span class="literal">new</span> operator is built into the C++ language, whereas <span class="literal">malloc</span> is merely a standard library function. Remember that C is a subset of C++, so you might see either in a C++ program. The most notable difference between <span class="literal">malloc</span> and <span class="literal">new</span> is that invocations of <span class="literal">new</span> for object types will result in an implicit invocation of the object’s constructor, where memory returned by <span class="literal">malloc</span> is not initialized before it is made available to the caller.</p>
</div>
<p class="indent">When a constructor executes, the following sequence of actions takes place:</p>
<ol>
<li class="noindent">If the class has a superclass, the superclass constructor is invoked.</li>
<li class="noindent">If the class has any virtual functions, the vftable pointer is initialized to point to the class’s vftable. This may overwrite a vftable pointer that was initialized in the superclass constructor, which is exactly the desired behavior.</li>
<li class="noindent">If the class has any data members that are themselves objects, the constructor for each of those data members is invoked.</li>
<li class="noindent">Finally, the class constructor is executed. This is the C++ constructor code specified by the programmer of the class.</li>
</ol>
<p class="indent">From a programmer’s perspective, constructors do not specify a return type or allow a value to be returned. Some compilers actually return <span class="literal">this</span> as a result that they may further utilize in the caller, but this is a compiler implementation detail and C++ programmers cannot access the returned value.</p>
<p class="indent">Destructors, as their name implies, are called at the end of an object’s lifetime. For global and static objects, destructors are called by cleanup code that is executed after the <span class="literal">main</span> function terminates. Destructors for stack-allocated objects are invoked as the objects go out of scope. Destructors for heap-allocated objects are invoked via the <span class="literal">delete</span> operator immediately before the memory allocated to the object is released.</p>
<span epub:type="pagebreak" id="page_179"/>
<p class="indent">The actions performed by destructors mimic those performed by constructors, with the exception that they are performed in roughly reverse order:</p>
<ol>
<li class="noindent">If the class has any virtual functions, the vftable pointer for the object is restored to point to the vftable for the associated class. This is required in case a subclass had overwritten the vftable pointer as part of its creation process.</li>
<li class="noindent">The programmer-specified code for the destructor executes.</li>
<li class="noindent">If the class has any data members that are themselves objects, the destructor for each of those members is executed.</li>
<li class="noindent">Finally, if the object has a superclass, the superclass destructor is called.</li>
</ol>
<p class="indent">By understanding when superclass constructors and destructors are called, it is possible to trace an object’s inheritance hierarchy through the chain of calls to its related superclass functions.</p>
<div class="box5">
<p class="boxtitle-c"><strong>I THINK YOU ARE OVERLOADED</strong></p>
<p class="noindent">Overloaded functions are functions that share the same name but have different parameters. C++ requires that each version of an overloaded function differ from every other version in the sequence and/or quantity of parameter types that the function receives. In other words, while they share the same function name, each function prototype must be unique, and each overloaded function body can be uniquely identified within the disassembled binary. This is not to be confused with functions, such as <span class="literal">printf</span>, that take a variable number of arguments but are associated with a single function body.</p>
</div>
<h4 class="h4" id="ch08lev164"><strong><em>Name Mangling</em></strong></h4>
<p class="noindent">Also called <em>name decoration</em>, <em>name mangling</em> is the mechanism C++ compilers use to distinguish among overloaded versions of a function. To generate unique, internal names for overloaded functions, compilers decorate the function name with additional characters that encode various pieces of information about the function: the namespace to which the function (or its owning class) belongs (if any), the class to which the function belongs (if any), and the parameter sequence (type and order) required to call the function.</p>
<p class="indent">Name mangling is a compiler implementation detail for C++ programs and, as such, is not part of the C++ language specification. Not unexpectedly, compiler vendors have developed their own, often-incompatible conventions for name mangling. Fortunately, Ghidra understands the name mangling conventions employed by Microsoft’s C++ compiler and GNU <span class="literal">g++</span> v3 (and later) as well as some other compilers. Ghidra provides names of the form <span class="literal">FUN_</span><span class="codeitalic">address</span> in place of the mangled name. Mangled names do <span epub:type="pagebreak" id="page_180"/>carry valuable information regarding the signature of each function, and Ghidra includes this information in the Symbol Table window as well as propagating the information to the disassembly and other related windows. (To determine the signature of a function without a mangled name, you might need to conduct time-consuming analysis of the data flowing into and out of the function.)</p>
<h4 class="h4" id="ch08lev165"><strong><em>Runtime Type Identification</em></strong></h4>
<p class="noindent">C++ provides operators to determine (<span class="literal">typeid</span>) and check (<span class="literal">dynamic_cast</span>) an object’s data type at runtime. To support these operations, C++ compilers must embed type-specific information, for each polymorphic class, within a program binary. When a <span class="literal">typeid</span> or <span class="literal">dynamic_cast</span> operation is performed at runtime, library routines reference the type-specific information in order to determine the exact runtime type of the polymorphic object being referenced. Unfortunately, as with name mangling, <em>Runtime Type Identification (RTTI)</em> is a compiler implementation detail rather than a language issue, and there is no standard means by which compilers implement RTTI capabilities.</p>
<p class="indent">We will take a brief look at the similarities and differences between the RTTI implementations of Microsoft’s C++ compiler and GNU <span class="literal">g++</span>. Specifically, we’ll describe how to locate RTTI information and, from there, how to learn the name of the class to which that information pertains. Readers desiring more detailed discussion of Microsoft’s RTTI implementation should consult the references listed at the end of this chapter. In particular, the references detail how to traverse a class’s inheritance hierarchy, including how to trace that hierarchy when multiple inheritance is being used.</p>
<p class="indent">Consider the following simple program, which uses polymorphism:</p>
<p class="programs">  class abstract_class {<br/>
      public:<br/>
          virtual int vfunc() = 0;<br/>
  };<br/>
    class concrete_class : public abstract_class {<br/>
      public:<br/>
          concrete_class(){};<br/>
          int vfunc();<br/>
  };<br/>
  int concrete_class::vfunc() {return 0;}<br/>
<span class="ent">➊</span> void print_type(abstract_class *p) {<br/>
      cout &lt;&lt; typeid(*p).name() &lt;&lt; endl;<br/>
  }<br/>
  int main() {<br/>
      abstract_class *sc = new concrete_class();<span class="ent">➋</span><br/>
      print_type(sc);<br/>
  }</p>
<p class="indent">The <span class="literal">print_type</span> function <span class="ent">➊</span> prints the type of the object being pointed to by the pointer <span class="literal">p</span>. In this case, it must print <span class="literal">"concrete_class"</span> since a <span class="literal">concrete</span><span class="literal">_class</span> <span epub:type="pagebreak" id="page_181"/>object is created in the <span class="literal">main</span> function <span class="ent">➋</span>. How does <span class="literal">print_type</span>, and more specifically <span class="literal">typeid</span>, know what type of object <span class="literal">p</span> is pointing to?</p>
<p class="indent">The answer is surprisingly simple. Since every polymorphic object contains a pointer to a vftable, compilers leverage that fact by co-locating class-type information with the class vftable. Specifically, the compiler places a pointer, immediately prior to the class vftable, that points to a structure containing information about the class that owns the vftable. In GNU <span class="literal">g++</span> code, this pointer points to a <span class="literal">type_info</span> structure, which contains a pointer to the name of the class. In Microsoft C++ code, the pointer points to a Microsoft <span class="literal">RTTICompleteObjectLocator</span> structure, which in turn contains a pointer to a <span class="literal">TypeDescriptor</span> structure. The <span class="literal">TypeDescriptor</span> structure contains a character array that specifies the name of the polymorphic class.</p>
<p class="indent">RTTI information is required only in C++ programs that use the <span class="literal">typeid</span> or <span class="literal">dynamic_cast</span> operator. Most compilers provide options to disable the generation of RTTI in binaries that do not require it; therefore, you should not be surprised if you encounter compiled binaries that contain no RTTI information even though vftables are present.</p>
<p class="indent">For C++ programs built with Microsoft’s C++ compiler, Ghidra contains an RTTI analyzer that is enabled by default and that is capable of identifying Microsoft RTTI structures, annotating those structures (if present) in the disassembly listing, and utilizing class names recovered from those RTTI structures in the Symbol Tree’s <em>Classes</em> folder. Ghidra has no RTTI analyzer for non-Windows binaries. When Ghidra encounters an unstripped, non-Windows binary, if it understands the name mangling scheme employed in the binary, then Ghidra utilizes available name information to populate the Symbol Tree’s <em>Classes</em> folder. If a non-Windows binary has been stripped, Ghidra will not be able to automatically recover any class names or identify vftables or RTTI information.</p>
<h4 class="h4" id="ch08lev166"><strong><em>Inheritance Relationships</em></strong></h4>
<p class="noindent">It is possible to unravel inheritance relationships by using a compiler’s particular implementation of RTTI, but RTTI may not be present when a program does not utilize the <span class="literal">typeid</span> or <span class="literal">dynamic_cast</span> operators. Lacking RTTI information, what techniques can be employed to determine inheritance relationships among C++ classes?</p>
<p class="indent">The simplest method to determine an inheritance hierarchy is to observe the chain of calls to superclass constructors that are called when an object is created. The single biggest hindrance to this technique is the use of inline constructors. In C/C++, a function declared as <span class="literal">inline</span> is usually treated as a macro by the compiler, and the code for the function is expanded in place of an explicit function call. Inline functions hide the fact that a function is being used, since no assembly language call statement will be generated. This makes it challenging to understand that a superclass constructor has in fact been called.</p>
<p class="indent">The analysis and comparison of vftables can also reveal inheritance relationships. For example, in comparing the vftables shown in <a href="ch08.xhtml#fig8_14">Figure 8-14</a>, we note that the vftable for <span class="literal">SubClass</span> contains two of the same pointers that <span epub:type="pagebreak" id="page_182"/>appear in the vftable for <span class="literal">BaseClass</span>, and we conclude that <span class="literal">BaseClass</span> and <span class="literal">SubClass</span> must be related in some way. To understand which one is the base class and which one is the subclass, we can apply the following guidelines, singly or in combination:</p>
<ul>
<li class="noindent">When two vftables contain the same number of entries, the two corresponding classes <em>may</em> be involved in an inheritance relationship.</li>
<li class="noindent">When the vftable for class X contains more entries than the vftable for class Y, class X <em>may</em> be a subclass of class Y.</li>
<li class="noindent">When the vftable for class X contains entries that are also found in the vftable for class Y, then one of the following relationships must exist: X is a subclass of Y, Y is a subclass of X, or X and Y are both subclasses of a common superclass Z.</li>
<li class="noindent">When the vftable for class X contains entries that are also found in the vftable for class Y and the vftable for class X contains at least one <span class="literal">purecall</span> entry that is not also present in the corresponding vftable entry for class Y, then class Y is likely to be a subclass of class X.</li>
</ul>
<p class="indent">While the preceding list is by no means all-inclusive, we can use these guidelines to deduce the relationship between <span class="literal">BaseClass</span> and <span class="literal">SubClass</span> in <a href="ch08.xhtml#fig8_14">Figure 8-14</a>. In this case, the last three rules all apply, but the last rule specifically leads us to conclude, based on vftable analysis alone, that <span class="literal">SubClass</span> inherits from <span class="literal">BaseClass</span>.</p>
<h4 class="h4" id="ch08lev167"><strong><em>C++ Reverse Engineering References</em></strong></h4>
<p class="noindent">Several excellent references exist on reverse engineering compiled C++.<sup><a id="ch08fn2a" href="footnotes.xhtml#ch08fn2">2</a></sup> While many of the details in each of these articles apply specifically to programs compiled using Microsoft’s C++ compiler, many of the concepts apply equally to programs compiled using other C++ compilers.</p>
<h3 class="h3" id="ch08lev168"><strong>Summary</strong></h3>
<p class="noindent">You can expect to encounter complex data types in all but the most trivial programs. Understanding how data within data structures is accessed and knowing how to recognize clues to the layout of those data structures is an essential reverse engineering skill. Ghidra provides a wide variety of features designed specifically to deal with data structures. Familiarity with these features will greatly enhance your ability to comprehend what data is being manipulated and spend more time understanding how and why that data is being manipulated. In the next chapter, we continue our discussion of Ghidra’s basic capabilities with an in-depth look at cross-references.</p>
</div>



  </body></html>