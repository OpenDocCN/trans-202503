<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_157"/><strong><span class="big">9</span></strong><br/><strong>IN-VEHICLE INFOTAINMENT SYSTEMS</strong></h2>&#13;
<div class="image1"><img src="graphics/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent"><em>In-vehicle infotainment (IVI) system</em> is the name often given to the touchscreen interface in a car’s center console. These consoles often run an operating system such as Windows CE, Linux, QNX, or Green Hills and may even run Android in a VM as well. They can support numerous features with varying levels of integration with the vehicle.</p>&#13;
<p class="indent">The IVI system offers more remote attack surfaces than any other vehicle component. In this chapter, you’ll learn how to analyze and identify an IVI unit, how to determine how it works, and how to overcome potential hurdles. Once you understand your IVI system, you’ll have gained a great deal of insight into how your target vehicle works. Gaining access to the IVI system will not only allow you to modify the IVI itself but also will open a door to additional information about how your vehicle works, such as how it routes CAN bus packets and updates the ECU. Understanding the IVI system can <span epub:type="pagebreak" id="page_158"/>also provide insight into whether the system phones home to the manufacturer; if it does, you can use access to the IVI to see what data is being collected and potentially transmitted back to the manufacturer.</p>&#13;
<h3 class="h3" id="ch09lev1sec1"><strong>Attack Surfaces</strong></h3>&#13;
<p class="noindent">IVI systems typically have one or more of these physical inputs that you can use to communicate with a vehicle:</p>&#13;
<p class="noindentt"><strong>Auxiliary jack</strong></p>&#13;
<p class="bull">• CD-ROM</p>&#13;
<p class="bull">• DVD</p>&#13;
<p class="bull">• Touchscreen, knobs or buttons, and other physical input methods</p>&#13;
<p class="bull">• USB ports</p>&#13;
<p class="noindentt"><strong>One or more wireless inputs</strong></p>&#13;
<p class="bull">• Bluetooth</p>&#13;
<p class="bull">• Cellular connection</p>&#13;
<p class="bull">• Digital radio (such as Digital Audio Broadcasting)</p>&#13;
<p class="bull">• GPS</p>&#13;
<p class="bull">• Wi-Fi</p>&#13;
<p class="bull">• XM Radio</p>&#13;
<p class="noindentt"><strong>Internal network controls</strong></p>&#13;
<p class="bull">• Bus networks (CAN, LIN, KWP, K-Line, and so on)</p>&#13;
<p class="bull">• Ethernet</p>&#13;
<p class="bull">• High-speed media bus</p>&#13;
<p class="indentt">Vehicles often use CAN to communicate with their components, such as modules, ECUs, IVI systems, and telematic units. Some IVI systems use Ethernet to communicate between high-speed devices, whether to send normal IP traffic or CAN packets using Electronic System Design’s NTCAN or the Ethernet low-level socket interface (ELLSI). (For more on vehicle protocols, see <a href="ch02.html#ch02">Chapter 2</a>.)</p>&#13;
<h3 class="h3" id="ch09lev1sec2"><strong>Attacking Through the Update System</strong></h3>&#13;
<p class="noindent">One way to attack the IVI system is to go after its software. If your skill set primarily lies in the realm of software-related services, you may feel most comfortable with this method, and if you’ve ever researched embedded devices, such as home Wi-Fi routers, some of the methods discussed in the following should look familiar to you.</p>&#13;
<p class="indent">We’ll focus on using system updates to gain access to the system. It may be possible to access the system through other software means, such as a debug screen, an undocumented backdoor, or a published vulnerability, <span epub:type="pagebreak" id="page_159"/>but we’ll focus on gaining access through software updates because that method is the most generic across IVI systems and is the primary one used to identify and access a target system via software.</p>&#13;
<h4 class="h4" id="ch09lev2sec1"><strong><em>Identifying Your System</em></strong></h4>&#13;
<p class="noindent">In order to fully understand your target IVI system, you must first determine what kind of software it’s running. Next, you need to figure out how to access this software, which often involves looking for the methods the IVI uses to update or load its operating system. Once you understand how the system updates, you’ll have the knowledge you need to identify vulnerabilities and modify the system.</p>&#13;
<p class="indent">Before you can begin making modifications, you need to know what operating system the IVI is running. The easiest way to do so is to search for the brand of the IVI—first, by looking for a label on the outside of the IVI unit or frame. If you don’t see a label, look for a display option on the interface that displays software version numbers and often the device name. Also, check online to see whether anyone has already researched your target system and, if the system is manufactured by a third party, whether it has a website and firmware updates. Download any firmware or tools you can find for later use. Find out how the system is updated. Is there a map update service available? What other update methods are available? Even if you find that system updates are sent over the air, it’s usually possible to find USB drives or a DVD containing map updates, like the one from a Honda Civic shown in <a href="ch09.html#ch9fig1">Figure 9-1</a>.</p>&#13;
<div class="image"><img src="graphics/f09-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="ch9fig1"/>Figure 9-1: NavTeq infotainment unit in an open state</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_160"/>This IVI has a normal CD tray for music at the top plus a hidden plastic door at the bottom that folds down to reveal a DVD tray holding the map software.</p>&#13;
<h4 class="h4" id="ch09lev2sec2"><strong><em>Determining the Update File Type</em></strong></h4>&#13;
<p class="noindent">System updates are often delivered as compressed files with <em>.zip</em> or <em>.cab</em> file extensions, but sometimes they have nonstandard extensions, like <em>.bin</em> or <em>.dat</em>. If the update files have <em>.exe</em> or <em>.dll</em> extensions, you’re probably looking at a Microsoft Windows–based system.</p>&#13;
<p class="indent">To determine how the files are compressed and their target architecture, view their headers with a hex editor or use a tool such as <span class="literal">file</span> available on *nix-based systems. The <span class="literal">file</span> command will report a file’s architecture, such as ARM or, as with the Honda Civic IVI shown in <a href="ch09.html#ch9fig1">Figure 9-1</a>, a Hitachi SuperH SH-4 Processor. This information is useful if you want to compile new code for a device or if you plan on writing or using an exploit against it.</p>&#13;
<p class="indent">If the <span class="literal">file</span> command hasn’t identified the type of file, you may be looking at a packed image. To analyze a firmware bundle, you can use a tool such as <span class="literal">binwalk</span>, which is a Python tool that uses signatures to carve out files from a collected binary. For instance, you can simply run <span class="literal">binwalk</span> on your firmware image to see a list of identified file types:</p>&#13;
<div class="image1a"><img src="graphics/f0160-01.jpg" alt="image"/></div>&#13;
<p class="indent">Using the <span class="literal">-e</span> flag would extract each of these files for further analysis and review. In this example, you can see a SquashFS filesystem was detected.</p>&#13;
<p class="indent">This filesystem could be extracted with the <span class="literal">-e</span> flag and then “unsquashed” using the <span class="literal">unsquashfs</span> tool to view the filesystem, as I’ve done here:</p>&#13;
<p class="programs">$ <span class="codestrong">binwalk -e firmware.bin</span><br/>$ <span class="codestrong">cd _firmware.bin.extracted</span><br/>$ <span class="codestrong">unsquashfs -f -d firmware.unsquashed 140090.squashfs</span></p>&#13;
<p class="indent">The <span class="literal">binewalk -e</span> commands will extract all known files from <em>firmware.bin</em> to the folder <em>_firmware.bin.extracted</em>. Inside that folder, you’ll see files named <span epub:type="pagebreak" id="page_161"/>after their hex address with an extension that matches the detected file type. In this example, the <em>squashfs</em> file is called <em>140090.squashfs</em> because that was the location in <em>firmware.bin</em>.</p>&#13;
<h4 class="h4" id="ch09lev2sec3"><strong><em>Modifying the System</em></strong></h4>&#13;
<p class="noindent">Once you know your system’s OS, architecture, and update method, the next thing to do is to see whether you can use this information to modify it. Some updates are “protected” by a digital signature, and these can be tricky to update. But often there’s no protection or the update process will simply use an MD5 hash check. The best way to find these protections is to modify the existing update software and trigger an update.</p>&#13;
<p class="indent">A good starting point for system modification is something with a visible result, like a splash screen or icon because once you successfully change it, you’ll know immediately (see <a href="ch09.html#ch9fig2">Figure 9-2</a>).</p>&#13;
<div class="image"><img src="graphics/f09-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="ch9fig2"/>Figure 9-2: Example modification: NavTeq unit with a modified splash screen</em></p>&#13;
<p class="indent"><a href="ch09.html#ch9fig2">Figure 9-2</a> shows how I modified the splash screen of an IVI system by replacing the normal background image with a Jolly Roger flag and the vehicle’s emblem with a character from Street Fighter. Replacing images in your splash screen is a safe way to ensure you can modify the IVI system without much risk of breaking the system.</p>&#13;
<p class="indent">Find an image in your update file, modify it, then reburn the update DVD and force a system update. (Find out how in the IVI’s manual.) If the update files were compressed in a single archive, be sure to recompress the modified version so that it appears in the same format as before you modified it.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>If you run into a checksum issue and your update fails, look for a file in the update that might be a hash, such as a text file containing strings like <em>4cb1b61d0ef0ef683ddbed607c74f2bf</em>. You’ll need to update this file with the hash of your new modified image. You may be able to guess the hashing algorithm by looking at the size of the hash and performing some trial and error. For instance, an 8-character hash, such as d579793f, may be CRC32; a 32-character hash, such as c46c4c478a4b6c32934ef6559d25002f, may be an MD5 hash; and a 40-character hash, such as 0aaedee31976f-350a9ef821d6e7571116e848180, may be SHA-1. These are the three most common hash algorithms, but there are others you might come across, and a quick Google search or reference to the tables at <em><a href="https://en.wikipedia.org/wiki/List_of_hash_functions">https://en.wikipedia.org/wiki/List_of_hash_functions</a></em> should give you a clue as to which algorithm was used.</p>&#13;
<p class="indent">The Linux tools <span class="literal">crc32</span>, <span class="literal">md5sum</span>, and <span class="literal">sha1sum</span> will let you quickly calculate the hash of an existing file and compare it to the contents of the original text file. If you can generate a hash that matches that of the existing file, then you’ve found the correct algorithm.</p>&#13;
<p class="indent">For example, say you find a single file on an update DVD called <em>Validation.dat</em> that lists the contents of the files on the DVD, as shown in <a href="ch09.html#ch9list1">Listing 9-1</a>. This listing includes the names of three files on the DVD and their associated hashes.</p>&#13;
<p class="programs">09AVN.bin       b46489c11cc0cf01e2f987c0237263f9<br/>PROG_INFO.MNG   629757e00950898e680a61df41eac192<br/>UPDATE_APL.EXE  7e1321b3c8423b30c1cb077a2e3ac4f0</p>&#13;
<p class="list-caption"><a id="ch9list1"/><em>Listing 9-1: Sample</em> <span class="literal">Validation.dat</span> <em>file found on an update DVD</em></p>&#13;
<p class="indent">The length of the hash listed for each file—32 characters—suggests that this might be an MD5 hash. To confirm, use the Linux <span class="literal">md5sum</span> tool to generate an MD5 hash for each file. <a href="ch09.html#ch9list2">Listing 9-2</a> shows what that would look like for the <em>09AVN.bin</em> file.</p>&#13;
<p class="programs">$ <span class="codestrong">md5sum 09AVN.bin</span><br/>b46489c11cc0cf01e2f987c0237263f9 09AVN.bin</p>&#13;
<p class="list-caption"><a id="ch9list2"/><em>Listing 9-2: Using</em> <span class="literal"><span class="codeitalic">md5sum</span></span> <em>to see the hash of the</em> 09AVN.bin <em>file</em></p>&#13;
<p class="indent">Compare the hash for <em>09AVN.bin</em> in <a href="ch09.html#ch9list1">Listing 9-1</a> with the results of running <span class="literal">md5sum</span> in <a href="ch09.html#ch9list2">Listing 9-2</a>, and you’ll see that the hashes match; we’re indeed looking at an MD5 hash. This result tells us that in order to modify <em>09AVN.bin</em>, we’d need to recalculate the MD5 hash and update the <em>Validation.dat</em> file that contains all the hashes with the new hash.</p>&#13;
<p class="indent">Another way to determine the algorithm used to create the hash is to run the <span class="literal">strings</span> command on some of the binaries or DLLs in your update package to search for strings in the file, like MD5 or SHA. If the hash is small, like d579793f, and CRC32 doesn’t seem to work, you’re probably looking at a custom hash.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_163"/>In order to create a custom hash, you need to understand the algorithm used to create that hash, which will require digging in with a disassembler, such as IDA Pro, Hopper, or radare2, which is free. For instance, <a href="ch09.html#ch9list3">Listing 9-3</a> shows sample output from a custom CRC algorithm viewed in radare2:</p>&#13;
<p class="programs">|  .------&gt; 0x00400733    488b9568fff. mov rdx, [rbp-0x98]<br/>|- fcn.0040077c 107<br/>|  ||| |    0x0040073a    488d855ffff. lea rax, [rbp-0xa1]<br/>|  ||| |    0x00400741    4889d1       mov rcx, rdx<br/>|  ||| |    0x00400744    ba01000000   mov edx, 0x1<br/>|  ||| |    0x00400749    be01000000   mov esi, 0x1<br/>|  ||| |    0x0040074e    4889c7       mov rdi, rax<br/>|  ||| |    0x00400751    e8dafdffff   call sym.imp.fread<br/>|  ||| |       sym.imp.fread()<br/>|  ||| |    0x00400756    8b9560ffffff mov edx, [rbp-0xa0]<br/>|  ||| |    0x0040075c    89d0         mov eax, edx <span class="ent">➊</span><br/>|  ||| |    0x0040075e    c1e005       shl eax, 0x5 <span class="ent">➋</span><br/>|  ||| |    0x00400761    01c2         add edx, eax <span class="ent">➌</span><br/>|  ||| |    0x00400763    0fb6855ffff. movzx eax, byte [rbp-0xa1]<br/>|  ||| |    0x0040076a    0fbec0       movsx eax, al<br/>|  ||| |    0x0040076d    01d0         add eax, edx<br/>|  ||| |    0x0040076f    898560ffffff mov [rbp-0xa0], eax<br/>|  ||| |    0x00400775    838564fffff. add dword [rbp-0x9c], 0x1<br/>|  ||       ; CODE (CALL) XREF from 0x00400731 (fcn.0040066c)<br/>|  |`-----&gt; 0x0040077c    8b8564ffffff mov eax, [rbp-0x9c]<br/>|  | | |    0x00400782    4863d0       movsxd rdx, eax<br/>|  | | |    0x00400785    488b45a0     mov rax, [rbp-0x60]<br/>|  | | |    0x00400789    4839c2       cmp rdx, rax<br/>|  `======&lt; 0x0040078c    7ca5         jl 0x400733</p>&#13;
<p class="list-caption"><em><a id="ch9list3"/>Listing 9-3: Disassembly of a CRC checksum function in radare2</em></p>&#13;
<p class="indent">Unless you’re good at reading low-level assembler, this may be a bit much to start with, but here we go. The algorithm in <a href="ch09.html#ch9list3">Listing 9-3</a> reads in a byte at <span class="ent">➊</span>, multiplies it by 5 at <span class="ent">➋</span>, and then, at <span class="ent">➌</span>, adds it to the hash to calculate the final sum. The rest of the assembly is mainly used by the <span class="literal">read</span> loop to process the binary file.</p>&#13;
<h4 class="h4" id="ch09lev2sec4"><strong><em>Apps and Plugins</em></strong></h4>&#13;
<p class="noindent">Whether your goal is to perform firmware updates, create custom splash screens, or achieve other exploitation, you’ll often find that you can get the information you need to exploit or modify a vehicle by going after IVI applications rather than the IVI operating system itself. Some systems allow third-party applications to be installed on the IVI, often through an app store or a dealer-customized interface. For example, you’ll notice there’s usually a way for developers to sideload apps for testing. Modifying an existing plugin or creating your own can be a great way to execute code to further unlock a system. Because standards are still being written to define how <em>applications</em> should interface with the vehicle, every manufacturer is free to implement its own API and security models. These APIs are often ripe for abuse.</p>&#13;
<h4 class="h4" id="ch09lev2sec5"><span epub:type="pagebreak" id="page_164"/><strong><em>Identifying Vulnerabilities</em></strong></h4>&#13;
<p class="noindent">Once you’ve found out how to update your system—whether by modifying the splash screen, company logo, warranty message, or other item—you’re ready to look for vulnerabilities in the system. Your choice of how to proceed will depend on your ultimate goal.</p>&#13;
<p class="indent">If you’re looking for existing vulnerabilities in the infotainment unit, the next step is to pull all the binaries off the IVI so you can analyze them. (This research is already covered in great detail in several books about reverse engineering, so I won’t go into detail here.) Check the versions of binaries and libraries on the system. Often, even in the case of map updates, the core OS is rarely updated, and there’s a good chance that an already identified vulnerability exists on the system. You may even find an existing Metasploit exploit for the system!</p>&#13;
<p class="indent">If your goal is, for example, to create a malicious update that wiretaps a vehicle’s Bluetooth driver, you have almost everything you need at this stage to do so. The only piece you may still need is the software development kit (SDK), which you use to compile the target system. Getting your hands on one will make your task much easier, although it’s still possible to create or modify a binary using a hex editor instead. Often the infotainment OS is built with a standard SDK, such as the Microsoft Auto Platform.</p>&#13;
<p class="indent">For example, consider a navigation system with certain protections designed to prevent a customer from using a DVD-R in the system. The manufacturer’s original idea was to charge owners $250 to purchase updated mapping DVDs, and they wanted to prevent people from simply copying someone else’s DVD.</p>&#13;
<p class="indent">In its attempt to prevent this type of sharing, the manufacturer added several DVD checks to the navigation system, as shown in the IDA display sample code in <a href="ch09.html#ch9fig3">Figure 9-3</a>. But say as a consumer you want to use a backup copy of your purchased DVD in your system rather than the original because your car gets really hot during the day and you don’t want the DVD to warp.</p>&#13;
<p class="indent">While an ordinary consumer isn’t likely to be able to bypass these DVD checks, it would be possible to locate the DVD checks and replace them with no-operation instructions (NOPs), which would make the checks literally do nothing. Then you could upload this modified version of the DVD check to your IVI and use your backup DVD for navigation.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>All the hacks mentioned so far can be done without removing the unit. However, you could dig even deeper by taking the unit out and going after the chips and memory directly, as discussed in <a href="ch06.html#ch06">Chapter 6</a>.</em></p>&#13;
</div>&#13;
<div class="image"><span epub:type="pagebreak" id="page_165"/><img src="graphics/f09-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch9fig3"/><em>Figure 9-3: IDA view of DVD checks</em></p>&#13;
<h3 class="h3" id="ch09lev1sec3"><span epub:type="pagebreak" id="page_166"/><strong>Attacking the IVI Hardware</strong></h3>&#13;
<p class="noindent">If you’re more comfortable attacking hardware than software and you’re able to remove the IVI from the target vehicle, you can go after the IVI system hardware instead. For that matter, if you’ve had no luck accessing the IVI system software, a hardware attack might provide additional insight that’ll help you find a way in. You’ll sometimes find that you can access system security keys by attacking the hardware when something like the update method mentioned earlier fails.</p>&#13;
<h4 class="h4" id="ch09lev2sec6"><strong><em>Dissecting the IVI Unit’s Connections</em></strong></h4>&#13;
<p class="noindent">If you’re unable to gain access to a vehicle’s system through the update method discussed in the previous section, you can attack the IVI’s wiring and bus lines. Your first step will be to remove the IVI unit and then trace the wires back to the circuit board in order to identify its components and connections, like the ones shown in <a href="ch09.html#ch9fig4">Figure 9-4</a>.</p>&#13;
<div class="image"><img src="graphics/f09-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="ch9fig4"/>Figure 9-4: Connector view of a double DIN IVI unit</em></p>&#13;
<p class="noindent">When you take your IVI unit out, you’ll see a lot of wires because, unlike aftermarket radios, OEM units are heavily connected to the vehicle. The back metal panel on the IVI usually doubles as a heat sink, and each connector is often separated by its functionality. (Some vehicles keep the Bluetooth and cellular piece in another module, so if you’re looking to research a wireless exploit and the IVI unit doesn’t have this wireless module, continue looking for the telematics module.)</p>&#13;
<p class="indent">By tracing the actual wires or looking at a wiring diagram like the one shown in <a href="ch09.html#ch9fig5">Figure 9-5</a>, you can see that the Bluetooth module is actually a separate piece from the navigation unit (IVI). Notice in the diagram <span epub:type="pagebreak" id="page_167"/>that the Bluetooth unit uses CAN (B-CAN) on pin 18. If you look at the navigation unit’s wiring diagram, you can see that instead of CAN, K-Line (pin 3) is directly attached to the IVI unit. (We discussed these protocols in <a href="ch02.html#ch02">Chapter 2</a>.)</p>&#13;
<div class="image"><img src="graphics/f09-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="ch9fig5"/>Figure 9-5: Hands-free wiring diagram</em></p>&#13;
<p class="indent">If you can determine whether your target is connected to a network bus, you’ll know just how much your exploit can control. At the very least, the bus directly connected to the target can be influenced by any code you put on the target system. For instance, in the wiring examples shown in <span epub:type="pagebreak" id="page_168"/><a href="ch09.html#ch9fig5">Figure 9-5</a>, a vulnerability in the Bluetooth module would give us direct CAN access; however, if we exploited the IVI’s navigation system, we’d need to use K-Line instead (see <a href="ch09.html#ch9fig6">Figure 9-6</a>). You can tell which network you have access to by looking at the wiring diagram in <a href="ch09.html#ch9fig5">Figure 9-5</a> and seeing whether K-Line or CAN are connected to your target device. Which bus you’re on will affect your payload and what networked systems you’ll be able to influence directly.</p>&#13;
<div class="image"><img src="graphics/f09-06.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="ch9fig6"/>Figure 9-6: K-Line specified in the wiring diagram for the navigation unit</em></p>&#13;
<h4 class="h4" id="ch09lev2sec7"><strong><em>Disassembling the IVI Unit</em></strong></h4>&#13;
<p class="noindent">If your goal is to directly attack the system hardware or if you don’t have a wiring diagram showing the connections to the entertainment unit, you’ll need to start taking the unit apart. Because IVI units are really compact and they bundle a lot of functionality into a small area, taking them apart means removing lots of screws and several layers of connected circuit boards. The disassembly task is time consuming and complicated and should probably be your last resort.</p>&#13;
<p class="indent">To begin disassembly, start by removing the case. Each unit comes apart differently, but typically you can remove the front and back plate screws and then work your way down from the top. Once inside, you’ll most likely find a circuit board like the one shown in <a href="ch09.html#ch9fig7">Figure 9-7</a>.</p>&#13;
<p class="indent">Although the print on the circuit board is a little hard to read, you’ll probably find that many of the pins are labeled. Pay close attention to any connectors that are attached to the circuit board but not connected or that are covered by the heat sink. You’ll often find that certain connectors used during the manufacturing process are left behind, disconnected on the circuit board. These can be a great way in to the IVI unit. For example, <a href="ch09.html#ch9fig8">Figure 9-8</a> shows a hidden connector revealed once the back panel was removed on the target IVI.</p>&#13;
<p class="indent">Hidden connectors are a great place to start when going after a device’s firmware. These connectors often have methods to load and debug the firmware running on the systems, and they can also provide serial-style debugging interfaces that you can use to see what’s happening with the system. In particular, you should look for JTAG and UART interfaces.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_169"/><img src="graphics/f09-07.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch9fig7"/><em>Figure 9-7: Many pins and connectors are labeled directly on the PCB.</em></p>&#13;
<div class="image"><img src="graphics/f09-08.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="ch9fig8"/>Figure 9-8: Nonexposed hidden connector</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>At this stage, you should start tracing the pins and looking at data sheets for the onboard chips. After a bit of sleuthing as to where these pins connect, you should have a better idea of what you’re dealing with and the intended purpose of this hidden connector. (See <a href="ch08.html#ch08">Chapter 8</a> for more on analyzing circuit boards and reverse engineering hardware.)</p>&#13;
<h3 class="h3" id="ch09lev1sec4"><strong>Infotainment Test Benches</strong></h3>&#13;
<p class="noindent">Instead of tampering with your own factory-installed entertainment unit and risking damage, you can experiment with a test bench system, whether that’s one from a junkyard or an open source development platform. (Aftermarket radios aren’t a good choice because they don’t usually tie into the CAN bus network.) In this section, we’ll look at two open source entertainment systems that you can run in a VM on a PC, the GENIVI demo platform, and Automotive Grade, which requires an IVI.</p>&#13;
<h4 class="h4" id="ch09lev2sec8"><strong><em>GENIVI Meta-IVI</em></strong></h4>&#13;
<p class="noindent">The GENIVI Alliance (<em><a href="http://www.genivi.org/">http://www.genivi.org/</a></em>) is an organization whose main objective is to drive the adoption of open source IVI software. Membership is paid, but you can download and participate in the GENIVI software projects for free. Membership, especially board-level membership, in GENIVI is very costly, but you can join the mailing list to participate in some of the development and discussions. The GENIVI system can be run directly on Linux with no need for an IVI. It’s basically a collection of components that you can use to build your own IVI.</p>&#13;
<p class="indent">In <a href="ch09.html#ch9fig9">Figure 9-9</a>, a high-level block diagram of the GENIVI system shows how the pieces fit together.</p>&#13;
<p class="indent">The GENIVI demo platform has some basic human–machine interface (HMI) functionality: the FSA PoC stands for <em>fuel stop advisor proof-of-concept</em> (proof of concept because certain of these apps aren’t used in production). The FSA is part of the navigation system and is designed to alert drivers if they are going to run out of fuel before reaching their destination. The Web browser and audio manager PoCs should be self-explanatory. Another component not shown in the figure is the navigation app. This app is powered by the open source Navit project (<em><a href="http://www.navit-project.org/">http://www.navit-project.org/</a></em>) and uses a plugin for the freely licensed OpenStreetMap mapping software (<em><a href="https://www.openstreetmap.org/">https://www.openstreetmap.org/</a></em>).</p>&#13;
<p class="indent">The GENIVI’s middleware components make up the core GENIVI operating system, and they’re discussed here in the order in which they appear in <a href="ch09.html#ch9fig9">Figure 9-9</a> (persistency is excluded since there isn’t currently any documentation on this module):</p>&#13;
<p class="uln"><strong>Diagnostic log and trace (DLT)</strong> An AUTOSAR 4.0–compatible logging and tracing module. (Autosar is simply an automotive standards group; see <em><a href="https://www.autosar.org/">https://www.autosar.org/</a></em>.) Some features of the DLT can use TCP/IP, serial communications, or standard syslog.</p>&#13;
<p class="uln"><span epub:type="pagebreak" id="page_171"/><strong>Node state manager (NSM)</strong> Keeps track of the vehicle’s running state and is responsible for shutdown and for monitoring system health.</p>&#13;
<p class="uln"><strong>Node startup controller (NSC)</strong> Part of the NSM persistence. Handles all data stored on a hard drive or flash drive.</p>&#13;
<p class="uln"><strong>Audio manager daemon</strong> The audio hardware/software abstraction layer.</p>&#13;
<p class="uln"><strong>Audio manager plugins</strong> Part of the audio manager daemon.</p>&#13;
<p class="uln"><strong>Webkit</strong> Web browser engine.</p>&#13;
<p class="uln"><strong>Automotive message broker (AMB)</strong> Allows an application to access vehicle information from the CAN bus without having to know the specific CAN bus packet layouts. (The system you’re talking to must support OBD or AMB directly in order for this to work.)</p>&#13;
<div class="image"><img src="graphics/f09-09.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="ch9fig9"/>Figure 9-9: GENIVI software layout</em></p>&#13;
<h5 class="h5" id="ch09lev3sec1"><strong>Building the Environment</strong></h5>&#13;
<p class="noindent">The easiest way to build the GENIVI system on Linux is to use a Docker image. First, grab the easy build like this:</p>&#13;
<p class="programs">$ <span class="codestrong">git clone https://github.com/gmacario/easy-build</span></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>This Docker image won’t work on the eCryptfs filesystem that Ubuntu uses on home directories, so make sure to download and follow these instructions outside your default home directory.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_172"/>You’ll need Docker installed if you don’t already have it. On Ubuntu, this command is:</p>&#13;
<p class="programs">$ <span class="codestrong">sudo apt-get install docker.io</span></p>&#13;
<p class="indent">Then, <span class="literal"><span class="codestrong">cd</span></span> into the <em>easy-build/build-yocto-genivi</em> folder in your <em>Home</em> directory and run this:</p>&#13;
<p class="programs">$ <span class="codestrong">sudo docker pull gmacario/build-yocto-genivi</span><br/>$ s<span class="codestrong">udo ./run.sh</span></p>&#13;
<p class="indent">Docker builds a little VM for you to work in, and running <span class="literal">run.sh</span> should put you in a root terminal environment in the Docker instance.</p>&#13;
<p class="indent">Now, finish the install by getting the rest of the GENIVI build and creating an image that you can use in the QEMU VM. Run the following commands:</p>&#13;
<p class="programs"># <span class="codestrong">chmod a+w /dev/shm</span><br/># <span class="codestrong">chown build.build ~build/shared</span><br/># <span class="codestrong">su - build</span><br/>$ <span class="codestrong">export GENIVI=~/genivi-baseline</span><br/>$ <span class="codestrong">source $GENIVI/poky/oe-init-build-env ~/shared/my-genivi-build</span><br/>$ <span class="codestrong">export TOPDIR=$PWD</span><br/>$ <span class="codestrong">sh ~/configure_build.sh</span><br/>$ <span class="codestrong">cd $TOPDIR</span><br/>$ <span class="codestrong">bitbake -k intrepid-image</span></p>&#13;
<p class="indent">The output of the final <span class="literal">bitbake</span> command should look something like this:</p>&#13;
<p class="programs">Build Configuration:<br/>BB_VERSION        = "1.24.0"<br/>BUILD_SYS         = "x86_64-linux"<br/>NATIVELSBSTRING   = "Ubuntu-14.04"<br/>TARGET_SYS        = "i586-poky-linux"<br/>MACHINE           = "qemux86"<br/>DISTRO            = "poky-ivi-systemd"<br/>DISTRO_VERSION    = "7.0.2"<br/>TUNE_FEATURES     = "m32 i586"<br/>TARGET_FPU        = ""<br/>meta<br/>meta-yocto<br/>meta-yocto-bsp    = "(detachedfromdf87cb2):df87cb27efeaea1455f20692f9f1397c6fcab254"<br/>meta-ivi<br/>meta-ivi-bsp      = "(detachedfrom7.0.2):54000a206e4df4d5a94db253d3cb8a9f79e4a0ae"<br/>meta-oe           = "(detachedfrom9efaed9):9efaed99125b1c4324663d9a1b2d3319c74e7278"</p>&#13;
<p class="indent">As of this writing, the build process errors out on fetching the Bluez package.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_173"/>Remove the following file, and try <span class="literal">bitbake</span> again:</p>&#13;
<p class="programs">$ <span class="codestrong">rm /home/build/genivi-baseline/meta-ivi/meta-ivi/recipes-connectivity/bluez5/bluez5_%.bbappend</span></p>&#13;
<p class="indent">Once everything is finished, you should have images in your <em>tmp/deploy/ images/qemux86/</em> folder.</p>&#13;
<p class="indent">Now you’re ready to run your image in an emulator. For ARM emulation, run this:</p>&#13;
<p class="programs">$ <span class="codestrong">$GENIVI/meta-ivi/scripts/runqemu horizon-image vexpressa9</span></p>&#13;
<p class="indent">For x86, use this command:</p>&#13;
<p class="programs">$ <span class="codestrong">$GENIVI/poky/scripts/runqemu horizon-image qemux86</span></p>&#13;
<p class="indent">And this command is for x86-64:</p>&#13;
<p class="programs">$ <span class="codestrong">$GENIVI/poky/scripts/runqemu horizon-image qemux86-x64</span></p>&#13;
<p class="indent">You should now be ready to research a GENIVI-based IVI system. As you’ve seen, the steps can be a bit daunting. The most difficult part of working on GENIVI is getting it up and running. Once you have a system to look at, you can pick any executable to begin your security audit.</p>&#13;
<h4 class="h4" id="ch09lev2sec9"><strong><em>Automotive Grade Linux</em></strong></h4>&#13;
<p class="noindent"><em>Automotive Grade Linux (AGL)</em> is an IVI system that you can run on a physical IVI unit. Unlike GENIVI, AGL doesn’t have a costly board structure. AGL’s goals are similar to those of GENIVI: it’s trying to build an open source IVI unit as well as other related parts, such as telematics and instrument clusters.</p>&#13;
<p class="indent">As of this writing, you should be able to find a demo image of AGL for VMware (last released in 2013), installation instructions, and a bootable USB version for x86 at the AGL website (<em><a href="http://automotivelinux.org/">http://automotivelinux.org/</a></em>). These images are designed to run on in-vehicle computer hardware, like the Nexcom VTC-1000, a headless Linux device that comes with CAN and touchscreens. Unlike the GENIVI project, the AGL demonstration images are mainly designed and tested to run on hardware, although it may be possible to run some development images in a VM.</p>&#13;
<p class="indent">As you can see in <a href="ch09.html#ch9fig10">Figure 9-10</a>, the AGL demonstration image has a very pretty interface, but don’t expect all applications to run smoothly, as many are simply placeholders that are actively being built. Because AGL is normally tested on physical hardware, you’ll have to spend around $1,000 to get the hardware necessary to install AGL smoothly. It’s also possible to get an image to run on a QEMU VM as well. (One nice thing about buying a development IVI is that you can program it to work with any vehicle.)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_174"/><img src="graphics/f09-10.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch9fig10"/><em>Figure 9-10: Automotive Grade Linux sample screens</em></p>&#13;
<h3 class="h3" id="ch09lev1sec5"><strong>Acquiring an OEM IVI for Testing</strong></h3>&#13;
<p class="noindent">If you decide to run a physical IVI unit for testing, you’ll have to either pull a factory (OEM) IVI system from an existing vehicle or buy a development IVI, such as the Nexcom VTC-1000 or a model like those referenced in the Tizen hardware compatibility list (<em><a href="https://wiki.tizen.org/wiki/IVI/IVI_Platforms">https://wiki.tizen.org/wiki/IVI/IVI_Platforms</a></em>).</p>&#13;
<p class="indent">If you choose to go the OEM factory-installed route, you can buy one from the dealership or pull one from a junkyard. Development and OEM IVI units purchased directly from a dealership will typically run from $800 to $2,000, so it’s much more cost-effective to pull one from a junkyard, though it may be difficult to find your target high-end IVI system. You can also buy non-OEM aftermarket units, such as Kenwood or Pioneer, which—while often cheaper—typically won’t tie into a vehicle’s CAN system.</p>&#13;
<p class="indent">Unfortunately, pulling a radio out of a modern vehicle without destroying it isn’t an easy task. You’ll often need to remove the plastic around the gauge cluster on the dashboard and the plastic around the radio before you can remove the radio from its harness. If you run into an antitheft security code for the radio, check the owner’s manual for the code, if you’re lucky enough to find that. If you can’t find the code, be sure to grab the VIN <span epub:type="pagebreak" id="page_175"/>from the donor vehicle because you might need it to get or reset the antitheft PIN. (If you grabbed the ECU from the vehicle, remember you can query that to get the VIN as well.)</p>&#13;
<p class="indent">You’ll need to refer to the wiring diagram for your IVI system in order to get it to start on its own, but you can leave out most of the wires that you’re not testing. If you’re building an OEM-based unit, it may be worth your while to completely disassemble the unit and to connect any test connectors so that you’ll not only have the normal IVI system running but also be able to access any of the hidden connectors.</p>&#13;
<h3 class="h3" id="ch09lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">You should now be comfortable analyzing your existing radio system. We’ve covered how to safely work in a VM or test environment to find vulnerabilities in IVI systems. These systems hold a lot of code and are the most powerful electronic systems in a vehicle. Mastery of the IVI units will give you full control of your target, and there’s no part of a vehicle with a greater concentration of attack surface than the IVI system. When performing security research, an IVI and telematics system will provide you with the most valuable vulnerabilities, and you’ll find that the vulnerabilities found in these systems will often be remote or wireless and directly connected to the vehicle’s bus lines.<span epub:type="pagebreak" id="page_176"/></p>&#13;
</body></html>