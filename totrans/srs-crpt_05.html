<html><head></head><body>
<h2 class="h2" id="ch4"><span epub:type="pagebreak" id="page_53"/><span class="big">4</span><br/>BLOCK CIPHERS</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">During the Cold War, the US and Soviets developed their own ciphers. The US government created the Data Encryption Standard (DES), which was adopted as a federal standard from 1979 to 2005, while the KGB developed GOST 28147-89, an algorithm kept secret until 1990 and still used today. In 2000, the US-based National Institute of Standards and Technology (NIST) selected the successor to DES, called the <em>Advanced Encryption Standard (AES)</em>, an algorithm developed in Belgium and now found in most electronic devices. AES, DES, and GOST 28147-89 have something in common: they’re all <em>block ciphers</em>, a type of cipher that combines a core algorithm working on blocks of data with a mode of operation, or a technique to process sequences of data blocks.</p>
<p class="indent"><span epub:type="pagebreak" id="page_54"/>This chapter reviews the core algorithms that underlie block ciphers, discusses their modes of operation, and explains how they all work together. It also discusses how AES works and concludes with coverage of a classic attack tool from the 1970s, the meet-in-the-middle attack, and a favorite attack technique of the 2000s—padding oracles.</p>
<h3 class="h3" id="lev1sec27">What Is a Block Cipher?</h3>
<p class="noindentb">A block cipher consists of an encryption algorithm and a decryption algorithm:</p>
<ul>
<li class="noindent">The <em>encryption algorithm</em> (<strong>E</strong>) takes a key, <em>K</em>, and a plaintext block, <em>P</em>, and produces a ciphertext block, <em>C</em>. We write an encryption operation as <em>C</em> = <strong>E</strong>(<em>K</em>, <em>P</em>).</li>
<li class="noindent">The <em>decryption algorithm</em> (<strong>D</strong>) is the inverse of the encryption algorithm and decrypts a message to the original plaintext, <em>P</em>. This operation is written as <em>P</em> = <strong>D</strong>(<em>K</em>, <em>C</em>).</li>
</ul>
<p class="indentt">Since they’re the inverse of each other, the encryption and decryption algorithms usually involve similar operations.</p>
<h4 class="h4" id="lev2sec46"><em>Security Goals</em></h4>
<p class="noindent">If you’ve followed earlier discussions about encryption, randomness, and indistinguishability, the definition of a secure block cipher will come as no surprise. Again, we’ll define security as random-lookingness, so to speak.</p>
<p class="indent">In order for a block cipher to be secure, it should be a <em>pseudorandom permutation (PRP)</em>, meaning that as long as the key is secret, an attacker shouldn’t be able to compute an output of the block cipher from any input. That is, as long as <em>K</em> is secret and random from an attacker’s perspective, they should have no clue about what <strong>E</strong>(<em>K</em>, <em>P</em>) looks like, for any given <em>P</em>.</p>
<p class="indent">More generally, attackers should be unable to discover any <em>pattern</em> in the input/output values of a block cipher. In other words, it should be impossible to tell a block cipher from a truly random permutation, given black-box access to the encryption and decryption functions for some fixed and unknown key. By the same token, they should be unable to recover a secure block cipher’s secret key; otherwise, they would be able to use that key to tell the block cipher from a random permutation. Of course that also implies that attackers can’t predict the plaintext that corresponds to a given ciphertext produced by the block cipher.</p>
<h4 class="h4" id="lev2sec47"><em>Block Size</em></h4>
<p class="noindent">Two values characterize a block cipher: the block size and the key size. Security depends on both values. Most block ciphers have either 64-bit or 128-bit blocks—DES’s blocks have 64 (2<sup>6</sup>) bits, and AES’s blocks have 128 (2<sup>7</sup>) bits. In computing, lengths that are powers of two simplify data processing, storage, and addressing. But why 2<sup>6</sup> and 2<sup>7</sup> and not 2<sup>4</sup> or 2<sup>16</sup> bits?</p>
<p class="indent"><span epub:type="pagebreak" id="page_55"/>For one thing, it’s important that blocks are not too large in order to minimize both the length of ciphertext and the memory footprint. With regard to the length of the ciphertext, block ciphers process blocks, not bits. This means that in order to encrypt a 16-bit message when blocks are 128 bits, you’ll first need to convert the message into a 128-bit block, and only then will the block cipher process it and return a 128-bit ciphertext. The wider the blocks, the longer this overhead. As for the <em>memory footprint</em>, in order to process a 128-bit block, you need at least 128 bits of memory. This is small enough to fit in the registers of most CPUs or to be implemented using dedicated hardware circuits. Blocks of 64, 128, or even 512 bits are short enough to allow for efficient implementations in most cases. But larger blocks (for example, several kilobytes long) can have a noticeable impact on the cost and performance of implementations.</p>
<p class="indent">When ciphertexts’ length or memory footprint is critical, you may have to use 64-bit blocks, because these will produce shorter ciphertexts and consume less memory. Otherwise, 128-bit or larger blocks are better, mainly because 128-bit blocks can be processed more efficiently than 64-bit ones on modern CPUs and are also more secure. In particular, CPUs can leverage special CPU instructions in order to efficiently process one or more 128-bit blocks in parallel—for example, the Advanced Vector Extensions (AVX) family of instructions in Intel CPUs.</p>
<h4 class="h4" id="lev2sec48"><em>The Codebook Attack</em></h4>
<p class="noindent">While blocks shouldn’t be too large, they also shouldn’t be too small; otherwise, they may be susceptible to <em>codebook attacks</em>, which are attacks against block ciphers that are only efficient when smaller blocks are used. The codebook attack works like this with 16-bit blocks:</p>
<ol>
<li class="noindent"><p class="list">Get the 65536 (2<sup>16</sup>) ciphertexts corresponding to each 16-bit plaintext block.</p></li>
<li class="noindent"><p class="list">Build a lookup table—the <em>codebook</em>—mapping each ciphertext block to its corresponding plaintext block.</p></li>
<li class="noindent"><p class="list">To decrypt an unknown ciphertext block, look up its corresponding plaintext block in the table.</p></li>
</ol>
<p class="indent">When 16-bit blocks are used, the lookup table needs only 2<sup>16</sup> × 16 = 2<sup>20</sup> bits of memory, or 128 kilobytes. With 32-bit blocks, memory needs grow to 16 gigabytes, which is still manageable. But with 64-bit blocks, you’d have to store 2<sup>70</sup> bits (a zetabit, or 128 exabytes), so forget about it. Codebook attacks won’t be an issue for larger blocks.</p>
<h3 class="h3" id="lev1sec28">How to Construct Block Ciphers</h3>
<p class="noindent">There are hundreds of block ciphers but only a handful of techniques to construct one. First, a block cipher used in practice isn’t a gigantic algorithm but a repetition of <em>rounds</em>, a short sequence of operations that is weak on its <span epub:type="pagebreak" id="page_56"/>own but strong in number. Second, there are two main techniques to construct a round: substitution–permutation networks (as in AES) and Feistel schemes (as in DES). In this section, we look at how these work, after viewing an attack that works when all rounds are identical to each other.</p>
<h4 class="h4" id="lev2sec49"><em>A Block Cipher’s Rounds</em></h4>
<p class="noindent">Computing a block cipher boils down to computing a sequence of <em>rounds.</em> In a block cipher, a round is a basic transformation that is simple to specify and to implement, and which is iterated several times to form the block cipher’s algorithm. This construction, consisting of a small component repeated many times, is simpler to implement and to analyze than a construction that would consist of a single huge algorithm.</p>
<p class="indent">For example, a block cipher with three rounds encrypts a plaintext by computing <em>C</em> = <strong>R</strong><sub>3</sub>(<strong>R</strong><sub>2</sub>(<strong>R</strong><sub>1</sub>(<em>P</em>))), where the rounds are <strong>R</strong><sub>1</sub>, <strong>R</strong><sub>2</sub>, and <strong>R</strong><sub>3</sub> and <em>P</em> is a plaintext. Each round should also have an inverse in order to make it possible for a recipient to compute back to plaintext. Specifically, <em>P</em> = <strong>iR</strong><sub>1</sub>(<strong>iR</strong><sub>2</sub>(<strong>iR</strong><sub>3</sub>(<em>C</em>))), where <strong>iR</strong><sub>1</sub> is the inverse of <strong>R</strong><sub>1</sub>, and so on.</p>
<p class="indent">The round functions—<strong>R</strong><sub>1</sub>, <strong>R</strong><sub>2</sub>, and so on—are usually identical algorithms, but they are parameterized by a value called the <em>round key</em>. Two round functions with two distinct round keys will behave differently, and therefore will produce distinct outputs if fed with the same input.</p>
<p class="indent">Round keys are keys derived from the main key, <em>K</em>, using an algorithm called a <em>key schedule</em>. For example, <strong>R</strong><sub>1</sub> takes the round key <em>K</em><sub>1</sub>, <strong>R</strong><sub>2</sub> takes the round key <em>K</em><sub>2</sub>, and so on.</p>
<p class="indent">Round keys should always be different from each other in every round. For that matter, not all round keys should be equal to the key <em>K</em>. Otherwise, all the rounds would be identical and the block cipher would be less secure, as described next.</p>
<h4 class="h4" id="lev2sec50"><em>The Slide Attack and Round Keys</em></h4>
<p class="noindent">In a block cipher, no round should be identical to another round in order to avoid a <em>slide attack</em>. Slide attacks look for two plaintext/ciphertext pairs (<em>P</em><sub>1</sub>, <em>C</em><sub>1</sub>) and (<em>P</em><sub>2</sub>, <em>C</em><sub>2</sub>), where <em>P</em><sub>2</sub> = <strong>R</strong>(<em>P</em><sub>1</sub>) if <strong>R</strong> is the cipher’s round (see <a href="ch04.xhtml#ch4fig1">Figure 4-1</a>). When rounds are identical, the relation between the two plaintexts, <em>P</em><sub>2</sub> = <strong>R</strong>(<em>P</em><sub>1</sub>), implies the relation <em>C</em><sub>2</sub> = <strong>R</strong>(<em>C</em><sub>1</sub>) between their respective ciphertexts. <a href="ch04.xhtml#ch4fig1">Figure 4-1</a> shows three rounds, but the relation <em>C</em><sub>2</sub> = <strong>R</strong>(<em>C</em><sub>1</sub>) will hold no matter the number of rounds, be it 3, 10, or 100. The problem is that knowing the input and output of a single round often helps recover the key. (For details, read the 1999 paper by Biryukov and Wagner called “Advanced Slide Attacks,” available at <em><a href="https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf">https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf</a></em>)</p>
<p class="indent">The use of different round keys as parameters ensures that the rounds will behave differently and thus foil slide attacks.</p>
<div class="image"><span epub:type="pagebreak" id="page_57"/><img src="../images/f04-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig1"/><em>Figure 4-1: The principle of the slide attack, against block ciphers with identical rounds</em></p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>One potential byproduct and benefit of using round keys is protection against side-channel attacks, or attacks that exploit information leaked from the implementation of a cipher (for example, electromagnetic emanations). If the transformation from the main key</em>, K, <em>to a round key</em>, K<sub>i</sub>, <em>is not invertible, then if an attacker finds</em> K<sub>i</sub>, <em>they can’t use that key to find</em> K. <em>Unfortunately, few block ciphers have a one-way key schedule. The key schedule of AES allows attackers to compute</em> K <em>from any round key</em>, K<sub>i</sub>, for example.</p>
</div>
<h4 class="h4" id="lev2sec51"><em>Substitution–Permutation Networks</em></h4>
<p class="noindent">If you’ve read textbooks about cryptography, you’ll undoubtedly have read about <em>confusion</em> and <em>diffusion</em>. Confusion means that the input (plaintext and encryption key) undergoes complex transformations, and diffusion means that these transformations depend equally on all bits of the input. At a high level, confusion is about depth whereas diffusion is about breadth. In the design of a block cipher, confusion and diffusion take the form of substitution and permutation operations, which are combined within substitution–permutation networks (SPNs).</p>
<p class="indent">Substitution often appears in the form of <em>S-boxes</em>, or <em>substitution boxes</em>, which are small lookup tables that transform chunks of 4 or 8 bits. For example, the first of the eight S-boxes of the block cipher Serpent is composed of the 16 elements (3 8 f 1 a 6 5 b e d 4 2 7 0 9 c), where each element represents a 4-bit nibble. This particular S-box maps the 4-bit nibble 0000 to 3 (0011), the 4-bit nibble 0101 (5 in decimal) to 6 (0110), and so on.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>S-boxes must be carefully chosen to be cryptographically strong: they should be as nonlinear as possible (inputs and outputs should be related with complex equations) and have no statistical bias (meaning, for example, that flipping an input bit should potentially affect any of the output bits).</em></p>
</div>
<p class="indentt">The permutation in a substitution–permutation network can be as simple as changing the order of the bits, which is easy to implement but doesn’t mix up the bits very much. Instead of a reordering of the bits, some ciphers use basic linear algebra and matrix multiplications to mix up the bits: they perform a series of multiplication operations with fixed values (the matrix’s <span epub:type="pagebreak" id="page_58"/>coefficients) and then add the results. Such linear algebra operations can quickly create dependencies between all the bits within a cipher and thus ensure strong diffusion. For example, the block cipher FOX transforms a 4-byte vector (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>) to (<em>a</em>′, <em>b</em>′, <em>c</em>′, <em>d</em>′), defined as follows:</p>
<div class="image91"><img src="../images/f0058-01.jpg" alt="image"/></div>
<p class="indent">In the above equations, the numbers 2 and 253 are interpreted as binary polynomials rather than integers; hence, additions and multiplications are defined a bit differently than what we’re used to. For example, instead of having 2 + 2 = 4, we have 2 + 2 = 0. Regardless, the point is that each byte in the initial state affects all 4 bytes in the final state.</p>
<h4 class="h4" id="lev2sec52"><em>Feistel Schemes</em></h4>
<p class="noindent">In the 1970s, IBM engineer Horst Feistel designed a block cipher called Lucifer that works as follows:</p>
<ol>
<li class="noindent"><p class="list">Split the 64-bit block into two 32-bit halves, <em>L</em> and <em>R</em>.</p></li>
<li class="noindent"><p class="list">Set <em>L</em> to <em>L</em> ⊕ <strong>F</strong>(<em>R</em>), where <strong>F</strong> is a substitution–permutation round.</p></li>
<li class="noindent"><p class="list">Swap the values of <em>L</em> and <em>R</em>.</p></li>
<li class="noindent"><p class="list">Go to step 2 and repeat 15 times.</p></li>
<li class="noindent"><p class="list">Merge <em>L</em> and <em>R</em> into the 64-bit output block.</p></li>
</ol>
<p class="indent">This construction became known as a <em>Feistel scheme</em>, as shown in <a href="ch04.xhtml#ch4fig2">Figure 4-2</a>. The left side is the scheme as just described; the right side is a functionally equivalent representation where, instead of swapping <em>L</em> and <em>R</em>, rounds alternate the operations <em>L</em> = <em>L</em> ⊕ <strong>F</strong>(<em>R</em>) and <em>R</em> = <em>R</em> ⊕ <strong>F</strong>(<em>L</em>).</p>
<div class="image"><img src="../images/f04-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig2"/><em>Figure 4-2: The Feistel scheme block cipher construction in two equivalent forms</em></p>
<p class="indent">I’ve omitted the keys from <a href="ch04.xhtml#ch4fig2">Figure 4-2</a> to simplify the diagrams, but note that the first <strong>F</strong> takes a first round key, <em>K</em><sub>1</sub>, and the second <strong>F</strong> takes another round key, <em>K</em><sub>2</sub>. In DES, the <strong>F</strong> functions take a 48-bit round key, which is derived from the 56-bit key, <em>K</em>.</p>
<p class="indent">In a Feistel scheme, the <strong>F</strong> function can be either a pseudorandom permutation (PRP) or a pseudorandom function (PRF). A PRP yields distinct outputs for any two distinct inputs, whereas a PRF will have values <em>X</em> and <em>Y</em> for which <strong>F</strong>(<em>X</em>) = <strong>F</strong>(<em>Y</em>). But in a Feistel scheme, that difference doesn’t matter as long as <strong>F</strong> is cryptographically strong.</p>
<p class="indent"><span epub:type="pagebreak" id="page_59"/>How many rounds should there be in a Feistel scheme? Well, DES performs 16 rounds, whereas GOST 28147-89 performs 32 rounds. If the <strong>F</strong> function is as strong as possible, four rounds are in theory sufficient, but real ciphers use more rounds to defend against potential weaknesses in <strong>F</strong>.</p>
<h3 class="h3" id="lev1sec29">The Advanced Encryption Standard (AES)</h3>
<p class="noindent">AES is the most-used cipher in the universe. Prior to the adoption of AES, the standard cipher in use was DES, with its ridiculous 56-bit security, as well as the upgraded version of DES known as Triple DES, or 3DES.</p>
<p class="indent">Although 3DES provides a higher level of security (112-bit security), it’s inefficient because the key needs to be 168 bits long in order to get 112-bit security, and it’s slow in software (DES was created to be fast in integrated circuits, not on mainstream CPUs). AES fixes both issues.</p>
<p class="indent">NIST standardized AES in 2000 as a replacement for DES, at which point it became the world’s de facto encryption standard. Most commercial encryption products today support AES, and the NSA has approved it for protecting top-secret information. (Some countries do prefer to use their own cipher, largely because they don’t want to use a US standard, but AES is actually more Belgian than it is American.)</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>AES used to be called Rijndael (a portmanteau for its inventors’ names, Rijmen and Daemen, pronounced like “rain-dull”) when it was one of the 15 candidates in the AES competition, the process held by NIST from 1997 to 2000 to specify “an unclassified, publicly disclosed encryption algorithm capable of protecting sensitive government information well into the next century,” as stated in the 1997 announcement of the competition in the Federal Register. The AES competition was kind of a “Got Talent” competition for cryptographers, where anyone could participate by submitting a cipher or breaking other contestants’ ciphers.</em></p>
</div>
<h4 class="h4" id="lev2sec53"><em>AES Internals</em></h4>
<p class="noindent">AES processes blocks of 128 bits using a secret key of 128, 192, or 256 bits, with the 128-bit key being the most common because it makes encryption slightly faster and because the difference between 128- and 256-bit security is meaningless for most applications.</p>
<div class="image"><img src="../images/f04-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig3"/><em>Figure 4-3: The internal state of AES viewed as a 4 × 4 array of 16 bytes</em></p>
<p class="indent">Whereas some ciphers work with individual bits or 64-bit words, AES manipulates <em>bytes</em>. It views a 16-byte plaintext as a two-dimensional array of bytes (<em>s</em> = <em>s</em><sub>0</sub>, <em>s</em><sub>1</sub>, … , <em>s</em><sub>15</sub>), as shown in <a href="ch04.xhtml#ch4fig3">Figure 4-3</a>. (The letter <em>s</em> is used because this array is called the <em>internal state</em>, or just <em>state</em>.) AES transforms the bytes, columns, and rows of this array to produce a final value that is the ciphertext.</p>
<p class="indent"><span epub:type="pagebreak" id="page_60"/>In order to transform its state, AES uses an SPN structure like the one shown in <a href="ch04.xhtml#ch4fig4">Figure 4-4</a>, with 10 rounds for 128-bit keys, 12 for 192-bit keys, and 14 for 256-bit keys.</p>
<div class="image"><img src="../images/f04-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig4"/><em>Figure 4-4: The internal operations of AES</em></p>
<p class="indentb"><a href="ch04.xhtml#ch4fig4">Figure 4-4</a> shows the four building blocks of an AES round (note that all but the last round are a sequence of SubBytes, ShiftRows, MixColumns, and AddRoundKey):</p>
<p class="hang"><strong>AddRoundKey</strong> XORs a round key to the internal state.</p>
<p class="hang"><strong>SubBytes</strong> Replaces each byte (<em>s</em><sub>0</sub>, <em>s</em><sub>1</sub>, … , <em>s</em><sub>15</sub>) with another byte according to an S-box. In this example, the S-box is a lookup table of 256 elements.</p>
<p class="hang"><strong>ShiftRows</strong> Shifts the <em>i</em>th row of <em>i</em> positions, for <em>i</em> ranging from 0 to 3 (see <a href="ch04.xhtml#ch4fig5">Figure 4-5</a>).</p>
<p class="hang"><strong>MixColumns</strong> Applies the same linear transformation to each of the four columns of the state (that is, each group of cells with the same shade of gray, as shown on the left side of <a href="ch04.xhtml#ch4fig5">Figure 4-5</a>).</p>
<p class="indent">Remember that in an SPN, the <em>S</em> stands for substitution and the <em>P</em> for permutation. Here, the substitution layer is SubBytes and the permutation layer is the combination of ShiftRows and MixColumns.</p>
<p class="indent">The key schedule function <em>KeyExpansion</em>, shown in <a href="ch04.xhtml#ch4fig4">Figure 4-4</a>, is the AES key schedule algorithm. This expansion creates 11 round keys (<em>K</em><sub>0</sub>, <em>K</em><sub>1</sub>, … , <em>K</em><sub>10</sub>) of 16 bytes each from the 16-byte key, using the same S-box as SubBytes and a combination of XORs. One important property of <span epub:type="pagebreak" id="page_61"/>KeyExpansion is that given any round key, <em>K</em><sub><em>i</em></sub>, an attacker can determine all other round keys as well as the main key, <em>K</em>, by reversing the algorithm. The ability to get the key from any round key is usually seen as an imperfect defense against side-channel attacks, where an attacker may easily recover a round key.</p>
<div class="image"><img src="../images/f04-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig5"/><em>Figure 4-5: ShiftRows rotates bytes within each row of the internal state.</em></p>
<p class="indentt">Without these operations, AES would be totally insecure. Each operation contributes to AES’s security in a specific way:</p>
<ul>
<li class="noindent">Without KeyExpansion, all rounds would use the same key, <em>K</em>, and AES would be vulnerable to slide attacks.</li>
<li class="noindent">Without AddRoundKey, encryption wouldn’t depend on the key; hence, anyone could decrypt any ciphertext without the key.</li>
<li class="noindent">SubBytes brings nonlinear operations, which add cryptographic strength. Without it, AES would just be a large system of linear equations that is solvable using high-school algebra.</li>
<li class="noindent">Without ShiftRows, changes in a given column would never affect the other columns, meaning you could break AES by building four 2<sup>32</sup>-element codebooks for each column. (Remember that in a secure block cipher, flipping a bit in the input should affect all the output bits.)</li>
<li class="noindent">Without MixColumns, changes in a byte would not affect any other bytes of the state. A chosen-plaintext attacker could then decrypt any ciphertext after storing 16 lookup tables of 256 bytes each that hold the encrypted values of each possible value of a byte.</li>
</ul>
<p class="indentt">Notice in <a href="ch04.xhtml#ch4fig4">Figure 4-4</a> that the last round of AES doesn’t include the MixColumns operation. That operation is omitted in order to save useless computation: because MixColumns is linear (meaning, predictable), you could cancel its effect in the very last round by combining bits in a way that doesn’t depend on their value or the key. SubBytes, however, can’t be inverted without the state’s value being known prior to AddRoundKey.</p>
<p class="indent">To decrypt a ciphertext, AES unwinds each operation by taking its inverse function: the inverse lookup table of SubBytes reverses the SubBytes transformation, ShiftRow shifts in the opposite direction, <span epub:type="pagebreak" id="page_62"/>MixColumns’s inverse is applied (as in the matrix inverse of the matrix encoding its operation), and AddRoundKey’s XOR is unchanged because the inverse of an XOR is another XOR.</p>
<h4 class="h4" id="lev2sec54"><em>AES in Action</em></h4>
<p class="noindent">To try encrypting and decrypting with AES, you can use Python’s crypto­graphy library, as in <a href="ch04.xhtml#ch4list1">Listing 4-1</a>.</p>
<p class="programs">#!/usr/bin/env python<br/><br/>from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes<br/>from cryptography.hazmat.backends import default_backend<br/>from binascii import hexlify as hexa<br/>from os import urandom<br/><br/># pick a random 16-byte key using Python's crypto PRNG<br/>k = urandom(16)<br/>print "k = %s" % hexa(k)<br/># create an instance of AES-128 to encrypt a single block<br/>cipher = Cipher(algorithms.AES(k), modes.ECB(), backend = default_backend())<br/>aes_encrypt = cipher.encryptor()<br/><br/># set plaintext block p to the all-zero string<br/>p = '\x00'*16<br/># encrypt plaintext p to ciphertext c<br/>c = aes_encrypt.update(p) + aes_encrypt.finalize()<br/>print "enc(%s) = %s" % (hexa(p), hexa(c))<br/># decrypt ciphertext c to plaintext p<br/>aes_decrypt = cipher.decryptor()<br/>p = aes_decrypt.update(c) + aes_decrypt.finalize()<br/>print "dec(%s) = %s" % (hexa(c), hexa(p))</p>
<p class="figcap"><a id="ch4list1"/><em>Listing 4-1: Trying AES with Python’s cryptography library</em></p>
<p class="indent">Running this script produces something like the following output:</p>
<p class="programs">$ <span class="codestrong">./aes_block.py</span><br/>k = 2c6202f9a582668aa96d511862d8a279<br/>enc(00000000000000000000000000000000) = 12b620bb5eddcde9a07523e59292a6d7<br/>dec(12b620bb5eddcde9a07523e59292a6d7) = 00000000000000000000000000000000</p>
<p class="indent">You’ll get different results because the key is randomized at every new execution.</p>
<h3 class="h3" id="lev1sec30">Implementing AES</h3>
<p class="noindent">Real AES software works differently than the algorithm shown in <a href="ch04.xhtml#ch4fig4">Figure 4-4</a>. You won’t find production-level AES code calling a <span class="literal">SubBytes()</span> function, then a <span class="literal">ShiftRows()</span> function, and then a <span class="literal">MixColumns()</span> function because that would be inefficient. Instead, fast AES software uses special techniques called table-based implementations and native instructions.</p>
<h4 class="h4" id="lev2sec55"><span epub:type="pagebreak" id="page_63"/><em>Table-Based Implementations</em></h4>
<p class="noindent">Table-based implementations of AES replace the sequence SubBytes-ShiftRows-MixColumns with a combination of XORs and lookups in tables hardcoded into the program and loaded in memory at execution time. This is possible because MixColumns is equivalent to XORing four 32-bit values, where each depends on a single byte from the state and on SubBytes. Thus, you can build four tables with 256 entries each, one for each byte value, and implement the sequence SubBytes-MixColumns by looking up four 32-bit values and XORing them together.</p>
<p class="indent">For example, the table-based C implementation in the OpenSSL toolkit looks like <a href="ch04.xhtml#ch4list2">Listing 4-2</a>.</p>
<p class="programs8">    /* round 1: */<br/>    t0 = Te0[s0 &gt;&gt; 24] ^ Te1[(s1 &gt;&gt; 16) &amp; 0xff] ^ Te2[(s2 &gt;&gt; 8) &amp; 0xff] ^ Te3[s3 &amp; 0xff] ^ rk[ 4];<br/>    t1 = Te0[s1 &gt;&gt; 24] ^ Te1[(s2 &gt;&gt; 16) &amp; 0xff] ^ Te2[(s3 &gt;&gt; 8) &amp; 0xff] ^ Te3[s0 &amp; 0xff] ^ rk[ 5];<br/>    t2 = Te0[s2 &gt;&gt; 24] ^ Te1[(s3 &gt;&gt; 16) &amp; 0xff] ^ Te2[(s0 &gt;&gt; 8) &amp; 0xff] ^ Te3[s1 &amp; 0xff] ^ rk[ 6];<br/>    t3 = Te0[s3 &gt;&gt; 24] ^ Te1[(s0 &gt;&gt; 16) &amp; 0xff] ^ Te2[(s1 &gt;&gt; 8) &amp; 0xff] ^ Te3[s2 &amp; 0xff] ^ rk[ 7];<br/>    /* round 2: */<br/>    s0 = Te0[t0 &gt;&gt; 24] ^ Te1[(t1 &gt;&gt; 16) &amp; 0xff] ^ Te2[(t2 &gt;&gt; 8) &amp; 0xff] ^ Te3[t3 &amp; 0xff] ^ rk[ 8];<br/>    s1 = Te0[t1 &gt;&gt; 24] ^ Te1[(t2 &gt;&gt; 16) &amp; 0xff] ^ Te2[(t3 &gt;&gt; 8) &amp; 0xff] ^ Te3[t0 &amp; 0xff] ^ rk[ 9];<br/>    s2 = Te0[t2 &gt;&gt; 24] ^ Te1[(t3 &gt;&gt; 16) &amp; 0xff] ^ Te2[(t0 &gt;&gt; 8) &amp; 0xff] ^ Te3[t1 &amp; 0xff] ^ rk[10];<br/>    s3 = Te0[t3 &gt;&gt; 24] ^ Te1[(t0 &gt;&gt; 16) &amp; 0xff] ^ Te2[(t1 &gt;&gt; 8) &amp; 0xff] ^ Te3[t2 &amp; 0xff] ^ rk[11];<br/>--<span class="codeitalic">snip</span>--</p>
<p class="figcap"><a id="ch4list2"/><em>Listing 4-2: The table-based C implementation of AES in OpenSSL</em></p>
<p class="indent">A basic table-based implementation of AES encryption needs four kilobytes’ worth of tables because each table stores 256 32-bit values, which occupy 256 × 32 = 8192 bits, or one kilobyte. Decryption requires another four tables, and thus four more kilobytes. But there are tricks to reduce the storage from four kilobytes to one, or even fewer.</p>
<p class="indent">Alas, table-based implementations are vulnerable to <em>cache-timing attacks</em>, which exploit timing variations when a program reads or writes elements in cache memory. Depending on the relative position in cache memory of the elements accessed, access time varies. Timings thus leak information about which element was accessed, which in turn leaks information on the secrets involved.</p>
<p class="indent">Cache-timing attacks are difficult to avoid. One obvious solution would be to ditch lookup tables altogether by writing a program whose execution time doesn’t depend on its inputs, but that’s almost impossible to do and still retain the same speed, so chip manufacturers have opted for a radical solution: instead of relying on potentially vulnerable software, they rely on <em>hardware</em>.</p>
<h4 class="h4" id="lev2sec56"><em>Native Instructions</em></h4>
<p class="noindent">AES native instructions (AES-NI) solve the problem of cache-timing attacks on AES software implementations. To understand how AES-NI works, you need to think about the way software runs on hardware: to run a program, a <span epub:type="pagebreak" id="page_64"/>microprocessor translates binary code into a series of instructions executed by integrated circuit components. For example, a <span class="literal">MUL</span> assembly instruction between two 32-bit values will activate the transistors implementing a 32-bit multiplier in the microprocessor. To implement a crypto algorithm, we usually just express a combination of such basic operations—additions, multiplications, XORs, and so on—and the microprocessor activates its adders, multipliers, and XOR circuits in the prescribed order.</p>
<p class="indent">AES native instructions take this to a whole new level by providing developers with dedicated assembly instructions that compute AES. Instead of coding an AES round as a sequence of assembly instructions, when using AES-NI, you just call the instruction <span class="literal">AESENC</span> and the chip will compute the round for you. Native instructions allow you to just tell the processor to run an AES round instead of requiring you to program rounds as a combination of basic operations.</p>
<p class="indent">A typical assembly implementation of AES using native instructions looks like <a href="ch04.xhtml#ch4list3">Listing 4-3</a>.</p>
<p class="programs">PXOR       %xmm5,  %xmm0<br/>AESENC     %xmm6,  %xmm0<br/>AESENC     %xmm7,  %xmm0<br/>AESENC     %xmm8,  %xmm0<br/>AESENC     %xmm9,  %xmm0<br/>AESENC     %xmm10, %xmm0<br/>AESENC     %xmm11, %xmm0<br/>AESENC     %xmm12, %xmm0<br/>AESENC     %xmm13, %xmm0<br/>AESENC     %xmm14, %xmm0<br/>AESENCLAST %xmm15, %xmm0</p>
<p class="figcap"><a id="ch4list3"/><em>Listing 4-3: AES native instructions</em></p>
<p class="indent">This code encrypts the 128-bit plaintext initially in the register <span class="literal">xmm0</span>, assuming that registers <span class="literal">xmm5</span> to <span class="literal">xmm15</span> hold the precomputed round keys, with each instruction writing its result into <span class="literal">xmm0</span>. The initial <span class="literal">PXOR</span> instruction XORs the first round key prior to computing the first round, and the final <span class="literal">AESENCLAST</span> instruction performs the last round slightly different from the others (MixColumns is omitted).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>AES is about ten times faster on platforms that implement native instructions, which as I write this, are virtually all laptop, desktop, and server microprocessors, as well as most mobile phones and tablets. In fact, on the latest Intel microarchitecture the <span class="literalital">AESENC</span> instruction has a latency of four cycles with a reciprocal throughput of one cycle, meaning that a call to <span class="literalital">AESENC</span> takes four cycles to complete and that a new call can be made every cycle. To encrypt a series of blocks consecutively it thus takes 4 × 10 = 40 cycles to complete the 10 rounds or 40 / 16 = 2.5 cycles per byte. At 2 GHz (2 × 10 <sup>9</sup> cycles per second), that gives a throughput of about 736 megabytes per second. If the blocks to encrypt or decrypt are independent of each other, as certain modes of operation allow, then four blocks can be processed in parallel to take full advantage of the <span class="literalital">AESENC</span> circuit in order to reach a latency of 10 cycles per block instead of 40, or about 3 gigabytes per second.</em></p>
</div>
<h4 class="h4" id="lev2sec57"><span epub:type="pagebreak" id="page_65"/><em>Is AES Secure?</em></h4>
<p class="noindent">AES is as secure as a block cipher can be, and it will never be broken. Fundamentally, AES is secure because all output bits depend on all input bits in some complex, pseudorandom way. To achieve this, the designers of AES carefully chose each component for a particular reason—MixColumns for its maximal diffusion properties and SubBytes for its optimal non-linearity—and they have shown that this composition protects AES against whole classes of cryptanalytic attacks.</p>
<p class="indent">But there’s no proof that AES is immune to all possible attacks. For one thing, we don’t know what all possible attacks are, and we don’t always know how to prove that a cipher is secure against a given attack. The only way to really gain confidence in the security of AES is to crowdsource attacks: have many skilled people attempt to break AES and, hopefully, fail to do so.</p>
<p class="indent">After more than 15 years and hundreds of research publications, the theoretical security of AES has only been scratched. In 2011 cryptanalysts found a way to recover an AES-128 key by performing about 2<sup>126</sup> operations instead of 2<sup>128</sup>, a speed-up of a factor four. But this “attack” requires an insane amount of plaintext–ciphertext pairs—about 2<sup>88</sup> bits worth. In other words, it’s a nice finding but not one you need to worry about.</p>
<p class="indent">The upshot is that you should care about a million things when implementing and deploying crypto, but AES security is not one of those. The biggest threat to block ciphers isn’t in their core algorithms but in their modes of operation. When an incorrect mode is chosen, or when the right one is misused, even a strong cipher like AES won’t save you.</p>
<h3 class="h3" id="lev1sec31">Modes of Operation</h3>
<p class="noindent">In <a href="ch01.xhtml#ch1">Chapter 1</a>, I explained how encryption schemes combine a permutation with a mode of operation to handle messages of any length. In this section, I’ll cover the main modes of operations used by block ciphers, their security and function properties, and how (not) to use them. I’ll begin with the dumbest one: electronic codebook.</p>
<h4 class="h4" id="lev2sec58"><em>The Electronic Codebook (ECB) Mode</em></h4>
<div class="image"><img src="../images/f04-06.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig6"/><em>Figure 4-6: The ECB mode</em></p>
<p class="noindent">The simplest of the block cipher encryption modes is electronic codebook (ECB), which is barely a mode of operation at all. ECB takes plaintext blocks <em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, … , <em>P</em><sub><em>N</em></sub> and processes each independently by computing <em>C</em><sub>1</sub> = <strong>E</strong>(<em>K</em>, <em>P</em><sub>1</sub>), <em>C</em><sub>2</sub> = <strong>E</strong>(<em>K</em>, <em>P</em><sub>2</sub>), and so on, as shown in <a href="ch04.xhtml#ch4fig6">Figure 4-6</a>. It’s a simple operation but also an insecure one. I repeat: ECB is insecure and you should not use it!</p>
<p class="indent">Marsh Ray, a cryptographer at Microsoft, once said, “Everybody knows ECB mode is bad because we can see the penguin.” He was referring to a famous illustration of ECB’s insecurity <span epub:type="pagebreak" id="page_66"/>that uses an image of Linux’s mascot, Tux, as shown in <a href="ch04.xhtml#ch4fig7">Figure 4-7</a>. You can see the original image of Tux on the left, and the image encrypted in ECB mode using AES (though the underlying cipher doesn’t matter) on the right. It’s easy to see the penguin’s shape in the encrypted version because all the blocks of one shade of gray in the original image are encrypted to the same new shade of gray in the new image; in other words, ECB encryption just gives you the same image but with different colors.</p>
<div class="image"><img src="../images/f04-07.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig7"/><em>Figure 4-7: The original image (left) and the ECB-encrypted image (right)</em></p>
<p class="indent">The Python program in <a href="ch04.xhtml#ch4list4">Listing 4-4</a> also shows ECB’s insecurity. It picks a pseudorandom key and encrypts a 32-byte message <span class="literal">p</span> containing two blocks of null bytes. Notice that encryption yields two identical blocks and that repeating encryption with the same key and the same plaintext yields the same two blocks again.</p>
<p class="programs">#!/usr/bin/env python<br/><br/>from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes<br/>from cryptography.hazmat.backends import default_backend<br/>from binascii import hexlify as hexa<br/>from os import urandom<br/><br/>BLOCKLEN = 16<br/>def blocks(data):<br/>    split = [hexa(data[i:i+BLOCKLEN]) for i in range(0, len(data), BLOCKLEN)]<br/>    return ' '.join(split)<br/><br/>k = urandom(16)<br/>print 'k = %s' % hexa(k)<br/><br/># create an instance of AES-128 to encrypt and decrypt<br/>cipher = Cipher(algorithms.AES(k), modes.ECB(), backend=default_backend())<br/>aes_encrypt = cipher.encryptor()<br/># set plaintext block p to the all-zero string<br/>p = '\x00'*BLOCKLEN*2<br/><br/># encrypt plaintext p to ciphertext c<br/>c = aes_encrypt.update(p) + aes_encrypt.finalize()<br/>print 'enc(%s) = %s' % (blocks(p), blocks(c))</p>
<p class="figcap"><span epub:type="pagebreak" id="page_67"/><a id="ch4list4"/><em>Listing 4-4: Using AES in ECB mode in Python</em></p>
<p class="indent">Running this script gives ciphertext blocks like this, for example:</p>
<p class="programs">$ <span class="codestrong">./aes_ecb.py</span><br/>k = 50a0ebeff8001250e87d31d72a86e46d<br/>enc(00000000000000000000000000000000 00000000000000000000000000000000) =<br/>5eb4b7af094ef7aca472bbd3cd72f1ed 5eb4b7af094ef7aca472bbd3cd72f1ed</p>
<p class="indent">As you can see, when the ECB mode is used, identical ciphertext blocks reveal identical plaintext blocks to an attacker, whether those are blocks within a single ciphertext or across different ciphertexts. This shows that block ciphers in ECB mode aren’t semantically secure.</p>
<p class="indent">Another problem with ECB is that it only takes complete blocks of data, so if blocks were 16 bytes, as in AES, you could only encrypt chunks of 16 bytes, 32 bytes, 48 bytes, or any other multiple of 16 bytes. There are a few ways to deal with this, as you’ll see with the next mode, CBC. (I won’t tell you how these tricks work with ECB because you shouldn’t be using ECB in the first place.)</p>
<h4 class="h4" id="lev2sec59"><em>The Cipher Block Chaining (CBC) Mode</em></h4>
<p class="noindent">Cipher block chaining (CBC) is like ECB but with a small twist that makes a big difference: instead of encrypting the <em>i</em>th block, <em>P</em><sub><em>i</em></sub>, as <em>C</em><sub><em>i</em></sub> = <strong>E</strong>(<em>K</em>, <em>P</em><sub><em>i</em></sub>), CBC sets <em>C</em><sub><em>i</em></sub> = <strong>E</strong>(<em>K</em>, <em>P</em><sub><em>i</em></sub> ⊕ <em>C</em><sub><em>i</em> − 1</sub>), where <em>C</em><sub><em>i</em> − 1</sub> is the previous ciphertext block—thereby <em>chaining</em> the blocks <em>C</em><sub><em>i</em> − 1</sub> and <em>C</em><sub><em>i</em></sub>. When encrypting the first block, <em>P</em><sub>1</sub>, there is no previous ciphertext block to use, so CBC takes a random initial value (IV), as shown in <a href="ch04.xhtml#ch4fig8">Figure 4-8</a>.</p>
<div class="image"><img src="../images/f04-08.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig8"/><em>Figure 4-8: The CBC mode</em></p>
<p class="indent">The CBC mode makes each ciphertext block dependent on all the previous blocks, and ensures that identical plaintext blocks won’t be identical ciphertext blocks. The random initial value guarantees that two identical plaintexts will encrypt to distinct ciphertexts when calling the cipher twice with two distinct initial values.</p>
<p class="indent"><a href="ch04.xhtml#ch4list5">Listing 4-5</a> illustrates these two benefits. This program takes an all-zero, 32-byte message (like the one in <a href="ch04.xhtml#ch4list4">Listing 4-4</a>), encrypts it twice with CBC, and shows the two ciphertexts. The line <span class="literal">iv = urandom(16)</span>, shown in bold, picks a new random IV for each new encryption.<span epub:type="pagebreak" id="page_68"/></p>
<p class="programs8">#!/usr/bin/env python<br/><br/>from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes<br/>from cryptography.hazmat.backends import default_backend<br/>from binascii import hexlify as hexa<br/>from os import urandom<br/><br/>BLOCKLEN = 16<br/># the blocks() function splits a data string into space-separated blocks<br/>def blocks(data):<br/>    split = [hexa(data[i:i+BLOCKLEN]) for i in range(0, len(data), BLOCKLEN)]<br/>    return ' '.join(split)<br/>k = urandom(16)<br/>print 'k = %s' % hexa(k)<br/># pick a random IV<br/><span class="codestrong">iv = urandom(16)</span><br/>print 'iv = %s' % hexa(iv)<br/># pick an instance of AES in CBC mode<br/>aes = Cipher(algorithms.AES(k), modes.CBC(iv), backend=default_backend()).encryptor()<br/><br/>p = '\x00'*BLOCKLEN*2<br/>c = aes.update(p) + aes.finalize()<br/>print 'enc(%s) = %s' % (blocks(p), blocks(c))<br/># now with a different IV and the same key<br/><span class="codestrong">iv = urandom(16)</span><br/>print 'iv = %s' % hexa(iv)<br/>aes = Cipher(algorithms.AES(k), modes.CBC(iv), backend=default_backend()).encryptor()<br/>c = aes.update(p) + aes.finalize()<br/>print 'enc(%s) = %s' % (blocks(p), blocks(c))</p>
<p class="figcap"><a id="ch4list5"/><em>Listing 4-5: Using AES in CBC mode</em></p>
<p class="indentt">The two plaintexts are the same (two all-zero blocks), but the encrypted blocks should be distinct, as in this example execution:</p>
<p class="programs">$ <span class="codestrong">./aes_cbc.py</span><br/>k = 9cf0d31ad2df24f3cbbefc1e6933c872<br/>iv = 0a75c4283b4539c094fc262aff0d17af<br/>enc(00000000000000000000000000000000 00000000000000000000000000000000) =<br/>370404dcab6e9ecbc3d24ca5573d2920 3b9e5d70e597db225609541f6ae9804a<br/>iv = a6016a6698c3996be13e8739d9e793e2<br/>enc(00000000000000000000000000000000 00000000000000000000000000000000) =<br/>655e1bb3e74ee8cf9ec1540afd8b2204 b59db5ac28de43b25612dfd6f031087a</p>
<p class="indent">Alas, CBC is often used with a constant IV instead of a random one, which exposes identical plaintexts and plaintexts that start with identical blocks. For example, say the two-block plaintext <em>P</em><sub>1</sub> || <em>P</em><sub>2</sub> is encrypted in CBC mode to the two-block ciphertext <em>C</em><sub>1</sub> || <em>C</em><sub>2</sub>. If <em>P</em><sub>1</sub> || <em>P</em><sub>2</sub>′ is encrypted with the same IV, where <em>P</em><sub>2</sub>′ is some block distinct from <em>P</em><sub>2</sub>, then the ciphertext will <span epub:type="pagebreak" id="page_69"/>look like <em>C</em><sub>1</sub> || <em>C</em><sub>2</sub>′, with <em>C</em><sub>2</sub>′ different from <em>C</em><sub>2</sub> but with the same first block <em>C</em><sub>1</sub>. Thus, an attacker can guess that the first block is the same for both plaintexts, even though they only see the ciphertexts.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In CBC mode, decryption needs to know the IV used to encrypt, so the IV is sent along with the ciphertext, in the clear.</em></p>
</div>
<p class="indent">With CBC, decryption can be much faster than encryption due to parallelism. While encryption of a new block, <em>P</em><sub><em>i</em></sub><em>,</em> needs to wait for the previous block, <em>C</em><sub><em>i</em> − 1</sub>, decryption of a block computes <em>P</em><sub><em>i</em></sub> = <strong>D</strong>(<em>K</em>, <em>C</em><sub><em>i</em></sub>) ⊕ <em>C</em><sub><em>i</em> − 1</sub>, where there’s no need for the previous plaintext block, <em>P</em><sub><em>i</em> − 1</sub>. This means that all blocks can be decrypted in parallel simultaneously, as long as you also know the previous ciphertext block, which you usually do.</p>
<h4 class="h4" id="lev2sec60"><em>How to Encrypt Any Message in CBC Mode</em></h4>
<p class="noindent">Let’s circle back to the block termination issue and look at how to process a plaintext whose length is not a multiple of the block length. For example, how would we encrypt an 18-byte plaintext with AES-CBC when blocks are 16 bytes? What do we do with the two bytes left? We’ll look at two widely used techniques to deal with this problem. The first one, padding, makes the ciphertext a bit longer than the plaintext, while the second one, <em>ciphertext stealing</em>, produces a ciphertext of the same length as the plaintext.</p>
<h5 class="h5">Padding a Message</h5>
<p class="noindent">Padding is a technique that allows you to encrypt a message of any length, even one smaller than a single block. Padding for block ciphers is specified in the PKCS#7 standard and in RFC 5652, and is used almost everywhere CBC is used, such as in some HTTPS connections.</p>
<p class="indent">Padding is used to expand a message to fill a complete block by adding extra bytes to the plaintext. Here are the rules for padding 16-byte blocks:</p>
<ul>
<li class="noindent">If there’s one byte left—for example, if the plaintext is 1 byte, 17 bytes, or 33 bytes long—pad the message with 15 bytes 0f (15 in decimal).</li>
<li class="noindent">If there are two bytes left, pad the message with 14 bytes 0e (14 in decimal).</li>
<li class="noindent">If there are three bytes left, pad the message with 13 bytes 0d (13 in decimal).</li>
</ul>
<p class="indentt">If there are 15 plaintext bytes and a single byte missing to fill a block, padding adds a single 01 byte. If the plaintext is already a multiple of 16, the block length, add 16 bytes 10 (16 in decimal). You get the idea. The trick generalizes to any block length up to 255 bytes (for larger blocks, a byte is too small to encode values greater than 255).</p>
<p class="indent"><span epub:type="pagebreak" id="page_70"/>Decryption of a padded message works like this:</p>
<ol>
<li class="noindent"><p class="list">Decrypt all the blocks as with unpadded CBC.</p></li>
<li class="noindent"><p class="list">Make sure that the last bytes of the last block conform to the padding rule: that they finish with at least one 01 byte, at least two 02 bytes, or at least three 03 bytes, and so on. If the padding isn’t valid—for example, if the last bytes are 01 02 03—the message is rejected. Otherwise, decryption strips the padding bytes and returns the plaintext bytes left.</p></li>
</ol>
<p class="indent">One downside of padding is that it makes ciphertext longer by at least one byte and at most a block.</p>
<h5 class="h5">Ciphertext Stealing</h5>
<p class="noindent">Ciphertext stealing is another trick used to encrypt a message whose length isn’t a multiple of the block size. Ciphertext stealing is more complex and less popular than padding, but it offers at least three benefits:</p>
<ul>
<li class="noindent">Plaintexts can be of any <em>bit</em> length, not just bytes. You can, for example, encrypt a message of 131 bits.</li>
<li class="noindent">Ciphertexts are exactly the same length as plaintexts.</li>
<li class="noindent">Ciphertext stealing is not vulnerable to padding oracle attacks, powerful attacks that sometimes work against CBC with padding (as we’ll see in <a href="ch04.xhtml#lev2sec63">“Padding Oracle Attacks”</a> on page 74).</li>
</ul>
<p class="indentt">In CBC mode, ciphertext stealing extends the last incomplete plaintext block with bits from the previous ciphertext block, and then encrypts the resulting block. The last, incomplete ciphertext block is made up of the first blocks from the previous ciphertext block; that is, the bits that have not been appended to the last plaintext block.</p>
<div class="image"><img src="../images/f04-09.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig9"/><em>Figure 4-9: Ciphertext stealing for CBC-mode encryption</em></p>
<p class="indent">In <a href="ch04.xhtml#ch4fig9">Figure 4-9</a>, we have three blocks, where the last block, <em>P</em><sub>3</sub>, is incomplete (represented by a zero). <em>P</em><sub>3</sub> is XORed with the last bits from the previous ciphertext block, and the encrypted result is returned as <em>C</em><sub>2</sub>. The last ciphertext block, <em>C</em><sub>3</sub>, then consists of the first bits from the previous ciphertext block. Decryption is simply the inverse of this operation.</p>
<p class="indent">There aren’t any major problems with ciphertext stealing, but it’s inelegant and hard to get right, especially when NIST’s standard specifies three different ways to implement it (see Special Publication 800-38A).</p>
<h4 class="h4" id="lev2sec61"><span epub:type="pagebreak" id="page_71"/><em>The Counter (CTR) Mode</em></h4>
<p class="noindentb">To avoid the troubles and retain the benefits of ciphertext stealing, you should use counter mode (CTR). CTR is hardly a block cipher mode: it turns a block cipher into a stream cipher that just takes bits in and spits bits out and doesn’t embarrass itself with the notion of blocks. (I’ll discuss stream ciphers in detail in <a href="ch05.xhtml#ch5">Chapter 5</a>.)</p>
<div class="image"><img src="../images/f04-10.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig10"/><em>Figure 4-10: The CTR mode</em></p>
<p class="indentt">In CTR mode (see <a href="ch04.xhtml#ch4fig10">Figure 4-10</a>), the block cipher algorithm won’t transform plaintext data. Instead, it will encrypt blocks composed of a <em>counter</em> and a <em>nonce</em>. A counter is an integer that is incremented for each block. No two blocks should use the same counter within a message, but different messages can use the same sequence of counter values (1, 2, 3, …). A nonce is a number used only once. It is the same for all blocks in a single message, but no two messages should use the same nonce.</p>
<p class="indent">As shown in <a href="ch04.xhtml#ch4fig10">Figure 4-10</a>, in CTR mode, encryption XORs the plaintext and the stream taken from “encrypting” the nonce, <em>N</em>, and counter, <em>Ctr</em>. Decryption is the same, so you only need the encryption algorithm for both encryption and decryption. The Python script in <a href="ch04.xhtml#ch4list6">Listing 4-6</a> gives you a hands-on example.</p>
<p class="programs">#!/usr/bin/env python<br/><br/>from Crypto.Cipher import AES<br/>from Crypto.Util import Counter<br/>from binascii import hexlify as hexa<br/>from os import urandom<br/>from struct import unpack<br/><br/>k = urandom(16)<br/>print 'k = %s' % hexa(k)<br/><br/># pick a starting value for the counter<br/>nonce = unpack('&lt;Q', urandom(8))[0]<br/># instantiate a counter function<br/>ctr = Counter.new(128, initial_value=nonce)<br/><br/># pick an instance of AES in CTR mode, using ctr as counter<br/>aes = AES.new(k, AES.MODE_CTR, counter=ctr)<br/><br/># no need for an entire block with CTR<br/>p = '\x00\x01\x02\x03'<br/><br/># encrypt p<br/>c = aes.encrypt(p)<br/>print 'enc(%s) = %s' % (hexa(p), hexa(c))<br/># decrypt using the encrypt function<br/>ctr = Counter.new(128, initial_value=nonce)<br/>aes = AES.new(k, AES.MODE_CTR, counter=ctr)<br/>p = aes.encrypt(c)<br/>print 'enc(%s) = %s' % (hexa(c), hexa(p))</p>
<p class="figcap"><span epub:type="pagebreak" id="page_72"/><a id="ch4list6"/><em>Listing 4-6: Using AES in CTR mode</em></p>
<p class="indentt">The example execution encrypts a 4-byte plaintext and gets a 4-byte ciphertext. It then decrypts that ciphertext using the encryption function:</p>
<p class="programs">$ <span class="codestrong">./aes_ctr.py</span><br/>k = 130a1aa77fa58335272156421cb2a3ea<br/>enc(00010203) = b23d284e<br/>enc(b23d284e) = 00010203</p>
<p class="indent">As with the initial value in CBC, CTR’s nonce is supplied by the encrypter and sent with the ciphertext in the clear. But unlike CBC’s initial value, CTR’s nonce doesn’t need to be random, it simply needs to be unique. A nonce should be unique for the same reason that a one-time pad shouldn’t be reused: when calling the pseudorandom stream, <em>S</em>, if you encrypt <em>P</em><sub>1</sub> to <em>C</em><sub>1</sub> = <em>P</em><sub>1</sub> ⊕ <em>S</em> and <em>P</em><sub>2</sub> to <em>C</em><sub>2</sub> = <em>P</em><sub>2</sub> ⊕ <em>S</em> using the same nonce, then <em>C</em><sub>1</sub> ⊕ <em>C</em><sub>2</sub> reveals <em>P</em><sub>1</sub> ⊕ <em>P</em><sub>2</sub>.</p>
<p class="indent">A random nonce will do the trick only if it’s long enough; for example, if the nonce is <em>n</em> bits, chances are that after 2<sup><em>N</em>/ 2</sup> encryptions and as many nonces you’ll run into duplicates. Sixty-four bits are therefore insufficient for a random nonce, since you can expect a repetition after approximately 2<sup>32</sup> nonces, which is an unacceptably low number.</p>
<p class="indent">The counter is guaranteed unique if it’s incremented for every new plaintext, and if it’s long enough; for example, a 64-bit counter.</p>
<p class="indent">One particular benefit to CTR is that it can be faster than in any other mode. Not only is it parallelizable, but you can also start encrypting even before knowing the message by picking a nonce and computing the stream that you’ll later XOR with the plaintext.</p>
<h3 class="h3" id="lev1sec32">How Things Can Go Wrong</h3>
<p class="noindent">There are two must-know attacks on block ciphers: meet-in-the-middle attacks, a technique discovered in the 1970s but still used in many cryptanalytic attacks (not to be confused with man-in-the-middle attacks), and padding oracle attacks, a class of attacks discovered in 2002 by academic cryptographers, then mostly ignored, and finally rediscovered a decade later along with several vulnerable applications.</p>
<h4 class="h4" id="lev2sec62"><em>Meet-in-the-Middle Attacks</em></h4>
<p class="noindent">The 3DES block cipher is an upgraded version of the 1970s standard DES that takes a key of 56 × 3 = 168 bits (an improvement on DES’s 56-bit key). But the security level of 3DES is 112 bits instead of 168 bits, because of the <em>meet-in-the-middle (MitM)</em> attack.</p>
<p class="indent"><span epub:type="pagebreak" id="page_73"/>As you can see in <a href="ch04.xhtml#ch4fig11">Figure 4-11</a>, 3DES encrypts a block using the DES encryption and decryption functions: first encryption with a key, <em>K</em><sub>1</sub>, then decryption with a key, <em>K</em><sub>2</sub>, and finally encryption with another key, <em>K</em><sub>3</sub>. If <em>K</em><sub>1</sub> = <em>K</em><sub>2</sub>, the first two calls cancel themselves out and 3DES boils down to a single DES with key <em>K</em><sub>3</sub>. 3DES does encrypt-decrypt-encrypt rather than encrypting thrice to allow systems to emulate DES when necessary using the new 3DES interface.</p>
<div class="image"><img src="../images/f04-11.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig11"/><em>Figure 4-11: The 3DES block cipher construction</em></p>
<p class="indent">Why use triple DES and not just double DES, that is, <strong>E</strong>(<em>K</em><sub>1</sub>, <strong>E</strong>(<em>K</em><sub>2</sub>, <em>P</em>))? It turns out that the MitM attack makes double DES only as secure as single DES. <a href="ch04.xhtml#ch4fig12">Figure 4-12</a> shows the MitM attack in action.</p>
<div class="image"><img src="../images/f04-12.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig12"/><em>Figure 4-12: The meet-in-the-middle attack</em></p>
<p class="indentt">The meet-in-the-middle attack works as follows to attack double DES:</p>
<ol>
<li class="noindent"><p class="list">Say you have <em>P</em> and <em>C</em> = <strong>E</strong>(<em>K</em><sub>2</sub>, <strong>E</strong>(<em>K</em><sub>1</sub>, <em>P</em>)) with two unknown 56-bit keys, <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub>. (DES takes 56-bit keys, so double DES takes 112 key bits in total.) You build a key–value table with 2<sup>56</sup> entries of <strong>E</strong>(<em>K</em><sub>1</sub>, <em>P</em>), where <strong>E</strong> is the DES encryption function and <em>K</em><sub>1</sub> is the value stored.</p></li>
<li class="noindent"><p class="list">For all 2<sup>56</sup> values of <em>K</em><sub>2</sub>, compute <strong>D</strong>(<em>K</em><sub>2</sub>, <em>C</em>) and check whether the resulting value appears in the table as an index (thus as a middle value, represented by a question mark in <a href="ch04.xhtml#ch4fig12">Figure 4-12</a>).</p></li>
<li class="noindent"><p class="list">If a middle value is found as an index of the table, you fetch the corresponding <em>K</em><sub>1</sub> from the table and verify that the (<em>K</em><sub>1</sub>, <em>K</em><sub>2</sub>) found is the right one by using other pairs of <em>P</em> and <em>C</em>. Encrypt <em>P</em> using <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub> and then check that the ciphertext obtained is the given <em>C</em>.</p></li>
</ol>
<p class="indent">This method recovers <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub> by performing about 2<sup>57</sup> instead of 2<sup>112</sup> operations: step 1 encrypts 2<sup>56</sup> blocks and then step 2 decrypts at most 2<sup>56</sup> blocks, for 2<sup>56</sup> + 2<sup>56</sup> = 2<sup>57</sup> operations in total. You also need to store 2<sup>56</sup> elements of 15 bytes each, or about 128 petabytes. That’s a lot, but there’s a trick that allows you to run the same attack with only negligible memory (as you’ll see in <a href="ch06.xhtml#ch6">Chapter 6</a>).</p>
<p class="indent"><span epub:type="pagebreak" id="page_74"/>As you can see, you can apply the MitM attack to 3DES in almost the same way you would to double DES, except that the third stage will go through all 2<sup>112</sup> values of <em>K</em><sub>2</sub> and <em>K</em><sub>3</sub>. The whole attack thus succeeds after performing about 2<sup>112</sup> operations, meaning that 3DES gets only 112-bit security despite having 168 bits of key material.</p>
<h4 class="h4" id="lev2sec63"><em>Padding Oracle Attacks</em></h4>
<p class="noindent">Let’s conclude this chapter with one of the simplest and yet most devastating attacks of the 2000s: the padding oracle attack. Remember that padding fills the plaintext with extra bytes in order to fill a block. A plaintext of 111 bytes, for example, is a sequence of six 16-byte blocks followed by 15 bytes. To form a complete block, padding adds a 01 byte. For a 110-byte plaintext, padding adds two 02 bytes, and so on.</p>
<p class="indent">A <em>padding oracle</em> is a system that behaves differently depending on whether the padding in a CBC-encrypted ciphertext is valid. You can see it as a black box or an API that returns either a <em>success</em> or an <em>error</em> value. A padding oracle can be found in a service on a remote host sending error messages when it receives malformed ciphertexts. Given a padding oracle, padding oracle attacks record which inputs have a valid padding and which don’t, and exploit this information to decrypt chosen ciphertext values.</p>
<div class="image"><img src="../images/f04-13.jpg" alt="image"/></div>
<p class="figcap"><a id="ch4fig13"/><em>Figure 4-13: Padding oracle attacks recover X by choosing C<sub>1</sub> and checking the validity of padding.</em></p>
<p class="indent">Say you want to decrypt ciphertext block <em>C</em><sub>2</sub>. I’ll call <em>X</em> the value you’re looking for, namely <strong>D</strong>(<em>K</em>, <em>C</em><sub>2</sub>), and <em>P</em><sub>2</sub> the block obtained after decrypting in CBC mode (see <a href="ch04.xhtml#ch4fig13">Figure 4-13</a>). If you pick a random block <em>C</em><sub>1</sub> and send the two-block ciphertext <em>C</em><sub>1</sub> || <em>C</em><sub>2</sub> to the oracle, decryption will only succeed if <em>C</em><sub>1</sub> ⊕ <em>P</em><sub>2</sub> = <em>X</em> ends with valid padding—a single 01 byte, two 02 bytes, or three 03 bytes, and so on.</p>
<p class="indent">Based on this observation, padding oracle attacks on CBC encryption can decrypt a block <em>C</em><sub>2</sub> like this (bytes are denoted in array notation: <em>C</em><sub>1</sub>[0] is <em>C</em><sub>1</sub>’s first byte, <em>C</em><sub>1</sub>[1] its second byte, and so on up to <em>C</em><sub>1</sub>[15], <em>C</em><sub>1</sub>’s last byte):</p>
<ol>
<li class="noindent"><p class="list">Pick a random block <em>C</em><sub>1</sub> and vary its last byte until the padding oracle accepts the ciphertext as valid. Usually, in a valid ciphertext, <em>C</em><sub>1</sub>[15] ⊕ <em>X</em>[15] = 01, so you’ll find <em>X</em>[15] after trying around 128 values of <em>C</em><sub>1</sub>[15].</p></li>
<li class="noindent"><p class="list">Find the value <em>X</em>[14] by setting <em>C</em><sub>1</sub>[15] to <em>X</em>[15] ⊕ 02 and searching for the <em>C</em><sub>1</sub>[14] that gives correct padding. When the oracle accepts the ciphertext as valid, it means you have found <em>C</em><sub>1</sub>[14] such that <em>C</em><sub>1</sub>[14] ⊕ <em>X</em>[14] = 02.</p></li>
<li class="noindent"><p class="list">Repeat steps 1 and 2 for all 16 bytes.</p></li>
</ol>
<p class="indent">The attack needs on average 128 queries to the oracle for each of the 16 bytes, which is about 2000 queries in total. (Note that each query must use the same initial value.)</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_75"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In practice, implementing a padding oracle attack is a bit more complicated than what I’ve described, because you have to deal with wrong guesses at step 1. A ciphertext may have valid padding not because</em> P<sub>2</sub> <em>ends with a single 01 but because it ends with two 02 bytes or three 03 bytes. But that’s easily managed by testing the validity of ciphertexts where more bytes are modified.</em></p>
</div>
<h3 class="h3" id="lev1sec33">Further Reading</h3>
<p class="noindent">There’s a lot to say about block ciphers, be it in how algorithms work or in how they can be attacked. For instance, Feistel networks and SPNs aren’t the only ways to build a block cipher. The block ciphers IDEA and FOX use the Lai–Massey construction, and Threefish uses ARX networks, a combination of addition, word rotations, and XORs.</p>
<p class="indent">There are also many more modes than just ECB, CBC, and CTR. Some modes are folklore techniques that nobody uses, like CFB and OFB, while others are for specific applications, like XTS for tweakable encryption or GCM for authenticated encryption.</p>
<p class="indent">I’ve discussed Rijndael, the AES winner, but there were 14 other algorithms in the race: CAST-256, CRYPTON, DEAL, DFC, E2, FROG, HPC, LOKI97, Magenta, MARS, RC6, SAFER+, Serpent, and Twofish. I recommend that you look them up to see how they work, how they were designed, how they have been attacked, and how fast they are. It’s also worth checking out the NSA’s designs (Skipjack, and more recently, SIMON and SPECK) and more recent “lightweight” block ciphers such as KATAN, PRESENT, or PRINCE.<span epub:type="pagebreak" id="page_76"/></p>
</body></html>