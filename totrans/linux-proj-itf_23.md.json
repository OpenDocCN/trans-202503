["```\n#include <sys/time.h>\n\nint `setitimer`(int *which*, const struct itimerval **new_value*,\n              struct itimerval **old_value*);\n```", "```\nstruct itimerval {\n    struct timeval it_interval;     /* Interval for periodic timer */\n    struct timeval it_value;        /* Current value (time until\n                                       next expiration) */\n};\n```", "```\nstruct timeval {\n    time_t      tv_sec;             /* Seconds */\n    suseconds_t tv_usec;            /* Microseconds (long int) */\n};\n```", "```\n#include <sys/time.h>\n\nint `getitimer`(int *which*, struct itimerval **curr_value*);\n```", "```\n$ `./real_timer 1 800000 1 0`         *Initial value 1.8 seconds, interval 1 second*\n       Elapsed   Value  Interval\nSTART:    0.00\nMain:     0.50    1.30    1.00      *Timer counts down until expiration*\nMain:     1.00    0.80    1.00\nMain:     1.50    0.30    1.00\nALARM:    1.80    1.00    1.00      *On expiration, timer is reloaded from interval*\nMain:     2.00    0.80    1.00\nMain:     2.50    0.30    1.00\nALARM:    2.80    1.00    1.00\nMain:     3.00    0.80    1.00\nMain:     3.50    0.30    1.00\nALARM:    3.80    1.00    1.00\nThat's all folks\n```", "```\n`timers/real_timer.c`\n    #include <signal.h>\n    #include <sys/time.h>\n    #include <time.h>\n    #include \"tlpi_hdr.h\"\n\n    static volatile sig_atomic_t gotAlarm = 0;\n                            /* Set nonzero on receipt of SIGALRM */\n\n    /* Retrieve and display the real time, and (if 'includeTimer' is\n       TRUE) the current value and interval for the ITIMER_REAL timer */\n\n    static void\n displayTimes(const char *msg, Boolean includeTimer)\n    {\n        struct itimerval itv;\n        static struct timeval start;\n        struct timeval curr;\n        static int callNum = 0;             /* Number of calls to this function */\n\n        if (callNum == 0)                   /* Initialize elapsed time meter */\n            if (gettimeofday(&start, NULL) == -1)\n                errExit(\"gettimeofday\");\n\n        if (callNum % 20 == 0)              /* Print header every 20 lines */\n            printf(\"       Elapsed   Value Interval\\n\");\n\n            if (gettimeofday(&curr, NULL) == -1)\n            errExit(\"gettimeofday\");\n        printf(\"%-7s %6.2f\", msg, curr.tv_sec - start.tv_sec +\n                            (curr.tv_usec - start.tv_usec) / 1000000.0);\n\n        if (includeTimer) {\n            if (getitimer(ITIMER_REAL, &itv) == -1)\n                errExit(\"getitimer\");\n            printf(\"  %6.2f  %6.2f\",\n                    itv.it_value.tv_sec + itv.it_value.tv_usec / 1000000.0,\n                    itv.it_interval.tv_sec + itv.it_interval.tv_usec / 1000000.0);\n        }\n\n        printf(\"\\n\");\n        callNum++;\n    }\n\n    static void\n    sigalrmHandler(int sig)\n    {\n     gotAlarm = 1;\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        struct itimerval itv;\n        clock_t prevClock;\n        int maxSigs;                /* Number of signals to catch before exiting */\n        int sigCnt;                 /* Number of signals so far caught */\n        struct sigaction sa;\n\n        if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s [secs [usecs [int-secs [int-usecs]]]]\\n\", argv[0]);\n\n        sigCnt = 0;\n\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = 0;\n        sa.sa_handler = sigalrmHandler;\n     if (sigaction(SIGALRM, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n         /* Set timer from the command-line arguments */\n\n        itv.it_value.tv_sec = (argc > 1) ? getLong(argv[1], 0, \"secs\") : 2;\n        itv.it_value.tv_usec = (argc > 2) ? getLong(argv[2], 0, \"usecs\") : 0;\n        itv.it_interval.tv_sec = (argc > 3) ? getLong(argv[3], 0, \"int-secs\") : 0;\n        itv.it_interval.tv_usec = (argc > 4) ? getLong(argv[4], 0, \"int-usecs\") : 0;\n\n       /* Exit after 3 signals, or on first signal if interval is 0 */\n\n        maxSigs = (itv.it_interval.tv_sec == 0 &&\n                    itv.it_interval.tv_usec == 0) ? 1 : 3;\n\n            displayTimes(\"START:\", FALSE);\n     if (setitimer(ITIMER_REAL, &itv, 0) == -1)\n            errExit(\"setitimer\");\n\n        prevClock = clock();\n        sigCnt = 0;\n\n     for (;;) {\n\n            /* Inner loop consumes at least 0.5 seconds CPU time */\n\n            while (((clock() - prevClock) * 10 / CLOCKS_PER_SEC) < 5) {\n             if (gotAlarm) {                     /* Did we get a signal? */\n                    gotAlarm = 0;\n                    displayTimes(\"ALARM:\", TRUE);\n\n                    sigCnt++;\n                 if (sigCnt >= maxSigs) {\n                        printf(\"That's all folks\\n\");\n                        exit(EXIT_SUCCESS);\n                    }\n                }\n            }\n\n            prevClock = clock();\n            displayTimes(\"Main: \", TRUE);\n        }\n    }\n         `timers/real_timer.c`\n```", "```\n#include <unistd.h>\n\nunsigned int `alarm`(unsigned int *seconds*);\n```", "```\n`timers/timed_read.c`\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\n#define BUF_SIZE 200\n\nstatic void     /* SIGALRM handler: interrupts blocked system call */\nhandler(int sig)\n{\n    printf(\"Caught signal\\n\");          /* UNSAFE (see Section 21.1.2) */\n}\n\nint\nmain(int argc, char *argv[])\n{\n    struct sigaction sa;\n    char buf[BUF_SIZE];\n    ssize_t numRead;\n    int savedErrno;\n\n    if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s [num-secs [restart-flag]]\\n\", argv[0]);\n\n    /* Set up handler for SIGALRM. Allow system calls to be interrupted,\n       unless second command-line argument was supplied. */\n\n    sa.sa_flags = (argc > 2) ? SA_RESTART : 0;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_handler = handler;\n    if (sigaction(SIGALRM, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    alarm((argc > 1) ? getInt(argv[1], GN_NONNEG, \"num-secs\") : 10);\n\n    numRead = read(STDIN_FILENO, buf, BUF_SIZE - 1);\n\n    savedErrno = errno;                 /* In case alarm() changes it */\n    alarm(0);                           /* Ensure timer is turned off */\n    errno = savedErrno;\n\n    /* Determine result of read() */\n\n    if (numRead == -1) {\n        if (errno == EINTR)\n            printf(\"Read timed out\\n\");\n        else\n            errMsg(\"read\");\n    } else {\n        printf(\"Successful read (%ld bytes): %.*s\",\n                (long) numRead, (int) numRead, buf);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `timers/timed_read.c`\n```", "```\n#include <unistd.h>\n\nunsigned int `sleep`(unsigned int *seconds*);\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <time.h>\n\nint `nanosleep`(const struct timespec **request*, struct timespec **remain*);\n```", "```\nstruct timespec {\n    time_t tv_sec;         /* Seconds */\n    long   tv_nsec;        /* Nanoseconds */\n};\n```", "```\n$ `./t_nanosleep 10 0`                      *Sleep for 10 seconds*\n*Type Control-C*\nSlept for:  1.853428 secs\nRemaining:  8.146617000\n*Type Control-C*\nSlept for:  4.370860 secs\nRemaining:  5.629800000\n*Type Control-C*\nSlept for:  6.193325 secs\nRemaining:  3.807758000\nSlept for: 10.008150 secs\nSleep complete\n```", "```\n`timers/t_nanosleep.c`\n#define _POSIX_C_SOURCE 199309\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nsigintHandler(int sig)\n{\n    return;                     /* Just interrupt nanosleep() */\n}\n\nint\nmain(int argc, char *argv[])\n{\n    struct timeval start, finish;\n    struct timespec request, remain;\n    struct sigaction sa;\n    int s;\n\n    if (argc != 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s secs nanosecs\\n\", argv[0]);\n\n    request.tv_sec = getLong(argv[1], 0, \"secs\");\n    request.tv_nsec = getLong(argv[2], 0, \"nanosecs\");\n\n    /* Allow SIGINT handler to interrupt nanosleep() */\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sa.sa_handler = sigintHandler;\n    if (sigaction(SIGINT, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    if (gettimeofday(&start, NULL) == -1)\n        errExit(\"gettimeofday\");\n\n    for (;;) {\n        s = nanosleep(&request, &remain);\n        if (s == -1 && errno != EINTR)\n            errExit(\"nanosleep\");\n\n        if (gettimeofday(&finish, NULL) == -1)\n            errExit(\"gettimeofday\");\n        printf(\"Slept for: %9.6f secs\\n\", finish.tv_sec - start.tv_sec +\n                        (finish.tv_usec - start.tv_usec) / 1000000.0);\n\n        if (s == 0)\n            break;                      /* nanosleep() completed */\n\n        printf(\"Remaining: %2ld.%09ld\\n\", (long) remain.tv_sec,\n                remain.tv_nsec);\n        request = remain;               /* Next sleep is with remaining time */\n    }\n\n    printf(\"Sleep complete\\n\");\n    exit(EXIT_SUCCESS);\n}\n      `timers/t_nanosleep.c`\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <time.h>\n\nint `clock_gettime`(clockid_t *clockid*, struct timespec **tp*);\nint `clock_getres`(clockid_t *clockid*, struct timespec **res*);\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <time.h>int `clock_settime`(clockid_t *clockid*,\n const struct timespec **tp*);\n```", "```\n#include <time.h>\n\nint `clock_getcpuclockid`(pid_t *pid*, clockid_t **clockid*);\n```", "```\n#include <pthread.h>\n#include <time.h>\n\nint `pthread_getcpuclockid`(pthread_t *thread*, clockid_t **clockid*);\n```", "```\n#include <time.h>\n\nint `clock_nanosleep`(clockid_t *clockid*, *int flags*,\n       const struct timespec **request*, struct timespec **remain*);\n```", "```\nstruct timespec request;\n\n    /* Retrieve current value of CLOCK_REALTIME clock */\n\n    if (clock_gettime(CLOCK_REALTIME, &request) == -1)\n        errExit(\"clock_gettime\");\n\n    request.tv_sec += 20;               /* Sleep for 20 seconds from now */\n\n    s = clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &request, NULL);\n    if (s != 0) {\n        if (s == EINTR)\n            printf(\"Interrupted by signal handler\\n\");\n        else\n            errExitEN(s, \"clock_nanosleep\");\n    }\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <signal.h>\n#include <time.h>\n\nint `timer_create`(clockid_t *clockid*, struct sigevent **evp*, timer_t **timerid*);\n```", "```\nunion sigval {\n    int   sival_int;              /* Integer value for accompanying data */\n    void *sival_ptr;              /* Pointer value for accompanying data */\n};\n\nstruct sigevent {\n    int          sigev_notify;    /* Notification method */\n    int          sigev_signo;     /* Timer expiration signal */\n    union sigval sigev_value;     /* Value accompanying signal or\n                                     passed to thread function */\n    union {\n        pid_t      _tid;          /* ID of thread to be signaled /\n        struct {\n            void (*_function) (union sigval);\n                                  /* Thread notification function */\n            void  *_attribute;    /* Really 'pthread_attr_t *' */\n        } _sigev_thread;\n    } _sigev_un;\n};\n\n#define sigev_notify_function    _sigev_un._sigev_thread._function\n#define sigev_notify_attributes  _sigev_un._sigev_thread._attribute\n#define sigev_notify_thread_id   _sigev_un._tid\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <time.h>\n\nint `timer_settime`(timer_t *timerid*, int *flags*, const struct itimerspec **value*,\n                  struct itimerspec **old_value*);\n```", "```\nstruct itimerspec {\n    struct timespec it_interval;    /* Interval for periodic timer */\n    struct timespec it_value;       /* First expiration */\n};\n```", "```\nstruct timespec {\n    time_t tv_sec;                  /* Seconds */\n    long   tv_nsec;                 /* Nanoseconds */\n};\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <time.h>\n\nint `timer_gettime`(timer_t *timerid*, struct itimerspec **curr_value*);\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <time.h>\n\nint `timer_delete`(timer_t *timerid*);\n```", "```\n`timers/ptmr_sigev_signal.c`\n    #define _POSIX_C_SOURCE 199309\n    #include <signal.h>\n    #include <time.h>\n    #include \"curr_time.h\"                  /* Declares currTime() */\n    #include \"itimerspec_from_str.h\"        /* Declares itimerspecFromStr() */\n    #include \"tlpi_hdr.h\"\n\n    #define TIMER_SIG SIGRTMAX              /* Our timer notification signal */\n\n    static void\n handler(int sig, siginfo_t *si, void *uc)\n    {\n        timer_t *tidptr;\n\n        tidptr = si->si_value.sival_ptr;\n\n        /* UNSAFE: This handler uses non-async-signal-safe functions\n           (printf(); see Section 21.1.2) */\n\n            printf(\"[%s] Got signal %d\\n\", currTime(\"%T\"), sig);\n        printf(\"    *sival_ptr         = %ld\\n\", (long) *tidptr);\n        printf(\"    timer_getoverrun() = %d\\n\", timer_getoverrun(*tidptr));\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        struct itimerspec ts;\n        struct sigaction  sa;\n        struct sigevent   sev;\n        timer_t *tidlist;\n        int j;\n\n        if (argc < 2)\n            usageErr(\"%s secs[/nsecs][:int-secs[/int-nsecs]]...\\n\", argv[0]);\n\n        tidlist = calloc(argc - 1, sizeof(timer_t));\n        if (tidlist == NULL)\n            errExit(\"malloc\");\n\n        /* Establish handler for notification signal */\n\n        sa.sa_flags = SA_SIGINFO;\n        sa.sa_sigaction = handler;\n        sigemptyset(&sa.sa_mask);\n    if (sigaction(TIMER_SIG, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n        /* Create and start one timer for each command-line argument */\n\n        sev.sigev_notify = SIGEV_SIGNAL;    /* Notify via signal */\n        sev.sigev_signo = TIMER_SIG;        /* Notify using this signal */\n\n        for (j = 0; j < argc - 1; j++) {\n        itimerspecFromStr(argv[j + 1], &ts);\n\n            sev.sigev_value.sival_ptr = &tidlist[j];\n                    /* Allows handler to get ID of this timer */\n        if (timer_create(CLOCK_REALTIME, &sev, &tidlist[j]) == -1)\n                errExit(\"timer_create\");\n            printf(\"Timer ID: %ld (%s)\\n\", (long) tidlist[j], argv[j + 1]);\n        if (timer_settime(tidlist[j], 0, &ts, NULL) == -1)\n                errExit(\"timer_settime\");\n        }\n    for (;;)                            /* Wait for incoming timer signals */\n            pause();\n    }\n          `timers/ptmr_sigev_signal.c`\n```", "```\n`timers/itimerspec_from_str.c`\n#define_POSIX_C_SOURCE 199309\n#include <string.h>\n#include <stdlib.h>\n#include \"itimerspec_from_str.h\"        /* Declares function defined here */\n\n/* Convert a string of the following form to an itimerspec structure:\n   \"value.sec[/value.nanosec][:interval.sec[/interval.nanosec]]\".\n   Optional components that are omitted cause 0 to be assigned to the\n   corresponding structure fields. */\n\nvoid\nitimerspecFromStr(char *str, struct itimerspec *tsp)\n{\n    char *cptr, *sptr;\n\n    cptr = strchr(str, ':');\n    if (cptr != NULL)\n        *cptr = '\\0';\n\n    sptr = strchr(str, '/');\n    if (sptr != NULL)\n        *sptr = '\\0';\n\n    tsp->it_value.tv_sec = atoi(str);\n    tsp->it_value.tv_nsec = (sptr != NULL) ? atoi(sptr + 1) : 0;\n\n    if (cptr == NULL) {\n        tsp->it_interval.tv_sec = 0;\n        tsp->it_interval.tv_nsec = 0;\n    } else {\n        sptr = strchr(cptr + 1, '/');\n        if (sptr != NULL)\n            *sptr = '\\0';\n        tsp->it_interval.tv_sec = atoi(cptr + 1);\n        tsp->it_interval.tv_nsec = (sptr != NULL) ? atoi(sptr + 1) : 0;\n    }\n}\n     `timers/itimerspec_from_str.c`\n```", "```\n$ `./ptmr_sigev_signal 2:5`\nTimer ID: 134524952 (2:5)\n[15:54:56] Got signal 64                  SIGRTMAX *is signal 64 on this system*\n    *sival_ptr         = 134524952        *sival_ptr* *points to the variable* *tid*\n    timer_getoverrun() = 0\n[15:55:01] Got signal 64\n    *sival_ptr         = 134524952\n    timer_getoverrun() = 0\n*Type Control-Z to suspend the process*\n[1]+  Stopped       ./ptmr_sigev_signal 2:5\n```", "```\n$ `fg`\n./ptmr_sigev_signal 2:5\n[15:55:34] Got signal 64\n    *sival_ptr         = 134524952\n    timer_getoverrun() = 5\n*Type Control-C to kill the program*\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <time.h>\n\nint `timer_getoverrun`(timer_t *timerid*);\n```", "```\n$ `./ptmr_sigev_thread 5:5 10:10`\nTimer ID: 134525024 (5:5)\nTimer ID: 134525080 (10:10)\n[13:06:22] Thread notify\n    timer ID=134525024\n    timer_getoverrun()=0\nmain(): count = 1\n[13:06:27] Thread notify\n    timer ID=134525080\n    timer_getoverrun()=0\nmain(): count = 2\n[13:06:27] Thread notify\n    timer ID=134525024\n    timer_getoverrun()=0\nmain(): count = 3\n*Type Control-Z to suspend the program*\n[1]+  Stopped       ./ptmr_sigev_thread 5:5 10:10\n$ `fg`                                      *Resume execution*\n./ptmr_sigev_thread 5:5 10:10\n[13:06:45] Thread notify\n    timer ID=134525024\n    timer_getoverrun()=2                  *There were timer overruns*\nmain(): count = 6\n[13:06:45] Thread notify\n    timer ID=134525080\n    timer_getoverrun()=0\nmain(): count = 7\n*Type Control-C to kill the program*\n```", "```\n`timers/ptmr_sigev_thread.c`\n    #include <signal.h>\n    #include <time.h>\n    #include <pthread.h>\n    #include \"curr_time.h\"              /* Declaration of currTime() */\n    #include \"tlpi_hdr.h\"\n    #include \"itimerspec_from_str.h\"    /* Declares itimerspecFromStr() */\n\n    static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;\n    static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\n    static int expireCnt = 0;           /* Number of expirations of all timers */\n\n    static void                         /* Thread notification function */\n threadFunc(union sigval sv)\n    {\n        timer_t *tidptr;\n        int s;\n\n        tidptr = sv.sival_ptr;\n\n        printf(\"[%s] Thread notify\\n\", currTime(\"%T\"));\n        printf(\"    timer ID=%ld\\n\", (long) *tidptr);\n        printf(\"    timer_getoverrun()=%d\\n\", timer_getoverrun(*tidptr));\n\n        /* Increment counter variable shared with main thread and signal\n           condition variable to notify main thread of the change. */\n\n        s = pthread_mutex_lock(&mtx);\n        if (s != 0)\n            errExitEN(s, \"pthread_mutex_lock\");\n\n        expireCnt += 1 + timer_getoverrun(*tidptr);\n\n        s = pthread_mutex_unlock(&mtx);\n        if (s != 0)\n            errExitEN(s, \"pthread_mutex_unlock\");\n    s = pthread_cond_signal(&cond);\n        if (s != 0)\n            errExitEN(s, \"pthread_cond_signal\");\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        struct sigevent sev;\n        struct itimerspec ts;\n        timer_t *tidlist;\n        int s, j;\n\n            if (argc < 2)\n            usageErr(\"%s secs[/nsecs][:int-secs[/int-nsecs]]...\\n\", argv[0]);\n\n        tidlist = calloc(argc - 1, sizeof(timer_t));\n        if (tidlist == NULL)\n            errExit(\"malloc\");\n    sev.sigev_notify = SIGEV_THREAD;            /* Notify via thread */\n    sev.sigev_notify_function = threadFunc;     /* Thread start function */\n        sev.sigev_notify_attributes = NULL;\n                /* Could be pointer to pthread_attr_t structure */\n\n        /* Create and start one timer for each command-line argument */\n\n        for (j = 0; j < argc - 1; j++) {\n            itimerspecFromStr(argv[j + 1], &ts);\n        sev.sigev_value.sival_ptr = &tidlist[j];\n                    /* Passed as argument to threadFunc() */\n        if (timer_create(CLOCK_REALTIME, &sev, &tidlist[j]) == -1)\n                errExit(\"timer_create\");\n            printf(\"Timer ID: %ld (%s)\\n\", (long) tidlist[j], argv[j + 1]);\n        if (timer_settime(tidlist[j], 0, &ts, NULL) == -1)\n                errExit(\"timer_settime\");\n        }\n\n        /* The main thread waits on a condition variable that is signaled\n           on each invocation of the thread notification function. We\n           print a message so that the user can see that this occurred. */\n\n        s = pthread_mutex_lock(&mtx);\n        if (s != 0)\n            errExitEN(s, \"pthread_mutex_lock\");\n    for (;;) {\n            s = pthread_cond_wait(&cond, &mtx);\n            if (s != 0)\n                errExitEN(s, \"pthread_cond_wait\");\n            printf(\"main(): expireCnt = %d\\n\", expireCnt);\n        }\n    }\n\n          `timers/ptmr_sigev_thread.c`\n```", "```\n#include <sys/timerfd.h>\n\nint `timerfd_create`(int *clockid*, int *flags*);\n```", "```\n#include <sys/timerfd.h>\n\nint `timerfd_settime`(int *fd*, int *flags*, const struct itimerspec **new_value*,\n                    struct itimerspec **old_value*);\n```", "```\n#include <sys/timerfd.h>\n\nint `timerfd_gettime`(int *fd*, struct itimerspec **curr_value*);\n```", "```\n$ `./demo_timerfd 1:1 100`\n1.000: expirations read: 1; total=1\n2.000: expirations read: 1; total=2\n3.000: expirations read: 1; total=3\n*Type Control-Z to suspend program in background for a few seconds*\n[1]+  Stopped           ./demo_timerfd 1:1 100\n$ `fg`                                      *Resume program in foreground*\n./demo_timerfd 1:1 100\n14.205: expirations read: 11; total=14    *Multiple expirations since last* *read()*\n15.000: expirations read: 1; total=15\n16.000: expirations read: 1; total=16\n*Type Control-C to terminate the program*\n```", "```\n`timers/demo_timerfd.c`\n#include <sys/timerfd.h>\n#include <time.h>\n#include <stdint.h>                     /* Definition of uint64_t */\n#include \"itimerspec_from_str.h\"        /* Declares itimerspecFromStr() */\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct itimerspec ts;\n    struct timespec start, now;\n    int maxExp, fd, secs, nanosecs;\n    uint64_t numExp, totalExp;\n    ssize_t s;\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s secs[/nsecs][:int-secs[/int-nsecs]] [max-exp]\\n\", argv[0]);\n\n    itimerspecFromStr(argv[1], &ts);\n    maxExp = (argc > 2) ? getInt(argv[2], GN_GT_0, \"max-exp\") : 1;\n\n    fd = timerfd_create(CLOCK_REALTIME, 0);\n    if (fd == -1)\n        errExit(\"timerfd_create\");\n\n    if (timerfd_settime(fd, 0, &ts, NULL) == -1)\n        errExit(\"timerfd_settime\");\n\n    if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)\n        errExit(\"clock_gettime\");\n\n    for (totalExp = 0; totalExp < maxExp;) {\n\n        /* Read number of expirations on the timer, and then display\n           time elapsed since timer was started, followed by number\n           of expirations read and total expirations so far. */\n\n        s = read(fd, &numExp, sizeof(uint64_t));\n        if (s != sizeof(uint64_t))\n            errExit(\"read\");\n\n        totalExp += numExp;\n\n        if (clock_gettime(CLOCK_MONOTONIC, &now) == -1)\n            errExit(\"clock_gettime\");\n\n        secs = now.tv_sec - start.tv_sec;\n        nanosecs = now.tv_nsec - start.tv_nsec;\n        if (nanosecs < 0) {\n            secs--;\n            nanosecs += 1000000000;\n        }\n\n        printf(\"%d.%03d: expirations read: %llu; total=%llu\\n\",\n                secs, (nanosecs + 500000) / 1000000,\n                (unsigned long long) numExp, (unsigned long long) totalExp);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `timers/demo_timerfd.c`\n```", "```\n    $ `while true; do kill -INT` ``*`pid`*```"]