- en: Chapter 2. DATA REPRESENTATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 数据表示
- en: '![DATA REPRESENTATION](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![数据表示](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: A major stumbling block many beginners encounter when attempting to learn assembly
    language is the common use of the binary and hexadecimal numbering systems. Although
    hexadecimal numbers are a little strange, their advantages outweigh their disadvantages
    by a large margin. Understanding the binary and hexadecimal numbering systems
    is important because their use simplifies the discussion of other topics, including
    bit operations, signed numeric representation, character codes, and packed data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者在学习汇编语言时遇到的一个主要障碍是二进制和十六进制计数系统的常见使用。尽管十六进制数字有些奇怪，但它们的优点远大于缺点。理解二进制和十六进制计数系统非常重要，因为它们的使用简化了其他主题的讨论，包括位操作、有符号数表示、字符编码和打包数据。
- en: 'This chapter discusses several important concepts, including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论几个重要概念，包括：
- en: The binary and hexadecimal numbering systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制和十六进制计数系统
- en: Binary data organization (bits, nibbles, bytes, words, and double words)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数据组织（比特、半字节、字节、字、双字）
- en: Signed and unsigned numbering systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号和无符号计数系统
- en: Arithmetic, logical, shift, and rotate operations on binary values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对二进制值进行算术、逻辑、移位和旋转操作
- en: Bit fields and packed data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位域和打包数据
- en: This is basic material, and the remainder of this text depends on your understanding
    these concepts. If you are already familiar with these terms from other courses
    or study, you should at least skim this material before proceeding to the next
    chapter. If you are unfamiliar with this material, or only vaguely familiar with
    it, you should study it carefully before proceeding. *All of the material in this
    chapter is important!* Do not skip over any material.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基础内容，本书其余部分将基于你对这些概念的理解。如果你已经在其他课程或学习中接触过这些术语，至少应该浏览一遍这些内容再继续下一章。如果你对这些内容不熟悉，或者仅有模糊了解，你应该在继续之前仔细学习它。*本章的所有内容都很重要！*
    不要跳过任何内容。
- en: 2.1 Numbering Systems
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 计数系统
- en: Most modern computer systems do not represent numeric values using the decimal
    (base-10) system. Instead, they typically use a binary or two's complement numbering
    system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机系统并不使用十进制（基数10）系统来表示数值。相反，它们通常使用二进制或二的补码计数系统。
- en: 2.1.1 A Review of the Decimal System
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.1 十进制系统回顾
- en: 'You''ve been using the decimal numbering system for so long that you probably
    take it for granted. When you see a number like *123*, you don''t think about
    the value 123; rather, you generate a mental image of how many items this value
    represents. In reality, however, the number 123 represents:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用十进制计数系统很长时间了，以至于可能不再注意它。当你看到像*123*这样的数字时，你不会去思考数字123的具体数值，而是会在脑海中生成一个关于这个数值代表多少个物品的形象。然而，实际上，数字123表示：
- en: '| 1*10² + 2*10¹ + 3*10⁰ |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 1*10² + 2*10¹ + 3*10⁰ |'
- en: or
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '| 100 + 20 + 3 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 100 + 20 + 3 |'
- en: 'In a decimal positional numbering system, each digit appearing to the left
    of the decimal point represents a value between 0 and 9 times an increasing power
    of 10\. Digits appearing to the right of the decimal point represent a value between
    0 and 9 times an increasing negative power of 10\. For example, the value 123.456
    means:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制位置计数系统中，小数点左侧的每个数字表示一个值，该值为0到9之间的数字乘以逐渐增加的10的幂次。小数点右侧的数字表示一个值，该值为0到9之间的数字乘以逐渐增加的负10的幂次。例如，值123.456表示：
- en: '| 1*10² + 2*10¹ + 3*10⁰ + 4*10^(−1) + 5*10^(−2) + 6*10^(−3) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 1*10² + 2*10¹ + 3*10⁰ + 4*10^(−1) + 5*10^(−2) + 6*10^(−3) |'
- en: or
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '| 100 + 20 + 3 + 0.4 + 0.05 + 0.006 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 100 + 20 + 3 + 0.4 + 0.05 + 0.006 |'
- en: 2.1.2 The Binary Numbering System
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.2 二进制计数系统
- en: Most modern computer systems operate using binary logic. The computer represents
    values using two voltage levels (usually 0v and +2.4..5v). Two such levels can
    represent exactly two unique values. These could be any two different values,
    but they typically represent the values 0 and 1\. These values, coincidentally,
    correspond to the two digits in the binary numbering system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机系统使用二进制逻辑进行操作。计算机使用两个电压级别（通常为0v和+2.4..5v）表示值。两个这样的电平可以准确表示两个独特的值。这些值可以是任何两个不同的值，但通常它们表示0和1。这两个值恰巧对应于二进制计数系统中的两个数字。
- en: 'The binary numbering system works just like the decimal numbering system, with
    two exceptions: Binary allows only the digits 0 and 1 (rather than 0..9), and
    binary uses powers of 2 rather than powers of 10\. Therefore, it is very easy
    to convert a binary number to decimal. For each `1` in the binary string, add
    in `2`*`^n`* where *n* is the zero-based position of the binary digit. For example,
    the binary value 11001010[2] represents:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制计数系统与十进制计数系统类似，只有两个例外：二进制只允许数字0和1（而不是0..9），而且二进制使用2的幂而不是10的幂。因此，将二进制数转换为十进制非常容易。对于二进制字符串中的每个`1`，将`2`*`^n`*加上去，其中*n*是二进制数字的基于零的位置。例如，二进制值11001010[2]表示：
- en: '| 1*2⁷ + 1*2⁶ + 0*2⁵ + 0*2⁴ + 1*2³ + 0*2² + 1*2¹ + 0*2⁰ |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 1*2⁷ + 1*2⁶ + 0*2⁵ + 0*2⁴ + 1*2³ + 0*2² + 1*2¹ + 0*2⁰ |'
- en: '| = |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| = |'
- en: '| 128 + 64 + 8 + 2 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 128 + 64 + 8 + 2 |'
- en: '| = |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| = |'
- en: '| 202[10] |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 202[10] |'
- en: To convert decimal to binary is slightly more difficult. You must find those
    powers of 2 that, when added together, produce the decimal result.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制转换为二进制稍微困难一些。你必须找出那些2的幂，当它们加在一起时，能得出十进制结果。
- en: 'A simple way to convert decimal to binary is the *even/odd - divide by two*
    algorithm. This algorithm uses the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 转换十进制为二进制的一种简单方法是*奇偶-除以二*算法。该算法使用以下步骤：
- en: If the number is even, emit a 0\. If the number is odd, emit a 1.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字是偶数，输出0。如果数字是奇数，输出1。
- en: Divide the number by 2 and throw away any fractional component or remainder.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字除以2并舍去任何小数部分或余数。
- en: If the quotient is 0, the algorithm is complete.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果商为0，算法完成。
- en: If the quotient is not 0 and is odd, insert a 1 before the current string; if
    the number is even, prefix your binary string with 0.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果商不是0并且是奇数，则在当前字符串前插入1；如果数字是偶数，则在二进制字符串前加0。
- en: Go back to step 2 and repeat.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回第2步并重复。
- en: Binary numbers, although they have little importance in high-level languages,
    appear everywhere in assembly language programs. So you should be somewhat comfortable
    with them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数虽然在高级语言中不太重要，但在汇编语言程序中随处可见。所以你应该对它们有一定的熟悉度。
- en: 2.1.3 Binary Formats
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.3 二进制格式
- en: 'In the purest sense, every binary number contains an infinite number of digits
    (or *bits*, which is short for *binary digits*). For example, we can represent
    the number 5 by any of the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在最纯粹的意义上，每个二进制数包含无限多个数字（或*位*，即*二进制数字*的简称）。例如，我们可以通过以下任何一种方式表示数字5：
- en: '| 101 00000101 0000000000101 ...000000000000101 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 101 00000101 0000000000101 ...000000000000101 |'
- en: Any number of leading zero digits may precede the binary number without changing
    its value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有任意数量的前导零位出现在二进制数之前，而不会改变其值。
- en: We will adopt the convention of ignoring any leading zeros present in a value.
    For example, 101[2] represents the number 5 but because the 80x86 typically works
    with groups of 8 bits, we'll find it much easier to zero extend all binary numbers
    to some multiple of 4 or 8 bits. Therefore, following this convention, we'd represent
    the number 5 as 0101[2] or 00000101[2].
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用忽略值中任何前导零的惯例。例如，101[2]表示数字5，但由于80x86通常以8位为一组工作，因此我们会发现将所有二进制数扩展到4位或8位的倍数要容易得多。因此，按照这一惯例，我们会将数字5表示为0101[2]或00000101[2]。
- en: In the United States, most people separate every three digits with a comma to
    make larger numbers easier to read. For example, 1,023,435,208 is much easier
    to read and comprehend than 1023435208\. We'll adopt a similar convention in this
    text for binary numbers. We will separate each group of four binary bits with
    an underscore. For example, we will write the binary value 1010111110110010 as
    1010_1111_1011_0010.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国，大多数人将每三个数字用逗号分开，以便更容易阅读较大的数字。例如，1,023,435,208比1023435208更容易阅读和理解。我们将在本文中采用类似的惯例，使用下划线分隔每四个位的二进制数字。例如，我们将把二进制值1010111110110010写为1010_1111_1011_0010。
- en: 'We''ll number each bit as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式编号每一位：
- en: The rightmost bit in a binary number is bit position 0.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制数中最右边的位是位位置0。
- en: Each bit to the left is given the next successive bit number.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一位向左递增一个连续的位编号。
- en: 'An 8-bit binary value uses bits 0..7:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8位二进制值使用位0..7：
- en: '| X[7] X[6] X[5] X[4] X[3] X[2] X[1] X[0] |'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| X[7] X[6] X[5] X[4] X[3] X[2] X[1] X[0] |'
- en: 'A 16-bit binary value uses bit positions 0..15:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 16位二进制值使用位位置0..15：
- en: '| X[15] X[14] X[13] X[12] X[11] X[10] X[9] X[8] X[7] X[6] X[5] X[4] X[3] X[2]
    X[1] X[0] |'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| X[15] X[14] X[13] X[12] X[11] X[10] X[9] X[8] X[7] X[6] X[5] X[4] X[3] X[2]
    X[1] X[0] |'
- en: A 32-bit binary value uses bit positions 0..31, and so on.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 32位二进制值使用位位置0..31，以此类推。
- en: Bit 0 is the *low-order (L.O.)* bit (some refer to this as the *least significant
    bit*). The leftmost bit is called the *high-order (H.O.)* bit (or the *most significant
    bit*). We'll refer to the intermediate bits by their respective bit numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 位0是*低位（L.O.）*位（有些人称之为*最低有效位*）。最左边的位称为*高位（H.O.）*位（或*最高有效位*）。我们将按位号来称呼中间的位。
- en: 2.2 The Hexadecimal Numbering System
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 十六进制计数系统
- en: 'Unfortunately, binary numbers are verbose. To represent the value 202[10] requires
    eight binary digits. The decimal version requires only three decimal digits and
    thus represents numbers much more compactly than in binary. This fact is not lost
    on the engineers who design binary computer systems. When dealing with large values,
    binary numbers quickly become unwieldy. Unfortunately, the computer "thinks" in
    binary, so most of the time it is convenient to use the binary numbering system.
    Although we can convert between decimal and binary, the conversion is not a trivial
    task. The hexadecimal (base 16) numbering system solves many of the problems inherent
    in the binary system. Hexadecimal numbers offer the two features we''re looking
    for: They''re very compact, and it''s simple to convert them to binary and vice
    versa. For this reason, most engineers use the hexadecimal numbering system.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，二进制数很冗长。表示值202[10]需要8个二进制数字。十进制版本只需要3个十进制数字，因此比二进制表示的数字更紧凑。这一点在设计二进制计算机系统的工程师心中早已显现出来。当处理大数值时，二进制数很快变得笨拙。不幸的是，计算机“思考”时使用的是二进制，因此大多数时候使用二进制计数系统是方便的。虽然我们可以在十进制和二进制之间转换，但转换并不是一项简单的任务。十六进制（基数16）计数系统解决了二进制系统固有的许多问题。十六进制数字具备我们所需的两个特点：它们非常紧凑，且转换为二进制及反向转换都很简单。因此，大多数工程师使用十六进制计数系统。
- en: 'Because the radix (base) of a hexadecimal number is 16, each hexadecimal digit
    to the left of the hexadecimal point represents some value times a successive
    power of 16\. For example, the number 1234[16] is equal to:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于十六进制数字的基数是16，十六进制小数点左边的每个十六进制数字表示某个值乘以16的连续幂。例如，数字1234[16]等于：
- en: '| 1*16³ + 2*16² + 3*16¹ + 4*16⁰ |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 1*16³ + 2*16² + 3*16¹ + 4*16⁰ |'
- en: or
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '| 4096 + 512 + 48 + 4 = 4660[10] |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 4096 + 512 + 48 + 4 = 4660[10] |'
- en: 'Each hexadecimal digit can represent one of 16 values between 0 and 15[10].
    Because there are only 10 decimal digits, we need to invent 6 additional digits
    to represent the values in the range 10[10]..15[10]. Rather than create new symbols
    for these digits, we''ll use the letters A..F. The following are all examples
    of valid hexadecimal numbers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个十六进制数字可以表示介于0和15[10]之间的16个值。由于只有10个十进制数字，我们需要发明6个附加数字来表示10[10]到15[10]之间的值。我们不为这些数字创造新符号，而是使用字母A到F。以下都是有效的十六进制数字示例：
- en: '| 1234[16] DEAD[16] BEEF[16] 0AFB[16] FEED[16] DEAF[16] |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 1234[16] DEAD[16] BEEF[16] 0AFB[16] FEED[16] DEAF[16] |'
- en: 'Because we''ll often need to enter hexadecimal numbers into the computer system,
    we''ll need a different mechanism for representing hexadecimal numbers. After
    all, on most computer systems you cannot enter a subscript to denote the radix
    of the associated value. We''ll adopt the following conventions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们经常需要将十六进制数输入计算机系统，所以我们需要一种不同的机制来表示十六进制数。毕竟，在大多数计算机系统中，你不能输入下标来表示相关值的基数。我们将采用以下约定：
- en: All hexadecimal values begin with a $ character; for example, $123A4.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有十六进制值都以$字符开头；例如，$123A4。
- en: All binary values begin with a percent sign (%).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有二进制值都以百分号（%）开头。
- en: Decimal numbers do not have a prefix character.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制数字没有前缀字符。
- en: If the radix is clear from the context, this book may drop the leading $ or
    % character.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上下文已经能明确基数，本书可能会省略前导的$或%字符。
- en: 'Here are some examples of valid hexadecimal numbers:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一些有效的十六进制数字示例：
- en: '| $1234 $DEAD $BEEF $AFB $FEED $DEAF |'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| $1234 $DEAD $BEEF $AFB $FEED $DEAF |'
- en: As you can see, hexadecimal numbers are compact and easy to read. In addition,
    you can easily convert between hexadecimal and binary. Consider [Table 2-1](ch02s02.html#binary_solidus_hexadecimal_conversion
    "Table 2-1. Binary/Hexadecimal Conversion"). This table provides all the information
    you'll ever need to convert any hexadecimal number into a binary number or vice
    versa.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，十六进制数字简洁且易于阅读。此外，你可以轻松地在十六进制和二进制之间进行转换。请参阅[表2-1](ch02s02.html#binary_solidus_hexadecimal_conversion
    "表2-1. 二进制/十六进制转换")。此表提供了将任何十六进制数转换为二进制数或反之所需的所有信息。
- en: Table 2-1. Binary/Hexadecimal Conversion
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1. 二进制/十六进制转换
- en: '| Binary | Hexadecimal |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 十六进制 |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| %0000 | $0 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| %0000 | $0 |'
- en: '| %0001 | $1 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| %0001 | $1 |'
- en: '| %0010 | $2 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| %0010 | $2 |'
- en: '| %0011 | $3 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| %0011 | $3 |'
- en: '| %0100 | $4 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| %0100 | $4 |'
- en: '| %0101 | $5 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| %0101 | $5 |'
- en: '| %0110 | $6 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| %0110 | $6 |'
- en: '| %0111 | $7 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| %0111 | $7 |'
- en: '| %1000 | $8 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| %1000 | $8 |'
- en: '| %1001 | $9 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| %1001 | $9 |'
- en: '| %1010 | $A |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| %1010 | $A |'
- en: '| %1011 | $B |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| %1011 | $B |'
- en: '| %1100 | $C |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| %1100 | $C |'
- en: '| %1101 | $D |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| %1101 | $D |'
- en: '| %1110 | $E |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| %1110 | $E |'
- en: '| %1111 | $F |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| %1111 | $F |'
- en: 'To convert a hexadecimal number into a binary number, simply substitute the
    corresponding 4 bits for each hexadecimal digit in the number. For example, to
    convert $ABCD into a binary value, simply convert each hexadecimal digit according
    to [Table 2-1](ch02s02.html#binary_solidus_hexadecimal_conversion "Table 2-1. Binary/Hexadecimal
    Conversion"), as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要将十六进制数字转换为二进制数字，只需将每个十六进制数字对应的4位二进制数替换即可。例如，要将$ABCD转换为二进制值，只需根据[表2-1](ch02s02.html#binary_solidus_hexadecimal_conversion
    "表2-1. 二进制/十六进制转换")将每个十六进制数字转换，如下所示：
- en: '| A | B | C | D | Hexadecimal |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| A | B | C | D | 十六进制 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1010 | 1011 | 1100 | 1101 | Binary |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | 1011 | 1100 | 1101 | 二进制 |'
- en: To convert a binary number into hexadecimal format is almost as easy. The first
    step is to pad the binary number with zeros to make sure that there is a multiple
    of 4 bits in the number. For example, given the binary number 1011001010, the
    first step would be to add 2 bits to the left of the number so that it contains
    12 bits. The converted binary value is 001011001010\. The next step is to separate
    the binary value into groups of 4 bits, for example, 0010_1100_1010\. Finally,
    look up these binary values in [Table 2-1](ch02s02.html#binary_solidus_hexadecimal_conversion
    "Table 2-1. Binary/Hexadecimal Conversion") and substitute the appropriate hexadecimal
    digits, that is, $2CA. Contrast this with the difficulty of conversion between
    decimal and binary or decimal and hexadecimal!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制数转换为十六进制格式几乎同样简单。第一步是用零填充二进制数，确保数字中的位数是4的倍数。例如，给定二进制数1011001010，第一步是向数字左侧添加2个二进制位，使其包含12位。转换后的二进制值为001011001010。下一步是将二进制值分成4位一组，例如，0010_1100_1010。最后，在[表2-1](ch02s02.html#binary_solidus_hexadecimal_conversion
    "表2-1. 二进制/十六进制转换")中查找这些二进制值，并替换为相应的十六进制数字，即$2CA。对比一下十进制和二进制或十进制和十六进制之间的转换难度！
- en: Because converting between hexadecimal and binary is an operation you will need
    to perform over and over again, you should take a few minutes and memorize the
    conversion table. Even if you have a calculator that will do the conversion for
    you, you'll find manual conversion to be a lot faster and more convenient when
    converting between binary and hex.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在十六进制和二进制之间转换是你需要反复执行的操作，所以你应该花几分钟记住转换表。即使你有一个可以为你进行转换的计算器，你会发现手动转换在二进制和十六进制之间的转换要快得多且更方便。
- en: 2.3 Data Organization
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 数据组织
- en: In pure mathematics a value's representation may take require an arbitrary number
    of bits. Computers, on the other hand, generally work with some specific number
    of bits. Common collections are single bits, groups of 4 bits (called *nibbles*),
    groups of 8 bits (*bytes*), groups of 16 bits (*words*), groups of 32 bits (*double
    words* or *dwords*), groups of 64 bits (*quad words* or *qwords*), groups of 128
    bits (*long words* or *lwords*), and more. The sizes are not arbitrary. There
    is a good reason for these particular values. This section will describe the bit
    groups commonly used on the Intel 80x86 chips.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯数学中，一个值的表示可能需要任意数量的位数。而计算机通常使用特定数量的位。常见的位数集合有单个位、4位一组（称为*nibble*）、8位一组（*byte*）、16位一组（*word*）、32位一组（*double
    word*或*dword*）、64位一组（*quad word*或*qword*）、128位一组（*long word*或*lword*）等。位数不是任意的，这些特定的值有其合理的原因。本节将描述在Intel
    80x86芯片上常用的位组。
- en: 2.3.1 Bits
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.1 位
- en: The smallest unit of data on a binary computer is a single bit. With a single
    bit, you can represent any two distinct items. Examples include 0 or 1, true or
    false, on or off, male or female, and right or wrong. However, you are *not* limited
    to representing binary data types (that is, those objects that have only two distinct
    values). You could use a single bit to represent the numbers 723 and 1,245 or,
    perhaps, the values 6,254 and 5\. You could also use a single bit to represent
    the colors red and blue. You could even represent two unrelated objects with a
    single bit. For example, you could represent the color red and the number 3,256
    with a single bit. You can represent *any two* different values with a single
    bit. However, you can represent *only two* different values with a single bit.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制计算机上的最小数据单位是单个比特。通过一个比特，你可以表示任何两种不同的项目。举例来说，包括0或1，true或false，开或关，男或女，对或错。然而，你并*不*局限于表示二进制数据类型（即那些只有两种不同值的对象）。你可以用一个比特表示数字723和1,245，或者可能是值6,254和5。你也可以用一个比特表示红色和蓝色。你甚至可以用一个比特表示两个不相关的对象。例如，你可以用一个比特表示红色和数字3,256。你可以用一个比特表示*任何两个*不同的值。然而，你只能用一个比特表示*两种*不同的值。
- en: 'To confuse things even more, different bits can represent different things.
    For example, you could use one bit to represent the values 0 and 1, while a different
    bit could represent the values true and false. How can you tell by looking at
    the bits? The answer, of course, is that you can''t. But this illustrates the
    whole idea behind computer data structures: *data is what you define it to be*.
    If you use a bit to represent a boolean (true/false) value, then that bit (by
    your definition) represents true or false. For the bit to have any real meaning,
    you must be consistent. If you''re using a bit to represent true or false at one
    point in your program, you shouldn''t use that value to represent red or blue
    later.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更加混淆的是，不同的比特可以表示不同的东西。例如，你可以用一个比特表示值0和1，而另一个比特可以表示值true和false。你怎么通过观察这些比特来判断它们的意义呢？答案显然是，你不能。但这恰恰说明了计算机数据结构的核心思想：*数据是你定义的那样*。如果你用一个比特表示布尔值（true/false），那么这个比特（按照你的定义）就代表了true或false。为了让比特具有实际意义，你必须保持一致性。如果在程序的某一部分你用一个比特表示true或false，那么你就不应该在后面的部分用它来表示红色或蓝色。
- en: Because most items you'll be trying to model require more than two different
    values, single-bit values aren't the most popular data type you'll use. However,
    because everything else consists of groups of bits, bits will play an important
    role in your programs. Of course, there are several data types that require two
    distinct values, so it would seem that bits are important by themselves. However,
    you will soon see that individual bits are difficult to manipulate, so we'll often
    use other data types to represent two-state values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为大多数你需要建模的项目需要超过两种不同的值，单比特值并不是你最常使用的数据类型。然而，由于其他一切都是由比特组组成的，因此比特在你的程序中将发挥重要作用。当然，也有几种数据类型需要两个不同的值，所以看起来比特本身是很重要的。然而，你很快就会发现，单个比特难以操作，因此我们通常会使用其他数据类型来表示两种状态值。
- en: 2.3.2 Nibbles
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.2 Nibbles
- en: 'A *nibble* is a collection of 4 bits. It wouldn''t be a particularly interesting
    data structure except for two facts: *binary-coded decimal (BCD)* numbers^([[21](#ftn.CHP-2-FN-1)])
    and hexadecimal numbers. It takes 4 bits to represent a single BCD or hexadecimal
    digit. With a nibble, we can represent up to 16 distinct values because there
    are 16 unique combinations of a string of 4 bits:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*nibble*是4个比特的集合。它本身并不是一个特别有趣的数据结构，除非考虑到两个事实：*二进制编码十进制（BCD）*数字^([[21](#ftn.CHP-2-FN-1)])和十六进制数字。表示一个BCD或十六进制数字需要4个比特。通过一个nibble，我们可以表示最多16个不同的值，因为4个比特的字符串有16种唯一的组合：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the case of hexadecimal numbers, the values 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    A, B, C, D, E, and F are represented with 4 bits. BCD uses 10 different digits
    (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) and requires also 4 bits (because we can only represent
    8 different values with 3 bits, the additional 6 values we can represent with
    4 bits are never used in BCD representation). In fact, any 16 distinct values
    can be represented with a nibble, though hexadecimal and BCD digits are the primary
    items we can represent with a single nibble.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于十六进制数字，值0、1、2、3、4、5、6、7、8、9、A、B、C、D、E和F用4个比特表示。BCD使用10个不同的数字（0、1、2、3、4、5、6、7、8、9），也需要4个比特（因为用3个比特只能表示8个不同的值，剩下的6个值用4个比特表示，但在BCD表示法中这些额外的值从未被使用）。事实上，任何16个不同的值都可以通过nibble表示，虽然十六进制和BCD数字是我们可以用单个nibble表示的主要项目。
- en: 2.3.3 Bytes
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.3 字节
- en: Without question, the most important data structure used by the 80x86 microprocessor
    is the byte, which consists of 8 bits. Main memory and I/O addresses on the 80x86
    are all byte addresses. This means that the smallest item that can be individually
    accessed by an 80x86 program is an 8-bit value. To access anything smaller requires
    that we read the byte containing the data and eliminate the unwanted bits. The
    bits in a byte are normally numbered from 0 to 7, as shown in [Figure 2-1](ch02s03.html#bit_numbering
    "Figure 2-1. Bit numbering").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，80x86微处理器使用的最重要数据结构是字节，它由8个位组成。80x86的主内存和I/O地址都是字节地址。这意味着，80x86程序能够单独访问的最小项是8位值。要访问更小的数据，必须读取包含数据的字节并去除不需要的位。字节中的位通常从0到7进行编号，如[图2-1](ch02s03.html#bit_numbering
    "图2-1. 位编号")所示。
- en: '![Bit numbering](tagoreillycom20100401nostarchimages577885.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![位编号](tagoreillycom20100401nostarchimages577885.png)'
- en: Figure 2-1. Bit numbering
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1. 位编号
- en: Bit 0 is the *low-order bit* or *least significant bit*, and bit 7 is the *high-order
    bit* or *most significant bit* of the byte. We'll refer to all other bits by their
    number.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 位0是*低位*或*最低有效位*，位7是*高位*或*最高有效位*。我们将其他所有位按其编号来引用。
- en: Note that a byte also contains exactly two nibbles (see [Figure 2-2](ch02s03.html#the_two_nibbles_in_a_byte
    "Figure 2-2. The two nibbles in a byte")).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个字节还恰好包含两个半字节（参见[图2-2](ch02s03.html#the_two_nibbles_in_a_byte "图2-2. 一个字节中的两个半字节")）。
- en: '![The two nibbles in a byte](tagoreillycom20100401nostarchimages577887.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![一个字节中的两个半字节](tagoreillycom20100401nostarchimages577887.png)'
- en: Figure 2-2. The two nibbles in a byte
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2. 一个字节中的两个半字节
- en: Bits 0..3 compose the *low-order nibble*, and bits 4..7 form the *high-order
    nibble*. Because a byte contains exactly two nibbles, byte values require two
    hexadecimal digits.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 位0到3组成*低位半字节*，位4到7组成*高位半字节*。由于一个字节恰好包含两个半字节，因此字节值需要两个十六进制数字。
- en: Because a byte contains 8 bits, it can represent 2⁸ (256) different values.
    Generally, we'll use a byte to represent numeric values in the range 0..255, signed
    numbers in the range −128..+127 (see [2.8 Signed and Unsigned Numbers](ch02s08.html
    "2.8 Signed and Unsigned Numbers")), ASCII/IBM character codes, and other special
    data types requiring no more than 256 different values. Many data types have fewer
    than 256 items, so 8 bits is usually sufficient.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个字节包含8个位，它可以表示2⁸（256）个不同的值。通常，我们使用字节表示范围为0到255的数字值、有符号数范围为−128到+127（参见[2.8
    有符号和无符号数字](ch02s08.html "2.8 有符号和无符号数字")）、ASCII/IBM字符代码以及其他需要不超过256个不同值的特殊数据类型。许多数据类型的项数少于256，因此8位通常足够。
- en: Because the 80x86 is a byte-addressable machine, it turns out to be more efficient
    to manipulate a whole byte than an individual bit or nibble. For this reason,
    most programmers use a whole byte to represent data types that require no more
    than 256 items, even if fewer than 8 bits would suffice. For example, we'll often
    represent the boolean values true and false by 00000001[2] and 00000000[2], respectively.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于80x86是字节寻址机器，因此操作整个字节比操作单个位或半字节更高效。因此，大多数程序员使用整个字节来表示需要不超过256个项的数据类型，即使使用少于8位也足够。例如，我们通常通过00000001[2]和00000000[2]分别表示布尔值true和false。
- en: Probably the most important use for a byte is holding a character value. Characters
    typed at the keyboard, displayed on the screen, and printed on the printer all
    have numeric values. To communicate with the rest of the world, PCs typically
    use a variant of the *ASCII character set*. There are 128 defined codes in the
    ASCII character set.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 字节最重要的用途可能是保存字符值。键盘输入的字符、显示在屏幕上的字符以及打印在打印机上的字符都有数值。为了与外部世界进行通信，个人电脑通常使用*ASCII字符集*的变种。ASCII字符集中定义了128个代码。
- en: 'Because bytes are the smallest unit of storage in the 80x86 memory space, bytes
    also happen to be the smallest variable you can create in an HLA program. As you
    saw in the last chapter, you can declare an 8-bit signed integer variable using
    the `int8` data type. Because `int8` objects are signed, you can represent values
    in the range −128..+127 using an `int8` variable. You should only store signed
    values into `int8` variables; if you want to create an arbitrary byte variable,
    you should use the `byte` data type, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字节是80x86内存空间中最小的存储单元，因此字节也恰好是你可以在HLA程序中创建的最小变量。如你在上一章中看到的，你可以使用`int8`数据类型声明一个8位有符号整数变量。由于`int8`对象是有符号的，因此你可以使用`int8`变量表示范围为−128到+127的值。你应该只将有符号值存储到`int8`变量中；如果你想创建一个任意字节变量，则应该使用`byte`数据类型，如下所示：
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `byte` data type is a partially untyped data type. The only type information
    associated with a `byte` object is its size (1 byte). You may store any 8-bit
    value (small signed integers, small unsigned integers, characters, and the like)
    into a byte variable. It is up to you to keep track of the type of object you've
    put into a byte variable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte`数据类型是一个部分未类型化的数据类型。与`byte`对象关联的唯一类型信息是它的大小（1字节）。你可以将任何8位值（小的有符号整数、小的无符号整数、字符等）存储到字节变量中。你需要自行跟踪你存储在字节变量中的对象类型。'
- en: 2.3.4 Words
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.4 字
- en: A word is a group of 16 bits. We'll number the bits in a word from 0 to 15,
    as [Figure 2-3](ch02s03.html#bit_numbers_in_a_word "Figure 2-3. Bit numbers in
    a word") shows. Like the byte, bit 0 is the low-order bit. For words, bit 15 is
    the high-order bit. When referencing the other bits in a word, we'll use their
    bit position number.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字是由16个位组成的。我们将字中的位从0编号到15，如[图2-3](ch02s03.html#bit_numbers_in_a_word "图2-3.
    字中的位数")所示。与字节一样，位0是最低有效位。对于字来说，位15是最高有效位。在引用字中的其他位时，我们将使用它们的位位置编号。
- en: '![Bit numbers in a word](tagoreillycom20100401nostarchimages577889.png.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![字中的位数](tagoreillycom20100401nostarchimages577889.png.jpg)'
- en: Figure 2-3. Bit numbers in a word
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3. 字中的位数
- en: Notice that a word contains exactly 2 bytes. Bits 0..7 form the low-order byte,
    and bits 8..15 form the high-order byte (see [Figure 2-4](ch02s03.html#the_two_bytes_in_a_word
    "Figure 2-4. The two bytes in a word")).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个字包含恰好2个字节。位0..7构成低字节，位8..15构成高字节（见[图2-4](ch02s03.html#the_two_bytes_in_a_word
    "图2-4. 字中的两个字节")）。
- en: '![The two bytes in a word](tagoreillycom20100401nostarchimages577891.png.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![字中的两个字节](tagoreillycom20100401nostarchimages577891.png.jpg)'
- en: Figure 2-4. The two bytes in a word
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4. 字中的两个字节
- en: Of course, a word may be further broken down into four nibbles, as shown in
    [Figure 2-5](ch02s03.html#nibbles_in_a_word "Figure 2-5. Nibbles in a word").
    Nibble 0 is the low-order nibble in the word, and nibble 3 is the high-order nibble
    of the word. We'll simply refer to the other two nibbles as *nibble 1* or *nibble
    2*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个字还可以进一步分解为四个半字，如[图2-5](ch02s03.html#nibbles_in_a_word "图2-5. 字中的半字")所示。半字0是字中的最低有效半字，半字3是字中的最高有效半字。我们将其他两个半字分别称为*nibble
    1*和*nibble 2*。
- en: '![Nibbles in a word](tagoreillycom20100401nostarchimages577893.png.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![字中的半字](tagoreillycom20100401nostarchimages577893.png.jpg)'
- en: Figure 2-5. Nibbles in a word
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5. 字中的半字
- en: With 16 bits, you can represent 2^(16) (65,536) different values. These could
    be the values in the range 0..65,535 or, as is usually the case, the signed values
    −32,768..+32,767, or any other data type with no more than 65,536 values. The
    three major uses for words are short signed integer values, short unsigned integer
    values, and Unicode characters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过16个位，你可以表示2^(16)（65,536）种不同的值。这些值可以是范围0..65,535内的值，或者通常的情况是有符号值−32,768..+32,767，或者是任何其他不超过65,536个值的数据类型。字的三大主要用途是短的有符号整数值、短的无符号整数值以及Unicode字符。
- en: Words can represent integer values in the range 0..65,535 or −32,768..32,767\.
    Unsigned numeric values are represented by the binary value corresponding to the
    bits in the word. Signed numeric values use the two's complement form for numeric
    values (see [2.8 Signed and Unsigned Numbers](ch02s08.html "2.8 Signed and Unsigned
    Numbers")). As Unicode characters, words can represent up to 65,536 different
    characters, allowing the use of non-Roman character sets in a computer program.
    Unicode is an international standard, like ASCII, that allows computers to process
    non-Roman characters such as Asian, Greek, and Russian characters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 字可以表示0..65,535或−32,768..32,767范围内的整数值。无符号数值由字中的位所对应的二进制值表示。有符号数值使用二的补码形式表示数值（参见[2.8
    有符号和无符号数](ch02s08.html "2.8 有符号和无符号数")）。作为Unicode字符，字可以表示最多65,536个不同的字符，允许计算机程序使用非罗马字符集。Unicode是一种国际标准，类似于ASCII，它允许计算机处理非罗马字符，例如亚洲字符、希腊字母和俄语字符。
- en: 'As with bytes, you can also create word variables in an HLA program. Of course,
    in the last chapter you saw how to create 16-bit signed integer variables using
    the `int16` data type. To create an arbitrary word variable, just use the `word`
    data type, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与字节类似，你也可以在HLA程序中创建字变量。当然，在上一章中你已经看到如何使用`int16`数据类型创建16位有符号整数变量。要创建一个任意的字变量，只需使用`word`数据类型，如下所示：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 2.3.5 Double Words
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.5 双字
- en: A double word is exactly what its name implies, a pair of words. Therefore,
    a double-word quantity is 32 bits long, as shown in [Figure 2-6](ch02s03.html#bit_numbers_in_a_double_word
    "Figure 2-6. Bit numbers in a double word").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 双字正如其名，是一对字。因此，双字量是32位长，如[图2-6](ch02s03.html#bit_numbers_in_a_double_word "图2-6.
    双字中的比特数")所示。
- en: '![Bit numbers in a double word](tagoreillycom20100401nostarchimages577895.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![双字中的比特数](tagoreillycom20100401nostarchimages577895.png)'
- en: Figure 2-6. Bit numbers in a double word
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6. 双字中的比特数
- en: Naturally, this double word can be divided into a high-order word and a low-order
    word, four different bytes, or eight different nibbles (see [Figure 2-7](ch02s03.html#nibbles_comma_bytes_comma_and_words_in_a
    "Figure 2-7. Nibbles, bytes, and words in a double word")).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，这个双字可以分为高位字和低位字、四个不同的字节，或者八个不同的半字节（见[图2-7](ch02s03.html#nibbles_comma_bytes_comma_and_words_in_a
    "图2-7. 双字中的字节、字和四位字节")）。
- en: Double words (dwords) can represent all kinds of different things. A common
    item you will represent with a double word is a 32-bit integer value (that allows
    unsigned numbers in the range 0..4,294,967,295 or signed numbers in the range
    −2,147,483,648..2,147,483,647). 32-bit floating-point values also fit into a double
    word. Another common use for double-word objects is to store pointer values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 双字（dwords）可以表示各种不同的事物。你常用双字表示的一个项目是32位整数值（允许无符号数在0..4,294,967,295范围内，或有符号数在−2,147,483,648..2,147,483,647范围内）。32位浮点值也可以适应双字。双字对象的另一个常见用途是存储指针值。
- en: '![Nibbles, bytes, and words in a double word](tagoreillycom20100401nostarchimages577897.png.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![双字中的字节、字和四位字节](tagoreillycom20100401nostarchimages577897.png.jpg)'
- en: Figure 2-7. Nibbles, bytes, and words in a double word
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-7. 双字中的字节、字和四位字节
- en: 'In [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE"), you
    saw how to create 32-bit signed integer variables using the `int32` data type.
    You can also create an arbitrary double-word variable using the `dword` data type,
    as the following example demonstrates:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 汇编语言的世界，你好")中，你学会了如何使用`int32`数据类型创建32位有符号整数变量。你还可以使用`dword`数据类型创建任意双字变量，如以下示例所示：
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 2.3.6 Quad Words and Long Words
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.6 四字和长字
- en: 'Obviously, we can keep on defining larger and larger word sizes. However, the
    80x86 supports only certain native sizes, so there is little reason to keep on
    defining terms for larger and larger objects. Although bytes, words, and double
    words are the most common sizes you''ll find in 80x86 programs, quad word (64-bit)
    values are also important because certain floating-point data types require 64
    bits. Likewise, the SSE/MMX instruction set of modern 80x86 processors can manipulate
    64-bit values. In a similar vein, long-word (128-bit) values are also important
    because the SSE instruction set on later 80x86 processors can manipulate 128-bit
    values. HLA allows the declaration of 64- and 128-bit values using the `qword`
    and `lword` types, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以继续定义越来越大的字大小。然而，80x86只支持某些特定的原生大小，因此继续定义更大对象的术语没有太大意义。虽然字节、字和双字是你在80x86程序中最常见的大小，但四字（64位）值也很重要，因为某些浮点数据类型需要64位。同样，现代80x86处理器的SSE/MMX指令集可以操作64位值。从类似的角度看，长字（128位）值也很重要，因为后期80x86处理器的SSE指令集能够操作128位值。HLA允许使用`qword`和`lword`类型声明64位和128位值，如下所示：
- en: '[PRE4]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that you may also define 64-bit and 128-bit integer values using HLA declarations
    like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你还可以使用像以下这样的HLA声明来定义64位和128位的整数值：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, you may not directly manipulate 64-bit and 128-bit integer objects
    using standard instructions like `mov`, `add`, and `sub` because the standard
    80x86 integer registers process only 32 bits at a time. In [Chapter 8](ch08.html
    "Chapter 8. ADVANCED ARITHMETIC"), you will see how to manipulate these *extended-precision*
    values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能直接使用标准指令如`mov`、`add`和`sub`来操作64位和128位整数对象，因为标准80x86整数寄存器每次只能处理32位。在[第8章](ch08.html
    "第8章. 高级算术")中，你将看到如何操作这些*扩展精度*值。
- en: '* * *'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[21](#CHP-2-FN-1)]) Binary-coded decimal is a numeric scheme used to represent
    decimal numbers using 4 bits for each decimal digit.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[21](#CHP-2-FN-1)]) 二进制编码十进制是一种数值方案，用于通过每个十进制数字4位来表示十进制数。
- en: 2.4 Arithmetic Operations on Binary and Hexadecimal Numbers
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 二进制和十六进制数的算术运算
- en: 'There are several operations we can perform on binary and hexadecimal numbers.
    For example, we can add, subtract, multiply, divide, and perform other arithmetic
    operations. Although you needn''t become an expert at it, you should be able to,
    in a pinch, perform these operations manually using a piece of paper and a pencil.
    Having just said that you should be able to perform these operations manually,
    the correct way to perform such arithmetic operations is to have a calculator
    that does them for you. There are several such calculators on the market; the
    following list shows some of the manufacturers of hexadecimal calculators (in
    2010):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对二进制和十六进制数字执行几种运算。例如，我们可以加法、减法、乘法、除法，以及执行其他算术运算。虽然你不必成为这一方面的专家，但在紧急情况下，你应该能够手动使用纸和笔完成这些运算。虽然刚才说过你应该能够手动执行这些算术运算，正确的做法是拥有一款可以自动完成这些运算的计算器。市场上有几款这样的计算器；以下是一些十六进制计算器制造商的列表（2010年）：
- en: Casio
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡西欧（Casio）
- en: Hewlett-Packard
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惠普（Hewlett-Packard）
- en: Sharp
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 夏普（Sharp）
- en: Texas Instruments
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 德州仪器（Texas Instruments）
- en: This list is by no means exhaustive. Other calculator manufacturers probably
    produce these devices as well. The Hewlett-Packard devices are arguably the best
    of the bunch. However, they are more expensive than the others. Sharp and Casio
    produce units that sell for well under fifty dollars. If you plan on doing any
    assembly language programming at all, owning one of these calculators is essential.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并非详尽无遗。其他计算器制造商可能也生产这些设备。惠普（Hewlett-Packard）的设备无疑是其中最好的。然而，它们比其他品牌更贵。夏普和卡西欧生产的设备价格远低于五十美元。如果你打算进行任何汇编语言编程，拥有其中一款计算器是必不可少的。
- en: 'To understand why you should spend the money on a calculator, consider the
    following arithmetic problem:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么你应该花钱买一台计算器，考虑以下这个算术问题：
- en: '[PRE6]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You''re probably tempted to write in the answer $10 as the solution to this
    problem. But that is not correct! The correct answer is 10, which is $A, not 16,
    which is $10\. A similar problem exists with the following subtraction problem:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想写出答案$10作为这个问题的解答。但那是错误的！正确答案是10，即$A，而不是16，即$10。类似的问题也出现在以下的减法问题中：
- en: '[PRE7]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You're probably tempted to answer $9 even though the correct answer is $F. Remember,
    this problem is asking, "What is the difference between 16 and 1?" The answer,
    of course, is 15, which is $F.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想回答$9，尽管正确答案是$F。记住，这个问题问的是：“16和1之间的差是多少？”答案当然是15，即$F。
- en: Even if these two problems don't bother you, in a stressful situation your brain
    will switch back into decimal while you're thinking about something else and you'll
    produce the incorrect result. Moral of the story—if you must do an arithmetic
    computation using hexadecimal numbers by hand, take your time and be careful about
    it. Either that, or convert the numbers to decimal, perform the operation in decimal,
    and convert them back to hexadecimal.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这两个问题不困扰你，在紧张情况下，你的大脑会在你考虑其他事情时自动转换回十进制，从而得出错误的结果。故事的寓意是——如果你必须手动使用十六进制数字进行算术计算，一定要慢慢来，注意细节。或者，你可以将数字转换为十进制，进行十进制运算后再转换回十六进制。
- en: 2.5 A Note About Numbers vs. Representation
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 数字与表示的说明
- en: Many people confuse numbers and their representation. A common question beginning
    assembly language students ask is, "I have a binary number in the EAX register;
    how do I convert that to a hexadecimal number in the EAX register?" The answer
    is, " You don't." Although a strong argument could be made that numbers in memory
    or in registers are represented in binary, it's best to view values in memory
    or in a register as *abstract numeric quantities*. Strings of symbols like 128,
    $80, or %1000_0000 are not different numbers; they are simply different representations
    for the same abstract quantity that we refer to as "one hundred twenty-eight."
    Inside the computer, a number is a number regardless of representation; the only
    time representation matters is when you input or output the value in a human-readable
    form.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人会混淆数字及其表示形式。初学汇编语言的学生常问一个问题：“我有一个在EAX寄存器中的二进制数；我怎么将它转换为EAX寄存器中的十六进制数？”答案是，“你不能。”尽管可以提出有力的论据，认为内存或寄存器中的数字是以二进制表示的，但最好将内存或寄存器中的值视为*抽象的数值*。像128、$80或%1000_0000这样的符号串并不是不同的数字；它们只是“128”这个抽象量的不同表示形式。在计算机内部，无论表示方式如何，数字就是数字；只有在你以人类可读的形式输入或输出值时，表示方式才重要。
- en: Human-readable forms of numeric quantities are always strings of characters.
    To print the value 128 in human-readable form, you must convert the numeric value
    128 to the three-character sequence 1 followed by 2 followed by 8\. This would
    provide the decimal representation of the numeric quantity. If you prefer, you
    could convert the numeric value 128 to the three-character sequence $80\. It's
    the same number, but we've converted it to a different sequence of characters
    because (presumably) we wanted to view the number using hexadecimal representation
    rather than decimal. Likewise, if we want to see the number in binary, then we
    must convert this numeric value to a string containing a 1 followed by seven 0s.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 人类可读的数字量形式始终是字符字符串。为了以人类可读的形式打印值128，必须将数字值128转换为由字符1、2、8组成的三字符序列。这将提供数字量的十进制表示形式。如果你愿意，也可以将数字值128转换为三字符序列$80\。它是相同的数字，但我们将其转换为不同的字符序列，因为（假设）我们希望以十六进制表示该数字，而不是十进制。同样，如果我们希望以二进制形式查看该数字，则必须将该数字值转换为包含一个1后跟七个0的字符串。
- en: By default, HLA displays all `byte`, `word`, `dword`, `qword`, and `lword` variables
    using the hexadecimal numbering system when using the `stdout.put` routine. Likewise,
    HLA's `stdout.put` routine will display all register values in hexadecimal form.
    Consider the program in [Example 2-1](ch02s05.html#decimal-to-hexadecimal_conversion_progra
    "Example 2-1. Decimal-to-hexadecimal conversion program"), which converts values
    input as decimal numbers to their hexadecimal equivalents.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用`stdout.put`例程时，HLA会以十六进制计数法显示所有`byte`、`word`、`dword`、`qword`和`lword`变量。同样，HLA的`stdout.put`例程也会以十六进制形式显示所有寄存器的值。考虑[示例2-1](ch02s05.html#decimal-to-hexadecimal_conversion_progra
    "示例2-1. 十进制到十六进制转换程序")中的程序，该程序将作为十进制数字输入的值转换为其十六进制等价值。
- en: Example 2-1. Decimal-to-hexadecimal conversion program
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-1. 十进制到十六进制转换程序
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In a similar fashion, the default input base is also hexadecimal for registers
    and `byte`, `word`, `dword`, `qword`, or `lword` variables. The program in [Example 2-2](ch02s05.html#hexadecimal-to-decimal_conversion_progra
    "Example 2-2. Hexadecimal-to-decimal conversion program") is the converse of the
    one in [Example 2-1](ch02s05.html#decimal-to-hexadecimal_conversion_progra "Example 2-1. Decimal-to-hexadecimal
    conversion program"); it inputs a hexadecimal value and outputs it as decimal.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，寄存器和`byte`、`word`、`dword`、`qword`、`lword`类型变量的默认输入基数也是十六进制。在[示例2-2](ch02s05.html#hexadecimal-to-decimal_conversion_progra
    "示例2-2. 十六进制到十进制转换程序")中的程序与[示例2-1](ch02s05.html#decimal-to-hexadecimal_conversion_progra
    "示例2-1. 十进制到十六进制转换程序")中的程序相反；它输入一个十六进制值，并将其输出为十进制。
- en: Example 2-2. Hexadecimal-to-decimal conversion program
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-2. 十六进制到十进制转换程序
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Just because the HLA `stdout.put` routine chooses decimal as the default output
    base for `int8`, `int16`, and `int32` variables doesn't mean that these variables
    hold decimal numbers. Remember, memory and registers hold numeric values, not
    hexadecimal or decimal values. The `stdout.put` routine converts these numeric
    values to strings and prints the resulting strings. The choice of hexadecimal
    versus decimal output was a design choice in the HLA language, nothing more. You
    could very easily modify HLA so that it outputs registers and `byte`, `word`,
    `dword`, `qword`, or `lword` variables as decimal values rather than as hexadecimal.
    If you need to print the value of a register or `byte`, `word`, or `dword` variable
    as a decimal value, simply call one of the `putiX` routines to do this. The `stdout.puti8`
    routine will output its parameter as an 8-bit signed integer. Any 8-bit parameter
    will work. So you could pass an 8-bit register, an `int8` variable, or a `byte`
    variable as the parameter to `stdout.puti8` and the result will always be decimal.
    The `stdout.puti16` and `stdout.puti32` routines provide the same capabilities
    for 16-bit and 32-bit objects. The program in [Example 2-3](ch02s05.html#variable-less_hexadecimal-to-decimal_con
    "Example 2-3. Variable-less hexadecimal-to-decimal converter") demonstrates the
    decimal conversion program ([Example 2-2](ch02s05.html#hexadecimal-to-decimal_conversion_progra
    "Example 2-2. Hexadecimal-to-decimal conversion program")) using only the EBX
    register (that is, it does not use the variable `iValue`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为 HLA 的 `stdout.put` 例程选择了十进制作为 `int8`、`int16` 和 `int32` 变量的默认输出基数，并不意味着这些变量保存的是十进制数。请记住，内存和寄存器保存的是数值，而不是十六进制或十进制值。`stdout.put`
    例程将这些数值转换为字符串并打印出结果。选择十六进制还是十进制输出是 HLA 语言中的设计选择，仅此而已。你可以很容易地修改 HLA，使其将寄存器和 `byte`、`word`、`dword`、`qword`
    或 `lword` 变量输出为十进制值，而不是十六进制值。如果你需要将寄存器或 `byte`、`word`、`dword` 变量的值以十进制显示，只需调用其中一个
    `putiX` 例程。`stdout.puti8` 例程会将其参数作为 8 位有符号整数输出。任何 8 位参数都能工作。所以你可以将一个 8 位寄存器、`int8`
    变量或 `byte` 变量作为参数传递给 `stdout.puti8`，结果将始终是十进制输出。`stdout.puti16` 和 `stdout.puti32`
    例程为 16 位和 32 位对象提供相同的功能。[示例 2-3](ch02s05.html#variable-less_hexadecimal-to-decimal_con
    "示例 2-3. 无变量的十六进制到十进制转换器") 程序演示了使用仅包含 EBX 寄存器的十进制转换程序（即不使用变量 `iValue`），与 [示例 2-2](ch02s05.html#hexadecimal-to-decimal_conversion_progra
    "示例 2-2. 十六进制到十进制转换程序") 一起展示。
- en: Example 2-3. Variable-less hexadecimal-to-decimal converter
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-3. 无变量的十六进制到十进制转换器
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that HLA's `stdin.get` routine uses the same default base for input as
    `stdout.put` uses for output. That is, if you attempt to read an `int8`, `int16`,
    or `int32` variable, the default input base is decimal. If you attempt to read
    a register or `byte`, `word`, `dword`, `qword`, or `lword` variable, the default
    input base is hexadecimal. If you want to change the default input base to decimal
    when reading a register or a `byte`, `word`, `dword`, `qword`, or `lword` variable,
    then you can use `stdin.geti8`, `stdin.geti16`, `stdin.geti32`, `stdin.geti64`,
    or `stdin.geti128`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，HLA 的 `stdin.get` 例程对于输入使用的默认基数与 `stdout.put` 例程用于输出时使用的默认基数相同。也就是说，如果你尝试读取一个
    `int8`、`int16` 或 `int32` 变量，默认输入基数是十进制。如果你尝试读取一个寄存器或 `byte`、`word`、`dword`、`qword`
    或 `lword` 变量，默认输入基数是十六进制。如果你希望在读取寄存器或 `byte`、`word`、`dword`、`qword` 或 `lword`
    变量时将默认输入基数更改为十进制，则可以使用 `stdin.geti8`、`stdin.geti16`、`stdin.geti32`、`stdin.geti64`
    或 `stdin.geti128`。
- en: 'If you want to go in the opposite direction, that is you want to input or output
    an `int8`, `int16`, `int32`, `int64`, or `int128` variable as a hexadecimal value,
    you can call the `stdout.puth8`, `stdout.puth16`, `stdout.puth32`, `stdout.puth64`,
    `stdout.puth128`, `stdin.geth8`, `stdin.geth16`, `stdin.geth32`, `stdin.geth64`,
    or `stdin.geth128` routines. The `stdout.puth8`, `stdout.puth16`, `stdout.puth32`,
    `stdout.puth64`, and `stdout.puth128` routines write 8-bit, 16-bit, 32-bit, 64-bit,
    or 128-bit objects as hexadecimal values. The `stdin.geth8`, `stdin.geth16`, `stdin.geth32`,
    `stdin.geth64`, and `stdin.geth128` routines read 8-, 16-, 32-, 64-, and 128-bit
    values, respectively; they return their results in the AL, AX, or EAX registers
    (or in a parameter location for 64-bit and 128-bit values). The program in [Example 2-4](ch02s05.html#demonstration_of_stdin.geth32_and_stdout
    "Example 2-4. Demonstration of stdin.geth32 and stdout.puth32") demonstrates the
    use of a few of these routines:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想反向操作，也就是将 `int8`、`int16`、`int32`、`int64` 或 `int128` 变量作为十六进制值输入或输出，可以调用
    `stdout.puth8`、`stdout.puth16`、`stdout.puth32`、`stdout.puth64`、`stdout.puth128`、`stdin.geth8`、`stdin.geth16`、`stdin.geth32`、`stdin.geth64`
    或 `stdin.geth128` 函数。`stdout.puth8`、`stdout.puth16`、`stdout.puth32`、`stdout.puth64`
    和 `stdout.puth128` 函数将 8 位、16 位、32 位、64 位或 128 位对象以十六进制值写入。`stdin.geth8`、`stdin.geth16`、`stdin.geth32`、`stdin.geth64`
    和 `stdin.geth128` 函数分别读取 8 位、16 位、32 位、64 位和 128 位的值；它们将结果返回到 AL、AX 或 EAX 寄存器（或者对于
    64 位和 128 位值返回到参数位置）。[示例 2-4](ch02s05.html#demonstration_of_stdin.geth32_and_stdout
    "示例 2-4. 演示 stdin.geth32 和 stdout.puth32") 中的程序展示了这些函数的一些使用方法：
- en: Example 2-4. Demonstration of `stdin.geth32` and `stdout.puth32`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-4. 演示 `stdin.geth32` 和 `stdout.puth32`
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 2.6 Logical Operations on Bits
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 位级逻辑运算
- en: 'There are four primary logical operations we''ll do with hexadecimal and binary
    numbers: `and`, `or`, `xor` (exclusive-or), and `not`. Unlike for the arithmetic
    operations, a hexadecimal calculator isn''t necessary to perform these operations.
    It is often easier to do them by hand than to use an electronic device to compute
    them. The logical `and` operation is a dyadic^([[22](#ftn.CHP-2-FN-2)]) operation
    (meaning it accepts exactly two operands). These operands are individual binary
    bits. The `and` operation is:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行四种主要的逻辑运算，使用十六进制和二进制数字：`and`、`or`、`xor`（异或）和 `not`。与算术运算不同，进行这些运算时不需要十六进制计算器。手动操作通常比使用电子设备计算要简单。逻辑
    `and` 运算是一个二元^([[22](#ftn.CHP-2-FN-2)]) 运算（意味着它接受恰好两个操作数）。这些操作数是单独的二进制位。`and`
    运算为：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A compact way to represent the logical `and` operation is with a truth table.
    A truth table takes the form shown in [Table 2-2](ch02s06.html#and_truth_table
    "Table 2-2. and Truth Table").
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一种紧凑的方式来表示逻辑 `and` 运算是使用真值表。真值表的形式如 [表 2-2](ch02s06.html#and_truth_table "表
    2-2. and 真值表") 所示。
- en: Table 2-2. `and` Truth Table
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2. `and` 真值表
- en: '| **`and`** | 0 | 1 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **`and`** | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: This is just like the multiplication tables you've encountered in school. The
    values in the left column correspond to the leftmost operand of the `and` operation.
    The values in the top row correspond to the rightmost operand of the `and` operation.
    The value located at the intersection of the row and column (for a particular
    pair of input values) is the result of logically `and`ing those two values together.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像你在学校遇到的乘法表。左列的值对应 `and` 运算的左操作数。顶部行的值对应 `and` 运算的右操作数。位于行和列交点处的值（对于特定输入值对）是这两个值进行逻辑
    `and` 运算后的结果。
- en: In English, the logical `and` operation is, "If the first operand is 1 and the
    second operand is 1, the result is 1; otherwise the result is 0." We could also
    state this as, "If either or both operands are 0, the result is 0."
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，逻辑`and`运算是，“如果第一个操作数为 1 且第二个操作数为 1，则结果为 1；否则结果为 0。”我们也可以这样表达，“如果任一操作数或两个操作数都是
    0，则结果为 0。”
- en: One important fact to note about the logical `and` operation is that you can
    use it to force a 0 result. If one of the operands is 0, the result is always
    0 regardless of the other operand. In the truth table above, for example, the
    row labeled with a 0 input contains only 0s, and the column labeled with a 0 contains
    only 0 results. Conversely, if one operand contains a 1, the result is exactly
    the value of the second operand. These results of the `and` operation are very
    important, particularly when we want to force bits to 0\. We will investigate
    these uses of the logical `and` operation in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于逻辑`and`操作，有一个重要的事实需要注意，那就是你可以用它来强制得到一个0的结果。如果一个操作数为0，则结果始终为0，不管另一个操作数的值是什么。例如，在上面的真值表中，标记为0输入的行只有0，标记为0的列结果也全是0。相反，如果一个操作数为1，则结果完全等于第二个操作数的值。`and`操作的这些结果非常重要，特别是当我们想强制将比特设置为0时。我们将在下一节中进一步探讨逻辑`and`操作的这些应用。
- en: 'The logical `or` operation is also a dyadic operation. Its definition is:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑`or`操作也是一种二元操作。它的定义是：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The truth table for the `or` operation takes the form appearing in [Table 2-3](ch02s06.html#or_truth_table
    "Table 2-3. or Truth Table").
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`操作的真值表呈现于[表2-3](ch02s06.html#or_truth_table "表2-3. or 真值表")中。'
- en: Table 2-3. `or` Truth Table
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-3. `or` 真值表
- en: '| **`or`** | 0 | 1 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| **`or`** | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 1 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: Colloquially, the logical `or` operation is, "If the first operand or the second
    operand (or both) is 1, the result is 1; otherwise the result is 0." This is also
    known as the *inclusive-or* operation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 口语中，逻辑`or`操作是，“如果第一个操作数或第二个操作数（或两者）为1，则结果为1；否则结果为0。”这也被称为*包含或*操作。
- en: If one of the operands to the logical `or` operation is a 1, the result is always
    1 regardless of the second operand's value. If one operand is 0, the result is
    always the value of the second operand. Like the logical `and` operation, this
    is an important side effect of the logical `or` operation that will prove quite
    useful.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果逻辑`or`操作的一个操作数为1，则结果始终为1，不管第二个操作数的值是什么。如果一个操作数为0，则结果始终是第二个操作数的值。像逻辑`and`操作一样，这是逻辑`or`操作的一个重要副作用，实际上非常有用。
- en: Note that there is a difference between this form of the inclusive logical `or`
    operation and the standard English meaning. Consider the phrase "I am going to
    the store *or* I am going to the park." Such a statement implies that the speaker
    is going to the store or to the park but not to both places. Therefore, the English
    version of logical `or` is slightly different from the inclusive-or operation;
    indeed, this is the definition of the *exclusive-or* operation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种形式的包含逻辑`or`操作与标准英语中的含义是不同的。考虑句子“我要去商店*或者*我要去公园。”这样的表述意味着说话者要么去商店，要么去公园，而不是同时去两个地方。因此，英语中的逻辑`or`略有不同于包含或操作；实际上，这就是*异或*操作的定义。
- en: 'The logical `xor` (exclusive-or) operation is also a dyadic operation. Its
    definition follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑`xor`（异或）操作也是一种二元操作。它的定义如下：
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The truth table for the `xor` operation takes the form shown in [Table 2-4](ch02s06.html#xor_truth_table
    "Table 2-4. xor Truth Table").
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor`操作的真值表呈现于[表2-4](ch02s06.html#xor_truth_table "表2-4. xor 真值表")中。'
- en: Table 2-4. `xor` Truth Table
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-4. `xor` 真值表
- en: '| **`xor`** | 0 | 1 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **`xor`** | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 1 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: In English, the logical `xor` operation is, "If the first operand or the second
    operand, but not both, is 1, the result is 1; otherwise the result is 0." Note
    that the exclusive-or operation is closer to the English meaning of the word *or*
    than is the logical `or` operation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，逻辑`xor`操作是，“如果第一个操作数或第二个操作数（但不是两者），为1，则结果为1；否则结果为0。”请注意，异或操作比逻辑`or`操作更接近英语中*or*这个词的含义。
- en: If one of the operands to the logical exclusive-or operation is a 1, the result
    is always the *inverse* of the other operand; that is, if one operand is 1, the
    result is 0 if the other operand is 1, and the result is 1 if the other operand
    is 0\. If the first operand contains a 0, then the result is exactly the value
    of the second operand. This feature lets you selectively invert bits in a bit
    string.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果逻辑异或操作的一个操作数为1，则结果始终是另一个操作数的*反转*；即，如果一个操作数为1，而另一个操作数为1，则结果为0；如果另一个操作数为0，则结果为1。如果第一个操作数为0，则结果完全等于第二个操作数的值。这个特性让你可以在比特串中选择性地反转比特。
- en: 'The logical `not` operation is a monadic operation (meaning it accepts only
    one operand):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑`not`操作是单目操作（意味着它只接受一个操作数）：
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The truth table for the `not` operation appears in [Table 2-5](ch02s06.html#not_truth_table
    "Table 2-5. not Truth Table").
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`操作的真值表见于[表2-5](ch02s06.html#not_truth_table "表2-5. not真值表")。'
- en: Table 2-5. `not` Truth Table
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-5. `not` 真值表
- en: '| **`not`** | 0 | 1 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **`not`** | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|   | 1 | 0 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|   | 1 | 0 |'
- en: '* * *'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[22](#CHP-2-FN-2)]) Many texts call this a binary operation. The term *dyadic*
    means the same thing and avoids the confusion with the binary numbering system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[22](#CHP-2-FN-2)]) 许多文本称之为二进制运算。术语*二元*表示相同的意思，并避免了与二进制计数系统的混淆。
- en: 2.7 Logical Operations on Binary Numbers and Bit Strings
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.7 二进制数和位串的逻辑运算
- en: 'The previous section defines the logical functions for single-bit operands.
    Because the 80x86 uses groups of 8, 16, or 32 bits, we need to extend the definition
    of these functions to deal with more than 2 bits. Logical functions on the 80x86
    operate on a *bit-by-bit* (or *bitwise*) basis. Given two values, these functions
    operate on bit 0, producing bit 0 of the result. They operate on bit 1 of the
    input values, producing bit 1 of the result, and so on. For example, if you want
    to compute the logical `and` of the following two 8-bit numbers, you would perform
    the logical `and` operation on each column independently of the others:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节定义了单比特操作数的逻辑函数。由于80x86使用的是8、16或32位的字长，我们需要扩展这些函数的定义，以处理超过2位的情况。80x86上的逻辑函数是逐位（或按位）操作的。给定两个值，这些函数对第0位执行操作，生成结果的第0位。它们对输入值的第1位执行操作，生成结果的第1位，以此类推。例如，如果你想计算以下两个8位数的逻辑`and`，你将对每一列独立地执行逻辑`and`操作：
- en: '[PRE16]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You may apply this bit-by-bit calculation to the other logical functions as
    well.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这种逐位计算应用于其他逻辑函数。
- en: Because we've defined logical operations in terms of binary values, you'll find
    it much easier to perform logical operations on binary values than on other representations.
    Therefore, if you want to perform a logical operation on two hexadecimal numbers,
    you should convert them to binary first. This applies to most of the basic logical
    operations on binary numbers (e.g., `and`, `or`, `xor`, etc.).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经定义了基于二进制值的逻辑运算，所以你会发现对二进制值进行逻辑运算比其他表示形式更容易。因此，如果你想对两个十六进制数执行逻辑运算，应该先将它们转换为二进制。这适用于大多数基本的二进制逻辑运算（如`and`、`or`、`xor`等）。
- en: The ability to force bits to 0 or 1 using the logical `and`/`or` operations
    and the ability to invert bits using the logical `xor` operation are very important
    when working with strings of bits (e.g., binary numbers). These operations let
    you selectively manipulate certain bits within some bit string while leaving other
    bits unaffected. For example, if you have an 8-bit binary value *X* and you want
    to guarantee that bits 4..7 contain 0s, you could logically `and` the value *X*
    with the binary value %0000_1111\. This bitwise logical `and` operation would
    force the H.O. 4 bits to 0 and pass the L.O. 4 bits of *X* unchanged. Likewise,
    you could force the L.O. bit of *X* to 1 and invert bit 2 of *X* by logically
    `or`ing *X* with %0000_0001 and logically exclusive-`or`ing *X* with %0000_0100,
    respectively. Using the logical `and`, `or`, and `xor` operations to manipulate
    bit strings in this fashion is known as *masking* bit strings. We use the term
    *masking* because we can use certain values (1 for `and`, 0 for `or`/`xor`) to
    mask out or mask in certain bits from the operation when forcing bits to 0, 1,
    or their inverse.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑`and`/`or`操作将比特强制为0或1的能力，以及使用逻辑`xor`操作反转比特的能力，在处理比特串（如二进制数）时非常重要。这些操作使你能够选择性地操作比特串中的某些比特，而不影响其他比特。例如，如果你有一个8位的二进制值*X*，并且想要保证第4..7位为0，你可以将值*X*与二进制值%0000_1111进行逻辑`and`运算。这个逐位逻辑`and`操作会将高4位强制为0，而将*X*的低4位保持不变。同样，你可以通过将*X*与%0000_0001进行逻辑`or`运算，将*X*的低位强制为1，并通过将*X*与%0000_0100进行逻辑异或（exclusive-`or`）运算来反转*X*的第2位。以这种方式使用逻辑`and`、`or`和`xor`操作来处理比特串被称为*掩码*比特串。我们使用*掩码*这个术语，因为我们可以使用特定的值（`and`用1，`or`/`xor`用0）来掩盖或掩入某些比特，从而在将比特强制为0、1或其反值时控制操作。
- en: 'The 80x86 CPUs support four instructions that apply these bitwise logical operations
    to their operands. The instructions are `and`, `or`, `xor`, and `not`. The `and`,
    `or`, and `xor` instructions use the same syntax as the `add` and `sub` instructions:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU支持四条指令，将这些按位逻辑操作应用于操作数。这些指令是`and`、`or`、`xor`和`not`。`and`、`or`和`xor`指令与`add`和`sub`指令使用相同的语法：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These operands have the same limitations as the `add` operands. Specifically,
    the *`source`* operand has to be a constant, memory, or register operand, and
    the *`dest`* operand must be a memory or register operand. Also, the operands
    must be the same size and they cannot both be memory operands. These instructions
    compute the obvious bitwise logical operation via the following equation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作数与`add`操作数具有相同的限制。具体来说，*`source`*操作数必须是常数、内存或寄存器操作数，*`dest`*操作数必须是内存或寄存器操作数。此外，操作数必须具有相同的大小，并且不能同时是内存操作数。这些指令通过以下等式计算明显的按位逻辑操作：
- en: '[PRE18]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The 80x86 logical `not` instruction, because it has only a single operand,
    uses a slightly different syntax. This instruction takes the following form:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86逻辑`not`指令，由于只有一个操作数，因此使用稍微不同的语法。该指令的形式如下：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This instruction computes the following result:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算出以下结果：
- en: '[PRE20]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The *`dest`* operand must be a register or memory operand. This instruction
    inverts all the bits in the specified destination operand.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*`dest`*操作数必须是寄存器或内存操作数。此指令会反转指定目标操作数中的所有位。'
- en: 'The program in [Example 2-5](ch02s07.html#and_comma_or_comma_xor_comma_and_not_exa
    "Example 2-5. and, or, xor, and not example") inputs two hexadecimal values from
    the user and calculates their logical `and`, `or`, `xor`, and `not`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在[示例 2-5](ch02s07.html#and_comma_or_comma_xor_comma_and_not_exa "示例 2-5. and,
    or, xor, and not 示例")中从用户输入两个十六进制值，并计算它们的逻辑`and`、`or`、`xor`和`not`：
- en: Example 2-5. `and`, `or`, `xor`, and `not` example
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-5. `and`、`or`、`xor`和`not`示例
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 2.8 Signed and Unsigned Numbers
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8 带符号数和无符号数
- en: Thus far, we've treated binary numbers as unsigned values. The binary number
    ...00000 represents 0, ...00001 represents 1, ...00010 represents 2, and so on
    toward infinity. What about negative numbers? Signed values have been tossed around
    in previous sections, and we've mentioned the two's complement numbering system,
    but we haven't discussed how to represent negative numbers using the binary numbering
    system. Now it is time to describe the two's complement numbering system.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将二进制数视为无符号值。二进制数...00000表示0，...00001表示1，...00010表示2，依此类推，直到无穷大。那么负数呢？带符号值在前面的章节中已经提到过，我们提到了二进制补码系统，但我们还没有讨论如何使用二进制系统表示负数。现在是时候描述二进制补码系统了。
- en: 'To represent signed numbers using the binary numbering system, we have to place
    a restriction on our numbers: They must have a finite and fixed number of bits.
    For our purposes, we''re going to severely limit the number of bits to 8, 16,
    32, 64, 128, or some other small number of bits.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用二进制编号系统表示带符号数字，我们必须对数字施加限制：它们必须具有有限且固定的位数。为了简便起见，我们将大幅限制位数，限制为8、16、32、64、128或其他一些较小的位数。
- en: With a fixed number of bits we can represent only a certain number of objects.
    For example, with 8 bits we can represent only 256 different values. Negative
    values are objects in their own right, just like positive numbers and 0; therefore,
    we'll have to use some of the 256 different 8-bit values to represent negative
    numbers. In other words, we have to use up some of the bit combinations to represent
    negative numbers. To make things fair, we'll assign half of the possible combinations
    to the negative values and half to the positive values and 0\. So we can represent
    the negative values −128..−1 and the nonnegative values 0..127 with a single 8-bit
    byte. With a 16-bit word we can represent values in the range −32,768..+32,767\.
    With a 32-bit double word we can represent values in the range −2,147,483,648..+2,147,483,647\.
    In general, with *n* bits we can represent the signed values in the range −2^(*n*−1)
    to +2^(*n*−1)−1.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用固定的位数，我们只能表示有限数量的对象。例如，使用8位，我们只能表示256个不同的值。负值是独立的对象，就像正数和0一样；因此，我们必须使用256个不同的8位值中的一部分来表示负数。换句话说，我们必须使用一些位组合来表示负数。为了公平起见，我们将把一半的可能组合分配给负值，另一半分配给正值和0。因此，我们可以用一个8位字节表示负值−128..−1和非负值0..127。使用16位字，我们可以表示值范围−32,768..+32,767。使用32位双字，我们可以表示值范围−2,147,483,648..+2,147,483,647。一般来说，使用*n*位时，我们可以表示带符号值范围为−2^(*n*−1)到+2^(*n*−1)−1。
- en: Okay, so we can represent negative values. Exactly how do we do it? Well, there
    are many possible ways, but the 80x86 microprocessor uses the two's complement
    notation, so it makes sense to study that method. In the two's complement system,
    the H.O. bit of a number is a *sign bit*. If the H.O. bit is 0, the number is
    positive; if the H.O. bit is 1, the number is negative. Following are some examples.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们可以表示负数。我们究竟该怎么做呢？实际上有许多方法，但80x86微处理器使用的是二补码表示法，因此研究这种方法是有意义的。在二补码系统中，一个数的最高有效位（H.O.
    bit）是一个*符号位*。如果最高有效位是0，则该数为正数；如果最高有效位是1，则该数为负数。以下是一些例子。
- en: 'For 16-bit numbers:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于16位数：
- en: '[PRE22]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the H.O. bit is 0, then the number is positive and uses the standard binary
    format. If the H.O. bit is 1, then the number is negative and uses the two''s
    complement form. To convert a positive number to its negative, two''s complement
    form, you use the following algorithm:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最高有效位是0，则该数为正数，并使用标准二进制格式。如果最高有效位是1，则该数为负数，并使用二补码形式。将正数转换为负数的二补码形式，你可以使用以下算法：
- en: Invert all the bits in the number; that is, apply the logical `not` function.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转数值中的所有位；也就是说，应用逻辑`not`运算。
- en: Add 1 to the inverted result and ignore any overflow out of the H.O. bit.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将1加到反转后的结果，并忽略任何从最高有效位溢出的部分。
- en: 'For example, to compute the 8-bit equivalent of −5:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，计算−5的8位等价数：
- en: '[PRE23]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we take −5 and perform the two''s complement operation on it, we get our
    original value, %0000_0101, back again, just as we expect:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们对−5进行二补码操作，我们会得到原始值 %0000_0101，正如我们所期望的那样：
- en: '[PRE24]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following examples provide some positive and negative 16-bit signed values:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下例子提供了一些正负16位有符号数值：
- en: '[PRE25]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To convert the numbers above to their negative counterpart (that is, to negate
    them), do the following:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将上面的数字转换为其负数（即取反），请执行以下操作：
- en: '[PRE26]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: $8000 inverted becomes $7FFF. After adding 1 we obtain $8000! Wait, what's going
    on here? −(−32,768) is −32,768? Of course not. But the value +32,768 cannot be
    represented with a 16-bit signed number, so we cannot negate the smallest negative
    value.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: $8000 反转后变为 $7FFF。加1后，我们得到 $8000！等等，发生了什么？−(−32,768)是−32,768吗？当然不是。但+32,768的值无法用16位有符号数表示，所以我们无法取反最小的负值。
- en: 'Why bother with such a miserable numbering system? Why not use the H.O. bit
    as a sign flag, storing the positive equivalent of the number in the remaining
    bits? (This, by the way, is known as the *one''s complement numbering system*.)
    The answer lies in the hardware. As it turns out, negating values is the only
    tedious job. With the two''s complement system, most other operations are as easy
    as the binary system. For example, suppose you were to perform the addition 5
    + (−5). The result is 0\. Consider what happens when we add these two values in
    the two''s complement system:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用如此复杂的编号系统？为什么不将最高有效位作为符号标志，将数值的正数等价物存储在剩余的位中呢？（顺便说一下，这被称为*一补码编号系统*。）答案在于硬件。事实证明，取反值是唯一繁琐的操作。使用二补码系统时，大多数其他操作和二进制系统一样简单。例如，假设你要执行加法
    5 + (−5)。结果是0。考虑一下当我们在二补码系统中将这两个数相加时发生了什么：
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We end up with a carry into the ninth bit, and all other bits are 0\. As it
    turns out, if we ignore the carry out of the H.O. bit, adding two signed values
    always produces the correct result when using the two's complement numbering system.
    This means we can use the same hardware for signed and unsigned addition and subtraction.
    This wouldn't be the case with other numbering systems.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终会在第九位产生进位，其他所有位都为0。事实上，如果我们忽略从最高有效位产生的进位，使用二补码编号系统时，两个符号数的加法总是能得到正确的结果。这意味着我们可以使用相同的硬件进行有符号和无符号的加法与减法，而其他编号系统则不能做到这一点。
- en: Usually, you will not need to perform the two's complement operation by hand.
    The 80x86 microprocessor provides an instruction, `neg` (negate), that performs
    this operation for you. Furthermore, hexadecimal calculators perform this operation
    by pressing the change sign key (+/− or CHS). Nevertheless, manually computing
    the two's complement is easy, and you should know how to do it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不需要手动执行二补码操作。80x86微处理器提供了一条指令，`neg`（取反），可以为你执行这个操作。此外，十六进制计算器通过按下切换符号键（+/−
    或 CHS）来执行这个操作。不过，手动计算二补码很简单，你应该知道怎么做。
- en: Remember that the data represented by a set of binary bits depends entirely
    on the context. The 8-bit binary value %1100_0000 could represent a character,
    it could represent the unsigned decimal value 192, or it could represent the signed
    decimal value −64\. As the programmer, it is your responsibility to define the
    data's format and then use the data consistently.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由一组二进制位表示的数据完全取决于上下文。8位二进制值%1100_0000可以表示一个字符，也可以表示无符号十进制值192，或者表示有符号十进制值−64。作为程序员，你有责任定义数据的格式，然后一致地使用这些数据。
- en: 'The 80x86 negate instruction, `neg`, uses the same syntax as the `not` instruction;
    that is, it takes a single destination operand:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86的取反指令`neg`与`not`指令使用相同的语法；即，它接受一个目标操作数：
- en: '[PRE28]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This instruction computes *`dest`* `= -`*`dest`*`;` and the operand has the
    same limitations as for `not` (it must be a memory location or a register). `neg`
    operates on byte-, word-, and dword-sized objects. Because this is a signed integer
    operation, it only makes sense to operate on signed integer values. The program
    in [Example 2-6](ch02s08.html#twoscomplement_example "Example 2-6. twosComplement
    example") demonstrates the two''s complement operation by using the `neg` instruction:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算 *`dest`* `= -`*`dest`*`;` 操作数与`not`指令相同的限制（它必须是一个内存位置或寄存器）。`neg`指令作用于字节、字（word）和双字（dword）大小的对象。由于这是一个有符号整数操作，所以只对有符号整数值进行操作才有意义。[示例2-6](ch02s08.html#twoscomplement_example
    "示例2-6. twosComplement 示例")中的程序通过使用`neg`指令演示了二进制补码操作：
- en: Example 2-6. `twosComplement` example
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-6. `twosComplement` 示例
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you've seen previously, you use the `int8`, `int16`, `int32`, `int64`, and
    `int128` data types to reserve storage for signed integer variables. You've also
    seen routines like `stdout.puti8` and `stdin.geti32` that read and write signed
    integer values. Because this section has made it abundantly clear that you must
    differentiate signed and unsigned calculations in your programs, you should probably
    be asking yourself, "How do I declare and use unsigned integer variables?"
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用`int8`、`int16`、`int32`、`int64`和`int128`数据类型来为有符号整数变量预留存储空间。你也看到过像`stdout.puti8`和`stdin.geti32`这样的例程，它们用于读取和写入有符号整数值。由于本节已经明确指出，你必须在程序中区分有符号和无符号计算，你可能会问自己：“如何声明和使用无符号整数变量？”
- en: 'The first part of the question, "How do I declare unsigned integer variables,"
    is the easiest to answer. You simply use the `uns8`, `uns16`, `uns32`, `uns64`,
    and `uns128` data types when declaring the variables. For example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的第一部分，“如何声明无符号整数变量”，最容易回答。你只需在声明变量时使用`uns8`、`uns16`、`uns32`、`uns64`和`uns128`数据类型。例如：
- en: '[PRE30]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As for using these unsigned variables, the HLA Standard Library provides a complementary
    set of input/output routines for reading and displaying unsigned variables. As
    you can probably guess, these routines include `stdout.putu8`, `stdout.putu16`,
    `stdout.putu32`, `stdout.putu64`, `stdout.putu128`, `stdout.putu8Size`, `stdout.putu16Size`,
    `stdout.putu32Size`, `stdout.putu64Size`, `stdout.putu128Size`, `stdin.getu8`,
    `stdin.getu16`, `stdin.getu32`, `stdin.getu64`, and `stdin.getu128`. You use these
    routines just as you would use their signed integer counterparts except you get
    to use the full range of the unsigned values with these routines. The source code
    in [Example 2-7](ch02s08.html#unsigned_i_solidus_o "Example 2-7. Unsigned I/O")
    demonstrates unsigned I/O as well as demonstrates what can happen if you mix signed
    and unsigned operations in the same calculation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 至于如何使用这些无符号变量，HLA标准库提供了一组补充的输入/输出例程，用于读取和显示无符号变量。你可以猜到，这些例程包括`stdout.putu8`、`stdout.putu16`、`stdout.putu32`、`stdout.putu64`、`stdout.putu128`、`stdout.putu8Size`、`stdout.putu16Size`、`stdout.putu32Size`、`stdout.putu64Size`、`stdout.putu128Size`、`stdin.getu8`、`stdin.getu16`、`stdin.getu32`、`stdin.getu64`和`stdin.getu128`。你可以像使用有符号整数对应例程一样使用这些例程，只不过你可以使用这些例程访问无符号值的全部范围。[示例2-7](ch02s08.html#unsigned_i_solidus_o
    "示例2-7. 无符号I/O")的源代码演示了无符号I/O，并展示了如果你在同一计算中混合有符号和无符号操作会发生什么。
- en: Example 2-7. Unsigned I/O
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-7. 无符号I/O
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 2.9 Sign Extension, Zero Extension, Contraction, and Saturation
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9 符号扩展、零扩展、收缩和饱和
- en: Because two's complement format integers have a fixed length, a small problem
    develops. What happens if you need to convert an 8-bit two's complement value
    to 16 bits? This problem and its converse (converting a 16-bit value to 8 bits)
    can be accomplished via *sign extension* and *contraction* operations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因为补码格式的整数具有固定的长度，所以会出现一个小问题。如果需要将一个8位补码值转换为16位会发生什么？这个问题及其反问题（将16位值转换为8位）可以通过*符号扩展*和*收缩*操作来完成。
- en: Consider the value −64\. The 8-bit two's complement value for this number is
    $C0\. The 16-bit equivalent of this number is $FFC0\. Now consider the value +64\.
    The 8- and 16-bit versions of this value are $40 and $0040, respectively. The
    difference between the 8- and 16-bit numbers can be described by the rule, "If
    the number is negative, the H.O. byte of the 16-bit number contains $FF; if the
    number is positive, the H.O. byte of the 16-bit quantity is 0."
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑值 −64。这个数的8位补码值是$C0。该数的16位等效值是$FFC0。现在考虑值 +64。该值的8位和16位版本分别为$40和$0040。8位和16位数值之间的区别可以通过以下规则描述：“如果数值是负数，16位数值的高字节包含$FF；如果数值是正数，16位数值的高字节是0。”
- en: To extend a signed value from some number of bits to a greater number of bits
    is easy; just copy the sign bit into all the additional bits in the new format.
    For example, to sign extend an 8-bit number to a 16-bit number, simply copy bit
    7 of the 8-bit number into bits 8..15 of the 16-bit number. To sign extend a 16-bit
    number to a double word, simply copy bit 15 into bits 16..31 of the double word.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个有符号值从某些位数扩展到更大的位数很容易；只需将符号位复制到新格式中的所有附加位。例如，要将8位数符号扩展为16位数，只需将8位数的第7位复制到16位数的第8到15位。要将16位数符号扩展为双字，只需将16位数的第15位复制到双字的第16到31位。
- en: 'You must use sign extension when manipulating signed values of varying lengths.
    Often you''ll need to add a byte quantity to a word quantity. You must sign extend
    the byte quantity to a word before the operation takes place. Other operations
    (multiplication and division, in particular) may require a sign extension to 32
    bits:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作不同长度的有符号值时，你必须使用符号扩展。通常你需要将一个字节量与一个字量相加。在进行操作之前，必须先将字节量符号扩展为字。其他操作（特别是乘法和除法）可能需要扩展到32位：
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To extend an unsigned value to a larger one, you must zero extend the value.
    Zero extension is very easy—just store a 0 into the H.O. byte(s) of the larger
    operand. For example, to zero extend the 8-bit value $82 to 16 bits, you simply
    add a 0 to the H.O. byte, yielding $0082.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个无符号值扩展为更大的值，你必须进行零扩展。零扩展非常简单——只需将0存储到更大操作数的高字节中。例如，要将8位值$82零扩展到16位，你只需在高字节加上0，得到$0082。
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The 80x86 provides several instructions that will let you sign or zero extend
    a smaller number to a larger number. [Table 2-6](ch02s09.html#instructions_for_extending_al_comma_ax_c
    "Table 2-6. Instructions for Extending AL, AX, and EAX") lists a group of instructions
    that will sign extend the AL, AX, or EAX register.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86提供了几条指令，允许你将一个较小的数字符号扩展或零扩展到较大的数字。[表2-6](ch02s09.html#instructions_for_extending_al_comma_ax_c
    "表2-6. 扩展AL, AX, 和EAX的指令")列出了能够符号扩展AL、AX或EAX寄存器的一组指令。
- en: Table 2-6. Instructions for Extending AL, AX, and EAX
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-6. 扩展AL, AX, 和EAX的指令
- en: '| Instruction | Explanation |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 说明 |'
- en: '| --- | --- |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cbw();` | Converts the byte in AL to a word in AX via sign extension. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `cbw();` | 通过符号扩展将AL中的字节转换为AX中的字。 |'
- en: '| `cwd();` | Converts the word in AX to a double word in DX:AX via sign extension.
    |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `cwd();` | 通过符号扩展将AX中的字转换为DX:AX中的双字。 |'
- en: '| `cdq();` | Converts the double word in EAX to the quad word in EDX:EAX via
    sign extension. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `cdq();` | 通过符号扩展将EAX中的双字转换为EDX:EAX中的四字。 |'
- en: '| `cwde();` | Converts the word in AX to a double word in EAX via sign extension.
    |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `cwde();` | 通过符号扩展将AX中的字转换为EAX中的双字。 |'
- en: Note that the `cwd` (convert word to double word) instruction does not sign
    extend the word in AX to the double word in EAX. Instead, it stores the H.O. word
    of the sign extension into the DX register (the notation DX:AX tells you that
    you have a double-word value with DX containing the upper 16 bits and AX containing
    the lower 16 bits of the value). If you want the sign extension of AX to go into
    EAX, you should use the `cwde` (convert word to double word, extended) instruction.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`cwd`（将字转换为双字）指令并不会将AX中的字进行符号扩展到EAX中的双字。相反，它将符号扩展的高字节部分存储到DX寄存器中（符号DX:AX表示你有一个双字值，其中DX包含高16位，AX包含低16位）。如果你希望将AX的符号扩展放入EAX中，应该使用`cwde`（将字转换为双字，扩展）指令。
- en: The four instructions above are unusual in the sense that these are the first
    instructions you've seen that do not have any operands. These instructions' operands
    are *implied* by the instructions themselves.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 上述四条指令是不同寻常的，因为这是你见过的第一组没有任何操作数的指令。这些指令的操作数是由指令本身*隐含*的。
- en: Within a few chapters you will discover just how important these instructions
    are and why the `cwd` and `cdq` instructions involve the DX and EDX registers.
    However, for simple sign extension operations, these instructions have a few major
    drawbacks—you do not get to specify the source and destination operands, and the
    operands must be registers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，你将发现这些指令的重要性以及为什么`cwd`和`cdq`指令涉及DX和EDX寄存器。然而，对于简单的符号扩展操作，这些指令有一些主要缺点——你无法指定源操作数和目标操作数，并且操作数必须是寄存器。
- en: 'For general sign extension operations, the 80x86 provides an extension of the
    `mov` instruction, `movsx` (move with sign extension), that copies data and sign
    extends the data while copying it. The `movsx` instruction''s syntax is very similar
    to the `mov` instruction:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般的符号扩展操作，80x86提供了`mov`指令的扩展——`movsx`（带符号扩展的移动指令），它在复制数据的同时进行符号扩展。`movsx`指令的语法与`mov`指令非常相似：
- en: '[PRE34]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The big difference in syntax between this instruction and the `mov` instruction
    is the fact that the destination operand must be larger than the source operand.
    That is, if the source operand is a byte, the destination operand must be a word
    or a double word. Likewise, if the source operand is a word, the destination operand
    must be a double word. Another difference is that the destination operand has
    to be a register; the source operand, however, can be a memory location.^([[23](#ftn.CHP-2-FN-3)])
    The `movsx` instruction does not allow constant operands.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令与`mov`指令的最大语法区别在于目标操作数必须比源操作数大。也就是说，如果源操作数是字节，目标操作数必须是字或双字。类似地，如果源操作数是字，目标操作数必须是双字。另一个区别是目标操作数必须是寄存器；而源操作数则可以是内存位置。^([[23](#ftn.CHP-2-FN-3)])
    `movsx`指令不允许常量操作数。
- en: To zero extend a value, you can use the `movzx` instruction. It has the same
    syntax and restrictions as the `movsx` instruction. Zero extending certain 8-bit
    registers (AL, BL, CL, and DL) into their corresponding 16-bit registers is easily
    accomplished without using `movzx` by loading the complementary H.O. register
    (AH, BH, CH, or DH) with 0\. Obviously, to zero extend AX into DX:AX or EAX into
    EDX:EAX, all you need to do is load DX or EDX with 0.^([[24](#ftn.CHP-2-FN-4)])
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个值进行零扩展，可以使用`movzx`指令。它的语法和限制与`movsx`指令相同。零扩展某些8位寄存器（AL、BL、CL和DL）到它们对应的16位寄存器，可以通过将互补的高字节寄存器（AH、BH、CH或DH）加载为0来轻松实现，而无需使用`movzx`指令。显然，要将AX零扩展到DX:AX或EAX零扩展到EDX:EAX，你需要做的就是将DX或EDX加载为0。^([[24](#ftn.CHP-2-FN-4)])
- en: The sample program in [Example 2-8](ch02s09.html#sign_extension_instructions
    "Example 2-8. Sign extension instructions") demonstrates the use of the sign extension
    instructions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例2-8](ch02s09.html#sign_extension_instructions "示例2-8. 符号扩展指令")中的示例程序演示了符号扩展指令的使用。'
- en: Example 2-8. Sign extension instructions
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-8. 符号扩展指令
- en: '[PRE35]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Sign *contraction*, converting a value with some number of bits to the identical
    value with a fewer number of bits, is a little more troublesome. Sign extension
    never fails. Given an *m*-bit signed value, you can always convert it to an *n*-bit
    number (where *n* > *m*) using sign extension. Unfortunately, given an *n*-bit
    number, you cannot always convert it to an *m*-bit number if *m* < *n*. For example,
    consider the value −448\. As a 16-bit signed number, its hexadecimal representation
    is $FE40\. Unfortunately, the magnitude of this number is too large for an 8-bit
    value, so you cannot sign contract it to 8 bits. This is an example of an overflow
    condition that occurs upon conversion.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 符号*收缩*，将具有一定数量位的值转换为具有较少位的相同值，是稍微麻烦一点的操作。符号扩展从不失败。给定一个 *m* 位的有符号值，你总是可以将其通过符号扩展转换为
    *n* 位数（其中 *n* > *m*）。不幸的是，给定一个 *n* 位数，如果 *m* < *n*，你并不总能将其转换为 *m* 位数。例如，考虑值 −448。作为一个
    16 位有符号数，它的十六进制表示为 $FE40。不幸的是，这个数字的大小对于一个 8 位值来说太大了，因此你无法将其符号收缩为 8 位。这是一个在转换过程中发生溢出的例子。
- en: 'To properly sign contract a value, you must look at the H.O. byte(s) that you
    want to discard. The H.O. bytes must all contain either 0 or $FF. If you encounter
    any other values, you cannot contract it without overflow. Finally, the H.O. bit
    of your resulting value must match *every* bit you''ve removed from the number.
    Here are some examples (16 bits to 8 bits):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地对合同值进行签名，你必须查看要丢弃的 H.O. 字节。H.O. 字节必须全都包含 0 或 $FF。如果你遇到其他值，则无法在不发生溢出的情况下进行收缩。最后，结果值的
    H.O. 位必须与从数字中移除的*每一个*位匹配。以下是一些示例（16 位到 8 位）：
- en: '[PRE36]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Another way to reduce the size of an integer is by *saturation*. Saturation
    is useful in situations where you must convert a larger object to a smaller object,
    and you're willing to live with possible loss of precision. To convert a value
    via saturation you simply copy the larger value to the smaller value if it is
    not outside the range of the smaller object. If the larger value is outside the
    range of the smaller value, then you *clip* the value by setting it to the largest
    (or smallest) value within the range of the smaller object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种减少整数大小的方法是*饱和*。饱和在需要将较大的对象转换为较小的对象，并且你愿意接受可能的精度损失时非常有用。通过饱和转换值时，如果较大的值不超出较小对象的范围，你只需将较大的值复制到较小的对象中。如果较大的值超出了较小值的范围，那么你*裁剪*该值，将其设置为较小对象范围内的最大（或最小）值。
- en: For example, when converting a 16-bit signed integer to an 8-bit signed integer,
    if the 16-bit value is in the range −128..+127, you simply copy the L.O. byte
    of the 16-bit object to the 8-bit object. If the 16-bit signed value is greater
    than +127, then you clip the value to +127 and store +127 into the 8-bit object.
    Likewise, if the value is less than −128, you clip the final 8-bit object to −128\.
    Saturation works the same way when clipping 32-bit values to smaller values. If
    the larger value is outside the range of the smaller value, then you simply set
    the smaller value to the value closest to the out-of-range value that you can
    represent with the smaller value.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当将一个 16 位有符号整数转换为 8 位有符号整数时，如果 16 位值在 −128..+127 的范围内，你只需将 16 位对象的 L.O. 字节复制到
    8 位对象中。如果 16 位有符号值大于 +127，那么你将值裁剪为 +127，并将 +127 存储到 8 位对象中。同样，如果该值小于 −128，你将最终的
    8 位对象裁剪为 −128。饱和操作在将 32 位值裁剪为较小值时同样有效。如果较大的值超出了较小值的范围，那么你只需将较小值设置为可以用较小值表示的最接近溢出值。
- en: Obviously, if the larger value is outside the range of the smaller value, then
    there will be a loss of precision during the conversion. While clipping the value
    to the limits the smaller object imposes is never desirable, sometimes this is
    acceptable because the alternative is to raise an exception or otherwise reject
    the calculation. For many applications, such as audio or video processing, the
    clipped result is still recognizable, so this is a reasonable conversion.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果较大的值超出了较小值的范围，那么在转换过程中就会出现精度损失。虽然将值裁剪到较小对象所限制的范围并不是理想的做法，但有时这是可以接受的，因为另一种选择是引发异常或拒绝计算。对于许多应用场景，如音频或视频处理，裁剪后的结果仍然是可识别的，因此这是一个合理的转换方式。
- en: '* * *'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[23](#CHP-2-FN-3)]) This doesn't turn out to be much of a limitation because
    sign extension almost always precedes an arithmetic operation that must take place
    in a register.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[23](#CHP-2-FN-3)]) 这并不会成为太大的限制，因为符号扩展几乎总是发生在必须在寄存器中执行的算术操作之前。
- en: ^([[24](#CHP-2-FN-4)]) Zero extending into DX:AX or EDX:EAX is just as necessary
    as the CWD and CDQ instructions, as you will eventually see.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[24](#CHP-2-FN-4)]) 零扩展到 DX:AX 或 EDX:EAX 和 CWD、CDQ 指令同样重要，正如你最终会看到的那样。
- en: 2.10 Shifts and Rotates
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.10 移位与旋转
- en: Another set of logical operations that apply to bit strings is the *shift* and
    *rotate* operations. These two categories can be further broken down into *left
    shifts, left rotates, right shifts*, and *right rotates*. These operations turn
    out to be extremely useful.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应用于比特串的逻辑操作是*移位*和*旋转*操作。这两类操作可以进一步细分为*左移、左旋、右移*和*右旋*。这些操作非常有用。
- en: The left-shift operation moves each bit in a bit string one position to the
    left ([Figure 2-8](ch02s10.html#shift-left_operation "Figure 2-8. Shift-left operation")
    provides an example of an 8-bit shift).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 左移操作将比特串中的每个位向左移动一位位置（[图2-8](ch02s10.html#shift-left_operation "图2-8. 左移操作")提供了一个8位移位的示例）。
- en: '![Shift-left operation](tagoreillycom20100401nostarchimages577899.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![左移操作](tagoreillycom20100401nostarchimages577899.png)'
- en: Figure 2-8. Shift-left operation
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-8. 左移操作
- en: 'Bit 0 moves into bit position 1, the previous value in bit position 1 moves
    into bit position 2, and so on. There are, of course, two questions that naturally
    arise: "What goes into bit 0?" and "Where does the high-order bit go?" We''ll
    shift a 0 into bit 0, and the previous value of the high-order bit will become
    the *carry* out of this operation.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 位0移动到位位置1，位位置1中的先前值移动到位位置2，以此类推。当然，随之而来的两个问题是：“位0中放入什么？”以及“最高位去哪里了？”我们将一个0移入位0，先前的最高位值将成为此次操作的*进位*。
- en: 'The 80x86 provides a shift-left instruction, `shl`, that performs this useful
    operation. The syntax for the `shl` instruction is:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86提供了一个左移指令`shl`，可以执行此有用操作。`shl`指令的语法为：
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The *`count`* operand is either CL or a constant in the range 0..*n*, where
    *n* is one less than the number of bits in the destination operand (for example,
    *n* = 7 for 8-bit operands, *n* = 15 for 16-bit operands, and *n* = 31 for 32-bit
    operands). The *`dest`* operand is a typical destination operand. It can be either
    a memory location or a register.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*`count`* 操作数可以是 CL 或一个常数，范围是 0..*n*，其中 *n* 是目标操作数中比特位数减去1（例如，8位操作数时 *n* =
    7，16位操作数时 *n* = 15，32位操作数时 *n* = 31）。*`dest`* 操作数是一个典型的目标操作数，可以是内存位置或寄存器。'
- en: When the *`count`* operand is the constant 1, the `shl` instruction does the
    operation shown in [Figure 2-9](ch02s10.html#shift-left_operation-id1 "Figure 2-9. Shift-left
    operation").
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当*`count`* 操作数为常数 1 时，`shl` 指令执行如[图2-9](ch02s10.html#shift-left_operation-id1
    "图2-9. 左移操作")所示的操作。
- en: '![Shift-left operation](tagoreillycom20100401nostarchimages577901.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![左移操作](tagoreillycom20100401nostarchimages577901.png)'
- en: Figure 2-9. Shift-left operation
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-9. 左移操作
- en: In [Figure 2-9](ch02s10.html#shift-left_operation-id1 "Figure 2-9. Shift-left
    operation"), the *C* represents the carry flag. That is, the H.O. bit shifted
    out of the operand moves into the carry flag. Therefore, you can test for overflow
    after a `shl( 1`, *`dest`* `);` instruction by testing the carry flag immediately
    after executing the instruction (e.g., by using `if( @c ) then...` or `if( @nc
    ) then...`).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-9](ch02s10.html#shift-left_operation-id1 "图2-9. 左移操作")中，*C* 代表进位标志。也就是说，从操作数中移出的最高位会进入进位标志。因此，你可以在执行
    `shl(1, *`dest`*);` 指令后，通过立即测试进位标志来检测溢出（例如，使用 `if( @c ) then...` 或 `if( @nc )
    then...`）。
- en: Intel's literature suggests that the state of the carry flag is undefined if
    the shift count is a value other than 1\. Usually, the carry flag contains the
    last bit shifted out of the destination operand, but Intel doesn't seem to guarantee
    this.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的文献指出，如果移位计数是1以外的值，则进位标志的状态未定义。通常，进位标志包含从目标操作数中移出的最后一位，但英特尔似乎没有保证这一点。
- en: 'Note that shifting a value to the left is the same thing as multiplying it
    by its radix. For example, shifting a decimal number one position to the left
    (adding a 0 to the right of the number) effectively multiplies it by 10 (the radix):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，左移值等同于将其乘以基数。例如，将一个十进制数左移一位（在数字右侧加上一个0）实际上是将其乘以10（基数）：
- en: '[PRE38]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: (`shl 1` means shift one digit position to the left.)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: (`shl 1` 表示将一个数字位置向左移。)
- en: Because the radix of a binary number is 2, shifting it left multiplies it by
    2\. If you shift a binary value to the left twice, you multiply it by 2 twice
    (that is, you multiply it by 4). If you shift a binary value to the left three
    times, you multiply it by 8 (2*2*2). In general, if you shift a value to the left
    *n* times, you multiply that value by 2^(*n*).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二进制数字的基数是2，左移操作相当于乘以2。如果你将二进制值左移两次，你相当于将其乘以2两次（即乘以4）。如果你将二进制值左移三次，你相当于将其乘以8（2*2*2）。一般来说，如果你将一个值左移*n*次，你就将该值乘以2^(*n*)。
- en: A right-shift operation works the same way, except we're moving the data in
    the opposite direction. For a byte value, bit 7 moves into bit 6, bit 6 moves
    into bit 5, bit 5 moves into bit 4, and so on. During a right shift, we'll move
    a 0 into bit 7, and bit 0 will be the carry out of the operation (see [Figure 2-10](ch02s10.html#shift-right_operation
    "Figure 2-10. Shift-right operation")).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 右移操作的工作方式相同，只是我们将数据移向相反的方向。对于字节值，第7位移入第6位，第6位移入第5位，第5位移入第4位，依此类推。在右移过程中，我们将一个0移入第7位，第0位将作为操作的进位输出（见[图2-10](ch02s10.html#shift-right_operation
    "图2-10. 右移操作")）。
- en: '![Shift-right operation](tagoreillycom20100401nostarchimages577903.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![右移操作](tagoreillycom20100401nostarchimages577903.png)'
- en: Figure 2-10. Shift-right operation
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-10. 右移操作
- en: 'As you would probably expect, the 80x86 provides a `shr` instruction that will
    shift the bits to the right in a destination operand. The syntax is the same as
    the `shl` instruction except, of course, you specify `shr` rather than `shl`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预料的那样，80x86提供了一个`shr`指令，可以将目标操作数的位向右移。其语法与`shl`指令相同，当然，区别在于你指定的是`shr`而不是`shl`：
- en: '[PRE39]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This instruction shifts a 0 into the H.O. bit of the destination operand, it
    shifts the other bits one place to the right (that is, from a higher bit number
    to a lower bit number). Finally, bit 0 is shifted into the carry flag. If you
    specify a count of 1, the `shr` instruction does the operation shown in [Figure 2-11](ch02s10.html#shift-right_operation-id1
    "Figure 2-11. Shift-right operation").
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将一个0移入目标操作数的最高有效位（H.O.），并将其他位向右移一个位置（即，从高位数字移到低位数字）。最后，位0被移入进位标志。如果你指定移位次数为1，`shr`指令会执行[图2-11](ch02s10.html#shift-right_operation-id1
    "图2-11. 右移操作")中所示的操作。
- en: '![Shift-right operation](tagoreillycom20100401nostarchimages577905.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![右移操作](tagoreillycom20100401nostarchimages577905.png)'
- en: Figure 2-11. Shift-right operation
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-11. 右移操作
- en: Once again, Intel's documents suggest that shifts of more than 1 bit leave the
    carry in an undefined state.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，Intel的文档建议，移位超过1位时，进位会处于未定义状态。
- en: Because a left shift is equivalent to a multiplication by 2, it should come
    as no surprise that a right shift is roughly comparable to a division by 2 (or,
    in general, a division by the radix of the number). If you perform *n* right shifts,
    you will divide that number by 2^(*n*).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于左移相当于乘以2，因此右移大致可以看作是除以2（或者一般而言，除以该数字的基数）。如果你执行*n*次右移，那么你将该数字除以2^(*n*)。
- en: 'There is one problem with shift rights with respect to division: A shift right
    is only equivalent to an *unsigned* division by 2\. For example, if you shift
    the unsigned representation of 254 ($FE) one place to the right, you get 127 ($7F),
    exactly what you would expect. However, if you shift the binary representation
    of −2 ($FE) to the right one position, you get 127 ($7F), which is *not* correct.
    This problem occurs because we''re shifting a 0 into bit 7\. If bit 7 previously
    contained a 1, we''re changing it from a negative to a positive number. Not a
    good thing to do when dividing by 2.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 关于除法，右移操作有一个问题：右移仅相当于*无符号*除以2。例如，如果你将无符号表示的254（$FE）右移一位，你得到127（$7F），这正是你期望的结果。然而，如果你将-2的二进制表示（$FE）右移一位，你得到127（$7F），这是*不*正确的。这个问题发生是因为我们将一个0移入了第7位。如果第7位之前是1，那么我们将其从负数变成了正数。在除以2时这样做并不好。
- en: 'To use the shift right as a division operator, we must define a third shift
    operation: arithmetic shift right.^([[25](#ftn.CHP-2-FN-5)]) An arithmetic shift
    right works just like the normal shift-right operation (a logical shift right)
    with one exception: Instead of shifting a 0 into the high-order bit, an arithmetic
    shift-right operation copies the high-order bit back into itself; that is, during
    the shift operation it does not modify the high-order bit, as [Figure 2-12](ch02s10.html#arithmetic_shift-right_operation
    "Figure 2-12. Arithmetic shift-right operation") shows.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将右移用作除法运算符，我们必须定义第三种移位操作：算术右移。^([[25](#ftn.CHP-2-FN-5)]) 算术右移的工作原理与普通右移操作（逻辑右移）相同，唯一的例外是：算术右移操作不会将
    0 移入高位，而是将高位的值保留在其自身中；也就是说，在移位操作过程中，它不会修改高位，如[图 2-12](ch02s10.html#arithmetic_shift-right_operation
    "图 2-12. 算术右移操作")所示。
- en: '![Arithmetic shift-right operation](tagoreillycom20100401nostarchimages577907.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![算术右移操作](tagoreillycom20100401nostarchimages577907.png)'
- en: Figure 2-12. Arithmetic shift-right operation
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-12. 算术右移操作
- en: An arithmetic shift right generally produces the result you expect. For example,
    if you perform the arithmetic shift-right operation on −2 ($FE), you get −1 ($FF).
    Keep one thing in mind about arithmetic shift right, however. This operation always
    rounds the numbers to the closest integer that is *less than or equal to the actual
    result*. Based on experiences with high-level programming languages and the standard
    rules of integer truncation, most people assume this means that a division always
    truncates toward 0\. But this simply isn't the case. For example, if you apply
    the arithmetic shift-right operation on −1 ($FF), the result is −1, not 0\. Because
    −1 is less than 0, the arithmetic shift-right operation rounds toward −1\. This
    is not a bug in the arithmetic shift-right operation; it just uses a different
    (though valid) definition of integer division.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 算术右移通常会产生你预期的结果。例如，如果对 −2 ($FE) 执行算术右移操作，结果是 −1 ($FF)。然而，有一点需要牢记关于算术右移：该操作总是将数字舍入到
    *小于或等于实际结果* 的最接近整数。基于高级编程语言的经验和整数截断的标准规则，大多数人认为这意味着除法总是向 0 截断。但事实并非如此。例如，如果对 −1
    ($FF) 执行算术右移操作，结果是 −1，而不是 0。因为 −1 小于 0，算术右移操作会舍入到 −1。这并不是算术右移操作的错误；它只是使用了与整数除法不同（但有效）的定义。
- en: 'The 80x86 provides an arithmetic shift-right instruction, `sar` (shift arithmetic
    right). This instruction''s syntax is nearly identical to `shl` and `shr`. The
    syntax is:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 提供了一个算术右移指令，`sar`（算术右移）。该指令的语法几乎与 `shl` 和 `shr` 相同。其语法如下：
- en: '[PRE40]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The usual limitations on the count and destination operands apply. This instruction
    operates as shown in [Figure 2-13](ch02s10.html#sar_open_parenthesis_1_comma_dest_close
    "Figure 2-13. sar( 1, dest ) operation") if the count is 1.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通常关于计数和目标操作数的限制适用。如果计数为 1，则该指令的操作如[图 2-13](ch02s10.html#sar_open_parenthesis_1_comma_dest_close
    "图 2-13. `sar( 1, dest )` 操作")所示。
- en: '![sar( 1, dest ) operation](tagoreillycom20100401nostarchimages577909.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![sar( 1, dest ) 操作](tagoreillycom20100401nostarchimages577909.png)'
- en: Figure 2-13. `sar( 1, dest )` operation
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-13. `sar( 1, dest )` 操作
- en: Once again, Intel's documents suggest that shifts of more than 1 bit leave the
    carry in an undefined state.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，Intel 的文档建议，如果移位超过 1 位，进位将处于未定义状态。
- en: 'Another pair of useful operations are *rotate left* and *rotate right*. These
    operations behave like the shift-left and shift-right operations with one major
    difference: The bit shifted out from one end is shifted back in at the other end.
    [Figure 2-14](ch02s10.html#rotate-left_and_rotate-right_operations "Figure 2-14. Rotate-left
    and rotate-right operations") diagrams these operations.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的操作是 *左旋转* 和 *右旋转*。这些操作与左移和右移操作类似，但有一个主要区别：从一端移出的位会被旋转回另一端。[图 2-14](ch02s10.html#rotate-left_and_rotate-right_operations
    "图 2-14. 左旋转和右旋转操作") 展示了这些操作。
- en: '![Rotate-left and rotate-right operations](tagoreillycom20100401nostarchimages577911.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![左旋转和右旋转操作](tagoreillycom20100401nostarchimages577911.png)'
- en: Figure 2-14. Rotate-left and rotate-right operations
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-14. 左旋转和右旋转操作
- en: 'The 80x86 provides `rol` (rotate left) and `ror` (rotate right) instructions
    that do these basic operations on their operands. The syntax for these two instructions
    is similar to the shift instructions:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 提供了 `rol`（左旋转）和 `ror`（右旋转）指令，对其操作数执行这些基本操作。这两个指令的语法与移位指令类似：
- en: '[PRE41]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once again, these instructions provide a special behavior if the shift count
    is 1\. Under this condition these two instructions also copy the bit shifted out
    of the destination operand into the carry flag as [Figure 2-15](ch02s10.html#rol_open_parenthesis_1_comma_dest_close
    "Figure 2-15. rol( 1, dest ) operation") and [Figure 2-16](ch02s10.html#ror_open_parenthesis_1_comma_dest_close
    "Figure 2-16. ror( 1, dest ) operation") show.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些指令在移位计数为 1 时提供特殊行为。在这种情况下，这两个指令还会将从目标操作数中移出的位复制到进位标志中，正如[图 2-15](ch02s10.html#rol_open_parenthesis_1_comma_dest_close
    "图 2-15. rol( 1, dest ) 操作")和[图 2-16](ch02s10.html#ror_open_parenthesis_1_comma_dest_close
    "图 2-16. ror( 1, dest ) 操作")所示。
- en: '![rol( 1, dest ) operation](tagoreillycom20100401nostarchimages577913.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![rol( 1, dest ) 操作](tagoreillycom20100401nostarchimages577913.png)'
- en: Figure 2-15. `rol( 1, dest )` operation
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-15. `rol( 1, dest )` 操作
- en: Note that Intel's documents suggest that rotates of more than 1 bit leave the
    carry in an undefined state.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，英特尔的文档建议，超过 1 位的旋转操作会使进位处于未定义状态。
- en: '![ror( 1, dest ) operation](tagoreillycom20100401nostarchimages577915.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![ror( 1, dest ) 操作](tagoreillycom20100401nostarchimages577915.png)'
- en: Figure 2-16. `ror( 1, dest )` operation
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-16. `ror( 1, dest )` 操作
- en: 'It is often more convenient for the rotate operation to shift the output bit
    through the carry and shift the previous carry value back into the input bit of
    the shift operation. The 80x86 `rcl` (rotate through carry left) and `rcr` (rotate
    through carry right) instructions achieve this for you. These instructions use
    the following syntax:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旋转操作，通常更方便将输出位通过进位进行旋转，并将之前的进位值重新输入到移位操作的输入位中。80x86 的 `rcl`（进位左旋转）和 `rcr`（进位右旋转）指令为你实现了这一点。这些指令使用以下语法：
- en: '[PRE42]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As is true for the other shift and rotate instructions, the *`count`* operand
    is either a constant or the CL register, and the *`dest`* operand is a memory
    location or register. The *`count`* operand must be a value that is less than
    the number of bits in the *`dest`* operand. For a count value of 1, these two
    instructions do the rotation shown in [Figure 2-17](ch02s10.html#rcl_open_parenthesis_1_comma_dest_close
    "Figure 2-17. rcl( 1, dest ) and rcr( 1, dest ) operations").
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他移位和旋转指令一样，*`count`* 操作数要么是常数，要么是 CL 寄存器，*`dest`* 操作数则是内存位置或寄存器。*`count`*
    操作数的值必须小于 *`dest`* 操作数的位数。对于移位计数值为 1 的情况，这两个指令执行的旋转操作如[图 2-17](ch02s10.html#rcl_open_parenthesis_1_comma_dest_close
    "图 2-17. rcl( 1, dest ) 和 rcr( 1, dest ) 操作")所示。
- en: '![rcl( 1, dest ) and rcr( 1, dest ) operations](tagoreillycom20100401nostarchimages577917.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![rcl( 1, dest ) 和 rcr( 1, dest ) 操作](tagoreillycom20100401nostarchimages577917.png)'
- en: Figure 2-17. `rcl( 1, dest )` and `rcr( 1, dest )` operations
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-17. `rcl( 1, dest )` 和 `rcr( 1, dest )` 操作
- en: Again, Intel's documents suggest that rotates of more than 1 bit leave the carry
    in an undefined state.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，英特尔的文档建议，超过 1 位的旋转操作会使进位处于未定义状态。
- en: '* * *'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[25](#CHP-2-FN-5)]) There is no need for an arithmetic shift left. The standard
    shift-left operation works for both signed and unsigned numbers, assuming no overflow
    occurs.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#CHP-2-FN-5)]) 不需要算术左移。标准的左移操作适用于有符号和无符号数值，前提是没有溢出发生。
- en: 2.11 Bit Fields and Packed Data
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.11 位域和打包数据
- en: 'Although the 80x86 operates most efficiently on `byte`, `word`, and `dword`
    data types, occasionally you''ll need to work with a data type that uses some
    number of bits other than 8, 16, or 32\. For example, consider a date of the form
    04/02/01\. It takes three numeric values to represent this date: month, day, and
    year values. Months, of course, take on the values 1..12\. It will require at
    least 4 bits (maximum of 16 different values) to represent the month. Days range
    between 1 and 31\. So it will take 5 bits (maximum of 32 different values) to
    represent the day entry. The year value, assuming that we''re working with values
    in the range 0..99, requires 7 bits (that can be used to represent up to 128 different
    values). 4 + 5 + 7 = 16 bits, or 2 bytes. In other words, we can pack our date
    data into 2 bytes rather than the 3 that would be required if we used a separate
    byte for each of the month, day, and year values. This saves 1 byte of memory
    for each date stored, which could be a substantial saving if you need to store
    many dates. The bits could be arranged as shown in [Figure 2-18](ch02s11.html#short_packed_date_format_open_parenthesi
    "Figure 2-18. Short packed date format (2 bytes)").'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管80x86在处理`byte`、`word`和`dword`数据类型时效率最高，但有时你需要处理一些比8、16或32位更复杂的数据类型。例如，考虑一下格式为04/02/01的日期。表示这个日期需要三个数值：月份、日期和年份。月份的值当然是1到12之间的数值。因此，表示月份至少需要4位（二进制最大值为16）。日期的范围是1到31，因此表示日期需要5位（二进制最大值为32）。假设年份在0到99之间，表示年份需要7位（最多可以表示128种不同的值）。4
    + 5 + 7 = 16位，或者2字节。换句话说，我们可以将日期数据打包成2字节，而不是使用3个字节（分别为月份、日期和年份各分配一个字节）。这样每存储一个日期就能节省1个字节的内存，如果需要存储大量日期，这将是一个显著的节省。位可以按[图2-18](ch02s11.html#short_packed_date_format_open_parenthesi
    "图2-18. 短打包日期格式（2字节）")中的方式进行排列。
- en: '![Short packed date format (2 bytes)](tagoreillycom20100401nostarchimages577919.png.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![短打包日期格式（2字节）](tagoreillycom20100401nostarchimages577919.png.jpg)'
- en: Figure 2-18. Short packed date format (2 bytes)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-18. 短打包日期格式（2字节）
- en: 'MMMM represents the 4 bits making up the month value, DDDDD represents the
    5 bits making up the day, and YYYYYYY is the 7 bits composing the year. Each collection
    of bits representing a data item is a *bit field*. For example, April 2, 2001,
    would be represented as $4101:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: MMMM代表组成月份值的4位，DDDDD代表组成日期的5位，YYYYYYY代表组成年份的7位。每个数据项的位集合称为*位字段*。例如，2001年4月2日将表示为$4101：
- en: '[PRE43]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Although packed values are *space efficient* (that is, very efficient in terms
    of memory usage), they are computationally *inefficient* (slow!). The reason?
    It takes extra instructions to unpack the data packed into the various bit fields.
    These extra instructions take additional time to execute (and additional bytes
    to hold the instructions); hence, you must carefully consider whether packed data
    fields will save you anything. The sample program in [Example 2-9](ch02s11.html#packing_and_unpacking_date_data
    "Example 2-9. Packing and unpacking date data") demonstrates the effort that must
    go into packing and unpacking this 16-bit date format.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管打包的值*节省空间*（即在内存使用上非常高效），但它们在计算上是*低效*的（慢！）。原因是什么？因为需要额外的指令来解包那些打包在各个位字段中的数据。这些额外的指令需要额外的时间来执行（并且需要额外的字节来存储这些指令）；因此，必须仔细考虑打包的数据字段是否能为你节省任何东西。[示例2-9](ch02s11.html#packing_and_unpacking_date_data
    "示例 2-9. 打包和解包日期数据")中的示例程序展示了打包和解包这种16位日期格式所需的工作量。
- en: Example 2-9. Packing and unpacking date data
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-9. 打包和解包日期数据
- en: '[PRE44]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Of course, having gone through the problems with Y2K (Year 2000), you know that
    using a date format that limits you to 100 years (or even 127 years) would be
    quite foolish at this time. If you are concerned about your software running 100
    years from now, perhaps it would be wise to use a 3-byte date format rather than
    a 2-byte format. As you will see in the chapter on arrays, however, you should
    always try to create data objects whose length is an even power of 2 (1 byte,
    2 bytes, 4 bytes, 8 bytes, and so on) or you will pay a performance penalty. Hence,
    it is probably wise to go ahead and use 4 bytes and pack this data into a double-word
    variable. [Figure 2-19](ch02s11.html#long_packed_date_format_open_parenthesis
    "Figure 2-19. Long packed date format (4 bytes)") shows one possible data organization
    for a 4-byte date.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，经过了千年虫（Y2K）问题，你知道使用一个限制为100年（甚至127年）的日期格式在现在看来是非常愚蠢的。如果你担心你的软件在100年后仍在运行，也许使用一个3字节的日期格式而不是2字节格式会更明智。不过，正如你将在数组章节中看到的，通常你应该尽量创建长度为偶数次幂的2的数据对象（1字节、2字节、4字节、8字节等），否则你会遭遇性能损失。因此，可能明智的做法是直接使用4字节，并将这些数据打包到一个双字变量中。[图
    2-19](ch02s11.html#long_packed_date_format_open_parenthesis "图 2-19. 长紧凑日期格式（4字节）")展示了一个可能的4字节日期数据组织方式。
- en: '![Long packed date format (4 bytes)](tagoreillycom20100401nostarchimages577921.png.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![长紧凑日期格式（4字节）](tagoreillycom20100401nostarchimages577921.png.jpg)'
- en: Figure 2-19. Long packed date format (4 bytes)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-19. 长紧凑日期格式（4字节）
- en: In this long packed date format we made several changes beyond simply extending
    the number of bits associated with the year. First, because there are extra bits
    in a 32-bit double-word variable, this format allocates extra bits to the month
    and day fields. Because these two fields now consist of 8 bits each, they can
    be easily extracted as a byte object from the double word. This leaves fewer bits
    for the year, but 65,536 years is probably sufficient; you can probably assume
    without too much concern that your software will not still be in use 63,000 years
    from now when this date format will no longer work.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种长格式的紧凑日期格式中，我们做了一些更改，不仅仅是简单地扩展与年份相关的位数。首先，因为在32位双字变量中有额外的位，所以该格式为月份和日期字段分配了额外的位。由于这两个字段现在各自包含8个位，它们可以很容易地作为字节对象从双字中提取。这会留下更少的位给年份，但65,536年可能已经足够；你可以假设，除非你的软件仍然在63,000年后使用，否则它不太可能在这个日期格式停止工作时仍然被使用。
- en: 'Of course, you could argue that this is no longer a packed date format. After
    all, we needed three numeric values, two of which fit just nicely into 1 byte
    each and one that should probably have at least 2 bytes. Because this "packed"
    date format consumes the same 4 bytes as the unpacked version, what is so special
    about this format? Well, another difference you will note between this long packed
    date format and the short date format appearing in [Figure 2-18](ch02s11.html#short_packed_date_format_open_parenthesi
    "Figure 2-18. Short packed date format (2 bytes)") is the fact that this long
    date format rearranges the bits so the `Year` field is in the H.O. bit positions,
    the `Month` field is in the middle bit positions, and the `Day` field is in the
    L.O. bit positions. This is important because it allows you to very easily compare
    two dates to see if one date is less than, equal to, or greater than another date.
    Consider the following code:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以争辩说，这不再是一个紧凑日期格式。毕竟，我们需要三个数值，其中两个正好可以各自占用1个字节，而另一个则可能至少需要2个字节。因为这个“紧凑”日期格式与非紧凑版本消耗相同的4个字节，那么这个格式到底有什么特别之处呢？好吧，你会注意到，在这个长格式的紧凑日期格式与出现在[图
    2-18](ch02s11.html#short_packed_date_format_open_parenthesi "图 2-18. 短紧凑日期格式（2字节）")中的短日期格式之间，另一个区别是，这个长日期格式重新排列了位，使得`Year`字段位于高字节位，`Month`字段位于中间字节位，而`Day`字段位于低字节位。这一点非常重要，因为它使得你可以非常方便地比较两个日期，查看一个日期是否小于、等于或大于另一个日期。请看以下代码：
- en: '[PRE45]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Had you kept the different date fields in separate variables, or organized the
    fields differently, you would not have been able to compare *`Date1`* and *`Date2`*
    in such an easy fashion. Therefore, this example demonstrates another reason for
    packing data even if you don't realize any space savings—it can make certain computations
    more convenient or even more efficient (contrary to what normally happens when
    you pack data).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将不同的日期字段保存在单独的变量中，或者以不同的方式组织字段，你就无法像这样轻松地比较*`Date1`*和*`Date2`*。因此，这个例子展示了另一个打包数据的理由，即使你没有意识到任何空间节省——它可以使某些计算变得更加方便，甚至更高效（与通常打包数据时会发生的情况相反）。
- en: Examples of practical packed data types abound. You could pack eight boolean
    values into a single byte, you could pack two BCD digits into a byte, and so on.
    Of course, a classic example of packed data is the EFLAGS register (see [Figure 2-20](ch02s11.html#eflags_register_as_packed_boolean_data
    "Figure 2-20. EFLAGS register as packed boolean data")). This register packs nine
    important boolean objects (along with seven important system flags) into a single
    16-bit register. You will commonly need to access many of these flags. For this
    reason, the 80x86 instruction set provides many ways to manipulate the individual
    bits in the EFLAGS register. Of course, you can test many of the condition code
    flags using the HLA pseudo-boolean variables such as `@c`, `@nc`, `@z`, and `@nz`
    in an `if` statement or other statement using a boolean expression.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的打包数据类型例子比比皆是。你可以将八个布尔值打包成一个字节，将两个BCD数字打包成一个字节，等等。当然，经典的打包数据示例是EFLAGS寄存器（参见[图
    2-20](ch02s11.html#eflags_register_as_packed_boolean_data "图 2-20. EFLAGS寄存器作为打包布尔数据")）。该寄存器将九个重要的布尔对象（以及七个重要的系统标志）打包成一个16位寄存器。你通常需要访问这些标志中的许多。因此，80x86指令集提供了多种方法来操作EFLAGS寄存器中的各个位。当然，你可以使用HLA伪布尔变量（如`@c`、`@nc`、`@z`和`@nz`）在`if`语句或其他布尔表达式中测试许多条件代码标志。
- en: In addition to the condition codes, the 80x86 provides instructions that directly
    affect certain flags ([Table 2-7](ch02s11.html#instructions_that_affect_certain_flags
    "Table 2-7. Instructions That Affect Certain Flags")).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 除了条件代码外，80x86还提供了直接影响某些标志的指令（[表 2-7](ch02s11.html#instructions_that_affect_certain_flags
    "表 2-7. 影响某些标志的指令")）。
- en: Table 2-7. Instructions That Affect Certain Flags
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-7. 影响某些标志的指令
- en: '| Instruction | Explanation |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 说明 |'
- en: '| --- | --- |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cld();` | Clears (sets to 0) the direction flag. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `cld();` | 清除（设置为0）方向标志。 |'
- en: '| `std();` | Sets (to 1) the direction flag. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `std();` | 设置（为1）方向标志。 |'
- en: '| `cli();` | Clears the interrupt disable flag. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `cli();` | 清除中断禁止标志。 |'
- en: '| `sti();` | Sets the interrupt disable flag. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `sti();` | 设置中断禁止标志。 |'
- en: '| `clc();` | Clears the carry flag. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `clc();` | 清除进位标志。 |'
- en: '| `stc();` | Sets the carry flag. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `stc();` | 设置进位标志。 |'
- en: '| `cmc();` | Complements (inverts) the carry flag. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `cmc();` | 互补（反转）进位标志。 |'
- en: '| `sahf();` | Stores the AH register into the L.O. 8 bits of the EFLAGS register.
    |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `sahf();` | 将AH寄存器存储到EFLAGS寄存器的低8位。 |'
- en: '| `lahf();` | Loads AH from the L.O. 8 bits of the EFLAGS register. |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `lahf();` | 从EFLAGS寄存器的低8位加载AH。 |'
- en: There are other instructions that affect the EFLAGS register as well; these
    instructions, however, demonstrate how to access several of the packed boolean
    values in the EFLAGS register. The `lahf` and `sahf` instructions, in particular,
    provide a convenient way to access the L.O. 8 bits of the EFLAGS register as an
    8-bit byte (rather than as eight separate 1-bit values). See [Figure 2-20](ch02s11.html#eflags_register_as_packed_boolean_data
    "Figure 2-20. EFLAGS register as packed boolean data") for a layout of the EFLAGS
    register.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他影响EFLAGS寄存器的指令；然而，这些指令演示了如何访问EFLAGS寄存器中的几个打包布尔值。特别是，`lahf`和`sahf`指令提供了一种方便的方法，可以将EFLAGS寄存器的低8位作为一个8位字节（而不是作为八个单独的1位值）进行访问。有关EFLAGS寄存器的布局，请参见[图
    2-20](ch02s11.html#eflags_register_as_packed_boolean_data "图 2-20. EFLAGS寄存器作为打包布尔数据")。
- en: '![EFLAGS register as packed boolean data](tagoreillycom20100401nostarchimages577923.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![EFLAGS寄存器作为打包布尔数据](tagoreillycom20100401nostarchimages577923.png)'
- en: Figure 2-20. EFLAGS register as packed boolean data
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-20. EFLAGS寄存器作为打包布尔数据
- en: 'The `lahf` (load AH with the L.O. 8 bits of the EFLAGS register) and the `sahf`
    (store AH into the L.O. byte of the EFLAGS register) use the following syntax:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`lahf`（将AH加载为EFLAGS寄存器的低8位）和`sahf`（将AH存储到EFLAGS寄存器的低字节）使用以下语法：'
- en: '[PRE46]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 2.12 An Introduction to Floating-Point Arithmetic
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.12 浮点运算简介
- en: 'Integer arithmetic does not let you represent fractional numeric values. Therefore,
    modern CPUs support an approximation of *real* arithmetic: floating-point arithmetic.
    A big problem with floating-point arithmetic is that it does not follow the standard
    rules of algebra. Nevertheless, many programmers apply normal algebraic rules
    when using floating-point arithmetic. This is a source of defects in many programs.
    One of the primary goals of this section is to describe the limitations of floating-point
    arithmetic so you will understand how to use it properly.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 整数运算无法表示小数值。因此，现代CPU支持一种*实数*运算的近似方法：浮点运算。浮点运算的一个大问题是，它不遵循代数的标准规则。然而，许多程序员在使用浮点运算时仍然应用正常的代数规则。这是许多程序中的缺陷来源。本节的主要目标之一是描述浮点运算的局限性，以便你能正确使用它。
- en: Normal algebraic rules apply only to *infinite precision* arithmetic. Consider
    the simple statement *x* := *x* + 1, where *x* is an integer. On any modern computer
    this statement follows the normal rules of algebra *as long as overflow does not
    occur*. That is, this statement is valid only for certain values of *x* (*minint*
    <= *x* < *maxint*). Most programmers do not have a problem with this because they
    are well aware of the fact that integers in a program do not follow the standard
    algebraic rules (e.g., 5/2 does not equal 2.5).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的代数规则只适用于*无限精度*运算。考虑简单的语句*x* := *x* + 1，其中*x*是整数。在任何现代计算机上，只要没有发生溢出，这个语句遵循正常的代数规则。也就是说，这个语句只对某些*x*值有效（*minint*
    <= *x* < *maxint*）。大多数程序员对此没有问题，因为他们充分意识到程序中的整数并不遵循标准的代数规则（例如，5/2不等于2.5）。
- en: Integers do not follow the standard rules of algebra because the computer represents
    them with a finite number of bits. You cannot represent any of the (integer) values
    above the maximum integer or below the minimum integer. Floating-point values
    suffer from this same problem, only worse. After all, the integers are a subset
    of the real numbers. Therefore, the floating-point values must represent the same
    infinite set of integers. However, there are an infinite number of real values
    between any two integer values, so this problem is infinitely worse. Therefore,
    as well as having to limit your values between a maximum and minimum range, you
    cannot represent all the values between those two ranges either.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 整数不遵循代数标准规则，因为计算机用有限数量的位来表示它们。你无法表示大于最大整数或小于最小整数的任何整数值。浮点值也有同样的问题，而且问题更严重。毕竟，整数是实数的一个子集。因此，浮点值必须表示同样的无限整数集合。然而，在任何两个整数值之间都有无限多个实数值，所以这个问题变得更加严重。因此，除了需要将值限制在最大和最小范围之间，你也无法表示这两个范围之间的所有值。
- en: To represent real numbers, most floating-point formats employ scientific notation
    and use some number of bits to represent a *mantissa* and a smaller number of
    bits to represent an *exponent*. The end result is that floating-point numbers
    can only represent numbers with a specific number of *significant* digits. This
    has a big impact on how floating-point arithmetic operates. To easily see the
    impact of limited precision arithmetic, we will adopt a simplified decimal floating-point
    format for our examples. Our floating-point format will provide a mantissa with
    three significant digits and a decimal exponent with two digits. The mantissa
    and exponents are both signed values, as shown in [Figure 2-21](ch02s12.html#a_floating-point_format
    "Figure 2-21. A floating-point format").
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示实数，大多数浮点数格式采用科学记数法，并使用一定数量的位来表示*尾数*，以及更少数量的位来表示*指数*。最终结果是浮点数只能表示具有特定数量*有效*数字的数值。这对浮点运算的运作有很大影响。为了更清楚地看到有限精度运算的影响，我们将在示例中采用简化的十进制浮点格式。我们的浮点格式将提供一个具有三位有效数字的尾数和一个两位数字的十进制指数。尾数和指数都是带符号的值，如[图2-21](ch02s12.html#a_floating-point_format
    "图2-21. 浮点数格式")所示。
- en: '![A floating-point format](tagoreillycom20100401nostarchimages577925.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![浮点数格式](tagoreillycom20100401nostarchimages577925.png)'
- en: Figure 2-21. A floating-point format
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-21. 浮点数格式
- en: When adding and subtracting two numbers in scientific notation, we must adjust
    the two values so that their exponents are the same. For example, when adding
    1.23e1 and 4.56e0, we must adjust the values so they have the same exponent. One
    way to do this is to convert 4.56e0 to 0.456e1 and then add. This produces 1.686e1\.
    Unfortunately, the result does not fit into three significant digits, so we must
    either *round* or *truncate* the result to three significant digits. Rounding
    generally produces the most accurate result, so let's round the result to obtain
    1.69e1\. As you can see, the lack of *precision* (the number of digits or bits
    we maintain in a computation) affects the accuracy (the correctness of the computation).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当对两个科学记数法表示的数字进行加减时，我们必须调整这两个值，使它们的指数相同。例如，当加1.23e1和4.56e0时，我们必须调整这两个值的指数，使它们相同。一个方法是将4.56e0转换为0.456e1，然后再进行加法。这会得到1.686e1。遗憾的是，结果无法容纳三位有效数字，因此我们必须对结果进行*四舍五入*或*截断*到三位有效数字。四舍五入通常能得到最准确的结果，因此我们将结果四舍五入得到1.69e1。正如你所看到的，*精度*（我们在计算中保留的数字或位数）影响了结果的准确性（计算的正确性）。
- en: In the previous example, we were able to round the result because we maintained
    *four* significant digits *during* the calculation. If our floating-point calculation
    had been limited to three significant digits *during* computation, we would have
    had to truncate the last digit of the smaller number, obtaining 1.68e1, a value
    that is even less accurate. To improve the accuracy of floating-point calculations,
    it is necessary to add extra digits for use during the calculation. Extra digits
    available during a computation are known as *guard digits* (or *guard bits* in
    the case of a binary format). They greatly enhance accuracy during a long chain
    of computations.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们能够四舍五入结果，因为在计算过程中我们保留了*四*位有效数字。如果我们的浮点计算在计算过程中只能保留三位有效数字，我们就必须截断较小数字的最后一位，得到1.68e1，这是一个更不准确的值。为了提高浮点计算的准确性，有必要在计算过程中添加额外的数字。计算过程中可用的额外数字被称为*保护数字*（对于二进制格式而言，称为*保护位*）。它们在长链计算过程中能大大提高准确性。
- en: 'The accuracy loss during a single computation usually isn''t enough to worry
    about unless you are greatly concerned about the accuracy of your computations.
    However, if you compute a value that is the result of a sequence of floating-point
    operations, the error can *accumulate* and greatly affect the computation itself.
    For example, suppose we were to add 1.23e3 to 1.00e0\. Adjusting the numbers so
    their exponents are the same before the addition produces 1.23e3 + 0.001e3\. The
    sum of these two values, even after rounding, is 1.23e3\. This might seem perfectly
    reasonable to you; after all, we can maintain only three significant digits, so
    adding in a small value shouldn''t affect the result at all. However, suppose
    we were to add 1.00e0 to 1.23e3 *ten times*. The first time we add 1.00e0 to 1.23e3
    we get 1.23e3\. Likewise, we get this same result the second, third, fourth .
    . . and tenth times we add 1.00e0 to 1.23e3\. On the other hand, had we added
    1.00e0 to itself 10 times, then added the result (1.00e1) to 1.23e3, we would
    have gotten a different result, 1.24e3\. This is an important thing to know about
    limited-precision arithmetic:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在单次计算中，准确性损失通常不足以引起担忧，除非你对计算的准确性非常关注。然而，如果你计算的值是多个浮点运算结果的序列，那么误差可能会*累积*，并极大地影响计算本身。例如，假设我们要将1.23e3加到1.00e0。通过在加法前调整这两个数的指数，使其相同，得到1.23e3
    + 0.001e3。即使经过四舍五入，这两个值的和仍然是1.23e3。这对你来说可能完全合理；毕竟，我们只能保留三位有效数字，因此加上一个小值不应该影响结果。然而，假设我们将1.00e0加到1.23e3
    *十次*。第一次将1.00e0加到1.23e3时，得到1.23e3。同样，在第二次、第三次、第四次……直到第十次加法时，我们都得到1.23e3。另一方面，如果我们将1.00e0加到自己身上10次，再将结果（1.00e1）加到1.23e3，我们会得到不同的结果，1.24e3。这是有限精度运算中需要注意的一个重要点：
- en: '**The order of evaluation can affect the accuracy of the result**.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**运算顺序会影响结果的准确性**。'
- en: You will get more accurate results if the relative magnitudes (that is, the
    exponents) are close to one another when adding and subtracting floating-point
    values. If you are performing a chain calculation involving addition and subtraction,
    you should attempt to group the values appropriately.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相对大小（即指数）在加减浮点值时接近，你将得到更准确的结果。如果进行的是包含加法和减法的连锁计算，应该尽量将值适当地分组。
- en: '| Another problem with addition and subtraction is that you can wind up with
    *false precision*. Consider the computation 1.23e0 − 1.22e0\. This produces 0.01e0\.
    Although this is mathematically equivalent to 1.00e − 2, this latter form suggests
    that the last two digits are exactly 0\. Unfortunately, we have only a single
    significant digit at this time. Indeed, some floating-point unit (FPU) software
    packages might actually insert random digits (or bits) into the L.O. positions.
    This brings up a second important rule concerning limited precision arithmetic:
    |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| 加法和减法的另一个问题是可能会导致*虚假精度*。考虑计算 1.23e0 − 1.22e0\。这会产生 0.01e0\。虽然这在数学上等同于 1.00e
    − 2，但后者的形式表明最后两位数字是精确为0的。不幸的是，我们目前只有一个有效数字。实际上，一些浮点单元（FPU）软件包可能会在低位插入随机数字（或位）。这引出了关于有限精度算术的第二条重要规则：
    |'
- en: '**When subtracting two numbers with the same signs or adding two numbers with
    different signs, the accuracy of the result may be less than the precision available
    in the floating-point format**.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**在减去两个符号相同的数字或加两个符号不同的数字时，结果的准确性可能低于浮点格式所能提供的精度**。'
- en: 'Multiplication and division do not suffer from the same problems as addition
    and subtraction because you do not have to adjust the exponents before the operation;
    all you need to do is add the exponents and multiply the mantissas (or subtract
    the exponents and divide the mantissas). By themselves, multiplication and division
    do not produce particularly poor results. However, they tend to multiply any error
    that already exists in a value. For example, if you multiply 1.23e0 by 2, when
    you should be multiplying 1.24e0 by 2, the result is even less accurate. This
    brings up a third important rule when working with limited-precision arithmetic:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法和除法不像加法和减法那样存在相同的问题，因为你不需要在运算前调整指数；你所需要做的只是加上指数并乘以尾数（或减去指数并除以尾数）。就其本身而言，乘法和除法不会产生特别差的结果。然而，它们倾向于放大已经存在的任何误差。例如，如果你将
    1.23e0 乘以 2，而你应该将 1.24e0 乘以 2，结果会更加不准确。这引出了在进行有限精度算术运算时的第三条重要规则：
- en: '**When performing a chain of calculations involving addition, subtraction,
    multiplication, and division, try to perform the multiplication and division operations
    first**.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**在进行涉及加法、减法、乘法和除法的计算链时，尽量先执行乘法和除法操作**。'
- en: Often, by applying normal algebraic transformations, you can arrange a calculation
    so the multiply and divide operations occur first. For example, suppose you want
    to compute *x* * ( *y* + *z* ). Normally you would add *y* and *z* together and
    multiply their sum by *x*. However, you will get a little more accuracy if you
    transform *x* * ( *y* + *z* ) to get *x* * *y* + *x* * *z* and compute the result
    by performing the multiplications first.^([[26](#ftn.CHP-2-FN-6)])
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过应用正常的代数变换，你可以调整计算顺序，使得乘法和除法运算优先进行。例如，假设你想计算 *x* * ( *y* + *z* )。通常你会先将
    *y* 和 *z* 相加，然后将它们的和乘以 *x*。然而，如果你将 *x* * ( *y* + *z* ) 转换为 *x* * *y* + *x* * *z*
    并先执行乘法运算，你会获得更高的准确性。^([[26](#ftn.CHP-2-FN-6)])
- en: '| Multiplication and division are not without their own problems. When multiplying
    two very large or very small numbers, it is quite possible for *overflow* or *underflow*
    to occur. The same situation occurs when dividing a small number by a large number
    or dividing a large number by a small number. This brings up a fourth rule you
    should attempt to follow when multiplying or dividing values: |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 乘法和除法并非没有问题。当乘以两个非常大或非常小的数字时，很可能会发生*溢出*或*下溢*。同样的情况也会出现在将一个小数字除以一个大数字，或将一个大数字除以一个小数字时。这引出了你在乘法或除法时应遵循的第四条规则：
    |'
- en: '**When multiplying and dividing sets of numbers, try to arrange the multiplications
    so that they multiply large and small numbers together; likewise, try to divide
    numbers that have the same relative magnitudes**.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**在进行乘法和除法时，尽量安排乘法顺序，使得大数和小数相乘；同样，尽量将具有相同相对大小的数字进行除法运算**。'
- en: Comparing floating-point numbers is very dangerous. Given the inaccuracies present
    in any computation (including converting an input string to a floating-point value),
    you should *never* compare two floating-point values to see if they are equal.
    In a binary floating-point format, different computations that produce the same
    (mathematical) result may differ in their least significant bits. For example,
    1.31e0 + 1.69e0 should produce 3.00e0\. Likewise, 1.50e0 + 1.50e0 should produce
    3.00e0\. However, if you were to compare (1.31e0 + 1.69e0) against (1.50e0 + 1.50e0),
    you might find out that these sums are *not* equal to one another. The test for
    equality succeeds if and only if all bits (or digits) in the two operands are
    exactly the same. Because this is not necessarily true after two different floating-point
    computations that should produce the same result, a straight test for equality
    may not work.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 比较浮动点数值是非常危险的。鉴于任何计算中（包括将输入字符串转换为浮动点值）都可能存在不准确性，你*绝不*应该比较两个浮动点值是否相等。在二进制浮动点格式中，不同的计算可能产生相同的（数学）结果，但它们的最低有效位可能不同。例如，1.31e0
    + 1.69e0 应该得到 3.00e0。同样，1.50e0 + 1.50e0 应该得到 3.00e0。然而，如果你比较 (1.31e0 + 1.69e0)
    和 (1.50e0 + 1.50e0)，你可能会发现这两个和*并不*相等。只有当两个操作数的所有位（或数字）完全相同，等式测试才会成功。因为在两次不同的浮动点计算结果应该相同的情况下，这一点不一定成立，所以直接进行相等测试可能不起作用。
- en: '| The standard way to test for equality between floating-point numbers is to
    determine how much error (or tolerance) you will allow in a comparison and check
    to see if one value is within this error range of the other. The usual way to
    do this is to use a test like the following: |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 测试浮动点数值是否相等的标准方法是确定你在比较中允许多少误差（或容差），并检查一个值是否在另一个值加减某个小误差值的范围内。通常的做法是使用类似如下的测试：|'
- en: '[PRE47]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '| Another common way to handle this same comparison is to use a statement of
    the form |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| 处理同样比较的另一种常见方式是使用类似以下形式的语句 |'
- en: '[PRE48]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '| You must exercise care when choosing the value for *`error`*. This should
    be a value slightly greater than the largest amount of error that will creep into
    your computations. The exact value will depend upon the particular floating-point
    format you use, but more on that a little later. Here is the final rule we will
    state in this section: |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 在选择*`error`*的值时必须小心。这个值应该略大于你计算中可能出现的最大误差值。具体的值取决于你使用的浮动点格式，但稍后会详细说明。这里是我们在本节中给出的最终规则：|'
- en: '**When comparing two floating-point numbers, always compare one value to see
    if it is in the range given by the second value plus or minus some small error
    value**.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**比较两个浮动点数值时，总是比较一个值，看它是否在由另一个值加减某个小误差值的范围内**。'
- en: There are many other little problems that can occur when using floating-point
    values. This text can only point out some of the major problems and make you aware
    of the fact that you cannot treat floating-point arithmetic like real arithmetic—the
    inaccuracies present in limited-precision arithmetic can get you into trouble
    if you are not careful. A good text on numerical analysis or even scientific computing
    can help fill in the details that are beyond the scope of this text. If you are
    going to be working with floating-point arithmetic, *in any language*, you should
    take the time to study the effects of limited-precision arithmetic on your computations.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浮动点值时，可能会遇到许多其他小问题。本文仅能指出一些主要问题，并提醒你不能像对待实际算术运算那样处理浮动点算术——有限精度算术中的不准确性可能会让你陷入麻烦，如果你不小心的话。一本关于数值分析的好书，甚至是科学计算的书，可以帮助你填补本文无法涉及的细节。如果你打算使用浮动点算术，*无论是什么语言*，你应该花时间研究有限精度算术对计算结果的影响。
- en: '| HLA''s `if` statement does not support boolean expressions involving floating-point
    operands. Therefore, you cannot use statements like `if( x < 3.141) then...` in
    your programs. [Chapter 6](ch06.html "Chapter 6. ARITHMETIC") will teach you how
    to do floating-point comparisons. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| HLA的`if`语句不支持涉及浮动点操作数的布尔表达式。因此，你不能在程序中使用像`if( x < 3.141) then...`这样的语句。[第6章](ch06.html
    "第6章. 算术运算")会教你如何进行浮动点比较。|'
- en: 2.12.1 IEEE Floating-Point Formats
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.12.1 IEEE浮动点格式
- en: When Intel planned to introduce a floating-point unit for its new 8086 microprocessor,
    it was smart enough to realize that the electrical engineers and solid-state physicists
    who design chips were probably not the best people to pick the best possible binary
    representation for a floating-point format. So Intel went out and hired the best
    numerical analyst it could find to design a floating-point format for its 8087
    FPU. That person then hired two other experts in the field, and the three of them
    (Kahn, Coonan, and Stone) designed Intel's floating-point format. They did such
    a good job designing the KCS Floating-Point Standard that the IEEE organization
    adopted this format for the IEEE floating-point format.^([[27](#ftn.CHP-2-FN-7)])
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 当英特尔计划为其新的8086微处理器引入浮点单元时，它足够聪明地意识到，设计芯片的电气工程师和固态物理学家可能并不是选择最佳浮点格式的最佳人选。因此，英特尔聘请了最好的数值分析师来为其8087浮点处理单元设计浮点格式。这个人随后又聘请了两位领域专家，三人（Kahn、Coonan和Stone）共同设计了英特尔的浮点格式。他们设计的KCS浮点标准如此成功，以至于IEEE组织采纳了这一格式作为IEEE浮点格式。^([[27](#ftn.CHP-2-FN-7)])
- en: 'To handle a wide range of performance and accuracy requirements, Intel actually
    introduced *three* floating-point formats: single-precision, double-precision,
    and extended-precision. The single- and double-precision formats corresponded
    to C''s float and double types or FORTRAN''s real and double-precision types.
    Intel intended to use extended-precision for long chains of computations. Extended-precision
    contains 16 extra bits that the calculations could use as guard bits before rounding
    down to a double-precision value when storing the result.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理各种性能和精度要求，英特尔实际上引入了*三*种浮点格式：单精度、双精度和扩展精度。单精度和双精度格式对应于C语言中的float和double类型，或者FORTRAN中的real和double-precision类型。英特尔计划使用扩展精度来处理长链式计算。扩展精度包含16个额外的位，这些位可以作为保护位，在将计算结果四舍五入到双精度值时使用。
- en: The single-precision format uses a *one's complement 24-bit mantissa* and an
    *8-bit excess-127 exponent*. The mantissa usually represents a value from 1.0
    to just under 2.0\. The H.O. bit of the mantissa is always assumed to be 1 and
    represents a value just to the left of the *binary point*.^([[28](#ftn.CHP-2-FN-8)])
    The remaining 23 mantissa bits appear to the right of the binary point. Therefore,
    the mantissa represents the value
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 单精度格式使用*补码24位尾数*和*8位过量127指数*。尾数通常表示从1.0到接近2.0之间的一个值。尾数的高位（H.O.位）始终假定为1，并表示*二进制点*左边的一个值。剩余的23个位则出现在二进制点的右侧。因此，尾数表示的值为
- en: '[PRE49]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `mmmm` characters represent the 23 bits of the mantissa. Keep in mind that
    we are working with binary numbers here. Therefore, each position to the right
    of the binary point represents a value (0 or 1) times a successive negative power
    of 2\. The implied 1 bit is always multiplied by 2⁰, which is 1\. This is why
    the mantissa is always greater than or equal to 1\. Even if the other mantissa
    bits are all 0, the implied 1 bit always gives us the value 1^([[29](#ftn.CHP-2-FN-9)]).
    Of course, even if we had an almost infinite number of 1 bits after the binary
    point, they still would not add up to 2\. This is why the mantissa can represent
    values in the range 1 to just under 2.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmmm`字符代表尾数的23位。请记住，我们在这里处理的是二进制数。因此，二进制点右侧的每个位置表示一个值（0或1）乘以2的连续负次幂。隐含的1位总是乘以2⁰，也就是1。这就是为什么尾数始终大于或等于1的原因。即使其他尾数位都是0，隐含的1位也总是给我们带来值1^([[29](#ftn.CHP-2-FN-9)])。当然，即使我们在二进制点后有几乎无限多个1位，它们仍然加起来不会达到2。这就是为什么尾数可以表示从1到接近2之间的值。'
- en: Although there are an infinite number of values between 1 and 2, we can only
    represent 8 million of them because we use a 23-bit mantissa (the 24th bit is
    always 1). This is the reason for inaccuracy in floating-point arithmetic—we are
    limited to 23 bits of precision in computations involving single-precision floating-point
    values.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管1和2之间存在无限多个值，但我们只能表示其中的800万个值，因为我们使用了23位尾数（第24位始终为1）。这就是浮点运算不准确的原因——在涉及单精度浮点值的计算时，我们只能使用23位的精度。
- en: The mantissa uses a one's complement format rather than two's complement. This
    means that the 24-bit value of the mantissa is simply an unsigned binary number,
    and the sign bit determines whether that value is positive or negative. One's
    complement numbers have the unusual property that there are two representations
    for 0 (with the sign bit set or clear). Generally, this is important only to the
    person designing the floating-point software or hardware system. We will assume
    that the value 0 always has the sign bit clear.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 尾数使用的是一补码格式，而不是二补码。这意味着尾数的24位值只是一个无符号二进制数，符号位决定该值是正数还是负数。一补码数有一个不寻常的属性，那就是0有两种表示方式（符号位可以是设置的或清除的）。通常，这对于设计浮点软件或硬件系统的人来说是重要的。我们假设值0总是符号位清除的。
- en: To represent values outside the range 1.0 to just under 2.0, the exponent portion
    of the floating-point format comes into play. The floating-point format raises
    2 to the power specified by the exponent and then multiplies the mantissa by this
    value. The exponent is 8 bits and is stored in an *excess-127* format. In excess-127
    format, the exponent 2⁰ is represented by the value 127 ($7F ). Therefore, to
    convert an exponent to excess-127 format, simply add 127 to the exponent value.
    The use of excess-127 format makes it easier to compare floating-point values.
    The single-precision floating-point format takes the form shown in [Figure 2-22](ch02s12.html#single-precision_open_parenthesis_32-bit
    "Figure 2-22. Single-precision (32-bit) floating-point format").
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示1.0到接近2.0范围之外的值，浮点格式的指数部分发挥了作用。浮点格式将2的指数次方与尾数相乘，得到最终结果。指数为8位，并以*超127*格式存储。在超127格式中，指数2⁰由值127（$7F）表示。因此，要将一个指数转换为超127格式，只需将127加到该指数值上。使用超127格式使得浮点数值比较更加容易。单精度浮点格式的形式如[图2-22](ch02s12.html#single-precision_open_parenthesis_32-bit
    "图2-22. 单精度（32位）浮点格式")所示。
- en: '![Single-precision (32-bit) floating-point format](tagoreillycom20100401nostarchimages577927.png.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![单精度（32位）浮点格式](tagoreillycom20100401nostarchimages577927.png.jpg)'
- en: Figure 2-22. Single-precision (32-bit) floating-point format
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-22. 单精度（32位）浮点格式
- en: With a 24-bit mantissa, you will get approximately 6 ½ digits of precision (½
    digit of precision means that the first six digits can all be in the range 0..9,
    but the seventh digit can only be in the range 0..*x*, where *x* < 9 and is generally
    close to 5). With an 8-bit excess-127 exponent, the dynamic range of single-precision
    floating-point numbers is approximately 2 ± 128 or about 10 ± 38.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 使用24位尾数，你将得到大约6 ½位的精度（½位精度意味着前六位数字可以在0到9的范围内，但第七位只能在0到*x*的范围内，其中*x* < 9，并且通常接近5）。使用一个8位的超127指数，单精度浮点数的动态范围大约为2
    ± 128，或者约为10 ± 38。
- en: Although single-precision floating-point numbers are perfectly suitable for
    many applications, the dynamic range is somewhat limited and is unsuitable for
    many financial, scientific, and other applications. Furthermore, during long chains
    of computations, the limited accuracy of the single-precision format may introduce
    serious error.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单精度浮点数在许多应用中非常适用，但其动态范围有限，不适用于许多金融、科学及其他应用。此外，在长时间的计算链中，单精度格式的有限精度可能会引入严重的误差。
- en: The double-precision format helps overcome the problems of single-precision
    floating-point. Using twice the space, the double-precision format has an 11-bit
    excess-1023 exponent and a 53-bit mantissa (with an implied H.O. bit of 1) plus
    a sign bit. This provides a dynamic range of about 10^(±308) and 14 ½ digits of
    precision, sufficient for most applications. Double-precision floating-point values
    take the form shown in [Figure 2-23](ch02s12.html#bit_double-precision_floating-point_for
    "Figure 2-23. 64-bit double-precision floating-point format").
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 双精度格式有助于克服单精度浮点数的问题。使用双倍空间，双精度格式具有一个11位的超1023指数和一个53位的尾数（带有一个隐含的高阶位1）以及一个符号位。这提供了大约10^(±308)的动态范围和14
    ½位的精度，足以满足大多数应用需求。双精度浮点数的形式如[图2-23](ch02s12.html#bit_double-precision_floating-point_for
    "图2-23. 64位双精度浮点格式")所示。
- en: '![64-bit double-precision floating-point format](tagoreillycom20100401nostarchimages577929.png.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![64位双精度浮点格式](tagoreillycom20100401nostarchimages577929.png.jpg)'
- en: Figure 2-23. 64-bit double-precision floating-point format
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-23. 64位双精度浮点格式
- en: In order to help ensure accuracy during long chains of computations involving
    double-precision floating-point numbers, Intel designed the extended-precision
    format. The extended-precision format uses 80 bits. Twelve of the additional 16
    bits are appended to the mantissa and four of the additional bits are appended
    to the end of the exponent. Unlike the single- and double-precision values, the
    extended-precision format's mantissa does not have an implied H.O. bit, which
    is always 1\. Therefore, the extended-precision format provides a 64-bit mantissa,
    a 15-bit excess-16383 exponent, and a 1-bit sign. The format for the extended-precision
    floating-point value is shown in [Figure 2-24](ch02s12.html#bit_extended-precision_floating-point_f
    "Figure 2-24. 80-bit extended-precision floating-point format").
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助确保在涉及双精度浮点数的长链计算过程中精度的准确性，Intel 设计了扩展精度格式。扩展精度格式使用 80 位。额外的 16 位中，有 12 位附加到尾数，4
    位附加到指数的末尾。与单精度和双精度值不同，扩展精度格式的尾数没有隐含的 H.O. 位（该位始终为 1）。因此，扩展精度格式提供了一个 64 位的尾数、一个
    15 位的超常指数（excess-16383）和一个 1 位的符号位。扩展精度浮点值的格式如 [图 2-24](ch02s12.html#bit_extended-precision_floating-point_f
    "图 2-24. 80 位扩展精度浮点格式") 所示。
- en: '![80-bit extended-precision floating-point format](tagoreillycom20100401nostarchimages577931.png.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![80 位扩展精度浮点格式](tagoreillycom20100401nostarchimages577931.png.jpg)'
- en: Figure 2-24. 80-bit extended-precision floating-point format
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-24. 80 位扩展精度浮点格式
- en: On the FPUs all computations are done using the extended-precision format. Whenever
    you load a single or double-precision value, the FPU automatically converts it
    to an extended-precision value. Likewise, when you store a single or double-precision
    value to memory, the FPU automatically rounds the value down to the appropriate
    size before storing it. By always working with the extended-precision format,
    Intel guarantees a large number of guard bits are present to ensure the accuracy
    of your computations.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在浮点运算单元（FPU）中，所有的计算都使用扩展精度格式进行。每当你加载一个单精度或双精度值时，FPU 会自动将其转换为扩展精度值。同样，当你将一个单精度或双精度值存储到内存时，FPU
    会在存储之前自动将该值向下舍入到适当的大小。通过始终使用扩展精度格式，Intel 确保有大量的保护位，以确保计算的准确性。
- en: To maintain maximum precision during computation, most computations use *normalized*
    values. A normalized floating-point value is one whose H.O. mantissa bit contains
    1\. Almost any nonnormalized value can be normalized; shift the mantissa bits
    to the left and decrement the exponent until a 1 appears in the H.O. bit of the
    mantissa. Remember, the exponent is a binary exponent. Each time you increment
    the exponent, you multiply the floating-point value by 2\. Likewise, whenever
    you decrement the exponent, you divide the floating-point value by 2\. By the
    same token, shifting the mantissa to the left one bit position multiplies the
    floating-point value by 2; likewise, shifting the mantissa to the right divides
    the floating-point value by 2\. Therefore, shifting the mantissa to the left one
    position *and* decrementing the exponent does not change the value of the floating-point
    number at all.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在计算过程中保持最大的精度，大多数计算都使用*标准化*值。标准化浮点值是指其 H.O. 尾数位为 1 的值。几乎任何非标准化值都可以被标准化；将尾数位向左移动，并递减指数，直到尾数的
    H.O. 位变为 1。记住，指数是二进制指数。每次递增指数时，浮点值都会乘以 2。同样，每次递减指数时，浮点值都会除以 2。因此，将尾数向左移动一位也会将浮点值乘以
    2；同样，将尾数向右移动则会将浮点值除以 2。因此，将尾数向左移动一位*并*递减指数完全不会改变浮点数的值。
- en: Keeping floating-point numbers normalized is beneficial because it maintains
    the maximum number of bits of precision for a computation. If the H.O. bits of
    the mantissa are all 0, the mantissa has that many fewer bits of precision available
    for computation. Therefore, a floating-point computation will be more accurate
    if it involves only normalized values.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 保持浮点数的标准化是有益的，因为它保持了计算的最大精度位数。如果尾数的 H.O. 位全为 0，则尾数的有效位数就会减少。由此，涉及标准化值的浮点计算会更精确。
- en: There are two important cases where a floating-point number cannot be normalized.
    Zero is one of these special cases. Obviously it cannot be normalized because
    the floating-point representation for 0 has no 1 bits in the mantissa. This, however,
    is not a problem because we can exactly represent the value 0 with only a single
    bit.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个重要的情况，在这些情况下浮点数无法归一化。零是其中一种特殊情况。显然它无法归一化，因为 0 的浮点表示法在尾数中没有 1 位。然而，这不是问题，因为我们可以仅用一个比特精确表示值
    0。
- en: The second case is when we have some H.O. bits in the mantissa that are 0 but
    the biased exponent is also 0 (and we cannot decrement it to normalize the mantissa).
    Rather than disallow certain small values, whose H.O. mantissa bits and biased
    exponent are 0 (the most negative exponent possible), the IEEE standard allows
    special *denormalized* values to represent these smaller values.^([[30](#ftn.CHP-2-FN-10)])
    Although the use of denormalized values allows IEEE floating-point computations
    to produce better results than if underflow occurred, keep in mind that denormalized
    values offer less bits of precision.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是当尾数中有一些高阶位是 0，而偏置指数也为 0 时（并且我们不能减少它来归一化尾数）。为了不禁止某些小值，这些小值的尾数高阶位和偏置指数都是
    0（这是最小的偏置指数），IEEE 标准允许使用特殊的 *非规格化* 值来表示这些较小的值。^([[30](#ftn.CHP-2-FN-10)]) 尽管使用非规格化值可以使
    IEEE 浮点运算产生比发生下溢时更好的结果，但请记住，非规格化值提供的精度比特较少。
- en: 2.12.2 HLA Support for Floating-Point Values
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.12.2 HLA 对浮点值的支持
- en: HLA provides several data types and library routines to support the use of floating-point
    data in your assembly language programs. These include built-in types to declare
    floating-point variables as well as routines that provide floating-point input,
    output, and conversion.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了多种数据类型和库例程，以支持在汇编语言程序中使用浮点数据。这些包括内置类型来声明浮点变量，以及提供浮点输入、输出和转换的例程。
- en: 'Perhaps the best place to start when discussing HLA''s floating-point facilities
    is with a description of floating-point literal constants. HLA floating-point
    constants allow the following syntax:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论 HLA 的浮点功能时，最好的起点可能是描述浮点字面常量。HLA 浮点常量允许以下语法：
- en: An optional `+` or `−` symbol, denoting the sign of the mantissa (if this is
    not present, HLA assumes that the mantissa is positive)
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的 `+` 或 `−` 符号，表示尾数的符号（如果没有此符号，HLA 默认认为尾数为正）
- en: Followed by one or more decimal digits
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后跟一个或多个小数位数字
- en: Optionally followed by a decimal point and one or more decimal digits
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地跟随小数点和一个或多个小数位数字
- en: Optionally followed by an `e` or `E`, optionally followed by a sign (`+` or
    `−`) and one or more decimal digits
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地跟随 `e` 或 `E`，可选地跟随符号（`+` 或 `−`）和一个或多个小数位数字
- en: 'Note that the decimal point or the `e`/`E` must be present in order to differentiate
    this value from an integer or unsigned literal constant. Here are some examples
    of legal literal floating-point constants:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，必须存在小数点或 `e`/`E`，以区分该值与整数或无符号字面常量。以下是一些合法的浮点字面常量示例：
- en: '[PRE50]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that a floating-point literal constant cannot begin with a decimal point;
    it must begin with a decimal digit, so you must use 0.1 to represent .1 in your
    programs.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，浮点字面常量不能以小数点开头；它必须以十进制数字开头，因此你必须使用 0.1 来表示 .1。
- en: 'HLA also allows you to place an underscore character (`_`) between any two
    consecutive decimal digits in a floating-point literal constant. You may use the
    underscore character in place of a comma (or other language-specific separator
    character) to help make your large floating-point numbers easier to read. Here
    are some examples:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 还允许在浮点字面常量中的任意两个连续十进制数字之间插入下划线字符（`_`）。你可以使用下划线字符代替逗号（或其他语言特定的分隔符）来帮助使大浮点数字更易于阅读。以下是一些示例：
- en: '[PRE51]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To declare a floating-point variable you use the `real32`, `real64`, or `real80`
    data types. Like their integer and unsigned brethren, the number at the end of
    these data type declarations specifies the number of bits used for each type''s
    binary representation. Therefore, you use `real32` to declare single-precision
    real values, `real64` to declare double-precision floating-point values, and `real80`
    to declare extended-precision floating-point values. Other than the fact that
    you use these types to declare floating-point variables rather than integers,
    their use is nearly identical to that for `int8`, `int16`, `int32`*,* and so on.
    The following examples demonstrate these declarations and their syntax:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个浮动点变量，可以使用`real32`、`real64`或`real80`数据类型。与它们的整数和无符号兄弟类似，这些数据类型声明末尾的数字指定了每种类型二进制表示中使用的位数。因此，使用`real32`声明单精度浮动点值，使用`real64`声明双精度浮动点值，使用`real80`声明扩展精度浮动点值。除了需要使用这些类型声明浮动点变量而不是整数外，它们的使用与`int8`、`int16`、`int32`等几乎完全相同。以下示例展示了这些声明及其语法：
- en: '[PRE52]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To output a floating-point variable in ASCII form, you would use one of the
    `stdout.putr32`*,* `stdout.putr64`, or `stdout.putr80` routines. These procedures
    display a number in decimal notation, that is, a string of digits, an optional
    decimal point, and a closing string of digits. Other than their names, these three
    routines use exactly the same calling sequence. Here are the calls and parameters
    for each of these routines:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 要以ASCII格式输出一个浮动点变量，可以使用`stdout.putr32`、`stdout.putr64`或`stdout.putr80`函数。这些程序会以十进制表示一个数字，即一串数字、可选的小数点以及结尾的一串数字。除了名称不同之外，这三个函数的调用方式完全相同。以下是每个函数的调用和参数：
- en: '[PRE53]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first parameter to these procedures is the floating-point value you wish
    to print. The size of this parameter must match the procedure''s name (e.g., the
    `r` parameter must be an 80-bit extended-precision floating-point variable when
    calling the `stdout.putr80` routine). The second parameter specifies the field
    width for the output text; this is the number of print positions the number will
    require when the procedure displays it. Note that this width must include print
    positions for the sign of the number and the decimal point. The third parameter
    specifies the number of print positions after the decimal point. For example:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序的第一个参数是您希望打印的浮动点值。此参数的大小必须与程序名称相匹配（例如，在调用`stdout.putr80`程序时，`r`参数必须是80位的扩展精度浮动点变量）。第二个参数指定输出文本的字段宽度；即当程序显示数字时，数字所需的打印位置数。请注意，这个宽度必须包括数字的符号和小数点的打印位置。第三个参数指定小数点后打印位置的数量。例如：
- en: '[PRE54]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: displays the value
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 显示值
- en: '[PRE55]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: (underscores represent leading spaces in this example).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: （下划线表示此示例中的前导空格）。
- en: 'Of course, if the number is very large or very small, you will want to use
    scientific notation rather than decimal notation for your floating-point numeric
    output. The HLA Standard Library `stdout.pute32`, `stdout.pute64`, and `stdout.pute80`
    routines provide this facility. These routines use the following procedure prototypes:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果数字非常大或非常小，您会希望使用科学计数法而不是十进制表示来输出浮动点数字。HLA标准库中的`stdout.pute32`、`stdout.pute64`和`stdout.pute80`函数提供了这个功能。这些函数使用以下程序原型：
- en: '[PRE56]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Unlike the decimal output routines, these scientific notation output routines
    do not require a third parameter specifying the number of digits after the decimal
    point to display. The `width` parameter indirectly specifies this value because
    all but one of the mantissa digits always appear to the right of the decimal point.
    These routines output their values in decimal notation, similar to the following:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 与十进制输出函数不同，这些科学计数法输出函数不需要第三个参数来指定显示小数点后要显示的位数。`width`参数间接地指定了这个值，因为除了一个尾数数字，所有尾数数字总是出现在小数点的右边。这些函数将它们的值以十进制表示输出，类似如下：
- en: '[PRE57]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can also output floating-point values using the HLA Standard Library `stdout.put`
    routine. If you specify the name of a floating-point variable in the `stdout.put`
    parameter list, the `stdout.put` code will output the value using scientific notation.
    The actual field width varies depending on the size of the floating-point variable
    (the `stdout.put` routine attempts to output as many significant digits as possible,
    in this case). Here''s an example:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用HLA标准库的`stdout.put`例程来输出浮动点值。如果你在`stdout.put`参数列表中指定了浮动点变量的名称，`stdout.put`代码将使用科学计数法输出该值。实际的字段宽度会根据浮动点变量的大小有所不同（`stdout.put`例程尽力输出尽可能多的有效数字）。以下是一个示例：
- en: '[PRE58]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you specify a field width, by using a colon followed by a signed integer
    value, then the `stdout.put` routine will use the appropriate `stdout.puteXX`
    routine to display the value. That is, the number will still appear in scientific
    notation, but you get to control the field width of the output value. Like the
    field width for integer and unsigned values, a positive field width right justifies
    the number in the specified field, and a negative number left justifies the value.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了字段宽度，使用冒号后跟一个带符号的整数值，那么`stdout.put`例程将使用相应的`stdout.puteXX`例程来显示该值。也就是说，数字仍然以科学计数法显示，但你可以控制输出值的字段宽度。像整数和无符号值的字段宽度一样，正数字段宽度会将数字右对齐，而负数字段宽度则将数字左对齐。
- en: 'Here is an example that prints the `XPVar2` variable using 10 print positions:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用10个打印位置打印`XPVar2`变量的示例：
- en: '[PRE59]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you wish to use `stdout.put` to print a floating-point value in decimal
    notation, you need to use the following syntax:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用`stdout.put`以十进制表示法打印浮动点值，你需要使用以下语法：
- en: '[PRE60]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that the *`DecPts`* field must be a nonnegative integer value.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*`DecPts`*字段必须是一个非负整数值。
- en: 'When `stdout.put` contains a parameter of this form, it calls the corresponding
    `stdout.putr`*`XX`* routine to display the specified floating-point value. As
    an example, consider the following call:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当`stdout.put`包含这种形式的参数时，它会调用相应的`stdout.putr`*`XX`*例程来显示指定的浮动点值。例如，考虑以下调用：
- en: '[PRE61]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The corresponding output is:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的输出是：
- en: '[PRE62]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The HLA Standard Library provides several other useful routines you can use
    when outputting floating-point values. Consult the HLA Standard Library reference
    manual for more information on these routines.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: HLA标准库提供了几个其他有用的例程，你可以在输出浮动点值时使用。有关这些例程的更多信息，请参阅HLA标准库参考手册。
- en: 'The HLA Standard Library provides several routines to let you display floating-point
    values in a wide variety of formats. In contrast, the HLA Standard Library provides
    only two routines to support floating-point input: `stdin.getf()` and `stdin.get()`.
    The `stdin.getf()` routine requires the use of the 80x86 FPU stack, a hardware
    component that this chapter doesn''t cover. Therefore, we''ll defer the discussion
    of the `stdin.getf()` routine until [Chapter 6](ch06.html "Chapter 6. ARITHMETIC").
    Because the `stdin.get()` routine provides all the capabilities of the `stdin.getf()`
    routine, this deferral will not be a problem.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: HLA标准库提供了多个例程，允许你以多种格式显示浮动点值。相比之下，HLA标准库仅提供两个例程来支持浮动点输入：`stdin.getf()`和`stdin.get()`。`stdin.getf()`例程需要使用80x86
    FPU堆栈，这是一个本章没有涉及的硬件组件。因此，我们将在[第6章](ch06.html "第6章. 算术")中推迟对`stdin.getf()`例程的讨论。由于`stdin.get()`例程提供了`stdin.getf()`例程的所有功能，这个推迟不会成为问题。
- en: 'You''ve already seen the syntax for the `stdin.get()` routine; its parameter
    list simply contains a list of variable names. The `stdin.get()` function reads
    appropriate values for the user for each of the variables appearing in the parameter
    list. If you specify the name of a floating-point variable, the `stdin.get()`
    routine automatically reads a floating-point value from the user and stores the
    result into the specified variable. The following example demonstrates the use
    of this routine:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过`stdin.get()`例程的语法；它的参数列表仅包含变量名称的列表。`stdin.get()`函数会为每个出现在参数列表中的变量读取相应的值。如果你指定了一个浮动点变量的名称，`stdin.get()`例程会自动从用户处读取一个浮动点值，并将结果存储到指定的变量中。以下示例演示了该例程的使用：
- en: '[PRE63]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Warning
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: This section discussed how you would declare floating-point variables and how
    you would input and output them. It did not discuss arithmetic. Floating-point
    arithmetic is different from integer arithmetic; you cannot use the 80x86 *`add`*
    and *`sub`* instructions to operate on floating-point values. Floating-point arithmetic
    will be the subject of [Chapter 6](ch06.html "Chapter 6. ARITHMETIC").
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: ^([[26](#CHP-2-FN-6)]) Of course, the drawback is that you must now perform
    two multiplications rather than one, so the result may be slower.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: ^([[27](#CHP-2-FN-7)]) There were some minor changes to the way certain degenerate
    operations were handled, but the bit representation remained essentially unchanged.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: ^([[28](#CHP-2-FN-8)]) The binary point is the same thing as the decimal point
    except it appears in binary numbers rather than decimal numbers.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: ^([[29](#CHP-2-FN-9)]) Actually, this isn't necessarily true. The IEEE floating-point
    format supports *denormalized* values where the H.O. bit is not 0\. However, we
    will ignore denormalized values in our discussion.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: ^([[30](#CHP-2-FN-10)]) The alternative would be to underflow the values to
    0.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 2.13 Binary-Coded Decimal Representation
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the integer and floating-point formats cover most of the numeric needs
    of an average program, there are some special cases where other numeric representations
    are convenient. In this section we'll discuss the binary-coded decimal format
    because the 80x86 CPU provides a small amount of hardware support for this data
    representation.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: BCD values are a sequence of nibbles, with each nibble representing a value
    in the range 0..9\. Of course you can represent values in the range 0..15 using
    a nibble; the BCD format, however, uses only 10 of the possible 16 different values
    for each nibble.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Each nibble in a BCD value represents a single decimal digit. Therefore, with
    a single byte (i.e., two digits) we can represent values containing two decimal
    digits, or values in the range 0..99 (see [Figure 2-25](ch02s13.html#cd_data_representation_in_memory
    "Figure 2-25. CD data representation in memory")). With a word, we can represent
    values having four decimal digits, or values in the range 0..9,999\. Likewise,
    with a double word we can represent values with up to eight decimal digits (because
    there are eight nibbles in a double-word value).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '![CD data representation in memory](tagoreillycom20100401nostarchimages577933.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
- en: Figure 2-25. CD data representation in memory
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, BCD storage isn't particularly memory efficient. For example,
    an 8-bit BCD variable can represent values in the range 0..99 while that same
    8 bits, when holding a binary value, can represent values in the range 0..255\.
    Likewise, a 16-bit binary value can represent values in the range 0..65,535, while
    a 16-bit BCD value can represent only about one-sixth of those values (0..9,999).
    Inefficient storage isn't the only problem. BCD calculations tend to be slower
    than binary calculations.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you''re probably wondering why anyone would ever use the BCD
    format. The BCD format does have two saving graces: It''s very easy to convert
    BCD values between the internal numeric representation and their string representation;
    also, it''s very easy to encode multidigit decimal values in hardware (e.g., using
    a thumb wheel or dial) using BCD. For these two reasons, you''re likely to see
    people using BCD in embedded systems (such as toaster ovens, alarm clocks, and
    nuclear reactors) but rarely in general-purpose computer software.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能在想，为什么有人会使用BCD格式。BCD格式确实有两个优点：它可以非常容易地在内部数字表示和字符串表示之间转换BCD值；此外，使用BCD在硬件中（例如，通过旋转按钮或拨轮）编码多位十进制值也非常简单。基于这两个原因，你可能会看到在嵌入式系统中（如烤面包机、闹钟和核反应堆）使用BCD，但在通用计算机软件中却很少见。
- en: A few decades ago people mistakenly thought that calculations involving BCD
    (or just decimal) arithmetic were more accurate than binary calculations. Therefore,
    they would often perform important calculations, like those involving dollars
    and cents (or other monetary units) using decimal-based arithmetic. While it is
    true that certain calculations can produce more accurate results in BCD, this
    statement is not true in general. Indeed, for most calculations (even those involving
    fixed-point decimal arithmetic), the binary representation is more accurate. For
    this reason, most modern computer programs represent all values in a binary form.
    For example, the Intel 80x86 floating-point unit supports a pair of instructions
    for loading and storing BCD values. Internally, however, the FPU converts these
    BCD values to binary and performs all calculations in binary. It uses BCD only
    as an external data format (external to the FPU, that is). This generally produces
    more accurate results and requires far less silicon than having a separate coprocessor
    that supports decimal arithmetic.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，人们错误地认为涉及BCD（或十进制）算术的计算比二进制计算更准确。因此，他们常常使用基于十进制的算术进行重要的计算，如涉及美元和分（或其他货币单位）的计算。虽然某些计算在BCD中可能会得到更精确的结果，但这个说法并不普遍成立。事实上，对于大多数计算（即使是固定点十进制算术的计算），二进制表示更为准确。因此，大多数现代计算机程序都以二进制形式表示所有值。例如，Intel
    80x86浮点单元支持一对加载和存储BCD值的指令。然而，内部上，FPU将这些BCD值转换为二进制并在二进制中执行所有计算。它仅将BCD作为外部数据格式（即外部于FPU）使用。这通常能产生更准确的结果，并且比拥有一个支持十进制算术的独立协处理器需要的硅片要少得多。
- en: 2.14 Characters
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.14 字符
- en: Perhaps the most important data type on a personal computer is the character
    data type. The term *character* refers to a human or machine-readable symbol that
    is typically a nonnumeric entity. In general, the term *character* refers to any
    symbol that you can normally type on a keyboard (including some symbols that may
    require multiple key presses to produce) or display on a video display. Many beginners
    often confuse the terms *character* and *alphabetic character*. These terms are
    not the same. Punctuation symbols, numeric digits, spaces, tabs, carriage returns
    (enter), other control characters, and other special symbols are also characters.
    When this text uses the term *character* it refers to any of these characters,
    not just the alphabetic characters. When this text refers to alphabetic characters,
    it will use phrases like "alphabetic characters," "uppercase characters," or "lowercase
    characters."
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 也许个人计算机上最重要的数据类型是字符数据类型。*字符*一词指的是一个人类或机器可读的符号，通常是一个非数字实体。一般而言，*字符*指的是任何你通常可以在键盘上输入（包括一些可能需要多次按键才能产生的符号）或在视频显示器上显示的符号。许多初学者常常混淆*字符*和*字母字符*这两个术语。这两个术语并不相同。标点符号、数字、空格、制表符、回车符（Enter）、其他控制字符以及其他特殊符号也是字符。当本文使用*字符*一词时，它指的是这些字符中的任何一个，而不仅仅是字母字符。当本文指的是字母字符时，它会使用“字母字符”、“大写字母字符”或“小写字母字符”等表述。
- en: Another common problem beginners have when they first encounter the character
    data type is differentiating between numeric characters and numbers. The character
    `1` is different from the value 1\. The computer (generally) uses two different
    internal representations for numeric characters (`0`, `1`, ..., `9`) versus the
    numeric values 0..9\. You must take care not to confuse the two.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者在第一次接触字符数据类型时，另一个常见的问题是区分数字字符和数字。字符`1`与值1是不同的。计算机（通常）对数字字符（`0`、`1`、...、`9`）和数字值（0到9）使用两种不同的内部表示。你必须小心不要把这两者混淆。
- en: Most computer systems use a 1- or 2-byte sequence to encode the various characters
    in binary form. Windows, Mac OS X, FreeBSD, and Linux certainly fall into this
    category, using either the ASCII or Unicode encodings for characters. This section
    will discuss the ASCII character set and the character declaration facilities
    that HLA provides.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 2.14.1 The ASCII Character Encoding
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ASCII (American Standard Code for Information Interchange) character set
    maps 128 textual characters to the unsigned integer values 0..127 ($0..$7F). Internally,
    of course, the computer represents everything using binary numbers, so it should
    come as no surprise that the computer also uses binary values to represent nonnumeric
    entities such as characters. Although the exact mapping of characters to numeric
    values is arbitrary and unimportant, it is important to use a standardized code
    for this mapping because you will need to communicate with other programs and
    peripheral devices and you need to talk the same "language" as these other programs
    and devices. This is where the ASCII code comes into play; it is a standardized
    code that nearly everyone has agreed on. Therefore, if you use the ASCII code
    65 to represent the character `'A'`, then you know that some peripheral device
    (such as a printer) will correctly interpret this value as the character `'A'`
    whenever you transmit data to that device.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: You should not get the impression that ASCII is the only character set in use
    on computer systems. IBM uses the EBCDIC character set family on many of its mainframe
    computer systems. Another common character set in use is the Unicode character
    set. Unicode is an extension to the ASCII character set that uses 16 bits rather
    than 7 bits to represent characters. This allows the use of 65,536 different characters
    in the character set, allowing the inclusion of most symbols in the world's different
    languages into a single unified character set.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the ASCII character set provides only 128 different characters and
    a byte can represent 256 different values, an interesting question arises: "What
    do we do with the values 128..255 that one could store into a byte?" One answer
    is to ignore those extra values. That will be the primary approach of this text.
    Another possibility is to extend the ASCII character set and add an additional
    128 characters to it. Of course, this would tend to defeat the whole purpose of
    having a standardized character set unless you could get everyone to agree on
    the extensions. That is a difficult task.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: When IBM first created its IBM-PC, it defined these extra 128 character codes
    to contain various non-English alphabetic characters, some line-drawing graphics
    characters, some mathematical symbols, and several other special characters. Because
    IBM's PC was the foundation for what we typically call a PC today, that character
    set has become a pseudo-standard on all IBM-PC compatible machines. Even on modern
    machines, which are not IBM-PC compatible and cannot run early PC software, the
    IBM extended character set survives. Note, however, that this PC character set
    (an extension of the ASCII character set) is not universal. Most printers will
    not print the extended characters when using native fonts, and many programs (particularly
    in non-English-speaking countries) do not use those characters for the upper 128
    codes in an 8-bit value. For these reasons, this text will generally stick to
    the standard 128-character ASCII character set.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that it is a standard, simply encoding your data using standard
    ASCII characters does not guarantee compatibility across systems. While it's true
    that an `'A'` on one machine is most likely an `'A'` on another machine, there
    is very little standardization across machines with respect to the use of the
    control characters. Indeed, of the 32 control codes plus delete, there are only
    four control codes commonly supported—backspace (BS), tab, carriage return (CR),
    and line feed (LF). Worse still, different machines often use these control codes
    in different ways. *End of line* is a particularly troublesome example. Windows,
    MS-DOS, CP/M, and other systems mark end of line by the two-character sequence
    CR/LF. Older Apple Macintosh computers (Mac OS 9 and earlier) and many other systems
    mark the end of a line by a single CR character. Linux, Mac OS X, FreeBSD, and
    other Unix systems mark the end of a line with a single LF character. Needless
    to say, attempting to exchange simple text files between such systems can be an
    experience in frustration. Even if you use standard ASCII characters in all your
    files on these systems, you will still need to convert the data when exchanging
    files between them. Fortunately, such conversions are rather simple.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Despite some major shortcomings, ASCII data is *the* standard for data interchange
    across computer systems and programs. Most programs can accept ASCII data; likewise
    most programs can produce ASCII data. Because you will be dealing with ASCII characters
    in assembly language, it would be wise to study the layout of the character set
    and memorize a few key ASCII codes (e.g., for `'0'`, `'A'`, `'a'`, etc.).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: The ASCII character set is divided into four groups of 32 characters. The first
    32 characters, ASCII codes 0..$1F (31), form a special set of nonprinting characters,
    the *control characters*. We call them control characters because they perform
    various printer/display control operations rather than display symbols. Examples
    include *carriage return*, which positions the cursor to the left side of the
    current line of characters;^([[31](#ftn.CHP-2-FN-11)]) line feed, which moves
    the cursor down one line on the output device; and backspace, which moves the
    cursor back one position to the left. Unfortunately, different control characters
    perform different operations on different output devices. There is very little
    standardization among output devices. To find out exactly how a control character
    affects a particular device, you will need to consult its manual.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: The second group of 32 ASCII character codes contains various punctuation symbols,
    special characters, and the numeric digits. The most notable characters in this
    group include the space character (ASCII code $20) and the numeric digits (ASCII
    codes $30..$39).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: The third group of 32 ASCII characters contains the uppercase alphabetic characters.
    The ASCII codes for the characters `'A'`..`'Z'` lie in the range $41..$5A (65..90).
    Because there are only 26 different alphabetic characters, the remaining 6 codes
    hold various special symbols.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: The fourth, and final, group of 32 ASCII character codes represents the lowercase
    alphabetic symbols, 5 additional special symbols, and another control character
    (delete). Note that the lowercase character symbols use the ASCII codes $61..$7A.
    If you convert the codes for the upper- and lowercase characters to binary, you
    will notice that the uppercase symbols differ from their lowercase equivalents
    in exactly one bit position. For example, consider the character codes for `'E'`
    and `'e'` appearing in [Figure 2-26](ch02s14.html#ascii_codes_for_e_and_e "Figure 2-26. ASCII
    codes for E and e").
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '![ASCII codes for E and e](tagoreillycom20100401nostarchimages577935.png)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
- en: Figure 2-26. ASCII codes for E and e
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: The only place these two codes differ is in bit 5\. Uppercase characters always
    contain a 0 in bit 5; lowercase alphabetic characters always contain a 1 in bit
    5\. You can use this fact to quickly convert between upper- and lowercase. If
    you have an uppercase character, you can force it to lowercase by setting bit
    5 to 1\. If you have a lowercase character and you wish to force it to uppercase,
    you can do so by setting bit 5 to 0\. You can toggle an alphabetic character between
    upper- and lowercase by simply inverting bit 5.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, bits 5 and 6 determine which of the four groups in the ASCII character
    set you're in, as [Table 2-8](ch02s14.html#ascii_groups "Table 2-8. ASCII Groups")
    shows.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-8. ASCII Groups
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '| Bit 6 | Bit 5 | Group |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | Control characters |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | Digits and punctuation |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | Uppercase and special |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | Lowercase and special |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
- en: So you could, for instance, convert any upper- or lowercase (or corresponding
    special) character to its equivalent control character by setting bits 5 and 6
    to 0.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Consider, for a moment, the ASCII codes of the numeric digit characters appearing
    in [Table 2-9](ch02s14.html#ascii_codes_for_numeric_digits "Table 2-9. ASCII Codes
    for Numeric Digits").
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-9. ASCII Codes for Numeric Digits
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Decimal | Hexadecimal |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
- en: '| 0 | 48 | $30 |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
- en: '| 1 | 49 | $31 |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
- en: '| 2 | 50 | $32 |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
- en: '| 3 | 51 | $33 |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
- en: '| 4 | 52 | $34 |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
- en: '| 5 | 53 | $35 |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
- en: '| 6 | 54 | $36 |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
- en: '| 7 | 55 | $37 |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
- en: '| 8 | 56 | $38 |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
- en: '| 9 | 57 | $39 |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
- en: The decimal representations of these ASCII codes are not very enlightening.
    However, the hexadecimal representation of these ASCII codes reveals something
    very important—the L.O. nibble of the ASCII code is the binary equivalent of the
    represented number. By stripping away (i.e., setting to 0) the H.O. nibble of
    a numeric character, you can convert that character code to the corresponding
    binary representation. Conversely, you can convert a binary value in the range
    0..9 to its ASCII character representation by simply setting the H.O. nibble to
    3\. Note that you can use the logical `and` operation to force the H.O. bits to
    0; likewise, you can use the logical `or` operation to force the H.O. bits to
    %0011 (3).
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you *cannot* convert a string of numeric characters to their equivalent
    binary representation by simply stripping the H.O. nibble from each digit in the
    string. Converting 123 ($31 $32 $33) in this fashion yields 3 bytes: $010203;
    the correct value for 123 is $7B. Converting a string of digits to an integer
    requires more sophistication than this; the conversion above works only for single
    digits.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 2.14.2 HLA Support for ASCII Characters
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you could easily store character values in `byte` variables and use
    the corresponding numeric equivalent ASCII code when using a character literal
    in your program, such agony is unnecessary. HLA provides support for character
    variables and literals in your assembly language programs.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'Character literal constants in HLA take one of two forms: a single character
    surrounded by apostrophes or a hash mark (`#`) followed by a numeric constant
    in the range 0..127 (specifying the ASCII code of the character). Here are some
    examples:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that these examples all represent the same character (`'A'`) because the
    ASCII code of `'A'` is 65.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'With one exception, only a single character may appear between the apostrophes
    in a literal character constant. That single exception is the apostrophe character
    itself. If you wish to create an apostrophe literal constant, place four apostrophes
    in a row (i.e., double up the apostrophe inside the surrounding apostrophes):'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The hash mark operator (`#`) must precede a legal HLA numeric constant (either
    decimal, hexadecimal, or binary, as the examples above indicate). In particular,
    the hash mark is not a generic character conversion function; it cannot precede
    registers or variable names, only constants.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, you should always use the apostrophe form of the character
    literal constant for graphic characters (that is, those that are printable or
    displayable). Use the hash mark form for control characters (that are invisible
    or do funny things when you print them) or for extended ASCII characters that
    may not display or print properly within your source code.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Notice the difference between a character literal constant and a string literal
    constant in your programs. Strings are sequences of zero or more characters surrounded
    by quotation marks; characters are surrounded by apostrophes.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: It is especially important to realize that
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The character constant `'A'` and the string containing the single character
    `A` have two completely different internal representations. If you attempt to
    use a string containing a single character where HLA expects a character constant,
    HLA will report an error. Strings and string constants are the subject of [Chapter 4](ch04.html
    "Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES").
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a character variable in an HLA program, you use the `char` data
    type. For example, the following declaration demonstrates how to declare a variable
    named `UserInput`:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This declaration reserves 1 byte of storage that you could use to store any
    character value (including 8-bit extended ASCII characters). You can also initialize
    character variables as the following example demonstrates:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Because character variables are 8-bit objects, you can manipulate them using
    8-bit registers. You can move character variables into 8-bit registers, and you
    can store the value of an 8-bit register into a character variable.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library provides a handful of routines that you can use for
    character I/O and manipulation; these include `stdout.putc`, `stdout.putcSize`,
    `stdout.put`*,* `stdin.getc`*,* and `stdin.get`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'The `stdout.putc` routine uses the following calling sequence:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This procedure outputs the single-character parameter passed to it as a character
    to the standard output device. The parameter may be any `char` constant or variable,
    or a `byte` variable or register.^([[32](#ftn.CHP-2-FN-12)])
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: The `stdout.putcSize` routine provides output width control when displaying
    character variables. The calling sequence for this procedure is
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This routine prints the specified character (parameter `c`) using at least *`widthInt32`*
    print positions.^([[33](#ftn.CHP-2-FN-13)]) If the absolute value of *`widthInt32`*
    is greater than 1, then `stdout.putcSize` prints the *`fillchar`* character as
    padding. If the value of *`widthInt32`* is positive, then `stdout.putcSize` prints
    the character right justified in the print field; if *`widthInt32`* is negative,
    then `stdout.putcSize` prints the character left justified in the print field.
    Because character output is usually left justified in a field, the *`widthInt32`*
    value will normally be negative for this call. The space character is the most
    common *`fillchar`* value.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also print character values using the generic `stdout.put` routine.
    If a character variable appears in the `stdout.put` parameter list, then `stdout.put`
    will automatically print it as a character value. For example:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can read characters from the standard input using the `stdin.getc` and `stdin.get`
    routines. The `stdin.getc` routine does not have any parameters. It reads a single
    character from the standard input buffer and returns this character in the AL
    register. You may then store the character value away or otherwise manipulate
    the character in the AL register. The program in [Example 2-10](ch02s14.html#character_input_sample
    "Example 2-10. Character input sample") reads a single character from the user,
    converts it to uppercase if it is a lowercase character, and then displays the
    character.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10. Character input sample
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You can also use the generic `stdin.get` routine to read character variables
    from the user. If a `stdin.get` parameter is a character variable, then the `stdin.get`
    routine will read a character from the user and store the character value into
    the specified variable. [Example 2-11](ch02s14.html#stdin.get_character_input_sample
    "Example 2-11. stdin.get character input sample") is a rewrite of [Example 2-10](ch02s14.html#character_input_sample
    "Example 2-10. Character input sample") using the `stdin.get` routine.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11. `stdin.get` character input sample
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you may recall from the last chapter, the HLA Standard Library buffers its
    input. Whenever you read a character from the standard input using `stdin.getc`
    or `stdin.get`, the library routines read the next available character from the
    buffer; if the buffer is empty, then the program reads a new line of text from
    the user and returns the first character from that line. If you want to guarantee
    that the program reads a new line of text from the user when you read a character
    variable, you should call the `stdin.flushInput` routine before attempting to
    read the character. This will flush the current input buffer and force the input
    of a new line of text on the next input (probably a `stdin.getc` or `stdin.get`
    call).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: The end of line is problematic. Different operating systems handle the end of
    line differently on output versus input. From the console device, pressing the
    **enter** key signals the end of a line; however, when reading data from a file,
    you get an end-of-line sequence that is a linefeed or a carriage return/line feed
    pair (under Windows) or just a line feed (under Linux/Mac OS X/FreeBSD). To help
    solve this problem, HLA's Standard Library provides an "end of line" function.
    This procedure returns true (1) in the AL register if all the current input characters
    have been exhausted; it returns false (0) otherwise. The sample program in [Example 2-12](ch02s14.html#testing_for_end_of_line_using_stdin.eoln
    "Example 2-12. Testing for end of line using stdin.eoln") demonstrates the `stdin.eoln`
    function.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12. Testing for end of line using `stdin.eoln`
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The HLA language and the HLA Standard Library provide many other procedures
    and additional support for character objects. [Chapter 4](ch04.html "Chapter 4. CONSTANTS,
    VARIABLES, AND DATA TYPES") and [Chapter 11](ch11.html "Chapter 11. THE STRING
    INSTRUCTIONS"), as well as the HLA reference documentation, describe how to use
    these features.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: ^([[31](#CHP-2-FN-11)]) Historically, carriage return refers to the *paper carriage*
    used on typewriters. A carriage return consisted of physically moving the carriage
    all the way to the right so that the next character typed would appear at the
    left-hand side of the paper.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: ^([[32](#CHP-2-FN-12)]) If you specify a byte variable or a byte-sized register
    as the parameter, the `stdout.putc` routine will output the character whose ASCII
    code appears in the variable or register.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: ^([[33](#CHP-2-FN-13)]) The only time `stdout.putcSize` uses more print positions
    than you specify is when you specify 0 as the width; then this routine uses exactly
    one print position.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 2.15 The Unicode Character Set
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the ASCII character set is, unquestionably, the most popular character
    representation on computers, it is certainly not the only format around. For example,
    IBM uses the EBCDIC code on many of its mainframe and minicomputer lines. Because
    EBCDIC appears mainly on IBM''s big iron and you''ll rarely encounter it on personal
    computer systems, we will not consider that character set in this text. Another
    character representation that is becoming popular on small computer systems (and
    large ones, for that matter) is the Unicode character set. Unicode overcomes two
    of ASCII''s greatest limitations: the limited character space (i.e., a maximum
    of 128/256 characters in an 8-bit byte) and the lack of international (beyond
    the United States) characters.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Unicode uses a 16-bit word to represent a single character. Therefore, Unicode
    supports up to 65,536 different character codes. This is obviously a huge advance
    over the 256 possible codes we can represent with an 8-bit byte. Unicode is upward
    compatible from ASCII. Specifically, if the H.O. 9 bits of a Unicode character
    contain 0, then the L.O. 7 bits represent the same character as the ASCII character
    with the same character code. If the H.O. 9 bits contain some nonzero value, then
    the character represents some other value. If you're wondering why so many different
    character codes are necessary, simply note that certain Asian character sets contain
    4,096 characters (at least their Unicode subset does).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: This text will stick to the ASCII character set except for a few brief mentions
    of Unicode here and there. Eventually, this text may have to eliminate the discussion
    of ASCII in favor of Unicode because many new operating systems are using Unicode
    internally (and converting to ASCII as necessary). Unfortunately, many string
    algorithms are not as conveniently written for Unicode as for ASCII (especially
    character set functions), so we'll stick with ASCII in this text as long as possible.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: 2.16 For More Information
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The electronic edition of this book (on Webster at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://artofasm.com/](http://artofasm.com/)) contains some additional information
    on data representation you may find useful. For general information about data
    representation, you should consider reading my book *Write Great Code, Volume
    1* (No Starch Press, 2004), or a textbook on data structures and algorithms (available
    at any bookstore).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
