- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: BEFUNGE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: BEFUNGE
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: Like Piet, Befunge is a 2D programming language. Befunge is fun, is not particularly
    difficult to work with, and produces some of the most aesthetically pleasing source
    code I’ve ever seen. I think you’ll agree by the end of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Piet 一样，Befunge 是一种二维编程语言。Befunge 很有趣，使用起来不算特别难，而且生成的源代码是我见过的最具美学感的代码之一。我想到最后你也会同意这一点。
- en: Our goal is to learn and experiment with Befunge. After BF, it’s perhaps the
    most influential esolang, and is usually included in lists with titles like “Ten
    of the weirdest programming languages you’ve never heard of.” We’ll learn why
    Befunge exists and why it’s called Befunge. We’ll then follow our usual pattern
    of exploring the gist of the language with examples. We’ll conclude with a discussion.
    I hope this marks only the beginning of your Befunge experiments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是学习并实验 Befunge。紧随 BF 之后，它可能是最具影响力的另类编程语言之一，通常出现在诸如“你从未听说过的十大最奇怪编程语言”的列表中。我们将了解
    Befunge 存在的原因以及它为何被称为 Befunge。然后，我们将按照惯例，通过示例探索语言的要点。最后，我们将进行讨论。我希望这仅仅是你进行 Befunge
    实验的开始。
- en: '**Befunge-93 World Tour**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Befunge-93 世界之旅**'
- en: In 1993, the movie *Jurassic Park* brought dinosaurs to the big screen, Mulder
    and Scully were chasing aliens on TV, and Bill Clinton was beginning his first
    term as president. In 1993, a typical home computer cost about $1,800 in 2022
    dollars, had around 4MB of RAM, a 16 MHz clock speed, a 20MB hard drive, and a
    “high-density” 1.44MB floppy drive. And, most notably for us, in 1993, Chris Pressey
    gifted Befunge to the world.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 1993 年，电影 *侏罗纪公园* 将恐龙带上了大银幕，Mulder 和 Scully 在电视上追逐外星人，Bill Clinton 开始了他的总统任期。1993
    年，一台典型的家用电脑大约价值 1,800 美元（按 2022 年的货币价值计算），拥有约 4MB 的内存，16 MHz 的时钟速度，20MB 的硬盘和一个“高密度”
    1.44MB 的软盘驱动器。而最值得我们注意的是，1993 年，Chris Pressey 将 Befunge 赠送给了世界。
- en: Depending on how you view things, Befunge was the world’s first 2D programming
    language. One might argue that Konrad Zuse’s *Plankalkül* was the first because
    its source code included stacked commands, but I think Befunge’s approach is sufficiently
    different to claim the honor. Pressey’s intention for Befunge was to create a
    language that was as difficult to compile as possible. The “Befunge” name is a
    misspelling of “before” as typed on a BBS in the wee hours of the morning. If
    the term BBS is unfamiliar, it stands for “bulletin board system,” which was how
    early personal computer enthusiasts communicated with each other over slow modems
    before the internet became accessible to the general public.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据不同的视角，Befunge 被认为是世界上第一个二维编程语言。有人可能会争辩说，Konrad Zuse 的 *Plankalkül* 才是第一个，因为它的源代码包含了堆叠命令，但我认为
    Befunge 的方法与众不同，足以获得这个荣誉。Pressey 创建 Befunge 的初衷是打造一种尽可能难以编译的语言。“Befunge”这个名字是“before”的拼写错误，发生在凌晨时分的
    BBS 上。如果你不熟悉 BBS，它代表“公告板系统”，那是早期个人电脑爱好者通过慢速调制解调器在互联网普及之前相互交流的方式。
- en: Let’s dive into the world of Befunge to learn how it works and how to write
    code for it. We’ll begin by installing and building the canonical interpreter
    for Befunge-93, after which we’ll take it for a ride with some simple examples.
    Along the way, we’ll learn how to use BEdit, a Befunge-93 editor. You don’t need
    to use BEdit to write Befunge code—any text editor will do—but I found BEdit handy.
    Then again, I wrote it, so I’m biased.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨 Befunge 的世界，了解它是如何工作的以及如何编写 Befunge 代码。我们将从安装和构建 Befunge-93 的标准解释器开始，然后通过一些简单的示例来体验它。在这个过程中，我们还将学习如何使用
    BEdit，一个 Befunge-93 编辑器。你不必非得使用 BEdit 来编写 Befunge 代码——任何文本编辑器都可以——但我发现 BEdit 很方便。说实话，我就是写了它，所以有点偏见。
- en: '***Building Befunge-93***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建 Befunge-93***'
- en: Run the following command to obtain Befunge-93 from creator Chris Pressey’s
    GitHub site.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令从创始人 Chris Pressey 的 GitHub 网站获取 Befunge-93。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will get you the latest version, most likely the Silver Jubilee version
    from 2018\. That’s the version we’ll work with.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助你获取最新版本，很可能是2018年的银禧版。我们将使用这个版本。
- en: Building the Befunge interpreter is straightforward. However, before you build
    it, if you wish, I suggest making a small code change to initialize the pseudorandom
    number seed using `/dev/urandom` instead of using `time`, which is how it’s written.
    That way, if you run the interpreter many times within a second, which we’ll do
    later in the chapter, the pseudorandom generator will not produce the same sequence
    repeatedly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Befunge解释器是简单的。然而，在构建之前，如果你愿意，我建议做一个小小的代码修改，使用`/dev/urandom`来初始化伪随机数种子，而不是使用`time`，这是原本的写法。这样，如果你在一秒钟内多次运行解释器，正如我们稍后在本章中要做的那样，伪随机生成器就不会重复产生相同的序列。
- en: 'I suggest the following steps to build `bef`, the Befunge interpreter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议按照以下步骤构建`bef`，Befunge解释器：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The second command starts a text editor with *bef.c* open. If you don’t use
    `vi` or `vim`, make the appropriate substitution for your typical editor (then
    learn `vim`). Look for `srand`, which should be around line 252\. Then replace
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令会启动一个文本编辑器并打开*bef.c*。如果你不使用`vi`或`vim`，请为你常用的编辑器做适当的替换（然后学习`vim`）。查找`srand`，它应该在第252行左右。然后替换：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: with
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lastly, use `make` to build the interpreter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`make`来构建解释器。
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We want the *bef* executable in the *bin* directory. I encountered no issues
    using `gcc` and suspect you won’t, either. Change to the *bin* directory and test
    the build by typing
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`bef`可执行文件位于*bin*目录下。我使用`gcc`时没有遇到问题，猜测你也不会。切换到*bin*目录并通过输入以下命令来测试构建：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Befunge is simple to use. We’ll explore its visual debugger, `-d`, later. You’ll
    probably want to use `-q` to suppress the startup message. I defined an alias:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge很容易使用。稍后我们会探索它的可视调试器`-d`。你可能会想使用`-q`来抑制启动信息。我定义了一个别名：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Befunge is ready. Let’s see how to use it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge准备好了。我们来看看如何使用它。
- en: '***Printing Text***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***打印文本***'
- en: 'Befunge programs live on a playfield that is 80 characters across and 25 lines
    tall. All Befunge commands are a single character. For data, Befunge uses a stack,
    like Forth. Befunge even supports a few Forth primitives to manipulate the stack:
    `DUP`, `DROP`, and `SWAP`. Of all the esolangs we’ve explored, Befunge has the
    richest command set.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge程序运行在一个80字符宽，25行高的游戏区域内。所有Befunge指令都是单个字符。数据部分，Befunge使用一个堆栈，像Forth一样。Befunge甚至支持一些Forth原语来操作堆栈：`DUP`、`DROP`和`SWAP`。在我们探索过的所有异构语言中，Befunge拥有最丰富的指令集。
- en: 'The best way to get into Befunge is to see it in action. Let’s start with *cow.bf*
    . First, we’ll run it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的入门方式是亲眼看看Befunge如何运作。让我们从*cow.bf*开始。首先，我们运行它：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I agree, nothing too impressive. Let’s look at the code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意，这没什么令人印象深刻的。我们来看一下代码。
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Okay, now things are a little more interesting. What are we to make of this
    jumble of characters? Befunge programs, like Piet programs, run in all directions,
    beginning in the upper-left corner (row 0, column 0), with the instruction pointer
    to the right, meaning instructions are evaluated from left to right running along
    the row.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在事情变得更有趣了。我们该如何理解这一堆字符呢？Befunge程序像Piet程序一样可以在各个方向上运行，程序从左上角（第0行，第0列）开始，指令指针指向右侧，这意味着指令从左到右沿着行进行求值。
- en: 'The first row of *cow.bf* is `<v"How now brown cow?"0`. The first instruction
    is `<`, which tells Befunge to change the instruction pointer to move to the left.
    The playfield wraps at the edges and ignores spaces. Therefore, the first instruction
    of *cow.bf* moves flow to the left, which wraps around, ignores spaces, and encounters
    `0` moving right to left. Befunge pushes digits onto the stack, so `0` pushes
    a 0 on the stack. The next instruction is the double quote (`"`), which begins
    string mode. The interpreter then pushes ASCII values of the characters onto the
    stack until it encounters the next double quote. Therefore, the string `How now
    brown cow?` is pushed on the stack in ASCII, one character at a time. However,
    program flow in Befunge moves right to left, so the string is pushed on the stack
    *backward*, starting with the question mark first and ending with `H`. But this
    is exactly what we want because stacks are LIFO data structures. We now have our
    first Befunge idiom: push strings on the stack from right to left so the string
    can be read in code from left to right.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*cow.bf* 的第一行是 `<v"How now brown cow?"0`。第一个指令是 `<`，它告诉Befunge将指令指针移到左侧。游戏场景在边缘处会进行环绕，并且会忽略空格。因此，*cow.bf*
    的第一个指令将流动方向向左移动，并环绕，忽略空格，并遇到 `0` 向右到左移动。Befunge 会将数字推入栈中，所以 `0` 会将 0 推入栈中。下一个指令是双引号
    (`"`)，它开始字符串模式。解释器随后将字符的 ASCII 值推入栈中，直到遇到下一个双引号。因此，字符串 `How now brown cow?` 会以
    ASCII 码的形式一个字符一个字符地被推入栈中。然而，Befunge 的程序流是从右到左的，所以字符串会以 *反向* 的顺序被推入栈中，从问号开始，最后是
    `H`。但这正是我们想要的，因为栈是后进先出（LIFO）数据结构。我们现在有了第一个 Befunge 习惯用法：将字符串从右到左推入栈中，这样字符串可以从左到右在代码中读取。'
- en: The character after the leftmost double quote is `v`, which changes program
    flow to down. The very next instruction is `>`, which changes the flow to the
    right again. Then comes `:`, which duplicates the top stack value, the ASCII code
    for `H`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最左侧的双引号后的字符是 `v`，它将程序流改为向下。紧接着的指令是 `>`，它再次将程序流改为向右。接下来是 `:`，它将栈顶的值复制一份，即 `H`
    的 ASCII 码。
- en: Program flow is again directed down by `v` to hit underscore (_), the first
    of Befunge’s two conditional commands. The _ command pops the top stack item and,
    if it is 0, changes program flow to the right; otherwise, it goes left. If the
    top stack item is 0, we want to end, as the string has been printed. Recall that
    the first instruction after `<` in the upper left pushed 0 on the stack.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 程序流再次被 `v` 指令引导向下，触发下划线符号（_），这是 Befunge 的两个条件指令之一。`_` 指令弹出栈顶项目，如果它是 0，则将程序流改为向右；否则，向左。如果栈顶项目是
    0，我们希望结束程序，因为字符串已经被打印出来。回想一下，`<` 后的第一条指令在左上角将 0 推入栈中。
- en: If the top stack item isn’t 0, the string hasn’t been entirely printed yet.
    Therefore, moving to the left from _ uses a comma (`,`) to print the character
    and change the program flow to up. Going up hits `>` on the second line to start
    the loop again.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈顶项目不是 0，则字符串尚未完全打印。因此，从 `_` 向左移动时，使用逗号（`,`）打印字符并将程序流改为向上。向上移动触发第二行的 `>`，使程序流再次向右。
- en: The _ command encounters the 0 initially pushed on the stack at the beginning
    of the program. This will direct flow to the right to execute `91+,@`. The first
    three commands push the digits 9 and 1 onto the stack and add the digits so the
    stack contains 10\. Even though only single digits can be pushed onto the stack
    in code, the stack itself supports a signed 64-bit integer. With 10 on the stack,
    we hit `,` to print the top stack item as an ASCII character—in this case, a newline.
    To end a Befunge program, execute `@`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`_` 指令遇到了程序开始时最初推入栈的 0。这将把程序流引导向右，执行 `91+,@`。前几个命令将数字 9 和 1 推入栈中并相加，使栈中包含 10。尽管在代码中栈只能推入单个数字，但栈本身支持有符号的
    64 位整数。当栈中有 10 时，我们执行 `,`，将栈顶的项目作为 ASCII 字符输出—在此案例中是换行符。要结束一个Befunge程序，执行 `@`。'
- en: 'We now understand how *cow.bf* works. With all this flowing left, right, up,
    and down, it would be nice to *see cow.bf* working. Thankfully, Befunge is cleverly
    made, and by using the `-d` command line option, we can, literally, watch program
    flow happen. This works best when any output is directed to a file. Similarly,
    if there is input from the user, it’s best read from a file. Naturally, a static
    book cannot show you the flow of the program, but the following command will:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了 *cow.bf* 的工作原理。随着这些流动的左、右、上和下，最好能 *看到 cow.bf* 正在工作。幸运的是，Befunge 非常巧妙，通过使用
    `-d` 命令行选项，我们可以字面上看到程序流的变化。这在任何输出被定向到文件时效果最佳。同样地，如果有用户输入，最好从文件中读取。显然，静态书籍无法向你展示程序的流动，但以下命令可以做到：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once you press ENTER you’ll see the source code at the top of the screen with
    a cursor flowing over each instruction as it is executed. You can watch the loop
    repeat to print each character on the stack before ending. The output is then
    written to the temporary file, *ttt*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 后，你会看到屏幕顶部显示源代码，并且光标会在每条指令执行时流动。你可以看到循环重复，打印栈上的每个字符，直到结束。然后，输出会写入临时文件，*ttt*。
- en: '***Using BEdit***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 BEdit***'
- en: How was *cow.bf* created? You could use a normal text editor, but I used *bedit.py*,
    a simple Befunge editor created in Python. We won’t discuss the code, but do take
    a look if you are curious. Note that the terminal window in which you run *bedit.py*
    must be at least 120 characters wide and 26 lines tall. If not, *bedit.py* will
    happily remind you.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*cow.bf* 是如何创建的？你可以使用普通的文本编辑器，但我用了 *bedit.py*，一个用 Python 创建的简单 Befunge 编辑器。我们不讨论代码，但如果你感兴趣的话可以看看。注意，你运行
    *bedit.py* 的终端窗口必须至少宽 120 个字符，高 26 行。如果不符合要求，*bedit.py* 会愉快地提醒你。'
- en: Executing `python3 bedit.py examples/cow.bf` produces [Figure 11-1](ch11.xhtml#ch011fig1).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `python3 bedit.py examples/cow.bf` 会生成 [图 11-1](ch11.xhtml#ch011fig1)。
- en: '![Image](Images/11fig01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/11fig01.jpg)'
- en: '*Figure 11-1: Editing* cow.bf'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：编辑* cow.bf'
- en: The editor has two panes. On the left is a pane of 80×25 characters. This is
    the Befunge playfield where code goes. On the right is a summary of the editor
    and Befunge commands for reference. To move around the code, use the arrow keys.
    Any character you enter will go where the cursor currently is. To make entering
    code easier, typing characters moves in the direction of the last arrow key. Therefore,
    to type from right to left, move the cursor to the left with the left arrow key
    and begin typing. A bit of experimentation is all it takes to get the hang of
    it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器有两个面板。左边是 80×25 字符的面板，这是 Befunge 的工作区，代码会写在这里。右边是编辑器和 Befunge 命令的总结，供参考。要在代码中移动，使用箭头键。你输入的任何字符都会进入光标所在的位置。为了便于输入代码，输入字符时光标会朝最后一次按下的箭头键方向移动。因此，要从右到左输入，先按左箭头将光标移动到左边，然后开始输入。只需要稍微试验一下，就能掌握它。
- en: Use CTRL-W to write the file and CTRL-E to exit, which will also write the file
    if it has been modified. You must supply the name of the file on the command line,
    whether new or not. Pressing CTRL-H clears the current row from the cursor to
    the right edge. Likewise, CTRL-V clears the current column from the cursor down.
    That’s it; the editor is simple, but I used it to create all the examples in this
    chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CTRL-W 保存文件，使用 CTRL-E 退出，如果文件被修改过，退出时也会保存文件。你必须在命令行中提供文件名，无论是新文件还是旧文件。按下
    CTRL-H 会清除从光标到右边缘的当前行。同样，CTRL-V 会清除从光标到下方的当前列。就是这些；编辑器很简单，但我用它创建了本章中的所有示例。
- en: '***Befunge Says Hello***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Befunge 打招呼***'
- en: Before we get to genuinely interesting, or at least illustrative, Befunge programs,
    we must look at our obligatory example. Run *hello.bf* to see our favorite greeting.
    Then, bring it up in BEdit to look at the code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入真正有趣，或者至少有示范性的 Befunge 程序之前，我们必须看一个必备的示例。运行 *hello.bf* 查看我们的最爱问候语。然后，打开它在
    BEdit 中查看代码。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is one of the more unusual examples of “Hello, world!” we’ve yet seen.
    Note that anywhere the program doesn’t go is fair game for comments, like the
    one on the second line (line 1, counting from 0). We’ll count lines from 0 because
    that’s how computer people count. See if you can figure out how this version works
    (hint: think characters, not strings). It’s not tricky, just unusual because of
    Befunge’s 2D program flow. Because Befunge can’t directly push numbers larger
    than 9 on the stack, larger values must be calculated piece by piece.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们见过的更为独特的“Hello, world!”示例之一。注意，程序不去的地方是可以用来写注释的，比如第二行（从 0 开始计数）的注释。我们会从
    0 开始计数，因为计算机界的人都是这么计数的。看看你能不能猜出这个版本是如何工作的（提示：想想字符，而不是字符串）。这并不复杂，只是由于 Befunge 的
    2D 程序流程而显得不寻常。因为 Befunge 不能直接将大于 9 的数字推送到栈上，所以较大的数值必须逐步计算。
- en: '[Table 11-1](ch11.xhtml#ch011tab1) lists Befunge’s commands.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-1](ch11.xhtml#ch011tab1) 列出了 Befunge 的命令。'
- en: '**Table 11-1:** The Befunge-93 Command Set'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-1：** Befunge-93 命令集'
- en: '| **Command** | **Description** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0`–`9` | Push a digit |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `0`–`9` | 输入一个数字 |'
- en: '| `+-*/%` | `( a b -- a op b )` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `+-*/%` | `( a b -- a op b )` |'
- en: '| `!` | `( a -- !a )` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `!` | `( a -- !a )` |'
- en: '| ` | `( a b -- a>b )` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| ` | `( a b -- a>b )` |'
- en: '| `><^v` | Set instruction pointer direction |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `><^v` | 设置指令指针方向 |'
- en: '| `?` | Pointer to random direction |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 指向随机方向 |'
- en: '| `_` | Pop; 0 = right, else left |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `_` | 弹出；0 = 右，其他为左 |'
- en: '| `&#124;` | Pop; 0 = down, else up |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 弹出；0 = 下，其他为上 |'
- en: '| `"` | Push string |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `"` | 压入字符串 |'
- en: '| `:` | `( a -- a a )` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `:` | `( a -- a a )` |'
- en: '| `\` | `( a b -- b a )` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `\` | `( a b -- b a )` |'
- en: '| `$` | `( a -- )` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `$` | `( a -- )` |'
- en: '| `.` | Pop; print as integer |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 弹出；作为整数打印 |'
- en: '| `,` | Pop; print as char |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 弹出；作为字符打印 |'
- en: '| `#` | Skip next cell (bridge) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `#` | 跳过下一个单元（桥接） |'
- en: '| `p` | `( v c r -- )` play[r,c] = v |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `p` | `( v c r -- )` play[r,c] = v |'
- en: '| `g` | `( c r -- )` push play[r,c] |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `g` | `( c r -- )` 压入 play[r,c] |'
- en: '| `&` | Input number; push |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 输入数字；压入栈 |'
- en: '| `~` | Input char; push |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 输入字符；压入栈 |'
- en: '| `@` | Exit program |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `@` | 退出程序 |'
- en: Most commands are easy to understand, but a few, like `#`, `?`, `p`, and `g`,
    are less clear and are the focus of the examples that follow. Note the use of
    Forth-style stack effect comments where appropriate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数命令很容易理解，但有一些命令，如 `#`、`?`、`p` 和 `g`，比较不直观，以下的示例将专门讲解这些命令。注意适当使用类似Forth语言风格的栈效果注释。
- en: '**Befunge in Action**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Befunge的应用**'
- en: The Befunge-93 repository includes many examples in the *eg* directory. That
    said, with one exception mentioned in the discussion, we’ll roll our own examples
    in this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge-93的代码库中包含了许多位于 *eg* 目录下的示例。尽管如此，除了讨论中提到的一个例外，我们将在本章中自己编写示例。
- en: Specifically, we’ll explore what makes Befunge unique. Naturally, a 2D language
    is unusual, but I find other parts of the language even more interesting in terms
    of thinking about coding.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别探讨Befunge的独特之处。自然，二维语言就很不常见，但我认为该语言的其他部分在编码思维方面更加有趣。
- en: However, first we must explore flow control and, at the same time, how input
    works. Doing this leaves us well situated to explore other language features.
    After flow control, we’ll explore Befunge’s `#` bridge command, which might seem
    unnecessary at first, but it is really quite clever. After that comes `?`, Befunge’s
    version of a pseudorandom number generator. We close the section with `p` and
    `g`, which enable both data storage in program space and self-modifying code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首先我们必须探索流程控制，同时也要了解输入是如何工作的。完成这部分后，我们就可以顺利地探索语言的其他特性。在流程控制之后，我们将探讨Befunge的
    `#` 桥接命令，初看似乎没什么用，但实际上它非常巧妙。接下来是 `?`，Befunge的伪随机数生成器。最后，我们用 `p` 和 `g` 结束这一部分，它们使得数据可以存储在程序空间中并支持自修改代码。
- en: '***Going with the Flow***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跟随流程***'
- en: Flow control in Piet ([Chapter 9](ch09.xhtml#ch09)) was accomplished by setting
    up barriers. Befunge makes life easier by explicitly selecting new directions
    through the playfield, as we saw above with *cow.bf* and *hello.bf* .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Piet中的流程控制（[第9章](ch09.xhtml#ch09)）是通过设置障碍来实现的。Befunge通过显式选择新的方向来简化流程控制，就像我们在
    *cow.bf* 和 *hello.bf* 中看到的那样。
- en: Let’s work through two examples to improve our understanding of flow in Befunge.
    The first example converts a string of binary digits to decimal. The second converts
    text files using DOS line endings to Unix format.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过两个示例来加深对Befunge中流程的理解。第一个示例将一串二进制数字转换为十进制。第二个示例将使用DOS行结束符的文本文件转换为Unix格式。
- en: '**Binary to Decimal**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**二进制转十进制**'
- en: One approach to converting a binary number to decimal is to add the binary digit,
    from left to right, to a running total initialized to 0, then multiply by 2\.
    When all the digits have been processed, divide by 2 to get the final value. Division
    by 2 is necessary because multiplying by 2 sets up for the next digit; however,
    there is no next digit after the last digit is read.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制数转换为十进制的一种方法是，从左到右依次将二进制数字加到一个初始为0的运行总和上，然后乘以2。当所有数字处理完后，除以2得到最终值。除以2是必要的，因为乘以2是为了为下一个数字做准备；然而，在读取完最后一个数字后，就没有下一个数字了。
- en: For example, if the input is 1101[2], we get the decimal equivalent as
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果输入是 1101[2]，我们得到的十进制等效值是
- en: ((((((((0 + 1) × 2) + 1) × 2) + 0) × 2) + 1) × 2) ÷ 2 = 13
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ((((((((0 + 1) × 2) + 1) × 2) + 0) × 2) + 1) × 2) ÷ 2 = 13
- en: We’ll use the stack to hold the running total; therefore, the first thing we
    need on the stack is a 0\. Then, we’ll begin a loop to read a character, subtract
    48 to make it a 0 or 1, add it to the running total, and then multiply by 2\.
    When all binary digits are read, divide by 2, print the top stack item as a decimal,
    and exit. Simple.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用栈来保存运行总和；因此，首先需要在栈上放一个0。然后，我们开始一个循环，读取一个字符，减去48使其变为0或1，添加到运行总和中，然后乘以2。当所有二进制数字读取完后，除以2，打印栈顶项作为十进制数，并退出。很简单。
- en: Well, not quite. How do we know all the binary digits have been read? One of
    two things will happen, both of which affect the value of the input character
    read. If the character is a newline, ASCII 10, then we know input is complete.
    Also, if reading from a file, the input might be end-of-file (EOF), which Befunge
    reports as *–*1\. Therefore, we’ll need to check for both cases.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，差不多。我们怎么知道所有二进制数字都已读取完毕呢？会发生两种情况，其中任何一种都会影响所读取的输入字符的值。如果字符是换行符，ASCII值为10，那么我们知道输入已经完成。另外，如果从文件中读取，输入可能是文件结尾（EOF），Befunge将其报告为*–*1。因此，我们需要检查这两种情况。
- en: '[Listing 11-1](ch11.xhtml#ch011list1) presents *bin2dec.bf* .'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-1](ch11.xhtml#ch011list1)展示了*bin2dec.bf*。'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 11-1: Converting binary strings to decimal*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-1：将二进制字符串转换为十进制*'
- en: 'This code is fairly compact with only four lines of code. The first line begins
    with `0v` to push 0 on the stack and move down. The next instruction is `>` to
    move again to the right. At this point, we want to read a binary digit and check
    if it’s a newline: `~:55+-|`. The first character (tilde) reads the binary digit
    as a character and places it on the stack. The second character (colon) duplicates
    the character value so we can subtract 10 from it without losing it.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简洁，只有四行代码。第一行以`0v`开始，表示将0压入栈并向下移动。接下来的指令是`>`，表示再次向右移动。在这时，我们要读取一个二进制数字并检查它是否为换行符：`~:55+-|`。第一个字符（波浪符）将二进制数字作为字符读取并压入栈。第二个字符（冒号）复制字符值，以便我们可以在不丢失该值的情况下减去10。
- en: To get 10 on the stack, we use `55+`, and we use `-` to subtract. The stack
    now contains the running total, which is still 0, the first character, and whatever
    we get from subtracting 10 from the character. If the character is a newline,
    the stack contains 0 and pipe (`|`) will change program flow to down, thereby
    executing `>$2/.55+,@` to drop the extra copy of the final input character, divide
    the running total by 2, print it as a number, output a newline, and exit. Notice
    that `|` is the down/up equivalent of _. It moves program flow down if the top
    stack item is 0 and moves it up otherwise.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将10推入栈，我们使用`55+`，并使用`-`进行减法。栈现在包含当前总和（仍然是0）、第一个字符，以及从字符中减去10得到的结果。如果字符是换行符，栈将包含0，管道符（`|`）将改变程序的流向向下，从而执行`>$2/.55+,@`来删除最后一个输入字符的多余副本，除以2输出当前总和作为数字，输出换行符并退出。请注意，`|`是_的上下等效符号。如果栈顶项为0，它将使程序流向下；否则，流向上。
- en: If the character isn’t a newline, flow moves up from `|` to `>:1+|`. This block
    of code checks if EOF was read by adding 1 and asking if the top stack item is
    0 or not. If it is, flow goes down from the second pipe to execute the second
    copy of `>$2/.55+,@`, thereby printing the decimal answer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符不是换行符，程序流将从`|`上移到`>:1+|`。这段代码检查是否读取了EOF，通过加1并询问栈顶项是否为0。如果是，流将从第二个管道向下移动，执行第二个`>$2/.55+,@`副本，从而打印出十进制答案。
- en: Lastly, if the character isn’t newline or EOF, we move to the rest of line 0,
    `>68*-+2*`, to subtract 48, add the 0 or 1 to the running total, and multiply
    by 2\. The final character of line 0 is `v` to direct flow to the final character
    of line 2, `>`, which wraps back around to the beginning of line 2 to get the
    next input character.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果字符不是换行符或EOF，我们会移动到第0行的其余部分，`>68*-+2*`，以减去48，将0或1加到当前总和中，并乘以2。第0行的最后一个字符是`v`，它将流向第2行的最后一个字符`>`，然后回绕到第2行的开头以获取下一个输入字符。
- en: 'There are several ways to run *bin2dec.bf* . We could just run it and manually
    type the binary number. Or we might use `echo` to send the number to `bef`. Lastly,
    we might use file redirection. For example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以运行*bin2dec.bf*。我们可以直接运行它并手动输入二进制数字。或者，我们可以使用`echo`将数字发送到`bef`。最后，我们可以使用文件重定向。例如：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To watch a trace of *bin2dec.bf* , we can use `ttt` as above, but we need to
    use Befunge’s command line arguments. For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要观察*bin2dec.bf*的追踪，我们可以像上面一样使用`ttt`，但需要使用Befunge的命令行参数。例如：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you watch the trace, you’ll see that the program ends when newline is read.
    We can see the newline explicitly with `xxd`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察追踪，你会看到程序在读取换行符时结束。我们可以通过`xxd`明确看到换行符。
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, the input file need not have a final newline. In that case, the program
    does not exit by the first pipe, which checks for newline, but by the second pipe,
    which reads EOF (that is, *–*1). The following snippet of Python creates a new
    input file without a final newline.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，输入文件不需要以换行符结尾。在这种情况下，程序不会通过第一个检查换行符的管道退出，而是通过第二个读取EOF（即*–*1）的管道退出。以下Python代码片段创建了一个没有最终换行符的新输入文件。
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now run *bef* with `-d` as above, substituting `zzz` for `ttt`, and watch carefully.
    The program ends by taking the second pipe. The moral of the story is: care is
    required when deciding whether the input to a Befunge program is complete.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在像上面那样运行*bef*，用`-d`参数替换`zzz`为`ttt`，仔细观察。程序通过进入第二个管道结束。这个故事的教训是：在决定Befunge程序的输入是否完成时需要小心。
- en: '**DOS to Unix**'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从DOS到Unix**'
- en: 'A common issue when moving files from one computer system to another is a mismatch
    in end-of-line conventions. Unix systems end each line of a text file with ASCII
    10\. This is a linefeed and is sometimes called newline. However, Windows systems,
    which are built on MS-DOS, use two characters at the end of each line: ASCII 13
    and ASCII 10\. ASCII 13 is a carriage return. Besides being an unnecessary waste
    of disk space, the carriage return causes trouble with systems that expect only
    a linefeed. ASCII 13 is CTRL-M, so some Unix editors show an extraneous `^M` when
    manipulating files with DOS line endings. Thus, it would be nice to convert such
    files to Unix format. To complicate matters still further, older Macintosh text
    files use only ASCII 13 as the line ending. Thankfully, such text files are becoming
    rare.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件从一个计算机系统转移到另一个系统时，一个常见的问题是行结束符不匹配。Unix系统在每一行的末尾使用ASCII 10。这是换行符，有时称为“newline”。然而，Windows系统（基于MS-DOS）在每行的末尾使用两个字符：ASCII
    13和ASCII 10。ASCII 13是回车符。除了浪费不必要的磁盘空间，回车符还会导致期望只有换行符的系统出现问题。ASCII 13是CTRL-M，所以一些Unix编辑器在处理具有DOS行结束符的文件时会显示多余的`^M`。因此，将这样的文件转换为Unix格式是很有必要的。更复杂的是，早期的Macintosh文本文件只使用ASCII
    13作为行结束符。幸运的是，这种文本文件越来越少见了。
- en: Naturally, there are utilities to convert text file line endings, to say nothing
    of modern text editors that handle DOS files without trouble. But just for a moment,
    let’s pretend it’s still 1993 and our Amiga computer isn’t that influenced by
    DOS. We need a conversion utility, and we happen to have this nifty new language
    called Befunge to play with. Surely it can do what we want.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，有一些工具可以转换文本文件的行结束符，更不用说现代文本编辑器可以轻松处理DOS文件了。但暂且假设现在是1993年，我们的Amiga电脑还没有受到DOS的影响。我们需要一个转换工具，而恰好我们有这个新奇的语言Befunge可以玩。它肯定能做我们想要的。
- en: '[Listing 11-2](ch11.xhtml#ch011list2) contains *dos2unix.bf* , a program to
    convert text files with DOS line endings to Unix (and Amiga). Structurally, it’s
    rather similar to [Listing 11-1](ch11.xhtml#ch011list1), but there are some differences.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-2](ch11.xhtml#ch011list2)包含了*dos2unix.bf*，一个将具有DOS行结束符的文本文件转换为Unix（和Amiga）格式的程序。从结构上看，它与[清单11-1](ch11.xhtml#ch011list1)相似，但也有一些不同之处。'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 11-2: Converting DOS line endings to Unix*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-2：将DOS行结束符转换为Unix格式*'
- en: The overall flow of the program is left to right, from column 0 of line 2 on
    over. The first block of code, `~:1+|`, reads a character and ascertains whether
    it is EOF. If so, we’re done and `@` calls it a day. If not, we need to check
    if the character read is ASCII 13, which is precisely what `>:85+-|` does. If
    we subtract 13 and get 0, then the character is ASCII 13\. In that case, take
    the branch on line 2, `>$~:55+-|`, which drops the extra ASCII 13, reads the next
    input character, and checks if it’s ASCII 10\. If it is, we want to keep it, so
    `>^` moves up to `>>,` to print it. If the second character read isn’t ASCII 10,
    we have an embedded ASCII 13, which is weird, but whatever, we’ll keep it. That’s
    the top branch of the second pipe on line 2\. Lastly, if the pipe in line 1 does
    not move down, it moves up to print the input character. This is the path taken
    for most of the characters read.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的整体流程是从左到右的，从第二行的第0列开始。第一个代码块`~:1+|`读取一个字符并确认它是否是EOF。如果是，我们就完成了，`@`就会结束。如果不是，我们需要检查读取的字符是否是ASCII
    13，这正是`>:85+-|`所做的。如果减去13得到0，那么字符就是ASCII 13。在这种情况下，进入第二行的分支`>$~:55+-|`，它去掉多余的ASCII
    13，读取下一个输入字符，并检查它是否是ASCII 10。如果是，我们希望保留它，所以`>^`会移动到`>>,`进行打印。如果第二个字符不是ASCII 10，我们就遇到了嵌入的ASCII
    13，这有点奇怪，但没关系，我们会保留它。这就是第二行管道的上层分支。最后，如果第一行的管道没有向下移动，它会向上移动以打印输入字符。这是大多数字符读取时所走的路径。
- en: 'Now let’s test *dos2unix.bf* . To run it with redirection, use the following
    commands:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试*dos2unix.bf*。要使用重定向运行它，请使用以下命令：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The input file, *ttt.dos*, uses DOS line endings. The output of `xxd` shows
    the carriage return and linefeed characters as `0d0a`. The output, *ttt.unix*,
    has only `0a`, as it should.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件*ttt.dos*使用DOS行结束符。`xxd`的输出显示回车和换行字符为`0d0a`。输出文件*ttt.unix*只有`0a`，这是应该有的。
- en: I admit that the two examples in this section are not the most beguiling. However,
    they help check your understanding of how Befunge works. Writing programs is more
    fun than reading them, so I encourage you to give something similar a go. Perhaps
    a utility to take a Unix text file and spit out a DOS version? When you are ready,
    move on to the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认这一节中的两个例子并不是最吸引人的。不过，它们有助于检查你对Befunge工作原理的理解。编写程序比阅读程序更有趣，所以我鼓励你尝试类似的东西。也许是一个将Unix文本文件转换为DOS版本的小工具？当你准备好了，继续下一个章节。
- en: '***Building Bridges***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***搭建桥梁***'
- en: The command that likely made the least sense at first blush when you read through
    [Table 11-1](ch11.xhtml#ch011tab1) was `#` (hash mark), the bridge command. This
    command skips the next instruction, acting as a bridge to move over it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读[Table 11-1](ch11.xhtml#ch011tab1)时，最让你摸不着头脑的指令很可能是`#`（井号），桥接指令。这个指令会跳过下一个指令，起到桥接的作用，跳过它。
- en: For example, a Befunge program consisting of only `88*1+#.,` will print the
    letter *A* forever. The first part, `88*1+`, puts 65 on the stack. Then, `#` skips
    the next instruction, which is a period to print `65`, and instead hits the comma
    to print ASCII 65, which is `A`. That is all the text on the first line, so the
    instruction pointer will wrap around to repeat it, over and over ([Listing 11-3](ch11.xhtml#ch011list3)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个只包含`88*1+#.,`的Befunge程序将永远打印字母*A*。首先，`88*1+`将65放入栈中。然后，`#`跳过下一个指令，该指令是一个点号用来打印`65`，而是直接跳到逗号，打印ASCII值65，即`A`。这就是第一行的所有文本，因此指令指针将循环回去，反复执行（见[Listing
    11-3](ch11.xhtml#ch011list3)）。
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 11-3: One use for the bridge instruction*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-3：桥接指令的一个用途*'
- en: The `#` skips the next instruction—why on earth would we want to do that? One
    reason for `#` is found in *bridge.bf* ([Listing 11-3](ch11.xhtml#ch011list3)),
    which does nothing more than print the word `xyxxy`. If you hear a hollow voice
    saying “fool,” fear not. (And if you don’t understand that reference, fear not
    as well.)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`#`跳过下一个指令——我们为什么要这么做呢？`#`的一个原因可以在*bridge.bf*中找到（见[Listing 11-3](ch11.xhtml#ch011list3)），它做的仅仅是打印单词`xyxxy`。如果你听到一个空洞的声音说“傻瓜”，不要担心。（如果你不理解这个引用，也不用担心。）'
- en: As with the *cow.bf* example above, *bridge.bf* moves from right to left and
    loops to print character after character. However, in this case, consider line
    1, `>:#v_82+,@`. From left to right, the commands are to move right, duplicate
    the character at the top of the stack, and then skip the `v` command but execute
    the underscore (_), which moves to the right if the top stack item is 0 and moves
    to the left otherwise.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与上面的*cow.bf*示例类似，*bridge.bf*从右向左移动并循环打印字符。然而，在这种情况下，考虑第1行，`>:#v_82+,@`。从左到右，指令是向右移动，复制栈顶的字符，然后跳过`v`指令，但执行下划线（_），如果栈顶元素为0，则向右移动，否则向左移动。
- en: Here’s where we see the utility of bridge. If the character is 0, go right to
    push 10 on the stack, print the newline character, and exit. Otherwise, move left.
    The first instruction moving left from _ is `v`, the very instruction `#` skipped
    when moving from left to right.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这时我们就看到了桥接指令的用处。如果字符是0，向右移动并将10压入栈中，打印换行符并退出。否则，向左移动。从`_`向左移动的第一个指令是`v`，这是在从左向右移动时被`#`跳过的指令。
- en: Executing `v` moves down, then left, to print the character and ultimately loop
    around to process the next character. So the bridge command is essential in this
    case as it allows one set of commands when the program flows to the right while
    executing a different set of commands when it flows to the left. Keep this behavior
    in mind because we’ll see it again in the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`v`会向下移动，再向左移动，打印字符，最终循环回去处理下一个字符。因此，桥接命令在这个例子中非常重要，因为它允许在程序向右流动时使用一组指令，而在程序向左流动时执行另一组指令。记住这个行为，因为我们将在下一节再次看到它。
- en: '***Fun with Dice***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***骰子的乐趣***'
- en: 'Befunge’s `?` command randomly changes the instruction pointer’s direction.
    It might be up, down, left, or right. Let’s have some fun with this unusual instruction.
    At first blush, we might think it useless: who wants a program that isn’t deterministic?
    Then again, random numbers are frequently used in everything from games to simulations.
    Can we press `?` into similar service?'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge的`?`命令会随机改变指令指针的方向，可能是上、下、左或右。让我们来玩玩这个不寻常的指令。乍一看，我们可能会觉得它没什么用：谁需要一个不确定的程序呢？不过，随机数在从游戏到模拟的各种应用中都很常见。我们能否将`?`用到类似的场景中？
- en: As `?` selects a new instruction pointer direction, it seems reasonable we might
    use it to simulate dice. In particular, `?` selects from four possible directions,
    so we might simulate what gamers call a D4, which is a die with four sides instead
    of the usual six.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`?`选择了一个新的指令指针方向，似乎很合理我们可以利用它来模拟骰子。特别是，`?`从四个可能的方向中选择，因此我们可以模拟玩家所说的D4，这是一个有四个面的骰子，而不是通常的六面骰。
- en: How can `?` help us here? Well, if we encounter `?`, there are four possible
    directions to go, so if we push a 1, 2, 3, or 4 depending on which direction is
    selected, we’ll get our four-sided die.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`如何在这里帮助我们呢？嗯，如果我们遇到`?`，有四个可能的方向可以选择，因此如果我们根据选择的方向推动1、2、3或4，我们就能得到一个四面骰。'
- en: '[Listing 11-4](ch11.xhtml#ch011list4) shows one approach to simulating a four-sided
    die.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-4](ch11.xhtml#ch011list4)展示了模拟四面骰的一种方法。'
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 11-4: Simulating a four-sided die*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-4：模拟四面骰*'
- en: In this case, we move to `?` by moving down to line 1, then right. Notice the
    bridge instruction in line 1\. When moving to the right, we want to skip the `v`
    instruction to reach `?`. If `?` selects to move to the left, we hit the `v` to
    move to line 2 and push 1 on the stack. Likewise, the other three directions away
    from `?` end up pushing 2, 3, or 4 before hitting line 3, which moves to the right
    to print the selected value.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过下移到第1行，然后向右移动，进入`?`。注意第1行的桥接指令。当向右移动时，我们希望跳过`v`指令以到达`?`。如果`?`选择向左移动，我们会遇到`v`，它将我们带到第2行并在栈上推送1。同样，`?`的其他三个方向将分别推送2、3或4，然后到达第3行，这里会向右移动以打印选定的值。
- en: If we run *die4.bf* 10,000 times, we expect each outcome value to appear with
    roughly equal frequency. One such experiment of 10,000 runs produced `[2472, 2577,
    2452, 2499]` as the respective number of 1s, 2s, 3s, and 4s. The values are similar,
    so it’s fair to say our four-sided die program works.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行*die4.bf* 10,000次，我们期望每个结果值的出现频率大致相等。一次10,000次的实验产生了 `[2472, 2577, 2452,
    2499]`，分别表示1、2、3和4的出现次数。这些值相似，因此可以公平地说我们的四面骰程序运行正常。
- en: '[Listing 11-5](ch11.xhtml#ch011list5) shows a first attempt at simulating a
    standard six-sided die.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-5](ch11.xhtml#ch011list5)展示了模拟标准六面骰的第一次尝试。'
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 11-5: Attempting to simulate a six-sided die*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5：尝试模拟六面骰*'
- en: 'If nothing else, [Listing 11-5](ch11.xhtml#ch011list5) is nice and symmetric.
    I toyed with putting it on a t-shirt. Flow moves down the center from top to bottom.
    When the interpreter encounters a `?`, moving back up forces flow back into `?`,
    leaving only three exits: to either side or down. If to the side, a number from
    1 to 6 is pushed on the stack and printed, and arrows move flow to the bottom
    to print a newline before exiting.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有别的，[清单 11-5](ch11.xhtml#ch011list5)的设计是不错且对称的。我曾考虑把它印在T恤上。流程从上到下沿中间流动。当解释器遇到`?`时，向上移动会将流程强制回到`?`，只留下三个出口：向两侧或向下。如果向两侧，则会在栈上推送并打印1到6之间的数字，箭头将流程移动到底部打印换行符后退出。
- en: There are six numbers, so surely this arrangement is appropriate. If you run
    this version 10,000 times, you might get a distribution similar to `[3337, 3333,
    1072, 1109, 543, 606]`, which is not at all uniform. [Listing 11-5](ch11.xhtml#ch011list5)
    can be found in *die6_biased.bf* , and as you might expect from the name, it is
    a loaded die that strongly favors 1s and 2s.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个数字，因此这种安排肯定是合适的。如果你运行这个版本10,000次，可能会得到类似 `[3337, 3333, 1072, 1109, 543, 606]`
    的分布，这并不均匀。[清单 11-5](ch11.xhtml#ch011list5)可以在*die6_biased.bf*中找到，正如你从名字中可以预见的那样，它是一个有偏的骰子，强烈偏向1和2。
- en: From the counts, the ratio between 1s and 2s to 3s and 4s then 5s and 6s is
    6:2:1, meaning one is six times as frequent as six. If we look at the structure
    of [Listing 11-5](ch11.xhtml#ch011list5), we can calculate the probabilities associated
    with each outcome. The first `?` has a 1 out of 3 chance of selecting 1, 2, or
    moving on to other numbers. Therefore, the probability of choosing a 1 or a 2
    is 1/3 + 1/3 = 2/3\. That means the sum of the remaining probabilities, those
    for selecting 3 through 6, must total 1/3\. Selecting 3 or 4 is similar to 1 or
    2—there is a 1 out of 3 chance—but it’s 1 out of 3 from what is already a 1 out
    of 3 chance. Therefore, there is a 1 in 9 chance of selecting 3 and the same for
    selecting 4\. The final 1 in 9 chance is split evenly between choosing 5 or 6,
    or 1 in 18 each.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从计数结果来看，1和2与3和4，再到5和6的比率是6:2:1，这意味着1的出现频率是6倍于6的。如果我们看看[列表 11-5](ch11.xhtml#ch011list5)的结构，就能计算出每个结果的概率。第一个`?`有1/3的概率选择1、2或继续到其他数字。因此，选择1或2的概率是1/3
    + 1/3 = 2/3。这意味着剩余概率的总和，即选择3到6的概率，必须是1/3。选择3或4与选择1或2类似——它们的概率是1/3——但它是从原本1/3的概率中再选择，因此选择3或4的概率是1/9，选择5或6的概率也是1/9。最终，选择5或6的1/9的概率均分为选择5或6的各1/18的概率。
- en: If the probabilities above are correct, they must add up to 1\. Let’s use Scheme
    to check that they do.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述的概率是正确的，它们的总和应该等于1。让我们使用Scheme来检查它们是否满足这个条件。
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our calculations are correct. Clearly, we don’t want [Listing 11-5](ch11.xhtml#ch011list5),
    aesthetics aside. So how can we use something that selects 1 in 4 to get something
    that selects 1 in 6 with equal probabilities?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算是正确的。显然，除了美学考虑，我们不希望看到[列表 11-5](ch11.xhtml#ch011list5)。那么，如何利用选择1/4的机制来得到选择1/6并且概率相等的结果呢？
- en: If we restrict `?` to select one of two options only, we can use each of those
    outputs to choose another pair, thereby changing two options into four. Do the
    same for each of the four, and we have eight outputs, each equally likely to be
    selected. We only want six of the eight, so if either of the remaining two are
    selected, we repeat until one of the six is chosen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`?`限制为只选择两个选项中的一个，我们可以使用每一个输出去选择另一个对，从而将两个选项变成四个。对每一对都做相同的操作，我们就得到了八个输出，每个输出被选中的概率相同。我们只需要这八个中的六个，因此如果选择了剩下的两个中的任何一个，就重复此过程直到选中六个之一。
- en: There are different ways to write such an algorithm. The file *die6.bf* holds
    one of them (see [Listing 11-6](ch11.xhtml#ch011list6)). Take a moment to look
    at the code to absorb what it means. Then linger a little longer to appreciate
    the code’s ethereal beauty.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以编写这样的算法。文件*die6.bf*包含其中的一种实现（见[列表 11-6](ch11.xhtml#ch011list6)）。花些时间查看代码，理解它的意义。然后再停留一会儿，欣赏代码那种空灵的美感。
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 11-6: Simulating a six-sided die with equal probabilities*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-6：模拟具有相等概率的六面骰子*'
- en: The rightmost instructions push 1 through 6 on the stack. However, if flow reaches
    the top or bottom, it continues to the right to wrap around and move back to the
    beginning until one of the six desired paths is selected.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最右边的指令将1到6压入栈中。然而，如果流动到达顶部或底部，它会继续向右延续，绕回到起点，直到选中六个目标路径中的一个。
- en: Running the code in [Listing 11-6](ch11.xhtml#ch011list6) 10,000 times gives
    us frequencies of `[1678, 1638, 1705, 1660, 1637, 1682]`, which is exactly what
    we want; each outcome is now equally likely. As an exercise, see if you can come
    up with arrangements of `?` to simulate an 8-sided die, 12-sided die, or even
    20-sided die.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 11-6](ch11.xhtml#ch011list6)中运行代码10,000次，得到的频率为`[1678, 1638, 1705, 1660,
    1637, 1682]`，这正是我们想要的；每个结果现在的选中概率是相等的。作为练习，看看你是否能构造出`?`的排列来模拟一个8面骰子、12面骰子，甚至是20面骰子。
- en: '***Wandering Around***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***四处游走***'
- en: 'The file *brownian.bf* contains a program where the entire playfield is filled
    with `?` and nothing else. Running this program on its own is boring; it produces
    no output and never ends. However, running it with Befunge’s debugger is mesmerizing:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*brownian.bf*包含一个程序，其中整个游戏场地都被`?`填充，除此之外没有任何内容。单独运行这个程序很无聊，它没有输出，也不会结束。然而，用Befunge的调试器运行它却很迷人：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The cursor wanders over the playfield in a way that is reminiscent of Brownian
    motion, the random motion of particles in some medium.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 光标在游戏场地上游走，给人一种类似于布朗运动的感觉，即粒子在某种介质中的随机运动。
- en: Before we move on, take a look at *zero.bf* . It consists of an entire playfield
    of `?` commands with a single period (`.`) in the middle.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，看看*zero.bf*。它由一个完全由`?`命令构成的游戏场地和中央的一个句点（`.`）组成。
- en: Befunge never throws an error because of the stack. If you attempt to pop the
    stack when it is empty, Befunge returns 0\. The print command pops the stack,
    so printing when the stack is empty outputs 0\. If you run *zero.bf* with the
    debugger, you might think you’re in for a long wait to hit the one print instruction.
    However, if you run *zero.bf* without the debugger, your screen will quickly fill
    with 0s. Human perception of how fast computers operate is orders of magnitude
    too slow. Computers are so much quicker than we can appreciate that even a simple
    interpreter like Befunge randomly hits that one print command at a tremendous
    rate. In fact, dumping the output to the screen is slow. Direct the output to
    a file instead, and even my old system has Befunge printing nearly 15,000 0s per
    second.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge从不因为栈而抛出错误。如果你在栈为空时尝试弹出栈，Befunge会返回0。打印指令会弹出栈，所以当栈为空时打印会输出0。如果你用调试器运行
    *zero.bf*，你可能会认为要等很长时间才能执行到唯一的打印指令。然而，如果你没有用调试器运行 *zero.bf*，你的屏幕会迅速被0填满。人类对计算机运算速度的感知远远慢于计算机的实际速度。计算机的运算速度比我们能理解的要快得多，甚至像Befunge这样简单的解释器也能以极高的速度随机达到那个唯一的打印指令。实际上，将输出打印到屏幕上是很慢的。将输出重定向到文件，即便是我的旧系统，Befunge每秒也能打印近15,000个0。
- en: 'However, it turns out my statement about Befunge not throwing stack errors
    is incorrect. Run this program: `00/.@`. I consider it an Easter egg.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事实证明我之前关于Befunge不会抛出栈错误的说法是错误的。运行这个程序：`00/.@`。我把它当作一个复活节彩蛋。
- en: '***Updating the Playfield on the Fly***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动态更新游戏区***'
- en: Befunge programs live in the playfield and memory is restricted to the stack.
    Or is it? The `p` instruction lets the programmer write to the playfield as the
    program runs. If the altered cell happens to be part of the running program, and
    the value written is the ASCII code for a valid command, then Befunge will use
    that command. This means that Befunge allows self-modifying code, which, under
    normal circumstances, is taboo. But we’re working with esolangs, so what was forbidden
    may be permitted. Use `p` to write to the playfield and `g` to read from it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge程序存在于游戏区，而内存仅限于栈。或者说真的是这样吗？`p` 指令允许程序员在程序运行时写入游戏区。如果修改的单元格恰好是正在运行的程序的一部分，并且写入的值是一个有效命令的ASCII码，Befunge将会使用该命令。这意味着Befunge允许自修改代码，而在正常情况下，自修改代码是禁忌的。但由于我们在处理的是怪异语言，许多禁忌可能变得可以接受。使用
    `p` 写入游戏区，使用 `g` 从游戏区读取数据。
- en: Let’s explore `p` and `g` with two examples. The first converts an integer less
    than 65,536 (= 2^(16)) to a four-digit hexadecimal number. The second is a simple
    calculator.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过两个例子来探索 `p` 和 `g`。第一个将小于65,536（= 2^(16)）的整数转换为四位十六进制数。第二个是一个简单的计算器。
- en: '**What the Hex?**'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**什么是十六进制？**'
- en: Old-school BASIC used `DATA` and `READ` to store data in source code. These
    were usually instructions for small machine language routines that were `POKE`d
    into memory and later `CALL`ed from BASIC. We can use `g` similarly to read data
    from the playfield.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 老式BASIC语言使用 `DATA` 和 `READ` 在源代码中存储数据。这些通常是一些小型机器语言例程的指令，后来通过 `POKE` 被写入内存并由BASIC通过
    `CALL` 调用。我们可以类似地使用 `g` 从游戏区读取数据。
- en: Suppose we have a number, *v*, on the stack. We’ll assume it’s positive and
    less than 65,536\. Our task is to convert this number to four hex digits and print
    them. One way to do this is to split *v* in two by replacing it with *v*/256 and
    *v* mod 256\. Then, if we do the same with the split values using 16 in place
    of 256, we’ll extract the four hexadecimal digit values.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设栈上有一个数字 *v*。我们假设它是正数且小于65,536。我们的任务是将这个数字转换为四位十六进制数并打印出来。实现这个的方法之一是通过将 *v*
    分成两部分，替换成 *v*/256 和 *v* mod 256。然后，如果我们使用16替代256对这两个拆分值做同样的操作，就可以提取出四个十六进制数值。
- en: For example, if the user enters 1234, the sequence of operations leads to
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户输入1234，操作序列将导致
- en: '![Image](Images/f0311.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0311.jpg)'
- en: or (0,4,13,2) = 04*D*2[16] = 1234.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 (0,4,13,2) = 04*D*2[16] = 1234。
- en: Let’s put this algorithm to the test and, at the same time, use `p` and `*g*`
    because we can. The code we need is in *dec2hex.bf* and is shown in [Listing 11-7](ch11.xhtml#ch011list7).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下这个算法，并同时使用 `p` 和 `*g*`，因为我们可以。我们需要的代码在 *dec2hex.bf* 中，并且可以在 [列表11-7](ch11.xhtml#ch011list7)
    中查看。
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 11-7: Converting decimal to hex*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-7：将十进制转换为十六进制*'
- en: The program flows in a zig-zag pattern, row by row, beginning with line 1\.
    First, the user is asked for a number (`&`), after which comes the division and
    modulo by 256\. At the end of the line, *v*/256 and *v* mod 256 are on the stack.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序以之字形模式逐行执行，从第1行开始。首先，系统要求用户输入一个数字（`&`），接着执行除以256和取模256操作。行末时，*v*/256 和 *v*
    mod 256 会被压入栈中。
- en: Line 2 runs from right to left. Flipping the instructions, the interpreter executes
    `:82*/20p82*%10p`. Let’s break this down a bit. The first instruction duplicates
    the top stack item, *v* mod 256\. Next, `82*/` divides the top stack item by 16,
    thereby calculating the second digit of the answer. To store it in the playfield,
    we use `20p`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行从右到左执行。翻转指令后，解释器执行`：82*/20p82*%10p`。让我们来分解一下。第一条指令复制栈顶项，*v*模256。接下来，`82*/`将栈顶项除以16，从而计算出答案的第二个数字。为了将其存储在游戏区域中，我们使用`20p`。
- en: '[Table 11-1](ch11.xhtml#ch011tab1) says the `p` instruction expects three values
    on the stack: the value to store, the playfield column, and the playfield row.
    Therefore, `20p` stores the second digit value in row 0, column 2\. The remainder
    of line 2 uses modulo to get the value of the first digit and places it in `10p`,
    row 0, column 1\. Line 3, running left to right, repeats the calculation to find
    the values of digits 3 and 4.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[表11-1](ch11.xhtml#ch011tab1)指出，`p`指令期望栈中有三个值：要存储的值、游戏区域的列和游戏区域的行。因此，`20p`会将第二个数字的值存储在第0行、第2列。第2行的其余部分使用模运算来获取第一个数字的值，并将其放入`10p`，第0行、第1列。第3行，从左到右，重复计算，找到数字3和4的值。'
- en: When line 4 begins, again running right to left, we have the digit values in
    row 0 of the playfield. We now need to print them as ASCII characters. You’ve
    likely noticed the string `0123456789ABCDEF` in line 0\. We’ll use this string
    to get the characters we need. This is the Befunge equivalent of `DATA` in BASIC
    or FORTRAN. The digit value serves as an index into this string.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当第4行开始时，再次从右到左运行，我们在游戏区域的第0行拥有数字值。现在我们需要将它们作为ASCII字符打印出来。你可能注意到了在第0行有一个字符串`0123456789ABCDEF`。我们将使用这个字符串来获取我们需要的字符。这相当于BASIC或FORTRAN中的`DATA`。数字值作为该字符串的索引。
- en: Flipped, line 4 is `40g5+0g,`. The first part, `40g`, reads the value of digit
    4, which is the most significant digit. To index the proper character, we must
    add 5, then another `g` pulls the proper character, placing its ASCII value on
    the stack for `,` to print. The remainder of [Listing 11-7](ch11.xhtml#ch011list7)
    prints the rest of the answer and a newline and then ends.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转后，第4行是`40g5+0g,`。第一部分，`40g`，读取数字4的值，即最重要的数字。为了索引正确的字符，我们需要加上5，然后另一个`g`会提取正确的字符，将其ASCII值放到栈中，供`,`打印。其余的[清单11-7](ch11.xhtml#ch011list7)打印出剩余的答案并换行，然后结束。
- en: Running *dec2hex.bf* shows that the program works.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*dec2hex.bf*可以证明程序是有效的。
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It’s more interesting to run this example with the debugger. For example, if
    the temporary file *ttt* contains an integer, say 6,502, we might run the code
    with the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 用调试器运行这个例子更有趣。例如，如果临时文件*ttt*包含一个整数，比如6502，我们可能会使用以下代码来运行：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: While the code executes, watch the top row carefully. You’ll see four lights,
    er, dots appear. These are the specific digits placed in the playfield by the
    `p` instructions. When the program ends, the output is in another temporary file,
    *qqq*, which contains 1966[16] = 6502.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码执行时，仔细观察顶行。你会看到四个灯，呃，点出现在屏幕上。这些是由`p`指令放置在游戏区域中的具体数字。当程序结束时，输出会在另一个临时文件*qqq*中，该文件包含1966[16]
    = 6502。
- en: Using the playfield to store program data is a handy option. Using the playfield
    to alter program execution is the next step. Let’s see how.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用游戏区域来存储程序数据是一个方便的选项。使用游戏区域来改变程序执行则是下一步。让我们来看一下。
- en: '**Program Transmogrification**'
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**程序变形**'
- en: 'Self-modifying code, or, as I like to call it, *program transmogrification*,
    is seldom used and with good reason. However, Befunge supports it, and there are
    times it’s more handy than not. For example, a calculator program needs to accept
    a number, an operator, and another number. The code is much the same regardless
    of the operator, as long as the operator is binary. Befunge supports five binary
    arithmetic operators: `+`, `-`, `*`, `/`, and `%`. Let’s make a simple calculator
    that lets users enter a single digit, the desired operator, and a second digit
    before calculating and printing the answer.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 自修改代码，或者我喜欢称之为*程序变形*，很少被使用，而且有其充分的理由。然而，Befunge支持这种方式，而且有时它比不支持更为方便。例如，一个计算器程序需要接受一个数字、一个运算符以及另一个数字。无论运算符是什么，代码基本相同，只要运算符是二元的。Befunge支持五个二元算术运算符：`+`、`-`、`*`、`/`和`%`。我们来做一个简单的计算器，允许用户输入一个单一数字，期望的运算符和第二个数字，然后计算并输出结果。
- en: In Python, we might implement such a calculator with
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可能会这样实现一个计算器：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’re assuming the existence of a function, `getch`, that returns a single character
    from the keyboard.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设存在一个函数`getch`，它返回从键盘读取的单个字符。
- en: The Python code would do the trick, but its highly repetitive `if` statement
    isn’t particularly attractive. If we know the operation is addition, the code
    becomes simpler.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码可以实现这个功能，但它高度重复的`if`语句并不特别吸引人。如果我们知道操作是加法，代码会变得更简单。
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the operation is division, the code is the same; just replace `+` with `/`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作是除法，代码是一样的；只需将`+`替换为`/`。
- en: 'The key to our Befunge calculator is in the phrase, “just replace *X* with
    *Y*.” That is exactly what we’ll do: we’ll write the program as if the operator
    were always addition, but modify the program source in the playfield during program
    execution to use the user’s actual operator.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Befunge计算器的关键在于短语：“只需将 *X* 替换为 *Y*”。这正是我们要做的：我们将程序写成如果操作符始终是加法，但在程序执行过程中修改游戏场地中的程序源代码，以使用用户的实际操作符。
- en: 'Algorithmically, then, we need to do the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 算法上，我们需要做的是：
- en: Get a single digit character from the user and convert it to a number on the
    stack.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从用户那里获取一个数字字符，并将其转换为堆栈上的一个数字。
- en: Get a single operator character from the user and place it in the proper location
    in the playfield so Befunge uses it when calculating the answer.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从用户那里获取一个操作符字符，并将其放置在游戏场地中的适当位置，以便Befunge在计算答案时使用它。
- en: Get a second digit from the user on the stack.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从堆栈中获取用户输入的第二个数字。
- en: Perform the operation and print the answer.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行操作并打印答案。
- en: '[Listing 11-8](ch11.xhtml#ch011list8) shows *calc.bf* . It’s even shorter than
    the description of what it does.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-8](ch11.xhtml#ch011list8)展示了 *calc.bf*。它甚至比它所做的事情的描述还要简短。'
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 11-8: Program transmogrification in action*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-8：程序变形的实际操作*'
- en: The first part reads a character, assumed to be a digit, and subtracts 48 to
    convert it to an integer. That’s `~68*-`. The program then asks for the operator,
    which it places in row 1, column 6 (`~61p`). If you look at row 1, column 6, you’ll
    see it contains a `+`, which is overwritten by the operator character the user
    enters—program transmogrification!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分读取一个字符，假设它是一个数字，并减去48将其转换为整数。那是`~68*-`。然后程序请求输入操作符，并将其放置在第1行第6列（`~61p`）。如果你查看第1行第6列，你会看到它包含一个`+`，这个`+`会被用户输入的操作符字符覆盖——程序变形！
- en: The rest of line 0 gets the second digit, prints a space, an equals sign, and
    another space. Line 1 applies the updated operation, prints the result and a newline,
    and exits. Let’s see [Listing 11-8](ch11.xhtml#ch011list8) in action.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第0行的其余部分获取第二个数字，打印一个空格，一个等号，再加一个空格。第1行应用更新后的操作，打印结果和换行符，然后退出。让我们看看 [清单11-8](ch11.xhtml#ch011list8)
    的实际运行。
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The stated goal of Befunge was to make a language that is too hard to compile,
    so it makes sense to allow self-modifying code. In this particular case, especially
    given how Befunge works as a programming language, a bit of self-modification
    was the more elegant solution. Without it, *calc.bf* would have to be much larger:
    it would need to enable comparing the operator character with each of the five
    possible operators along with a different code path for each operator. This would
    definitely not be as elegant.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge的目标是创造一种难以编译的语言，因此允许自我修改代码是合理的。在这种特定情况下，尤其考虑到Befunge作为编程语言的运作方式，一点自我修改是更优雅的解决方案。没有它，*calc.bf*将不得不大得多：它需要能够将操作符字符与五个可能的操作符进行比较，并为每个操作符提供不同的代码路径。这显然不如现在这样优雅。
- en: '**Discussion**'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: 'Befunge-93 is imperative, and the stack is of arbitrary size, limited only
    by the computer’s RAM, so we might think it’s Turing complete. However, it isn’t.
    What keeps it from being Turing complete is a limitation many other languages
    do not have: the program *must* fit in the playfield, as that’s all the room there
    is. Therefore, programs cannot be arbitrarily complex and Befunge-93 is not Turing
    complete.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge-93是命令式的，堆栈大小是任意的，仅受计算机内存的限制，因此我们可能认为它是图灵完备的。然而，它并不是。阻止它成为图灵完备的是许多其他语言没有的限制：程序
    *必须* 适应游戏场地，因为那里就是所有的空间。因此，程序不能过于复杂，Befunge-93并不是图灵完备的。
- en: You may notice that in the previous paragraph, I was careful to type “Befunge-93.”
    A later version of Befunge, Befunge-98, removes the limitation on playfield size
    and therefore *is* Turing complete. However, I felt an affinity for the original,
    which is why we worked with it here.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在前一段中，我特别小心地输入了“Befunge-93”。Befunge的后续版本，Befunge-98，取消了对游戏场地大小的限制，因此
    *它* 是图灵完备的。然而，我对原版Befunge有一种亲切感，这也是我们在这里使用它的原因。
- en: 'The web has many additional resources for Befunge, though not at the scale
    of BF or even Piet. The best resources for Befunge are *[https://esolang.org/](https://esolang.org/)*
    and Chris Pressey’s site (*[https://git.catseye.tc/Befunge-93/](https://git.catseye.tc/Befunge-93/)*).
    I also found this interview with Pressey interesting: *[https://esoteric.codes/blog/interview-with-chris-pressey/](https://esoteric.codes/blog/interview-with-chris-pressey/)*.
    Befunge figures prominently. Last of all, if you’re like me, you’ll find plenty
    to explore and think about by examining all of Pressey’s site, including the many
    other programming languages he’s developed over the years (*[https://catseye.tc/](https://catseye.tc/)*).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上有许多关于 Befunge 的额外资源，尽管没有 BF 或 Piet 那么广泛。Befunge 最好的资源是 *[https://esolang.org/](https://esolang.org/)*
    和 Chris Pressey 的网站 (*[https://git.catseye.tc/Befunge-93/](https://git.catseye.tc/Befunge-93/)*)。我还觉得这次与
    Pressey 的访谈很有趣： *[https://esoteric.codes/blog/interview-with-chris-pressey/](https://esoteric.codes/blog/interview-with-chris-pressey/)*。Befunge
    在其中占据了重要位置。最后，如果你像我一样，你会通过浏览 Pressey 的整个站点，发现许多有趣的内容值得探索和思考，包括他这些年来开发的其他编程语言 (*[https://catseye.tc/](https://catseye.tc/)*).
- en: 'Befunge has been written in Befunge—see the included *befunge.bf* file. It’s
    from the esolang wiki. To use it, run *befunge.bf* , passing in the Befunge program
    you want to run from standard in. If the program has input, separate the program
    text from the input with a semicolon (`;`). For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Befunge 已经用 Befunge 编写过——请参阅附带的 *befunge.bf* 文件。它来自 Esolang 维基。使用时，运行 *befunge.bf*，并传入你希望从标准输入运行的
    Befunge 程序。如果程序有输入，请用分号（`;`）分隔程序文本和输入。例如：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is quite impressive and reinforces the argument that Befunge-93 would be
    Turing complete if there were enough program space. The `2>` redirection ignores
    the Befunge error messages that you’ll see if you don’t use it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常令人印象深刻，也加强了一个观点：如果有足够的程序空间，Befunge-93 将是图灵完备的。`2>` 重定向忽略了 Befunge 错误消息，如果没有使用它，你会看到这些错误。
- en: It just happens that the Befunge interpreter in Befunge fits in the playfield.
    The esolang wiki does not provide authorship information for *befunge .bf* , so
    I’m not sure who we should thank for such a clever implementation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正好，Befunge 中的 Befunge 解释器适配了游戏场地。Esolang 维基没有提供 *befunge .bf* 的作者信息，所以我不确定应该感谢谁提供了这么巧妙的实现。
- en: 2D programming is cute and much in line with what a “good” esolang is—something
    outside the box. The clever bits, to me, are seeing the utility of an instruction
    like `#`, the bridge instruction, and with it the recognition that programs running
    in multiple directions might want to do slightly different things when running
    left to right or right to left, even for the same line of code. Using single-digit
    numbers, knowing any number can be built on the stack as needed, is also quite
    clever.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 二维编程很可爱，也非常符合“好”的 esolang 定义——它是超越常规的东西。对我来说，巧妙之处在于看到了像 `#` 这样的指令的实用性，它是一个桥接指令，同时也意识到运行方向不同的程序可能在从左到右或从右到左运行时，即使是同一行代码，可能会做稍微不同的事情。使用一位数字，知道任何数字都可以根据需要在栈上构建，这也是非常巧妙的。
- en: Good esolangs inspire other esolangs. Befunge is no different. For example,
    if there is a 2D language, then why not a 3D language? Interested? If so, take
    a look at Suzy (*[https://github.com/gvx/suzy/](https://github.com/gvx/suzy/)*).
    However, be aware that it hasn’t been updated for more than a decade, so use Python
    2.*X* to run its examples.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的 esolang 会激发其他 esolang 的灵感，Befunge 也不例外。例如，如果有二维语言，为什么不可以有三维语言呢？有兴趣吗？如果有的话，可以看看
    Suzy（*[https://github.com/gvx/suzy/](https://github.com/gvx/suzy/)*）。不过要注意，它已经超过十年没有更新了，所以运行示例时请使用
    Python 2.*X*。
- en: 'What about other 2D languages? Befunge has inspired so many esolangs that a
    term has evolved just to describe them: *fungeoids*. The esolang wiki lists pages
    of fungeoids at *[https://esolangs.org/wiki/Category:Two-dimensional_languages](https://esolangs.org/wiki/Category:Two-dimensional_languages)*.
    If imitation is the sincerest form of flattery, then Befunge should feel abundantly
    flattered, provided Befunge can feel anything, of course.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 那么其他的二维语言呢？Befunge 启发了许多 esolang，以至于出现了一个专门描述它们的术语：*fungeoids*。Esolang 维基列出了
    *[https://esolangs.org/wiki/Category:Two-dimensional_languages](https://esolangs.org/wiki/Category:Two-dimensional_languages)*
    中的 fungeoids 页面。如果模仿是最真诚的恭维，那么 Befunge 应该会感到非常受宠若惊，当然，前提是 Befunge 能够有感觉。
- en: '**Summary**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'Befunge was the target of this chapter. We learned that Befunge is the first
    2D programming language, has been around long enough to have a silver jubilee,
    and is fun to program in. We also learned that Befunge has inspired a swarm of
    related esolangs: the fungeoids.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是 Befunge。我们了解到，Befunge 是第一个二维编程语言，已经存在足够长的时间，甚至有了银禧年，它的编程过程非常有趣。我们还了解到，Befunge
    激发了大量相关的怪异编程语言：即所谓的 fungeoids。
- en: 'And, with that, our exploration of existing esolangs draws to a close. [Part
    I](part01.xhtml#part01) of the book discussed the essentials of programming languages.
    [Part II](part02.xhtml#part02) prepped us for esolangs by studying atypical programming
    languages, and [Part III](part03.xhtml#part03) explored existing esolangs. Now
    we move to [Part IV](part04.xhtml#part04) to implement two homegrown esolangs:
    Filska and Firefly.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的结束，我们对现有的怪异编程语言（esolangs）进行了探索。[第一部分](part01.xhtml#part01)讨论了编程语言的基本要素。[第二部分](part02.xhtml#part02)通过研究非典型编程语言，为我们了解怪异编程语言做了准备，而[第三部分](part03.xhtml#part03)则探讨了现有的怪异编程语言。现在，我们进入[第四部分](part04.xhtml#part04)，来实现两种本土创作的怪异编程语言：Filska
    和 Firefly。
