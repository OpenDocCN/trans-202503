- en: '11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BEFUNGE
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Like Piet, Befunge is a 2D programming language. Befunge is fun, is not particularly
    difficult to work with, and produces some of the most aesthetically pleasing source
    code I’ve ever seen. I think you’ll agree by the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to learn and experiment with Befunge. After BF, it’s perhaps the
    most influential esolang, and is usually included in lists with titles like “Ten
    of the weirdest programming languages you’ve never heard of.” We’ll learn why
    Befunge exists and why it’s called Befunge. We’ll then follow our usual pattern
    of exploring the gist of the language with examples. We’ll conclude with a discussion.
    I hope this marks only the beginning of your Befunge experiments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Befunge-93 World Tour**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1993, the movie *Jurassic Park* brought dinosaurs to the big screen, Mulder
    and Scully were chasing aliens on TV, and Bill Clinton was beginning his first
    term as president. In 1993, a typical home computer cost about $1,800 in 2022
    dollars, had around 4MB of RAM, a 16 MHz clock speed, a 20MB hard drive, and a
    “high-density” 1.44MB floppy drive. And, most notably for us, in 1993, Chris Pressey
    gifted Befunge to the world.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how you view things, Befunge was the world’s first 2D programming
    language. One might argue that Konrad Zuse’s *Plankalkül* was the first because
    its source code included stacked commands, but I think Befunge’s approach is sufficiently
    different to claim the honor. Pressey’s intention for Befunge was to create a
    language that was as difficult to compile as possible. The “Befunge” name is a
    misspelling of “before” as typed on a BBS in the wee hours of the morning. If
    the term BBS is unfamiliar, it stands for “bulletin board system,” which was how
    early personal computer enthusiasts communicated with each other over slow modems
    before the internet became accessible to the general public.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into the world of Befunge to learn how it works and how to write
    code for it. We’ll begin by installing and building the canonical interpreter
    for Befunge-93, after which we’ll take it for a ride with some simple examples.
    Along the way, we’ll learn how to use BEdit, a Befunge-93 editor. You don’t need
    to use BEdit to write Befunge code—any text editor will do—but I found BEdit handy.
    Then again, I wrote it, so I’m biased.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building Befunge-93***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Run the following command to obtain Befunge-93 from creator Chris Pressey’s
    GitHub site.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will get you the latest version, most likely the Silver Jubilee version
    from 2018\. That’s the version we’ll work with.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Befunge interpreter is straightforward. However, before you build
    it, if you wish, I suggest making a small code change to initialize the pseudorandom
    number seed using `/dev/urandom` instead of using `time`, which is how it’s written.
    That way, if you run the interpreter many times within a second, which we’ll do
    later in the chapter, the pseudorandom generator will not produce the same sequence
    repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'I suggest the following steps to build `bef`, the Befunge interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The second command starts a text editor with *bef.c* open. If you don’t use
    `vi` or `vim`, make the appropriate substitution for your typical editor (then
    learn `vim`). Look for `srand`, which should be around line 252\. Then replace
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, use `make` to build the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We want the *bef* executable in the *bin* directory. I encountered no issues
    using `gcc` and suspect you won’t, either. Change to the *bin* directory and test
    the build by typing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Befunge is simple to use. We’ll explore its visual debugger, `-d`, later. You’ll
    probably want to use `-q` to suppress the startup message. I defined an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Befunge is ready. Let’s see how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Printing Text***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Befunge programs live on a playfield that is 80 characters across and 25 lines
    tall. All Befunge commands are a single character. For data, Befunge uses a stack,
    like Forth. Befunge even supports a few Forth primitives to manipulate the stack:
    `DUP`, `DROP`, and `SWAP`. Of all the esolangs we’ve explored, Befunge has the
    richest command set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to get into Befunge is to see it in action. Let’s start with *cow.bf*
    . First, we’ll run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I agree, nothing too impressive. Let’s look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now things are a little more interesting. What are we to make of this
    jumble of characters? Befunge programs, like Piet programs, run in all directions,
    beginning in the upper-left corner (row 0, column 0), with the instruction pointer
    to the right, meaning instructions are evaluated from left to right running along
    the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first row of *cow.bf* is `<v"How now brown cow?"0`. The first instruction
    is `<`, which tells Befunge to change the instruction pointer to move to the left.
    The playfield wraps at the edges and ignores spaces. Therefore, the first instruction
    of *cow.bf* moves flow to the left, which wraps around, ignores spaces, and encounters
    `0` moving right to left. Befunge pushes digits onto the stack, so `0` pushes
    a 0 on the stack. The next instruction is the double quote (`"`), which begins
    string mode. The interpreter then pushes ASCII values of the characters onto the
    stack until it encounters the next double quote. Therefore, the string `How now
    brown cow?` is pushed on the stack in ASCII, one character at a time. However,
    program flow in Befunge moves right to left, so the string is pushed on the stack
    *backward*, starting with the question mark first and ending with `H`. But this
    is exactly what we want because stacks are LIFO data structures. We now have our
    first Befunge idiom: push strings on the stack from right to left so the string
    can be read in code from left to right.'
  prefs: []
  type: TYPE_NORMAL
- en: The character after the leftmost double quote is `v`, which changes program
    flow to down. The very next instruction is `>`, which changes the flow to the
    right again. Then comes `:`, which duplicates the top stack value, the ASCII code
    for `H`.
  prefs: []
  type: TYPE_NORMAL
- en: Program flow is again directed down by `v` to hit underscore (_), the first
    of Befunge’s two conditional commands. The _ command pops the top stack item and,
    if it is 0, changes program flow to the right; otherwise, it goes left. If the
    top stack item is 0, we want to end, as the string has been printed. Recall that
    the first instruction after `<` in the upper left pushed 0 on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: If the top stack item isn’t 0, the string hasn’t been entirely printed yet.
    Therefore, moving to the left from _ uses a comma (`,`) to print the character
    and change the program flow to up. Going up hits `>` on the second line to start
    the loop again.
  prefs: []
  type: TYPE_NORMAL
- en: The _ command encounters the 0 initially pushed on the stack at the beginning
    of the program. This will direct flow to the right to execute `91+,@`. The first
    three commands push the digits 9 and 1 onto the stack and add the digits so the
    stack contains 10\. Even though only single digits can be pushed onto the stack
    in code, the stack itself supports a signed 64-bit integer. With 10 on the stack,
    we hit `,` to print the top stack item as an ASCII character—in this case, a newline.
    To end a Befunge program, execute `@`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now understand how *cow.bf* works. With all this flowing left, right, up,
    and down, it would be nice to *see cow.bf* working. Thankfully, Befunge is cleverly
    made, and by using the `-d` command line option, we can, literally, watch program
    flow happen. This works best when any output is directed to a file. Similarly,
    if there is input from the user, it’s best read from a file. Naturally, a static
    book cannot show you the flow of the program, but the following command will:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once you press ENTER you’ll see the source code at the top of the screen with
    a cursor flowing over each instruction as it is executed. You can watch the loop
    repeat to print each character on the stack before ending. The output is then
    written to the temporary file, *ttt*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using BEdit***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How was *cow.bf* created? You could use a normal text editor, but I used *bedit.py*,
    a simple Befunge editor created in Python. We won’t discuss the code, but do take
    a look if you are curious. Note that the terminal window in which you run *bedit.py*
    must be at least 120 characters wide and 26 lines tall. If not, *bedit.py* will
    happily remind you.
  prefs: []
  type: TYPE_NORMAL
- en: Executing `python3 bedit.py examples/cow.bf` produces [Figure 11-1](ch11.xhtml#ch011fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/11fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: Editing* cow.bf'
  prefs: []
  type: TYPE_NORMAL
- en: The editor has two panes. On the left is a pane of 80×25 characters. This is
    the Befunge playfield where code goes. On the right is a summary of the editor
    and Befunge commands for reference. To move around the code, use the arrow keys.
    Any character you enter will go where the cursor currently is. To make entering
    code easier, typing characters moves in the direction of the last arrow key. Therefore,
    to type from right to left, move the cursor to the left with the left arrow key
    and begin typing. A bit of experimentation is all it takes to get the hang of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Use CTRL-W to write the file and CTRL-E to exit, which will also write the file
    if it has been modified. You must supply the name of the file on the command line,
    whether new or not. Pressing CTRL-H clears the current row from the cursor to
    the right edge. Likewise, CTRL-V clears the current column from the cursor down.
    That’s it; the editor is simple, but I used it to create all the examples in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '***Befunge Says Hello***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we get to genuinely interesting, or at least illustrative, Befunge programs,
    we must look at our obligatory example. Run *hello.bf* to see our favorite greeting.
    Then, bring it up in BEdit to look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one of the more unusual examples of “Hello, world!” we’ve yet seen.
    Note that anywhere the program doesn’t go is fair game for comments, like the
    one on the second line (line 1, counting from 0). We’ll count lines from 0 because
    that’s how computer people count. See if you can figure out how this version works
    (hint: think characters, not strings). It’s not tricky, just unusual because of
    Befunge’s 2D program flow. Because Befunge can’t directly push numbers larger
    than 9 on the stack, larger values must be calculated piece by piece.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-1](ch11.xhtml#ch011tab1) lists Befunge’s commands.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** The Befunge-93 Command Set'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0`–`9` | Push a digit |'
  prefs: []
  type: TYPE_TB
- en: '| `+-*/%` | `( a b -- a op b )` |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | `( a -- !a )` |'
  prefs: []
  type: TYPE_TB
- en: '| ` | `( a b -- a>b )` |'
  prefs: []
  type: TYPE_TB
- en: '| `><^v` | Set instruction pointer direction |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Pointer to random direction |'
  prefs: []
  type: TYPE_TB
- en: '| `_` | Pop; 0 = right, else left |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Pop; 0 = down, else up |'
  prefs: []
  type: TYPE_TB
- en: '| `"` | Push string |'
  prefs: []
  type: TYPE_TB
- en: '| `:` | `( a -- a a )` |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | `( a b -- b a )` |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | `( a -- )` |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Pop; print as integer |'
  prefs: []
  type: TYPE_TB
- en: '| `,` | Pop; print as char |'
  prefs: []
  type: TYPE_TB
- en: '| `#` | Skip next cell (bridge) |'
  prefs: []
  type: TYPE_TB
- en: '| `p` | `( v c r -- )` play[r,c] = v |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | `( c r -- )` push play[r,c] |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Input number; push |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Input char; push |'
  prefs: []
  type: TYPE_TB
- en: '| `@` | Exit program |'
  prefs: []
  type: TYPE_TB
- en: Most commands are easy to understand, but a few, like `#`, `?`, `p`, and `g`,
    are less clear and are the focus of the examples that follow. Note the use of
    Forth-style stack effect comments where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Befunge in Action**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Befunge-93 repository includes many examples in the *eg* directory. That
    said, with one exception mentioned in the discussion, we’ll roll our own examples
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we’ll explore what makes Befunge unique. Naturally, a 2D language
    is unusual, but I find other parts of the language even more interesting in terms
    of thinking about coding.
  prefs: []
  type: TYPE_NORMAL
- en: However, first we must explore flow control and, at the same time, how input
    works. Doing this leaves us well situated to explore other language features.
    After flow control, we’ll explore Befunge’s `#` bridge command, which might seem
    unnecessary at first, but it is really quite clever. After that comes `?`, Befunge’s
    version of a pseudorandom number generator. We close the section with `p` and
    `g`, which enable both data storage in program space and self-modifying code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Going with the Flow***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Flow control in Piet ([Chapter 9](ch09.xhtml#ch09)) was accomplished by setting
    up barriers. Befunge makes life easier by explicitly selecting new directions
    through the playfield, as we saw above with *cow.bf* and *hello.bf* .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through two examples to improve our understanding of flow in Befunge.
    The first example converts a string of binary digits to decimal. The second converts
    text files using DOS line endings to Unix format.
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary to Decimal**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One approach to converting a binary number to decimal is to add the binary digit,
    from left to right, to a running total initialized to 0, then multiply by 2\.
    When all the digits have been processed, divide by 2 to get the final value. Division
    by 2 is necessary because multiplying by 2 sets up for the next digit; however,
    there is no next digit after the last digit is read.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the input is 1101[2], we get the decimal equivalent as
  prefs: []
  type: TYPE_NORMAL
- en: ((((((((0 + 1) × 2) + 1) × 2) + 0) × 2) + 1) × 2) ÷ 2 = 13
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the stack to hold the running total; therefore, the first thing we
    need on the stack is a 0\. Then, we’ll begin a loop to read a character, subtract
    48 to make it a 0 or 1, add it to the running total, and then multiply by 2\.
    When all binary digits are read, divide by 2, print the top stack item as a decimal,
    and exit. Simple.
  prefs: []
  type: TYPE_NORMAL
- en: Well, not quite. How do we know all the binary digits have been read? One of
    two things will happen, both of which affect the value of the input character
    read. If the character is a newline, ASCII 10, then we know input is complete.
    Also, if reading from a file, the input might be end-of-file (EOF), which Befunge
    reports as *–*1\. Therefore, we’ll need to check for both cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-1](ch11.xhtml#ch011list1) presents *bin2dec.bf* .'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: Converting binary strings to decimal*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is fairly compact with only four lines of code. The first line begins
    with `0v` to push 0 on the stack and move down. The next instruction is `>` to
    move again to the right. At this point, we want to read a binary digit and check
    if it’s a newline: `~:55+-|`. The first character (tilde) reads the binary digit
    as a character and places it on the stack. The second character (colon) duplicates
    the character value so we can subtract 10 from it without losing it.'
  prefs: []
  type: TYPE_NORMAL
- en: To get 10 on the stack, we use `55+`, and we use `-` to subtract. The stack
    now contains the running total, which is still 0, the first character, and whatever
    we get from subtracting 10 from the character. If the character is a newline,
    the stack contains 0 and pipe (`|`) will change program flow to down, thereby
    executing `>$2/.55+,@` to drop the extra copy of the final input character, divide
    the running total by 2, print it as a number, output a newline, and exit. Notice
    that `|` is the down/up equivalent of _. It moves program flow down if the top
    stack item is 0 and moves it up otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: If the character isn’t a newline, flow moves up from `|` to `>:1+|`. This block
    of code checks if EOF was read by adding 1 and asking if the top stack item is
    0 or not. If it is, flow goes down from the second pipe to execute the second
    copy of `>$2/.55+,@`, thereby printing the decimal answer.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if the character isn’t newline or EOF, we move to the rest of line 0,
    `>68*-+2*`, to subtract 48, add the 0 or 1 to the running total, and multiply
    by 2\. The final character of line 0 is `v` to direct flow to the final character
    of line 2, `>`, which wraps back around to the beginning of line 2 to get the
    next input character.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to run *bin2dec.bf* . We could just run it and manually
    type the binary number. Or we might use `echo` to send the number to `bef`. Lastly,
    we might use file redirection. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To watch a trace of *bin2dec.bf* , we can use `ttt` as above, but we need to
    use Befunge’s command line arguments. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you watch the trace, you’ll see that the program ends when newline is read.
    We can see the newline explicitly with `xxd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: However, the input file need not have a final newline. In that case, the program
    does not exit by the first pipe, which checks for newline, but by the second pipe,
    which reads EOF (that is, *–*1). The following snippet of Python creates a new
    input file without a final newline.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run *bef* with `-d` as above, substituting `zzz` for `ttt`, and watch carefully.
    The program ends by taking the second pipe. The moral of the story is: care is
    required when deciding whether the input to a Befunge program is complete.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DOS to Unix**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A common issue when moving files from one computer system to another is a mismatch
    in end-of-line conventions. Unix systems end each line of a text file with ASCII
    10\. This is a linefeed and is sometimes called newline. However, Windows systems,
    which are built on MS-DOS, use two characters at the end of each line: ASCII 13
    and ASCII 10\. ASCII 13 is a carriage return. Besides being an unnecessary waste
    of disk space, the carriage return causes trouble with systems that expect only
    a linefeed. ASCII 13 is CTRL-M, so some Unix editors show an extraneous `^M` when
    manipulating files with DOS line endings. Thus, it would be nice to convert such
    files to Unix format. To complicate matters still further, older Macintosh text
    files use only ASCII 13 as the line ending. Thankfully, such text files are becoming
    rare.'
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, there are utilities to convert text file line endings, to say nothing
    of modern text editors that handle DOS files without trouble. But just for a moment,
    let’s pretend it’s still 1993 and our Amiga computer isn’t that influenced by
    DOS. We need a conversion utility, and we happen to have this nifty new language
    called Befunge to play with. Surely it can do what we want.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-2](ch11.xhtml#ch011list2) contains *dos2unix.bf* , a program to
    convert text files with DOS line endings to Unix (and Amiga). Structurally, it’s
    rather similar to [Listing 11-1](ch11.xhtml#ch011list1), but there are some differences.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: Converting DOS line endings to Unix*'
  prefs: []
  type: TYPE_NORMAL
- en: The overall flow of the program is left to right, from column 0 of line 2 on
    over. The first block of code, `~:1+|`, reads a character and ascertains whether
    it is EOF. If so, we’re done and `@` calls it a day. If not, we need to check
    if the character read is ASCII 13, which is precisely what `>:85+-|` does. If
    we subtract 13 and get 0, then the character is ASCII 13\. In that case, take
    the branch on line 2, `>$~:55+-|`, which drops the extra ASCII 13, reads the next
    input character, and checks if it’s ASCII 10\. If it is, we want to keep it, so
    `>^` moves up to `>>,` to print it. If the second character read isn’t ASCII 10,
    we have an embedded ASCII 13, which is weird, but whatever, we’ll keep it. That’s
    the top branch of the second pipe on line 2\. Lastly, if the pipe in line 1 does
    not move down, it moves up to print the input character. This is the path taken
    for most of the characters read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s test *dos2unix.bf* . To run it with redirection, use the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The input file, *ttt.dos*, uses DOS line endings. The output of `xxd` shows
    the carriage return and linefeed characters as `0d0a`. The output, *ttt.unix*,
    has only `0a`, as it should.
  prefs: []
  type: TYPE_NORMAL
- en: I admit that the two examples in this section are not the most beguiling. However,
    they help check your understanding of how Befunge works. Writing programs is more
    fun than reading them, so I encourage you to give something similar a go. Perhaps
    a utility to take a Unix text file and spit out a DOS version? When you are ready,
    move on to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building Bridges***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The command that likely made the least sense at first blush when you read through
    [Table 11-1](ch11.xhtml#ch011tab1) was `#` (hash mark), the bridge command. This
    command skips the next instruction, acting as a bridge to move over it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a Befunge program consisting of only `88*1+#.,` will print the
    letter *A* forever. The first part, `88*1+`, puts 65 on the stack. Then, `#` skips
    the next instruction, which is a period to print `65`, and instead hits the comma
    to print ASCII 65, which is `A`. That is all the text on the first line, so the
    instruction pointer will wrap around to repeat it, over and over ([Listing 11-3](ch11.xhtml#ch011list3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-3: One use for the bridge instruction*'
  prefs: []
  type: TYPE_NORMAL
- en: The `#` skips the next instruction—why on earth would we want to do that? One
    reason for `#` is found in *bridge.bf* ([Listing 11-3](ch11.xhtml#ch011list3)),
    which does nothing more than print the word `xyxxy`. If you hear a hollow voice
    saying “fool,” fear not. (And if you don’t understand that reference, fear not
    as well.)
  prefs: []
  type: TYPE_NORMAL
- en: As with the *cow.bf* example above, *bridge.bf* moves from right to left and
    loops to print character after character. However, in this case, consider line
    1, `>:#v_82+,@`. From left to right, the commands are to move right, duplicate
    the character at the top of the stack, and then skip the `v` command but execute
    the underscore (_), which moves to the right if the top stack item is 0 and moves
    to the left otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s where we see the utility of bridge. If the character is 0, go right to
    push 10 on the stack, print the newline character, and exit. Otherwise, move left.
    The first instruction moving left from _ is `v`, the very instruction `#` skipped
    when moving from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Executing `v` moves down, then left, to print the character and ultimately loop
    around to process the next character. So the bridge command is essential in this
    case as it allows one set of commands when the program flows to the right while
    executing a different set of commands when it flows to the left. Keep this behavior
    in mind because we’ll see it again in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Fun with Dice***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Befunge’s `?` command randomly changes the instruction pointer’s direction.
    It might be up, down, left, or right. Let’s have some fun with this unusual instruction.
    At first blush, we might think it useless: who wants a program that isn’t deterministic?
    Then again, random numbers are frequently used in everything from games to simulations.
    Can we press `?` into similar service?'
  prefs: []
  type: TYPE_NORMAL
- en: As `?` selects a new instruction pointer direction, it seems reasonable we might
    use it to simulate dice. In particular, `?` selects from four possible directions,
    so we might simulate what gamers call a D4, which is a die with four sides instead
    of the usual six.
  prefs: []
  type: TYPE_NORMAL
- en: How can `?` help us here? Well, if we encounter `?`, there are four possible
    directions to go, so if we push a 1, 2, 3, or 4 depending on which direction is
    selected, we’ll get our four-sided die.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-4](ch11.xhtml#ch011list4) shows one approach to simulating a four-sided
    die.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-4: Simulating a four-sided die*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we move to `?` by moving down to line 1, then right. Notice the
    bridge instruction in line 1\. When moving to the right, we want to skip the `v`
    instruction to reach `?`. If `?` selects to move to the left, we hit the `v` to
    move to line 2 and push 1 on the stack. Likewise, the other three directions away
    from `?` end up pushing 2, 3, or 4 before hitting line 3, which moves to the right
    to print the selected value.
  prefs: []
  type: TYPE_NORMAL
- en: If we run *die4.bf* 10,000 times, we expect each outcome value to appear with
    roughly equal frequency. One such experiment of 10,000 runs produced `[2472, 2577,
    2452, 2499]` as the respective number of 1s, 2s, 3s, and 4s. The values are similar,
    so it’s fair to say our four-sided die program works.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-5](ch11.xhtml#ch011list5) shows a first attempt at simulating a
    standard six-sided die.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-5: Attempting to simulate a six-sided die*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If nothing else, [Listing 11-5](ch11.xhtml#ch011list5) is nice and symmetric.
    I toyed with putting it on a t-shirt. Flow moves down the center from top to bottom.
    When the interpreter encounters a `?`, moving back up forces flow back into `?`,
    leaving only three exits: to either side or down. If to the side, a number from
    1 to 6 is pushed on the stack and printed, and arrows move flow to the bottom
    to print a newline before exiting.'
  prefs: []
  type: TYPE_NORMAL
- en: There are six numbers, so surely this arrangement is appropriate. If you run
    this version 10,000 times, you might get a distribution similar to `[3337, 3333,
    1072, 1109, 543, 606]`, which is not at all uniform. [Listing 11-5](ch11.xhtml#ch011list5)
    can be found in *die6_biased.bf* , and as you might expect from the name, it is
    a loaded die that strongly favors 1s and 2s.
  prefs: []
  type: TYPE_NORMAL
- en: From the counts, the ratio between 1s and 2s to 3s and 4s then 5s and 6s is
    6:2:1, meaning one is six times as frequent as six. If we look at the structure
    of [Listing 11-5](ch11.xhtml#ch011list5), we can calculate the probabilities associated
    with each outcome. The first `?` has a 1 out of 3 chance of selecting 1, 2, or
    moving on to other numbers. Therefore, the probability of choosing a 1 or a 2
    is 1/3 + 1/3 = 2/3\. That means the sum of the remaining probabilities, those
    for selecting 3 through 6, must total 1/3\. Selecting 3 or 4 is similar to 1 or
    2—there is a 1 out of 3 chance—but it’s 1 out of 3 from what is already a 1 out
    of 3 chance. Therefore, there is a 1 in 9 chance of selecting 3 and the same for
    selecting 4\. The final 1 in 9 chance is split evenly between choosing 5 or 6,
    or 1 in 18 each.
  prefs: []
  type: TYPE_NORMAL
- en: If the probabilities above are correct, they must add up to 1\. Let’s use Scheme
    to check that they do.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our calculations are correct. Clearly, we don’t want [Listing 11-5](ch11.xhtml#ch011list5),
    aesthetics aside. So how can we use something that selects 1 in 4 to get something
    that selects 1 in 6 with equal probabilities?
  prefs: []
  type: TYPE_NORMAL
- en: If we restrict `?` to select one of two options only, we can use each of those
    outputs to choose another pair, thereby changing two options into four. Do the
    same for each of the four, and we have eight outputs, each equally likely to be
    selected. We only want six of the eight, so if either of the remaining two are
    selected, we repeat until one of the six is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways to write such an algorithm. The file *die6.bf* holds
    one of them (see [Listing 11-6](ch11.xhtml#ch011list6)). Take a moment to look
    at the code to absorb what it means. Then linger a little longer to appreciate
    the code’s ethereal beauty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-6: Simulating a six-sided die with equal probabilities*'
  prefs: []
  type: TYPE_NORMAL
- en: The rightmost instructions push 1 through 6 on the stack. However, if flow reaches
    the top or bottom, it continues to the right to wrap around and move back to the
    beginning until one of the six desired paths is selected.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code in [Listing 11-6](ch11.xhtml#ch011list6) 10,000 times gives
    us frequencies of `[1678, 1638, 1705, 1660, 1637, 1682]`, which is exactly what
    we want; each outcome is now equally likely. As an exercise, see if you can come
    up with arrangements of `?` to simulate an 8-sided die, 12-sided die, or even
    20-sided die.
  prefs: []
  type: TYPE_NORMAL
- en: '***Wandering Around***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The file *brownian.bf* contains a program where the entire playfield is filled
    with `?` and nothing else. Running this program on its own is boring; it produces
    no output and never ends. However, running it with Befunge’s debugger is mesmerizing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The cursor wanders over the playfield in a way that is reminiscent of Brownian
    motion, the random motion of particles in some medium.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, take a look at *zero.bf* . It consists of an entire playfield
    of `?` commands with a single period (`.`) in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: Befunge never throws an error because of the stack. If you attempt to pop the
    stack when it is empty, Befunge returns 0\. The print command pops the stack,
    so printing when the stack is empty outputs 0\. If you run *zero.bf* with the
    debugger, you might think you’re in for a long wait to hit the one print instruction.
    However, if you run *zero.bf* without the debugger, your screen will quickly fill
    with 0s. Human perception of how fast computers operate is orders of magnitude
    too slow. Computers are so much quicker than we can appreciate that even a simple
    interpreter like Befunge randomly hits that one print command at a tremendous
    rate. In fact, dumping the output to the screen is slow. Direct the output to
    a file instead, and even my old system has Befunge printing nearly 15,000 0s per
    second.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it turns out my statement about Befunge not throwing stack errors
    is incorrect. Run this program: `00/.@`. I consider it an Easter egg.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Updating the Playfield on the Fly***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Befunge programs live in the playfield and memory is restricted to the stack.
    Or is it? The `p` instruction lets the programmer write to the playfield as the
    program runs. If the altered cell happens to be part of the running program, and
    the value written is the ASCII code for a valid command, then Befunge will use
    that command. This means that Befunge allows self-modifying code, which, under
    normal circumstances, is taboo. But we’re working with esolangs, so what was forbidden
    may be permitted. Use `p` to write to the playfield and `g` to read from it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore `p` and `g` with two examples. The first converts an integer less
    than 65,536 (= 2^(16)) to a four-digit hexadecimal number. The second is a simple
    calculator.
  prefs: []
  type: TYPE_NORMAL
- en: '**What the Hex?**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Old-school BASIC used `DATA` and `READ` to store data in source code. These
    were usually instructions for small machine language routines that were `POKE`d
    into memory and later `CALL`ed from BASIC. We can use `g` similarly to read data
    from the playfield.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a number, *v*, on the stack. We’ll assume it’s positive and
    less than 65,536\. Our task is to convert this number to four hex digits and print
    them. One way to do this is to split *v* in two by replacing it with *v*/256 and
    *v* mod 256\. Then, if we do the same with the split values using 16 in place
    of 256, we’ll extract the four hexadecimal digit values.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the user enters 1234, the sequence of operations leads to
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: or (0,4,13,2) = 04*D*2[16] = 1234.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put this algorithm to the test and, at the same time, use `p` and `*g*`
    because we can. The code we need is in *dec2hex.bf* and is shown in [Listing 11-7](ch11.xhtml#ch011list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-7: Converting decimal to hex*'
  prefs: []
  type: TYPE_NORMAL
- en: The program flows in a zig-zag pattern, row by row, beginning with line 1\.
    First, the user is asked for a number (`&`), after which comes the division and
    modulo by 256\. At the end of the line, *v*/256 and *v* mod 256 are on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Line 2 runs from right to left. Flipping the instructions, the interpreter executes
    `:82*/20p82*%10p`. Let’s break this down a bit. The first instruction duplicates
    the top stack item, *v* mod 256\. Next, `82*/` divides the top stack item by 16,
    thereby calculating the second digit of the answer. To store it in the playfield,
    we use `20p`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-1](ch11.xhtml#ch011tab1) says the `p` instruction expects three values
    on the stack: the value to store, the playfield column, and the playfield row.
    Therefore, `20p` stores the second digit value in row 0, column 2\. The remainder
    of line 2 uses modulo to get the value of the first digit and places it in `10p`,
    row 0, column 1\. Line 3, running left to right, repeats the calculation to find
    the values of digits 3 and 4.'
  prefs: []
  type: TYPE_NORMAL
- en: When line 4 begins, again running right to left, we have the digit values in
    row 0 of the playfield. We now need to print them as ASCII characters. You’ve
    likely noticed the string `0123456789ABCDEF` in line 0\. We’ll use this string
    to get the characters we need. This is the Befunge equivalent of `DATA` in BASIC
    or FORTRAN. The digit value serves as an index into this string.
  prefs: []
  type: TYPE_NORMAL
- en: Flipped, line 4 is `40g5+0g,`. The first part, `40g`, reads the value of digit
    4, which is the most significant digit. To index the proper character, we must
    add 5, then another `g` pulls the proper character, placing its ASCII value on
    the stack for `,` to print. The remainder of [Listing 11-7](ch11.xhtml#ch011list7)
    prints the rest of the answer and a newline and then ends.
  prefs: []
  type: TYPE_NORMAL
- en: Running *dec2hex.bf* shows that the program works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s more interesting to run this example with the debugger. For example, if
    the temporary file *ttt* contains an integer, say 6,502, we might run the code
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: While the code executes, watch the top row carefully. You’ll see four lights,
    er, dots appear. These are the specific digits placed in the playfield by the
    `p` instructions. When the program ends, the output is in another temporary file,
    *qqq*, which contains 1966[16] = 6502.
  prefs: []
  type: TYPE_NORMAL
- en: Using the playfield to store program data is a handy option. Using the playfield
    to alter program execution is the next step. Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: '**Program Transmogrification**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Self-modifying code, or, as I like to call it, *program transmogrification*,
    is seldom used and with good reason. However, Befunge supports it, and there are
    times it’s more handy than not. For example, a calculator program needs to accept
    a number, an operator, and another number. The code is much the same regardless
    of the operator, as long as the operator is binary. Befunge supports five binary
    arithmetic operators: `+`, `-`, `*`, `/`, and `%`. Let’s make a simple calculator
    that lets users enter a single digit, the desired operator, and a second digit
    before calculating and printing the answer.'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we might implement such a calculator with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We’re assuming the existence of a function, `getch`, that returns a single character
    from the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code would do the trick, but its highly repetitive `if` statement
    isn’t particularly attractive. If we know the operation is addition, the code
    becomes simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the operation is division, the code is the same; just replace `+` with `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to our Befunge calculator is in the phrase, “just replace *X* with
    *Y*.” That is exactly what we’ll do: we’ll write the program as if the operator
    were always addition, but modify the program source in the playfield during program
    execution to use the user’s actual operator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithmically, then, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a single digit character from the user and convert it to a number on the
    stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a single operator character from the user and place it in the proper location
    in the playfield so Befunge uses it when calculating the answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a second digit from the user on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the operation and print the answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 11-8](ch11.xhtml#ch011list8) shows *calc.bf* . It’s even shorter than
    the description of what it does.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-8: Program transmogrification in action*'
  prefs: []
  type: TYPE_NORMAL
- en: The first part reads a character, assumed to be a digit, and subtracts 48 to
    convert it to an integer. That’s `~68*-`. The program then asks for the operator,
    which it places in row 1, column 6 (`~61p`). If you look at row 1, column 6, you’ll
    see it contains a `+`, which is overwritten by the operator character the user
    enters—program transmogrification!
  prefs: []
  type: TYPE_NORMAL
- en: The rest of line 0 gets the second digit, prints a space, an equals sign, and
    another space. Line 1 applies the updated operation, prints the result and a newline,
    and exits. Let’s see [Listing 11-8](ch11.xhtml#ch011list8) in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The stated goal of Befunge was to make a language that is too hard to compile,
    so it makes sense to allow self-modifying code. In this particular case, especially
    given how Befunge works as a programming language, a bit of self-modification
    was the more elegant solution. Without it, *calc.bf* would have to be much larger:
    it would need to enable comparing the operator character with each of the five
    possible operators along with a different code path for each operator. This would
    definitely not be as elegant.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Befunge-93 is imperative, and the stack is of arbitrary size, limited only
    by the computer’s RAM, so we might think it’s Turing complete. However, it isn’t.
    What keeps it from being Turing complete is a limitation many other languages
    do not have: the program *must* fit in the playfield, as that’s all the room there
    is. Therefore, programs cannot be arbitrarily complex and Befunge-93 is not Turing
    complete.'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that in the previous paragraph, I was careful to type “Befunge-93.”
    A later version of Befunge, Befunge-98, removes the limitation on playfield size
    and therefore *is* Turing complete. However, I felt an affinity for the original,
    which is why we worked with it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web has many additional resources for Befunge, though not at the scale
    of BF or even Piet. The best resources for Befunge are *[https://esolang.org/](https://esolang.org/)*
    and Chris Pressey’s site (*[https://git.catseye.tc/Befunge-93/](https://git.catseye.tc/Befunge-93/)*).
    I also found this interview with Pressey interesting: *[https://esoteric.codes/blog/interview-with-chris-pressey/](https://esoteric.codes/blog/interview-with-chris-pressey/)*.
    Befunge figures prominently. Last of all, if you’re like me, you’ll find plenty
    to explore and think about by examining all of Pressey’s site, including the many
    other programming languages he’s developed over the years (*[https://catseye.tc/](https://catseye.tc/)*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Befunge has been written in Befunge—see the included *befunge.bf* file. It’s
    from the esolang wiki. To use it, run *befunge.bf* , passing in the Befunge program
    you want to run from standard in. If the program has input, separate the program
    text from the input with a semicolon (`;`). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is quite impressive and reinforces the argument that Befunge-93 would be
    Turing complete if there were enough program space. The `2>` redirection ignores
    the Befunge error messages that you’ll see if you don’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: It just happens that the Befunge interpreter in Befunge fits in the playfield.
    The esolang wiki does not provide authorship information for *befunge .bf* , so
    I’m not sure who we should thank for such a clever implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 2D programming is cute and much in line with what a “good” esolang is—something
    outside the box. The clever bits, to me, are seeing the utility of an instruction
    like `#`, the bridge instruction, and with it the recognition that programs running
    in multiple directions might want to do slightly different things when running
    left to right or right to left, even for the same line of code. Using single-digit
    numbers, knowing any number can be built on the stack as needed, is also quite
    clever.
  prefs: []
  type: TYPE_NORMAL
- en: Good esolangs inspire other esolangs. Befunge is no different. For example,
    if there is a 2D language, then why not a 3D language? Interested? If so, take
    a look at Suzy (*[https://github.com/gvx/suzy/](https://github.com/gvx/suzy/)*).
    However, be aware that it hasn’t been updated for more than a decade, so use Python
    2.*X* to run its examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about other 2D languages? Befunge has inspired so many esolangs that a
    term has evolved just to describe them: *fungeoids*. The esolang wiki lists pages
    of fungeoids at *[https://esolangs.org/wiki/Category:Two-dimensional_languages](https://esolangs.org/wiki/Category:Two-dimensional_languages)*.
    If imitation is the sincerest form of flattery, then Befunge should feel abundantly
    flattered, provided Befunge can feel anything, of course.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Befunge was the target of this chapter. We learned that Befunge is the first
    2D programming language, has been around long enough to have a silver jubilee,
    and is fun to program in. We also learned that Befunge has inspired a swarm of
    related esolangs: the fungeoids.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, with that, our exploration of existing esolangs draws to a close. [Part
    I](part01.xhtml#part01) of the book discussed the essentials of programming languages.
    [Part II](part02.xhtml#part02) prepped us for esolangs by studying atypical programming
    languages, and [Part III](part03.xhtml#part03) explored existing esolangs. Now
    we move to [Part IV](part04.xhtml#part04) to implement two homegrown esolangs:
    Filska and Firefly.'
  prefs: []
  type: TYPE_NORMAL
