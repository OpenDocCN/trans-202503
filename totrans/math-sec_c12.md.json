["```\ndef concat_str(a, b):\n    **'''**\n **Returns the concatenation of string 'b' to string 'a'.**\n **Parameters:**\n **a (str): A string literal**\n **b (str): Another string literal**\n **Returns:**\n **concat_str (str): String after adding 'b' to the end of 'a'**\n **'''**\n    concat_str = a + b\n    return concat_str\nprint(concat_str.__doc__)\n```", "```\nimport pygame, sys\nimport state_manager as state\n❶ for event in pygame.event.get():\n  ❷ if event.type == pygame.QUIT:\n        `--snip--`\n        sys.exit()\n    elif event.type == pygame.MOUSEBUTTONDOWN:\n      ❸ state.handle_click(event)\n    elif event.type == pygame.KEYDOWN:\n pygame.event.clear(None)\n        state.handle_keydown(event)\n    elif event.type == pygame.KEYUP:\n        state.handle_keyup(event)\n  ❹ elif event.type != pygame.MOUSEMOTION:\n        print(event.type)\n```", "```\ndef handle_keydown(event):\n    global shifted\n    global controlled\n  ❶ if event.key in [303, 304]:\n        # Shift key depressed.\n      ❷ shifted = True\n        return\n  ❸ if event.key == 306:\n        controlled = True\n        return\n  ❹ if event.unicode == \"z\":\n      ❺ undo()\n```", "```\ndef handle_keyup(event):\n    global shifted\n    global controlled\n if event.key in [303, 304]:\n        shifted = False\n        return\n    if event.key == 306:\n        controlled = False\n        return\n```", "```\ndef handle_click(event):\n  ❶ clicked = check_clicked_existing_vertex(event.pos)\n  ❷ in_room = check_clicked_within_room(event.pos)\n  ❸ if event.button == 1:\n        `--snip--`\n      ❹ left_click(event, clicked, in_room)\n    elif event.button == 3:\n        `--snip--`\n      ❺ right_click(event, clicked, in_room)\n```", "```\nimport threading, os, Image\n❶ class DisplayAGP(threading.Thread):\n    open_image = None\n  ❷ def set_file(self, bgd_file):\n        self.open_image = bgd_file\n\n  ❸ def run(self):\n        file, ext = os.path.splitext(self.open_image)\n        im = Image.open(self.open_image)\n      ❹ im.show()\n        return\n```", "```\nfor fp in image_files:\n    t = DisplayAGP()\n    t.set_file(fp)\n    t.daemon = True\n    t.start()\n```", "````### Processor Parallelism    One of the major drawbacks to threading parallelism is that all the threads live in one application, which in turn lives in one section of your processor. Chances are your computer, phone, tablet, and probably even your toaster have multiple cores in their central processors. Threads load all the workers onto one core while the other cores sit idle (at least from Python’s perspective), losing all the advantages of modern computer architecture. *Processor parallelism* (also called *multiprocessing*) aims to address this limitation by enabling multiple copies of an application to communicate with one another ([https://docs.python.org/3/library/multiprocessing.html](https://docs.python.org/3/library/multiprocessing.html)). By splitting the work across separate instances of an application, you allow your processor to divide the work among all the cores. These cores are each independent little processors that can execute instructions on the same clock cycle as the other cores, making it the truest form of parallelism available in Python. Going back to our test grading analogy, this would be like giving each grader their own copy of the answer sheet to take home and work from. The graders would each get a copy of the resources they need to complete their portion of the tests (such as the answer key and a stack of questions), but they could also use whatever additional resources they have access to at home (such as a faster computer). Each grader operates in their own environment, completely independent of the other people grading papers. Once someone finishes grading their portion of the tests, they bring their graded answers back to you (the teacher, or main process), who then compiles the individual responses into final scores.    [Listing 12-7](#listing12-7) shows how we can call a separate process to solve a multifloor project.    ``` def mp_solve_floors(floors):   ❶ ctx = mp.get_context('fork')   ❷ q = ctx.Queue()     p = ctx.Queue()     procs = []     for i in range(0,len(floors)):       ❸ proc = ctx.Process(target=mp_agp_solver, args=(p,q))       ❹ proc.start()         procs.append(proc)     results = []     for f in floors:         `--snip--`       ❺ p.put(work_item)  while True:       ❻ results.append(q.get())     for proc in procs:       ❼ proc.join()     return results ```    Listing 12-7: Using multiprocessing to solve floors concurrently    The `mp_` preface in the function name `mp_solve_floors` is a standard way to denote functions that are designed to be part of a multiprocessing architecture. The function expects a list of `Polygon` objects representing the floors to be solved using the AGP solver we developed in the previous chapter.    We first define the context that we’ll use to create the other processes. There are a few options, and the best one depends on your use case and the underlying system. The `fork` ❶ context will create a new process that has a copy of all the variable values in the main process. It’s also fairly stable across different underlying operating systems, making it a good choice for this application.    Once the process has been created, the values change independent of the main process, so we need a way to communicate between processes. A common way to synchronize information between the main process and the worker processes is to create one or more shared queues, using the `Queue` class ❷. Typically, you want to create a queue for each direction of communication you want to support. In this case, the `p` queue will be used to send work objects to the worker processes, and the `q` queue will be used by the worker processes to send the solutions back to the main process.    Once we have our queues, we loop over each floor in the list and create a solver process. The `target` parameter tells the process what function to call when the `start` method is called from the main thread ❹. The target for these processes is `mp_agp_solver` function ❸, which we’ll go over in a moment.    Notice that we pass in the two queues to every `mp_agp_solver` process as it is created. These work queues are how the different subprocesses will communicate with the main process. The main process will send work to the subprocesses using the `p` queue and receive the results back using the `q` queue. Once all the processes have been instantiated, we add each floor to the work queue by calling `p.put(w)` ❺ (where `w` represents the piece of work being sent—in this case, a `Polygon` representing the floor of the gallery).    At this point, the solvers can begin their work. As they complete the solution for each floor, they’ll place the output into the return queue. The main thread continues to look for results in the queue until it receives a solution for every floor (based on the solution count matching the floor count). When it finds a result in the queue, it appends it to the `results` list ❻. Once all the results are received, the main process loops over all created processes and calls the `join` ❼ function, which essentially ends the process’s execution.    Next, let’s cover the changes necessary to the solution code to make it pull the work from the queue. [Listing 12-8](#listing12-8) shows the `mp_agp_floorplan` function that’s called as the target of each subprocess.    ``` def mp_agp_floorplan(p, q):     work = None     while work == None:         floor = p.get()     `--snip--`     q.put(solution) ```    Listing 12-8: Modifying the solver for use in multiprocessing    The major change to the solution code from [Chapter 11](c11.xhtml) is that we now add a `while` loop that tries to continuously get a floor to solve from the incoming queue `p` with `p.get`. Once the work object is received, the snipped portion of the code performs the steps for solving a floor plan we defined in the previous chapter, including converting the polygons to a graph, tessellating the floor shape, applying the greedy coloring algorithm, and so on. Once the floor plan has been solved, the graph object, Triangle result, and the coloring solution are packaged into a dictionary called `solution`, which is passed back to the main process using the outgoing queue with `q.put`.    Using parallelism to speed up your application and allow concurrent operations is an excellent way to move from the concept phase to a full-fledged application: most users have come to expect snappy performance. To get the most out of Python’s parallel processing options, you should read the documentation for both the threading and the multiprocessing libraries. Thankfully, the developers of the multiprocessing library (the later of the two) had the good sense to model its API after the threading library, which was already very popular.    ## Adding a Graphical User Interface    Perhaps the largest single change from a proof of concept to a minimum viable product is the addition of a graphical user interface (GUI). Most users expect to be greeted by some visual workspace when running a program, and adding one makes your program accessible to the general public. Unfortunately, designing and developing a GUI can get very complex very quickly; there can be hundreds of components like buttons, text, and images that need to be managed. Users have different sizes and types of screens, which means laying out visual elements properly requires lots of additional code that you must account for. Furthermore, graphic elements like buttons aren’t static. When you click a button, the program provides some kind of audio or visual feedback (such as darkening the button to make it look like it’s been pressed). While this isn’t a book on programming graphics in Python (a topic on which there are numerous tomes already), I couldn’t totally ignore the topic: the graphics code makes up a large percentage of the project’s total code base. Thankfully, PyGame has a collection of tools to help ease the pain. I’ll cover some basic examples here to keep the code short and understandable.    ### Displaying and Managing Images in PyGame    The `Display` and `Surface` classes make up the base of the graphics platform. The `Display` class handles interfacing with the user’s screen and contains parameters related to the video system as well as code to modify how the interface is displayed onscreen. The `Surface` class holds collections of elements that should be displayed together. Each copy of the `Surface` class is like a blank canvas. Typically, you’ll have one `Display` class and one or more `Surface` classes to handle different (visually distinct) sections of the application ([https://www.pygame.org/docs](https://www.pygame.org/docs)).    [Listing 12-9](#listing12-9) shows the simplest example of using the `Display` class.    ``` import pygame ❶ pygame.init() ❷ background = pygame.image.load(\"guggenheim.tif\") ❸ screen = pygame.display.set_mode(background.get_rect().size, 0, 32) background = background.convert() running = True ❹ while running:     for event in pygame.event.get():         if event.type == pygame.QUIT:             running = False   ❺ screen.blit(background, (0, 0))     mid_x = screen.get_width() / 2     mid_y = screen.get_height() / 2   ❻ pygame.draw.circle(screen, (0, 255, 0), (mid_x, mid_y), 50)   ❼ pygame.display.flip() ❽ pygame.quit() ```    Listing 12-9: Displaying graphics using the PyGame display module    We start by initializing a PyGame application with `pygame.init` ❶. The `init` function performs a series of background steps that, among other things, let your system know Python needs to interface with the video display. We load the background image (in this case, the Guggenheim floor plan) using the `pygame.image.load` ❷ function. The `background` variable now holds a copy of the image data, which we can use to retrieve the width and height required to display the image with `background.get_rect().size`.    We pass this information as the first parameter to the `pygame.display.set_mode` function ❸ to create a `Surface` object that’s the exact size of the background image. Before we can display the image, though, we need to convert it from the intermediate data format PyGame uses into a format that can be drawn to the screen faster. We begin the program loop ❹ by defining a sentinel named `running` that will remain `True` until the user executes the `pygame.QUIT` event. Everything inside the program loop is executed on each run, which allows us to update the graphic elements and create basic animations.    We tell PyGame to draw the background image on the next update by calling the `screen.blit` function ❺ with the converted background image object and the location on the `Surface` to place the image (based on the location of the image’s upper-left corner). We can then place additional graphics on top of the background floor plan.    We first add a circle to the display using the `pygame.draw.circle` function ❻. The circle doesn’t mean anything at the moment, but it does show how we can combine background images and shapes drawn with code. We pass the function the screen to draw on as the first argument. Next, we choose a color to draw with; you can use an RGB tuple (as shown in the example) or a hexadecimal color code. After that, we pass in the midpoint location (the center point for the circle) to tell PyGame where to place the drawing relative to the screen. Rather than hardcoding these values, we can calculate them relative to the size of the screen. We place the circle in the middle of the screen by taking half of the screen’s width and height parameters as the x- and y-coordinates, respectively. The benefit of using relative position is that we don’t need to change the location of objects manually if we resize the screen. The drawback is that the logic for laying out lots of graphics can become fairly long and tedious to develop.    Once we’ve laid out all the necessary graphic elements, we call the PyGame `display.flip` function ❼, which updates the whole screen area with any graphic changes. At this point, the whole loop then starts over. The loop continues until the user executes the `pygame.QUIT` event, which sets `running` to `False`; on the next loop check, the `while` loop is exited and the `pygame.quit` function is called ❽.    [Figure 12-2](#figure12-2) shows the result of running the code in [Listing 12-9](#listing12-9).  ![](image_fi/502567c12/f12002.png)    Figure 12-2: Drawing graphics onscreen with PyGame      This figure shows the loaded floor plan for the Guggenheim museum along with a large, black circle (which will be green when you see it onscreen) in the center of the image. The circle is on top of the floor plan because of the order in which we drew the items. Of course, drawing a circle in the middle of the screen isn’t very useful, so we’ll combine the positional information from `MOUSE_CLICK` events with the ability to draw shapes onscreen for more advanced functionality.    I highly recommend you dive into the `Display` and `Surface` class documents, as we’ve only scratched the surface here.    ### Organizing Graphics with Sprites and Layers    The problem with the previous method of drawing to the screen is that we’re drawing all the graphics directly on the same surface, which means that if we want to remove the circle at some point later in the code, we’d need to clear the screen and then redraw the entire background. You can imagine how this would scale. If you have dozens of components onscreen, you’d need to redraw each of those as well. Drawing and redrawing the screen can become a computationally expensive task, which will make the program appear choppy.    A better method is to split up the graphics into individual components that can be displayed, removed, or changed without the need to modify the entire screen. To do so, we use a special class called a sprite, which you might be familiar with if you’ve ever worked with animation software. A *sprite* is a combination of the visualization of an element and the code to interact with it. For example, when a user draws a polygon representing a portion of a gallery (called a `Room` in the code), the `Polygon` is placed in a `Sprite` object that adds functions for showing or hiding the room on the display, as well as code to add obstacles (holes) to the room.    [Listing 12-10](#listing12-10) shows a simplified version of the `Room` sprite class.    ``` ❶ class Room(pygame.sprite.Sprite):     color = (0,0,255) # Default to blue     WHITE = (255,255,255)     def __init__(self, vertices, screen_sz):         super().__init__()       ❷ self.vertex_list = vertices       ❸ self.surface_size = screen_sz              def init_surface(self):         self.screen = pygame.Surface(self.surface_size)       ❹ self.screen.fill(WHITE)       ❺ self.screen.set_colorkey(WHITE)       ❻ pygame.draw.polygon(             self.screen,             self.color,             self.vertex_list,             0 # Filled polygon         )   ❼ def clear_surface(self):         self.screen.fill(WHITE)         self.screen.set_colorkey(WHITE) ```    Listing 12-10: Creating a custom sprite class for `Room` polygons    Every custom sprite class you write begins by extending the `pygame.sprite.Sprite` class, either directly, as shown here ❶, or by extending another class derived from the original `Sprite` class. The rest of the class definition is identical to other classes. You can assign class attributes and use the `__init__` function to customize each instance of the class. In the `__init__` function, we set the instance’s `vertex_list` attribute (the exterior points of the polygon to be drawn) ❷ and the `surface_size` attribute ❸ (the size in pixels of the surface used to display the drawn polygon).    The `init_surface` function creates the actual `Surface` object in the attribute named `screen`, which will hold the drawn polygon data. By default, drawing a polygon on a screen will result in a solid background around the exterior of the polygon shape. When laid over the background image, this additional color will block portions of the floor plan from view, which is no good. We can make the background transparent by filling the surface with a color (white in this example) ❹ and then calling the `set_colorkey` function ❺ with the same color. The `set_colorkey` function makes the pixels that match the key color transparent. The effect in our application is to hide everything but the shape of the polygon so you can lay it over the floor plan without needlessly blocking sections.    We draw the polygon to the surface using the `pygame.draw.polygon` function ❻. Note that the last parameter you pass in represents the line thickness to draw with. Setting the thickness to `0` tells PyGame to completely fill the polygon with the color you pass in. Make sure the color you pass to the `set_colorkey` function is different than the one used to draw the polygon, or you’ll remove the polygon as well.    Finally, the `clear_surface` function ❼ uses the same `set_colorkey` trick to make the surface completely transparent, which is useful for temporarily hiding the polygon on the screen, without completely removing it.    The `Room` class also has several functions that it inherits from the parent `Sprite` class, such as `add`, `remove`, and `update`, all of which allow you to control the sprite’s behavior after it has been created. [Listing 12-11](#listing12-11) shows how you can use the `Room` class to define a polygon overlay.    ``` gallery_poly = [(20, 10), (20, 20), (55, 148), (145, 145)] `--snip--` poly_sprite = Room(gallery_poly, background.get_rect().size) poly_sprite.init_surface() screen.blit(poly_sprite.screen, (5,5)) `--snip--` ```    Listing 12-11: Using the `Room` sprite to display a polygon    First, we define a polygon to display as a list of vertices named `gallery_poly`. You can take these points from user input (like a series of mouse clicks) or load them from a file, as long as the data is in (*x*, *y*) format.    We define the sprite to hold the polygon data by calling the `Room` initialization method defined in [Listing 12-10](#listing12-10). We prepare the polygon for display by calling the `init_surface` function. Finally, we call the `blit` function on the main display `screen` and pass in the polygon’s screen attribute with `poly_sprite.screen`. Blitting the sprite’s screen onto the main screen tells PyGame to update the display with the information from the sprite.    You can see the result of this code in [Figure 12-3](#figure12-3).  ![](image_fi/502567c12/f12003.png)    Figure 12-3: Drawing a polygon with a sprite      By combining the techniques of capturing user input, drawing directly to the screen, and using sprites to manage more complex graphic elements, you can come up with exquisitely detailed interactive displays to allow your users to complete their tasks. My advice for interface development is to start simply and build up, rather than trying to develop the whole UI at once. For example, start with the ability to draw a polygon using mouse clicks and keyboard shortcuts before adding graphic buttons and menus. When you’re ready to develop a more visually appealing UI (such as one with buttons and checkboxes for configuration options), check out another library named Phil’s Game Utilities (PGU), which is written to complement PyGame’s display classes with a large number of predefined visual components (like the aforementioned checkboxes). Using PGU, you can quickly develop context-aware menu options, animated buttons, and other polished visual elements users have come to expect. The downside is that it takes a lot of code to make the magic work. Showing and explaining the code for any nontrivial GUI would take more pages than I have to cover the rest of the art gallery project.    ## Saving and Reloading Project Data    We’ve discussed the user’s desire to work on complex projects over a number of working sessions. The desire to save and load work is almost universal when it comes to practical software. Python offers developers a wide variety of options for saving and reloading data. You have traditional methods, like databases and flat files, along with more modern options, such as pickle, a library for saving and loading Python objects.    The exact method for saving and loading data has to be designed with your specific architecture in mind. For example, if you’re developing your application to run in the cloud, you might want to avoid saving data to flat files, or even local file-based databases like SQLite. At the very least, you’ll need to plan for storing the data in a manner that can be accessed from your cloud infrastructure (more on this in the next chapter).    ### Saving to a Dictionary    I chose to save the data as several files, grouped together inside a compressed (that is, zipped) file. The majority of the data will be stored in JSON files, which can easily be written from most dictionaries. To make life simple, I added a function called `to_dict` to each custom class, which returns all the data necessary to redefine the object from an empty copy of the class.    [Listing 12-12](#listing12-12) shows an example of the `to_dict` function for the `Room` class.    ``` def to_dict(self):   ❶ return {         \"vertex_list\": self.vertex_list,         \"name\": self.name,         \"color\": self.color,         \"floor\": self.floor,         \"surface_size\": self.surface_size,       ❷ \"obstacles\": [o.to_dict() for o in self.obstacles]      } ```    Listing 12-12: Creating a dictionary representation for the `Room` class    This function returns a dictionary object ❶ that is designed to be JSON serializable. You can include nested objects that also have a `to_dict` function. The `obstacles` key ❷ will hold a list of dictionaries, each of which defines an `Obstacle` object to include in the room during reload.    Converting a dictionary to a JSON string is simple using the json library (part of the standard libraries), as shown in [Listing 12-13](#listing12-13).    ``` room = Room([(2,2),(2,4),(4,4)], (10,10)) `--snip--` room_str = json.dumps(room.to_dict()) with open(\"/tmp/project/floors.json\", \"w\") as f:     f.write(room_str) ```    Listing 12-13: Saving a JSON representation of an object    We start by creating one or more objects. The call to the `Room` initialization creates a room shaped like a triangle with a display area of 10×10 pixels. We create a JSON representation of the room by calling `json.dumps` and passing in the dictionary representation of the `room` object. The `json.dumps` function returns a string that can be used to safely store or transport the data across a network.    After creating a JSON string for every object we want to save, we write the strings into a file called *floors.json* inside a temporary directory. If you’re on a Windows machine, you’ll want to change the references to the *temp* directory to something like *C:\\Users\\Temp* depending on your version. At this point, you could incorporate the `DataSaver` from [Listing 11-8](c11.xhtml#listing11-8) to save the `Triangle` files (if the user has created any tessellations), but since we already covered that code, I won’t show it here.    Once all of the data objects and resources are saved as files in the temporary directory, we create a compressed archive file for easier storage. We can do this with the `make_archive` function from the `shutils` library like so:    ``` shutil.make_archive(\"output_file.agp\", \"zip\", \"/temp/dir\") ```    The first argument is a string that will be used to name the output archive. The second argument is the format to use when compressing the archive. Several options are supported, but the most universal, by far, is the *.zip* file format. The final argument is the path to the directory that holds the temporary files. At this point, you’ll have a compressed file called *output_file.agp*, which can be examined with any common unzipping tool (I personally like 7Zip because it’s free and cross-platform).    Next, we’ll look at reloading the data from the JSON strings.    ### Loading from JSON Files    Reloading files works in the reverse order as saving. The program takes in a compressed archive, unpacks it to a temporary directory, and attempts to rebuild all of the objects contained within. Unpacking an archive to a directory is fairly straightforward, as shown in [Listing 12-14](#listing12-14).    ``` from zipfile import ZipFile import os os.mkdir(\"/tmp/project\") with ZipFile(\"output_file.agp\", \"r\") as zipf:     os.cwd(\"/tmp/project\")      zipf.extractall() ```    Listing 12-14: Extracting files from a previously created ZIP file    We start by creating the temporary directory where the project files will live with `os.makedir`. We then open the archive by calling the `ZipFile` class with the path to the archive and the mode to use. Using the `with` construct allows us to keep the file data in memory as the variable `zipf` until the indented block of code is complete. Once the code block finishes, Python will automatically close the file.    We change the working directory into the temporary project directory with `os.cwd`. Finally, we extract the files to the temporary directory by calling `zipf.extractall`.    Once the archive is extracted, we can load the data back into a dictionary with the following code:    ``` with open(\"/tmp/project/floors.json\") as f:     room_dict = json.loads(f.read()) ```    Essentially, this code block opens the *floors.json* file that was extracted in [Listing 12-14](#listing12-14) and then passes the contents of the file to the *json.loads* function. The result is a dictionary object that has the same structure and data as if you had called the `to_dict` function.    The final step is to convert this data back into the proper object classes. To aid in the process, I recommend adding another function called `from_dict` to each class as you develop it. The `from_dict` function is the complement of the `to_dict` function in that it converts a dictionary-like object into object parameters.    [Listing 12-15](#listing12-15) shows the `from_dict` function for the `Room` class.    ``` def from_dict(self, p_dict):     for k in list(p_dict.keys()):       ❶ if k == \"obstacles\":             for k2 in p_dict[k]:               ❷ obs = Obstacle([])               ❸ obs.from_dict(k2)                 obs.init_surface()               ❹ self.obstacles.append(obs)         else:           ❺ setattr(self, k, p_dict[k]) ```    Listing 12-15: Reloading a `Room` from a dictionary    To simplify the process, there are only two cases of interest for the `Room` class: the case where we’re dealing with the list of obstacles and the case where we’re dealing with all other attributes. If the code is parsing the `obstacles` attribute ❶, we loop over all the obstacles in the data. For each, we create an empty `Obstacle` object ❷ and call the `from_dict` function ❸ on the data to recreate the object with all the appropriate attributes. Calling `init_surface` prepares the `Obstacle` object for display when the time comes. Finally, we append it to the room’s `obstacles` attribute ❹.    In the event where the parameter being processed isn’t an obstacle, we simply add it as an attribute of the object being created using the `setattr` function ❺. Using the `setattr` function allows us to expand the definition of each class (for example, adding a new attribute to the `to_dict` function) without needing to update the `from_dict` function as well. Because we can update one function without impacting the other, we call these two functions *loosely coupled*. Loose coupling is a good goal to strive for in a production application because it reduces the amount of effort needed for ongoing development. We can use the `from_dict` function to recreate the `room` object from the file data with the following code:    ``` room = Room([], (1,1)) room.from_dict(room_dict) ```    First, we create an empty `Room` object to hold the attributes; then, we call the `from_dict` function and pass in the dictionary `room_dict`. At this point the code is back to the same state it was in at the beginning of [Listing 12-13](#listing12-13).    ## Running the Example Application    I’ve included a working example of the application in the chapter’s supplemental materials. It includes the features we’ve discussed up to this point. You can use the application to play with solving your own floor plans, then dive into the code and start improving it! Once you’ve navigated to the project folder, you can see the application’s help screen with this command:    ``` $ **python poly_draw.py -h**  ```    The output will be a list of options like these:    ``` `--snip--` Usage: poly_draw.py [options]  Options:   -h, --help            show this help message and exit   -r RESUME_FILE, --resume=RESUME_FILE                         Load Room shapes from a previously saved file   -b BGD_FILE, --background=BGD_FILE                         Background PNG to load (if not resuming)   -o OUT_FILE, --out-file=OUT_FILE                         File to save shapes to   -e EPSILON, --epsilon=EPSILON                         Sets near-miss distance   -f, --use-feet        Convert answers from meters to feet ```    We’ve already covered the first option, `-h`, which prints out this helpful menu. The `-r` option allows you to resume sessions by passing in the location of a compressed project file created using the save feature we discussed earlier. The `-b` option allows you to set the base floor plan’s background image when you’re starting a new project. The `-o` option allows you to specify the filename to save shape data to when the save command is called (with the S key), and the `-e` option allows you to change the value the program will use for epsilon. If you have trouble clicking vertices, you can try increasing this number a few pixels at a time until you achieve the desired result. Turning it up too high can cause unexpected behaviors, though. Finally, the `-f` option tells the application to use feet as the unit instead of the default meters when scaling the solution.    You can try the program out with a floor plan like the example of the Guggenheim as follows:    ``` **$ python poly_draw.py -b** `guggenheim.tif` **-o myfloorplan** ```    Replace the reference to `guggenheim.tif` with the name of your file. The application will ask you to enter a name for the floor plan in the console. For now let’s call the floor “main.” After you press enter, the application will open the Guggenheim image and enter the scaling state. Click two places in the image to draw a line. The console will then ask you to input a length for this line. This is how the application will figure out the real-word distance of the scaled image. You can now start drawing the rooms on the screen by clicking around with the left mouse button. When you want to finish the room, connect the final point back to the initial starting point to create the closed shape of the room. When you click the starting point to close the room, the console will ask you to input a name for the room. Enter something like “Gallery” and press enter. You should see the inside of the area you traced out change to green. Finally, try saving your work with ctrl-S. You should see the console spit out a message like this:    ``` Saving... Saving 1 floors. Saving 1 rooms. Successfully Saved: myfloorplan ```    If you list the files in the directory, you should now see a compressed file named *myfloorplan* that contains the floor and room data you just created. You can now safely exit the program using the X button at the top of the window. You can reload your previous save and begin work again with the following command:    ``` python poly_draw.py -r myfloorplan -o myfloorplan ```    It’s actually best practice to change the `-o` filename by appending a version number between edits. This way, you can always go back to a previously working copy if something goes awry.    There are many more functions in the example application and better ways to handle keypresses. There are also some incomplete features I’ve left for you to finish for practice. Read the code and play with the application to see if you can complete them.    ## Summary    We’ve covered a great deal of material in this chapter, but we’ve barely scratched the surface of user interfaces in Python and the multitude of events available in PyGame. You’ve seen how you can use these events to capture user input via the keyboard and mouse, but there are limitless ways you can expand on the concepts shown here to make your application more intuitive or enable power users (users that have a high level of familiarity and understanding of an application) to speed up their work. As mentioned, for a more visual interface, I encourage you to look into Phil’s Game Utilities, especially if you want your application to be accessible to the largest number of users.    A polished visual display is key to gaining interest from less technical users. There’s an entire field of study devoted to understanding how people interact with systems called *human–computer interaction* *(HCI)* research ([https://en.wikipedia.org/wiki/Human–computer_interaction](https://en.wikipedia.org/wiki/Human–computer_interaction)). As a developer, you can use HCI research to quantify how users interact with your application and locate areas for improvement. As a security analyst, you can use knowledge of HCI to plan interface controls that make managing privacy and security more intuitive. One particularly good source on the topic is the book *Research Methods in Human–Computer Interaction* (Wiley, 2014).^([2](b01.xhtml#c12-endnote-002))    We also covered one possible way to save data between user sessions using JSON files. Saving the data in a human-readable format like JSON allows you to troubleshoot the save and load functions easily during development. We’ll discuss other potential options for saving the data in the next chapter, where we’ll also cover different options for distributing your application to the masses, including moving the application into the cloud.````"]