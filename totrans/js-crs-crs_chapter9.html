<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>JavaScript Crash Course</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:26ab05bf-a247-42ca-b08d-ede069333d2b" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch9" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch9">
<span class="CN"><span aria-label=" Page 141. " epub:type="pagebreak" id="pg_141" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">THE CANVAS ELEMENT</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.png"/>
</figure>
<p class="INTROTNI2">One of the more interactive elements in HTML is the <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element. This element acts like a painter’s canvas: it provides space for you to draw images within the browser window using JavaScript. What’s more, by repeatedly erasing old images and drawing new ones, you can create animations on the canvas. In this sense, the <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element is more like the screen at a movie theater, where the image is updated many times every second to create the appearance of motion.</p>
<p class="TX">In this chapter you’ll learn how to create <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> elements and how to use the Canvas API, which gives you a way to manipulate the canvas via JavaScript. You’ll write JavaScript to draw static images to the canvas. Then you’ll build a simple interactive drawing application. Finally, you’ll learn the basics of creating 2D animations on the canvas.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-46"/><span aria-label=" Page 142. " epub:type="pagebreak" id="pg_142" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Creating a Canvas</samp></h3>
<p class="TNI1">To include a <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element on a web page, you add it to the <span class="SANS_TheSansMonoCd_W5Regular_11">body</span> element in the page’s <i>index.html</i> file. All you need are the opening and closing HTML tags, <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;canvas&gt;&lt;/canvas&gt;</span>, as the <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element doesn’t have any required attributes. However, it’s a good idea to give the canvas an <span class="SANS_TheSansMonoCd_W5Regular_11">id</span>, so you can easily access it using JavaScript. It’s also common to set the element’s <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attributes so you can establish the size of the canvas.</p>
<p class="TX">Images that appear in the canvas are generated using JavaScript, not HTML. Any HTML between the opening and closing tags will appear only if the browser doesn’t support the <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element, so this can be used as a fallback for older or text-only browsers.</p>
<p class="TX">Let’s create an HTML file that includes a <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element. We’ll also include a <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> element linking to a JavaScript file, where we’ll write code to generate images on the canvas. We’ll use the same HTML file throughout the chapter to draw different kinds of images. Create a new directory called <i>chapter9</i>, and make a new file in that directory called <i>index.html</i>. Enter the content shown in <a href="#Lis9-1">Listing 9-1</a>.</p>
<span id="Lis9-1"/>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Canvas&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id="canvas" width="300" height="300"&gt;&lt;/canvas&gt;
    &lt;script src="script.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: An</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file with a canvas element</samp></p>
<p class="TX">This is our familiar HTML template, similar to the <i>index.html</i> files we’ve created in previous chapters, but with a <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element instead of an <span class="SANS_TheSansMonoCd_W5Regular_11">h1</span> element. The <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attributes specify the size of the canvas in pixels. By default, the canvas is transparent, so you won’t actually see anything yet if you load the page.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="h1-47"/><samp class="SANS_Futura_Std_Bold_B_11">Making Static Drawings</samp></h3>
<p class="TNI1">Now that we have a <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element, we’re ready to draw on it using JavaScript and the Canvas API. We’ll start by drawing a solid rectangle. Then we’ll look at how to create other static drawings. Create a new file called <i>script.js</i> in the <i>chapter9</i> directory, and enter the code shown in <a href="#Lis9-2">Listing 9-2</a>.</p>
<span id="Lis9-2"/>
<pre><code>let canvas = document.querySelector("#canvas");
let ctx = canvas.getContext("2d");
ctx.fillStyle = "blue";
ctx.fillRect(10, 10, 200, 100);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: Drawing a rectangle in</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp></p>
<p class="TX"><span aria-label=" Page 143. " epub:type="pagebreak" id="pg_143" role="doc-pagebreak"/>First, we get a reference to the <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element using the <span class="SANS_TheSansMonoCd_W5Regular_11">document .querySelector</span> method. The <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element has a method called <span class="SANS_TheSansMonoCd_W5Regular_11">getContext</span>, which we use to get the canvas’s <i>drawing context</i>. The drawing context is an object that provides the entire Canvas API as a set of methods and properties (like <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">fillStyle</span>, respectively, both used in <a href="#Lis9-2">Listing 9-2</a>). These methods and properties are what we’ll use to draw images on the canvas. In this case, we pass the string <span class="SANS_TheSansMonoCd_W5Regular_11">"2d"</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">getContext</span> method to request the two-dimensional drawing context.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>You can draw 3D graphics on the canvas by passing the string <span class="SANS_TheSansMonoCd_W5Regular_11">"webgl"</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">"webgpu"</span> to the getContext method instead of <span class="SANS_TheSansMonoCd_W5Regular_11">"2d"</span>, but both of those are much more complicated than 2D graphics and are outside the scope of this book.</i></p>
<p class="TX">Next, we tell the drawing context that we want the fill color for new elements to be blue, using the <span class="SANS_TheSansMonoCd_W5Regular_11">fillStyle</span> property. Finally, we draw a filled rectangle using the current fill color with the <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span> method. This method takes four arguments: the x- and y-coordinates of the top-left corner of the rectangle, and the width and height of the rectangle in pixels. The coordinates work the same way as the coordinates for the whole browser window: x values increase as you move from left to right across the canvas, and y values increase from top to bottom, with (0, 0) representing the top-left corner of the canvas.</p>
<p class="TX">Open <i>index.html</i> in your browser. You should see a solid blue rectangle, as shown in <a href="chapter9.xhtml#fig9-1">Figure 9-1</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig9-1" src="../images/Figure_9-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: The blue rectangle</samp></p></figcaption>
</figure>
<p class="TX">Any subsequent calls to <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span> will use the same <span class="SANS_TheSansMonoCd_W5Regular_11">fillStyle</span>, so they’ll also produce blue rectangles (until you set a new <span class="SANS_TheSansMonoCd_W5Regular_11">fillStyle</span>, that is). You can confirm this by drawing some more rectangles to the canvas.</p>
<section aria-labelledby="sec3" epub:type="division">
<aside aria-label="box-29" class="box" id="sec3">
<h4 class="BH" id="box-29"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  9-1.</samp><samp class="SANS_Futura_Std_Book_11">  Draw a 100-pixel square starting at (0, 0).</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  9-2.</samp><samp class="SANS_Futura_Std_Book_11">  We set the canvas to be 300 pixels wide by 300 pixels tall. What happens if you draw a rectangle that’s bigger than the canvas?</samp></p>
</aside>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="h2-60"/><span aria-label=" Page 144. " epub:type="pagebreak" id="pg_144" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing Outlined Rectangles</samp></h4>
<p class="TNI1">As well as <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span> for making a rectangle filled with a color, the Canvas API provides the <span class="SANS_TheSansMonoCd_W5Regular_11">strokeRect</span> method for outlining (<i>stroking</i>) a rectangle. To try it out, modify <i>script.js</i> as shown in <a href="#Lis9-3">Listing 9-3</a>.</p>
<span id="Lis9-3"/>
<pre><code><span class="gray">let canvas = document.querySelector("#canvas");</span>
<span class="gray">let ctx = canvas.getContext("2d");</span>
ctx.lineWidth = 2;
ctx.strokeStyle = "red";
ctx.strokeRect(10, 10, 200, 100);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Using</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">strokeRect to outline a rectangle</samp></p>
<p class="TX">First we specify the width of the outline with the <span class="SANS_TheSansMonoCd_W5Regular_11">lineWidth</span> property, setting it to 2 pixels wide. Then we use <span class="SANS_TheSansMonoCd_W5Regular_11">strokeStyle</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">strokeRect</span>, rather than <span class="SANS_TheSansMonoCd_W5Regular_11">fillStyle</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span>, to create an outlined rectangle with no fill color. The <span class="SANS_TheSansMonoCd_W5Regular_11">strokeRect</span> method takes the same arguments as <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span>: the x- and y-coordinates of the top-left corner, and the width and height of the rectangle.</p>
<p class="TX">When you reload <i>index.html</i>, you should see the rectangle is now outlined in red, with no fill, as shown in <a href="chapter9.xhtml#fig9-2">Figure 9-2</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig9-2" src="../images/Figure_9-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: A red-outlined rectangle</samp></p></figcaption>
</figure>
<p class="TX">When you set styles on the drawing context, such as the line width or line color, those settings apply only to subsequent additions to the canvas. That is, they don’t retroactively affect anything that’s already been drawn. In this sense, the canvas really is very much like a physical canvas, where the current style is determined by the color of paint and type of brush you’re using at the moment. To demonstrate, we’ll draw several rectangles with different colors. Add the code in <a href="#Lis9-4">Listing 9-4</a> to the end of <i>script.js</i>, after the code for drawing the red rectangle.</p>
<span id="Lis9-4"/>
<pre><code><var>--snip--</var>
ctx.strokeStyle = "orange";
ctx.strokeRect(20, 20, 180, 80);

ctx.strokeStyle = "yellow";
ctx.strokeRect(30, 30, 160, 60);

<span aria-label=" Page 145. " epub:type="pagebreak" id="pg_145" role="doc-pagebreak"/>ctx.strokeStyle = "green";
ctx.strokeRect(40, 40, 140, 40);

ctx.strokeStyle = "blue";
ctx.strokeRect(50, 50, 120, 20);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-4: Drawing more rectangles</samp></p>
<p class="TX">This code draws a series of nested rectangles, each offset by 10 pixels from the previous one and each 20 pixels smaller than the previous one. Before we draw each successive rectangle, we change the color of the outline by updating the <span class="SANS_TheSansMonoCd_W5Regular_11">strokeStyle</span> property.</p>
<p class="TX">Refresh <i>index.html</i>, and you should see something like the image in <a href="chapter9.xhtml#fig9-3">Figure 9-3</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig9-3" src="../images/Figure_9-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: Concentric rectangles</samp></p></figcaption>
</figure>
<p class="TX">Each rectangle is a different color, indicating that the style changes didn’t impact anything that had already been drawn.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<aside aria-label="box-30" class="box" id="sec5">
<h4 class="BH" id="box-30"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  9-3.</samp><samp class="SANS_Futura_Std_Book_11">  Rewrite the code to create the nested rectangles using a loop, so you only need to write the calls to</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">ctx.strokeStyle</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">ctx.strokeRect</span> <samp class="SANS_Futura_Std_Book_11">once. Hint: think about how to manipulate the looping variable to (a) retrieve a stroke color from an array and (b) set the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">strokeRect</span> <samp class="SANS_Futura_Std_Book_11">arguments appropriately.</samp></p>
</aside>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing Other Shapes Using Paths</samp></h4>
<p class="TNI1">All other shapes besides rectangles are drawn on the canvas as <i>paths</i>. A path is a series of points connected by straight or curved lines, and then either stroked with an outline or filled in with a color. As an example, we’ll draw a path between three different points and then fill it in to make a red triangle. Replace the contents of <i>script.js</i> with the code in <a href="#Lis9-5">Listing 9-5</a>.</p>
<span id="Lis9-5"/>
<pre><code><span aria-label=" Page 146. " epub:type="pagebreak" id="pg_146" role="doc-pagebreak"/><span class="gray">let canvas = document.querySelector("#canvas");</span>
<span class="gray">let ctx = canvas.getContext("2d");</span>
ctx.fillStyle = "red";
ctx.beginPath();
ctx.moveTo(100, 100);
ctx.lineTo(150, 15);
ctx.lineTo(200, 100);
ctx.lineTo(100, 100);
ctx.fill();
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-5: Drawing a triangle with path methods</samp></p>
<p class="TX">Drawing a path takes three steps. First, you declare that you want to start drawing a new path with <span class="SANS_TheSansMonoCd_W5Regular_11">beginPath</span>. Then, you use various methods to define where the path will be. Finally, you use <span class="SANS_TheSansMonoCd_W5Regular_11">fill</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">stroke</span> to fill or stroke the path.</p>
<p class="TX">In this case, we use two different methods to define the path: <span class="SANS_TheSansMonoCd_W5Regular_11">moveTo</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">lineTo</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">moveTo</span> method moves an imaginary pen to a particular point on the canvas defined by x- and y-coordinates, without drawing a line. We use this method to define the starting point of our path, (100, 100), which will be the bottom-left corner of the triangle. The <span class="SANS_TheSansMonoCd_W5Regular_11">lineTo</span> method does the same as <span class="SANS_TheSansMonoCd_W5Regular_11">moveTo</span>, but it draws a line as it moves. Thus, <span class="SANS_TheSansMonoCd_W5Regular_11">lineTo(150, 15)</span> draws a line from (100, 100) to (150, 15), and so on. Finally, we fill the shape with the <span class="SANS_TheSansMonoCd_W5Regular_11">fill</span> method. When you refresh the page, you should see a red triangle, as shown in <a href="chapter9.xhtml#fig9-4">Figure 9-4</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig9-4" src="../images/Figure_9-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: Drawing a filled triangle</samp></p></figcaption>
</figure>
<p class="TX">Drawing circles follows a similar pattern, but uses a method called <span class="SANS_TheSansMonoCd_W5Regular_11">arc</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">moveTo</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">lineTo</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">arc</span> method draws an <i>arc</i>, a section of the circumference of a circle. You can produce any length of arc with the <span class="SANS_TheSansMonoCd_W5Regular_11">arc</span> method, but here we’ll use it to produce an entire circle.</p>
<p class="TX">Update <i>script.js</i> with the code in <a href="#Lis9-6">Listing 9-6</a>. The first and third steps of the path drawing code are the same, but we replace the second step with the code for drawing a circle rather than a triangle.</p>
<span id="Lis9-6"/>
<pre><code><span class="gray">let canvas </span><span class="gray">= document.querySelector("#canvas");</span>
<span class="gray">let ctx = canvas.getContext("2d");</span>
<span class="gray">ctx.fillStyle = "red";</span>
<span class="gray">ctx.beginPath();</span>
<span aria-label=" Page 147. " epub:type="pagebreak" id="pg_147" role="doc-pagebreak"/>ctx.arc(150, 100, 50, 0, Math.PI * 2, false);
<span class="gray">ctx.fill();</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-6: Drawing a circle with path methods</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">arc</span> method takes a whopping six arguments. The first two are the x- and y-coordinates of the center of the circle. In this case we’re centering the circle at the coordinates (150, 100). The third argument is the circle’s radius in pixels, which we set to <span class="SANS_TheSansMonoCd_W5Regular_11">50</span>. The next two arguments give the starting and ending angles of the arc in radians: we provide <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> for the starting angle and <span class="SANS_TheSansMonoCd_W5Regular_11">Math.PI * 2</span> for the ending angle to produce a full circle. The final argument specifies whether the arc should be drawn clockwise (<span class="SANS_TheSansMonoCd_W5Regular_11">false</span>) or counterclockwise (<span class="SANS_TheSansMonoCd_W5Regular_11">true</span>) from the starting angle to the ending angle. In this case, we pick clockwise, but since we’re drawing a full circle, the direction is irrelevant.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><span class="note_Italic">Radians</span> <i>are a way of measuring angles. In degrees, a full revolution of a circle goes from 0 to 360. In radians, a revolution goes from 0 to 2<span lang="el" xml:lang="el">π</span>.</i></p>
<p class="TX">When you refresh the page now, you should see a red circle, as shown in <a href="chapter9.xhtml#fig9-5">Figure 9-5</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig9-5" src="../images/Figure_9-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: Drawing a filled circle</samp></p></figcaption>
</figure>
<p class="TX">You can use the same technique to draw a stroked circle instead by using the <span class="SANS_TheSansMonoCd_W5Regular_11">stroke</span> method rather than the <span class="SANS_TheSansMonoCd_W5Regular_11">fill</span> method. What’s more, you can make compound shapes like rounded rectangles by combining calls to the <span class="SANS_TheSansMonoCd_W5Regular_11">lineTo</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">arc</span> methods. The Canvas API also allows for drawing more complex curves with the <span class="SANS_TheSansMonoCd_W5Regular_11">quadraticCurveTo</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bezierCurveTo</span> methods. Search the Mozilla Developer Network (MDN) Web Docs (<a href="https://developer.mozilla.org"><i>https://<wbr/>developer<wbr/>.mozilla<wbr/>.org</i></a>) for more details about these other methods.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="h1-48"/><samp class="SANS_Futura_Std_Bold_B_11">Interacting with the Canvas</samp></h3>
<p class="TNI1">The canvas gets a lot more interesting when the user can interact with it. The <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element itself doesn’t have any notion of interactivity built in. However, we can add that interactivity with JavaScript by writing event handlers that listen for certain user actions and trigger Canvas API methods that update the canvas in response.</p>
<p class="TX"><span aria-label=" Page 148. " epub:type="pagebreak" id="pg_148" role="doc-pagebreak"/>In this section, we’ll build a very basic drawing application using a <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element with a <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> handler. The handler will listen for clicks on the canvas, and call a method that draws a circle at the position where the click happened. We’ll also create a slider so the user can set the opacity of the circles, and a button to clear the canvas.</p>
<p class="TX">First, let’s add the necessary HTML elements to create a slider and a button. Make the modifications shown in <a href="#Lis9-7">Listing 9-7</a> to <i>index.html</i>.</p>
<span id="Lis9-7"/>
<pre><code><span class="gray">&lt;!DOCTYPE html&gt;</span>
<span class="gray">&lt;html&gt;</span>
<span class="gray">  &lt;head&gt;</span>
<span class="gray">    &lt;title&gt;Canvas&lt;/title&gt;</span>
<span class="gray">  &lt;/head&gt;</span>
<span class="gray">  &lt;body&gt;</span>
<span class="gray">    &lt;canvas id="canvas" width="300" height="300"&gt;&lt;/canvas</span>&gt;
    &lt;div&gt;
      &lt;button id="clear"&gt;Clear&lt;/button&gt;
      &lt;input id="opacity" type="range" min="0" max="1" value="1" step="0.1"&gt;
      &lt;label for="opacity"&gt;Opacity&lt;/label&gt;
    &lt;/div&gt;
<span class="gray">    &lt;script src="script.js"&gt;&lt;/script&gt;</span>
<span class="gray">  &lt;/body&gt;</span>
<span class="gray">&lt;/html&gt;</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-7: Adding some additional elements to</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp></p>
<p class="TX">Here we add a new <span class="SANS_TheSansMonoCd_W5Regular_11">div</span> element containing three other HTML elements. The <span class="SANS_TheSansMonoCd_W5Regular_11">div</span> element is there to group the elements inside it together and to position them below the canvas (without the <span class="SANS_TheSansMonoCd_W5Regular_11">div</span> they’d appear to the right of the canvas).</p>
<p class="TX">The first element inside the <span class="SANS_TheSansMonoCd_W5Regular_11">div</span> is a <span class="SANS_TheSansMonoCd_W5Regular_11">button</span> element. It creates a clickable button. Any content between the opening and closing tags will appear as text on the button, so our button will have the text <i>Clear</i>. Later, we’ll write a JavaScript function that clears any circles on the canvas when the user clicks the button.</p>
<p class="TX">Next inside the <span class="SANS_TheSansMonoCd_W5Regular_11">div</span> is an <span class="SANS_TheSansMonoCd_W5Regular_11">input</span> element, which is used for taking values from the user. The <span class="SANS_TheSansMonoCd_W5Regular_11">input</span> element doesn’t allow any child elements, so it doesn’t need a closing tag. In this case the <span class="SANS_TheSansMonoCd_W5Regular_11">input</span> is of type <span class="SANS_TheSansMonoCd_W5Regular_11">range</span>, which means it will display as a slider. This slider will be used to set the opacity of new circles drawn on the canvas. It has several attributes defining its functionality: <span class="SANS_TheSansMonoCd_W5Regular_11">min</span> defines the minimum value the slider will produce, <span class="SANS_TheSansMonoCd_W5Regular_11">max</span> defines the maximum value, <span class="SANS_TheSansMonoCd_W5Regular_11">value</span> defines the initial value the slider is set to, and <span class="SANS_TheSansMonoCd_W5Regular_11">step</span> is the size of each movement (enabling you to control the number of allowed values). This slider is set to range from <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> in steps of <span class="SANS_TheSansMonoCd_W5Regular_11">0.1</span>, and it starts at <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, which corresponds to full opacity.</p>
<p class="TX">The last element in the <span class="SANS_TheSansMonoCd_W5Regular_11">div</span> is a <span class="SANS_TheSansMonoCd_W5Regular_11">label</span> element, which applies a label to another element. The <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> attribute of the label determines which element the label should be applied to; its value has to match the <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> of another element. In this case, we assign the label to the slider by specifying <span class="SANS_TheSansMonoCd_W5Regular_11">opacity</span> as the target <span class="SANS_TheSansMonoCd_W5Regular_11">id</span>. This will cause the slider to be labeled <i>Opacity</i>, which is the text <span aria-label=" Page 149. " epub:type="pagebreak" id="pg_149" role="doc-pagebreak"/>content of the <span class="SANS_TheSansMonoCd_W5Regular_11">label</span> element. Thanks to the <span class="SANS_TheSansMonoCd_W5Regular_11">label</span> element’s <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> attribute, the browser understands that the <span class="SANS_TheSansMonoCd_W5Regular_11">label</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">input</span> elements are related, and certain actions performed on the <span class="SANS_TheSansMonoCd_W5Regular_11">label</span> will apply to the <span class="SANS_TheSansMonoCd_W5Regular_11">input</span>. For example, if you hover over the <span class="SANS_TheSansMonoCd_W5Regular_11">label</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">input</span> will display as hovered, and if you click the <span class="SANS_TheSansMonoCd_W5Regular_11">label</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">input</span> will get keyboard focus (in this case, pressing the left or right arrow key will decrease or increase the value of the slider, respectively).</p>
<p class="TX">Load <i>index.html</i> in your browser, and you should see something similar to <a href="chapter9.xhtml#fig9-6">Figure 9-6</a> (the exact appearance of these elements may vary depending on your browser and operating system).</p>
<figure class="IMG"><img alt="" class="img6" id="fig9-6" src="../images/Figure_9-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: The new button and input elements</samp></p></figcaption>
</figure>
<p class="TX">Now that we have the HTML elements, we can write the JavaScript that will make this application interactive. First, we’ll add some general declarations and the code for drawing circles when the user clicks on the canvas. Update <i>script.js</i> with the code shown in <a href="#Lis9-8">Listing 9-8</a>.</p>
<span id="Lis9-8"/>
<pre><code><span class="gray">let canvas = document.querySelector("#canvas");</span>
<span class="gray">let ctx = canvas.getContext("2d");</span>

let width = canvas.width;
let height = canvas.height;

let opacity = 1;

function drawCircle(x, y) {
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> ctx.fillStyle = `rgba(0, 255, 0, ${opacity})`;
  ctx.beginPath();
  ctx.arc(x, y, 10, 0, Math.PI * 2, false);
  ctx.fill();
}

canvas.addEventListener("click", e =&gt; {
  drawCircle(e.offsetX, e.offsetY);
});
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-8: Drawing a circle on click</samp></p>
<p class="TX">First we store the width and height of the <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element in two variables, <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span>. We’ll need these variables later, in our function for clearing the canvas. The <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> properties of the JavaScript <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> object come straight from the HTML <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element’s <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> properties (which are both set to <span class="SANS_TheSansMonoCd_W5Regular_11">300</span> in <i>index.html</i>). We also initialize the variable <span class="SANS_TheSansMonoCd_W5Regular_11">opacity</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>.</p>
<p class="TX">Next, we create a helper function called <span class="SANS_TheSansMonoCd_W5Regular_11">drawCircle</span>. This function takes an x- and a y-coordinate and draws a filled circle at that location. We use the same path drawing methods demonstrated in <a href="#Lis9-6">Listing 9-6</a> to draw the <span aria-label=" Page 150. " epub:type="pagebreak" id="pg_150" role="doc-pagebreak"/>circle. The <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> parameters determine the circle’s center, and we set its radius to <span class="SANS_TheSansMonoCd_W5Regular_11">10</span> pixels.</p>
<p class="TX">One key difference from the previous drawing examples is that we’re setting <span class="SANS_TheSansMonoCd_W5Regular_11">fillStyle</span> to an <i>RGBA</i> color instead of a named color like <span class="SANS_TheSansMonoCd_W5Regular_11">"red"</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">"blue"</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. RGBA is a way of defining colors using four numbers corresponding to the red, green, blue, and alpha channels. The first three indicate the amount of each primary color of light. Their values can range from <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">255</span>, and they can be combined to produce any color you might want. Setting all three to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> produces black, and setting all three to <span class="SANS_TheSansMonoCd_W5Regular_11">255</span> produces white. <i>Alpha</i> is another word for opacity, and it defines how opaque or transparent the color should be, ranging from <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> (completely transparent) to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> (completely opaque).</p>
<p class="TX">In the Canvas API, you set RGBA colors using the string <span class="SANS_TheSansMonoCd_W5Regular_11">"rgba(…)"</span> with the four values in the parentheses, separated by commas. For example, setting <span class="SANS_TheSansMonoCd_W5Regular_11">fillStyle</span> to the string <span class="SANS_TheSansMonoCd_W5Regular_11">"rgba(0, 255, 0, 0.9)"</span> would make bright green circles that are slightly transparent. In our case, we wrap the RGBA string in backticks so we can use a placeholder for the alpha value to allow the user to change the opacity with the slider.</p>
<p class="TX">Lastly, we add a <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> event handler to the <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element using <span class="SANS_TheSansMonoCd_W5Regular_11">add EventListener</span>. The handler calls the <span class="SANS_TheSansMonoCd_W5Regular_11">drawCircle</span> function we just created, passing the <span class="SANS_TheSansMonoCd_W5Regular_11">offsetX</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">offsetY</span> properties of the <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> event as the function’s parameters. The <span class="SANS_TheSansMonoCd_W5Regular_11">offsetX</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">offsetY</span> properties give the distance of the <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> event from the top-left corner of the clicked element itself (rather than from the top-left corner of the whole browser window), so they’re ideal for determining exactly where on the canvas the click happened.</p>
<p class="TX">Reload <i>index.html</i> in your browser and try clicking on the canvas. Wherever you click, a small green circle should appear, as shown in <a href="chapter9.xhtml#fig9-7">Figure 9-7</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig9-7" src="../images/Figure_9-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: Drawing green circles with mouse clicks</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 151. " epub:type="pagebreak" id="pg_151" role="doc-pagebreak"/>To complete the drawing application, we need to wire up the Clear button and the Opacity slider. Add the code in <a href="#Lis9-9">Listing 9-9</a> to the end of <i>script.js</i>.</p>
<span id="Lis9-9"/>
<pre><code><var>--snip--</var>
document.querySelector("#clear").addEventListener("click", () =&gt; {
  ctx.clearRect(0, 0, width, height);
});

document.querySelector("#opacity").addEventListener("change", e =&gt; {
  opacity = e.target.value;
});
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-9: Wiring up the Clear and Opacity controls</samp></p>
<p class="TX">First we add a <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> event handler to the Clear button. This calls a Canvas API method called <span class="SANS_TheSansMonoCd_W5Regular_11">clearRect</span>, which clears a rectangular section of the canvas. Just like when drawing a rectangle, you define the rectangle to be cleared using the x- and y-coordinates of its top-left corner, followed by its width and height. Here we use <span class="SANS_TheSansMonoCd_W5Regular_11">(0, 0, width, height)</span> to specify that we want to clear a rectangle that starts at the top-left corner of the canvas and is as wide and high as the canvas itself. Thus, <span class="SANS_TheSansMonoCd_W5Regular_11">ctx.clearRect(0, 0, width, height);</span> clears the entire canvas.</p>
<p class="TX">Next, we add a <span class="SANS_TheSansMonoCd_W5Regular_11">change</span> event handler to the Opacity slider. The <span class="SANS_TheSansMonoCd_W5Regular_11">change</span> event is triggered on <span class="SANS_TheSansMonoCd_W5Regular_11">input</span> elements when their value changes, so this handler will be called whenever the slider is set to a new position. We get the <span class="SANS_TheSansMonoCd_W5Regular_11">input</span> element with <span class="SANS_TheSansMonoCd_W5Regular_11">e.target</span> and get the element’s current value with <span class="SANS_TheSansMonoCd_W5Regular_11">.value</span>. Then we update the <span class="SANS_TheSansMonoCd_W5Regular_11">opacity</span> variable with this value. Because the <span class="SANS_TheSansMonoCd_W5Regular_11">drawCircle</span> function uses the value of <span class="SANS_TheSansMonoCd_W5Regular_11">opacity</span> as the alpha component of the RGBA color, any new circles will use the latest value set with the Opacity slider.</p>
<p class="TX">Now when you reload <i>index.html</i> in your browser, you should have a fully functioning (if basic) drawing application! You can use the Opacity slider to change the opacity of new circles and the Clear button to clear the canvas and start drawing again. Try drawing overlapping circles with the Opacity slider set halfway to see how they overlay.</p>
<section aria-labelledby="sec8" epub:type="division">
<aside aria-label="box-31" class="box" id="sec8">
<h4 class="BH" id="box-31"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  9-4.</samp><samp class="SANS_Futura_Std_Book_11">  Add sliders for controlling the R, G, and B components of the color. These will need to range from</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <samp class="SANS_Futura_Std_Book_11">to</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">255</span><samp class="SANS_Futura_Std_Book_11">. You could also add a Radius slider that controls the radius of the circle drawn in the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">drawCircle</span> <samp class="SANS_Futura_Std_Book_11">function.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  9-5.</samp><samp class="SANS_Futura_Std_Book_11">  Make a new function called</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">drawSquare</span> <samp class="SANS_Futura_Std_Book_11">that draws a square centered on a point, and call that function from the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> <samp class="SANS_Futura_Std_Book_11">handler instead of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">drawCircle</span><samp class="SANS_Futura_Std_Book_11">.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="h1-49"/><span aria-label=" Page 152. " epub:type="pagebreak" id="pg_152" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Animating the Canvas</samp></h3>
<p class="TNI1">As noted at the beginning of this chapter, you can animate the canvas by drawing on it and updating the image multiple times per second. In this section, we’ll code a very simple animation to show the basics of how this works.</p>
<p class="TX">Animating the canvas generally follows this basic pattern:</p>
<div class="top">
<p class="NL">  1.  Update state</p>
<p class="NL">  2.  Clear canvas</p>
<p class="NL">  3.  Draw image</p>
<p class="NL">  4.  Wait a short time</p>
<p class="NL">  5.  Repeat</p>
</div>
<p class="TX"><i>State</i> here means some variable(s) storing information about the current frame of the animation. This could be the current location of an object in motion, the direction the object is moving in, and so on. In our example, the state will be the x- and y-coordinates of a circle. When it’s time to update the state, we’ll increment the x- and y-coordinates by 1, meaning that the circle’s position will gradually move diagonally down and to the right. Drawing the image will entail drawing a small circle centered at the updated x- and y-coordinates. We clear the canvas before drawing the circle to ensure that the image from the previous cycle is removed. We’ll tackle the last two steps (waiting and repeating) by using the <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span> function to call our code every 100 ms, or 10 times a second.</p>
<p class="TX">We can continue to work with the same HTML and JavaScript files. The only change to make to <i>index.html</i> is to remove the <span class="SANS_TheSansMonoCd_W5Regular_11">div</span> and its nested elements that we added in <a href="#Lis9-7">Listing 9-7</a>, as they’re not needed anymore. After removing those elements, update <i>script.js</i> based on the code in <a href="#Lis9-10">Listing 9-10</a>.</p>
<span id="Lis9-10"/>
<pre><code><span class="gray">let canvas = document.querySelector("#canvas");</span>
<span class="gray">let ctx = canvas.getContext("2d");</span>

<span class="gray">let width = canvas.width;</span>
<span class="gray">let height = canvas.height;</span>

let x = 0;
let y = 0;

<span class="gray">function drawCircle(x, y) {</span>
  ctx.fillStyle = "rgb(0, 128, 255)";
<span class="gray">  ctx.beginPath();</span>
<span class="gray">  ctx.arc(x, y, 10, 0, Math.PI * 2, false);</span>
<span class="gray">  ctx.fill();</span>
<span class="gray">}</span>

function update() {
  x += 1;
  y += 1;
}

<span aria-label=" Page 153. " epub:type="pagebreak" id="pg_153" role="doc-pagebreak"/>function draw() {
  ctx.clearRect(0, 0, width, height);
  drawCircle(x, y);
}

setInterval(() =&gt; {
  update();
  draw();
}, 100);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-10: Creating an animation</samp></p>
<p class="TX">We create two new variables, <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, representing the location of the circle that we’ll animate. These variables store the current state of the animation and will be updated at regular intervals. The <span class="SANS_TheSansMonoCd_W5Regular_11">drawCircle</span> function itself is mostly unchanged, although the <span class="SANS_TheSansMonoCd_W5Regular_11">fillStyle</span> is different. Now that we’re not setting an opacity, we can use the simpler <span class="SANS_TheSansMonoCd_W5Regular_11">rgb(…)</span>-format string for setting the red, green, and blue values. With <span class="SANS_TheSansMonoCd_W5Regular_11">"rgb(…)"</span>, the opacity of the color is always 100 percent.</p>
<p class="TX">After <span class="SANS_TheSansMonoCd_W5Regular_11">drawCircle</span> we declare the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function, where we update the <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> variables, incrementing each by <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>. Next we declare the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> function, which clears the canvas and then calls <span class="SANS_TheSansMonoCd_W5Regular_11">drawCircle</span> to draw a circle at the current x- and y-coordinates. Finally, we call <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span> to orchestrate the animation. You may recall from <a href="chapter5.xhtml">Chapter 5</a> that <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span> takes a function and a time interval in milliseconds, and repeatedly calls that function once every time interval. Here we’re calling an anonymous function every 100 ms. The anonymous function itself calls <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> to create each frame of the animation.</p>
<p class="TX">Reload <i>index.html</i> in your browser, and you should see a small circle gradually move across the canvas from the top-left to the bottom-right corner. Even after the circle leaves the canvas, the x- and y-coordinates will keep increasing, but the canvas ignores anything drawn outside of its bounds.</p>
<section aria-labelledby="sec10" epub:type="division">
<aside aria-label="box-32" class="box" id="sec10">
<h4 class="BH" id="box-32"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  9-6.</samp><samp class="SANS_Futura_Std_Book_11">  Update the animation so the circle reappears at the top-left corner when it reaches the bottom-right corner. There are a few ways to do this. One option is to use the remainder operator (</samp><span class="SANS_TheSansMonoCd_W5Regular_11">%</span><samp class="SANS_Futura_Std_Book_11">), which evenly divides the first operand by the second and returns the remainder. For example,</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">325 % 100</span> <samp class="SANS_Futura_Std_Book_11">gives</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">25</span><samp class="SANS_Futura_Std_Book_11">. By passing</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">x % width</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">y % height</span> <samp class="SANS_Futura_Std_Book_11">to the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">drawCircle</span> <samp class="SANS_Futura_Std_Book_11">function, you can ensure that the circle will always be drawn within the canvas. You can also use the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">%=</span> <samp class="SANS_Futura_Std_Book_11">operator to keep the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> <samp class="SANS_Futura_Std_Book_11">values within bounds in the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> <samp class="SANS_Futura_Std_Book_11">function, using</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">x %= width</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">y %= height</span> <samp class="SANS_Futura_Std_Book_11">after incrementing their values. Try out both options.</samp></p>
<p class="BoxListNumber"><span aria-label=" Page 154. " epub:type="pagebreak" id="pg_154" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">  9-7.</samp><samp class="SANS_Futura_Std_Book_11">  How could you make the circle start out at the left side of the canvas, move to the right, then move back, and so on? Hint: you’ll need to declare another state variable to keep track of the direction, for example,</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">let forwards = true</span><samp class="SANS_Futura_Std_Book_11">, and use that variable to decide whether to increment or decrement</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">x</span><samp class="SANS_Futura_Std_Book_11">.</samp> <samp class="SANS_Futura_Std_Book_11">You’ll then need to update the new variable to be</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> <samp class="SANS_Futura_Std_Book_11">when the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> <samp class="SANS_Futura_Std_Book_11">value gets past a certain point.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  9-8.</samp><samp class="SANS_Futura_Std_Book_11">  Try changing the time interval in the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span> <samp class="SANS_Futura_Std_Book_11">function. For example, what does the animation look like with an interval of 1,000 ms, or 10 ms, or 1 ms? Note that at a certain point, the browser won’t be able to update as fast as you’re asking it to, so it’s unlikely that a 1 ms interval will run 10 times faster than a 10 ms interval.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H1" id="sec11"><span id="h1-50"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>
<p class="TNI1">In this chapter, you learned the basics of drawing on the <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element, as well as some techniques for creating interactive applications and animations using the canvas. We’ll build on some of these techniques later in this book as we learn how to make a canvas-based game.</p>
</section>
</section>
</body>
</html>