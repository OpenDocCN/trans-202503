["```\n{-# OPTIONS -Wall #-}\n\nmodule Newton2 where\n\nimport Graphics.Gnuplot.Simple\n```", "```\nvelocityCF :: Mass\n           -> Velocity          -- initial velocity\n           -> [Force]           -- list of forces\n           -> Time -> Velocity  -- velocity function\n```", "```\nvelocityCF :: Mass -> Velocity -> [Force] -> (Time -> Velocity)\n```", "```\ntype R = Double\n```", "```\ntype Mass     = R\ntype Time     = R\ntype Position = R\ntype Velocity = R\ntype Force    = R\n```", "```\nvelocityCF m v0 fs\n    = let fNet = sum fs       -- net force\n          a0   = fNet / m     -- Newton's second law\n          v t  = v0 + a0 * t  -- constant acceleration eqn\n      in v\n```", "```\npositionCF :: Mass\n           -> Position          -- initial position\n           -> Velocity          -- initial velocity\n           -> [Force]           -- list of forces\n           -> Time -> Position  -- position function\npositionCF m x0 v0 fs\n    = let fNet = sum fs\n          a0   = fNet / m\n          x t  = x0 + v0 * t + a0*t**2 / 2\n      in x\n```", "```\nvelocityCF 0.1 0.6 [0.04, -0.08]\n```", "```\nPrelude>  :l Newton2\n[1 of 1] Compiling Newton2         ( Newton2.hs, interpreted )\nOk, one module loaded.\n*Newton2>  :t velocityCF 0.1 0.6 [0.04, -0.08]\nvelocityCF 0.1 0.6 [0.04, -0.08] :: Time -> Velocity\n*Newton2> velocityCF 0.1 0.6 [0.04, -0.08] 0\n0.6\n*Newton2> velocityCF 0.1 0.6 [0.04, -0.08] 1\n0.2\n```", "```\ncarGraph :: IO ()\ncarGraph\n    = plotFunc [Title \"Car on an air track\"\n               ,XLabel \"Time (s)\"\n               ,YLabel \"Velocity of Car (m/s)\"\n               ,PNG \"CarVelocity.png\"\n               ,Key Nothing\n               ] [0..4 :: Time] (velocityCF 0.1 0.6 [0.04, -0.08])\n```", "```\n*Newton2> carGraph\n```", "```\nvelocityFt :: Mass -> Velocity -> [Time -> Force] -> Time -> Velocity\n```", "```\nvelocityFt :: R                 -- dt for integral\n           -> Mass\n           -> Velocity          -- initial velocity\n           -> [Time -> Force]   -- list of force functions\n           -> Time -> Velocity  -- velocity function\nvelocityFt dt m v0 fs\n    = let fNet t = sum [f t | f <- fs]\n          a t = fNet t / m\n      in antiDerivative dt v0 a\n```", "```\nantiDerivative :: R -> R -> (R -> R) -> (R -> R)\nantiDerivative dt v0 a t = v0 + integral dt a 0 t\n\nintegral :: R -> (R -> R) -> R -> R -> R\nintegral dt f a b\n    = sum [f t * dt | t <- [a+dt/2, a+3*dt/2 .. b - dt/2]]\n```", "```\npositionFt :: R                 -- dt for integral\n           -> Mass\n           -> Position          -- initial position\n           -> Velocity          -- initial velocity\n           -> [Time -> Force]   -- list of force functions\n           -> Time -> Position  -- position function\npositionFt dt m x0 v0 fs\n     = antiDerivative dt x0 (velocityFt dt m v0 fs)\n```", "```\npedalCoast :: Time -> Force\npedalCoast t\n    = let tCycle = 20\n          nComplete :: Int\n          nComplete = truncate (t / tCycle)\n          remainder = t - fromIntegral nComplete * tCycle\n      in if remainder < 10\n         then 10\n         else 0\n```", "```\nchildGraph :: IO ()\nchildGraph\n    = plotFunc [Title \"Child pedaling then coasting\"\n               ,XLabel \"Time (s)\"\n               ,YLabel \"Position of Bike (m)\"\n               ,PNG \"ChildPosition.png\"\n               ,Key Nothing\n               ] [0..40 :: R] (positionFt 0.1 20 0 0 [pedalCoast])\n```", "```\nfAir :: R  -- drag coefficient\n     -> R  -- air density\n     -> R  -- cross-sectional area of object\n     -> Velocity\n     -> Force\nfAir drag rho area v = -drag * rho * area * abs v * v / 2\n```", "```\nnewtonSecondV :: Mass\n              -> [Velocity -> Force]  -- list of force functions\n              -> Velocity             -- current velocity\n              -> R                    -- derivative of velocity\nnewtonSecondV m fs v0 = sum [f v0 | f <- fs] / m\n```", "```\nupdateVelocity :: R                    -- time interval dt\n               -> Mass\n               -> [Velocity -> Force]  -- list of force functions\n               -> Velocity             -- current velocity\n               -> Velocity             -- new velocity\nupdateVelocity dt m fs v0\n   = v0 + (newtonSecondV m fs v0) * dt\n```", "```\nvelocityFv :: R                    -- time step\n           -> Mass\n           -> Velocity             -- initial velocity v(0)\n           -> [Velocity -> Force]  -- list of force functions\n           -> Time -> Velocity     -- velocity function\nvelocityFv dt m v0 fs t\n    = let numSteps = abs $ round (t / dt)\n      in iterate (updateVelocity dt m fs) v0 !! numSteps\n```", "```\nbikeVelocity :: Time -> Velocity\nbikeVelocity = velocityFv 1 70 0 [const 100,fAir 2 1.225 0.6]\n```", "```\nbikeGraph :: IO ()\nbikeGraph = plotFunc [Title \"Bike velocity\"\n                     ,XLabel \"Time (s)\"\n                     ,YLabel \"Velocity of Bike (m/s)\"\n                     ,PNG \"BikeVelocity1.png\"\n                     ,Key Nothing\n                     ] [0,0.5..60] bikeVelocity\n```", "```\nnewtonSecondTV :: Mass\n               -> [(Time,Velocity) -> Force]  -- force funcs\n               -> (Time,Velocity)             -- current state\n               -> (R,R)                       -- deriv of state\nnewtonSecondTV m fs (t,v0)\n    = let fNet = sum [f (t,v0) | f <- fs]\n          acc = fNet / m\n      in (1,acc)\n```", "```\nupdateTV :: R                           -- time interval dt\n         -> Mass\n         -> [(Time,Velocity) -> Force]  -- list of force funcs\n         -> (Time,Velocity)             -- current state\n         -> (Time,Velocity)             -- new state\nupdateTV dt m fs (t,v0)\n    = let (dtdt, dvdt) = newtonSecondTV m fs (t,v0)\n      in (t  + dtdt * dt\n         ,v0 + dvdt * dt)\n```", "```\nstatesTV :: R                           -- time step\n         -> Mass\n         -> (Time,Velocity)             -- initial state\n         -> [(Time,Velocity) -> Force]  -- list of force funcs\n         -> [(Time,Velocity)]           -- infinite list of states\nstatesTV dt m tv0 fs\n    = iterate (updateTV dt m fs) tv0\n```", "```\nvelocityFtv :: R                          -- time step\n           -> Mass\n           -> (Time,Velocity)             -- initial state\n           -> [(Time,Velocity) -> Force]  -- list of force funcs\n           -> Time -> Velocity            -- velocity function\nvelocityFtv dt m tv0 fs t\n   = let numSteps = abs $ round (t / dt)\n     in snd $ statesTV dt m tv0 fs !! numSteps\n```", "```\npedalCoastAir :: [(Time,Velocity)]\npedalCoastAir = statesTV 0.1 20 (0,0)\n                [\\(t,_) -> pedalCoast t\n                ,\\(_,v) -> fAir 2 1.225 0.5 v]\n```", "```\npedalCoastAirGraph :: IO ()\npedalCoastAirGraph\n    = plotPath [Title \"Pedaling and coasting with air\"\n               ,XLabel \"Time (s)\"\n               ,YLabel \"Velocity of Bike (m/s)\"\n               ,PNG \"pedalCoastAirGraph.png\"\n               ,Key Nothing\n               ] (takeWhile (\\(t,_) -> t <= 100)\n                  pedalCoastAir)\n```", "```\npedalCoastAir2 :: Time -> Velocity\npedalCoastAir2 = velocityFtv 0.1 20 (0,0)\n                 [\\( t,_v) -> pedalCoast t\n                 ,\\(_t, v) -> fAir 1 1.225 0.5 v]\n```", "```\nvelocityCF' :: Mass\n            -> Velocity          -- initial velocity\n            -> [Force]           -- list of forces\n            -> Time -> Velocity  -- velocity function\nvelocityCF' m v0 fs t = undefined m v0 fs t\n```", "```\nsumF :: [R -> R] -> R -> R\nsumF = undefined\n```", "```\npositionFv :: R                   -- time step\n           -> Mass\n           -> Position            -- initial position x(0)\n           -> Velocity            -- initial velocity v(0)\n           -> [Velocity -> Force] -- list of force functions\n           -> Time -> Position    -- position function\npositionFv = undefined\n```", "```\npositionFtv :: R                    -- time step\n            -> Mass\n            -> Position             -- initial position x(0)\n            -> Velocity             -- initial velocity v(0)\n            -> [(Time,Velocity) -> Force]  -- force functions\n            -> Time -> Position     -- position function\npositionFtv = undefined\n```", "```\nupdateExample :: (Time,Velocity)  -- starting state\n              -> (Time,Velocity)  -- ending state\nupdateExample = undefined\n```"]