<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_277"/><span class="big">8</span><br/>HEAPS AND SEGMENT TREES</h2>
<div class="image1"><img alt="Image" src="../images/common1.jpg"/></div>
<p class="noindenta">Data structures organize our data to make it possible to accelerate certain operations. For example, in <a href="ch01.xhtml">Chapter 1</a>, we learned about hash tables, which speed up the search for a specified element in a collection.</p>
<p class="indent">In this chapter, we’ll learn two new data structures: heaps and segment trees. A heap is what you want whenever you need the maximum (or minimum) element; a segment tree is what you want when you need to perform queries on pieces of an array. In our first problem, we’ll see how heaps turn slow maximum computations into fast heap operations; in our second and third problems, we’ll see how segment trees do similarly for more general array queries.</p>
<h3 class="h3" id="lev50">Problem 1: Supermarket Promotion</h3>
<p class="noindent">This is SPOJ problem <span class="literal">PRO</span>.</p>
<h4 class="h4" id="sec118"><em>The Problem</em></h4>
<p class="noindent">In a supermarket, each shopper picks up the items that they want to buy, then goes through the checkout to pay for their items. Once a shopper pays, the shopper is given a receipt that has the total cost of what they purchased. <span epub:type="pagebreak" id="page_278"/>For example, if someone picks up some items and the total is $18, then the cost written on their receipt is $18. We don’t care about the cost of individual items.</p>
<p class="indent">The supermarket is having a promotion that will last <em>n</em> days. During the promotion, each receipt is placed in a ballot box. At the end of each day, two receipts are removed from the ballot box: one of maximum cost <em>x</em> and one of minimum cost <em>y</em>. The shopper who produced the maximum-cost receipt gets a prize worth <em>x</em> – <em>y</em> dollars. (Don’t worry about how the supermarket identifies that shopper based on their receipt.) The <em>x</em> and <em>y</em> receipts are then gone, never to reappear, but all other receipts from that day stay in the ballot box (and may be removed on some future day).</p>
<p class="indent">It’s guaranteed that there will be at least two receipts in the ballot box at the end of each day.</p>
<p class="indent">Our task is to compute the total prize money that will be given out by the supermarket as part of the promotion.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindents">A line containing <em>n</em>, the duration in days of the promotion. <em>n</em> is between 1 and 5,000.</li>
<li class="noindents"><em>n</em> lines, one for each day of the promotion. Each such line begins with integer <em>k</em>, indicating that there are <em>k</em> receipts on this day. The line then contains <em>k</em> integers, representing the cost of each receipt for this day. <em>k</em> is between 0 and 100,000; each receipt cost is a positive number that’s at most 1,000,000.</li>
</ul>
<p class="indent">The total number of receipts produced throughout the entire promotion is at most 1,000,000.</p>
<h5 class="h5">Output</h5>
<p class="noindent">Output the total prize money given out by the supermarket.</p>
<p class="indent">The time limit for solving the test case is 0.6 seconds.</p>
<h4 class="h4" id="sec119"><em>Solution 1: Maximum and Minimum in an Array</em></h4>
<p class="noindent">For many of the problems in this book, it’s a challenge to devise a correct algorithm, let alone an efficient one. At least for the current problem, correctness doesn’t seem so hard. Determining the prize on each day simply involves searching the ballot box for the maximum cost and then searching again for the minimum cost. Maybe that will be efficient enough, too?</p>
<p class="indent">Let’s look at a test case:</p>
<pre>2
16 6 63 16 82 25 2 43 5 17 10 56 85 38 15 32 91
1 57</pre>
<span epub:type="pagebreak" id="page_279"/>
<p class="indent">Remember that the first number on each line of receipts tells us the number of receipts and is not itself a receipt cost. After the first day and before removing any receipts, we have these 16 receipt costs:</p>
<pre>6 63 16 82 25 2 43 5 17 10 56 85 38 15 32 91</pre>
<p class="indent">The maximum receipt is 91 and the minimum is 2. Those two receipts are removed, and they contribute 91 – 2 = 89 in prize money. Here’s what’s left after removing 91 and 2:</p>
<pre>6 63 16 82 25 43 5 17 10 56 85 38 15 32</pre>
<p class="indent">Now we move on to the second day. We add the 57 to get:</p>
<pre>6 63 16 82 25 43 5 17 10 56 85 38 15 32 57</pre>
<p class="indent">The maximum now is 85 and the minimum is 5, so that’s 85 – 5 = 80 added to the prize money. The total prize money for this promotion is therefore 89 + 80 = 169.</p>
<p class="indent">One implementation idea involves storing the receipts in an array. To remove a receipt, we could literally remove it, as we just did. That would involve shifting later receipts to the left, to fill the vacated array entry. But it’s simpler to keep the receipts where they are and associate a <span class="literal">used</span> flag with each receipt. If <span class="literal">used</span> is <span class="literal">0</span>, then the receipt hasn’t been used yet; if it’s <span class="literal">1</span>, then it has been used and is logically removed (so we had better ignore it from here on out).</p>
<p class="indent">Here are a couple of constants and the <span class="literal">receipt</span> struct:</p>
<pre>#define MAX_RECEIPTS 1000000
#define MAX_COST 1000000

typedef struct receipt {
  int cost;
  int used;
} receipt;</pre>
<p class="indent">We’re going to need helper functions to identify and remove the maximum receipt cost and minimum receipt cost, so let’s knock those out now. <a href="ch08.xhtml#ch08ex01">Listing 8-1</a> gives the code.</p>
<pre> int extract_max(receipt receipts[], int num_receipts) {
   int max, max_index, i;
<span class="ent">❶</span> max = -1;
   for (i = 0; i &lt; num_receipts; i++)
   <span class="ent">➋</span> if (!receipts[i].used &amp;&amp; receipts[i].cost &gt; max) {
        max_index = i;
        max = receipts[i].cost;
      }
<span epub:type="pagebreak" id="page_280"/><span class="ent">➌</span> receipts[max_index].used = 1;
   return max;
}

int extract_min(receipt receipts[], int num_receipts) {
  int min, min_index, i;
<span class="ent">➍</span> min = MAX_COST + 1;
   for (i = 0; i &lt; num_receipts; i++)
   <span class="ent">➎</span> if (!receipts[i].used &amp;&amp; receipts[i].cost &lt; min) {
        min_index = i;
        min = receipts[i].cost;
     }
<span class="ent">➏</span> receipts[min_index].used = 1;
   return min;
}</pre>
<p class="excap" id="ch08ex01"><em>Listing 8-1: Finding and removing maximum and minimum costs</em></p>
<p class="indent">The standard term for the operation that removes and returns the maximum value is <em>extract-max</em>. Likewise, the operation that removes and returns the minimum value is called <em>extract-min</em>.</p>
<p class="indent">These functions operate very similarly. The <span class="literal">extract_max</span> function sets <span class="literal">max</span> to <span class="literal">-1</span> <span class="ent">❶</span>, which is smaller than any receipt cost. When it finds a “real” receipt cost, <span class="literal">max</span> will be set to that cost, and from then on it will track the largest cost found so far. Similar reasoning explains why <span class="literal">extract_min</span> initializes <span class="literal">min</span> with a cost higher than any valid cost <span class="ent">➍</span>. Notice that, in each function, the only receipts that are considered are those whose <span class="literal">used</span> value is <span class="literal">0</span> <span class="ent">➋</span> <span class="ent">➎</span> and that each function sets the identified receipt’s <span class="literal">used</span> value to <span class="literal">1</span> <span class="ent">➌</span> <span class="ent">➏</span>.</p>
<p class="indent">With those two helper functions in hand, we can write a <span class="literal">main</span> function to read the input and solve the problem. One interesting aspect here is that reading input and solving the problem are interleaved: we read a little input (the receipts for the first day), calculate the prize for that day, read a little more input (the receipts for the second day), calculate the prize for that day, and so on. This is implemented in <a href="ch08.xhtml#ch08ex02">Listing 8-2</a>.</p>
<pre> int main(void) {
   static struct receipt receipts[MAX_RECEIPTS];
   int num_days, num_receipts_today;
   int num_receipts = 0;
<span class="ent">❶</span> long long total_prizes = 0;
   int i, j, max, min;
   scanf("%d", &amp;num_days);

   for (i = 0; i &lt; num_days; i++) {
     scanf("%d", &amp;num_receipts_today);
     for (j = 0; j &lt; num_receipts_today; j++) {
       scanf("%d", &amp;receipts[num_receipts].cost);
       receipts[num_receipts].used = 0;
       num_receipts++;
<span epub:type="pagebreak" id="page_281"/>    }
    max = extract_max(receipts, num_receipts);
    min = extract_min(receipts, num_receipts);
    total_prizes += max - min;
  }
  printf("%lld\n", total_prizes);
  return 0;
}</pre>
<p class="excap" id="ch08ex02"><em>Listing 8-2: The main function for reading input and solving the problem</em></p>
<p class="indent">The only gotcha here is the type of the <span class="literal">total_prizes</span> variable <span class="ent">❶</span>. An integer or long integer may not be enough. A typical long integer can hold values up to about 4 billion; the total prize money could be up to 5,000 × 1,000,000, which is 5 billion. Long long integers can hold integers that are billions, trillions, and way beyond that, so we’re certainly safe using a long long integer here.</p>
<p class="indent">The outer <span class="literal">for</span> loop runs once for each day, and the inner <span class="literal">for</span> loop reads each receipt for the day. Once each day’s receipts have been read, we extract the maximum receipt, extract the minimum receipt, and update the total prize money.</p>
<p class="indent">This is a complete solution to the problem. It correctly outputs <span class="literal">169</span> for our sample test case, and you should spend some time convincing yourself that it’s correct in general.</p>
<p class="indent">Unfortunately, it’s too slow, and you would get a “Time-Limit Exceeded” error from the judge.</p>
<p class="indent">We can explore the inefficiency by thinking about a worst-case test case. Let’s say that the promotion lasts 5,000 days and that on each of the first 10 days we get 100,000 receipts. After the tenth day, we’ll have about a million receipts in the array. Finding the maximum and minimum involves a linear scan through the array. However, since we remove only two receipts per day, we’ll have close to a million receipts in there all the way through the promotion. So, we’re looking at 5,000 days, almost all of which require about a million steps to find the maximum and another million steps to find the minimum. That’s about 5,000 × 2,000,000, or 10 billion, steps! There is no chance of solving this, given the stringent time limit. If only we could speed up those maximum and minimum computations.</p>
<p class="indent">Let’s quickly disarm sorting as a possible improvement here. If we kept the receipts array sorted, then finding and removing the maximum would take constant time, as the maximum would be at the rightmost index. Finding the minimum would take constant time, too, but it would take linear time to remove the minimum since we’d have to shift all other elements to the left. Sorting also ruins the efficiency of adding a receipt: when we’re not sorting, we can just plunk it at the end of the array, but when sorting we have to find its proper position. No, sorting isn’t the answer. The answer is heaps.</p>
<span epub:type="pagebreak" id="page_282"/>
<h4 class="h4" id="sec120"><em>Max-Heaps</em></h4>
<p class="noindent">We’ll begin by focusing on how to quickly find and extract the maximum element from an array. That’s only solving half the problem—we need to be able to do this for the minimum, too—but we’ll get to that.</p>
<h5 class="h5">Finding the Maximum</h5>
<p class="noindent">Take a look at the tree in <a href="ch08.xhtml#ch08fig01">Figure 8-1</a>. It has 13 nodes corresponding to the following 13 receipts (the first 13 receipts in our sample test case): 6, 63, 16, 82, 25, 2, 43, 5, 17, 10, 56, 85, and 38.</p>
<div class="image"><img alt="Image" id="ch08fig01" src="../images/ch08fig01.jpg"/></div>
<p class="figcap"><em>Figure 8-1: A max-heap</em></p>
<p class="indent">Quick—what’s the maximum receipt cost in that tree?</p>
<p class="indent">It’s 85, and it’s right there at the root. If you were promised that the maximum element of some tree was at its root, then you could just return the element at the root and not search or traverse the tree at all.</p>
<p class="indent">Our plan is to maintain the tree such that the maximum receipt cost is always at the root. We’ll have to be vigilant, because we’re going to be bombarded by two kinds of events that can mess up our tree:</p>
<p class="block"><strong>A new receipt comes in.</strong>   We have to figure out how to reorganize the tree to incorporate this receipt. The new receipt could even be higher than everything else in the tree, in which case we need to get the receipt to the root.</p>
<p class="block"><strong>A receipt gets extracted from the tree.</strong>   We have to figure out how to reorganize the tree so that the maximum element remaining in the tree is at the root.</p>
<p class="indent">Of course, we have to do these inserts and extracts quickly. In particular, we need to be quicker than linear time, as a linear-time scan through an array is what brought us here in the first place!</p>
<h5 class="h5">What Is a Max-Heap?</h5>
<p class="noindent"><a href="ch08.xhtml#ch08fig01">Figure 8-1</a> is an example of a <em>max-heap</em>. The “max” there means that this tree enables us to quickly find the maximum element.</p>
<p class="indent">A max-heap has two important properties. First, it’s a <em>complete</em> binary tree. This means that each level in the tree is full (that is, it has no missing <span epub:type="pagebreak" id="page_283"/>nodes), except possibly the bottom level, whose nodes are filled in from left to right. In <a href="ch08.xhtml#ch08fig01">Figure 8-1</a>, notice how each level is completely full. Well, the bottom level isn’t completely full, but that’s okay because its nodes are filled in from the left. (Don’t confuse complete binary trees here with full binary trees from <a href="ch02.xhtml">Chapter 2</a>.)</p>
<p class="indent">The fact that a max-heap is a complete binary tree doesn’t directly help us find the maximum, insert an element, or extract the maximum, but it does lead to a lightning-fast implementation of heaps, as we’ll see.</p>
<p class="indent">Second, the value of a node is greater than or equal to the values of its child nodes. (The values in <a href="ch08.xhtml#ch08fig01">Figure 8-1</a> are all distinct, so a parent’s value is strictly greater than those of its children.) This is called the <em>max-heap-order</em> property.</p>
<p class="indent">Consider the node in <a href="ch08.xhtml#ch08fig01">Figure 8-1</a> with a value of 56. As promised, 56 is greater than the values of its child nodes (10 and 25). This property is true everywhere in the tree, and it’s why the maximum value must be at the root. Every other node has a parent node with greater value!</p>
<h5 class="h5">Inserting into a Max-Heap</h5>
<p class="noindent">When a new receipt arrives, we’ll insert it into the max-heap, but we have to do it carefully so that the max-heap-order property is maintained.</p>
<p class="indent">Starting with <a href="ch08.xhtml#ch08fig01">Figure 8-1</a>, let’s insert 15. There’s only one place we can put it without breaking the complete-tree property: on the bottom level, to the right of the 38 (see <a href="ch08.xhtml#ch08fig02">Figure 8-2</a>).</p>
<div class="image"><img alt="Image" id="ch08fig02" src="../images/ch08fig02.jpg"/></div>
<p class="figcap"><em>Figure 8-2: A max-heap with 15 inserted</em></p>
<p class="indent">It’s a complete binary tree, for sure, but does the max-heap-order property hold? It does! 15’s parent is 16, and 16 is greater than 15, just as we require. There’s no additional work to do.</p>
<p class="indent">Now consider a tougher one. We’ll insert 32 into <a href="ch08.xhtml#ch08fig02">Figure 8-2</a>, resulting in <a href="ch08.xhtml#ch08fig03">Figure 8-3</a>.</p>
<span epub:type="pagebreak" id="page_284"/>
<div class="image"><img alt="Image" id="ch08fig03" src="../images/ch08fig03.jpg"/></div>
<p class="figcap"><em>Figure 8-3: A max-heap with 32 inserted</em></p>
<p class="indent">There’s some trouble here. Inserting 32 has broken the max-heap-order property, because its parent 16 is less than 32. (Here, and in subsequent figures, the thick edge shows a max-heap-order violation.) We can fix this problem by swapping the 16 and 32, as in <a href="ch08.xhtml#ch08fig04">Figure 8-4</a>.</p>
<div class="image"><img alt="Image" id="ch08fig04" src="../images/ch08fig04.jpg"/></div>
<p class="figcap"><em>Figure 8-4: A max-heap with the max-heap-order violation repaired</em></p>
<p class="indent">Ahh, order has been restored: 32 must be greater than both of its children at this point. It’s greater than its child 16 because that’s why we performed the swap, and it’s greater than its other child 15 because 15 used to be a child of 16. In general, performing such a swap is guaranteed to maintain the max-heap-order property between the new node and its children.</p>
<p class="indent">We’re back to a max-heap, and it only took us one swap to do it. It could take more swaps, though, which I’ll demonstrate now by inserting 91 into <a href="ch08.xhtml#ch08fig04">Figure 8-4</a>. See <a href="ch08.xhtml#ch08fig05">Figure 8-5</a> for the result.</p>
<span epub:type="pagebreak" id="page_285"/>
<div class="image"><img alt="Image" id="ch08fig05" src="../images/ch08fig05.jpg"/></div>
<p class="figcap"><em>Figure 8-5: A max-heap with 91 inserted</em></p>
<p class="indent">We had to start a new level at the bottom of the tree, since the previous bottom level is full. We can’t keep the 91 as a child of 5, though, because it violates the max-heap-order property. A swap will fix it . . . well, sort of. See <a href="ch08.xhtml#ch08fig06">Figure 8-6</a>.</p>
<div class="image"><img alt="Image" id="ch08fig06" src="../images/ch08fig06.jpg"/></div>
<p class="figcap"><em>Figure 8-6: A max-heap with 91 moved up</em></p>
<p class="indent">We’ve fixed the problem between 5 and 91, but now we have a new problem between 17 and 91. We can fix this one by another swap; see <a href="ch08.xhtml#ch08fig07">Figure 8-7</a>.</p>
<span epub:type="pagebreak" id="page_286"/>
<div class="image"><img alt="Image" id="ch08fig07" src="../images/ch08fig07.jpg"/></div>
<p class="figcap"><em>Figure 8-7: A max-heap with 91 moved up again</em></p>
<p class="indent">We have yet another max-heap-order violation, this time between 63 and 91. However, notice that the violation is moving up the tree, becoming closer and closer to the root. At worst, we’ll end up shuttling 91 up to the root of the tree. That’s exactly what will happen here, because 91 is the maximum element. It takes two more swaps to finish the job: the first is shown in <a href="ch08.xhtml#ch08fig08">Figure 8-8</a>.</p>
<div class="image"><img alt="Image" id="ch08fig08" src="../images/ch08fig08.jpg"/></div>
<p class="figcap"><em>Figure 8-8: A max-heap with 91 moved up yet again</em></p>
<p class="indent">And the second swap is shown in <a href="ch08.xhtml#ch08fig09">Figure 8-9</a>.</p>
<span epub:type="pagebreak" id="page_287"/>
<div class="image"><img alt="Image" id="ch08fig09" src="../images/ch08fig09.jpg"/></div>
<p class="figcap"><em>Figure 8-9: A max-heap with the heap-order violation repaired</em></p>
<p class="indent">We’ve got a max-heap again! We only had to perform four swaps to fix the heap of 16 elements, and that was for a value that bubbled up all the way to the root. As we’ve seen, inserting other values that don’t make it all the way to the root will be even faster than that.</p>
<h5 class="h5">Extracting from a Max-Heap</h5>
<p class="noindent">At the end of each day of the promotion, we’ll need to extract the maximum receipt from the max-heap. As with insertion, we must be careful to fix the tree so that it’s a max-heap again. We’ll see that the process mirrors that of insertion, this time with a value bubbling down rather than up.</p>
<p class="indent">Let’s start with <a href="ch08.xhtml#ch08fig01">Figure 8-1</a> and extract the maximum. Here is that figure again:</p>
<div class="image"><img alt="Image" src="../images/page_287_01.jpg"/></div>
<p class="indent">Extracting the maximum removes 85 as the root of the tree, but we need to put something else at the root; otherwise, we would no longer have a tree. The only node we can use, without breaking the complete-tree property, is the rightmost node on the bottom level. That is, we can swap 85 with 38, arriving at <a href="ch08.xhtml#ch08fig10">Figure 8-10</a>.</p>
<span epub:type="pagebreak" id="page_288"/>
<div class="image"><img alt="Image" id="ch08fig10" src="../images/ch08fig10.jpg"/></div>
<p class="figcap"><em>Figure 8-10: A max-heap with 85 extracted</em></p>
<p class="indent">We just took a small value from the bottom of the tree and blasted it up to the top. In general, that’s going to break the max-heap-order property. It certainly does so here, because 38 is less than both 63 and 82.</p>
<p class="indent">We’ll again fix the max-heap-order property by using swaps. Unlike insertion, extraction presents us with a choice. Should we swap 38 and 63, or should we swap 38 and 82? Swapping 38 and 63 doesn’t solve the problem at the root, because 82 would end up as a child of 63. Swapping 38 and 82 is the right move. In general, we want to perform the swap with the larger child, so the max-heap-order property is fixed between the larger child and its new children. <a href="ch08.xhtml#ch08fig11">Figure 8-11</a> shows the result of swapping 38 and 82.</p>
<div class="image"><img alt="Image" id="ch08fig11" src="../images/ch08fig11.jpg"/></div>
<p class="figcap"><em>Figure 8-11: A max-heap with 38 moved down</em></p>
<p class="indent">We’re not out of the woods yet—there’s still a max-heap-order violation between 38 and 43. The good news is that the max-heap-order violation is moving down the tree. If we keep pushing the violations down, then in the worst case we’ll have a max-heap again when 38 hits the bottom of the tree.</p>
<p class="indent">Let’s swap 38 and 43; see <a href="ch08.xhtml#ch08fig12">Figure 8-12</a>.</p>
<span epub:type="pagebreak" id="page_289"/>
<div class="image"><img alt="Image" id="ch08fig12" src="../images/ch08fig12.jpg"/></div>
<p class="figcap"><em>Figure 8-12: A max-heap with 38 moved farther down</em></p>
<p class="indent">The 38 is now fine right where it is, so we’ve restored the max-heap-order property.</p>
<h5 class="h5">Height of a Max-Heap</h5>
<p class="noindent">Both insertion and extraction perform at most one swap per level: insertion swaps up the tree and extraction swaps down the tree. Are insertion and extraction fast? That depends on the height of the max-heap: if the height is small, then these operations are fast. Thus we need to understand the relationship between the number of elements in a max-heap and the height of the max-heap.</p>
<p class="indent">Take a look at <a href="ch08.xhtml#ch08fig13">Figure 8-13</a>, where I’ve drawn the complete binary tree of 16 nodes.</p>
<div class="image"><img alt="Image" id="ch08fig13" src="../images/ch08fig13.jpg"/></div>
<p class="figcap"><em>Figure 8-13: A complete binary tree of 16 nodes (numbered from top to bottom and left to right)</em></p>
<p class="indent">I’ve numbered the nodes from top to bottom, left to right. That’s why the root is 1; its two children are 2 and 3; their children are 4, 5, 6, and 7; <span epub:type="pagebreak" id="page_290"/>and so on. We can observe that each new level starts with a number that is a power of 2: the root is 1, the level below that starts at 2, the level below that starts at 4, then 8, then 16. That is, we need to double the number of nodes to produce just one more level in the tree. This is like binary search, where doubling the number of elements leads to just one more iteration of the loop. As with binary search, then, the height of a complete binary tree, and therefore the height of a max-heap, is <em>O</em>(log <em>n</em>), where <em>n</em> is the number of elements in the tree.</p>
<p class="indent">We are victorious! Inserting into a max-heap is <em>O</em>(log <em>n</em>). Extracting from a max-heap is <em>O</em>(log <em>n</em>). We no longer have to be slowed down by <em>O</em>(<em>n</em>) linear-time work.</p>
<h5 class="h5">Max-Heaps as Arrays</h5>
<p class="noindent">A max-heap is just a binary tree, and we know how to implement binary trees. While it is possible to implement a max-heap as such, it’s quite challenging to do so.</p>
<p class="indent">Think back to when we solved Halloween Haul in <a href="ch02.xhtml">Chapter 2</a>. We used a <span class="literal">node</span> struct with pointers to the left and right children. That would be enough for us to be able to bubble a value down a max-heap. However, it would not be enough for us to be able to bubble a value up a max-heap, because doing so requires access to parent nodes. So we might add a parent pointer:</p>
<pre>typedef struct node {
  <span class="codeitalic1">fields for receipts</span>
  struct node *left, *right, *parent;
} node;</pre>
<p class="indent">Even if we added the <span class="literal">parent</span> like that, we still have direct access only to the root of our tree. When inserting a value, how are we supposed to quickly find where to insert it? When extracting, how are we supposed to quickly find the rightmost node on the bottom level? There is a better way.</p>
<p class="indent">Let’s again use <a href="ch08.xhtml#ch08fig13">Figure 8-13</a>, where I’ve numbered the nodes from top to bottom and left to right. The parent of node number 16 is 8. The parent of node number 12 is 6. The parent of node number 7 is 3. What is the relationship between the number of a node and the number of its parent?</p>
<p class="indent">The answer is: divide by 2! 16/2 = 8. 12/2 = 6. 7/2 = 3. Well, that last one is really 3.5, so just drop the fractional part.</p>
<p class="indent">We integer-divide by 2 to move up the tree. Let’s see what happens if we reverse that process and multiply by two instead. 8 × 2 = 16, so multiplying by 2 takes us from 8 to its left child. However, most nodes have two children, and we may also want to move from a node to its right child. We can do that, too: we just add 1 to the number of the left child. For example, we can move from 6 to its left child by 6 × 2 = 12 and move from 6 to its right child by 6 × 2 + 1 = 13. (The relationship between 13/2 and 6 is an example of why it’s safe to drop the 0.5 to move from a child to its parent.)</p>
<p class="indent">These relationships between nodes hold only because max-heaps are complete binary trees. In general, binary trees can have more chaotic structure, having a long chain of nodes here and a short chain there. We can’t <span epub:type="pagebreak" id="page_291"/>breeze around such a tree by multiplying and dividing by 2 unless we inserted placeholder nodes to maintain the illusion that the tree is complete. That would waste a huge amount of memory if the tree were very unbalanced.</p>
<p class="indent">If we store a max-heap in an array—first the root, then its children, then their children, and so on—then the index of a node in the array corresponds to its node number. We’ll have to start indexing at 1, not 0, to match the numbering in <a href="ch08.xhtml#ch08fig13">Figure 8-13</a>. (It’s possible to start at index 0, but that would result in slightly messier relationships between nodes: the parent of the node at index <em>i</em> would be at (<em>i</em> – 1)/2, and the children would be at indices 2<em>i</em> + 1 and 2<em>i</em> + 2.)</p>
<p class="indent">Here again is <a href="ch08.xhtml#ch08fig01">Figure 8-1</a>, the heap of 13 receipt costs:</p>
<div class="image"><img alt="Image" src="../images/page_291_01.jpg"/></div>
<p class="indent">Here is the corresponding array:</p>
<div class="image"><img alt="Image" src="../images/pg291-01.jpg"/></div>
<p class="indenta">Index 6 in the array has a value of 43. What is 43’s left child? To answer that, just look up index 6 × 2 = 12 in the array: it’s 2. What is 43’s right child? Look up index 6 × 2 + 1 = 13: it’s 38. What is 43’s parent? Check index 6/2 = 3: it’s 82. No matter which node we’re currently focused on in the tree, we can use the array to move to a child or the parent with just a tiny bit of math.</p>
<h5 class="h5">Implementing a Max-Heap</h5>
<p class="noindent">Each element of our heaps will hold both a receipt index and a receipt cost. These are the two pieces of information that we’ll want to know about a receipt when we extract it.</p>
<p class="indent">Here’s the struct:</p>
<pre>typedef struct heap_element {
  int receipt_index;
  int cost;
} heap_element;</pre>
<span epub:type="pagebreak" id="page_292"/>
<p class="indent">Now we’re ready to implement a max-heap. The two key operations are inserting into the heap and extracting the maximum from the heap. Let’s start with inserting into the heap; see <a href="ch08.xhtml#ch08ex03">Listing 8-3</a>.</p>
<pre>void max_heap_insert(heap_element heap[], int *num_heap,
                     int receipt_index, int cost) {
  int i;
  heap_element temp;
<span class="ent">❶</span> (*num_heap)++;
<span class="ent">➋</span> heap[*num_heap] = (heap_element){receipt_index, cost};
<span class="ent">➌</span> i = *num_heap;
<span class="ent">➍</span> while (i &gt; 1 &amp;&amp; heap[i].cost &gt; heap[i / 2].cost) {
     temp = heap[i];
     heap[i] = heap[i / 2];
     heap[i / 2] = temp;
  <span class="ent">➎</span> i = i / 2;
  }
}</pre>
<p class="excap" id="ch08ex03"><em>Listing 8-3: Inserting into max-heap</em></p>
<p class="indent">The <span class="literal">max_heap_insert</span> function takes four parameters. The first two are for the heap: <span class="literal">heap</span> is the array that holds the max-heap, and <span class="literal">num_heap</span> is a pointer to the number of elements in the heap. The reason why <span class="literal">num_heap</span> is a pointer is because we’ll need to increase the number of elements in the heap by one and make the caller aware of that increase. The latter two parameters are for the new receipt: <span class="literal">receipt_index</span> is the index of the receipt that we’re inserting, and <span class="literal">cost</span> is its associated cost.</p>
<p class="indent">We begin by increasing the number of elements in the heap by one <span class="ent">❶</span> and then storing the new receipt in the new heap slot <span class="ent">➋</span>. Variable <span class="literal">i</span> tracks the index in the heap of the newly inserted element <span class="ent">➌</span>.</p>
<p class="indent">We have no guarantee that we still have a max-heap. What we just inserted may be larger than its parent, so we need to perform the required swaps. That’s the point of the <span class="literal">while</span> loop <span class="ent">➍</span>.</p>
<p class="indent">There are two conditions required for the <span class="literal">while</span> loop to continue. First, we need <span class="literal">i &gt; 1</span>, because otherwise <span class="literal">i</span> is 1 and has no parent. (Remember that the heap starts at index 1, not 0.) Second, we need the node’s receipt cost to be greater than that of its parent. The body of the <span class="literal">while</span> loop performs the swap, then it moves us from the current node to its parent <span class="ent">➎</span>. Ahh, again, we have that divide-by-2 scheme to move up the tree. Such spare, pleasing, and correct code is the best kind.</p>
<p class="indent">Now let’s turn to extracting from the max-heap. <a href="ch08.xhtml#ch08ex04">Listing 8-4</a> provides the code.</p>
<pre> heap_element max_heap_extract(heap_element heap[], int *num_heap) {
   heap_element remove, temp;
   int i, child;
<span class="ent">❶</span> remove = heap[1];
<span class="ent">➋</span> heap[1] = heap[*num_heap];
<span class="ent">➌</span> (*num_heap)--;
<span class="ent">➍</span> i = 1;
<span class="ent">➎</span> while (i * 2 &lt;= *num_heap) {
  <span class="ent">➏</span> child = i * 2;
     if (child &lt; *num_heap &amp;&amp; heap[child + 1].cost &gt; heap[child].cost)
    <span class="ent">❼</span> child++;
  <span class="ent">❽</span> if (heap[child].cost &gt; heap[i].cost) {
       temp = heap[i];
       heap[i] = heap[child];
       heap[child] = temp;
    <span class="ent">❾</span> i = child;
     } else
       break;
  }
  return remove;
}</pre>
<span epub:type="pagebreak" id="page_293"/>
<p class="excap" id="ch08ex04"><em>Listing 8-4: Extracting the maximum from max-heap</em></p>
<p class="indent">We begin by saving the receipt that we’re about to extract, which is at the root of the heap <span class="ent">❶</span>. We then replace the root with the bottom-most, right-most node <span class="ent">➋</span>  and decrease the number of elements in the heap by one <span class="ent">➌</span>. That new root element might not meet the max-heap-order property, so we use variable <span class="literal">i</span> to track its position in the heap <span class="ent">➍</span>. Then, just as in <a href="ch08.xhtml#ch08ex03">Listing 8-3</a>, we have a <span class="literal">while</span> loop that will perform the necessary swaps. This time, the <span class="literal">while</span> loop condition <span class="ent">➎</span>  says that the left child of Node <span class="literal">i</span> is in the heap; if it’s not, then Node <span class="literal">i</span> has no children and a max-heap-order violation cannot exist.</p>
<p class="indent">Inside the loop, <span class="literal">child</span> is set to the left child <span class="ent">➏</span>. Then, if the right child exists, we check whether its cost is higher than that of the left child. If it is, then we set <span class="literal">child</span> to be that right child <span class="ent">❼</span>. Now <span class="literal">child</span> is the biggest child, so we check whether it is involved in a max-heap-order violation <span class="ent">❽</span>. If it is, then we perform the swap. Finally, we move down the tree <span class="ent">❾</span> so that we’re ready to check for another max-heap-order violation.</p>
<p class="indent">Notice what happens if the node and its largest child are already correctly ordered: we <span class="literal">break</span> out of the loop, since there can’t be any more violations in the tree.</p>
<p class="indent">The last thing the function does is return the maximum-cost receipt. We’ll be able to use that to help determine the prize for the day and to make sure that we never consider this receipt again. First, however, let’s learn about min-heaps, so we can extract minimums in addition to maximums.</p>
<h4 class="h4" id="sec121"><em>Min-Heaps</em></h4>
<p class="noindent">A <em>min-heap</em> allows us to quickly insert a new receipt and extract the minimum-cost receipt.</p>
<span epub:type="pagebreak" id="page_294"/>
<h5 class="h5">Definition and Operations</h5>
<p class="noindent">Guess what? You know almost everything you need to know about min-heaps, because they are almost identical to max-heaps.</p>
<p class="indent">A min-heap is a complete binary tree. It will have height <em>O</em>(log <em>n</em>), where <em>n</em> is the number of elements in the heap. We’ll be able to store it in an array just as we did a max-heap. To find the parent of a node, divide by 2; to find the left child, multiply by 2; to find the right child, multiply by 2 and add 1. There is nothing new here.</p>
<p class="indent">The only new thing is the <em>min-heap-order</em> property: the value of a node is less than or equal to the values of its child nodes. This results in the smallest value, not the largest value, at the root. That’s exactly where we want it to make minimum-extractions fast.</p>
<p class="indent">Let’s again consider the following 13 receipt costs: 6, 63, 16, 82, 25, 2, 43, 5, 17, 10, 56, 85, and 38. <a href="ch08.xhtml#ch08fig014">Figure 8-14</a> shows a min-heap for these costs.</p>
<div class="image"><img alt="Image" id="ch08fig014" src="../images/ch08fig14.jpg"/></div>
<p class="figcap"><em>Figure 8-14: A min-heap</em></p>
<p class="indent">Inserting into a min-heap and extracting the minimum from a min-heap are analogous to the corresponding max-heap operations.</p>
<p class="indent">To insert, add the new node to the right of all nodes on the bottom level, or start a new level if the bottom level is full. Then swap the node up until it becomes the root or is greater than or equal to its parent.</p>
<p class="indent">To extract the minimum, replace the root by the bottom-most, rightmost value, and then swap it down the tree until it becomes a leaf or is less than or equal to its children.</p>
<h5 class="h5">Implementing a Min-Heap</h5>
<p class="noindent">Implementing a min-heap is a copy-and-paste job using our max-heap code. Just change the function names and change the comparisons from <span class="literal">&gt;</span> to <span class="literal">&lt;</span>. That’s it. See <a href="ch08.xhtml#ch08ex05">Listing 8-5</a> for the insertion code.</p>
<pre>void min_heap_insert(heap_element heap[], int *num_heap,
                     int receipt_index, int cost) {
  int i;
  heap_element temp;
  (*num_heap)++;
  heap[*num_heap] = (heap_element){receipt_index, cost};
<span epub:type="pagebreak" id="page_295"/>  i = *num_heap;
  while (i &gt; 1 &amp;&amp; heap[i].cost &lt; heap[i / 2].cost) {
    temp = heap[i];
    heap[i] = heap[i / 2];
    heap[i / 2] = temp;
    i = i / 2;
  }
}</pre>
<p class="excap" id="ch08ex05"><em>Listing 8-5: Inserting into min-heap</em></p>
<p class="indent"><a href="ch08.xhtml#ch08ex06">Listing 8-6</a> gives the minimum-extraction code.</p>
<pre>heap_element min_heap_extract(heap_element heap[], int *num_heap) {
  heap_element remove, temp;
  int i, child;
  remove = heap[1];
  heap[1] = heap[*num_heap];
  (*num_heap)--;
  i = 1;
  while (i * 2 &lt;= *num_heap) {
    child = i * 2;
    if (child &lt; *num_heap &amp;&amp; heap[child + 1].cost &lt; heap[child].cost)
      child++;
    if (heap[child].cost &lt; heap[i].cost) {
      temp = heap[i];
      heap[i] = heap[child];
      heap[child] = temp;
      i = child;
    } else
      break;
  }
  return remove;
}</pre>
<p class="excap" id="ch08ex06"><em>Listing 8-6: Extracting a minimum from min-heap</em></p>
<p class="indent">There is big-time code duplication here! In practice, what you’d do is write more general <span class="literal">heap_insert</span> and <span class="literal">heap_extract</span> functions that take a comparison function as a parameter (much like <span class="literal">qsort</span> does). It’s simpler, though, to understand the code without that, so let’s keep it as is.</p>
<h4 class="h4" id="sec122"><em>Solution 2: Heaps</em></h4>
<p class="noindent">Now that we’ve got max-heaps and min-heaps, we’re ready for round 2 with this problem.</p>
<p class="indent">All we need is a <span class="literal">main</span> function that reads the input and uses heaps to quickly insert and extract receipts. See <a href="ch08.xhtml#ch08ex07">Listing 8-7</a> for the code. As you read through it, you’ll come across two <span class="literal">while</span> loops. What on earth are those doing?</p>
<span epub:type="pagebreak" id="page_296"/>
<pre>int main(void) {
<span class="ent">❶</span> static int used[MAX_RECEIPTS] = {0};
<span class="ent">➋</span> static heap_element max_heap[MAX_RECEIPTS + 1];
   static heap_element min_heap[MAX_RECEIPTS + 1];
   int num_days, receipt_index_today;
   int receipt_index = 0;
   long long total_prizes = 0;
   int i, j, cost;
   int max_num_heap = 0, min_num_heap = 0;
   heap_element max_element, min_element;
   scanf("%d", &amp;num_days);

   for (i = 0; i &lt; num_days; i++) {
     scanf("%d", &amp;receipt_index_today);
     for (j = 0; j &lt; receipt_index_today; j++) {
       scanf("%d", &amp;cost);
     <span class="ent">➌</span> max_heap_insert(max_heap, &amp;max_num_heap, receipt_index, cost);
     <span class="ent">➍</span> min_heap_insert(min_heap, &amp;min_num_heap, receipt_index, cost);
       receipt_index++;
    }

 <span class="ent">➎</span> max_element = max_heap_extract(max_heap, &amp;max_num_heap);
    while (used[max_element.receipt_index])
      max_element = max_heap_extract(max_heap, &amp;max_num_heap);
    used[max_element.receipt_index] = 1;

 <span class="ent">➏</span> min_element = min_heap_extract(min_heap, &amp;min_num_heap);
    while (used[min_element.receipt_index])
      min_element = min_heap_extract(min_heap, &amp;min_num_heap);
    used[min_element.receipt_index] = 1;
    total_prizes += max_element.cost - min_element.cost;
  }
  printf("%lld\n", total_prizes);
  return 0;
}</pre>
<p class="excap" id="ch08ex07"><em>Listing 8-7: The main function for solving the problem using heaps</em></p>
<p class="indent">We have a <span class="literal">used</span> array <span class="ent">❶</span> that will store for each receipt a <span class="literal">1</span> if it has been used and a <span class="literal">0</span> if not. The max-heap <span class="ent">➋</span> and min-heap are one element larger than the <span class="literal">used</span> array; this accounts for us not using index 0 in the heaps.</p>
<p class="indent">For a given day, we insert the index of each receipt into both the max-heap <span class="ent">➌</span>  and min-heap <span class="ent">➍</span>. We then extract a receipt from the max-heap <span class="ent">➎</span> and extract a receipt from the min-heap <span class="ent">➏</span>. This is where those two <span class="literal">while</span> loops come in, looping until we get a receipt that hasn’t yet been used. Let me explain what’s going on.</p>
<p class="indent">When we extract a receipt from the max-heap, it would be nice to also extract it from the min-heap so that the two heaps always contain exactly the <span epub:type="pagebreak" id="page_297"/>same receipts. Notice, though, that we don’t actually extract that same receipt from the min-heap. Why? Because we have no idea where that receipt <em>is</em> in the min-heap! At some later time, that receipt might be extracted from the min-heap—but it has already been used, so we want to throw it away and not process it again.</p>
<p class="indent">The opposite can happen, too, because we extract a receipt from the min-heap and leave it in the max-heap. At some later time, that used receipt might come out of the max-heap. We need to ignore it and extract from the max-heap again.</p>
<p class="indent">So that’s what the <span class="literal">while</span> loops do: ignore receipts that have already been processed by one of the heaps.</p>
<p class="indent">A new test case may help. Here it is:</p>
<pre>2
2 6 7
2 9 10</pre>
<p class="indent">The prize money here is 7 – 6 = 1 from the first day and 10 – 9 = 1 from the second day, so the total prize money is 2.</p>
<p class="indent">After reading the two receipts on the first day, each heap holds the two receipts. For the max-heap, we have:</p>
<div class="bqparan">
<table class="all">
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="borderbz"><span class="codestrong">receipt_index</span></th>
<th class="borderbz"><span class="codestrong">cost</span></th>
</tr>
</thead>
<tbody>
<tr>
<td class="center" style="vertical-align: top">1</td>
<td class="center" style="vertical-align: top">7</td>
</tr>
<tr>
<td class="borderbz" style="vertical-align: top">0</td>
<td class="borderbz" style="vertical-align: top">6</td>
</tr>
</tbody>
</table>
</div>
<p class="indenta">For the min-heap, we have:</p>
<div class="bqparan">
<table class="all">
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="borderbz" style="vertical-align: top"><span class="codestrong">receipt_index</span></th>
<th class="borderbz" style="vertical-align: top"><span class="codestrong">cost</span></th>
</tr>
</thead>
<tbody>
<tr>
<td class="center" style="vertical-align: top">0</td>
<td class="center" style="vertical-align: top">6</td>
</tr>
<tr>
<td class="borderbz" style="vertical-align: top">1</td>
<td class="borderbz" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
</div>
<p class="indenta">We then do the heap extractions, removing one receipt from each heap. Here’s what’s left for the max-heap:</p>
<table class="all">
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="borderbz" style="vertical-align: top"><span class="borderb"><span class="codestrong">receipt_index</span></span></th>
<th class="borderbz" style="vertical-align: top"><span class="borderb"><span class="codestrong">cost</span></span></th>
</tr>
</thead>
<tbody>
<tr>
<td class="borderbz" style="vertical-align: top">0</td>
<td class="borderbz" style="vertical-align: top">6</td>
</tr>
</tbody>
</table>
<p class="indent">Here’s what’s left for the min-heap:</p>
<table class="all">
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="borderbz" style="vertical-align: top"><span class="codestrong">receipt_index</span></th>
<th class="borderbz" style="vertical-align: top"><span class="codestrong">cost</span></th>
</tr>
</thead>
<tbody>
<tr>
<td class="borderbz" style="vertical-align: top">1</td>
<td class="borderbz" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
<p class="indent">Receipt 0 is still in the max-heap, and Receipt 1 is still in the min-heap. However, they have been used, so we’d better not use them again.</p>
<span epub:type="pagebreak" id="page_298"/>
<p class="indent">Now consider the second day. Receipts 2 and 3 get added to each heap, so for the max-heap, we have:</p>
<div class="bqparan">
<table class="all">
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="borderbz" style="vertical-align: top"><span class="codestrong">receipt_index</span></th>
<th class="borderbz" style="vertical-align: top"><span class="codestrong">cost</span></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">3</td>
<td class="grayzz" style="vertical-align: top">10</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">0</td>
<td class="center" style="vertical-align: top">6</td>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">2</td>
<td class="grayzz" style="vertical-align: top">9</td>
</tr>
</tbody>
</table>
</div>
<p class="noindenta">For the min-heap, we have:</p>
<div class="bqparan">
<table class="all">
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="borderbz" style="vertical-align: top"><span class="codestrong">receipt_index</span></th>
<th class="borderbz" style="vertical-align: top"><span class="codestrong">cost</span></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">1</td>
<td class="grayzz" style="vertical-align: top">7</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">9</td>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">3</td>
<td class="grayzz" style="vertical-align: top">10</td>
</tr>
</tbody>
</table>
</div>
<p class="indenta">When we extract from the max-heap, we get Receipt 3. That’s great. However, when we extract from the min-heap, we get Receipt 1. Without the <span class="literal">while</span> loop to throw it away, this would be big trouble, because Receipt 1 has already been used.</p>
<p class="indent">At the end of a given day, one or both of the <span class="literal">while</span> loops might iterate many times. If this kept happening, day after day, then we’d have to be concerned about the impact on our program’s efficiency. Notice, though, that a receipt can be removed from a heap at most once. If there are <em>r</em> receipts in a heap, then there can be at most <em>r</em> extractions from the heap, whether they are clustered in a single day or across many days.</p>
<p class="indent">It is time to submit to the judge. Unlike Solution 1, which frittered away its time with slow searches, our heap-based solution should pass all of the test cases well within the time limit.</p>
<h3 class="h3" id="lev51">Heaps</h3>
<p class="noindent">If you have a stream of values coming in and at any given time you may be asked to process the maximum or minimum value, then a heap is what you want. A max-heap is used to extract and process the maximum; a min-heap is used to extract and process the minimum.</p>
<p class="indent">A heap can be used to implement a <em>priority queue</em>. In a priority queue, each element has a priority that determines its importance. In some applications, the priorities of important elements are big numbers, in which case a max-heap should be used; in others, the priorities of important elements are small numbers, in which case a min-heap should be used. Of course, if we need both high- and low-priority elements, we can use two heaps as we did when solving the Supermarket Promotion problem.</p>
<h4 class="h4" id="sec123"><em>Two More Applications</em></h4>
<p class="noindent">I find that min-heaps are used more often than max-heaps. Let’s explore two examples where min-heaps can be used.</p>
<h5 class="h5"><span epub:type="pagebreak" id="page_299"/>Heapsort</h5>
<p class="noindent">There’s a famous sorting algorithm called <em>heapsort</em> that we can implement now that we understand min-heaps. All we do is insert all of the values into the min-heap and then extract the minimum one by one. The extractions pull out the smallest value, then the second-smallest value, then the third-smallest value, and so on, handing us the values sorted from smallest to largest. It’s literally four lines. Check it out in <a href="ch08.xhtml#ch08ex08">Listing 8-8</a>.</p>
<pre>#define N 10

int main(void) {
  static int values[N] = {96, 61, 36, 74, 45, 60, 47, 6, 95, 93};
  static int min_heap[N + 1];
  int i, min_num_heap = 0;

  // Heapsort. 4 lines!
  for (i = 0; i &lt; N; i++)
    min_heap_insert(min_heap, &amp;min_num_heap, values[i]);
  for (i = 0; i &lt; N; i++)
    values[i] = min_heap_extract(min_heap, &amp;min_num_heap);

  for (i = 0; i &lt; N; i++)
    printf("%d ", values[i]);
  printf("\n");
  return 0;
}</pre>
<p class="excap" id="ch08ex08"><em>Listing 8-8: Heapsort</em></p>
<p class="indent">We’re inserting integers into the heap here, so you should change <span class="literal">min_heap_insert</span> and <span class="literal">min_heap_extract</span> to use and compare integers rather than <span class="literal">heap_element</span> structs.</p>
<p class="indent">Heapsort performs <em>n</em> inserts and <em>n</em> extracts. A heap implements each of those in log <em>n</em> time, so heapsort is an <em>O</em>(<em>n</em> log <em>n</em>) algorithm. That’s the same worst-case runtime as the fastest possible sorting algorithms. (The <span class="literal">q</span> in C’s <span class="literal">qsort</span> function probably gets its name from <em>quicksort</em>, which is a sorting algorithm that is faster than heapsort in practice. We’ll encounter quicksort in <a href="ch10.xhtml">Chapter 10</a>.)</p>
<h5 class="h5">Dijkstra’s Algorithm</h5>
<p class="noindent">Dijkstra’s algorithm (<a href="ch06.xhtml">Chapter 6</a>) spends a lot of its time finding the next node to process. It does that by searching through node distances, looking for the smallest one. To speed up Dijkstra’s algorithm, we can use a min-heap! This is demonstrated in “Dijkstra’s Algorithm: Using a Heap” in <a href="app02.xhtml">Appendix B</a>.</p>
<span epub:type="pagebreak" id="page_300"/>
<h4 class="h4" id="sec124"><em>Choosing a Data Structure</em></h4>
<p class="noindent">A data structure is typically good for only a few different operation types. There’s no super data structure that makes everything fast, so it’s up to you to choose the appropriate data structure for the problem you’re solving.</p>
<p class="indent">Think back to <a href="ch01.xhtml">Chapter 1</a>, when we learned about the hash table data structure. Could we have used a hash table to solve Supermarket Promotion?</p>
<p class="indent">No! A hash table is good for speeding up the search for a specific item that we’re searching for. What are the snowflakes that might be similar to snowflake <em>s</em>? Is word <em>c</em> in this word list? Those are the kinds of questions you want to ask of a hash table. What is the minimum element in this array? No hashing is going to help there. You’d have to search through the hash table, which is no faster than searching a regular array. It’s our job to choose a data structure specifically designed for the task at hand. For finding the minimum element in an array, that data structure is a min-heap.</p>
<p class="indent">As with any general-purpose data structure, heaps can be used to solve a surprisingly diverse set of problems—but the heap data structure itself remains as is, just as you’ve learned it here. So instead of solving another heap problem, let’s proceed to a problem where we’ll need a new data structure called a <em>segment tree</em>. As with heaps, segment trees speed up only a small number of types of operations. Even so, it’s impressive how many problems are in the wheelhouse of segment trees, where those speedups are exactly what we need.</p>
<h3 class="h3" id="lev52">Problem 2: Building Treaps</h3>
<p class="noindent">In this problem, we’ll produce a representation of a <em>treap</em>. A treap is a flexible data structure that can solve a variety of search problems, and I encourage you to learn more about treaps if you’re interested. Here we’re concerned only with building a treap, not using it. Of course, I’ll provide all you need to know about treaps for our purposes.</p>
<p class="indent">This is POJ problem <span class="literal">1785</span>.</p>
<h4 class="h4" id="sec125"><em>The Problem</em></h4>
<p class="noindent">A treap is a binary tree where each node has both a label and a priority. <a href="ch08.xhtml#ch08fig015">Figure 8-15</a> shows an example treap, in which the uppercase letters are the labels and the positive integers are the priorities. I’ve separated the label and priority for each node by a slash. For example, the root node has label C and priority 58.</p>
<span epub:type="pagebreak" id="page_301"/>
<div class="image"><img alt="Image" id="ch08fig015" src="../images/ch08fig15.jpg"/></div>
<p class="figcap"><em>Figure 8-15: A treap</em></p>
<p class="indent">A treap has to satisfy two properties: one on its labels and one on its priorities.</p>
<p class="indent">First, let’s talk about labels. For any node <em>x</em>, the labels in its left subtree are all less than the label of <em>x</em>, and the labels in its right subtree are all greater than the label of <em>x</em>. This is called the <em>binary search tree (BST)</em> property.</p>
<p class="indent">You can verify that the treap in <a href="ch08.xhtml#ch08fig015">Figure 8-15</a> meets this label property. For our alphabetic labels, one label is less than another if it comes earlier in the alphabet. Take the root node as an example. Its label is C. Both labels in its left subtree are less than C, and all labels in its right subtree are greater than C. As another example, consider the node with label G. All of the labels in its left subtree—D, E, and F—are less than G. What about all of the labels in its right subtree? Well, there are none, so there’s nothing to check!</p>
<p class="indent">Second, let’s talk about priorities. For any node <em>x</em>, the priorities of its children are less than the priority of <em>x</em>. Hey, this is like the max-heap-order property!</p>
<p class="indent">Take a look at the root again. Its priority is 58. Its children had better have lower priorities—and they do, with priorities 54 and 56. How about that G node, with priority 55? We need its child to have a lower priority—and it does, with priority 49.</p>
<p class="indent">So that’s a treap: a binary tree whose labels satisfy the BST property and whose priorities satisfy the max-heap-order property. Notice that there’s no shape requirement: a treap can have any structure whatsoever. There’s certainly no complete tree requirement like there is for heaps.</p>
<p class="indent">In this problem, we are provided the label/priority of each node. Our task is to assemble and output a treap for these nodes.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains zero or more test cases. Each line of input begins with an integer <em>n</em>. Each <em>n</em> is between 0 and 50,000. If <em>n</em> is 0, then there are no further test cases to process.</p>
<span epub:type="pagebreak" id="page_302"/>
<p class="indent">If <em>n</em> is greater than zero, then it indicates the number of nodes in the test case. Following <em>n</em> is <em>n</em> space-separated tokens, one for each node. Each token is of the form <span class="literal">L/P</span>, where <span class="literal">L</span> is the label and <span class="literal">P</span> is the priority for this node. Labels are strings of letters; priorities are positive integers. All labels are unique, and all priorities are unique.</p>
<p class="indent">Here is possible input that leads to the treap in <a href="ch08.xhtml#ch08fig015">Figure 8-15</a>:</p>
<pre>11 A/54 I/16 K/39 E/36 B/42 G/55 D/49 H/56 C/58 J/40 F/5
0</pre>
<h5 class="h5">Output</h5>
<p class="noindent">For each test case, output the treap on its own line. Here is the required format for the treap:</p>
<pre><span class="codeitalic1">(&lt;left_subtreap&gt;&lt;L&gt;/&lt;P&gt;&lt;right_subtreap&gt;)</span></pre>
<p class="indent">Here <span class="codeitalic">&lt;left_subtreap&gt;</span> is the left subtreap, <span class="codeitalic">&lt;L&gt;</span> is the label of the root, <span class="codeitalic">&lt;P&gt;</span> is the priority of the root, and <span class="codeitalic">&lt;right_subtreap&gt;</span> is the right subtreap. The subtreaps are output in the same format.</p>
<p class="indent">Here is the output corresponding to the sample input:</p>
<pre>((A/54(B/42))C/58(((D/49(E/36(F/5)))G/55)H/56((I/16)J/40(K/39))))</pre>
<p class="indent">The time limit for solving the test cases is two seconds.</p>
<h4 class="h4" id="sec126"><em>Recursively Outputting Treaps</em></h4>
<p class="noindent">Let’s again consider our sample nodes and reason through how we can produce a treap from them. Here are those nodes:</p>
<pre>A/54 I/16 K/39 E/36 B/42 G/55 D/49 H/56 C/58 J/40 F/5</pre>
<p class="indent">Remember that treap priorities must obey the max-heap-order property. In particular, this means that a node with maximum priority must be the root node. In addition, because the input guarantees that all priorities are distinct, there is only one node that has the maximum priority. So it’s settled: the root node must be <span class="literal">C/58</span>.</p>
<p class="indent">We now must decide for each other node whether it should go in C’s left subtreap or right subtreap. The priorities of these nodes are all less than 58, so priority won’t help us make any kind of left–right split—but the BST property will! The BST property of treaps tells us that the labels in the left subtreap must be less than C and the labels in the right subtreap must be greater than C. We can therefore split the remaining nodes into two groups, one for the left subtreap and one for the right subtreap, as follows:</p>
<pre>A/54 B/42
I/16 K/39 E/36 G/55 D/49 H/56 J/40 F/5</pre>
<p class="indent">That is, the left subtreap will have Nodes A and B, and the right subtreap will have Nodes I, K, E, G, and so on.</p>
<span epub:type="pagebreak" id="page_303"/>
<p class="indent">Now, we’re done! We’ve split the original problem into two smaller subproblems of exactly the same form. We were asked to produce a treap for 11 nodes. We’ve reduced that problem to producing a treap for two nodes and a treap for eight nodes. We can do those recursively!</p>
<p class="indent">Let’s nail down the specific rules that we’ll use. For the base case, we can use a treap of zero nodes, which requires no output at all. For the recursive case, we’ll identify the root as the node with highest priority and then split the remaining nodes into those with smaller labels and those with larger labels. We output an open parenthesis, recursively output the treap for the smaller labels, output the root node of the treap, output the treap for the larger labels, and finally output a closing parenthesis.</p>
<p class="indent">For our sample input, we’ll output an opening parenthesis. Then we’ll output the left subtreap:</p>
<pre>(A/54(B/42))</pre>
<p class="indent">This is followed by the root node:</p>
<pre>C/58</pre>
<p class="noindent">then the right subtreap:</p>
<pre>(((D/49(E/36(F/5)))G/55)H/56((I/16)J/40(K/39)))</pre>
<p class="noindent">and finally a closing parenthesis.</p>
<h4 class="h4" id="sec127"><em>Sorting by Label</em></h4>
<p class="noindent">I have one other implementation idea before we turn to the code. As I’ve described things so far, it seems that we’d need to literally create a new array with small-labeled nodes to pass to the first recursive call and a new array with large-labeled nodes to pass to the second recursive call. That would result in lots of copying between arrays. Fortunately, we can avoid all that by sorting the nodes by label, from smallest to largest, at the outset. Then we can just tell each recursive call the starting and ending indices of the array that it is responsible for.</p>
<p class="indent">For example, if we sort our sample input by label, we get this:</p>
<pre>A/54 B/42 C/58 D/49 E/36 F/5 G/55 H/56 I/16 J/40 K/39</pre>
<p class="indent">We can then tell the first recursive call to produce the subtreap for the first two nodes and the second recursive call to produce the subtreap for the latter eight.</p>
<h4 class="h4" id="sec128"><em>Solution 1: Recursion</em></h4>
<p class="noindent">Here are some constants and a struct:</p>
<pre>#define MAX_NODES 50000
#define LABEL_LENGTH 16
<span epub:type="pagebreak" id="page_304"/>typedef struct treap_node {
  char * label;
  int priority;
} treap_node;</pre>
<p class="indent">We don’t know how long the labels are, so we’ll go with an initial size of 16. You’ll see that we call a <span class="literal">read_label</span> function to read each label; if a length of 16 proves insufficient, that function will allocate more memory until the label fits. (This is probably overkill, since it looks like the test cases use short labels of up to only five letters, but it’s better to be safe than sorry.)</p>
<h5 class="h5">The main Function</h5>
<p class="noindent">Let’s look at the <span class="literal">main</span> function, as given in <a href="ch08.xhtml#ch08ex09">Listing 8-9</a>. It uses some helper functions—<span class="literal">read_label</span> that we just talked about and <span class="literal">compare</span> for comparing treap nodes—and calls <span class="literal">solve</span> for actually outputting the treap. We’ll discuss those shortly.</p>
<pre>int main(void) {
  static treap_node treap_nodes[MAX_NODES];
  int num_nodes, i;
  scanf("%d ", &amp;num_nodes);
  while (num_nodes &gt; 0) {
    for (i = 0; i &lt; num_nodes; i++) {
      treap_nodes[i].label = read_label(LABEL_LENGTH);
      scanf("%d ", &amp;treap_nodes[i].priority);
    }
    qsort(treap_nodes, num_nodes, sizeof(treap_node), compare);
    solve(treap_nodes, 0, num_nodes - 1);
    printf("\n");
    scanf("%d ", &amp;num_nodes);
  }
  return 0;
}</pre>
<p class="excap" id="ch08ex09"><em>Listing 8-9: The main function for reading input and solving the problem</em></p>
<p class="indent">Be careful with <span class="literal">scanf</span> in a program that reads a mix of numbers and strings. Here, each number from the input is followed by whitespace, and we don’t want those space characters prefixing the labels that follow. To read and throw away those spaces, we use a space following each <span class="literal">%d scanf</span> format specifier.</p>
<h5 class="h5">Helper Functions</h5>
<p class="noindent">We use <span class="literal">scanf</span> to read the priorities but not the labels. The labels are read by the <span class="literal">read_label</span> function in <a href="ch08.xhtml#ch08ex010">Listing 8-10</a>.</p>
<pre> /* based on https://stackoverflow.com/questions/16870485 */
 char *read_label(int size) {
   <span epub:type="pagebreak" id="page_305"/>char *str;
   int ch;
   int len = 0;
   str = malloc(size);
   if (str == NULL) {
     fprintf(stderr, "malloc error\n");
     exit(1);
   }
<span class="ent">❶</span> while ((ch = getchar()) != EOF &amp;&amp; (ch != '/')) {
     str[len++] = ch;
     if (len == size) {
       size = size * 2;
       str = realloc(str, size);
       if (str == NULL) {
         fprintf(stderr, "realloc error\n");
         exit(1);
       }
     }
   }
   str[len] = '\0';
   return str;
}</pre>
<p class="excap" id="ch08ex010"><em>Listing 8-10: Reading a label</em></p>
<p class="indent">We’ve used essentially the same function once before in <a href="ch05.xhtml#ch05ex015">Listing 5-15</a>. The only difference this time is that we stop reading at the <span class="literal">/</span> character that separates the label from the priority <span class="ent">❶</span>. As usual, <span class="literal">qsort</span> needs a comparison function, and the one we want, given in <a href="ch08.xhtml#ch08ex011">Listing 8-11</a>, compares nodes by label.</p>
<pre>int compare(const void *v1, const void *v2) {
  const treap_node *n1 = v1;
  const treap_node *n2 = v2;
  return strcmp(n1-&gt;label, n2-&gt;label);
}</pre>
<p class="excap" id="ch08ex011"><em>Listing 8-11: A comparison function for sorting</em></p>
<p class="indent">The <span class="literal">strcmp</span> function works perfectly as a comparison function, because it returns a negative integer if the first string is alphabetically less than the second string, <span class="literal">0</span> if the strings are equal, and a positive integer if the first string is alphabetically greater than the second string.</p>
<h5 class="h5">Outputting the Treap</h5>
<p class="noindent">Before we get to the main event—the <span class="literal">solve</span> function—we need a helper function to return the index of the node with maximum priority. This is provided in <a href="ch08.xhtml#ch08ex012">Listing 8-12</a>. It’s a slow, linear search from index <span class="literal">left</span> to index <span class="literal">right</span> (and this should worry you!).</p>
<span epub:type="pagebreak" id="page_306"/>
<pre>int max_priority_index(treap_node treap_nodes[], int left, int right) {
  int i;
  int max_index = left;
  for (i = left + 1; i &lt;= right; i++)
    if (treap_nodes[i].priority &gt; treap_nodes[max_index].priority)
      max_index = i;
  return max_index;
}</pre>
<p class="excap" id="ch08ex012"><em>Listing 8-12: Finding the maximum priority</em></p>
<p class="indent">Now we’re ready to output the treap! See <a href="ch08.xhtml#ch08ex013">Listing 8-13</a> for the <span class="literal">solve</span> function.</p>
<pre>void solve(treap_node treap_nodes[], int left, int right) {
  int root_index;
  treap_node root;
<span class="ent">❶</span> if (left &gt; right)
     return;
<span class="ent">➋</span> root_index = max_priority_index(treap_nodes, left, right);
   root = treap_nodes[root_index];
   printf("(");
<span class="ent">➌</span> solve(treap_nodes, left, root_index - 1);
   printf("%s/%d", root.label, root.priority);
<span class="ent">➍</span> solve(treap_nodes, root_index + 1, right);
   printf(")");
}</pre>
<p class="excap" id="ch08ex013"><em>Listing 8-13: Solving the problem</em></p>
<p class="indent">This function takes three parameters: the array of treap nodes and <span class="literal">left</span> and <span class="literal">right</span> indices determining the range of nodes over which we’d like the treap to be built. In order for the treap to be built for all of the nodes, the initial call from <span class="literal">main</span> will pass <span class="literal">0</span> for <span class="literal">left</span> and <span class="literal">num_nodes - 1</span> for <span class="literal">right</span>.</p>
<p class="indent">The base case for this recursive function occurs when there are no nodes in the treap <span class="ent">❶</span>. In this case, we simply return without outputting anything. With no nodes, there is no output.</p>
<p class="indent">Otherwise, from nodes with indices between <span class="literal">left</span> and <span class="literal">right</span>, we find the index of the node with maximum priority <span class="ent">➋</span>. That’s the root of the treap, and it splits the problem in two: outputting a treap for those nodes with smaller labels and outputting a treap for those nodes with larger labels. We solve each of these subproblems with a recursive call <span class="ent">➌</span> <span class="ent">➍</span>.</p>
<p class="indent">There we have it: our first solution. It’s quite nice, I’d say. In fact, it does two important things right. First, it sorts the nodes, once and for all, so that each call of <span class="literal">solve</span> needs only its <span class="literal">left</span> and <span class="literal">right</span> indices. Second, it uses recursion to make short work of the otherwise-daunting process of outputting a treap.</p>
<span epub:type="pagebreak" id="page_307"/>
<p class="indent">However, submit this code to the judge and you’ll see that everything grinds to a halt because of that linear search to find the node with maximum priority (<a href="ch08.xhtml#ch08ex012">Listing 8-12</a>). What’s so wrong with it? What kind of treap triggers its worst-case performance? We’ll talk about that next.</p>
<h4 class="h4" id="sec129"><em>Range Maximum Queries</em></h4>
<p class="noindent">In the previous chapter, we talked about solving the range sum query problem. That one asked, “Given an array <span class="literal">a</span>, left index <span class="literal">left</span>, and right index <span class="literal">right</span>, what is the <em>sum</em> of all elements from <span class="literal">a[left]</span> to <span class="literal">a[right]</span>?”</p>
<p class="indent">Here, in Building Treaps, we’re being asked to solve a related problem known as the <em>range maximum query (RMQ)</em> problem. This asks, “Given an array <span class="literal">a</span>, left index <span class="literal">left</span>, and right index <span class="literal">right</span>, what is the index of the <em>maximum</em> element of all elements from <span class="literal">a[left]</span> to <span class="literal">a[right]</span>?” (Rather than the index, for some problems it might suffice to get the maximum element itself, but for Building Treaps we need the index.)</p>
<p class="indent">In Solution 1, we offered an implementation of RMQ in <a href="ch08.xhtml#ch08ex012">Listing 8-12</a>. It iterates from <span class="literal">left</span> to <span class="literal">right</span>, checking whether we’ve found an index whose node has higher priority than what we’ve discovered so far. We call that function for each subtreap, and each call involves a linear search through the active segment of the array. If most of those linear searches were on small array segments, then we might get away with this. However, there are some inputs that cause many of the searches to be on huge segments of the array. Here’s such a list of nodes that we might read from the input:</p>
<pre>A/1 B/2 C/3 D/4 E/5 F/6 G/7</pre>
<p class="indent">We scan all seven nodes, finding <span class="literal">G/7</span> as the node with maximum priority. We then recursively output the treap for the small-labeled nodes and recursively output the treap for the large-labeled nodes. Unfortunately, the first recursive call gets all but the <span class="literal">G/7</span> node, as the second recursive call is on zero nodes. The first recursive call gets this:</p>
<pre>A/1 B/2 C/3 D/4 E/5 F/6</pre>
<p class="indent">Now we need another scan of these six elements to identify the node with highest priority. We’ll identify <span class="literal">F/6</span> as that node, make it the root of this subtreap, and then make two more recursive calls. Again, however, the first recursive call is saddled with all remaining nodes, leading to another expensive array scan. This pattern of expensive array scans can continue until there are no nodes remaining.</p>
<p class="indent">Generalizing, we can say that, for <em>n</em> nodes, the first RMQ could take <em>n</em> steps, the second could take <em>n</em> – 1 steps, and so on, all the way down to 1 step. That’s 1 + 2 + 3 + . . .+ <em>n</em> steps in all. A closed form for this formula is <em>n</em>(<em>n</em> + 1)/2. In <a href="ch01.xhtml">Chapter 1</a>, we saw a very similar formula in “Diagnosing the Problem” on <a href="ch01.xhtml#ch01lev1">page 9</a>. We can similarly conclude that we’re doing <em>O</em>(<em>n</em><sup>2</sup>) (quadratic) work here.</p>
<p class="indent">Here’s another way to see that we’re doing <em>O</em>(<em>n</em><sup>2</sup>) work. Throw away the <em>n</em>/2 smallest terms and focus on only the remaining <em>n</em>/2 larger terms. <span epub:type="pagebreak" id="page_308"/>(Let’s assume that <em>n</em> is even so that <em>n</em>/2 is an integer.) This leaves us with <em>n</em> + (<em>n</em> – 1) + (<em>n</em> – 2) + . . . + (<em>n</em>/2 + 1). There are <em>n</em>/2 terms here, each of which is larger than <em>n</em>/2, so in total they add up to at least (<em>n</em>/2)(<em>n</em>/2) = <em>n</em><sup>2</sup>/4. This is quadratic!</p>
<p class="indent">Therefore, a linear search to solve the RMQ problem is not satisfactory.</p>
<p class="indent">In the previous chapter, we used a prefix array to speed up range sum queries. Give that a quick refresher now, because I’m about to ask you a question: Can we use that technique to solve the RMQ, too?</p>
<p class="indent">Unfortunately, no. (Or, fortunately no, because I can teach you one of my favorite data structures as a result.) To sum the elements from index 2 to 5, we can look up the prefix sum for index 5 and subtract the prefix sum for index 1. That’s because subtraction undoes addition: the prefix sum for index 5 contains the prefix sum for index 1, so we can just subtract the latter out of there. Unfortunately, we cannot “undo” a maximum computation in the same way. If the maximum for the elements up to index 5 is 10, and the maximum for the elements up to index 1 is also 10, what is the maximum from index 2 to index 5? Who knows! With that 10 gone, it could be whatever is at index 2, or 3, or 4, or 5. A huge, early element prevents later elements from making any change at all to the prefix array. When that huge element is gone, we lose our bearings. Contrast that to a prefix sum array, where every element leaves its mark.</p>
<p class="indent">As a last-ditch effort, let’s try a heap. Can we use a max-heap to solve the RMQ? No, again. A max-heap gives us the maximum element in the entire heap, with no provision for restricting that to a given range.</p>
<p class="indent">It’s time for something new.</p>
<h4 class="h4" id="sec130"><em>Segment Trees</em></h4>
<p class="noindent">Shoo, treaps, shoo! We’ll return to treaps later, just as soon as we have a better implementation of RMQ.</p>
<p class="indent">A <em>segment tree</em> is a full binary tree where each node is associated with a particular segment of an underlying array. (In Building Treaps, the underlying array is the array of priorities.) Each node stores the answer for the query on its segment. For the RMQ, each node stores the index of the maximum element in its segment, but segment trees can be used for other queries, too. The segments are arranged such that a small number of them can be assembled to answer any query.</p>
<h5 class="h5">The Segments</h5>
<p class="noindent">The root node of a segment tree covers the entire array. So, if we’re ever asked for the RMQ on the entire array, we can solve that in one step by just looking at the root. For other queries, we’ll have to use other nodes. The root node has two children: the left child covers the first half of the array and the right child covers the second half. Each of these nodes has two children of its own, which subdivide the segments even further, and so on, until we get to segments of just one element.</p>
<span epub:type="pagebreak" id="page_309"/>
<p class="indent"><a href="ch08.xhtml#ch08fig016">Figure 8-16</a> shows a segment tree that supports queries on an eight-element array. Each node is labeled with its left and right endpoints. There’s no information in the segment tree about the RMQ yet; for now, we’ll just focus on the segments themselves.</p>
<div class="image"><img alt="Image" id="ch08fig016" src="../images/ch08fig16.jpg"/></div>
<p class="figcap"><em>Figure 8-16: A segment tree for an eight-element array</em></p>
<p class="indent">Notice that the sizes of segments are cut in half for each level that we descend in the tree. For example, the root segment covers eight elements, each of its children covers four elements, each of their children covers two elements, and so on. Like a heap, the height of a segment tree is log <em>n</em>, where <em>n</em> is the number of elements in the array. We’ll be able to answer any query by doing a constant amount of work per level, so we’ll obtain <em>O</em>(log <em>n</em>) time per query.</p>
<p class="indent"><a href="ch08.xhtml#ch08fig016">Figure 8-16</a> is a complete binary tree. Through our study of heaps, we know what to do with these: store them in an array! We can then use the same math to find the children of a parent, which we’ll need when processing segment trees.</p>
<p class="indent">Now, I’m going to hit you with another segment tree, one that exposes a bit of a surprise. See <a href="ch08.xhtml#ch08fig017">Figure 8-17</a>.</p>
<div class="image"><img alt="Image" id="ch08fig017" src="../images/ch08fig17.jpg"/></div>
<p class="figcap"><em>Figure 8-17: A segment tree for an 11-element array</em></p>
<p class="indent">That’s not a complete binary tree at all, because the bottom level is not filled in from left to right! For example, Node 2-2 has no children, even though 3-4 does.</p>
<span epub:type="pagebreak" id="page_310"/>
<p class="indent">Everything’s okay, though. We’ll continue to store a segment tree in an array. We’ll continue to multiply a node’s index by 2 to get its left child and to multiply by 2 and add 1 to get its right child. All that will happen is a little bit of waste in the array. For example, the order of elements in the array for <a href="ch08.xhtml#ch08fig017">Figure 8-17</a> is as follows, where <span class="literal">*</span> is an unused element:</p>
<pre>0-10
0-5 6-10
0-2 3-5 6-8 9-10
0-1 2-2 3-4 5-5 6-7 8-8 9-9 10-10
0-0 1-1 * * 3-3 4-4 * * 6-6 7-7 * * * * * *</pre>
<p class="indent">This waste <em>does</em> make it a little more difficult to determine the number of array elements we need for the segment tree.</p>
<p class="indent">If the number of elements, <em>n</em>, in the underlying array is a power of 2, then we’ll be safe with a segment tree that can hold 2<em>n</em> elements. For example, count the nodes in <a href="ch08.xhtml#ch08fig016">Figure 8-16</a>: it takes 15 nodes, which is less than 8 × 2 = 16. (2<em>n</em> is safe because all powers of 2 less than <em>n</em> add up to exactly <em>n</em> – 1. For example, 4 + 2 + 1 = 7, which is 1 less than 8.) If <em>n</em> isn’t a power of 2, then 2<em>n</em> isn’t enough. For proof, look no further than <a href="ch08.xhtml#ch08fig017">Figure 8-17</a>, which would require an array of 31 elements (more than 2 × 11 = 22) to hold it.</p>
<p class="indent">The more elements to cover in the segment tree, the bigger we need to make the segment tree array—but how big should it be? Suppose that we have an underlying array of <em>n</em> elements for which we want to build a segment tree. I’ll argue that the segment tree should be allocated an array of 4<em>n</em> elements to be safe.</p>
<p class="indent">Let <em>m</em> be the smallest power of 2 greater than or equal to <em>n</em>. For example, if <em>n</em> is 11, then <em>m</em> is 16. We can store a segment tree for <em>m</em> elements in an array with 2<em>m</em> elements. Since <em>m</em> ≥ <em>n</em>, an array with 2<em>m</em> elements is enough to store a segment tree for <em>n</em> elements, too.</p>
<p class="indent">Fortunately, <em>m</em> can’t be that high: it’s at most twice the value of <em>n</em>. (The worst case occurs for values of <em>n</em> that are just above powers of 2. For example, if <em>n</em> is 9, then <em>m</em> is 16, which is almost twice as large as 9.) Therefore, if we need an array of 2<em>m</em> elements and <em>m</em> is at most 2<em>n</em>, then 2<em>m</em> is at most 2 × 2<em>n</em> = 4<em>n</em>.</p>
<h5 class="h5" id="ch09lev1a">Initializing the Segments</h5>
<p class="noindent">In each node of the segment tree, we’ll store three things: the left index of its segment, the right index of its segment, and the index of the maximum element in the range. We’ll initialize the first two of these before moving to the third.</p>
<p class="indent">Here’s the struct that we’ll use for a segment tree node:</p>
<pre>typedef struct segtree_node {
  int left, right;
  int max_index;
} segtree_node;</pre>
<span epub:type="pagebreak" id="page_311"/>
<p class="noindent">To initialize the <span class="literal">left</span> and <span class="literal">right</span> members for each node, we’ll write the body for the following function signature:</p>
<pre>void init_segtree(segtree_node segtree[], int node,
                  int left, int right)</pre>
<p class="indent">We assume that <span class="literal">segtree</span> is an array with sufficient space for the segment tree. The <span class="literal">node</span> parameter is the root index of the segment tree; <span class="literal">left</span> and <span class="literal">right</span> are its segment’s left and right indices, respectively. An initial call of <span class="literal">init_segtree</span> would look like this:</p>
<pre>init_segtree(segtree, 1, 0, num_elements - 1);</pre>
<p class="indent">Here <span class="literal">num_elements</span> is the number of elements in the underlying array (for example, the number of nodes in a treap).</p>
<p class="indent">We can use recursion to implement <span class="literal">init_segtree</span>. If <span class="literal">left</span> and <span class="literal">right</span> are equal, then we have a one-element segment and there is no subdividing to do. Otherwise, we’re in the recursive case and have to split the segment in two. <a href="ch08.xhtml#ch08ex014">Listing 8-14</a> provides the code.</p>
<pre>void init_segtree(segtree_node segtree[], int node,
                  int left, int right) {
  int mid;
  segtree[node].left = left;
  segtree[node].right = right;
<span class="ent">❶</span> if (left == right)
     return;
<span class="ent">➋</span> mid = (left + right) / 2;
<span class="ent">➌</span> init_segtree(segtree, node * 2, left, mid);
<span class="ent">➍</span> init_segtree(segtree, node * 2 + 1, mid + 1, right);
}</pre>
<p class="excap" id="ch08ex014"><em>Listing 8-14: Initializing segment tree segments</em></p>
<p class="indent">We first store the values of <span class="literal">left</span> and <span class="literal">right</span> in the node. Then, we check the base case <span class="ent">❶</span>, returning from the function if no children are required.</p>
<p class="indent">If children are required, then we calculate the midpoint of the current range <span class="ent">➋</span>. We then need to build the left segment tree for the indices from <span class="literal">left</span> to <span class="literal">mid</span> and the right segment tree for the indices from <span class="literal">mid + 1</span> to <span class="literal">right</span>. This is accomplished by two recursive calls: one for the left <span class="ent">➌</span>  and one for the right <span class="ent">➍</span>. Notice how we use <span class="literal">node * 2</span> to move to the left child and <span class="literal">node * 2 + 1</span> to move to the right child.</p>
<h5 class="h5">Filling the Segment Tree</h5>
<p class="noindent">With the segment tree initialized, it’s time to add the index of the maximum element in its segment to each node. For an example, we’ll need both a segment tree and the array on which the segment tree will be based. For the <span epub:type="pagebreak" id="page_312"/>segment tree, let’s use <a href="ch08.xhtml#ch08fig017">Figure 8-17</a>, and, for the array, let’s use the 11 priorities from “Sorting by Label” on <a href="ch08.xhtml#sec127">page 303</a>. <a href="ch08.xhtml#ch08fig018">Figure 8-18</a> shows the filled segment tree. The maximum index for each node is given below its segment endpoints.</p>
<div class="image"><img alt="Image" id="ch08fig018" src="../images/ch08fig18.jpg"/></div>
<p class="figcap"><em>Figure 8-18: A segment tree and an array of priorities</em></p>
<p class="indent">Let’s perform a couple of quick checks. Consider the 0-0 node on the bottom of the tree. That’s a segment of only index 0, so the only choice for the index of the maximum element is 0. This sounds like a base case to me!</p>
<p class="indent">Now consider Node 6-10. The node says that 7 is the index of the maximum element from index 6 to index 10. Index 7 holds 56, and you can verify that this is the largest element in the segment. To quickly calculate this, we can use the maximum indices stored in 6-10’s child nodes: the left child says that 7 is the desired index for the 6-8 segment, and the right child says that 9 is the desired index for the 9-10 segment. For 6-10, then, we really have only two choices: index 7 or index 9, the elements that we get back from these subtrees. This sounds like a recursive case to me!</p>
<p class="indent">That’s right: we’re going to use recursion to fill the tree, much as we did to initialize the tree’s segments. <a href="ch08.xhtml#ch08ex015">Listing 8-15</a> gives the code.</p>
<pre>int fill_segtree(segtree_node segtree[], int node,
                 treap_node treap_nodes[]) {
  int left_max, right_max;

<span class="ent">❶</span> if (segtree[node].left == segtree[node].right) {
     segtree[node].max_index = segtree[node].left;
  <span class="ent">➋</span> return segtree[node].max_index;
  }
<span epub:type="pagebreak" id="page_313"/><span class="ent">➌</span> left_max = fill_segtree(segtree, node * 2, treap_nodes);
<span class="ent">➍</span> right_max = fill_segtree(segtree, node * 2 + 1, treap_nodes);

<span class="ent">➎</span> if (treap_nodes[left_max].priority &gt; treap_nodes[right_max].priority)
     segtree[node].max_index = left_max;
   else
     segtree[node].max_index = right_max;
<span class="ent">➏</span> return segtree[node].max_index;
}</pre>
<p class="excap" id="ch08ex015"><em>Listing 8-15: Adding the maximums</em></p>
<p class="indent">The <span class="literal">segtree</span> parameter is the array where the segment tree is stored; we assume that it has already been initialized by <a href="ch08.xhtml#ch08ex014">Listing 8-14</a>. The <span class="literal">node</span> parameter is the root index of the segment tree, and <span class="literal">treap_nodes</span> is an array of treap nodes. We need the treap nodes here so we can access their priorities, but otherwise this doesn’t have anything to do with treaps. You could easily replace the treap nodes with whatever you need for solving a given problem.</p>
<p class="indent">This function returns the index of the maximum element for the root node of the segment tree.</p>
<p class="indent">The code begins with the base case check: that the node spans just a single index <span class="ent">❶</span>. If it does, then the maximum index for the node is just its left index (or its right—they’re the same, after all). We then return that maximum index <span class="ent">➋</span>.</p>
<p class="indent">If we’re not in the base case, then we’re looking at a segment that spans more than one index. We make a recursive call to the left subtree <span class="ent">➌</span>. That call figures out the <span class="literal">max_index</span> value for each node in that subtree and returns to us the <span class="literal">max_index</span> value of that subtree’s root. We then do the same for the right subtree <span class="ent">➍</span>. Then we compare the indices we got back from those recursive calls <span class="ent">➎</span>, choosing the one whose priority is higher, and setting this node’s <span class="literal">max_index</span> accordingly. The last thing to do is to return that maximum index <span class="ent">➏</span>.</p>
<p class="indent">Filling the tree in this way takes linear time: for each node, we do a constant amount of work to find its maximum index.</p>
<h5 class="h5">Querying the Segment Tree</h5>
<p class="noindent">Let’s recap. We were stymied in our attempts to solve Building Treaps because we didn’t have a fast way to respond to the range maximum queries. As a result, we’ve spent a lot of time developing segment trees, deciding how to choose the segments, how big to make the segment tree array, and how to store the index of the maximum element for each node.</p>
<p class="indent">Of course, all of this segment tree stuff would be for naught unless it gives us fast queries. Finally, then, it’s time for the payoff: getting fast queries using a segment tree. It’s go time! Don’t worry—it doesn’t involve much more than the kind of recursion we’ve been using on segment trees so far.</p>
<span epub:type="pagebreak" id="page_314"/>
<p class="indent">To get a feel for this, we’ll make some sample queries on <a href="ch08.xhtml#ch08fig018">Figure 8-18</a>. Here’s that figure again:</p>
<div class="image"><img alt="Image" src="../images/page_314_01.jpg"/></div>
<p class="indenta">For our first query, let’s do 6-10. This range covers only some of what the root’s 0-10 segment covers, so returning the root’s maximum index wouldn’t be justified. Instead, we’ll ask each of the root’s children for the maximum relevant index and use those answers to return the maximum index overall. The root’s left child covers Segment 0-5, and that has no overlap at all with our 6-10 range. The left recursive call tells us nothing. The root’s right child, however, covers exactly Segment 6-10. The recursive call on that right child will return 7, and that’s what we should return overall: 7 is the index of the maximum element in the 6-10 range.</p>
<p class="indent">For our second query, let’s do 3-8. Again, we’ll ask each of the root’s children for the maximum relevant index—except that, this time, both children will have something to say, because 3-8 overlaps both 0-5 and 6-10. The recursive call on the left child will return 3, and the recursive call on the right child will return 7. At the root, then, all we do is compare the element at index 3 with the element at index 7. The one at index 7 is higher, so that’s our answer.</p>
<p class="indent">I don’t normally unwind recursion, but I’ll make an exception here because I think it might help. Let’s further dive into the recursive call on the left subtree. We’re still querying 3-8, and the range of the node is 0-5. The left child of 0-5 is 0-2. 0-2 doesn’t have any indices in common with our 3-8 query range, so it’s out. That leaves the 3-5 node to do the work. Importantly, 3-5 is completely contained within our desired 3-8 range, so we stop here and return 3 from the 3-5 recursive call.</p>
<p class="indent">Querying the node of a segment tree falls into one of three cases, and we have seen them all in our examples here. Case 1 is when the node has no indices in common with the query range, case 2 is when the node’s segment is completely contained within the query range, and case 3 is when <span epub:type="pagebreak" id="page_315"/>the node’s segment contains part of the query range but also contains indices not in the query range.</p>
<p class="indent">I recommend pausing here, just before we look at the code, to work a few more query examples by hand. In particular, try the query 4-9. You’ll notice that it requires tracing two long paths down the tree. This is the worst-case behavior: we split into two nodes near the top of the tree, and then we trace those two paths all the way down. Convince yourself through further examples, perhaps on larger segment trees, that those paths cannot further subdivide into two long paths of their own. So, although querying a segment tree does do a little more work than a heap operation—sometimes tracing two paths rather than one—it still accesses a small number of nodes per level, giving an <em>O</em>(log <em>n</em>) runtime.</p>
<p class="indent">The code for querying a segment tree is given in <a href="ch08.xhtml#ch08ex016">Listing 8-16</a>.</p>
<pre>int query_segtree(segtree_node segtree[], int node,
                  treap_node treap_nodes[], int left, int right) {
  int left_max, right_max;

<span class="ent">❶</span> if (right &lt; segtree[node].left || left &gt; segtree[node].right)
     return -1;

<span class="ent">➋</span> if (left &lt;= segtree[node].left &amp;&amp; segtree[node].right &lt;= right)
     return segtree[node].max_index;

<span class="ent">➌</span> left_max = query_segtree(segtree, node * 2,
                            treap_nodes, left, right);
<span class="ent">➍</span> right_max = query_segtree(segtree, node * 2 + 1,
                             treap_nodes, left, right);

   if (left_max == -1)
     return right_max;
   if (right_max == -1)
     return left_max;
<span class="ent">➎</span> if (treap_nodes[left_max].priority &gt; treap_nodes[right_max].priority)
     return left_max;
   return right_max;
}</pre>
<p class="excap" id="ch08ex016"><em>Listing 8-16: Querying the segment tree</em></p>
<p class="indent">The function parameters are similar to those of <a href="ch08.xhtml#ch08ex015">Listing 8-15</a>, except that we’ve added the <span class="literal">left</span> and <span class="literal">right</span> indices of our query. The code handles each of the three cases in turn.</p>
<p class="indent">In case 1, the node has nothing in common with the query. This holds exactly when the query range ends before the node’s segment starts or when the query range starts after the node’s segment ends <span class="ent">❶</span>. We return <span class="literal">-1</span> to indicate that this node has no maximum index to return.</p>
<p class="indent">In case 2, the node’s segment is completely within the query range <span class="ent">➋</span>. We therefore return the maximum index of this node’s segment.</p>
<span epub:type="pagebreak" id="page_316"/>
<p class="indent">That leaves case 3, where the node’s segment partially overlaps the query range. We make two recursive calls: one to get the maximum index from the left child <span class="ent">➌</span>  and one to get the maximum index from the right child <span class="ent">➍</span>. If one of those returns <span class="literal">-1</span>, then we return the other. If they both return valid indices, then we choose the index whose element is larger <span class="ent">➎</span>.</p>
<h4 class="h4" id="sec131"><em>Solution 2: Segment Trees</em></h4>
<p class="noindent">Our final order of business is to alter our first solution (specifically the <span class="literal">main</span> function in <a href="ch08.xhtml#ch08ex09">Listing 8-9</a> and the <span class="literal">solve</span> function in <a href="ch08.xhtml#ch08ex013">Listing 8-13</a>) to use segment trees. It won’t take much: we’ll just make the appropriate calls to the segment tree functions that we’ve already written.</p>
<p class="indent"><a href="ch08.xhtml#ch08ex017">Listing 8-17</a> contains the new <span class="literal">main</span> function.</p>
<pre> int main(void) {
   static treap_node treap_nodes[MAX_NODES];
<span class="ent">❶</span> static segtree_node segtree[MAX_NODES * 4 + 1];
   int num_nodes, i;
   scanf("%d ", &amp;num_nodes);
   while (num_nodes &gt; 0) {
     for (i = 0; i &lt; num_nodes; i++) {
       treap_nodes[i].label = read_label(LABEL_LENGTH);
       scanf("%d ", &amp;treap_nodes[i].priority);
     }
     qsort(treap_nodes, num_nodes, sizeof(treap_node), compare);
  <span class="ent">➋</span> init_segtree(segtree, 1, 0, num_nodes - 1);
  <span class="ent">➌</span> fill_segtree(segtree, 1, treap_nodes);
  <span class="ent">➍</span> solve(treap_nodes, 0, num_nodes - 1, segtree);
     printf("\n"); 
     scanf("%d ", &amp;num_nodes);
  }
  return 0;
}</pre>
<p class="excap" id="ch08ex017"><em>Listing 8-17: The main function with segment trees added</em></p>
<p class="indent">The only additions are the declaration of the segment tree <span class="ent">❶</span>, a call to initialize the segment tree’s segments <span class="ent">➋</span>, a call to compute the maximum index for each segment tree node <span class="ent">➌</span>, and a new argument to pass the segment tree along to the <span class="literal">solve</span> function <span class="ent">➍</span>.</p>
<p class="indent">The new <span class="literal">solve</span> function itself is given in <a href="ch08.xhtml#ch08ex018">Listing 8-18</a>.</p>
<pre>void solve(treap_node treap_nodes[], int left, int right,
           segtree_node segtree[]) {
  int root_index;
  treap_node root;
  if (left &gt; right)
    return;
<span class="ent">❶</span> root_index = query_segtree(segtree, 1, treap_nodes, left, right);
   <span epub:type="pagebreak" id="page_317"/>root = treap_nodes[root_index];
   printf("(");
   solve(treap_nodes, left, root_index - 1, segtree);
   printf("%s/%d", root.label, root.priority);
   solve(treap_nodes, root_index + 1, right, segtree);
   printf(")");
}</pre>
<p class="excap" id="ch08ex018"><em>Listing 8-18: Solving the problem with segment trees added</em></p>
<p class="indent">There’s only one substantive change: the call to <span class="literal">query_segtree</span> to implement the RMQ <span class="ent">❶</span>!</p>
<p class="indent">Phew! We had to work pretty hard there. This segment tree solution should pass all of the judge’s test cases within the time limit. In the end, it was worth it, though, because segment trees insinuate themselves into fast solutions to all kinds of problems.</p>
<h3 class="h3" id="lev53">Segment Trees</h3>
<p class="noindent">Segment trees go by several other names in the wild, including interval trees, tournament trees, order-statistic trees, and range query trees. It doesn’t help that “segment tree” is also used to refer to an entirely different data structure than what we’ve studied here! Perhaps through my chosen terminology I have unknowingly aligned myself with some particular segment of the programmer population.</p>
<p class="indent">Whatever you call them, segment trees are must-know structures for those learning algorithms and those interested in competitive programming. On an underlying array of <em>n</em> elements, you can build a segment tree in <em>O</em>(<em>n</em>) time and query a range in <em>O</em>(log <em>n</em>) time.</p>
<p class="indent">In Building Treaps, we used segment trees to solve the RMQ, but segment trees can be used for other queries, too. If you can answer a query by quickly combining answers to two subqueries, then a segment tree is likely the tool of choice. What about a minimum range query? With a segment tree, you just take the minimum (not the maximum) of the children’s answers. What about a range sum query? With a segment tree, you just take the sum of the children’s answers.</p>
<p class="indent">Perhaps you’re wondering whether segment trees apply only when the elements of the underlying array remain constant through the execution of the program. In Building Treaps, for example, the treap nodes never changed, so there was no way in which our segment tree could ever become out of sync with what was stored in the array. Indeed, many segment tree problems share this characteristic: an array to be queried, not modified. However, a neat bonus feature of segment trees is that they can be used even when the underlying array is allowed to change. Problem 3 shows you how this is done, and it also shows us a new type of query that we haven’t seen before.</p>
<span epub:type="pagebreak" id="page_318"/>
<h3 class="h3" id="lev54">Problem 3: Two Sum</h3>
<p class="noindent">There is no context this time—this is just a pure problem for segment trees. As you’ll see, we’ll need to support updates to the array, and the query we’ll need is not the same as the RMQ.</p>
<p class="indent">This is SPOJ problem <span class="literal">KGSS</span>.</p>
<h4 class="h4" id="sec132"><em>The Problem</em></h4>
<p class="noindent">We are given a sequence of integers <em>a</em>[1], <em>a</em>[2], . . . , <em>a</em>[<em>n</em>], where each integer is at least 0. (Think of the sequence as an array that starts at index 1 rather than 0.)</p>
<p class="indent">We need to support two types of operations on the sequence:</p>
<p class="block"><strong>Update</strong>   Given integers <em>x</em> and <em>y</em>, change <em>a</em>[<em>x</em>] to <em>y</em>.</p>
<p class="block"><strong>Query</strong>   Given integers <em>x</em> and <em>y</em>, return the maximum sum of two elements in the range <em>a</em>[<em>x</em>] to <em>a</em>[<em>y</em>].</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindents">A line containing <em>n</em>, the number of elements in the sequence. <em>n</em> is between 2 and 100,000.</li>
<li class="noindents">A line containing <em>n</em> integers, each giving one element of the sequence in order from <em>a</em>[1] to <em>a</em>[<em>n</em>]. Each integer is at least 0.</li>
<li class="noindents">A line containing <em>q</em>, the number of operations to be performed on the sequence. <em>q</em> is between 0 and 100,000.</li>
<li class="noindents"><em>q</em> lines, each giving one update or query operation to be performed on the sequence.</li>
</ul>
<p class="indent">Here are the operations that can be performed in those <em>q</em> lines.</p>
<p class="block"><strong>Update</strong>   An update operation is specified as the letter <span class="literal">U</span>, a space, an integer <em>x</em>, a space, and an integer <em>y</em>. It indicates that <em>a</em>[<em>x</em>] should be changed to <em>y</em>. For example, <span class="literal">U 1 4</span> means that <em>a</em>[1] is to be changed from its current value to 4. <em>x</em> is between 1 and <em>n</em>; <em>y</em> is at least 0. This operation does not result in any output.</p>
<p class="block"><strong>Query</strong>   A query operation is specified as the letter <span class="literal">Q</span>, a space, an integer <em>x</em>, a space, and an integer <em>y</em>. It indicates that we should output the maximum sum of two elements in the range <em>a</em>[<em>x</em>] to <em>a</em>[<em>y</em>]. For example, <span class="literal">Q 1 4</span> asks us for the maximum sum of two elements in the range <em>a</em>[1] to <em>a</em>[4]. <em>x</em> and <em>y</em> are between 1 and <em>n</em>, and <em>x</em> is less than <em>y</em>.</p>
<h5 class="h5">Output</h5>
<p class="noindent">Output the result of each query operation, one per line.</p>
<p class="indent">The time limit for solving the test case is one second.</p>
<span epub:type="pagebreak" id="page_319"/>
<h4 class="h4" id="sec133"><em>Filling the Segment Tree</em></h4>
<p class="noindent">In Building Treaps, we needed the segment tree to give us indices of the underlying array, which we used to characterize the recursion and split the treap nodes. This time, however, there’s no reason to store indices in the segment tree. All we care about is the sum of elements, not the indices of those elements.</p>
<p class="indent">We’ll initialize the segments of our segment tree just like we did in “Initializing the Segments” on <a href="ch08.xhtml#ch09lev1a">page 310</a>. We now need the segments to start covering the array at index 1, not index 0, but otherwise there’s nothing new here. <a href="ch08.xhtml#ch08fig019">Figure 8-19</a> shows a segment tree that supports a seven-element array. It covers indices 1 to 7, not 0 to 6, to correspond to the problem description.</p>
<div class="image"><img alt="Image" id="ch08fig019" src="../images/ch08fig19.jpg"/></div>
<p class="figcap"><em>Figure 8-19: A segment tree for a seven-element array</em></p>
<p class="indent">Add the code from <a href="ch08.xhtml#ch08ex014">Listing 8-14</a> to your program.</p>
<p class="indent">Now let’s think about how to fill each node with the maximum sum of two elements in its segment. Suppose that we’ve already found the maximum sum of two elements for Node 1-2 and already found the maximum sum of two elements for Node 3-4. We want to find the maximum sum of two elements for Node 1-4. How do we do this?</p>
<p class="indent">Life was good when we were solving the RMQ, because the maximum for a node is just the maximum of its children. For example, if the maximum value in the left subtree is 10 and the maximum in the right subtree is 6, then the maximum for their parent node is 10. No surprises there. In contrast, with this “maximum sum of two elements” segment tree, something weird happens.</p>
<p class="indent">Suppose we have these four sequence elements: 10, 8, 6, and 15. The maximum sum of two elements in Segment 1-2 is 18, and the maximum sum of two elements in Segment 3-4 is 21. Is 18 the answer for Segment 1-4, or is 21? Neither is correct! The answer is 10 + 15 = 25. We can’t conjure up that 25 if all we know is the 18 from the left and 21 from the right. We need the left and right children to tell us more about their segment—more than just “Oh hey, here’s my maximum sum of two elements.”</p>
<p class="indent">To be clear, sometimes getting back just the maximum sum of two elements from each child <em>is</em> enough. Consider this sequence: 10, 8, 6, and 4. The maximum sum of two elements for Segment 1-2 is 18, and the maximum sum of two elements in Segment 3-4 is 10. The maximum sum of <span epub:type="pagebreak" id="page_320"/>two elements in 1-4 is 18, which happens to be the answer from its child segment 1-2—but that was lucky!</p>
<p class="indent">There are at most three options for the maximum sum of two elements for a segment. (There are fewer than three options if a node’s child doesn’t have a valid maximum sum.) Those options are as follows:</p>
<p class="block"><strong>Option 1</strong>   The maximum sum is in the left child. This is like the lucky case that we just did. We get the answer from what the left child tells us.</p>
<p class="block"><strong>Option 2</strong>   The maximum sum is in the right child. This is another lucky case, where the answer is what the right child tells us.</p>
<p class="block"><strong>Option 3</strong>   The maximum sum includes one element from the left child and one element from the right child. This one requires more work, because the answer is not one of the maximums of our children. This is where we need more information from the children.</p>
<p class="indenta">If the maximum sum of two elements for some segment consists of one element from the left and one from the right, then it must use the maximum element from the left and the maximum element from the right. Let’s return to the sequence 10, 8, 6, and 15. The maximum sum here is an example that involves one element from the left (10) and one element from the right (15). Notice that these are the largest elements in the left and right segments, respectively. There’s no way to take an element from each side and do better than this.</p>
<p class="indent">Now we see what the segment tree nodes have to tell us. In addition to what the outside world cares about—the maximum sum of two elements—we also need the maximum element on its own. Combined, these two pieces of information about child segments enable us to fill in the information for the parent segment.</p>
<p class="indent"><a href="ch08.xhtml#ch08fig020">Figure 8-20</a> shows an example segment tree built for an array. Notice that each node contains both maxsum (the maximum sum of two elements) and maxelm (the maximum element).</p>
<div class="image"><img alt="Image" id="ch08fig020" src="../images/ch08fig20.jpg"/></div>
<p class="figcap"><em>Figure 8-20: A segment tree and its corresponding array</em></p>
<span epub:type="pagebreak" id="page_321"/>
<p class="indent">Computing the maximum element for each node is something that we know how to do: it’s just the RMQ problem that we solved in Building Treaps.</p>
<p class="indent">That leaves the maximum sum of two elements for each node. To begin, we set the maximum sum for the nodes with one-element segments, such as 1-1, 2-2, and so on, to the special value –1. The reason we do this is that there aren’t even two elements in these segments to choose from! The –1 alerts us that the parent’s maximum sum cannot be the maximum sum of this child.</p>
<p class="indent">The maximum sum for each other node is set based on the maximum sums of its children. Consider Node 1-7. There are three options for its maximum sum. We could take the maximum sum 25 from the left, or we could take the maximum sum 12 from the right, or we could take the maximum element 15 from the left and the maximum element 9 from the right to get 15 + 9 = 24. Of these, 25 is the largest number, so that’s what we choose.</p>
<p class="indent">We make a special case of the fake –1 maximum sum values to highlight that those cannot be taken as options for the maximum sum of the parent node. Look out for this in the upcoming code.</p>
<p class="indent">We’ll use a struct for the segment tree nodes:</p>
<pre>typedef struct segtree_node {
  int left, right;
  int max_sum, max_element;
} segtree_node;</pre>
<p class="indent">We’ll use another struct for what we will return from the <span class="literal">fill_segtree</span> and <span class="literal">query_segtree</span> functions:</p>
<pre>typedef struct node_info {
  int max_sum, max_element;
} node_info;</pre>
<p class="indent">We need <span class="literal">node_info</span> because it lets us return both the maximum sum and the maximum element; returning one integer, without the struct, would not be sufficient.</p>
<p class="indent">The code for computing the maximum sum and the maximum element for each segment is given in <a href="ch08.xhtml#ch08ex019">Listing 8-19</a>.</p>
<pre>int max(int v1, int v2) {
  if (v1 &gt; v2)
    return v1;
  else
    return v2;
}

node_info fill_segtree(segtree_node segtree[], int node,
                       int seq[]) {
  node_info left_info, right_info;

<span epub:type="pagebreak" id="page_322"/><span class="ent">❶</span> if (segtree[node].left == segtree[node].right) {
     segtree[node].max_sum = -1;
     segtree[node].max_element = seq[segtree[node].left];
  <span class="ent">➋</span> return (node_info){segtree[node].max_sum, segtree[node].max_element};
   }

<span class="ent">➌</span> left_info = fill_segtree(segtree, node * 2, seq);
   right_info = fill_segtree(segtree, node * 2 + 1, seq);

<span class="ent">➍</span> segtree[node].max_element = max(left_info.max_element,
                                   right_info.max_element);

<span class="ent">➎</span> if (left_info.max_sum == -1 &amp;&amp; right_info.max_sum == -1)
  <span class="ent">➏</span> segtree[node].max_sum = left_info.max_element +
                             right_info.max_element;

<span class="ent">❼</span> else if (left_info.max_sum == -1)
     segtree[node].max_sum = max(left_info.max_element +
                                 right_info.max_element,
                                 right_info.max_sum);

<span class="ent">❽</span> else if (right_info.max_sum == -1)
     segtree[node].max_sum = max(left_info.max_element +
                                 right_info.max_element,
                                 left_info.max_sum);

  else
 <span class="ent">❾</span> segtree[node].max_sum = max(left_info.max_element +
                                right_info.max_element,
                                max(left_info.max_sum, right_info.max_sum));
  return (node_info){segtree[node].max_sum, segtree[node].max_element};
}</pre>
<p class="excap" id="ch08ex019"><em>Listing 8-19: Adding the maximum sum and maximum element</em></p>
<p class="indent">When the segment contains just one element, we’re in the base case <span class="ent">❶</span>. We set the maximum sum to the special <span class="literal">-1</span> value, which indicates that there is no valid sum of two elements here, and we set the maximum element to the only element in the segment. We then return the maximum sum and maximum element <span class="ent">➋</span>.</p>
<p class="indent">Otherwise, we’re in the recursive case. We use <span class="literal">left_info</span> to hold the information for the left segment and <span class="literal">right_info</span> to hold the information for the right segment. Each of those variables is initialized using a recursive call <span class="ent">➌</span>.</p>
<p class="indent">As we discussed, the maximum element in a segment is just the maximum of the maximum element in the left and the maximum element in the right <span class="ent">➍</span>.</p>
<span epub:type="pagebreak" id="page_323"/>
<p class="indent">Now consider the maximum sum of two elements. If neither of the children has a maximum sum <span class="ent">➎</span>, then we know that each child’s segment contains just one element. This parent therefore has only two elements in its segment, and adding up those elements is the only choice for the maximum sum of two elements <span class="ent">➏</span>.</p>
<p class="indent">Next, what do we do if the left child has only one element and the right child has more than one element <span class="ent">❼</span>? Well, now we have two options for the maximum sum for the parent. The first option is to add the maximum elements from each half. The second is to take the maximum sum from the right segment. We use <span class="literal">max</span> to take the best of these two. The case when the right child has only one element and left child has more than one element is analogous <span class="ent">❽</span>.</p>
<p class="indent">The final case is when both children have more than one element <span class="ent">❾</span>. Now we have three options: add the maximum elements from each half, take the maximum sum from the left, or take the maximum sum from the right.</p>
<h4 class="h4" id="sec134"><em>Querying the Segment Tree</em></h4>
<p class="noindent">The work we just did to fill in the segment information is going to pay off again, right now, for the code to query the segment tree. See <a href="ch08.xhtml#ch08ex020">Listing 8-20</a>.</p>
<pre>node_info query_segtree(segtree_node segtree[], int node,
                        int seq[], int left, int right) {
  node_info left_info, right_info, ret_info;

<span class="ent">❶</span> if (right &lt; segtree[node].left || left &gt; segtree[node].right)
     return (node_info){-1, -1};

<span class="ent">➋</span> if (left &lt;= segtree[node].left &amp;&amp; segtree[node].right &lt;= right)
     return (node_info) {segtree[node].max_sum, segtree[node].max_element};

   left_info = query_segtree(segtree, node * 2, seq, left, right);
   right_info = query_segtree(segtree, node * 2 + 1, seq, left, right);

   if (left_info.max_element == -1)
     return right_info;
   if (right_info.max_element == -1)
     return left_info;

   ret_info.max_element = max(left_info.max_element, right_info.max_element);

   if (left_info.max_sum == -1 &amp;&amp; right_info.max_sum == -1) {
     ret_info.max_sum = left_info.max_element + right_info.max_element;
     return ret_info;
   }

   else if (left_info.max_sum == -1) {
     ret_info.max_sum = max(left_info.max_element + right_info.max_element,
                            right_info.max_sum);
     return ret_info;
   }

   else if (right_info.max_sum == -1) {
     ret_info.max_sum = max(left_info.max_element + right_info.max_element,
                            left_info.max_sum);
     return ret_info;
   }

   else {
     ret_info.max_sum = max(left_info.max_element + right_info.max_element,
                            max(left_info.max_sum, right_info.max_sum));
     return ret_info;
   }
}</pre>
<span epub:type="pagebreak" id="page_324"/>
<p class="excap" id="ch08ex020"><em>Listing 8-20: Querying the segment tree</em></p>
<p class="indent">The structure of this code parallels the RMQ code in <a href="ch08.xhtml#ch08ex016">Listing 8-16</a>. If the node’s segment has nothing in common with the query range <span class="ent">❶</span>, we return a struct where both the maximum sum and maximum element are <span class="literal">-1</span>. We can use this special value of <span class="literal">-1</span> for the maximum element to tell us that there is no information available from a recursive call.</p>
<p class="indent">If the node’s segment is completely within the query range <span class="ent">➋</span>, then we return the maximum sum and maximum element for this node.</p>
<p class="indent">Finally, if the node’s segment partially overlaps the query range, then we follow the same logic as when we filled in the segment information in <a href="ch08.xhtml#ch08ex019">Listing 8-19</a>.</p>
<h4 class="h4" id="sec135"><em>Updating the Segment Tree</em></h4>
<p class="noindent">When an element of the sequence array is updated, we have to adjust the segment tree to keep pace. Otherwise, queries on the segment tree would use now-stale array elements and may therefore yield results at odds with what’s currently in the array.</p>
<p class="indent">One option is to start from scratch and ignore whatever segment information is already in the tree. We can do that by rerunning <a href="ch08.xhtml#ch08ex019">Listing 8-19</a> each time an array element is updated. That would certainly bring the segment tree back up to date, so correctness is not a concern.</p>
<span epub:type="pagebreak" id="page_325"/>
<p class="indent">Efficiency is a concern, though! Rebuilding the segment tree takes <em>O</em>(<em>n</em>) time. All it would take to tank our performance is a stream of <em>q</em> update operations, with no query operations at all. That would force <em>n</em> work to be done a total of <em>q</em> times, for <em>O</em>(<em>nq</em>) performance. That’s especially grim if you think about the cost of updates with no segment tree at all: they’re constant-time operations on an array! We can’t afford to trade constant time for linear time. However, we <em>can</em> afford to trade constant time for logarithmic time, because the latter is very close to constant time.</p>
<p class="indent">The way we escape the linear-time work is to realize that only a small number of segment tree nodes need to be updated when an element of the array is updated. Dismantling the entire tree for a single update is a gross overreaction.</p>
<p class="indent">Let me explain what I mean by example. Here again is <a href="ch08.xhtml#ch08fig020">Figure 8-20</a>:</p>
<div class="image"><img alt="Image" src="../images/unch08fig04.jpg"/></div>
<p class="indent">Now imagine the next operation is <span class="literal">U 4 1</span>, which means that index 4 of the sequence should be changed to value 1 (as the 15 that was there is gone). The new segment tree and array are shown in <a href="ch08.xhtml#ch08fig021">Figure 8-21</a>.</p>
<span epub:type="pagebreak" id="page_326"/>
<div class="image"><img alt="Image" id="ch08fig021" src="../images/ch08fig21.jpg"/></div>
<p class="figcap"><em>Figure 8-21: A segment tree and its corresponding array following an array update</em></p>
<p class="indent">Notice that only three nodes have changed. Node 4-4 has to change, of course, because the only element in its segment changed. However, the impact of that change can’t ripple too far: the only other nodes that can change are ancestors of 4-4, because those are the only other nodes that have an index of 4 in their segments! Indeed, in this example, you can confirm that the only other nodes that changed are the three ancestors 3-4, 1-4, and 1-7. At worst, then, we go from a leaf of the tree to the root, updating nodes along that path. Since the height of the tree is <em>O</em>(log <em>n</em>), this path has only <em>O</em>(log <em>n</em>) nodes.</p>
<p class="indent">As long as we don’t waste time on recursion through inoperative parts of the segment tree, we will end up with an <em>O</em>(log <em>n</em>) update procedure. <a href="ch08.xhtml#ch08ex021">Listing 8-21</a> gives the code.</p>
<pre>node_info update_segtree(segtree_node segtree[], int node,
                         int seq[], int index) {
  segtree_node left_node, right_node;
  node_info left_info, right_info;

<span class="ent">❶</span> if (segtree[node].left == segtree[node].right) {
     segtree[node].max_element = seq[index];
     return (node_info) {segtree[node].max_sum, segtree[node].max_element};
  }

  left_node = segtree[node * 2];
  right_node = segtree[node * 2 + 1];

<span class="ent">➋</span> if (index &lt;= left_node.right ) {
  <span class="ent">➌</span> left_info = update_segtree(segtree, node * 2, seq, index);
<span epub:type="pagebreak" id="page_327"/><span class="ent">➍</span> right_info = (node_info){right_node.max_sum, right_node.max_element};
 } else {
   right_info = update_segtree(segtree, node * 2 + 1, seq, index);
   left_info = (node_info){left_node.max_sum, left_node.max_element};
 }

 segtree[node].max_element = max(left_info.max_element,
                                 right_info.max_element);

 if (left_info.max_sum == -1 &amp;&amp; right_info.max_sum == -1)
   segtree[node].max_sum = left_info.max_element +
                           right_info.max_element;

 else if (left_info.max_sum == -1)
   segtree[node].max_sum = max(left_info.max_element +
                               right_info.max_element,
                               right_info.max_sum);

 else if (right_info.max_sum == -1)
   segtree[node].max_sum = max(left_info.max_element +
                               right_info.max_element,
                               left_info.max_sum);

  else
    segtree[node].max_sum = max(left_info.max_element +
                                right_info.max_element,
                                max(left_info.max_sum, right_info.max_sum));
 return (node_info) {segtree[node].max_sum, segtree[node].max_element};
}</pre>
<p class="excap" id="ch08ex021"><em>Listing 8-21: Updating the segment tree</em></p>
<p class="indent">This function is designed to be called <em>after</em> the array element at the given <span class="literal">index</span> has been updated. Every call of this function is required to ensure that <span class="literal">node</span> is the root of a segment tree whose segment contains <span class="literal">index</span>.</p>
<p class="indent">Our base case is when the segment contains just one element <span class="ent">❶</span>. Since we never make a recursive call unless <span class="literal">index</span> is in the node’s segment, we know this segment contains exactly our desired index. We thus update <span class="literal">max_element</span> of the node to whatever is now stored at <span class="literal">seq[index]</span>. We don’t update <span class="literal">max_sum</span>: it’s staying at <span class="literal">-1</span>, because this segment still has just one element in it.</p>
<p class="indent">Now suppose we’re not in the base case. We have a node, and we know that exactly one of its elements, <span class="literal">index</span>, has been updated. There’s absolutely no reason, then, to make <em>two</em> recursive calls, since only one of the node’s children can house the updated element. If <span class="literal">index</span> is in the left child, then we want to make a recursive call on the left child to update the left subtree. If <span class="literal">index</span> is in the right child, then we want to make a recursive call on the right child to update the right subtree.</p>
<span epub:type="pagebreak" id="page_328"/>
<p class="indent">To determine which child <span class="literal">index</span> is in, we compare it to the rightmost index of the left child. If <span class="literal">index</span> comes before the left child’s segment ends <span class="ent">➋</span>, then we need a recursive call on the left; otherwise, we need a recursive call on the right.</p>
<p class="indent">Let’s talk a little about the case where we make a recursive call on the left <span class="ent">➌</span>; the <span class="literal">else</span> branch, where we make a recursive call on the right, is similar. We make the recursive call that updates the left subtree and returns to us the information for that updated segment. For the right subtree, we just inherit what was there before <span class="ent">➍</span>—there’s no update occurring there, so nothing can change.</p>
<p class="indent">The rest of the code parallels that of <a href="ch08.xhtml#ch08ex019">Listing 8-19</a>.</p>
<h4 class="h4" id="sec136"><em>The main Function</em></h4>
<p class="noindent">We’re now ready to use our souped-up segment tree to solve the problem. The code for the <span class="literal">main</span> function is given in <a href="ch08.xhtml#ch08ex022">Listing 8-22</a>.</p>
<pre>#define MAX_SEQ 100000

int main(void) {
  static int seq[MAX_SEQ + 1];
  static segtree_node segtree[MAX_SEQ * 4 + 1];
  int num_seq, num_ops, i, op, x, y;
  char c;
  scanf("%d", &amp;num_seq);
  for (i = 1; i &lt;= num_seq; i++)
    scanf("%d", &amp;seq[i]);
  init_segtree(segtree, 1, 1, num_seq);
  fill_segtree(segtree, 1, seq);
  scanf("%d", &amp;num_ops);
  for (op = 0; op &lt; num_ops; op++) {
    scanf(" %c%d%d ", &amp;c, &amp;x, &amp;y);

 <span class="ent">❶</span> if (c == 'U') {
      seq[x] = y;
      update_segtree(segtree, 1, seq, x);

 <span class="ent">➋</span> } else {
     printf("%d\n", query_segtree(segtree, 1, seq, x, y).max_sum);
    }
  }
  return 0;
}</pre>
<p class="excap" id="ch08ex022"><em>Listing 8-22: The <span class="codeitalic1">main</span> function for reading input and solving the problem</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_329"/>The only thing to highlight here is the logic for processing the operations. If the next operation is an update operation <span class="ent">❶</span>, we respond by updating the array element and then updating the segment tree. Otherwise, the operation is a query operation <span class="ent">➋</span>, and we respond by querying the segment tree.</p>
<p class="indent">It is time to submit the code. The judge should enjoy this fast, segment-tree-based solution.</p>
<h3 class="h3" id="lev55">Summary</h3>
<p class="noindent">In this chapter, we studied how to implement and use heaps and segment trees. Like any useful data structure, these data structures support a small number of highly efficient operations. It’s not often that a data structure solves a problem on its own. More typically, you already have an algorithm whose speed is reasonable, and a data structure helps you make it even faster. For example, our implementation of Dijkstra’s algorithm in <a href="ch06.xhtml">Chapter 6</a> already does quite well, but add a min-heap and it does even better.</p>
<p class="indent">Whenever you’re performing the same kind of operation over and over, you should seek out an opportunity to bolster your algorithm with a data structure. Are you searching for specified items in an array? Then hash tables are called for. Are you trying to find the maximum or minimum? Then heaps will do the trick. Are you querying segments of an array? Then employ segment trees. What about deciding whether two elements are in the same set? Well now, you’ll have to read the next chapter for that one!</p>
<h3 class="h3" id="lev56">Notes</h3>
<p class="noindent">Supermarket Promotion is originally from the 2000 Polish Olympiad in Informatics, Stage 3. Building Treaps is originally from the 2004 Ulm University Local Contest. Two Sum is originally from the 2009 Kurukshetra Online Programming Contest.</p>
<p class="indent">For more about segment trees and many other data structures, I recommend Matt Fontaine’s <em>Algorithms Live!</em> series of videos (see <em><a href="http://algorithms-live.blogspot.com">http://algorithms-live.blogspot.com</a></em>). Matt’s segment tree video gave me the idea to explicitly store <span class="literal">left</span> and <span class="literal">right</span> segment indices in each node. (Most of the segment tree code you’ll see out there doesn’t do this, instead passing those indices around as additional function parameters that I always have trouble keeping straight.)<span epub:type="pagebreak" id="page_330"/></p>
</body></html>