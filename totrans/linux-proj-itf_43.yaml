- en: Chapter 43. Interprocess Communication Overview
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第43章。进程间通信概述
- en: This chapter presents a brief overview of the facilities that processes and
    threads can use to communicate with one another and to synchronize their actions.
    The following chapters provide more details about these facilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了进程和线程可以用来相互通信和同步其动作的设施。后续章节将提供关于这些设施的更多细节。
- en: A Taxonomy of IPC Facilities
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPC 设施的分类
- en: '[Figure 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities "Figure 43-1. A taxonomy
    of UNIX IPC facilities") summarizes the rich variety of UNIX communication and
    synchronization facilities, dividing them into three broad functional categories:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities "图 43-1. UNIX IPC 设施的分类")
    总结了 UNIX 通信和同步设施的丰富多样性，将它们分为三个广泛的功能类别：'
- en: '*Communication*: These facilities are concerned with exchanging data between
    processes.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通信*：这些设施用于进程间的数据交换。'
- en: '*Synchronization*: These facilities are concerned with synchronizing the actions
    of processes or threads.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步*：这些设施用于同步进程或线程的动作。'
- en: '*Signals*: Although signals are intended primarily for other purposes, they
    can be used as a synchronization technique in certain circumstances. More rarely,
    signals can be used as a communication technique: the signal number itself is
    a form of information, and realtime signals can be accompanied by associated data
    (an integer or a pointer). Signals are described in detail in [Chapter 20](ch20.html
    "Chapter 20. Signals: Fundamental Concepts") to [Chapter 22](ch22.html "Chapter 22. Signals:
    Advanced Features").'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信号*：尽管信号主要用于其他目的，但在某些情况下，它们可以作为同步技术使用。更少见的是，信号可以作为通信技术使用：信号编号本身就是一种信息形式，实时信号可以附带相关数据（整数或指针）。信号的详细描述见[第20章](ch20.html
    "第20章. 信号：基本概念")至[第22章](ch22.html "第22章. 信号：高级特性")。'
- en: Although some of these facilities are concerned with synchronization, the general
    term *interprocess communication* (IPC) is often used to describe them all.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其中一些设施涉及同步，但通常使用通用术语*进程间通信*（IPC）来描述所有这些设施。
- en: '![A taxonomy of UNIX IPC facilities](figs/web/43-1_IPC-taxonomy.png.jpg)Figure 43-1. A
    taxonomy of UNIX IPC facilities'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![UNIX IPC 设施的分类](figs/web/43-1_IPC-taxonomy.png.jpg)图 43-1. UNIX IPC 设施的分类'
- en: 'As [Figure 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities "Figure 43-1. A
    taxonomy of UNIX IPC facilities") illustrates, often several facilities provide
    similar IPC functionality. There are a couple of reasons for this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities "图 43-1. UNIX IPC 设施的分类")所示，通常多个设施提供类似的
    IPC 功能。出现这种情况有几个原因：
- en: Similar facilities evolved on different UNIX variants, and later came to be
    ported to other UNIX systems. For example, FIFOs were developed on System V, while
    (stream) sockets were developed on BSD.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相似的设施在不同的 UNIX 变种中发展起来，并随后被移植到其他 UNIX 系统中。例如，FIFO 最早在 System V 上开发，而（流）套接字则是在
    BSD 上开发的。
- en: New facilities have been developed to address design deficiencies in similar
    earlier facilities. For example, the POSIX IPC facilities (message queues, semaphores,
    and shared memory) were designed as an improvement on the older System V IPC facilities.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了解决早期相似设施的设计缺陷，开发了新的设施。例如，POSIX IPC 设施（消息队列、信号量和共享内存）作为对较老的 System V IPC 设施的改进而设计。
- en: In some cases, facilities that are grouped together in [Figure 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities
    "Figure 43-1. A taxonomy of UNIX IPC facilities") actually provide significantly
    different functionality. For example, stream sockets can be used to communicate
    over a network, while FIFOs can be used only for communication between processes
    on the same machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，[图 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities "图 43-1. UNIX IPC
    设施的分类")中归为一类的设施实际上提供了显著不同的功能。例如，流套接字可以用于通过网络进行通信，而 FIFO 仅用于在同一台机器上的进程之间进行通信。
- en: Communication Facilities
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信设施
- en: The various communication facilities shown in [Figure 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities
    "Figure 43-1. A taxonomy of UNIX IPC facilities") allow processes to exchange
    data with one another. (These facilities can also be used to exchange data between
    the threads of a single process, but this is seldom necessary, since threads can
    exchange information via shared global variables.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities "图 43-1. UNIX IPC 设施分类")所示，各种通信设施允许进程之间交换数据。（这些设施也可以用于单个进程的线程之间交换数据，但通常不需要，因为线程可以通过共享全局变量交换信息。）
- en: 'We can break the communication facilities into two categories:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将通信设施分为两类：
- en: '*Data-transfer facilities*: The key factor distinguishing these facilities
    is the notion of writing and reading. In order to communicate, one process writes
    data to the IPC facility, and another process reads the data. These facilities
    require two data transfers between user memory and kernel memory: one transfer
    from user memory to kernel memory during writing, and another transfer from kernel
    memory to user memory during reading. ([Figure 43-2](ch43.html#exchanging_data_between_two_processes_us
    "Figure 43-2. Exchanging data between two processes using a pipe") shows this
    situation for a pipe.)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据传输设施*：区分这些设施的关键因素是写入和读取的概念。为了进行通信，一个进程将数据写入 IPC 设施，另一个进程读取该数据。这些设施需要在用户内存和内核内存之间进行两次数据传输：一次是写入时从用户内存到内核内存的传输，另一次是读取时从内核内存到用户内存的传输。（[图
    43-2](ch43.html#exchanging_data_between_two_processes_us "图 43-2. 使用管道在两个进程之间交换数据")展示了管道的这种情况。）'
- en: '*Shared memory*: Shared memory allows processes to exchange information by
    placing it in a region of memory that is shared between the processes. (The kernel
    accomplishes this by making page-table entries in each process point to the same
    pages of RAM, as shown in [Figure 49-2](ch49.html#two_processes_with_a_shared_mapping_of_t
    "Figure 49-2. Two processes with a shared mapping of the same region of a file"),
    in [Memory-mapped I/O](ch49.html#memory-mapped_i_solidus_o "Memory-mapped I/O").)
    A process can make data available to other processes by placing it in the shared
    memory region. Because communication doesn’t require system calls or data transfer
    between user memory and kernel memory, shared memory can provide very fast communication.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享内存*：共享内存允许进程通过将数据放置在进程间共享的内存区域来交换信息。（内核通过使每个进程的页面表条目指向相同的 RAM 页面来实现这一点，如[图
    49-2](ch49.html#two_processes_with_a_shared_mapping_of_t "图 49-2. 两个进程共享同一文件区域的映射")所示，参见[内存映射
    I/O](ch49.html#memory-mapped_i_solidus_o "内存映射 I/O")）。进程可以通过将数据放入共享内存区域，使数据对其他进程可用。由于通信不需要系统调用或在用户内存和内核内存之间传输数据，因此共享内存可以提供非常快速的通信。'
- en: '![Exchanging data between two processes using a pipe](figs/web/43-2_IPC-pipe-scale90.png.jpg)Figure 43-2. Exchanging
    data between two processes using a pipe'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用管道在两个进程之间交换数据](figs/web/43-2_IPC-pipe-scale90.png.jpg)图 43-2. 使用管道在两个进程之间交换数据'
- en: Data transfer
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据传输
- en: 'We can further break data-transfer facilities into the following subcategories:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步将数据传输设施分为以下子类别：
- en: '*Byte stream*: The data exchanged via pipes, FIFOs, and datagram sockets is
    an undelimited byte stream. Each read operation may read an arbitrary number of
    bytes from the IPC facility, regardless of the size of blocks written by the writer.
    This model mirrors the traditional UNIX “file as a sequence of bytes” model.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字节流*：通过管道、FIFO 和数据报套接字交换的数据是一个未定界的字节流。每次读取操作可以从 IPC 设施读取任意数量的字节，而不管写入进程写入的块大小。这种模型反映了传统
    UNIX 中“文件作为字节序列”的模型。'
- en: '*Message*: The data exchanged via System V message queues, POSIX message queues,
    and datagram sockets takes the form of delimited messages. Each read operation
    reads a whole message, as written by the writer process. It is not possible to
    read part of a message, leaving the remainder on the IPC facility; nor is it possible
    to read multiple messages in a single read operation.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息*：通过 System V 消息队列、POSIX 消息队列和数据报套接字交换的数据以定界消息的形式存在。每个读取操作读取一个完整的消息，正如写入进程所写。无法读取消息的一部分并将剩余部分留在
    IPC 设施中；也不能在一次读取操作中读取多个消息。'
- en: '*Pseudoterminals*: A pseudoterminal is a communication facility intended for
    use in specialized situations. We provide details in [Chapter 64](ch64.html "Chapter 64. Pseudoterminals").'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*伪终端*：伪终端是一种通信设施，主要用于特殊情况。我们在[第 64 章](ch64.html "第 64 章. 伪终端")中提供了详细信息。'
- en: 'A few general features distinguish data-transfer facilities from shared memory:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 几个通用特性将数据传输设施与共享内存区分开：
- en: Although a data-transfer facility may have multiple readers, reads are destructive.
    A read operation consumes data, and that data is not available to any other process.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管数据传输设施可能有多个读取器，但读取是破坏性的。读取操作会消耗数据，而该数据不再对其他进程可用。
- en: Note
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `MSG_PEEK` flag can be used to perform a nondestructive read from a socket
    ([Socket-Specific I/O System Calls: *recv()* and *send()*](ch61.html#socket-specific_i_solidus_o_system_calls
    "Socket-Specific I/O System Calls: recv() and send()")). UDP (Internet domain
    datagram) sockets allow a single message to be broadcast or multicast to multiple
    recipients ([TCP Versus UDP](ch61.html#tcp_versus_udp "TCP Versus UDP")).'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MSG_PEEK`标志可用于执行非破坏性读取操作（[特定于套接字的I/O系统调用：*recv()*和*send()*](ch61.html#socket-specific_i_solidus_o_system_calls
    "特定于套接字的I/O系统调用：recv()和send()")）。UDP（互联网域数据报）套接字允许将单个消息广播或多播到多个接收方（[TCP与UDP](ch61.html#tcp_versus_udp
    "TCP与UDP")）。'
- en: Synchronization between the reader and writer processes is automatic. If a reader
    attempts to fetch data from a data-transfer facility that currently has no data,
    then (by default) the read operation will block until some process writes data
    to the facility.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者和写者进程之间的同步是自动进行的。如果读者试图从当前没有数据的数据传输设施中读取数据，则（默认情况下）读取操作会阻塞，直到某个进程向该设施写入数据。
- en: Shared memory
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享内存
- en: 'Most modern UNIX systems provide three flavors of shared memory: System V shared
    memory, POSIX shared memory, and memory mappings. We consider the differences
    between them when describing the facilities in later chapters (see [Comparisons
    Between Shared Memory APIs](ch54.html#comparisons_between_shared_memory_apis "Comparisons
    Between Shared Memory APIs") in particular).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代UNIX系统提供三种共享内存形式：System V共享内存、POSIX共享内存和内存映射。在后续章节中，我们会在描述这些设施时考虑它们之间的差异（特别请参见[共享内存API的比较](ch54.html#comparisons_between_shared_memory_apis
    "共享内存API的比较")）。
- en: 'Note the following general points about shared memory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意关于共享内存的以下几点：
- en: Although shared memory provides fast communication, this speed advantage is
    offset by the need to synchronize operations on the shared memory. For example,
    one process should not attempt to access a data structure in the shared memory
    while another process is updating it. A semaphore is the usual synchronization
    method used with shared memory.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管共享内存提供了快速通信，但这种速度优势受到同步共享内存操作需求的制约。例如，当一个进程正在更新共享内存中的数据结构时，另一个进程不应尝试访问它。信号量是与共享内存一起使用的常见同步方法。
- en: Data placed in shared memory is visible to all of the processes that share that
    memory. (This contrasts with the destructive read semantics described above for
    data-transfer facilities.)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置在共享内存中的数据对所有共享该内存的进程可见。（这与上文所述的数据传输设施中的破坏性读取语义相对。）
- en: Synchronization Facilities
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步设施
- en: The synchronization facilities shown in [Figure 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities
    "Figure 43-1. A taxonomy of UNIX IPC facilities") allow processes to coordinate
    their actions. Synchronization allows processes to avoid doing things such as
    simultaneously updating a shared memory region or the same part of a file. Without
    synchronization, such simultaneous updates could cause an application to produce
    incorrect results.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities "图43-1. UNIX IPC设施分类")中所示的同步设施允许进程协调它们的操作。同步使得进程能够避免同时更新共享内存区域或文件的相同部分。如果没有同步，这种同时更新可能会导致应用程序产生错误的结果。
- en: 'UNIX systems provide the following synchronization facilities:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX系统提供以下同步设施：
- en: '*Semaphores*: A semaphore is a kernel-maintained integer whose value is never
    permitted to fall below 0\. A process can decrease or increase the value of a
    semaphore. If an attempt is made to decrease the value of the semaphore below
    0, then the kernel blocks the operation until the semaphore’s value increases
    to a level that permits the operation to be performed. (Alternatively, the process
    can request a nonblocking operation; then, instead of blocking, the kernel causes
    the operation to return immediately with an error indicating that the operation
    can’t be performed immediately.) The meaning of a semaphore is determined by the
    application. A process decrements a semaphore (from, say, 1 to 0) in order to
    reserve exclusive access to some shared resource, and after completing work on
    the resource, increments the semaphore so that the shared resource is released
    for use by some other process. The use of a binary semaphore—a semaphore whose
    value is limited to 0 or 1—is common. However, an application that deals with
    multiple instances of a shared resource would employ a semaphore whose maximum
    value equals the number of shared resources. Linux provides both System V semaphores
    and POSIX semaphores, which have essentially similar functionality.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信号量*：信号量是由内核维护的整数，其值永远不能低于 0。进程可以减少或增加信号量的值。如果尝试将信号量的值减少到 0 以下，内核会阻塞该操作，直到信号量的值增加到允许操作执行的水平。（或者，进程可以请求一个非阻塞操作；此时，内核会立即返回错误，表示该操作无法立即执行。）信号量的含义由应用程序决定。进程通过递减信号量（比如从
    1 变为 0）来预定对某个共享资源的独占访问，完成对资源的操作后，再增加信号量，以便释放该共享资源供其他进程使用。二进制信号量——其值限制为 0 或 1——的使用非常普遍。然而，处理多个实例的共享资源的应用程序会使用一个最大值等于共享资源数量的信号量。Linux
    提供了 System V 信号量和 POSIX 信号量，它们在功能上基本相同。'
- en: '*File locks*: File locks are a synchronization method explicitly designed to
    coordinate the actions of multiple processes operating on the same file. They
    can also be used to coordinate access to other shared resources. File locks come
    in two flavors: read (shared) locks and write (exclusive) locks. Any number of
    processes can hold a read lock on the same file (or region of a file). However,
    when one process holds a write lock on a file (or file region), other processes
    are prevented from holding either read or write locks on that file (or file region).
    Linux provides file-locking facilities via the *flock()* and *fcntl()* system
    calls. The *flock()* system call provides a simple locking mechanism, allowing
    processes to place a shared or an exclusive lock on an entire file. Because of
    its limited functionality, *flock()* locking facility is rarely used nowadays.
    The *fcntl()* system call provides record locking, allowing processes to place
    multiple read and write locks on different regions of the same file.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件锁*：文件锁是一种专门设计用来协调多个进程在同一文件上操作的同步方法。它们也可以用于协调对其他共享资源的访问。文件锁有两种类型：读锁（共享锁）和写锁（独占锁）。任何数量的进程都可以对同一文件（或文件的某一部分）持有读锁。然而，当一个进程持有文件（或文件区域）的写锁时，其他进程将无法在该文件（或文件区域）上持有任何读锁或写锁。Linux
    通过 *flock()* 和 *fcntl()* 系统调用提供文件锁定功能。*flock()* 系统调用提供了一种简单的锁机制，允许进程对整个文件进行共享或独占锁定。由于其功能有限，*flock()*
    锁定机制如今很少使用。*fcntl()* 系统调用提供了记录锁定，允许进程在同一文件的不同区域上放置多个读锁和写锁。'
- en: '*Mutexes and condition variables*: These synchronization facilities are normally
    used with POSIX threads, as described in [Chapter 30](ch30.html "Chapter 30. Threads:
    Thread Synchronization").'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*互斥量和条件变量*：这些同步设施通常与 POSIX 线程一起使用，如[第 30 章](ch30.html "第 30 章. 线程：线程同步")中所述。'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some UNIX implementations, including Linux systems with a *glibc* that provides
    the NPTL threading implementation, also allow mutexes and condition variables
    to be shared between processes. SUSv3 permits, but doesn’t require, an implementation
    to support process-shared mutexes and condition variables. They are not available
    on all UNIX systems, and so are not commonly employed for process synchronization.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 UNIX 实现，包括提供 NPTL 线程实现的 Linux 系统，允许互斥量和条件变量在进程之间共享。SUSv3 允许但不强制要求实现支持进程共享的互斥量和条件变量。它们并非在所有
    UNIX 系统上都可用，因此不常用于进程同步。
- en: When performing interprocess synchronization, our choice of facility is typically
    determined by the functional requirements. When coordinating access to a file,
    file record locking is usually the best choice. Semaphores are often the better
    choice for coordinating access to other types of shared resource.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行进程间同步时，我们通常根据功能需求来选择设施。在协调对文件的访问时，文件记录锁定通常是最佳选择。而对于协调访问其他类型共享资源，信号量通常是更好的选择。
- en: Communication facilities can also be used for synchronization. For example,
    in [Pipes as a Method of Process Synchronization](ch44.html#pipes_as_a_method_of_process_synchroniza
    "Pipes as a Method of Process Synchronization"), we show how a pipe can be used
    to synchronize the actions of a parent process with its children. More generally,
    any of the data-transfer facilities can be used for synchronization, with the
    synchronization operation taking the form of exchanging messages via the facility.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通信设施也可以用于同步。例如，在[管道作为进程同步方法](ch44.html#pipes_as_a_method_of_process_synchroniza
    "管道作为进程同步方法")中，我们展示了如何使用管道同步父进程与其子进程的操作。更一般而言，任何数据传输设施都可以用于同步，同步操作以通过该设施交换消息的形式进行。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Since kernel 2.6.22, Linux provides an additional, nonstandard synchronization
    mechanism via the *eventfd()* system call. This system call creates an *eventfd*
    object that has an associated 8-byte unsigned integer maintained by the kernel.
    The system call returns a file descriptor that refers to the object. Writing an
    integer to this file descriptor adds that integer to the object’s value. A *read()*
    from the file descriptor blocks if the object’s value is 0\. If the object has
    a nonzero value, a *read()* returns that value and resets it to 0\. In addition,
    *poll()*, *select()*, or *epoll* can be used to test if the object has a nonzero
    value; if it does, the file descriptor indicates as being readable. An application
    that wishes to use an *eventfd* object for synchronization must first create the
    object using *eventfd()*, and then call *fork()* to create related processes that
    inherit file descriptors referring to the object. For further details, see the
    *eventfd(2)* manual page.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Linux 内核 2.6.22 版本起，Linux 提供了一种额外的、非标准的同步机制，通过 *eventfd()* 系统调用实现。该系统调用创建了一个
    *eventfd* 对象，内核维护着一个与之关联的 8 字节无符号整数。系统调用返回一个文件描述符，指向该对象。向该文件描述符写入整数会将该整数添加到对象的值中。若对文件描述符进行
    *read()* 操作且对象的值为 0，则该操作会阻塞。如果对象的值非零，*read()* 操作会返回该值并将其重置为 0。此外，可以使用 *poll()*、*select()*
    或 *epoll* 来测试对象是否有非零值；如果有，文件描述符将被标记为可读。希望使用 *eventfd* 对象进行同步的应用程序，必须首先使用 *eventfd()*
    创建该对象，然后调用 *fork()* 来创建相关的进程，这些进程会继承指向该对象的文件描述符。有关更多详细信息，请参见 *eventfd(2)* 手册页。
- en: Comparing IPC Facilities
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较 IPC 设施
- en: When it comes to IPC, we face a range of choices that can at first seem bewildering.
    In later chapters that describe each IPC facility, we include sections that compare
    each facility against other similar facilities. In the following pages, we consider
    a number of general points that may determine the choice of IPC facility.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 IPC 时，我们会面临一系列的选择，初看起来可能让人感到困惑。在后续章节中，我们将描述每种 IPC 设施，并对每种设施与其他类似设施进行比较。在接下来的页面中，我们会考虑一些可能决定选择哪种
    IPC 设施的通用因素。
- en: IPC object identification and handles for open objects
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPC 对象标识符与打开对象的句柄
- en: In order to access an IPC object, a process must have some means of identifying
    the object, and once the object has been “opened,” the process must use some type
    of handle to refer to the open object. [Table 43-1](ch43.html#identifiers_and_handles_for_various_type
    "Table 43-1. Identifiers and handles for various types of IPC facilities") summarizes
    these properties for the various types of IPC facilities.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问 IPC 对象，进程必须具备某种标识对象的方式，并且一旦对象被“打开”，进程必须使用某种类型的句柄来引用已打开的对象。[表 43-1](ch43.html#identifiers_and_handles_for_various_type
    "表 43-1. 各种类型 IPC 设施的标识符和句柄") 总结了不同类型 IPC 设施的这些属性。
- en: Table 43-1. Identifiers and handles for various types of IPC facilities
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表 43-1. 各种类型 IPC 设施的标识符和句柄
- en: '| Facility type | Name used to identify object | Handle used to refer to object
    in programs |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 设施类型 | 用于标识对象的名称 | 用于在程序中引用对象的句柄 |'
- en: '| --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Pipe | no name | file descriptor |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 管道 | 无名称 | 文件描述符 |'
- en: '| FIFO | pathname | file descriptor |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| FIFO | 路径名 | 文件描述符 |'
- en: '| UNIX domain socket | pathname | file descriptor |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| UNIX 域套接字 | 路径名 | 文件描述符 |'
- en: '| Internet domain socket | IP address + port number | file descriptor |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 网络域套接字 | IP 地址 + 端口号 | 文件描述符 |'
- en: '| System V message queue | System V IPC key | System V IPC identifier |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| System V 消息队列 | System V IPC 键值 | System V IPC 标识符 |'
- en: '| System V semaphore | System V IPC key | System V IPC identifier |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| System V 信号量 | System V IPC 键值 | System V IPC 标识符 |'
- en: '| System V shared memory | System V IPC key | System V IPC identifier |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| System V 共享内存 | System V IPC 键值 | System V IPC 标识符 |'
- en: '| POSIX message queue | POSIX IPC pathname | *mqd_t* (message queue descriptor)
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 消息队列 | POSIX IPC 文件路径名 | *mqd_t*（消息队列描述符） |'
- en: '| POSIX named semaphore | POSIX IPC pathname | *sem_t ** (semaphore pointer)
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 命名信号量 | POSIX IPC 文件路径名 | *sem_t **（信号量指针） |'
- en: '| POSIX unnamed semaphore | no name | *sem_t ** (semaphore pointer) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 无名信号量 | 无名称 | *sem_t **（信号量指针） |'
- en: '| POSIX shared memory | POSIX IPC pathname | file descriptor |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 共享内存 | POSIX IPC 文件路径名 | 文件描述符 |'
- en: '| Anonymous mapping | no name | none |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 匿名映射 | 无名称 | 无 |'
- en: '| Memory-mapped file | pathname | file descriptor |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 内存映射文件 | 文件路径名 | 文件描述符 |'
- en: '| *flock()* lock | pathname | file descriptor |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| *flock()* 锁 | 文件路径名 | 文件描述符 |'
- en: '| *fcntl()* lock | pathname | file descriptor |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| *fcntl()* 锁 | 文件路径名 | 文件描述符 |'
- en: Functionality
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 功能性
- en: 'There are functional differences between the various IPC facilities that can
    be relevant in determining which facility to use. We begin by summarizing the
    differences between data-transfer facilities and shared memory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 各种 IPC 设施之间存在功能差异，这些差异在决定使用哪个设施时可能是相关的。我们首先总结一下数据传输设施和共享内存之间的区别：
- en: Data-transfer facilities involve read and write operations, with transferred
    data being consumable by just one reader process. Flow control between writer
    and reader, as well as synchronization (so that a reader is blocked when trying
    to read data from a facility that is currently empty) is automatically handled
    by the kernel. This model fits well with many application designs.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输设施涉及读写操作，传输的数据只能被一个读取进程消费。写入进程与读取进程之间的流控制，以及同步操作（确保在数据设施为空时，读取进程会被阻塞），由内核自动处理。该模型非常适合许多应用程序设计。
- en: Other application designs more naturally suit a shared-memory model. Shared
    memory allows one process to make data visible to any number of other processes
    sharing the same memory region. Communication “operations” are simple—a process
    can access data in shared memory in the same manner as it accesses any other memory
    in its virtual address space. On the other hand, the need to handle synchronization
    (and perhaps flow control) can add to the complexity of a shared-memory design.
    This model fits well with application designs that need to maintain shared state
    (e.g., a shared data structure).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他应用程序设计更自然地适应共享内存模型。共享内存允许一个进程将数据对任何共享同一内存区域的其他进程可见。通信“操作”非常简单——进程可以像访问其虚拟地址空间中的任何其他内存一样访问共享内存中的数据。另一方面，处理同步（以及可能的流控制）可能会增加共享内存设计的复杂性。该模型非常适合需要维持共享状态的应用程序设计（例如，共享数据结构）。
- en: 'With respect to the various data-transfer facilities, the following points
    are worth noting:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于各种数据传输设施，以下几点值得注意：
- en: Some data-transfer facilities transfer data as a byte stream (pipes, FIFOs,
    and stream sockets); others are message-oriented (message queues and datagram
    sockets). Which approach is preferable depends on the application. (An application
    can also impose a message-oriented model on a byte-stream facility, by using delimiter
    characters, fixed-length messages, or message headers that encode the length of
    the total message; see Section 44.8.)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些数据传输设施将数据作为字节流传输（管道、FIFO 和流套接字）；而其他设施则是面向消息的（消息队列和数据报套接字）。哪种方法更可取取决于具体应用。（应用程序还可以通过使用分隔符字符、固定长度的消息或编码了消息总长度的消息头，将字节流设施转换为面向消息的模型；详见第44.8节。）
- en: A distinctive feature of System V and POSIX message queues, compared with other
    data-transfer facilities, is the ability to assign a numeric type or priority
    to a message, so that messages can be delivered in a different order from that
    in which they were sent.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他数据传输设施相比，System V 和 POSIX 消息队列的一个显著特点是能够为消息分配一个数值类型或优先级，使得消息可以按照与发送顺序不同的顺序进行传递。
- en: 'Pipes, FIFOs, and sockets are implemented using file descriptors. These IPC
    facilities all support a range of alternative I/O models that we describe in [Chapter 63](ch63.html
    "Chapter 63. Alternative I/O Models"): I/O multiplexing (the *select()* and *poll()*
    system calls), signal-driven I/O, and the Linux-specific *epoll* API. The primary
    benefit of these techniques is that they allow an application to simultaneously
    monitor multiple file descriptors to see whether I/O is possible on any of them.
    By contrast, System V message queues don’t employ file descriptors and don’t support
    these techniques.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道、FIFO 和套接字是通过文件描述符实现的。这些 IPC 设施都支持一系列替代 I/O 模型，我们在[第 63 章](ch63.html "第 63
    章. 替代 I/O 模型")中描述了这些模型：I/O 多路复用（*select()* 和 *poll()* 系统调用）、信号驱动 I/O，以及 Linux
    特有的 *epoll* API。这些技术的主要优点是，它们允许应用程序同时监控多个文件描述符，以查看是否可以在任何一个上进行 I/O 操作。相比之下，System
    V 消息队列不使用文件描述符，也不支持这些技术。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, POSIX message queues are also implemented using file descriptors and
    support the alternative I/O techniques described above. However, this behavior
    is not specified in SUSv3, and is not supported on most other implementations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，POSIX 消息队列也是通过文件描述符实现的，并支持上述的替代 I/O 技术。然而，这种行为在 SUSv3 中并未指定，并且在大多数其他实现中不受支持。
- en: POSIX message queues provide a notification facility that can send a signal
    to a process, or instantiate a new thread, when a message arrives on a previously
    empty queue.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 消息队列提供了一种通知功能，当一个消息到达一个先前为空的队列时，可以向进程发送信号或实例化一个新的线程。
- en: UNIX domain sockets provide a feature that allows a file descriptor to be passed
    from one process to another. This allows one process to open a file and make it
    available to another process that otherwise might not be able to access the file.
    We briefly describe this feature in [Passing File Descriptors](ch61.html#passing_file_descriptors
    "Passing File Descriptors").
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNIX 域套接字提供了一种功能，允许将文件描述符从一个进程传递到另一个进程。这允许一个进程打开一个文件，并将其提供给另一个可能无法访问该文件的进程。我们在[传递文件描述符](ch61.html#passing_file_descriptors
    "传递文件描述符")中简要描述了这个功能。
- en: UDP (Internet domain datagram) sockets allow a sender to broadcast or multicast
    a message to multiple recipients. We briefly describe this feature in [TCP Versus
    UDP](ch61.html#tcp_versus_udp "TCP Versus UDP").
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP（互联网域数据报）套接字允许发送方将消息广播或多播到多个接收者。我们在[TCP 与 UDP](ch61.html#tcp_versus_udp "TCP
    与 UDP")中简要描述了这个功能。
- en: 'With respect to process-synchronization facilities, the following points are
    worth noting:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于进程同步设施，以下几点值得注意：
- en: Record locks placed using *fcntl()* are considered to be owned by the process
    placing the lock. The kernel uses this ownership property to detect deadlocks
    (situations where two or more processes are holding locks that block each other’s
    further lock requests). If a deadlock situation occurs, the kernel denies the
    lock request of one of the processes, returning an error from the *fcntl()* call
    to indicate that a deadlock occurred. System V and POSIX semaphores don’t have
    an ownership property; no deadlock detection occurs for semaphores.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *fcntl()* 设置的记录锁被认为是由设置锁的进程拥有的。内核利用这一所有权属性来检测死锁（即两个或多个进程持有相互阻塞的锁，导致无法继续请求锁的情况）。如果发生死锁，内核会拒绝其中一个进程的锁请求，并从
    *fcntl()* 调用返回错误，表明发生了死锁。System V 和 POSIX 信号量没有所有权属性，因此不会对信号量进行死锁检测。
- en: Record locks placed using *fcntl()* are automatically released when the process
    that owns the locks terminates. System V semaphores provide a similar feature
    in the form of an “undo” feature, but this feature is not reliable in all circumstances
    ([Semaphore Undo Values](ch47.html#semaphore_undo_values "Semaphore Undo Values")).
    POSIX semaphores don’t provide an analog of this feature.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *fcntl()* 设置的记录锁在拥有锁的进程终止时会自动释放。System V 信号量提供了类似的功能，即“撤销”功能，但在某些情况下此功能并不可靠（[信号量撤销值](ch47.html#semaphore_undo_values
    "信号量撤销值")）。POSIX 信号量没有类似的功能。
- en: Network communication
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络通信
- en: 'Of all of the IPC methods shown in [Figure 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities
    "Figure 43-1. A taxonomy of UNIX IPC facilities"), only sockets permit processes
    to communicate over a network. Sockets are generally used in one of two domains:
    the UNIX domain, which allows communication between processes on the same system,
    and the *Internet* domain, which allows communication between processes on different
    hosts connected via a TCP/IP network. Often, only minor changes are required to
    convert a program that uses UNIX domain sockets into one that uses Internet domain
    sockets, so an application that is built using UNIX domain sockets can be made
    network-capable with relatively little effort.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities "图 43-1. UNIX IPC 设施的分类")中显示的所有
    IPC 方法中，只有套接字允许进程通过网络进行通信。套接字通常用于两个领域之一：UNIX 域，它允许同一系统中的进程之间进行通信；和*Internet* 域，它允许通过
    TCP/IP 网络连接的不同主机上的进程之间进行通信。通常，只需要进行少量修改，就可以将使用 UNIX 域套接字的程序转换为使用 Internet 域套接字的程序，因此，使用
    UNIX 域套接字构建的应用程序可以相对轻松地变为支持网络的应用程序。
- en: Portability
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可移植性
- en: Modern UNIX implementations support most of the IPC facilities shown in [Figure 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities
    "Figure 43-1. A taxonomy of UNIX IPC facilities"). However, the POSIX IPC facilities
    (message queues, semaphores, and shared memory) are not quite as widely available
    as their System V IPC counterparts, especially on older UNIX systems. (An implementation
    of POSIX message queues and full support for POSIX semaphores have appeared on
    Linux only in the 2.6.*x* kernel series.) Therefore, from a portability point
    of view, System V IPC may be preferable to POSIX IPC.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 UNIX 实现支持[图 43-1](ch43.html#a_taxonomy_of_unix_ipc_facilities "图 43-1. UNIX
    IPC 设施的分类")中显示的大多数 IPC 设施。然而，POSIX IPC 设施（消息队列、信号量和共享内存）并不像 System V IPC 设施那样广泛可用，特别是在较旧的
    UNIX 系统上。（POSIX 消息队列的实现和对 POSIX 信号量的完全支持仅在 Linux 2.6.*x* 内核系列中出现。）因此，从可移植性的角度来看，System
    V IPC 可能比 POSIX IPC 更可取。
- en: System V IPC design issues
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: System V IPC 设计问题
- en: 'The System V IPC facilities were designed independently of the traditional
    UNIX I/O model, and consequently suffer a few peculiarities that make their programming
    interfaces more complicated to use. The corresponding POSIX IPC facilities were
    designed to address these problems. The following points are of particular note:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: System V IPC 设施是在传统 UNIX I/O 模型之外独立设计的，因此存在一些特性，使得其编程接口使用起来更加复杂。相应的 POSIX IPC
    设施旨在解决这些问题。以下几点尤其值得注意：
- en: The System V IPC facilities are connectionless. These facilities provide no
    notion of a handle (like a file descriptor) referring to an open IPC object. In
    later chapters, we’ll sometimes talk of “opening” a System V IPC object, but this
    is really just shorthand to describe the process of obtaining a handle to refer
    to the object. The kernel does not record the process as having “opened” the object
    (unlike other types of IPC objects). This means that the kernel can’t maintain
    a reference count of the number of processes that are currently using an object.
    Consequently, it can require additional programming effort for an application
    to be able to know when an object can safely be deleted.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: System V IPC 设施是无连接的。这些设施没有类似于文件描述符的句柄（如文件描述符）来引用一个打开的 IPC 对象。在后面的章节中，我们有时会提到“打开”一个
    System V IPC 对象，但这实际上只是描述获取一个句柄来引用该对象的简写。内核并不会记录进程“打开”了该对象（与其他类型的 IPC 对象不同）。这意味着内核无法维护当前正在使用该对象的进程数的引用计数。因此，应用程序可能需要额外的编程工作，才能知道何时可以安全地删除该对象。
- en: The programming interfaces for the System V IPC facilities are inconsistent
    with the traditional UNIX I/O model (they use integer key values and IPC identifiers
    instead of pathnames and file descriptors). The programming interfaces are also
    overly complex. This last point applies particularly to System V semaphores (refer
    to [Disadvantages of System V Semaphores](ch47.html#disadvantages_of_system_v_semaphores
    "Disadvantages of System V Semaphores") and [Comparisons with Other Synchronization
    Techniques](ch53.html#comparisons_with_other_synchronization_t "Comparisons with
    Other Synchronization Techniques")).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: System V IPC 设施的编程接口与传统的 UNIX I/O 模型不一致（它们使用整数键值和 IPC 标识符，而不是路径名和文件描述符）。这些编程接口也过于复杂。最后一点特别适用于
    System V 信号量（参考[System V 信号量的缺点](ch47.html#disadvantages_of_system_v_semaphores
    "System V 信号量的缺点")和[与其他同步技术的比较](ch53.html#comparisons_with_other_synchronization_t
    "与其他同步技术的比较")）。
- en: By contrast, the kernel counts open references for POSIX IPC objects. This simplifies
    decisions about when an object can be deleted. Furthermore, the POSIX IPC facilities
    provide an interface that is simpler and more consistent with the traditional
    UNIX model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，内核会计算 POSIX IPC 对象的打开引用计数。这简化了何时可以删除对象的决策。此外，POSIX IPC 设施提供的接口更简单，并且与传统的
    UNIX 模型更加一致。
- en: Accessibility
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可访问性
- en: 'The second column of [Table 43-2](ch43.html#accessibility_and_persistence_for_variou
    "Table 43-2. Accessibility and persistence for various types of IPC facilities")
    summarizes an important characteristic of each type of IPC object: the permissions
    scheme that governs which processes can access the object. The following list
    adds some details on the various schemes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 43-2](ch43.html#accessibility_and_persistence_for_variou "表 43-2. 各种类型的
    IPC 设施的可访问性和持久性")的第二列总结了每种类型的 IPC 对象的一个重要特性：权限方案，规定了哪些进程可以访问该对象。以下列表增加了关于各种方案的细节：'
- en: For some IPC facilities (e.g., FIFOs and sockets), object names live in the
    file system, and accessibility is determined according to the associated file
    permissions mask, which specifies permissions for owner, group, and other ([File
    Permissions](ch15.html#file_permissions "File Permissions")). Although System
    V IPC objects don’t reside in the file system, each object has an associated permissions
    mask whose semantics are similar to those for files.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一些 IPC 设施（例如 FIFO 和套接字），对象名称存储在文件系统中，且可访问性由关联的文件权限掩码决定，该掩码指定所有者、组和其他的权限（[文件权限](ch15.html#file_permissions
    "文件权限")）。尽管 System V IPC 对象不驻留在文件系统中，但每个对象都有一个相关的权限掩码，其语义与文件的权限掩码类似。
- en: A few IPC facilities (pipes, anonymous memory mappings) are marked as being
    accessible only by related processes. Here, *related* means related via *fork()*.
    In order for two processes to access the object, one of them must create the object
    and then call *fork()*. As a consequence of the *fork()*, the child process inherits
    a handle referring to the object, allowing both processes to share the object.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 IPC 设施（管道、匿名内存映射）被标记为仅由相关进程访问。这里的 *相关* 指通过 *fork()* 相关。为了让两个进程访问该对象，其中一个必须创建该对象并调用
    *fork()*。作为 *fork()* 的结果，子进程会继承一个引用该对象的句柄，从而使两个进程可以共享该对象。
- en: The accessibility of a POSIX unnamed semaphore is determined by the accessibility
    of the shared memory region containing the semaphore.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 无名信号量的可访问性由包含信号量的共享内存区域的可访问性决定。
- en: In order to place a lock on a file, a process must have a file descriptor referring
    to the file (i.e., in practice, it must have permission to open the file).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了对文件加锁，进程必须拥有指向该文件的文件描述符（即实际上，它必须具有打开文件的权限）。
- en: There are no restrictions on accessing (i.e., connecting or sending a datagram
    to) an Internet domain socket. If necessary, access control must be implemented
    within the application.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问（即连接或发送数据报到）网络域套接字没有任何限制。如有必要，访问控制必须在应用程序内部实现。
- en: Table 43-2. Accessibility and persistence for various types of IPC facilities
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 43-2. 各种类型的 IPC 设施的可访问性和持久性
- en: '| Facility type | Accessibility | Persistence |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 设施类型 | 可访问性 | 持久性 |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Pipe | only by related processes | process |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 管道 | 仅由相关进程访问 | 进程 |'
- en: '| FIFO | permissions mask | process |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| FIFO | 权限掩码 | 进程 |'
- en: '| UNIX domain socket | permissions mask | process |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| UNIX 域套接字 | 权限掩码 | 进程 |'
- en: '| Internet domain socket | by any process | process |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 网络域套接字 | 由任何进程访问 | 进程 |'
- en: '| System V message queue | permissions mask | kernel |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| System V 消息队列 | 权限掩码 | 内核 |'
- en: '| System V semaphore | permissions mask | kernel |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| System V 信号量 | 权限掩码 | 内核 |'
- en: '| System V shared memory | permissions mask | kernel |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| System V 共享内存 | 权限掩码 | 内核 |'
- en: '| POSIX message queue | permissions mask | kernel |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 消息队列 | 权限掩码 | 内核 |'
- en: '| POSIX named semaphore | permissions mask | kernel |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 命名信号量 | 权限掩码 | 内核 |'
- en: '| POSIX unnamed semaphore | permissions of underlying memory | depends |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 无名信号量 | 底层内存的权限 | 视情况而定 |'
- en: '| POSIX shared memory | permissions mask | kernel |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| POSIX 共享内存 | 权限掩码 | 内核 |'
- en: '| Anonymous mapping | only by related processes | process |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 匿名映射 | 仅由相关进程访问 | 进程 |'
- en: '| Memory-mapped file | permissions mask | file system |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 内存映射文件 | 权限掩码 | 文件系统 |'
- en: '| *flock()* file lock | *open()* of file | process |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| *flock()* 文件锁 | *open()* 打开文件 | 进程 |'
- en: '| *fcntl()* file lock | *open()* of file | process |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| *fcntl()* 文件锁 | *open()* 打开文件 | 进程 |'
- en: Persistence
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 持久性
- en: 'The term *persistence* refers to the lifetime of an IPC object. (Refer to the
    third column of [Table 43-2](ch43.html#accessibility_and_persistence_for_variou
    "Table 43-2. Accessibility and persistence for various types of IPC facilities").)
    We can distinguish three types of persistence:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*持久性*一词指的是IPC对象的生命周期。（请参见[表43-2](ch43.html#accessibility_and_persistence_for_variou
    "表43-2. 各种IPC设施的可访问性和持久性")的第三列。）我们可以区分三种持久性：'
- en: '*Process persistence*: A process-persistent IPC object remains in existence
    only as long as it is held open by at least one process. If the object is closed
    by all processes, then all kernel resources associated with the object are freed,
    and any unread data is destroyed. Pipes, FIFOs, and sockets are examples of IPC
    facilities with process persistence.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进程持久性*：进程持久的IPC对象仅在至少一个进程保持它打开时存在。如果所有进程都关闭该对象，那么与该对象相关的所有内核资源都会被释放，任何未读的数据也会被销毁。管道、FIFO和套接字是具有进程持久性的IPC设施的例子。'
- en: Note
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The persistence of a FIFO’s data is not the same as the persistence of its name.
    A FIFO has a name in the file system that persists even after all file descriptors
    referring to the FIFO have been closed.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FIFO的数据持久性与其名称的持久性不同。FIFO在文件系统中有一个名称，即使所有引用该FIFO的文件描述符都被关闭后，名称仍然会存在。
- en: '*Kernel persistence*: A kernel-persistent IPC object exists until either it
    is explicitly deleted or the system is shut down. The lifetime of the object is
    independent of whether any process holds the object open. This means that, for
    example, one process can create an object, write data to it, and then close it
    (or terminate). At a later point, another process can open the object and read
    the data. Examples of facilities with kernel persistence are System V IPC and
    POSIX IPC. We exploit this property in the example programs that we present when
    describing these facilities in later chapters: for each facility, we implement
    separate programs that create an object, delete an object, and perform communication
    or synchronization.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内核持久性*：内核持久的IPC对象会一直存在，直到它被显式删除或系统关闭。该对象的生命周期与是否有进程保持该对象打开无关。这意味着，例如，一个进程可以创建一个对象，将数据写入其中，然后关闭它（或终止）。稍后，另一个进程可以打开该对象并读取数据。具有内核持久性的设施示例有System
    V IPC和POSIX IPC。我们在后面的章节中描述这些设施时，会利用这一特性，展示示例程序：对于每个设施，我们会实现单独的程序来创建对象、删除对象并执行通信或同步。'
- en: '*File-system persistence*: An IPC object with file-system persistence retains
    its information even when the system is rebooted. The object exists until it is
    explicitly deleted. The only type of IPC object that demonstrates file-system
    persistence is shared memory based on a memory-mapped file.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件系统持久性*：具有文件系统持久性的IPC对象即使在系统重启后也能保留其信息。该对象会一直存在，直到它被显式删除。唯一展示文件系统持久性的IPC对象是基于内存映射文件的共享内存。'
- en: Performance
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 性能
- en: 'In some circumstances, different IPC facilities may show notable differences
    in performance. However, in later chapters, we generally refrain from making performance
    comparisons, for the following reasons:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，不同的IPC设施可能会表现出显著的性能差异。然而，在后面的章节中，我们通常避免进行性能比较，原因如下：
- en: The performance of an IPC facility may not be a significant factor in the overall
    performance of an application, and it may not be the only factor in determining
    the choice of an IPC facility.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPC设施的性能可能在整个应用程序的性能中并不是一个显著因素，也可能不是决定选择IPC设施的唯一因素。
- en: The relative performance of the various IPC facilities may vary across UNIX
    implementations or between different versions of the Linux kernel.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种IPC设施的相对性能可能在不同的UNIX实现中，或者在不同版本的Linux内核中有所不同。
- en: Most importantly, the performance of an IPC facility will vary depending on
    the precise manner and environment in which it is used. Relevant factors include
    the size of the data units exchanged in each IPC operation, the amount of unread
    data that may be outstanding on the IPC facility, whether or not a process context
    switch is required for each unit of data exchanged, and other load on the system.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，IPC设施的性能会根据其使用的具体方式和环境而有所不同。相关因素包括每次IPC操作中交换的数据单元的大小、可能存在的未读数据量、是否需要为每个交换的数据单元进行进程上下文切换，以及系统的其他负载。
- en: If IPC performance is crucial, there is no substitute for application-specific
    benchmarks run under an environment that matches the target system. To this end,
    it may be worth writing an abstract software layer that hides details of the IPC
    facility from the application and then testing performance when different IPC
    facilities are substituted underneath the abstract layer.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 IPC 性能至关重要，那么没有什么能够替代在与目标系统匹配的环境中运行的特定应用基准测试。为此，可能值得编写一个抽象的软件层，将 IPC 设施的细节从应用程序中隐藏起来，然后在抽象层下替换不同的
    IPC 设施并测试性能。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we provided an overview of various facilities that processes
    (and threads) can use to communicate with one another and to synchronize their
    actions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了进程（和线程）可以用来相互通信和同步其操作的各种设施。
- en: Among the communication facilities provided on Linux are pipes, FIFOs, sockets,
    message queues, and shared memory. Synchronization facilities provided on Linux
    include semaphores and file locks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 提供的通信设施包括管道（pipes）、命名管道（FIFOs）、套接字（sockets）、消息队列（message queues）和共享内存（shared
    memory）。Linux 提供的同步设施包括信号量（semaphores）和文件锁（file locks）。
- en: In many cases, we have a choice of several possible techniques for communication
    and synchronization when performing a given task. In the course of this chapter,
    we compared the different techniques in various ways, with the aim of highlighting
    some differences that may influence the choice of one technique over another.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，在执行特定任务时，我们可以选择几种可能的通信和同步技术。在本章中，我们以不同方式比较了这些技术，目的是突出一些可能影响选择某一技术而非其他技术的差异。
- en: In the following chapters, we go into each of the communication and synchronization
    facilities in much more detail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地讨论每个通信和同步设施。
- en: Exercises
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Write a program that measures the bandwidth provided by pipes. As command-line
    arguments, the program should accept the number of data blocks to be sent and
    the size of each data block. After creating a pipe, the program splits into two
    process: a child that writes the data blocks to the pipe as fast as possible,
    and a parent that reads the data blocks. After all data has been read, the parent
    should print the elapsed time required and the bandwidth (bytes transferred per
    second). Measure the bandwidth for different data block sizes.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，测量管道提供的带宽。作为命令行参数，程序应接受要发送的数据块数量和每个数据块的大小。在创建管道后，程序会分为两个进程：一个子进程以尽可能快的速度将数据块写入管道，父进程则读取数据块。在所有数据读取完毕后，父进程应打印所需的时间和带宽（每秒传输的字节数）。测试不同数据块大小的带宽。
- en: Repeat the preceding exercise for System V message queues, POSIX message queues,
    UNIX domain stream sockets, and UNIX domain datagram sockets. Use these programs
    to compare the relative performance of the various IPC facilities on Linux. If
    you have access to other UNIX implementations, perform the same comparisons on
    those systems.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 System V 消息队列、POSIX 消息队列、UNIX 域流套接字（UNIX domain stream sockets）和 UNIX 域数据报套接字（UNIX
    domain datagram sockets）重复前面的练习。使用这些程序比较 Linux 上各种 IPC 设施的相对性能。如果你可以访问其他 UNIX
    实现，尝试在这些系统上做相同的比较。
