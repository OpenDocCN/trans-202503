- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: MAKING BUBBLEDRAW A MULTITOUCH ANDROID APP
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作多点触控的BubbleDraw安卓应用
- en: '![Image](../images/circle.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/circle.jpg)'
- en: Our final app will be a multitouch Android version of BubbleDraw that enables
    the user to draw bubbles with the touch of a finger—or all 10 fingers!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的应用将是一个多点触控的安卓版本BubbleDraw，用户可以通过触摸屏幕绘制气泡——甚至是用所有10个手指！
- en: The processors in Android devices are usually much smaller and slower than desktop
    CPUs. If you’ve ever gotten an “App Not Responding” error, you’ve seen what happens
    when an app consumes too much of a device’s processing power. So, instead of a
    timer, this version of the app will use a new approach to animation called *threading*,
    which will make the app use less processing power. Threading is what makes it
    possible for us to run multiple apps at the same time, or *multitask*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备中的处理器通常比桌面CPU小且慢。如果你曾遇到“应用未响应”的错误，你就会知道当应用消耗过多设备处理能力时会发生什么。因此，这个版本的应用将采用一种名为*线程*的全新动画方法，它将使应用使用更少的处理能力。线程使得我们能够同时运行多个应用，或者说是*多任务处理*。
- en: The new BubbleDraw app will also make use of *multitouch*. Take a look at [Figure
    11-1](ch11.xhtml#ch11fig1), which shows bubbles pouring out of several different
    locations, where my younger son Max touched his fingers to the screen.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 新的BubbleDraw应用也将使用*多点触控*。请查看[图11-1](ch11.xhtml#ch11fig1)，图中显示了气泡从多个不同位置喷涌而出，我的小儿子Max将手指触摸在屏幕上。
- en: '![Image](../images/f0250-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0250-01.jpg)'
- en: '*Figure 11-1: The Android version of the BubbleDraw app will use multitouch
    so that the user can draw bubbles on multiple locations of the screen at once.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：BubbleDraw应用的安卓版本将使用多点触控，用户可以在屏幕的多个位置同时绘制气泡。*'
- en: The mobile BubbleDraw app will reuse a lot of the features from the desktop
    and GUI versions, such as the source code from the `Bubble` class we finished
    building in [Chapter 10](ch10.xhtml#ch10). There are a couple of differences in
    how we draw graphics on Android, however, and since we’re also adding threading
    and multitouch, you’ll need to learn some new app-building techniques. You’ll
    develop these new skills using the BubbleDraw app as a foundation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 移动版BubbleDraw应用将重用桌面和GUI版本的许多功能，比如我们在[第10章](ch10.xhtml#ch10)完成的`Bubble`类的源代码。不过，在安卓设备上绘制图形的方式有所不同，而且由于我们还将添加线程和多点触控功能，你需要学习一些新的应用构建技巧。你将通过使用BubbleDraw应用作为基础来掌握这些新技能。
- en: Setting Up the BubbleDraw Project
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置BubbleDraw项目
- en: Open Android Studio, close any open projects, and click **Start a new Android
    Studio project**. In the Create New Project window, enter **BubbleDraw** in the
    Application Name field, leave Company Domain the same (*example.com* or your website
    name), and then click **Next**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Android Studio，关闭所有打开的项目，然后点击**开始一个新的Android Studio项目**。在创建新项目的窗口中，输入**BubbleDraw**作为应用名称，保持公司域名不变（*example.com*或你的网站名称），然后点击**下一步**。
- en: 'This time, we want to choose a newer API level than we used for our previous
    apps. Both the Hi-Lo guessing game and Secret Messages apps used GUI interfaces
    that would work on older Android devices. In this app, however, we’ll need the
    `drawOval()` method to draw the bubbles, which requires API level 21 or higher.
    Select **API 21: Android 5.0 (Lollipop)** as the Minimum SDK.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '这一次，我们想选择一个比之前应用中使用的更新的API版本。Hi-Lo猜数字游戏和秘密消息应用都使用了适用于较旧安卓设备的GUI界面。然而，在这个应用中，我们需要使用`drawOval()`方法来绘制气泡，这需要API
    21或更高版本。选择**API 21: Android 5.0 (Lollipop)**作为最低SDK版本。'
- en: An additional difference is that instead of the basic activity we used in the
    Hi-Lo guessing game and Secret Messages apps, in this app we’ll use an empty activity
    because we don’t need a basic GUI interface. Instead of a regular GUI app layout,
    we’re going to create an interactive, touch-enabled drawing canvas. On the Add
    an Activity to Mobile screen, choose **Empty Activity** and click **Next**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不同之处是，这个应用将不再像我们在Hi-Lo猜数字游戏和秘密消息应用中使用的基本活动那样，而是使用一个空活动，因为我们不需要基本的GUI界面。我们不会使用常规的GUI应用布局，而是创建一个交互式的触摸绘图画布。在“向移动设备添加活动”屏幕上，选择**空活动**并点击**下一步**。
- en: We’ll keep `MainActivity` as the Activity Name, as we did in our previous apps,
    but uncheck the **Backwards Compatibility** checkbox and click **Finish**. Turning
    off backward compatibility will keep our code simpler.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留`MainActivity`作为活动名称，正如我们在之前的应用中所做的那样，但取消勾选**向后兼容性**复选框并点击**完成**。关闭向后兼容性将使我们的代码更加简洁。
- en: As in the previous two desktop versions of the BubbleDraw app, we’re going to
    use two Java files to keep our bubble code separate from the main app code. Once
    your project opens, click the Project tab along the left edge of the screen to
    display the Project Explorer pane, if it’s not already visible. Then, select the
    **Android** tab at the top of the Project Explorer pane. Under *app* ▸ *java*,
    find the *main* BubbleDraw package (don’t select the *androidTest* or *test* packages).
    Right-click your BubbleDraw package in the Project Explorer and select **New**
    ▸ **Java Class**, as shown in [Figure 11-2](ch11.xhtml#ch11fig2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的两个桌面版本的BubbleDraw应用一样，我们将使用两个Java文件来将气泡代码与主应用代码分开。一旦你的项目打开，点击屏幕左侧的“项目”标签以显示项目资源管理器窗格，如果它尚未显示的话。然后，选择项目资源管理器窗格顶部的**Android**标签。在*app*
    ▸ *java*下，找到*main* BubbleDraw包（不要选择*androidTest*或*test*包）。右键点击项目资源管理器中的BubbleDraw包，选择**新建**
    ▸ **Java类**，如[图11-2](ch11.xhtml#ch11fig2)所示。
- en: '![Image](../images/f0251-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0251-01.jpg)'
- en: '*Figure 11-2: Add a new Java class to your main BubbleDraw package for the
    bubble code.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：为气泡代码在你的主BubbleDraw包中添加一个新的Java类。*'
- en: In the Create New Class pop-up window, name the new class `BubbleView`. In Android,
    a `View` is any GUI component. The `BubbleView` class serves the same function
    as the `BubblePanel` class did in the desktop app. All our bubble drawing code
    will go in this class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在“创建新类”弹出窗口中，将新类命名为`BubbleView`。在Android中，`View`是任何GUI组件。`BubbleView`类的功能与桌面应用中的`BubblePanel`类相同。我们所有的气泡绘制代码都将写在这个类中。
- en: Android Studio’s Create New Class window allows us to set the superclass and
    interfaces easily. First, we’ll make our new `BubbleView` class inherit the ability
    to draw graphics easily. In the **Superclass** text field, begin typing `ImageView`
    and then click **ImageView (android.widget)** in the autocomplete drop-down list
    to make the new class’s parent class `ImageView`. This will display as `android.widget.ImageView`
    after you click it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio的“创建新类”窗口允许我们轻松设置超类和接口。首先，我们将使新`BubbleView`类继承轻松绘制图形的能力。在**超类**文本框中，开始输入`ImageView`，然后在自动完成下拉列表中点击**ImageView
    (android.widget)**，将新类的父类设置为`ImageView`。点击后，它将显示为`android.widget.ImageView`。
- en: Next we’ll implement an `OnTouchListener` interface to enable our app to handle
    touch events, similar to the mouse events we used in the previous versions of
    the app. In the **Interface(s)** text field, begin typing `OnTouchListener` and
    then click **OnTouchListener (android.view.View)** in the autocomplete drop-down
    list. Once you click it, it will display as `android.view.View.OnTouchListener`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`OnTouchListener`接口，以使我们的应用能够处理触摸事件，类似于我们在应用的早期版本中使用的鼠标事件。在**接口**文本框中，开始输入`OnTouchListener`，然后在自动完成下拉列表中点击**OnTouchListener
    (android.view.View)**。点击后，它将显示为`android.view.View.OnTouchListener`。
- en: Click **OK**. You should now see the `BubbleView` class inside your *com.<yourdomain>.bubbledraw*
    package. Double-click the `BubbleView` class in the Project Explorer to begin
    editing the file. The `BubbleView` class may be underlined in red to let you know
    it’s missing some code, but we’ll fill in those required pieces as we code the
    app in the next few sections.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**。现在，你应该能在*com.<yourdomain>.bubbledraw*包内看到`BubbleView`类。双击项目资源管理器中的`BubbleView`类，开始编辑该文件。`BubbleView`类可能会被红色下划线标记，表示缺少一些代码，但我们将在接下来的几节中填补这些必需的部分。
- en: Creating the BubbleView Constructor
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建BubbleView构造函数
- en: Double-click the *BubbleView.java* tab to expand it to fullscreen in the app
    for easier editing. Let’s begin building the `BubbleView` class by adding variables
    similar to those in the `BubblePanel` class. Just as in our desktop and GUI versions
    of the app, we’ll need a random number generator and an `ArrayList` for the bubbles
    the user has drawn, as well as some integer variables for the default bubble size
    and the animation delay in milliseconds.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 双击*BubbleView.java*标签，将其展开为全屏，以便更轻松地进行编辑。让我们开始构建`BubbleView`类，首先添加一些与`BubblePanel`类类似的变量。和我们在桌面版及GUI版本的应用中一样，我们需要一个随机数生成器和一个用于存储用户绘制的气泡的`ArrayList`，以及一些整数变量，用于设置默认气泡大小和动画延迟（毫秒）。
- en: '*Adding the Animation Variables*'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*添加动画变量*'
- en: We’ll want random colors and speeds for our bubbles, so inside the opening brace
    for the `BubbleView` class, begin typing `private Random` and then click **Random
    (java.util)** in the autocomplete drop-down list.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为气泡设置随机颜色和速度，因此在`BubbleView`类的起始大括号内，开始输入`private Random`，然后在自动完成下拉列表中点击**Random
    (java.util)**。
- en: We’ll click the automatic code completion list items every time we add a new
    type of object in our code. Remember, Android Studio’s code completion feature
    not only helps you code faster, it reduces errors from mistyped or misspelled
    class names and `import` statements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在代码中添加一种新类型的对象时，我们都会点击自动代码补全列表中的项。记住，安卓Studio的代码补全功能不仅帮助你更快编写代码，还能减少因拼写错误或类名错误而导致的错误。
- en: 'Finish declaring your `private Random rand = new Random();`. Then, add each
    of the variables shown in the following code. Check your `import` statements afterward
    to make sure they match the ones here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完成声明你的`private Random rand = new Random();`。然后，添加以下代码中显示的每个变量。检查你的`import`语句，确保它们与你这里的内容一致：
- en: 'package com.yourdomain.bubbledraw;  // Note: your package name may differ'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: package com.yourdomain.bubbledraw;  // 注意：你的包名可能不同
- en: import android.widget.ImageView;
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: import android.widget.ImageView;
- en: import android.view.View;
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: import android.view.View;
- en: import java.util.ArrayList;
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.ArrayList;
- en: import java.util.Random;
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Random;
- en: public class BubbleView extends ImageView implements View.OnTouchListener {
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubbleView extends ImageView implements View.OnTouchListener {
- en: ➊ private Random rand = new Random();
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ private Random rand = new Random();
- en: ➋ private ArrayList<Bubble> bubbleList;
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ private ArrayList<Bubble> bubbleList;
- en: ➌ private int size = 50;
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ private int size = 50;
- en: ➍ private int delay = 33;
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ private int delay = 33;
- en: '}'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: These four lines are similar to the variables we declared at the top of the
    `BubblePanel` class in [Chapters 9](ch9.xhtml#ch9) and [10](ch10.xhtml#ch10),
    with a few changes for the Android version of the app. The declaration for a random
    number generator at ➊ is identical to our old version, because both use `java.util.Random`.
    The same goes for the line at ➋, where we declare an `ArrayList` of `Bubble` objects
    called `bubbleList`. This will again be where we store the bubbles created by
    the user. The `Bubble` type specifier should show up in red, letting us know we
    haven’t defined a `Bubble` class yet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这四行代码与我们在[第9章](ch9.xhtml#ch9)和[第10章](ch10.xhtml#ch10)中声明的变量相似，只有一些针对安卓版本的调整。➊处的随机数生成器声明与我们之前的版本相同，因为它们都使用了`java.util.Random`。同样，➋处声明了一个名为`bubbleList`的`Bubble`对象的`ArrayList`，这将是我们存储用户创建的气泡的地方。`Bubble`类型说明符应该以红色显示，提示我们还没有定义`Bubble`类。
- en: At ➌, we’re declaring an integer variable for the default bubble size, but we’ve
    made it bigger for the Android app because of the smaller pixel size on mobile
    devices. Your mobile phone or tablet often has a much smaller screen size and
    denser resolution than your desktop computer, so we’ll set our default bubble
    size to `50` to make the bubbles easier to see in the app. You can edit this line
    later to make your bubbles bigger or smaller depending on how you want them to
    look on your device.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们声明了一个整数变量作为默认的气泡大小，但由于移动设备的像素较小，我们将其在安卓应用中设为更大。你的手机或平板电脑的屏幕通常比桌面电脑小，而且分辨率更高，因此我们将默认的气泡大小设置为`50`，以便在应用中更容易看到这些气泡。你可以稍后编辑这一行，根据气泡在设备上显示的效果调整它的大小。
- en: At ➍, we’re keeping the animation speed at 30 fps by setting the delay between
    frames to `33` milliseconds. Remember, to get the animation speed, we divide 1,000
    milliseconds by the number of frames per second, 30 fps, to get the number of
    milliseconds per frame, 1,000 ÷ 30 = 33.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在➍处，我们通过将每帧之间的延迟设置为`33`毫秒，将动画速度保持在每秒30帧。记住，要计算动画速度，我们将1,000毫秒除以每秒的帧数30帧，得到每帧的毫秒数，1,000
    ÷ 30 = 33。
- en: 'Both the graphics and animation will be slightly different on Android than
    they were on desktops, so we’ll need to add two new variables:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓上，图形和动画与桌面端会有所不同，因此我们需要添加两个新变量：
- en: public class BubbleView extends ImageView implements View.OnTouchListener {
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubbleView extends ImageView implements View.OnTouchListener {
- en: private Random rand = new Random();
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: private Random rand = new Random();
- en: private ArrayList<Bubble> bubbleList;
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: private ArrayList<Bubble> bubbleList;
- en: private int size = 50;
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: private int size = 50;
- en: private int delay = 33;
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: private int delay = 33;
- en: ➊ private Paint myPaint = new Paint();
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ private Paint myPaint = new Paint();
- en: ➋ private Handler h = new Handler();
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ private Handler h = new Handler();
- en: '}'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The line at ➊ declares an `android.graphics.Paint` object called `myPaint`.
    Think of this as a paintbrush for drawing bubbles on the Android screen. You must
    have a `Paint` object to be able to draw shapes on an Android `Canvas`. Press
    ENTER after typing `Paint` to accept the code completion suggestion, or click
    `Paint` after typing it and press ALT-ENTER (or OPTION-ENTER) to automatically
    import the `android.graphics.Paint` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ➊这一行声明了一个名为`myPaint`的`android.graphics.Paint`对象。可以将其视为在Android屏幕上绘制气泡的画笔。你必须拥有一个`Paint`对象才能在Android的`Canvas`上绘制图形。在键入`Paint`后按ENTER以接受代码完成建议，或者在键入后点击`Paint`并按ALT-ENTER（或OPTION-ENTER）以自动导入`android.graphics.Paint`类。
- en: The line at ➋ declares another new type of variable, an `android.os .Handler`
    named `h`. Make sure you import the `android.os` version of the `Handler` class
    since there are other classes with similar names. This `Handler` object will enable
    us to work with threading to accomplish the animation, and you can think of it
    as analogous to the `Timer` in the desktop app. Unlike a `Timer`, however, the
    `Handler` will allow us to communicate with a *thread*, which is an individual
    process in a multitasking environment where we might be running several apps at
    once. A `Handler` won’t keep the CPU busy counting off the time between events
    as a `Timer` would; instead, it will release the CPU and allow other tasks to
    run until it’s time to redraw another frame of animation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ➋这一行声明了一个新的变量类型，名为`h`的`android.os.Handler`。确保你导入的是`android.os`版本的`Handler`类，因为有其他类有类似的名字。这个`Handler`对象将使我们能够使用线程来实现动画，你可以将它类比为桌面应用中的`Timer`。然而，与`Timer`不同的是，`Handler`将允许我们与一个*线程*进行通信，线程是一个在多任务环境中运行的独立进程，在该环境下我们可能同时运行多个应用程序。与`Timer`会持续占用CPU计算事件之间的时间不同，`Handler`将释放CPU，允许其他任务运行，直到该重新绘制另一个动画帧的时间到来。
- en: Next, let’s add a constructor to the app and start drawing bubbles.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向应用程序中添加一个构造函数并开始绘制气泡。
- en: '*Creating the BubbleView() Constructor*'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*创建BubbleView()构造函数*'
- en: 'The next step will be writing the constructor for the `BubbleView` class. Below
    the variables we just declared, enter the constructor code as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是为`BubbleView`类编写构造函数。在我们刚声明的变量下面，输入如下构造函数代码：
- en: public class BubbleView extends ImageView implements View.OnTouchListener {
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: public class BubbleView extends ImageView implements View.OnTouchListener {
- en: private Random rand = new Random();
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: private Random rand = new Random();
- en: private ArrayList<Bubble> bubbleList;
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: private ArrayList<Bubble> bubbleList;
- en: private int size = 50;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: private int size = 50;
- en: private int delay = 33;
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: private int delay = 33;
- en: private Paint myPaint = new Paint();
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: private Paint myPaint = new Paint();
- en: private Handler h = new Handler();
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: private Handler h = new Handler();
- en: public BubbleView(Context context, AttributeSet attributeSet) {
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: public BubbleView(Context context, AttributeSet attributeSet) {
- en: super(context, attributeSet);
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: super(context, attributeSet);
- en: '}'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Use automatic code completion to import `android.content.Context` and `android.util.AttributeSet`.
    Android uses these two classes to store information about the current application,
    and we need to import them to be able to call the `super()` method. The `super()`
    method sets up the app and drawing screen by calling the constructor of the parent
    class, `ImageView`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动代码完成导入`android.content.Context`和`android.util.AttributeSet`。Android使用这两个类来存储当前应用程序的信息，我们需要导入它们才能调用`super()`方法。`super()`方法通过调用父类`ImageView`的构造函数来设置应用程序和绘制屏幕。
- en: 'For now, the only statement we’ll add to the constructor is a line to initialize
    the `bubbleList`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将添加到构造函数中的唯一语句是初始化`bubbleList`的代码：
- en: public BubbleView(Context context, AttributeSet attributeSet) {
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: public BubbleView(Context context, AttributeSet attributeSet) {
- en: super(context, attributeSet);
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: super(context, attributeSet);
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: '}'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Initializing the `bubbleList` by setting it equal to a new, empty `ArrayList`
    of `Bubble` objects works the same way here as it did in the previous versions
    of the app. We’ll be able to store new bubbles in `bubbleList` as the user touches
    the screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`bubbleList`，通过将其设置为一个新的、空的`ArrayList`对象来存储`Bubble`，在这里的工作方式与应用程序的早期版本相同。我们可以在用户触摸屏幕时将新的气泡存储到`bubbleList`中。
- en: '*Preparing the Layout to Use BubbleView*'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*准备布局以使用BubbleView*'
- en: Now that we’ve begun building the `BubbleView` class, it’s time to tell our
    GUI layout file to display `BubbleView` when the app runs. In the Project Explorer,
    open *app* ▸ *res* ▸ *layout* ▸ *activity_main.xml* and switch to the Text tab
    at the bottom of the window.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始构建`BubbleView`类，接下来是告诉我们的GUI布局文件在应用程序运行时显示`BubbleView`。在项目资源管理器中，打开*app*
    ▸ *res* ▸ *layout* ▸ *activity_main.xml*并切换到底部窗口的Text选项卡。
- en: 'Replace the contents of the *activity_main.xml* file with the following, substituting
    your app’s package name in place of mine:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将*activity_main.xml*文件的内容替换为以下内容，并将我的包名替换为你的应用包名：
- en: <?xml version="1.0" encoding="utf-8"?>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <?xml version="1.0" encoding="utf-8"?>
- en: ➊ <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
- en: xmlns:tools="http://schemas.android.com/tools"
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: xmlns:tools="http://schemas.android.com/tools"
- en: android:layout_width="match_parent"
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: android:layout_width="match_parent"
- en: android:layout_height="match_parent"
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: android:layout_height="match_parent"
- en: ➋ android:background="#000000"
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ android:background="#000000"
- en: ➌ tools:context="com.*yourdomain*.bubbledraw.BubbleView">
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ tools:context="com.*yourdomain*.bubbledraw.BubbleView">
- en: ➍ <com.*yourdomain*.bubbledraw.BubbleView
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ <com.*yourdomain*.bubbledraw.BubbleView
- en: ➎ android:layout_width="match_parent"
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ android:layout_width="match_parent"
- en: ➏ android:layout_height="match_parent"
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ android:layout_height="match_parent"
- en: />
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: </RelativeLayout>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: </RelativeLayout>
- en: This app uses the default `RelativeLayout` ➊, which will allow us to easily
    place other GUI components later. Much of the `RelativeLayout` properties are
    the same as the default, but we’ve added a `background` color of `#000000` ➋,
    or black.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用使用默认的`RelativeLayout` ➊，这将使我们以后能够轻松地放置其他GUI组件。`RelativeLayout`的许多属性与默认设置相同，但我们添加了一个`background`颜色`#000000`
    ➋，即黑色。
- en: When you replace the package name `com.`*yourdomain*`.bubbledraw` at ➌ and ➍
    with your package name, Android helps you by making a code completion suggestion
    at ➍.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在第➌和➊行将包名`com.`*yourdomain*`.bubbledraw`替换为你的包名时，Android会通过在第➍行提供代码补全建议来帮助你。
- en: The line at ➍ places the `BubbleView` into the layout, and the lines at ➎ and
    ➏ tell the program to match the width and height of the *activity_main .xml* window,
    which is the parent object of `BubbleView`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ➋这一行将`BubbleView`放入布局，接下来的第➎和➏行指示程序匹配*activity_main.xml*窗口的宽度和高度，该窗口是`BubbleView`的父级对象。
- en: The *activity_main.xml* file is the default GUI layout view that your app loads
    when it runs. Telling *activity_main.xml* to load `BubbleView` as the only item
    in the layout and match the layout’s width and height results in the `BubbleView`
    app taking up the full screen. So, with these changes, the *activity_main.xml*
    file now knows to call on `BubbleView` to show our bubble drawing canvas.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*activity_main.xml*文件是你的应用程序运行时加载的默认GUI布局视图。通过告诉*activity_main.xml*加载`BubbleView`作为布局中的唯一项目，并匹配布局的宽度和高度，最终使得`BubbleView`应用占据整个屏幕。因此，经过这些修改后，*activity_main.xml*文件现在知道调用`BubbleView`来显示我们的泡泡绘图画布。'
- en: Speaking of bubbles, let’s reuse the `Bubble` class from the desktop version
    of this app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 说到泡泡，我们来重用桌面版应用中的`Bubble`类吧。
- en: Modifying the Bubble Class
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改`Bubble`类
- en: Open the *BubbleDrawGUI* project from [Chapter 10](ch10.xhtml#ch10) in Eclipse
    to access the old `Bubble` class. Open the *BubblePanel.java* class and scroll
    to the bottom of the file where we defined the `Bubble` class. Copy the class’s
    entire source code, from `private class Bubble` all the way down to the next-to-last
    closing brace. The final brace in the file is the closing brace for `BubblePanel`,
    so make sure you copy only the closing braces for `update()` and the `Bubble`
    class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开[第10章](ch10.xhtml#ch10)中的*BubbleDrawGUI*项目，进入Eclipse，访问旧版`Bubble`类。打开*BubblePanel.java*类，滚动到文件底部，找到我们定义的`Bubble`类。复制该类的完整源代码，从`private
    class Bubble`一直复制到倒数第二个闭括号。文件中的最后一个括号是`BubblePanel`的闭括号，因此只需确保复制`update()`和`Bubble`类的闭括号。
- en: Now that you’ve copied the `Bubble` class, switch back to Android Studio and
    place the cursor directly after the closing brace for the `BubbleView()` constructor.
    Press ENTER to insert a blank line before the final closing brace at the bottom
    of the file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经复制了`Bubble`类，切换回Android Studio，将光标放在`BubbleView()`构造函数的闭括号后面。按ENTER键，在文件底部的最终闭括号之前插入一个空行。
- en: 'Most of the code from the desktop version of `Bubble` will work, but we’ll
    need to make a few changes to account for differences in the way Android draws
    graphics. Let’s start near the top of the `Bubble` class. In Android graphics,
    color values are stored as integers instead of `Color` objects, so change `private
    Color color` to `private int color` as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分来自桌面版`Bubble`的代码都可以正常工作，但我们需要做一些调整，以适应Android绘制图形的方式。我们从`Bubble`类的顶部开始。在Android图形中，颜色值是以整数形式存储的，而不是`Color`对象，因此将`private
    Color color`改为`private int color`，如下面所示：
- en: private class Bubble {
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: private int x;
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: private int x;
- en: private int y;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: private int y;
- en: private int size;
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: private int size;
- en: private int color;
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: private int color;
- en: private int xspeed, yspeed;
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: private int xspeed, yspeed;
- en: private final int MAX_SPEED = 5;
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: private final int MAX_SPEED = 5;
- en: All the other variables remain the same.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有变量保持不变。
- en: 'We’ll also need to change the color entry in the `Bubble()` constructor. Delete
    `new Color` and replace it with `Color.argb`, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改`Bubble()`构造函数中的颜色条目。删除`new Color`并用`Color.argb`替换，如下所示：
- en: public Bubble(int newX, int newY, int newSize) {
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: public Bubble(int newX, int newY, int newSize) {
- en: x = newX;
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: x = newX;
- en: y = newY;
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: y = newY;
- en: size = newSize;
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: size = newSize;
- en: color = Color.argb(rand.nextInt(256),
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: color = Color.argb(rand.nextInt(256),
- en: rand.nextInt(256),
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256),
- en: rand.nextInt(256),
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256),
- en: rand.nextInt(256) );
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: rand.nextInt(256) );
- en: xspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: xspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
- en: yspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: yspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
- en: '}'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Be sure to remove the keyword `new`, since `Color.argb()` doesn’t create a new
    object. Instead, the `Color.argb()` method will convert four *ARGB* values (*alpha,
    red, green*, and *blue*) into a single color integer that can be used to change
    paint colors in Android.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要移除`new`关键字，因为`Color.argb()`并不会创建一个新对象。相反，`Color.argb()`方法将四个*ARGB*值（*alpha,
    red, green* 和 *blue*）转换为一个单一的颜色整数，可以用来改变Android中的画笔颜色。
- en: This is the first time we’ve used the `Color` class in this app, so it will
    show up in red in the Android Studio text editor. You can either manually add
    `import android.graphics.Color;` to the `import` statements at the top of the
    file, or you can click the word **Color** and press ALT-ENTER (or OPTION-ENTER)
    to have Android Studio perform the import for you. Pressing ALT-ENTER is similar
    to accepting a code completion suggestion, except that you can use ALT-ENTER to
    import a class even *after* you’ve typed your code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次在这个应用中使用`Color`类，因此在Android Studio的文本编辑器中它会显示为红色。你可以手动将`import android.graphics.Color;`添加到文件顶部的`import`语句中，或者点击**Color**并按ALT-ENTER（或OPTION-ENTER）让Android
    Studio为你自动导入。按ALT-ENTER类似于接受代码补全建议，不过你可以在输入代码后使用ALT-ENTER来导入类。
- en: 'Next, we’ll need to change the entire `draw()` method in the `Bubble` class.
    Replace the `draw()` method we copied with the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改`Bubble`类中的整个`draw()`方法。用以下代码替换我们复制的`draw()`方法：
- en: xspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: xspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
- en: yspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: yspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;
- en: '}'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➊ public void draw(Canvas canvas) {
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ public void draw(Canvas canvas) {
- en: ➋ myPaint.setColor(color);
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ myPaint.setColor(color);
- en: ➌ canvas.drawOval(x - size/2, y - size/2,
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ canvas.drawOval(x - size/2, y - size/2,
- en: x + size/2, y + size/2, myPaint);
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: x + size/2, y + size/2, myPaint);
- en: '}'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void update() {
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: public void update() {
- en: At ➊, the `draw()` method accepts a parameter of type `android.graphics .Canvas`
    instead of `java.awt.Graphics`. Be sure to import the `Canvas` class either as
    you type or by clicking it and pressing ALT-ENTER (or OPTION-ENTER) afterward.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '在➊处，`draw()`方法接受一个类型为`android.graphics .Canvas`的参数，而不是`java.awt.Graphics`。一定要在输入时或之后点击它并按ALT-ENTER（或OPTION-ENTER）来导入`Canvas`类。 '
- en: At ➋, we set the color for the `myPaint` object to use this bubble’s `color`
    value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处，我们将`myPaint`对象的颜色设置为该气泡的`color`值。
- en: The line at ➌ differs from the desktop version in several places. First, the
    command to draw an oval on an Android `Canvas` is `drawOval()` instead of `fillOval()`.
    Second, we specify the bounding box that will hold the oval using its *left, top,
    right, bottom* values instead of *left, top, width, height*. The left and top
    remain the same, at `x - size/2` and `y - size/2`. (Remember, we subtract half
    the width and height of the bubble to center it on the `(x, y)` location where
    the user touched the screen.) The right side of the bubble’s bounding box is `x
    + size/2`, and the bottom of the bubble is `y + size/2`, as shown in [Figure 11-3](ch11.xhtml#ch11fig3).
    Instead of using the width and height to calculate the bottom-right corner of
    the bounding box for the oval, as we did in the desktop version, Android requires
    us to specify the x- and y-coordinates of the bottom-right corner, or `x + size/2,
    y + size/2`. Finally, the `drawOval()` method requires a `Paint` object, so we
    pass it `myPaint`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ➌处的代码与桌面版有几个不同之处。首先，在Android的`Canvas`上绘制椭圆的命令是`drawOval()`，而不是`fillOval()`。其次，我们使用椭圆的*left,
    top, right, bottom*值来指定包含椭圆的边界框，而不是使用*left, top, width, height*。左边和顶部保持不变，分别是`x
    - size/2`和`y - size/2`。（记住，我们减去气泡的宽度和高度的一半，以便将其居中于用户触摸屏幕的`(x, y)`位置。）气泡边界框的右侧是`x
    + size/2`，底部是`y + size/2`，如[图11-3](ch11.xhtml#ch11fig3)所示。与桌面版使用宽度和高度计算椭圆的右下角不同，Android要求我们指定右下角的x和y坐标，即`x
    + size/2, y + size/2`。最后，`drawOval()`方法需要一个`Paint`对象，因此我们传入了`myPaint`。
- en: '![Image](../images/f0257-01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0257-01.jpg)'
- en: '*Figure 11-3: Android’s drawOval() method takes the top-left and bottom-right
    coordinates of an imaginary bounding box instead of the top, left, width, and
    height values we saw in the desktop Swing toolkit.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：Android的drawOval()方法使用一个虚拟边界框的左上角和右下角坐标，而不是我们在桌面Swing工具包中看到的顶部、左侧、宽度和高度值。*'
- en: Those are the only changes needed to port the `Bubble` class from desktop to
    Android. Save your file after making these changes. Next, we’ll draw all the bubbles
    on the screen.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是将`Bubble`类从桌面移植到Android所需的唯一更改。做出这些更改后，保存文件。接下来，我们将在屏幕上绘制所有气泡。
- en: Drawing in Android with the onDraw() Method
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用onDraw()方法在Android中绘图
- en: 'We want to test the app’s ability to draw bubbles on the screen, so next we’ll
    add an `onDraw()` method to our `BubbleView` class. The `onDraw()` method in a
    `View` class is similar to the `paintComponent()` method in a `JPanel`: it tells
    Java what to draw whenever the screen is refreshed.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想测试应用程序在屏幕上绘制气泡的能力，因此接下来我们将向`BubbleView`类添加一个`onDraw()`方法。`View`类中的`onDraw()`方法类似于`JPanel`中的`paintComponent()`方法：它告诉Java在每次屏幕刷新时绘制什么内容。
- en: 'We want to draw the list of bubbles, so add the following code below the `BubbleView()`
    constructor in *BubbleView.java* and above the `Bubble` class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想绘制气泡列表，因此在*BubbleView.java*中的`BubbleView()`构造函数下方和`Bubble`类上方添加以下代码：
- en: public BubbleView(Context context, AttributeSet attributeSet) {
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: public BubbleView(Context context, AttributeSet attributeSet) {
- en: super(context, attributeSet);
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: super(context, attributeSet);
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: '}'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➊ protected void onDraw(Canvas canvas) {
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ protected void onDraw(Canvas canvas) {
- en: '➋ for (Bubble b : bubbleList)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ for (Bubble b : bubbleList)'
- en: b.draw(canvas);
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: b.draw(canvas);
- en: '}'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private class Bubble {
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: At ➊, the `onDraw()` method must be declared as protected with one parameter,
    a `Canvas` object, to work because it must exactly match the default `View.onDraw()`
    method that we’re overriding. We need this method because it’s required in all
    `View` subclasses and `BubbleView` is a child class of `ImageView`, which is a
    subclass of `View`. The `onDraw()` method will be called anytime the screen containing
    our `BubbleView` needs to be refreshed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，`onDraw()`方法必须声明为protected并带有一个参数，即`Canvas`对象，才能正常工作，因为它必须与我们正在重写的默认`View.onDraw()`方法完全匹配。我们需要这个方法，因为它在所有`View`子类中都是必需的，而`BubbleView`是`ImageView`的子类，后者是`View`的子类。每当包含我们`BubbleView`的屏幕需要刷新时，`onDraw()`方法将被调用。
- en: 'The inside of the `onDraw()` method reuses the `for-each` loop at ➋ that calls
    each bubble’s `draw()` function. The line at ➋ could be read as follows: “For
    each `Bubble` `b` in `bubbleList`, draw `b` on the Android `Canvas`.”'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDraw()`方法内部重用了➋的`for-each`循环，它调用每个气泡的`draw()`函数。➋的这一行可以这样理解：“对于`bubbleList`中的每个`Bubble`
    `b`，在Android的`Canvas`上绘制`b`。”'
- en: There are just a couple of steps left before we can test our app’s ability to
    draw colorful bubbles. Let’s knock those out to see an early beta test of the
    Android BubbleDraw app.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个步骤，我们可以在测试应用程序绘制多彩气泡之前完成它们。让我们先做这些，看看Android版本的BubbleDraw应用程序的早期测试效果。
- en: Testing BubbleDraw with 100 Bubbles
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试BubbleDraw，显示100个气泡
- en: 'We wrote a short method called `testBubbles()` in the first version of the
    BubbleDraw desktop app. It looked like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在BubbleDraw桌面应用程序的第一个版本中，我们编写了一个名为`testBubbles()`的简短方法。它看起来像下面这样：
- en: public void testBubbles() {
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: public void testBubbles() {
- en: for(int n = 0; n < 100; n++) {
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: for(int n = 0; n < 100; n++) {
- en: int x = rand.nextInt(600);
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: int x = rand.nextInt(600);
- en: int y = rand.nextInt(400);
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: int y = rand.nextInt(400);
- en: int size = rand.nextInt(50);
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: int size = rand.nextInt(50);
- en: bubbleList.add( new Bubble(x, y, size) );
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList.add( new Bubble(x, y, size) );
- en: '}'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: repaint();
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: repaint();
- en: '}'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The purpose of `testBubbles()` was to see whether we could draw bubbles on the
    screen before we had implemented the mouse and timer event handlers. Let’s do
    the same for the Android version of the app.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`testBubbles()`的目的是在我们实现鼠标和定时器事件处理之前，查看是否能够在屏幕上绘制气泡。现在，我们为Android版本的应用程序做同样的事情。'
- en: '*Adding testBubbles()*'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*添加testBubbles()*'
- en: 'First, let’s add a slightly modified version of the `testBubbles()` function
    just below the `onDraw()` method in *BubbleView.java*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在*BubbleView.java*中的`onDraw()`方法下方添加一个略微修改版的`testBubbles()`函数：
- en: protected void onDraw(Canvas canvas) {
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onDraw(Canvas canvas) {
- en: 'for (Bubble b : bubbleList)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Bubble b : bubbleList)'
- en: b.draw(canvas);
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: b.draw(canvas);
- en: '}'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void testBubbles() {
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: public void testBubbles() {
- en: for(int n = 0; n < 100; n++) {
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: for(int n = 0; n < 100; n++) {
- en: ➊ int x = rand.nextInt(600);
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ int x = rand.nextInt(600);
- en: ➋ int y = rand.nextInt(600);
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ int y = rand.nextInt(600);
- en: ➌ int s = rand.nextInt(size) + size;
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ int s = rand.nextInt(size) + size;
- en: ➍ bubbleList.add( new Bubble(x, y, s) );
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ bubbleList.add( new Bubble(x, y, s) );
- en: '}'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➎ invalidate();
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ invalidate();
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private class Bubble {
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: The first two lines are identical to the Eclipse version of `testBubbles()`.
    These lines declare the function and set up a `for` loop to run 100 times. At
    ➊, we keep the range of `x` values the same and set it to `600`, but you can make
    this larger if you know the resolution of your device. At ➋, we change the range
    for the random `y` value to `600` for the bubble’s vertical location.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行与 Eclipse 版本的 `testBubbles()` 相同。这些行声明了该函数，并设置了一个 `for` 循环，循环 100 次。在 ➊ 处，我们保持
    `x` 值的范围不变，设置为 `600`，但如果你知道设备的分辨率，可以将其设置得更大。在 ➋ 处，我们将随机 `y` 值的范围更改为 `600`，用于气泡的垂直位置。
- en: At ➌, we generate larger bubbles by adding a random number between `0` and `size`
    to the default value `size`. In this case, we’ll have bubbles ranging from 50
    to 100 pixels in diameter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们通过将 `0` 和 `size` 之间的随机数添加到默认值 `size` 中来生成更大的气泡。在这种情况下，我们将有直径从 50 到 100
    像素的气泡。
- en: At ➍, we create a new `Bubble` object using the three random values we just
    created and add it to the `bubbleList`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➍ 处，我们使用刚刚创建的三个随机值创建一个新的 `Bubble` 对象，并将其添加到 `bubbleList` 中。
- en: Finally, at ➎ we’re using a new function, `invalidate()`, which works similarly
    to the `repaint()` function in the desktop version of BubbleDraw. It tells Java
    that the screen needs to be updated, or refreshed. The `invalidate()` function
    clears the screen and calls the `onDraw()` method, which will draw all the bubbles
    in `bubbleList`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 ➎ 处我们使用了一个新函数 `invalidate()`，它的作用类似于桌面版 BubbleDraw 中的 `repaint()` 函数。它告诉
    Java 屏幕需要更新或刷新。`invalidate()` 函数会清空屏幕并调用 `onDraw()` 方法，后者会绘制 `bubbleList` 中的所有气泡。
- en: 'Now that we’ve defined the `testBubbles()` method, we just need to call that
    method from the `BubbleView()` constructor to try it out:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 `testBubbles()` 方法，我们只需要从 `BubbleView()` 构造函数中调用该方法进行尝试：
- en: public BubbleView(Context context, AttributeSet attributeSet) {
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: public BubbleView(Context context, AttributeSet attributeSet) {
- en: super(context, attributeSet);
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: super(context, attributeSet);
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: testBubbles();
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: testBubbles();
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Now, when the app loads, the `testBubbles()` method will be called to populate
    the `bubbleList` with 100 random bubbles.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当应用程序加载时，`testBubbles()` 方法将被调用，填充 `bubbleList`，其中包含 100 个随机气泡。
- en: '*Fixing the OnTouchListener Error*'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*修复 OnTouchListener 错误*'
- en: 'There’s only one issue left to fix before we can test our app: the `BubbleView`
    class is still underlined in red to let us know there’s a possible compile error.
    Mouse over the line `public class BubbleView`, and you’ll see an error that tells
    us we’re missing an `onTouch()` method for the `OnTouchListener`. In other words,
    this error reminds us that we’ve defined the `BubbleView` class as implementing
    an `OnTouchListener`, but we haven’t yet added an `onTouch()` method to handle
    touch events.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试应用程序之前，还有一个问题需要修复：`BubbleView` 类仍然被红色下划线标记，提示我们可能有编译错误。将鼠标悬停在 `public class
    BubbleView` 这一行上，你将看到一个错误，告诉我们 `OnTouchListener` 的 `onTouch()` 方法缺失。换句话说，这个错误提醒我们，尽管我们已将
    `BubbleView` 类定义为实现 `OnTouchListener`，但尚未添加 `onTouch()` 方法来处理触摸事件。
- en: To fix this error, mouse over it and click the red lightbulb warning icon. In
    the drop-down menu under the red lightbulb, click **Implement methods**. A pop-up
    window will appear, asking you to select which methods to implement, as shown
    in [Figure 11-4](ch11.xhtml#ch11fig4).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复此错误，将鼠标悬停在其上并点击红色灯泡警告图标。在红色灯泡下拉菜单中，点击**实现方法**。会弹出一个窗口，询问你选择要实现哪些方法，如 [图 11-4](ch11.xhtml#ch11fig4)
    所示。
- en: '![Image](../images/f0260-01.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0260-01.jpg)'
- en: '*Figure 11-4: Android Studio implements the onTouch() method to complete the
    OnTouchListener.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：Android Studio 实现了 onTouch() 方法以完成 OnTouchListener。*'
- en: 'Click **OK**, and Android Studio will insert an `onTouch()` method into your
    code to clear the error:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**，Android Studio 会在你的代码中插入一个 `onTouch()` 方法来清除错误：
- en: '@Override'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean onTouch(View view, MotionEvent motionEvent) {
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean onTouch(View view, MotionEvent motionEvent) {
- en: return false;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: return false;
- en: '}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: If the code Android Studio inserted doesn’t match what you see here, correct
    the parameter names in your code to match `view` and `motionEvent` as shown. This
    is the method that we’ll modify to handle touch events later, but for now let’s
    give our app a test run to see it draw 100 bubbles!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Android Studio 插入的代码与这里看到的内容不匹配，请在代码中更正参数名称，以匹配 `view` 和 `motionEvent`，如图所示。这是我们稍后将修改以处理触摸事件的方法，但现在让我们先测试一下应用程序，看看它是否能绘制
    100 个气泡！
- en: '*Running the BubbleDraw App*'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*运行 BubbleDraw 应用程序*'
- en: Press the green run button to test your app. In the Select Deployment Target
    window, choose your emulator or device, as we did in “[Running the App on the
    Android Emulator](ch4.xhtml#toc_lev70)” on [page 94](ch4.xhtml#page_94). I’m selecting
    my **Nexus 6P** emulator, shown in [Figure 11-5](ch11.xhtml#ch11fig5).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 按下绿色运行按钮来测试你的应用程序。在选择部署目标窗口中，选择你的模拟器或设备，正如我们在“[在Android模拟器上运行应用程序](ch4.xhtml#toc_lev70)”中第[94页](ch4.xhtml#page_94)所做的那样。我选择了我的**Nexus
    6P**模拟器，见[图11-5](ch11.xhtml#ch11fig5)。
- en: '![Image](../images/f0260-02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0260-02.jpg)'
- en: '*Figure 11-5: Press the run button to compile and run your app. Then select
    your emulator or device and click* ***OK***.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-5：按下运行按钮编译并运行你的应用程序。然后选择你的模拟器或设备并点击***确定***。*'
- en: Click **OK** to start your device and deploy the BubbleDraw app we’ve developed
    to this point. You should see bubbles fill the upper-left portion of your screen,
    as shown in [Figure 11-6](ch11.xhtml#ch11fig6). The bubbles appear in the upper
    left because we only generated x- and y-coordinates between 0 and 600 and most
    Android devices can display 1,000 or more pixels in each direction. Remember,
    in Java, the (0,0) coordinate is in the upper left.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**以启动你的设备并部署我们迄今为止开发的BubbleDraw应用程序。你应该看到气泡填满屏幕的左上角，正如[图11-6](ch11.xhtml#ch11fig6)所示。气泡出现在左上角，因为我们只生成了0到600之间的x和y坐标，而大多数安卓设备可以在每个方向上显示1000个以上的像素。记住，在Java中，(0,0)坐标位于左上角。
- en: '![Image](../images/f0261-01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0261-01.jpg)'
- en: '*Figure 11-6: A successful test run of the BubbleDraw app to this point; 100
    bubbles appear in the upper left of the screen.*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-6：到目前为止成功测试运行BubbleDraw应用程序；100个气泡出现在屏幕的左上角。*'
- en: Similar to the first test run of the desktop version of the app, there’s no
    animation or touch interaction, because we haven’t added them yet. But our app
    runs on the emulator and draws our bubbles correctly on the screen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与桌面版应用程序的第一次测试运行类似，当前没有动画或触摸交互，因为我们还没有添加它们。但是我们的应用程序在模拟器上运行，并正确地在屏幕上绘制了气泡。
- en: Next, let’s add animation to make the bubbles move. And then we’ll add the final
    touch—touch!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加动画，使气泡移动。然后我们将添加最后的点睛之笔——触摸！
- en: Using Threaded Animation and Multitasking in Java
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Java中使用线程动画和多任务处理
- en: The threading we’ll use to achieve smooth animation in the BubbleDraw Android
    app is just like the threading you’d add to any multitasking app in Java. We mentioned
    earlier that one advantage of using threading for animation is that it doesn’t
    tie up the processor while it waits between redrawing each frame. But threading
    can also be used in any other apps you develop that run multiple processes at
    once, such as apps that query a database or upload a file in the background. Using
    threading allows your app to do background tasks without freezing up the GUI interface
    while it waits for a process to finish.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在BubbleDraw安卓应用程序中使用的线程，与在任何Java多任务应用程序中添加的线程类似。我们之前提到过，使用线程进行动画的一个优点是，它不会在等待每一帧重新绘制时占用处理器。但是，线程也可以在你开发的任何其他应用程序中使用，这些应用程序一次运行多个进程，例如查询数据库或在后台上传文件的应用程序。使用线程可以让你的应用程序在等待进程完成时执行后台任务，而不会冻结GUI界面。
- en: Threading is especially important on devices such as phones and tablets that
    have limited processing power. Unresponsive apps are especially annoying, and
    threading will help prevent the BubbleDraw app from becoming one.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 线程在处理器能力有限的设备上，特别是在手机和平板电脑上，尤其重要。无响应的应用程序尤其令人烦恼，线程可以帮助防止BubbleDraw应用程序变得无响应。
- en: The `Handler h` object that we created earlier in the chapter is what lets us
    communicate with a thread. In this app, we’ll create a thread that executes the
    animation by updating the positions of all the bubbles. Then, we’ll use our handler,
    `h`, to tell the thread when to run. This will allow the handler and thread to
    function like our `Timer` animation in the previous chapters, but without hogging
    the CPU between frames.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面创建的`Handler h`对象可以让我们与线程进行通信。在这个应用程序中，我们将创建一个线程来执行动画，通过更新所有气泡的位置。然后，我们将使用我们的处理程序`h`来告诉线程何时运行。这将使处理程序和线程像我们在前几章中的`Timer`动画一样工作，但不会在每帧之间占用CPU。
- en: 'There are two ways to add threading to your applications in Java: by extending
    the `Thread` class or by implementing the `Runnable` interface. We’ll choose the
    `Runnable` approach.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以在Java应用程序中添加线程：通过扩展`Thread`类或实现`Runnable`接口。我们将选择`Runnable`方法。
- en: A class that implements `Runnable()` needs a `run()` method that tells the thread
    what to do when the thread is running. For BubbleDraw, we want the `run()` method
    to perform the animation by moving the bubbles and redrawing the screen.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Runnable()`的类需要一个`run()`方法，该方法告诉线程在运行时需要做什么。对于BubbleDraw，我们希望`run()`方法通过移动气泡并重新绘制屏幕来执行动画。
- en: 'Let’s create a `Runnable` object called `r` and place it right below the `BubbleView()`
    constructor:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`r`的`Runnable`对象，并将其放置在`BubbleView()`构造函数的正下方：
- en: public BubbleView(Context context, AttributeSet attributeSet) {
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: public BubbleView(Context context, AttributeSet attributeSet) {
- en: super(context, attributeSet);
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: super(context, attributeSet);
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: testBubbles();
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: testBubbles();
- en: '}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➊ private Runnable r = new Runnable() {
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ private Runnable r = new Runnable() {
- en: '@Override'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: ➋ public void run() {
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ public void run() {
- en: '}'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➌ };
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ };
- en: protected void onDraw(Canvas canvas) {
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onDraw(Canvas canvas) {
- en: As you type the second half of the declaration at ➊, a code completion suggestion
    will pop up to complete the new `Runnable()` object. Accept the `java.lang.Runnable`
    code completion, and Android Studio will automatically add the `public void run()`
    method stub for you ➋. Notice the semicolon after the closing brace for the `Runnable`
    object ➌—this is required because we’re defining `r` and assigning it to a new
    `Runnable` object all at the same time. The semicolon at ➌ actually completes
    the statement we started back at ➊. The automatic code completion doesn’t add
    the semicolon after the closing brace at ➌, though, so make sure you’ve added
    it to avoid a compiler error.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在➊处输入声明的后半部分时，代码补全建议会弹出，自动完成新的`Runnable()`对象。接受`java.lang.Runnable`的代码补全，Android
    Studio会自动为你添加`public void run()`方法的存根➋。注意，在`Runnable`对象的闭括号后面的分号➌是必须的，因为我们在同一时刻既定义了`r`又将其分配给了新的`Runnable`对象。➌处的分号实际上完成了我们在➊处开始的语句。自动代码补全不会在➌处添加分号，所以确保你已经添加了它，以避免编译错误。
- en: 'Now we need to add the code inside the `run()` method to tell Java what we
    want to happen every time our `Runnable` thread `r` is called:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`run()`方法中添加代码，告诉Java每次调用`Runnable`线程`r`时需要执行什么操作：
- en: private Runnable r = new Runnable() {
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: private Runnable r = new Runnable() {
- en: '@Override'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void run() {
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: public void run() {
- en: '➊ for(Bubble b : bubbleList)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ for(Bubble b : bubbleList)'
- en: ➋ b.update();
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ b.update();
- en: ➌ invalidate();
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ invalidate();
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: protected void onDraw(Canvas canvas) {
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onDraw(Canvas canvas) {
- en: 'for (Bubble b : bubbleList)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Bubble b : bubbleList)'
- en: b.draw(canvas);
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: b.draw(canvas);
- en: '}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: At ➊, we use the `for-each` statement again to loop through every `Bubble b`
    in `bubbleList`. At each iteration of the loop, we call b.update() ➋ to update
    the location of each bubble for the next frame of animation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们再次使用`for-each`语句来循环遍历`bubbleList`中的每个`Bubble b`。在每次循环迭代中，我们调用b.update()
    ➋来更新每个气泡的位置，为下一帧动画做准备。
- en: At ➌, we call the `invalidate()` function after the loop has finished running
    to clear the screen and tell Java to redraw the view by calling the `onDraw()`
    method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们在循环完成后调用`invalidate()`函数，以清除屏幕并通过调用`onDraw()`方法告诉Java重新绘制视图。
- en: 'The final step to adding thread-based animation is to connect the `Handler`
    `h` to the `Runnable` thread `r`. We’ll do this at the end of the `onDraw()` method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 添加基于线程的动画的最后一步是将`Handler` `h`与`Runnable`线程`r`连接起来。我们将在`onDraw()`方法的最后进行此操作：
- en: protected void onDraw(Canvas canvas) {
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onDraw(Canvas canvas) {
- en: 'for (Bubble b : bubbleList)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Bubble b : bubbleList)'
- en: b.draw(canvas);
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: b.draw(canvas);
- en: h.postDelayed(r, delay);
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: h.postDelayed(r, delay);
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The `postDelayed()` method sends a message from the handler to our thread `r`,
    telling it to run again after a delay of 33 milliseconds, the value of `delay`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`postDelayed()`方法将一条消息从处理程序发送到我们的线程`r`，告诉它在延迟33毫秒后再次运行，延迟值为`delay`。'
- en: Save these changes and run the app again. You’ll see the 100 test bubbles slowly
    spread out to fill the screen, as shown in [Figure 11-7](ch11.xhtml#ch11fig7).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这些更改并重新运行应用程序。你将看到100个测试气泡缓慢扩展以填满屏幕，如[图11-7](ch11.xhtml#ch11fig7)所示。
- en: Even at a rate of 30 frames per second, your fastest bubbles probably seem quite
    slow. This is because of the larger number of pixels on your Android device or
    emulator. You may recall that we set a `MAX_SPEED` in the `Bubble` class of just
    5 pixels per frame. The Nexus 6P phone that we’re emulating has a screen resolution
    of 1,440 × 2,560, meaning it would take more than 500 frames, or more than 15
    seconds, for the fastest bubbles to travel the full length of the screen.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在每秒 30 帧的情况下，你最快的气泡也可能看起来很慢。这是因为你的 Android 设备或模拟器上有更多的像素。你可能还记得我们在 `Bubble`
    类中设置的 `MAX_SPEED` 仅为每帧 5 像素。我们正在模拟的 Nexus 6P 手机的屏幕分辨率是 1,440 × 2,560，这意味着最快的气泡需要超过
    500 帧，或者超过 15 秒，才能穿越整个屏幕。
- en: '![Image](../images/f0263-01.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0263-01.jpg)'
- en: '*Figure 11-7: We have liftoff! Our bubbles are finally animated, courtesy of
    threaded animation.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-7：我们起飞了！我们的气泡终于有了动画效果，得益于线程动画。*'
- en: 'Let’s speed that up just a bit by changing `MAX_SPEED` to a higher value, like
    15 pixels per frame:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微加速一点，将 `MAX_SPEED` 改为更高的值，比如每帧 15 像素：
- en: private class Bubble {
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: private class Bubble {
- en: private int x;
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: private int x;
- en: private int y;
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: private int y;
- en: private int size;
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: private int size;
- en: private int color;
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: private int color;
- en: private int xspeed, yspeed;
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: private int xspeed, yspeed;
- en: private final int MAX_SPEED = 15;
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: private final int MAX_SPEED = 15;
- en: Save the file and run it again. Your bubbles will move around the screen more
    fluidly now. Feel free to increase or decrease the value to suit your taste.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并重新运行。现在，你的气泡将更加流畅地在屏幕上移动。你可以根据自己的喜好增大或减小数值。
- en: Now that we’ve implemented the animation, it’s time to add touch to make the
    app respond to the user.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了动画，是时候添加触摸响应，让应用程序能够响应用户操作了。
- en: Using Touch to Draw with Your Finger
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用触摸手势绘制气泡
- en: One feature that made the desktop BubbleDraw app so much fun was the fact that
    we could click and drag the mouse to draw bubbles anywhere we wanted. We’re going
    to bring that same level of enjoyment to the Android app, and then we’ll turn
    it up to 11 when we add multitouch!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使桌面版 BubbleDraw 应用如此有趣的一个特点是我们可以点击并拖动鼠标，在任何地方绘制气泡。我们将把这种乐趣带入 Android 应用程序中，然后在添加多点触控时让它变得更有趣！
- en: You’ve already seen where we need to add the touch event handler code—in the
    `onTouch()` function we added earlier.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到我们需要在哪里添加触摸事件处理代码——就是我们之前添加的 `onTouch()` 函数中。
- en: To handle touch events, first we need to determine the location of the user’s
    touch. Then we’ll add a bubble at that location.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理触摸事件，首先我们需要确定用户触摸的位置。然后，我们将在该位置添加一个气泡。
- en: 'To find out the x- and y-coordinates of the user’s touch, we can use `motionEvent.getX()`
    and `motionEvent.getY()`. Let’s add the full `onTouch()` method and then break
    it down:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出用户触摸的 x 和 y 坐标，我们可以使用 `motionEvent.getX()` 和 `motionEvent.getY()`。让我们添加完整的
    `onTouch()` 方法，并进行拆解：
- en: public boolean onTouch(View view, MotionEvent motionEvent) {
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean onTouch(View view, MotionEvent motionEvent) {
- en: ➊ int x = (int) motionEvent.getX();
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ int x = (int) motionEvent.getX();
- en: ➋ int y = (int) motionEvent.getY();
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ int y = (int) motionEvent.getY();
- en: ➌ int s = rand.nextInt(size) + size;
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ int s = rand.nextInt(size) + size;
- en: ➍ bubbleList.add( new Bubble(x, y, s) );
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ bubbleList.add( new Bubble(x, y, s) );
- en: ➎ return true;
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ return true;
- en: '}'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: At ➊, we get the x-location of the user’s touch with the method `motionEvent.getX()`.
    Notice, however, that we have to cast the value to an integer—the `motionEvent.getX()`
    returns a floating-point value in Android, so we cast it with `(int)`. The y-location
    ➋ works the same way, and at ➌, we generate a random size as we did in `testBubbles()`
    and store it in `s`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们通过 `motionEvent.getX()` 方法获取用户触摸的 x 坐标。然而，请注意，我们需要将该值转换为整数——因为 `motionEvent.getX()`
    在 Android 中返回的是浮动点值，所以我们使用 `(int)` 进行转换。y 坐标 ➋ 以相同方式处理，在 ➌ 处，我们像在 `testBubbles()`
    中一样生成一个随机大小并将其存储在 `s` 中。
- en: At ➍, we create a `Bubble` object with the given `x`, `y`, and `s` values and
    add it to `bubbleList`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➍ 处，我们创建一个 `Bubble` 对象，并使用给定的 `x`、`y` 和 `s` 值将其添加到 `bubbleList` 中。
- en: The last line, at ➎, requires a bit of explanation. Notice that the return type
    of the `onTouch()` method is a `boolean`. This means that the `onTouch()` method
    must return a `true` or `false` value. In Android, the `onTouch()` method should
    return `true` if you’ve fully handled the touch event. If you want Android to
    handle a touch event, such as scrolling or zooming, after your `onTouch()` event
    handler is finished, return `false`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码，在 ➎ 处，需要做一点解释。请注意，`onTouch()` 方法的返回类型是 `boolean`。这意味着 `onTouch()` 方法必须返回一个
    `true` 或 `false` 值。在 Android 中，如果你已经完全处理了触摸事件，`onTouch()` 方法应返回 `true`。如果你希望 Android
    在你的 `onTouch()` 事件处理完成后继续处理触摸事件，例如滚动或缩放，请返回 `false`。
- en: For the drawing app, we don’t need Android to scroll the screen when the user
    swipes—we’ve handled the touch event completely for our app by adding a bubble
    where the user touched, so we return the value `true`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绘图应用，我们不需要 Android 在用户滑动时滚动屏幕——我们通过在用户触摸的位置添加气泡，完全处理了触摸事件，因此返回值为`true`。
- en: 'The last step is similar to the steps for the mouse listener in the desktop
    versions of BubbleDraw: we need to add the listener in the constructor. Scroll
    up to the `BubbleView()` constructor, comment out the `testBubbles()` function,
    and add the line of code shown here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步类似于桌面版 BubbleDraw 中鼠标监听器的步骤：我们需要在构造函数中添加监听器。向上滚动到`BubbleView()`构造函数，注释掉`testBubbles()`函数，并添加如下代码：
- en: public BubbleView(Context context, AttributeSet attributeSet) {
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: public BubbleView(Context context, AttributeSet attributeSet) {
- en: super(context, attributeSet);
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: super(context, attributeSet);
- en: bubbleList = new ArrayList<Bubble>();
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList = new ArrayList<Bubble>();
- en: // testBubbles();
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: // testBubbles();
- en: setOnTouchListener(this);
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: setOnTouchListener(this);
- en: '}'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: We comment out the call to `testBubbles()` because we don’t need the 100 test
    bubbles anymore. We’re going to add bubbles by touching the screen on our Android
    device or by clicking and dragging the mouse to simulate a touch on the Android
    emulator. The `setOnTouchListener(this)` statement adds a listener for touch events,
    telling Java that `this`, an object of the `BubbleView` class, will handle the
    touch events.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注释掉了对`testBubbles()`的调用，因为我们不再需要100个测试气泡了。我们将通过在 Android 设备上触摸屏幕或在 Android
    模拟器上点击并拖动鼠标来模拟触摸。`setOnTouchListener(this)`语句添加了一个触摸事件监听器，告诉 Java `this`，即`BubbleView`类的一个对象，将处理触摸事件。
- en: With these changes, we’re ready to try out our app. Save your code and run the
    app on your emulator. Click and drag on the emulator window to simulate dragging
    your finger across the screen. You’ll see bubbles flow from the location you touch,
    as shown in [Figure 11-8](ch11.xhtml#ch11fig8).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们准备好尝试我们的应用了。保存你的代码并在模拟器上运行应用。在模拟器窗口点击并拖动，以模拟手指在屏幕上的滑动。你将看到气泡从你触摸的位置流出，如[图11-8](ch11.xhtml#ch11fig8)所示。
- en: You can also run this on your physical Android device. We’ll review how to do
    that in the next section, after adding the ability to handle multiple touch events
    on the screen at the same time.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在你的物理 Android 设备上运行此应用。我们将在下一部分中回顾如何操作，在那之前，我们需要添加处理多个触摸事件的能力。
- en: '![Image](../images/f0265-01.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0265-01.jpg)'
- en: '*Figure 11-8: Click and drag the mouse to simulate a one-finger touch on the
    emulator, and a stream of bubbles will flow out.*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-8：点击并拖动鼠标模拟模拟器上的单指触摸，气泡会流出。*'
- en: '*Using Multitouch to Draw with 10 Fingers at a Time!*'
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用多点触控同时用10根手指绘图！*'
- en: You may have played an app that makes use of multitouch, like a two-player game
    in which you control objects on one side of the screen with one or more fingers,
    while your friend controls objects on the other side of the screen. If you have,
    you understand the awesome power that multitouch brings to apps and games.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能玩过使用多点触控的应用，比如一款双人游戏，其中你用一根或多根手指控制屏幕一侧的物体，而你的朋友控制屏幕另一侧的物体。如果你玩过，你就会理解多点触控给应用和游戏带来的强大功能。
- en: The great news is that the code to handle multiple touch events in Android is
    almost as simple as the code to handle a single touch! In fact, we’ll just add
    a statement and modify a couple of lines in `onTouch()`, and our app will handle
    multitouch events.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，处理 Android 中的多点触控事件的代码几乎和处理单点触控事件的代码一样简单！事实上，我们只需要添加一行语句，并修改`onTouch()`中的几行代码，我们的应用就能处理多点触控事件。
- en: The method that tells us how many touch events are happening at the same time
    is `getPointerCount()`. It returns how many *pointers*—touch events or fingers—are
    on the screen in the current `MotionEvent`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我们当前有多少个触摸事件正在同时发生的方法是`getPointerCount()`。它返回当前`MotionEvent`中屏幕上有多少个*指针*——触摸事件或手指。
- en: 'We can add a `for` loop to add bubbles for every pointer in the current touch
    event:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个`for`循环，为当前触摸事件中的每个指针添加气泡：
- en: public boolean onTouch(View view, MotionEvent motionEvent) {
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean onTouch(View view, MotionEvent motionEvent) {
- en: ➊ for (int n = 0; n < motionEvent.getPointerCount(); n++) {
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ for (int n = 0; n < motionEvent.getPointerCount(); n++) {
- en: ➋ int x = (int) motionEvent.getX(n);
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ int x = (int) motionEvent.getX(n);
- en: ➌ int y = (int) motionEvent.getY(n);
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ int y = (int) motionEvent.getY(n);
- en: int s = rand.nextInt(size) + size;
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: int s = rand.nextInt(size) + size;
- en: bubbleList.add(new Bubble(x, y, s));
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: bubbleList.add(new Bubble(x, y, s));
- en: ➍ }
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ }
- en: return true;
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: return true;
- en: '}'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: At ➊, we add a `for` loop that increments the variable `n` from `0` up to the
    number of pointers in the current touch event. The function `motionEvent .getPointerCount()`
    returns the number of pointers. If there is only one touch event, `getPointerCount()`
    will return `1`, and the loop will run only once, for `n = 0`. For two touch events,
    `n` will get the values `0` and `1`, and so on.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 步骤中，我们添加了一个 `for` 循环，将变量 `n` 从 `0` 递增到当前触摸事件中的指针数量。函数 `motionEvent.getPointerCount()`
    返回指针的数量。如果只有一个触摸事件，`getPointerCount()` 会返回 `1`，此时循环只会执行一次，`n = 0`。如果有两个触摸事件，`n`
    将分别为 `0` 和 `1`，以此类推。
- en: At ➋, we modify the `motionEvent.getX()` method by inserting an `n` in the parentheses
    after `getX()`. Pointers are numbered in touch events, so passing the variable
    `n` as an argument to `motionEvent.getX()` will get the x-location of the *n*th
    touch pointer in the current touch event. So, `getX(0)` will return the x-location
    of the first touch, `getX(1)` will return the x-coordinate of the second touch,
    and so on. At ➌, we do the same for the y-coordinates of each touch with `getY(n)`.
    Finally, don’t forget to close the brace of the `for` loop at ➍.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 步骤中，我们通过在 `getX()` 后的括号内插入 `n` 来修改 `motionEvent.getX()` 方法。触摸事件中的指针是有编号的，因此将变量
    `n` 作为参数传递给 `motionEvent.getX()` 会获取当前触摸事件中第 *n* 个触摸指针的 x 坐标。所以，`getX(0)` 会返回第一个触摸点的
    x 坐标，`getX(1)` 会返回第二个触摸点的 x 坐标，依此类推。在 ➌ 步骤中，我们用 `getY(n)` 对每个触摸点的 y 坐标做同样的操作。最后，别忘了在
    ➍ 步骤中关闭 `for` 循环的括号。
- en: That’s all it takes! Java and Android make processing multitouch events easy.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！Java 和 Android 让处理多点触控事件变得很容易。
- en: '*Testing Multitouch Events on an Android Device*'
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在 Android 设备上测试多点触控事件*'
- en: Save your code so that we can run the app again. This time, we’re going to run
    the app on a physical Android device. Unfortunately, we can’t easily simulate
    multitouch events with a single mouse on the Android emulator, so you’ll need
    to run the app on a real phone or tablet.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的代码，这样我们就可以再次运行应用。这一次，我们将把应用运行在一台真实的 Android 设备上。不幸的是，我们无法在 Android 模拟器中通过单一鼠标轻松模拟多点触控事件，所以你需要在一台真实的手机或平板上运行该应用。
- en: First, plug your Android device into the computer running Android Studio using
    a USB cable. Allow USB debugging from the computer on the device (see “[Running
    the App on a Real Android Device](ch4.xhtml#toc_lev71)” on [page 100](ch4.xhtml#page_100)).
    Close the BubbleDraw app in your emulator, if it’s running. Then, press the run
    button or go to **Run** ▸ **Run ‘app’**.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过 USB 数据线将你的 Android 设备连接到运行 Android Studio 的电脑上。在设备上允许 USB 调试（请参见 “[在真实
    Android 设备上运行应用](ch4.xhtml#toc_lev71)” 在 [第 100 页](ch4.xhtml#page_100)）。如果模拟器中正在运行
    BubbleDraw 应用，关闭它。然后，点击运行按钮或选择 **Run** ▸ **Run ‘app’**。
- en: In the Select Deployment Target window, find and select your device—mine is
    the Asus Nexus 7—and click **OK**. Android Studio will recompile the app and deploy
    it to your device.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择部署目标窗口中，找到并选择你的设备——我的设备是 Asus Nexus 7——然后点击 **OK**。Android Studio 会重新编译应用并将其部署到你的设备上。
- en: When the app starts, it looks like a black screen with “BubbleDraw” in the title
    bar. Once you place one or more fingers on the screen, though, things get much
    more interesting, as shown in [Figure 11-9](ch11.xhtml#ch11fig9).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用启动时，屏幕看起来像是一个黑色屏幕，标题栏上显示“BubbleDraw”。不过，一旦你将一根或多根手指放在屏幕上，情况就变得更有趣了，正如 [图
    11-9](ch11.xhtml#ch11fig9) 所示。
- en: '![Image](../images/f0267-01.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0267-01.jpg)'
- en: '*Figure 11-9: Touching the screen of my Android device with two (left), three
    (center), or four fingers (right) creates multiple streams of colorful, bouncing
    bubbles.*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-9：用两根（左）、三根（中）或四根手指（右）触摸我的 Android 设备屏幕，会创建多个彩色、跳跃的气泡流。*'
- en: As you drag your fingers across the screen, bubbles seem to flow from your fingertips,
    whether you use one finger, two, five, or even ten!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用手指在屏幕上拖动时，无论是用一个手指、两个手指、五个手指，还是十个手指，气泡似乎都会从你的指尖流出！
- en: 'There’s one other cool feature we didn’t mention yet: to clear the screen,
    just turn your device sideways (make sure your device’s orientation lock is set
    to Auto-rotate, not Portrait view). The change in orientation forces the app to
    reinitialize the `BubbleView`, which resets the `bubbleList` and clears the screen.
    It’s a cool effect, and it makes the app feel even more tactile and interactive.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个很酷的功能我们还没提到：要清除屏幕，只需将设备横向旋转（确保设备的方向锁定设置为自动旋转，而不是竖屏模式）。方向的变化会强制应用重新初始化 `BubbleView`，这将重置
    `bubbleList` 并清除屏幕。这是一个酷炫的效果，它让应用感觉更加触感丰富和互动。
- en: There’s just one more customization we’ll make to our final BubbleDraw app.
    We’ll replace the default Android app icon with an icon of our own.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对最终的 BubbleDraw 应用进行最后一次自定义：我们将用我们自己的图标替换默认的 Android 应用图标。
- en: Changing the App Launcher Icon
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改应用启动图标
- en: All our apps so far have used the default Android app launcher icons, which
    feature Android’s friendly green droid. But what if you wanted to use your own,
    custom icon for the BubbleDraw app—for example, your company’s logo or a screenshot
    from the app like the one shown in [Figure 11-10](ch11.xhtml#ch11fig10)?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有应用都使用了默认的 Android 应用启动图标，图标上展示了 Android 的友好绿机器人。但如果你想为 BubbleDraw
    应用使用你自己的自定义图标，例如你公司的标志或像 [图 11-10](ch11.xhtml#ch11fig10) 所示的应用截图，该怎么办呢？
- en: In order to give your app its own custom icon, you’ll need to create your own
    *ic_launcher.png* file, paste it into the *app* ▸ *src* ▸ *main* ▸ *res* ▸ *drawable*
    folder, and then modify the *AndroidManifest.xml* file to use your new icon as
    the app launcher icon for your app.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你的应用程序添加自定义图标，你需要创建自己的 *ic_launcher.png* 文件，将其粘贴到 *app* ▸ *src* ▸ *main*
    ▸ *res* ▸ *drawable* 文件夹中，然后修改 *AndroidManifest.xml* 文件，使用你新创建的图标作为应用程序的启动图标。
- en: '![Image](../images/f0268-01.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0268-01.jpg)'
- en: '*Figure 11-10: A custom image cut from a BubbleDraw screenshot*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：从 BubbleDraw 截图中裁剪的自定义图像*'
- en: '*Creating a Custom App Icon*'
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*创建自定义应用图标*'
- en: By default, Android names the launcher icon for your app *ic_launcher.png*.
    If you open the *app* ▸ *src* ▸ *main* ▸ *res* ▸ *mipmap* folder, you’ll see several
    *ic_launcher.png* files of various sizes—stored inside folders labeled *mipmap
    _mdpi, mipmap_xxhdpi*, and so on—that correlate to the various screen sizes of
    different phones and tablets.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Android 会将应用的启动图标命名为 *ic_launcher.png*。如果你打开 *app* ▸ *src* ▸ *main* ▸
    *res* ▸ *mipmap* 文件夹，你会看到几个不同大小的 *ic_launcher.png* 文件——这些文件存储在名为 *mipmap_mdpi,
    mipmap_xxhdpi* 等文件夹中——这些文件与不同手机和平板电脑的各种屏幕尺寸相对应。
- en: We’ll call our new image *ic_launcher.png* as well, just for convenience. Using
    your favorite image-editing program, create a PNG file with the image you want
    to use for your app launcher icon. (The site *[http://www.gimp.org/](http://www.gimp.org/)*
    has a great, free image editor, and *[https://www.pixlr.com/editor/](https://www.pixlr.com/editor/)*
    is also free over the web.) It’s best to use a square image, but Android can also
    work with files that aren’t perfectly square. My image measures 156 × 156 pixels,
    but anything between 64 × 64 and 256 × 256 should work fine.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了方便也将新图像命名为 *ic_launcher.png*。使用你喜欢的图像编辑程序，创建一个你想用作应用启动图标的 PNG 文件。（网站 *[http://www.gimp.org/](http://www.gimp.org/)*
    提供了一个很棒的免费图像编辑器，而 *[https://www.pixlr.com/editor/](https://www.pixlr.com/editor/)*
    也可以在线免费使用。）最好使用正方形图像，但 Android 也可以处理不完全正方形的文件。我的图像尺寸为 156 × 156 像素，但任何介于 64 ×
    64 和 256 × 256 之间的尺寸都应该可以正常工作。
- en: '**NOTE**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you want to use a screenshot of the app like I did, taking a screenshot
    is easy: press and hold your Android device’s sleep/wake button and the volume-down
    button at the same time until the screen flashes to let you know the image is
    saved. In your Photos app, find Screenshots, and you should see the image. You
    can edit the image to be 256 × 256 pixels or smaller by emailing it to yourself
    so you can access it on your regular computer, or by cropping the image directly
    on your Android device and then emailing it to yourself.*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想像我一样使用应用程序的截图，截屏非常简单：同时按住你的 Android 设备的休眠/唤醒按钮和音量减小按钮，直到屏幕闪烁，表示图像已保存。在你的照片应用程序中，找到“截图”文件夹，你应该能看到该图像。你可以通过给自己发送电子邮件，将图像编辑为
    256 × 256 像素或更小，或者直接在 Android 设备上裁剪图像，然后将其通过电子邮件发送给自己。*'
- en: Save or export your file from the image editor as *ic_launcher.png*. In the
    next step, we’ll copy this image and paste it into the BubbleDraw project in Android
    Studio.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 从图像编辑器中保存或导出你的文件为 *ic_launcher.png*。在下一步中，我们将复制这个图像并将其粘贴到 Android Studio 中的
    BubbleDraw 项目中。
- en: '*Adding the Custom Icon to Your App*'
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*将自定义图标添加到你的应用程序*'
- en: Once you’ve created your own *ic_launcher.png* app icon file, open the folder
    you saved it into and copy the file.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了自己的 *ic_launcher.png* 应用图标文件，打开你保存它的文件夹并复制该文件。
- en: In Android Studio, under the Project Explorer pane for your BubbleDraw app,
    find the *app* ▸ *res* ▸ *drawable* or *app* ▸ *src* ▸ *main* ▸ *res* ▸  *drawable*
    folder and paste your new *ic_launcher.png* image into it, as shown in [Figure
    11-11](ch11.xhtml#ch11fig11).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，在你的 BubbleDraw 应用的项目资源管理器窗格下，找到 *app* ▸ *res* ▸ *drawable*
    或 *app* ▸ *src* ▸ *main* ▸ *res* ▸ *drawable* 文件夹，将你的新 *ic_launcher.png* 图像粘贴到其中，如
    [图 11-11](ch11.xhtml#ch11fig11) 所示。
- en: '![Image](../images/f0269-01.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0269-01.jpg)'
- en: '*Figure 11-11: Paste your new, custom app icon into the* app ▸ src ▸ main ▸
    res ▸ drawable *folder.*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-11：将你新的自定义应用图标粘贴到* app ▸ src ▸ main ▸ res ▸ drawable *文件夹中。*'
- en: You’ll see an Android Copy window verifying the location of the file. Click
    **OK**.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个 Android 复制窗口，验证文件的位置。点击 **OK**。
- en: When the icon copies into your *drawable* folder, you’ll be able to open the
    folder and double-click *ic_launcher.png* to preview it in Android Studio.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当图标复制到你的 *drawable* 文件夹中时，你可以打开该文件夹并双击 *ic_launcher.png* 在 Android Studio 中预览它。
- en: We now have the new icon we created in the BubbleDraw project’s structure, so
    we can tell Android to use this image as the app icon.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在 BubbleDraw 项目的结构中创建了新图标，因此我们可以告诉 Android 使用这个图像作为应用图标。
- en: '*Displaying Your New Icon*'
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*显示你的新图标*'
- en: For this last step, we’ll edit the *AndroidManifest.xml* file for your app.
    The *AndroidManifest.xml* file describes some of the basic structure, properties,
    and functionality of your app to the Android operating system.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一步，我们将编辑你应用的 *AndroidManifest.xml* 文件。*AndroidManifest.xml* 文件描述了应用的一些基本结构、属性和功能，并将这些信息提供给
    Android 操作系统。
- en: 'Under *app* ▸ *src* ▸ *main* (or *app* ▸ *manifests*), open *AndroidManifest.xml*.
    Near the top of the file, find the entry for `android:icon`, and change it to
    the new file you just placed in the *drawable* folder:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *app* ▸ *src* ▸ *main*（或 *app* ▸ *manifests*）下，打开 *AndroidManifest.xml*。在文件的顶部，找到
    `android:icon` 的条目，并将其更改为你刚刚放入 *drawable* 文件夹中的新文件：
- en: <application
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <application
- en: android:allowBackup="true"
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: android:allowBackup="true"
- en: android:icon="@drawable/ic_launcher"
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: android:icon="@drawable/ic_launcher"
- en: We’re telling Android to look inside this project’s *drawable* folder and find
    an image file named *ic_launcher*. We leave the *.png* extension off in the manifest.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉 Android 在这个项目的 *drawable* 文件夹中查找一个名为 *ic_launcher* 的图像文件。在清单文件中，我们省略了 *.png*
    后缀。
- en: Now, save the *AndroidManifest.xml* file and press the run button to compile
    and deploy the app with the new icon. Once the app updates on your emulator or
    Android device, you’ll see the new icon for BubbleDraw, as shown in [Figure 11-12](ch11.xhtml#ch11fig12).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存 *AndroidManifest.xml* 文件并按下运行按钮，以编译并部署带有新图标的应用程序。一旦应用程序在你的模拟器或 Android
    设备上更新，你就会看到 BubbleDraw 的新图标，如[图 11-12](ch11.xhtml#ch11fig12)所示。
- en: The custom PNG image we created is now the icon for the app in Android!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的自定义 PNG 图像现在是 Android 应用程序的图标！
- en: '![Image](../images/f0270-01.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0270-01.jpg)'
- en: '*Figure 11-12: We’ve customized the app launcher icon for the BubbleDraw app.*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-12：我们已定制 BubbleDraw 应用程序的启动图标。*'
- en: '*Changing the App Name*'
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*更改应用名称*'
- en: You can also customize the app’s name as it appears on both the app icon and
    the title bar inside the app. In your Project Explorer tab on the left, under
    *app* ▸ *src* ▸ *main* ▸ *res* ▸ *values*, open *strings.xml*. The *strings.xml*
    file stores the `app_name` string that’s used both on the launcher icon, as shown
    in [Figure 11-12](ch11.xhtml#ch11fig12), and in the title bar of the app while
    it’s running.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以定制应用程序名称，它将出现在应用图标和应用内的标题栏中。在左侧的项目资源管理器标签中，找到 *app* ▸ *src* ▸ *main* ▸ *res*
    ▸ *values*，然后打开 *strings.xml*。*strings.xml* 文件存储了 `app_name` 字符串，该字符串既用于启动图标，如[图
    11-12](ch11.xhtml#ch11fig12)所示，也用于应用运行时的标题栏。
- en: 'Since BubbleDraw without a space between the words is a bit strange, we’ll
    add a space between the words in the line of XML that defines the `app_name` variable
    in *strings.xml*:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 BubbleDraw 中单词之间没有空格显得有些奇怪，我们将在定义 `app_name` 变量的 *strings.xml* 文件中的 XML 行中添加空格：
- en: <resources>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <resources>
- en: <string name="app_name">Bubble Draw</string>
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: <string name="app_name">Bubble Draw</string>
- en: </resources>
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: </resources>
- en: Of course, you can make this app name anything you want, like *Your Name*`\'s
    Bubble Draw App`, but only about 11 or 12 characters will fit below the app icon,
    so you’d see something like *Your Name*`'s...` on your home screen. You also would
    need to escape any special characters in the app name, including the single quote,
    with the backslash character.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将应用名称设置为任何你想要的，比如 *Your Name*`\'s Bubble Draw App`，但大约只有 11 或 12 个字符能够适应图标下方的空间，因此你会在主屏幕上看到类似
    *Your Name*`'s...` 的效果。你还需要使用反斜杠字符转义应用名称中的任何特殊字符，包括单引号。
- en: Now that you know how, go back and customize your Hi-Lo guessing game and Secret
    Messages apps with their own icons as well. Keep refining your apps and trying
    new things—it’s the best way to keep learning as you code.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道该怎么做了，回去定制你的 Hi-Lo 猜数字游戏和秘密信息应用程序，并为它们添加自己的图标。不断优化你的应用并尝试新事物——这是在编码过程中保持学习的最佳方式。
- en: What You Learned
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你所学到的
- en: You’ve come a long way since [Chapter 1](ch1.xhtml#ch1). After building three
    complete mobile and desktop apps, you’ve gained significant computing skills and
    put those newfound abilities to use. Perhaps most importantly of all, you learned
    how to improve the apps step-by-step by adding more and more functionality until
    each app does exactly what you want it to do.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第1章](ch1.xhtml#ch1)开始，你已经走过了很长的路程。在构建了三款完整的移动和桌面应用之后，你已经获得了显著的计算技能，并且将这些新获得的能力付诸实践。也许最重要的是，你学会了如何通过一步步添加更多功能来逐步改进应用，直到每个应用都能完全按照你的需求运行。
- en: 'In this chapter, you reinforced several skills and added the following abilities
    to your coding tool chest:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你巩固了几个技能，并将以下能力添加到了你的编码工具箱中：
- en: • Drawing graphics in Android
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: • 在 Android 中绘制图形
- en: • Adding a new class to an Android Studio project
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: • 向 Android Studio 项目中添加新类
- en: • Setting up variables and importing classes
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: • 设置变量并导入类
- en: • Building a class constructor from scratch
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: • 从头开始构建类构造函数
- en: • Converting Java AWT graphics to Android `Canvas` graphics
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: • 将 Java AWT 图形转换为 Android `Canvas` 图形
- en: • Drawing on an `ImageView` using the `onDraw()` method
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 `onDraw()` 方法在 `ImageView` 上绘制
- en: • Creating a `Runnable` object to implement threading in Java
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: • 创建一个 `Runnable` 对象来实现 Java 中的线程
- en: • Using a `Handler` to communicate with a separate thread in Java
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 `Handler` 与 Java 中的单独线程进行通信
- en: • Using threading to improve animation efficiency
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用线程来提高动画效率
- en: • Handling multiple touch events and using `MotionEvent` methods to locate touch
    events onscreen
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: • 处理多个触摸事件，并使用 `MotionEvent` 方法来定位屏幕上的触摸事件
- en: • Customizing the app launcher icon and app name
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: • 自定义应用启动器图标和应用名称
- en: Programming Challenges
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Try these programming challenge exercises to review and practice what you’ve
    learned, as well as to expand your programming skills. Visit the book’s website
    at *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    for sample solutions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尝试这些编程挑战练习来回顾和实践你所学到的内容，并扩展你的编程技能。访问本书的网站 *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    获取示例解决方案。
- en: '*#1: Combining One-Finger and Multitouch Events, v1.0*'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#1: 结合单指和多点触控事件，v1.0*'
- en: In this chapter, we learned to handle a single-touch event and multiple-touch
    events. In this challenge, your task is to tell the difference between a single-touch
    and a multitouch event. You’ll change the logic inside the `onTouch()` method
    to draw bigger bubbles when one finger is touching the screen and smaller bubbles
    when more fingers touch the screen.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何处理单点触控事件和多点触控事件。在这个挑战中，你的任务是区分单点触控和多点触控事件。你将改变 `onTouch()` 方法中的逻辑，当一个手指触摸屏幕时绘制更大的气泡，而当多个手指触摸屏幕时绘制更小的气泡。
- en: Remember, you can find out the number of touch events using the `getPointerCount()`
    on your `MotionEvent` object inside the `onTouch()` method.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以通过在 `onTouch()` 方法内的 `MotionEvent` 对象上使用 `getPointerCount()` 来获取触摸事件的数量。
- en: For extra practice, code your app so that more fingers will result in smaller
    and smaller bubbles.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了额外练习，编写代码使得更多的手指触摸时，气泡会变得越来越小。
- en: '*#2: Combining One-Finger and Multitouch Events, v2.0*'
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#2: 结合单指和多点触控事件，v2.0*'
- en: 'Once you’ve mastered Programming Challenge #1, give this one a try. Modify
    both the `Bubble` class and the `onTouch()` listener to group bubbles when you
    draw with one finger by giving them all the same `xspeed` and `yspeed` values,
    but still allow multitouch to blow bubbles in every direction.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '当你掌握了编程挑战 #1 后，可以尝试这个。修改 `Bubble` 类和 `onTouch()` 监听器，在单指绘制时将气泡组合在一起，给它们相同的
    `xspeed` 和 `yspeed` 值，但仍允许多点触控使气泡朝任意方向膨胀。'
- en: 'This will require changes to the `onTouch()` listener similar to those in Programming
    Challenge #1\. But, to group the bubbles, you’ll need a way to draw some bubbles
    with fixed speeds and other bubbles with random speeds. The bubbles drawn during
    a single-touch event should all move at the same fixed speed so that they appear
    grouped, and bubbles drawn with multitouch should continue to be assigned random
    speed values.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '这将需要对 `onTouch()` 监听器进行类似于编程挑战 #1 中的更改。但是，为了将气泡分组，你需要一种方法来绘制一些具有固定速度的气泡，而其他气泡则具有随机速度。在单点触控事件期间绘制的气泡应该以相同的固定速度移动，以便它们看起来是组合在一起的，而多点触控绘制的气泡应继续分配随机速度值。'
- en: To accomplish this, you can create a second `Bubble()` constructor. It will
    be similar to the `Bubble(x, y, size)` constructor that we created for the `Bubble`
    class originally, but it will have a different number of parameters.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你可以创建第二个`Bubble()`构造函数。它将类似于我们最初为`Bubble`类创建的`Bubble(x, y, size)`构造函数，但它会有不同数量的参数。
- en: For example, you could create a second `Bubble()` constructor that takes the
    five parameters `x`, `y`, `size`, `xspeed`, and `yspeed`. Then, you could use
    that constructor whenever the user touches the screen with just one finger to
    give all the bubbles the same speed values. You’d use the original constructor
    whenever the user touches more than one finger to the screen so the bubbles flow
    in random directions.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建一个第二个`Bubble()`构造函数，接受五个参数`x`、`y`、`size`、`xspeed`和`yspeed`。然后，你可以在用户只用一个手指触摸屏幕时使用这个构造函数，给所有气泡相同的速度值。当用户用两个以上的手指触摸屏幕时，你则使用原始构造函数，这样气泡就会朝随机方向流动。
