- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: SERVER-SIDE REQUEST FORGERY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端请求伪造（SSRF）**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: A *server-side request forgery (SSRF)* vulnerability allows an attacker to make
    a server perform unintended network requests. Like a cross-site request forgery
    (CSRF) vulnerability, an SSRF abuses another system to perform malicious actions.
    While a CSRF exploits another user, an SSRF exploits a targeted application server.
    As with CSRFs, SSRF vulnerabilities can vary in impact and execution methods.
    However, just because you can make a targeted server send requests to other arbitrary
    servers doesn’t mean the targeted application is vulnerable. The application may
    intentionally allow this behavior. For this reason, it’s important to understand
    how to demonstrate impact when you’ve found a potential SSRF.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务器端请求伪造（SSRF）* 漏洞使攻击者能够让服务器执行未预期的网络请求。与跨站请求伪造（CSRF）漏洞类似，SSRF 利用另一个系统执行恶意行为。CSRF
    是利用另一个用户，而 SSRF 则是利用目标应用服务器。与 CSRF 一样，SSRF 漏洞的影响和执行方式可能有所不同。然而，仅仅因为你能够让目标服务器向其他任意服务器发送请求，并不意味着目标应用程序本身存在漏洞。该应用程序可能故意允许这种行为。因此，理解如何在发现潜在
    SSRF 时展示影响非常重要。'
- en: '**Demonstrating the Impact of Server-Side Request Forgery**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**展示服务器端请求伪造的影响**'
- en: Depending on how a website is organized, a server vulnerable to SSRF might make
    an HTTP request to an internal network or to external addresses. The vulnerable
    server’s ability to make requests determines what you can do with the SSRF.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据网站的组织结构，容易受到 SSRF 攻击的服务器可能会向内部网络或外部地址发出 HTTP 请求。受影响服务器发出请求的能力决定了你可以通过 SSRF
    做些什么。
- en: 'Some larger websites have firewalls that prohibit external internet traffic
    from accessing internal servers: for example, the website will have a limited
    number of publicly facing servers that receive HTTP requests from visitors and
    send requests on to other servers that are publicly inaccessible. A common example
    is a database server, which is often inaccessible to the internet. When you’re
    logging into a site that communicates with a database server, you might submit
    a username and password through a regular web form. The website would receive
    your HTTP request and perform its own request to the database server using your
    credentials. Then the database server would respond to the web application server,
    and the web application server would relay the information to you. During this
    process, you’re often not aware that the remote database server exists, and you
    should have no direct access to the database.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较大的网站设置了防火墙，禁止外部互联网流量访问内部服务器。例如，网站通常会设置有限数量的对外开放的服务器，这些服务器接收来自访问者的 HTTP 请求，并将请求转发到其他无法公开访问的服务器。一个常见的例子是数据库服务器，通常无法直接访问互联网。当你登录与数据库服务器通信的网站时，你可能会通过常规的网页表单提交用户名和密码。网站接收你的
    HTTP 请求后，会使用你的凭据向数据库服务器发出请求。然后，数据库服务器会向 Web 应用服务器响应信息，Web 应用服务器会将这些信息转发给你。在这个过程中，你通常并不意识到远程数据库服务器的存在，且不应该直接访问该数据库。
- en: Vulnerable servers that allow attacker control of requests to internal servers
    could expose private information. For example, if an SSRF existed in the preceding
    database example, it might allow an attacker to send requests to the database
    server and retrieve information they shouldn’t have access to. SSRF vulnerabilities
    provide attackers access to a broader network to target.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 允许攻击者控制请求到内部服务器的易受攻击服务器可能会暴露私人信息。例如，如果在前述的数据库示例中存在 SSRF 漏洞，攻击者可能会发送请求到数据库服务器并获取他们本不应访问的信息。SSRF
    漏洞为攻击者提供了访问更广泛网络的机会，可以作为目标。
- en: Suppose you find an SSRF, but the vulnerable site doesn’t have internal servers
    or those servers aren’t accessible via the vulnerability. In that case, check
    whether you can perform requests to arbitrary external sites from the vulnerable
    server. If you can exploit the target server to communicate with a server you
    control, you can use the requested information from it to learn more about the
    software the target application is using. You might also be able to control the
    response to it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你发现了 SSRF 漏洞，但受影响的网站没有内部服务器，或者这些服务器无法通过漏洞访问。在这种情况下，检查是否可以通过受影响服务器向任意外部站点发出请求。如果你能利用目标服务器与自己控制的服务器进行通信，你可以使用从中请求的信息进一步了解目标应用程序所使用的软件。你也许还可以控制其响应。
- en: For example, you might be able to convert external requests to internal requests
    if the vulnerable server follows redirects, a trick Justin Kennedy pointed out
    to me. In some cases, a site won’t allow access to internal IPs but will contact
    external sites. If so, you can return an HTTP response with a status code of 301,
    302, 303, or 307, which are types of redirects. Because you control the response,
    you can point the redirection to an internal IP address to test whether the server
    will follow the 301 response and make an HTTP request to its internal network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果易受攻击的服务器遵循重定向，你可能能够将外部请求转换为内部请求，这是Justin Kennedy向我指出的一个技巧。在某些情况下，网站可能不允许访问内部IP，但会与外部网站通信。如果是这样，你可以返回一个状态码为301、302、303或307的HTTP响应，这些都是重定向类型。由于你控制响应，你可以将重定向指向内部IP地址，以测试服务器是否会遵循301响应并发起对内部网络的HTTP请求。
- en: Alternatively, you could use the response from your server to test for other
    vulnerabilities, such as SQLi or XSS, as discussed in “[Attacking Users with SSRF
    Responses](ch10.xhtml#ch10lev1sec4)” on [page 98](ch10.xhtml#page_98). The success
    of this depends on how the targeted application is using the response from the
    forged request but it often pays to be creative in these situations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以利用服务器的响应来测试其他漏洞，例如SQL注入（SQLi）或跨站脚本（XSS），如在[“通过SSRF响应攻击用户”](ch10.xhtml#ch10lev1sec4)一节中所讨论的，[第98页](ch10.xhtml#page_98)提供了相关内容。这是否成功取决于目标应用如何使用伪造请求的响应，但在这些情况下，富有创意通常会有所帮助。
- en: The least impactful situation is when an SSRF vulnerability only allows you
    to communicate with a limited number of external websites. In those cases, you
    might take advantage of an incorrectly configured blacklist. For instance, suppose
    a website can communicate externally with *www.<example>.com* but only validates
    that the URL provided ends in *<example>.com*. An attacker could register *attacker<example>.com*,
    allowing the attacker to control a response to the target site.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最不具影响力的情况是，当SSRF漏洞仅允许你与有限数量的外部网站进行通信时。在这些情况下，你可能会利用配置错误的黑名单。例如，假设一个网站可以与*www.<example>.com*进行外部通信，但仅验证提供的URL是否以*<example>.com*结尾。攻击者可以注册*attacker<example>.com*，从而让攻击者控制目标站点的响应。
- en: '**Invoking GET vs. POST Requests**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**调用GET与POST请求**'
- en: After you verify that you can submit an SSRF, confirm whether you can invoke
    a `GET` or `POST` HTTP method to exploit the site. HTTP `POST` requests can be
    more significant if an attacker can control the `POST` parameters; `POST` requests
    often invoke state-changing behavior, such as creating user accounts, invoking
    system commands, or executing arbitrary code depending on what other applications
    the vulnerable server can communicate with. HTTP `GET` requests, on the other
    hand, are often associated with exfiltrating data. Because `POST` request SSRFs
    can be complex and depend on the system, in this chapter we’ll focus on bugs that
    use `GET` requests. To learn more about `POST` request–based SSRF, read Orange
    Tsai’s presentation slides from Black Hat 2017 at *[https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认你可以提交SSRF后，验证你是否能调用`GET`或`POST` HTTP方法来利用该站点。如果攻击者能够控制`POST`参数，那么HTTP `POST`请求可能会更具影响力；`POST`请求通常会触发状态改变行为，比如创建用户账户、调用系统命令或执行任意代码，具体取决于易受攻击的服务器能与哪些其他应用程序通信。而HTTP
    `GET`请求则通常与数据外泄有关。由于`POST`请求的SSRF可能会很复杂，且依赖于系统环境，本章将重点讨论使用`GET`请求的漏洞。要了解更多关于基于`POST`请求的SSRF，请阅读Orange
    Tsai在2017年黑帽大会上的演讲幻灯片，链接为*[https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)*。
- en: '**Performing Blind SSRFs**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**执行盲SSRF攻击**'
- en: After confirming where and how you can make a request, consider whether you
    can access the response of a request. When you can’t access a response, you’ve
    found a *blind SSRF*. For example, an attacker might have access to an internal
    network through SSRF but be unable to read HTTP responses to the internal server
    requests. So, they’ll need to find an alternative means of extracting information,
    usually by using timing or the Domain Name System (DNS).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认可以在哪里以及如何发起请求之后，考虑是否能够访问请求的响应。如果无法访问响应，那你就发现了一个*盲SSRF*。例如，攻击者可能通过SSRF访问了内部网络，但无法读取对内部服务器请求的HTTP响应。因此，他们需要找到另一种方式来提取信息，通常是通过计时攻击或使用域名系统（DNS）。
- en: In some blind SSRFs, response times can reveal information about the servers
    being interacted with. One way of exploiting response times is to *port scan*
    inaccessible servers. *Ports* pass information to and from a server. You scan
    ports on a server by sending a request and seeing whether they respond. For example,
    you can try to exploit an SSRF on an internal network by port scanning internal
    servers. By doing so, you might determine whether the server is open, closed,
    or filtered based on whether a response from a known port (like port 80 or 443)
    returns in 1 second or 10 seconds. *Filtered ports* are like a communication black
    hole. They don’t reply to requests, so you’ll never know whether they’re open
    or closed, and the request will time out. In contrast, a quick reply might mean
    the server is open and accepting communication or is closed and not accepting
    communication. When you’re exploiting SSRF to port scan, try to connect to common
    ports, such as 22 (used for SSH), 80 (HTTP), 443 (HTTPS), 8080 (alternate HTTP),
    and 8443 (alternate HTTPS). You’ll be able to confirm whether responses differ
    and deduce information from those differences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些盲目SSRFs中，响应时间可能会揭示与服务器交互的信息。利用响应时间的一种方式是对不可访问的服务器进行*端口扫描*。*端口*在服务器之间传递信息。你可以通过发送请求并查看是否有响应来扫描服务器上的端口。例如，你可以尝试通过端口扫描内部服务器来利用内网中的SSRF。通过这种方式，你可能会根据是否有来自已知端口（如端口80或443）的响应在1秒钟或10秒钟内返回，从而判断服务器是开放、关闭还是被过滤的。*过滤端口*就像是一个通信黑洞。它们不会回复请求，因此你永远无法知道它们是开放还是关闭，且请求会超时。相反，快速的回复可能意味着服务器是开放并接受通信，或者是关闭并且不接受通信。当你利用SSRF进行端口扫描时，可以尝试连接到常见的端口，如22（用于SSH）、80（HTTP）、443（HTTPS）、8080（备用HTTP）和8443（备用HTTPS）。你将能够确认响应是否不同，并从这些差异中推断出信息。
- en: DNS is a map for the internet. You can try to invoke DNS requests using internal
    systems and control the address of the request, including the subdomain. If you’re
    successful, you might be able to smuggle information from blind SSRF vulnerabilities.
    To exploit a blind SSRF in this way, you append the smuggled information as a
    subdomain to your own domain. The targeted server then performs a DNS lookup to
    your site for that subdomain. For example, let’s say you find a blind SSRF and
    can execute limited commands on a server but can’t read any responses. If you
    can invoke DNS lookups while controlling the lookup domain, you can add the SSRF
    output to a subdomain and use the command `whoami`. This technique is commonly
    referred to as *out-of-band (OOB) exfiltration*. When you use the `whoami` command
    on the subdomain, the vulnerable website sends a DNS request to your server. Your
    server receives a DNS lookup for *data.<yourdomain>.com*, where *data* is the
    output from the vulnerable server’s `whoami` command. Because URLs can only include
    alphanumeric characters, you’ll need to encode the data using base32 encoding.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DNS是互联网的地图。你可以尝试通过内部系统调用DNS请求，并控制请求的地址，包括子域名。如果成功，你可能能够通过盲目SSRF漏洞偷运信息。为了以这种方式利用盲目SSRF，你将偷运的信息作为子域名附加到你自己的域名上。目标服务器随后会对该子域名进行DNS查找，指向你的网站。例如，假设你发现了一个盲目SSRF漏洞，并且能够在服务器上执行有限的命令，但无法读取任何响应。如果你能在控制查找域名的同时调用DNS查找，你可以将SSRF输出添加到子域名，并使用`whoami`命令。这种技术通常被称为*带外（OOB）信息外泄*。当你在子域名上使用`whoami`命令时，易受攻击的网站会向你的服务器发送一个DNS请求。你的服务器会接收到对*data.<yourdomain>.com*的DNS查找，其中*data*是易受攻击的服务器上`whoami`命令的输出。由于URL只能包含字母数字字符，你需要使用base32编码来对数据进行编码。
- en: '**Attacking Users with SSRF Responses**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**利用SSRF响应攻击用户**'
- en: When you can’t target internal systems, you can instead try to exploit SSRFs
    that impact users or the application itself. If your SSRF isn’t blind, one way
    of doing so is to return malicious responses to the SSRF request, such as cross-site
    scripting (XSS) or SQL injection (SQLi) payloads, which execute on the vulnerable
    site. Stored XSS payloads are especially significant if other users regularly
    access them, because you can exploit these payloads to attack the users. For example,
    suppose *www.<example>.com/picture?url=* accepted a URL to fetch an image for
    your account profile in the URL parameter. You could submit a URL to your own
    site that returns an HTML page with a XSS payload. So the full URL would be *www.<example>.com/picture?url=<attacker>.com/xss*.
    If *www.<example>.com* saved the payload’s HTML and rendered it as the profile
    image, the site would have a stored XSS vulnerability. But if the site rendered
    the HTML payload and didn’t save it, you could still test whether the site prevented
    CSRF for that action. If it didn’t, you could share the URL *www.<example>.com/picture?url=<attacker>.com/xss*
    with a target. If the target visited the link, the XSS would fire as a result
    of the SSRF and make a request to your site.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你无法直接攻击内部系统时，可以尝试利用影响用户或应用程序本身的 SSRF。如果你的 SSRF 不是盲目型的，可以通过向 SSRF 请求返回恶意响应来实现攻击，比如跨站脚本（XSS）或
    SQL 注入（SQLi）有效载荷，这些攻击会在易受攻击的网站上执行。如果其他用户经常访问存储型 XSS 有效载荷，那么它特别重要，因为你可以利用这些有效载荷攻击用户。例如，假设
    *www.<example>.com/picture?url=* 接受一个 URL 来为你的账户资料加载图片。如果你向自己的站点提交一个返回带有 XSS 有效载荷的
    HTML 页面的网址，那么完整的网址会是 *www.<example>.com/picture?url=<attacker>.com/xss*。如果 *www.<example>.com*
    保存了有效载荷的 HTML 并将其作为个人资料图片渲染，那么该站点就存在存储型 XSS 漏洞。但如果该站点渲染了 HTML 有效载荷并没有保存，你仍然可以测试该站点是否为该操作阻止了
    CSRF。如果没有阻止，你可以将链接 *www.<example>.com/picture?url=<attacker>.com/xss* 分享给目标。如果目标访问了该链接，SSRF
    将触发 XSS，并向你的站点发出请求。
- en: When you’re looking for SSRF vulnerabilities, keep an eye out for opportunities
    to submit a URL or IP address as part of some site functionality. Then consider
    how you could leverage that behavior to either communicate with internal systems
    or combine it with some other type of malicious behavior.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你寻找 SSRF 漏洞时，留意是否有机会将 URL 或 IP 地址作为某些网站功能的一部分提交。然后考虑如何利用这种行为来与内部系统通信，或将其与其他类型的恶意行为结合。
- en: '**ESEA SSRF and Querying AWS Metadata**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**ESEA SSRF 和查询 AWS 元数据**'
- en: '**Difficulty:** Medium'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 中等'
- en: '**URL:** *[https://play.esea.net/global/media_preview.php?url=/](https://play.esea.net/global/media_preview.php?url=/)*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL：** *[https://play.esea.net/global/media_preview.php?url=/](https://play.esea.net/global/media_preview.php?url=/)*'
- en: '**Source:** *[http://buer.haus/2016/04/18/esea-server-side-request-forgery-and-querying-aws-meta-data/](http://buer.haus/2016/04/18/esea-server-side-request-forgery-and-querying-aws-meta-data/)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[http://buer.haus/2016/04/18/esea-server-side-request-forgery-and-querying-aws-meta-data/](http://buer.haus/2016/04/18/esea-server-side-request-forgery-and-querying-aws-meta-data/)*'
- en: '**Date reported:** April 11, 2016'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2016年4月11日'
- en: '**Bounty paid:** $1,000'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励金额：** $1,000'
- en: In some cases, you can exploit and demonstrate the impact of an SSRF in multiple
    ways. E-Sports Entertainment Association (ESEA), a competitive video gaming community,
    opened a self-run bug bounty program in 2016\. Immediately after ESEA launched
    the program, Brett Buerhaus used *Google dorking* to quickly search for URLs ending
    in the *.php* file extension. Google dorking uses Google search keywords to specify
    where a search is performed and the type of information looked for. Buerhaus used
    the query *site:[https://play.esea.net/](https://play.esea.net/) ext:php*, which
    tells Google to return results only for the site *[https://play.esea.net/](https://play.esea.net/)*
    when a file ends in *.php*. Older site designs serve web pages that end with *.php*
    and can indicate a page is using outdated functionality, making it a good place
    to look for vulnerabilities. When Buerhaus ran the search, he received the URL
    *[https://play.esea.net/global/media_preview.php?url=](https://play.esea.net/global/media_preview.php?url=)*
    as part of the results.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以通过多种方式利用并展示SSRF的影响。电子竞技娱乐协会（ESEA），一个竞争性视频游戏社区，在2016年启动了一个自营的漏洞奖励计划。ESEA启动该计划后，Brett
    Buerhaus通过*Google dorking*快速搜索以*.php*扩展名结尾的URL。Google dorking使用Google搜索关键词来指定搜索的执行位置和目标信息类型。Buerhaus使用了查询*site:[https://play.esea.net/](https://play.esea.net/)
    ext:php*，这告诉Google仅返回以*.php*结尾的*https://play.esea.net/*网站的结果。旧版网站设计通常会使用以*.php*结尾的网页，这可能表明该页面使用了过时的功能，因此是查找漏洞的好地方。当Buerhaus进行搜索时，他收到了URL*[https://play.esea.net/global/media_preview.php?url=](https://play.esea.net/global/media_preview.php?url=)*作为结果之一。
- en: This result is notable because of the parameter `url=`. The parameter indicates
    ESEA could be rendering content from external sites defined by the URL parameter.
    When you’re looking for SSRF, the URL parameter is a red flag. To begin testing,
    Buerhaus inserted his own domain into the parameter to create the URL *[https://play.esea.net/global/media_preview.php?url=http://ziot.org](https://play.esea.net/global/media_preview.php?url=http://ziot.org)*.
    He received an error message that ESEA was expecting the URL to return an image.
    So he tried the URL *[https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png)*
    and was successful.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果之所以引人注目，是因为其中的`url=`参数。这个参数表明ESEA可能正在渲染由URL参数定义的外部网站内容。在寻找SSRF漏洞时，URL参数是一个警示信号。为了开始测试，Buerhaus将自己的域名插入到该参数中，构造出URL*[https://play.esea.net/global/media_preview.php?url=http://ziot.org](https://play.esea.net/global/media_preview.php?url=http://ziot.org)*。他收到了一个错误信息，表明ESEA期望该URL返回一张图片。于是他尝试了URL*[https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png)*，并成功了。
- en: Validating file extensions is a common approach to secure functionality where
    users can control parameters that make server-side requests. ESEA was limiting
    the URL rendering to images, but that didn’t mean it was validating URLs properly.
    Buerhaus added a null byte (*%00*) to the URL to start his testing. In programming
    languages in which the programmer needs to manage memory manually, a null byte
    terminates strings. Depending on how a site implements its functionality, adding
    a null byte might cause the site to end the URL prematurely. If ESEA was vulnerable,
    instead of making a request to *https://play.esea.net/global/media_preview.php?url=http://ziot.org%00/1.png*,
    the site would make the request to *[https://play.esea.net/global/media_preview.php?url=http://ziot.org](https://play.esea.net/global/media_preview.php?url=http://ziot.org)*.
    But Buerhaus found that adding a null byte didn’t work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 验证文件扩展名是确保功能安全的常见方法之一，在这种方法中，用户可以控制会发起服务器请求的参数。ESEA将URL渲染限制为图像，但这并不意味着它正确地验证了URL。Buerhaus在URL中添加了一个空字节(*%00*)来开始他的测试。在需要程序员手动管理内存的编程语言中，空字节用于终止字符串。根据网站实现功能的方式，添加空字节可能会导致网站提前结束URL。如果ESEA存在漏洞，网站就会将请求发送到*https://play.esea.net/global/media_preview.php?url=http://ziot.org%00/1.png*，而不是按预期发出请求到*[https://play.esea.net/global/media_preview.php?url=http://ziot.org](https://play.esea.net/global/media_preview.php?url=http://ziot.org)*。但Buerhaus发现，添加空字节并没有奏效。
- en: Next, he tried adding additional forward slashes, which divide parts of a URL.
    Input after multiple forward slashes is often ignored because multiple slashes
    don’t conform to a URL’s standard structure. Instead of making a request to *[https://play.esea.net/global/media_preview.php?url=http://ziot.org///1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org///1.png)*,
    Buerhaus hoped the site would make a request to *[https://play.esea.net/global/media_preview.php?url=http://ziot.org](https://play.esea.net/global/media_preview.php?url=http://ziot.org)*.
    This test also failed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，他尝试添加更多的正斜杠，它们将 URL 的各个部分分开。多个正斜杠后面的输入通常会被忽略，因为多个斜杠不符合 URL 的标准结构。Buerhaus
    希望站点会发起请求到 *[https://play.esea.net/global/media_preview.php?url=http://ziot.org](https://play.esea.net/global/media_preview.php?url=http://ziot.org)*，而不是
    *[https://play.esea.net/global/media_preview.php?url=http://ziot.org///1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org///1.png)*。这个测试也失败了。
- en: In his final attempt, Buerhaus changed the *1.png* in his URL from part of the
    URL to a parameter by converting the forward slash to a question mark. So instead
    of *[https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png)*,
    he submitted *[https://play.esea.net/global/media_preview.php?url=http://ziot.org?1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org?1.png)*.
    The first URL submits the request to his site looking for */1.png*. But the second
    URL causes the request to be made to the site home page *[http://ziot.org](http://ziot.org)*
    with *1.png* as a parameter in the request. As a result, ESEA rendered Buerhaus’s
    *[http://ziot.org](http://ziot.org)* web page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的最后一次尝试中，Buerhaus 将其 URL 中的 *1.png* 从 URL 的一部分改为一个参数，通过将正斜杠转换为问号。因此，他提交的 URL
    从 *[https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png)*
    改为了 *[https://play.esea.net/global/media_preview.php?url=http://ziot.org?1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org?1.png)*。第一个
    URL 向他的网站提交请求，查找 */1.png*。但第二个 URL 使请求发送到网站的主页 *[http://ziot.org](http://ziot.org)*，并将
    *1.png* 作为请求中的参数。因此，ESEA 渲染了 Buerhaus 的 *[http://ziot.org](http://ziot.org)* 网页。
- en: Buerhaus had confirmed that he could make external HTTP requests and the site
    would render the response—a promising start. But invoking requests to any server
    might be an acceptable risk to companies if the server doesn’t disclose information
    or the website doesn’t do anything with the HTTP response. To escalate the severity
    of the SSRF, Buerhaus returned an XSS payload in his server’s response, as described
    in “[Attacking Users with SSRF Responses](ch10.xhtml#ch10lev1sec4)” on [page 98](ch10.xhtml#page_98).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Buerhaus 已确认他可以发起外部 HTTP 请求，并且网站会呈现响应——这是一个很有前景的开始。但向任何服务器发起请求可能是公司可以接受的风险，前提是服务器不会泄露信息，或者网站不会对
    HTTP 响应做任何处理。为了提升 SSRF 的严重性，Buerhaus 在他的服务器响应中返回了一个 XSS payload，正如在 “[通过 SSRF
    响应攻击用户](ch10.xhtml#ch10lev1sec4)” 中描述的那样，参见 [第 98 页](ch10.xhtml#page_98)。
- en: He shared the vulnerability with Ben Sadeghipour to see if they could escalate
    it. Sadeghipour suggested submitting *http://169.254.169.254/latest/meta-data/hostname*.
    This is an IP address that Amazon Web Services (AWS) provides for sites it hosts.
    If an AWS server sends an HTTP request to this URL, AWS returns metadata about
    the server. Usually, this feature helps with internal automation and scripting.
    But the endpoint can also be used to access private information. Depending on
    the site’s AWS configuration, the endpoint *http://169.254.169.254/latest/meta-data/iam/security-credentials/*
    returns the Identify Access Manager (IAM) security credentials for the server
    performing the request. Because AWS security credentials are difficult to configure,
    it’s not uncommon for accounts to have more permissions than required. If you
    can access these credentials, you can use the AWS command line to control any
    service the user has access to. ESEA was in fact hosted on AWS, and the internal
    host name of the server was returned to Buerhaus. At this point, he stopped and
    reported the vulnerability.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 他将这个漏洞与 Ben Sadeghipour 分享，看看他们是否能将其提升为更严重的漏洞。Sadeghipour 建议提交 *http://169.254.169.254/latest/meta-data/hostname*。这是
    Amazon Web Services (AWS) 为其托管的网站提供的一个 IP 地址。如果 AWS 服务器向该 URL 发送 HTTP 请求，AWS 会返回关于服务器的元数据。通常，这个功能有助于内部自动化和脚本处理。但该端点也可以用来访问私密信息。根据站点的
    AWS 配置，端点 *http://169.254.169.254/latest/meta-data/iam/security-credentials/*
    会返回执行请求的服务器的身份访问管理 (IAM) 安全凭证。由于 AWS 安全凭证配置较为复杂，账户通常会比实际需要的权限更多。如果能够访问这些凭证，你可以使用
    AWS 命令行控制用户有权限访问的任何服务。ESEA 确实托管在 AWS 上，服务器的内部主机名被返回给了 Buerhaus。此时，他停止了操作并报告了该漏洞。
- en: '***Takeaways***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结***'
- en: Google dorking can save you time when you’re looking for vulnerabilities that
    require URLs set up in a specific way. If you use the tool to look for SSRF vulnerabilities,
    watch out for target URLs that appear to be interacting with external sites. In
    this case, the site was exposed by the URL parameter `url=`. When you find an
    SSRF, think big. Buerhaus could have reported the SSRF using the XSS payload,
    but that wouldn’t have been nearly as impactful as accessing the site’s AWS metadata.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Google dorking 可以在你寻找需要特定 URL 设置的漏洞时节省时间。如果你使用该工具寻找 SSRF 漏洞，注意那些看起来正在与外部网站交互的目标
    URL。在这个案例中，漏洞通过 URL 参数 `url=` 被暴露。当你发现 SSRF 漏洞时，要有宏大的视角。Buerhaus 本可以使用 XSS 载荷报告
    SSRF，但那远没有访问网站的 AWS 元数据那样具有影响力。
- en: '**Google Internal DNS SSRF**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Google 内部 DNS SSRF**'
- en: '**Difficulty:** Medium'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 中等'
- en: '**URL:** *[https://toolbox.googleapps.com/](https://toolbox.googleapps.com/)*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *[https://toolbox.googleapps.com/](https://toolbox.googleapps.com/)*'
- en: '**Source:** *[https://www.rcesecurity.com/2017/03/ok-google-give-me-all-your-internal-dns-information/](https://www.rcesecurity.com/2017/03/ok-google-give-me-all-your-internal-dns-information/)*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://www.rcesecurity.com/2017/03/ok-google-give-me-all-your-internal-dns-information/](https://www.rcesecurity.com/2017/03/ok-google-give-me-all-your-internal-dns-information/)*'
- en: '**Date reported:** January 2017'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2017 年 1 月'
- en: '**Bounty paid:** Undisclosed'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励支付：** 未公开'
- en: Sometimes sites are meant to perform HTTP requests to external sites only. When
    you find sites with this functionality, check whether you can abuse it to access
    internal networks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，网站本应仅执行对外部站点的 HTTP 请求。当你发现具有此功能的网站时，检查是否可以滥用它来访问内部网络。
- en: Google provides the site *[https://toolbox.googleapps.com](https://toolbox.googleapps.com)*
    to help users debug issues they’re having with Google’s G Suite services. That
    service’s DNS tool caught Julien Ahrens’s (*[www.rcesecurity.com](http://www.rcesecurity.com)*)
    attention because it allowed users to perform HTTP requests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Google 提供了 *[https://toolbox.googleapps.com](https://toolbox.googleapps.com)*
    网站，帮助用户调试他们在使用 Google G Suite 服务时遇到的问题。该服务的 DNS 工具引起了 Julien Ahrens 的注意（* [www.rcesecurity.com](http://www.rcesecurity.com)
    *），因为它允许用户执行 HTTP 请求。
- en: 'Google’s DNS tools include dig, which acts just like the Unix `dig` command
    and allows users to query domain name servers for a site’s DNS information. DNS
    information maps an IP address to a readable domain, such as *www.<example>.com*.
    At the time of Ahrens’s finding, Google included two input fields: one for the
    URL to map to an IP address and the other for the domain name server, as shown
    in [Figure 10-1](ch10.xhtml#ch10fig01).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的 DNS 工具包括 dig，功能类似于 Unix 的 `dig` 命令，允许用户查询域名服务器以获取网站的 DNS 信息。DNS 信息将
    IP 地址映射到可读的域名，如 *www.<example>.com*。在 Ahrens 发现该漏洞时，Google 包含了两个输入框：一个用于将 URL
    映射为 IP 地址，另一个用于域名服务器，如 [图 10-1](ch10.xhtml#ch10fig01) 所示。
- en: '![image](../images/10fig01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig01.jpg)'
- en: '*Figure 10-1: An example query to the Google dig tool*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：谷歌dig工具的查询示例*'
- en: Ahrens noticed the Name server field in particular because it allows users to
    specify an IP address to point the DNS query to. This significant discovery suggested
    that users could send DNS queries to any IP address.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ahrens特别注意到Name server字段，因为它允许用户指定一个IP地址来指向DNS查询。这个重要的发现表明，用户可以将DNS查询发送到任何IP地址。
- en: 'Some IP addresses are reserved for internal use. They’re discoverable by internal
    DNS queries but shouldn’t be accessible through the internet. These reserved IP
    ranges include:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一些IP地址被保留用于内部使用。它们可以通过内部DNS查询发现，但不应该通过互联网访问。这些保留的IP范围包括：
- en: 10.0.0.0 to 10.255.255.255
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.0.0.0 到 10.255.255.255
- en: 100.64.0.0 to 100.127.255.255
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100.64.0.0 到 100.127.255.255
- en: 127.0.0.0 to 127.255.255.255
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 127.0.0.0 到 127.255.255.255
- en: 172.16.0.0 to 172.31.255.255
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 172.16.0.0 到 172.31.255.255
- en: 192.0.0.0 to 192.0.0.255
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 192.0.0.0 到 192.0.0.255
- en: 198.18.0.0 to 198.19.255.255
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 198.18.0.0 到 198.19.255.255
- en: In addition, some IP addresses are reserved for specific purposes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些IP地址被保留用于特定目的。
- en: To begin testing the Name server field, Ahrens submitted his site as the server
    to look up and used the IP address 127.0.0.1 as the Name server. IP address 127.0.0.1
    is commonly referred to as the *localhost*, and a server uses it to refer to itself.
    In this case, localhost is the Google server executing the dig command. Ahrens’s
    test resulted in the error “Server did not respond.” The error implies that the
    tool was trying to connect to its own port 53 (the port that responds to DNS lookups)
    for information about Ahrens’s site, *[rcesecurity.com](http://rcesecurity.com)*.
    The wording “did not respond” is crucial because it implies that the server allows
    internal connections, whereas wording like “permission denied” would not. This
    red flag signaled Ahrens to keep testing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始测试Name server字段，Ahrens将自己的网站作为要查找的服务器，并使用IP地址127.0.0.1作为Name server。IP地址127.0.0.1通常被称为*localhost*，服务器使用它来引用自己。在这个案例中，localhost是执行dig命令的谷歌服务器。Ahrens的测试结果是“服务器没有响应”错误。这个错误意味着工具尝试连接到自己的53号端口（响应DNS查询的端口）以获取关于Ahrens网站的信息，*[rcesecurity.com](http://rcesecurity.com)*。
    wording "did not respond"（没有响应）非常重要，因为它意味着服务器允许内部连接，而如果是“permission denied”（拒绝权限）之类的词语就不一样。这一警示信号让Ahrens继续进行测试。
- en: 'Next, Ahrens sent the HTTP request to the Burp Intruder tool so he could begin
    enumerating internal IP addresses in the 10.*x*.*x*.*x* range. After a couple
    of minutes, he received a response from one internal 10\. IP address (he purposely
    did not disclose which) with an empty A record, which is a type of record that
    DNS servers return. Although the A record was empty, it was for Ahrens’s website:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ahrens将HTTP请求发送到Burp Intruder工具，这样他就可以开始枚举10.*x*.*x*.*x*范围内的内部IP地址。几分钟后，他收到来自一个内部10\.IP地址的响应（他故意没有透露是哪个IP地址），返回了一个空的A记录，这是DNS服务器返回的一种记录类型。尽管A记录为空，但它是Ahrens网站的记录：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ahrens had found a DNS server with internal access that would respond to him.
    An internal DNS server usually doesn’t know about external websites, which explains
    the empty A record. But the server should know how to map to internal addresses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ahrens发现了一个具有内部访问权限的DNS服务器，它会响应他的请求。一个内部DNS服务器通常不知道外部网站，这解释了空白的A记录。但该服务器应该知道如何映射到内部地址。
- en: 'To demonstrate the impact of the vulnerability, Ahrens had to retrieve information
    about Google’s internal network because information about an internal network
    shouldn’t be publicly accessible. A quick Google search revealed that Google used
    the subdomain *[corp.google.com](http://corp.google.com)* as the base for its
    internal sites. So Ahrens began brute-forcing subdomains from *[corp.google.com](http://corp.google.com)*,
    eventually revealing the domain *ad.corp.google.com*. Submitting this subdomain
    to the dig tool and requesting A records for the internal IP address Ahrens had
    found earlier returned Google’s private DNS information, which was far from empty:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示漏洞的影响，Ahrens必须检索关于谷歌内部网络的信息，因为内部网络的信息不应该公开访问。一次快速的谷歌搜索显示，谷歌使用子域名*[corp.google.com](http://corp.google.com)*作为其内部站点的基础。因此，Ahrens开始对*[corp.google.com](http://corp.google.com)*进行子域名暴力破解，最终发现了域名*ad.corp.google.com*。将这个子域名提交给dig工具，并请求早前找到的内部IP地址的A记录，返回了谷歌的私人DNS信息，内容远非空白：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note the references to the internal IP addresses `100.REDACTED` and `172.REDACTED`.
    In comparison, the public DNS lookup for *ad.corp.google.com* returns the following
    record, which doesn’t include any information about the private IP addresses that
    Ahrens discovered:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意内部 IP 地址 `100.REDACTED` 和 `172.REDACTED` 的引用。相比之下，*ad.corp.google.com* 的公共
    DNS 查询返回了以下记录，其中不包括 Ahrens 发现的私有 IP 地址信息：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Ahrens also requested the Name servers for *ad.corp.google.com* using Google’s
    DNS tools, which returned the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ahrens 还使用 Google 的 DNS 工具请求了 *ad.corp.google.com* 的名称服务器，返回了以下结果：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In addition, Ahrens discovered that at least one internal domain was publicly
    accessible to the internet: a Minecraft server at *minecraft.corp.google.com*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Ahrens 还发现至少有一个内部域名可以公开访问：一个位于 *minecraft.corp.google.com* 的 Minecraft 服务器。
- en: '***Takeaways***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点***'
- en: Be on the lookout for websites that include functionality to make external HTTP
    requests. When you find them, try pointing the request internally using the private
    network IP address 127.0.0.1 or the IP ranges listed in the example. If you discover
    internal sites, try to access them from an external source to demonstrate greater
    impact. Most likely, they’re only meant to be internally accessible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意包含外部 HTTP 请求功能的网站。当你找到这些网站时，尝试使用私有网络 IP 地址 127.0.0.1 或示例中列出的 IP 范围，将请求指向内部。如果你发现了内部网站，尝试从外部源访问它们，以展示更大的影响。它们很可能只允许内部访问。
- en: '**Internal Port Scanning Using Webhooks**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Webhook 进行内部端口扫描**'
- en: '**Difficulty:** Easy'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 简单'
- en: '**URL:** N/A'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL：** 不适用'
- en: '**Source:** N/A'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** 不适用'
- en: '**Date reported:** October 2017'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2017年10月'
- en: '**Bounty paid:** Undisclosed'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**赏金支付：** 未公开'
- en: '*Webhooks* allow users to ask one site to send a request to another remote
    site when certain actions occur. For example, an ecommerce site might allow users
    to set up a webhook that sends purchase information to a remote site every time
    a user submits an order. Webhooks that let the user define the URL of the remote
    site provide an opportunity for SSRFs. But the impact of any SSRFs might be limited
    because you can’t always control the request or access the response.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Webhook* 允许用户在某些操作发生时，要求一个网站向另一个远程网站发送请求。例如，一个电子商务网站可能允许用户设置一个 webhook，每当用户提交订单时，就将购买信息发送到远程网站。允许用户定义远程网站
    URL 的 webhook 提供了 SSRF（服务器端请求伪造）的机会。但是，任何 SSRF 的影响可能是有限的，因为你不能总是控制请求或访问响应。'
- en: While testing a site in October 2017, I noticed I could create custom webhooks.
    So I submitted the webhook URL as *http://localhost* to see whether the server
    would communicate with itself. The site said this URL wasn’t permitted, so I also
    tried *http://127.0.0.1*, which also returned an error message. Undeterred, I
    tried referencing 127.0.0.1 in other ways. The website *[https://www.psyon.org/tools/ip_address_converter.php?ip=127.0.0.1/](https://www.psyon.org/tools/ip_address_converter.php?ip=127.0.0.1/)*
    lists several alternative IP addresses, including 127.0.1, 127.1, and many others.
    Both appeared to work.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2017 年 10 月测试一个网站时，我注意到我可以创建自定义 webhook。所以我提交了一个 *http://localhost* 的 webhook
    URL，看看服务器是否会与自身通信。该网站表示这个 URL 不被允许，所以我又尝试了 *http://127.0.0.1*，但也返回了错误信息。没有气馁，我尝试以其他方式引用
    127.0.0.1。网站 *[https://www.psyon.org/tools/ip_address_converter.php?ip=127.0.0.1/](https://www.psyon.org/tools/ip_address_converter.php?ip=127.0.0.1/)*
    列出了几个替代的 IP 地址，包括 127.0.1、127.1 等等。两者似乎都有效。
- en: After submitting my report, I realized the severity of my finding was too low
    to warrant a bounty. All I had demonstrated was the ability to bypass the site’s
    localhost check. To be eligible for a reward, I had to demonstrate that I could
    compromise the site’s infrastructure or extract information.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 提交报告后，我意识到我的发现的严重性不足以获得赏金。我展示的只是绕过了该站点的本地检查。为了有资格获得奖励，我必须证明我能够破坏该站点的基础设施或提取信息。
- en: The site also used a feature called web integrations, which allows users to
    import remote content to the site. By creating a custom integration, I could provide
    a remote URL that returns an XML structure for the site to parse and render for
    my account.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站还使用了一个名为“Web 集成”的功能，允许用户将远程内容导入到网站中。通过创建自定义集成，我可以提供一个远程 URL，返回一个 XML 结构供该站点解析并为我的账户呈现。
- en: To start, I submitted 127.0.0.1 and hoped the site might disclose information
    about the response. Instead, the site rendered the error 500 “Unable to connect”
    in place of valid content. This error looked promising because the site was disclosing
    information about the response. Next, I checked whether I could communicate with
    ports on the server. I went back to the integration configuration and submitted
    127.0.0.1:443, which is the IP address to access and the server port separated
    by a colon. I wanted to see whether the site could communicate on port 443\. Again,
    I received the error 500 “Unable to connect.” I also received the same error for
    port 8080\. Then I tried port 22, which connects over SSH. This time the error
    was 503, “Could not retrieve all headers.”
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我提交了127.0.0.1，并希望网站能披露有关响应的信息。结果，网站显示了错误500“无法连接”，而没有返回有效的内容。这个错误看起来很有前景，因为网站披露了关于响应的信息。接着，我检查是否能够与服务器上的端口进行通信。我回到集成配置，提交了127.0.0.1:443，这是访问服务器的IP地址和端口号之间用冒号分隔的形式。我想看看网站是否能够在端口443上通信。再次，我收到了错误500“无法连接”。对于端口8080，我也收到了相同的错误。然后，我尝试了端口22，它通过SSH连接。这次错误是503，“无法检索所有头信息”。
- en: Bingo. The “Could not retrieve all headers” response was sending HTTP traffic
    to a port expecting the SSH protocol. This response differs from a 500 response
    because it confirms that a connection can be made. I resubmitted my report to
    demonstrate that I could use web integrations to port scan the company’s internal
    server because responses were different for open/closed and filtered ports.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 中奖了。“无法检索所有头信息”的响应将HTTP流量发送到一个期望SSH协议的端口。这种响应不同于500错误响应，因为它确认可以建立连接。我重新提交了报告，展示我可以利用Web集成功能对公司内部服务器进行端口扫描，因为不同的端口（开放/关闭或过滤）返回了不同的响应。
- en: '***Takeaways***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点总结***'
- en: If you can submit a URL to create webhooks or intentionally import remote content,
    try to define specific ports. Minor changes in how a server responds to different
    ports can reveal whether a port is open or closed or filtered. In addition to
    differences in the messages the server returns, ports might reveal whether they’re
    open or closed or filtered by how long it takes the server to respond to the request.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以提交URL来创建Web钩子或故意导入远程内容，尝试定义特定的端口。服务器对不同端口的响应方式的细微变化可以揭示端口是否开放、关闭或被过滤。除了服务器返回的消息差异外，端口的响应时间也可能揭示它们是开放、关闭还是被过滤的。
- en: '**Summary**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: SSRFs occur when an attacker can leverage a server to perform unintended network
    requests. But not all requests are exploitable. For example, the fact that a site
    allows you to make a request to a remote or local server doesn’t mean it’s significant.
    Identifying the ability to make an unintended request is just the first step in
    identifying these bugs. The key to reporting them is to demonstrate the full impact
    of their behavior. In each example in this chapter, the sites allowed HTTP requests
    to be made. But they didn’t adequately protect their own infrastructure from malicious
    users.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SSRF（服务器端请求伪造）发生在攻击者可以利用服务器执行未预期的网络请求时。但并不是所有请求都可以被利用。例如，一个网站允许你向远程或本地服务器发起请求，并不意味着这个请求具有重要性。识别出能够发起未预期请求的能力只是发现这些漏洞的第一步。报告这些漏洞的关键在于展示其行为的完整影响。在本章中的每个例子里，网站都允许发起HTTP请求。但它们没有充分保护自己的基础设施，防止恶意用户的攻击。
