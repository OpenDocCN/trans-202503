- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SERVER-SIDE REQUEST FORGERY**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A *server-side request forgery (SSRF)* vulnerability allows an attacker to make
    a server perform unintended network requests. Like a cross-site request forgery
    (CSRF) vulnerability, an SSRF abuses another system to perform malicious actions.
    While a CSRF exploits another user, an SSRF exploits a targeted application server.
    As with CSRFs, SSRF vulnerabilities can vary in impact and execution methods.
    However, just because you can make a targeted server send requests to other arbitrary
    servers doesn’t mean the targeted application is vulnerable. The application may
    intentionally allow this behavior. For this reason, it’s important to understand
    how to demonstrate impact when you’ve found a potential SSRF.
  prefs: []
  type: TYPE_NORMAL
- en: '**Demonstrating the Impact of Server-Side Request Forgery**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on how a website is organized, a server vulnerable to SSRF might make
    an HTTP request to an internal network or to external addresses. The vulnerable
    server’s ability to make requests determines what you can do with the SSRF.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some larger websites have firewalls that prohibit external internet traffic
    from accessing internal servers: for example, the website will have a limited
    number of publicly facing servers that receive HTTP requests from visitors and
    send requests on to other servers that are publicly inaccessible. A common example
    is a database server, which is often inaccessible to the internet. When you’re
    logging into a site that communicates with a database server, you might submit
    a username and password through a regular web form. The website would receive
    your HTTP request and perform its own request to the database server using your
    credentials. Then the database server would respond to the web application server,
    and the web application server would relay the information to you. During this
    process, you’re often not aware that the remote database server exists, and you
    should have no direct access to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerable servers that allow attacker control of requests to internal servers
    could expose private information. For example, if an SSRF existed in the preceding
    database example, it might allow an attacker to send requests to the database
    server and retrieve information they shouldn’t have access to. SSRF vulnerabilities
    provide attackers access to a broader network to target.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you find an SSRF, but the vulnerable site doesn’t have internal servers
    or those servers aren’t accessible via the vulnerability. In that case, check
    whether you can perform requests to arbitrary external sites from the vulnerable
    server. If you can exploit the target server to communicate with a server you
    control, you can use the requested information from it to learn more about the
    software the target application is using. You might also be able to control the
    response to it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you might be able to convert external requests to internal requests
    if the vulnerable server follows redirects, a trick Justin Kennedy pointed out
    to me. In some cases, a site won’t allow access to internal IPs but will contact
    external sites. If so, you can return an HTTP response with a status code of 301,
    302, 303, or 307, which are types of redirects. Because you control the response,
    you can point the redirection to an internal IP address to test whether the server
    will follow the 301 response and make an HTTP request to its internal network.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could use the response from your server to test for other
    vulnerabilities, such as SQLi or XSS, as discussed in “[Attacking Users with SSRF
    Responses](ch10.xhtml#ch10lev1sec4)” on [page 98](ch10.xhtml#page_98). The success
    of this depends on how the targeted application is using the response from the
    forged request but it often pays to be creative in these situations.
  prefs: []
  type: TYPE_NORMAL
- en: The least impactful situation is when an SSRF vulnerability only allows you
    to communicate with a limited number of external websites. In those cases, you
    might take advantage of an incorrectly configured blacklist. For instance, suppose
    a website can communicate externally with *www.<example>.com* but only validates
    that the URL provided ends in *<example>.com*. An attacker could register *attacker<example>.com*,
    allowing the attacker to control a response to the target site.
  prefs: []
  type: TYPE_NORMAL
- en: '**Invoking GET vs. POST Requests**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After you verify that you can submit an SSRF, confirm whether you can invoke
    a `GET` or `POST` HTTP method to exploit the site. HTTP `POST` requests can be
    more significant if an attacker can control the `POST` parameters; `POST` requests
    often invoke state-changing behavior, such as creating user accounts, invoking
    system commands, or executing arbitrary code depending on what other applications
    the vulnerable server can communicate with. HTTP `GET` requests, on the other
    hand, are often associated with exfiltrating data. Because `POST` request SSRFs
    can be complex and depend on the system, in this chapter we’ll focus on bugs that
    use `GET` requests. To learn more about `POST` request–based SSRF, read Orange
    Tsai’s presentation slides from Black Hat 2017 at *[https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performing Blind SSRFs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After confirming where and how you can make a request, consider whether you
    can access the response of a request. When you can’t access a response, you’ve
    found a *blind SSRF*. For example, an attacker might have access to an internal
    network through SSRF but be unable to read HTTP responses to the internal server
    requests. So, they’ll need to find an alternative means of extracting information,
    usually by using timing or the Domain Name System (DNS).
  prefs: []
  type: TYPE_NORMAL
- en: In some blind SSRFs, response times can reveal information about the servers
    being interacted with. One way of exploiting response times is to *port scan*
    inaccessible servers. *Ports* pass information to and from a server. You scan
    ports on a server by sending a request and seeing whether they respond. For example,
    you can try to exploit an SSRF on an internal network by port scanning internal
    servers. By doing so, you might determine whether the server is open, closed,
    or filtered based on whether a response from a known port (like port 80 or 443)
    returns in 1 second or 10 seconds. *Filtered ports* are like a communication black
    hole. They don’t reply to requests, so you’ll never know whether they’re open
    or closed, and the request will time out. In contrast, a quick reply might mean
    the server is open and accepting communication or is closed and not accepting
    communication. When you’re exploiting SSRF to port scan, try to connect to common
    ports, such as 22 (used for SSH), 80 (HTTP), 443 (HTTPS), 8080 (alternate HTTP),
    and 8443 (alternate HTTPS). You’ll be able to confirm whether responses differ
    and deduce information from those differences.
  prefs: []
  type: TYPE_NORMAL
- en: DNS is a map for the internet. You can try to invoke DNS requests using internal
    systems and control the address of the request, including the subdomain. If you’re
    successful, you might be able to smuggle information from blind SSRF vulnerabilities.
    To exploit a blind SSRF in this way, you append the smuggled information as a
    subdomain to your own domain. The targeted server then performs a DNS lookup to
    your site for that subdomain. For example, let’s say you find a blind SSRF and
    can execute limited commands on a server but can’t read any responses. If you
    can invoke DNS lookups while controlling the lookup domain, you can add the SSRF
    output to a subdomain and use the command `whoami`. This technique is commonly
    referred to as *out-of-band (OOB) exfiltration*. When you use the `whoami` command
    on the subdomain, the vulnerable website sends a DNS request to your server. Your
    server receives a DNS lookup for *data.<yourdomain>.com*, where *data* is the
    output from the vulnerable server’s `whoami` command. Because URLs can only include
    alphanumeric characters, you’ll need to encode the data using base32 encoding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacking Users with SSRF Responses**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you can’t target internal systems, you can instead try to exploit SSRFs
    that impact users or the application itself. If your SSRF isn’t blind, one way
    of doing so is to return malicious responses to the SSRF request, such as cross-site
    scripting (XSS) or SQL injection (SQLi) payloads, which execute on the vulnerable
    site. Stored XSS payloads are especially significant if other users regularly
    access them, because you can exploit these payloads to attack the users. For example,
    suppose *www.<example>.com/picture?url=* accepted a URL to fetch an image for
    your account profile in the URL parameter. You could submit a URL to your own
    site that returns an HTML page with a XSS payload. So the full URL would be *www.<example>.com/picture?url=<attacker>.com/xss*.
    If *www.<example>.com* saved the payload’s HTML and rendered it as the profile
    image, the site would have a stored XSS vulnerability. But if the site rendered
    the HTML payload and didn’t save it, you could still test whether the site prevented
    CSRF for that action. If it didn’t, you could share the URL *www.<example>.com/picture?url=<attacker>.com/xss*
    with a target. If the target visited the link, the XSS would fire as a result
    of the SSRF and make a request to your site.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re looking for SSRF vulnerabilities, keep an eye out for opportunities
    to submit a URL or IP address as part of some site functionality. Then consider
    how you could leverage that behavior to either communicate with internal systems
    or combine it with some other type of malicious behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**ESEA SSRF and Querying AWS Metadata**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://play.esea.net/global/media_preview.php?url=/](https://play.esea.net/global/media_preview.php?url=/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[http://buer.haus/2016/04/18/esea-server-side-request-forgery-and-querying-aws-meta-data/](http://buer.haus/2016/04/18/esea-server-side-request-forgery-and-querying-aws-meta-data/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** April 11, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $1,000'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you can exploit and demonstrate the impact of an SSRF in multiple
    ways. E-Sports Entertainment Association (ESEA), a competitive video gaming community,
    opened a self-run bug bounty program in 2016\. Immediately after ESEA launched
    the program, Brett Buerhaus used *Google dorking* to quickly search for URLs ending
    in the *.php* file extension. Google dorking uses Google search keywords to specify
    where a search is performed and the type of information looked for. Buerhaus used
    the query *site:[https://play.esea.net/](https://play.esea.net/) ext:php*, which
    tells Google to return results only for the site *[https://play.esea.net/](https://play.esea.net/)*
    when a file ends in *.php*. Older site designs serve web pages that end with *.php*
    and can indicate a page is using outdated functionality, making it a good place
    to look for vulnerabilities. When Buerhaus ran the search, he received the URL
    *[https://play.esea.net/global/media_preview.php?url=](https://play.esea.net/global/media_preview.php?url=)*
    as part of the results.
  prefs: []
  type: TYPE_NORMAL
- en: This result is notable because of the parameter `url=`. The parameter indicates
    ESEA could be rendering content from external sites defined by the URL parameter.
    When you’re looking for SSRF, the URL parameter is a red flag. To begin testing,
    Buerhaus inserted his own domain into the parameter to create the URL *[https://play.esea.net/global/media_preview.php?url=http://ziot.org](https://play.esea.net/global/media_preview.php?url=http://ziot.org)*.
    He received an error message that ESEA was expecting the URL to return an image.
    So he tried the URL *[https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png)*
    and was successful.
  prefs: []
  type: TYPE_NORMAL
- en: Validating file extensions is a common approach to secure functionality where
    users can control parameters that make server-side requests. ESEA was limiting
    the URL rendering to images, but that didn’t mean it was validating URLs properly.
    Buerhaus added a null byte (*%00*) to the URL to start his testing. In programming
    languages in which the programmer needs to manage memory manually, a null byte
    terminates strings. Depending on how a site implements its functionality, adding
    a null byte might cause the site to end the URL prematurely. If ESEA was vulnerable,
    instead of making a request to *https://play.esea.net/global/media_preview.php?url=http://ziot.org%00/1.png*,
    the site would make the request to *[https://play.esea.net/global/media_preview.php?url=http://ziot.org](https://play.esea.net/global/media_preview.php?url=http://ziot.org)*.
    But Buerhaus found that adding a null byte didn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Next, he tried adding additional forward slashes, which divide parts of a URL.
    Input after multiple forward slashes is often ignored because multiple slashes
    don’t conform to a URL’s standard structure. Instead of making a request to *[https://play.esea.net/global/media_preview.php?url=http://ziot.org///1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org///1.png)*,
    Buerhaus hoped the site would make a request to *[https://play.esea.net/global/media_preview.php?url=http://ziot.org](https://play.esea.net/global/media_preview.php?url=http://ziot.org)*.
    This test also failed.
  prefs: []
  type: TYPE_NORMAL
- en: In his final attempt, Buerhaus changed the *1.png* in his URL from part of the
    URL to a parameter by converting the forward slash to a question mark. So instead
    of *[https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png)*,
    he submitted *[https://play.esea.net/global/media_preview.php?url=http://ziot.org?1.png](https://play.esea.net/global/media_preview.php?url=http://ziot.org?1.png)*.
    The first URL submits the request to his site looking for */1.png*. But the second
    URL causes the request to be made to the site home page *[http://ziot.org](http://ziot.org)*
    with *1.png* as a parameter in the request. As a result, ESEA rendered Buerhaus’s
    *[http://ziot.org](http://ziot.org)* web page.
  prefs: []
  type: TYPE_NORMAL
- en: Buerhaus had confirmed that he could make external HTTP requests and the site
    would render the response—a promising start. But invoking requests to any server
    might be an acceptable risk to companies if the server doesn’t disclose information
    or the website doesn’t do anything with the HTTP response. To escalate the severity
    of the SSRF, Buerhaus returned an XSS payload in his server’s response, as described
    in “[Attacking Users with SSRF Responses](ch10.xhtml#ch10lev1sec4)” on [page 98](ch10.xhtml#page_98).
  prefs: []
  type: TYPE_NORMAL
- en: He shared the vulnerability with Ben Sadeghipour to see if they could escalate
    it. Sadeghipour suggested submitting *http://169.254.169.254/latest/meta-data/hostname*.
    This is an IP address that Amazon Web Services (AWS) provides for sites it hosts.
    If an AWS server sends an HTTP request to this URL, AWS returns metadata about
    the server. Usually, this feature helps with internal automation and scripting.
    But the endpoint can also be used to access private information. Depending on
    the site’s AWS configuration, the endpoint *http://169.254.169.254/latest/meta-data/iam/security-credentials/*
    returns the Identify Access Manager (IAM) security credentials for the server
    performing the request. Because AWS security credentials are difficult to configure,
    it’s not uncommon for accounts to have more permissions than required. If you
    can access these credentials, you can use the AWS command line to control any
    service the user has access to. ESEA was in fact hosted on AWS, and the internal
    host name of the server was returned to Buerhaus. At this point, he stopped and
    reported the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Google dorking can save you time when you’re looking for vulnerabilities that
    require URLs set up in a specific way. If you use the tool to look for SSRF vulnerabilities,
    watch out for target URLs that appear to be interacting with external sites. In
    this case, the site was exposed by the URL parameter `url=`. When you find an
    SSRF, think big. Buerhaus could have reported the SSRF using the XSS payload,
    but that wouldn’t have been nearly as impactful as accessing the site’s AWS metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Internal DNS SSRF**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://toolbox.googleapps.com/](https://toolbox.googleapps.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://www.rcesecurity.com/2017/03/ok-google-give-me-all-your-internal-dns-information/](https://www.rcesecurity.com/2017/03/ok-google-give-me-all-your-internal-dns-information/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** January 2017'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Undisclosed'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes sites are meant to perform HTTP requests to external sites only. When
    you find sites with this functionality, check whether you can abuse it to access
    internal networks.
  prefs: []
  type: TYPE_NORMAL
- en: Google provides the site *[https://toolbox.googleapps.com](https://toolbox.googleapps.com)*
    to help users debug issues they’re having with Google’s G Suite services. That
    service’s DNS tool caught Julien Ahrens’s (*[www.rcesecurity.com](http://www.rcesecurity.com)*)
    attention because it allowed users to perform HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google’s DNS tools include dig, which acts just like the Unix `dig` command
    and allows users to query domain name servers for a site’s DNS information. DNS
    information maps an IP address to a readable domain, such as *www.<example>.com*.
    At the time of Ahrens’s finding, Google included two input fields: one for the
    URL to map to an IP address and the other for the domain name server, as shown
    in [Figure 10-1](ch10.xhtml#ch10fig01).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/10fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: An example query to the Google dig tool*'
  prefs: []
  type: TYPE_NORMAL
- en: Ahrens noticed the Name server field in particular because it allows users to
    specify an IP address to point the DNS query to. This significant discovery suggested
    that users could send DNS queries to any IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some IP addresses are reserved for internal use. They’re discoverable by internal
    DNS queries but shouldn’t be accessible through the internet. These reserved IP
    ranges include:'
  prefs: []
  type: TYPE_NORMAL
- en: 10.0.0.0 to 10.255.255.255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 100.64.0.0 to 100.127.255.255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 127.0.0.0 to 127.255.255.255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 172.16.0.0 to 172.31.255.255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 192.0.0.0 to 192.0.0.255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 198.18.0.0 to 198.19.255.255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, some IP addresses are reserved for specific purposes.
  prefs: []
  type: TYPE_NORMAL
- en: To begin testing the Name server field, Ahrens submitted his site as the server
    to look up and used the IP address 127.0.0.1 as the Name server. IP address 127.0.0.1
    is commonly referred to as the *localhost*, and a server uses it to refer to itself.
    In this case, localhost is the Google server executing the dig command. Ahrens’s
    test resulted in the error “Server did not respond.” The error implies that the
    tool was trying to connect to its own port 53 (the port that responds to DNS lookups)
    for information about Ahrens’s site, *[rcesecurity.com](http://rcesecurity.com)*.
    The wording “did not respond” is crucial because it implies that the server allows
    internal connections, whereas wording like “permission denied” would not. This
    red flag signaled Ahrens to keep testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Ahrens sent the HTTP request to the Burp Intruder tool so he could begin
    enumerating internal IP addresses in the 10.*x*.*x*.*x* range. After a couple
    of minutes, he received a response from one internal 10\. IP address (he purposely
    did not disclose which) with an empty A record, which is a type of record that
    DNS servers return. Although the A record was empty, it was for Ahrens’s website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ahrens had found a DNS server with internal access that would respond to him.
    An internal DNS server usually doesn’t know about external websites, which explains
    the empty A record. But the server should know how to map to internal addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the impact of the vulnerability, Ahrens had to retrieve information
    about Google’s internal network because information about an internal network
    shouldn’t be publicly accessible. A quick Google search revealed that Google used
    the subdomain *[corp.google.com](http://corp.google.com)* as the base for its
    internal sites. So Ahrens began brute-forcing subdomains from *[corp.google.com](http://corp.google.com)*,
    eventually revealing the domain *ad.corp.google.com*. Submitting this subdomain
    to the dig tool and requesting A records for the internal IP address Ahrens had
    found earlier returned Google’s private DNS information, which was far from empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the references to the internal IP addresses `100.REDACTED` and `172.REDACTED`.
    In comparison, the public DNS lookup for *ad.corp.google.com* returns the following
    record, which doesn’t include any information about the private IP addresses that
    Ahrens discovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Ahrens also requested the Name servers for *ad.corp.google.com* using Google’s
    DNS tools, which returned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, Ahrens discovered that at least one internal domain was publicly
    accessible to the internet: a Minecraft server at *minecraft.corp.google.com*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Be on the lookout for websites that include functionality to make external HTTP
    requests. When you find them, try pointing the request internally using the private
    network IP address 127.0.0.1 or the IP ranges listed in the example. If you discover
    internal sites, try to access them from an external source to demonstrate greater
    impact. Most likely, they’re only meant to be internally accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal Port Scanning Using Webhooks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Easy'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** October 2017'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Undisclosed'
  prefs: []
  type: TYPE_NORMAL
- en: '*Webhooks* allow users to ask one site to send a request to another remote
    site when certain actions occur. For example, an ecommerce site might allow users
    to set up a webhook that sends purchase information to a remote site every time
    a user submits an order. Webhooks that let the user define the URL of the remote
    site provide an opportunity for SSRFs. But the impact of any SSRFs might be limited
    because you can’t always control the request or access the response.'
  prefs: []
  type: TYPE_NORMAL
- en: While testing a site in October 2017, I noticed I could create custom webhooks.
    So I submitted the webhook URL as *http://localhost* to see whether the server
    would communicate with itself. The site said this URL wasn’t permitted, so I also
    tried *http://127.0.0.1*, which also returned an error message. Undeterred, I
    tried referencing 127.0.0.1 in other ways. The website *[https://www.psyon.org/tools/ip_address_converter.php?ip=127.0.0.1/](https://www.psyon.org/tools/ip_address_converter.php?ip=127.0.0.1/)*
    lists several alternative IP addresses, including 127.0.1, 127.1, and many others.
    Both appeared to work.
  prefs: []
  type: TYPE_NORMAL
- en: After submitting my report, I realized the severity of my finding was too low
    to warrant a bounty. All I had demonstrated was the ability to bypass the site’s
    localhost check. To be eligible for a reward, I had to demonstrate that I could
    compromise the site’s infrastructure or extract information.
  prefs: []
  type: TYPE_NORMAL
- en: The site also used a feature called web integrations, which allows users to
    import remote content to the site. By creating a custom integration, I could provide
    a remote URL that returns an XML structure for the site to parse and render for
    my account.
  prefs: []
  type: TYPE_NORMAL
- en: To start, I submitted 127.0.0.1 and hoped the site might disclose information
    about the response. Instead, the site rendered the error 500 “Unable to connect”
    in place of valid content. This error looked promising because the site was disclosing
    information about the response. Next, I checked whether I could communicate with
    ports on the server. I went back to the integration configuration and submitted
    127.0.0.1:443, which is the IP address to access and the server port separated
    by a colon. I wanted to see whether the site could communicate on port 443\. Again,
    I received the error 500 “Unable to connect.” I also received the same error for
    port 8080\. Then I tried port 22, which connects over SSH. This time the error
    was 503, “Could not retrieve all headers.”
  prefs: []
  type: TYPE_NORMAL
- en: Bingo. The “Could not retrieve all headers” response was sending HTTP traffic
    to a port expecting the SSH protocol. This response differs from a 500 response
    because it confirms that a connection can be made. I resubmitted my report to
    demonstrate that I could use web integrations to port scan the company’s internal
    server because responses were different for open/closed and filtered ports.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you can submit a URL to create webhooks or intentionally import remote content,
    try to define specific ports. Minor changes in how a server responds to different
    ports can reveal whether a port is open or closed or filtered. In addition to
    differences in the messages the server returns, ports might reveal whether they’re
    open or closed or filtered by how long it takes the server to respond to the request.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SSRFs occur when an attacker can leverage a server to perform unintended network
    requests. But not all requests are exploitable. For example, the fact that a site
    allows you to make a request to a remote or local server doesn’t mean it’s significant.
    Identifying the ability to make an unintended request is just the first step in
    identifying these bugs. The key to reporting them is to demonstrate the full impact
    of their behavior. In each example in this chapter, the sites allowed HTTP requests
    to be made. But they didn’t adequately protect their own infrastructure from malicious
    users.
  prefs: []
  type: TYPE_NORMAL
