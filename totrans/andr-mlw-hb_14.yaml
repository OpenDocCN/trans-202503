- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SMS FRAUD**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Imagine that a TV program asks viewers to contribute $25 to a relief organization
    by texting a code to a designated phone number. If you send such a code, the charge
    will be added to your phone bill, then transferred to the charitable organization.
    You’ll find SMS messages like these used for a number of legitimate purposes,
    such as to respond to a political poll or guess the winner of a football game.
  prefs: []
  type: TYPE_NORMAL
- en: Often, however, malicious apps can send codes to premium services without the
    user’s consent. The victim won’t know that this is happening until they receive
    their phone bill at the end of the month and discover the mysterious charges.
    We refer to this type of abuse as *SMS fraud*. SMS fraud malware focuses on making
    unauthorized charges to the user’s account but doesn’t include other malicious
    activity that relies on text messages, such as spyware or banking trojan behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we use the Extra-Trees classifier to evaluate the features
    useful for detecting Android SMS fraud apps. [Chapter 2](ch02.xhtml) introduced
    numerous such families, including BeeKeeper, Camera, Joker, RuFraud, RuPlay, Taicliphot,
    Wallpaper, and WallySMS. Additionally, our tests included Moundial, a smaller
    SMS fraud family previously unknown to the public that targeted Spanish Android
    users around 2014.
  prefs: []
  type: TYPE_NORMAL
- en: '**SMS Fraud vs. Goodware**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you take a look at the 20 most significant features for separating Android
    goodware from apps engaging in SMS fraud ([Figure 11-1](ch11.xhtml#ch11fig1)),
    you should notice something interesting: although 11 of these features are permission-related,
    none involve SMS permissions. Perhaps this is because various legitimate apps
    might use such permissions to, for example, allow messaging from within the app.
    We’ll discuss other possibilities in “[The Absence of SMS Permissions](ch11.xhtml#ch11lev1sec2)”
    on [page 270](ch11.xhtml#ch11lev1sec2).'
  prefs: []
  type: TYPE_NORMAL
- en: Like ransomware and rooting malware, SMS fraud apps invoke the `org.apache.http.com.scheme`
    and `org.apache.http.com` APIs more often than goodware. On the other hand, goodware
    generally makes more calls to many Android APIs, such as `android.content.res`,
    `android.view`, `android.media.session`, `android.view.accessibility`, and `android.os`.
    The one exception is the Wi-Fi API (`android.net.wifi`), which provides classes
    for Wi-Fi connectivity. We are not sure why SMS fraud apps use this more than
    goodware. It may simply be an artifact of previous malware developed by the same
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Non-SMS Permissions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve described many of the significant permissions in previous chapters. Some
    of these don’t appear to serve any purpose. For example, `MOUNT_UNMOUNT_FILESYSTEMS`
    and `INSTALL_PACKAGES` are privileged permissions, and SMS fraud apps tend to
    declare these but never use them. These apps may also request the `READ_LOGS`
    permission, though this permission doesn’t enable malicious functionality for
    unprivileged applications.
  prefs: []
  type: TYPE_NORMAL
- en: Other permissions can enable an app to perform tasks common to many forms of
    malware. For example, the `KILL_BACKGROUND_PROCESSES` and `RESTART_PACKAGES` permissions,
    the latter of which was deprecated in Android 4.0.3 (Ice Cream Sandwich), may
    be used to kill undesirable processes as part of a defense strategy. Also, the
    `RECEIVE_BOOT_COMPLETED` permission provides the easiest way for malware to persist
    by automatically restarting after a phone reboot.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining permissions have clear uses specific to SMS fraud. The `READ_PHONE_STATE`
    permission allows the app to read configuration settings for the phone’s telephony
    stack, for example to find out the device’s phone number or mobile carrier. As
    premium short codes are carrier-specific, malware needs this information to target
    the right mobile carrier. We see that the probability of this permission being
    requested by apps engaged in SMS fraud is over 80 percent, more than double the
    probability of goodware requesting it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: Top 20 features that best distinguish Android SMS fraud malware
    from goodware using the Extra-Trees classifier*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.xhtml), we noted that apps can use the `ACCESS_WIFI_STATE`
    permission to access the Android `WifiManager` and get the state of the device’s
    Wi-Fi connection. SMS fraud happens over the telephony stack rather than the Wi-Fi
    stack; even so, multiple SMS fraud families attempt to understand the device’s
    Wi-Fi state. This may be because these apps want to have the Wi-Fi stack as a
    backup option. The probability of this permission being requested by SMS fraud
    apps is almost exactly twice that of its being requested by goodware.
  prefs: []
  type: TYPE_NORMAL
- en: Apps use the `GET_TASKS` permission to identify the processes running on the
    device. Almost 70 percent of apps engaging in SMS fraud request this permission,
    compared to less than than 20 percent of goodware. Malicious apps may seek this
    permission for a number of reasons, such as to see whether there is an antivirus
    engine running.
  prefs: []
  type: TYPE_NORMAL
- en: The `SYSTEM_ALERT_WINDOW` permission is used to display notification windows,
    presumably to inform the user of legitimate issues. However, SMS fraud apps may
    use this capability to obscure the screen. For instance, if the compromised device’s
    mobile carrier sends a request to authenticate a potential SMS fraud transaction,
    this permission may enable the malware to obscure the window while it responds
    to the incoming text. The probability of SMS fraud apps requesting this permission
    is four to five times higher than the probability of goodware doing so.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Absence of SMS Permissions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The absence of SMS-related permissions in the top 20 features list may have
    surprised you. Surely, an SMS fraud app needs to write and send SMS messages in
    order to carry out its malicious work. If we look at the top 50 features, we’ll
    find the `WRITE_SMS` permission in position 33, suggesting that this permission
    is indeed somewhat important for distinguishing SMS fraud apps from goodware.
  prefs: []
  type: TYPE_NORMAL
- en: Still, the scarcity of other SMS-related permissions is puzzling. Because different
    classifiers identify the important features in different ways, we therefore checked
    whether other classifiers would consider these permissions more relevant. [Figure
    11-2](ch11.xhtml#ch11fig2) shows the top 20 features generated by the random forest
    classifier.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this classifier uses very different features from the Extra-Trees
    classifier to separate goodware from SMS fraud apps. In fact, it ranks `SEND_SMS`
    as the most important feature! The probability of apps engaging in SMS fraud requesting
    this permission is over eight times that of goodware requesting it, according
    to this model. The `RECEIVE_SMS`, `WRITE_SMS`, and `READ_SMS` permissions all
    also appear in the list of top 20 features, with SMS fraud apps requesting all
    of them far more frequently than goodware.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the top features suggested by the XGBoost classifier, shown
    in [Figure 11-3](ch11.xhtml#ch11fig3). Here too, we saw a different set of features
    identified as important, and `SEND_SMS` and `RECEIVE_SMS` appear in the top 20.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Top 20 features that best distinguish Android SMS fraud malware
    from goodware using the random forest classifier*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Top 20 features that best distinguish Android SMS fraud malware
    from goodware using the XGBoost classifier*'
  prefs: []
  type: TYPE_NORMAL
- en: As these results indicate, different machine learning methods may identify different
    features as being the most important. For example, one method might consider every
    feature from the total set of features and measure the value of each by calculating
    the drop in predictive performance of a machine learning algorithm when that feature
    is removed. The greater the drop, the more important the feature is. Other methods
    might use well-known statistical models, such as mutual information or principal
    component analysis (PCA). In addition to the statistical methods used, the design
    and structure of the classifiers themselves influence the identification of different
    sets of prominent features.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we constructed a decision tree for separating SMS fraud apps from goodware.
    You can see the first three levels of the decision tree in [Figure 11-4](ch11.xhtml#ch11fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: A decision tree with a depth of three for distinguishing Android
    SMS fraud malware from goodware*'
  prefs: []
  type: TYPE_NORMAL
- en: This decision tree branches to the left child of a node when the condition stated
    in the node is true; otherwise, it branches to the right. The `SEND_SMS` permission
    is at level two in the tree, immediately below the root, attesting to the importance
    that this type of classifier places on it.
  prefs: []
  type: TYPE_NORMAL
- en: The right child of this node checks the number of times that classes in the
    *android.content.res* package are called in an app’s source code. This package
    contains classes used to access various files and media, as well as parameters
    that configure the device. If the number of calls is smaller than or equal to
    82.0 and the app requests the `SEND_SMS` permission, then there is a probability
    of 1106/1108 (almost 100 percent) of the app being an SMS fraud app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, two other branches in this decision tree do not depend at all
    on the `SEND_SMS` permission being used, which may explain why the initial set
    of top 20 features generated by the Extra-Trees classifier didn’t identify any
    SMS-related permissions. One of the paths checks the following: that there are
    fewer than 82 calls to classes in the *android.content.res* package, that the
    app does not request the `SEND_SMS` permission, and that there are more than 1.5
    calls to classes in *org.apache.http.conn.scheme*. If all of these conditions
    are met, there is a 100 percent probability of the app being SMS fraud malware.
    The other path checks whether there are more than 82 calls to classes in *android.content.res*
    and more than 5.5 calls to classes in *org.apache.http.conn.scheme*, which also
    results in a 100 percent probability of the app being SMS fraud.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results described in this section teach us a valuable lesson about machine
    learning for malware analysis: be sure to look at different classifiers for clues
    about what to examine manually in the code. Looking at the results generated by
    just one classifier, even one with high performance, may lead to skewed inferences
    about the importance of particular app elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Prediction Efficacy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 11-1](ch11.xhtml#ch11tab1) shows the performance of various machine
    learning classifiers at predicting whether an app is engaged in SMS fraud or is
    goodware, given different sets and combinations of basic and advanced features.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Evaluation of Android SMS Fraud Malware vs. Goodware'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature set** | **Best classifier** | **AUC** | **Precision** | **Recall**
    | **F1** | **FPR** | **FNR** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| API package | GBDT | 0.9862 | 0.9483 | 0.9161 | 0.9319 | 0.0517 | 0.0293
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static (S | RF | 0.9792 | 0.9780 | 0.9208 | 0.9485 | 0.0220 | 0.0275 |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic (S) | MLP | 0.9056 | 0.8972 | 0.5759 | 0.7015 | 0.1028 | 0.1332 |'
  prefs: []
  type: TYPE_TB
- en: '| S + D | XGBoost | 0.9810 | 0.9819 | 0.9208 | 0.9504 | 0.0181 | 0.0274 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D | XGBoost | 0.9975 | 0.9837 | 0.9642 | 0.9738 | 0.0163 | 0.0126
    |'
  prefs: []
  type: TYPE_TB
- en: '| TSG | XGBoost | 0.9872 | 0.9463 | 0.9142 | 0.9300 | 0.0537 | 0.0300 |'
  prefs: []
  type: TYPE_TB
- en: '| LM | RF | 0.8737 | 0.6654 | 0.6748 | 0.6701 | 0.3346 | 0.1157 |'
  prefs: []
  type: TYPE_TB
- en: '| FC | SVM | 0.8833 | 0.9127 | 0.5024 | 0.6480 | 0.0873 | 0.1519 |'
  prefs: []
  type: TYPE_TB
- en: '| CG | RF | 0.8519 | 0.9000 | 0.6532 | 0.7570 | 0.1000 | 0.1119 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + TSG | XGBoost | 0.9457 | 0.8845 | 0.8803 | 0.8824 | 0.1155
    | 0.1199 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + LM | RF | 0.9975 | 0.9827 | 0.9661 | 0.9743 | 0.0173 | 0.0119
    |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + FC | GBDT | 0.9974 | 0.9837 | 0.9651 | 0.9743 | 0.0163 | 0.0123
    |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + CG | XGBoost | 0.9975 | 0.9827 | 0.9642 | 0.9734 | 0.0173 |
    0.0126 |'
  prefs: []
  type: TYPE_TB
- en: '| All features | XGBoost | 0.9974 | 0.9827 | 0.9642 | 0.9734 | 0.0173 | 0.0126
    |'
  prefs: []
  type: TYPE_TB
- en: '| Best late fusion | XGBoost | 0.9973 | 0.9809 | 0.9670 | **0.9739** | 0.0191
    | 0.0116 |'
  prefs: []
  type: TYPE_TB
- en: As these results show, using the late fusion approach, machine learning techniques
    are able to generate excellent results, with a precision of over 98 percent and
    a recall of over 96 percent.
  prefs: []
  type: TYPE_NORMAL
- en: '**SMS Fraud vs. Other Malware**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 11-5](ch11.xhtml#ch11fig5) shows the 20 most important features for
    distinguishing SMS fraud apps from other forms of malware, according to the Extra-Trees
    classifier. As you can see, SMS-related permissions play an important role here,
    so we’ll focus on those.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Permission-Related Features***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although the Extra-Trees classifier does not rely on SMS-related permissions
    for distinguishing SMS fraud malware from goodware, it does find them useful for
    distinguishing this type of malware from other forms. Around 70 percent of SMS
    fraud apps seek the `SEND_SMS`, `READ_SMS`, and `RECEIVE_SMS` permissions, compared
    to less than 20 percent of other malware. Likewise, 50 percent of SMS fraud apps
    seek the `WRITE_SMS` permission, compared to about 20 percent of other malware.
    You might be wondering why some SMS fraud apps don’t need these permissions. The
    reason is that certain of these apps trick the user into sending premium SMS messages
    themselves. This doesn’t require the `SEND_SMS` permission; the app opens the
    default SMS app and hopes that the user will click the Send button on their own.
  prefs: []
  type: TYPE_NORMAL
- en: On a related note, we see that SMS fraud apps are more than twice as likely
    as other types of malware to request the `CALL_PHONE` permission (over 40 percent
    do, compared to less than 20 percent of other malware). One explanation for this
    difference could be that some SMS fraud families also dabble in other forms of
    telephony-related fraud. For example, the RuPlay family contains code to redirect
    outgoing calls to a phone number provided by the malware developers, while the
    BeeKeeper family contains code to both redirect outgoing calls and make new phone
    calls to these numbers. Redirecting outgoing calls also requires the `PROCESS_OUTGOING_CALLS`
    permission, which enables apps to learn about outgoing calls in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: Top 20 features that best distinguish Android SMS fraud malware
    from other malware using the Extra-Trees classifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Also of note is that SMS fraud apps access the `READ_LOGS`, `ACCESS_WIFI_STATE`,
    and `RESTART_PACKAGES` permissions less frequently than other malware. However,
    like ransomware, they invoke the functions `org.apache.http.conn` and `org.apache.http.conn.schema`
    more frequently than other forms of malware. The same is also true for `org.apache.http.params`
    as well as some Android APIs, such as those from the packages *android.app*, *android.net*,
    *android.content*, and *android.content.pm*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Prediction Efficacy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 11-2](ch11.xhtml#ch11tab2) shows how our machine learning approaches
    perform at distinguishing between apps engaging in SMS fraud and other forms of
    malicious apps.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-2:** Metrics for Evaluating Android SMS Fraud Malware vs. Other
    Malware'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature set** | **Best classifier** | **AUC** | **Precision** | **Recall**
    | **F1** | **FPR** | **FNR** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| API package | XGBoost | 0.8075 | 0.8135 | 0.7921 | 0.8027 | 0.1865 | 0.2043
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static (S) | XGBoost | 0.7739 | 0.7652 | 0.7926 | 0.7787 | 0.2348 | 0.2165
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic (D) | RF | 0.6756 | 0.6395 | 0.6739 | 0.6563 | 0.3605 | 0.3470 |'
  prefs: []
  type: TYPE_TB
- en: '| S + D | GBDT | 0.7949 | 0.7977 | 0.7827 | 0.7901 | 0.2023 | 0.2151 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D | GBDT | 0.8209 | 0.8088 | 0.8172 | 0.8129 | 0.1912 | 0.1856
    |'
  prefs: []
  type: TYPE_TB
- en: '| TSG | RF | 0.7097 | 0.7110 | 0.7097 | 0.7104 | 0.2890 | 0.2917 |'
  prefs: []
  type: TYPE_TB
- en: '| LM | RF | 0.7443 | 0.7611 | 0.5992 | 0.6705 | 0.2389 | 0.3328 |'
  prefs: []
  type: TYPE_TB
- en: '| FC | SVM | 0.5459 | 0.5222 | 0.6211 | 0.5674 | 0.4778 | 0.4713 |'
  prefs: []
  type: TYPE_TB
- en: '| CG | RF | 0.7443 | 0.7611 | 0.5992 | 0.6705 | 0.2389 | 0.3328 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + TSG | GBDT | 0.9180 | 0.8619 | 0.8351 | 0.8483 | 0.1381 | 0.1610
    |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + LM | XGBoost | 0.8718 | 0.8385 | 0.7667 | 0.8010 | 0.1615 |
    0.2166 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + FC | GBDT | 0.8791 | 0.8388 | 0.7653 | 0.8004 | 0.1612 | 0.2171
    |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + CG | GBDT | 0.8983 | 0.8688 | 0.7912 | 0.8282 | 0.1312 | 0.1932
    |'
  prefs: []
  type: TYPE_TB
- en: '| All features | XGBoost | 0.9168 | 0.8635 | 0.8285 | 0.8456 | 0.1365 | 0.1659
    |'
  prefs: []
  type: TYPE_TB
- en: '| Best late fusion | XGBoost | 0.9377 | 0.9273 | 0.9075 | **0.9173** | 0.0727
    | 0.0750 |'
  prefs: []
  type: TYPE_TB
- en: Not surprisingly, predictive accuracy decreases when separating SMS fraud apps
    from other malware. Precision drops to under 93 percent, while recall drops to
    just below 92 percent. Nevertheless, these are still strong results.
  prefs: []
  type: TYPE_NORMAL
- en: '**BeeKeeper: A Case Study**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a look at the BeeKeeper SMS fraud malware *angrybirds.app* (v16,
    51fe). Widely distributed around 2013, the malware targeted the Russian Beeline
    carrier. [Listing 11-1](ch11.xhtml#ch11lis1) shows the list of permissions requested
    by the app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: All permissions requested by the BeeKeeper SMS fraud malware*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that it requests permissions like `SEND_SMS`, which is necessary
    for sending the text messages that perpetrate SMS fraud, and `RECEIVE_SMS`, which
    the malware uses to receive command-and-control messages over SMS when a network
    connection to its internet-based command-and-control server is unavailable. The
    `CALL_PHONE` and `PROCESS_OUTGOING_CALLS` permissions are also noteworthy. BeeKeeper
    uses these to make phone calls to numbers received from its command-and-control
    server and redirect outgoing calls to other numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-2](ch11.xhtml#ch11lis2) shows one of the several code sections
    involved in sending SMS fraud messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: A heavily obfuscated code snippet showing the BeeKeeper SMS
    fraud malware sending SMS messages*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the app extracting the compromised device’s IMEI and IMSI numbers,
    its phone number, and its country. A very long encoded string argument passed
    to the `decript` method (which we’ve shortened here for brevity) is found inside
    an `if` statement whose condition is always false. We cannot be sure why the malware’s
    author made this choice; perhaps they wanted to prevent it from executing during
    testing, which they did by setting the `if` condition to false, and then never
    turned it back on. Lastly, the app acquires subscription information and executes
    the `sendSms` function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Predictions for SMS Fraud Samples**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Table 11-3](ch11.xhtml#ch11tab3) shows how our machine learning classifiers
    performed on 10 important SMS fraud samples.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-3:** Performance of Machine Learning Classifiers on SMS Fraud Families'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sample name** | **Distinguished from goodware** | **Distinguished from
    other malware** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| BeeKeeper | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Camera | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| HDC Bookmark | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Joker | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Moundial | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| RuFraud | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| RuPlay | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| TaiClipHot | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Wallpaper | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| WallySMS | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: As you can see, in every case, they (that is, our late fusion ensemble) correctly
    classified the samples as SMS fraud apps rather than goodware. However, there
    were two prediction errors when we used the classifiers to determine whether the
    samples were SMS fraud apps or another form of malware. Importantly, one of these
    errors occurred when classifying Joker, a malware family likely created by a large
    criminal syndicate that has taken extensive steps to evade detection. The malware’s
    many variants incorporate one evasion strategy after another in a cat-and-mouse
    game that has been going on since 2016, leading to increasingly complex anti-analysis
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Up Next**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ve seen in this chapter, machine learning models provided with a combination
    of features are able to successfully predict whether an app is goodware or an
    SMS fraud app. Permissions play a major role in these apps’ behavior and are also
    significant factors that distinguish SMS fraud apps from other Android malware.
    However, you’ve also seen that no single feature discussed since [Chapter 7](ch07.xhtml)
    can, on its own, identify a particular kind of malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'To maximize detection effectiveness, we recommend using these machine learning
    methods in conjunction with the manual analysis techniques described in [Part
    II](part2.xhtml). Use the machine learning models as a triage system, similar
    to the process employed in a hospital emergency room: analysts should first examine
    apps flagged as highly likely to be malicious before specialists take a deeper
    look.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the last malware category chapter. In the next and final chapter, we
    will share our thoughts on the future of Android malware and the future of malware
    detection with machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  prefs: []
  type: TYPE_NORMAL
