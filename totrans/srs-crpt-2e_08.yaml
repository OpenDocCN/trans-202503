- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">STREAM
    CIPHERS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">流加密</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Symmetric ciphers can be either block ciphers or stream ciphers. Recall from
    [Chapter 4](chapter4.xhtml) that block ciphers mix chunks of plaintext bits together
    with key bits to produce chunks of ciphertext of the same size, usually 64 or
    128 bits. Stream ciphers, on the other hand, don’t mix plaintext and key bits;
    instead, they generate pseudorandom bits from the key and encrypt the plaintext
    by XORing it with the pseudorandom bits, in the same fashion as the one-time pad
    explained in [Chapter 1](chapter1.xhtml).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密可以是分组加密或流加密。回顾[第4章](chapter4.xhtml)，分组加密将明文的若干位与密钥位混合，生成相同大小的密文块，通常为64位或128位。另一方面，流加密不混合明文和密钥位；相反，它们从密钥生成伪随机位，通过将其与明文进行异或加密，类似于[第1章](chapter1.xhtml)中解释的一次性密码本。
- en: Stream ciphers are sometimes shunned because they have historically been more
    fragile than block ciphers and are more often broken—both the experimental ones
    designed by amateurs and the ciphers deployed in systems used by millions, including
    mobile phones, Wi-Fi, and public transport smart cards. But fortunately, although
    it’s taken almost 20 years, we now know how to design secure stream ciphers, and
    we trust them to protect Bluetooth connections, mobile 4G communications, and
    TLS connections.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 流加密有时被排斥，因为它们在历史上比分组加密更脆弱，更容易被破解——无论是业余爱好者设计的实验性算法，还是被数百万用户使用的系统中的加密算法，包括手机、Wi-Fi和公共交通智能卡。但幸运的是，尽管花了将近20年时间，我们现在知道如何设计安全的流加密算法，并信任它们来保护蓝牙连接、移动4G通信和TLS连接。
- en: 'This chapter first presents how stream ciphers work and discusses the two main
    classes of stream ciphers: stateful and counter based. We’ll then study hardware-
    and software-oriented stream ciphers and look at some insecure ciphers (A5/1 as
    used in GSM mobile communications, and RC4 in older version of TLS) and secure,
    state-of-the-art ones (Grain-128a for hardware and Salsa20 for software).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍流加密的工作原理，并讨论流加密的两大主要类别：有状态流加密和基于计数器的流加密。然后我们将研究硬件和软件导向的流加密算法，并查看一些不安全的加密算法（如在GSM移动通信中使用的A5/1和在旧版TLS中使用的RC4）以及安全的、最先进的算法（如硬件中的Grain-128a和软件中的Salsa20）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Stream Ciphers Work</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">流加密的工作原理</samp>
- en: Stream ciphers are more akin to deterministic random bit generators (DRBGs)
    than block ciphers because they generate a stream of pseudorandom bits rather
    than directly mixing plaintext data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 流加密更像是确定性随机比特生成器（DRBG），而非分组加密，因为它们生成的是伪随机比特流，而不是直接混合明文数据。
- en: 'What sets stream ciphers apart from DRBGs is that DRBGs take a single input
    value, whereas stream ciphers take two values: a key and a nonce. The key should
    be secret and is usually 128 or 256 bits. The nonce doesn’t have to be secret,
    but it should be unique for each key and is usually between 64 and 128 bits.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 流加密与确定性随机比特生成器（DRBG）不同之处在于，DRBG只接受一个输入值，而流加密接受两个值：一个密钥和一个随机数。密钥应当保密，通常为128位或256位。随机数不必保密，但应当对每个密钥唯一，通常为64位到128位之间。
- en: Stream ciphers produce a pseudorandom stream of bits we call the *keystream*.
    To encrypt the keystream, we XOR it to a plaintext and then XOR it again to the
    ciphertext to decrypt it. [Figure 5-1](chapter5.xhtml#fig5-1) shows the basic
    stream cipher encryption operation, where **SC** is the stream cipher algorithm,
    *KS* the keystream, *P* the plaintext, and *C* the ciphertext.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 流加密生成我们称之为*密钥流*的伪随机比特流。为了加密密钥流，我们将其与明文进行异或操作，然后再与密文进行异或操作以解密。[图5-1](chapter5.xhtml#fig5-1)展示了基本的流加密操作，其中**SC**是流加密算法，*KS*是密钥流，*P*是明文，*C*是密文。
- en: '![](../images/fig5-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: How stream ciphers
    encrypt, taking a secret key,</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, and a public nonce,</samp> <samp class="SANS_Futura_Std_Book_11">N</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-1：流加密如何加密，使用一个秘密密钥</samp>
    <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">和一个公共随机数</samp>
    <samp class="SANS_Futura_Std_Book_11">N</samp>
- en: A stream cipher computes *KS* = **SC**(*K*, *N*), encrypts as *C* = *P* ⊕ *KS*,
    and decrypts as *P* = *C* ⊕ *KS*. The encryption and decryption functions are
    the same because both do the same thing—namely, XOR bits with the keystream. That’s
    why, for example, certain cryptographic libraries provide a single <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt</samp>
    function for both encryption and decryption.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码计算 *KS* = **SC**(*K*, *N*)，加密过程为 *C* = *P* ⊕ *KS*，解密过程为 *P* = *C* ⊕ *KS*。加密和解密函数是相同的，因为它们执行的是相同的操作——即用密钥流对位进行异或运算。因此，例如，某些加密库提供一个单一的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt</samp> 函数来处理加密和解密。
- en: Stream ciphers allow you to encrypt a message with key *K*[1] and nonce *N*[1]
    and then encrypt another message with key *K*[1] and nonce *N*[2] that’s different
    from *N*[1], or with key *K*[2], which is different from *K*[1] and nonce *N*[1].
    However, you should never again encrypt with *K*[1] and *N*[1] because you would
    use the same keystream *KS* twice. That is, you’d have a first ciphertext *C*[1]
    = *P*[1] ⊕ *KS* and a second ciphertext *C*[2] = *P*[2] ⊕ *KS*, and if you know
    *P*[1], then you could determine *P*[2] = *C*[1] ⊕ *C*[2] ⊕ *P*[1].
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码允许你使用密钥 *K*[1] 和随机数 *N*[1] 加密一条消息，然后使用不同的密钥 *K*[1] 和随机数 *N*[2] 加密另一条消息，或者使用密钥
    *K*[2]（不同于 *K*[1]）和随机数 *N*[1]。然而，你绝不应再使用 *K*[1] 和 *N*[1] 进行加密，因为这样会重复使用相同的密钥流
    *KS*。也就是说，你将得到第一个密文 *C*[1] = *P*[1] ⊕ *KS* 和第二个密文 *C*[2] = *P*[2] ⊕ *KS*，如果你知道
    *P*[1]，那么你可以通过 *C*[1] ⊕ *C*[2] ⊕ *P*[1] 来确定 *P*[2]。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: Nonce *is short for “number used only once.” In the context of stream ciphers,
    we sometimes call it the* IV*, for “initial value.”*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数 *是“仅使用一次的数字”（number used only once）的缩写。在流密码的上下文中，我们有时称其为*IV*，即“初始化值”（initial
    value）。*
- en: 'From a high-level perspective, there are two types of stream ciphers: stateful
    and counter based. *Stateful stream ciphers* have a secret internal state that
    evolves throughout keystream generation. The cipher initializes the state from
    the key and the nonce and then calls an update function to update the state value
    and produce one or more keystream bits from the state, as [Figure 5-2](chapter5.xhtml#fig5-2)
    shows. For example, RC4 is stateful while Salsa20 is counter based.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，流密码分为两种类型：有状态流密码和基于计数器的流密码。*有状态流密码* 有一个在生成密钥流过程中不断变化的内部状态。该密码从密钥和随机数初始化状态，然后调用更新函数以更新状态值，并从状态生成一个或多个密钥流位，如[图5-2](chapter5.xhtml#fig5-2)所示。例如，RC4
    是有状态的，而 Salsa20 是基于计数器的。
- en: '![](../images/fig5-2.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: A stateful stream
    cipher</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-2：有状态流密码</samp>
- en: '*Counter-based stream ciphers* produce chunks of a keystream from a key, a
    nonce, and a counter value, as in [Figure 5-3](chapter5.xhtml#fig5-3). Unlike
    stateful stream ciphers, counter-based stream ciphers such as Salsa20 don’t keep
    track of a secret during keystream generation, apart from the counter’s value.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于计数器的流密码* 通过一个密钥、一个随机数和一个计数器值生成密钥流块，如[图5-3](chapter5.xhtml#fig5-3)所示。与有状态流密码不同，基于计数器的流密码，如
    Salsa20，在生成密钥流时不跟踪任何秘密信息，除了计数器的值。'
- en: '![](../images/fig5-3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: A counter-based
    stream cipher</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-3：基于计数器的流密码</samp>
- en: 'These two approaches define the high-level architecture of the stream cipher,
    regardless of how the core algorithms work. The internals of the stream cipher
    also fall into two categories, depending on the target platform of the cipher:
    hardware oriented and software oriented.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法定义了流密码的高级架构，和核心算法如何工作无关。流密码的内部结构也分为两类，具体取决于密码的目标平台：硬件导向和软件导向。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hardware-Oriented Stream Ciphers</samp>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">硬件导向流密码</samp>
- en: When cryptographers talk about hardware, they mean application-specific integrated
    circuits (ASICs), programmable logic devices (PLDs), and field-programmable gate
    arrays (FPGAs). A cipher’s hardware implementation is an electronic circuit that
    implements the cryptographic algorithm at the bit level and that can’t be used
    for anything else; in other words, the circuit is *dedicated hardware*. On the
    other hand, software implementations of cryptographic algorithms simply tell a
    microprocessor what instructions to execute in order to run the algorithm. These
    instructions operate on bytes or words and then call pieces of electronic circuits
    that implement general-purpose operations such as addition and multiplication.
    Software deals with bytes or words of 32 or 64 bits, whereas hardware deals with
    bits. The first stream ciphers worked with bits to save complex wordwise operations
    and thus be more efficient in hardware, their target platform at the time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当密码学家谈论硬件时，他们指的是专用集成电路（ASIC）、可编程逻辑设备（PLD）和现场可编程门阵列（FPGA）。一个密码算法的硬件实现是一个电子电路，它在比特级别上实现密码学算法，且不能用于其他任何用途；换句话说，该电路是*专用硬件*。另一方面，密码学算法的软件实现只是告诉微处理器执行什么指令来运行该算法。这些指令作用于字节或字（byte/word），然后调用一些实现通用操作（如加法和乘法）的电子电路。软件处理的是32位或64位的字节或字，而硬件处理的是比特（bit）。最早的流密码算法处理的是比特，以节省复杂的字级操作，从而在硬件上更加高效，这是当时它们的目标平台。
- en: Stream ciphers were mainly used for hardware implementations because they were
    cheaper than block ciphers. They needed less memory and fewer logical gates than
    block ciphers and therefore occupied a smaller area on an integrated circuit,
    which reduced fabrication costs. For example, counting in gate-equivalents, the
    standard area metric for integrated circuits, you could find stream ciphers taking
    less than 1,000 gate-equivalents; by contrast, typical software-oriented block
    ciphers needed at least 10,000 gate-equivalents, making crypto an order of magnitude
    more expensive than with stream ciphers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码算法主要用于硬件实现，因为它们比块密码算法更便宜。它们需要的内存和逻辑门比块密码算法少，因此在集成电路上占用的面积更小，从而降低了制造成本。例如，按门等效数计算，这是集成电路的标准面积度量，你会发现流密码算法只需要不到1000个门等效；相比之下，典型的面向软件的块密码算法至少需要10000个门等效，使得加密比使用流密码算法时贵了一个数量级。
- en: Today, however, block ciphers are no longer more expensive than stream ciphers—first,
    because there are now hardware-friendly block ciphers about as small as stream
    ciphers, and second, because the cost of hardware has plunged. Yet stream ciphers
    are often associated with hardware because they used to be the best option.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今块密码算法的成本不再高于流密码算法——首先，因为现在有一些硬件友好的块密码算法，它们的体积几乎和流密码一样小，其次，因为硬件成本大幅下降。然而，流密码算法通常与硬件相关联，因为它们曾是最优选择。
- en: In the next section, I’ll explain the basic mechanism behind hardware stream
    ciphers, called *feedback shift registers (FSRs)*. Almost all hardware stream
    ciphers rely on FSRs in some way, whether that’s the A5/1 cipher used in 2G mobile
    phones or the more recent Grain-128a cipher.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将解释硬件流密码背后的基本机制，即*反馈移位寄存器（FSR）*。几乎所有硬件流密码都以某种方式依赖于FSR，无论是2G手机中使用的A5/1密码，还是更新的Grain-128a密码。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The first standard block cipher, the Data Encryption Standard (DES), was optimized
    for hardware rather than software. When the US government standardized DES in
    the 1970s, most target applications were hardware implementations. It’s therefore
    no surprise that the S-boxes in DES are small and fast to compute when implemented
    as a logical circuit in hardware but inefficient in software. Unlike DES, the
    current Advanced Encryption Standard (AES) deals with bytes and is therefore more
    efficient in software than DES.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一个标准块密码算法，数据加密标准（DES），是为了硬件优化的，而非软件。当美国政府在1970年代将DES标准化时，大多数目标应用都是硬件实现。因此，DES中的S盒在硬件实现时非常小且计算快速，但在软件中却效率低下，这也就不足为奇了。与DES不同，当前的高级加密标准（AES）处理的是字节，因此在软件中比DES更加高效。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Feedback Shift Registers</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">反馈移位寄存器</samp>
- en: Countless stream ciphers use FSRs because they’re simple and well understood.
    An FSR is an array of bits equipped with an update *feedback function*, which
    I’ll denote as **f**. The FSR’s state is stored in the array, or register, and
    each *update* of the FSR uses the feedback function to change the state’s value
    and to produce one output bit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无数的流密码使用 FSR，因为它们简单且易于理解。FSR 是一个由比特组成的数组，配备了一个更新的 *反馈函数*，我将其表示为 **f**。FSR 的状态存储在数组或寄存器中，每次
    *更新* FSR 时，使用反馈函数来更改状态值并产生一个输出比特。
- en: 'In practice, an FSR works like this: if *R*[0] is the initial value of the
    FSR, the next state, *R*[1], is defined as *R*[0] left-shifted by 1 bit, where
    the bit leaving the register is returned as output and where the empty position
    is filled with **f**(*R*[0]).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，FSR 的工作方式如下：如果 *R*[0] 是 FSR 的初始值，那么下一状态 *R*[1] 被定义为将 *R*[0] 向左移 1 位，其中离开寄存器的比特作为输出，而空缺的位置由
    **f**(*R*[0]) 填充。
- en: 'We repeat the same rule to compute the subsequent state values *R*[2], *R*[3],
    and so on. That is, given *R*t, the FSR’s state at time *t*, the next state, *R*t
    [+ 1], is the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复相同的规则来计算后续的状态值 *R*[2]、*R*[3] 等。也就是说，给定 *R*t，FSR 在时刻 *t* 的状态，下一状态 *R*[t +
    1] 为以下内容：
- en: '![](../images/pg91-1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg91-1.jpg)'
- en: 'In this equation, <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> is
    the logical OR operator, and <samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>
    is the shift operator, as used in the C language. For example, given the 8-bit
    string 00001111, we have this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方程中，<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> 是逻辑或运算符，<samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>
    是移位运算符，像 C 语言中使用的那样。例如，给定 8 位字符串 00001111，我们得到：
- en: '![](../images/pg91-2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg91-2.jpg)'
- en: The bit shift moves the bits to the left, losing the leftmost bit to retain
    the state’s bit length and zeroing the rightmost bit. The update operation of
    an FSR is identical, except that instead of being set to 0, the rightmost bit
    is set to **f**(*R*t).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 比特移位将比特向左移动，丢失最左边的比特以保持状态的比特长度，并将最右边的比特归零。FSR 的更新操作是相同的，唯一不同的是最右边的比特不被设置为 0，而是被设置为
    **f**(*R*t)。
- en: 'Consider, for example, a 4-bit FSR whose feedback function **f** XORs all 4
    bits together. Initialize the state to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个 4 比特的 FSR，其反馈函数 **f** 对所有 4 比特进行异或运算。将状态初始化为以下内容：
- en: '![](../images/pg91-3.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg91-3.jpg)'
- en: 'Now shift the bits to the left, where 1 is output and the rightmost bit is
    set to the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将比特向左移动，其中 1 是输出，最右边的比特设置为以下内容：
- en: '![](../images/pg91-4.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg91-4.jpg)'
- en: 'Now the state becomes this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态变为：
- en: '![](../images/pg91-5.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg91-5.jpg)'
- en: 'The next update outputs 1, left-shifts the state, and sets the rightmost bit
    to the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次更新输出 1，将状态左移，并将最右边的比特设置为以下内容：
- en: '![](../images/pg91-6.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg91-6.jpg)'
- en: 'Now the state is this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态如下：
- en: '![](../images/pg91-7.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg91-7.jpg)'
- en: 'The next three updates return three 0 bits and give the following state values:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三次更新返回三个 0 比特，并给出以下状态值：
- en: '![](../images/pg91-8.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg91-8.jpg)'
- en: We thus return to our initial state of 1100 after five iterations; updating
    the state five times from any of the values observed throughout this cycle returns
    us to this initial value. We say that 5 is the *period* of the FSR given any one
    of the values 1100, 1000, 0001, 0011, or 0110\. Because the period of this FSR
    is 5, clocking the register 10 times yields twice the same 5-bit sequence. Likewise,
    if you clock the register 20 times, starting from 1100, the output bits will be
    11000110001100011000, or four times the same 5-bit sequence of 11000\. Intuitively,
    such repeating patterns should be avoided, and a longer period is better for security.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在五次迭代后我们回到了初始状态 1100；从此循环中观察到的任何值更新状态五次都能回到这个初始值。我们说，给定任一值 1100、1000、0001、0011
    或 0110，5 是 FSR 的 *周期*。因为该 FSR 的周期是 5，时钟信号钟动寄存器 10 次会得到两次相同的 5 位序列。同样，如果从 1100
    开始时钟信号钟动寄存器 20 次，输出比特将是 11000110001100011000，或者四次相同的 5 位序列 11000。直观上，这种重复模式应该避免，较长的周期对安全性更好。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*If you plan to use an FSR in a stream cipher, avoid one with short periods,
    which make the output more predictable. With some types of FSRs, it’s easy to
    figure out their period, but it’s almost impossible to do so with others.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你打算在流密码中使用 FSR，请避免使用周期较短的 FSR，因为它们的输出更容易预测。对于某些类型的 FSR，容易推算出它们的周期，但对于其他类型几乎不可能做到这一点。*'
- en: '[Figure 5-4](chapter5.xhtml#fig5-4) shows the structure of this cycle, along
    with the other cycles of that FSR, with each cycle being a circle whose dots represent
    a state of the register.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-4](chapter5.xhtml#fig5-4)展示了这个周期的结构，以及该FSR的其他周期，每个周期都是一个圆圈，圆圈中的点代表寄存器的一个状态。'
- en: '![](../images/fig5-4.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: Cycles of the FSR
    whose feedback function XORs the 4 bits together</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-4: FSR的周期，其中反馈函数将4个位进行异或运算</samp>'
- en: Indeed, this particular FSR has two other period-5 cycles—{0100, 1001, 0010,
    0101, 1010} and {1111, 1110, 1101, 1011, 0111}. Note that any given state can
    belong to only one cycle of states. Here, we have three cycles of five states
    each, covering 15 of the 2⁴ = 16 possible values of our 4-bit register. The 16th
    possible value is 0000, which, as [Figure 5-4](chapter5.xhtml#fig5-4) shows, is
    a period-1 cycle because the FSR transforms 0000 to 0000.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个特定的FSR有两个其他的周期-5循环——{0100, 1001, 0010, 0101, 1010}和{1111, 1110, 1101,
    1011, 0111}。请注意，任何给定的状态只能属于一个状态循环。在这里，我们有三个周期，每个周期包含五个状态，涵盖了4位寄存器的16个可能值中的15个。第16个可能值是0000，正如[图5-4](chapter5.xhtml#fig5-4)所示，它是一个周期-1循环，因为FSR将0000转换为0000。
- en: An FSR is essentially a register of bits, where each update of the register
    outputs a bit (the leftmost bit of the register) and where a function computes
    the new rightmost bit of the register. (All other bits are left-shifted.) The
    period of an FSR, from some initial state, is the number of updates needed until
    the FSR enters the same state again. If it takes *N* updates to do so, the FSR
    will produce the same *N* bits again and again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: FSR本质上是一个位寄存器，每次更新寄存器时都会输出一个位（寄存器最左边的位），并且有一个函数计算寄存器的新最右位。（所有其他位都会左移。）一个FSR的周期，从某个初始状态开始，是需要的更新次数，直到FSR再次进入相同的状态。如果需要*N*次更新才能做到这一点，那么FSR将一次又一次地生成相同的*N*个位。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Linear Feedback Shift
    Registers</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">线性反馈移位寄存器</samp>'
- en: '*Linear feedback shift registers (LFSRs)* are FSRs with a *linear* feedback
    function—namely, a function that’s the XOR of some bits of the state, such as
    the example of a 4-bit FSR in the previous section and its feedback function returning
    the XOR of the register’s 4 bits. Recall that in cryptography, linearity is synonymous
    with predictability and suggestive of a simple underlying mathematical structure.
    And, as you might expect, thanks to this linearity, we can analyze LFSRs using
    notions like linear complexity, finite fields, and primitive polynomials—but I’ll
    skip the math details and just give you the essential facts.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性反馈移位寄存器 (LFSRs)* 是具有*线性*反馈函数的FSRs——即，一个反馈函数，它是某些状态位的异或（XOR）运算，如前一节中的4位FSR示例及其反馈函数返回寄存器4个位的异或运算。回想一下，在密码学中，线性意味着可预测性，暗示着简单的数学结构。而且，正如你所预期的那样，正因为这种线性特性，我们可以使用线性复杂度、有限域和原始多项式等概念来分析LFSRs——但我会跳过数学细节，只给出基本的事实。'
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In linear algebra, we define a linear transform* ***f*** *as a function that
    satisfies* ***f****(*u *+* v*) =* ***f****(*u*) +* ***f****(*v*). If you know*
    ***f***(u) *and* ***f****(*v*), you can then determine* ***f****(*u *+* v*) without
    knowing* u *or* v*. With a nonlinear function, it’s much more complicated; you
    can’t easily find* ***f****(*u *+* v*) from* ***f****(*u*) and* ***f****(*v*).*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*在线性代数中，我们定义一个线性变换* ***f*** *为一个满足* ***f****(*u *+* v*) =* ***f****(*u*) +*
    ***f****(*v*) 的函数。如果你知道* ***f***(u) *和* ***f****(*v*)，那么你就可以在不知道* u *或* v*的情况下确定*
    ***f****(*u *+* v*)*。对于非线性函数，情况要复杂得多；你无法轻易地从* ***f****(*u*) 和* ***f****(*v*)*
    找到* ***f****(*u *+* v*)*。*'
- en: 'The choice of which bits to XOR together is crucial for the period of the LFSR
    and thus for its cryptographic value. The good news is that we know how to select
    the position of the bits to guarantee a maximal period of 2*^n* – 1\. Specifically,
    we take the indices of the bits, from 1 for the rightmost to *n* for the leftmost,
    and write the polynomial expression 1 + *X* + *X* ² + . . . + *X* *^n*, where
    we include the term *X* *^i* only if the *i*th bit is one of the bits XORed in
    the feedback function. The period is maximal *if and only if* that polynomial
    is *primitive*. To be primitive, the polynomial must have the following qualities:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪些位进行异或运算对LFSR的周期至关重要，从而影响其加密值。好消息是，我们知道如何选择位的位置，以确保最大周期为2*^n* – 1。具体来说，我们从右至左，分别为位1到位*n*，写出多项式表达式1
    + *X* + *X*² + ... + *X* *^n*，其中只有当第*i*个位置的位被用在反馈函数中的异或运算时，才包括项 *X* *^i*。只有当该多项式是*原始的*，周期才是最大周期。要使多项式是原始的，它必须具备以下性质：
- en: 'The polynomial must be irreducible, meaning that it can’t be factorized—that
    is, written as a product of smaller polynomials. For example, *X* + *X* ³ is not
    irreducible because it’s equal to (1 + *X*)(*X* + *X*²):'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式必须是不可约的，这意味着它不能被因式分解——也就是说，不能写成更小的多项式的积。例如，*X* + *X*³ 不是不可约的，因为它等于(1 + *X*)(*X*
    + *X*²)：
- en: '![](../images/pg93-1.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg93-1.jpg)'
- en: The polynomial must satisfy certain other mathematical properties that cannot
    be easily explained without nontrivial mathematical notions but are easy to test.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该多项式必须满足某些其他数学性质，这些性质无法用简单的数学概念解释，但可以通过测试轻松验证。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The maximal period of an* n*-bit LFSR is 2*^n – *1, not 2*^n*, because the
    all-zero state always loops on itself infinitely. Because the XOR of any number
    of zeros is zero, new bits entering the state from the feedback functions will
    always be zero; hence, the all-zero state is doomed to stay all zeros.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*位LFSR的最大周期是2*^n* – 1，而不是2*^n*，因为全零状态总是自循环，永远不变。由于任何数量的零异或结果都是零，来自反馈函数的输入位将始终为零；因此，全零状态注定会保持全零。 '
- en: For example, [Figure 5-5](chapter5.xhtml#fig5-5) shows a 4-bit LFSR with the
    feedback polynomial 1 + *X* + *X*³ + *X*⁴ in which we XOR the bits at positions
    1, 3, and 4 together to compute the new bit set to *L*[1]. However, this polynomial
    isn’t primitive because we can factorize it into (1 + *X*³)(1 + *X*).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图5-5](chapter5.xhtml#fig5-5)显示了一个4位LFSR，其反馈多项式为1 + *X* + *X*³ + *X*⁴，在此我们将位置1、3和4的位进行异或运算，计算出新的位，设为*L*[1]。然而，这个多项式不是原始的，因为它可以因式分解为(1
    + *X*³)(1 + *X*)。
- en: '![](../images/fig5-5.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: An LFSR with the
    feedback polynomial 1 +</samp> <samp class="SANS_Futura_Std_Book_11">X</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp> <samp class="SANS_Futura_Std_Book_11">X</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp>
    <samp class="SANS_Futura_Std_Book_11">X</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">4</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-5：具有反馈多项式1 +</samp> <samp
    class="SANS_Futura_Std_Book_11">X</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp>
    <samp class="SANS_Futura_Std_Book_11">X</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp> <samp class="SANS_Futura_Std_Book_11">X</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">4</samp>
- en: 'Indeed, the period of the LFSR in [Figure 5-5](chapter5.xhtml#fig5-5) isn’t
    maximal. To prove this, start from the state 0001:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，[图5-5](chapter5.xhtml#fig5-5)中的LFSR的周期不是最大周期。为了证明这一点，从状态0001开始：
- en: '![](../images/pg94-1.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg94-1.jpg)'
- en: 'Now left-shift by 1 bit and set the new bit to 0 + 0 + 1 = 1:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在左移1位，并将新位设为0 + 0 + 1 = 1：
- en: '![](../images/pg94-2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg94-2.jpg)'
- en: 'Repeating the operation five more times gives the following state values:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再进行五次相同操作，得到以下状态值：
- en: '![](../images/pg94-3.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg94-3.jpg)'
- en: The state after six updates is the same as the initial one, demonstrating that
    we’re in a period-6 cycle and proving that the LFSR’s period isn’t the maximal
    value of 15.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 六次更新后的状态与初始状态相同，这表明我们处于一个周期为6的循环中，证明该LFSR的周期不是最大值15。
- en: Let’s now look at an LFSR with a maximal period, considering the LFSR in [Figure
    5-6](chapter5.xhtml#fig5-6).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个具有最大周期的LFSR，参考[图5-6](chapter5.xhtml#fig5-6)中的LFSR。
- en: '![](../images/fig5-6.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: An LFSR with the
    feedback polynomial 1 +</samp> <samp class="SANS_Futura_Std_Book_11">X</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp>
    <samp class="SANS_Futura_Std_Book_11">X</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">4</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, a primitive polynomial, ensuring a
    maximal period</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-6：一个具有反馈多项式1 +</samp> <samp
    class="SANS_Futura_Std_Book_11">X</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">3</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">+</samp> <samp class="SANS_Futura_Std_Book_11">X</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">4</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">，一个原始多项式，确保最大周期</samp>
- en: 'This feedback polynomial is a primitive polynomial described by 1 + *X* ³ +
    *X* ⁴, and you can verify that its period is maximal (namely, 15). From an initial
    value, the state evolves as follows (from 0001 to 0010, 0100, 1001, 0011, and
    so on):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该反馈多项式是一个原始多项式，描述为1 + *X*³ + *X*⁴，你可以验证它的周期是最大值（即15）。从初始值开始，状态按以下方式演变（从0001到0010、0100、1001、0011，依此类推）：
- en: '![](../images/pg94-4.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg94-4.jpg)'
- en: The state spans all possible values except 0000 with no repetition until it
    eventually loops. This demonstrates that the period is maximal and that the feedback
    polynomial is primitive.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该状态遍历所有可能的值，除了0000，并且在最终循环之前没有重复。这证明了周期是最大值，且反馈多项式是原始的。
- en: Alas, using an LFSR as a stream cipher is not secure. If *n* is the LFSR’s bit
    length, an attacker needs only *n* output bits to recover the LFSR’s initial state,
    allowing them to determine all previous bits and predict all future bits. This
    attack is possible because the LFSR is linear, implying that relations between
    the bits of the state obey linear equations, which are simple to solve. You can
    use the Berlekamp–Massey algorithm to solve the equations defined by the LFSR’s
    mathematical structure to find not only the LFSR’s initial state but also its
    feedback polynomial. In fact, you don’t even need to know the exact length of
    the LFSR to succeed; you can repeat the Berlekamp–Massey algorithm for all possible
    values of *n* until you hit the right one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，使用LFSR作为流密码并不安全。如果*n*是LFSR的位长度，攻击者只需要*n*个输出位就能恢复LFSR的初始状态，从而确定所有之前的位并预测所有未来的位。之所以可能发生这种攻击，是因为LFSR是线性的，这意味着状态位之间的关系服从线性方程，解决这些方程是很简单的。你可以使用Berlekamp–Massey算法来解决由LFSR数学结构定义的方程，不仅可以找到LFSR的初始状态，还可以找到其反馈多项式。实际上，你甚至不需要知道LFSR的确切长度就能成功；你可以对所有可能的*n*值重复Berlekamp–Massey算法，直到找到正确的值。
- en: The upshot is that LFSRs are cryptographically weak because they’re linear.
    Output bits and initial state bits are related by simple and short equations that
    you can solve with high school linear algebra techniques. To strengthen LFSRs,
    let’s add a pinch of nonlinearity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，LFSR在密码学上较弱，因为它们是线性的。输出位和初始状态位通过简单且简短的方程关联，你可以使用高中线性代数技巧来解决这些方程。为了增强LFSR的安全性，我们可以加入一点非线性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Filtered LFSRs</samp>
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">过滤LFSR</samp>
- en: To mitigate the insecurity of LFSRs, hide their linearity by passing their output
    bits through a nonlinear function before returning them to produce a *filtered
    LFSR*, as [Figure 5-7](chapter5.xhtml#fig5-7) illustrates.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻LFSR的不安全性，可以通过在返回之前将其输出位通过非线性函数进行处理来隐藏其线性特性，从而产生一个*过滤LFSR*，正如[图5-7](chapter5.xhtml#fig5-7)所示。
- en: '![](../images/fig5-7.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-7: A filtered LFSR</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-7：一个过滤LFSR</samp>
- en: The **g** function in [Figure 5-7](chapter5.xhtml#fig5-7) must be a *nonlinear*
    function—one that both XORs bits together and combines them with logical AND or
    OR operations. For example, *L*[1]*L*[2] + *L*[3]*L*[4] is a nonlinear function
    (I’ve omitted the multiplication sign, so *L*[1]*L*[2] means *L*[1] × *L*[2],
    or *L*[1] & *L*[2] using C syntax).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-7](chapter5.xhtml#fig5-7)中的**g**函数必须是一个*非线性*函数——它不仅进行XOR操作，还结合了逻辑与或运算。例如，*L*[1]*L*[2]
    + *L*[3]*L*[4]是一个非线性函数（我省略了乘号，因此*L*[1]*L*[2]表示*L*[1] × *L*[2]，或者使用C语法表示为*L*[1]
    & *L*[2]）。'
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*You can write feedback functions either directly in terms of an FSR’s bits,
    like* L1L2 *+* L3L4*, or using the equivalent polynomial notation 1 +* XX*²* *+*
    X*³*X*⁴**. The direct notation is easier to grasp, but the polynomial notation
    better serves the mathematical analysis of an FSR’s properties. We’ll stick to
    the direct notation unless we care about the mathematical properties.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以直接用FSR的位表示反馈函数，比如* L1L2 *+* L3L4*，或者使用等效的多项式表示法 1 +* XX*²* +* X*³*X*⁴**。直接表示法更容易理解，但多项式表示法更适用于FSR属性的数学分析。除非我们关心数学属性，否则我们会坚持使用直接表示法。*'
- en: 'Filtered LFSRs are stronger than plain LFSRs because their nonlinear function
    thwarts straightforward attacks. Still, more complex attacks such as the following
    will break the system:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 滤波LFSR比普通LFSR更强，因为它们的非线性函数能阻止直接攻击。不过，像以下这样的更复杂攻击仍然能够破解系统：
- en: '**Algebraic attacks **Solve the nonlinear equation systems deduced from the
    output bits, where unknowns in the equations are bits from the LFSR state.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**代数攻击** 解出从输出位推导出的非线性方程系统，其中方程中的未知数是LFSR状态的位。'
- en: '**Cube attacks **Compute derivatives of the nonlinear equations to reduce the
    degree of the system down to one and then solve it efficiently like a linear system.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**立方体攻击** 计算非线性方程的导数，将系统的次数降到1，然后像线性系统一样高效地求解。'
- en: '**Fast correlation attacks **Exploit filtering functions that, despite their
    nonlinearity, tend to behave like linear functions.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速相关攻击** 利用过滤函数，尽管它们是非线性的，但通常表现得像线性函数。'
- en: The lesson here, as we’ve seen in previous examples, is that Band-Aids don’t
    fix bullet holes. Patching a broken algorithm with a slightly stronger layer won’t
    make the whole thing secure. You must fix the problem at the core.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训，如我们在前面的例子中看到的那样，是创可贴无法修补枪伤。用稍微强一点的层来修补破损的算法并不能使整个系统变得安全。你必须从核心解决问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Nonlinear FSRs</samp>
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">非线性FSR</samp>
- en: '*Nonlinear FSRs (NFSRs)* are like LFSRs but with a nonlinear feedback function
    instead of a linear one. Instead of just bitwise XORs, the feedback function can
    include bitwise AND and OR operations—a feature with both pros and cons.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*非线性FSR（NFSR）*类似于LFSR，但它有一个非线性的反馈函数，而不是线性的。反馈函数不仅仅是按位XOR操作，它还可以包括按位与（AND）和或（OR）操作——这既有优点也有缺点。'
- en: 'One benefit of the addition of nonlinear feedback functions is that they make
    NFSRs cryptographically stronger than LFSRs because the output bits depend on
    the initial secret state in a complex fashion, according to equations of exponential
    size. The LFSRs’ linear function keeps the relations simple, with at most *n*
    terms (*N*[1], *N*[2], . . . , *N*n, if the *N*is are the NFSR’s state bits).
    For example, a 4-bit NFSR with an initial secret state (*N*[1], *N*[2], *N*[3],
    *N*[4]) and a feedback function *N*[1] + *N*[2] + *N*[1]*N*[2] + *N*[3]*N*[4]
    produce a first output bit equal to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 非线性反馈函数的一个好处是，它们使NFSR在密码学上比LFSR更强，因为输出位依赖于初始秘密状态，并且根据指数大小的方程进行复杂的计算。LFSR的线性函数使关系保持简单，最多有*n*项（*N*[1]，*N*[2]，...，*N*[n]，如果*N*是NFSR的状态位）。例如，一个4位的NFSR，初始秘密状态为(*N*[1]，*N*[2]，*N*[3]，*N*[4])，反馈函数为*N*[1]
    + *N*[2] + *N*[1]*N*[2] + *N*[3]*N*[4]，其第一个输出位为以下表达式：
- en: '![](../images/pg96-1.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg96-1.jpg)'
- en: 'The second iteration replaces the *N*[1] value with that new bit. Expressing
    the second output bit in terms of the initial state, we get the following equation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次迭代将*N*[1]值替换为新的位。将第二个输出位用初始状态表示，我们得到以下方程：
- en: '![](../images/pg96-2.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg96-2.jpg)'
- en: This new equation has algebraic degree 3 (the highest number of bits multiplied
    together, here in *N*[1]*N*[3]*N*[4]) rather than degree 2 of the feedback function,
    and it has six terms instead of four. As a result, iterating the nonlinear function
    quickly yields unmanageable equations because the size of the output grows exponentially.
    Although you’ll never compute those equations when running the NFSR, an attacker
    has to solve them in order to break the system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新方程的代数次数为3（最高次乘积的位数，这里是*N*[1]*N*[3]*N*[4]），而不是反馈函数的次数2，并且它有六个项而不是四个。因此，迭代非线性函数会迅速产生无法处理的方程，因为输出的大小呈指数增长。尽管在运行NFSR时你永远不会计算这些方程，攻击者必须解决它们才能破解系统。
- en: One downside to NFSRs is that there’s no efficient way to determine an NFSR’s
    period or to know whether its period is maximal. For an NFSR of *n* bits, you
    need to run close to 2*^n* trials to verify that its period is maximal. This calculation
    is impossible for large NFSRs of 80 bits or more.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: NFSR 的一个缺点是，没有高效的方法来确定 NFSR 的周期或知道其周期是否最大。对于一个 *n* 位的 NFSR，你需要进行接近 2*^n* 次试验，才能验证其周期是否最大。对于
    80 位或更大位数的 NFSR，这种计算几乎是不可能的。
- en: 'Fortunately, there’s a trick to using an NFSR without worrying about short
    periods: you can combine LFSRs and NFSRs to get both a guaranteed maximal period
    and the cryptographic strength—and that’s exactly how Grain-128a works.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用 NFSR 而不必担心短周期有一个技巧：你可以将 LFSR 和 NFSR 结合起来，既能确保最大周期，又能提供加密强度——这正是 Grain-128a
    的工作原理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grain-128a</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grain-128a</samp>
- en: Remember the AES competition discussed in [Chapter 4](chapter4.xhtml), in the
    context of the AES block cipher? The stream cipher Grain is the offspring of a
    similar project called the eSTREAM competition. This competition closed in 2008
    with a shortlist of recommended stream ciphers, which included four hardware-oriented
    ciphers and four software-oriented ones. Grain is one of these hardware ciphers,
    and Grain-128a is an upgraded version from the original authors of Grain. [Figure
    5-8](chapter5.xhtml#fig5-8) shows the action mechanism of Grain-128a.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在[第 4 章](chapter4.xhtml)中讨论的 AES 竞赛吗？流密码 Grain 是一个类似项目 eSTREAM 竞赛的产物。这个竞赛于
    2008 年结束，推荐了多个流密码，其中包括四个面向硬件的密码和四个面向软件的密码。Grain 就是其中一个硬件密码，Grain-128a 是 Grain
    的原始作者升级版。[图 5-8](chapter5.xhtml#fig5-8) 展示了 Grain-128a 的工作机制。
- en: '![](../images/fig5-8.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-8: The mechanism of
    Grain-128a, with a 128-bit NFSR and a 128-bit LFSR</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-8：Grain-128a 的机制，带有 128
    位 NFSR 和 128 位 LFSR</samp>
- en: Grain-128a is about as simple as a stream cipher can be, combining a 128-bit
    LFSR, a 128-bit NFSR, and a filter function, **h**. The LFSR has a maximal period
    of 2^(128) – 1, which ensures that the period of the whole system is at least
    2^(128) – 1 to protect against potential short cycles in the NFSR. At the same
    time, the NFSR and the nonlinear filter function **h** add cryptographic strength.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Grain-128a 可以说是流密码中最简单的一种，结合了一个 128 位的 LFSR、一个 128 位的 NFSR 和一个滤波函数 **h**。LFSR
    的最大周期为 2^(128) – 1，确保整个系统的周期至少为 2^(128) – 1，以防 NFSR 存在潜在的短周期。同时，NFSR 和非线性滤波函数
    **h** 增强了加密强度。
- en: Grain-128a takes a 128-bit key and a 96-bit nonce. It copies the 128 key bits
    into the NFSR’s 128 bits and copies the 96 nonce bits into the first 96 LFSR bits,
    filling the 32 bits left with ones and a single zero bit at the end. The initialization
    phase updates the whole system 256 times before returning the first keystream
    bit. During initialization, the bit returned by the **h** function is thus not
    output as a keystream but instead goes into the LFSR to ensure that its subsequent
    state depends on both the key and the nonce.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Grain-128a 采用一个 128 位的密钥和一个 96 位的 nonce。它将 128 位的密钥位复制到 NFSR 的 128 位中，将 96 位的
    nonce 位复制到前 96 位 LFSR 中，剩下的 32 位用 1 填充，最后一个位填充为 0。初始化阶段会更新整个系统 256 次，然后返回第一个密钥流位。在初始化过程中，**h**
    函数返回的位不会作为密钥流输出，而是进入 LFSR，以确保其后续状态依赖于密钥和 nonce。
- en: Grain-128a’s LFSR feedback function is
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Grain-128a 的 LFSR 反馈函数是
- en: '![](../images/pg98-1.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg98-1.jpg)'
- en: where *L*[1], *L*[2], . . . , *L*[128] are the bits of the LFSR. This feedback
    function takes only 6 bits from the 128-bit LFSR, but that’s enough to get a primitive
    polynomial that guarantees a maximal period. The small number of bits minimizes
    the cost of a hardware implementation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*L*[1]、*L*[2]、……、*L*[128] 是 LFSR 的位。这个反馈函数只从 128 位的 LFSR 中取出 6 位，但这足以得到一个原始多项式，确保最大周期。较少的位数最小化了硬件实现的成本。'
- en: 'Here is the feedback polynomial of Grain-128a’s NFSR (*N*[1], . . . , *N*[128]):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Grain-128a 的 NFSR 的反馈多项式（*N*[1]，……，*N*[128]）：
- en: '![](../images/pg98-2.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg98-2.jpg)'
- en: This function was carefully chosen to maximize its cryptographic strength while
    minimizing its implementation cost. It has an algebraic degree of 4 because its
    term with the most variables has four variables (namely, *N*[33]*N*[35]*N*[36]*N*[40]).
    Moreover, **g** can’t be approximated by a linear function because it’s highly
    nonlinear. Also, in addition to **g**, Grain-128a XORs the bit coming out from
    the LFSRs to feed the result back as the NFSR’s new, rightmost bit.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数经过精心选择，以最大化其加密强度，同时最小化实现成本。它的代数度为 4，因为其项中包含最多的变量（即 *N*[33]*N*[35]*N*[36]*N*[40]）。此外，**g**
    不能通过线性函数来逼近，因为它是高度非线性的。而且，除了 **g** 之外，Grain-128a 还将来自 LFSR 的位与结果进行异或运算，将该结果反馈回
    NFSR 的新右侧位。
- en: The filter function **h** is another nonlinear function; it takes 9 bits from
    the NFSR and 7 bits from the LFSR and combines them in a way that ensures good
    cryptographic properties.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器函数 **h** 是另一个非线性函数；它从 NFSR 中提取 9 位，从 LFSR 中提取 7 位，并以一种确保良好加密属性的方式将它们组合起来。
- en: As I write this, there is no known attack on Grain-128a, and I’m confident that
    it will remain secure. Grain-128a is used in some low-end embedded systems that
    need a compact and fast stream cipher—typically industrial proprietary systems—which
    is why Grain-128a is little known in the open source software community.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这篇文章时，Grain-128a 尚未被发现有任何已知的攻击方式，我相信它将继续保持安全。Grain-128a 被用于一些低端嵌入式系统，这些系统需要一种紧凑且快速的流密码——通常是工业专有系统——这也是为什么
    Grain-128a 在开源软件社区中鲜为人知的原因。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A5/1</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A5/1</samp>
- en: A5/1 is a stream cipher that was used to encrypt voice communications in the
    2G mobile standard. The A5/1 standard was created in 1987 but only published in
    the late 1990s after it was reverse engineered. Attacks appeared in the early
    2000s, and A5/1 was eventually broken in a way that allows actual (rather than
    theoretical) decryption of encrypted communications. Let’s see why and how.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: A5/1 是一种流密码，用于对 2G 移动通信标准中的语音通信进行加密。A5/1 标准创建于 1987 年，但直到 1990 年代末才公布，因为它是在被逆向工程后才被公开的。攻击在
    2000 年代初期出现，最终 A5/1 被破解，可以对加密的通信进行实际（而非理论）解密。让我们来看一下为什么以及如何发生的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A5/1’s Mechanism</samp>
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A5/1 的机制</samp>
- en: As [Figure 5-9](chapter5.xhtml#fig5-9) shows, A5/1 relies on three LFSRs and
    uses a trick that looks clever at first glance but actually fails to be secure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 5-9](chapter5.xhtml#fig5-9)所示，A5/1 依赖于三个 LFSR，并使用一种乍一看似乎很聪明的技巧，但实际上并不安全。
- en: '![](../images/fig5-9.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-9.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-9: The A5/1 cipher</samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-9：A5/1 加密算法</samp>
- en: 'A5/1 uses LFSRs of 19, 22, and 23 bits, with the polynomials for each as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: A5/1 使用 19 位、22 位和 23 位的 LFSR，其每个多项式如下：
- en: '![](../images/pg99-1.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg99-1.jpg)'
- en: 'How could this be seen as secure with only LFSRs and no NFSR? The trick lies
    in A5/1’s update mechanism. Instead of updating all three LFSRs at each clock
    cycle, the designers of A5/1 added a clocking rule that does the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么只使用 LFSR 而没有 NFSR 就能被认为是安全的呢？其中的技巧在于 A5/1 的更新机制。A5/1 的设计者并没有在每个时钟周期都更新三个
    LFSR，而是增加了一个时钟规则，具体执行以下操作：
- en: 1.  Checks the value of the 9th bit of LFSR 1, the 11th bit of LFSR 2, and the
    11th bit of LFSR 3, called the *clocking bits*. Of those 3 bits, either all have
    the same value (1 or 0) or two have the same value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  检查 LFSR 1 的第 9 位、LFSR 2 的第 11 位和 LFSR 3 的第 11 位，这些被称为*时钟位*。这三个位中，所有位的值要么相同（1
    或 0），要么有两个位的值相同。
- en: 2.  Clocks the registers whose clocking bits are equal to the majority value,
    0 or 1\. Either two or three LFSRs are clocked at each update.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  时钟更新那些时钟位与多数值相等的寄存器，值为 0 或 1。每次更新时，两个或三个 LFSR 会被时钟同步。
- en: Without this rule, A5/1 would provide no security whatsoever, and bypassing
    this rule is enough to break the cipher. However, that’s easier said than done,
    as you’ll see.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个规则，A5/1 根本无法提供任何安全性，绕过这个规则足以破坏加密算法。然而，正如你将看到的，这并非易事。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In A5/1’s irregular clocking rule, each register is clocked with a probability
    of 3/4 at any update. Namely, the probability that at least one other register
    has the same bit value is 1 – (1/2)**²**, where (1/2)**²* *is the chance that
    both of the other two registers have a different bit value.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 A5/1 的不规则时钟规则中，每个寄存器在每次更新时以 3/4 的概率进行时钟跳变。换句话说，至少有一个寄存器的位值与其他寄存器相同的概率为 1
    - (1/2)**²**，其中 (1/2)**²* *是另外两个寄存器的位值不同的概率。*'
- en: 2G communications use A5/1 with a key of 64 bits and a 22-bit nonce, which changes
    for every new data frame. The initialization mechanism of A5/1 first sets all
    registers to zero and injects the key followed by the nonce bit by bit to each
    register, and after each bit is injected, the registers are updated. The system
    is then updated 100 times following the previously described irregular rule.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 2G通信使用A5/1，密钥为64位，nonce为22位，每个新的数据帧都会改变nonce。A5/1的初始化机制首先将所有寄存器设置为零，然后逐位注入密钥，接着是nonce，注入每一位后寄存器都会更新。然后，系统根据前述的不规则规则更新100次。
- en: Attacks on A5/1 recover the 64-bit initial state of the system (the 19 + 22
    + 23 LFSR initial value), in turn revealing the nonce (if it wasn’t already known)
    and the key, by unwinding the initialization mechanism. The attacks are *known-plaintext
    attacks (KPAs)* because part of the encrypted data is known, which allows attackers
    to determine the corresponding keystream parts by XORing the ciphertext with the
    known plaintext chunks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对A5/1的攻击恢复了系统的64位初始状态（19 + 22 + 23的LFSR初始值），从而通过解开初始化机制，揭示了nonce（如果它尚未已知）和密钥。这些攻击是*已知明文攻击（KPA）*，因为部分加密数据是已知的，攻击者可以通过将密文与已知明文块进行异或运算，来确定相应的密钥流部分。
- en: 'There are two main types of attacks on A5/1:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对A5/1的攻击主要有两种类型：
- en: '**Subtle attacks **Exploit the internal linearity of A5/1 and its simple irregular
    clocking system.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**微妙攻击** 利用A5/1的内部线性性及其简单的不规则时钟系统。'
- en: '**Brutal attacks **Exploit only the short key of A5/1 and the invertibility
    of the frame number injection.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**暴力攻击** 仅利用A5/1的短密钥和帧号注入的可逆性。'
- en: Let’s see how these attacks work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些攻击是如何工作的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Subtle Attacks</samp>
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">微妙攻击</samp>
- en: 'We’ll examine the *guess-and-determine* subtle attack. In this kind of attack,
    an attacker guesses certain secret values of the state to determine others. In
    cryptanalysis, “guessing” means brute-forcing: for each possible value of LFSRs
    1 and 2 and all possible values of LFSR 3’s clocking bit during the first 11 clocks,
    the attack reconstructs LFSR 3’s bits by solving equations that depend on the
    bits guessed. When the guess is correct, the attacker gets the right value for
    LFSR 3.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究*猜测并确定*微妙攻击。在这种攻击中，攻击者猜测状态的某些秘密值以确定其他值。在密码分析中，“猜测”意味着暴力破解：对于LFSR 1和2的每个可能值以及在前11个时钟周期中LFSR
    3的时钟位的所有可能值，攻击通过解方程重建LFSR 3的位，这些方程依赖于猜测的位。当猜测正确时，攻击者就能获得LFSR 3的正确值。
- en: 'The attack’s pseudocode looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击的伪代码如下：
- en: '[PRE0]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How efficient is this attack compared to the 2^(64)-trial brute-force search
    discussed in [Chapter 3](chapter3.xhtml)? This attack makes at most 2^(19) × 2^(22)
    × 2^(11) = 2^(52) operations in the worst case, when the algorithm succeeds only
    at the very last test. That’s 2^(12) (or about 4,000) times faster than in the
    brute-force search, assuming that the last two operations in the previous pseudocode
    require about as much computation as testing a 64-bit key in a brute-force search.
    But is this assumption correct?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 相比[第3章](chapter3.xhtml)中讨论的2^(64)-次尝试的暴力破解搜索，这种攻击效率如何？在最坏的情况下，当算法仅在最后一次测试时成功时，该攻击最多会进行2^(19)
    × 2^(22) × 2^(11) = 2^(52)次操作。假设前述伪代码中的最后两个操作所需的计算量与在暴力破解中测试64位密钥所需的计算量相当，那么这比暴力破解搜索速度快了大约2^(12)（或约4000）倍。但这个假设正确吗？
- en: 'Recall our discussion of the full attack cost in [Chapter 3](chapter3.xhtml).
    When evaluating the cost of an attack, we need to consider not only the amount
    of computation required to perform the attack but also parallelism and memory
    consumption. Neither is an issue here: as with any brute-force attack, the guess-and-determine
    attack is embarrassingly parallel (or *N* times faster when run on *N* cores)
    and doesn’t need more memory than just running the cipher itself.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在[第3章](chapter3.xhtml)中关于完整攻击成本的讨论。当评估一次攻击的成本时，我们不仅需要考虑执行攻击所需的计算量，还需要考虑并行性和内存消耗。在这里，这两个问题都不成立：与任何暴力破解攻击一样，猜测并确定攻击是显著并行的（或者在*N*个核心上运行时，速度是*N*倍）且不需要比仅仅运行密码算法更多的内存。
- en: Our 2^(52) attack cost estimate is inaccurate for another reason. In fact, each
    of the 2^(52) operations (testing a key candidate) takes about four times as many
    clock cycles as does testing a key in a brute-force attack. The upshot is that
    the real cost of this particular attack is closer to 4 × 2^(52) = 2^(54) operations
    when compared to a brute-force attack.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的2^(52)攻击成本估算不准确，还有另一个原因。实际上，每个2^(52)操作（测试一个密钥候选）所需的时钟周期数是暴力破解攻击测试一个密钥所需时钟周期数的四倍。结果是，这个特定攻击的真实成本接近于4
    × 2^(52) = 2^(54)次操作，相比暴力破解攻击。
- en: The guess-and-determine attack on A5/1 can decrypt encrypted mobile communications,
    but it takes a couple of hours to recover the key when run on a cluster of dedicated
    hardware devices. In other words, it’s nowhere near real-time decryption. For
    that, we have another type of attack.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对A5/1的猜测-确定攻击可以解密加密的移动通信，但在一个专用硬件设备集群上运行时，恢复密钥需要几个小时。换句话说，它远未达到实时解密的程度。为此，我们有另一种类型的攻击。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Brutal Attacks</samp>
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">暴力攻击</samp>
- en: The *time-memory trade-off (TMTO)* attack is the brutal attack on A5/1\. This
    attack doesn’t care about A5/1’s internals; it cares only that its state is 64
    bits long. The TMTO attack sees A5/1 as a black box that takes in a 64-bit value
    (the state) and spits out a 64-bit value (the first 64 keystream bits).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间-内存权衡（TMTO）*攻击就是对A5/1的暴力攻击。这种攻击不关心A5/1的内部结构；它只关心其状态是64位长。TMTO攻击将A5/1视为一个黑盒，它接受一个64位值（状态）并输出一个64位值（前64个密钥流位）。'
- en: 'The idea behind the attack is to reduce the cost of a brute-force search in
    exchange for using a lot of memory. The simplest type of TMTO is a type of codebook
    attack, wherein you precompute a table of 2^(64) elements containing a combination
    of key and value pairs (<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">value</samp>)
    and store the output value for each of the 2^(64) possible keys. To use this precomputed
    table for the attack, simply collect the output of an A5/1 instance and then look
    up in the table which key corresponds to that output. The attack itself is fast—taking
    only the amount of time necessary to look up a value in memory—but the creation
    of the table takes 2^(64) computations of A5/1\. Worse, codebook attacks require
    an insane amount of memory: 2^(64) × (64 + 64) bits, which is 2^(68) bytes or
    256 exabytes. That’s dozens of data centers, so we can forget about it.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该攻击背后的思想是通过使用大量内存来降低暴力搜索的成本。最简单的TMTO类型是一种密码本攻击，其中你预先计算一个包含密钥和值对组合的2^(64)个元素的表，并为每个2^(64)个可能的密钥存储输出值。要使用这个预先计算的表进行攻击，只需收集A5/1实例的输出，然后在表中查找哪个密钥对应该输出。攻击本身很快——只需要查找一个内存中的值，但表的创建需要进行2^(64)次A5/1计算。更糟糕的是，密码本攻击需要极其庞大的内存：2^(64)
    × (64 + 64)比特，即2^(68)字节或256 exabyte。这相当于数十个数据中心，因此我们可以忘掉这一点。
- en: TMTO attacks reduce the memory requirements of codebook attacks at the price
    of increased computation during the online phase of the attack. The smaller the
    table, the more computations required to crack a key. Regardless, it costs about
    2^(64) operations to prepare the table, but that needs to be done only once.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: TMTO攻击通过在攻击的在线阶段增加计算量来减少密码本攻击的内存要求。表越小，破解密钥所需的计算量就越大。无论如何，准备表格的成本大约是2^(64)次操作，但这只需要做一次。
- en: In 2010, researchers took about two months to generate two terabytes’ worth
    of tables, using graphics processing units (GPUs) and running 100,000 instances
    of A5/1 in parallel. With the help of such large tables, calls encrypted with
    A5/1 could be decrypted almost in real time. Telecommunication operators have
    implemented workarounds to mitigate the attack, but a real solution came with
    the 3G and 4G mobile telephony standards, which ditched A5/1 altogether.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在2010年，研究人员花费了约两个月的时间，通过使用图形处理单元（GPU）并并行运行100,000个A5/1实例，生成了2TB的表格。在这些庞大的表格的帮助下，用A5/1加密的电话通话几乎可以实时解密。电信运营商已采取了规避措施来减轻这一攻击，但真正的解决方案是在3G和4G移动通信标准中出现的，这些标准彻底放弃了A5/1。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Software</samp><samp class="SANS_Futura_Std_Bold_B_11">-Oriented
    Stream Ciphers</samp>
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">面向软件的流密码</samp><samp class="SANS_Futura_Std_Bold_B_11">-导向流密码</samp>
- en: Software stream ciphers work with bytes or 32- or 64-bit words instead of individual
    bits, which proves to be more efficient on modern CPUs where instructions can
    perform arithmetic operations on a word in the same amount of time as on a bit.
    Software stream ciphers are therefore better suited than hardware ciphers for
    servers or browsers running on personal computers, where powerful general-purpose
    processors run the cipher as native software.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 软件流密码使用字节或 32 位、64 位字而不是单独的比特，这在现代 CPU 上更为高效，因为指令在相同时间内可以对字进行算术运算，效果与对比特的运算一样。软件流密码因此比硬件密码更适合用于服务器或浏览器等个人计算机上的应用，后者通过强大的通用处理器将密码作为原生软件运行。
- en: Today, there is considerable interest in software stream ciphers for a few reasons.
    First, because many devices embed powerful CPUs and hardware has become cheaper,
    there’s less of a need for small bit-oriented ciphers. For example, the two stream
    ciphers in the mobile communications standard 4G (the European SNOW3G and the
    Chinese ZUC) work with 32-bit words and not bits, unlike the older A5/1.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，软件流密码受到了相当大的关注，原因有几个。首先，由于许多设备嵌入了强大的 CPU 且硬件变得更加便宜，因此对小型按位操作的密码需求减少了。例如，4G
    移动通信标准中的两个流密码（欧洲的 SNOW3G 和中国的 ZUC）使用 32 位字而非比特，区别于较旧的 A5/1。
- en: 'Second, stream ciphers have gained popularity in software at the expense of
    block ciphers, notably following the fiasco of the padding oracle attack against
    block ciphers in CBC mode. In addition, stream ciphers are easier to specify and
    to implement than block ciphers: instead of mixing message and key bits together,
    stream ciphers just ingest key bits as a secret. In fact, one of the most popular
    stream ciphers is actually a block cipher in disguise: AES in counter mode (CTR).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，流密码在软件中的流行度已超过了分组密码，尤其是在针对 CBC 模式分组密码的填充 oracle 攻击事件后。除此之外，流密码比分组密码更易于指定和实现：它们只是将密钥比特作为秘密输入，而不是将消息和密钥比特混合在一起。事实上，最流行的流密码之一实际上是伪装的分组密码：计数模式下的
    AES（CTR）。
- en: One software stream cipher design, used by SNOW3G and ZUC, copies hardware ciphers
    and their FSRs, replacing bits with bytes or words. But these aren’t the most
    interesting designs for a cryptographer. As of this writing, the two designs of
    most interest are RC4 and Salsa20, which are used in numerous systems, despite
    the fact that one is completely broken.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一种流行的软件流密码设计被 SNOW3G 和 ZUC 使用，它复制了硬件密码及其 FSR，替换了比特为字节或字。但这些并不是对密码学家最有趣的设计。截至本文撰写时，最受关注的两种设计是
    RC4 和 Salsa20，尽管其中一种已经完全被攻破，但它们仍被广泛应用于多个系统中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RC4</samp>
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RC4</samp>
- en: Designed in 1987 by Ron Rivest of RSA Security and then reverse engineered and
    leaked in 1994, RC4 has long been the most widely used stream cipher. RC4 has
    been used in countless applications, most famously in the first Wi-Fi encryption
    standard Wired Equivalent Privacy (WEP) and in the Transport Layer Security (TLS)
    protocol used to establish HTTPS connections. Unfortunately, RC4 isn’t secure
    enough for most applications, including WEP and TLS. To understand why, let’s
    see how RC4 works.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: RC4 由 RSA 安全公司的 Ron Rivest 于 1987 年设计，并在 1994 年被逆向工程并泄露，长期以来一直是最广泛使用的流密码。RC4
    被应用于无数场合，其中最著名的是第一个 Wi-Fi 加密标准 Wired Equivalent Privacy (WEP) 和用于建立 HTTPS 连接的传输层安全协议（TLS）。不幸的是，RC4
    对于大多数应用而言并不够安全，包括 WEP 和 TLS。为了理解原因，我们来看看 RC4 的工作原理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">How RC4 Works</samp>
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">RC4 工作原理</samp>
- en: RC4 is among the simplest ciphers ever created. It doesn’t perform any crypto-like
    operations, and it has no XORs, no multiplications, no S-boxes . . . nada. It
    simply swaps bytes. RC4’s internal state is an array, *S*, of 256 bytes, first
    set to *S*[0] = 0, *S*[1] = 1, *S*[2] = 2, . . . , *S*[255] = 255, and then initialized
    from an *n*-byte *K* using its *key scheduling algorithm (KSA)*, which works as
    in the Python code in [Listing 5-1](chapter5.xhtml#Lis5-1).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: RC4 是有史以来最简单的密码之一。它不执行任何类似加密的操作，也没有 XOR、乘法、S-box 等... 什么都没有。它仅仅是交换字节。RC4 的内部状态是一个包含
    256 个字节的数组 *S*，最初设置为 *S*[0] = 0, *S*[1] = 1, *S*[2] = 2, ... , *S*[255] = 255，然后通过其
    *密钥调度算法（KSA）* 从一个 *n* 字节的 *K* 中初始化，算法的实现如同在 [Listing 5-1](chapter5.xhtml#Lis5-1)
    中的 Python 代码所示。
- en: '[PRE1]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: The key scheduling
    algorithm of RC4</samp>'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: RC4 的密钥调度算法</samp>'
- en: 'Once this algorithm completes, array *S* still contains all the byte values
    from 0 to 255 but now in a random-looking order. For example, with the all-zero
    128-bit key, the state *S* (from *S*[0] to *S*[255]) becomes:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个算法完成，数组*S*仍然包含从0到255的所有字节值，但现在是随机排列的。例如，使用全零128位密钥时，状态*S*（从*S*[0]到*S*[255]）变为：
- en: '![](../images/pg103-1.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg103-1.jpg)'
- en: 'However, if I flip the first key bit and run the KSA again, I get a totally
    different, apparently random state:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我翻转第一个密钥位并重新运行KSA，我会得到一个完全不同、显然是随机的状态：
- en: '![](../images/pg103-2.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg103-2.jpg)'
- en: 'Given the initial state *S*, RC4 generates a keystream, *KS*, of the same length
    as the plaintext, *P*, to compute a ciphertext: *C* = *P* ⊕ *KS*. The bytes of
    the keystream *KS* are computed from *S* according to the Python code in [Listing
    5-2](chapter5.xhtml#Lis5-2), if *P* is *m* bytes long.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 给定初始状态*S*，RC4生成一个与明文*P*长度相同的密钥流*KS*，用来计算密文：*C* = *P* ⊕ *KS*。密钥流*KS*的字节是根据[清单5-2](chapter5.xhtml#Lis5-2)中的Python代码，从*S*计算得出的，前提是*P*是*m*字节长。
- en: '[PRE2]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: The keystream
    generation of RC4, where</samp> <samp class="SANS_Futura_Std_Book_11">S</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">is the state initialized in [Listing
    5-1](chapter5.xhtml#Lis5-1)</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单5-2：RC4的密钥流生成，其中</samp> <samp
    class="SANS_Futura_Std_Book_11">S</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">是[清单5-1](chapter5.xhtml#Lis5-1)中初始化的状态</samp>
- en: 'In [Listing 5-2](chapter5.xhtml#Lis5-2), each iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop modifies up to 2 bytes of RC4’s internal state *S*: the *S*[*i*] and *S*[*j*]
    whose values are swapped. That is, if *i* = 0 and *j* = 4 and if *S*[0] = 56 and
    *S*[4] = 78, then the swap operation sets *S*[0] to 78 and *S*[4] to 56\. If *j*
    equals *i*, then S[*i*] isn’t modified.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单5-2](chapter5.xhtml#Lis5-2)中，每次迭代的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环最多会修改RC4内部状态*S*的2个字节：交换值的*S*[*i*]和*S*[*j*]。也就是说，如果*i*
    = 0且*j* = 4，并且如果*S*[0] = 56且*S*[4] = 78，那么交换操作将*S*[0]设为78，*S*[4]设为56。如果*j*等于*i*，则*S*[*i*]不被修改。
- en: This looks too simple to be secure, yet it took 20 years for cryptanalysts to
    find exploitable flaws. Before the flaws were revealed, we knew RC4’s weaknesses
    only in specific implementations, as in the first Wi-Fi encryption standard, WEP.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来太简单，难以保证安全，然而加密分析师花了20年才发现可被利用的漏洞。在这些漏洞被揭示之前，我们仅知道RC4在特定实现中的弱点，例如在第一个Wi-Fi加密标准WEP中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">RC4 in WEP</samp>
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">WEP中的RC4</samp>
- en: WEP, the first-generation Wi-Fi security protocol, is now completely broken
    due to weaknesses in the protocol’s design and in RC4.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: WEP，第一代Wi-Fi安全协议，由于协议设计和RC4的弱点，现在已经完全被破解。
- en: In its WEP implementation, RC4 encrypts payload data of 802.11 frames, the datagrams
    (or packets) that transport data over the wireless network. All payloads delivered
    in the same session use the same secret key of 40 or 104 bits but have what is
    a supposedly unique 3-byte nonce encoded in the frame header (the part of the
    frame that encodes metadata and comes before the actual payload).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在其WEP实现中，RC4加密802.11帧的有效载荷数据，这些数据报（或数据包）在无线网络中传输数据。所有在同一会话中传输的有效载荷都使用相同的40位或104位秘密密钥，但在帧头中有一个假定为唯一的3字节随机数（它编码元数据，并位于实际有效载荷之前）。
- en: 'The problem is that RC4 doesn’t support a nonce, at least not in its official
    specification, and we can’t use a stream cipher without a nonce. The WEP designers
    addressed this limitation with a workaround: they included a 24-bit nonce in the
    wireless frame’s header and prepended it to the WEP key to be used as RC4’s secret
    key. That is, if the nonce is the bytes *N*[0], *N*[1], *N*[2] and the WEP key
    is *K*[0], *K*[1], *K*[2], *K*[3], *K*[4], the actual RC4 key is *N*[0], *N*[1],
    *N*[2], *K*[0], *K*[1], *K*[2], *K*[3], *K*[4]. The net effect is to have 40-bit
    secret keys yield 64-bit effective keys and to have 104-bit keys yield 128-bit
    effective keys. The result? The advertised 128-bit WEP protocol actually offers
    only 104-bit security, at best.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于RC4不支持随机数（nonce），至少在它的官方规范中没有支持，而没有随机数就无法使用流密码。WEP的设计者通过一种变通方法解决了这一限制：他们在无线帧的头部包含了一个24位的随机数，并将其添加到WEP密钥前面，作为RC4的密钥使用。也就是说，如果随机数是字节*N*[0]，*N*[1]，*N*[2]，而WEP密钥是*K*[0]，*K*[1]，*K*[2]，*K*[3]，*K*[4]，那么实际的RC4密钥就是*N*[0]，*N*[1]，*N*[2]，*K*[0]，*K*[1]，*K*[2]，*K*[3]，*K*[4]。最终效果是，40位的密钥变成了64位的有效密钥，104位的密钥变成了128位的有效密钥。结果是什么呢？广告中的128位WEP协议实际上最多只能提供104位的安全性。
- en: 'But here are the real problems with WEP’s nonce trick:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里是 WEP 的 nonce 技巧的真正问题：
- en: '**The nonces are too small at only 24 bits **This means that if a nonce is
    chosen randomly for each new message, you have to wait about 2^(24/2) = 2^(12)
    packets, or a few megabytes’ worth of traffic, until you can find two packets
    encrypted with the same nonce and thus the same keystream. Even if the nonce is
    a counter running from 0 to 2^(24) – 1, it takes a few gigabytes’ worth of data
    until a rollover, when the repeated nonce can allow the attacker to decrypt packets.
    But there’s a bigger problem.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**nonce 太小，只有 24 位** 这意味着，如果为每个新消息随机选择一个 nonce，你必须等待大约 2^(24/2) = 2^(12) 个数据包，或者几兆字节的数据流量，直到你能找到两个使用相同
    nonce 和相同密钥流加密的数据包。即使 nonce 是一个从 0 到 2^(24)-1 的计数器，在发生溢出之前，也需要几千兆字节的数据量，才能让攻击者通过重复的
    nonce 解密数据包。但问题更大。'
- en: '**Combining the nonce and key in this fashion helps recover the key **WEP’s
    three nonsecret nonce bytes let an attacker determine the value of *S* after three
    iterations of the key scheduling algorithm. Because of this, cryptanalysts found
    that the first keystream byte strongly depends on the first secret key byte—the
    fourth byte ingested by the KSA—and that this bias can be exploited to recover
    the secret key.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**以这种方式组合 nonce 和密钥有助于恢复密钥** WEP 的三个非保密 nonce 字节使攻击者能够在密钥调度算法运行三次后确定 *S* 的值。因为这个原因，密码分析师发现第一个密钥流字节强烈依赖于第一个秘密密钥字节——KSA
    使用的第四个字节——这种偏差可以被利用来恢复秘密密钥。'
- en: 'Exploiting those weaknesses requires access to both ciphertexts and the keystream—that
    is, known or chosen plaintexts. But that’s easy enough: known plaintexts occur
    when the Wi-Fi frames encapsulate data with a known header, and chosen plaintexts
    occur when the attacker injects known plaintext encrypted with the target key.
    The upshot is that the attacks work in practice, not just on paper.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些弱点需要访问密文和密钥流——也就是说，已知或选择的明文。但这很容易：已知明文发生在 Wi-Fi 帧封装了带有已知头部的数据时，而选择的明文发生在攻击者注入用目标密钥加密的已知明文时。结果是，攻击在实际中有效，而不仅仅是在理论上。
- en: Following the appearance of the first attacks on WEP in 2001, researchers found
    faster attacks that required fewer ciphertexts. Today, you can even find tools
    such as aircrack-ng that implement the entire attack, from network sniffing to
    cryptanalysis.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2001 年首次出现 WEP 攻击后，研究人员发现了一些更快速的攻击方法，所需的密文更少。如今，你甚至可以找到像 aircrack-ng 这样的工具，实施整个攻击，从网络嗅探到密码分析。
- en: WEP’s insecurity is due to both weaknesses in RC4, which takes a single one-use
    key instead of a key and a nonce (as in any decent stream cipher), and weaknesses
    in the WEP design itself.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: WEP 的不安全性既来源于 RC4 的弱点，RC4 采用了单次使用的密钥，而不是像任何合适的流密码那样使用密钥和 nonce（一次性随机数），也来源于
    WEP 设计本身的缺陷。
- en: Now let’s look at the second biggest failure of RC4.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看 RC4 的第二大失败。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">RC4 in TLS</samp>
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">TLS 中的 RC4</samp>
- en: TLS is the single most important security protocol used on the internet. It’s
    best known for underlying HTTPS connections, but it’s also used to protect some
    virtual private network (VPN) connections, as well as email servers, mobile applications,
    and many others. And sadly, TLS has long supported RC4.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 是互联网中使用的最重要的安全协议。它以支撑 HTTPS 连接而广为人知，但也被用于保护一些虚拟专用网络（VPN）连接、电子邮件服务器、移动应用程序等。遗憾的是，TLS
    长期以来一直支持 RC4。
- en: Unlike WEP, the TLS implementation doesn’t make the same blatant mistake of
    tweaking the RC4 specs in order to use a public nonce. Instead, TLS just feeds
    RC4 a unique 128-bit session key, which means it’s a bit less broken than WEP.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与 WEP 不同，TLS 实现没有犯同样明显的错误，即调整 RC4 规格来使用公共 nonce。相反，TLS 只给 RC4 提供了一个独特的 128 位会话密钥，这意味着它比
    WEP 稍微不那么容易破解。
- en: 'The weakness in TLS is due only to RC4 and its inexcusable flaws: statistical
    biases, or nonrandomness, which we know is a total deal-breaker for a stream cipher.
    For example, the second keystream byte produced by RC4 is zero, with a probability
    of 1/128, whereas it should ideally be 1/256\. (Recall that a byte can take 256
    values from 0 to 255; hence, a truly random byte is zero with a chance of 1/256.)
    Crazier still is the fact that most experts continued to trust RC4 as late as
    2013, even though its statistical biases have been known since 2001.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: TLS中的弱点仅仅源于RC4及其不可原谅的缺陷：统计偏差，或称非随机性，这一点我们知道对于流密码来说是完全不可接受的。例如，RC4生成的第二个密钥流字节是零的概率为1/128，而理想情况下它的概率应该是1/256（回忆一下，一个字节可以取0到255之间的256个值；因此，真正随机的字节零出现的概率应该是1/256）。更离奇的是，大多数专家直到2013年依然相信RC4，尽管其统计偏差自2001年以来就已为人所知。
- en: RC4’s known statistical biases should have been enough to ditch the cipher altogether,
    even if we didn’t know how to exploit the biases to compromise actual applications.
    In TLS, RC4’s flaws weren’t publicly exploited until 2011, but the NSA allegedly
    managed to exploit RC4’s weaknesses to compromise TLS’s RC4 connections well before
    then.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: RC4已知的统计偏差本应足以让我们彻底放弃这种密码算法，即使我们不知道如何利用这些偏差来危及实际应用。在TLS中，RC4的缺陷直到2011年才被公开利用，但据称NSA在此之前就已经利用RC4的弱点来攻破TLS的RC4连接。
- en: As it turned out, not only was RC4’s second keystream byte biased, but all of
    the first 256 bytes were biased as well. In 2011, researchers found that the probability
    that one of those bytes comes to zero equals 1/256 + *c*/256² for some constant,
    *c*, taking values between 0.24 and 1.34\. It’s not just for the byte zero but
    for other byte values as well. The amazing thing about RC4 is that it fails where
    even many noncryptographic PRNGs succeed—namely, at producing uniformly distributed
    pseudorandom bytes (that is, where each of the 256 bytes has a chance of 1/256
    of showing up).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，不仅RC4的第二个密钥流字节有偏差，前256个字节也都有偏差。2011年，研究人员发现其中一个字节为零的概率等于1/256 + *c*/256²，其中常数*c*的值介于0.24和1.34之间。不仅仅是字节零，其他字节值也存在类似的偏差。RC4令人惊讶之处在于，它在很多非加密伪随机数生成器都能成功的地方失败了——也就是说，它无法生成均匀分布的伪随机字节（即每个256个字节中，每个字节都有1/256的概率出现）。
- en: 'RC4’s flawed TLS implementation can even be exploited in the weakest attack
    model, the chosen-ciphertext: you collect ciphertexts and look for the plaintext,
    not the key. But there’s a caveat: you’ll need many ciphertexts, encrypting *the
    same plaintext* several times using different secret keys. We sometimes call this
    attack model the *broadcast model* because it’s akin to broadcasting the same
    message to multiple recipients.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: RC4在TLS中的缺陷甚至可以在最弱的攻击模型——选择密文攻击中被利用：你收集密文并寻找明文，而不是密钥。但有一个警告：你需要许多密文，并使用不同的密钥多次加密*相同的明文*。我们有时将这种攻击模型称为*广播模型*，因为它类似于将相同的消息广播给多个接收者。
- en: 'Say you want to decrypt the plaintext byte *P*[1] of a plaintext P given many
    ciphertext bytes obtained by intercepting the different ciphertexts of the same
    message. You’ll thus obtain the first bytes of each of the four ciphertexts *C*¹,
    . . . , *C*⁴, for four keystreams *KS*¹, . . . , *KS*⁴ such that:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要解密明文P的明文字节*P*[1]，并且通过拦截同一消息的不同密文，获取了多个密文字节。这样，你将得到四个密文的第一个字节*C*¹、*C*²、*C*³、*C*⁴，以及四个密钥流*KS*¹、*KS*²、*KS*³、*KS*⁴，使得：
- en: '![](../images/pg105-1.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg105-1.jpg)'
- en: Because of RC4’s bias, keystream bytes *KS*[1]*^i* (the first byte in each of
    the four instances) are more likely to be zero than any other byte value. Therefore,
    *C*[1]*^i* bytes are more likely to be equal to *P*[1] than to any other value.
    To determine *P*[1] given the *C*[1]*^i* bytes, simply count the number of occurrences
    of each byte value and return the most frequent one as *P*[1]. However, because
    the statistical bias is very small, you need millions of values to get it right
    with any certainty.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RC4的偏差，密钥流字节*KS*[1]*^i*（四个实例中的第一个字节）更可能是零，而不是其他任何字节值。因此，*C*[1]*^i*字节更可能等于*P*[1]，而不是任何其他值。为了确定*P*[1]，给定*C*[1]*^i*字节，只需计算每个字节值出现的次数，并返回出现频率最高的字节作为*P*[1]。然而，由于统计偏差非常小，你需要数百万个值才能以一定的准确性得到正确的结果。
- en: The attack generalizes to recover more than one plaintext byte and to exploit
    more than one biased value (zero here). The algorithm just becomes a bit more
    complicated. However, this attack is hard to put into practice because it needs
    to collect many ciphertexts encrypting the same plaintext but using different
    keys. For example, the attack can’t break all TLS-protected connections that use
    RC4 because you need to trick the server into encrypting the same plaintext to
    many different recipients, or many times to the same recipient with different
    keys.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击概括为恢复多个明文字节并利用多个偏差值（这里为零）。算法变得稍微复杂了一些。但是，这种攻击很难实施，因为它需要收集许多加密同一明文但使用不同密钥的密文。例如，该攻击无法破解使用
    RC4 的所有 TLS 保护连接，因为您需要欺骗服务器将相同明文加密给许多不同的接收者，或者多次使用不同密钥加密给同一接收者。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Salsa20</samp>
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Salsa20</samp>
- en: Salsa20 is a simple, software-oriented cipher optimized for modern CPUs that
    has been implemented in numerous protocols and libraries, along with its variant,
    ChaCha. Its designer, respected cryptographer Daniel J. Bernstein, submitted Salsa20
    to the eSTREAM competition in 2005 and won a place in eSTREAM’s software portfolio.
    Salsa20’s simplicity and speed have made it popular among developers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20 是一种简单的、面向软件的密码算法，专为现代CPU优化，已在许多协议和库中实现，以及其变体 ChaCha。其设计者，受人尊敬的密码学家 Daniel
    J. Bernstein，于2005年将 Salsa20 提交给 eSTREAM 竞赛，并在 eSTREAM 的软件组合中赢得了一席之地。Salsa20 的简单性和速度使其在开发者中非常流行。
- en: Salsa20 is a counter-based stream cipher—it generates its keystream by repeatedly
    processing a counter incremented for each block. As [Figure 5-10](chapter5.xhtml#fig5-10)
    shows, the *Salsa20 core* algorithm transforms a 512-bit block using a key (*K*),
    a nonce (*N*), and a counter value (*Ctr*). Salsa20 then adds the result to the
    original value of the block to produce a *keystream block*. (If the algorithm
    were to return the core’s permutation directly as an output, Salsa20 would be
    totally insecure because it could be inverted. The final addition of the initial
    secret state *K* || *N* || *Ctr* makes the transform key-to-keystream-block noninvertible.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20 是基于计数器的流密码 —— 它通过重复处理每个块的计数器来生成密钥流。如[图5-10](chapter5.xhtml#fig5-10)所示，*Salsa20
    核心* 算法使用密钥（*K*）、一次性数（*N*）和计数器值（*Ctr*）来转换一个512位块。然后 Salsa20 将结果添加到块的原始值中以生成 *密钥流块*。（如果算法直接将核心的排列作为输出返回，Salsa20
    将是完全不安全的，因为它可以被反向操作。最终加上初始秘密状态 *K* || *N* || *Ctr* 使得密钥到密钥流块的转换是不可逆的。）
- en: '![](../images/fig5-10.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-10.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-10: Salsa20’s encryption
    scheme for a 512-bit plaintext block</samp>'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-10：Salsa20 用于512位明文块的加密方案</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using the Quarter-Round Function</samp>
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用 Quarter-Round 函数</samp>
- en: 'Salsa20’s core permutation uses a function called *quarter-round* (**QR**),
    which transforms four 32-bit words (*a*, *b*, *c*, and *d*) as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20 的核心置换使用称为 *quarter-round*（**QR**）的函数，它将四个32位字（*a*、*b*、*c* 和 *d*）转换如下：
- en: '![](../images/pg106-1.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg106-1.jpg)'
- en: We compute these four lines from top to bottom, meaning that the new value of
    *b* depends on *a* and on *d*, the new value of *c* depends on *a* and on the
    new value of *b* (and thus *d* as well), and so on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按自上而下的顺序计算这四行，意味着 *b* 的新值取决于 *a* 和 *d*，*c* 的新值取决于 *a* 和 *b* 的新值（因此也取决于 *d*），依此类推。
- en: 'The operation <<< is wordwise left-rotation by the specified number of bits,
    which can be any value between 1 and 31 (for 32-bit words). For example, <<< 8
    rotates a word’s bits of eight positions toward the left, as the following examples
    show:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <<< 操作是按指定位数进行逐字左旋转，可以是1到31之间的任何值（对于32位字）。例如，<<< 8 将一个字的位向左旋转八个位置，如下例所示：
- en: '![](../images/pg107-1.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg107-1.jpg)'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Transforming Salsa20’s 512-Bit
    State</samp>
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">转换 Salsa20 的 512 位状态</samp>
- en: Salsa20’s core permutation transforms a 512-bit internal state viewed as a 4×4
    array of 32-bit words. [Figure 5-11](chapter5.xhtml#fig5-11) shows the initial
    state, using a key of eight words (256 bits), a nonce of two words (64 bits),
    a counter of two words (64 bits), and four fixed constant words (128 bits) that
    are identical for each encryption/decryption and all blocks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20 的核心置换将 512 位的内部状态转换为一个 4×4 的 32 位字数组。[图 5-11](chapter5.xhtml#fig5-11)
    展示了初始状态，使用了一个由八个字（256 位）组成的密钥、两个字（64 位）的随机数、两个字（64 位）的计数器以及四个固定常数字（128 位），这些常数对于每次加密/解密和所有块都是相同的。
- en: '![](../images/fig5-11.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-11: The initialization
    of Salsa20’s state</samp>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-11：Salsa20 状态的初始化</samp>
- en: To transform the initial 512-bit state, Salsa20 first applies the **QR** transform
    to all four columns independently (known as the *column-round*) and then to all
    four rows independently (the *row-round*), as [Figure 5-12](chapter5.xhtml#fig5-12)
    illustrates. The sequence column-round/row-round is a *double-round*. Salsa20
    repeats 10 double-rounds, for 20 rounds in total, which is the reason for the
    *20* in *Salsa20*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了转换初始的 512 位状态，Salsa20 首先独立地对四列应用 **QR** 变换（称为 *列轮*），然后独立地对四行应用变换（*行轮*），正如
    [图 5-12](chapter5.xhtml#fig5-12) 所示。列轮/行轮序列就是 *双轮*。Salsa20 重复进行 10 次双轮，总共 20 轮，这就是
    *Salsa20* 中 *20* 的由来。
- en: '![](../images/fig5-12.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-12.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-12: Columns and rows
    transformed by Salsa20’s quarter-round (</samp><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">QR</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">) function</samp>'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-12：通过 Salsa20 的四分之一轮（</samp><samp
    class="SANS_Futura_Std_Bold_Oblique_BI_11">QR</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">）函数转换的列和行</samp>
- en: 'The column-round transforms the four columns like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列轮通过以下方式转换四列：
- en: '![](../images/pg108-1.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg108-1.jpg)'
- en: 'The row-round transforms the rows by doing the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 行轮通过以下方式转换行：
- en: '![](../images/pg108-2.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg108-2.jpg)'
- en: In a column-round, each **QR** takes *x*i arguments ordered from the top to
    the bottom line, whereas a row-round’s **QR** takes as a first argument the words
    on the diagonal (as in the array on the right in [Figure 5-12](chapter5.xhtml#fig5-12))
    rather than words from the first column.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在列轮中，每个 **QR** 以从上到下的顺序接受 *x*i 参数，而行轮的 **QR** 以对角线上的词作为第一个参数（如 [图 5-12](chapter5.xhtml#fig5-12)
    右侧数组所示），而不是来自第一列的词。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Evaluating Salsa20</samp>
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">评估 Salsa20</samp>
- en: '[Listing 5-3](chapter5.xhtml#Lis5-3) shows Salsa20’s initial states for the
    first and second blocks when initialized with an all-zero key (<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    bytes) and an all-one nonce (<samp class="SANS_TheSansMonoCd_W5Regular_11">ff</samp>
    bytes). These two states differ in only 1 bit, in the counter, which is in bold:
    specifically, 0 for the first block and 1 for the second.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-3](chapter5.xhtml#Lis5-3) 展示了当使用全零密钥（<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    字节）和全一随机数（<samp class="SANS_TheSansMonoCd_W5Regular_11">ff</samp> 字节）初始化时，Salsa20
    第一个和第二个块的初始状态。这两个状态仅在计数器中有 1 位的差异，计数器部分用粗体显示：具体来说，第一个块为 0，第二个块为 1。'
- en: '[PRE3]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: Salsa20’s initial
    states for the first two blocks with an all-zero key and an all-one nonce</samp>'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-3：使用全零密钥和全一随机数时 Salsa20
    第一个和第二个块的初始状态</samp>
- en: Yet, despite only a 1-bit difference, the respective internal states after 10
    double-rounds are totally different from each other, as [Listing 5-4](chapter5.xhtml#Lis5-4)
    shows.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管只有 1 位的差异，经过 10 次双轮变换后的内部状态彼此完全不同，正如 [清单 5-4](chapter5.xhtml#Lis5-4) 所示。
- en: '[PRE4]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: The states from
    [Listing 5-3](chapter5.xhtml#Lis5-3) after 10 Salsa20 double-rounds</samp>'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-4：经过 10 次 Salsa20 双轮变换后的
    [清单 5-3](chapter5.xhtml#Lis5-3) 状态</samp>
- en: 'But remember, even though word values in the keystream block may look random,
    it’s far from a guarantee of security. RC4’s output looks random, but it has blatant
    biases. Fortunately, Salsa20 is much more secure than RC4 and doesn’t have statistical
    biases. Keep in mind, however, that even when keystreams are statistically indistinguishable
    from perfectly random bytes, this isn’t sufficient to achieve cryptographic security.  #####
    <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Learning Differential Cryptanalysis</samp>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，即使密钥流块中的字值看起来随机，这也远不能保证安全性。RC4 的输出看起来是随机的，但它有明显的偏差。幸运的是，Salsa20 比 RC4 更加安全，并且没有统计偏差。然而，请记住，即使密钥流在统计上与完全随机字节无法区分，这也不足以实现密码学安全。#####
    <samp class="SANS_Futura_Std_Bold_Condensed_B_11">学习差分密码分析</samp>
- en: 'To demonstrate why Salsa20 is more secure than RC4, let’s look at the basics
    of *differential cryptanalysis*, the study of the differences between states rather
    than their actual values. For example, the two initial states in [Listing 5-3](chapter5.xhtml#Lis5-3)
    differ by 1 bit in the counter or by the word *x*[8] in the Salsa20 state array.
    The following array shows the bitwise difference between these two states:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明 Salsa20 比 RC4 更安全，让我们来看看*差分密码分析*的基础知识，它研究的是状态之间的差异，而不是它们的实际值。例如，[Listing
    5-3](chapter5.xhtml#Lis5-3) 中的两个初始状态在计数器中的第 1 位或 Salsa20 状态数组中的词 *x*[8] 有 1 位的不同。下表显示了这两个状态之间的按位差异：
- en: '![](../images/pg109-1.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg109-1.jpg)'
- en: The difference between the two states is actually the XOR of these states. The
    1 bit in bold corresponds to a 1-bit difference between the two states. In the
    XOR of the two states, any nonzero bits indicate differences.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个状态之间的差异实际上是这两个状态的 XOR 结果。加粗的 1 位对应于这两个状态之间的 1 位差异。在这两个状态的 XOR 结果中，任何非零位都表示差异。
- en: 'To see how fast changes propagate in the initial state as a result of Salsa20’s
    core algorithm, let’s look at the difference between two states throughout the
    rounds iteration. After one round, the difference propagates across the first
    column to two of the three other words in that column:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看 Salsa20 的核心算法在初始状态下如何迅速传播变化，让我们观察两种状态在多轮迭代过程中的差异。在一轮之后，差异会传播到第一列中的两个其他单词：
- en: '![](../images/pg109-2.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg109-2.jpg)'
- en: 'After two rounds, differences further propagate across the rows that already
    include a difference, which is all but the second row. At this point the differences
    between the states are rather sparse; not many bits have changed within a word:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在两轮之后，差异进一步传播到已经包含差异的行，除了第二行。此时状态之间的差异较为稀疏；在一个字中的比特变化不多：
- en: '![](../images/pg109-3.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg109-3.jpg)'
- en: 'After three rounds, the differences between the states become more dense, though
    the many zero nibbles indicate that many bit positions are still not affected
    by the initial difference:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在三轮之后，状态之间的差异变得更加密集，尽管许多零位显示出许多比特位置仍然未受初始差异的影响：
- en: '![](../images/pg109-4.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg109-4.jpg)'
- en: 'After four rounds, differences look random to a human observer, and they are
    also almost random statistically as well:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在四轮之后，差异对于人类观察者看起来是随机的，从统计学角度来看，它们几乎也是随机的：
- en: '![](../images/pg110-1.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg110-1.jpg)'
- en: After only four rounds, a single difference propagates to most of the bits in
    the 512-bit state. In cryptography, we call this *full diffusion*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅经过四轮，一次差异就会传播到 512 位状态的大部分位。在密码学中，我们称之为*完全扩散*。
- en: Not only do differences propagate across all states, they also do so according
    to complex equations that make future differences hard to predict because highly
    *nonlinear* relations drive the state’s evolution, thanks to the mix of XOR, addition,
    and rotation. If we used only XORs, we’d still have many differences propagating,
    but the process would be linear and therefore insecure.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 差异不仅会传播到所有状态，而且传播的方式符合复杂的方程式，使得未来的差异难以预测，因为高度的*非线性*关系驱动了状态的演变，这得益于异或（XOR）、加法和旋转的混合。如果我们只使用
    XOR，虽然差异依然会传播，但过程将是线性的，因此不安全。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacking Salsa20/8</samp>
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">攻击 Salsa20/8</samp>
- en: Salsa20 makes 20 rounds by default, but we sometimes use it with only 12 rounds,
    in a version called Salsa20/12, to make it faster. Although Salsa20/12 uses eight
    fewer rounds than Salsa20, it’s in practice as reliable as the 20-round version,
    according to the state-of-the-art research progress. Even Salsa20/8, with only
    eight rounds, is known to be only theoretically weaker but as solid in practice
    as Salsa20.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20默认执行20轮，但我们有时使用仅12轮的版本，称为Salsa20/12，以提高速度。尽管Salsa20/12比Salsa20少了八轮，但根据最新的研究进展，实际上它与20轮版本一样可靠。即使是Salsa20/8，只有八轮，也被认为只是理论上较弱，但在实践中与Salsa20一样稳固。
- en: Breaking Salsa20 should ideally take 2^(256) operations, thanks to its use of
    a 256-bit key. If one can recover the key by performing fewer than 2^(256) operations,
    the cipher is in theory broken. That’s exactly the case with Salsa20/8.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，打破Salsa20应该需要2^(256)次操作，因为它使用了256位密钥。如果能够通过少于2^(256)次的操作恢复密钥，则该加密算法在理论上是破解的。Salsa20/8恰好就是这种情况。
- en: 'The attack on Salsa20/8 (published in the 2008 paper “New Features of Latin
    Dances: Analysis of Salsa, ChaCha, and Rumba,” of which I’m a co-author and for
    which we won a cryptanalysis prize from Daniel J. Bernstein) exploits a statistical
    bias in Salsa’s core algorithm after four rounds to recover the key of eight-round
    Salsa20\. In reality, this is mostly a theoretical attack: we estimate its complexity
    at 2^(251) operations of the core function—infeasible, like any computation of,
    say, 2^(100) operations or more, but less so than breaking the expected 2^(256)
    complexity.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对Salsa20/8的攻击（发布于2008年的论文《拉丁舞的新特性：Salsa、ChaCha和Rumba的分析》，我作为共同作者之一，并因此获得了Daniel
    J. Bernstein的密码分析奖）利用了Salsa核心算法在四轮后的统计偏差，从而恢复了八轮Salsa20的密钥。实际上，这大多是一个理论攻击：我们估计其复杂度为2^(251)次核心函数操作——这是不可行的，就像计算2^(100)次操作或更多一样不现实，但比打破预期的2^(256)复杂度要容易一些。
- en: 'The attack exploits not only a bias over the first four rounds of Salsa20/8
    but also a property of the last four rounds: knowing the nonce, *N*, and the counter,
    *Ctr* (refer to [Figure 5-10](chapter5.xhtml#fig5-10)), the only value needed
    to invert the computation from the keystream back to the initial state is the
    key, *K*. But as [Figure 5-13](chapter5.xhtml#fig5-13) shows, if you know only
    some part of *K*, you can partially invert the computation up until the fourth
    round and observe some bits of that intermediate state—including the biased bit!
    You’ll observe the bias only if you have the correct guess of the partial key;
    hence, the bias serves as an indicator that you’ve got the correct key.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 该攻击不仅利用了Salsa20/8前四轮的偏差，还利用了最后四轮的一个特性：已知nonce，*N*，和计数器，*Ctr*（参见[图5-10](chapter5.xhtml#fig5-10)），要将密钥流逆向计算回初始状态所需的唯一值就是密钥，*K*。但是正如[图5-13](chapter5.xhtml#fig5-13)所示，如果你仅知道部分*K*，你可以将计算逆转到第四轮，并观察到一些中间状态的位——包括偏差位！你只有在正确猜出部分密钥时，才会观察到偏差；因此，偏差就作为一个指示，表明你已经找到了正确的密钥。
- en: '![](../images/fig5-13.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig5-13.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-13: The principle
    of the attack on Salsa20/8</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-13：Salsa20/8攻击原理</samp>
- en: In the actual attack on Salsa20/8, to determine the correct guess we need to
    guess 220 bits of the key, and we need 2^(31) pairs of keystream blocks, all with
    the same specific difference in the nonce. Once we single out the correct 220
    bits, we brute-force 36 bits. The brute-forcing takes 2^(36) operations, a computation
    that is dwarfed by the unrealistic 2^(220) × 2^(31) = 2^(251) trials needed to
    find the 220 bits to complete the first part of the attack.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的Salsa20/8攻击中，为了确定正确的猜测，我们需要猜测密钥的220个位，并且需要2^(31)对具有相同特定nonce差异的密钥流块。一旦筛选出正确的220个位，我们就能通过暴力破解36个位。暴力破解需要2^(36)次操作，这一计算量比2^(220)
    × 2^(31) = 2^(251)次试验还要小，而后者是找到220个位以完成攻击第一部分所需的次数。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">可能出错的地方</samp>
- en: Alas, many things can go wrong with stream ciphers, from brittle, insecure designs
    to strong algorithms incorrectly implemented. I’ll explore each category of potential
    problems in the following sections.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，流密码中可能会出现许多问题，从脆弱、不安全的设计到实现不当的强加密算法。我将在接下来的章节中探讨每一类潜在问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nonce Reuse</samp>
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nonce重用</samp>
- en: The most common failure with stream ciphers occurs when reusing a nonce more
    than once with the same key. This produces identical keystreams, allowing you
    to break the encryption—for example, by XORing two ciphertexts together; the keystream
    then vanishes, and you’re left with the XOR of the two plaintexts.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码中最常见的失败发生在使用相同的密钥多次重用 nonce 时。这会产生相同的密钥流，从而使加密被破解——例如，通过将两个密文进行异或操作；然后，密钥流消失，你将得到两个明文的异或结果。
- en: A real example is older versions of Microsoft Word and Excel that used a unique
    nonce for each document, but modifying a document didn’t change the nonce. As
    a result, one could use the clear and encrypted text of an older version of a
    document to decrypt later encrypted versions. If Microsoft made this blunder,
    you can imagine how large the problem might be.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真实的例子是早期版本的 Microsoft Word 和 Excel，它们为每个文档使用了唯一的 nonce，但修改文档并不会改变 nonce。因此，人们可以使用旧版本文档的明文和加密文本来解密后来加密的版本。如果微软犯下这个错误，你可以想象问题会有多大。
- en: Certain stream ciphers designed in the 2010s tried to mitigate the risk of nonce
    reuse by building “misuse-resistant” constructions, or ciphers that remain secure
    even if a nonce is used twice. However, achieving this level of security comes
    with a performance penalty, as you’ll see in [Chapter 8](chapter8.xhtml) with
    the SIV mode.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 某些在 2010 年代设计的流密码尝试通过构建“抗滥用”构造来减轻 nonce 重用的风险，或者即使 nonce 被使用两次也能保持安全的密码。然而，达到这一安全级别会带来性能上的惩罚，正如你在
    [第 8 章](chapter8.xhtml) 中看到的 SIV 模式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Broken RC4 Implementation</samp>
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">损坏的 RC4 实现</samp>
- en: Though it’s intrinsically weak, RC4 can become even weaker if you blindly optimize
    its implementation. For example, let’s consider an entry in the 2007 Underhanded
    C Contest, an informal competition where programmers write benign-looking code
    that actually includes a malicious function.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 RC4 本身非常脆弱，但如果你盲目优化其实现，它可能会变得更脆弱。例如，考虑一下 2007 年的 Underhanded C 竞赛中的一个参赛作品，这是一个非正式的竞赛，程序员编写看似无害的代码，实际上却包含恶意功能。
- en: 'Here’s how it works. The naive way to implement the line <samp class="SANS_TheSansMonoCd_W5Regular_11">swap(S[i],
    S[j])</samp> in RC4’s algorithm is to do the following, as this Python code shows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作原理如下。实现 RC4 算法中行 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap(S[i],
    S[j])</samp> 的一种简单方法是执行以下操作，如 Python 代码所示：
- en: '[PRE5]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This way of swapping two variables works, but you need to create a new variable,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">buf</samp>. To avoid this, programmers
    often use the following *XOR-swap* trick to swap the values of the variables <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种交换两个变量的方法是可行的，但你需要创建一个新的变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">buf</samp>。为了避免这种情况，程序员通常使用以下
    *XOR-交换* 技巧来交换变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 的值：
- en: '[PRE6]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This works because the second line sets <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, and the third line
    sets <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = y</samp>. Using this trick to implement RC4 gives the implementation in [Listing
    5-5](chapter5.xhtml#Lis5-5) (adapted from David Wagner and Philippe Biondi’s program
    submitted to the 2007 Underhanded C Contest, and online at *[http://<wbr>www<wbr>.underhanded<wbr>-c<wbr>.org<wbr>/<wbr>_page<wbr>_id<wbr>_16<wbr>.html](http://www.underhanded-c.org/_page_id_16.html)*).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法之所以有效，是因为第二行将 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>，第三行将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">y = y</samp>。使用这个技巧来实现 RC4 会得到
    [清单 5-5](chapter5.xhtml#Lis5-5) 中的实现（改编自 David Wagner 和 Philippe Biondi 提交到 2007
    年 Underhanded C 竞赛的程序，并在线访问于 *[http://<wbr>www<wbr>.underhanded<wbr>-c<wbr>.org<wbr>/<wbr>_page<wbr>_id<wbr>_16<wbr>.html](http://www.underhanded-c.org/_page_id_16.html)*）。
- en: '[PRE7]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: An incorrect C
    implementation of RC4, due to its use of an XOR swap</samp>'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-5：由于使用了异或交换，RC4的C语言实现不正确</samp>
- en: Can you spot the problem with the XOR swap?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现异或交换的问题吗？
- en: 'Things go south when <samp class="SANS_TheSansMonoCd_W5Regular_11">i = j</samp>.
    Instead of leaving the state unchanged, the XOR swap sets <samp class="SANS_TheSansMonoCd_W5Regular_11">S[i]</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">S[i]</samp> ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">S[i]
    = 0</samp>. In effect, a byte of the state is set to zero each time <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    equals <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> in the key schedule
    or during encryption, ultimately leading to an all-zero state and thus to an all-zero
    keystream. For example, after processing 68KB of data, most of the bytes in the
    256-byte state are zero, and the output keystream looks like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <samp class="SANS_TheSansMonoCd_W5Regular_11">i = j</samp> 时，情况就变得糟糕。与其保持状态不变，异或交换会将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S[i]</samp> 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">S[i]</samp>
    ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">S[i] = 0</samp>。实际上，每当 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> 时，状态中的一个字节就会被置为零，无论是在密钥调度还是加密过程中，最终会导致一个全零的状态，从而生成一个全零的密钥流。例如，在处理68KB数据后，256字节状态中的大多数字节都变为零，输出的密钥流如下所示：
- en: '![](../images/pg113-1.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg113-1.jpg)'
- en: The lesson here is to refrain from over-optimizing your crypto implementations.
    Clarity and confidence always trump performance in cryptography.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，不要过度优化你的加密实现。在密码学中，清晰和信心始终优于性能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weak Ciphers Baked
    into Hardware</samp>
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">嵌入硬件的弱密码</samp>
- en: When a cryptosystem fails to be secure, some systems quickly respond by silently
    updating the affected software remotely (as with web applications) or by releasing
    a new version and prompting the users to upgrade (as with mobile applications).
    Other systems aren’t so lucky and need to stick to the compromised cryptosystem
    for a while before upgrading to a secure version, as is the case with certain
    satellite phones.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个加密系统无法保持安全时，有些系统会迅速通过远程静默更新受影响的软件（如网页应用程序）或通过发布新版本并提示用户升级（如移动应用程序）来响应。其他系统则没那么幸运，需要坚持使用被破坏的加密系统一段时间，才能升级到安全版本，某些卫星电话就是这种情况。
- en: In the early 2000s, US and European telecommunication standardization institutes
    (TIA and ETSI) jointly developed two standards for satellite phone (satphone)
    communications. Satphones are like mobile phones, except that their signal goes
    through satellites rather than terrestrial stations. The advantage is that you
    can use them pretty much everywhere in the world, as long as you have satellite
    coverage. Their downsides are the price, quality, latency, and, as it turns out,
    security.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代初期，美国和欧洲的电信标准化机构（TIA和ETSI）共同开发了两项卫星电话通信标准。卫星电话类似于移动电话，区别在于它们的信号通过卫星传输，而非地面基站。其优点是，只要有卫星覆盖，几乎可以在全球任何地方使用。缺点是价格、质量、延迟，以及，事实证明，安全性。
- en: GMR-1 and GMR-2 are the two satphone standards adopted by most commercial vendors,
    such as Thuraya and Inmarsat. Both include stream ciphers to encrypt voice communications.
    GMR-1’s cipher is hardware oriented, with a combination of four LFSRs, similar
    to A5/2, the deliberately insecure cipher in the 2G mobile standard aimed at non-Western
    countries. GMR-2’s cipher is software oriented, with an 8-byte state and the use
    of S-boxes. Both stream ciphers are insecure and protect users only against amateurs,
    not against state agencies.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: GMR-1和GMR-2是大多数商业供应商（如Thuraya和Inmarsat）采用的两种卫星电话标准。它们都包含流密码用于加密语音通信。GMR-1的密码设计偏向硬件，结合了四个LFSR，类似于A5/2——一种故意不安全的密码，用于面向非西方国家的2G移动标准。GMR-2的密码设计偏向软件，使用了8字节的状态和S盒。两种流密码都不安全，只能防御业余攻击者，无法抵御国家级机构的攻击。
- en: This story reminds us that stream ciphers used to be easier to break than block
    ciphers and that they’re easier to sabotage. Why? Well, if you design a weak stream
    cipher on purpose, when you find the flaw, you can still blame it on the weakness
    of stream ciphers and deny any malicious intent.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事提醒我们，流密码曾经比块密码更容易被破解，而且更容易被破坏。为什么？因为如果你故意设计一个弱的流密码，当你发现漏洞时，你依然可以把问题归咎于流密码本身的弱点，并否认任何恶意意图。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进一步阅读</samp>
- en: To learn more about stream ciphers, begin with the archives of the eSTREAM competition
    at *[https://<wbr>www<wbr>.ecrypt<wbr>.eu<wbr>.org<wbr>/stream<wbr>/project<wbr>.html](https://www.ecrypt.eu.org/stream/project.html)*,
    where you’ll find hundreds of papers on stream ciphers, including details of more
    than 30 candidates and many attacks. Some of the most interesting attacks are
    the correlation attacks, algebraic attacks, and cube attacks. See in particular
    the work of Nicolas Courtois and Willi Meier for the first two attack types and
    that of Itai Dinur and Adi Shamir for cube attacks.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于流密码的信息，可以从eSTREAM竞赛的档案开始，访问 *[https://<wbr>www<wbr>.ecrypt<wbr>.eu<wbr>.org<wbr>/stream<wbr>/project<wbr>.html](https://www.ecrypt.eu.org/stream/project.html)*，在这里你可以找到数百篇关于流密码的论文，其中包括30多个候选算法的详细信息以及许多攻击。最有趣的攻击之一是相关性攻击、代数攻击和立方体攻击。特别参考Nicolas
    Courtois和Willi Meier的研究，了解前两种攻击类型，以及Itai Dinur和Adi Shamir的立方体攻击研究。
- en: For more about attacks on RC4, look up the 2001 Scott Fluhrer, Itsik Mantin,
    and Adi Shamir (FMS) attack, and the 2013 research article “On the Security of
    RC4 in TLS.”
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于RC4攻击的信息，可以查阅2001年Scott Fluhrer、Itsik Mantin和Adi Shamir（FMS）提出的攻击，以及2013年关于“RC4在TLS中的安全性”的研究文章。
- en: Salsa20’s legacy deserves your attention, too. The stream cipher ChaCha is similar
    to Salsa20 but with a slightly different core permutation that was later used
    in the hash function BLAKE, as you’ll see in [Chapter 6](chapter6.xhtml). These
    algorithms all leverage Salsa20’s software implementation techniques using parallelized
    instructions, as discussed at *[https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/snuffle<wbr>.html](https://cr.yp.to/snuffle.html)*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20的遗产同样值得关注。流密码ChaCha与Salsa20相似，但其核心置换略有不同，后来这一置换被用于哈希函数BLAKE，正如你在[第6章](chapter6.xhtml)中看到的那样。这些算法都利用了Salsa20的软件实现技术，采用并行指令，正如在
    *[https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/snuffle<wbr>.html](https://cr.yp.to/snuffle.html)*
    中所讨论的那样。
