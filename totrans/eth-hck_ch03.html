<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
	<head>
		<title>Ethical Hacking: A Hands-on Introduction to Breaking In</title>
		<link href="../styles/9781718501881.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3776231c-affd-4772-8376-b44c973236be" name="Adept.expected.resource"/>
	</head>
	<body>
		<h2 class="h2" id="ch3"><span epub:type="pagebreak" id="page_31"/><strong><span class="big">3</span><br/>ANALYZING CAPTURED TRAFFIC</strong></h2>
		<p class="verse"><em>The internet is just a world passing notes around a classroom.</em></p>
		<p class="chap-au">–Jon Stewart</p>
		<div class="imagec">
			<img alt="image" src="../images/common.jpg"/>
		</div>
		<p class="noindents">In <a href="ch02.xhtml#ch2">Chapter 2</a>, you learned how a hacker in a coffee shop could use an ARP spoofing attack to intercept a victim’s internet traffic. Now let’s actually view that traffic. In this chapter, we’ll use two tools, <em>Wireshark</em> and <em>TCPDump</em>, to steal private data from the unencrypted packets we intercepted. I’ll also introduce the concept of a protocol and discuss the general software architecture of the internet. We’ll conclude by analyzing the packets collected by your firewall so that you can detect attacks on your network.</p>
		<h3 class="h3" id="ch03lev1"><strong>Packets and the Internet Protocol Stack</strong></h3>
		<p class="noindent">A <em>protocol</em> is a set of rules that governs the communication between systems. For example, when humans communicate, we first exchange “Hello” messages and then exchange information before ending the conversation with <span epub:type="pagebreak" id="page_32"/>“Goodbye.” Similarly, when a browser wants to learn the IP address of a website such as <em><a href="https://cs.virginia.edu/">https://cs.virginia.edu/</a></em>, it uses the <em>Domain Name System (DNS)</em> protocol to communicate with a DNS server. It begins by sending a DNS query requesting the IP address for <em><a href="https://cs.virginia.edu/">https://cs.virginia.edu/</a></em>. The DNS server will then respond with the IP address. <a href="ch03.xhtml#ch3fig1">Figure 3-1</a> shows protocol sequence diagrams for both human communication and the DNS protocol.</p>
		<div class="image" id="ch3fig1">
			<img alt="image" src="../images/ch03fig01.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-1: A protocol sequence diagram showing an example human communication protocol and the DNS communication protocol</em></p>
		<p class="indent">In addition to governing communication rules, a protocol determines how information is laid out in a packet. In English, we often say “Hello, Alice” and rarely “Alice Hello,” because the English language dictates that the greeting should precede the name. The same is true for internet protocols. They usually require the packet header to contain specific information. Returning to the letter example from <a href="ch02.xhtml#ch2">Chapter 2</a>, <a href="ch03.xhtml#ch3fig2">Figure 3-2</a> shows how address fields on an envelope are analogous to packet headers.</p>
		<div class="image" id="ch3fig2">
			<img alt="image" src="../images/ch03fig02.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-2: How header fields in a packet are like addresses on an envelope</em></p>
		<p class="indent">In addition to IP addresses, this figure contains header fields for the source and destination <em>port numbers</em>, which are assigned by the operating system when it allows a process to communicate over the network. Port <span epub:type="pagebreak" id="page_33"/>numbers are unique, meaning that no two processes on a machine can use the same port number. A <em>process</em> is an abstraction that represents a running program. For example, when you open your web browser, your computer’s operating system starts a process that is associated with that browser. When a process wants to send and receive information through the network, the operating system assigns that process a port number. You can think of this number as being like a shipping port. For example, packets intended for your web server will usually arrive at your IP address 192.168.1.100 on port 443. In other words, ports expose internal processes to the network.</p>
		<p class="indent">Ports are necessary because they allow multiple processes on your computer to communicate with the internet simultaneously, as illustrated in <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>.</p>
		<div class="image" id="ch3fig3">
			<img alt="image" src="../images/ch03fig03.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-3: How ports allow packets to flow in and out of a system</em></p>
		<p class="indent">When your operating system receives a packet from the network, it examines the port number to decide whether the packet is intended for your browser or messenger. However, ports also create a security risk because they open your computer to outside attackers. Often, one of the first things an attacker will do is scan a machine to discover open ports. A port is open if it accepts a connection from an external process. If the attacker finds an open port, they will attempt to infect your machine by sending it malicious packets. We’ll discuss how to scan for open ports and exploit the associated vulnerable process in <a href="ch04.xhtml#ch4">Chapter 4</a>.</p>
		<h4 class="h4" id="ch03lev2"><strong><em>The Five-Layer Internet Protocol Stack</em></strong></h4>
		<p class="noindent">To address the complexity of designing software for the internet, engineers decided to abstract the architecture into five independent layers. Each layer <span epub:type="pagebreak" id="page_34"/>is responsible for managing the communication between specific components in the network. For example, the network layer manages communication between routers on the internet, whereas the application layer manages communication between applications, such as BitTorrent clients.</p>
		<p class="indent">Each layer is independent, meaning its actions aren’t affected by the actions performed at the other layers. The protocol stack achieves this through a process called <em>encapsulation</em>, in which each layer treats information from the layers above it as generic data and does not try to interpret it. <a href="ch03.xhtml#ch3fig4">Figure 3-4</a> shows how information is encapsulated at each layer before it is finally transmitted at the physical layer.</p>
		<div class="image" id="ch3fig4">
			<img alt="image" src="../images/ch03fig04.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-4: Five-layer internet protocol stack</em></p>
		<p class="indent">Let’s say a user composes an email. This happens at the application layer. As you can see, the messages associated with the email are then placed in transport layer packets. The transport layer does not read or alter the email in any way. It simply labels the packet with the information needed to process it. These transport layer packets are then placed into network layer packets and then data link layer packets before they are finally transmitted. By encapsulating and labeling each packet with its own headers, each layer can make decisions without depending on information from another layer. <a href="ch03.xhtml#ch3fig5">Figure 3-5</a> shows an overview of the five-layer internet protocol stack, along with its headers and components. This layered approach allows two components in the same layer to communicate as though they were the only components in the network. For example, when your web browser makes a request to <em><a href="https://google.com">https://google.com</a></em>, it is completely unaware of the routers that handle the request. Thus, it appears as though the web browser were directly communicating with the Google server. Now let’s look more closely at each layer.</p>
		<div class="image" id="ch3fig5">
			<span epub:type="pagebreak" id="page_35"/>
			<img alt="image" src="../images/ch03fig05.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-5: The network components that are communicating at each layer of the five-layer internet protocol stack</em></p>
		<h5 class="h5" id="ch03lev3"><strong>The Application Layer</strong></h5>
		<p class="noindent">The <em>application layer</em> is responsible for communications between applications; for example, between your Firefox browser and the University of Virginia web servers. There are several application layer protocols. The <em>hypertext transfer protocol (HTTP)</em> sends web pages to browsers, and the <em>file transfer protocol (FTP)</em> uploads files to a server. This is one of the easiest layers for which software developers can define their own protocols. DNS, FTP, and BitTorrent are a few examples of application layer protocols. Throughout this book, you’ll modify various application layer protocols. For example, in <a href="ch07.xhtml#ch7">Chapter 7</a>, you’ll write a Python program that sends a fake email using a modified version of the simple mail transfer protocol (SMTP). Some malicious programs define custom protocols to avoid detection, whereas others use existing protocols in unexpected ways, such as using DNS for <em>command and control</em>. Not to worry, I’ll discuss this in the next chapter, when you’ll implement your own simple custom application layer protocol.</p>
		<h5 class="h5" id="ch03lev4"><strong>The Transport Layer</strong></h5>
		<p class="noindent">The <em>transport layer</em> is responsible for managing communication between processes communicating over the internet. Because of limitations in its design, <span epub:type="pagebreak" id="page_36"/>the internet does not always reliably deliver packets. You may have noticed dropped packets while video chatting or playing a game. This layer has two main protocols: the <em>transmission control protocol (TCP)</em>, which provides a guarantee that packets have reached their destination, and the <em>user datagram protocol (UDP)</em>, which is less complex and provides no guarantees.</p>
		<h5 class="h5" id="ch03lev5"><strong>The Network Layer</strong></h5>
		<p class="noindent">The <em>network layer</em> is responsible for controlling how packets flow between routers in the network. IP addresses are implemented at this layer. You can see every router your packets pass through by using the <span class="literal">traceroute</span> tool. The <span class="literal">traceroute</span> tool uses a network layer protocol called the <em>internet control message protocol (ICMP)</em> to construct packets that probe the network to learn the path a packet takes. You can run <span class="literal">traceroute</span> using the following command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">traceroute www.virginia.edu</span><br/><br/>traceroute to uvahome.prod.acquia-sites.com (54.227.255.92)<br/>
 1 pfSense.localdomain (192.168.1.1)  0.55 ms  .66 ms  0.61 ms<br/>
 2 1.0.0.1 (10.0.0.1)  3.077 ms  1.011 ms  2.894 ms<br/>
 .......</p>
		<p class="indent">The command probes each router with three packets and then records the time it takes for each packet to reach the router. As you can see, the first router we encounter is the pfSense router in our lab environment. The second router is the one in the coffee shop.</p>
		<h5 class="h5" id="ch03lev6"><strong>The Data Link Layer</strong></h5>
		<p class="noindent">The <em>data link layer</em> is responsible for communication between NICs. It also detects errors that might have occurred during transmissions. For example, Wi-Fi signals may become corrupted during transmission due to interference from other radio signals. The data link layer also implements the MAC protocol, which is responsible for sharing the <em>transmission medium</em> (for example, radio spectrum or wires). Consider the laptops in the coffee shop. How is it possible for all of these machines to transmit Wi-Fi radio waves without interfering with one another? Well, Wi-Fi implements a MAC protocol called <em>carrier sense multiple access</em>, which listens to the Wi-Fi signals and then transmits only when no one else is transmitting. Essentially, the laptops in the coffee shop are waiting their turn by listening for an empty slot.</p>
		<h5 class="h5" id="ch03lev7"><strong>The Physical Layer</strong></h5>
		<p class="noindent">The <em>physical layer</em> is responsible for converting the ones and zeros that represent data in a computer into a transmittable form. This could mean translating them into pulses of light, radio or electrical signals, or even sound. For example, communications at the physical layer might use a laser that emits pulses of light into a fiber-optic cable.</p>
		<h3 class="h3" id="ch03lev8"><span epub:type="pagebreak" id="page_37"/><strong>Viewing Packets in Wireshark</strong></h3>
		<p class="noindent">Now let’s examine some packets. Wireshark is a tool that allows you to capture and view the packets that flow through your NIC. It’s installed by default in most Kali Linux installations. To launch Wireshark, click <strong>Applications</strong> ▶<strong>Sniffing and Snooping</strong> ▶<strong>Wireshark</strong>, or open a terminal window and run the following command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">sudo wireshark</span></p>
		<p class="indent">If Wireshark is not installed, install it by running the following:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">sudo apt install wireshark</span></p>
		<p class="indent">It’s important to run Wireshark with root privileges so it has unrestricted access to your computer’s interfaces. After you start Wireshark, you should see a welcome screen similar to <a href="ch03.xhtml#ch3fig6">Figure 3-6</a>.</p>
		<div class="image" id="ch3fig6">
			<img alt="image" src="../images/ch03fig06.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-6: The Wireshark welcome screen</em></p>
		<p class="indent">The welcome screen lists the interfaces your machine uses to communicate with the network. Because all of our virtual lab’s devices are attached to an Ethernet interface, we’ll monitor traffic on the <span class="literal">eth0</span> interface. Select this interface by clicking <strong>eth0</strong>. On the other hand, if you want to monitor Wi-Fi traffic, you should select the <strong>wlan</strong> interface. A third interface, labeled <strong>lo</strong>, represents a virtual network interface called the <em>loopback interface</em>, which redirects traffic back to the machine itself.</p>
		<p class="indent">Let’s use Wireshark to view the packets we intercepted during the ARP spoofing attack in <a href="ch02.xhtml#ch2">Chapter 2</a>. Recall that an ARP spoofing attack tricks the network into routing the victim’s incoming and outgoing traffic through the hacker’s NIC. <a href="ch03.xhtml#ch3fig7">Figure 3-7</a> shows an overview of how we use Wireshark to view the packets intercepted during an ARP spoofing attack. Packets are duplicated as they enter the NIC, and the copies are sent directly to Wireshark using operating system drivers in the NPCAP library. Simultaneously, the card forwards the original packets to the victim’s NIC, where they are sent to the victim’s browser. The browser displays the web page (<em><a href="http://facebook.com/">http://facebook.com/</a></em>, in this example) and the victim remains completely unaware that their packets were intercepted.</p>
		<div class="image" id="ch3fig7">
			<span epub:type="pagebreak" id="page_38"/>
			<img alt="image" src="../images/ch03fig07.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-7: Interactions between Wireshark and the NIC</em></p>
		<p class="indent">To avoid having to re-execute an ARP spoofing attack, we’ll examine packets we generate ourselves on the Kali Linux virtual machine. However, if you wanted to perform another ARP spoofing attack, you could still use the steps described here.</p>
		<p class="indent">First, we’ll pretend to be the victim and generate some web traffic by accessing the web server on the Metasploitable machine. Because we didn’t configure a DNS server in our setup, our victim can’t access the Metasploitable server by entering a URL like <em><a href="http://www.evil.corp/">http://www.evil.corp/</a></em>. Instead, we’ll manually obtain the server’s IP address. Log in to the Metasploitable machine using the username <strong>msfadmin</strong> and password <strong>msfadmin</strong>. When you’ve logged in, run the following command to obtain its IP address:</p>
		<p class="programs">msfadmin@metasploitable:~$ <span class="codestrong1">ifconfig eth0</span><br/><br/>
   eth0    Link encap:Ethernet  HWaddr 00:17:9A:0A:F6:44<br/>
   inet addr: 192.168.1.101   Bcast:192.168.1.255  Mask:255.255.255.0</p>
		<p class="indent">The value after <span class="literal">inet addr:</span> is the IP address.</p>
		<p class="indent">Back in Kali Linux, start the packet capture process by clicking the shark fin icon (<span class="middle"><img alt="image" src="../images/icon.jpg"/></span>) in the upper-left corner of the Wireshark screen. Next, we will pretend to be the victim and generate packets by opening the Firefox browser and entering the server’s IP address into the address bar; for example: <em>http://192.168.1.101/</em> (your machine might have a different address). <a href="ch03.xhtml#ch3fig8">Figure 3-8</a> shows the three main sections of the Wireshark capture screen.</p>
		<div class="image" id="ch3fig8">
			<span epub:type="pagebreak" id="page_39"/>
			<img alt="image" src="../images/ch03fig08.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-8: The Wireshark window</em></p>
		<p class="indent">If you choose to do this in the context of an ARP-spoofing attack you would generate the traffic from the victim machine instead of the Kali Linux machine. Once the page has loaded, click the red stop icon (<span class="middle"><img alt="image" src="../images/icon1.jpg"/></span>) to end the capture. Notice that the process of opening the browser and visiting a single web page generated more than 4,000 packets!</p>
		<p class="indent">How could an attacker possibly sift through all of this information to learn more about the victim? Not to worry: Wireshark contains a filter function that allows you to find the packets that interest you. Let’s assume that you’re interested in viewing only packets that have been sent to the Metasploitable server at the IP address 192.168.1.101 (remember, your IP address may be different). Enter the following command into the filter box so that Wireshark will display only the packets exchanged with the Metasploitable server.</p>
		<p class="programs">ip.dst == 192.168.1.101</p>
		<p class="indent">Let’s examine this command closely. Here, we are limiting the packets to only those with a destination IP address (<span class="literal">ip.dst</span>) of 192.168.1.101. <a href="ch03.xhtml#ch3fig9">Figure 3-9</a> shows the result of running this filter query.</p>
		<div class="image" id="ch3fig9">
			<span epub:type="pagebreak" id="page_40"/>
			<img alt="image" src="../images/ch03fig09.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-9: Filtering packets in Wireshark</em></p>
		<p class="indent">Filtering packets to include only those that are sent to the server reduces the number of packets you need to examine. Once you understand the general syntax of Wireshark display filters, you can construct filters of your own. Here is the structure of a Wireshark filter:</p>
		<p class="programs">[Protocol].[header/field] [operator: +,==,!=] [value]</p>
		<p class="indent">First, specify the protocol (<span class="literal">[Protocol]</span>); for example, TCP or IP. Next, specify the packet field you’d like to filter on; for example, the source IP address (<span class="literal">src</span>) or destination IP address (<span class="literal">dst</span>). Lastly, specify an operator and value; for example, not equal to (<span class="literal">!=</span>) 192.168.1.10. Using this structure, we will construct a filter that displays only packets with the server’s source IP address, as follows:</p>
		<p class="programs">ip.src == 192.168.1.101</p>
		<p class="indent">Wireshark also allows you to filter packets based on their content. For example, an attacker might find packets that contain terms like <em>password</em>, <em>email</em>, or <em>@virginia</em>. You can search all TCP packets for the term <em>login</em> using the following filter:</p>
		<p class="programs">tcp contains login</p>
		<p class="indent">Armed with these filtering techniques, let’s identify the TCP packets transmitted between the server and the Kali Linux machine. Right-click one of the packets with the destination address of the Metasploitable server and select <strong>Conversation Filter</strong> ▶<strong>TCP</strong>, as shown in <a href="ch03.xhtml#ch3fig10">Figure 3-10</a>. This will display only the packets exchanged between the Kali Linux virtual machine and the Metasploitable server.</p>
		<div class="image" id="ch3fig10">
			<span epub:type="pagebreak" id="page_41"/>
			<img alt="image" src="../images/ch03fig10.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-10: TCP conversation filtering</em></p>
		<p class="indent">This is equivalent to the following filter:</p>
		<p class="programs">ip.src == 192.168.1.101 | ip.dst == 192.168.1.101</p>
		<p class="indent">Now, why are there so many packets if all we did was load a single web page? This happens because the server breaks the web page into smaller pieces and then transmits them as separate packets if a file is too large to be transmitted in a single packet. The recipient will reassemble these packets to recover the original file.</p>
		<p class="indent">Wireshark lets you reconstruct this data from a packet stream by clicking a packet and selecting <strong>Follow</strong> ▶<strong>TCP Stream</strong>, as shown in <a href="ch03.xhtml#ch3fig11">Figure 3-11</a>. If you do this, you should see the HTML corresponding to the page.</p>
		<div class="image" id="ch3fig11">
			<img alt="image" src="../images/ch03fig11.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-11: Following a TCP stream on Wireshark</em></p>
		<p class="indent">The reassembled stream should look like <a href="ch03.xhtml#ch3fig12">Figure 3-12</a>.</p>
		<div class="image" id="ch3fig12">
			<span epub:type="pagebreak" id="page_42"/>
			<img alt="image" src="../images/ch03fig12.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-12: The reconstructed TCP stream</em></p>
		<p class="indent">Now you know how an attacker can use Wireshark to steal private data from the unencrypted packets intercepted in an ARP spoofing attack. This is why it’s so important to ensure that your web traffic is encrypted using HTTPS.</p>
		<h3 class="h3" id="ch03lev9"><strong>Analyzing Packets Collected by Your Firewall</strong></h3>
		<p class="noindent">Now that you’ve seen how a hacker uses Wireshark, let’s change tracks. This section discusses using Wireshark to determine if your network is being hacked. I’ll show you how to capture and analyze traffic collected by your pfSense firewall using Wireshark and <span class="literal">tcpdump</span>, a command line tool that allows you to save captured packets to a file.</p>
		<p class="indent">An easy way to do this is to save all packets associated with port 80 that pass through the firewall. Port 80 is almost always used for HTTP communication, whereas port 443 is commonly used for encrypted HTTPS traffic. If you’re interested in viewing web traffic, start with these two ports. For simplicity, I’ll focus on unencrypted HTTP traffic here. In <a href="ch06.xhtml#ch6">Chapter 6</a>, you’ll learn how to decrypt encrypted traffic by obtaining the encryption key from the victim’s machine.</p>
		<h4 class="h4" id="ch03lev10"><strong><em>Capturing Traffic on Port 80</em></strong></h4>
		<p class="noindent">Boot up the Kali Linux machine and navigate to <em><a href="http://cs.virginia.edu/">http://cs.virginia.edu/</a></em>. Because all traffic on your network passes through the pfSense firewall, you can use the <span class="literal">tcpdump</span> command on the pfSense machine to capture the TCP packets from the Kali Linux machine. Now start pfSense. You should see a screen that looks like this:</p>
		<p class="programs"> <span class="codestrong1">Welcome to pfSense                  (amd64) on pfSense</span><br/><br/>
 WAN (wan)       -&gt; em0        -&gt; v4/DHCP4: 10.0.1.11/24<br/>
 LAN (lan)       -&gt; em1        -&gt; v4: 192.168.1.1/24<br/><br/><span epub:type="pagebreak" id="page_43"/> 0) Logout (SSH only)                  9) pfTop<br/>
 1) Assign Interfaces                 10) Filter Logs<br/>
 2) Set interface(s) IP address       11) Restart webConfigurator<br/>
 3) Reset webConfigurator password    12) PHP shell + pfSense tools<br/>
 4) Reset to factory defaults         13) Update from console<br/>
 5) Reboot system                     14) Disable Secure Shell (sshd)<br/>
 6) Halt system                       15) Restore recent configuration<br/>
 7) Ping host                         16) Restart PHP-FPM<br/>
 8) Shell<br/>Enter an option:</p>
		<p class="indent">Start the shell option by entering <strong>8</strong>:</p>
		<p class="programs">Enter an option: <span class="codestrong1">8</span><br/><br/>
[RELEASE][root@pfSense.localdomain]/root:</p>
		<p class="indent">Next, enter <span class="literal"><strong>tcpdump</strong></span> in the shell. The program will run without options and capture all packets going through all of the system’s interfaces, and will continue to run until you terminate it by pressing CTRL-C. Here’s a sample <span class="literal">tcpdump</span> output:</p>
		<p class="programs">   [RELEASE][root@pfSense.localdomain]/root: <span class="codestrong1">tcpdump</span><br/>
   tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br/>
   listening on em0, link-type EN10MB (Ethernet), capture size 262144 byte<br/>
   ...<br/>
   ...<br/><span class="ent">➊</span> 15:18:44.372924 IP 192.168.1.100.41193 &gt; z.arin.net.domain<br/>
   57745% [1au] DS? 41.198.in-addr.arpa (40)<br/>
   ...</p>
		<p class="indent">Notice that the traffic is organized into lines. Let’s analyze one of them to understand what’s being printed. <span class="literal">15:18:44.372924</span> is a timestamp indicating when the traffic was captured <span class="ent">➊</span>. <span class="literal">IP</span> identifies the protocol of the packet, and <span class="literal">192.168.1.100.41193</span> indicates the source’s combined IP address and port number (the port number alone is <span class="literal">41193</span>). Next, <span class="literal">z.arin.net.domain.57745</span> represents the destination’s IP address and port. To make the trace more readable, <span class="literal">tcpdump</span> converts this IP address to its associated domain name. You can disable this by adding the <span class="literal">-n</span> flag to the command. Everything else is specific information pertaining to the packet.</p>
		<p class="indent">As in Wireshark, you can capture packets from a specific protocol by passing that protocol as an argument to <span class="literal">tcpdump</span>. You can also listen to packets from a certain port by specifying the port number. For example, to capture only TCP packets on port 443, run this command in pfSense:</p>
		<p class="programs">[RELEASE][root@pfSense.localdomain]/root: <span class="codestrong1">tcpdump tcp port 443 -n</span><br/>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br/><span epub:type="pagebreak" id="page_44"/>listening on <span class="ent">➊</span>em0, link-type EN10MB (Ethernet), capture size 262144 bytes<br/>
01:49:15.194721 IP 10.0.1.11.4092 &gt; 172.253.63.113.443: Flags ....<br/>
01:49:15.208283 IP 172.253.63.113.443 &gt; 10.0.1.11.4092: Flags ....</p>
		<p class="indent">If you don’t see any packets, try refreshing your web browser in Kali Linux. Instead of displaying the packets in the terminal, you also can write them to a file that you then can analyze in Wireshark:</p>
		<p class="programs">tcpdump -i <span class="codeitalic">&lt;interface&gt;</span> -s <span class="codeitalic">&lt;number of packets to capture&gt;</span> -w <span class="codeitalic">&lt;file.pcap&gt;</span></p>
		<p class="indent">The <span class="literal">-i</span> option represents the interface on which you’d like to capture packets. (You captured packets on the <span class="literal">em0</span> interface <span class="ent">➊</span> in the previous example.) You can get a list of all interfaces on a device by selecting the shell option from the start screen and running the <span class="literal">ifconfig</span> command. The <span class="literal">-s</span> flag represents the number of packets to capture, and the <span class="literal">-w</span> flag specifies the name of the file where the data will be stored. Once you’ve collected the data, you can view the file in Wireshark. Analyzing these traces can often be very tedious. Online tools like <em><a href="https://packettotal.com">https://packettotal.com</a></em> will analyze <em>.pcap</em> files for you and flag suspicious activity.</p>
		<h3 class="h3" id="ch03lev11"><strong>Exercises</strong></h3>
		<p class="noindent">Try these exercises to deepen your understanding of Wireshark and pfSense. In the first exercise, you’ll log in to pfSense through the web interface and explore its features. In the second exercise, you’ll use Wireshark to analyze packets from an ARP spoofing attack.</p>
		<h4 class="h4" id="ch03lev12"><strong><em>pfSense</em></strong></h4>
		<p class="noindent">In the Kali Linux browser, log in to pfSense by entering the router’s IP address into the URL bar. You will see a security warning saying that the security certificate is not valid. Select the option to add an exception. The pfSense firewall uses a self-signed certificate. I’ll discuss these certificates in <a href="ch06.xhtml#ch6">Chapter 6</a>. Next, log in using the default username <strong>admin</strong> and password <strong>pfsense</strong>. Once you’re logged in, change the default password, as shown in <a href="ch03.xhtml#ch3fig13">Figure 3-13</a>.</p>
		<div class="image" id="ch3fig13">
			<img alt="image" src="../images/ch03fig13.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-13: Change the default password in the pfSense firewall/router</em></p>
		<p class="indent">Now you’ll view real-time statistics on packets flowing through the firewall. Click <strong>Status</strong> and select <strong>Dashboard</strong> from the drop-down menu. You can view a global snapshot of your system from the dashboard. You also can add and remove panels from your dashboard. For example, click the plus icon and select <strong>Traffic graphs</strong> to add a real-time traffic graph. <a href="ch03.xhtml#ch3fig14">Figure 3-14</a> shows a screenshot of the dashboard.</p>
		<div class="image" id="ch3fig14">
			<span epub:type="pagebreak" id="page_45"/>
			<img alt="image" src="../images/ch03fig14.jpg"/>
		</div>
		<p class="figcap"><em>Figure 3-14: The pfSense dashboard</em></p>
		<p class="indent">Experiment by adding panels to the dashboard. Use this as an opportunity to familiarize yourself with the firewall.</p>
		<h4 class="h4" id="ch03lev13"><strong><em>Exploring Packets in Wireshark</em></strong></h4>
		<p class="noindent">Download the Wireshark capture of our ARP spoofing attack (<em>arpspoof.pcap</em>) from this book’s GitHub page at <em><a href="https://github.com/The-Ethical-Hacking-Book/ARP-pcap-files">https://github.com/The-Ethical-Hacking-Book/ARP-pcap-files</a></em>. Open the file in Wireshark and try answering the following questions: What are the MAC and IP addresses of the victim’s and attacker’s machines, and what is the MAC address of the local network’s router? Hint: the local router’s IP address is 192.168.1.1.</p>
		<p class="indent">You can find other packet captures to analyze by visiting <em><a href="https://www.netresec.com/index.ashx?page=PcapFiles/">https://www.netresec.com/index.ashx?page=PcapFiles/</a></em>.<span epub:type="pagebreak" id="page_46"/></p>
	</body>
</html>