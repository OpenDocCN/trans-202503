- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">COMMON
    FPGA MODULES</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: 'Working with an FPGA can feel like building with LEGO: you have a limited variety
    of small bricks at your disposal, but by stacking them elegantly, you can create
    amazingly complex designs. At the lowest level, you’re working with LUTs and flip-flops.
    At a slightly higher level, there are several basic building blocks that appear
    over and over again in FPGA designs, including multiplexers and demultiplexers,
    shift registers, and first in, first out (FIFO) and other types of memory.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Each of these elements is very common. In fact, it’s likely that one or more
    of them will be used in every single FPGA project you’ll ever work on. In this
    chapter, I’ll show you how these basic building blocks work and how to implement
    them with Verilog and VHDL. For each of these common elements, you’ll create a
    self-contained module that you can reuse anytime you need that element in an FPGA
    design. This will reinforce your FPGA programming knowledge and give you a solid
    foundation for your own projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Multiplexers and Demultiplexers</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Multiplexers* and *demultiplexers* are circuit components that allow you to
    select between two or more things. In the case of a multiplexer (sometimes spelled
    *multiplexor*, and often shortened to *mux*), you have multiple input signals,
    and you select which of them is sent to a single output. A demultiplexer (*demux*
    for short) is the opposite: you have a single input signal, and you select which
    of multiple outputs it should go to.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplexers and demultiplexers have many applications. For example, a mux
    could be used to select which speed to run a fan at: the low-med-high switch might
    be acting as a mux to control which setting is sent to the fan controller. A demux
    could work with a switch to select which of four LEDs to illuminate: only one
    LED will be illuminated at a time, but you’ll be able to specify which one is
    illuminated.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Muxes and demuxes are classified based on how many inputs and outputs they
    have. For example, a 4-1 (pronounced *four-to-one*) mux has four inputs and one
    output. Conversely, a 1-4 (pronounced *one-to-four*) demux has one input and four
    outputs. You can design muxes to have any number of inputs, depending on the requirements
    of your circuit: you can have a 2-1 mux, a 3-1 mux, an 8-1 mux, a 13-1 mux, or
    whatever you want. Likewise, you can design a demux with however many outputs
    you need.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing a Multiplexer</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s consider how to create a multiplexer on an FPGA. Specifically, we’ll look
    at creating a 4-1 mux, but you can apply the same logic to a mux with any number
    of inputs. [Figure 6-1](#fig6-1) shows a block diagram of a 4-1 mux.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: A 4-1 multiplexer
    (mux)</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Our multiplexer has four inputs on the left: <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data3</samp>. On the right
    is the single output, called <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>.
    At the bottom are two additional inputs, labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp>. *Sel* is short
    for *select*. These selector inputs choose which of the four data inputs is passed
    to the output. The truth table in [Table 6-1](#tab6-1) shows how <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> work together
    to determine the mux’s output.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for a 4-1 Mux</samp>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Sel1</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Sel0</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data</samp> |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data0</samp> |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data1</samp> |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data2</samp> |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data3</samp> |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: Looking at [Table 6-1](#tab6-1), we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data0</samp>
    is connected to the output when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> are both 0\. The
    output gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data1</samp> when
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> is 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp>
    is 1, it gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data2</samp> when
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> is 1 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp>
    is 0, and it gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data3</samp>
    when both selectors are 1.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '*Because muxes serve to select which inputs go to which outputs, they’re often
    called* selectors*. In fact, select is a reserved word in VHDL that can be used
    to generate muxes.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this truth table in Verilog or VHDL is simply a matter of evaluating
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp>
    and assigning the appropriate data input to the output. The following listing
    shows how it’s done (I’ve omitted the signal definitions to focus on the actual
    mux code, but more context can be found in the book’s GitHub repository, at *[https://<wbr>github<wbr>.com<wbr>/nandland<wbr>/getting<wbr>-started<wbr>-with<wbr>-fpgas](https://github.com/nandland/getting-started-with-fpgas))*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Verilog version uses the conditional (or ternary) operator, represented
    by a question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>). This
    is shorthand for writing conditional expressions without using <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp>
    statements. The operator works by first evaluating the condition before the question
    mark (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">!i_Sel1 & !i_Sel0</samp>).
    If the condition is true, the expression selects the condition before the colon.
    If the condition is false, it selects the condition after the colon. Here, we’ve
    chained several <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> operators
    together to handle each possible combination of the two selector inputs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In the VHDL version, we accomplish the same thing by chaining several <samp
    class="SANS_TheSansMonoCd_W5Regular_11">when/else</samp> statements. Since the
    VHDL version uses more spelled-out keywords, it’s a bit more readable, but the
    Verilog is more concise. In both the Verilog and VHDL versions, the chain of logical
    checks gets evaluated until one evaluates as true. If none of them are true, then
    we use the last assignment in the chain.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing a Demultiplexer</samp>
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a 1-4 demux, the block diagram looks like a mirrored version of a 4-1 mux,
    as you can see in [Figure 6-2](#fig6-2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: A 1-4 demultiplexer
    (demux)</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: This demux takes a single data input on the left (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>)
    and selects which output to connect it to. The demux is doing a 1-4 selection,
    so two input selectors are required to select between the four possible outputs.
    The truth table in [Table 6-2](#tab6-2) shows all the possible combinations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for a 1-4 Demux</samp>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Sel1</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Sel0</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data3</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data2</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data1</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data0</samp>
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: 'Looking at the table, we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>
    is connected to one of the four outputs at a time, as determined by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp>
    selector inputs. When <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> are both 0, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Data0</samp> gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>;
    otherwise it gets 0\. When <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp>
    is 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> is 1, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Data1</samp> gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>;
    otherwise it gets 0\. When <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp>
    is 1 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> is 0, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Data2</samp> gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>;
    otherwise it gets 0\. Finally, when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp>
    is 1 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> is 1, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Data3</samp> gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>;
    otherwise it gets 0\. Let’s see how we can implement this truth table in Verilog
    and VHDL:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how each output in this code is set independently. The input <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>
    can only be assigned to a single output at a time. For example, we assign it to
    the first output, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data0</samp>,
    when both selector inputs are 0 ❶. When an output isn’t wired to the input data,
    then it’s just set to 0 to disable it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, since a mux or demux can be created with just a few lines of code,
    it’s unlikely that you’d ever create a module to instantiate a single multiplexer
    or demultiplexer. Generally, you’ll be better off just putting the code that builds
    the mux or demux directly into the module where it’s needed. However, multiplexers
    and demultiplexers are incredibly common circuit design elements, so it’s important
    to understand how to implement them. Next, we’ll look at another common component:
    the shift register.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Shift Register</samp>
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *shift register* is a series of flip-flops where the output of one flip-flop
    is connected to the input of the next. We looked at a shift register back in [Chapter
    4](chapter4.xhtml) when we talked about a chain of flip-flops, but to keep things
    simple I didn’t introduce the term at the time. To review, [Figure 6-3](#fig6-3)
    shows a chain of four flip-flops, which we can now call a *4-bit shift register*.
    As discussed in [Chapter 4](chapter4.xhtml), each additional flip-flop in the
    chain adds a single clock cycle of delay to the output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*移位寄存器*是由一系列触发器组成，其中一个触发器的输出连接到下一个触发器的输入。在[第4章](chapter4.xhtml)中，我们讨论过触发器链，但为了简单起见，我当时没有介绍这个术语。回顾一下，[图6-3](#fig6-3)展示了一个四个触发器组成的链条，我们现在可以称之为*4位移位寄存器*。如[第4章](chapter4.xhtml)所讨论，链中的每一个附加触发器都会为输出增加一个时钟周期的延迟。
- en: '![](../images/Figure6-3.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-3: A shift register</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图6-3：移位寄存器</samp>
- en: Shift registers have many uses. For example, they can delay data for some fixed
    number of clock cycles, convert data from serial to parallel or from parallel
    to serial, or create a linear feedback shift register. We’ll look at examples
    of each of these applications in this section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 移位寄存器有很多用途。例如，它们可以延迟数据若干固定的时钟周期，或者将数据从串行转换为并行，或从并行转换为串行，甚至可以创建线性反馈移位寄存器。在本节中，我们将看到每种应用的示例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Delaying Data</samp>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">延迟数据</samp>
- en: Creating delay in an FPGA is the most common application of a shift register.
    The delay is often used to align data in time. For example, when you send input
    data through a math operation, it might take a few clock cycles to produce a result.
    If you need to align the output result with the original input data, then the
    original input data needs to be delayed by the number of clock cycles that the
    math operation will take to perform.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在FPGA中创建延迟是移位寄存器最常见的应用。延迟通常用于对齐数据的时间。例如，当你通过数学运算发送输入数据时，可能需要几个时钟周期才能产生结果。如果需要将输出结果与原始输入数据对齐，那么原始输入数据就需要延迟与数学运算所需时钟周期的数量相同的时间。
- en: 'As we’ve seen, a shift register is simply a chain of flip-flops, and the number
    of flip-flops in the chain dictates how many clock cycles it will take for the
    data on the input to propagate to the output. With that in mind, this code will
    create a shift register that generates a four-clock-cycle delay on some input
    data:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，移位寄存器仅仅是由一串触发器组成，链中触发器的数量决定了输入数据传播到输出所需的时钟周期数。考虑到这一点，下面的代码将创建一个移位寄存器，它在某些输入数据上生成四个时钟周期的延迟：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here we create a shift register called <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift</samp>,
    which will be four flip-flops in length ❶. Remember, the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_</samp>
    in the name is a clue that the signal will consist of flip-flops and be assigned
    within a clocked <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> block
    (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block
    (in VHDL). We load up the first flip-flop in the chain (position <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>)
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data_To_Delay</samp>, the
    input signal ❷. Then we use a trick to create the remaining three flip-flop assignments
    in a single line of code, rather than three: we take the values on flip-flops
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    and assign them to flip-flops <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> ❸. This way, the
    data that was on the first flip-flop in the chain is shifted to the second flip-flop,
    the data on the second flip-flop is shifted to the third, and so on. If you wanted,
    you could break this step down into its individual operations, like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift</samp>的移位寄存器，它的长度为四个触发器❶。请记住，名字中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_</samp>是一个提示，表示信号由触发器组成，并将在一个时钟驱动的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp>块（在Verilog中）或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块（在VHDL中）中赋值。我们将链中的第一个触发器（位置<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>）加载为输入信号<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data_To_Delay</samp>❷。然后，我们使用一个技巧，通过一行代码创建剩余三个触发器的赋值，而不是三行：我们将触发器<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>到<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>的值赋给触发器<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>到<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>❸。这样，链中第一个触发器中的数据被移到第二个触发器，第二个触发器中的数据被移到第三个，以此类推。如果你愿意，也可以将此步骤分解为单独的操作，如下所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example shows the Verilog version. For VHDL, replace the square brackets
    with parentheses.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示的是Verilog版本。对于VHDL，使用括号替换方括号。
- en: Writing out each assignment individually demonstrates more explicitly how the
    data moves through the shift register one bit at a time, but both methods will
    work the same way. Now we can use bit position <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift</samp> for our purposes,
    as this is the flip-flop that represents a four-clock-cycle delay of the input
    data <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data_To_Delay</samp>. If
    we needed a three-clock-cycle delay instead, we could use the data at bit position
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, or we could add more flip-flops
    to the chain to create a longer delay.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 分别写出每个赋值操作可以更明确地展示数据如何逐位通过移位寄存器移动，但这两种方法的效果是一样的。现在我们可以将<sup class="SANS_TheSansMonoCd_W5Regular_11">r_Shift</sup>的第<samp
    class="SANS_TheSansMonoCd_W5Regular_11">3</samp>位用于我们的目的，因为这是代表输入数据<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data_To_Delay</samp>延迟四个时钟周期的触发器。如果我们需要一个三时钟周期的延迟，可以使用第<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>位的数据，或者我们可以在链中添加更多的触发器来创建更长的延迟。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    Serial and Parallel Data</samp>
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">串行与并行数据之间的转换</samp>
- en: 'Converting from serial data to parallel data and vice versa is another common
    use of a shift register. You might need to do this when communicating with off-chip
    interfaces that transmit and receive data serially. One specific example is interfacing
    with a *universal asynchronous receiver-transmitter (UART)*. This is a device
    that transmits bytes of data by breaking them into individual bits, which are
    then reconstituted into bytes on the receiving end. When the data is sent, it
    is converted from parallel to serial: the eight parallel bits of data in a byte
    are sent serially, one after the other. When the data is received, it’s converted
    back from serial (individual bits) to parallel (a complete byte).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将串行数据转换为并行数据，反之亦然，是移位寄存器的另一个常见用途。当与外部芯片接口进行通信时，可能需要进行这种转换，尤其是当这些接口串行地发送和接收数据时。一个具体的例子是与*通用异步接收发送器（UART）*的接口。这是一种通过将字节数据拆分成单个比特来发送的设备，然后在接收端重新组装成字节。当数据发送时，它会从并行转换为串行：一个字节中的八个并行比特依次串行发送。当数据接收时，它会从串行（单个比特）转换回并行（一个完整的字节）。
- en: UARTs are widely used to send and receive data between devices because they’re
    simple and effective, and they’re a perfect application for a shift register.
    An eight-bit shift register can send a byte of data by reading it out, one flip-flop
    at a time, or it can receive a byte of data by shifting the bits through the chain
    of flip-flops, one bit after the other. For example, say we want to send and receive
    ASCII-encoded characters, each of which can be represented within a single byte
    of data. First, let’s look at the receiving end of the UART. Each line in [Table
    6-3](#tab6-3) represents the receipt of a single bit of data. The column on the
    right shows how the complete byte is built up by shifting the bits through a shift
    register.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-3:</samp> <samp class="SANS_Futura_Std_Book_11">Receiving
    a Byte of Data Through a UART</samp>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bit index</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Received
    bit</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte contents</samp> |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp> |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp> |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1011</samp> |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">01011</samp> |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">001011</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1001011</samp> |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">01001011</samp> |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '|  |  | <samp class="SANS_TheSansMonoCd_W5Regular_11">ASCII=0x4B=''K''</samp>
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: UARTs normally receive data starting with the least significant (rightmost)
    bit. The first bit received is shifted through the shift register from the most
    significant (leftmost) position to the least significant position as more bits
    come in. Let’s walk through how this works.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: On the first line of the table, we’ve received the first bit, which has a value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. We place it into the
    most significant bit position, the first flip-flop in the shift register. When
    we receive the second bit, which is also a <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    we shift the existing bit to the right, and put the new received bit in the most
    significant bit position. The third bit we receive is a <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    Once again, we place it into the most significant position, and the rest of the
    bits are shifted right. Once we’ve received all eight bits, the shift register
    is full, with the last bit placed into the most significant bit position and the
    first bit placed in the least significant position. At this point, the byte is
    complete. In our example, we’ve received <samp class="SANS_TheSansMonoCd_W5Regular_11">01001011</samp>,
    which is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x4B</samp>
    (meaning <samp class="SANS_TheSansMonoCd_W5Regular_11">4B</samp> in hexadecimal),
    the ASCII encoding for the letter K. By receiving the data one bit at a time and
    shifting the received bits to the right with a shift register, we converted serial
    data to parallel data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the transmit side of a UART. [Table 6-4](#tab6-4) shows how
    to transmit the byte <samp class="SANS_TheSansMonoCd_W5Regular_11">00110111</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">0x37</samp>, which is the digit
    7 in ASCII.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-4:</samp> <samp class="SANS_Futura_Std_Book_11">Transmitting
    a Byte of Data Through a UART</samp>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Bit index</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte
    contents</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Transmitted bit</samp>
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">ASCII=0x37=''7''</samp>
    |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00110111</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">0011011</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">001101</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">00110</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">0011</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">001</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">00</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: In this case, we start with the entire byte of data loaded in an 8-bit shift
    register. Again, a UART transmits from least significant bit to most significant
    bit, so here we send out the rightmost bit and shift the entire byte to the right
    with each step. By using a shift register to send out one bit at a time and shift
    the remaining bits to the right, we’re converting parallel data to serial data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Linear
    Feedback Shift Register</samp>
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last common application of the shift register is to create a *linear feedback
    shift register (LFSR)*. This is a shift register where certain flip-flops in the
    chain are tapped into and used as input for either an XOR or an XNOR gate (we’ll
    be using XNOR). The output of this gate is then fed back into the beginning of
    the shift register, hence the word *feedback* in the name. *Linear* comes from
    the fact that this arrangement produces an input bit that’s a linear function
    of the LFSR’s previous state. [Figure 6-4](#fig6-4) shows an example of a 3-bit
    LFSR, but keep in mind that LFSRs can have any number of bits.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-4.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-4: A 3-bit LFSR</samp>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: This LFSR features three chained flip-flops, representing bits 0 through 2 of
    a shift register. The outputs of the bit 1 flip-flop and the bit 2 flip-flop are
    passed through an XNOR gate, and the output of the gate is sent to the input of
    the first bit in the shift register. The value of the LFSR at any given clock
    cycle is the value of the three flip-flop outputs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '*The flip-flops in [Figure 6-4](#fig6-4) are drawn backward compared to how
    we’ve usually seen them, with input D on the right and output Q on the left. I
    drew them this way so the least significant bit (bit 0) would appear on the right,
    to match how we write numbers, but there’s nothing special here; these are the
    same flip-flops that we all know and love, just mirrored.*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: When an LFSR is running, the pattern generated by the individual flip-flops
    is *pseudorandom*, meaning it’s close to but not completely random. It’s only
    pseudorandom because from any state of the LFSR pattern, you can predict the next
    state. [Table 6-5](#tab6-5) shows what happens when the 3-bit LFSR is initialized
    to zero, then the clock starts toggling.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-5:</samp> <samp class="SANS_Futura_Std_Book_11">Pseudorandom
    Output of 3-Bit LFSR</samp>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Clock cycle</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">LFSR
    data (binary)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">LFSR data (decimal)</samp>
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>
    | <samp class="SANS_Futura_Std_Book_11">6</samp> |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>
    | <samp class="SANS_Futura_Std_Book_11">5</samp> |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>
    | <samp class="SANS_Futura_Std_Book_11">6</samp> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">…</samp> | <samp class="SANS_Futura_Std_Book_11">…</samp>
    | <samp class="SANS_Futura_Std_Book_11">…</samp> |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: The LFSR goes from <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> on the first clock
    cycle. This makes sense, because the XNOR of bit 2 (0) and bit 1 (0) is 1, which
    gets written into bit 0\. On the next clock cycle, the LFSR goes from <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>. Once again we’ve
    taken the XNOR of bit 2 (0) and bit 1 (0), giving us a new bit 0 value of 1\.
    Meanwhile, the old bit 0 value (1) has shifted to bit 1\. Following the rest of
    the values in the table, they seem relatively random—pseudorandom, even!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the table repeats itself on the seventh clock cycle, so there are
    seven unique values that the 3-bit LFSR can have: <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>.
    It can never have a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>.
    If you’re wondering why, consider what would happen if this value arose. At the
    next clock cycle, the new bit 0 would be the XNOR of 1 and 1, which is 1, while
    the other bits would shift over, giving us <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    again. The LFSR would be stuck on <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>
    forever, so it would effectively stop running! As a rule, for an LFSR that’s *N*
    bit positions long, the maximum number of clock cycles that the LFSR takes to
    run through all combinations is 2*^N* − 1\. For 3 bits, it’s 2³ − 1 = 7; for 4
    bits, it’s 2⁴ − 1 = 15; and so on.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Because of their pseudorandomness, LFSRs have many applications. They can function
    as low-utilization counters, test pattern generators, data scramblers, or be used
    in cryptography. The LFSR is lightweight, so these kinds of mathematical operations
    are carried out with few resources, which is desirable so you can save your precious
    FPGA flip-flops and LUTs for other tasks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how the LFSR in [Figure 6-4](#fig6-4) could be implemented in
    Verilog and VHDL:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First we declare a 3-bit-wide LFSR ❶. We perform the shift and incorporate the
    result of the XNOR operation through concatenation ❷. In Verilog we concatenate
    values by placing them in curly brackets, <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>,
    separated by commas, while in VHDL we use a single ampersand (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>).
    Together, the shifting and concatenation build up a single 3-bit-wide value, with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">w_XNOR</samp> in the least significant
    bit position. Finally, we assign the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_XNOR</samp>
    gate, based on the values of bits 2 and 1 in the register ❸. This is a continuous
    assignment, occurring outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, and it
    will be implemented by a LUT in the FPGA.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '*This example has shown a very simple 3-bit-wide LFSR, but an LFSR would normally
    have initialization and reset logic, which would help avoid and recover from any
    disallowed state. More thorough code, including reset logic and the ability to
    size the LFSR to any number of bits, is available in the book’s GitHub repository.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: LFSRs are a simple and efficient way to perform several useful tasks. They also
    highlight one of the strengths of an FPGA, namely being able to quickly perform
    math operations with few resources. Consider that you could have hundreds of LFSRs
    running in parallel on a single FPGA without issue, and you can start to see how
    FPGAs excel at fast math operations running in parallel.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #5: Selectively Blinking an
    LED</samp>'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve introduced some building blocks, let’s start putting them together.
    The requirement for this project is to blink each of four LEDs on your development
    board on and off, but only one LED should be blinking at a time. You’ll select
    which LED to blink using two switches. [Table 6-6](#tab6-6) shows how the LED
    selection is performed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-6:</samp> <samp class="SANS_Futura_Std_Book_11">LED
    Selection</samp>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Switch_2</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Switch_1</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">LED to blink</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Signal
    name</samp> |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">D1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">D2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_2</samp>
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">D3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_3</samp>
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">D4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_4</samp>
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: Looking at the table, we can see that when the two input switches are both 0
    (not pressed), the D1 LED will blink. By pushing just switch 1 down (setting it
    to 1), we select the D2 LED to blink. When we push down just switch 2, D3 should
    blink, and finally, when we push down both buttons, D4 should blink. This sounds
    like a job for a demultiplexer! We’ll have a single signal that toggles on and
    off, and we’ll want to route it to one of four LEDs. But how can we generate the
    toggling signal?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The clock on a development board is quite fast. On the Go Board (discussed
    in [Appendix A](appendix_A.xhtml)), for example, it’s 25 MHz. If we fed that directly
    to an LED, then the LED would blink at 25 MHz. To the human eye, it would look
    like the LED was just on, since that’s too fast for us to perceive. We need to
    generate a signal that toggles on its own, but at some much slower frequency than
    the clock: say, 2 to 4 Hz. That’s fast enough that you’ll be able to tell the
    LED is blinking quickly, but not too fast for the human eye to see. Remember,
    however, that FPGAs have no built-in concept of time, so we can’t blink an LED
    by writing code like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As discussed in [Chapter 5](chapter5.xhtml), an FPGA can determine how much
    time has passed by counting clock cycles. To wait for 0.20 seconds to pass, we
    would need to count one-fifth of the number of clock cycles that occur in a second.
    In the case of the Go Board, since there are 25,000,000 clock cycles per second
    (a 25 MHz clock), we would need to count to 25,000,000 / 5 = 5,000,000\. Once
    the count hits this limit, we could reset it to zero and toggle the state of the
    LED.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: But there’s another way! Recall that one of the possible uses for an LFSR is
    to create a low-resource counter. Start an LFSR with a certain pattern, such as
    all zeros, and it will take 2*^N* − 1 clock cycles for that pattern to recur,
    where *N* is the number of flip-flops that make up the LFSR. Create an LFSR with
    a high enough number of flip-flops in the shift register, and the rate at which
    it cycles through all its values will be slow enough to toggle the LED at a satisfying
    frequency. For example, a 22-bit LFSR will repeat its pattern every 2^(22) − 1
    = 4,194,303 clock cycles. With the Go Board’s 25 MHz clock, that comes out to
    a little less than 0.20 seconds.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '*If your board has a different clock frequency, you’ll need to experiment with
    the number of bits in the LFSR. For the 100 MHz clock on the Alchitry Cu, for
    example (see [Appendix A](appendix_A.xhtml)), try 24 bits: 2**^(24)* − *1* = *16,777,215
    cycles, or about 0.17 seconds.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Each time the LFSR returns to all zeros, it will toggle a signal, and we’ll
    use that signal to blink whichever LED is currently selected. All of this can
    be done using fewer FPGA resources than a traditional counter. [Figure 6-5](#fig6-5)
    shows a block diagram of how it will work.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-5.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-5: The Project #5
    block diagram</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'This project will instantiate two modules: the LFSR and the 1-4 demux. Between
    the two modules, we’ll have a flip-flop and a NOT gate (which will become a LUT).
    The input to the LFSR is the clock, and the output is a signal that goes high
    for one clock cycle when the LFSR has reached its limit and started at the beginning
    of its pattern again. We call this a *done pulse*. A *pulse* is a 1 (high) on
    a signal that lasts for one clock cycle, and this particular pulse signals when
    the LFSR is done with each cycle through its pattern loop.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: We can’t use the LFSR output directly to blink the LEDs, but we can use it to
    create a toggling signal. We do this by feeding the LFSR output signal into the
    enable input of a flip-flop. The flip-flop’s output will be the inversion (using
    a NOT gate) of its input. This way, each time the LFSR cycles through its pattern,
    the done pulse will enable the flip-flop for one clock cycle and trigger a change
    on the flip-flop’s output, either from a 0 to a 1 or from a 1 to a 0\. The net
    result is a signal with a 50 percent duty cycle and a frequency of about 3 Hz,
    perfect for toggling an LED at a rate the human eye can see. This toggling signal
    is the input to the demux module. The 1-4 demux selects which LED to pass the
    toggling signal to by reading the values on the two switches (SW1 and SW2). Only
    one LED will be blinking at a time, while the LEDs not selected by the switches
    will be off.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp>
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at the Verilog and VHDL for this project, starting with the top-level
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our project has three top-level inputs—the clock and two switches—as well as
    four outputs for the four LEDs. After declaring these, we instantiate the LFSR
    module ❶. We’ll look closely at the module next, but for now, notice its <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp> output ❸, which we
    wire to <samp class="SANS_TheSansMonoCd_W5Regular_11">w_LFSR_Done</samp>. This
    output will pulse with each repetition of the LFSR loop.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We don’t actually need the LFSR to output the current value on its register
    for this project, but this may be important in other contexts, so the LFSR module
    has an <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> output
    for this purpose. One handy trick when instantiating a module with unused outputs
    is to keep those outputs unconnected, which we do here with <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp>
    ❷. In Verilog, we simply leave the parentheses after the output name empty, while
    in VHDL we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> keyword.
    When this design is synthesized, the synthesis tool will prune any outputs that
    are unused, removing logic that doesn’t go anywhere. This way, you can reuse modules
    without having to worry about devoting precious FPGA resources to unused features.
    The synthesis tools are smart enough to optimize your design and remove signals
    where they aren’t needed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: In our top-level logic, we check if <samp class="SANS_TheSansMonoCd_W5Regular_11">w_LFSR_Done</samp>
    is high, meaning the LFSR has output its done pulse ❹. If so, we invert the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_LFSR_Toggle</samp> signal. This is the
    signal that gets sent to the 1-4 demux, which we instantiate next ❺. The selection
    is performed by the two input switches, and the outputs of the demux are directly
    connected to the four output LEDs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already seen the code for the 1-4 demux module, in “Implementing a Demultiplexer”
    on page 94. Let’s look at the LFSR module now:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This module is similar to the 3-bit LFSR that we looked at earlier in the chapter,
    but the LFSR register has been scaled up to be 22 bits wide ❶. (Modify the code
    if you need a different bit width based on your board’s clock speed.) The module
    also has extra logic to generate the done pulse, as well as to output the LFSR
    data, which may be useful in other contexts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We shift the LFSR register and concatenate the result with a new value for the
    rightmost bit ❷, just as we did in the 3-bit LFSR module. Then we XNOR the leftmost
    two bits in the register to get the new rightmost bit value ❸. We generate the
    done pulse on the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp>
    output when all of the flip-flops that make up the LFSR have zeros on their outputs
    ❹. Since this will be the case for exactly one clock cycle, this pulse will be
    one clock cycle wide. Otherwise, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp>
    will be low. Finally, we assign the contents of the LFSR register to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> output ❺. This way
    the module provides access to the LFSR data itself, but remember that in this
    case the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> output
    won’t be synthesized since we don’t need the data for this particular application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can build and program the FPGA. When the project starts running,
    you should see one of the LEDs blinking, but you can select a different LED to
    blink by pushing either or both of the two switches.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trying Another Way</samp>
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This project has shown how simple building blocks like LFSRs and demuxes can
    be combined to build larger projects, and it has illustrated an interesting application
    for an LFSR. In the real world, however, you probably wouldn’t use an LFSR to
    act as a counter like this, since it doesn’t provide much flexibility. Let’s say
    we want to change the count limit. With the LFSR implementation, we only have
    a few possible options to choose from, based on the number of bits in the LFSR.
    For blinking an LED, that was totally acceptable, as we didn’t care exactly how
    fast the LED was blinking—anywhere between 2 and 4 Hz would be fine. But if we
    needed to count to a very specific value—say, 4,000,000 instead of 4,194,303—we’d
    be hard pressed to do this with the LFSR. The next lowest option would be to use
    a 21-bit LFSR instead of a 22-bit LFSR, which would only allow us to count to
    2^(21) − 1 = 2,097,151\. For any value between 2,097,151 and 4,194,303, we’re
    out of luck.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: To provide more flexibility, I created another version of this project that
    uses a traditional counter. [Figure 6-6](#fig6-6) shows the block diagram of this
    alternate code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-6.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-6: The revised Project
    #5 block diagram</samp>'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’ve replaced the LFSR module with a module that simply counts up to
    some value and then toggles its output. This approach also allows us to eliminate
    the flip-flop and NOT gate between the project’s two modules. Let’s look at the
    code for the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code is much simpler to read and understand than the LFSR code. We declare
    a register that will act as a counter, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp>
    parameter/generic to define its size ❶. If the module is enabled, we check if
    the counter has reached its limit ❷. If so, we invert the output signal ❸ and
    reset the counter ❹. If the counter isn’t at its limit, then it simply increments
    by 1 ❺. With this code, we can set the counter to any arbitrary value and it will
    count to exactly that value.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '*In the VHDL code, we have an output signal o_Toggle on the right side of an
    assignment* ❸*, meaning we’re accessing the output’s value. This is valid in VHDL-2008
    and later but will throw an error on older versions of VHDL. I recommend using
    VHDL-2008 in your designs, because of improvements like this.*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the changes to the top-level code that are needed to use
    this new <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module instead of the LFSR:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I’ve snipped the parts that are the same. The LFSR has been removed and replaced
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module ❶. Since that module generates a toggling signal, we no longer need the
    flip-flop between the two modules. Instead, we can feed <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Counter_Toggle</samp>,
    the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module, directly into the demux ❷.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparing the Two
    Approaches</samp>
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you’ve seen, using a traditional counter is simpler and more flexible than
    using an LFSR. However, earlier I asserted that implementing an LFSR requires
    fewer resources than a traditional counter. Let’s compare the resource utilization
    reports for the two approaches to this project to see how significant the resource
    savings are. First, here’s the report for the LFSR version:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And here’s the report for the counter version:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The LFSR approach has used 1 fewer flip-flop and 23 fewer LUTs than the counter,
    so the LFSR does indeed require fewer resources. However, it helps to put that
    into perspective. Modern FPGAs have thousands of LUTs. You really shouldn’t have
    to count every single one. By going with the LFSR, we might save 1 percent (or
    less) of the total resources of our FPGA, but we lose readability and flexibility
    in the design. In general, I prefer to implement solutions that make sense and
    are simple, and in this case the LFSR isn’t the simplest solution.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In addition to showing you how to blink an LED and create a sophisticated project
    by combining various basic building blocks, this project has illustrated that
    there’s often a trade-off between simplicity and resources. You’ll find that there
    are typically several ways to solve problems within an FPGA, and you’ll have to
    determine which solution works best for you. It could be that the most resource-efficient
    solution isn’t the simplest, but on the other hand, the simplest solution may
    not require significantly more resources. In many cases, you might iterate on
    a design with different approaches, testing each one out. This is always a good
    exercise; you’ll become a stronger FPGA engineer when you explore multiple ways
    to write your code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Random Access Memory</samp>
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Random-access memory (RAM)* allows you to store data within your FPGA and
    read it back later. This is an incredibly common requirement in an FPGA design.
    For example, you might want to store data received from a camera, a computer,
    or a microcontroller and retrieve it later for processing, or you may need to
    create a storage space for data before saving it to a microSD card. These are
    just a few examples of use cases for a RAM. The *random-access* part of the name
    means that you can access the data in any order. On one clock cycle, for example,
    you could read out the first location of memory, and then on the very next clock
    cycle you could read out the last location of memory.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: A RAM is typically designed to be either *single-port* or *dual-port*. In a
    single-port RAM, there’s just one interface into the memory, so in a single clock
    cycle you can either read from or write to the memory, but not both. A dual-port
    RAM allows you to read from and write to the memory in the same clock cycle. The
    latter is more versatile and used more often, so we’ll focus on how to implement
    that on an FPGA. [Figure 6-7](#fig6-7) shows at a high level what we’ll be creating.
    Note that this is just one possible implementation; the exact signal names can
    vary.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-7.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-7: A dual-port RAM
    block diagram</samp>'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the figure, the memory itself is represented by the large rectangle.
    The size of the memory is defined by its width and depth. The depth determines
    the number of memory locations available, while the width determines how many
    bits can be stored at each location. For example, if the memory is 8 bits wide,
    then each location can store a byte of data. Multiplying the width by the depth
    tells you the total number of bits of memory available. For example, if we have
    an 8-bit-wide memory that’s 16 locations deep, then there’s a total of 8 × 16
    = 128 bits of memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The memory has two ports, one for writing (on the left) and one for reading
    (on the right). Each port has its own clock signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Clk</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Clk</samp>. For our purposes,
    we’ll tie both of these to the same clock, but note that it’s possible for each
    port to operate according to its own independent clock. We’ll discuss working
    with more than one clock, or *crossing clock domains*, in [Chapter 7](chapter7.xhtml).
    For now, just know that this module is built with that feature in mind.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Each port has an address signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Addr</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp>, which communicates
    the index into the memory where the writing or reading operation should take place.
    If you’ve programmed in C, this is like the index into an array. The indices typically
    range from 0 to (*depth* – 1), giving us a total of *depth* locations in the physical
    memory.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: For writing the data, we need to set the write address correctly, put the data
    that we want to write on <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Data</samp>,
    and pulse the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_DV</samp> for
    a single clock cycle. <samp class="SANS_TheSansMonoCd_W5Regular_11">DV</samp>
    here stands for *data valid*, which I commonly use to indicate that the data signal
    should be “looked at” by the module. If we want to keep writing to the memory,
    we can change the address and the data, and keep pulsing the data valid signal.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: For reading the data, we drive <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp>
    high, while setting the read address to the address we want to read from. The
    module that is performing the read can simply monitor the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_DV</samp>
    to see when it goes high; this indicates that there is valid data on <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp>,
    which is the data that is read from the memory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A RAM Implementation</samp>
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you understand at a high level how a RAM works, let’s examine the
    code implementing the memory:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We’ve implemented the memory as a module called <samp class="SANS_TheSansMonoCd_W5Regular_11">RAM_2Port</samp>.
    Notice that the module has two parameters (in Verilog) or generics (in VHDL):
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    ❶. This gives us the flexibility to create a RAM of any size we want, without
    having to modify the module code. If we need a memory that’s 4 bits wide and 16
    locations deep, this code can do that; if we need it to be 16 bits wide by 1,024
    deep, this code can do that too. We only need to choose different <samp class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> values when we
    instantiate the module.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the signal declarations to the module, we can see all the signals
    shown in [Figure 6-7](#fig6-7) that make up the write and read interfaces. The
    signals <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Addr</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp> will provide the indices
    of the write and read locations, respectively. These address signals are given
    a bit width large enough to represent any index to a memory containing <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>
    elements. For example, if you need to address into 128 memory locations (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">128</samp>), then you’re going to
    need 7 bits to accomplish that (2⁷ = 128), so the address signals will be 7 bits
    wide. In Verilog, this sizing of the address works with the <samp class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp>
    trick described in [Chapter 5](chapter5.xhtml). In VHDL we can leave the length
    of the vector undefined and set it in the higher-level module when this memory
    is instantiated. The instantiation itself must be of a fixed width, which will
    then specify the address signal width in this module. The last place we are using
    the parameters/generics to size our signals is for <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Data</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp>. These carry
    the actual data being written or read, respectively, and are sized based on <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp> to accommodate the full width
    of each location in memory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We instantiate the memory itself as <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Mem</samp>
    ❷. It will be <samp class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp> wide
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> long, for a total
    storage of <samp class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp> × <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> bits of memory. This instantiates
    a two-dimensional (2D) array in the code. In Verilog, we create it by setting
    a register of specific width, as we’ve done in the past, but with extra brackets
    on the end that specify the number of memory locations based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>.
    In VHDL, we need to create a custom data type called <samp class="SANS_TheSansMonoCd_W5Regular_11">t_Mem</samp>
    that defines the 2D array; then we can create the memory signal <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Mem</samp>,
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">t_Mem</samp>.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Next, we give the write and read operations their own <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks, triggered
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Clk</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Clk</samp> clock signals, respectively.
    (Again, unless you need to cross clock domains, you can simply tie these signals
    to the same clock in the higher-level code that instantiates this module.) For
    write operations, we first check to see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_DV</samp>
    signal is high ❸. If it is, we take the data that’s on <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Data</samp>
    and store it into memory at the location specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Addr</samp>
    ❹. This looks a lot like updating a value in an array, because that’s basically
    what we’re doing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: For read operations, the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp>
    output is updated with the value of the memory at the address given by <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp>
    ❺. At the same time, the value on <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp>
    is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_DV</samp> ❻. The
    higher-level module will set <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp>
    to high when it’s actually trying to read data, and passing this signal to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_DV</samp> generates a data valid
    pulse telling the higher-level module that the data is safe to read. Notice, however,
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp> doesn’t really
    control when data will be read within this module. In fact, the code to update
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp> ❺ will run on every
    single clock cycle, updating it with whatever is stored at the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp>
    memory location, whether we’re explicitly trying to read data out of the memory
    or not. That’s fine! It does no harm to read the memory on every clock cycle like
    this, even if we end up ignoring the data that’s being read out.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: To see the dual-port memory operating in a simulation, download the code from
    the repository and run the testbench for this module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RAM on an FPGA</samp>
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve written the code for a dual-port RAM, but what FPGA component makes up
    the memory itself? The answer is, *it depends*. If the memory is small enough—for
    example, 4 locations wide by 8 deep—the storage elements will be individual flip-flops.
    However, if the memory gets large enough, the synthesis tools will instead decide
    to use a block RAM (BRAM). We’ll discuss the block RAM in detail in [Chapter 9](chapter9.xhtml).
    For now, just know that it’s a large memory storage component that exists on the
    FPGA for this very purpose.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: You wouldn’t want to use flip-flops for large memories because you’re limited
    with how many flip-flops are available for memory storage. You want to save those
    precious flip-flops to do the main work in your FPGA, not just store a single
    bit of data in a large memory. The synthesis tools are smart; they know it’s best
    to push a large memory instantiation to one or more block RAMs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">FIFO: First In, First Out</samp>'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *first in, first out (FIFO)* is another common FPGA building block for
    storing and retrieving data. The concept of a FIFO is quite simple: data comes
    in one entry at a time and gets read out in order from oldest to newest. [Figure
    6-8](#fig6-8) shows a high-level representation of a FIFO.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-8.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-8: A high-level block
    diagram of a FIFO</samp>'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, a FIFO has a write interface pushing data in on the left side
    and a read interface pulling data out on the right side. Compared to the dual-port
    RAM diagram in [Figure 6-7](#fig6-7), notice that I’ve flipped the width and depth
    here. This helps to visualize the key FIFO behavior: the first data that gets
    put in is the first data that gets pulled out. In this sense, data moves through
    a FIFO like cars through a tunnel. The first car into the tunnel is also the first
    car out. Other programming languages often have some sort of queue structure,
    which behaves the same way. With a FIFO in an FPGA, however, you’re building a
    real queue out of real components!'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'FIFOs are used extensively in FPGA designs. Any time you need to buffer some
    data between a producer and a consumer, a FIFO acts as that buffer. For example,
    to write data to an off-chip memory storage element like a low-power double data
    rate (LPDDR) memory, you’d use many FIFOs to queue up the data, and then quickly
    burst it out of the FPGA into the LPDDR. Similarly, if you interface with a camera,
    you might store rows of pixel data into FIFOs for image manipulation like blurring
    or brightness enhancement. Finally, whenever you need to send data across clock
    domains, FIFOs are up to the task: one clock coordinates loading data into the
    FIFO, while the other clock coordinates reading it out.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'A FIFO is full when there are no more memory locations available for new write
    data. A FIFO is empty when it has nothing in it. This leads to two critical rules
    that you must follow to ensure your FIFO behaves as expected:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Never write to a full FIFO.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Never read from an empty FIFO.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing to a full FIFO is bad because it can cause data loss: you’ll end up
    overwriting data that was stored earlier. Reading from an empty FIFO is also bad,
    as you don’t know what data you’re going to get out of it. Breaking one of these
    two rules is one of the most common FPGA bugs that I’ve encountered in my career.
    It’s also one of the harder bugs to find, because writing to a full FIFO or reading
    from an empty FIFO can cause strange behavior, like unexpected data and data loss.
    Often this corrupted data looks like a problem with the data, rather than a problem
    with the FIFO, so what’s causing the bug is difficult to diagnose. Keep these
    rules in mind as we discuss the details of how a FIFO works.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Input and Output
    Signals</samp>
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A FIFO is basically a version of a dual-port RAM with some extra signals added
    to create the FIFO behavior. Before we look at the code for the FIFO, let’s consider
    what all those signals are. [Figure 6-9](#fig6-9) shows a more detailed block
    diagram of a FIFO.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-9.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-9: A detailed FIFO
    block diagram</samp>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Like the dual-port RAM, the FIFO has ports for writing and reading. Each port
    has its own dedicated clock. FIFOs are commonly used to cross clock domains, so
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Clk</samp> is different from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Clk</samp>. However, the FIFO
    that we’ll explore has a single clock for both the write and read ports, for simplicity
    and portability across FPGAs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Next, on the write side, the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_DV</samp>
    (data valid) input signals when there’s data to be written on <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Data</samp>
    and pushes that data into the FIFO. On the read side, the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_DV</samp> signals similarly
    communicate when we wish to read data, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp>
    output retrieves the data itself. All of this is just like what we saw on the
    RAM. Unlike on the RAM, however, we no longer need to worry about keeping track
    of which address to write to or read from. The FIFO knows to simply cycle through
    the memory addresses in sequence, one after the other, when reading or writing.
    As such, there’s no need for <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Addr</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp> input signals
    we had on the RAM. Instead, the remaining input and output signals help to track
    how much of the FIFO is used, while ensuring that we don’t write to a full FIFO
    or read from an empty FIFO.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: On the write side, the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp>
    output goes high when all the locations within the FIFO have been written to.
    When the user sees <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp>
    go high, they must stop writing to the FIFO until some space frees up and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp> goes low again. As you know
    by now, writing to a full FIFO is very bad and should be avoided.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp> signals, also on the
    write side, aren’t always included in FIFO modules, but they can be very helpful.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AF</samp> is short for *almost full*,
    and these signals allow the user to set a watermark in the FIFO before it fills
    up completely. If the number of elements (sometimes called *words*) in the FIFO
    is greater than or equal to the value set by <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp> will be high.
    Otherwise, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp> will
    be low. This feature is particularly useful in situations where data is written
    to the FIFO in batches. For example, say the write interface *must* write a minimum
    of four elements at a time in a burst, meaning once the interface starts writing
    it can’t stop, even if the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp>
    flag goes high mid-burst. To prevent data loss, we would want to set <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp>
    to *depth* − 4 and then check that <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp>
    is low before writing each burst of four elements. This ensures that there will
    be space in the FIFO for all four elements, before the write operation begins.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The read side has a similar set of FIFO-specific signals. <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Empty</samp>
    will be high when the FIFO has no data in it. To ensure that we never read from
    an empty FIFO, we should check the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Empty</samp>
    flag before attempting to read data out to know if there’s data available for
    reading.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp> signals behave similarly
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp>,
    guaranteeing that a burst of reads is possible without the FIFO becoming empty
    mid-burst (<samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> is short for
    *almost empty*). For example, say your FIFO is 1,024 bits deep and 1 byte wide,
    and you have an LPDDR interface that requires data to be written in 256-byte bursts.
    Again, since a burst can’t be interrupted, you can’t simply stop reading if the
    FIFO becomes empty partway through the read. To guarantee that at least 256 bytes
    will be available to be pulled from the FIFO before sending a burst of data to
    the LPDDR, set <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp>
    to 256, and check that <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp>
    is low before reading data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '*If you don’t need almost full or almost empty behaviors for your application,
    you can just ignore the i_AF_Level, o_AF_Flag, i_AE_Level, and o_AE_Flag signals
    in your design.*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-10](#fig6-10) shows some examples summarizing what we’ve learned
    about FIFO signals.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-10.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-10: FIFO flag examples</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The figure illustrates a FIFO with a depth of 12 words (the width isn’t important).
    For this example, let’s assume we’ve set <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp>
    to 4 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> to 8\.
    In the first row, we can see that if the FIFO has nothing in it, the count is
    zero and the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Empty</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp> signals are both
    set to 1\. Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp>
    is set when the count is less than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp>.
    Next, we see that there are four words written, the FIFO is no longer empty, but
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp> is still set. It’s
    not until the fifth word is written that <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp>
    goes low. All flags are low from words five through seven, but when there are
    eight words in the FIFO, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp>
    goes high (since <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp>
    was set to 8). When the FIFO is full, we see that both <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp> are high.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A FIFO Implementation</samp>
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll now consider the Verilog and VHDL for implementing the FIFO illustrated
    in [Figure 6-9](#fig6-9). This code adds features around the <samp class="SANS_TheSansMonoCd_W5Regular_11">RAM_2Port</samp>
    module discussed in “A RAM Implementation” on page 113 that convert the RAM into
    a FIFO. The complete code is available in the book’s GitHub repository, along
    with the testbenches that exercise it. I’m not showing the module signals or the
    instantiation of the memory (the dual-port RAM from the previous section) here,
    so we can focus on the functional code that makes the FIFO a FIFO:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The bulk of this code is the main <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block (in VHDL), which handles memory addressing, counting the number of elements
    in the FIFO, and read and write operations. Notice that this block has a reset
    signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rst_L</samp>, in the sensitivity
    list, in addition to a clock signal. If the reset signal goes low, then we’re
    in a reset state and we reset the signals that control the read address, the write
    address, and the FIFO count ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">_L</samp>
    at the end of the reset signal name is a clue that it’s active-low.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '*As I mentioned earlier, FIFOs are useful for crossing clock domains, but this
    particular implementation of a FIFO cannot do this. It only has one clock, the
    i_Clk signal. Crossing clock domains is an advanced feature that we aren’t prepared
    to implement at this stage in the book.*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the logic for the write address ❷ and read address ❸. For these,
    we simply increment the address each time we do a write or a read. When we reach
    the last address in the FIFO, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp>,
    we start over again at 0\. Thanks to this system, elements are written to memory
    sequentially and they’re read from memory in the same order they were written,
    ensuring adherence to the first-in, first-out scheme.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: To keep track of the number of elements in the FIFO, first we check for the
    condition where we’re doing a read but not a write ❹. In this case, the total
    number of elements in the FIFO goes down by 1\. Next we check if we’re doing a
    write but not a read ❺, in which case the total number of elements in the FIFO
    increases by 1\. It’s also possible that we could be writing *and* reading at
    the same time, but notice that the code doesn’t explicitly handle this case. That’s
    intentional; in this situation, the count will remain the same. We could make
    this explicit by writing <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count;</samp>,
    but this isn’t necessary. By default, the count variable retains its value.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: We also perform several signal assignments outside of the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block ❻. Recall
    that this will generate combinational (as opposed to sequential) logic. First
    we assign the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp> flag,
    which will be high when <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>, or when
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> is equal to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp> *and* there’s a write *and*
    there’s not a read. This second case lets the full flag “anticipate” the write
    and tell the higher-level module to stop writing, since the FIFO is about to be
    full.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Next we have the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Empty</samp>
    assignment, which is a bit simpler. When the count is zero, the FIFO is empty;
    otherwise, it’s not empty. After that we assign the almost full (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp>)
    and almost empty (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp>)
    flags. For these, we need to compare the count of the FIFO to the thresholds determined
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp>,
    respectively. This is the first time we’ve seen the <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> comparison operators
    being used in Verilog and VHDL. These are perfectly valid to include in combinational
    signal assignments.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: By monitoring these status flags from a higher-level module, you’ll be able
    to precisely control when data can move into and out of the FIFO.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about several common building blocks in FPGA designs,
    including multiplexers and demultiplexers, shift registers, RAM, and FIFOs. You
    saw how these components work and learned how to implement them with Verilog and
    VHDL. With these foundational pieces of code, you can start to see how very large
    FPGA designs can be composed of many smaller modules structured together.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
