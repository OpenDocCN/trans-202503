- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: CUSTOMIZING DISASSEMBLY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义反汇编
- en: So far, I’ve discussed basic binary analysis and disassembly techniques. But
    these basic techniques aren’t designed to handle obfuscated binaries that break
    standard disassembler assumptions or special-purpose analyses such as vulnerability
    scanning. Sometimes, even the scripting functionality offered by disassemblers
    isn’t enough to remedy this. In such cases, you can build your own specialized
    disassembly engine tailored to your needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经讨论了基本的二进制分析和反汇编技术。但是，这些基本技术并不是为了解决那些打破标准反汇编假设的混淆二进制文件，或者像漏洞扫描这样的特殊分析设计的。有时候，即使是反汇编工具提供的脚本功能也不足以解决这些问题。在这种情况下，你可以构建一个专门的反汇编引擎，量身定制，满足你的需求。
- en: In this chapter, you’ll learn how to implement a custom disassembler with *Capstone*,
    a disassembly framework that gives you full control over the entire analysis process.
    You’ll begin by exploring the Capstone API, using it to build a custom linear
    disassembler and a recursive disassembler. You’ll then learn to implement a more
    advanced tool, namely a *Return-Oriented Programming (ROP)* gadget scanner that
    you can use to build ROP exploits.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用*Capstone*实现一个自定义反汇编器，*Capstone*是一个反汇编框架，能够让你完全控制整个分析过程。你将首先探索Capstone
    API，使用它构建一个自定义的线性反汇编器和递归反汇编器。接着，你将学习如何实现一个更先进的工具，即*返回导向编程（ROP）*小工具扫描器，利用它构建ROP利用攻击。
- en: 8.1 Why Write a Custom Disassembly Pass?
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1 为什么要编写自定义反汇编模块？
- en: Most well-known disassemblers such as IDA Pro are designed to aid manual reverse
    engineering. These are powerful disassembly engines that offer an extensive graphical
    interface, a myriad of options to visualize the disassembled code, and convenient
    ways to navigate through large piles of assembly instructions. When your goal
    is just to understand what a binary does, a general-purpose disassembler works
    fine, but general-purpose tools lack the flexibility needed for advanced automated
    analysis. While many disassemblers come with scripting functionality for postprocessing
    the disassembled code, they don’t provide options for tweaking the disassembly
    process itself, and they aren’t meant for efficient batch processing of binaries.
    So when you want to perform a specialized, automated binary analysis of multiple
    binaries simultaneously, you’ll need a custom disassembler.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数著名的反汇编工具，如IDA Pro，旨在帮助手动逆向工程。这些是强大的反汇编引擎，提供了广泛的图形界面，丰富的选项来可视化反汇编的代码，以及方便的方式来浏览大量汇编指令。当你的目标仅仅是理解一个二进制文件的功能时，通用反汇编工具足够使用，但通用工具缺乏进行高级自动化分析所需的灵活性。虽然许多反汇编工具提供了用于后处理反汇编代码的脚本功能，但它们并不提供调整反汇编过程本身的选项，也不适用于高效批量处理二进制文件。因此，当你希望对多个二进制文件进行专门的自动化分析时，你将需要一个自定义反汇编器。
- en: '*8.1.1 A Case for Custom Disassembly: Obfuscated Code*'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.1.1 自定义反汇编的应用案例：混淆代码*'
- en: A custom disassembly pass is useful when you need to analyze binaries that break
    standard disassembler assumptions, such as malware, obfuscated or handcrafted
    binaries, or binaries extracted from memory dumps or firmware. Moreover, custom
    disassembly passes allow you to easily implement specialized binary analyses that
    scan for specific artifacts, such as code patterns that indicate possible vulnerabilities.
    They’re also useful as research tools, allowing you to experiment with novel disassembly
    techniques.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要分析那些打破标准反汇编假设的二进制文件时，比如恶意软件、混淆的或手工制作的二进制文件，或者从内存转储或固件中提取的二进制文件时，自定义反汇编模块就非常有用。此外，自定义反汇编模块还允许你轻松实现专门的二进制分析，如扫描特定的伪迹象，例如指示可能存在漏洞的代码模式。它们还可以作为研究工具，帮助你尝试新的反汇编技术。
- en: As a first concrete use case for custom disassembly, let’s consider a particular
    type of code obfuscation that uses *instruction overlapping*. Most disassemblers
    output a single disassembly listing per binary because the assumption is that
    each byte in a binary is mapped to at most one instruction, each instruction is
    contained in a single basic block, and each basic block is part of a single function.
    In other words, disassemblers typically assume that chunks of code don’t overlap
    with each other. Instruction overlapping breaks this assumption to confuse disassemblers,
    making the overlapping code more difficult to reverse engineer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为定制反汇编的第一个具体应用案例，我们来考虑一种特定类型的代码混淆，它使用 *指令重叠*。大多数反汇编工具会为每个二进制文件输出一份单一的反汇编列表，因为它们假设二进制文件中的每个字节至多对应一条指令，每条指令都包含在一个单独的基本块中，而每个基本块都是某个函数的一部分。换句话说，反汇编工具通常假设代码块之间不会互相重叠。指令重叠打破了这个假设，迷惑了反汇编工具，使得重叠的代码更难以进行逆向工程。
- en: Instruction overlapping works because instructions on the x86 platform vary
    in length. Unlike some other platforms, such as ARM, not all x86 instructions
    consist of the same number of bytes. As a result, the processor doesn’t enforce
    any particular instruction alignment in memory, making it possible for one instruction
    to occupy a set of code addresses already occupied by another instruction. This
    means that on x86, you can start disassembling from the middle of one instruction,
    and the disassembly will yield *another* instruction that partially (or completely)
    overlaps with the first instruction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 指令重叠之所以可行，是因为 x86 平台上的指令长度各不相同。与其他一些平台（如 ARM）不同，并非所有 x86 指令都由相同数量的字节组成。因此，处理器不会强制要求指令在内存中的特定对齐方式，这使得一条指令有可能占用已经被另一条指令占用的代码地址。这意味着，在
    x86 上，你可以从某条指令的中间开始反汇编，而反汇编的结果将会是与第一条指令部分（或完全）重叠的 *另一* 条指令。
- en: Obfuscators happily abuse overlapping instructions to confuse disassemblers.
    Instruction overlapping is especially easy on x86 because the x86 instruction
    set is extremely dense, meaning that nearly any byte sequence corresponds to some
    valid instruction.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆器乐于滥用指令重叠来迷惑反汇编工具。指令重叠在 x86 上尤其容易实现，因为 x86 指令集极为紧凑，这意味着几乎任何字节序列都对应着某条有效的指令。
- en: '[Listing 8-1](ch08.xhtml#ch08list1) shows an example of instruction overlapping.
    You can find the original source that produced this listing in *overlapping_bb.c*.
    To disassemble overlapping code, you can use `objdump`’s `-start-address=<addr>`
    flag to start disassembling at the given address.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-1](ch08.xhtml#ch08list1) 展示了一个指令重叠的示例。你可以在 *overlapping_bb.c* 中找到产生此列表的原始源代码。要反汇编重叠的代码，你可以使用
    `objdump` 的 `-start-address=<addr>` 标志，从给定地址开始反汇编。'
- en: '*Listing 8-1: Disassembly of* overlapping_bb *(1)*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-1：重叠_bb 的反汇编（1）*'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Listing 8-1](ch08.xhtml#ch08list1) shows a simple function that takes one
    input parameter, which is called `i` ➊, and has a local variable called `j` ➋.
    After some computation, the function returns `j`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-1](ch08.xhtml#ch08list1) 展示了一个简单的函数，它接受一个输入参数，称为 `i` ➊，并有一个局部变量 `j` ➋。经过一些计算后，函数返回
    `j`。'
- en: 'Upon closer inspection, you should notice something odd: the `jne` instruction
    at address `40060a` ➌ conditionally jumps into the *middle* of the instruction
    starting at `400610` instead of continuing at the *start* of any of the listed
    instructions! Most disassemblers like `objdump` and IDA Pro only disassemble the
    instructions shown in [Listing 8-1](ch08.xhtml#ch08list1). This means that general-purpose
    disassemblers would miss the overlapping instruction at address `400612` because
    those bytes are already occupied by the instruction reached in the fall-through
    case of the `jne`. This kind of overlapping makes it possible to hide code paths
    that can have a drastic effect on the overall outcome of a program. For example,
    consider the following case.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你应该会注意到一些奇怪的地方：地址 `40060a` ➌ 处的 `jne` 指令条件跳转到指令 `400610` 开始的 *中间* 部分，而不是继续执行任何列出指令的
    *开始*！大多数反汇编工具，如 `objdump` 和 IDA Pro，只会反汇编 [列表 8-1](ch08.xhtml#ch08list1) 中显示的指令。这意味着通用反汇编工具会错过地址
    `400612` 处的重叠指令，因为这些字节已经被 `jne` 指令的 fall-through 跳转所占用。这种指令重叠使得隐藏对程序整体结果有重大影响的代码路径成为可能。例如，考虑以下情况。
- en: In [Listing 8-1](ch08.xhtml#ch08list1), if the jump at address `40060a` is not
    taken (`i == 0`), the instructions reached by the fall-through case compute and
    return the value `148` ➍. However, if the jump *is* taken (`i != 0`), the code
    path that was hidden in [Listing 8-1](ch08.xhtml#ch08list1) executes. Let’s look
    at [Listing 8-2](ch08.xhtml#ch08list2), which shows that hidden code path, to
    see how this returns an entirely different value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 8-1](ch08.xhtml#ch08list1) 中，如果地址 `40060a` 处的跳转没有被执行（`i == 0`），穿透情况到达的指令会计算并返回值
    `148` ➍。然而，如果跳转*被*执行（`i != 0`），那么在 [清单 8-1](ch08.xhtml#ch08list1) 中隐藏的代码路径会被执行。我们来看看
    [清单 8-2](ch08.xhtml#ch08list2)，它展示了这个隐藏的代码路径，看看它是如何返回完全不同的值的。
- en: '*Listing 8-2: Disassembly of* overlapping_bb *(2)*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-2：重叠基本块的反汇编（2）*'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Listing 8-2](ch08.xhtml#ch08list2) shows the code path that executes if the
    `jne` instruction ➊ is taken. In that case, it jumps over two bytes (`400610`
    and `400611`) to address `0x400612` ➋, which is in the middle of the `xor` instruction
    reached in the fall-through case of the `jne`. This results in a different instruction
    stream. In particular, the arithmetic operations done on `j` are now different,
    causing the function to return `i + 4` ➌ instead of `148`. As you can imagine,
    this sort of obfuscation makes the code hard to understand, especially if the
    obfuscation is applied in more than one place.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-2](ch08.xhtml#ch08list2) 显示了如果执行 `jne` 指令 ➊ 的代码路径。在这种情况下，它跳过两个字节（`400610`
    和 `400611`），跳转到地址 `0x400612` ➋，这是 `xor` 指令的中间部分，这个指令出现在 `jne` 的穿透情况中。这会导致不同的指令流。特别是，`j`
    上进行的算术运算现在不同，导致函数返回 `i + 4` ➌ 而不是 `148`。正如你能想象的那样，这种混淆使得代码难以理解，特别是当这种混淆在多个地方应用时。'
- en: You can usually coax disassemblers into revealing hidden instructions by restarting
    disassembly at a different offset, as I’ve done with `objdump`’s `-start-address`
    flag in the previous listings. As you can see in [Listing 8-2](ch08.xhtml#ch08list2),
    restarting the disassembly at address `400612` reveals the instruction hidden
    there. However, doing that causes the instruction at address `400610` to become
    hidden instead. Some obfuscated programs are riddled with overlapping code sequences
    like the one shown in this example, making the code extremely tedious and difficult
    to investigate manually.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过在不同的偏移量重新启动反汇编来诱使反汇编器揭示隐藏的指令，就像我在前面的清单中使用 `objdump` 的 `-start-address`
    标志所做的那样。如 [清单 8-2](ch08.xhtml#ch08list2) 所示，在地址 `400612` 重新启动反汇编可以揭示隐藏在那里的指令。然而，这样做会导致地址
    `400610` 处的指令变得隐藏。某些混淆程序充斥着像这个例子中展示的重叠代码序列，使得代码非常繁琐，且手动调查时十分困难。
- en: The example of [Listings 8-1](ch08.xhtml#ch08list1) and [8-2](ch08.xhtml#ch08list2)
    shows that building a specialized deobfuscation tool that automatically “untangles”
    overlapping instructions can make reverse engineering much easier. Especially
    if you need to reverse obfuscated binaries often, the effort to build a deobfuscation
    tool pays off in the long run.^([1](footnote.xhtml#ch08fn_1)) Later in this chapter,
    you’ll learn how to build a recursive disassembler that can deal with overlapping
    basic blocks like the ones shown in the previous listings.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.xhtml#ch08list1) 和 [8-2](ch08.xhtml#ch08list2) 的示例表明，构建一个专门的去混淆工具，可以自动“解开”重叠指令，这可以大大简化逆向工程。特别是如果你经常需要逆向混淆的二进制文件，那么构建去混淆工具的努力在长远来看是值得的。^([1](footnote.xhtml#ch08fn_1))
    本章后续内容中，你将学习如何构建一个递归反汇编器，它能够处理像前面清单所示的重叠基本块。'
- en: Overlapping Code in Nonobfuscated Binaries
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 非混淆二进制文件中的重叠代码
- en: It’s interesting to note that overlapping instructions occur not only in deliberately
    obfuscated code but also in highly optimized code that contains handwritten assembly.
    Admittedly, the second case is both easier to deal with and a lot less common.
    The following listing shows an overlapping instruction from `glibc` 2.22.^(*a*)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，重叠指令不仅发生在故意混淆的代码中，还出现在包含手写汇编的高度优化代码中。诚然，第二种情况更容易处理，而且出现的频率也要低得多。以下清单展示了来自
    `glibc` 2.22 的重叠指令。^(*a*)
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Depending on the result of the `cmp` instruction, the `je` either jumps to address
    `7b066` or falls through to address `7b065`. The only difference is that the latter
    address corresponds to a `lock cmpxchg` instruction, while the former corresponds
    to a `cmpxchg`. In other words, the conditional jump is used to choose between
    a locked and nonlocked variant of the same instruction by optionally jumping over
    a `lock` prefix byte.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `cmp` 指令的结果，`je` 指令要么跳转到地址 `7b066`，要么继续执行到地址 `7b065`。唯一的区别是，后者地址对应一个 `lock
    cmpxchg` 指令，而前者对应一个 `cmpxchg`。换句话说，条件跳转用于在同一指令的锁定和非锁定变种之间进行选择，通过选择性跳过一个 `lock`
    前缀字节。
- en: '*a*. `glibc` is the GNU C library. It’s used in virtually all C programs compiled
    on GNU/Linux platforms and is therefore heavily optimized.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*. `glibc` 是 GNU C 库。它几乎在所有在 GNU/Linux 平台上编译的 C 程序中都会使用，因此经过了大量的优化。'
- en: '*8.1.2 Other Reasons to Write a Custom Disassembler*'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.1.2 编写自定义反汇编器的其他原因*'
- en: Obfuscated code isn’t the only reason to build a custom disassembly pass. In
    general, customization is useful in any situation where you need full control
    over the disassembly process. As I mentioned earlier, those situations occur when
    you’re analyzing obfuscated or otherwise special binaries or when you need to
    perform specialized analyses that general-purpose disassemblers aren’t designed
    for.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆代码并不是构建自定义反汇编流程的唯一原因。一般来说，定制化在你需要完全控制反汇编过程的任何情况下都非常有用。正如我之前提到的，那些情况通常出现在你分析混淆的或其他特殊的二进制文件时，或者当你需要进行通用反汇编工具不支持的专业分析时。
- en: Later in this chapter, you’ll see an example that uses custom disassembly to
    build a ROP gadget scanner, which requires disassembling the binary from multiple
    starting offsets, an operation not readily supported by most disassemblers. ROP
    gadget scanning involves finding every possible code sequence in a binary, including
    unaligned ones, that could be used in a ROP exploit.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，你将看到一个示例，展示如何使用自定义反汇编来构建 ROP gadget 扫描器，这需要从多个起始偏移量反汇编二进制文件，而大多数反汇编器并不直接支持这种操作。ROP
    gadget 扫描涉及在二进制文件中查找每一个可能的代码序列，包括未对齐的代码序列，这些序列可以在 ROP 利用中使用。
- en: Conversely, sometimes you’ll want to omit some code paths from the disassembly
    rather than find every possible code sequence. For instance, this is useful when
    you want to ignore bogus paths created by an obfuscator^([2](footnote.xhtml#ch08fn_2))
    or build a hybrid static-dynamic analysis and focus your disassembly on specific
    paths that you’ve already explored dynamically.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，有时你可能会想从反汇编中省略某些代码路径，而不是查找每一个可能的代码序列。例如，这在你希望忽略混淆器创建的虚假路径^([2](footnote.xhtml#ch08fn_2))，或者构建一个混合静态-动态分析并将反汇编集中在你已经动态探索过的特定路径时非常有用。
- en: There are also cases when building a custom disassembly tool may not be needed
    strictly for technical reasons, but you may choose to do so anyway for the sake
    of improving efficiency or reducing cost. For instance, automated binary analysis
    tools often require only very basic disassembly functionality. The toughest part
    of their job is the custom analysis of the disassembled instructions, and this
    step doesn’t require the extensive user interfaces or conveniences that automated
    disassemblers have. In such cases, you can choose to build your own custom tools
    using only free open source disassembly libraries, rather than depend on large,
    commercial disassemblers that can cost up to thousands of dollars.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些情况，构建自定义反汇编工具可能并非出于技术上的必要，而是为了提高效率或降低成本。例如，自动化二进制分析工具通常只需要非常基础的反汇编功能。它们最艰难的部分是自定义分析反汇编后的指令，而这一步并不需要像自动反汇编器那样提供复杂的用户界面或便利功能。在这种情况下，你可以选择使用免费的开源反汇编库来构建自己的自定义工具，而不是依赖那些可能昂贵的商业反汇编器，后者的费用可能高达数千美元。
- en: 'Another reason for building a custom disassembler is efficiency. Scripting
    in standard disassemblers typically requires at least two passes over the code:
    one for the initial disassembly and another for the postprocessing done by the
    script. Also, those scripts are typically written in a high-level language (such
    as Python), which yields relatively poor runtime performance. This means that
    when doing complex analysis on many large binaries, you can often greatly improve
    performance by building a tool that can run natively and do all necessary analysis
    in one pass.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自定义反汇编器的另一个原因是效率。标准反汇编器中的脚本通常需要对代码进行至少两次遍历：一次用于初始的反汇编，另一次用于脚本进行的后处理。此外，这些脚本通常是用高级语言（如Python）编写的，这导致了相对较差的运行时性能。这意味着，在对许多大型二进制文件进行复杂分析时，构建一个能够原生运行并在一次遍历中完成所有必要分析的工具，往往能大大提高性能。
- en: Now that you’ve seen why custom disassembly is useful, let’s take a look at
    how to do it! I’ll start with a brief introduction to *Capstone*, one of the most
    popular libraries for building custom disassembly tools.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了自定义反汇编的有用性，让我们看看如何进行！我将从简要介绍*Capstone*开始，它是构建自定义反汇编工具最流行的库之一。
- en: 8.2 Introduction to Capstone
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2 Capstone简介
- en: Capstone is a disassembly framework designed to provide a simple, lightweight
    API that transparently handles most popular instruction architectures, including
    x86/x86-64, ARM, and MIPS, among others. It has bindings for C/C++ and Python
    (plus other languages, but we’ll use C/C++ as usual) and runs on all popular platforms,
    including Windows, Linux, and macOS. It’s also completely free and open source.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Capstone 是一个反汇编框架，旨在提供一个简单、轻量级的API，能够透明地处理大多数流行的指令架构，包括x86/x86-64、ARM、MIPS等。它为C/C++和Python（以及其他语言，虽然我们将像往常一样使用C/C++）提供了绑定，并支持所有流行平台，包括Windows、Linux和macOS。它也是完全免费的，且开源。
- en: Building disassembly tools with Capstone is a straightforward process, with
    extremely versatile possibilities. Although the API is centered around just a
    few functions and data structures, it doesn’t sacrifice usability for simplicity.
    With Capstone, you can easily recover virtually all relevant details of disassembled
    instructions, including instruction opcodes, mnemonics, class, registers read
    and written by the instruction, and more. The best way to learn Capstone is through
    example, so let’s dive right in.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Capstone构建反汇编工具是一个直接的过程，具有极其多样的可能性。尽管API主要围绕几个函数和数据结构构建，但它并没有为了简洁而牺牲可用性。使用Capstone，你可以轻松地恢复反汇编指令的几乎所有相关细节，包括指令操作码、助记符、类别、指令读取和写入的寄存器等。学习Capstone的最好方式是通过实例，因此让我们直接开始。
- en: '*8.2.1 Installing Capstone*'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.2.1 安装Capstone*'
- en: Capstone v3.0.5 is preinstalled on the virtual machine supplied with this book.
    If you want to try Capstone on another machine, installing it is quite straightforward.
    The Capstone website^([3](footnote.xhtml#ch08fn_3)) provides ready-made packages
    for Windows and Ubuntu, among others, and there is a source archive for installing
    Capstone on other platforms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Capstone v3.0.5 已预安装在本书随附的虚拟机中。如果你想在其他机器上尝试 Capstone，安装过程相当简单。Capstone 网站^([3](footnote.xhtml#ch08fn_3))提供了适用于Windows和Ubuntu等操作系统的现成软件包，并且提供了一个源代码档案，供在其他平台上安装Capstone。
- en: 'As usual, we’ll write our Capstone-based tools in C/C++, but for quick experiments,
    you may also want to explore Capstone using Python. For this, you’ll need the
    Capstone Python bindings. These are also preinstalled on the virtual machine,
    but installing them on your own machine is easy if you have the `pip` Python package
    manager. Make sure you already have the Capstone core package and then enter the
    following into your command prompt to install the Capstone Python bindings:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将使用C/C++编写基于Capstone的工具，但对于快速实验，你也可以使用Python来探索Capstone。为此，你需要Capstone的Python绑定。这些绑定也已预安装在虚拟机中，但如果你有`pip`
    Python包管理器，在你自己的机器上安装它们也非常简单。确保你已经安装了Capstone核心包，然后在命令提示符中输入以下内容来安装Capstone Python绑定：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once you have the Python bindings, you can start a Python interpreter and begin
    your own disassembly experiments in Python, as shown in [Listing 8-3](ch08.xhtml#ch08list3).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了Python绑定，你就可以启动Python解释器并开始自己的反汇编实验，如[Listing 8-3](ch08.xhtml#ch08list3)所示。
- en: '*Listing 8-3: Exploring the Python Capstone bindings*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-3: 探索Python Capstone绑定*'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example imports the `capstone` package and uses Python’s built-in `help`
    command to explore Capstone ➊. The class that provides the main functionality
    is `capstone.Cs` ➋. Most important, it provides access to Capstone’s `disasm`
    function, which disassembles a code buffer and returns the disassembly result
    to you. To explore the remaining functionality offered by Capstone’s Python bindings,
    use Python’s built-in `help` and `dir` commands! In the rest of this chapter,
    I’ll focus on building Capstone tools with C/C++, but the API closely resembles
    Capstone’s Python API.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例导入了`capstone`包，并使用Python内置的`help`命令来探索Capstone ➊。提供主要功能的类是`capstone.Cs`
    ➋。最重要的是，它提供了访问Capstone的`disasm`函数的功能，该函数将代码缓冲区反汇编并返回反汇编结果。要探索Capstone的Python绑定提供的其他功能，可以使用Python内置的`help`和`dir`命令！在本章的其余部分，我将重点介绍使用C/C++构建Capstone工具，但该API与Capstone的Python
    API非常相似。
- en: '*8.2.2 Linear Disassembly with Capstone*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.2.2 使用Capstone进行线性反汇编*'
- en: From a high-level perspective, Capstone takes a memory buffer containing a block
    of code bytes as an input and outputs instructions disassembled from those bytes.
    The most basic way to use Capstone is to feed it a buffer containing all the code
    bytes in the `.text` section of a given binary and then linearly disassemble those
    instructions into a human-readable form, or instruction mnemonics. Aside from
    some initialization and output-parsing code, Capstone allows you to implement
    this mode of usage using only a single API call to the `cs_disasm` function. The
    example in [Listing 8-4](ch08.xhtml#ch08list4) implements a simple `objdump`-like
    tool. To load a binary into a block of bytes that Capstone can use, we’ll reuse
    the `libbfd`-based binary loader (*loader.h*) implemented in [Chapter 4](ch04.xhtml#ch04).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，Capstone将包含一段代码字节的内存缓冲区作为输入，并输出从这些字节中反汇编的指令。使用Capstone的最基本方法是将包含给定二进制`.text`部分的所有代码字节的缓冲区传递给它，然后将这些指令线性地反汇编成可读的形式，或者指令助记符。除了初始化和输出解析代码外，Capstone只需通过调用`cs_disasm`函数即可实现此用法模式。[示例
    8-4](ch08.xhtml#ch08list4)中的示例实现了一个类似`objdump`的简单工具。为了将二进制文件加载到Capstone可以使用的字节块中，我们将重用[第4章](ch04.xhtml#ch04)中实现的基于`libbfd`的二进制加载器（*loader.h*）。
- en: '*Listing 8-4:* basic_capstone_linear.cc'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-4:* basic_capstone_linear.cc'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That’s all you need to implement a simple linear disassembler! Note the line
    at the top of the source that says `#include <capstone/capstone.h>`. To use Capstone
    in a C program, it’s enough to include this header file and link the program with
    the Capstone library using the `-lcapstone` linker flag. All other Capstone header
    files are `#include`’d from *capstone.h*, so you never need to `#include` them
    manually. With that covered, let’s walk through the rest of the source in [Listing
    8-4](ch08.xhtml#ch08list4).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实现一个简单线性反汇编器所需的全部！注意源代码顶部的一行：`#include <capstone/capstone.h>`。要在C程序中使用Capstone，只需包含这个头文件，并使用`-lcapstone`链接器标志将程序与Capstone库链接。所有其他Capstone头文件都从*capstone.h*中`#include`，因此你不需要手动`#include`它们。覆盖了这些内容后，我们一起浏览[示例
    8-4](ch08.xhtml#ch08list4)中的剩余源代码。
- en: Initializing Capstone
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化Capstone
- en: 'Let’s start with the `main` function, which expects a single command line argument:
    the name of a binary to disassemble. The `main` function passes the name of this
    binary to the `load_binary` function (implemented in [Chapter 4](ch04.xhtml#ch04)),
    which loads the binary into a `Binary` object called `bin` ➊. Then `main` passes
    `bin` to the `disasm` function ➋, waits for it to complete, and finally cleans
    up by unloading the binary. As you may have guessed, all the actual disassembly
    work is done in the `disasm` function.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`main`函数开始，它期望一个命令行参数：要反汇编的二进制文件的名称。`main`函数将此二进制文件的名称传递给`load_binary`函数（在[第4章](ch04.xhtml#ch04)中实现），该函数将二进制文件加载到一个名为`bin`的`Binary`对象中
    ➊。然后，`main`将`bin`传递给`disasm`函数 ➋，等待它完成，最后通过卸载二进制文件来进行清理。正如你可能猜到的，所有实际的反汇编工作都在`disasm`函数中完成。
- en: To disassemble the `.text` section of the given binary, `disasm` begins by calling
    `bin->get_text_section()` to get a pointer to a `Section` object representing
    the `.text` section. So far, this should be familiar from [Chapter 4](ch04.xhtml#ch04).
    Now let’s get to some actual Capstone code!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反汇编给定二进制文件的`.text`部分，`disasm`首先通过调用`bin->get_text_section()`来获取指向表示`.text`部分的`Section`对象的指针。到目前为止，这部分应该在[第4章](ch04.xhtml#ch04)中已经很熟悉了。现在让我们来看看一些实际的Capstone代码！
- en: The first Capstone function called by `disasm` is typical in any program that
    uses Capstone. It’s called `cs_open`, and its purpose is to open a properly configured
    Capstone instance ➌. In this case, a properly configured instance is one that’s
    set up to disassemble `x86-64` code. The first parameter you pass to `cs_open`
    is a constant called `CS_ARCH_X86`, informing Capstone that you want to disassemble
    code for the x86 architecture. More specifically, you tell Capstone that the code
    will be 64-bit by passing `CS_MODE_64` as the second parameter. Finally, the third
    parameter is a pointer to an object of type `csh` (short for “Capstone handle”).
    This pointer is called `dis`. After `cs_open` completes successfully, this handle
    represents a fully configured Capstone instance, which you’ll need to invoke any
    of the other Capstone API functions. If the initialization is successful, `cs_open`
    returns `CS_ERR_OK`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`disasm` 调用的第一个 Capstone 函数是任何使用 Capstone 的程序中的典型函数。它叫做 `cs_open`，其目的是打开一个正确配置的
    Capstone 实例 ➌。在本例中，一个正确配置的实例是指设置为反汇编 `x86-64` 代码的实例。你传递给 `cs_open` 的第一个参数是一个常量
    `CS_ARCH_X86`，告诉 Capstone 你想要反汇编 x86 架构的代码。更具体地说，你通过传递 `CS_MODE_64` 作为第二个参数，告诉
    Capstone 代码将是 64 位的。最后，第三个参数是一个指向类型为 `csh`（即“Capstone 句柄”）的对象的指针。这个指针被称为 `dis`。在
    `cs_open` 成功完成后，这个句柄表示一个完全配置好的 Capstone 实例，你将需要它来调用任何其他 Capstone API 函数。如果初始化成功，`cs_open`
    返回 `CS_ERR_OK`。'
- en: Disassembling a Code Buffer
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反汇编代码缓冲区
- en: Now that you have a Capstone handle and a loaded code section at your disposal,
    you can start disassembling! This takes only a single call to the `cs_disasm`
    function ➍.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了一个 Capstone 句柄和加载的代码段，可以开始反汇编了！这只需要调用一次 `cs_disasm` 函数 ➍。
- en: The first parameter to this call is `dis`, which is your Capstone handle. Next,
    `cs_disasm` expects a buffer (specifically, a `const uint8_t*`) containing the
    code to disassemble, a `size_t` integer indicating the number of code bytes in
    the buffer, and a `uint64_t` indicating the virtual memory address (VMA) of the
    first byte in the buffer. The code buffer and related values are all conveniently
    preloaded in the `Section` object representing the `.text` section of the loaded
    binary.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该调用的第一个参数是 `dis`，也就是你的 Capstone 句柄。接下来，`cs_disasm` 期望一个缓冲区（具体来说是 `const uint8_t*`）来存放待反汇编的代码，一个
    `size_t` 整数表示缓冲区中代码字节的数量，以及一个 `uint64_t` 表示缓冲区中第一个字节的虚拟内存地址（VMA）。代码缓冲区及相关值都方便地预加载在代表加载的二进制文件
    `.text` 部分的 `Section` 对象中。
- en: The final two parameters to `cs_disasm` are a `size_t`, which indicates the
    number of instructions to disassemble (here it’s 0 to disassemble as many as possible)
    and a pointer to a Capstone instruction buffer (`cs_insn**`). This final parameter
    deserves special attention because the `cs_insn` type plays a central role in
    Capstone-based applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs_disasm` 的最后两个参数是一个 `size_t`，用于指示要反汇编的指令数（这里是 0，表示尽可能多地反汇编）以及一个指向 Capstone
    指令缓冲区（`cs_insn**`）的指针。这个最后的参数需要特别注意，因为 `cs_insn` 类型在基于 Capstone 的应用程序中扮演着核心角色。'
- en: The cs_insn Structure
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cs_insn` 结构体'
- en: As you can see in the example code, the `disasm` function contains a local variable
    of type `cs_insn*`, called `insns`. The address of `insns` is used as the final
    parameter for the call to `cs_disasm` at ➍. While disassembling a code buffer,
    `cs_disasm` builds up an array of disassembled instructions. At the end of the
    disassembly process, it returns this array in `insns`, so that you can traverse
    all the disassembled instructions and handle them in some application-specific
    way. The example code just prints the instructions. Each instruction is of a `struct`
    type called `cs_insn`, which is defined in *capstone.h*, as shown in [Listing
    8-5](ch08.xhtml#ch08list5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在示例代码中所看到的，`disasm` 函数包含一个类型为 `cs_insn*` 的局部变量，名为 `insns`。`insns` 的地址作为调用
    `cs_disasm` 的最后一个参数，见 ➍。在反汇编代码缓冲区时，`cs_disasm` 会构建一个反汇编指令的数组。在反汇编过程结束时，它会将这个数组返回到
    `insns` 中，这样你就可以遍历所有的反汇编指令，并以某种特定于应用的方式处理它们。示例代码只是打印了这些指令。每条指令都是一个 `struct` 类型，名为
    `cs_insn`，该类型在 *capstone.h* 中定义，如 [列表 8-5](ch08.xhtml#ch08list5) 所示。
- en: '*Listing 8-5: Definition of* struct cs_insn *from* capstone.h'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：* `struct cs_insn` *在* capstone.h *中的定义*'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `id` field is a unique (architecture-specific) identifier for the instruction
    type, allowing you to check what kind of instruction you’re dealing with without
    resorting to string comparisons with the instruction mnemonic. For instance, you
    could implement instruction-specific handling for disassembled instructions, as
    shown in [Listing 8-6](ch08.xhtml#ch08list6).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 字段是一个唯一的（架构特定的）指令类型标识符，可以让你在不进行字符串比较的情况下检查你正在处理的指令类型。例如，你可以实现针对反汇编指令的指令特定处理，正如
    [Listing 8-6](ch08.xhtml#ch08list6) 中所示。'
- en: '*Listing 8-6: Instruction-specific handling with Capstone*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-6: 使用 Capstone 进行指令特定处理*'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, `insn` is a pointer to a `cs_insn` object. Note that `id` values
    are only unique within a particular architecture, not across architectures. The
    possible values are defined in an architecture-specific header file, which you’ll
    see in [Section 8.2.3](ch08.xhtml#ch08_2_3).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`insn` 是指向 `cs_insn` 对象的指针。请注意，`id` 值在特定架构内是唯一的，而不是跨架构唯一的。可能的值在架构特定的头文件中定义，你将在
    [Section 8.2.3](ch08.xhtml#ch08_2_3) 中看到。
- en: The `address`, `size`, and `bytes` fields in `cs_insn` contain the address,
    number of bytes, and bytes of the instruction. The `mnemonic` is a human-readable
    string representing the instruction (without the operands), while `op_str` is
    a human-readable representation of the operands of the instruction. Finally, `detail`
    is a pointer to a (mostly architecture-specific) data structure containing more
    detailed information about the disassembled instruction, such as which registers
    it reads and writes. Note that the `detail` pointer is set only if you explicitly
    enable Capstone’s detailed disassembly mode before starting the disassembly, which
    is not done in this example. You’ll see an example of disassembly using detailed
    disassembly mode in [Section 8.2.4](ch08.xhtml#ch08_2_4).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs_insn` 中的 `address`、`size` 和 `bytes` 字段包含指令的地址、字节数和字节内容。`mnemonic` 是一个表示指令的可读字符串（不包含操作数），而
    `op_str` 是指令操作数的可读表示。最后，`detail` 是指向一个（主要是架构特定的）数据结构的指针，包含有关反汇编指令的更详细信息，例如它读取和写入哪些寄存器。请注意，只有在你明确启用
    Capstone 的详细反汇编模式后，`detail` 指针才会被设置，而本示例中并未启用该模式。在 [Section 8.2.4](ch08.xhtml#ch08_2_4)
    中，你将看到使用详细反汇编模式的示例。'
- en: Interpreting the Disassembled Code and Cleaning Up
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反汇编代码解释与清理
- en: If all goes well, `cs_disasm` should return the number of disassembled instructions.
    In case of failure, it returns 0, and you must call the `cs_errno` function to
    check what the error is. This yields an `enum` value of type `cs_err`. In most
    cases, you want to print a human-readable error message and exit. For this reason,
    Capstone provides a convenient function called `cs_strerror`, which turns a `cs_err`
    value into a string describing the error.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，`cs_disasm` 应该返回反汇编的指令数量。如果失败，它会返回 0，你必须调用 `cs_errno` 函数来检查错误是什么。这将返回一个
    `enum` 类型的 `cs_err` 值。在大多数情况下，你需要打印一个可读的错误信息并退出。为此，Capstone 提供了一个便捷的函数 `cs_strerror`，它将一个
    `cs_err` 值转换为描述错误的字符串。
- en: If there are no errors, the `disasm` function loops over all the disassembled
    instructions returned by `cs_disasm` ➎ (refer to [Listing 8-4](ch08.xhtml#ch08list4)).
    This loop prints a line for each instruction, composed of the different fields
    in the `cs_insn` struct described earlier. Finally, after the loop completes,
    `disasm` calls `cs_free(insns, n)` to free the memory allocated by Capstone for
    each of the `n` instructions it parsed into the `insns` buffer ➏, then closes
    the Capstone instance by calling `cs_close`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，`disasm` 函数会遍历 `cs_disasm` 返回的所有反汇编指令 ➎（参见 [Listing 8-4](ch08.xhtml#ch08list4)）。这个循环会为每条指令打印一行，包含之前描述的
    `cs_insn` 结构体中的不同字段。最后，在循环完成后，`disasm` 会调用 `cs_free(insns, n)` 来释放 Capstone 为它解析到
    `insns` 缓冲区中的每条 `n` 条指令分配的内存 ➏，然后通过调用 `cs_close` 来关闭 Capstone 实例。
- en: You should now know most of the important Capstone functions and data structures
    you’ll need to perform basic disassembly and analysis tasks. If you want, you
    can try compiling and running the `basic_capstone_linear` example. Its output
    should be a list of the instructions in the `.text` section of the disassembled
    binary, like in [Listing 8-7](ch08.xhtml#ch08list7).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经了解了进行基本反汇编和分析任务所需的大部分重要 Capstone 函数和数据结构。如果你愿意，可以尝试编译并运行 `basic_capstone_linear`
    示例。它的输出应该是反汇编二进制文件 `.text` 区段中的指令列表，参考 [Listing 8-7](ch08.xhtml#ch08list7)。
- en: '*Listing 8-7: Example output of the linear disassembly tool*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-7: 线性反汇编工具的示例输出*'
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the rest of this chapter, you’ll see more elaborate disassembly examples
    using Capstone. The more complicated examples mostly come down to parsing some
    of the more detailed data structures. They’re not fundamentally more difficult
    than the examples you’ve already seen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将看到更多使用 Capstone 的详细反汇编示例。更复杂的示例大多归结为解析一些更详细的数据结构。它们并不比你已经看到的示例更加困难。
- en: '*8.2.3 Exploring the Capstone C API*'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.2.3 探索 Capstone C API*'
- en: Now that you’ve seen some of the basic Capstone functions and data structures,
    you may wonder if the rest of the Capstone API is documented somewhere. Unfortunately,
    no such comprehensive documentation of the Capstone API currently exists. The
    closest thing you have at your disposal is the Capstone header files. Luckily,
    they are well commented and not too complex, so with some basic pointers, you
    can quickly skim through them and find what you need for any given project. Capstone
    header files are all the C header files included with Capstone v3.0.5\. I shaded
    the most important ones for these purposes in [Listing 8-8](ch08.xhtml#ch08list8).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些基本的 Capstone 函数和数据结构，你可能会想知道 Capstone API 的其余部分是否有文档。目前，遗憾的是并没有一份全面的
    Capstone API 文档。你手头上最接近的资源是 Capstone 的头文件。幸运的是，这些文件注释清晰且不复杂，因此只需一些基本的指引，你就能快速浏览它们，找到任何给定项目所需的内容。Capstone
    的头文件包括所有与 Capstone v3.0.5 一同发布的 C 语言头文件。我在 [Listing 8-8](ch08.xhtml#ch08list8)
    中阴影标出了这些文件中最重要的部分。
- en: '*Listing 8-8: The Capstone C header files*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-8: Capstone C 头文件*'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you’ve seen, *capstone.h* is the main Capstone header file. It contains commented
    definitions of all the Capstone API functions as well as the architecture-independent
    data structures, such as `cs_insn` and `cs_err`. This is also where all the possible
    values for `enum` types like `cs_arch`, `cs_mode`, and `cs_err` are defined. For
    instance, if you wanted to modify the linear disassembler so it supports ARM code,
    you would reference *capstone.h* to find the proper architecture (`CS_ARCH_ARM`)
    and mode (`CS_MODE_ARM`) parameters to pass to the `cs_open` function.^([4](footnote.xhtml#ch08fn_4))
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*capstone.h* 是 Capstone 的主要头文件。它包含了所有 Capstone API 函数的注释定义，以及一些与架构无关的数据结构，如
    `cs_insn` 和 `cs_err`。这里也是所有 `enum` 类型（如 `cs_arch`、`cs_mode` 和 `cs_err`）的所有可能值的定义所在。例如，如果你想修改线性反汇编器，使其支持
    ARM 代码，你可以参考 *capstone.h* 来查找适当的架构（`CS_ARCH_ARM`）和模式（`CS_MODE_ARM`）参数，然后将它们传递给
    `cs_open` 函数。^([4](footnote.xhtml#ch08fn_4))
- en: Architecture-dependent data structures and constants are defined in separate
    header files, like *x86.h* for the x86 and x86-64 architecture. These files specify
    the possible values for the `id` field of the `cs_insn` struct—for x86, these
    are all the listed values of the `enum` type called `x86_insn`. For the most part,
    you’ll refer to the architecture-specific headers to find out which details are
    available through the `detail` field of the `cs_insn` type. If detailed disassembly
    mode is enabled, this field points to a `cs_detail` struct.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖架构的数据结构和常量定义在单独的头文件中，例如 x86 和 x86-64 架构的 *x86.h*。这些文件指定了 `cs_insn` 结构体中 `id`
    字段的可能值——对于 x86，这些值全部是名为 `x86_insn` 的 `enum` 类型中列出的值。大部分情况下，你需要参考特定架构的头文件，了解通过
    `cs_insn` 类型的 `detail` 字段可以访问哪些详细信息。如果启用了详细反汇编模式，该字段指向一个 `cs_detail` 结构体。
- en: The `cs_detail` struct contains a `union` of architecture-dependent `struct`
    types that provide detailed information on the instruction. The type associated
    with x86 is called `cs_x86`, which is defined in *x86.h*. To illustrate this,
    let’s build a recursive disassembler that uses Capstone’s detailed disassembly
    mode to obtain architecture-specific information on x86 instructions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs_detail` 结构体包含一个依赖架构的 `union`，其中包含提供指令详细信息的不同 `struct` 类型。与 x86 相关的类型叫做
    `cs_x86`，定义在 *x86.h* 中。为了说明这一点，接下来我们将构建一个递归反汇编器，使用 Capstone 的详细反汇编模式获取 x86 指令的架构特定信息。'
- en: '*8.2.4 Recursive Disassembly with Capstone*'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.2.4 使用 Capstone 的递归反汇编*'
- en: Without detailed disassembly, Capstone allows you to inspect only basic information
    about instructions, such as the address, raw bytes, or mnemonic representation.
    This is fine for a linear disassembler, as you saw in the previous example. However,
    more advanced binary analysis tools often need to make decisions based on instruction
    properties, such as the registers the instruction accesses, the type and value
    of its operands, the type of instruction (arithmetic, control flow, and so on),
    or the locations targeted by control flow instructions. This kind of detailed
    information is provided only in Capstone’s detailed disassembly mode. Parsing
    it requires extra effort on Capstone’s part, making detailed disassembly slower
    than in non-detailed mode. Therefore, you should use detailed mode only when needed.
    One instance that requires detailed disassembly mode is recursive disassembly.
    Recursive disassembly is a recurring theme in many binary analysis applications,
    so let’s explore it in more detail.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有详细反汇编的情况下，Capstone 只允许你检查关于指令的基本信息，如地址、原始字节或助记符表示。这对于线性反汇编器来说是足够的，正如你在之前的示例中看到的那样。然而，更高级的二进制分析工具通常需要根据指令属性做出决策，例如指令访问的寄存器、操作数的类型和值、指令类型（算术、控制流等）或控制流指令指向的位置。这类详细信息只有在
    Capstone 的详细反汇编模式中才会提供。解析这些信息需要 Capstone 额外的处理，因此详细反汇编的速度比非详细模式慢。因此，你应仅在需要时使用详细模式。递归反汇编就是需要详细反汇编模式的一个场景。递归反汇编是许多二进制分析应用中的一个常见主题，所以我们来更详细地探讨它。
- en: Recall from [Chapter 6](ch06.xhtml#ch06) that recursive disassembly discovers
    code by starting from known entry points, such as the main entry point of the
    binary, or function symbols, and following control flow instructions from there.
    In contrast to linear disassembly, which blindly disassembles all code in sequence,
    recursive disassembly isn’t easily fooled by things like data interspersed with
    the code. The downside is that recursive disassembly may miss instructions if
    the instructions are reachable only via indirect control flows, which cannot be
    resolved statically.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[第6章](ch06.xhtml#ch06)，递归反汇编通过从已知的入口点（如二进制文件的主入口点或函数符号）开始，跟随控制流指令来发现代码。与盲目按顺序反汇编所有代码的线性反汇编不同，递归反汇编不容易被诸如与代码交错的数据等情况欺骗。缺点是，如果指令只能通过间接控制流访问，而这些控制流无法静态解析，递归反汇编可能会遗漏这些指令。
- en: Setting Up Detailed Disassembly Mode
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置详细反汇编模式
- en: '[Listing 8-9](ch08.xhtml#ch08list9) shows a basic implementation of recursive
    disassembly. Unlike most recursive disassemblers, the one in this example doesn’t
    assume that bytes can belong to only a single instruction at a time, so overlapping
    code blocks are supported.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-9](ch08.xhtml#ch08list9)展示了递归反汇编的基本实现。与大多数递归反汇编器不同，本示例中的反汇编器并不假设字节一次只能属于单条指令，因此支持重叠的代码块。'
- en: '*Listing 8-9:* basic_capstone_recursive.cc'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-9:* basic_capstone_recursive.cc'
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see in [Listing 8-9](ch08.xhtml#ch08list9), the `main` function is
    identical to the one for the linear disassembler. And for the most part, the initialization
    code at the start of `disasm` is also similar. It starts by loading the `.text`
    section and getting a Capstone handle. However, there’s a small but important
    addition ➊. This added line enables detailed disassembly mode by activating the
    `CS_OPT_DETAIL` option. This is crucial for recursive disassembly because you
    need the control flow information, which is provided only in detailed disassembly
    mode.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[清单 8-9](ch08.xhtml#ch08list9)中看到的，`main`函数与线性反汇编器中的 `main` 函数完全相同。大部分情况下，`disasm`函数开头的初始化代码也很相似。它首先加载`.text`段并获取一个
    Capstone 句柄。然而，有一个小而重要的补充 ➊。这行代码通过激活 `CS_OPT_DETAIL` 选项来启用详细反汇编模式。这对于递归反汇编至关重要，因为你需要控制流信息，而这些信息只有在详细反汇编模式中才会提供。
- en: Next, the code explicitly allocates an instruction buffer ➋. While this wasn’t
    necessary for the linear disassembler, you need it here because you’ll use another
    Capstone API function for the actual disassembly than the one used before. This
    alternative disassembly function allows you to inspect each instruction while
    it’s disassembled without having to wait for all other instructions to be disassembled.
    This is a common requirement in detailed disassembly because you typically want
    to act on the details of each instruction as you go along in order to influence
    the control flow of the disassembler.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码显式地分配了一个指令缓冲区 ➋。虽然在线性反汇编器中并不需要这个缓冲区，但在这里需要它，因为你将使用与之前不同的Capstone API函数进行实际反汇编。这个替代的反汇编函数允许你在反汇编每条指令时即时检查它，而无需等待所有其他指令都被反汇编完毕。这是详细反汇编中的常见需求，因为你通常希望在过程中对每条指令的细节进行处理，以便影响反汇编器的控制流。
- en: Looping Through Entry Points
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过入口点进行循环
- en: 'Following the Capstone initialization, the logic of the recursive disassembler
    begins. The recursive disassembler is structured around a queue, which contains
    starting points for the disassembler. The first step is to bootstrap the disassembly
    process by filling the queue with initial entry points: the main entry point of
    the binary ➌ as well as any known function symbols ➍. After that, the code continues
    into the main disassembly loop ➎.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Capstone初始化之后，递归反汇编器的逻辑开始执行。递归反汇编器是围绕一个队列构建的，这个队列包含反汇编器的起始点。第一步是通过填充队列来启动反汇编过程，填充的内容包括：二进制文件的主入口点➌以及任何已知的函数符号
    ➍。之后，代码进入主反汇编循环 ➎。
- en: As mentioned, the loop is structured around a queue of addresses, which are
    used as starting points for the disassembly. As long as there are more starting
    points to explore, each iteration pops the next starting point from the queue
    and then follows control flow from there, disassembling as much code as possible.
    Essentially, this performs a linear disassembly from each starting point, pushing
    each newly discovered control flow destination into the queue. The new destination
    will be disassembled in a later iteration of the loop. Each linear sweep stops
    only when it encounters a `hlt` instruction, or an unconditional branch, because
    these instructions aren’t guaranteed to have a valid fall-through target. Data,
    instead of code, might come after these instructions, so you don’t want to continue
    disassembling past them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，循环是围绕一个地址队列构建的，这些地址用作反汇编的起始点。只要还有更多的起始点需要探索，每次迭代都会从队列中弹出下一个起始点，然后从那里开始跟随控制流，尽可能多地反汇编代码。实质上，这个过程从每个起始点执行线性反汇编，将每个新发现的控制流目标推入队列。新的目标将在循环的后续迭代中被反汇编。每次线性扫描只会在遇到`hlt`指令或无条件跳转时停止，因为这些指令无法保证有有效的跳转目标。这些指令后面可能是数据而不是代码，因此你不希望继续反汇编它们之后的内容。
- en: The loop uses several new Capstone functions that you probably haven’t seen
    before. For one thing, it uses a different API call, named `cs_disasm_iter`, for
    the actual disassembly ➏. Also, there are functions that retrieve detailed disassembly
    information, such as the targets of control flow instructions and information
    on whether a particular instruction is a control flow instruction in the first
    place. Let’s begin by discussing why you need to use `cs_disasm_iter` instead
    of plain old `cs_disasm` in this example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该循环使用了几个你可能以前没见过的Capstone新函数。首先，它使用了一个不同的API调用，名为`cs_disasm_iter`，来执行实际的反汇编
    ➏。此外，还有一些函数可以检索详细的反汇编信息，例如控制流指令的目标和判断某条指令是否为控制流指令的信息。让我们先讨论一下为什么在这个例子中需要使用`cs_disasm_iter`而不是传统的`cs_disasm`。
- en: Using Iterative Disassembly for Real-Time Instruction Parsing
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用迭代式反汇编进行实时指令解析
- en: As the name implies, `cs_disasm_iter` is an iterative variant of the `cs_disasm`
    function. With `cs_disasm_iter`, instead of disassembling a whole code buffer
    at once, Capstone disassembles only one instruction at a time. After disassembling
    each instruction, `cs_disasm_iter` returns either true or false. True means that
    an instruction was successfully disassembled, while false means nothing was disassembled.
    You can easily create a `while` loop, like the one shown at ➏, that calls `cs_disasm_iter`
    until there is no code left to disassemble.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，`cs_disasm_iter`是`cs_disasm`函数的迭代变体。使用`cs_disasm_iter`时，Capstone不会一次性反汇编整个代码缓冲区，而是每次只反汇编一条指令。每反汇编完一条指令，`cs_disasm_iter`会返回`true`或`false`。`true`表示指令成功反汇编，而`false`表示没有任何指令被反汇编。你可以轻松创建一个`while`循环，如➏所示，调用`cs_disasm_iter`直到没有剩余的代码可供反汇编。
- en: The parameters to `cs_disasm_iter` are essentially iterative variants of those
    you saw in the linear disassembler. As before, the first parameter is your Capstone
    handle. The second parameter is a pointer to the code to disassemble. However,
    instead of a `uint8_t*`, it’s now a double pointer (that is, a `uint8_t**`). This
    allows `cs_disasm_iter` to automatically update the pointer each time it is called,
    setting it to point just past the recently disassembled bytes. Since this behavior
    is similar to a program counter, this parameter is called `pc`. As you can see,
    for each starting point in the queue, you just have to point `pc` to the correct
    location in the `.text` section once. After that, you can simply call `cs_disasm_iter`
    in a loop, and it automatically takes care of incrementing `pc`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs_disasm_iter`的参数本质上是你在线性反汇编器中看到的那些参数的迭代变体。如同之前一样，第一个参数是你的Capstone句柄。第二个参数是指向要反汇编代码的指针。不过，现在它是一个双指针（即`uint8_t**`），而不是`uint8_t*`。这样，`cs_disasm_iter`可以在每次调用时自动更新指针，将其设置为指向刚刚反汇编过的字节之后的位置。由于这种行为类似于程序计数器，因此这个参数叫做`pc`。如你所见，对于队列中的每个起始点，你只需要将`pc`指向`.text`段中的正确位置一次。之后，你可以简单地在循环中调用`cs_disasm_iter`，它会自动处理`pc`的递增。'
- en: The third parameter is the number of bytes left to disassemble, which is also
    automatically decremented by `cs_disasm_iter`. In this case, it’s always equal
    to the size of the `.text` section minus the number of bytes already disassembled.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是剩余的字节数，用于反汇编，`cs_disasm_iter`会自动递减该值。在这种情况下，它始终等于`.text`段的大小减去已反汇编的字节数。
- en: There’s also an automatically incremented parameter called `addr`, which informs
    Capstone about the VMA of the code pointed to by `pc` (just as `text->vma` did
    in the linear disassembler). The last parameter is a pointer to a `cs_insn` object,
    which serves as a buffer for each disassembled instruction.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个自动递增的参数叫做`addr`，它告诉Capstone代码指针`pc`所指向的代码的虚拟内存地址（就像线性反汇编器中的`text->vma`）。最后一个参数是指向`cs_insn`对象的指针，它作为每条反汇编指令的缓冲区。
- en: Using `cs_disasm_iter` instead of `cs_disasm` has several advantages. The main
    reason for using it is its iterative behavior, which allows you to inspect each
    instruction right after it’s disassembled, letting you inspect control flow instructions
    and follow them recursively. In addition to its useful iterative behavior, `cs_disasm_iter`
    is faster and more memory efficient than `cs_disasm` since it doesn’t require
    a large preallocated buffer to contain all disassembled instructions at once.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cs_disasm_iter`代替`cs_disasm`有几个优点。使用它的主要原因是它的迭代行为，允许你在每条指令反汇编后立即检查它，从而让你检查控制流指令并递归跟踪它们。除了有用的迭代行为外，`cs_disasm_iter`还比`cs_disasm`更快、更节省内存，因为它不需要一个大的预分配缓冲区来一次性容纳所有反汇编的指令。
- en: Parsing Control Flow Instructions
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析控制流指令
- en: As you’ve seen, the disassembly loop uses several helper functions to determine
    whether a particular instruction is a control flow instruction and, if so, what
    its target is. For example, the function `is_cs_cflow_ins` (called at ➐) determines
    whether an instruction is any kind of control flow instruction (conditional or
    unconditional). To this end, it inspects Capstone’s detailed disassembly information.
    In particular, the `ins->detail` struct provided by Capstone contains an array
    of “groups” to which the instruction belongs (`ins->detail->groups`). With this
    information, you can easily make decisions based on the groups an instruction
    belongs to. For instance, you can tell that an instruction is some kind of jump
    instruction without having to explicitly check the `ins->id` field against every
    possible kind of jump, such as `jmp`, `ja`, `je`, `jnz`, and so on. In the case
    of the `is_cs_cflow_ins` function, it checks whether an instruction is a kind
    of jump, call, return, or return from interrupt (the actual check is implemented
    in another helper function, called `is_cs_cflow_group`). If an instruction is
    one of these four types, it’s considered a control flow instruction.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，拆解循环使用了多个辅助函数来判断某个特定指令是否为控制流指令，并且如果是，它的目标地址是什么。例如，`is_cs_cflow_ins`函数（在➐处调用）用于判断某个指令是否为任何类型的控制流指令（无论是条件跳转还是无条件跳转）。为此，它检查了Capstone提供的详细拆解信息。特别地，Capstone提供的`ins->detail`结构体包含了一个指令所属的“组”数组（`ins->detail->groups`）。通过这些信息，你可以轻松地根据指令所属的组做出决策。例如，你可以知道某个指令是跳转指令，而不需要显式地检查`ins->id`字段是否与所有可能的跳转指令匹配，如`jmp`、`ja`、`je`、`jnz`等。在`is_cs_cflow_ins`函数中，它会检查指令是否属于跳转、调用、返回或中断返回指令类型（实际检查由另一个辅助函数`is_cs_cflow_group`实现）。如果指令属于这四种类型中的任何一种，它就被认为是控制流指令。
- en: 'If a disassembled instruction turns out to be a control flow instruction, then
    you want to resolve its target if possible and add it to your queue if you haven’t
    seen it before so that the instructions at that target address are disassembled
    later. The code to resolve control flow targets is in a helper function called
    `get_cs_insn_immediate_target`. The example calls this function at ➑. As the name
    implies, it’s only capable of resolving “immediate” control flow targets: target
    addresses that are hardcoded in the control flow instruction. In other words,
    it makes no attempt to resolve indirect control flow targets, which is difficult
    to do statically, as you may recall from [Chapter 6](ch06.xhtml#ch06).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个拆解的指令被识别为控制流指令，那么你需要尽可能解析它的目标地址，并将其添加到队列中（如果之前没有见过该地址），以便稍后对该目标地址处的指令进行拆解。解析控制流目标地址的代码在一个名为`get_cs_insn_immediate_target`的辅助函数中。示例在➑处调用了这个函数。顾名思义，它只能解析“立即”控制流目标：即在控制流指令中硬编码的目标地址。换句话说，它不会尝试解析间接控制流目标，因为这在静态分析中是非常困难的，正如你在[第六章](ch06.xhtml#ch06)中看到的那样。
- en: 'Parsing control flow targets is the first instance of architecture-specific
    instruction handling in this example. Resolving a control flow target requires
    you to examine the instruction’s operands, and since every instruction architecture
    has its own set of operand types, parsing them cannot be done in a generic way.
    In this case, you’re operating on x86 code, so you need to access the x86-specific
    operand array provided by Capstone as part of the detailed disassembly information
    (`ins->detail->x86.operands`). This array contains operands in the form of a `struct`
    type called `cs_x86_op`. This struct contains an anonymous `union` of all possible
    operand types: register (`reg`), immediate (`imm`), floating point (`fp`), or
    memory (`mem`). Which of these fields is actually set depends on the operand type,
    and the type is indicated by the `type` field of `cs_x86_op`. The example disassembler
    only parses immediate control flow targets, so it checks for operands of `type
    X86_OP_IMM` and returns the value of any immediate targets it finds. If this target
    hasn’t been disassembled yet, the `disasm` function adds it to the queue.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 解析控制流目标是这个例子中架构特定指令处理的第一个实例。解决控制流目标需要检查指令的操作数，并且由于每种指令架构都有自己的一组操作数类型，不能以通用方式解析它们。在这个例子中，你正在操作x86代码，因此你需要访问Capstone提供的x86特定操作数字段数组，作为详细反汇编信息的一部分（`ins->detail->x86.operands`）。该数组包含以`struct`类型`cs_x86_op`表示的操作数。该`struct`包含一个匿名`union`，其中包含所有可能的操作数类型：寄存器（`reg`）、立即数（`imm`）、浮动点数（`fp`）或内存（`mem`）。实际设置的字段取决于操作数类型，类型由`cs_x86_op`中的`type`字段指示。示例反汇编器只解析立即数类型的控制流目标，因此它检查`type
    X86_OP_IMM`的操作数，并返回它找到的任何立即数目标的值。如果该目标尚未被反汇编，`disasm`函数会将其加入队列。
- en: Finally, if `disasm` encounters a `hlt` or an unconditional control flow, it
    halts disassembly because it doesn’t know whether there are noncode bytes after
    such instructions. To check for unconditional control flow instructions, `disasm`
    calls another helper function, called `is_cs_unconditional_cflow_ins` ➒. This
    function simply uses the `ins->id` field to check explicitly for all relevant
    types of instructions since there are only a few such types. There’s a separate
    check for `hlt` instructions at ➓. After the disassembly loop ends, the `disasm`
    function cleans up the allocated instruction buffer and closes the Capstone handle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`disasm`遇到`hlt`指令或无条件控制流指令，它会停止反汇编，因为它无法知道这些指令后面是否还有非代码字节。为了检查无条件控制流指令，`disasm`调用另一个辅助函数，叫做`is_cs_unconditional_cflow_ins`
    ➒。这个函数通过`ins->id`字段显式检查所有相关的指令类型，因为这种类型的指令种类有限。在➓处有一个单独的检查针对`hlt`指令。当反汇编循环结束后，`disasm`函数会清理分配的指令缓冲区并关闭Capstone句柄。
- en: Running the Recursive Disassembler
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行递归反汇编器
- en: The recursive disassembly algorithm just explored is the basis for many custom
    disassembly tools, as well as full-fledged disassembler suites such as Hopper
    or IDA Pro. Of course, these contain many more heuristics than this simple example
    for identifying function entry points and other useful code properties, even in
    the absence of function symbols. Try compiling and running the recursive disassembler!
    It works best on binaries with symbolic information. Its output is designed to
    let you follow along with what the recursive disassembly process is doing. For
    example, [Listing 8-10](ch08.xhtml#ch08list10) shows a snippet of the recursive
    disassembly output for the obfuscated binary with overlapping basic blocks introduced
    at the start of this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才探讨的递归反汇编算法是许多自定义反汇编工具的基础，也是像Hopper或IDA Pro这样的完整反汇编套件的基础。当然，这些工具包含比这个简单示例更多的启发式方法，用于识别函数入口点和其他有用的代码属性，即使没有函数符号也能识别。尝试编译并运行递归反汇编器！它在具有符号信息的二进制文件上效果最好。它的输出旨在让你跟随递归反汇编过程的每一步。例如，[列表8-10](ch08.xhtml#ch08list10)展示了本章开头引入的具有重叠基本块的混淆二进制文件的递归反汇编输出片段。
- en: '*Listing 8-10: Example output of the recursive disassembler*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表8-10：递归反汇编器的示例输出*'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see in [Listing 8-10](ch08.xhtml#ch08list10), the disassembler starts
    by queueing up entry points: first the binary’s main entry point and then any
    known function symbols. It then proceeds to disassemble as much code as safely
    possible starting from each address in the queue (the dashes denote the points
    at which the disassembler decides to stop and move to the next address in the
    queue). Along the way, the disassembler also finds new, previously unknown, addresses
    to put in the queue for later disassembly. For instance, the `jbe` instruction
    at address `0x400543` reveals the new target address `0x400560` ➊. The disassembler
    successfully finds both overlapping blocks in the obfuscated binary: the one at
    address `0x400610` ➋ as well as the one at address `0x400612` ➌ that’s embedded
    in it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 8-10](ch08.xhtml#ch08list10)所示，反汇编器首先排队处理入口点：首先是二进制文件的主入口点，然后是任何已知的函数符号。接着，它会从队列中的每个地址开始，尽可能安全地反汇编尽可能多的代码（破折号表示反汇编器决定停止并移动到队列中的下一个地址的位置）。在此过程中，反汇编器还会发现新的、以前未知的地址，将它们添加到队列中以便稍后反汇编。例如，地址`0x400543`处的`jbe`指令揭示了新的目标地址`0x400560`
    ➊。反汇编器成功地找到了在模糊二进制文件中重叠的两个代码块：一个位于地址`0x400610` ➋，另一个嵌入其中，位于地址`0x400612` ➌。
- en: 8.3 Implementing a ROP Gadget Scanner
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3 实现ROP Gadget扫描器
- en: 'All the examples you’ve seen so far are custom implementations of well-known
    disassembly techniques. However, you can do much more with Capstone! In this section,
    you’ll see a more specialized kind of tool with disassembly needs that aren’t
    covered by standard linear or recursive disassembly. Specifically, you’ll learn
    about a tool that is indispensable for modern exploit writing: a scanning tool
    that can find gadgets for use in ROP exploits. First, let’s explore what this
    means.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您看到的所有示例都是知名反汇编技术的自定义实现。然而，Capstone能做得更多！在本节中，您将看到一种更专业的工具，它的反汇编需求是标准的线性或递归反汇编所无法涵盖的。具体来说，您将了解一种对于现代漏洞编写至关重要的工具：一种扫描工具，它能够找到用于ROP攻击的gadget。首先，让我们来探索一下这意味着什么。
- en: '*8.3.1 Introduction to Return-Oriented Programming*'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.3.1 返回导向编程简介*'
- en: 'Nearly every introduction to exploitation covers Aleph One’s classic article
    “Smashing the Stack for Fun and Profit,” which explains the basics of exploiting
    stack-based buffer overflows. When this article was published in 1996, exploitation
    was relatively straightforward: find a vulnerability, load malicious shellcode
    into a buffer (typically a stack buffer) in the target application, and use the
    vulnerability to redirect control flow to the shellcode.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每篇关于漏洞利用的介绍文章都涵盖了Aleph One的经典文章《Smashing the Stack for Fun and Profit》，该文解释了基于栈的缓冲区溢出利用的基础。当这篇文章在1996年发布时，漏洞利用相对简单：找到一个漏洞，将恶意的shellcode加载到目标应用程序中的缓冲区（通常是栈缓冲区），然后利用该漏洞将控制流重定向到shellcode。
- en: Much has happened in the world of security since, and exploitation has gotten
    vastly more complicated. One of the most widespread defenses against classic exploits
    of this kind is data execution prevention (DEP), also known as W⊕X or NX. It was
    introduced in Windows XP in 2004 and prevents shellcode injection in an extremely
    straightforward way. DEP enforces that no region of memory is ever writable and
    executable at the same time. So if an attacker injects shellcode into a buffer,
    they cannot execute it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自那时以来，安全领域发生了很多变化，攻击手段变得更加复杂。针对这类经典漏洞的最广泛防御之一是数据执行防护（DEP），也称为W⊕X或NX。它在2004年随着Windows
    XP的推出而引入，能够以一种极其简单的方式防止shellcode注入。DEP强制要求任何内存区域不能同时是可写和可执行的。因此，如果攻击者将shellcode注入到缓冲区中，他们将无法执行它。
- en: Unfortunately, it wasn’t long before hackers found a way to circumvent DEP.
    New defenses prevented the injection of shellcode, but they couldn’t stop an attacker
    from using a vulnerability to redirect control flow to *existing code* in the
    exploited binary or the libraries it uses. This weakness was first exploited in
    a class of attacks known as return-to-libc (ret2libc) in which control flow is
    redirected to sensitive functions in the widely used libc library, like the `execve`
    function, which can be used to start a new process of the attacker’s choice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，黑客很快找到了一种绕过DEP的方法。新的防御措施阻止了shellcode的注入，但无法阻止攻击者利用漏洞将控制流重定向到被利用的二进制文件中或它所使用的库中的*现有代码*。这种弱点首次被利用是在一种称为返回到libc（ret2libc）的攻击中，其中控制流被重定向到广泛使用的libc库中的敏感函数，如`execve`函数，后者可用于启动攻击者选择的新进程。
- en: In 2007 came a generalized variant of ret2libc, known as *return-oriented programming
    (ROP)*. Instead of restricting attacks to existing functions, ROP allows an attacker
    to implement arbitrary malicious functionality by chaining together short existing
    code sequences in the target program’s memory space. These short code sequences
    are called *gadgets* in ROP terminology.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 2007年，出现了一种称为*面向返回编程（ROP）*的广义版本的ret2libc攻击。与将攻击限制于现有函数不同，ROP允许攻击者通过将目标程序内存空间中短小的现有代码序列连接起来来实现任意的恶意功能。这些短小的代码序列在ROP术语中被称为*工具链*。
- en: Each gadget ends in a return instruction and performs a basic operation, such
    as addition or logical comparison.^([5](footnote.xhtml#ch08fn_5)) By carefully
    selecting gadgets with well-defined semantics, an attacker can create what is
    essentially a customized instruction set where each gadget forms an instruction
    and then use this instruction set to craft arbitrary functionality, called a ROP
    program, without injecting any new code. Gadgets can be part of the host program’s
    normal instructions, but they can also be unaligned instruction sequences of the
    sort you saw in the obfuscated code example in [Listings 8-1](ch08.xhtml#ch08list1)
    and [8-2](ch08.xhtml#ch08list2).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工具链都以返回指令结束，并执行基本操作，例如加法或逻辑比较。^([5](footnote.xhtml#ch08fn_5)) 通过精心选择具有明确定义语义的工具链，攻击者可以创建一个本质上是定制化指令集的程序，其中每个工具链形成一个指令，然后使用这个指令集来构建任意功能，也就是所谓的ROP程序，而无需注入任何新代码。工具链可以是主机程序正常指令的一部分，也可以是未对齐的指令序列，就像你在[清单8-1](ch08.xhtml#ch08list1)和[8-2](ch08.xhtml#ch08list2)中看到的混淆代码示例那样。
- en: A ROP program consists of a series of gadget addresses carefully arranged on
    the stack so that the return instruction terminating each gadget transfers control
    to the next gadget in the chain. To start the ROP program, you execute an initial
    return instruction (for instance, by triggering it through an exploit) that jumps
    to the first gadget address. [Figure 8-1](ch08.xhtml#ch08fig1) illustrates an
    example ROP chain.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ROP程序由一系列精心排列在栈上的工具链地址组成，使得每个工具链结束的返回指令将控制权转移到链中的下一个工具链地址。要启动ROP程序，你执行一个初始返回指令（例如，通过攻击触发），该指令跳转到第一个工具链地址。[图8-1](ch08.xhtml#ch08fig1)展示了一个ROP链的示例。
- en: '![image](Images/f214-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f214-01.jpg)'
- en: '*Figure 8-1: An example ROP chain. Gadget* g[1] *loads a constant into* `eax`,
    *which is then added to* `esi` *by* g[2].'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：一个示例ROP链。工具链* g[1] *将常量加载到* `eax`，*然后由* g[2] *将其加到* `esi` *中。*'
- en: As you can see, the stack pointer (the `esp` register) initially points to the
    address of the first gadget g[1] in the chain. When the initial return instruction
    happens, it pops this first gadget address off the stack and transfers control
    to it, causing g[1] to run. Gadget g[1] performs a `pop` instruction that loads
    a constant arranged on the stack into the `eax` register and increments `esp`
    to point to the address of gadget g[2]. Then, g[1]’s `ret` instruction transfers
    control to g[2], which subsequently adds the constant in `eax` to the `esi` register.
    Gadget g[2] then returns to gadget g[3], and so on, until all gadgets g[1], .
    . . ,g[n] have been executed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，栈指针（`esp`寄存器）最初指向链中第一个工具链g[1]的地址。当初始返回指令发生时，它将栈中的第一个工具链地址弹出，并将控制权转移到该地址，导致g[1]执行。工具链g[1]执行一个`pop`指令，将栈上安排的常量加载到`eax`寄存器，并将`esp`递增以指向工具链g[2]的地址。接着，g[1]的`ret`指令将控制权转移到g[2]，g[2]随后将`eax`中的常量加到`esi`寄存器中。工具链g[2]然后返回给工具链g[3]，以此类推，直到所有工具链g[1]、...、g[n]都被执行。
- en: As you may have gathered from this, creating a ROP exploit requires that an
    attacker first select an appropriate set of ROP gadgets to use. In the following
    section, we’ll implement a tool that scans a binary for usable ROP gadgets and
    creates an overview of these gadgets to aid in building ROP exploits.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从中了解到的，创建ROP攻击利用需要攻击者首先选择一个合适的ROP工具链。在接下来的部分，我们将实现一个工具，该工具扫描二进制文件以查找可用的ROP工具链，并创建这些工具链的概览，以帮助构建ROP攻击。
- en: '*8.3.2 Finding ROP Gadgets*'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.3.2 查找ROP工具链*'
- en: The next listing shows the code for the ROP gadget finder. It outputs a list
    of ROP gadgets that can be found in the given binary. You can use this list to
    select appropriate gadgets and combine them into an exploit for the binary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码展示了ROP工具链查找器的代码。它输出给定二进制文件中可以找到的ROP工具链列表。你可以使用这个列表来选择合适的工具链，并将它们组合成针对该二进制文件的攻击。
- en: As mentioned, you want to find gadgets that end in a return instruction. Moreover,
    you want to look for both aligned and unaligned gadgets with respect to the binary’s
    normal instruction stream. Usable gadgets should have well-defined and simple
    semantics, so the length of the gadgets should be fairly limited. In this case,
    let’s (arbitrarily) limit gadget length to five instructions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你需要找到以返回指令结尾的小工具。此外，你还需要查找与二进制文件的常规指令流对齐或不对齐的小工具。可用的小工具应具有明确且简单的语义，因此它们的长度应相对有限。在这种情况下，我们（随意地）将小工具的长度限制为五条指令。
- en: To find both aligned and unaligned gadgets, one possible approach is to disassemble
    the binary from each possible starting byte and see for which bytes you end up
    with a usable gadget. However, you can make things more efficient by first scanning
    the binary for locations of return instructions (aligned or unaligned) and then
    traversing backward from there, building up increasingly long gadgets as you go
    along. This way, you don’t have to start a disassembly sweep at every possible
    address, but only at addresses near return instructions. Let’s clarify what exactly
    this means by taking a closer look at the gadget finder code shown in [Listing
    8-11](ch08.xhtml#ch08list11).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到对齐和不对齐的小工具，一种可能的方法是从每个可能的起始字节反汇编二进制文件，看看在哪些字节上你会得到一个可用的小工具。然而，你可以通过先扫描二进制文件以查找返回指令（无论是对齐还是不对齐）的位置，然后从这些位置向后遍历，逐渐构建出越来越长的小工具，从而提高效率。这样，你就不必在每个可能的地址处开始反汇编扫描，只需在接近返回指令的地址开始即可。让我们通过仔细查看[列表
    8-11](ch08.xhtml#ch08list11)中的小工具查找器代码，来更清楚地了解这到底意味着什么。
- en: '*Listing 8-11:* capstone_gadget_finder.cc'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-11:* capstone_gadget_finder.cc'
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The gadget finder in [Listing 8-11](ch08.xhtml#ch08list11) doesn’t introduce
    any new Capstone concepts. The `main` function is the same one you saw in the
    linear and recursive disassemblers, and the helper functions (`is_cs_cflow_group`,
    `is_cs_cflow_ins`, and `is_cs_ret_ins`) are similar to those you saw before. The
    Capstone disassembly function, `cs_disasm_iter`, is also one you’ve seen before.
    The interesting thing about the gadget finder is that it uses Capstone to analyze
    a binary in a way that can’t be done with a standard linear or recursive disassembler.
    All the gadget-finding functionality is implemented in the functions `find_gadgets`
    and `find_gadgets_at_root`, so let’s focus on them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-11](ch08.xhtml#ch08list11)中的小工具查找器并没有引入任何新的Capstone概念。`main`函数与线性和递归反汇编器中看到的相同，而辅助函数（`is_cs_cflow_group`、`is_cs_cflow_ins`和`is_cs_ret_ins`）也与之前看到的相似。Capstone反汇编函数`cs_disasm_iter`也是之前见过的。关于小工具查找器的有趣之处在于，它使用Capstone以一种标准线性或递归反汇编器无法做到的方式分析二进制文件。所有的小工具查找功能都在函数`find_gadgets`和`find_gadgets_at_root`中实现，所以我们接下来重点讨论它们。'
- en: Scanning for Roots and Mapping Gadgets
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扫描根节点并映射小工具
- en: The `find_gadgets` function is called from `main`, and it starts in a familiar
    way. First, it loads the `.text` section and initializes Capstone in detailed
    disassembly mode. After the initialization, `find_gadgets` loops over each byte
    in `.text` and checks whether it is equal to the value `0xc3`, the opcode for
    an x86 `ret` instruction ➊.^([6](footnote.xhtml#ch08fn_6)) Conceptually, each
    such instruction is a potential “root” for one or more gadgets, which you can
    find by searching backward starting from the root. You can think of all the gadgets
    that end in a particular `ret` instruction as a tree rooted at that `ret` instruction.
    To find all gadgets connected to a particular root, there’s a separate function,
    called `find_gadgets_at_root` (called at ➋), which I’ll discuss shortly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_gadgets`函数是从`main`调用的，它的开始方式非常熟悉。首先，它加载`.text`段，并在详细反汇编模式下初始化Capstone。初始化完成后，`find_gadgets`会遍历`.text`段中的每个字节，检查该字节是否等于`0xc3`，即x86
    `ret`指令的操作码 ➊。^([6](footnote.xhtml#ch08fn_6)) 从概念上讲，每条这样的指令都是一个潜在的“小工具根”，你可以通过从根节点开始向后搜索来找到一个或多个小工具。你可以将所有以特定`ret`指令结尾的小工具看作一棵以该`ret`指令为根的树。为了找到与特定根节点连接的所有小工具，有一个单独的函数，叫做`find_gadgets_at_root`（在
    ➋ 处调用），稍后我会详细讨论。'
- en: All the gadgets are added to a C++ `map` data structure that maps each unique
    gadget (in the form of a `string`) to the set of addresses at which this gadget
    can be found. The actual adding of gadgets to the `map` happens in the `find_gadgets_at_root`
    function. After the gadget search completes, `find_gadgets` prints out the entire
    mapping of gadgets ➌ and then cleans up and returns.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 gadgets 都会被添加到一个 C++ `map` 数据结构中，该结构将每个独特的 gadget（以 `string` 形式）映射到它可以找到的地址集合。实际的
    gadget 添加操作发生在 `find_gadgets_at_root` 函数中。在 gadget 搜索完成后，`find_gadgets` 会打印出所有
    gadgets 的映射 ➌，并随后进行清理并返回。
- en: Finding All Gadgets at a Given Root
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在给定根地址查找所有的 gadgets
- en: As mentioned, the function `find_gadgets_at_root` finds all gadgets that end
    up at a given root instruction. It starts by allocating an instruction buffer,
    which you need when using `cs_disasm_iter`. Then, it enters a loop that searches
    backward from the root instruction, beginning at one byte before the root address
    and decrementing the search address in each loop iteration until it’s 15 × 5 bytes
    from the root ➍. Why 15 × 5? This is because you want gadgets of at most five
    instructions, and since x86 instructions never consist of more than 15 bytes each,
    the furthest you’ll ever need to search backward from any given root is 15 × 5
    bytes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`find_gadgets_at_root` 函数会查找所有最终落在给定根指令上的 gadgets。它首先分配一个指令缓冲区，这是使用 `cs_disasm_iter`
    时所需的。接着，它进入一个循环，开始从根指令的前一个字节向后搜索，每次迭代时搜索地址减小，直到距离根地址 15 × 5 字节远 ➍。为什么是 15 × 5？这是因为你想要的
    gadget 最多包含五条指令，并且由于 x86 指令的长度永远不会超过 15 字节，所以从任何给定的根指令开始，向后搜索的最大距离是 15 × 5 字节。
- en: For every search offset, the gadget finder performs a linear disassembly sweep
    ➎. In contrast to the earlier linear disassembly example, this example uses Capstone’s
    `cs_disasm_iter` function for each disassembly sweep. The reason is that instead
    of disassembling an entire buffer at once, the gadget finder needs to check a
    series of stop conditions after each instruction.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个搜索偏移，gadget 查找器会执行一次线性反汇编扫描 ➎。与之前的线性反汇编示例不同，本示例在每次反汇编扫描时使用了 Capstone 的`cs_disasm_iter`函数。原因是，相比一次性反汇编整个缓冲区，gadget
    查找器需要在每条指令后检查一系列停止条件。
- en: First, it breaks off the linear sweep if it encounters an invalid instruction,
    discarding the gadget and moving on to the next search address, starting a new
    linear sweep from there. Checking for invalid instructions is important since
    gadgets at unaligned offsets are often invalid.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果遇到无效指令，它会中止线性扫描，丢弃当前 gadget，并继续搜索下一个地址，从那里重新开始新的线性扫描。检查无效指令是非常重要的，因为在不对齐的偏移处的
    gadgets 经常是无效的。
- en: The gadget finder also breaks off the disassembly sweep if it hits an instruction
    with an address beyond the root ➏. You may be wondering how it’s possible for
    the disassembly to reach an instruction beyond the root without hitting the root
    itself first. To see an example of this, remember that some of the addresses you
    disassemble are unaligned with respect to the normal instruction stream. This
    means that if you disassemble a multibyte unaligned instruction, the disassembly
    might consume the root instruction as part of the unaligned instruction’s opcode
    or operands so that the root itself never appears in the unaligned instruction
    stream.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 gadegt 查找器遇到一个地址超出根地址的指令，它还会中止反汇编扫描 ➏。你可能会想，为什么反汇编会在没有首先遇到根地址本身的情况下到达根地址以外的指令？为了举例说明，记住你反汇编的一些地址是与正常的指令流不对齐的。这意味着，如果你反汇编一个多字节的不对齐指令，反汇编可能会将根指令作为不对齐指令的操作码或操作数的一部分，因此根指令本身并不会出现在不对齐的指令流中。
- en: Finally, the gadget finder stops disassembling a given gadget if it finds a
    control flow instruction other than a return ➐. After all, gadgets are easier
    to use if they contain no control flow other than the final return instruction.^([7](footnote.xhtml#ch08fn_7))
    The gadget finder also discards gadgets that grow longer than the maximum gadget
    size ➑.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 gadegt 查找器发现了一个除了返回之外的控制流指令 ➐，它会停止反汇编当前的 gadget。毕竟，gadgets 如果除了最后的返回指令外不包含其他控制流，它们会更容易使用。^([7](footnote.xhtml#ch08fn_7))
    gadegt 查找器还会丢弃那些超过最大 gadget 大小的 gadgets ➑。
- en: If none of the stop conditions is true, then the gadget finder appends the newly
    disassembled instruction (`cs_ins`) to a string containing the gadget built up
    so far ➒. When the analysis reaches the root instruction, the gadget is complete
    and is appended to the `map` of gadgets ➓. After considering all possible starting
    points near the root, `find_gadgets_at_root` is done and returns control to the
    main `find_gadgets` function, which then continues with the next root instruction,
    if there are any left.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何停止条件成立，则小工具查找器会将新反汇编的指令（`cs_ins`）附加到目前为止构建的包含小工具的字符串中➒。当分析到达根指令时，小工具就完成了，并被附加到小工具的`map`中➓。在考虑完所有可能的根指令附近的起始点后，`find_gadgets_at_root`完成并将控制权交回主`find_gadgets`函数，之后如果还有剩余的根指令，程序会继续处理。
- en: Running the Gadget Finder
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行小工具查找器
- en: The command line interface for the gadget finder is the same as for the disassembly
    tools. [Listing 8-12](ch08.xhtml#ch08list12) shows what the output should look
    like.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 小工具查找器的命令行接口与反汇编工具相同。[列表 8-12](ch08.xhtml#ch08list12)显示了输出应该是什么样的。
- en: '*Listing 8-12: Example output of the ROP scanner*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-12: ROP扫描器的示例输出*'
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each line of output shows a gadget string, followed by the addresses where this
    gadget is found. For instance, there’s an `add al, ch; ret` gadget at address
    `0x406697`, which you could use in a ROP payload to add the `al` and `ch` registers
    together. Having an overview of the available gadgets like this helps a lot in
    selecting suitable ROP gadgets to use when crafting a ROP payload for use in an
    exploit.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每行输出显示一个小工具字符串，后跟此小工具所在的地址。例如，地址`0x406697`处有一个`add al, ch; ret`的小工具，您可以在ROP有效载荷中使用它来将`al`和`ch`寄存器相加。像这样概览可用的小工具有助于在为利用漏洞制作ROP有效载荷时选择合适的ROP小工具。
- en: 8.4 Summary
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4 总结
- en: You should now feel comfortable using Capstone to start building your own custom
    disassemblers. All the examples in this chapter are present on the virtual machine
    included with this book. Playing around with them is a good starting point for
    gaining fluency with the Capstone API. Use the following exercises and challenges
    to put your custom disassembly skills to the test!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够熟练使用Capstone来开始构建你自己的自定义反汇编器。本章中的所有示例都包含在本书附带的虚拟机中。玩弄这些示例是掌握Capstone
    API的一个好起点。通过以下练习和挑战来检验你的自定义反汇编技能！
- en: Exercises
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 1\. Generalizing the Disassembler
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 泛化反汇编器
- en: All the disassembly tools you saw in this chapter configured Capstone to disassemble
    x64 code only. You did this by passing `CS_ARCH_X86` and `CS_MODE_64` as the architecture
    and mode arguments to `cs_open`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中您看到的所有反汇编工具都配置了Capstone，仅用于反汇编x64代码。你通过将`CS_ARCH_X86`和`CS_MODE_64`作为架构和模式参数传递给`cs_open`来实现这一点。
- en: Let’s generalize these tools to automatically select the proper Capstone parameters
    to deal with other architectures by checking the type of the loaded binary using
    the `arch` and `bits` fields in the `Binary` class that the loader provides. To
    figure out which architecture and mode arguments to pass to Capstone, remember
    that */usr/include/capstone/capstone.h* contains lists of all possible `cs_arch`
    and `cs_mode` values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些工具泛化，使其能够通过检查加载的二进制文件中的`arch`和`bits`字段，自动选择适合其他架构的Capstone参数。这些字段由加载器提供。要弄清楚应该传递给Capstone的架构和模式参数，请记住，*/usr/include/capstone/capstone.h*文件中包含了所有可能的`cs_arch`和`cs_mode`值的列表。
- en: 2\. Explicit Detection of Overlapping Blocks
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 显式检测重叠块
- en: Although the example recursive disassembler can deal with overlapping basic
    blocks, it doesn’t give any explicit warning when there is overlapping code. Extend
    the disassembler to inform the user which blocks overlap.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管示例中的递归反汇编器能够处理重叠的基本块，但它在遇到重叠代码时并不会给出任何显式警告。扩展反汇编器以通知用户哪些块是重叠的。
- en: 3\. Cross-Variant Gadget Finder
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 跨变体小工具查找器
- en: When compiling a program from source, the resulting binary can differ significantly
    depending on factors such as the compiler version, compilation options, or target
    architecture. In addition, randomization strategies that harden binaries against
    exploitation by changing register allocations or shuffling code around complicate
    the exploit process. This means that when developing an exploit (such as a ROP
    exploit), you won’t always know which binary “variant” of a program is running
    on the target. For instance, is the target server compiled with `gcc` or `llvm`?
    Is it running on 32-bit or 64-bit? If you guess wrong, your exploit will likely
    fail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码编译程序时，生成的二进制文件可能会因为编译器版本、编译选项或目标架构等因素而有所不同。此外，防止二进制文件被利用的随机化策略（例如通过改变寄存器分配或打乱代码顺序）使得漏洞利用过程更加复杂。这意味着，在开发漏洞利用工具（例如ROP漏洞利用）时，你并不总是能够知道目标上运行的是哪种“变体”的程序。例如，目标服务器是用`gcc`还是`llvm`编译的？它是运行在32位还是64位架构上？如果猜错了，你的漏洞利用可能会失败。
- en: In this exercise, your goal is to expand the ROP gadget finder to take two or
    more binaries as input, representing different variants of the same program. It
    should output a list of VMAs that contain usable gadgets in *all* of the variants.
    Your new gadget finder should be able to scan each of the input binaries for gadgets
    but output only those addresses where all binaries contain a gadget, not just
    some of the binaries. For each reported VMA, the gadgets should also implement
    similar operations. For instance, they’ll contain an `add` instruction or a `mov`.
    Implementing a usable notion of similarity will be part of the challenge. The
    end result should be a cross-variant gadget finder that can be used to develop
    exploits that simultaneously work on multiple variants of the same program!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你的目标是扩展 ROP gadget 查找器，使其能够接受两个或更多的二进制文件作为输入，这些二进制文件代表同一程序的不同变体。它应当输出一个包含所有变体中都可以使用的
    gadget 的 VMA 列表。你的新 gadget 查找器应该能够扫描每个输入的二进制文件来查找 gadgets，但只输出那些所有二进制文件都包含 gadget
    的地址，而不仅仅是某些二进制文件包含的地址。对于每个报告的 VMA，这些 gadgets 还应当执行类似的操作。例如，它们将包含 `add` 指令或 `mov`
    指令。实现可用的相似性概念将是一个挑战。最终的结果应该是一个跨变体的 gadget 查找器，能够用于开发可以同时在同一程序的多个变体上工作的漏洞利用工具！
- en: To test your gadget finder, you can create variants of a program of your choice
    by compiling it multiple times with different compilation options or different
    compilers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的 gadget 查找器，你可以通过多次使用不同的编译选项或不同的编译器来编译自己选择的程序，生成该程序的不同变体。
