- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: CUSTOMIZING DISASSEMBLY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义反汇编
- en: So far, I’ve discussed basic binary analysis and disassembly techniques. But
    these basic techniques aren’t designed to handle obfuscated binaries that break
    standard disassembler assumptions or special-purpose analyses such as vulnerability
    scanning. Sometimes, even the scripting functionality offered by disassemblers
    isn’t enough to remedy this. In such cases, you can build your own specialized
    disassembly engine tailored to your needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经讨论了基本的二进制分析和反汇编技术。但是，这些基本技术并不是为了解决那些打破标准反汇编假设的混淆二进制文件，或者像漏洞扫描这样的特殊分析设计的。有时候，即使是反汇编工具提供的脚本功能也不足以解决这些问题。在这种情况下，你可以构建一个专门的反汇编引擎，量身定制，满足你的需求。
- en: In this chapter, you’ll learn how to implement a custom disassembler with *Capstone*,
    a disassembly framework that gives you full control over the entire analysis process.
    You’ll begin by exploring the Capstone API, using it to build a custom linear
    disassembler and a recursive disassembler. You’ll then learn to implement a more
    advanced tool, namely a *Return-Oriented Programming (ROP)* gadget scanner that
    you can use to build ROP exploits.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用*Capstone*实现一个自定义反汇编器，*Capstone*是一个反汇编框架，能够让你完全控制整个分析过程。你将首先探索Capstone
    API，使用它构建一个自定义的线性反汇编器和递归反汇编器。接着，你将学习如何实现一个更先进的工具，即*返回导向编程（ROP）*小工具扫描器，利用它构建ROP利用攻击。
- en: 8.1 Why Write a Custom Disassembly Pass?
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1 为什么要编写自定义反汇编模块？
- en: Most well-known disassemblers such as IDA Pro are designed to aid manual reverse
    engineering. These are powerful disassembly engines that offer an extensive graphical
    interface, a myriad of options to visualize the disassembled code, and convenient
    ways to navigate through large piles of assembly instructions. When your goal
    is just to understand what a binary does, a general-purpose disassembler works
    fine, but general-purpose tools lack the flexibility needed for advanced automated
    analysis. While many disassemblers come with scripting functionality for postprocessing
    the disassembled code, they don’t provide options for tweaking the disassembly
    process itself, and they aren’t meant for efficient batch processing of binaries.
    So when you want to perform a specialized, automated binary analysis of multiple
    binaries simultaneously, you’ll need a custom disassembler.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数著名的反汇编工具，如IDA Pro，旨在帮助手动逆向工程。这些是强大的反汇编引擎，提供了广泛的图形界面，丰富的选项来可视化反汇编的代码，以及方便的方式来浏览大量汇编指令。当你的目标仅仅是理解一个二进制文件的功能时，通用反汇编工具足够使用，但通用工具缺乏进行高级自动化分析所需的灵活性。虽然许多反汇编工具提供了用于后处理反汇编代码的脚本功能，但它们并不提供调整反汇编过程本身的选项，也不适用于高效批量处理二进制文件。因此，当你希望对多个二进制文件进行专门的自动化分析时，你将需要一个自定义反汇编器。
- en: '*8.1.1 A Case for Custom Disassembly: Obfuscated Code*'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.1.1 自定义反汇编的应用案例：混淆代码*'
- en: A custom disassembly pass is useful when you need to analyze binaries that break
    standard disassembler assumptions, such as malware, obfuscated or handcrafted
    binaries, or binaries extracted from memory dumps or firmware. Moreover, custom
    disassembly passes allow you to easily implement specialized binary analyses that
    scan for specific artifacts, such as code patterns that indicate possible vulnerabilities.
    They’re also useful as research tools, allowing you to experiment with novel disassembly
    techniques.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要分析那些打破标准反汇编假设的二进制文件时，比如恶意软件、混淆的或手工制作的二进制文件，或者从内存转储或固件中提取的二进制文件时，自定义反汇编模块就非常有用。此外，自定义反汇编模块还允许你轻松实现专门的二进制分析，如扫描特定的伪迹象，例如指示可能存在漏洞的代码模式。它们还可以作为研究工具，帮助你尝试新的反汇编技术。
- en: As a first concrete use case for custom disassembly, let’s consider a particular
    type of code obfuscation that uses *instruction overlapping*. Most disassemblers
    output a single disassembly listing per binary because the assumption is that
    each byte in a binary is mapped to at most one instruction, each instruction is
    contained in a single basic block, and each basic block is part of a single function.
    In other words, disassemblers typically assume that chunks of code don’t overlap
    with each other. Instruction overlapping breaks this assumption to confuse disassemblers,
    making the overlapping code more difficult to reverse engineer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为定制反汇编的第一个具体应用案例，我们来考虑一种特定类型的代码混淆，它使用 *指令重叠*。大多数反汇编工具会为每个二进制文件输出一份单一的反汇编列表，因为它们假设二进制文件中的每个字节至多对应一条指令，每条指令都包含在一个单独的基本块中，而每个基本块都是某个函数的一部分。换句话说，反汇编工具通常假设代码块之间不会互相重叠。指令重叠打破了这个假设，迷惑了反汇编工具，使得重叠的代码更难以进行逆向工程。
- en: Instruction overlapping works because instructions on the x86 platform vary
    in length. Unlike some other platforms, such as ARM, not all x86 instructions
    consist of the same number of bytes. As a result, the processor doesn’t enforce
    any particular instruction alignment in memory, making it possible for one instruction
    to occupy a set of code addresses already occupied by another instruction. This
    means that on x86, you can start disassembling from the middle of one instruction,
    and the disassembly will yield *another* instruction that partially (or completely)
    overlaps with the first instruction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 指令重叠之所以可行，是因为 x86 平台上的指令长度各不相同。与其他一些平台（如 ARM）不同，并非所有 x86 指令都由相同数量的字节组成。因此，处理器不会强制要求指令在内存中的特定对齐方式，这使得一条指令有可能占用已经被另一条指令占用的代码地址。这意味着，在
    x86 上，你可以从某条指令的中间开始反汇编，而反汇编的结果将会是与第一条指令部分（或完全）重叠的 *另一* 条指令。
- en: Obfuscators happily abuse overlapping instructions to confuse disassemblers.
    Instruction overlapping is especially easy on x86 because the x86 instruction
    set is extremely dense, meaning that nearly any byte sequence corresponds to some
    valid instruction.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆器乐于滥用指令重叠来迷惑反汇编工具。指令重叠在 x86 上尤其容易实现，因为 x86 指令集极为紧凑，这意味着几乎任何字节序列都对应着某条有效的指令。
- en: '[Listing 8-1](ch08.xhtml#ch08list1) shows an example of instruction overlapping.
    You can find the original source that produced this listing in *overlapping_bb.c*.
    To disassemble overlapping code, you can use `objdump`’s `-start-address=<addr>`
    flag to start disassembling at the given address.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-1](ch08.xhtml#ch08list1) 展示了一个指令重叠的示例。你可以在 *overlapping_bb.c* 中找到产生此列表的原始源代码。要反汇编重叠的代码，你可以使用
    `objdump` 的 `-start-address=<addr>` 标志，从给定地址开始反汇编。'
- en: '*Listing 8-1: Disassembly of* overlapping_bb *(1)*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-1：重叠_bb 的反汇编（1）*'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Listing 8-1](ch08.xhtml#ch08list1) shows a simple function that takes one
    input parameter, which is called `i` ➊, and has a local variable called `j` ➋.
    After some computation, the function returns `j`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-1](ch08.xhtml#ch08list1) 展示了一个简单的函数，它接受一个输入参数，称为 `i` ➊，并有一个局部变量 `j` ➋。经过一些计算后，函数返回
    `j`。'
- en: 'Upon closer inspection, you should notice something odd: the `jne` instruction
    at address `40060a` ➌ conditionally jumps into the *middle* of the instruction
    starting at `400610` instead of continuing at the *start* of any of the listed
    instructions! Most disassemblers like `objdump` and IDA Pro only disassemble the
    instructions shown in [Listing 8-1](ch08.xhtml#ch08list1). This means that general-purpose
    disassemblers would miss the overlapping instruction at address `400612` because
    those bytes are already occupied by the instruction reached in the fall-through
    case of the `jne`. This kind of overlapping makes it possible to hide code paths
    that can have a drastic effect on the overall outcome of a program. For example,
    consider the following case.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你应该会注意到一些奇怪的地方：地址 `40060a` ➌ 处的 `jne` 指令条件跳转到指令 `400610` 开始的 *中间* 部分，而不是继续执行任何列出指令的
    *开始*！大多数反汇编工具，如 `objdump` 和 IDA Pro，只会反汇编 [列表 8-1](ch08.xhtml#ch08list1) 中显示的指令。这意味着通用反汇编工具会错过地址
    `400612` 处的重叠指令，因为这些字节已经被 `jne` 指令的 fall-through 跳转所占用。这种指令重叠使得隐藏对程序整体结果有重大影响的代码路径成为可能。例如，考虑以下情况。
- en: In [Listing 8-1](ch08.xhtml#ch08list1), if the jump at address `40060a` is not
    taken (`i == 0`), the instructions reached by the fall-through case compute and
    return the value `148` ➍. However, if the jump *is* taken (`i != 0`), the code
    path that was hidden in [Listing 8-1](ch08.xhtml#ch08list1) executes. Let’s look
    at [Listing 8-2](ch08.xhtml#ch08list2), which shows that hidden code path, to
    see how this returns an entirely different value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 8-1](ch08.xhtml#ch08list1) 中，如果地址 `40060a` 处的跳转没有被执行（`i == 0`），穿透情况到达的指令会计算并返回值
    `148` ➍。然而，如果跳转*被*执行（`i != 0`），那么在 [清单 8-1](ch08.xhtml#ch08list1) 中隐藏的代码路径会被执行。我们来看看
    [清单 8-2](ch08.xhtml#ch08list2)，它展示了这个隐藏的代码路径，看看它是如何返回完全不同的值的。
- en: '*Listing 8-2: Disassembly of* overlapping_bb *(2)*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-2：重叠基本块的反汇编（2）*'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Listing 8-2](ch08.xhtml#ch08list2) shows the code path that executes if the
    `jne` instruction ➊ is taken. In that case, it jumps over two bytes (`400610`
    and `400611`) to address `0x400612` ➋, which is in the middle of the `xor` instruction
    reached in the fall-through case of the `jne`. This results in a different instruction
    stream. In particular, the arithmetic operations done on `j` are now different,
    causing the function to return `i + 4` ➌ instead of `148`. As you can imagine,
    this sort of obfuscation makes the code hard to understand, especially if the
    obfuscation is applied in more than one place.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-2](ch08.xhtml#ch08list2) 显示了如果执行 `jne` 指令 ➊ 的代码路径。在这种情况下，它跳过两个字节（`400610`
    和 `400611`），跳转到地址 `0x400612` ➋，这是 `xor` 指令的中间部分，这个指令出现在 `jne` 的穿透情况中。这会导致不同的指令流。特别是，`j`
    上进行的算术运算现在不同，导致函数返回 `i + 4` ➌ 而不是 `148`。正如你能想象的那样，这种混淆使得代码难以理解，特别是当这种混淆在多个地方应用时。'
- en: You can usually coax disassemblers into revealing hidden instructions by restarting
    disassembly at a different offset, as I’ve done with `objdump`’s `-start-address`
    flag in the previous listings. As you can see in [Listing 8-2](ch08.xhtml#ch08list2),
    restarting the disassembly at address `400612` reveals the instruction hidden
    there. However, doing that causes the instruction at address `400610` to become
    hidden instead. Some obfuscated programs are riddled with overlapping code sequences
    like the one shown in this example, making the code extremely tedious and difficult
    to investigate manually.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过在不同的偏移量重新启动反汇编来诱使反汇编器揭示隐藏的指令，就像我在前面的清单中使用 `objdump` 的 `-start-address`
    标志所做的那样。如 [清单 8-2](ch08.xhtml#ch08list2) 所示，在地址 `400612` 重新启动反汇编可以揭示隐藏在那里的指令。然而，这样做会导致地址
    `400610` 处的指令变得隐藏。某些混淆程序充斥着像这个例子中展示的重叠代码序列，使得代码非常繁琐，且手动调查时十分困难。
- en: The example of [Listings 8-1](ch08.xhtml#ch08list1) and [8-2](ch08.xhtml#ch08list2)
    shows that building a specialized deobfuscation tool that automatically “untangles”
    overlapping instructions can make reverse engineering much easier. Especially
    if you need to reverse obfuscated binaries often, the effort to build a deobfuscation
    tool pays off in the long run.^([1](footnote.xhtml#ch08fn_1)) Later in this chapter,
    you’ll learn how to build a recursive disassembler that can deal with overlapping
    basic blocks like the ones shown in the previous listings.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.xhtml#ch08list1) 和 [8-2](ch08.xhtml#ch08list2) 的示例表明，构建一个专门的去混淆工具，可以自动“解开”重叠指令，这可以大大简化逆向工程。特别是如果你经常需要逆向混淆的二进制文件，那么构建去混淆工具的努力在长远来看是值得的。^([1](footnote.xhtml#ch08fn_1))
    本章后续内容中，你将学习如何构建一个递归反汇编器，它能够处理像前面清单所示的重叠基本块。'
- en: Overlapping Code in Nonobfuscated Binaries
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 非混淆二进制文件中的重叠代码
- en: It’s interesting to note that overlapping instructions occur not only in deliberately
    obfuscated code but also in highly optimized code that contains handwritten assembly.
    Admittedly, the second case is both easier to deal with and a lot less common.
    The following listing shows an overlapping instruction from `glibc` 2.22.^(*a*)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，重叠指令不仅发生在故意混淆的代码中，还出现在包含手写汇编的高度优化代码中。诚然，第二种情况更容易处理，而且出现的频率也要低得多。以下清单展示了来自
    `glibc` 2.22 的重叠指令。^(*a*)
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Depending on the result of the `cmp` instruction, the `je` either jumps to address
    `7b066` or falls through to address `7b065`. The only difference is that the latter
    address corresponds to a `lock cmpxchg` instruction, while the former corresponds
    to a `cmpxchg`. In other words, the conditional jump is used to choose between
    a locked and nonlocked variant of the same instruction by optionally jumping over
    a `lock` prefix byte.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `cmp` 指令的结果，`je` 指令要么跳转到地址 `7b066`，要么继续执行到地址 `7b065`。唯一的区别是，后者地址对应一个 `lock
    cmpxchg` 指令，而前者对应一个 `cmpxchg`。换句话说，条件跳转用于在同一指令的锁定和非锁定变种之间进行选择，通过选择性跳过一个 `lock`
    前缀字节。
- en: '*a*. `glibc` is the GNU C library. It’s used in virtually all C programs compiled
    on GNU/Linux platforms and is therefore heavily optimized.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*. `glibc` 是 GNU C 库。它几乎在所有在 GNU/Linux 平台上编译的 C 程序中都会使用，因此经过了大量的优化。'
- en: '*8.1.2 Other Reasons to Write a Custom Disassembler*'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.1.2 编写自定义反汇编器的其他原因*'
- en: Obfuscated code isn’t the only reason to build a custom disassembly pass. In
    general, customization is useful in any situation where you need full control
    over the disassembly process. As I mentioned earlier, those situations occur when
    you’re analyzing obfuscated or otherwise special binaries or when you need to
    perform specialized analyses that general-purpose disassemblers aren’t designed
    for.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆代码并不是构建自定义反汇编流程的唯一原因。一般来说，定制化在你需要完全控制反汇编过程的任何情况下都非常有用。正如我之前提到的，那些情况通常出现在你分析混淆的或其他特殊的二进制文件时，或者当你需要进行通用反汇编工具不支持的专业分析时。
- en: Later in this chapter, you’ll see an example that uses custom disassembly to
    build a ROP gadget scanner, which requires disassembling the binary from multiple
    starting offsets, an operation not readily supported by most disassemblers. ROP
    gadget scanning involves finding every possible code sequence in a binary, including
    unaligned ones, that could be used in a ROP exploit.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，你将看到一个示例，展示如何使用自定义反汇编来构建 ROP gadget 扫描器，这需要从多个起始偏移量反汇编二进制文件，而大多数反汇编器并不直接支持这种操作。ROP
    gadget 扫描涉及在二进制文件中查找每一个可能的代码序列，包括未对齐的代码序列，这些序列可以在 ROP 利用中使用。
- en: Conversely, sometimes you’ll want to omit some code paths from the disassembly
    rather than find every possible code sequence. For instance, this is useful when
    you want to ignore bogus paths created by an obfuscator^([2](footnote.xhtml#ch08fn_2))
    or build a hybrid static-dynamic analysis and focus your disassembly on specific
    paths that you’ve already explored dynamically.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，有时你可能会想从反汇编中省略某些代码路径，而不是查找每一个可能的代码序列。例如，这在你希望忽略混淆器创建的虚假路径^([2](footnote.xhtml#ch08fn_2))，或者构建一个混合静态-动态分析并将反汇编集中在你已经动态探索过的特定路径时非常有用。
- en: There are also cases when building a custom disassembly tool may not be needed
    strictly for technical reasons, but you may choose to do so anyway for the sake
    of improving efficiency or reducing cost. For instance, automated binary analysis
    tools often require only very basic disassembly functionality. The toughest part
    of their job is the custom analysis of the disassembled instructions, and this
    step doesn’t require the extensive user interfaces or conveniences that automated
    disassemblers have. In such cases, you can choose to build your own custom tools
    using only free open source disassembly libraries, rather than depend on large,
    commercial disassemblers that can cost up to thousands of dollars.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些情况，构建自定义反汇编工具可能并非出于技术上的必要，而是为了提高效率或降低成本。例如，自动化二进制分析工具通常只需要非常基础的反汇编功能。它们最艰难的部分是自定义分析反汇编后的指令，而这一步并不需要像自动反汇编器那样提供复杂的用户界面或便利功能。在这种情况下，你可以选择使用免费的开源反汇编库来构建自己的自定义工具，而不是依赖那些可能昂贵的商业反汇编器，后者的费用可能高达数千美元。
- en: 'Another reason for building a custom disassembler is efficiency. Scripting
    in standard disassemblers typically requires at least two passes over the code:
    one for the initial disassembly and another for the postprocessing done by the
    script. Also, those scripts are typically written in a high-level language (such
    as Python), which yields relatively poor runtime performance. This means that
    when doing complex analysis on many large binaries, you can often greatly improve
    performance by building a tool that can run natively and do all necessary analysis
    in one pass.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自定义反汇编器的另一个原因是效率。标准反汇编器中的脚本通常需要对代码进行至少两次遍历：一次用于初始的反汇编，另一次用于脚本进行的后处理。此外，这些脚本通常是用高级语言（如Python）编写的，这导致了相对较差的运行时性能。这意味着，在对许多大型二进制文件进行复杂分析时，构建一个能够原生运行并在一次遍历中完成所有必要分析的工具，往往能大大提高性能。
- en: Now that you’ve seen why custom disassembly is useful, let’s take a look at
    how to do it! I’ll start with a brief introduction to *Capstone*, one of the most
    popular libraries for building custom disassembly tools.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了自定义反汇编的有用性，让我们看看如何进行！我将从简要介绍*Capstone*开始，它是构建自定义反汇编工具最流行的库之一。
- en: 8.2 Introduction to Capstone
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2 Capstone简介
- en: Capstone is a disassembly framework designed to provide a simple, lightweight
    API that transparently handles most popular instruction architectures, including
    x86/x86-64, ARM, and MIPS, among others. It has bindings for C/C++ and Python
    (plus other languages, but we’ll use C/C++ as usual) and runs on all popular platforms,
    including Windows, Linux, and macOS. It’s also completely free and open source.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Capstone 是一个反汇编框架，旨在提供一个简单、轻量级的API，能够透明地处理大多数流行的指令架构，包括x86/x86-64、ARM、MIPS等。它为C/C++和Python（以及其他语言，虽然我们将像往常一样使用C/C++）提供了绑定，并支持所有流行平台，包括Windows、Linux和macOS。它也是完全免费的，且开源。
- en: Building disassembly tools with Capstone is a straightforward process, with
    extremely versatile possibilities. Although the API is centered around just a
    few functions and data structures, it doesn’t sacrifice usability for simplicity.
    With Capstone, you can easily recover virtually all relevant details of disassembled
    instructions, including instruction opcodes, mnemonics, class, registers read
    and written by the instruction, and more. The best way to learn Capstone is through
    example, so let’s dive right in.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Capstone构建反汇编工具是一个直接的过程，具有极其多样的可能性。尽管API主要围绕几个函数和数据结构构建，但它并没有为了简洁而牺牲可用性。使用Capstone，你可以轻松地恢复反汇编指令的几乎所有相关细节，包括指令操作码、助记符、类别、指令读取和写入的寄存器等。学习Capstone的最好方式是通过实例，因此让我们直接开始。
- en: '*8.2.1 Installing Capstone*'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.2.1 安装Capstone*'
- en: Capstone v3.0.5 is preinstalled on the virtual machine supplied with this book.
    If you want to try Capstone on another machine, installing it is quite straightforward.
    The Capstone website^([3](footnote.xhtml#ch08fn_3)) provides ready-made packages
    for Windows and Ubuntu, among others, and there is a source archive for installing
    Capstone on other platforms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Capstone v3.0.5 已预安装在本书随附的虚拟机中。如果你想在其他机器上尝试 Capstone，安装过程相当简单。Capstone 网站^([3](footnote.xhtml#ch08fn_3))提供了适用于Windows和Ubuntu等操作系统的现成软件包，并且提供了一个源代码档案，供在其他平台上安装Capstone。
- en: 'As usual, we’ll write our Capstone-based tools in C/C++, but for quick experiments,
    you may also want to explore Capstone using Python. For this, you’ll need the
    Capstone Python bindings. These are also preinstalled on the virtual machine,
    but installing them on your own machine is easy if you have the `pip` Python package
    manager. Make sure you already have the Capstone core package and then enter the
    following into your command prompt to install the Capstone Python bindings:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将使用C/C++编写基于Capstone的工具，但对于快速实验，你也可以使用Python来探索Capstone。为此，你需要Capstone的Python绑定。这些绑定也已预安装在虚拟机中，但如果你有`pip`
    Python包管理器，在你自己的机器上安装它们也非常简单。确保你已经安装了Capstone核心包，然后在命令提示符中输入以下内容来安装Capstone Python绑定：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once you have the Python bindings, you can start a Python interpreter and begin
    your own disassembly experiments in Python, as shown in [Listing 8-3](ch08.xhtml#ch08list3).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了Python绑定，你就可以启动Python解释器并开始自己的反汇编实验，如[Listing 8-3](ch08.xhtml#ch08list3)所示。
- en: '*Listing 8-3: Exploring the Python Capstone bindings*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-3: 探索Python Capstone绑定*'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example imports the `capstone` package and uses Python’s built-in `help`
    command to explore Capstone ➊. The class that provides the main functionality
    is `capstone.Cs` ➋. Most important, it provides access to Capstone’s `disasm`
    function, which disassembles a code buffer and returns the disassembly result
    to you. To explore the remaining functionality offered by Capstone’s Python bindings,
    use Python’s built-in `help` and `dir` commands! In the rest of this chapter,
    I’ll focus on building Capstone tools with C/C++, but the API closely resembles
    Capstone’s Python API.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例导入了`capstone`包，并使用Python内置的`help`命令来探索Capstone ➊。提供主要功能的类是`capstone.Cs`
    ➋。最重要的是，它提供了访问Capstone的`disasm`函数的功能，该函数将代码缓冲区反汇编并返回反汇编结果。要探索Capstone的Python绑定提供的其他功能，可以使用Python内置的`help`和`dir`命令！在本章的其余部分，我将重点介绍使用C/C++构建Capstone工具，但该API与Capstone的Python
    API非常相似。
- en: '*8.2.2 Linear Disassembly with Capstone*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8.2.2 使用Capstone进行线性反汇编*'
- en: From a high-level perspective, Capstone takes a memory buffer containing a block
    of code bytes as an input and outputs instructions disassembled from those bytes.
    The most basic way to use Capstone is to feed it a buffer containing all the code
    bytes in the `.text` section of a given binary and then linearly disassemble those
    instructions into a human-readable form, or instruction mnemonics. Aside from
    some initialization and output-parsing code, Capstone allows you to implement
    this mode of usage using only a single API call to the `cs_disasm` function. The
    example in [Listing 8-4](ch08.xhtml#ch08list4) implements a simple `objdump`-like
    tool. To load a binary into a block of bytes that Capstone can use, we’ll reuse
    the `libbfd`-based binary loader (*loader.h*) implemented in [Chapter 4](ch04.xhtml#ch04).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，Capstone将包含一段代码字节的内存缓冲区作为输入，并输出从这些字节中反汇编的指令。使用Capstone的最基本方法是将包含给定二进制`.text`部分的所有代码字节的缓冲区传递给它，然后将这些指令线性地反汇编成可读的形式，或者指令助记符。除了初始化和输出解析代码外，Capstone只需通过调用`cs_disasm`函数即可实现此用法模式。[示例
    8-4](ch08.xhtml#ch08list4)中的示例实现了一个类似`objdump`的简单工具。为了将二进制文件加载到Capstone可以使用的字节块中，我们将重用[第4章](ch04.xhtml#ch04)中实现的基于`libbfd`的二进制加载器（*loader.h*）。
- en: '*Listing 8-4:* basic_capstone_linear.cc'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-4:* basic_capstone_linear.cc'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That’s all you need to implement a simple linear disassembler! Note the line
    at the top of the source that says `#include <capstone/capstone.h>`. To use Capstone
    in a C program, it’s enough to include this header file and link the program with
    the Capstone library using the `-lcapstone` linker flag. All other Capstone header
    files are `#include`’d from *capstone.h*, so you never need to `#include` them
    manually. With that covered, let’s walk through the rest of the source in [Listing
    8-4](ch08.xhtml#ch08list4).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实现一个简单线性反汇编器所需的全部！注意源代码顶部的一行：`#include <capstone/capstone.h>`。要在C程序中使用Capstone，只需包含这个头文件，并使用`-lcapstone`链接器标志将程序与Capstone库链接。所有其他Capstone头文件都从*capstone.h*中`#include`，因此你不需要手动`#include`它们。覆盖了这些内容后，我们一起浏览[示例
    8-4](ch08.xhtml#ch08list4)中的剩余源代码。
- en: Initializing Capstone
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化Capstone
- en: 'Let’s start with the `main` function, which expects a single command line argument:
    the name of a binary to disassemble. The `main` function passes the name of this
    binary to the `load_binary` function (implemented in [Chapter 4](ch04.xhtml#ch04)),
    which loads the binary into a `Binary` object called `bin` ➊. Then `main` passes
    `bin` to the `disasm` function ➋, waits for it to complete, and finally cleans
    up by unloading the binary. As you may have guessed, all the actual disassembly
    work is done in the `disasm` function.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`main`函数开始，它期望一个命令行参数：要反汇编的二进制文件的名称。`main`函数将此二进制文件的名称传递给`load_binary`函数（在[第4章](ch04.xhtml#ch04)中实现），该函数将二进制文件加载到一个名为`bin`的`Binary`对象中
    ➊。然后，`main`将`bin`传递给`disasm`函数 ➋，等待它完成，最后通过卸载二进制文件来进行清理。正如你可能猜到的，所有实际的反汇编工作都在`disasm`函数中完成。
- en: To disassemble the `.text` section of the given binary, `disasm` begins by calling
    `bin->get_text_section()` to get a pointer to a `Section` object representing
    the `.text` section. So far, this should be familiar from [Chapter 4](ch04.xhtml#ch04).
    Now let’s get to some actual Capstone code!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反汇编给定二进制文件的`.text`部分，`disasm`首先通过调用`bin->get_text_section()`来获取指向表示`.text`部分的`Section`对象的指针。到目前为止，这部分应该在[第4章](ch04.xhtml#ch04)中已经很熟悉了。现在让我们来看看一些实际的Capstone代码！
- en: The first Capstone function called by `disasm` is typical in any program that
    uses Capstone. It’s called `cs_open`, and its purpose is to open a properly configured
    Capstone instance ➌. In this case, a properly configured instance is one that’s
    set up to disassemble `x86-64` code. The first parameter you pass to `cs_open`
    is a constant called `CS_ARCH_X86`, informing Capstone that you want to disassemble
    code for the x86 architecture. More specifically, you tell Capstone that the code
    will be 64-bit by passing `CS_MODE_64` as the second parameter. Finally, the third
    parameter is a pointer to an object of type `csh` (short for “Capstone handle”).
    This pointer is called `dis`. After `cs_open` completes successfully, this handle
    represents a fully configured Capstone instance, which you’ll need to invoke any
    of the other Capstone API functions. If the initialization is successful, `cs_open`
    returns `CS_ERR_OK`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`disasm` 调用的第一个 Capstone 函数是任何使用 Capstone 的程序中的典型函数。它叫做 `cs_open`，其目的是打开一个正确配置的
    Capstone 实例 ➌。在本例中，一个正确配置的实例是指设置为反汇编 `x86-64` 代码的实例。你传递给 `cs_open` 的第一个参数是一个常量
    `CS_ARCH_X86`，告诉 Capstone 你想要反汇编 x86 架构的代码。更具体地说，你通过传递 `CS_MODE_64` 作为第二个参数，告诉
    Capstone 代码将是 64 位的。最后，第三个参数是一个指向类型为 `csh`（即“Capstone 句柄”）的对象的指针。这个指针被称为 `dis`。在
    `cs_open` 成功完成后，这个句柄表示一个完全配置好的 Capstone 实例，你将需要它来调用任何其他 Capstone API 函数。如果初始化成功，`cs_open`
    返回 `CS_ERR_OK`。'
- en: Disassembling a Code Buffer
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反汇编代码缓冲区
- en: Now that you have a Capstone handle and a loaded code section at your disposal,
    you can start disassembling! This takes only a single call to the `cs_disasm`
    function ➍.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了一个 Capstone 句柄和加载的代码段，可以开始反汇编了！这只需要调用一次 `cs_disasm` 函数 ➍。
- en: The first parameter to this call is `dis`, which is your Capstone handle. Next,
    `cs_disasm` expects a buffer (specifically, a `const uint8_t*`) containing the
    code to disassemble, a `size_t` integer indicating the number of code bytes in
    the buffer, and a `uint64_t` indicating the virtual memory address (VMA) of the
    first byte in the buffer. The code buffer and related values are all conveniently
    preloaded in the `Section` object representing the `.text` section of the loaded
    binary.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该调用的第一个参数是 `dis`，也就是你的 Capstone 句柄。接下来，`cs_disasm` 期望一个缓冲区（具体来说是 `const uint8_t*`）来存放待反汇编的代码，一个
    `size_t` 整数表示缓冲区中代码字节的数量，以及一个 `uint64_t` 表示缓冲区中第一个字节的虚拟内存地址（VMA）。代码缓冲区及相关值都方便地预加载在代表加载的二进制文件
    `.text` 部分的 `Section` 对象中。
- en: The final two parameters to `cs_disasm` are a `size_t`, which indicates the
    number of instructions to disassemble (here it’s 0 to disassemble as many as possible)
    and a pointer to a Capstone instruction buffer (`cs_insn**`). This final parameter
    deserves special attention because the `cs_insn` type plays a central role in
    Capstone-based applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs_disasm` 的最后两个参数是一个 `size_t`，用于指示要反汇编的指令数（这里是 0，表示尽可能多地反汇编）以及一个指向 Capstone
    指令缓冲区（`cs_insn**`）的指针。这个最后的参数需要特别注意，因为 `cs_insn` 类型在基于 Capstone 的应用程序中扮演着核心角色。'
- en: The cs_insn Structure
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cs_insn` 结构体'
- en: As you can see in the example code, the `disasm` function contains a local variable
    of type `cs_insn*`, called `insns`. The address of `insns` is used as the final
    parameter for the call to `cs_disasm` at ➍. While disassembling a code buffer,
    `cs_disasm` builds up an array of disassembled instructions. At the end of the
    disassembly process, it returns this array in `insns`, so that you can traverse
    all the disassembled instructions and handle them in some application-specific
    way. The example code just prints the instructions. Each instruction is of a `struct`
    type called `cs_insn`, which is defined in *capstone.h*, as shown in [Listing
    8-5](ch08.xhtml#ch08list5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在示例代码中所看到的，`disasm` 函数包含一个类型为 `cs_insn*` 的局部变量，名为 `insns`。`insns` 的地址作为调用
    `cs_disasm` 的最后一个参数，见 ➍。在反汇编代码缓冲区时，`cs_disasm` 会构建一个反汇编指令的数组。在反汇编过程结束时，它会将这个数组返回到
    `insns` 中，这样你就可以遍历所有的反汇编指令，并以某种特定于应用的方式处理它们。示例代码只是打印了这些指令。每条指令都是一个 `struct` 类型，名为
    `cs_insn`，该类型在 *capstone.h* 中定义，如 [列表 8-5](ch08.xhtml#ch08list5) 所示。
- en: '*Listing 8-5: Definition of* struct cs_insn *from* capstone.h'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：* `struct cs_insn` *在* capstone.h *中的定义*'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `id` field is a unique (architecture-specific) identifier for the instruction
    type, allowing you to check what kind of instruction you’re dealing with without
    resorting to string comparisons with the instruction mnemonic. For instance, you
    could implement instruction-specific handling for disassembled instructions, as
    shown in [Listing 8-6](ch08.xhtml#ch08list6).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 字段是一个唯一的（架构特定的）指令类型标识符，可以让你在不进行字符串比较的情况下检查你正在处理的指令类型。例如，你可以实现针对反汇编指令的指令特定处理，正如
    [Listing 8-6](ch08.xhtml#ch08list6) 中所示。'
- en: '*Listing 8-6: Instruction-specific handling with Capstone*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-6: 使用 Capstone 进行指令特定处理*'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, `insn` is a pointer to a `cs_insn` object. Note that `id` values
    are only unique within a particular architecture, not across architectures. The
    possible values are defined in an architecture-specific header file, which you’ll
    see in [Section 8.2.3](ch08.xhtml#ch08_2_3).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`insn` 是指向 `cs_insn` 对象的指针。请注意，`id` 值在特定架构内是唯一的，而不是跨架构唯一的。可能的值在架构特定的头文件中定义，你将在
    [Section 8.2.3](ch08.xhtml#ch08_2_3) 中看到。
- en: The `address`, `size`, and `bytes` fields in `cs_insn` contain the address,
    number of bytes, and bytes of the instruction. The `mnemonic` is a human-readable
    string representing the instruction (without the operands), while `op_str` is
    a human-readable representation of the operands of the instruction. Finally, `detail`
    is a pointer to a (mostly architecture-specific) data structure containing more
    detailed information about the disassembled instruction, such as which registers
    it reads and writes. Note that the `detail` pointer is set only if you explicitly
    enable Capstone’s detailed disassembly mode before starting the disassembly, which
    is not done in this example. You’ll see an example of disassembly using detailed
    disassembly mode in [Section 8.2.4](ch08.xhtml#ch08_2_4).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs_insn` 中的 `address`、`size` 和 `bytes` 字段包含指令的地址、字节数和字节内容。`mnemonic` 是一个表示指令的可读字符串（不包含操作数），而
    `op_str` 是指令操作数的可读表示。最后，`detail` 是指向一个（主要是架构特定的）数据结构的指针，包含有关反汇编指令的更详细信息，例如它读取和写入哪些寄存器。请注意，只有在你明确启用
    Capstone 的详细反汇编模式后，`detail` 指针才会被设置，而本示例中并未启用该模式。在 [Section 8.2.4](ch08.xhtml#ch08_2_4)
    中，你将看到使用详细反汇编模式的示例。'
- en: Interpreting the Disassembled Code and Cleaning Up
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反汇编代码解释与清理
- en: If all goes well, `cs_disasm` should return the number of disassembled instructions.
    In case of failure, it returns 0, and you must call the `cs_errno` function to
    check what the error is. This yields an `enum` value of type `cs_err`. In most
    cases, you want to print a human-readable error message and exit. For this reason,
    Capstone provides a convenient function called `cs_strerror`, which turns a `cs_err`
    value into a string describing the error.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，`cs_disasm` 应该返回反汇编的指令数量。如果失败，它会返回 0，你必须调用 `cs_errno` 函数来检查错误是什么。这将返回一个
    `enum` 类型的 `cs_err` 值。在大多数情况下，你需要打印一个可读的错误信息并退出。为此，Capstone 提供了一个便捷的函数 `cs_strerror`，它将一个
    `cs_err` 值转换为描述错误的字符串。
- en: If there are no errors, the `disasm` function loops over all the disassembled
    instructions returned by `cs_disasm` ➎ (refer to [Listing 8-4](ch08.xhtml#ch08list4)).
    This loop prints a line for each instruction, composed of the different fields
    in the `cs_insn` struct described earlier. Finally, after the loop completes,
    `disasm` calls `cs_free(insns, n)` to free the memory allocated by Capstone for
    each of the `n` instructions it parsed into the `insns` buffer ➏, then closes
    the Capstone instance by calling `cs_close`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，`disasm` 函数会遍历 `cs_disasm` 返回的所有反汇编指令 ➎（参见 [Listing 8-4](ch08.xhtml#ch08list4)）。这个循环会为每条指令打印一行，包含之前描述的
    `cs_insn` 结构体中的不同字段。最后，在循环完成后，`disasm` 会调用 `cs_free(insns, n)` 来释放 Capstone 为它解析到
    `insns` 缓冲区中的每条 `n` 条指令分配的内存 ➏，然后通过调用 `cs_close` 来关闭 Capstone 实例。
- en: You should now know most of the important Capstone functions and data structures
    you’ll need to perform basic disassembly and analysis tasks. If you want, you
    can try compiling and running the `basic_capstone_linear` example. Its output
    should be a list of the instructions in the `.text` section of the disassembled
    binary, like in [Listing 8-7](ch08.xhtml#ch08list7).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经了解了进行基本反汇编和分析任务所需的大部分重要 Capstone 函数和数据结构。如果你愿意，可以尝试编译并运行 `basic_capstone_linear`
    示例。它的输出应该是反汇编二进制文件 `.text` 区段中的指令列表，参考 [Listing 8-7](ch08.xhtml#ch08list7)。
- en: '*Listing 8-7: Example output of the linear disassembly tool*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-7: 线性反汇编工具的示例输出*'
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the rest of this chapter, you’ll see more elaborate disassembly examples
    using Capstone. The more complicated examples mostly come down to parsing some
    of the more detailed data structures. They’re not fundamentally more difficult
    than the examples you’ve already seen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '*8.2.3 Exploring the Capstone C API*'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve seen some of the basic Capstone functions and data structures,
    you may wonder if the rest of the Capstone API is documented somewhere. Unfortunately,
    no such comprehensive documentation of the Capstone API currently exists. The
    closest thing you have at your disposal is the Capstone header files. Luckily,
    they are well commented and not too complex, so with some basic pointers, you
    can quickly skim through them and find what you need for any given project. Capstone
    header files are all the C header files included with Capstone v3.0.5\. I shaded
    the most important ones for these purposes in [Listing 8-8](ch08.xhtml#ch08list8).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-8: The Capstone C header files*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you’ve seen, *capstone.h* is the main Capstone header file. It contains commented
    definitions of all the Capstone API functions as well as the architecture-independent
    data structures, such as `cs_insn` and `cs_err`. This is also where all the possible
    values for `enum` types like `cs_arch`, `cs_mode`, and `cs_err` are defined. For
    instance, if you wanted to modify the linear disassembler so it supports ARM code,
    you would reference *capstone.h* to find the proper architecture (`CS_ARCH_ARM`)
    and mode (`CS_MODE_ARM`) parameters to pass to the `cs_open` function.^([4](footnote.xhtml#ch08fn_4))
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Architecture-dependent data structures and constants are defined in separate
    header files, like *x86.h* for the x86 and x86-64 architecture. These files specify
    the possible values for the `id` field of the `cs_insn` struct—for x86, these
    are all the listed values of the `enum` type called `x86_insn`. For the most part,
    you’ll refer to the architecture-specific headers to find out which details are
    available through the `detail` field of the `cs_insn` type. If detailed disassembly
    mode is enabled, this field points to a `cs_detail` struct.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The `cs_detail` struct contains a `union` of architecture-dependent `struct`
    types that provide detailed information on the instruction. The type associated
    with x86 is called `cs_x86`, which is defined in *x86.h*. To illustrate this,
    let’s build a recursive disassembler that uses Capstone’s detailed disassembly
    mode to obtain architecture-specific information on x86 instructions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '*8.2.4 Recursive Disassembly with Capstone*'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Without detailed disassembly, Capstone allows you to inspect only basic information
    about instructions, such as the address, raw bytes, or mnemonic representation.
    This is fine for a linear disassembler, as you saw in the previous example. However,
    more advanced binary analysis tools often need to make decisions based on instruction
    properties, such as the registers the instruction accesses, the type and value
    of its operands, the type of instruction (arithmetic, control flow, and so on),
    or the locations targeted by control flow instructions. This kind of detailed
    information is provided only in Capstone’s detailed disassembly mode. Parsing
    it requires extra effort on Capstone’s part, making detailed disassembly slower
    than in non-detailed mode. Therefore, you should use detailed mode only when needed.
    One instance that requires detailed disassembly mode is recursive disassembly.
    Recursive disassembly is a recurring theme in many binary analysis applications,
    so let’s explore it in more detail.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 6](ch06.xhtml#ch06) that recursive disassembly discovers
    code by starting from known entry points, such as the main entry point of the
    binary, or function symbols, and following control flow instructions from there.
    In contrast to linear disassembly, which blindly disassembles all code in sequence,
    recursive disassembly isn’t easily fooled by things like data interspersed with
    the code. The downside is that recursive disassembly may miss instructions if
    the instructions are reachable only via indirect control flows, which cannot be
    resolved statically.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Detailed Disassembly Mode
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 8-9](ch08.xhtml#ch08list9) shows a basic implementation of recursive
    disassembly. Unlike most recursive disassemblers, the one in this example doesn’t
    assume that bytes can belong to only a single instruction at a time, so overlapping
    code blocks are supported.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-9:* basic_capstone_recursive.cc'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see in [Listing 8-9](ch08.xhtml#ch08list9), the `main` function is
    identical to the one for the linear disassembler. And for the most part, the initialization
    code at the start of `disasm` is also similar. It starts by loading the `.text`
    section and getting a Capstone handle. However, there’s a small but important
    addition ➊. This added line enables detailed disassembly mode by activating the
    `CS_OPT_DETAIL` option. This is crucial for recursive disassembly because you
    need the control flow information, which is provided only in detailed disassembly
    mode.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code explicitly allocates an instruction buffer ➋. While this wasn’t
    necessary for the linear disassembler, you need it here because you’ll use another
    Capstone API function for the actual disassembly than the one used before. This
    alternative disassembly function allows you to inspect each instruction while
    it’s disassembled without having to wait for all other instructions to be disassembled.
    This is a common requirement in detailed disassembly because you typically want
    to act on the details of each instruction as you go along in order to influence
    the control flow of the disassembler.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through Entry Points
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following the Capstone initialization, the logic of the recursive disassembler
    begins. The recursive disassembler is structured around a queue, which contains
    starting points for the disassembler. The first step is to bootstrap the disassembly
    process by filling the queue with initial entry points: the main entry point of
    the binary ➌ as well as any known function symbols ➍. After that, the code continues
    into the main disassembly loop ➎.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the loop is structured around a queue of addresses, which are
    used as starting points for the disassembly. As long as there are more starting
    points to explore, each iteration pops the next starting point from the queue
    and then follows control flow from there, disassembling as much code as possible.
    Essentially, this performs a linear disassembly from each starting point, pushing
    each newly discovered control flow destination into the queue. The new destination
    will be disassembled in a later iteration of the loop. Each linear sweep stops
    only when it encounters a `hlt` instruction, or an unconditional branch, because
    these instructions aren’t guaranteed to have a valid fall-through target. Data,
    instead of code, might come after these instructions, so you don’t want to continue
    disassembling past them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The loop uses several new Capstone functions that you probably haven’t seen
    before. For one thing, it uses a different API call, named `cs_disasm_iter`, for
    the actual disassembly ➏. Also, there are functions that retrieve detailed disassembly
    information, such as the targets of control flow instructions and information
    on whether a particular instruction is a control flow instruction in the first
    place. Let’s begin by discussing why you need to use `cs_disasm_iter` instead
    of plain old `cs_disasm` in this example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Using Iterative Disassembly for Real-Time Instruction Parsing
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name implies, `cs_disasm_iter` is an iterative variant of the `cs_disasm`
    function. With `cs_disasm_iter`, instead of disassembling a whole code buffer
    at once, Capstone disassembles only one instruction at a time. After disassembling
    each instruction, `cs_disasm_iter` returns either true or false. True means that
    an instruction was successfully disassembled, while false means nothing was disassembled.
    You can easily create a `while` loop, like the one shown at ➏, that calls `cs_disasm_iter`
    until there is no code left to disassemble.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The parameters to `cs_disasm_iter` are essentially iterative variants of those
    you saw in the linear disassembler. As before, the first parameter is your Capstone
    handle. The second parameter is a pointer to the code to disassemble. However,
    instead of a `uint8_t*`, it’s now a double pointer (that is, a `uint8_t**`). This
    allows `cs_disasm_iter` to automatically update the pointer each time it is called,
    setting it to point just past the recently disassembled bytes. Since this behavior
    is similar to a program counter, this parameter is called `pc`. As you can see,
    for each starting point in the queue, you just have to point `pc` to the correct
    location in the `.text` section once. After that, you can simply call `cs_disasm_iter`
    in a loop, and it automatically takes care of incrementing `pc`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter is the number of bytes left to disassemble, which is also
    automatically decremented by `cs_disasm_iter`. In this case, it’s always equal
    to the size of the `.text` section minus the number of bytes already disassembled.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: There’s also an automatically incremented parameter called `addr`, which informs
    Capstone about the VMA of the code pointed to by `pc` (just as `text->vma` did
    in the linear disassembler). The last parameter is a pointer to a `cs_insn` object,
    which serves as a buffer for each disassembled instruction.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Using `cs_disasm_iter` instead of `cs_disasm` has several advantages. The main
    reason for using it is its iterative behavior, which allows you to inspect each
    instruction right after it’s disassembled, letting you inspect control flow instructions
    and follow them recursively. In addition to its useful iterative behavior, `cs_disasm_iter`
    is faster and more memory efficient than `cs_disasm` since it doesn’t require
    a large preallocated buffer to contain all disassembled instructions at once.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Control Flow Instructions
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ve seen, the disassembly loop uses several helper functions to determine
    whether a particular instruction is a control flow instruction and, if so, what
    its target is. For example, the function `is_cs_cflow_ins` (called at ➐) determines
    whether an instruction is any kind of control flow instruction (conditional or
    unconditional). To this end, it inspects Capstone’s detailed disassembly information.
    In particular, the `ins->detail` struct provided by Capstone contains an array
    of “groups” to which the instruction belongs (`ins->detail->groups`). With this
    information, you can easily make decisions based on the groups an instruction
    belongs to. For instance, you can tell that an instruction is some kind of jump
    instruction without having to explicitly check the `ins->id` field against every
    possible kind of jump, such as `jmp`, `ja`, `je`, `jnz`, and so on. In the case
    of the `is_cs_cflow_ins` function, it checks whether an instruction is a kind
    of jump, call, return, or return from interrupt (the actual check is implemented
    in another helper function, called `is_cs_cflow_group`). If an instruction is
    one of these four types, it’s considered a control flow instruction.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'If a disassembled instruction turns out to be a control flow instruction, then
    you want to resolve its target if possible and add it to your queue if you haven’t
    seen it before so that the instructions at that target address are disassembled
    later. The code to resolve control flow targets is in a helper function called
    `get_cs_insn_immediate_target`. The example calls this function at ➑. As the name
    implies, it’s only capable of resolving “immediate” control flow targets: target
    addresses that are hardcoded in the control flow instruction. In other words,
    it makes no attempt to resolve indirect control flow targets, which is difficult
    to do statically, as you may recall from [Chapter 6](ch06.xhtml#ch06).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsing control flow targets is the first instance of architecture-specific
    instruction handling in this example. Resolving a control flow target requires
    you to examine the instruction’s operands, and since every instruction architecture
    has its own set of operand types, parsing them cannot be done in a generic way.
    In this case, you’re operating on x86 code, so you need to access the x86-specific
    operand array provided by Capstone as part of the detailed disassembly information
    (`ins->detail->x86.operands`). This array contains operands in the form of a `struct`
    type called `cs_x86_op`. This struct contains an anonymous `union` of all possible
    operand types: register (`reg`), immediate (`imm`), floating point (`fp`), or
    memory (`mem`). Which of these fields is actually set depends on the operand type,
    and the type is indicated by the `type` field of `cs_x86_op`. The example disassembler
    only parses immediate control flow targets, so it checks for operands of `type
    X86_OP_IMM` and returns the value of any immediate targets it finds. If this target
    hasn’t been disassembled yet, the `disasm` function adds it to the queue.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if `disasm` encounters a `hlt` or an unconditional control flow, it
    halts disassembly because it doesn’t know whether there are noncode bytes after
    such instructions. To check for unconditional control flow instructions, `disasm`
    calls another helper function, called `is_cs_unconditional_cflow_ins` ➒. This
    function simply uses the `ins->id` field to check explicitly for all relevant
    types of instructions since there are only a few such types. There’s a separate
    check for `hlt` instructions at ➓. After the disassembly loop ends, the `disasm`
    function cleans up the allocated instruction buffer and closes the Capstone handle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Running the Recursive Disassembler
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The recursive disassembly algorithm just explored is the basis for many custom
    disassembly tools, as well as full-fledged disassembler suites such as Hopper
    or IDA Pro. Of course, these contain many more heuristics than this simple example
    for identifying function entry points and other useful code properties, even in
    the absence of function symbols. Try compiling and running the recursive disassembler!
    It works best on binaries with symbolic information. Its output is designed to
    let you follow along with what the recursive disassembly process is doing. For
    example, [Listing 8-10](ch08.xhtml#ch08list10) shows a snippet of the recursive
    disassembly output for the obfuscated binary with overlapping basic blocks introduced
    at the start of this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-10: Example output of the recursive disassembler*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see in [Listing 8-10](ch08.xhtml#ch08list10), the disassembler starts
    by queueing up entry points: first the binary’s main entry point and then any
    known function symbols. It then proceeds to disassemble as much code as safely
    possible starting from each address in the queue (the dashes denote the points
    at which the disassembler decides to stop and move to the next address in the
    queue). Along the way, the disassembler also finds new, previously unknown, addresses
    to put in the queue for later disassembly. For instance, the `jbe` instruction
    at address `0x400543` reveals the new target address `0x400560` ➊. The disassembler
    successfully finds both overlapping blocks in the obfuscated binary: the one at
    address `0x400610` ➋ as well as the one at address `0x400612` ➌ that’s embedded
    in it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Implementing a ROP Gadget Scanner
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the examples you’ve seen so far are custom implementations of well-known
    disassembly techniques. However, you can do much more with Capstone! In this section,
    you’ll see a more specialized kind of tool with disassembly needs that aren’t
    covered by standard linear or recursive disassembly. Specifically, you’ll learn
    about a tool that is indispensable for modern exploit writing: a scanning tool
    that can find gadgets for use in ROP exploits. First, let’s explore what this
    means.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '*8.3.1 Introduction to Return-Oriented Programming*'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Nearly every introduction to exploitation covers Aleph One’s classic article
    “Smashing the Stack for Fun and Profit,” which explains the basics of exploiting
    stack-based buffer overflows. When this article was published in 1996, exploitation
    was relatively straightforward: find a vulnerability, load malicious shellcode
    into a buffer (typically a stack buffer) in the target application, and use the
    vulnerability to redirect control flow to the shellcode.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Much has happened in the world of security since, and exploitation has gotten
    vastly more complicated. One of the most widespread defenses against classic exploits
    of this kind is data execution prevention (DEP), also known as W⊕X or NX. It was
    introduced in Windows XP in 2004 and prevents shellcode injection in an extremely
    straightforward way. DEP enforces that no region of memory is ever writable and
    executable at the same time. So if an attacker injects shellcode into a buffer,
    they cannot execute it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it wasn’t long before hackers found a way to circumvent DEP.
    New defenses prevented the injection of shellcode, but they couldn’t stop an attacker
    from using a vulnerability to redirect control flow to *existing code* in the
    exploited binary or the libraries it uses. This weakness was first exploited in
    a class of attacks known as return-to-libc (ret2libc) in which control flow is
    redirected to sensitive functions in the widely used libc library, like the `execve`
    function, which can be used to start a new process of the attacker’s choice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: In 2007 came a generalized variant of ret2libc, known as *return-oriented programming
    (ROP)*. Instead of restricting attacks to existing functions, ROP allows an attacker
    to implement arbitrary malicious functionality by chaining together short existing
    code sequences in the target program’s memory space. These short code sequences
    are called *gadgets* in ROP terminology.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Each gadget ends in a return instruction and performs a basic operation, such
    as addition or logical comparison.^([5](footnote.xhtml#ch08fn_5)) By carefully
    selecting gadgets with well-defined semantics, an attacker can create what is
    essentially a customized instruction set where each gadget forms an instruction
    and then use this instruction set to craft arbitrary functionality, called a ROP
    program, without injecting any new code. Gadgets can be part of the host program’s
    normal instructions, but they can also be unaligned instruction sequences of the
    sort you saw in the obfuscated code example in [Listings 8-1](ch08.xhtml#ch08list1)
    and [8-2](ch08.xhtml#ch08list2).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: A ROP program consists of a series of gadget addresses carefully arranged on
    the stack so that the return instruction terminating each gadget transfers control
    to the next gadget in the chain. To start the ROP program, you execute an initial
    return instruction (for instance, by triggering it through an exploit) that jumps
    to the first gadget address. [Figure 8-1](ch08.xhtml#ch08fig1) illustrates an
    example ROP chain.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f214-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: An example ROP chain. Gadget* g[1] *loads a constant into* `eax`,
    *which is then added to* `esi` *by* g[2].'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the stack pointer (the `esp` register) initially points to the
    address of the first gadget g[1] in the chain. When the initial return instruction
    happens, it pops this first gadget address off the stack and transfers control
    to it, causing g[1] to run. Gadget g[1] performs a `pop` instruction that loads
    a constant arranged on the stack into the `eax` register and increments `esp`
    to point to the address of gadget g[2]. Then, g[1]’s `ret` instruction transfers
    control to g[2], which subsequently adds the constant in `eax` to the `esi` register.
    Gadget g[2] then returns to gadget g[3], and so on, until all gadgets g[1], .
    . . ,g[n] have been executed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: As you may have gathered from this, creating a ROP exploit requires that an
    attacker first select an appropriate set of ROP gadgets to use. In the following
    section, we’ll implement a tool that scans a binary for usable ROP gadgets and
    creates an overview of these gadgets to aid in building ROP exploits.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '*8.3.2 Finding ROP Gadgets*'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next listing shows the code for the ROP gadget finder. It outputs a list
    of ROP gadgets that can be found in the given binary. You can use this list to
    select appropriate gadgets and combine them into an exploit for the binary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, you want to find gadgets that end in a return instruction. Moreover,
    you want to look for both aligned and unaligned gadgets with respect to the binary’s
    normal instruction stream. Usable gadgets should have well-defined and simple
    semantics, so the length of the gadgets should be fairly limited. In this case,
    let’s (arbitrarily) limit gadget length to five instructions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: To find both aligned and unaligned gadgets, one possible approach is to disassemble
    the binary from each possible starting byte and see for which bytes you end up
    with a usable gadget. However, you can make things more efficient by first scanning
    the binary for locations of return instructions (aligned or unaligned) and then
    traversing backward from there, building up increasingly long gadgets as you go
    along. This way, you don’t have to start a disassembly sweep at every possible
    address, but only at addresses near return instructions. Let’s clarify what exactly
    this means by taking a closer look at the gadget finder code shown in [Listing
    8-11](ch08.xhtml#ch08list11).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-11:* capstone_gadget_finder.cc'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The gadget finder in [Listing 8-11](ch08.xhtml#ch08list11) doesn’t introduce
    any new Capstone concepts. The `main` function is the same one you saw in the
    linear and recursive disassemblers, and the helper functions (`is_cs_cflow_group`,
    `is_cs_cflow_ins`, and `is_cs_ret_ins`) are similar to those you saw before. The
    Capstone disassembly function, `cs_disasm_iter`, is also one you’ve seen before.
    The interesting thing about the gadget finder is that it uses Capstone to analyze
    a binary in a way that can’t be done with a standard linear or recursive disassembler.
    All the gadget-finding functionality is implemented in the functions `find_gadgets`
    and `find_gadgets_at_root`, so let’s focus on them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for Roots and Mapping Gadgets
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `find_gadgets` function is called from `main`, and it starts in a familiar
    way. First, it loads the `.text` section and initializes Capstone in detailed
    disassembly mode. After the initialization, `find_gadgets` loops over each byte
    in `.text` and checks whether it is equal to the value `0xc3`, the opcode for
    an x86 `ret` instruction ➊.^([6](footnote.xhtml#ch08fn_6)) Conceptually, each
    such instruction is a potential “root” for one or more gadgets, which you can
    find by searching backward starting from the root. You can think of all the gadgets
    that end in a particular `ret` instruction as a tree rooted at that `ret` instruction.
    To find all gadgets connected to a particular root, there’s a separate function,
    called `find_gadgets_at_root` (called at ➋), which I’ll discuss shortly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: All the gadgets are added to a C++ `map` data structure that maps each unique
    gadget (in the form of a `string`) to the set of addresses at which this gadget
    can be found. The actual adding of gadgets to the `map` happens in the `find_gadgets_at_root`
    function. After the gadget search completes, `find_gadgets` prints out the entire
    mapping of gadgets ➌ and then cleans up and returns.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Finding All Gadgets at a Given Root
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned, the function `find_gadgets_at_root` finds all gadgets that end
    up at a given root instruction. It starts by allocating an instruction buffer,
    which you need when using `cs_disasm_iter`. Then, it enters a loop that searches
    backward from the root instruction, beginning at one byte before the root address
    and decrementing the search address in each loop iteration until it’s 15 × 5 bytes
    from the root ➍. Why 15 × 5? This is because you want gadgets of at most five
    instructions, and since x86 instructions never consist of more than 15 bytes each,
    the furthest you’ll ever need to search backward from any given root is 15 × 5
    bytes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: For every search offset, the gadget finder performs a linear disassembly sweep
    ➎. In contrast to the earlier linear disassembly example, this example uses Capstone’s
    `cs_disasm_iter` function for each disassembly sweep. The reason is that instead
    of disassembling an entire buffer at once, the gadget finder needs to check a
    series of stop conditions after each instruction.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: First, it breaks off the linear sweep if it encounters an invalid instruction,
    discarding the gadget and moving on to the next search address, starting a new
    linear sweep from there. Checking for invalid instructions is important since
    gadgets at unaligned offsets are often invalid.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The gadget finder also breaks off the disassembly sweep if it hits an instruction
    with an address beyond the root ➏. You may be wondering how it’s possible for
    the disassembly to reach an instruction beyond the root without hitting the root
    itself first. To see an example of this, remember that some of the addresses you
    disassemble are unaligned with respect to the normal instruction stream. This
    means that if you disassemble a multibyte unaligned instruction, the disassembly
    might consume the root instruction as part of the unaligned instruction’s opcode
    or operands so that the root itself never appears in the unaligned instruction
    stream.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the gadget finder stops disassembling a given gadget if it finds a
    control flow instruction other than a return ➐. After all, gadgets are easier
    to use if they contain no control flow other than the final return instruction.^([7](footnote.xhtml#ch08fn_7))
    The gadget finder also discards gadgets that grow longer than the maximum gadget
    size ➑.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: If none of the stop conditions is true, then the gadget finder appends the newly
    disassembled instruction (`cs_ins`) to a string containing the gadget built up
    so far ➒. When the analysis reaches the root instruction, the gadget is complete
    and is appended to the `map` of gadgets ➓. After considering all possible starting
    points near the root, `find_gadgets_at_root` is done and returns control to the
    main `find_gadgets` function, which then continues with the next root instruction,
    if there are any left.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Running the Gadget Finder
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The command line interface for the gadget finder is the same as for the disassembly
    tools. [Listing 8-12](ch08.xhtml#ch08list12) shows what the output should look
    like.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 8-12: Example output of the ROP scanner*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each line of output shows a gadget string, followed by the addresses where this
    gadget is found. For instance, there’s an `add al, ch; ret` gadget at address
    `0x406697`, which you could use in a ROP payload to add the `al` and `ch` registers
    together. Having an overview of the available gadgets like this helps a lot in
    selecting suitable ROP gadgets to use when crafting a ROP payload for use in an
    exploit.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Summary
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should now feel comfortable using Capstone to start building your own custom
    disassemblers. All the examples in this chapter are present on the virtual machine
    included with this book. Playing around with them is a good starting point for
    gaining fluency with the Capstone API. Use the following exercises and challenges
    to put your custom disassembly skills to the test!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Generalizing the Disassembler
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: All the disassembly tools you saw in this chapter configured Capstone to disassemble
    x64 code only. You did this by passing `CS_ARCH_X86` and `CS_MODE_64` as the architecture
    and mode arguments to `cs_open`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Let’s generalize these tools to automatically select the proper Capstone parameters
    to deal with other architectures by checking the type of the loaded binary using
    the `arch` and `bits` fields in the `Binary` class that the loader provides. To
    figure out which architecture and mode arguments to pass to Capstone, remember
    that */usr/include/capstone/capstone.h* contains lists of all possible `cs_arch`
    and `cs_mode` values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Explicit Detection of Overlapping Blocks
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Although the example recursive disassembler can deal with overlapping basic
    blocks, it doesn’t give any explicit warning when there is overlapping code. Extend
    the disassembler to inform the user which blocks overlap.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Cross-Variant Gadget Finder
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: When compiling a program from source, the resulting binary can differ significantly
    depending on factors such as the compiler version, compilation options, or target
    architecture. In addition, randomization strategies that harden binaries against
    exploitation by changing register allocations or shuffling code around complicate
    the exploit process. This means that when developing an exploit (such as a ROP
    exploit), you won’t always know which binary “variant” of a program is running
    on the target. For instance, is the target server compiled with `gcc` or `llvm`?
    Is it running on 32-bit or 64-bit? If you guess wrong, your exploit will likely
    fail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, your goal is to expand the ROP gadget finder to take two or
    more binaries as input, representing different variants of the same program. It
    should output a list of VMAs that contain usable gadgets in *all* of the variants.
    Your new gadget finder should be able to scan each of the input binaries for gadgets
    but output only those addresses where all binaries contain a gadget, not just
    some of the binaries. For each reported VMA, the gadgets should also implement
    similar operations. For instance, they’ll contain an `add` instruction or a `mov`.
    Implementing a usable notion of similarity will be part of the challenge. The
    end result should be a cross-variant gadget finder that can be used to develop
    exploits that simultaneously work on multiple variants of the same program!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: To test your gadget finder, you can create variants of a program of your choice
    by compiling it multiple times with different compilation options or different
    compilers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
