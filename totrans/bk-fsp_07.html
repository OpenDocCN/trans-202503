<html><head></head><body><section class="chapter" title="Chapter&#xA0;7.&#xA0;Patterns, Patterns, Everywhere" epub:type="chapter" id="patternscomma_patternscomma_everywhere"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Patterns, Patterns, Everywhere</h2></div></div></div><p><a id="iddle1629" class="indexterm"/><a id="iddle1630" class="indexterm"/>Pattern matching is one of F#’s most powerful features. Patterns are so ingrained within the language that they’re employed by many of the constructs you’ve already seen, like <code class="literal">let</code> bindings, <code class="literal">try...with</code> expressions, and lambda expressions. In this chapter, you’ll learn about match expressions, predefined pattern types, and creating your own patterns with active patterns.</p><div class="sect1" title="Match Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="match_expressions">Match Expressions</h2></div></div></div><p>Although F# allows imperative style branching through if expressions, they can be difficult to maintain, particularly as the conditional logic’s complexity increases. Match expressions are F#’s primary branching mechanism.</p><p><a id="iddle1072" class="indexterm"/><a id="iddle1632" class="indexterm"/><a id="iddle1766" class="indexterm"/><a id="iddle1867" class="indexterm"/><a id="iddle1970" class="indexterm"/>On the surface, many match expressions resemble C#’s <code class="literal">switch</code> or Visual Basic’s <code class="literal">Select Case</code> statements, but they’re significantly more powerful. For instance, while <code class="literal">switch</code> and <code class="literal">Select Case</code> operate against only constant values, match expressions select an expression to evaluate according to which pattern matches the input. At their most basic, match expressions take the following form:</p><a id="pro_id00389"/><pre class="programlisting">match ①<span class="emphasis"><em>test-expression</em></span> with
  | ②<span class="emphasis"><em>pattern1</em></span> -&gt; ③<span class="emphasis"><em>result-expression1</em></span>
  | ④<span class="emphasis"><em>pattern2</em></span> -&gt; ⑤<span class="emphasis"><em>result-expression2</em></span>
  | ...</pre><p>In the preceding syntax, the expression at ① is evaluated and sequentially compared to each pattern in the expression body until a match is found. For example, if the result satisfies the pattern at ②, the expression at ③ is evaluated. Otherwise, the pattern at ④ is tested and, if it matches, the expression at ⑤ is evaluated, and so on. Because match expressions also return a value, each result expression must be of the same type.</p><p>The fact that patterns are matched sequentially has consequences for how you structure your code; you must organize your match expressions such that the patterns are listed from most to least specific. If a more general pattern is placed ahead of more specific patterns in a way that prevents any subsequent patterns from being evaluated, the compiler will issue a warning for each affected pattern.</p><p>Match expressions can be used with a wide variety of data types including (but not limited to) numbers, strings, tuples, and records. For example, here’s a function with a simple match expression that works with a discriminated union:</p><a id="pro_id00390"/><pre class="programlisting">let testOption opt =
  match opt with
  | Some(v) -&gt; printfn "Some: %i" v
  | None -&gt; printfn "None"</pre><p>In this snippet, <code class="literal">opt</code> is inferred to be of type <code class="literal">int option</code>, and the match expression includes patterns for both the <code class="literal">Some</code> and <code class="literal">None</code> cases. When the match expression evaluates, it first tests whether <code class="literal">opt</code> matches <code class="literal">Some</code>. If so, the pattern binds the value from <code class="literal">Some</code> into <code class="literal">v</code>, which is then printed when the result expression is evaluated. Likewise, when <code class="literal">None</code> matches, the result expression simply prints out <code class="literal">"None"</code>.</p><div class="sect2" title="Guard Clauses"><div class="titlepage"><div><div><h3 class="title" id="guard_clauses">Guard Clauses</h3></div></div></div><p>In addition to matching disparate values against patterns, you can further refine each case through <span class="emphasis"><em>guard clauses</em></span>, which allow you to specify additional criteria that must be met to satisfy a case. For instance, you can use guard <a id="iddle1466" class="indexterm"/><a id="iddle1633" class="indexterm"/><a id="iddle1767" class="indexterm"/>clauses (by inserting <code class="literal">when</code> followed by a condition) to distinguish between positive and negative numbers like so:</p><a id="pro_id00391"/><pre class="programlisting">let testNumber value =
  match value with
  | ①v when v &lt; 0 -&gt; printfn "%i is negative" v
  | ②v when v &gt; 0 -&gt; printfn "%i is positive" v
  | _ -&gt; printfn "zero"</pre><p>In this example, we have two cases with identical patterns but different guard clauses. Even though any integer will match any of the three patterns, the guard clauses on patterns ① and ② cause matching to fail unless the captured value meets their criteria.</p><p>You can combine multiple guard clauses with Boolean operators for more complex matching logic. For instance, you could construct a case that matches only positive, even integers as follows:</p><a id="pro_id00392"/><pre class="programlisting">let testNumber value =
  match value with
  | v when v &gt; 0 &amp;&amp; v % 2 = 0 -&gt; printfn "%i is positive and even" v
  | v -&gt; printfn "%i is zero, negative, or odd" v</pre></div><div class="sect2" title="Pattern-Matching Functions"><div class="titlepage"><div><div><h3 class="title" id="pattern-matching_functions">Pattern-Matching Functions</h3></div></div></div><p>There is an alternative match expression syntax called a <span class="emphasis"><em>pattern-matching function</em></span>. With the pattern-matching function syntax, the <code class="literal">match...with</code> portion of the match expression is replaced with <code class="literal">function</code> like this:</p><a id="pro_id00393"/><pre class="programlisting">&gt; <span class="strong"><strong>let testOption =</strong></span>
  <span class="strong"><strong>function</strong></span>
  | <span class="strong"><strong>Some(v) -&gt; printfn "Some: %i" v</strong></span>
  | <span class="strong"><strong>None -&gt; printfn "None";;</strong></span>

val testOption : _arg1:int option -&gt; unit</pre><p>As you can see from the signature in the output, by using the pattern-matching function syntax, we bind <code class="literal">testOption</code> to a function that accepts an <code class="literal">int option</code> (with the generated name <code class="literal">_arg1</code>) and returns <code class="literal">unit</code>. Using the <code class="literal">function</code> keyword this way is a convenient shortcut for creating a pattern-matching lambda expression and is functionally equivalent to writing:</p><a id="pro_id00394"/><pre class="programlisting">fun x -&gt;
  match x with
  | Some(v) -&gt; printfn "Some: %i" v
  | None -&gt; printfn "None";;</pre><p><a id="iddle1631" class="indexterm"/><a id="iddle1634" class="indexterm"/>Because pattern-matching functions are just a shortcut for lambda expressions, passing match expressions to higher-order functions is trivial. Suppose you want to filter out all of the <code class="literal">None</code> values from a list of optional integers. You might consider passing a pattern-matching function to the <code class="literal">List.filter</code> function like this:</p><a id="pro_id00395"/><pre class="programlisting">[ Some 10; None; Some 4; None; Some 0; Some 7 ]
|&gt; List.filter (function | Some(_) -&gt; true
                         | None -&gt; false)</pre><p>When the <code class="literal">filter</code> function is executed, it will invoke the pattern-matching function against each item in the source list, returning <code class="literal">true</code> when the item is <code class="literal">Some(_)</code>, or <code class="literal">false</code> when the item is <code class="literal">None</code>. As a result, the list created by <code class="literal">filter</code> will contain only <code class="literal">Some 10</code>, <code class="literal">Some 4</code>, <code class="literal">Some 0</code>, and <code class="literal">Some 7</code>.</p></div></div><div class="sect1" title="Exhaustive Matching"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exhaustive_matching">Exhaustive Matching</h2></div></div></div><p>When a match expression includes patterns such that every possible result of the test expression is accounted for, it is said to be <span class="emphasis"><em>exhaustive</em></span>, or <span class="emphasis"><em>covering</em></span>. When a value exists that isn’t covered by a pattern, the compiler issues a warning. Consider what happens when we match against an integer but cover only a few cases.</p><a id="pro_id00396"/><pre class="programlisting">&gt; <span class="strong"><strong>let numberToString =</strong></span>
  <span class="strong"><strong>function</strong></span>
  <span class="strong"><strong>| 0 -&gt; "zero"</strong></span>
  <span class="strong"><strong>| 1 -&gt; "one"</strong></span>
  <span class="strong"><strong>| 2 -&gt; "two"</strong></span>
  <span class="strong"><strong>| 3 -&gt; "three";;</strong></span>

    function
  --^^^^^^^^

stdin(4,3): warning FS0025: Incomplete pattern matches on this expression. For
example, the value '4' may indicate a case not covered by the pattern(s).

val numberToString : _arg1:int -&gt; string</pre><p>Here you can see that if the integer is ever anything other than 0, 1, 2, or 3, it will never be matched. The compiler even provides an example of a value that might not be covered—four, in this case. If <code class="literal">numberToString</code> is called with a value that isn’t covered, the call fails with a <code class="literal">MatchFailureException</code>:</p><a id="pro_id00397"/><pre class="programlisting">&gt; <span class="strong"><strong>numberToString 4;;</strong></span>
Microsoft.FSharp.Core.MatchFailureException: The match cases were incomplete
   at FSI_0025.numberToString(Int32 _arg1)
   at &lt;StartupCode$FSI_0026&gt;.$FSI_0026.main@()
Stopped due to error</pre><p><a id="iddle1508" class="indexterm"/><a id="iddle1748" class="indexterm"/><a id="iddle1762" class="indexterm"/><a id="iddle1764" class="indexterm"/><a id="iddle2101" class="indexterm"/><a id="iddle2119" class="indexterm"/>To address this problem, you could add more patterns, trying to match every possible value, but many times (such as with integers) matching every possible value isn’t feasible. Other times, you may care only about a few cases. In either scenario, you can turn to one of the patterns that match any value: the Variable pattern or the Wildcard pattern.</p><div class="sect2" title="Variable Patterns"><div class="titlepage"><div><div><h3 class="title" id="variable_patterns">Variable Patterns</h3></div></div></div><p><span class="emphasis"><em>Variable patterns</em></span> are represented with an identifier and are used whenever you want to match any value and bind that value to a name. Any names defined through Variable patterns are then available for use within guard clauses and the result expression for that case. For example, to make <code class="literal">numberToString</code> exhaustive, you could revise the function to include a Variable pattern like this:</p><a id="pro_id00398"/><pre class="programlisting">let numberToString =
  function
  | 0 -&gt; "zero"
  | 1 -&gt; "one"
  | 2 -&gt; "two"
  | 3 -&gt; "three"
① | n -&gt; sprintf "%O" n</pre><p>When you include a Variable pattern at ①, anything other than 0, 1, 2, or 3 will be bound to <code class="literal">n</code> and simply converted to a string.</p><p>The identifier defined in a Variable pattern should begin with a lowercase letter to distinguish it from an Identifier pattern. Now, invoking <code class="literal">numberToString</code> with <code class="literal">4</code> will complete without error, as shown here:</p><a id="pro_id00399"/><pre class="programlisting">&gt; <span class="strong"><strong>numberToString 4;;</strong></span>
val it : string = "4"</pre></div><div class="sect2" title="The Wildcard Pattern"><div class="titlepage"><div><div><h3 class="title" id="wildcard_pattern-id00012">The Wildcard Pattern</h3></div></div></div><p>The <span class="emphasis"><em>Wildcard pattern</em></span>, represented as a single underscore character (<code class="literal">_</code>), works just like a Variable pattern except that it discards the matched value rather than binding it to a name.</p><p>Here’s the previous <code class="literal">numberToString</code> implementation revised with a Wildcard pattern. Note that because the matched value is discarded, we need to return a general string instead of something based on the matched value.</p><a id="pro_id00400"/><pre class="programlisting">let numberToString =
  function
  | 0 -&gt; "zero"
  | 1 -&gt; "one"
  | 2 -&gt; "two"
  | 3 -&gt; "three"
  | _ -&gt; "unknown"</pre></div></div><div class="sect1" title="Matching Constant Values"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="matching_constant_values">Matching Constant Values</h2></div></div></div><p><a id="iddle1262" class="indexterm"/><a id="iddle1509" class="indexterm"/><a id="iddle1594" class="indexterm"/><a id="iddle1743" class="indexterm"/><a id="iddle1749" class="indexterm"/><a id="iddle1761" class="indexterm"/><a id="iddle2068" class="indexterm"/><span class="emphasis"><em>Constant patterns</em></span> consist of hardcoded numbers, characters, strings, and enumeration values. You’ve already seen several examples of Constant patterns, but to reiterate, the first four cases in the <code class="literal">numberToString</code> function that follows are all Constant patterns.</p><a id="pro_id00401"/><pre class="programlisting">let numberToString =
  function
  | 0 -&gt; "zero"
  | 1 -&gt; "one"
  | 2 -&gt; "two"
  | 3 -&gt; "three"
  | _ -&gt; "..."</pre><p>Here, the numbers 0 through 3 are explicitly matched and return the number as a word. All other values fall into the wildcard case.</p></div><div class="sect1" title="Identifier Patterns"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="identifier_patterns">Identifier Patterns</h2></div></div></div><p>When a pattern consists of more than a single character and begins with an uppercase character, the compiler attempts to resolve it as a name. This is called an <span class="emphasis"><em>Identifier pattern</em></span> and typically refers to discriminated union cases, identifiers decorated with <code class="literal">LiteralAttribute</code>, or exception names (as seen in a <code class="literal">try...with</code> block).</p><div class="sect2" title="Matching Union Cases"><div class="titlepage"><div><div><h3 class="title" id="matching_union_cases">Matching Union Cases</h3></div></div></div><p>When the identifier is a discriminated union case, the pattern is called a <span class="emphasis"><em>Union Case pattern</em></span>. Union Case patterns must include a wildcard or identifier for each data item associated with that case. If the case doesn’t have any associated data, the case label can appear on its own.</p><p>Consider the following discriminated union that defines a few shapes:</p><a id="pro_id00402"/><pre class="programlisting">type Shape =
| Circle of float
| Rectangle of float * float
| Triangle of float * float * float</pre><p>From this definition, it’s trivial to define a function that uses a match expression to calculate the perimeter of any of the included shapes. Here is one possible implementation:</p><a id="pro_id00403"/><pre class="programlisting">let getPerimeter =
  function
  | Circle(r) -&gt; 2.0 * System.Math.PI * r
  | Rectangle(w, h) -&gt; 2.0 * (w + h)
  | Triangle(l1, l2, l3) -&gt; l1 + l2 + l3</pre><p><a id="iddle1595" class="indexterm"/><a id="iddle1596" class="indexterm"/><a id="iddle1682" class="indexterm"/><a id="iddle1751" class="indexterm"/><a id="iddle1752" class="indexterm"/>As you can see, each shape defined by the discriminated union is covered, and the data items from each case are extracted into meaningful names like <code class="literal">r</code> for the radius of a circle or <code class="literal">w</code> and <code class="literal">h</code> for the width and height of a rectangle, respectively.</p></div><div class="sect2" title="Matching Literals"><div class="titlepage"><div><div><h3 class="title" id="matching_literals">Matching Literals</h3></div></div></div><p>When the compiler encounters an identifier defined with <code class="literal">LiteralAttribute</code> used as a case, it is called a <span class="emphasis"><em>Literal pattern</em></span> but is treated as though it were a Constant pattern.</p><p>Here is the <code class="literal">numberToString</code> function revised to use a few Literal patterns instead of Constant patterns:</p><a id="pro_id00404"/><pre class="programlisting">[&lt;LiteralAttribute&gt;]
let Zero = 0
[&lt;LiteralAttribute&gt;]
let One = 1
[&lt;LiteralAttribute&gt;]
let Two = 2
[&lt;LiteralAttribute&gt;]
let Three = 3

let numberToString =
  function
  | Zero -&gt; "zero"
  | One -&gt; "one"
  | Two -&gt; "two"
  | Three -&gt; "three"
  | _ -&gt; "unknown"</pre></div></div><div class="sect1" title="Matching Nulls"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="matching_nulls">Matching Nulls</h2></div></div></div><p>When performing pattern matching against types where <code class="literal">null</code> is a valid value, you’ll typically want to include a <span class="emphasis"><em>Null pattern</em></span> to keep any <code class="literal">null</code>s as isolated as possible. Null patterns are represented with the <code class="literal">null</code> keyword.</p><p>Consider this <code class="literal">matchString</code> pattern-matching function:</p><a id="pro_id00405"/><pre class="programlisting">&gt; <span class="strong"><strong>let matchString =</strong></span>
  <span class="strong"><strong>function</strong></span>
  <span class="strong"><strong>| "" -&gt; None</strong></span>
  <span class="strong"><strong>| v -&gt; Some(v.ToString());;</strong></span>

val matchString : _arg1:string -&gt; string option</pre><p>The <code class="literal">matchString</code> function includes two cases: a Constant pattern for the empty string and a Variable pattern for everything else. The compiler was happy to create this function for us without warning about incomplete pattern matches, but there’s a potentially serious problem: <code class="literal">null</code> is a valid value for strings, but the Variable pattern matches any value, including <code class="literal">null</code>! <a id="iddle1759" class="indexterm"/><a id="iddle2034" class="indexterm"/>Should a <code class="literal">null</code> string be passed to <code class="literal">matchString</code>, a <code class="literal">NullReferenceException</code> will be thrown when the <code class="literal">ToString</code> method is called on <code class="literal">v</code> because the Variable pattern matches <code class="literal">null</code> and therefore sets <code class="literal">v</code> to <code class="literal">null</code>, as shown here:</p><a id="pro_id00406"/><pre class="programlisting">&gt; <span class="strong"><strong>matchString null;;</strong></span>
System.NullReferenceException: Object reference not set to an instance of an object.
   at FSI_0070.matchString(String _arg1) in C:\Users\Dave\AppData\Local\Temp\~vsE434.fsx:line 68
   at &lt;StartupCode$FSI_0071&gt;.$FSI_0071.main@()
Stopped due to error</pre><p>Adding a Null pattern before the Variable pattern will ensure that the <code class="literal">null</code> value doesn’t leak into the rest of the application. By convention, Null patterns are typically listed first, so that’s the approach shown here with the <code class="literal">null</code> and empty string patterns combined with an OR pattern:</p><a id="pro_id00407"/><pre class="programlisting">let matchString =
  function
  <span class="strong"><strong>| null</strong></span>
  | "" -&gt; None
  | v -&gt; Some(v.ToString())</pre></div><div class="sect1" title="Matching Tuples"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="matching_tuples">Matching Tuples</h2></div></div></div><p>You can match and decompose a tuple to its constituent elements with a <span class="emphasis"><em>Tuple pattern</em></span>. For instance, a two-dimensional point represented as a tuple can be decomposed to its individual x- and y-coordinates with a Tuple pattern within a <code class="literal">let</code> binding like this:</p><a id="pro_id00408"/><pre class="programlisting">let point = 10, 20
let x, y = point</pre><p>In this example, the values <code class="literal">10</code> and <code class="literal">20</code> are extracted from <code class="literal">point</code> and bound to the <code class="literal">x</code> and <code class="literal">y</code> identifiers, respectively.</p><p>Similarly, you can use several Tuple patterns within a match expression to perform branching based upon the tupled values. In keeping with the point theme, to determine whether a particular point is located at the origin or along an axis, you could write something like this:</p><a id="pro_id00409"/><pre class="programlisting">let locatePoint p =
  match p with
  | ① (0, 0) -&gt; sprintf "%A is at the origin" p
  | ② (_, 0) -&gt; sprintf "%A is on the x-axis" p
  | ③ (0, _) -&gt; sprintf "%A is on the y-axis" p
  | ④ (x, y) -&gt; sprintf "Point (%i, %i)" x y</pre><p><a id="iddle1756" class="indexterm"/><a id="iddle1832" class="indexterm"/>The <code class="literal">locatePoint</code> function not only highlights using multiple Tuple patterns but also shows how multiple pattern types can be combined to form more complex branching logic. For instance, ① uses two Constant patterns within a Tuple pattern, while ② and ③ each use a Constant pattern and a Wildcard pattern within a Tuple pattern. Finally, ④ uses two Variable patterns within a Tuple pattern.</p><p>Remember, the number of items in a Tuple pattern must match the number of items in the tuple itself. For instance, attempting to match a Tuple pattern containing two items with a tuple containing three items will result in a compiler error because the underlying types are incompatible.</p></div><div class="sect1" title="Matching Records"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="matching_records">Matching Records</h2></div></div></div><p>Record types can participate in pattern matching through Record patterns. With <span class="emphasis"><em>Record patterns</em></span>, individual record instances can be matched and decomposed to their individual values.</p><p>Consider the following record type definition based on a typical American name:</p><a id="pro_id00410"/><pre class="programlisting">type Name = { First : string; Middle : string option; Last : string }</pre><p>In this record type, both the first and last names are required, but the middle name is optional. You can use a match expression to format the name according to whether a middle name is specified like so:</p><a id="pro_id00411"/><pre class="programlisting">let formatName =
  function
  | { First = f; Middle = Some(m); Last = l } -&gt; sprintf "%s, %s %s" l f m
  | { First = f; Middle = None; Last = l } -&gt; sprintf "%s, %s" l f</pre><p>Here, both patterns bind the first and last names to the identifiers <code class="literal">f</code> and <code class="literal">l</code>, respectively. But more interesting is how the patterns match the middle name against union cases for <code class="literal">Some(m)</code> and <code class="literal">None</code>. When the match expression is evaluated against a <code class="literal">Name</code> that includes a middle name, the middle name is bound to <code class="literal">m</code>. Otherwise, the match fails and the <code class="literal">None</code> case is evaluated.</p><p>The patterns in the <code class="literal">formatName</code> function extract each value from the record, but Record patterns can operate against a subset of the labels, too. For instance, if you want to determine only whether a name includes a middle name, you could construct a match expression like this:</p><a id="pro_id00412"/><pre class="programlisting">let hasMiddleName =
  function
  | { Middle = Some(_) } -&gt; true
  | { Middle = None } -&gt; false</pre><p><a id="iddle1144" class="indexterm"/><a id="iddle1582" class="indexterm"/><a id="iddle1740" class="indexterm"/><a id="iddle1750" class="indexterm"/>Many times, the compiler can automatically resolve which record type the pattern is constructed against, but if it can’t, you can specify the type name as follows:</p><a id="pro_id00413"/><pre class="programlisting">let hasMiddleName =
  function
  | { <span class="strong"><strong>Name.</strong></span>Middle = Some(_) } -&gt; true
  | { <span class="strong"><strong>Name.</strong></span>Middle = None } -&gt; false</pre><p>Qualifying the pattern like this will typically be necessary only when there are multiple record types with conflicting definitions.</p></div><div class="sect1" title="Matching Collections"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="matching_collections">Matching Collections</h2></div></div></div><p>Pattern matching isn’t limited to single values or structured data like tuples and records. F# includes several patterns for matching one-dimensional arrays and lists, too. If you want to match against another collection type, you’ll typically need to convert the collection to a list or array with <code class="literal">List.ofSeq</code>, <code class="literal">Array.ofSeq</code>, or a comparable mechanism.</p><div class="sect2" title="Array Patterns"><div class="titlepage"><div><div><h3 class="title" id="array_patterns">Array Patterns</h3></div></div></div><p><span class="emphasis"><em>Array patterns</em></span> closely resemble array definitions and let you match arrays with a specific number of elements. For example, you can use Array patterns to determine the length of an array like this:</p><a id="pro_id00414"/><pre class="programlisting">let getLength =
  function
  | null -&gt; 0
  | [| |] -&gt; 0
  | [| _ |] -&gt; 1
  | [| _; _; |] -&gt; 2
  | [| _; _; _ |] -&gt; 3
  | a -&gt; a |&gt; Array.length</pre><p>Ignoring the fact that to get the length of an array you’d probably forego this contrived pattern-matching example and inspect the <code class="literal">Array.length</code> property directly, the <code class="literal">getLength</code> function shows how Array patterns can match individual array elements from fixed-size arrays.</p></div><div class="sect2" title="List Patterns"><div class="titlepage"><div><div><h3 class="title" id="list_patterns">List Patterns</h3></div></div></div><p><span class="emphasis"><em>List patterns</em></span> are similar to Array patterns except that they look like and work against F# lists. Here’s the <code class="literal">getLength</code> function revised to work with F# lists instead of arrays.</p><a id="pro_id00415"/><pre class="programlisting">let getLength =
  function
  | [ ] -&gt; 0
  | [ _ ] -&gt; 1
  | [ _; _; ] -&gt; 2
  | [ _; _; _ ] -&gt; 3
  | lst -&gt; lst |&gt; List.length</pre><p><a id="iddle1261" class="indexterm"/><a id="iddle1742" class="indexterm"/><a id="iddle1760" class="indexterm"/><a id="iddle2040" class="indexterm"/>Note that there’s no <code class="literal">null</code> case because <code class="literal">null</code> is not a valid value for an F# list.</p></div><div class="sect2" title="Cons Patterns"><div class="titlepage"><div><div><h3 class="title" id="cons_patterns">Cons Patterns</h3></div></div></div><p>Another way to match F# lists is with the <span class="emphasis"><em>Cons pattern</em></span>. In pattern matching, the cons operator (<code class="literal">::</code>) works in reverse; instead of prepending an element to a list, it separates a list’s head from its tail. This allows you to recursively match against a list with an arbitrary number of elements.</p><p>In keeping with our theme, here’s how you could use a Cons pattern to find a collection’s length through pattern matching:</p><a id="pro_id00416"/><pre class="programlisting">let getLength n =
  ① let rec len c l =
    match l with
    | ② [] -&gt; c
    | ③ _ :: t -&gt; len (c + 1) t
  len 0 n</pre><p>This version of the <code class="literal">getLength</code> function is very similar to the F# list’s internal <code class="literal">length</code> property implementation. It defines <code class="literal">len</code> ①, an internal function that recursively matches against either an empty pattern ② or a Cons pattern ③. When the empty list is matched, <code class="literal">len</code> returns the supplied count value (<code class="literal">c</code>); otherwise, it makes a recursive call, incrementing the count and passing along the tail. The Cons pattern in <code class="literal">getLength</code> uses the Wildcard pattern for the head value because it’s not needed for subsequent operations.</p></div></div><div class="sect1" title="Matching by Type"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="matching_by_type">Matching by Type</h2></div></div></div><p>F# has two ways to match against particular data types: Type-Annotated patterns and Dynamic Type-Test patterns.</p><div class="sect2" title="Type-Annotated Patterns"><div class="titlepage"><div><div><h3 class="title" id="type-annotated_patterns">Type-Annotated Patterns</h3></div></div></div><p><span class="emphasis"><em>Type-Annotated patterns</em></span> let you specify the type of the matched value. They are especially useful in pattern-matching functions where the compiler needs a little extra help determining the expected type of the function’s implicit parameter. For example, the following function is supposed to check whether a string begins with an uppercase character:</p><a id="pro_id00417"/><pre class="programlisting">// Does not compile
let startsWithUpperCase =
  function
  | ① s when ② s.Length &gt; 0 &amp;&amp; s.[0] = System.Char.ToUpper s.[0] -&gt; true
  | _ -&gt; false</pre><p><a id="iddle1329" class="indexterm"/><a id="iddle1744" class="indexterm"/>As written, though, the <code class="literal">startsWithUpperCase</code> function won’t compile. Instead, it will fail with the following error:</p><a id="pro_id00418"/><pre class="programlisting">~vsD607.fsx(83,12): error FS0072: Lookup on object of indeterminate type based
on information prior to this program point. A type annotation may be needed
prior to this program point to constrain the type of the object. This may
allow the lookup to be resolved.</pre><p>The reason this fails to compile is that the guard conditions at ② rely on string properties, but those properties aren’t available because the compiler has automatically generalized the function’s implicit parameter. To fix the problem, we could either revise the function to have an explicit string parameter or we can include a type annotation in the pattern at ① like this (note that the parentheses are required):</p><a id="pro_id00419"/><pre class="programlisting">let startsWithUpperCase =
  function
  | <span class="strong"><strong>(s : string)</strong></span> when s.Length &gt; 0 &amp;&amp; s.[0] = System.Char.ToUpper s.[0] -&gt;
    true
  | _ -&gt; false</pre><p>With the type annotation in place, the parameter is no longer automatically generalized, making the string’s properties available within the guard condition.</p></div><div class="sect2" title="Dynamic Type-Test Patterns"><div class="titlepage"><div><div><h3 class="title" id="dynamic_type-test_patterns">Dynamic Type-Test Patterns</h3></div></div></div><p><span class="emphasis"><em>Dynamic Type-Test patterns</em></span> are, in a sense, the opposite of Type-Annotated patterns. Where Type-Annotated patterns force each case to match against the same data type, Dynamic Type-Test patterns are satisfied when the matched value is an instance of a particular type; that is, if you annotate a pattern to match strings, every case must match against strings. Dynamic Type-Test patterns are therefore useful for matching against type hierarchies. For instance, you might match against an interface instance but use Dynamic Type-Test patterns to provide different logic for specific implementations. Dynamic Type-Test patterns resemble the dynamic cast operator (<code class="literal">:?&gt;</code>) except that the <code class="literal">&gt;</code> is omitted.</p><p>The following <code class="literal">detectColorSpace</code> function shows you how to use Dynamic Type-Test patterns by matching against three record types. If none of the types are matched, the function raises an exception.</p><a id="pro_id00420"/><pre class="programlisting">type RgbColor = { R : int; G : int; B : int }
type CmykColor = { C : int; M : int; Y : int; K : int }
type HslColor = { H : int; S : int; L : int }

let detectColorSpace (cs : obj) =
  match cs with
  <span class="strong"><strong>| :? RgbColor -&gt; printfn "RGB"</strong></span>
  <span class="strong"><strong>| :? CmykColor -&gt; printfn "CMYK"</strong></span>
  <span class="strong"><strong>| :? HslColor -&gt; printfn "HSL"</strong></span>
  | _ -&gt; failwith "Unrecognized"</pre></div></div><div class="sect1" title="As Patterns"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="as_patterns">As Patterns</h2></div></div></div><p><a id="iddle1123" class="indexterm"/><a id="iddle1158" class="indexterm"/><a id="iddle1739" class="indexterm"/><a id="iddle1741" class="indexterm"/>The <span class="emphasis"><em>As pattern</em></span> lets you bind a name to the whole matched value and is particularly useful in <code class="literal">let</code> bindings that use pattern matching and pattern-matching functions where you don’t have direct named access to the matched value.</p><p>Normally, a <code class="literal">let</code> binding simply binds a name to a value, but as you’ve seen, you can also use patterns in a <code class="literal">let</code> binding to decompose a value and bind a name to each of its constituent parts like this:</p><a id="pro_id00421"/><pre class="programlisting">&gt; <span class="strong"><strong>let x, y = (10, 20);;</strong></span>

val y : int = 20
val x : int = 10</pre><p>If you want to bind not only the constituent parts but also the whole value, you could explicitly use two <code class="literal">let</code> bindings like this:</p><a id="pro_id00422"/><pre class="programlisting">&gt; <span class="strong"><strong>let point = (10, 20)</strong></span>
<span class="strong"><strong>let x, y = point;;</strong></span>

val point : int * int = (10, 20)
val y : int = 20
val x : int = 10</pre><p>Having two separate <code class="literal">let</code> bindings certainly works, but it’s more succinct to combine them into one with an As pattern like so:</p><a id="pro_id00423"/><pre class="programlisting">&gt; <span class="strong"><strong>let x, y as point = (10, 20);;</strong></span>

val point : int * int = (10, 20)
val y : int = 20
val x : int = 10</pre><p>The As pattern isn’t restricted to use within <code class="literal">let</code> bindings; you can also use it within match expressions. Here, we include an As pattern in each case to bind the matched tuple to a name.</p><a id="pro_id00424"/><pre class="programlisting">let locatePoint =
  function
  | (0, 0) as p -&gt; sprintf "%A is at the origin" p
  | (_, 0) as p -&gt; sprintf "%A is on the X-Axis" p
  | (0, _) as p -&gt; sprintf "%A is on the Y-Axis" p
  | (x, y) as p -&gt; sprintf "Point (%i, %i)" x y</pre></div><div class="sect1" title="Combining Patterns with AND"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="combining_patterns_with_and">Combining Patterns with AND</h2></div></div></div><p>With <span class="emphasis"><em>AND patterns</em></span>, sometimes called <span class="emphasis"><em>Conjunctive patterns</em></span>, you match the input against multiple, compatible patterns by combining them with an ampersand (<code class="literal">&amp;</code>). For the case to match, the input must satisfy each pattern.</p><p><a id="iddle1713" class="indexterm"/><a id="iddle1753" class="indexterm"/><a id="iddle1754" class="indexterm"/>Generally speaking, AND patterns aren’t all that useful in basic pattern-matching scenarios because the more expressive guard clauses are usually better suited to the task. That said, AND patterns are still useful for things like extracting values when another pattern is matched. (AND patterns are also used heavily with active patterns, which we’ll look at later.) For example, to determine whether a two-dimensional point is located at the origin or along an axis, you could write something like this:</p><a id="pro_id00425"/><pre class="programlisting">let locatePoint =
  function
  | (0, 0) as p -&gt; sprintf "%A is at the origin" p
  | ① (x, y) &amp; (_, 0) -&gt; sprintf "(%i, %i) is on the x-axis" x y
  | ② (x, y) &amp; (0, _) -&gt; sprintf "(%i, %i) is on the y-axis" x y
  | (x, y) -&gt; sprintf "Point (%i, %i)" x y</pre><p>The <code class="literal">locatePoint</code> function uses AND patterns at ① and ② to extract the <code class="literal">x</code> and <code class="literal">y</code> values from a tuple when the second or first value is 0, respectively.</p></div><div class="sect1" title="Combining Patterns with OR"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="combining_patterns_with_or">Combining Patterns with OR</h2></div></div></div><p>If a number of patterns should execute the same code when they’re matched, you can combine them using an OR, or <span class="emphasis"><em>Disjunctive</em></span>, pattern. An <span class="emphasis"><em>OR pattern</em></span> combines multiple patterns with a vertical pipe character (<code class="literal">|</code>). In many ways, OR patterns are similar to fall-through cases in C#’s <code class="literal">switch</code> statements.</p><p>Here, the <code class="literal">locatePoint</code> function has been revised to use an OR pattern so the same message can be printed for points on either axis:</p><a id="pro_id00426"/><pre class="programlisting">let locatePoint =
  function
  | (0, 0) as p -&gt; sprintf "%A is at the origin" p
  | ① (_, 0) | ② (0, _) as p -&gt; ③ sprintf "%A is on an axis" p
  | p -&gt; sprintf "Point %A" p</pre><p>In this version of <code class="literal">locatePoint</code>, the expression at ③ is evaluated when either the pattern at ① or ② is satisfied.</p></div><div class="sect1" title="Parentheses in Patterns"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="parentheses_in_patterns">Parentheses in Patterns</h2></div></div></div><p>When combining patterns, you can establish precedence with parentheses. For instance, to extract the <code class="literal">x</code> and <code class="literal">y</code> values from a point and also match whether the point is on either axis, you could write something like this:</p><a id="pro_id00427"/><pre class="programlisting">let locatePoint =
  function
  | (0, 0) as p -&gt; sprintf "%A is at the origin" p
  | (x, y) &amp; ① ((_, 0) | (0, _)) -&gt; sprintf "(%i, %i) is on an axis" x y
  | p -&gt; sprintf "Point %A" p</pre><p><a id="iddle1001" class="indexterm"/><a id="iddle1095" class="indexterm"/><a id="iddle1098" class="indexterm"/><a id="iddle1201" class="indexterm"/><a id="iddle1431" class="indexterm"/><a id="iddle1738" class="indexterm"/>Here, you match three patterns, establishing associativity at ① by wrapping the two axis-checking patterns in parentheses.</p></div><div class="sect1" title="Active Patterns"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="active_patterns">Active Patterns</h2></div></div></div><p>When none of the built-in pattern types do quite what you need, you can turn to active patterns. <span class="emphasis"><em>Active patterns</em></span> are a special type of function definition, called an <span class="emphasis"><em>active recognizer</em></span>, where you define one or more case names for use in your pattern-matching expressions.</p><p>Active patterns have many of the same characteristics of the built-in pattern types; they accept an input value and can decompose the value to its constituent parts. Unlike basic patterns, though, active patterns not only let you define what constitutes a match for each named case, but they can also accept other inputs.</p><p>Active patterns are defined with the following syntax:</p><a id="pro_id00428"/><pre class="programlisting">let (|CaseName1|CaseName2|...|CaseNameN|) [parameters] -&gt; expression</pre><p>As you can see, the case names are enclosed between <code class="literal">(|</code> and <code class="literal">|)</code> (called <span class="emphasis"><em>banana clips</em></span>) and are pipe-delimited. The active pattern definition must always include at least one parameter for the value to match and, because active recognizer functions are curried, the matched value must be the final parameter in order to work correctly with match expressions. Finally, the expression’s return value must be one of the named cases along with any associated data.</p><p>There are plenty of uses for active patterns, but a good example lies in a possible solution to the famed FizzBuzz problem. For the uninitiated, FizzBuzz is a puzzle that employers sometimes use during interviews to help screen candidates. The task at the heart of the problem is simple and often phrased thusly:</p><div class="blockquote"><blockquote class="blockquote"><p>Write a program that prints the numbers from 1 to 100. But for multiples of three, print <code class="literal">"Fizz"</code> instead of the number; for the multiples of five, print <code class="literal">"Buzz"</code>. For numbers that are multiples of both three and five, print <code class="literal">"FizzBuzz"</code>.</p></blockquote></div><p>To be clear, active patterns certainly aren’t the only (or necessarily even the best) way to solve the FizzBuzz problem. But the FizzBuzz problem—with its multiple, overlapping rules—allows us to showcase how powerful active patterns are.</p><p>We can start by defining the active recognizer. From the preceding description, we know that we need four patterns: <code class="literal">Fizz</code>, <code class="literal">Buzz</code>, <code class="literal">FizzBuzz</code>, and a default case for everything else. We also know the criteria for each case, so our recognizer might look something like this:</p><a id="pro_id00429"/><pre class="programlisting">let (|Fizz|Buzz|FizzBuzz|Other|) n =
  match ① (n % 3, n % 5) with
  | ② 0, 0 -&gt; FizzBuzz
  | ③ 0, _ -&gt; Fizz
  | ④ _, 0 -&gt; Buzz
  | ⑤ _ -&gt; Other n</pre><p><a id="iddle1097" class="indexterm"/><a id="iddle1433" class="indexterm"/><a id="iddle1734" class="indexterm"/><a id="iddle1755" class="indexterm"/>Here we have an active recognizer that defines the four case names. The recognizer’s body relies on further pattern matching to select the appropriate case. At ①, we construct a tuple containing the modulus of <span class="emphasis"><em>n</em></span> and 3 and the modulus of <span class="emphasis"><em>n</em></span> and 5. We then use a series of Tuple patterns to identify the correct case, the most specific being ②, where both elements are 0. The cases at ③ and ④ match when <span class="emphasis"><em>n</em></span> is divisible by 3 and <span class="emphasis"><em>n</em></span> is divisible by 5, respectively. The final case, ⑤, uses the Wildcard pattern to match everything else and return <code class="literal">Other</code> along with the supplied number. The active pattern gets us only partway to the solution, though; we still need to print the results.</p><p>The active recognizer identifies only which case a given number meets, so we still need a way to translate each case to a string. We can easily map the cases with a pattern-matching function like this:</p><a id="pro_id00430"/><pre class="programlisting">let fizzBuzz =
  function
  | Fizz -&gt; "Fizz"
  | Buzz -&gt; "Buzz"
  | FizzBuzz -&gt; "FizzBuzz"
  | Other n -&gt; n.ToString()</pre><p>The preceding <code class="literal">fizzBuzz</code> function uses basic pattern matching, but instead of using the built-in patterns, it uses cases defined by the active recognizer. Note how the <code class="literal">Other</code> case includes a Variable pattern, <code class="literal">n</code>, to hold the number associated with it.</p><p>Finally, we can complete the task by printing the results. We could do this in an imperative style, but because a functional approach is more fun let’s use a sequence like this:</p><a id="pro_id00431"/><pre class="programlisting">seq { 1..100 }
|&gt; Seq.map fizzBuzz
|&gt; Seq.iter (printfn "%s")</pre><p>Here, we create a sequence containing the numbers 1 through 100 and pipe it to <code class="literal">Seq.map</code>, which creates a new sequence containing the strings returned from <code class="literal">fizzBuzz</code>. The resulting sequence is then piped on to <code class="literal">Seq.iter</code> to print each value.</p></div><div class="sect1" title="Partial Active Patterns"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="partial_active_patterns">Partial Active Patterns</h2></div></div></div><p>As convenient as active patterns are, they do have a few drawbacks. First, each input must map to a named case. Second, active patterns are limited to seven named cases. If your situation doesn’t require mapping every possible input or you need more than seven cases, you can turn to partial active patterns.</p><p><span class="emphasis"><em>Partial active patterns</em></span> follow the same basic structure as complete active patterns, but instead of a list of case names they include only a single case name followed by an underscore. The basic syntax for a partial active pattern looks like this:</p><a id="pro_id00432"/><pre class="programlisting">let (|CaseName|_|) [parameters] = expression</pre><p>The value returned by a partial active pattern is a bit different than complete active patterns, too. Instead of returning the case directly, partial active patterns return an option of the pattern’s type. For example, if you have a partial active pattern for <code class="literal">Fizz</code>, the expression needs to return either <code class="literal">Some(Fizz)</code> or <code class="literal">None</code>. As far as your match expressions are concerned, though, the option is transparent, so you need to deal only with the case name.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p><span class="emphasis"><em>If you’re following along in FSI, you’ll want to reset your session before proceeding with the next examples to avoid any potential naming conflicts between the active patterns.</em></span></p></div><p>To see partial active patterns in action, we can return to the FizzBuzz problem. Using partial active patterns lets us rewrite the solution more succinctly. We can start by defining the partial active patterns like this:</p><a id="pro_id00433"/><pre class="programlisting">let (|Fizz|_|) n = if n % 3 = 0 then Some Fizz else None
let (|Buzz|_|) n = if n % 5 = 0 then Some Buzz else None</pre><p>The first thing you probably thought after reading the preceding snippet is “Why are there only two cases when the problem specifically defines three?” The reason is that partial active patterns are evaluated independently. So, to meet the requirements, we can construct a match expression such that a single case matches both <code class="literal">Fizz</code> and <code class="literal">Buzz</code> with an AND pattern, as shown here:</p><a id="pro_id00434"/><pre class="programlisting">let fizzBuzz =
  function
  | Fizz &amp; Buzz -&gt; "FizzBuzz"
  | Fizz -&gt; "Fizz"
  | Buzz -&gt; "Buzz"
  | n -&gt; n.ToString()</pre><p>Now all that’s left is to print the required values just like we did before:</p><a id="pro_id00435"/><pre class="programlisting">seq { 1..100 }
|&gt; Seq.map fizzBuzz
|&gt; Seq.iter (printfn "%s")</pre></div><div class="sect1" title="Parameterized Active Patterns"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="parameterized_active_patterns">Parameterized Active Patterns</h2></div></div></div><p><a id="iddle1096" class="indexterm"/>All of the active patterns we’ve seen so far have accepted only the single match value; we haven’t seen any that accept additional arguments that aid in matching. Remember, active recognizer functions are curried, so to include additional parameters in your active pattern definition you’ll need to list them before the match input argument.</p><p>It’s possible to construct yet another solution to the FizzBuzz problem using only a single <span class="emphasis"><em>Parameterized partial active pattern</em></span>. Consider this definition:</p><a id="pro_id00436"/><pre class="programlisting">let (|DivisibleBy|_|) d n = if n % d = 0 then Some DivisibleBy else None</pre><p>This partial active pattern looks just like the <code class="literal">Fizz</code> and <code class="literal">Buzz</code> partial active patterns we defined in the previous section except that it includes the <code class="literal">d</code> parameter, which it uses in the expression. We can now use this pattern to resolve the correct word from any input, like so:</p><a id="pro_id00437"/><pre class="programlisting">let fizzBuzz =
  function
  | DivisibleBy 3 &amp; DivisibleBy 5 -&gt; "FizzBuzz"
  | DivisibleBy 3 -&gt; "Fizz"
  | DivisibleBy 5 -&gt; "Buzz"
  | n -&gt; n.ToString()</pre><p>Now, instead of specialized cases for <code class="literal">Fizz</code> and <code class="literal">Buzz</code>, we simply match whether the input is divisible by three or five through the parameterized pattern. Printing out the results is no different than before:</p><a id="pro_id00438"/><pre class="programlisting">seq { 1..100 }
|&gt; Seq.map fizzBuzz
|&gt; Seq.iter (printfn "%s")</pre></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00013">Summary</h2></div></div></div><p>Pattern matching is one of F#’s most powerful and versatile features. Despite some superficial similarities to case-based branching structures in other languages, F#’s match expressions are a completely different animal. Not only does pattern matching offer an expressive way to match and decompose virtually any data type, but it even returns values as well.</p><p>In this chapter, you learned how to compose match expressions directly using <code class="literal">match...with</code> and indirectly using the <code class="literal">function</code> keyword. You also saw how the simple pattern types like the Wildcard, Variable, and Constant patterns can be used independently or in conjunction with other more complex patterns like those for records and lists. Finally, you saw how you can create your own custom patterns with complete and partial active patterns.</p></div></section></body></html>