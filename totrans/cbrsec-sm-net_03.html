<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0301" class="chapter" epub:type="chapter" id="ch03" role="doc-chapter">
<header id="header0301">
<h1 class="cn"><span aria-label="32" class="page" epub:type="pagebreak" id="p32" role="doc-pagebreak"/><span aria-label="33" class="page" epub:type="pagebreak" id="p33" role="doc-pagebreak"/><a class="xref" href="nsp-enoka501485-0007.xhtml#rch03">3</a></h1>
<h1 class="ct">Filtering Network Traffic with Firewalls</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="Chapter opening icon" height="100" src="images/nsp-enoka501485-ct.jpg" width="100"/></p>
</figure>
<p class="pf"><span class="page" data-locator="p33"/>A <i>firewall</i> monitors and filters incoming and outgoing network traffic. There’s a general misconception that the firewall is always the last line of defense; in reality, a perimeter firewall should be the first obstacle adversaries encounter when they try to penetrate any network, large or small. Every time a web browser accesses a website, a messaging program sends a message, or your email client sends and receives email, the traffic generated should pass through at least one firewall along its journey.</p>
<p>In this chapter, you’ll explore two firewall solutions: iptables and pfSense. In Linux, iptables is a common firewall often used as a <i>host firewall</i> (that is, a firewall that allows or denies traffic on a specific endpoint). pfSense, which can be implemented either as an open source software <span aria-label="34" class="page" epub:type="pagebreak" id="p34" role="doc-pagebreak"/>firewall or as a hardware firewall using the appliances sold by Netgate, is used as a perimeter or boundary firewall responsible for filtering traffic for entire networks or network segments.</p>
<section>
<h2 class="ah" id="ah0501"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0501">Types of Firewalls</a></h2>
<p class="paft">A <i>hardware firewall</i> can be physically and logically placed in a network. A <i>software firewall</i>, installed as an application on an endpoint, requires more configuration of both the firewall and its connected devices to filter traffic effectively. By using one or both of these, you’re able to effectively reduce your <i>attack surface</i>, which comprises the points where an adversary can try to infiltrate, compromise, or exploit your network. Ideally, attack surfaces should be as small as possible.</p>
<p>A <i>perimeter firewall</i>, installed between your private network and other networks like the internet, can be either software- or hardware-based. Perimeter firewalls are placed at the physical and logical border of the network, making it the first thing with which traffic bound for your internal network from the public internet communicates, as well as the last thing in your network that traffic bound for the internet passes through, as shown in <a class="xref" href="nsp-enoka501485-0012.xhtml#fig0301">Figure 3-1</a>.</p>
<figure class="figure" id="fig0301">
<p class="fig"><img alt="A perimeter firewall is placed in between the Laptop and the Internet." height="277" src="images/nsp-enoka501485-fig0301.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 3-1</span>: A perimeter firewall</p>
</figcaption>
</figure>
<p>Firewalls allow or deny (block) traffic based on a <i>ruleset</i> containing a configured list of rules. The way those rules are applied to traffic depends on the type of firewall you’re using. The most common type, a <i>packet-filtering firewall</i>, inspects each packet of data attempting to make it into (or out of) your internal network and then checks that packet against its ruleset. If the packet contents match a rule in the firewall ruleset, the firewall will either allow or deny that traffic, depending on what that rule indicates it should do.</p>
<p>There are also stateful and stateless firewalls. A <i>stateful</i> firewall tracks all inbound and outbound connections and monitors each connection as a unique conversation between two endpoints. This method provides the firewall with context about any given connection and allows more granular control of traffic. By contrast, a <i>stateless</i> firewall doesn’t record information about each connection. Both iptables and pfSense are stateful firewalls.</p>
<p>Almost all operating systems come with a built-in software firewall, known as a <i>host-based firewall</i>, that filters traffic specific to that host. Most Windows and Mac devices ship with an out-of-the-box host-based firewall whose basic ruleset is functional, if not exhaustive. By design, this firewall <span aria-label="35" class="page" epub:type="pagebreak" id="p35" role="doc-pagebreak"/>works as is for ordinary purposes; users don’t need to configure their own firewall, lessening confusion as well as the need for technical support from computer manufacturers. On Linux devices, you’ll have to configure a firewall—you’ll see how to do this in the next section.</p>
<p>It’s best to use both a host firewall and a perimeter firewall and to configure them correctly for your network to add multiple layers of defense.</p>
</section>
<section>
<h2 class="ah" id="ah0502"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0502">iptables</a></h2>
<p class="paft">Linux’s iptables utility offers incredible flexibility in filtering traffic entering, traversing, or leaving a network. The firewall organizes its rules in <i>policy chains</i>, lists of rules that analyze and match packets based on their contents. Each rule determines what the firewall will do with a packet that matches its definition—it might allow, reject, or drop the packet. When a packet is allowed, it passes through the firewall unhindered. When dropped, the firewall discards the packet and sends no response back to the sender. If a packet is rejected, the firewall discards the packet and sends a rejection message back to the sender, providing context about your network and the firewall you’re using.</p>
<p>There are three main types of policy chain: <i>input chains</i>, <i>output chains</i>, and <i>forward chains</i>. Input chains determine whether to allow certain traffic into the network from an external source, such as a <i>virtual private network (VPN)</i> connection from a remote location. A VPN is a method for logically—rather than physically—connecting to disparate networks, usually for remote access from one network to the other. VPNs are covered in greater detail in <a class="xref" href="nsp-enoka501485-0014.xhtml#ch05">Chapter 5</a>.</p>
<p>Output chains indicate whether the firewall should allow certain outbound traffic to an external network. For example, <i>Internet Control Message Protocol (ICMP)</i> is primarily used to diagnose network communication issues. ICMP ping packets are outbound traffic that pass through the output chain. A ping is a query from one device to another, usually to determine whether a connection can be made between the two. You’d need to allow the ping packets to travel from your device, through your firewall, and across several other devices on the public internet, to finally reach their destination. If your output chain blocks ICMP traffic, your device would be unable to ping anything, as the firewall would block or drop those packets.</p>
<p>In most cases, your stateful firewall rules should allow both new and established connections. For example, if you create an output chain to allow your device to ping Google, you need to tell the firewall to allow inbound traffic related to established connections. Otherwise, your device will send a ping out to Google that passes through your firewall, but the response from Google would get blocked by your firewall.</p>
<p>Forward chains forward the traffic your firewall receives to another network. In a small office or home network, host-based firewalls rarely use forward chains, unless the firewall is configured to serve as a router. A perimeter firewall would use the forward chain to route traffic from your internal network to the external network, or from one network segment to <span aria-label="36" class="page" epub:type="pagebreak" id="p36" role="doc-pagebreak"/>another, likely using network address translation (NAT), as discussed in <a class="xref" href="nsp-enoka501485-0010.xhtml#ch01">Chapter 1</a>. However, a configuration of this type is more complicated than necessary for small networks and would better fit an enterprise network.</p>
<p>By using these policy chains, you’ll be able to control the traffic traversing your network at a very granular level. In the following chapters, you’ll create several Linux servers, each of which would benefit from its own host-based firewall. I recommend configuring iptables on each of these servers using the following instructions.</p>
<p class="pcust1"><span class="ccust1">Note</span> iptables isn’t capable of securing IPv6 networks and traffic. If you plan to use IPv6 in your network, you’ll need to use ip6tables in addition to iptables. Unless you have a strong use case for IPv6 in your network, I recommend disabling IPv6 completely. Disabling IPv6 is covered in <a class="xref" href="nsp-enoka501485-0013.xhtml#ch04">Chapter 4</a>.</p>
<p class="hd" id="hd0501"><a class="xref" href="nsp-enoka501485-0007.xhtml#rhd0501"><span class="ccust2">#12: Installing iptables</span></a></p>
<p class="paft">If you’ve already built a standard Ubuntu server following the steps from <a class="xref" href="nsp-enoka501485-0010.xhtml#ch01">Chapter 1</a>, you can start configuring its iptables firewall. Once you’ve mastered the basics, use that knowledge to configure iptables on all your Linux endpoints. Otherwise, go back and create your Ubuntu system now.</p>
<p>Recent versions of Ubuntu have iptables installed by default, so log in via SSH as a standard, non-root user, and check for iptables by running a version check:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -V</code></p>
<p class="cl">[sudo] password for <code class="bi">user</code>:</p>
<p class="cll">iptables v1.8.7 (nf_tables)</p>
</div>
<p>If iptables is installed, the server should return version information, as shown here. Your version may be different.</p>
<p>If iptables isn’t installed, you’ll receive an error, in which case, install iptables:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo apt install iptables</code></p>
</div>
<p>Once it’s installed, run the same version check to confirm that the installation succeeded.</p>
<p>Next, install <code>iptables-persistent</code>, a tool that allows you to save your firewall configurations and automatically reload them after a reboot of the server:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo apt install iptables-persistent</code></p>
</div>
<p>An installation wizard should take over your terminal window. You’ll be shown the file in which your server will save the firewall rules (the default file is <i>/etc/iptables/rules.v4</i>) and told that rules from this file will load at system startup. Also, you’ll need to save any changes to firewall rules manually <span aria-label="37" class="page" epub:type="pagebreak" id="p37" role="doc-pagebreak"/>beyond this installation process. Select <b>Yes</b> to save any current firewall rules. If you don’t install this component, you’ll have to reconfigure your firewall every time you restart the server.</p>
<p>You can now check the current policy chains like so:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -L</code></p>
<p class="cl">[sudo] password for <code class="i">user</code>:</p>
<p class="cl">Chain INPUT (policy ACCEPT)</p>
<p class="cl">target     prot opt source               destination</p>
<p class="cl">Chain FORWARD (policy ACCEPT)</p>
<p class="cl">target     prot opt source               destination</p>
<p class="cl">Chain OUTPUT (policy ACCEPT)</p>
<p class="cll">target     prot opt source               destination</p>
</div>
<p>In the output, <code>policy ACCEPT</code> indicates that, by default, iptables accepts all traffic for input, output, and forwarding. This default behavior is desirable because it’ll work without any user configuration. However, it’s an insecure solution, so let’s modify it.</p>
<section>
<h3 class="bh" id="bh0501"><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0501">iptables Firewall Rules</a></h3>
<p class="paft">When creating iptables rules, keep in mind that order matters. As traffic reaches your firewall, iptables checks its rules one after the other <i>in the order they appear</i>. If the traffic matches a rule, iptables won’t check any further rules—if the first rule in your list of 50 denies all traffic, the firewall will interpret this rule, reject the traffic, and stop processing, which effectively isolates your device entirely. Alternatively, if you have the same 50 rules but the first rule allows all traffic, all traffic will be allowed to pass through the firewall. You should avoid both of those situations.</p>
<p>To understand how to construct an iptables firewall rule, take a look at this example:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -A INPUT -p tcp --dport 22 -m conntrack \</code></p>
<p class="cll"><code class="b">     --ctstate NEW,ESTABLISHED -j ACCEPT</code></p>
</div>
<p>Immediately after <code>sudo</code>, iptables is invoked to begin the rule definition. The next argument determines whether the rule will be appended to (<code>-A</code>), deleted from (<code>-D</code>), or inserted into (<code>-I</code>) the specified policy chain. You can also specify <code>-R</code> in this position when replacing or updating an existing rule. The <code>INPUT</code> indicates that a rule in the input chain is being modified. You also can specify <code>OUTPUT</code>, <code>FORWARD</code>, or other policy chains.</p>
<p>In most cases, iptables needs to know the protocol and port to which the rules relate. In this example, <code>-p tcp</code> indicates the rule will apply only to TCP traffic, and <code>--dport 22</code> tells iptables that the rule applies to packets with a destination port of 22. Both of those settings are optional. You can specify multiple ports with this syntax: <code>--match multiport --dports</code> <code class="i">port1,port2,port3</code>.</p>
<p class="pcust1"><span class="ccust1">Note</span> <i>Transmission Control Protocol (TCP)</i> is a <i>reliable</i> transmission protocol, designed to ensure successful delivery of packets over a network. If a computer <span aria-label="38" class="page" epub:type="pagebreak" id="p38" role="doc-pagebreak"/>experiences packet loss during communication that’s using TCP, those lost packets will be retransmitted, ensuring all of the data sent is eventually received by the destination host. <i>User Datagram Protocol (UDP)</i> is an <i>unreliable</i> protocol and does not ensure successful transmission of data or retransmit lost packets. UDP is used when some packet loss is acceptable and usually results in a faster connection. TCP is used when reliability matters, and every packet must be transmitted successfully.</p>
<p>The iptables firewall offers multiple matching modules, and you can specify the module to use with the <code>-m</code> argument. In this example, <code>conntrack</code>, a tool that allows stateful packet inspection, is used (also optional). Some other tools include <code>connbytes</code>, which creates rules based on the amount of traffic transferred, and <code>connrate</code>, which matches on the transfer rate of the traffic. See the iptables man page for more details: <a class="url-i" href="https://linux.die.net/man/8/iptables/">https://linux.die.net/man/8/iptables/</a>.</p>
<p>Next, <code>--ctstate</code> tells iptables to allow and track traffic for the types of connections that follow—in this case, <code>NEW</code> and <code>ESTABLISHED</code>. Many values are available for connection state, but the most frequently used are <code>NEW</code>, <code>ESTABLISHED</code>, <code>RELATED</code>, and <code>INVALID</code>. New and established states are self-explanatory; the packets are part of new or established traffic flows. Related packets don’t necessarily match an established connection, but they are expected by the firewall because an existing connection necessitates it (that is, it’s expected based on the firewall’s existing context). Invalid packets are any packets that don’t match the criteria for any other states.</p>
<p>Finally, iptables will interpret <code>-j</code> and whatever follows it as the action to jump to (perform) when this rule is matched. Most commonly, it will be either <code>ACCEPT</code> to allow traffic matching this rule; <code>DROP</code>, or <code>REJECT</code>, to deny or block the traffic; or <code>LOG</code> to log the traffic to a logfile (more details on that later).</p>
<p>Now that you understand the fundamentals of iptables rules, you’ll configure your firewall to allow and deny traffic.</p>
</section>
<section>
<h3 class="bh" id="bh0502"><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0502">Configuring iptables</a></h3>
<p class="paft">When configuring iptables, first add rules to drop invalid traffic:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -A OUTPUT -m state --state INVALID -j DROP</code></p>
<p class="cll">$ <code class="b">sudo iptables -A INPUT -m state --state INVALID -j DROP</code></p>
</div>
<p>Then, add rules to accept traffic related to existing connections, as well as established connections and the loopback address to avoid any issues later (a <i>loopback address</i> is an internal address that computers use for testing and diagnosing network issues):</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code></p>
<p class="cl">$ <code class="b">sudo iptables -A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code></p>
<p class="cll">$ <code class="b">sudo iptables -A INPUT -i lo -j ACCEPT</code></p>
</div>
<p><span aria-label="39" class="page" epub:type="pagebreak" id="p39" role="doc-pagebreak"/>This allows the firewall to accept traffic matching a known connection or related to a connection in progress and discard any unexpected packets (which can protect your network from unsolicited or malicious network scanning activity).</p>
<p>Once you’ve run these commands to enter the rules into the policy chains, rerun the list command to ensure they’ve been accepted:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -L</code></p>
<p class="cl">Chain INPUT (policy ACCEPT)</p>
<p class="cl">target     prot opt source           destination</p>
<p class="cl">DROP       all  --  anywhere         anywhere         state INVALID</p>
<p class="cl">ACCEPT     all  --  anywhere         anywhere         state RELATED,ESTABLISHED</p>
<p class="cl">ACCEPT     all  --  anywhere         anywhere</p>
<p class="cl">Chain FORWARD (policy ACCEPT)</p>
<p class="cl">target     prot opt source           destination</p>
<p class="cl">Chain OUTPUT (policy ACCEPT)</p>
<p class="cl">target     prot opt source           destination</p>
<p class="cl">DROP       all  --  anywhere         anywhere         state INVALID</p>
<p class="cll">ACCEPT     all  --  anywhere         anywhere         state RELATED,ESTABLISHED</p>
</div>
<p>Notice the rules have been added under the <code>INPUT</code> and <code>OUTPUT</code> chains. The <code>FORWARD</code> chain remains empty.</p>
<p>Next, ensure that your firewall allows SSH traffic. You can do this in two ways: by broadly allowing SSH or by allowing SSH only from a subset of devices in your network. To allow SSH traffic originating from all devices in your network, use the following command:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j \ ACCEPT</code></p>
</div>
<p>Creating broad rules can be helpful when connecting to or from multiple devices using SSH within your network. However, allowing the uninhibited use of programs and leaving protocols completely open is not the most secure solution. You should allow services like SSH only to and from specific IP addresses or ranges, as allowing remote access or file transfer between your endpoints and any other device is risky.</p>
<p>You can reduce your attack surface by specifying a source IP address or range (for example, 192.168.1.25) in your input chain with the <code>-s</code> <code class="bi">source</code> option, so if you’re configuring iptables on a virtual machine, you might choose to allow connections from a single host for management purposes and deny access to all other endpoints in your network:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -A INPUT -p tcp -s 192.168.1.25 --dport 22 -m \</code></p>
<p class="cll"><code class="b">       conntrack --ctstate NEW -j ACCEPT</code></p>
</div>
<p>We append this rule to the <code>INPUT</code> policy chain using <code>-A</code>, destination port <code>22</code>, and protocol <code>TCP</code>. For <code>NEW</code> connections, iptables will <code>ACCEPT</code> traffic matching this rule. The port can be one of your choosing; just be sure that <span aria-label="40" class="page" epub:type="pagebreak" id="p40" role="doc-pagebreak"/>your SSH configuration matches your firewall rule. If the rule allows SSH on port 22 but your SSH configuration allows connections on port 2222, the firewall will block your SSH connections.</p>
<p>If you make a mistake, delete the rule by running the same command, substituting the <code>-D</code> option in place of <code>-A</code>:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo iptables -D INPUT -p tcp -s</code> <code class="bi">192.168.1.25</code> <code class="b">--dport 22 -m conntrack \ --ctstate NEW,ESTABLISHED -j ACCEPT</code></p>
</div>
<p>Alternatively, you can delete all the rules you’ve specified for any of your policy chains by using the <code class="b">-F</code> <code class="i">chain</code>, or <code class="b">--flush</code> <code class="i">chain</code>, parameter:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo iptables -F INPUT</code></p>
</div>
<p>With this basic set of rules, now you can tell iptables what to do with all other traffic (that you don’t want entering or leaving your server or network). Once you’ve created rules to allow the specific traffic you want or need the firewall to allow, you can most likely block, deny, or drop everything else. You should do this after you’ve configured your firewall rules; otherwise, you might interrupt your connection and be unable to reconnect via SSH. Using the <code class="b">-P</code> argument sets the default behavior of your policy chains and lets iptables know what to do with traffic that doesn’t match your rules. To achieve this, set the policy chains’ default behaviors to <code>DROP</code> this traffic:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -P INPUT DROP</code></p>
<p class="cl">$ <code class="b">sudo iptables -P FORWARD DROP</code></p>
<p class="cll">$ <code class="b">sudo iptables -P OUTPUT DROP</code></p>
</div>
<p>Using <code>-P</code> in this way is different from <code>-A</code> and <code>-I</code> used previously, because it doesn’t affect the firewall rules themselves; instead, it deals with the overarching policies that govern traffic in your network. Where <code>-A</code> and <code>-I</code> append or insert rules for your firewall, respectively, <code>-P</code> configures the firewall behavior one level higher.</p>
<p>At this point, checking your iptables chains should return:</p>
<div class="codeline1">
<p class="cl1f">Chain INPUT (policy DROP)</p>
<p class="cl1">target     prot opt source               destination</p>
<p class="cl1">DROP       all  --  anywhere             anywhere             state INVALID</p>
<p class="cl1">ACCEPT     all  --  anywhere             anywhere             state RELATED,ESTABLISHED</p>
<p class="cl1">ACCEPT     all  --  anywhere             anywhere</p>
<p class="cl1">ACCEPT     tcp  -- 192.168.1.25          anywhere             tcp dpt:22 ctstate NEW</p>
<p class="cl1">Chain FORWARD (policy DROP)</p>
<p class="cl1">target     prot opt source               destination</p>
<p class="cl1">Chain OUTPUT (policy DROP)</p>
<p class="cl1">target     prot opt source               destination</p>
<p class="cl1">DROP       all  --  anywhere             anywhere             state INVALID</p>
<p class="cl1l">ACCEPT     all  --  anywhere             anywhere             state RELATED,ESTABLISHED</p>
</div>
<p>Notice that the policy for all three chains has changed from <code>ACCEPT</code> to <code>DROP</code>, indicating the default behavior for each chain is to drop traffic that <span aria-label="41" class="page" epub:type="pagebreak" id="p41" role="doc-pagebreak"/>doesn’t match any of the rules you’ve created. You should also be able to identify the rules you’ve added to the chains by comparing this output to the previous output listing the iptables rules. You may receive an error that DNS is failing, because the firewall is now blocking everything not explicitly allowed, including DNS (which runs on port 53). Resolve this issue by adding the following new rules:</p>
<div class="codeline1">
<p class="cl1f">$ <code class="b">sudo iptables -A OUTPUT -p udp --dport 53 -m conntrack --ctstate NEW -j ACCEPT</code></p>
<p class="cl1l">$ <code class="b">sudo iptables -A OUTPUT -p tcp --dport 53 -m conntrack --ctstate NEW -j ACCEPT</code></p>
</div>
<p>These commands append rules to the output chain, allowing this server to make outbound requests for domain name resolution on UDP and TCP port 53. With the addition of these rules, the server can resolve domain names.</p>
<p>Test your firewall by trying to ping the server from another device in your network; you should receive an error, as ICMP isn’t allowed through the firewall. Likewise, if you try to ping anything from the server itself, you should receive a similar error:</p>
<div class="codeline">
<p class="clf">$ <code class="b">ping google.com -c 5</code></p>
<p class="cl">PING google.com (&lt;<code class="i">ip_address</code>&gt;): 56(84) bytes of data.</p>
<p class="cl">ping: sendmsg: Operation not permitted</p>
<p class="cl">ping: sendmsg: Operation not permitted</p>
<p class="cl">ping: sendmsg: Operation not permitted</p>
<p class="cl">ping: sendmsg: Operation not permitted</p>
<p class="cl">ping: sendmsg: Operation not permitted</p>
<p class="cl">--- google.com ping statistics ---</p>
<p class="cll">5 packets transmitted, 0 received, 100% packet loss, time 4000ms</p>
</div>
<p>ICMP can be such a useful troubleshooting tool that you might decide to allow ping through your iptables firewall. To do so, add the following rules:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -A INPUT -p icmp -j ACCEPT</code></p>
<p class="cll">$ <code class="b">sudo iptables -A OUTPUT -p icmp -j ACCEPT</code></p>
</div>
<p>You may discover that you need to open additional ports in the firewall. For example, if you have a proxy installed or if you build one after reading <a class="xref" href="nsp-enoka501485-0015.xhtml#ch06">Chapter 6</a>, you’ll need to open the proxy port (3128) in your firewall:</p>
<div class="codeline1">
<p class="cl1s">$ <code class="b">sudo iptables -A OUTPUT -p tcp --dport 3128 -m conntrack --ctstate NEW -j ACCEPT</code></p>
</div>
<p>In most cases, you should block web browsing in general from servers—there are few, if any, legitimate reasons to use servers for this type of activity. Ideally, from both an administrative and a security standpoint, servers should be single-purpose. Allowing any additional service—especially browsing the internet—on a server results in a larger attack surface and creates potential vulnerabilities in your network.</p>
<p><span aria-label="42" class="page" epub:type="pagebreak" id="p42" role="doc-pagebreak"/>If you decide to allow this traffic from your server(s) so the server can retrieve software updates, create output rules for ports 80 and 443, the default ports for HTTP and HTTPS traffic, respectively:</p>
<div class="codeline1">
<p class="cl1f"><code>$</code> <code class="b">sudo iptables -A OUTPUT -p tcp --dport 80 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT</code></p>
<p class="cl1l"><code>$</code> <code class="b">sudo iptables -A OUTPUT -p tcp --dport 443 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT</code></p>
</div>
<p>The only difference between the HTTP and HTTPS rules is the port number.</p>
<p>Every time you add a rule, you should test it. The easiest way to do so, in this case, will be to first test your ability to browse the internet by using a web browser on the server (if you have the GUI installed) or by using <code>curl</code> in the bash terminal. Start by installing <code>curl</code>:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo apt install curl</code></p>
</div>
<p>If you don’t have rules allowing HTTP and HTTPS, the install command will fail, as updates are typically done over HTTP. However, if you do have those rules in place, <code>curl</code> should have installed successfully, so you can now ensure ports 80 and 443 are open:</p>
<div class="codeline">
<p class="clf">$ <code class="b">curl http://icanhazip.com</code></p>
<p class="cll"><code class="i">ipaddress</code></p>
</div>
<p class="pcon">The address <a class="url-i" href="http://icanhazip.com/">http://icanhazip.com/</a> is a public service provider that will return your current public IP address when queried with <code>curl</code>. If you’re shown your current public IP address, your firewall is configured correctly.</p>
<p>If you receive an error, one of your rules may have a problem. Check for typos, and if all else fails, delete your rules and start again using the <code>-D</code> or <code>-F</code> parameters discussed earlier. Once the firewall is correctly configured, feel free to add further rules as you deem necessary.</p>
<p>One particular set of rules to add are those that block traffic to specific IP addresses. Since most public websites can have multiple IP addresses, however, blocking a site using iptables isn’t the best option, as you’d have to create rules for each unique IP address. In most cases, you’d be better off using a proxy, which we’ll cover in <a class="xref" href="nsp-enoka501485-0015.xhtml#ch06">Chapter 6</a>.</p>
<p>If you want to use iptables to block sites—say, for example, to block all traffic to and from <a class="url-i" href="https://www.squirreldirectory.com/">https://www.squirreldirectory.com/</a>, which currently resides at IP address 206.189.69.35—you would add the following rules to your <code>INPUT</code> and <code>OUTPUT</code> chains:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -A INPUT -s 206.189.69.35 -j DROP</code></p>
<p class="cll">$ <code class="b">sudo iptables -A OUTPUT -s 206.189.69.35 -j DROP</code></p>
</div>
<p>Typically, you’d add this type of rule to allow or deny traffic from a static, private IP address that isn’t expected to change, and use a proxy for public IP addresses or URLs.</p>
</section>
<section>
<h3 class="bh" id="bh0503"><span aria-label="43" class="page" epub:type="pagebreak" id="p43" role="doc-pagebreak"/><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0503">Logging iptables Behavior</a></h3>
<p class="paft">You’ve now installed and configured the iptables firewall, but you haven’t told it to log anything, so it produces no records of its behavior, which can make it difficult to troubleshoot issues or determine whether blocked traffic should have been blocked.</p>
<p>First, create a new, custom policy chain. Note that this configuration is an example of where rule order is critical. You can name the chain whatever you like, but here, we’ll call it <code>LOGGING</code>:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo iptables -N LOGGING</code></p>
</div>
<p>The <code>-N</code> parameter is used to create new chains.</p>
<p>Next, add a rule at the end of each of the <code>INPUT</code> and <code>OUTPUT</code> chains that tells iptables to send any traffic that hasn’t yet matched a rule to the new <code>LOGGING</code> chain:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -A INPUT -j LOGGING</code></p>
<p class="cll">$ <code class="b">sudo iptables -A OUTPUT -j LOGGING</code></p>
</div>
<p>Then, tell iptables to log only once per minute for each type of dropped packet:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo iptables -A LOGGING -m limit --limit 1/minute -j LOG \</code></p>
<p class="cll"><code class="b">    --log-prefix "FW-Dropped: " --log-level 4</code></p>
</div>
<p>This limit is optional, and you can set it to any period, such as <code>1/second</code>, <code>1/minute</code>, <code>1/hour</code>, or <code>1/day</code>. Limiting the number of log entries reduces both the noise within and the size of the logfiles. Add a prefix (<code>"FW-Dropped: "</code>) to the log information so the firewall log entries are easy to identify. Setting the logging level to <code>4</code> will log up to warning-level events, indicating an event that has a material effect on the server or the firewall. Increasing the number results in more events with lower severity being logged, which is useful when troubleshooting. Log levels 1 to 3 will log only events or errors with higher than warning-level severity.</p>
<p>Finally, the following command indicates to the firewall that, once logged, the packets should be dropped:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo iptables -A LOGGING -j DROP</code></p>
</div>
<p>Your firewall will now log all the dropped packets both inbound to and outbound from the server. By default, those logs will be kept in <i>/var/log/messages</i>.</p>
<p>The last step is to save your firewall configuration. Remember that iptables configurations are temporary by default and won’t survive a reboot, which is why we installed <code>iptables-persistent</code> in <a class="xref" href="nsp-enoka501485-0012.xhtml#hd0501">Project 12</a>. To save your configuration, run the following command (<code>netfilter</code> is the command used by <code>iptables-persistent</code> for this purpose):</p>
<div class="codeline1">
<p class="cl1f"><span aria-label="44" class="page" epub:type="pagebreak" id="p44" role="doc-pagebreak"/>$ <code class="b">sudo netfilter-persistent save</code></p>
<p class="cl1">run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables save</p>
<p class="cl1l">run-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables save</p>
</div>
<p>With that, the firewall is ready to go.</p>
<p>You may consider adding temporary rules to your firewall, but remember the adage that “nothing is more permanent than a temporary firewall rule” (Austin Scott). In the case of adding a temporary rule to allow a user to download a file from the internet, for example, it would be better to find a different workaround, like using another host. If a rule like this is created and left in the firewall configuration, it creates a vulnerability and reduces the security offered by the firewall. Avoid temporary rules whenever possible.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0503"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0503">pfSense</a></h2>
<p class="paft">In addition to a firewall securing each endpoint in your network with iptables, you should implement a firewall like pfSense to secure your entire network at its border. Together, these firewalls add layers to your defense-in-depth strategy, making the job of any adversary more difficult with each level of complexity. You should place a perimeter firewall at the physical edge of your network—that is, as close to the internet as possible relative to the other endpoints in your network. For most, that position will be directly behind the modem/router or network boundary point that connects your network to your internet service provider. It is possible to achieve this logically, using virtual machines and the correct routing configuration. However, the best and most secure way to set up a perimeter firewall is to use a physical device.</p>
<p>Like iptables, the pfSense firewall is stateful. However, where iptables works as a feature installed on top of a base operating system like Ubuntu, pfSense is a fully fledged operating system. It’s based on FreeBSD, an open source version of Unix (an operating system similar to Linux that uses its own kernel) that has user-friendly features like a web management interface and can be deployed as either a virtual machine or a physical appliance.</p>
<p>You have a few options when it comes to creating a physical firewall. The first is to build a device that suits this purpose from a computer with a small footprint, like the Intel Next Unit of Computing (NUC). However, for the same cost or far less, Netgate sells pfSense appliances that are easy to configure and basically ready to go out of the box.</p>
<p>For the sake of simplicity (and security), we’ll discuss using a prebuilt device. This book will not cover building a device from scratch because the risk of misconfiguration is too high, especially when an inexpensive, secure solution is readily available. The Netgate 2100 Base pfSense+ costs around $400 at the time of writing. It’s powerful enough to be capable of most anything you can throw at it, short of a full-blown enterprise network. The SG-3100 is a step up from the entry-level 1100 pfSense+ and is more fully featured. It also has higher bandwidth and is capable of greater throughput, so it’s the ideal choice for smaller networks.</p>
<p class="hd" id="hd0502"><span aria-label="45" class="page" epub:type="pagebreak" id="p45" role="doc-pagebreak"/><a class="xref" href="nsp-enoka501485-0007.xhtml#rhd0502"><span class="ccust2">#13: Installing the pfSense Firewall</span></a></p>
<p class="paft">Upon receiving your pfSense device, remove it from the box and plug it into power. Connect an Ethernet cable from the WAN port on the device to any port on your cable, DSL modem, or network boundary point device. Connect another Ethernet cable from the LAN1 port to the Ethernet port on your computer.</p>
<p>To access the pfSense configuration page from your computer, browse to 192.168.1.1, the default IP address of the SG-3100. If that doesn’t work, you may need to disconnect your computer from your regular network and manually set its IP address to 192.168.1.2 (or any other address in the 192.168.1.<i>x</i> range, except the pfSense IP of 192.168.1.1) using the following instructions. This is necessary only for the initial configuration of the device and should need to be done only once on the computer you use to set up the pfSense appliance.</p>
<section class="list">
<p class="nlh">macOS</p>
<ol style="list-style-type:none">
<li class="nl">1. Open <b>System Preferences</b>.</li>
<li class="nl">2. Click <b>Network</b>.</li>
<li class="nl">3. Select the Ethernet connection between your pfSense device and your computer, and then set the Configure IPv4 drop-down box to <b>Manually</b>.</li>
<li class="nl">4. Enter <b>192.168.1.2</b> into the IP Address field, set Subnet Mask to <b>255.255.255.0</b>, and enter <b>192.168.1.1</b> into the Router field.</li>
<li class="nl">5. Click <b>Apply</b>.</li>
<li class="nl">6. Open your web browser and browse to 192.168.1.1. You should be presented with the pfSense login page.</li>
</ol>
</section>
<section class="list">
<p class="nlh">Windows</p>
<ol style="list-style-type:none">
<li class="nl">1. Open <b>Network and Internet Settings</b>.</li>
<li class="nl">2. Click <b>Change Adapter Options</b>.</li>
<li class="nl">3. Open the Ethernet connection between your pfSense device and your computer, and then click <b>Properties▸Internet Protocol Version ▸ (TCP/IP)▸Properties</b>.</li>
<li class="nl">4. Select the <b>Use the following IP address</b> radio button.</li>
<li class="nl">5. Enter <b>192.168.1.2</b> into the IP Address field, set Subnet Mask to <b>255.255.255.0</b>, and enter <b>192.168.1.1</b> into the Default Gateway field.</li>
<li class="nl">6. Click <b>OK</b> and close the remaining windows.</li>
<li class="nl">7. Open your web browser and browse to 192.168.1.1. You should be presented with the pfSense login page.</li>
</ol>
</section>
<section class="list">
<p class="nlh">Linux</p>
<ol style="list-style-type:none">
<li class="nl">1. Open <b>Settings</b>.</li>
<li class="nl">2. Click <b>Network</b>.</li>
<li class="nl">3. On the Ethernet connection between your pfSense device and your computer, click the configure <b>Cog</b>.</li>
<li class="nl"><span aria-label="46" class="page" epub:type="pagebreak" id="p46" role="doc-pagebreak"/>4. Select the <b>IPv4</b> tab.</li>
<li class="nl">5. Select the <b>Manual</b> radio button.</li>
<li class="nl">6. Enter <b>192.168.1.2</b> into the IP Address field, set Netmask to <b>255.255.255.0</b>, and enter <b>192.168.1.1</b> into the Gateway field.</li>
<li class="nl">7. Click <b>Apply</b> and close the Settings windows.</li>
<li class="nll">8. Open your web browser and browse to 192.168.1.1. You should be presented with the pfSense login page.</li>
</ol>
</section>
<p class="pcust1"><span class="ccust1">Note</span> If you receive a warning message indicating the site is not private or is unsafe, click through to the login page. This warning appears because there’s no SSL certificate configured, and you can ignore it for now. However, be wary of errors like this elsewhere; generally, an SSL certificate error (especially on the internet) is a serious warning that the page you’re trying to access is insecure.</p>
<p>On the pfSense login page, log in with the credentials provided when you received your device. Once you’re logged in, accept the end-user license agreement (EULA) if one is presented. Take a moment to review the system information, and then click the <b>System</b> menu at the top of the page and start the <b>Setup Wizard</b>. Use the following steps to finish setting up pfSense:</p>
<ol style="list-style-type:none">
<li class="nlf">1. At the welcome screen, click <b>Next</b>.</li>
<li class="nl">2. If the Support screen is displayed, click <b>Next</b>.</li>
<li class="nl">3. On the General Information screen, choose a hostname for the device, or leave it as the default, pfSense.</li>
<li class="nl">4. If you have a domain configured in your environment, enter it in the Domain field.</li>
<li class="nl">5. Ignore the DNS settings for now and click <b>Next</b>.</li>
<li class="nl">6. On the Time Server Information screen, accept the default Time server hostname, unless you have a time server in your environment, in which case enter its details here.</li>
<li class="nll">7. Be sure to select the correct time zone, and then click <b>Next</b>.</li>
</ol>
<p>You should now see the Configure WAN Interface page. You can use this page to configure your pfSense appliance to connect to your internet service provider. We’ll cover the most common configuration here, called <i>PPPoE</i>, that will most likely match the settings in your current modem/router. If not, contact your internet service provider for the correct configuration details for your connection.</p>
<ol style="list-style-type:none">
<li class="nlf">8. In the SelectedType box, select <b>PPPoE</b>.</li>
<li class="nl">9. Skip the General configuration options to accept the default settings.</li>
<li class="nl">10. Static IP Configuration and DHCP client configuration should be grayed out, so move on to PPPoE configuration.</li>
<li class="nl">11. Enter the username and password provided to you by your internet service provider.</li>
<li class="nl"><span aria-label="47" class="page" epub:type="pagebreak" id="p47" role="doc-pagebreak"/>12. Accept all other settings as default and click <b>Next</b>.</li>
<li class="nl">13. Set the LAN IP address of the pfSense appliance. You can choose to keep the IP addressing scheme you identified in <a class="xref" href="nsp-enoka501485-0010.xhtml#ch01">Chapter 1</a> by giving this device the first IP in the address range (192.168.1.1 in the case of an address scheme of 192.168.0.0/16), or you can change it by specifying a different LAN IP address on this page. If you’d like addresses in the 10.0.0.0/8 range, specify 10.0.0.1, and so on. Then click <b>Next</b>.</li>
<li class="nll">14. Change the administrator password. Be sure to select a strong passphrase at least 12 characters in length or longer, and save it in a password safe (we’ll discuss this further in <a class="xref" href="nsp-enoka501485-0020.xhtml#ch11">Chapter 11</a>). Once done, click <b>Next▸Reload▸Finish</b>.</li>
</ol>
<p>Your initial configuration is now complete. Assuming the device has been able to connect to your internet service provider with your credentials, you should be able to browse the internet. If not, you may have to do some troubleshooting. The best place for troubleshooting any issues is in the System Logs page within the Status menu at the top of the web interface. With any luck, any issues will become evident once you’ve looked over the logs. If you’re sure you entered all of the configuration details correctly, reach out to your internet service provider to ensure your settings are correct.</p>
<section>
<h3 class="bh" id="bh0504"><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0504">Hardening pfSense</a></h3>
<p class="paft">Your firewall is now configured and running, and it should already do a brilliant job of rejecting unsolicited traffic attempting to enter your network. However, you can take additional steps to ensure your device and network are even more secure.</p>
<p>While logged in to your pfSense device, click <b>System▸Advanced</b>.</p>
<figure class="figure" id="fig0302">
<p class="fig"><img alt="A screenshot showing the Advanced tab user interface where you can enter the SSL/TSL Certificate and TCP port." height="392" src="images/nsp-enoka501485-fig0302.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 3-2</span>: Advanced pfSense menu</p>
</figcaption>
</figure>
<p>In the Advanced menu tabs, you can change the protocols, ports, and proxy settings that pfSense uses, among other things. Click <b>Save</b> before leaving a tab if you change any settings.</p>
<p>In the Admin Access tab shown in <a class="xref" href="nsp-enoka501485-0012.xhtml#fig0302">Figure 3-2</a>, set webConfigurator Protocol to <b>HTTPS</b> to ensure a secure, encrypted connection to the device. It’s always preferable to use HTTPS instead of the unencrypted HTTP protocol because the added encryption ensures that, even if the network traffic is intercepted by an adversary, the adversary can’t decrypt it.</p>
<p><span aria-label="48" class="page" epub:type="pagebreak" id="p48" role="doc-pagebreak"/>In the next section of the Admin Access page (not shown in <a class="xref" href="nsp-enoka501485-0012.xhtml#fig0302">Figure 3-2</a>), you can change the SSH options. I recommend not allowing SSH access to the device all the time—that would be similar to leaving your front door unlocked at night. If you allow SSH access only while you’re actively using it, adversaries are able to attempt to access your network this way only while the service is available. Having the service turned off 99 percent of the time means attackers have only 1 percent of the time to attempt to breach the network. Disable this option unless you’re actively connecting to the device via SSH. Once these settings have been updated, click <b>Save</b>.</p>
<p>On the Networking tab, you can enable or disable IPv6 traffic. If you’re not actively using IPv6, disable it here to reduce your attack surface. Doing so should make the remaining settings on this page moot.</p>
<p>If you’re using a proxy for your web traffic, enter your proxy details in the Miscellaneous tab. If you’re planning to build your own proxy server using the steps detailed in <a class="xref" href="nsp-enoka501485-0015.xhtml#ch06">Chapter 6</a>, revisit this chapter and enter the proxy details at that stage.</p>
</section>
<section>
<h3 class="bh" id="bh0505"><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0505">pfSense Firewall Rules</a></h3>
<p class="paft">The default pfSense firewall rules will block traffic from both RFC1918 private network connections and <i>bogon networks</i> from entering your network from the internet. RFC1918 addresses, discussed in <a class="xref" href="nsp-enoka501485-0010.xhtml#ch01">Chapter 1</a>, are IP address ranges reserved for private, internal network use only, meaning addresses in these ranges should not appear on the public internet. They include the following ranges: 192.168.0.0/16, 10.0.0.0/8, and 172.16.0.0/12. If any of these happen to appear on the internet, your firewall should find this suspicious and discard that traffic. Similarly, bogon networks or bogon addresses are those that are public but haven’t been assigned to anyone by IANA. If an as-yet-unassigned address or address range is sending your network traffic, this is also suspicious, and the firewall should discard it.</p>
<p>While the default firewall rules are a good start, you should add a few rules manually to provide a higher level of security. For example, you shouldn’t allow services such as <i>Server Message Block (SMB)</i>, the service that allows Windows computers to share files across a network, to send or receive outbound or inbound traffic from your network to the internet or receive inbound traffic from the internet.</p>
<p class="pcust1"><span class="ccust1">Note</span> The WannaCry ransomware of May 2017 spread using an SMB vulnerability known as EternalBlue; blocking SMB at your perimeter firewall significantly reduces your risk of exposure to this vulnerability and the risk of other vulnerabilities like it being used to compromise your network.</p>
<p>To add a rule that blocks SMB traffic, follow these steps:</p>
<ol style="list-style-type:none">
<li class="nlf">1. In pfSense, at the top of the page, click <b>Firewall▸Rules</b>.</li>
<li class="nl">2. Click <b>LAN▸Add</b> to begin adding a rule.</li>
<li class="nl">3. Set the action to either <b>block</b> (drop the packets) or <b>reject</b> (drop the packets and notify the sender).</li>
<li class="nl"><span aria-label="49" class="page" epub:type="pagebreak" id="p49" role="doc-pagebreak"/>4. Set Address Family to <b>IPv4</b> and Protocol to <b>TCP</b>.</li>
<li class="nl">5. Set Source to <b>Any</b>, Destination to <b>Any</b>, and Destination Port Range (to and from) to <b>(other) 445</b>.</li>
<li class="nll">6. Ensure the <b>Log</b> box is ticked to log any dropped packets, and then click <b>Save</b>.</li>
</ol>
<p>Once you’re done, your firewall should no longer allow SMB traffic to pass your network boundary. Follow this same process for ports 137, 138, and 139, as these services (NetBIOS Name Resolution, NetBIOS Datagram Service, and NetBIOS Session Service) should never be allowed to cross the network boundary either, as all of these protocols are used for processes internal to a local network.</p>
<aside aria-labelledby="bxheader0301" class="box">
<div class="bxheader" id="bxheader0301">
<p class="bxh">Common Protocols to Block</p>
</div>
<p class="bxaft">Several network protocols should never cross the network boundary or perimeter, for example:</p>
<ul style="list-style-type:none">
<li class="bxulf">• NetBIOS Name Resolution, TCP and UDP port 137: Precursor to DNS, resolves hostnames to IP addresses</li>
<li class="bxul">• NetBIOS Datagram Service, UDP port 138: Enables unicast, multicast, and broadcast messages within a network</li>
<li class="bxul">• NetBIOS Session Service, TCP port 139: Facilitates communication between two computers on a network</li>
<li class="bxul">• MS RPC, TCP and UDP port 135: Facilitates communication between client/server applications</li>
<li class="bxul">• Telnet, TCP port 23: An insecure plaintext protocol used for remote access and maintenance of systems</li>
<li class="bxul">• SMB, TCP port 445: Allows Windows computers to share files across a network</li>
<li class="bxul">• SNMP, UDP ports 161 and 162: Used for remote system management and monitoring</li>
<li class="bxul">• TFTP, TCP and UDP port 69: Enables file transfer between computers on a network</li>
</ul>
</aside>
<p class="hd" id="hd0503"><a class="xref" href="nsp-enoka501485-0007.xhtml#rhd0503"><span class="ccust2">#14: Testing Your Firewall</span></a></p>
<p class="paft">With one or more of these rules in place, test the firewall to ensure the blocked traffic is actually being blocked. The best tool for this purpose is <i>Nmap</i>, which is used for network scanning or network mapping. It’s available in GUI form on Windows, Linux, and Mac (called <i>Zenmap</i>) and also as <span aria-label="50" class="page" epub:type="pagebreak" id="p50" role="doc-pagebreak"/>a command line tool. Installing the GUI version will make it available on the command line, so download and install the latest version from <a class="url-i" href="https://www.nmap.org/">https://www.nmap.org/</a>.</p>
<p>Otherwise, you can install it using the command line on Ubuntu:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo apt install nmap</code></p>
</div>
<p>Once you’ve installed Nmap, use the following command to scan port 445 from the command line, which we’ve told the firewall to block:</p>
<div class="codeline">
<p class="clf">$ <code class="b">sudo nmap -p 445 -A scanme.nmap.org</code></p>
<p class="cl"><code class="i">--snip--</code></p>
<p class="cl">Nmap scan report for scanme.nmap.org (45.33.32.156)</p>
<p class="cl">Host is up (0.20s latency).</p>
<p class="cl">Other addresses for scanme.nmap.org (not scanned): 2600:3c01::f03c:91ff:fe18:bb2f</p>
<p class="cl">PORT    STATE    SERVICE      VERSION</p>
<p class="cl">445/tcp filtered microsoft-ds</p>
<p class="cl">Service detection performed. Please report any incorrect results at https://nmap.org/submit/.</p>
<p class="cll">Nmap done: 1 IP address (1 host up) scanned in 2.54 seconds</p>
</div>
<p>You can use the same command in the Zenmap GUI—just exclude <code>sudo</code>. This command will perform a port scan from your device, which is behind your firewall, on the <a class="url-i" href="http://scanme.nmap.org/">http://scanme.nmap.org/</a> website, a public web page available for testing purposes from the creators of Nmap.</p>
<p>The command breaks down like this: <code>nmap</code> is the name of the program. The <code>-p 445</code> argument specifies the port or ports to be scanned, which can be either a comma-separated list (such as <code>-p 445,137,138,22</code>), a specific port as shown, or a port range like <code>-p1-1024</code>. The <code>-A</code> argument tells Nmap to try to identify the service and operating system on each scanned port, and <code>scanme.nmap.org</code> is the website or system to scan. If the results come back and the <code>STATE</code> shown for the port is <code>filtered</code>, the firewall has blocked the traffic, and the firewall rules are working. If the <code>STATE</code> shows <code>closed</code>, the firewall is allowing the traffic through, and the website itself, rather than the firewall, was returning a response saying the port is closed. If you receive this result, your firewall rule either isn’t configured or isn’t working.</p>
<p>Once your rules are working, go to the firewall logs to see the blocked packets. In pfSense, at the top of the page, click <b>Status▸System Logs▸Firewall</b> to see the last 500 entries in the firewall log, as shown in <a class="xref" href="nsp-enoka501485-0012.xhtml#fig0303">Figure 3-3</a>.</p>
<figure class="figure" id="fig0303">
<p class="fig"><span aria-label="51" class="page" epub:type="pagebreak" id="p51" role="doc-pagebreak"/><img alt="The pfSense Firewall Log includes the following information for each entry: Action, Time, Interface, Rule, Source, Destination, and Protocol." height="352" src="images/nsp-enoka501485-fig0303.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 3-3</span>: pfSense firewall log</p>
</figcaption>
</figure>
<p>In all likelihood, you’ll see a lot of blocked traffic. At this stage, it’s difficult to know what this blocked traffic could be. As an example, one of the entries at the top of my log shows a blocked connection from the IP address 80.82.77.245 on port 46732.</p>
<p>Upon further investigation, it appears as though this is a service that performs regular network scans of public IP addresses for “research purposes.” That said, it could be anything; how do I know whether this “research” is legitimate or an adversary attempting to find holes in my firewall to penetrate my network? In most cases, it’s impossible to know, but at least my firewall is actively blocking this activity, and I can find it in the firewall logs if I need to review it and act on it. We’ll discuss what you can do with this information in greater detail in <a class="xref" href="nsp-enoka501485-0019.xhtml#ch10">Chapter 10</a>, which covers network security monitoring.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0504"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0504">Summary</a></h2>
<p class="paft">Your network and hosts are demonstrably more secure for having host- and network-based firewalls in place. In the projects for this chapter, you’ve created rules and rulesets to make it significantly more difficult for an adversary trying to infiltrate your network, and even more challenging to do so undetected.</p>
<p>While this chapter has armed you with the fundamentals and a greater understanding of firewalls, it’s in your best interest to further research the ports and protocols you’d like to allow or deny within, as well as into and out of, your network. Every network will be different and have different requirements.</p>
</section>
</section>
</div></body></html>