["```\n#include <sys/mman.h>\n\nvoid *`mmap`(void **addr*, size_t *length*, int *prot*, int\n *flags*, int *fd*, off_t *offset*);\n```", "```\n`mmap/mmcat.c`\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    char *addr;\n    int fd;\n    struct stat sb;\n\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s file\\n\", argv[0]);\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd == -1)\n        errExit(\"open\");\n\n    /* Obtain the size of the file and use it to specify the size of\n       the mapping and the size of the buffer to be written */\n\n    if (fstat(fd, &sb) == -1)\n        errExit(\"fstat\");\n\n    addr = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n    if (addr == MAP_FAILED)\n        errExit(\"mmap\");\n\n    if (write(STDOUT_FILENO, addr, sb.st_size) != sb.st_size)\n        fatal(\"partial/failed write\");\n    exit(EXIT_SUCCESS);\n}\n     `mmap/mmcat.c`\n```", "```\n#include <sys/mman.h>\n\nint `munmap`(void **addr*, size_t *length*);\n```", "```\naddr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\nif (addr == MAP_FAILED)\n    errExit(\"mmap\");\n\n/* Code for working with mapped region */\n\nif (munmap(addr, length) == -1)\n    errExit(\"munmap\");\n```", "```\n$ `dd if=/dev/zero of=s.txt bs=1 count=1024`\n1024+0 records in\n1024+0 records out\n```", "```\n$ `./t_mmap s.txt hello`\nCurrent string=\nCopied \"hello\" to shared memory\n```", "```\n$ `./t_mmap s.txt goodbye`\nCurrent string=hello\nCopied \"goodbye\" to shared memory\n```", "```\n$ `od -c -w8 s.txt`\n0000000   g   o   o   d   b   y   e nul\n0000010 nul nul nul nul nul nul nul nul\n*\n0002000\n```", "```\n`mmap/t_mmap.c`\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\n#define MEM_SIZE 10\n\nint\nmain(int argc, char *argv[])\n{\n    char *addr;\n    int fd;\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s file [new-value]\\n\", argv[0]);\n\n    fd = open(argv[1], O_RDWR);\n    if (fd == -1)\n        errExit(\"open\");\n\n    addr = mmap(NULL, MEM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if (addr == MAP_FAILED)\n        errExit(\"mmap\");\n\n    if (close(fd) == -1)                /* No longer need 'fd' */\n        errExit(\"close\");\n\n    printf(\"Current string=%.*s\\n\", MEM_SIZE, addr);\n                /* Secure practice: output at most MEM_SIZE bytes */\n\n    if (argc > 2) {                     /* Update contents of region */\n        if (strlen(argv[2]) >= MEM_SIZE)\n            cmdLineErr(\"'new-value' too large\\n\");\n\n        memset(addr, 0, MEM_SIZE);      /* Zero out region */\n        strncpy(addr, argv[2], MEM_SIZE - 1);\n        if (msync(addr, MEM_SIZE, MS_SYNC) == -1)\n            errExit(\"msync\");\n\n        printf(\"Copied \\\"%s\\\" to shared memory\\n\", argv[2]);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `mmap/t_mmap.c`\n```", "```\n#include <sys/mman.h>\n\nint `msync`(void **addr*, size_t *length*, int *flags*);\n```", "```\nfd = open(\"/dev/zero\", O_RDWR);\nif (fd == -1)\n    errExit(\"open\");\naddr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\nif (addr == MAP_FAILED)\n    errExit(\"mmap\");\n```", "```\naddr = mmap(NULL, length, PROT_READ | PROT_WRITE,\n            MAP_SHARED | MAP_ANONYMOUS, -1, 0);\nif (addr == MAP_FAILED)\n    errExit(\"mmap\");\n```", "```\n$ `./anon_mmap`\nChild started, value = 1\nIn parent, value = 2\n```", "```\n`mmap/anon_mmap.c`\n#ifdef USE_MAP_ANON\n#define _BSD_SOURCE             /* Get MAP_ANONYMOUS definition */\n#endif\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int *addr;                  /* Pointer to shared memory region */\n\n#ifdef USE_MAP_ANON             /* Use MAP_ANONYMOUS */\n    addr = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE,\n                MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    if (addr == MAP_FAILED)\n        errExit(\"mmap\");\n\n#else                           /* Map /dev/zero */\n    int fd;\n\n    fd = open(\"/dev/zero\", O_RDWR);\n    if (fd == -1)\n        errExit(\"open\");\n\n    addr = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if (addr == MAP_FAILED)\n        errExit(\"mmap\");\n\n    if (close(fd) == -1)        /* No longer needed */\n        errExit(\"close\");\n#endif\n\n    *addr = 1;                  /* Initialize integer in mapped region */\n\n    switch (fork()) {           /* Parent and child share mapping */\n    case -1:\n        errExit(\"fork\");\n\n    case 0:                     /* Child: increment shared integer and exit */\n        printf(\"Child started, value = %d\\n\", *addr);\n        (*addr)++;\n\n        if (munmap(addr, sizeof(int)) == -1)\n            errExit(\"munmap\");\n        exit(EXIT_SUCCESS);\n\n    default:                    /* Parent: wait for child to terminate */\n        if (wait(NULL) == -1)\n            errExit(\"wait\");\n        printf(\"In parent, value = %d\\n\", *addr);\n        if (munmap(addr, sizeof(int)) == -1)\n            errExit(\"munmap\");\n        exit(EXIT_SUCCESS);\n    }\n}\n      `mmap/anon_mmap.c`\n```", "```\n#define _GNU_SOURCE\n#include <sys/mman.h>\n\nvoid *`mremap`(void **old_address*, size_t *old_size*, size_t *new_size*,\n int *flags*, ...);\n```", "```\n[swap size] + [RAM size] * overcommit_ratio / 100\n```", "```\n#define _GNU_SOURCE\n#include <sys/mman.h>\n\nint `remap_file_pages`(void **addr*, size_t *size*, int *prot*, size_t\n *pgoff*, int *flags*);\n```", "```\nps = sysconf(_SC_PAGESIZE);               /* Obtain system page size */\naddr = mmap(0, 3 * ps, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n```", "```\nremap_file_pages(addr, ps, 0, 2, 0);\n                            /* Maps page 0 of file into page 2 of region */\nremap_file_pages(addr + 2 * ps, ps, 0, 0, 0);\n                            /* Maps page 2 of file into page 0 of region */\n```"]