- en: Chapter 7. Patterns, Patterns, Everywhere
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章 模式，模式，处处是模式
- en: Pattern matching is one of F#’s most powerful features. Patterns are so ingrained
    within the language that they’re employed by many of the constructs you’ve already
    seen, like `let` bindings, `try...with` expressions, and lambda expressions. In
    this chapter, you’ll learn about match expressions, predefined pattern types,
    and creating your own patterns with active patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是 F# 最强大的特性之一。模式在语言中根深蒂固，许多你已经见过的结构都会使用模式，例如 `let` 绑定、`try...with` 表达式和
    lambda 表达式。在本章中，你将学习匹配表达式、预定义模式类型以及如何使用活动模式创建你自己的模式。
- en: Match Expressions
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配表达式
- en: Although F# allows imperative style branching through if expressions, they can
    be difficult to maintain, particularly as the conditional logic’s complexity increases.
    Match expressions are F#’s primary branching mechanism.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 F# 允许通过 if 表达式进行命令式风格的分支，但它们可能难以维护，尤其是当条件逻辑的复杂性增加时。匹配表达式是 F# 主要的分支机制。
- en: 'On the surface, many match expressions resemble C#’s `switch` or Visual Basic’s
    `Select Case` statements, but they’re significantly more powerful. For instance,
    while `switch` and `Select Case` operate against only constant values, match expressions
    select an expression to evaluate according to which pattern matches the input.
    At their most basic, match expressions take the following form:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，许多匹配表达式类似于 C# 的 `switch` 或 Visual Basic 的 `Select Case` 语句，但它们要强大得多。例如，`switch`
    和 `Select Case` 只对常量值进行操作，而匹配表达式根据哪个模式与输入匹配来选择要评估的表达式。在最基本的形式中，匹配表达式的结构如下：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding syntax, the expression at ① is evaluated and sequentially compared
    to each pattern in the expression body until a match is found. For example, if
    the result satisfies the pattern at ②, the expression at ③ is evaluated. Otherwise,
    the pattern at ④ is tested and, if it matches, the expression at ⑤ is evaluated,
    and so on. Because match expressions also return a value, each result expression
    must be of the same type.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的语法中，① 处的表达式首先被求值，并依次与表达式体中的每个模式进行比较，直到找到匹配项。例如，如果结果满足 ② 处的模式，③ 处的表达式将被求值。否则，④
    处的模式将被测试，如果匹配，⑤ 处的表达式将被求值，依此类推。因为匹配表达式也会返回一个值，所以每个结果表达式必须是相同类型的。
- en: The fact that patterns are matched sequentially has consequences for how you
    structure your code; you must organize your match expressions such that the patterns
    are listed from most to least specific. If a more general pattern is placed ahead
    of more specific patterns in a way that prevents any subsequent patterns from
    being evaluated, the compiler will issue a warning for each affected pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是按顺序匹配的这一事实对如何构建代码有影响；你必须组织你的匹配表达式，使得模式从最具体到最一般排列。如果更一般的模式排在更具体的模式前面，以至于阻止了后续模式的评估，编译器将会对每个受影响的模式发出警告。
- en: 'Match expressions can be used with a wide variety of data types including (but
    not limited to) numbers, strings, tuples, and records. For example, here’s a function
    with a simple match expression that works with a discriminated union:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配表达式可以与各种数据类型一起使用，包括（但不限于）数字、字符串、元组和记录。例如，下面是一个简单的匹配表达式，它与一个带有区分联合类型的函数一起工作：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this snippet, `opt` is inferred to be of type `int option`, and the match
    expression includes patterns for both the `Some` and `None` cases. When the match
    expression evaluates, it first tests whether `opt` matches `Some`. If so, the
    pattern binds the value from `Some` into `v`, which is then printed when the result
    expression is evaluated. Likewise, when `None` matches, the result expression
    simply prints out `"None"`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`opt` 被推断为 `int option` 类型，匹配表达式包含了 `Some` 和 `None` 两种情况的模式。当匹配表达式被求值时，它首先测试
    `opt` 是否与 `Some` 匹配。如果匹配，模式将 `Some` 中的值绑定到 `v`，然后当结果表达式被求值时，`v` 被打印出来。同样地，当匹配到
    `None` 时，结果表达式简单地打印出 `"None"`。
- en: Guard Clauses
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 守卫子句
- en: 'In addition to matching disparate values against patterns, you can further
    refine each case through *guard clauses*, which allow you to specify additional
    criteria that must be met to satisfy a case. For instance, you can use guard clauses
    (by inserting `when` followed by a condition) to distinguish between positive
    and negative numbers like so:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将不同的值与模式进行匹配外，你还可以通过 *守卫子句* 进一步完善每种情况，这些子句允许你指定额外的条件，只有满足这些条件才能满足某个情况。例如，你可以使用守卫子句（通过插入
    `when` 后跟条件）来区分正数和负数，如下所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we have two cases with identical patterns but different guard
    clauses. Even though any integer will match any of the three patterns, the guard
    clauses on patterns ① and ② cause matching to fail unless the captured value meets
    their criteria.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个具有相同模式但不同守卫子句的情况。尽管任何整数都会匹配这三种模式中的任何一种，但模式①和②上的守卫子句会导致匹配失败，除非捕获的值符合它们的标准。
- en: 'You can combine multiple guard clauses with Boolean operators for more complex
    matching logic. For instance, you could construct a case that matches only positive,
    even integers as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用布尔运算符将多个守卫子句结合起来，以实现更复杂的匹配逻辑。例如，你可以构造一个仅匹配正整数的偶数的情况，如下所示：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Pattern-Matching Functions
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配函数
- en: 'There is an alternative match expression syntax called a *pattern-matching
    function*. With the pattern-matching function syntax, the `match...with` portion
    of the match expression is replaced with `function` like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种替代的匹配表达式语法，称为*模式匹配函数*。使用模式匹配函数语法，`match...with`部分的匹配表达式被`function`替代，如下所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see from the signature in the output, by using the pattern-matching
    function syntax, we bind `testOption` to a function that accepts an `int option`
    (with the generated name `_arg1`) and returns `unit`. Using the `function` keyword
    this way is a convenient shortcut for creating a pattern-matching lambda expression
    and is functionally equivalent to writing:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中的签名可以看到，通过使用模式匹配函数语法，我们将`testOption`绑定为一个接受`int option`（生成的名称为`_arg1`）并返回`unit`的函数。以这种方式使用`function`关键字是创建模式匹配
    lambda 表达式的便捷方式，并且在功能上等价于编写：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because pattern-matching functions are just a shortcut for lambda expressions,
    passing match expressions to higher-order functions is trivial. Suppose you want
    to filter out all of the `None` values from a list of optional integers. You might
    consider passing a pattern-matching function to the `List.filter` function like
    this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模式匹配函数只是 lambda 表达式的简化版，将匹配表达式传递给高阶函数是非常简单的。假设你想从一个包含可选整数的列表中过滤掉所有`None`值，你可以考虑将一个模式匹配函数传递给`List.filter`函数，如下所示：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the `filter` function is executed, it will invoke the pattern-matching
    function against each item in the source list, returning `true` when the item
    is `Some(_)`, or `false` when the item is `None`. As a result, the list created
    by `filter` will contain only `Some 10`, `Some 4`, `Some 0`, and `Some 7`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`filter`函数时，它将对源列表中的每一项调用模式匹配函数，当项为`Some(_)`时返回`true`，当项为`None`时返回`false`。因此，由`filter`创建的列表将只包含`Some
    10`、`Some 4`、`Some 0`和`Some 7`。
- en: Exhaustive Matching
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 穷尽匹配
- en: When a match expression includes patterns such that every possible result of
    the test expression is accounted for, it is said to be *exhaustive*, or *covering*.
    When a value exists that isn’t covered by a pattern, the compiler issues a warning.
    Consider what happens when we match against an integer but cover only a few cases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个匹配表达式包含的模式能够涵盖测试表达式的所有可能结果时，称其为*穷尽*或*覆盖*的。当存在一个未被模式覆盖的值时，编译器会发出警告。考虑当我们匹配一个整数，但只覆盖了少数几个情况时会发生什么。
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here you can see that if the integer is ever anything other than 0, 1, 2, or
    3, it will never be matched. The compiler even provides an example of a value
    that might not be covered—four, in this case. If `numberToString` is called with
    a value that isn’t covered, the call fails with a `MatchFailureException`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到如果整数是0、1、2或3之外的任何值，它将永远不会匹配。编译器甚至提供了一个可能未被覆盖的值——在这个例子中是四。如果`numberToString`被调用时传入一个未被覆盖的值，调用将失败并抛出`MatchFailureException`：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To address this problem, you could add more patterns, trying to match every
    possible value, but many times (such as with integers) matching every possible
    value isn’t feasible. Other times, you may care only about a few cases. In either
    scenario, you can turn to one of the patterns that match any value: the Variable
    pattern or the Wildcard pattern.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以添加更多模式，尝试匹配所有可能的值，但许多时候（比如整数）匹配所有可能的值是不可行的。其他时候，你可能只关心几个特定的情况。在这两种情况下，你都可以使用匹配任何值的模式：变量模式或通配符模式。
- en: Variable Patterns
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量模式
- en: '*Variable patterns* are represented with an identifier and are used whenever
    you want to match any value and bind that value to a name. Any names defined through
    Variable patterns are then available for use within guard clauses and the result
    expression for that case. For example, to make `numberToString` exhaustive, you
    could revise the function to include a Variable pattern like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量模式*通过标识符表示，并在你希望匹配任何值并将该值绑定到一个名称时使用。通过变量模式定义的任何名称都可以在该情况的守卫子句和结果表达式中使用。例如，为了使
    `numberToString` 函数更加完备，你可以像这样修改函数，加入一个变量模式：'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you include a Variable pattern at ①, anything other than 0, 1, 2, or 3
    will be bound to `n` and simply converted to a string.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 ① 处包含一个变量模式时，除了 0、1、2 或 3 之外的任何值都会被绑定到 `n`，并简单地转换为字符串。
- en: 'The identifier defined in a Variable pattern should begin with a lowercase
    letter to distinguish it from an Identifier pattern. Now, invoking `numberToString`
    with `4` will complete without error, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 变量模式中定义的标识符应该以小写字母开头，以区分它与标识符模式。现在，调用 `numberToString` 并传入 `4` 将不再出现错误，如下所示：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Wildcard Pattern
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通配符模式
- en: The *Wildcard pattern*, represented as a single underscore character (`_`),
    works just like a Variable pattern except that it discards the matched value rather
    than binding it to a name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*通配符模式*，用单个下划线字符（`_`）表示，工作原理与变量模式相同，只是它丢弃匹配的值，而不是将其绑定到名称。'
- en: Here’s the previous `numberToString` implementation revised with a Wildcard
    pattern. Note that because the matched value is discarded, we need to return a
    general string instead of something based on the matched value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是经过修改的 `numberToString` 实现，加入了通配符模式。注意，由于匹配的值会被丢弃，我们需要返回一个通用的字符串，而不是基于匹配值的字符串。
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Matching Constant Values
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配常量值
- en: '*Constant patterns* consist of hardcoded numbers, characters, strings, and
    enumeration values. You’ve already seen several examples of Constant patterns,
    but to reiterate, the first four cases in the `numberToString` function that follows
    are all Constant patterns.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量模式*由硬编码的数字、字符、字符串和枚举值组成。你已经看到了一些常量模式的例子，但为了重申，接下来 `numberToString` 函数中的前四个情况都是常量模式。'
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the numbers 0 through 3 are explicitly matched and return the number as
    a word. All other values fall into the wildcard case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字 0 到 3 被明确匹配并返回数字对应的单词。所有其他值都进入通配符情况。
- en: Identifier Patterns
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符模式
- en: When a pattern consists of more than a single character and begins with an uppercase
    character, the compiler attempts to resolve it as a name. This is called an *Identifier
    pattern* and typically refers to discriminated union cases, identifiers decorated
    with `LiteralAttribute`, or exception names (as seen in a `try...with` block).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模式由多个字符组成并且以大写字母开头时，编译器会尝试将其解析为名称。这被称为 *标识符模式*，通常指代判别联合情况、带有 `LiteralAttribute`
    的标识符或异常名称（如在 `try...with` 块中所见）。
- en: Matching Union Cases
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配联合情况
- en: When the identifier is a discriminated union case, the pattern is called a *Union
    Case pattern*. Union Case patterns must include a wildcard or identifier for each
    data item associated with that case. If the case doesn’t have any associated data,
    the case label can appear on its own.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当标识符是一个判别联合情况时，该模式被称为 *联合情况模式*。联合情况模式必须为该情况关联的每个数据项包括一个通配符或标识符。如果该情况没有任何关联数据，则情况标签可以单独出现。
- en: 'Consider the following discriminated union that defines a few shapes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下定义了一些形状的判别联合：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From this definition, it’s trivial to define a function that uses a match expression
    to calculate the perimeter of any of the included shapes. Here is one possible
    implementation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义开始，定义一个函数来使用匹配表达式计算任何包含形状的周长就变得很简单了。以下是一个可能的实现：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, each shape defined by the discriminated union is covered, and
    the data items from each case are extracted into meaningful names like `r` for
    the radius of a circle or `w` and `h` for the width and height of a rectangle,
    respectively.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由判别联合定义的每个形状都被涵盖，且每个情况中的数据项被提取为有意义的名称，例如圆的半径 `r`，矩形的宽度 `w` 和高度 `h`。
- en: Matching Literals
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配字面量
- en: When the compiler encounters an identifier defined with `LiteralAttribute` used
    as a case, it is called a *Literal pattern* but is treated as though it were a
    Constant pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到一个使用 `LiteralAttribute` 定义的标识符作为情况时，它被称为 *字面量模式*，但它的处理方式和常量模式一样。
- en: 'Here is the `numberToString` function revised to use a few Literal patterns
    instead of Constant patterns:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的 `numberToString` 函数，使用了一些字面量模式代替常量模式：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Matching Nulls
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配空值
- en: When performing pattern matching against types where `null` is a valid value,
    you’ll typically want to include a *Null pattern* to keep any `null`s as isolated
    as possible. Null patterns are represented with the `null` keyword.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当对包含 `null` 为有效值的类型进行模式匹配时，你通常会想包括一个*空值模式*，以尽可能隔离所有的 `null` 值。空值模式通过 `null`
    关键字表示。
- en: 'Consider this `matchString` pattern-matching function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个 `matchString` 模式匹配函数：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `matchString` function includes two cases: a Constant pattern for the empty
    string and a Variable pattern for everything else. The compiler was happy to create
    this function for us without warning about incomplete pattern matches, but there’s
    a potentially serious problem: `null` is a valid value for strings, but the Variable
    pattern matches any value, including `null`! Should a `null` string be passed
    to `matchString`, a `NullReferenceException` will be thrown when the `ToString`
    method is called on `v` because the Variable pattern matches `null` and therefore
    sets `v` to `null`, as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`matchString` 函数包含两种情况：一个用于空字符串的常量模式和一个用于其他所有内容的变量模式。编译器很高兴为我们创建这个函数，并且没有警告我们关于不完整的模式匹配，但这里有一个潜在的严重问题：`null`
    是字符串的有效值，但变量模式匹配任何值，包括 `null`！如果一个 `null` 字符串传递给 `matchString`，当对 `v` 调用 `ToString`
    方法时，`NullReferenceException` 将被抛出，因为变量模式匹配 `null`，并因此将 `v` 设置为 `null`，如下面所示：'
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Adding a Null pattern before the Variable pattern will ensure that the `null`
    value doesn’t leak into the rest of the application. By convention, Null patterns
    are typically listed first, so that’s the approach shown here with the `null`
    and empty string patterns combined with an OR pattern:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量模式之前添加空值模式将确保 `null` 值不会泄露到应用程序的其他部分。按照惯例，空值模式通常列在最前面，因此这里的做法是将 `null` 和空字符串模式与“或”模式结合使用：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Matching Tuples
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配元组
- en: 'You can match and decompose a tuple to its constituent elements with a *Tuple
    pattern*. For instance, a two-dimensional point represented as a tuple can be
    decomposed to its individual x- and y-coordinates with a Tuple pattern within
    a `let` binding like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*元组模式*匹配并解构元组到其组成元素。例如，一个表示二维点的元组可以通过 `let` 绑定中的元组模式解构为单独的 x 和 y 坐标，像这样：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the values `10` and `20` are extracted from `point` and bound
    to the `x` and `y` identifiers, respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，值 `10` 和 `20` 从 `point` 中提取并分别绑定到 `x` 和 `y` 标识符。
- en: 'Similarly, you can use several Tuple patterns within a match expression to
    perform branching based upon the tupled values. In keeping with the point theme,
    to determine whether a particular point is located at the origin or along an axis,
    you could write something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以在匹配表达式中使用多个元组模式，基于元组值执行分支操作。以点的主题为例，假设要判断某个点是否位于原点或沿轴线，你可以写类似以下代码：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `locatePoint` function not only highlights using multiple Tuple patterns
    but also shows how multiple pattern types can be combined to form more complex
    branching logic. For instance, ① uses two Constant patterns within a Tuple pattern,
    while ② and ③ each use a Constant pattern and a Wildcard pattern within a Tuple
    pattern. Finally, ④ uses two Variable patterns within a Tuple pattern.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`locatePoint` 函数不仅突出了使用多个元组模式，还展示了如何将多种模式类型结合起来形成更复杂的分支逻辑。例如，① 在元组模式中使用了两个常量模式，而
    ② 和 ③ 分别在元组模式中使用了一个常量模式和一个通配符模式。最后，④ 在元组模式中使用了两个变量模式。'
- en: Remember, the number of items in a Tuple pattern must match the number of items
    in the tuple itself. For instance, attempting to match a Tuple pattern containing
    two items with a tuple containing three items will result in a compiler error
    because the underlying types are incompatible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，元组模式中的项数必须与元组本身的项数相匹配。例如，尝试将一个包含两项的元组模式与一个包含三项的元组进行匹配将导致编译错误，因为它们的基础类型不兼容。
- en: Matching Records
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配记录
- en: Record types can participate in pattern matching through Record patterns. With
    *Record patterns*, individual record instances can be matched and decomposed to
    their individual values.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型可以通过记录模式参与模式匹配。使用*记录模式*，可以匹配并解构单个记录实例，提取出其各个值。
- en: 'Consider the following record type definition based on a typical American name:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下基于典型美国姓名的记录类型定义：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this record type, both the first and last names are required, but the middle
    name is optional. You can use a match expression to format the name according
    to whether a middle name is specified like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种记录类型中，名字和姓氏都是必填的，但中间名是可选的。你可以使用匹配表达式根据是否指定中间名来格式化名字，如下所示：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, both patterns bind the first and last names to the identifiers `f` and
    `l`, respectively. But more interesting is how the patterns match the middle name
    against union cases for `Some(m)` and `None`. When the match expression is evaluated
    against a `Name` that includes a middle name, the middle name is bound to `m`.
    Otherwise, the match fails and the `None` case is evaluated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个模式分别将名字和姓氏绑定到标识符 `f` 和 `l`。更有趣的是，模式如何将中间名与 `Some(m)` 和 `None` 的联合情况进行匹配。当匹配表达式与包含中间名的
    `Name` 进行评估时，中间名将绑定到 `m`。否则，匹配失败，`None` 情况会被评估。
- en: 'The patterns in the `formatName` function extract each value from the record,
    but Record patterns can operate against a subset of the labels, too. For instance,
    if you want to determine only whether a name includes a middle name, you could
    construct a match expression like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`formatName` 函数中的模式从记录中提取每个值，但记录模式也可以作用于标签的子集。例如，如果你只想确定一个名字是否包含中间名，你可以构造一个像下面这样的匹配表达式：'
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Many times, the compiler can automatically resolve which record type the pattern
    is constructed against, but if it can’t, you can specify the type name as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常可以自动解析模式是针对哪种记录类型构造的，但如果无法确定，你可以像下面这样指定类型名称：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Qualifying the pattern like this will typically be necessary only when there
    are multiple record types with conflicting definitions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过像这样限定模式，通常只有在存在多个具有冲突定义的记录类型时才需要。
- en: Matching Collections
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配集合
- en: Pattern matching isn’t limited to single values or structured data like tuples
    and records. F# includes several patterns for matching one-dimensional arrays
    and lists, too. If you want to match against another collection type, you’ll typically
    need to convert the collection to a list or array with `List.ofSeq`, `Array.ofSeq`,
    or a comparable mechanism.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配不仅限于单一值或类似元组和记录这样的结构化数据。F# 还包括几种模式，用于匹配一维数组和列表。如果你想匹配另一种集合类型，通常需要通过 `List.ofSeq`、`Array.ofSeq`
    或类似的机制将集合转换为列表或数组。
- en: Array Patterns
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组模式
- en: '*Array patterns* closely resemble array definitions and let you match arrays
    with a specific number of elements. For example, you can use Array patterns to
    determine the length of an array like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组模式*与数组定义非常相似，允许你匹配具有特定元素个数的数组。例如，你可以使用数组模式来确定数组的长度，如下所示：'
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ignoring the fact that to get the length of an array you’d probably forego this
    contrived pattern-matching example and inspect the `Array.length` property directly,
    the `getLength` function shows how Array patterns can match individual array elements
    from fixed-size arrays.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略数组长度的计算通常直接通过 `Array.length` 属性检查，而不通过这种人为的模式匹配例子，`getLength` 函数展示了数组模式如何匹配固定大小数组中的单个元素。
- en: List Patterns
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表模式
- en: '*List patterns* are similar to Array patterns except that they look like and
    work against F# lists. Here’s the `getLength` function revised to work with F#
    lists instead of arrays.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表模式*类似于数组模式，只不过它们看起来像并且作用于 F# 列表。这里是 `getLength` 函数的修改版，已调整为与 F# 列表而非数组配合使用。'
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that there’s no `null` case because `null` is not a valid value for an
    F# list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有 `null` 情况，因为 `null` 不是 F# 列表的有效值。
- en: Cons Patterns
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cons 模式
- en: Another way to match F# lists is with the *Cons pattern*. In pattern matching,
    the cons operator (`::`) works in reverse; instead of prepending an element to
    a list, it separates a list’s head from its tail. This allows you to recursively
    match against a list with an arbitrary number of elements.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种匹配 F# 列表的方法是使用 *Cons 模式*。在模式匹配中，cons 操作符 (`::`) 是反向工作的；它不是将元素添加到列表前面，而是将列表的头部和尾部分开。这使得你能够递归地匹配具有任意数量元素的列表。
- en: 'In keeping with our theme, here’s how you could use a Cons pattern to find
    a collection’s length through pattern matching:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的主题一致，下面是如何使用 Cons 模式通过模式匹配来查找集合的长度：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This version of the `getLength` function is very similar to the F# list’s internal
    `length` property implementation. It defines `len` ①, an internal function that
    recursively matches against either an empty pattern ② or a Cons pattern ③. When
    the empty list is matched, `len` returns the supplied count value (`c`); otherwise,
    it makes a recursive call, incrementing the count and passing along the tail.
    The Cons pattern in `getLength` uses the Wildcard pattern for the head value because
    it’s not needed for subsequent operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`getLength`函数与F#列表的内部`length`属性实现非常相似。它定义了`len` ①，一个内部函数，递归地匹配空模式 ② 或Cons模式
    ③。匹配到空列表时，`len`返回提供的计数值（`c`）；否则，它会递归调用，递增计数并传递尾部。`getLength`中的Cons模式使用通配符模式来匹配头值，因为在后续操作中不需要它。
- en: Matching by Type
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按类型匹配
- en: 'F# has two ways to match against particular data types: Type-Annotated patterns
    and Dynamic Type-Test patterns.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: F#有两种方式可以匹配特定的数据类型：类型注解模式和动态类型测试模式。
- en: Type-Annotated Patterns
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型注解模式
- en: '*Type-Annotated patterns* let you specify the type of the matched value. They
    are especially useful in pattern-matching functions where the compiler needs a
    little extra help determining the expected type of the function’s implicit parameter.
    For example, the following function is supposed to check whether a string begins
    with an uppercase character:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型注解模式*允许你指定匹配值的类型。它们在模式匹配函数中特别有用，在这些函数中，编译器需要一些额外的帮助来确定函数隐式参数的预期类型。例如，以下函数用于检查一个字符串是否以大写字母开头：'
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As written, though, the `startsWithUpperCase` function won’t compile. Instead,
    it will fail with the following error:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，按目前的写法，`startsWithUpperCase`函数无法编译。它会失败并显示以下错误：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The reason this fails to compile is that the guard conditions at ② rely on
    string properties, but those properties aren’t available because the compiler
    has automatically generalized the function’s implicit parameter. To fix the problem,
    we could either revise the function to have an explicit string parameter or we
    can include a type annotation in the pattern at ① like this (note that the parentheses
    are required):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该编译失败的原因是守卫条件在 ② 依赖于字符串属性，但这些属性不可用，因为编译器已经自动泛化了函数的隐式参数。为了解决这个问题，我们可以修改函数，使其显式地使用字符串参数，或者我们可以在
    ① 的模式中包括类型注解，像这样（注意括号是必须的）：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the type annotation in place, the parameter is no longer automatically
    generalized, making the string’s properties available within the guard condition.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型注解后，参数不再自动泛化，从而使得字符串的属性可以在守卫条件中使用。
- en: Dynamic Type-Test Patterns
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态类型测试模式
- en: '*Dynamic Type-Test patterns* are, in a sense, the opposite of Type-Annotated
    patterns. Where Type-Annotated patterns force each case to match against the same
    data type, Dynamic Type-Test patterns are satisfied when the matched value is
    an instance of a particular type; that is, if you annotate a pattern to match
    strings, every case must match against strings. Dynamic Type-Test patterns are
    therefore useful for matching against type hierarchies. For instance, you might
    match against an interface instance but use Dynamic Type-Test patterns to provide
    different logic for specific implementations. Dynamic Type-Test patterns resemble
    the dynamic cast operator (`:?>`) except that the `>` is omitted.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态类型测试模式*在某种程度上是类型注解模式的对立面。类型注解模式要求每个案例都匹配相同的数据类型，而动态类型测试模式在匹配的值是特定类型的实例时满足条件；也就是说，如果你注解一个模式以匹配字符串，每个案例都必须匹配字符串。因此，动态类型测试模式非常适合匹配类型层次结构。例如，你可能会匹配一个接口实例，但使用动态类型测试模式为特定的实现提供不同的逻辑。动态类型测试模式类似于动态类型转换操作符（`:?>`），除了省略了`>`符号。'
- en: The following `detectColorSpace` function shows you how to use Dynamic Type-Test
    patterns by matching against three record types. If none of the types are matched,
    the function raises an exception.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`detectColorSpace`函数展示了如何通过匹配三种记录类型来使用动态类型测试模式。如果没有类型匹配，该函数会抛出异常。
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As Patterns
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为模式
- en: The *As pattern* lets you bind a name to the whole matched value and is particularly
    useful in `let` bindings that use pattern matching and pattern-matching functions
    where you don’t have direct named access to the matched value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*As模式*让你将一个名称绑定到整个匹配值，尤其在使用模式匹配和模式匹配函数的`let`绑定中很有用，因为在这些情况下，你没有直接访问匹配值的命名方式。'
- en: 'Normally, a `let` binding simply binds a name to a value, but as you’ve seen,
    you can also use patterns in a `let` binding to decompose a value and bind a name
    to each of its constituent parts like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`let`绑定只是将一个名字绑定到一个值，但正如你所见，你还可以在`let`绑定中使用模式来分解一个值，并将名字绑定到它的每个组成部分，像这样：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you want to bind not only the constituent parts but also the whole value,
    you could explicitly use two `let` bindings like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想绑定不仅仅是组成部分，而是整个值，你可以像这样显式使用两个`let`绑定：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Having two separate `let` bindings certainly works, but it’s more succinct
    to combine them into one with an As pattern like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有两个独立的`let`绑定当然是可行的，但通过将它们合并为一个使用As模式的绑定会更加简洁，如下所示：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The As pattern isn’t restricted to use within `let` bindings; you can also use
    it within match expressions. Here, we include an As pattern in each case to bind
    the matched tuple to a name.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: As模式不仅限于在`let`绑定中使用；你还可以在匹配表达式中使用它。在这里，我们在每个案例中都包含了一个As模式，用来将匹配到的元组绑定到一个名称上。
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Combining Patterns with AND
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过AND组合模式
- en: With *AND patterns*, sometimes called *Conjunctive patterns*, you match the
    input against multiple, compatible patterns by combining them with an ampersand
    (`&`). For the case to match, the input must satisfy each pattern.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*AND模式*，有时也叫*合取模式*，你可以通过将多个兼容的模式与一个和符号（`&`）结合，来匹配输入。要匹配成功，输入必须满足每一个模式。
- en: 'Generally speaking, AND patterns aren’t all that useful in basic pattern-matching
    scenarios because the more expressive guard clauses are usually better suited
    to the task. That said, AND patterns are still useful for things like extracting
    values when another pattern is matched. (AND patterns are also used heavily with
    active patterns, which we’ll look at later.) For example, to determine whether
    a two-dimensional point is located at the origin or along an axis, you could write
    something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在基本的模式匹配场景中，AND模式并不是特别有用，因为更具表现力的守卫子句通常更适合完成任务。尽管如此，AND模式在某些情况下仍然有用，例如在匹配另一个模式时提取值。（AND模式在活跃模式中也被广泛使用，稍后我们会讨论。）例如，要确定一个二维点是否位于原点或沿坐标轴上，你可以写出类似这样的代码：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `locatePoint` function uses AND patterns at ① and ② to extract the `x` and
    `y` values from a tuple when the second or first value is 0, respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`locatePoint`函数在①和②使用与模式相结合的AND模式，从元组中提取`x`和`y`的值，当第二个或第一个值分别为0时。'
- en: Combining Patterns with OR
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过OR组合模式
- en: If a number of patterns should execute the same code when they’re matched, you
    can combine them using an OR, or *Disjunctive*, pattern. An *OR pattern* combines
    multiple patterns with a vertical pipe character (`|`). In many ways, OR patterns
    are similar to fall-through cases in C#’s `switch` statements.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个模式在匹配时应该执行相同的代码，你可以使用OR（或*析取*）模式将它们结合起来。*OR模式*通过竖线字符（`|`）将多个模式组合在一起。在许多方面，OR模式类似于C#中`switch`语句的穿透案例。
- en: 'Here, the `locatePoint` function has been revised to use an OR pattern so the
    same message can be printed for points on either axis:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`locatePoint`函数已经被修改为使用OR模式，这样就能为位于任一坐标轴上的点打印相同的信息：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this version of `locatePoint`, the expression at ③ is evaluated when either
    the pattern at ① or ② is satisfied.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的`locatePoint`中，当①或②处的模式满足时，③处的表达式会被求值。
- en: Parentheses in Patterns
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式中的括号
- en: 'When combining patterns, you can establish precedence with parentheses. For
    instance, to extract the `x` and `y` values from a point and also match whether
    the point is on either axis, you could write something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合模式时，你可以通过括号来确定优先级。例如，要从一个点中提取`x`和`y`的值，并且匹配该点是否位于任一坐标轴上，你可以写出类似这样的代码：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, you match three patterns, establishing associativity at ① by wrapping
    the two axis-checking patterns in parentheses.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你匹配了三个模式，通过将两个坐标轴检查模式用括号括起来，在①处建立了结合性。
- en: Active Patterns
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活跃模式
- en: When none of the built-in pattern types do quite what you need, you can turn
    to active patterns. *Active patterns* are a special type of function definition,
    called an *active recognizer*, where you define one or more case names for use
    in your pattern-matching expressions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当内置的模式类型无法完全满足需求时，你可以使用活跃模式。*活跃模式*是一种特殊的函数定义，称为*活跃识别器*，在这种模式下，你定义一个或多个案例名称，以便在模式匹配表达式中使用。
- en: Active patterns have many of the same characteristics of the built-in pattern
    types; they accept an input value and can decompose the value to its constituent
    parts. Unlike basic patterns, though, active patterns not only let you define
    what constitutes a match for each named case, but they can also accept other inputs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 活动模式具有许多与内置模式类型相同的特征；它们接受一个输入值，并能将该值分解为其组成部分。然而，与基本模式不同的是，活动模式不仅允许你定义每个命名情况的匹配条件，还可以接受其他输入。
- en: 'Active patterns are defined with the following syntax:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 活动模式的定义语法如下：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, the case names are enclosed between `(|` and `|)` (called *banana
    clips*) and are pipe-delimited. The active pattern definition must always include
    at least one parameter for the value to match and, because active recognizer functions
    are curried, the matched value must be the final parameter in order to work correctly
    with match expressions. Finally, the expression’s return value must be one of
    the named cases along with any associated data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，情况名称被包含在 `(|` 和 `|)` 之间（称为 *香蕉夹*），并且以管道符分隔。活动模式定义必须至少包括一个参数用于匹配值，并且由于活动识别器函数是柯里化的，匹配的值必须是最终参数，以便与匹配表达式正确配合。最后，表达式的返回值必须是其中一个命名的情况，并附带任何相关的数据。
- en: 'There are plenty of uses for active patterns, but a good example lies in a
    possible solution to the famed FizzBuzz problem. For the uninitiated, FizzBuzz
    is a puzzle that employers sometimes use during interviews to help screen candidates.
    The task at the heart of the problem is simple and often phrased thusly:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 活动模式有许多用途，但一个好的例子是可能解决著名的 FizzBuzz 问题。对于那些未接触过的人，FizzBuzz 是一个面试中雇主有时用来筛选候选人的谜题。问题的核心任务很简单，通常表述如下：
- en: Write a program that prints the numbers from 1 to 100\. But for multiples of
    three, print `"Fizz"` instead of the number; for the multiples of five, print
    `"Buzz"`. For numbers that are multiples of both three and five, print `"FizzBuzz"`.
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个程序，打印从 1 到 100 的数字。但是，对于 3 的倍数，打印 `"Fizz"` 代替数字；对于 5 的倍数，打印 `"Buzz"`。对于同时是
    3 和 5 的倍数的数字，打印 `"FizzBuzz"`。
- en: To be clear, active patterns certainly aren’t the only (or necessarily even
    the best) way to solve the FizzBuzz problem. But the FizzBuzz problem—with its
    multiple, overlapping rules—allows us to showcase how powerful active patterns
    are.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 明确来说，活动模式当然不是解决 FizzBuzz 问题的唯一方式（也不一定是最好的方式）。但是，FizzBuzz 问题—其包含多个重叠的规则—使我们能够展示活动模式的强大。
- en: 'We can start by defining the active recognizer. From the preceding description,
    we know that we need four patterns: `Fizz`, `Buzz`, `FizzBuzz`, and a default
    case for everything else. We also know the criteria for each case, so our recognizer
    might look something like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从定义活动识别器开始。从前面的描述中，我们知道需要四个模式：`Fizz`、`Buzz`、`FizzBuzz`，以及一个默认情况用于其他所有情况。我们还知道每种情况的标准，因此我们的识别器可能长得像这样：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here we have an active recognizer that defines the four case names. The recognizer’s
    body relies on further pattern matching to select the appropriate case. At ①,
    we construct a tuple containing the modulus of *n* and 3 and the modulus of *n*
    and 5\. We then use a series of Tuple patterns to identify the correct case, the
    most specific being ②, where both elements are 0\. The cases at ③ and ④ match
    when *n* is divisible by 3 and *n* is divisible by 5, respectively. The final
    case, ⑤, uses the Wildcard pattern to match everything else and return `Other`
    along with the supplied number. The active pattern gets us only partway to the
    solution, though; we still need to print the results.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个活动识别器，它定义了四个情况名称。识别器的主体依赖于进一步的模式匹配来选择适当的情况。在 ① 处，我们构造一个元组，包含 *n* 对 3
    和 5 的取余值。然后，我们使用一系列元组模式来识别正确的情况，最具体的是 ②，其中两个元素都为 0。③ 和 ④ 处的情况分别匹配当 *n* 能被 3 和
    5 整除时。最后一个情况⑤，使用通配符模式来匹配所有其他情况，并返回 `Other` 以及提供的数字。尽管活动模式让我们解决了一部分问题，但我们仍然需要打印结果。
- en: 'The active recognizer identifies only which case a given number meets, so we
    still need a way to translate each case to a string. We can easily map the cases
    with a pattern-matching function like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 活动识别器仅识别给定数字符合哪种情况，因此我们仍然需要一种方法将每个情况转换为字符串。我们可以使用像这样的模式匹配函数轻松地映射这些情况：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding `fizzBuzz` function uses basic pattern matching, but instead of
    using the built-in patterns, it uses cases defined by the active recognizer. Note
    how the `Other` case includes a Variable pattern, `n`, to hold the number associated
    with it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`fizzBuzz`函数使用了基本的模式匹配，但它没有使用内置的模式，而是使用了由活动识别器定义的模式。注意`Other`案例包含了一个变量模式`n`，用于保存与其关联的数字。
- en: 'Finally, we can complete the task by printing the results. We could do this
    in an imperative style, but because a functional approach is more fun let’s use
    a sequence like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过打印结果来完成任务。我们可以用命令式的方式来做，但因为函数式编程更有趣，所以我们用类似这样的序列：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we create a sequence containing the numbers 1 through 100 and pipe it
    to `Seq.map`, which creates a new sequence containing the strings returned from
    `fizzBuzz`. The resulting sequence is then piped on to `Seq.iter` to print each
    value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个包含1到100的数字的序列，并将其传递给`Seq.map`，后者创建一个包含从`fizzBuzz`返回的字符串的新序列。然后，将生成的序列传递给`Seq.iter`以打印每个值。
- en: Partial Active Patterns
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分活动模式
- en: As convenient as active patterns are, they do have a few drawbacks. First, each
    input must map to a named case. Second, active patterns are limited to seven named
    cases. If your situation doesn’t require mapping every possible input or you need
    more than seven cases, you can turn to partial active patterns.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管活动模式很方便，但它们确实有一些缺点。首先，每个输入必须映射到一个命名的案例。其次，活动模式最多只能有七个命名案例。如果你的情况不需要映射每个可能的输入，或者你需要超过七个案例，你可以转向部分活动模式。
- en: '*Partial active patterns* follow the same basic structure as complete active
    patterns, but instead of a list of case names they include only a single case
    name followed by an underscore. The basic syntax for a partial active pattern
    looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*部分活动模式*的结构与完全活动模式相同，但它们不包括案例名称的列表，而是只包括一个单一的案例名称，后跟一个下划线。部分活动模式的基本语法如下：'
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The value returned by a partial active pattern is a bit different than complete
    active patterns, too. Instead of returning the case directly, partial active patterns
    return an option of the pattern’s type. For example, if you have a partial active
    pattern for `Fizz`, the expression needs to return either `Some(Fizz)` or `None`.
    As far as your match expressions are concerned, though, the option is transparent,
    so you need to deal only with the case name.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 部分活动模式返回的值与完全活动模式有所不同。它们不会直接返回案例，而是返回模式类型的一个选项。例如，如果你有一个`Fizz`的部分活动模式，表达式需要返回`Some(Fizz)`或`None`。不过，对于匹配表达式来说，选项是透明的，因此你只需要处理案例名称。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you’re following along in FSI, you’ll want to reset your session before
    proceeding with the next examples to avoid any potential naming conflicts between
    the active patterns.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你正在F#交互式窗口中跟进，建议在继续下一个示例之前重置会话，以避免活动模式之间可能发生的命名冲突。*'
- en: 'To see partial active patterns in action, we can return to the FizzBuzz problem.
    Using partial active patterns lets us rewrite the solution more succinctly. We
    can start by defining the partial active patterns like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到部分活动模式的实际应用，我们可以回到FizzBuzz问题。使用部分活动模式可以让我们更简洁地重写解决方案。我们可以像这样定义部分活动模式：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first thing you probably thought after reading the preceding snippet is
    “Why are there only two cases when the problem specifically defines three?” The
    reason is that partial active patterns are evaluated independently. So, to meet
    the requirements, we can construct a match expression such that a single case
    matches both `Fizz` and `Buzz` with an AND pattern, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读上面的代码片段后，你可能首先想到的是“为什么只有两个案例，而问题明确指定了三个？”原因是部分活动模式是独立评估的。因此，为了满足要求，我们可以构造一个匹配表达式，使得一个案例同时匹配`Fizz`和`Buzz`，使用一个AND模式，如下所示：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now all that’s left is to print the required values just like we did before:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是像之前一样打印所需的值：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Parameterized Active Patterns
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化活动模式
- en: All of the active patterns we’ve seen so far have accepted only the single match
    value; we haven’t seen any that accept additional arguments that aid in matching.
    Remember, active recognizer functions are curried, so to include additional parameters
    in your active pattern definition you’ll need to list them before the match input
    argument.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有活动模式都只接受单一的匹配值；我们还没有看到接受额外参数来帮助匹配的模式。记住，活动识别器函数是柯里化的，因此，要在活动模式定义中包括额外的参数，你需要在匹配输入参数之前列出它们。
- en: 'It’s possible to construct yet another solution to the FizzBuzz problem using
    only a single *Parameterized partial active pattern*. Consider this definition:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用一个*参数化部分激活模式*，也可以构造另一种FizzBuzz问题的解决方案。考虑以下定义：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This partial active pattern looks just like the `Fizz` and `Buzz` partial active
    patterns we defined in the previous section except that it includes the `d` parameter,
    which it uses in the expression. We can now use this pattern to resolve the correct
    word from any input, like so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分激活模式看起来与我们在上一节中定义的`Fizz`和`Buzz`部分激活模式完全相同，唯一的区别是它包括了`d`参数，并在表达式中使用它。现在我们可以使用这个模式从任何输入中解析出正确的单词，如下所示：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, instead of specialized cases for `Fizz` and `Buzz`, we simply match whether
    the input is divisible by three or five through the parameterized pattern. Printing
    out the results is no different than before:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再为`Fizz`和`Buzz`编写专门的案例，而是通过参数化模式匹配输入是否能被三或五整除。输出结果与之前没有区别：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Pattern matching is one of F#’s most powerful and versatile features. Despite
    some superficial similarities to case-based branching structures in other languages,
    F#’s match expressions are a completely different animal. Not only does pattern
    matching offer an expressive way to match and decompose virtually any data type,
    but it even returns values as well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是F#最强大、最灵活的特性之一。尽管它在表面上与其他语言中的基于案例的分支结构有些相似，但F#的匹配表达式完全是另一种形式。模式匹配不仅提供了一种表达式丰富的方式来匹配和分解几乎任何数据类型，甚至还能够返回值。
- en: In this chapter, you learned how to compose match expressions directly using
    `match...with` and indirectly using the `function` keyword. You also saw how the
    simple pattern types like the Wildcard, Variable, and Constant patterns can be
    used independently or in conjunction with other more complex patterns like those
    for records and lists. Finally, you saw how you can create your own custom patterns
    with complete and partial active patterns.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何直接使用`match...with`构造匹配表达式，以及如何间接使用`function`关键字。你还看到简单的模式类型，如通配符、变量和常量模式，如何独立使用或与记录和列表等更复杂的模式结合使用。最后，你学习了如何使用完全和部分激活模式创建自己的自定义模式。
