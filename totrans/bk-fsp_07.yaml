- en: Chapter 7. Patterns, Patterns, Everywhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern matching is one of F#’s most powerful features. Patterns are so ingrained
    within the language that they’re employed by many of the constructs you’ve already
    seen, like `let` bindings, `try...with` expressions, and lambda expressions. In
    this chapter, you’ll learn about match expressions, predefined pattern types,
    and creating your own patterns with active patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Match Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although F# allows imperative style branching through if expressions, they can
    be difficult to maintain, particularly as the conditional logic’s complexity increases.
    Match expressions are F#’s primary branching mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the surface, many match expressions resemble C#’s `switch` or Visual Basic’s
    `Select Case` statements, but they’re significantly more powerful. For instance,
    while `switch` and `Select Case` operate against only constant values, match expressions
    select an expression to evaluate according to which pattern matches the input.
    At their most basic, match expressions take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding syntax, the expression at ① is evaluated and sequentially compared
    to each pattern in the expression body until a match is found. For example, if
    the result satisfies the pattern at ②, the expression at ③ is evaluated. Otherwise,
    the pattern at ④ is tested and, if it matches, the expression at ⑤ is evaluated,
    and so on. Because match expressions also return a value, each result expression
    must be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that patterns are matched sequentially has consequences for how you
    structure your code; you must organize your match expressions such that the patterns
    are listed from most to least specific. If a more general pattern is placed ahead
    of more specific patterns in a way that prevents any subsequent patterns from
    being evaluated, the compiler will issue a warning for each affected pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Match expressions can be used with a wide variety of data types including (but
    not limited to) numbers, strings, tuples, and records. For example, here’s a function
    with a simple match expression that works with a discriminated union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `opt` is inferred to be of type `int option`, and the match
    expression includes patterns for both the `Some` and `None` cases. When the match
    expression evaluates, it first tests whether `opt` matches `Some`. If so, the
    pattern binds the value from `Some` into `v`, which is then printed when the result
    expression is evaluated. Likewise, when `None` matches, the result expression
    simply prints out `"None"`.
  prefs: []
  type: TYPE_NORMAL
- en: Guard Clauses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to matching disparate values against patterns, you can further
    refine each case through *guard clauses*, which allow you to specify additional
    criteria that must be met to satisfy a case. For instance, you can use guard clauses
    (by inserting `when` followed by a condition) to distinguish between positive
    and negative numbers like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have two cases with identical patterns but different guard
    clauses. Even though any integer will match any of the three patterns, the guard
    clauses on patterns ① and ② cause matching to fail unless the captured value meets
    their criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine multiple guard clauses with Boolean operators for more complex
    matching logic. For instance, you could construct a case that matches only positive,
    even integers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Pattern-Matching Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is an alternative match expression syntax called a *pattern-matching
    function*. With the pattern-matching function syntax, the `match...with` portion
    of the match expression is replaced with `function` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the signature in the output, by using the pattern-matching
    function syntax, we bind `testOption` to a function that accepts an `int option`
    (with the generated name `_arg1`) and returns `unit`. Using the `function` keyword
    this way is a convenient shortcut for creating a pattern-matching lambda expression
    and is functionally equivalent to writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Because pattern-matching functions are just a shortcut for lambda expressions,
    passing match expressions to higher-order functions is trivial. Suppose you want
    to filter out all of the `None` values from a list of optional integers. You might
    consider passing a pattern-matching function to the `List.filter` function like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the `filter` function is executed, it will invoke the pattern-matching
    function against each item in the source list, returning `true` when the item
    is `Some(_)`, or `false` when the item is `None`. As a result, the list created
    by `filter` will contain only `Some 10`, `Some 4`, `Some 0`, and `Some 7`.
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustive Matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a match expression includes patterns such that every possible result of
    the test expression is accounted for, it is said to be *exhaustive*, or *covering*.
    When a value exists that isn’t covered by a pattern, the compiler issues a warning.
    Consider what happens when we match against an integer but cover only a few cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that if the integer is ever anything other than 0, 1, 2, or
    3, it will never be matched. The compiler even provides an example of a value
    that might not be covered—four, in this case. If `numberToString` is called with
    a value that isn’t covered, the call fails with a `MatchFailureException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To address this problem, you could add more patterns, trying to match every
    possible value, but many times (such as with integers) matching every possible
    value isn’t feasible. Other times, you may care only about a few cases. In either
    scenario, you can turn to one of the patterns that match any value: the Variable
    pattern or the Wildcard pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable Patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Variable patterns* are represented with an identifier and are used whenever
    you want to match any value and bind that value to a name. Any names defined through
    Variable patterns are then available for use within guard clauses and the result
    expression for that case. For example, to make `numberToString` exhaustive, you
    could revise the function to include a Variable pattern like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you include a Variable pattern at ①, anything other than 0, 1, 2, or 3
    will be bound to `n` and simply converted to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The identifier defined in a Variable pattern should begin with a lowercase
    letter to distinguish it from an Identifier pattern. Now, invoking `numberToString`
    with `4` will complete without error, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Wildcard Pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Wildcard pattern*, represented as a single underscore character (`_`),
    works just like a Variable pattern except that it discards the matched value rather
    than binding it to a name.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the previous `numberToString` implementation revised with a Wildcard
    pattern. Note that because the matched value is discarded, we need to return a
    general string instead of something based on the matched value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Matching Constant Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Constant patterns* consist of hardcoded numbers, characters, strings, and
    enumeration values. You’ve already seen several examples of Constant patterns,
    but to reiterate, the first four cases in the `numberToString` function that follows
    are all Constant patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the numbers 0 through 3 are explicitly matched and return the number as
    a word. All other values fall into the wildcard case.
  prefs: []
  type: TYPE_NORMAL
- en: Identifier Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a pattern consists of more than a single character and begins with an uppercase
    character, the compiler attempts to resolve it as a name. This is called an *Identifier
    pattern* and typically refers to discriminated union cases, identifiers decorated
    with `LiteralAttribute`, or exception names (as seen in a `try...with` block).
  prefs: []
  type: TYPE_NORMAL
- en: Matching Union Cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the identifier is a discriminated union case, the pattern is called a *Union
    Case pattern*. Union Case patterns must include a wildcard or identifier for each
    data item associated with that case. If the case doesn’t have any associated data,
    the case label can appear on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following discriminated union that defines a few shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From this definition, it’s trivial to define a function that uses a match expression
    to calculate the perimeter of any of the included shapes. Here is one possible
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each shape defined by the discriminated union is covered, and
    the data items from each case are extracted into meaningful names like `r` for
    the radius of a circle or `w` and `h` for the width and height of a rectangle,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Matching Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the compiler encounters an identifier defined with `LiteralAttribute` used
    as a case, it is called a *Literal pattern* but is treated as though it were a
    Constant pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `numberToString` function revised to use a few Literal patterns
    instead of Constant patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Matching Nulls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When performing pattern matching against types where `null` is a valid value,
    you’ll typically want to include a *Null pattern* to keep any `null`s as isolated
    as possible. Null patterns are represented with the `null` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this `matchString` pattern-matching function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `matchString` function includes two cases: a Constant pattern for the empty
    string and a Variable pattern for everything else. The compiler was happy to create
    this function for us without warning about incomplete pattern matches, but there’s
    a potentially serious problem: `null` is a valid value for strings, but the Variable
    pattern matches any value, including `null`! Should a `null` string be passed
    to `matchString`, a `NullReferenceException` will be thrown when the `ToString`
    method is called on `v` because the Variable pattern matches `null` and therefore
    sets `v` to `null`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a Null pattern before the Variable pattern will ensure that the `null`
    value doesn’t leak into the rest of the application. By convention, Null patterns
    are typically listed first, so that’s the approach shown here with the `null`
    and empty string patterns combined with an OR pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Matching Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can match and decompose a tuple to its constituent elements with a *Tuple
    pattern*. For instance, a two-dimensional point represented as a tuple can be
    decomposed to its individual x- and y-coordinates with a Tuple pattern within
    a `let` binding like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the values `10` and `20` are extracted from `point` and bound
    to the `x` and `y` identifiers, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can use several Tuple patterns within a match expression to
    perform branching based upon the tupled values. In keeping with the point theme,
    to determine whether a particular point is located at the origin or along an axis,
    you could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `locatePoint` function not only highlights using multiple Tuple patterns
    but also shows how multiple pattern types can be combined to form more complex
    branching logic. For instance, ① uses two Constant patterns within a Tuple pattern,
    while ② and ③ each use a Constant pattern and a Wildcard pattern within a Tuple
    pattern. Finally, ④ uses two Variable patterns within a Tuple pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the number of items in a Tuple pattern must match the number of items
    in the tuple itself. For instance, attempting to match a Tuple pattern containing
    two items with a tuple containing three items will result in a compiler error
    because the underlying types are incompatible.
  prefs: []
  type: TYPE_NORMAL
- en: Matching Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Record types can participate in pattern matching through Record patterns. With
    *Record patterns*, individual record instances can be matched and decomposed to
    their individual values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following record type definition based on a typical American name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this record type, both the first and last names are required, but the middle
    name is optional. You can use a match expression to format the name according
    to whether a middle name is specified like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, both patterns bind the first and last names to the identifiers `f` and
    `l`, respectively. But more interesting is how the patterns match the middle name
    against union cases for `Some(m)` and `None`. When the match expression is evaluated
    against a `Name` that includes a middle name, the middle name is bound to `m`.
    Otherwise, the match fails and the `None` case is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The patterns in the `formatName` function extract each value from the record,
    but Record patterns can operate against a subset of the labels, too. For instance,
    if you want to determine only whether a name includes a middle name, you could
    construct a match expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Many times, the compiler can automatically resolve which record type the pattern
    is constructed against, but if it can’t, you can specify the type name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Qualifying the pattern like this will typically be necessary only when there
    are multiple record types with conflicting definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Matching Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern matching isn’t limited to single values or structured data like tuples
    and records. F# includes several patterns for matching one-dimensional arrays
    and lists, too. If you want to match against another collection type, you’ll typically
    need to convert the collection to a list or array with `List.ofSeq`, `Array.ofSeq`,
    or a comparable mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Array Patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Array patterns* closely resemble array definitions and let you match arrays
    with a specific number of elements. For example, you can use Array patterns to
    determine the length of an array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Ignoring the fact that to get the length of an array you’d probably forego this
    contrived pattern-matching example and inspect the `Array.length` property directly,
    the `getLength` function shows how Array patterns can match individual array elements
    from fixed-size arrays.
  prefs: []
  type: TYPE_NORMAL
- en: List Patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*List patterns* are similar to Array patterns except that they look like and
    work against F# lists. Here’s the `getLength` function revised to work with F#
    lists instead of arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that there’s no `null` case because `null` is not a valid value for an
    F# list.
  prefs: []
  type: TYPE_NORMAL
- en: Cons Patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to match F# lists is with the *Cons pattern*. In pattern matching,
    the cons operator (`::`) works in reverse; instead of prepending an element to
    a list, it separates a list’s head from its tail. This allows you to recursively
    match against a list with an arbitrary number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In keeping with our theme, here’s how you could use a Cons pattern to find
    a collection’s length through pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This version of the `getLength` function is very similar to the F# list’s internal
    `length` property implementation. It defines `len` ①, an internal function that
    recursively matches against either an empty pattern ② or a Cons pattern ③. When
    the empty list is matched, `len` returns the supplied count value (`c`); otherwise,
    it makes a recursive call, incrementing the count and passing along the tail.
    The Cons pattern in `getLength` uses the Wildcard pattern for the head value because
    it’s not needed for subsequent operations.
  prefs: []
  type: TYPE_NORMAL
- en: Matching by Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'F# has two ways to match against particular data types: Type-Annotated patterns
    and Dynamic Type-Test patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Type-Annotated Patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Type-Annotated patterns* let you specify the type of the matched value. They
    are especially useful in pattern-matching functions where the compiler needs a
    little extra help determining the expected type of the function’s implicit parameter.
    For example, the following function is supposed to check whether a string begins
    with an uppercase character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As written, though, the `startsWithUpperCase` function won’t compile. Instead,
    it will fail with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason this fails to compile is that the guard conditions at ② rely on
    string properties, but those properties aren’t available because the compiler
    has automatically generalized the function’s implicit parameter. To fix the problem,
    we could either revise the function to have an explicit string parameter or we
    can include a type annotation in the pattern at ① like this (note that the parentheses
    are required):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With the type annotation in place, the parameter is no longer automatically
    generalized, making the string’s properties available within the guard condition.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Type-Test Patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Dynamic Type-Test patterns* are, in a sense, the opposite of Type-Annotated
    patterns. Where Type-Annotated patterns force each case to match against the same
    data type, Dynamic Type-Test patterns are satisfied when the matched value is
    an instance of a particular type; that is, if you annotate a pattern to match
    strings, every case must match against strings. Dynamic Type-Test patterns are
    therefore useful for matching against type hierarchies. For instance, you might
    match against an interface instance but use Dynamic Type-Test patterns to provide
    different logic for specific implementations. Dynamic Type-Test patterns resemble
    the dynamic cast operator (`:?>`) except that the `>` is omitted.'
  prefs: []
  type: TYPE_NORMAL
- en: The following `detectColorSpace` function shows you how to use Dynamic Type-Test
    patterns by matching against three record types. If none of the types are matched,
    the function raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *As pattern* lets you bind a name to the whole matched value and is particularly
    useful in `let` bindings that use pattern matching and pattern-matching functions
    where you don’t have direct named access to the matched value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, a `let` binding simply binds a name to a value, but as you’ve seen,
    you can also use patterns in a `let` binding to decompose a value and bind a name
    to each of its constituent parts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to bind not only the constituent parts but also the whole value,
    you could explicitly use two `let` bindings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Having two separate `let` bindings certainly works, but it’s more succinct
    to combine them into one with an As pattern like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The As pattern isn’t restricted to use within `let` bindings; you can also use
    it within match expressions. Here, we include an As pattern in each case to bind
    the matched tuple to a name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Combining Patterns with AND
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With *AND patterns*, sometimes called *Conjunctive patterns*, you match the
    input against multiple, compatible patterns by combining them with an ampersand
    (`&`). For the case to match, the input must satisfy each pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, AND patterns aren’t all that useful in basic pattern-matching
    scenarios because the more expressive guard clauses are usually better suited
    to the task. That said, AND patterns are still useful for things like extracting
    values when another pattern is matched. (AND patterns are also used heavily with
    active patterns, which we’ll look at later.) For example, to determine whether
    a two-dimensional point is located at the origin or along an axis, you could write
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `locatePoint` function uses AND patterns at ① and ② to extract the `x` and
    `y` values from a tuple when the second or first value is 0, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Patterns with OR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a number of patterns should execute the same code when they’re matched, you
    can combine them using an OR, or *Disjunctive*, pattern. An *OR pattern* combines
    multiple patterns with a vertical pipe character (`|`). In many ways, OR patterns
    are similar to fall-through cases in C#’s `switch` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `locatePoint` function has been revised to use an OR pattern so the
    same message can be printed for points on either axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this version of `locatePoint`, the expression at ③ is evaluated when either
    the pattern at ① or ② is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Parentheses in Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When combining patterns, you can establish precedence with parentheses. For
    instance, to extract the `x` and `y` values from a point and also match whether
    the point is on either axis, you could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, you match three patterns, establishing associativity at ① by wrapping
    the two axis-checking patterns in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Active Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When none of the built-in pattern types do quite what you need, you can turn
    to active patterns. *Active patterns* are a special type of function definition,
    called an *active recognizer*, where you define one or more case names for use
    in your pattern-matching expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Active patterns have many of the same characteristics of the built-in pattern
    types; they accept an input value and can decompose the value to its constituent
    parts. Unlike basic patterns, though, active patterns not only let you define
    what constitutes a match for each named case, but they can also accept other inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Active patterns are defined with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the case names are enclosed between `(|` and `|)` (called *banana
    clips*) and are pipe-delimited. The active pattern definition must always include
    at least one parameter for the value to match and, because active recognizer functions
    are curried, the matched value must be the final parameter in order to work correctly
    with match expressions. Finally, the expression’s return value must be one of
    the named cases along with any associated data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of uses for active patterns, but a good example lies in a
    possible solution to the famed FizzBuzz problem. For the uninitiated, FizzBuzz
    is a puzzle that employers sometimes use during interviews to help screen candidates.
    The task at the heart of the problem is simple and often phrased thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a program that prints the numbers from 1 to 100\. But for multiples of
    three, print `"Fizz"` instead of the number; for the multiples of five, print
    `"Buzz"`. For numbers that are multiples of both three and five, print `"FizzBuzz"`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To be clear, active patterns certainly aren’t the only (or necessarily even
    the best) way to solve the FizzBuzz problem. But the FizzBuzz problem—with its
    multiple, overlapping rules—allows us to showcase how powerful active patterns
    are.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by defining the active recognizer. From the preceding description,
    we know that we need four patterns: `Fizz`, `Buzz`, `FizzBuzz`, and a default
    case for everything else. We also know the criteria for each case, so our recognizer
    might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here we have an active recognizer that defines the four case names. The recognizer’s
    body relies on further pattern matching to select the appropriate case. At ①,
    we construct a tuple containing the modulus of *n* and 3 and the modulus of *n*
    and 5\. We then use a series of Tuple patterns to identify the correct case, the
    most specific being ②, where both elements are 0\. The cases at ③ and ④ match
    when *n* is divisible by 3 and *n* is divisible by 5, respectively. The final
    case, ⑤, uses the Wildcard pattern to match everything else and return `Other`
    along with the supplied number. The active pattern gets us only partway to the
    solution, though; we still need to print the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The active recognizer identifies only which case a given number meets, so we
    still need a way to translate each case to a string. We can easily map the cases
    with a pattern-matching function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `fizzBuzz` function uses basic pattern matching, but instead of
    using the built-in patterns, it uses cases defined by the active recognizer. Note
    how the `Other` case includes a Variable pattern, `n`, to hold the number associated
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can complete the task by printing the results. We could do this
    in an imperative style, but because a functional approach is more fun let’s use
    a sequence like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a sequence containing the numbers 1 through 100 and pipe it
    to `Seq.map`, which creates a new sequence containing the strings returned from
    `fizzBuzz`. The resulting sequence is then piped on to `Seq.iter` to print each
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Active Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As convenient as active patterns are, they do have a few drawbacks. First, each
    input must map to a named case. Second, active patterns are limited to seven named
    cases. If your situation doesn’t require mapping every possible input or you need
    more than seven cases, you can turn to partial active patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '*Partial active patterns* follow the same basic structure as complete active
    patterns, but instead of a list of case names they include only a single case
    name followed by an underscore. The basic syntax for a partial active pattern
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The value returned by a partial active pattern is a bit different than complete
    active patterns, too. Instead of returning the case directly, partial active patterns
    return an option of the pattern’s type. For example, if you have a partial active
    pattern for `Fizz`, the expression needs to return either `Some(Fizz)` or `None`.
    As far as your match expressions are concerned, though, the option is transparent,
    so you need to deal only with the case name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you’re following along in FSI, you’ll want to reset your session before
    proceeding with the next examples to avoid any potential naming conflicts between
    the active patterns.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see partial active patterns in action, we can return to the FizzBuzz problem.
    Using partial active patterns lets us rewrite the solution more succinctly. We
    can start by defining the partial active patterns like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you probably thought after reading the preceding snippet is
    “Why are there only two cases when the problem specifically defines three?” The
    reason is that partial active patterns are evaluated independently. So, to meet
    the requirements, we can construct a match expression such that a single case
    matches both `Fizz` and `Buzz` with an AND pattern, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that’s left is to print the required values just like we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Parameterized Active Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the active patterns we’ve seen so far have accepted only the single match
    value; we haven’t seen any that accept additional arguments that aid in matching.
    Remember, active recognizer functions are curried, so to include additional parameters
    in your active pattern definition you’ll need to list them before the match input
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to construct yet another solution to the FizzBuzz problem using
    only a single *Parameterized partial active pattern*. Consider this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This partial active pattern looks just like the `Fizz` and `Buzz` partial active
    patterns we defined in the previous section except that it includes the `d` parameter,
    which it uses in the expression. We can now use this pattern to resolve the correct
    word from any input, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of specialized cases for `Fizz` and `Buzz`, we simply match whether
    the input is divisible by three or five through the parameterized pattern. Printing
    out the results is no different than before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern matching is one of F#’s most powerful and versatile features. Despite
    some superficial similarities to case-based branching structures in other languages,
    F#’s match expressions are a completely different animal. Not only does pattern
    matching offer an expressive way to match and decompose virtually any data type,
    but it even returns values as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to compose match expressions directly using
    `match...with` and indirectly using the `function` keyword. You also saw how the
    simple pattern types like the Wildcard, Variable, and Constant patterns can be
    used independently or in conjunction with other more complex patterns like those
    for records and lists. Finally, you saw how you can create your own custom patterns
    with complete and partial active patterns.
  prefs: []
  type: TYPE_NORMAL
