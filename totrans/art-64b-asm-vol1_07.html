<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="215" id="Page_215"/>5</span><br/>
<span class="ChapterTitle">Procedures</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">In a procedural programming language, the basic unit of code is the procedure. A <em>procedure</em> is a set of instructions that compute a value or take an action (such as printing or reading a character value). This chapter discusses how MASM implements procedures, parameters, and local variables. By the end of this chapter, you should be well versed in writing your own procedures and functions, and fully understand parameter passing and the Microsoft ABI calling convention.</p>
<h2 id="h1-501089c05-0001"><span epub:type="pagebreak" title="216" id="Page_216"/>	5.1	Implementing Procedures</h2>
<p class="BodyFirst">Most procedural programming languages implement procedures by using the call/return mechanism. The code calls a procedure, the procedure does its thing, and then the procedure returns to the caller. The call and return instructions provide the x86-64’s <em>procedure invocation mechanism</em>. The calling code calls a procedure with the <code>call</code> instruction, and the procedure returns to the caller with the <code>ret</code> instruction. For example, the following x86-64 instruction calls the C Standard Library <code>printf()</code> function:</p>
<pre><code>call printf</code></pre>
<p>Alas, the C Standard Library does not supply all the routines you will ever need. Most of the time you’ll have to write your own procedures. To do this, you will use MASM’s procedure-declaration facilities. A basic MASM procedure declaration takes the following form:</p>
<pre><code><var>proc_name</var> proc <var>options</var>
          <var>Procedure statements</var>
<var>proc_name</var> endp</code></pre>
<p>Procedure declarations appear in the <code>.code</code> section of your program. In the preceding syntax example, <var>proc_name</var> represents the name of the procedure you wish to define. This can be any valid (and unique) MASM identifier.</p>
<p>Here is a concrete example of a MASM procedure declaration. This procedure stores 0s into the 256 double words that RCX points at upon entry into the procedure:</p>
<pre><code>zeroBytes proc
          mov eax, 0
          mov edx, 256
repeatlp: mov [rcx+rdx*4-4], eax
          dec rdx
          jnz repeatlp
          ret
zeroBytes endp</code></pre>
<p>As you’ve probably noticed, this simple procedure doesn’t bother with the “magic” instructions that add and subtract a value to and from the RSP register. Those instructions are a requirement of the Microsoft ABI when the procedure will be calling other C/C++ code (or other code written in a Microsoft ABI–compliant language). Because this little function doesn’t call any other procedures, it doesn’t bother executing such code. Also note that this code uses the loop index to count down from 256 to 0, filling in the 256 dword array backward (from end to beginning) rather than filling it in from beginning to end. This is a common technique in assembly language.</p>
<p>You can use the x86-64 <code>call</code> instruction to call this procedure. When, during program execution, the code falls into the <code>ret</code> instruction, <span epub:type="pagebreak" title="217" id="Page_217"/>the procedure returns to whoever called it and begins executing the first instruction beyond the <code>call</code> instruction. The program in <a href="#listing5-1" id="listinganchor5-1">Listing 5-1</a> provides an example of a call to the <code>zeroBytes</code> routine.</p>
<pre><code>; Listing 5-1
 
; Simple procedure call example.

         option  casemap:none

nl       =       10

         .const
ttlStr   byte    "Listing 5-1", 0

        .data
dwArray dword   256 dup (1)
        
        .code

; Return program title to C++ program:

         public getTitle
getTitle proc
         lea rax, ttlStr
         ret
getTitle endp

; Here is the user-written procedure
; that zeroes out a buffer.

zeroBytes proc
          mov eax, 0
          mov edx, 256
repeatlp: mov [rcx+rdx*4-4], eax
          dec rdx
          jnz repeatlp
          ret
zeroBytes endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc

; "Magic" instruction offered without
; explanation at this point:

        sub     rsp, 48

<span epub:type="pagebreak" title="218" id="Page_218"/>        lea     rcx, dwArray
        call    zeroBytes 

        add     rsp, 48     ; Restore RSP
        ret                 ; Returns to caller
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing5-1">Listing 5-1</a>: Example of a simple procedure</p>
<h3 id="h2-501089c05-0001">5.1.1	The call and ret Instructions</h3>
<p class="BodyFirst">The x86-64 <code>call</code> instruction does two things. First, it pushes the (64-bit) address of the instruction immediately following the <code>call</code> onto the stack; then it transfers control to the address of the specified procedure. The value that <code>call</code> pushes onto the stack is known as the <em>return address</em>.</p>
<p>When the procedure wants to return to the caller and continue execution with the first statement following the <code>call</code> instruction, most procedures return to their caller by executing a <code>ret</code> (<em>return</em>) instruction. The <code>ret</code> instruction pops a (64-bit) return address off the stack and transfers control indirectly to that address.</p>
<p>The following is an example of the minimal procedure:</p>
<pre><code>minimal proc
        ret
minimal endp</code></pre>
<p>If you call this procedure with the <code>call</code> instruction, <code>minimal</code> will simply pop the return address off the stack and return to the caller. If you fail to put the <code>ret</code> instruction in the procedure, the program will not return to the caller upon encountering the <code>endp</code> statement. Instead, the program will fall through to whatever code happens to follow the procedure in memory.</p>
<p>The example program in <a href="#listing5-2" id="listinganchor5-2">Listing 5-2</a> demonstrates this problem. The main program calls <code>noRet</code>, which falls straight through to <code>followingProc</code> (printing the message <code>followingProc was called</code>).</p>
<pre><code>; Listing 5-2
 
; A procedure without a ret instruction.

               option  casemap:none

nl             =       10

              .const
ttlStr        byte    "Listing 5-2", 0
fpMsg         byte    "followingProc was called", nl, 0
        
              .code
              externdef printf:proc

<span epub:type="pagebreak" title="219" id="Page_219"/>; Return program title to C++ program:

              public getTitle
getTitle      proc
              lea rax, ttlStr
              ret
getTitle      endp

; noRet - Demonstrates what happens when a procedure
;         does not have a return instruction.

noRet         proc
noRet         endp

followingProc proc
              sub  rsp, 28h
              lea  rcx, fpMsg
              call printf
              add  rsp, 28h
              ret
followingProc endp

; Here is the "asmMain" function.

              public  asmMain
asmMain       proc
              push    rbx
                
              sub     rsp, 40   ; "Magic" instruction

              call    noRet
              
              add     rsp, 40   ; "Magic" instruction
              pop     rbx
              ret               ; Returns to caller
asmMain       endp
              end</code></pre>
<p class="CodeListingCaption"><a id="listing5-2">Listing 5-2</a>: Effect of a missing <code>ret</code> instruction in a procedure</p>
<p>Although this behavior might be desirable in certain rare circumstances, it usually represents a defect in most programs. Therefore, always remember to explicitly return from the procedure by using the <code>ret</code> instruction.</p>
<h3 id="h2-501089c05-0002">5.1.2	Labels in a Procedure</h3>
<p class="BodyFirst">Procedures may contain statement labels, just like the main procedure in your assembly language program (after all, the main procedure, <code>asmMain</code> in most of the examples in this book, is just another procedure declaration as far as MASM is concerned). Note, however, that statement labels defined within a procedure are <em>local</em> to that procedure; such symbols are not <em>visible</em> outside the procedure.</p>
<p><span epub:type="pagebreak" title="220" id="Page_220"/>In most situations, having <em>scoped symbols</em> in a procedure is nice (see <span class="xref" itemid="xref_target_“Local (Automatic) Variables” on page 234">“Local (Automatic) Variables” on page 234</span> for a discussion of scope). You don’t have to worry about <em>namespace pollution</em> (conflicting symbol names) among the different procedures in your source file. Sometimes, however, MASM’s name scoping can create problems. You might actually want to refer to a statement label outside a procedure.</p>
<p>One way to do this on a label-by-label basis is to use a global statement label declaration. <em>Global statement labels</em> are similar to normal statement labels in a procedure except you follow the symbol with two colons instead of a single colon, like so:</p>
<pre><code>globalSymbol:: mov eax, 0</code></pre>
<p>Global statement labels are visible outside the procedure. You can use an unconditional or conditional jump instruction to transfer control to a global symbol from outside the procedure; you can even use a <code>call</code> instruction to call that global symbol (in which case, it becomes a second entry point to the procedure). Generally, having multiple entry points to a procedure is considered bad programming style, and the use of multiple entry points often leads to programming errors. As such, you should rarely use global symbols in assembly language procedures.</p>
<p>If, for some reason, you don’t want MASM to treat all the statement labels in a procedure as local to that procedure, you can turn scoping on and off with the following statements:</p>
<pre><code>option scoped
option noscoped</code></pre>
<p>The <code>option noscoped</code> directive disables scoping in procedures (for all procedures following the directive). The <code>option scoped</code> directive turns scoping back on. Therefore, you can turn scoping off for a single procedure (or set of procedures) and turn it back on immediately afterward.</p>
<h2 id="h1-501089c05-0002">	5.2	Saving the State of the Machine</h2>
<p class="BodyFirst">Take a look at <a href="#listing5-3" id="listinganchor5-3">Listing 5-3</a>. This program attempts to print 20 lines of 40 spaces and an asterisk. Unfortunately, a subtle bug creates an infinite loop. The main program uses the <code>jnz printLp</code> instruction to create a loop that calls <code>PrintSpaces</code> 20 times. This function uses EBX to count off the 40 spaces it prints, and then returns with ECX containing 0. The main program then prints an asterisk and a newline, decrements ECX, and then repeats because ECX isn’t 0 (it will always contain 0FFFF_FFFFh at this point).</p>
<p>The problem here is that the <code>print40Spaces</code> subroutine doesn’t preserve the EBX register. <em>Preserving a register</em> means you save it upon entry into the subroutine and restore it before leaving. Had the <code>print40Spaces</code> subroutine preserved the contents of the EBX register, <a href="#listing5-3">Listing 5-3</a> would have functioned properly.</p>
<pre><code><span epub:type="pagebreak" title="221" id="Page_221"/>; Listing 5-3
 
; Preserving registers (failure) example.

               option  casemap:none

nl             =       10

              .const
ttlStr        byte    "Listing 5-3", 0
space         byte    " ", 0
asterisk      byte    '*, %d', nl, 0
        
              .code
              externdef printf:proc

; Return program title to C++ program:

              public getTitle
getTitle      proc
              lea rax, ttlStr
              ret
getTitle      endp

; print40Spaces - Prints out a sequence of 40 spaces
;                 to the console display.

print40Spaces proc
              sub  rsp, 48   ; "Magic" instruction
              mov  ebx, 40
printLoop:    lea  rcx, space
              call printf
              dec  ebx
              jnz  printLoop ; Until EBX == 0
              add  rsp, 48   ; "Magic" instruction
              ret
print40Spaces endp

; Here is the "asmMain" function.

              public  asmMain
asmMain       proc
              push    rbx
                
; "Magic" instruction offered without
; explanation at this point:

              sub     rsp, 40   ; "Magic" instruction

              mov     rbx, 20
astLp:        call    print40Spaces
              lea     rcx, asterisk
              mov     rdx, rbx
              call    printf
<span epub:type="pagebreak" title="222" id="Page_222"/>              dec     rbx
              jnz     astLp

              add     rsp, 40   ; "Magic" instruction
              pop     rbx
              ret     ; Returns to caller
asmMain       endp
              end</code></pre>
<p class="CodeListingCaption"><a id="listing5-3">Listing 5-3</a>: Program with an unintended infinite loop</p>
<p>You can use the x86-64’s <code>push</code> and <code>pop</code> instructions to preserve register values while you need to use them for something else. Consider the following code for <code>PrintSpaces</code>:</p>
<pre><code>print40Spaces proc
              push rbx
              sub  rsp, 40   ; "Magic" instruction
              mov  ebx, 40
printLoop:    lea  rcx, space
              call printf
              dec  ebx
              jnz  printLoop ; Until EBX == 0
              add  rsp, 40   ; "Magic" instruction
              pop  rbx
              ret
print40Spaces endp</code></pre>
<p><code>print40Spaces</code> saves and restores RBX by using <code>push</code> and <code>pop</code> instructions. Either the caller (the code containing the call instruction) or the callee (the subroutine) can take responsibility for preserving the registers. In the preceding example, the callee preserves the registers.</p>
<p><a href="#listing5-4" id="listinganchor5-4">Listing 5-4</a> shows what this code might look like if the caller preserves the registers (for reasons that will become clear in <span class="xref" itemid="xref_target_“Saving the State of the Machine, Part II” on page 280">“Saving the State of the Machine, Part II” on page 280</span>, the main program saves the value of RBX in a static memory location rather than using the stack).</p>
<pre><code>; Listing 5-4
 
; Preserving registers (caller) example.

               option  casemap:none

nl             =       10

              .const
ttlStr        byte    "Listing 5-4", 0
space         byte    " ", 0
asterisk      byte    '*, %d', nl, 0

              .data
saveRBX       qword   ?
        
<span epub:type="pagebreak" title="223" id="Page_223"/>              .code
              externdef printf:proc

; Return program title to C++ program:

              public getTitle
getTitle      proc
              lea rax, ttlStr
              ret
getTitle      endp
 
; print40Spaces - Prints out a sequence of 40 spaces
;                 to the console display.

print40Spaces proc
              sub  rsp, 48   ; "Magic" instruction
              mov  ebx, 40
printLoop:    lea  rcx, space
              call printf
              dec  ebx
              jnz  printLoop ; Until EBX == 0
              add  rsp, 48   ; "Magic" instruction
              ret
print40Spaces endp

; Here is the "asmMain" function.

              public  asmMain
asmMain       proc
              push    rbx
                
; "Magic" instruction offered without
; explanation at this point:

              sub     rsp, 40

              mov     rbx, 20
astLp:        mov     saveRBX, rbx
              call    print40Spaces
              lea     rcx, asterisk
              mov     rdx, saveRBX
              call    printf
              mov     rbx, saveRBX
              dec     rbx
              jnz     astLp

              add     rsp, 40
              pop     rbx
              ret     ; Returns to caller
asmMain       endp
              end</code></pre>
<p class="CodeListingCaption"><a id="listing5-4">Listing 5-4</a>: Demonstration of caller register preservation</p>
<p><span epub:type="pagebreak" title="224" id="Page_224"/>Callee preservation has two advantages: space and maintainability. If the callee (the procedure) preserves all affected registers, only one copy of the <code>push</code> and <code>pop</code> instructions exists—those the procedure contains. If the caller saves the values in the registers, the program needs a set of preservation instructions around every call. This makes your programs not only longer but also harder to maintain. Remembering which registers to save and restore on each procedure call is not easily done.</p>
<p>On the other hand, a subroutine may unnecessarily preserve some registers if it preserves all the registers it modifies. In the preceding examples, the <code>print40Spaces</code> procedure didn’t save RBX. Although <code>print40Spaces</code> changes RBX, this won’t affect the program’s operation. If the caller is preserving the registers, it doesn’t have to save registers it doesn’t care about.</p>
<p>One big problem with having the caller preserve registers is that your program may change over time. You may modify the calling code or the procedure to use additional registers. Such changes, of course, may change the set of registers that you must preserve. Worse still, if the modification is in the subroutine itself, you will need to locate <em>every</em> call to the routine and verify that the subroutine does not change any registers the calling code uses.</p>
<p>Assembly language programmers use a common convention with respect to register preservation: unless there is a good reason (performance) for doing otherwise, most programmers will preserve all registers that a procedure modifies (and that doesn’t explicitly return a value in a modified register). This reduces the likelihood of defects occurring in a program because a procedure modifies a register the caller expects to be preserved. Of course, you could follow the rules concerning the Microsoft ABI with respect to volatile and nonvolatile registers; however, such calling conventions impose their own inefficiencies on programmers (and other programs).</p>
<p>Preserving registers isn’t all there is to preserving the environment. You can also push and pop variables and other values that a subroutine might change. Because the x86-64 allows you to push and pop memory locations, you can easily preserve these values as well.</p>
<h2 id="h1-501089c05-0003">	5.3	Procedures and the Stack</h2>
<p class="BodyFirst">Because procedures use the stack to hold the return address, you must exercise caution when pushing and popping data within a procedure. Consider the following simple (and defective) procedure:</p>
<pre><code>MessedUp   proc

           push rax
           ret

MessedUp   endp</code></pre>
<p><span epub:type="pagebreak" title="225" id="Page_225"/>At the point the program encounters the <code>ret</code> instruction, the x86-64 stack takes the form shown in <a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a>.</p>
<figure>
<img src="image_fi/501089c05/f05001.png" alt="f05001" class=""/>
<figcaption><p><a id="figure5-1">Figure 5-1</a>: Stack contents before <span class="LiteralInCaption"><code>ret</code></span> in the <span class="LiteralInCaption"><code>MessedUp</code></span> procedure</p></figcaption>
</figure>
<p>The <code>ret</code> instruction isn’t aware that the value on the top of the stack is not a valid address. It simply pops whatever value is on top and jumps to that location. In this example, the top of the stack contains the saved RAX value. Because it is very unlikely that RAX’s value pushed on the stack was the proper return address, this program will probably crash or exhibit another undefined behavior. Therefore, when pushing data onto the stack within a procedure, you must take care to properly pop that data prior to returning from the procedure.</p>
<p>Popping extra data off the stack prior to executing the <code>ret</code> statement can also create havoc in your programs. Consider the following defective procedure:</p>
<pre><code>MessedUp2  proc

           pop rax
           ret

MessedUp2  endp</code></pre>
<p>Upon reaching the <code>ret</code> instruction in this procedure, the x86-64 stack looks something like <a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a>.</p>
<span epub:type="pagebreak" title="226" id="Page_226"/><figure>
<img src="image_fi/501089c05/f05002.png" alt="f05002" class=""/>
<figcaption><p><a id="figure5-2">Figure 5-2</a>: Stack contents before <span class="LiteralInCaption"><code>ret</code></span> in <span class="LiteralInCaption"><code>MessedUp2</code></span></p></figcaption>
</figure>
<p>Once again, the <code>ret</code> instruction blindly pops whatever data happens to be on the top of the stack and attempts to return to that address. Unlike the previous example, in which the top of the stack was unlikely to contain a valid return address (because it contained the value in RAX), there is a small possibility that the top of the stack in this example <em>does</em> contain a return address. However, this will not be the proper return address for the <code>messedUp2</code> procedure; instead, it will be the return address for the procedure that called <code>messedUp2</code>. To understand the effect of this code, consider the program in <a href="#listing5-5" id="listinganchor5-5">Listing 5-5</a>.</p>
<pre><code>; Listing 5-5
 
; Popping a return address by mistake.

               option  casemap:none

nl             =       10

              .const
ttlStr        byte    "Listing 5-5", 0
calling       byte    "Calling proc2", nl, 0
call1         byte    "Called proc1", nl, 0
rtn1          byte    "Returned from proc 1", nl, 0
rtn2          byte    "Returned from proc 2", nl, 0

              .code
              externdef printf:proc

; Return program title to C++ program:

              public getTitle
getTitle      proc
              lea rax, ttlStr
              ret
getTitle      endp

<span epub:type="pagebreak" title="227" id="Page_227"/>; proc1 - Gets called by proc2, but returns
;         back to the main program.

proc1         proc
              pop   rcx     ; Pops return address off stack
              ret
proc1         endp

proc2         proc
              call  proc1   ; Will never return

; This code never executes because the call to proc1
; pops the return address off the stack and returns
; directly to asmMain.

              sub   rsp, 40
              lea   rcx, rtn1
              call  printf
              add   rsp, 40
              ret
proc2         endp

; Here is the "asmMain" function.

              public asmMain
asmMain       proc

              sub   rsp, 40

              lea   rcx, calling
              call  printf

              call  proc2
              lea   rcx, rtn2
              call  printf

              add   rsp, 40
              ret           ; Returns to caller
asmMain       endp
              end</code></pre>
<p class="CodeListingCaption"><a id="listing5-5">Listing 5-5</a>: Effect of popping too much data off the stack</p>
<p>Because a valid return address is sitting on the top of the stack when <code>proc1</code> is entered, you might think that this program will actually work (properly). However, when returning from the <code>proc1</code> procedure, this code returns directly to the <code>asmMain</code> program rather than to the proper return address in the <code>proc2</code> procedure. Therefore, all code in the <code>proc2</code> procedure that follows the call to <code>proc1</code> does not execute. </p>
<p>When reading the source code, you may find it very difficult to figure out why those statements are not executing, because they immediately follow the call to the <code>proc1</code> procedure. It isn’t clear, unless you look very closely, that the program is popping an extra return address off the stack and therefore doesn’t return to <code>proc2</code> but rather returns directly to whoever calls <code>proc2</code>. <span epub:type="pagebreak" title="228" id="Page_228"/>Therefore, you should always be careful about pushing and popping data in a procedure, and verify that a one-to-one relationship exists between the pushes in your procedures and the corresponding pops.<sup class="FootnoteReference"><a id="c05-footnoteref-1" href="#c05-footnote-1">1</a></sup></p>
<h3 id="h2-501089c05-0003">5.3.1	Activation Records</h3>
<p class="BodyFirst">Whenever you call a procedure, the program associates certain information with that procedure call, including the return address, parameters, and automatic local variables, using a data structure called an <em>activation record.</em><sup class="FootnoteReference"><a id="c05-footnoteref-2" href="#c05-footnote-2">2</a></sup> The program creates an activation record when calling (activating) a procedure, and the data in the structure is organized in a manner identical to records.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	This section begins by discussing traditional activation records created by a hypothetical compiler, ignoring the parameter-passing conventions of the Microsoft ABI. Once this initial discussion is complete, this chapter will incorporate the Microsoft ABI conventions.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Construction of an activation record begins in the code that calls a procedure. The caller makes room for the parameter data (if any) on the stack and copies the data onto the stack. Then the <code>call</code> instruction pushes the return address onto the stack. At this point, construction of the activation record continues within the procedure itself. The procedure pushes registers and other important state information and then makes room in the activation record for local variables. The procedure might also update the RBP register so that it points at the base address of the activation record.</p>
<p>To see what a traditional activation record looks like, consider the following C++ procedure declaration:</p>
<pre><code>void ARDemo(unsigned i, int j, unsigned k)
{
     int a;
     float r;
     char c;
     bool b;
     short w
     .
     .
     .
}</code></pre>
<p>Whenever a program calls this <code>ARDemo</code> procedure, it begins by pushing the data for the parameters onto the stack. In the original C/C++ calling convention (ignoring the Microsoft ABI), the calling code pushes the parameters onto the stack in the opposite order that they appear in the parameter list, <span epub:type="pagebreak" title="229" id="Page_229"/>from right to left. Therefore, the calling code first pushes the value for the <code>k</code> parameter, then it pushes the value for the <code>j</code> parameter, and it finally pushes the data for the <code>i</code> parameter. After pushing the parameters, the program calls the <code>ARDemo</code> procedure. Immediately upon entry into the <code>ARDemo</code> procedure, the stack contains these four items arranged as shown in <a href="#figure5-3" id="figureanchor5-3">Figure 5-3</a>. By pushing the parameters in the reverse order, they appear on the stack in the correct order (with the first parameter at the lowest address in memory).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The x86-64 <code>push</code> instruction is capable of pushing 16-bit or 64-bit objects onto the stack. For performance reasons, you always want to keep RSP aligned on an 8-byte boundary (which largely eliminates using 16-bit pushes). For this and other reasons, modern programs always reserve at least 8 bytes for each parameter, regardless of the actual parameter size.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<figure>
<img src="image_fi/501089c05/f05003.png" alt="f05003" class=""/>
<figcaption><p><a id="figure5-3">Figure 5-3</a>: Stack organization immediately upon entry into <span class="LiteralInCaption"><code>ARDemo</code></span></p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The Microsoft ABI requires the stack to be aligned on a 16-byte boundary when making system calls. Assembly programs don’t require this, but it’s often convenient to keep the stack aligned this way for those times when you need to make a system call (OS or C Standard Library call).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The first few instructions in <code>ARDemo</code> will push the current value of RBP onto the stack and then copy the value of RSP into RBP.<sup class="FootnoteReference"><a id="c05-footnoteref-3" href="#c05-footnote-3">3</a></sup> Next, the code drops the stack pointer down in memory to make room for the local variables. This produces the stack organization shown in <a href="#figure5-4" id="figureanchor5-4">Figure 5-4</a>.</p>
<span epub:type="pagebreak" title="230" id="Page_230"/><figure>
<img src="image_fi/501089c05/f05004.png" alt="f05004" class=""/>
<figcaption><p><a id="figure5-4">Figure 5-4</a>: Activation record for <span class="LiteralInCaption"><code>ARDemo</code></span></p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Unlike parameters, local variables do not have to be a multiple of 8 bytes in the activation record. However, the entire block of local variables must be a multiple of 16 bytes in size so that RSP remains aligned on a 16-byte boundary as required by the Microsoft ABI. Hence the presence of <em>possible padding</em> in <a href="#figure5-4">Figure 5-4</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-501089c05-0001">5.3.1.1	Accessing Objects in the Activation Record</h4>
<p class="BodyFirst">To access objects in the activation record, you must use offsets from the RBP register to the desired object. The two items of immediate interest to you are the parameters and the local variables. You can access the parameters at positive offsets from the RBP register; you can access the local variables at negative offsets from the RBP register, as <a href="#figure5-5" id="figureanchor5-5">Figure 5-5</a> shows.</p>
<p>Intel specifically reserves the RBP (Base Pointer) register for use as a pointer to the base of the activation record. This is why you should avoid using the RBP register for general calculations. If you arbitrarily change the value in the RBP register, you could lose access to the current procedure’s parameters and local variables.</p>
<p>The local variables are aligned on offsets that are equal to their native size (chars are aligned on 1-byte addresses, shorts/words are aligned on 2-byte addresses, longs/ints/unsigneds/dwords are aligned on 4-byte addresses, and so forth). In the <code>ARDemo</code> example, all of the locals just happen to be allocated on appropriate addresses (assuming a compiler allocates storage in the order of declaration).</p>
<span epub:type="pagebreak" title="231" id="Page_231"/><figure>
<img src="image_fi/501089c05/f05005.png" alt="f05005" class=""/>
<figcaption><p><a id="figure5-5">Figure 5-5</a>: Offsets of objects in the <span class="LiteralInCaption"><code>ARDemo</code></span> activation record</p></figcaption>
</figure>
<h4 id="h3-501089c05-0002">5.3.1.2	Using Microsoft ABI Parameter Conventions</h4>
<p class="BodyFirst">The Microsoft ABI makes several modifications to the activation record model, in particular:</p>
<ul>
<li>The caller passes the first four parameters in registers rather than on the stack (though it must still reserve storage on the stack for those parameters).</li>
<li>Parameters are always 8-byte values.</li>
<li>The caller must reserve (at least) 32 bytes of parameter data on the stack, even if there are fewer than five parameters (plus 8 bytes for each additional parameter if there are five or more parameters).</li>
<li>RSP must be 16-byte-aligned immediately before the <code>call</code> instruction pushes the return address onto the stack.</li>
</ul>
<p>For more information, see <span class="xref" itemid="xref_target_“Microsoft ABI Notes” in Chapter 1">“Microsoft ABI Notes” in Chapter 1</span>. You must follow these conventions only when calling Windows or other Microsoft ABI–compliant code. For assembly language procedures that you write and call, you can use any convention you like.</p>
<h3 id="h2-501089c05-0004">5.3.2	The Assembly Language Standard Entry Sequence</h3>
<p class="BodyFirst">The caller of a procedure is responsible for allocating storage for parameters on the stack and moving the parameter data to its appropriate location. In the simplest case, this just involves pushing the data onto the stack by using <span epub:type="pagebreak" title="232" id="Page_232"/>64-bit <code>push</code> instructions. The <code>call</code> instruction pushes the return address onto the stack. It is the procedure’s responsibility to construct the rest of the activation record. You can accomplish this by using the following assembly language <em>standard entry sequence</em> code:</p>
<pre><code>push rbp          ; Save a copy of the old RBP value
mov rbp, rsp      ; Get ptr to activation record into RBP
sub rsp, <var>num_vars</var> ; Allocate local variable storage plus padding</code></pre>
<p>If the procedure doesn’t have any local variables, the third instruction shown here, <code>sub rsp, </code><var>num_vars</var>, isn’t necessary.</p>
<p><var>num_vars</var> represents the number of <em>bytes</em> of local variables needed by the procedure, a constant that should be a multiple of 16 (so the RSP register remains aligned on a 16-byte boundary).<sup class="FootnoteReference"><a id="c05-footnoteref-4" href="#c05-footnote-4">4</a></sup> If the number of bytes of local variables in the procedure is not a multiple of 16, you should round up the value to the next higher multiple of 16 before subtracting this constant from RSP. Doing so will slightly increase the amount of storage the procedure uses for local variables but will not otherwise affect the operation of the procedure.</p>
<p>If a Microsoft ABI–compliant program calls your procedure, the stack will be aligned on a 16-byte boundary immediately prior to the execution of the <code>call</code> instruction. As the return address adds 8 bytes to the stack, immediately upon entry into your procedure, the stack will be aligned on an (<em>RSP mod 16</em>) == <em>8</em> address (aligned on an 8-byte address but not on a 16-byte address). Pushing RBP onto the stack (to save the old value before copying RSP into RBP) adds another 8 bytes to the stack so that RSP is now 16-byte-aligned. Therefore, assuming the stack was 16-byte-aligned prior to the call, and the number you subtract from RSP is a multiple of 16, the stack will be 16-byte-aligned after allocating storage for local variables.</p>
<p>If you cannot ensure that RSP is 16-byte-aligned (<em>RSP mod 16 == 8</em>) upon entry into your procedure, you can always force 16-byte alignment by using the following sequence at the beginning of your procedure:</p>
<pre><code>push rbp
mov rbp, rsp
sub rsp, <var>num_vars</var>  ; Make room for local variables
and rsp, -16       ; Force qword stack alignment</code></pre>
<p>The –16 is equivalent to 0FFFF_FFFF_FFFF_FFF0h. The <code>and</code> instruction sequence forces the stack to be aligned on a 16-byte boundary (it reduces the value in the stack pointer so that it is a multiple of 16).</p>
<p>The <code>ARDemo</code> activation record has only 12 bytes of local storage. Therefore, subtracting 12 from RSP for the local variables will not leave the stack 16-byte-aligned. The <code>and</code> instruction in the preceding sequence, however, guarantees that RSP is 16-byte-aligned regardless of RSP’s value upon entry <span epub:type="pagebreak" title="233" id="Page_233"/>into the procedure (this adds in the padding bytes shown in <a href="#figure5-5">Figure 5-5</a>). The few bytes and CPU cycles needed to execute this instruction would pay off handsomely if RSP was not oword aligned. Of course, if you know that the stack was properly aligned before the call, you could dispense with the extra <code>and</code> instruction and simply subtract 16 from RSP rather than 12 (in other words, reserving 4 more bytes than the <code>ARDemo</code> procedure needs, to keep the stack aligned).</p>
<h3 id="h2-501089c05-0005">5.3.3	The Assembly Language Standard Exit Sequence</h3>
<p class="BodyFirst">Before a procedure returns to its caller, it needs to clean up the activation record. Standard MASM procedures and procedure calls, therefore, assume that it is the procedure’s responsibility to clean up the activation record, although it is possible to share the cleanup duties between the procedure and the procedure’s caller.</p>
<p>If a procedure does not have any parameters, the exit sequence is simple. It requires only three instructions:</p>
<pre><code>mov rsp, rbp   ; Deallocate locals and clean up stack
pop rbp        ; Restore pointer to caller's activation record
ret            ; Return to the caller</code></pre>
<p>In the Microsoft ABI (as opposed to pure assembly procedures), it is the caller’s responsibility to clean up any parameters pushed on the stack. Therefore, if you are writing a function to be called from C/C++ (or other Microsoft ABI–compliant code), your procedure doesn’t have to do anything at all about the parameters on the stack.</p>
<p>If you are writing procedures that will be called only from your assembly language programs, it is possible to have the callee (the procedure) rather than the caller clean up the parameters on the stack upon returning to the caller, using the following standard exit sequence:</p>
<pre><code>mov rsp, rbp    ; Deallocate locals and clean up stack
pop rbp         ; Restore pointer to caller's activation record
ret <var>parm_bytes</var>  ; Return to the caller and pop the parameters</code></pre>
<p>The <var>parm_bytes</var> operand of the <code>ret</code> instruction is a constant that specifies the number of bytes of parameter data to remove from the stack after the return instruction pops the return address. For example, the <code>ARDemo</code> example code in the previous sections has three quad words reserved for the parameters (because we want to keep the stack qword aligned). Therefore, the standard exit sequence would take the following form:</p>
<pre><code>mov rsp, rbp
pop rbp
ret 24</code></pre>
<p>If you do not specify a 16-bit constant operand to the <code>ret</code> instruction, the x86-64 will not pop the parameters off the stack upon return. Those parameters will still be sitting on the stack when you execute the first instruction <span epub:type="pagebreak" title="234" id="Page_234"/>following the <code>call</code> to the procedure. Similarly, if you specify a value that is too small, some of the parameters will be left on the stack upon return from the procedure. If the <code>ret</code> operand you specify is too large, the <code>ret</code> instruction will actually pop some of the caller’s data off the stack, usually with disastrous consequences.</p>
<p>By the way, Intel has added a special instruction to the instruction set to shorten the standard exit sequence: <code>leave</code>. This instruction copies RBP into RSP and then pops RBP. The following is equivalent to the standard exit sequence presented thus far:</p>
<pre><code>leave
ret <var>optional_const</var></code></pre>
<p>The choice is up to you. Most compilers generate the <code>leave</code> instruction (because it’s shorter), so using it is the standard choice.</p>
<h2 id="h1-501089c05-0004">	5.4	Local (Automatic) Variables</h2>
<p class="BodyFirst">Procedures and functions in most high-level languages let you declare <em>local variables</em>. These are generally accessible only within the procedure; they are not accessible by the code that calls the procedure. </p>
<p>Local variables possess two special attributes in HLLs: scope and lifetime.<em> </em>The <em>scope</em> of an identifier determines where that identifier is visible (accessible) in the source file during compilation. In most HLLs, the scope of a procedure’s local variable is the body of that procedure; the identifier is inaccessible outside that procedure.</p>
<p>Whereas scope is a compile-time attribute of a symbol, <em>lifetime</em> is a runtime attribute. The lifetime of a variable is from that point when storage is first bound to the variable until the point where the storage is no longer available for that variable. Static objects (those you declare in the <code>.data</code>, <code>.const</code>, <code>.data?</code>, and <code>.code</code> sections) have a lifetime equivalent to the total runtime of the application. The program allocates storage for such variables when the program first loads into memory, and those variables maintain that storage until the program terminates.</p>
<p>Local variables (or, more properly, <em>automatic variables</em>) have their storage allocated upon entry into a procedure, and that storage is returned for other use when the procedure returns to its caller. The name <em>automatic</em> refers to the program automatically allocating and deallocating storage for the variable on procedure invocation and return.</p>
<p>A procedure can access any global <code>.data</code>, <code>.data?</code>, or <code>.const</code> object the same way the main program accesses such variables—by referencing the name (using the PC-relative addressing mode). Accessing global objects is convenient and easy. Of course, accessing global objects makes your programs harder to read, understand, and maintain, so you should avoid using global variables within procedures. Although accessing global variables within a procedure may sometimes be the best solution to a given problem, <span epub:type="pagebreak" title="235" id="Page_235"/>you likely won’t be writing such code at this point, so you should carefully consider your options before doing so.<sup class="FootnoteReference"><a id="c05-footnoteref-5" href="#c05-footnote-5">5</a></sup></p>
<h3 id="h2-501089c05-0006">5.4.1	Low-Level Implementation of Automatic (Local) Variables</h3>
<p class="BodyFirst">Your program accesses local variables in a procedure by using negative offsets from the activation record base address (RBP). Consider the following MASM procedure in <a href="#listing5-6" id="listinganchor5-6">Listing 5-6</a> (which admittedly doesn’t do much, other than demonstrate the use of local variables).</p>
<pre><code>; Listing 5-6
 
; Accessing local variables.

               option  casemap:none
               .code

; sdword a is at offset -4 from RBP.
; sdword b is at offset -8 from RBP.
 
; On entry, ECX and EDX contain values to store
; into the local variables a and b (respectively):

localVars     proc
              push rbp
              mov  rbp, rsp
              sub  rsp, 16       ; Make room for a and b

              mov  [rbp-4], ecx  ; a = ECX
              mov  [rbp-8], edx  ; b = EDX

    ; Additional code here that uses a and b:
              
              mov   rsp, rbp
              pop   rbp
              ret
localVars     endp</code></pre>
<p class="CodeListingCaption"><a id="listing5-6">Listing 5-6</a>: Sample procedure that accesses local variables</p>
<p>The standard entry sequence allocates 16 bytes of storage even though locals <code>a</code> and <code>b</code> require only 8. This keeps the stack 16-byte-aligned. If this isn’t necessary for a particular procedure, subtracting 8 would work just as well.</p>
<p>The activation record for <code>localVars</code> appears in <a href="#figure5-6" id="figureanchor5-6">Figure 5-6</a>.</p>
<p>Of course, having to refer to the local variables by the offset from the RBP register is truly horrible. This code is not only difficult to read (is <code>[RBP-4]</code> the <code>a</code> or the <code>b</code> variable?) but also hard to maintain. For example, if you decide you no longer need the <code>a</code> variable, you’d have to go find every occurrence of <code>[RBP-8]</code> (accessing the <code>b</code> variable) and change it to <code>[RBP-4]</code>.</p>
<span epub:type="pagebreak" title="236" id="Page_236"/><figure>
<img src="image_fi/501089c05/f05006.png" alt="f05006" class=""/>
<figcaption><p><a id="figure5-6">Figure 5-6</a>: Activation record for the <span class="LiteralInCaption"><code>LocalVars</code></span> procedure</p></figcaption>
</figure>
<p>A slightly better solution is to create equates for your local variable names. Consider the modification to <a href="#listing5-6">Listing 5-6</a> shown here in <a href="#listing5-7" id="listinganchor5-7">Listing 5-7</a>.</p>
<pre><code>; Listing 5-7
 
; Accessing local variables #2.

            option  casemap:none
            .code

; localVars - Demonstrates local variable access.
 
; sdword a is at offset -4 from RBP.
; sdword b is at offset -8 from RBP.
 
; On entry, ECX and EDX contain values to store
; into the local variables a and b (respectively):

a           equ     &lt;[rbp-4]&gt;
b           equ     &lt;[rbp-8]&gt;
localVars   proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 16  ; Make room for a and b
              
            mov     a, ecx
            mov     b, edx
              
    ; Additional code here that uses a and b:
              
            mov     rsp, rbp
            pop     rbp
<span epub:type="pagebreak" title="237" id="Page_237"/>            ret
localVars   endp</code></pre>
<p class="CodeListingCaption"><a id="listing5-7">Listing 5-7</a>: Local variables using equates</p>
<p>This is considerably easier to read and maintain than the former program in <a href="#listing5-6">Listing 5-6</a>. It’s possible to improve on this equate system. For example, the following four equates are perfectly legitimate:</p>
<pre><code>a  equ &lt;[rbp-4]&gt;
b  equ a-4
d  equ b-4
e  equ d-4</code></pre>
<p>MASM will associate <code>[RBP-4]</code> with <code>a</code>, <code>[RBP-8]</code> with <code>b</code>, <code>[RBP-12]</code> with <code>d</code>, and <code>[RBP-16]</code> with <code>e</code>. However, getting too crazy with fancy equates doesn’t pay; MASM provides a high-level-like declaration for local variables (and parameters) you can use if you really want your declarations to be as maintainable as possible.</p>
<h3 id="h2-501089c05-0007">5.4.2	The MASM Local Directive</h3>
<p class="BodyFirst">Creating equates for local variables is a lot of work and error prone. It’s easy to specify the wrong offset when defining equates, and adding and removing local variables from a procedure is a headache. Fortunately, MASM provides a directive that lets you specify local variables, and MASM automatically fills in the offsets for the locals. That directive, <code>local</code>, uses the following syntax:</p>
<pre><code>local  <var>list_of_declarations</var></code></pre>
<p>The <var>list_of_declarations</var> is a list of local variable declarations, separated by commas. A local variable declaration has two main forms:</p>
<pre><code><var>identifier</var>:<var>type</var>
<var>identifier</var> [<var>elements</var>]:<var>type</var></code></pre>
<p>Here, <var>type</var> is one of the usual MASM data types (<code>byte</code>, <code>word</code>, <code>dword</code>, and so forth), and <var>identifier</var> is the name of the local variable you are declaring. The second form declares local arrays, where <var>elements</var> is the number of array elements. <var>elements</var> must be a constant expression that MASM can resolve at assembly time.</p>
<p><code>local</code> directives, if they appear in a procedure, must be the first statement(s) after a procedure declaration (the <code>proc</code> directive). A procedure may have more than one local statement; if there is more than one <code>local</code> directive, all must appear together after the <code>proc</code> declaration. Here’s a code snippet with examples of local variable declarations:</p>
<pre><code>procWithLocals proc
               local  var1:byte, local2:word, dVar:dword
               local  qArray[4]:qword, rlocal:real4
<span epub:type="pagebreak" title="238" id="Page_238"/>               local  ptrVar:qword
               local  userTypeVar:userType
                 .
                 .   ; Other statements in the procedure.
                 .
procWithLocals endp</code></pre>
<p>MASM automatically associates appropriate offsets with each variable you declare via the <code>local</code> directive. MASM assigns offsets to the variables by subtracting the variable’s size from the current offset (starting at zero) and then rounding down to an offset that is a multiple of the object’s size. For example, if <code>userType</code> is <code>typedef</code>’d to <code>real8</code>, MASM assigns offsets to the local variables in <code>procWithLocals</code> as shown in the following MASM listing output:</p>
<pre><code>var1 <span class="LiteralGray">. . . . . . . . . . . . .</span>        byte     rbp - 00000001
local2 <span class="LiteralGray">. . . . . . . . . . . .</span>        word     rbp - 00000004
dVar <span class="LiteralGray">. . . . . . . . . . . . .</span>        dword    rbp - 00000008
qArray <span class="LiteralGray">. . . . . . . . . . . .</span>        qword    rbp - 00000028
rlocal <span class="LiteralGray">. . . . . . . . . . . .</span>        dword    rbp - 0000002C
ptrVar <span class="LiteralGray">. . . . . . . . . . . .</span>        qword    rbp - 00000034
userTypeVar  <span class="LiteralGray">. . . . . . . . .</span>        qword    rbp - 0000003C</code></pre>
<p>In addition to assigning an offset to each local variable, MASM associates the <code>[RBP-constant]</code> addressing mode with each of these symbols. Therefore, if you use a statement like <code>mov ax, local2</code> in the procedure, MASM will substitute <code>[RBP-4]</code> for the symbol <code>local2</code>.</p>
<p>Of course, upon entry into the procedure, you must still allocate storage for the local variables on the stack; that is, you must still provide the code for the standard entry (and standard exit) sequence. This means you must add up all the storage needed for the local variables so you can subtract this value from RSP after moving RSP’s value into RBP. Once again, this is grunt work that could turn out to be a source of defects in the procedure (if you miscount the number of bytes of local variable storage), so you must take care when manually computing the storage requirements.</p>
<p>MASM does provide a solution (of sorts) for this problem: the <code>option</code> directive. You’ve seen the <code>option casemap:none</code>, <code>option noscoped</code>, and <code>option scoped</code> directives already; the <code>option</code> directive actually supports a wide array of arguments that control MASM’s behavior. Two option operands control procedure code generation when using the local directive: <code>prologue</code> and <code>epilogue</code>. These operands typically take the following two forms:</p>
<pre><code>option prologue:PrologueDef
option prologue:none
option epilogue:EpilogueDef
option epilogue:none</code></pre>
<p>By default, MASM assumes<code> prologue:none</code> and <code>epilogue:none</code>. When you specify <code>none</code> as the <code>prologue</code> and <code>epilogue</code> values, MASM will not generate any extra code to support local variable storage allocation and deallocation in a <span epub:type="pagebreak" title="239" id="Page_239"/>procedure; you will be responsible for supplying the standard entry and exit sequences for the procedure.</p>
<p>If you insert the <code>option prologue:</code><code>PrologueDef</code> (default prologue generation) and <code>option epilogue:</code><code>EpilogueDef</code> (default epilogue generation) into your source file, all following procedures will automatically generate the appropriate standard entry and exit sequences for you (assuming local directives are in the procedure). MASM will quietly generate the standard entry sequence (the <em>prologue</em>) immediately after the last local directive (and before the first machine instruction) in a procedure, consisting of the usual standard entry sequence instructions</p>
<pre><code>push  rbp
mov   rbp, rsp
sub   rsp, <var>local_size</var></code></pre>
<p class="BodyContinued">where <var>local_size</var> is a constant specifying the number of local variables plus a (possible) additional amount to leave the stack aligned on a 16-byte boundary. (MASM usually assumes the stack was aligned on a <em>mod 16 == 8</em> boundary prior to the <code>push rbp</code> instruction.)</p>
<p>For MASM’s automatically generated prologue code to work, the procedure must have exactly one entry point. If you define a global statement label as a second entry point, MASM won’t know that it is supposed to generate the prologue code at that point. Entering the procedure at that second entry point will create problems unless you explicitly include the standard entry sequence yourself. Moral of the story: procedures should have exactly one entry point.</p>
<p>Generating the standard exit sequence for the epilogue is a bit more problematic. Although it is rare for an assembly language procedure to have more than a single <em>entry</em> point, it’s common to have multiple <em>exit</em> points. After all, the exit point is controlled by the programmer’s placement of a <code>ret</code> instruction, not by a directive (like <code>endp</code>). MASM deals with the issue of multiple exit points by automatically translating any <code>ret</code> instruction it finds into the standard exit sequence:</p>
<pre><code>leave
ret</code></pre>
<p>Assuming, of course, that <code>option epilogue:EpilogueDef</code> is active.</p>
<p>You can control whether MASM generates prologues (standard entry sequences) and epilogues (standard exit sequences) independently of one another. So if you would prefer to write the <code>leave</code> instruction yourself (while having MASM generate the standard entry sequence), you can.</p>
<p>One final note about the <code>prologue:</code> and <code>epilogue:</code> options. In addition to specifying <code>prologue:PrologueDef</code> and <code>epilogue:EpilogueDef</code>, you can also supply a <em>macro identifier</em> after the <code>prologue:</code> or <code>epilogue:</code> options. If you supply a macro identifier, MASM will expand that macro for the standard entry or exit sequence. For more information on macros, see <span class="xref" itemid="xref_target_“Macros and the MASM Compile-Time Language” in Chapter 13">“Macros and the MASM Compile-Time Language” in Chapter 13</span>.</p>
<p><span epub:type="pagebreak" title="240" id="Page_240"/>Most of the example programs throughout the remainder of this book continue to use <code>textequ</code> declarations for local variables rather than the <code>local</code> directive to make the use of the <code>[RBP-constant]</code> addressing mode and local variable offsets more explicit.</p>
<h3 id="h2-501089c05-0008">5.4.3	Automatic Allocation</h3>
<p class="BodyFirst">One big advantage to automatic storage allocation is that it efficiently shares a fixed pool of memory among several procedures. For example, say you call three procedures in a row, like so:</p>
<pre><code>call ProcA
call ProcB
call ProcC</code></pre>
<p>The first procedure (<code>ProcA</code> in this code) allocates its local variables on the stack. Upon return, <code>ProcA</code> deallocates that stack storage. Upon entry into <code>ProcB</code>, the program allocates storage for <code>ProcB</code>’s local variables by <em>using the same memory locations just freed by ProcA</em>. Likewise, when <code>ProcB</code> returns and the program calls <code>ProcC</code>, <code>ProcC</code> uses the same stack space for its local variables that <code>ProcB</code> recently freed up. This memory reuse makes efficient use of the system resources and is probably the greatest advantage to using automatic variables.</p>
<p>Now that you’ve seen how assembly language allocates and deallocates storage for local variables, it’s easy to understand why automatic variables do not maintain their values between two calls to the same procedure. Once the procedure returns to its caller, the storage for the automatic variable is lost, and, therefore, the value is lost as well. Thus, <em>you must always assume that a local </em><var>var</var> <em>object is uninitialized upon entry into a procedure</em>. If you need to maintain the value of a variable between calls to a procedure, you should use one of the static variable declaration types.</p>
<h2 id="h1-501089c05-0005">	5.5	Parameters</h2>
<p class="BodyFirst">Although many procedures are totally self-contained, most require input data and return data to the caller. <em>Parameters</em> are values that you pass to and from a procedure. In straight assembly language, passing parameters can be a real chore.</p>
<p>The first thing to consider when discussing parameters is how we pass them to a procedure. If you are familiar with Pascal or C/C++, you’ve probably seen two ways to pass parameters: <em>pass by value</em> and <em>pass by reference</em>. Anything that can be done in an HLL can be done in assembly language (obviously, as HLL code compiles into machine code), but you have to provide the instruction sequence to access those parameters in an appropriate fashion.</p>
<p>Another concern you will face when dealing with parameters is <em>where</em> you pass them. There are many places to pass parameters: in registers, on the stack, in the code stream, in global variables, or in a combination of these. This chapter covers several of the possibilities.</p>
<h3 id="h2-501089c05-0009"><span epub:type="pagebreak" title="241" id="Page_241"/>5.5.1	Pass by Value</h3>
<p class="BodyFirst">A parameter passed by value is just that—the caller passes a value to the procedure. Pass-by-value parameters are input-only parameters. You can pass them to a procedure, but the procedure cannot return values through them. Consider this C/C++ function call:</p>
<pre><code>CallProc(I);</code></pre>
<p>If you pass <code>I</code> by value, <code>CallProc()</code> does not change the value of<em> </em><code>I</code>, regardless of what happens to the parameter inside <code>CallProc()</code>.</p>
<p>Because you must pass a copy of the data to the procedure, you should use this method only for passing small objects like bytes, words, double words, and quad words. Passing large arrays and records by value is inefficient (because you must create and pass a copy of the object to the procedure).<sup class="FootnoteReference"><a id="c05-footnoteref-6" href="#c05-footnote-6">6</a></sup></p>
<h3 id="h2-501089c05-0010">5.5.2	Pass by Reference</h3>
<p class="BodyFirst">To pass a parameter by reference, you must pass the address of a variable rather than its value. In other words, you must pass a pointer to the data. The procedure must dereference this pointer to access the data. Passing parameters by reference is useful when you must modify the actual parameter or when you pass large data structures between procedures. Because pointers on the x86-64 are 64 bits wide, a parameter that you pass by reference will consist of a quad-word value.</p>
<p>You can compute the address of an object in memory in two common ways: the <code>offset</code> operator or the <code>lea</code> instruction. You can use the <code>offset</code> operator to take the address of any static variable you’ve declared in your <code>.data</code>, <code>.data?</code>, <code>.const</code>, or <code>.code</code> sections. <a href="#listing5-8" id="listinganchor5-8">Listing 5-8</a> demonstrates how to obtain the address of a static variable (<code>staticVar</code>) and pass that address to a procedure (<code>someFunc</code>) in the RCX register.</p>
<pre><code>; Listing 5-8
 
; Demonstrate obtaining the address
; of a static variable using offset
; operator.

            option  casemap:none

            .data
staticVar   dword   ?

            .code
            externdef someFunc:proc
            
getAddress  proc

<span epub:type="pagebreak" title="242" id="Page_242"/>            mov     rcx, offset staticVar
            call    someFunc

            ret
getAddress  endp

            end</code></pre>
<p class="CodeListingCaption"><a id="listing5-8">Listing 5-8</a>: Using the <code>offset</code> operator to obtain the address of a static variable</p>
<p>Using the <code>offset</code> operator raises a couple of issues. First of all, it can compute the address of only a static variable; you cannot obtain the address of an automatic (local) variable or parameter, nor can you compute the address of a memory reference involving a complex memory addressing mode (for example, <code>[RBX+RDX*1-5]</code>). Another problem is that an instruction like <code>mov rcx, offset staticVar</code> assembles into a large number of bytes (because the <code>offset</code> operator returns a 64-bit constant). If you look at the assembly listing MASM produces (with the <code>/Fl</code> command line option), you can see how big this instruction is:</p>
<pre><code>00000000  48/ B9                mov    rcx, offset staticVar
           0000000000000000 R
0000000A  E8 00000000 E        call    someFunc</code></pre>
<p>As you can see here, the <code>mov</code> instruction is 10 (0Ah) bytes long.</p>
<p>You’ve seen numerous examples of the second way to obtain the address of a variable: the <code>lea</code> instruction (for example, when loading the address of a format string into RCX prior to calling <code>printf()</code>). <a href="#listing5-9" id="listinganchor5-9">Listing 5-9</a> shows the example in <a href="#listing5-8">Listing 5-8</a> recoded to use the <code>lea</code> instruction.</p>
<pre><code>; Listing 5-9
 
; Demonstrate obtaining the address
; of a variable using the lea instruction.

            option  casemap:none

            .data
staticVar   dword   ?

            .code
            externdef someFunc:proc
            
getAddress  proc

            lea     rcx, staticVar
            call    someFunc

            ret
getAddress  endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing5-9">Listing 5-9</a>: Obtaining the address of a variable using the <code>lea</code> instruction</p>
<p><span epub:type="pagebreak" title="243" id="Page_243"/>Looking at the listing MASM produces for this code, we find that the <code>lea</code> instruction is only 7 bytes long:</p>
<pre><code>00000000  48/ 8D 0D       lea     rcx, staticVar
           00000000 R
00000007  E8 00000000 E   call    someFunc</code></pre>
<p>So, if nothing else, your programs will be shorter if you use the <code>lea</code> instruction rather than the <code>offset</code> operator.</p>
<p>Another advantage to using <code>lea</code> is that it will accept any memory addressing mode, not just the name of a static variable. For example, if <code>staticVar</code> were an array of 32-bit integers, you could load the current element address, indexed by the RDX register, in RCX by using an instruction such as this:</p>
<pre><code>lea rcx, staticVar[rdx*4]  ; Assumes LARGEADDRESSAWARE:NO</code></pre>
<p>Pass by reference is usually less efficient than pass by value. You must dereference all pass-by-reference parameters on each access; this is slower than simply using a value because it typically requires at least two instructions. However, when passing a large data structure, pass by reference is faster because you do not have to copy the large data structure before calling the procedure. Of course, you’d probably need to access elements of that large data structure (for example, an array) by using a pointer, so little efficiency is lost when you pass large arrays by reference.</p>
<h3 id="h2-501089c05-0011">5.5.3	Low-Level Parameter Implementation</h3>
<p class="BodyFirst">A parameter-passing mechanism is a contract between the caller and the callee (the procedure). Both parties have to agree on where the parameter data will appear and what form it will take (for example, value or address). If your assembly language procedures are being called only by other assembly language code that you’ve written, you control both sides of the contract negotiation and get to decide where and how you’re going to pass parameters.</p>
<p>However, if external code is calling your procedure, or your procedure is calling external code, your procedure will have to adhere to whatever <em>calling convention</em> that external code uses. On 64-bit Windows systems, that calling convention will, undoubtedly, be the Windows ABI.</p>
<p>Before discussing the Windows calling conventions, we’ll consider the situation of calling code that you’ve written (and, therefore, have complete control over the calling conventions). The following sections provide insight into the various ways you can pass parameters in pure assembly language code (without the overhead associated with the Microsoft ABI).</p>
<h4 id="h3-501089c05-0003">5.5.3.1	Passing Parameters in Registers </h4>
<p class="BodyFirst">Having touched on <em>how</em> to pass parameters to a procedure, the next thing to discuss is <em>where</em> to pass parameters. This depends on the size and number of those parameters. If you are passing a small number of parameters to a <span epub:type="pagebreak" title="244" id="Page_244"/>procedure, the registers are an excellent place to pass them. If you are passing a single parameter to a procedure, you should use the registers listed in <a href="#table5-1" id="tableanchor5-1">Table 5-1</a> for the accompanying data types.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table5-1">Table 5-1</a>: Parameter Location by Size</p></figcaption>
<table id="table-501089c05-0001" border="1">
<thead>
<tr>
<td><b>Data size</b></td>
<td><b>Pass in this register</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Byte</td>
<td>CL</td>
</tr>
<tr>
<td>Word</td>
<td>CX</td>
</tr>
<tr>
<td>Double word</td>
<td>ECX</td>
</tr>
<tr>
<td>Quad word</td>
<td>RCX</td>
</tr>
</tbody>
</table>
</figure>
<p>This is not a hard-and-fast rule. However, these registers are convenient because they mesh with the first parameter register in the Microsoft ABI (which is where most people will pass a single parameter).</p>
<p>If you are passing several parameters to a procedure in the x86-64’s registers, you should probably use up the registers in the following order:</p>
<pre><code>First                                           Last
RCX, RDX, R8, R9, R10, R11, RAX, XMM0/YMM0-XMM5/YMM5</code></pre>
<p>In general, you should pass integer and other non-floating-point values in the general-purpose registers, and floating-point values in the XMM<em>x</em>/YMM<em>x</em> registers. This is not a hard requirement, but Microsoft reserves these registers for passing parameters and for local variables (<em>volatile</em>), so using these registers to pass parameters won’t mess with Microsoft ABI nonvolatile registers. Of course, if you intend to have Microsoft ABI–compliant code call your procedure, you must exactly observe the Microsoft calling conventions (see <span class="xref" itemid="xref_target_“Calling Conventions and the Microsoft ABI” on page 261">“Calling Conventions and the Microsoft ABI” on page 261</span>).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	You can use the <code>movsd</code> instruction to load a double-precision value into one of the XMM registers.<sup class="FootnoteReference"><a id="c05-footnoteref-7" href="#c05-footnote-7">7</a></sup> This instruction has the following syntax:</p>
<pre><code>movsd  XMM<span class="SubscriptLiteralItalic">n</span>, mem<sub>64</sub></code></pre>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Of course, if you’re writing pure assembly language code (no calls to or from any code you didn’t write), you can use most of the general-purpose registers as you see fit (RSP is an exception, and you should avoid RBP, but the others are fair game). Ditto for the XMM/YMM registers.</p>
<p>As an example, consider the <code>strfill(s,c)</code> procedure that copies the character <code>c</code> (passed by value in AL) to each character position in <code>s</code> (passed by reference in RDI) up to a zero-terminating byte (<a href="#listing5-10" id="listinganchor5-10">Listing 5-10</a>).</p>
<pre><code><span epub:type="pagebreak" title="245" id="Page_245"/>; Listing 5-10
 
; Demonstrate passing parameters in registers.

            option  casemap:none

            .data
staticVar   dword   ?

            .code
            externdef someFunc:proc
 
; strfill - Overwrites the data in a string with a character.
 
;     RDI -  Pointer to zero-terminated string
;            (for example, a C/C++ string).
;      AL -  Character to store into the string.

strfill     proc
            push    rdi     ; Preserve RDI because it changes

; While we haven't reached the end of the string:

whlNot0:    cmp     byte ptr [rdi], 0
            je      endOfStr

; Overwrite character in string with the character
; passed to this procedure in AL:

            mov     [rdi], al

; Move on to the next character in the string and
; repeat this process:

            inc     rdi
            jmp     whlNot0

endOfStr:   pop     rdi
            ret
strfill     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing5-10">Listing 5-10</a>: Passing parameters in registers to the <code>strfill</code> procedure</p>
<p>To call the <code>strfill</code> procedure, you would load the address of the string data into RDI and the character value into AL prior to the call. The following code fragment demonstrates a typical call to <code>strfill</code>:</p>
<pre><code>lea  rdi, stringData ; Load address of string into RDI
mov  al, ' '         ; Fill string with spaces
call strfill</code></pre>
<p>This code passes the string by reference and the character data by value.</p>
<h4 id="h3-501089c05-0004"><span epub:type="pagebreak" title="246" id="Page_246"/>5.5.3.2	Passing Parameters in the Code Stream</h4>
<p class="BodyFirst">Another place where you can pass parameters is in the code stream immediately after the <code>call</code> instruction. Consider the following <code>print</code> routine that prints a literal string constant to the standard output device:</p>
<pre><code>call print
byte "This parameter is in the code stream.",0</code></pre>
<p>Normally, a subroutine returns control to the first instruction immediately following the <code>call</code> instruction. Were that to happen here, the x86-64 would attempt to interpret the ASCII codes for <code>"This..."</code> as an instruction. This would produce undesirable results. Fortunately, you can skip over this string before returning from the subroutine. </p>
<p>So how do you gain access to these parameters? Easy. The return address on the stack points at them. Consider the implementation of <code>print</code> appearing in <a href="#listing5-11" id="listinganchor5-11">Listing 5-11</a>.</p>
<pre><code>; Listing 5-11
 
; Demonstration passing parameters in the code stream.

        option  casemap:none

nl          =       10
stdout      =       -11

            .const
ttlStr      byte    "Listing 5-11", 0

            .data
soHandle    qword   ?
bWritten    dword   ?

            .code

            ; Magic equates for Windows API calls:

            extrn __imp_GetStdHandle:qword
            extrn __imp_WriteFile:qword

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; Here's the print procedure.
; It expects a zero-terminated string
; to follow the call to print.

<span epub:type="pagebreak" title="247" id="Page_247"/>print       proc
            push    rbp
            mov     rbp, rsp
            and     rsp, -16         ; Ensure stack is 16-byte-aligned
            sub     rsp, 48          ; Set up stack for MS ABI

; Get the pointer to the string immediately following the
; call instruction and scan for the zero-terminating byte.

            mov     rdx, [rbp+8]     ; Return address is here
            lea     r8, [rdx-1]      ; R8 = return address - 1
search4_0:  inc     r8               ; Move on to next char
            cmp     byte ptr [R8], 0 ; At end of string?
            jne     search4_0

; Fix return address and compute length of string:

            inc     r8               ; Point at new return address
            mov     [rbp+8], r8      ; Save return address
            sub     r8, rdx          ; Compute string length
            dec     r8               ; Don't include 0 byte

; Call WriteFile to print the string to the console:
 
; WriteFile(fd, bufAdrs, len, &amp;bytesWritten);
 
; Note: pointer to the buffer (string) is already
; in RDX. The len is already in R8. Just need to
; load the file descriptor (handle) into RCX:

            mov     rcx, soHandle    ; Zero-extends!
            lea     r9, bWritten     ; Address of "bWritten" in R9
            call    __imp_WriteFile

            leave
            ret
print       endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 40
        
; Call getStdHandle with "stdout" parameter
; in order to get the standard output handle
; we can use to call write. Must set up
; soHandle before first call to print procedure.

            mov     ecx, stdout      ; Zero-extends!
            call    __imp_GetStdHandle
            mov     soHandle, rax    ; Save handle

<span epub:type="pagebreak" title="248" id="Page_248"/>; Demonstrate passing parameters in code stream
; by calling the print procedure:

            call    print
            byte    "Hello, world!", nl, 0

; Clean up, as per Microsoft ABI:

            leave
            ret     ; Returns to caller

asmMain     endp
            end </code></pre>
<p class="CodeListingCaption"><a id="listing5-11">Listing 5-11</a>: Print procedure implementation (using code stream parameters)</p>
<p>One quick note about a machine idiom in <a href="#listing5-11">Listing 5-11</a>. The instruction</p>
<pre><code>lea  r8, [rdx-1]</code></pre>
<p class="BodyContinued">isn’t actually loading an address into R8, per se. This is really an arithmetic instruction that is computing R8 = RDX – 1 (with a single instruction rather than two as would normally be required). This is a common usage of the <code>lea</code> instruction in assembly language programs. Therefore, it’s a little programming trick that you should become comfortable with.</p>
<p>Besides showing how to pass parameters in the code stream, the <code>print</code> routine also exhibits another concept: <em>variable-length parameters</em>. The string following the <code>call</code> can be any practical length. The zero-terminating byte marks the end of the parameter list.</p>
<p>We have two easy ways to handle variable-length parameters: either use a special terminating value (like 0) or pass a special length value that tells the subroutine the number of parameters you are passing. Both methods have their advantages and disadvantages.</p>
<p>Using a special value to terminate a parameter list requires that you choose a value that never appears in the list. For example, <code>print</code> uses 0 as the terminating value, so it cannot print the NUL character (whose ASCII code is 0). Sometimes this isn’t a limitation. Specifying a length parameter is another mechanism you can use to pass a variable-length parameter list. While this doesn’t require any special codes, or limit the range of possible values that can be passed to a subroutine, setting up the length parameter and maintaining the resulting code can be a real nightmare.<sup class="FootnoteReference"><a id="c05-footnoteref-8" href="#c05-footnote-8">8</a></sup></p>
<p>Despite the convenience afforded by passing parameters in the code stream, passing parameters there has disadvantages. First, if you fail to provide the exact number of parameters the procedure requires, the subroutine will get confused. Consider the <code>print</code> example. It prints a string of characters up to a zero-terminating byte and then returns control to the first instruction following that byte. If you leave off the zero-terminating <span epub:type="pagebreak" title="249" id="Page_249"/>byte, the <code>print</code> routine happily prints the following opcode bytes as ASCII characters until it finds a zero byte. Because zero bytes often appear in the middle of an instruction, the <code>print</code> routine might return control into the middle of another instruction, which will probably crash the machine.</p>
<p>Inserting an extra 0, which occurs more often than you might think, is another problem programmers have with the <code>print</code> routine. In such a case, the <code>print</code> routine would return upon encountering the first zero byte and attempt to execute the following ASCII characters as machine code. Problems notwithstanding, however, the code stream is an efficient place to pass parameters whose values do not change.</p>
<h4 id="h3-501089c05-0005">5.5.3.3	Passing Parameters on the Stack</h4>
<p class="BodyFirst">Most high-level languages use the stack to pass a large number of parameters because this method is fairly efficient. Although passing parameters on the stack is slightly less efficient than passing parameters in registers, the register set is limited (especially if you’re limiting yourself to the four registers the Microsoft ABI sets aside for this purpose), and you can pass only a few value or reference parameters through registers. The stack, on the other hand, allows you to pass a large amount of parameter data without difficulty. This is the reason that most programs pass their parameters on the stack (at least, when passing more than about three to six parameters).</p>
<p>To manually pass parameters on the stack, push them immediately before calling the subroutine. The subroutine then reads this data from the stack memory and operates on it appropriately. Consider the following high-level language function call:</p>
<pre><code>CallProc(i,j,k);</code></pre>
<p>Back in the days of 32-bit assembly language, you could have passed these parameters to <code>CallProc</code> by using an instruction sequence such as the following:</p>
<pre><code>push  k  ; Assumes i, j, and k are all 32-bit
push  j  ; variables
push  i  
call  CallProc</code></pre>
<p>Unfortunately, with the advent of the x86-64 64-bit CPU, the 32-bit push instruction was removed from the instruction set (the 64-bit <code>push</code> instruction replaced it). If you want to pass parameters to a procedure by using the <code>push</code> instruction, they must be 64-bit operands.<sup class="FootnoteReference"><a id="c05-footnoteref-9" href="#c05-footnote-9">9</a></sup></p>
<p>Because keeping RSP aligned on an appropriate boundary (8 or 16 bytes) is crucial, the Microsoft ABI simply requires that every parameter <span epub:type="pagebreak" title="250" id="Page_250"/>consume 8 bytes on the stack, and thus doesn’t allow larger arguments on the stack. If you’re controlling both sides of the parameter contract (caller and callee), you can pass larger arguments to your procedures. However, it is a good idea to ensure that all parameter sizes are a multiple of 8 bytes.</p>
<p>One simple solution is to make all your variables <code>qword</code> objects. Then you can directly push them onto the stack by using the <code>push</code> instruction prior to calling a procedure. However, not all objects fit nicely into 64 bits (characters, for example). Even those objects that could be 64 bits (for example, integers) often don’t require the use of so much storage. </p>
<p>One sneaky way to use the <code>push</code> instruction on smaller objects is to use type coercion. Consider the following calling sequence for <code>CallProc</code>:</p>
<pre><code>push  qword ptr k
push  qword ptr j
push  qword ptr i
call  CallProc</code></pre>
<p>This sequence pushes the 64-bit values starting at the addresses associated with variables <code>i</code>, <code>j</code>, and <code>k</code>, regardless of the size of these variables. If the <code>i</code>, <code>j</code>, and <code>k</code> variables are smaller objects (perhaps 32-bit integers), these <code>push</code> instructions will push their values onto the stack along with additional data beyond these variables. As long as <code>CallProc</code> treats these parameter values as their actual size (say, 32 bits) and ignores the HO bits pushed for each argument onto the stack, this will usually work out properly.</p>
<p>Pushing extra data beyond the bounds of the variable onto the stack creates one possible problem. If the variable is at the very end of a page in memory and the following page is not readable, then pushing data beyond the variable may attempt to push data from that next memory page, resulting in a memory access violation (which will crash your program). Therefore, if you use this technique, you must ensure that such variables do not appear at the very end of a memory page (with the possibility that the next page in memory is inaccessible). The easiest way to do this is to make sure the variables you push on the stack in this fashion are never the last variables you declare in your data sections; for example:</p>
<pre><code>i    dword ?
j    dword ?
k    dword ?
pad  qword ?  ; Ensures that there are at least 64 bits
              ; beyond the k variable</code></pre>
<p>While pushing extra data beyond a variable will work, it’s still a questionable programming practice. A better technique is to abandon the <code>push</code> instructions altogether and use a different technique to move the parameter data onto the stack.</p>
<p>Another way to “push” data onto the stack is to drop the RSP register down an appropriate amount in memory and then simply move data onto <span epub:type="pagebreak" title="251" id="Page_251"/>the stack by using a <code>mov</code> (or similar) instruction. Consider the following calling sequence for <code>CallProc</code>:</p>
<pre><code>sub  rsp, 12
mov  eax, k
mov  [rsp+8], eax
mov  eax, j
mov  [rsp+4], eax
mov  eax, i
mov  [rsp], eax
call CallProc</code></pre>
<p>Although this takes twice as many instructions as the previous examples (eight versus four), this sequence is safe (no possibility of accessing inaccessible memory pages). Furthermore, it pushes exactly the amount of data needed for the parameters onto the stack (32 bits for each object, for a total of 12 bytes).</p>
<p>The major problem with this approach is that it is a really bad idea to have an address in the RSP register that is not aligned on an 8-byte boundary. In the worst case, having a nonaligned (to 8 bytes) stack will crash your program; in the very best case, it will affect the performance of your program. So even if you want to pass the parameters as 32-bit integers, you should always allocate a multiple of 8 bytes for parameters on the stack prior to a call. The previous example would be encoded as follows:</p>
<pre><code>sub  rsp, 16   ; Allocate a multiple of 8 bytes
mov  eax, k
mov  [rsp+8], eax
mov  eax, j
mov  [rsp+4], eax
mov  eax, i
mov  [rsp], eax
call CallProc</code></pre>
<p>Note that <code>CallProc</code> will simply ignore the extra 4 bytes allocated on the stack in this fashion (don’t forget to remove this extra storage from the stack on return).</p>
<p>To satisfy the requirement of the Microsoft ABI (and, in fact, of most application binary interfaces for the x86-64 CPUs) that each parameter consume exactly 8 bytes (even if their native data size is smaller), you can use the following code (same number of instructions, just uses a little more stack space):</p>
<pre><code>sub  rsp, 24   ; Allocate a multiple of 8 bytes
mov  eax, k
mov  [rsp+16], eax
mov  eax, j
mov  [rsp+8], eax
mov  eax, i
mov  [rsp], eax
call CallProc</code></pre>
<p><span epub:type="pagebreak" title="252" id="Page_252"/>The <code>mov</code> instructions spread out the data on 8-byte boundaries. The HO dword of each 64-bit entry on the stack will contain garbage (whatever data was in stack memory prior to this sequence). That’s okay; the <code>CallProc</code> procedure (presumably) will ignore that extra data and operate only on the LO 32 bits of each parameter value.</p>
<p>Upon entry into <code>CallProc</code>, using this sequence, the x86-64’s stack looks like <a href="#figure5-7" id="figureanchor5-7">Figure 5-7</a>. </p>
<figure>
<img src="image_fi/501089c05/f05007.png" alt="f05007" class=""/>
<figcaption><p><a id="figure5-7">Figure 5-7</a>: Stack layout upon entry into <span class="LiteralInCaption"><code>CallProc</code></span></p></figcaption>
</figure>
<p>If your procedure includes the standard entry and exit sequences, you may directly access the parameter values in the activation record by indexing off the RBP register. Consider the layout of the activation record for <code>CallProc</code> that uses the following declaration:</p>
<pre><code>CallProc proc
         push  rbp      ; This is the standard entry sequence
         mov   rbp, rsp ; Get base address of activation record into RBP
          .
          .
          .
         leave
         ret   24</code></pre>
<p>Assuming you’ve pushed three quad-word parameters onto the stack, it should look something like <a href="#figure5-8" id="figureanchor5-8">Figure 5-8</a> immediately after the execution of <code>mov rbp, rsp</code> in <code>CallProc</code>.</p>
<p>Now you can access the parameters by indexing off the RBP register:</p>
<pre><code>mov eax, [rbp+32]    ; Accesses the k parameter
mov ebx, [rbp+24]    ; Accesses the j parameter
mov ecx, [rbp+16]    ; Accesses the i parameter</code></pre>
<span epub:type="pagebreak" title="253" id="Page_253"/><figure>
<img src="image_fi/501089c05/f05008.png" alt="f05008" class=""/>
<figcaption><p><a id="figure5-8">Figure 5-8</a>: Activation record for <span class="LiteralInCaption"><code>CallProc</code></span> after standard entry sequence execution</p></figcaption>
</figure>
<h4 id="h3-501089c05-0006">5.5.3.4	Accessing Value Parameters on the Stack</h4>
<p class="BodyFirst">Accessing parameters passed by value is no different from accessing a local variable object. One way to accomplish this is by using equates, as was demonstrated for local variables earlier. <a href="#listing5-12" id="listinganchor5-12">Listing 5-12</a> provides an example program whose procedure accesses a parameter that the main program passes to it by value.</p>
<pre><code>; Listing 5-12
 
; Accessing a parameter on the stack.

        option  casemap:none

nl          =       10
stdout      =       -11

            .const
ttlStr      byte    "Listing 5-12", 0
fmtStr1     byte    "Value of parameter: %d", nl, 0

            .data
value1      dword   20
value2      dword   30

            .code
            externdef printf:proc
            
<span epub:type="pagebreak" title="254" id="Page_254"/>; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

theParm     equ     &lt;[rbp+16]&gt;
ValueParm   proc
            push    rbp
            mov     rbp, rsp

            sub     rsp, 32         ; "Magic" instruction

            lea     rcx, fmtStr1
            mov     edx, theParm
            call    printf

            leave
            ret
ValueParm   endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 40

            mov     eax, value1
            mov     [rsp], eax      ; Store parameter on stack
            call    ValueParm

            mov     eax, value2
            mov     [rsp], eax
            call    ValueParm

; Clean up, as per Microsoft ABI:

            leave
            ret                     ; Returns to caller
        
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing5-12">Listing 5-12</a>: Demonstration of value parameters</p>
<p>Although you could access the value of <code>theParm</code> by using the anonymous address <code>[RBP+16]</code> within your code, using the equate in this fashion makes your code more readable and maintainable.</p>
<h3 id="h2-501089c05-0012"><span epub:type="pagebreak" title="255" id="Page_255"/>5.5.4	Declaring Parameters with the proc Directive</h3>
<p class="BodyFirst">MASM provides another solution for declaring parameters for procedures using the <code>proc</code> directive. You can supply a list of parameters as operands to the <code>proc</code> directive, as follows:</p>
<pre><code><var>proc_name</var>  proc  <var>parameter_list</var></code></pre>
<p class="BodyContinued">where <var>parameter_list</var> is a list of one or more parameter declarations separated by commas. Each parameter declaration takes the form</p>
<pre><code><var>parm_name</var>:<var>type</var></code></pre>
<p class="BodyContinued">where <var>parm_name</var> is a valid MASM identifier, and <var>type</var> is one of the usual MASM types (<code>proc</code>, <code>byte</code>, <code>word</code>, <code>dword</code>, and so forth). With one exception, the parameter list declarations are identical to the local directive’s operands: the exception is that MASM doesn’t allow arrays as parameters. (MASM parameters assume that the Microsoft ABI is being used, and the Microsoft ABI allows only 64-bit parameters.)</p>
<p>The parameter declarations appearing as <code>proc</code> operands assume that a standard entry sequence is executed and that the program will access parameters off the RBP register, with the saved RBP and return address values at offsets 0 and 8 from the RBP register (so the first parameter will start at offset 16). MASM assigns offsets for each parameter that are 8 bytes apart (per the Microsoft ABI). As an example, consider the following parameter declaration:</p>
<pre><code>procWithParms proc  k:byte, j:word, i:dword
                .
                .
                .
procWithParms endp</code></pre>
<p><code>k</code> will have the offset <code>[RBP+16]</code>, <code>j</code> will have the offset <code>[RBP+24]</code>, and <code>i</code> will have the offset <code>[RBP+32]</code>. Again, the offsets are always 8 bytes, regardless of the parameter data type.</p>
<p>As per the Microsoft ABI, MASM will allocate storage on the stack for the first four parameters, even though you would normally pass these parameters in RCX, RDX, R8, and R9. These 32 bytes of storage (starting at <code>RBP+16</code>) are called <em>shadow storage</em> in Microsoft ABI nomenclature. Upon entry into the procedure, the parameter values do not appear in this shadow storage (instead, the values are in the registers). The procedure can save the register values in this preallocated storage, or it can use the shadow storage for any purpose it desires (such as for additional local variable storage). However, if the procedure refers to the parameter names declared in the <code>proc</code> operand field, expecting to access the parameter data, the procedure should store the values from these registers into that shadow storage (assuming the parameters were passed in the RCX, RDX, R8, and R9 registers). Of course, if you <span epub:type="pagebreak" title="256" id="Page_256"/>push these arguments on the stack prior to the call (in assembly language, ignoring the Microsoft ABI calling convention), then the data is already in place, and you don’t have to worry about shadow storage issues.</p>
<p>When calling a procedure whose parameters you declare in the operand field of a <code>proc</code> directive, don’t forget that MASM assumes you push the parameters onto the stack in the reverse order they appear in the parameter list, to ensure that the first parameter in the list is at the lowest memory address on the stack. For example, if you call the <code>procWithParms</code> procedure from the previous code snippet, you’d typically use code like the following to push the parameters:</p>
<pre><code>mov   eax, dwordValue
push  rax             ; Parms are always 64 bits
mov   ax, wordValue
push  rax
mov   al, byteValue
push  rax
call  procWithParms</code></pre>
<p>Another possible solution (a few bytes longer, but often faster) is to use the following code:</p>
<pre><code>sub   rsp, 24         ; Reserve storage for parameters
mov   eax, dwordValue ; i
mov   [rsp+16], eax
mov   ax, wordValue
mov   [rsp+8], ax     ; j
mov   al, byteValue
mov   [rsp], al       ; k
call  procWithParms</code></pre>
<p>Don’t forget that if it is the callee’s responsibility to clean up the stack, you’d probably use an <code>add rsp, 24</code> instruction after the preceding two sequences to remove the parameters from the stack. Of course, you can also have the procedure itself clean up the stack by specifying the number to add to RSP as a <code>ret</code> instruction operand, as explained earlier in this chapter.</p>
<h3 id="h2-501089c05-0013">5.5.5	Accessing Reference Parameters on the Stack</h3>
<p class="BodyFirst">Because you pass the addresses of objects as reference parameters, accessing the reference parameters within a procedure is slightly more difficult than accessing value parameters because you have to dereference the pointers to the reference parameters.</p>
<p>In <a href="#listing5-13" id="listinganchor5-13">Listing 5-13</a>, the <code>RefParm</code> procedure has a single pass-by-reference parameter. A pass-by-reference parameter is always a (64-bit) pointer to an object. To access the value associated with the parameter, this code has to load that quad-word address into a 64-bit register and access the data indirectly. The <code>mov rax, theParm</code> instruction in <a href="#listing5-13">Listing 5-13</a> fetches this pointer into the RAX register, and then the procedure <code>RefParm</code> uses the <code>[RAX]</code> addressing mode to access the actual value of <code>theParm</code>.</p>
<pre><code><span epub:type="pagebreak" title="257" id="Page_257"/>; Listing 5-13
 
; Accessing a reference parameter on the stack.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 5-13", 0
fmtStr1     byte    "Value of parameter: %d", nl, 0

            .data
value1      dword   20
value2      dword   30

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

theParm     equ     &lt;[rbp+16]&gt; 
RefParm     proc
            push    rbp
            mov     rbp, rsp

            sub     rsp, 32         ; "Magic" instruction

            lea     rcx, fmtStr1
            mov     rax, theParm    ; Dereference parameter
            mov     edx, [rax]
            call    printf

            leave
            ret
RefParm     endp

; Here is the "asmMain" function.
        
            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 40

            lea     rax, value1
            mov     [rsp], rax      ; Store address on stack
            call    RefParm

<span epub:type="pagebreak" title="258" id="Page_258"/>            lea     rax, value2
            mov     [rsp], rax
            call    RefParm

; Clean up, as per Microsoft ABI:

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing5-13">Listing 5-13</a>: Accessing a reference parameter</p>
<p>Here are the build commands and program output for <a href="#listing5-13">Listing 5-13</a>:</p>
<pre><code>C:\&gt;<b>build listing5-13</b>

C:\&gt;<b>echo off</b>
 Assembling: listing5-13.asm
c.cpp

C:\&gt;<b>listing5-13</b>
Calling Listing 5-13:
Value of parameter: 20
Value of parameter: 30
Listing 5-13 terminated</code></pre>
<p>As you can see, accessing (small) pass-by-reference parameters is a little less efficient than accessing value parameters because you need an extra instruction to load the address into a 64-bit pointer register (not to mention you have to reserve a 64-bit register for this purpose). If you access reference parameters frequently, these extra instructions can really begin to add up, reducing the efficiency of your program. Furthermore, it’s easy to forget to dereference a reference parameter and use the address of the value in your calculations. Therefore, unless you really need to affect the value of the actual parameter, you should use pass by value to pass small objects to a procedure.</p>
<p>Passing large objects, like arrays and records, is where using reference parameters becomes efficient. When passing these objects by value, the calling code has to make a copy of the actual parameter; if it is a large object, the copy process can be inefficient. Because computing the address of a large object is just as efficient as computing the address of a small scalar object, no efficiency is lost when passing large objects by reference. Within the procedure, you must still dereference the pointer to access the object, but the efficiency loss due to indirection is minimal when you contrast this with the cost of copying that large object. The program in <a href="#listing5-14" id="listinganchor5-14">Listing 5-14</a> demonstrates how to use pass by reference to initialize an array of records.</p>
<pre><code>; Listing 5-14
 
; Passing a large object by reference.

<span epub:type="pagebreak" title="259" id="Page_259"/>        option  casemap:none

nl          =       10
NumElements =       24

Pt          struct
x           byte    ?
y           byte    ?
Pt          ends

            .const
ttlStr      byte    "Listing 5-14", 0
fmtStr1     byte    "RefArrayParm[%d].x=%d ", 0
fmtStr2     byte    "RefArrayParm[%d].y=%d", nl, 0

            .data
index       dword   ?
Pts         Pt      NumElements dup ({})

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

ptArray     equ     &lt;[rbp+16]&gt; 
RefAryParm  proc
            push    rbp
            mov     rbp, rsp

            mov     rdx, ptArray
            xor     rcx, rcx        ; RCX = 0

; While ECX &lt; NumElements, initialize each
; array element. x = ECX/8, y = ECX % 8.

ForEachEl:  cmp     ecx, NumElements
            jnl     LoopDone

            mov     al, cl
            shr     al, 3           ; AL = ECX / 8
            mov     [rdx][rcx*2].Pt.x, al

            mov     al, cl
            and     al, 111b        ; AL = ECX % 8
            mov     [rdx][rcx*2].Pt.y, al
            inc     ecx
            jmp     ForEachEl

LoopDone:   leave
<span epub:type="pagebreak" title="260" id="Page_260"/>            ret
RefAryParm  endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 40

; Initialize the array of points:

            lea     rax, Pts
            mov     [rsp], rax      ; Store address on stack
            call    RefAryParm

; Display the array:

            mov     index, 0
dispLp:     cmp     index, NumElements
            jnl     dispDone

            lea     rcx, fmtStr1
            mov     edx, index              ; Zero-extends!
            lea     r8, Pts                 ; Get array base
            movzx   r8, [r8][rdx*2].Pt.x    ; Get x field
            call    printf

            lea     rcx, fmtStr2
            mov     edx, index              ; Zero-extends!
            lea     r8, Pts                 ; Get array base
            movzx   r8, [r8][rdx*2].Pt.y    ; Get y field
            call    printf

            inc     index
            jmp     dispLp

; Clean up, as per Microsoft ABI:

dispDone:
            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing5-14">Listing 5-14</a>: Passing an array of records by referencing</p>
<p>Here are the build commands and output for <a href="#listing5-14">Listing 5-14</a>:</p>
<pre><code>C:\&gt;<b>build listing5-14</b>

C:\&gt;<b>echo off</b>
<span epub:type="pagebreak" title="261" id="Page_261"/> Assembling: listing5-14.asm
c.cpp

C:\&gt;<b>listing5-14</b>
Calling Listing 5-14:
RefArrayParm[0].x=0 RefArrayParm[0].y=0
RefArrayParm[1].x=0 RefArrayParm[1].y=1
RefArrayParm[2].x=0 RefArrayParm[2].y=2
RefArrayParm[3].x=0 RefArrayParm[3].y=3
RefArrayParm[4].x=0 RefArrayParm[4].y=4
RefArrayParm[5].x=0 RefArrayParm[5].y=5
RefArrayParm[6].x=0 RefArrayParm[6].y=6
RefArrayParm[7].x=0 RefArrayParm[7].y=7
RefArrayParm[8].x=1 RefArrayParm[8].y=0
RefArrayParm[9].x=1 RefArrayParm[9].y=1
RefArrayParm[10].x=1 RefArrayParm[10].y=2
RefArrayParm[11].x=1 RefArrayParm[11].y=3
RefArrayParm[12].x=1 RefArrayParm[12].y=4
RefArrayParm[13].x=1 RefArrayParm[13].y=5
RefArrayParm[14].x=1 RefArrayParm[14].y=6
RefArrayParm[15].x=1 RefArrayParm[15].y=7
RefArrayParm[16].x=2 RefArrayParm[16].y=0
RefArrayParm[17].x=2 RefArrayParm[17].y=1
RefArrayParm[18].x=2 RefArrayParm[18].y=2
RefArrayParm[19].x=2 RefArrayParm[19].y=3
RefArrayParm[20].x=2 RefArrayParm[20].y=4
RefArrayParm[21].x=2 RefArrayParm[21].y=5
RefArrayParm[22].x=2 RefArrayParm[22].y=6
RefArrayParm[23].x=2 RefArrayParm[23].y=7
Listing 5-14 terminated</code></pre>
<p>As you can see from this example, passing large objects by reference is very efficient.</p>
<h2 id="h1-501089c05-0006">	5.6	Calling Conventions and the Microsoft ABI</h2>
<p class="BodyFirst">Back in the days of 32-bit programs, different compilers and languages typically used completely different parameter-passing conventions. As a result, a program written in Pascal could not call a C/C++ function (at least, using the native Pascal parameter-passing conventions). Similarly, C/C++ programs couldn’t call FORTRAN, or BASIC, or functions written in other languages, without special help from the programmer. It was literally a Tower of Babel situation, as the languages were incompatible with one another.<sup class="FootnoteReference"><a id="c05-footnoteref-10" href="#c05-footnote-10">10</a></sup></p>
<p>To resolve these problems, CPU manufacturers, such as Intel, devised a set of protocols known as the <em>application binary interface</em> <em>(</em><em>ABI)</em> to provide conformity to procedure calls. Languages that conformed to the CPU <span epub:type="pagebreak" title="262" id="Page_262"/>manufacturer’s ABI were able to call functions and procedures written in other languages that also conformed to the same ABI. This brought a modicum of sanity to the world of programming language interoperability.</p>
<p>For programs running under Windows, Microsoft took a subset of the Intel ABI and created the Microsoft calling convention (which most people call the <em>Microsoft ABI</em>). The next section covers the Microsoft calling conventions in detail. However, first it’s worthwhile to discuss many of the other calling conventions that existed prior to the Microsoft ABI.<sup class="FootnoteReference"><a id="c05-footnoteref-11" href="#c05-footnote-11">11</a></sup></p>
<p>One of the older <em>formal</em> calling conventions is the <em>Pascal calling convention</em>. In this<em> </em>convention, a caller pushes parameters on the stack in the order that they appear in the actual parameter list (from left to right). On the 80x86/x86-64 CPUs, where the stack grows down in memory, the first parameter winds up at the highest address on the stack, and the last parameter winds up at the lowest address on the stack.</p>
<p>While it might look like the parameters appear backward on the stack, the computer doesn’t really care. After all, the procedure will access the parameters by using a numeric offset, and it doesn’t care about the offset’s value.<sup class="FootnoteReference"><a id="c05-footnoteref-12" href="#c05-footnote-12">12</a></sup> On the other hand, for simple compilers, it’s much easier to generate code that pushes the parameters in the order they appear in the source file, so the Pascal calling convention makes life a little easier for compiler writers (though optimizing compilers often rearrange the code anyway).</p>
<p>Another feature of the Pascal calling convention is that the callee (the procedure itself) is responsible for removing parameter data from the stack upon subroutine return. This localizes the cleanup code to the procedure so that parameter cleanup isn’t duplicated across every call to the procedure.</p>
<p>The big drawback to the Pascal calling sequence is that handling variable parameter lists is difficult. If one call to a procedure has three parameters, and a second call has four parameters, the offset to the first parameter will vary depending on the actual number of parameters. Furthermore, it’s more difficult (though certainly not impossible) for a procedure to clean up the stack after itself if the number of parameters varies. This is not an issue for Pascal programs, as standard Pascal does not allow user-written procedures and functions to have varying parameter lists. For languages like C/C++, however, this is an issue.</p>
<p>Because C (and other C-based programming languages) supports varying parameter lists (for example, the <code>printf()</code> function), C adopted a different calling convention: the <em>C calling convention</em>, also known as the <em>cdecl calling convention</em>. In C, the caller pushes parameters on the stack in the reverse order that they appear in the actual parameter list. So, it pushes the last parameter first and pushes the first parameter last. <span epub:type="pagebreak" title="263" id="Page_263"/>Because the stack is a LIFO data structure, the first parameter winds up at the lowest address on the stack (and at a fixed offset from the return address, typically right above it in memory; this is true regardless of how many actual parameters appear on the stack). Also, because C supports varying parameter lists, it is up to the caller to clean up the parameters on the stack after the return from the function.</p>
<p>The third common calling convention in use on 32-bit Intel machines, <em>STDCALL</em>, is basically a combination of the Pascal and C/C++ calling conventions. Parameters are passed right to left (as in C/C++). However, the callee is responsible for cleaning up the parameters on the stack before returning.</p>
<p>One problem with these three calling conventions is that they all use only memory to pass their parameters to a procedure. Of course, the most efficient place to pass parameters is in machine registers. This led to a fourth common calling convention known as the <em>FASTCALL calling convention</em>. In this<em> </em>convention, the calling program passes parameters in registers to a procedure. However, as registers are a limited resource on most CPUs, the FASTCALL calling convention typically passes only the first three to six parameters in registers. If more parameters are needed, the FASTCALL passes the remaining parameters on the stack (typically in reverse order, like the C/C++ and STDCALL calling conventions).</p>
<h2 id="h1-501089c05-0007">	5.7	The Microsoft ABI and Microsoft Calling Convention</h2>
<p class="BodyFirst">This chapter has repeatedly referred to the Microsoft ABI. Now it’s time to formally describe the Microsoft calling convention.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Remember that adhering to the Microsoft ABI is necessary only if you need to call another function that uses it, or if outside code is calling your function and expects the function to use the Microsoft ABI. If this is not the case, you can use any calling conventions that are convenient for your code.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501089c05-0014">5.7.1	Data Types and the Microsoft ABI</h3>
<p class="BodyFirst">As noted in <span class="xref" itemid="xref_target_“Microsoft ABI Notes” in Chapters 1, 3, and 4">“Microsoft ABI Notes” in Chapters 1, 3, and 4</span>, the native data type sizes are 1, 2, 4, and 8 bytes (see <a href="c01.xhtml#table1-6">Table 1-6</a> in Chapter 1). All such variables should be aligned in memory on their native size.</p>
<p>For parameters, all procedure/function parameters must consume exactly 64 bits. If a data object is smaller than 64 bits, the HO bits of the parameter value (the bits beyond the actual parameter’s native size) are undefined (and not guaranteed to be zero). Procedures should access only the actual data bits for the parameter’s native type and ignore the HO bits.</p>
<p>If a parameter’s native type is larger than 64 bits, the Microsoft ABI requires the caller to pass the parameter by reference rather than by value (that is, the caller must pass the address of the data).</p>
<h3 id="h2-501089c05-0015"><span epub:type="pagebreak" title="264" id="Page_264"/>5.7.2	Parameter Locations</h3>
<p class="BodyFirst">The Microsoft ABI uses a variant of the FASTCALL calling convention that requires the caller to pass the first four parameters in registers. <a href="#table5-2" id="tableanchor5-2">Table 5-2</a> lists the register locations for these parameters.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table5-2">Table 5-2</a>: FASTCALL Parameter Locations</p></figcaption>
<table id="table-501089c05-0002" border="1">
<thead>
<tr>
<td><b>Parameter</b></td>
<td><b>If scalar/reference</b></td>
<td><b>If floating point</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>RCX</td>
<td>XMM0</td>
</tr>
<tr>
<td>2</td>
<td>RDX</td>
<td>XMM1</td>
</tr>
<tr>
<td>3</td>
<td>R8</td>
<td>XMM2</td>
</tr>
<tr>
<td>4</td>
<td>R9</td>
<td>XMM3</td>
</tr>
<tr>
<td>5 to <em>n</em></td>
<td>On stack, right to left</td>
<td>On stack, right to left</td>
</tr>
</tbody>
</table>
</figure>
<p>If the procedure has floating-point parameters, the calling convention skips the use of the general-purpose register for that same parameter location. Say you have the following C/C++ function:</p>
<pre><code>void someFunc(int a, double b, char *c, double d)</code></pre>
<p>Then the Microsoft calling convention would expect the caller to pass <code>a</code> in (the LO 32 bits of) RCX, <code>b</code> in XMM1, a pointer to <code>c</code> in R8, and <code>d</code> in XMM3, skipping RDX, R9, XMM0, and XMM2. This rule has an exception: for vararg (variable number of parameters) or unprototyped functions, floating-point values must be duplicated in the corresponding general-purpose register (see <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/" class="LinkURL">https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/</a>).</p>
<p>Although the Microsoft calling convention passes the first four parameters in registers, it still requires the caller to allocate storage on the stack for these parameters (<em>shadow storage</em>).<sup class="FootnoteReference"><a id="c05-footnoteref-13" href="#c05-footnote-13">13</a></sup> In fact, the Microsoft calling convention requires the caller to allocate storage for four parameters on the stack even if the procedure doesn’t have four parameters (or any parameters at all). The caller doesn’t need to copy the parameter data into this stack storage area—leaving the parameter data only in the registers is sufficient. However, that stack space must be present. Microsoft compilers assume the stack space is there and will use that stack space to save the register values (for example, if the procedure calls another procedure and needs to preserve the registers across that other call). Sometimes Microsoft’s compilers use this shadow storage as local variables.</p>
<p>If you’re calling an external function (such as a C/C++ library function) that adheres to the Microsoft calling convention and you do not allocate the shadow storage, the application will almost certainly crash.</p>
<h3 id="h2-501089c05-0016"><span epub:type="pagebreak" title="265" id="Page_265"/>5.7.3	Volatile and Nonvolatile Registers</h3>
<p class="BodyFirst">As noted way back in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, the Microsoft ABI declares certain registers to be volatile and others to be nonvolatile. <em>Volatile</em> means that a procedure can modify the contents of the register without preserving its value. <em>Nonvolatile</em> means that a procedure must preserve a register’s value if it modifies that value. <a href="#table5-3" id="tableanchor5-3">Table 5-3</a> lists the registers and their volatility.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table5-3">Table 5-3</a>: Register Volatility</p></figcaption>
<table id="table-501089c05-0003" border="1">
<thead>
<tr>
<td><b>Register</b></td>
<td><b>Volatile/nonvolatile</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>RAX</td>
<td>Volatile</td>
</tr>
<tr>
<td>RBX</td>
<td>Nonvolatile</td>
</tr>
<tr>
<td>RCX</td>
<td>Volatile</td>
</tr>
<tr>
<td>RDX</td>
<td>Volatile</td>
</tr>
<tr>
<td>RDI</td>
<td>Nonvolatile</td>
</tr>
<tr>
<td>RSI</td>
<td>Nonvolatile</td>
</tr>
<tr>
<td>RBP</td>
<td>Nonvolatile</td>
</tr>
<tr>
<td>RSP</td>
<td>Nonvolatile</td>
</tr>
<tr>
<td>R8</td>
<td>Volatile</td>
</tr>
<tr>
<td>R9</td>
<td>Volatile</td>
</tr>
<tr>
<td>R10</td>
<td>Volatile</td>
</tr>
<tr>
<td>R11</td>
<td>Volatile</td>
</tr>
<tr>
<td>R12</td>
<td>Nonvolatile</td>
</tr>
<tr>
<td>R13</td>
<td>Nonvolatile</td>
</tr>
<tr>
<td>R14</td>
<td>Nonvolatile</td>
</tr>
<tr>
<td>R15</td>
<td>Nonvolatile</td>
</tr>
<tr>
<td>XMM0/YMM0</td>
<td>Volatile</td>
</tr>
<tr>
<td>XMM1/YMM1</td>
<td>Volatile</td>
</tr>
<tr>
<td>XMM2/YMM2</td>
<td>Volatile</td>
</tr>
<tr>
<td>XMM3/YMM3</td>
<td>Volatile</td>
</tr>
<tr>
<td>XMM4/YMM4</td>
<td>Volatile</td>
</tr>
<tr>
<td>XMM5/YMM5</td>
<td>Volatile</td>
</tr>
<tr>
<td>XMM6/YMM6</td>
<td>XMM6 Nonvolatile, upper half of YMM6 volatile</td>
</tr>
<tr>
<td>XMM7/YMM7</td>
<td>XMM7 Nonvolatile, upper half of YMM7 volatile</td>
</tr>
<tr>
<td>XMM8/YMM8</td>
<td>XMM8 Nonvolatile, upper half of YMM8 volatile</td>
</tr>
<tr>
<td>XMM9/YMM9</td>
<td>XMM9 Nonvolatile, upper half of YMM9 volatile</td>
</tr>
<tr>
<td>XMM10/YMM10</td>
<td>XMM10 Nonvolatile, upper half of YMM10 volatile</td>
</tr>
<tr>
<td>XMM11/YMM11</td>
<td>XMM11 Nonvolatile, upper half of YMM11 volatile</td>
</tr>
<tr>
<td><span epub:type="pagebreak" title="266" id="Page_266"/>XMM12/YMM12</td>
<td>XMM12 Nonvolatile, upper half of YMM12 volatile</td>
</tr>
<tr>
<td>XMM13/YMM13</td>
<td>XMM13 Nonvolatile, upper half of YMM13 volatile</td>
</tr>
<tr>
<td>XMM14/YMM14</td>
<td>XMM14 Nonvolatile, upper half of YMM14 volatile</td>
</tr>
<tr>
<td>XMM15/YMM15</td>
<td>XMM15 Nonvolatile, upper half of YMM15 volatile</td>
</tr>
<tr>
<td>FPU</td>
<td>Volatile, but FPU stack must be empty upon return</td>
</tr>
<tr>
<td>Direction flag</td>
<td>Must be cleared upon return</td>
</tr>
</tbody>
</table>
</figure>
<p>It is perfectly reasonable to use nonvolatile registers within a procedure. However, you must preserve those register values so that they are unchanged upon return from a function. If you’re not using the shadow storage for anything else, this is a good place to save and restore nonvolatile register values during a procedure call; for example:</p>
<pre><code>someProc  proc
          push  rbp
          mov   rbp, rsp
          mov   [rbp+16], rbx    ; Save RBX in parm 1's shadow
           .
           .  ; Procedure's code
           .
          mov    rbx, [rbp+16]   ; Restore RBX from shadow
          leave
          ret
someProc  endp</code></pre>
<p>Of course, if you’re using the shadow storage for another purpose, you can always save nonvolatile register values in local variables or can even push and pop the register values:</p>
<pre><code>someProc  proc        ; Save RBX via push
          push  rbx   ; Note that this affects parm offsets
          push  rbp
          mov   rbp, rsp
           .
           .  ; Procedure's code
           .
          leave
          pop   rbx   ; Restore RBX from stack
          ret
someProc  endp

someProc2 proc        ; Save RBX in a local
          push  rbp
          mov   rbp, rsp
          sub   rsp, 16       ; Keep stack aligned
          mov   [rbp-8], rbx  ; Save RBX
           .
           .  ; Procedure's code
           .
<span epub:type="pagebreak" title="267" id="Page_267"/>          mov   rbx, [rbp-8]  ; Restore RBX
          leave
          ret
someProc2 endp</code></pre>
<h3 id="h2-501089c05-0017">5.7.4	Stack Alignment</h3>
<p class="BodyFirst">As I’ve mentioned many times now, the Microsoft ABI requires the stack to be aligned on a 16-byte boundary whenever you make a call to a procedure. When Windows transfers control to your assembly code (or when another Windows ABI–compliant code calls your assembly code), you’re guaranteed that the stack will be aligned on an 8-byte boundary that is not also a 16-byte boundary (because the return address consumed 8 bytes after the stack was 16-byte-aligned). If, within your assembly code, you don’t care about 16-byte alignment, you can do anything you like with the stack (however, you should keep it aligned on at least an 8-byte boundary).</p>
<p>On the other hand, if you ever plan on calling code that uses the Microsoft calling conventions, you need to be able to ensure that the stack is properly aligned before the call. There are two ways to do this: carefully manage any modifications to the RSP register after entry into your code (so you know the stack is 16-byte-aligned whenever you make a call), or force the stack to an appropriate alignment prior to making a call. Forcing alignment to 16 bytes is easily achieved using this instruction:</p>
<pre><code>and rsp, -16</code></pre>
<p>However, you must execute this instruction <em>before</em> setting up parameters for a call. If you execute this instruction immediately before a call instruction (but after placing all the parameters on the stack), this could shift RSP down in memory, and then the parameters will not be at the expected offset upon entry into the procedure.</p>
<p>Suppose you don’t know the state of RSP and need to make a call to a procedure that expects five parameters (40 bytes, which is not a multiple of 16 bytes). Here’s a typical calling sequence you would use:</p>
<pre><code>  sub rsp, 40  ; Make room for 4 shadow parms plus a 5th parm
  and rsp, -16 ; Guarantee RSP is now 16-byte-aligned

; Code to move four parameters into registers and the
; 5th parameter to location [RSP+32]:

  mov rcx, parm1
  mov rdx, parm2
  mov r8,  parm3
  mov r9,  parm4
  mov rax, parm5
  mov [rsp+32], rax
  call procWith5Parms</code></pre>
<p>The only problem with this code is that it is hard to clean up the stack upon return (because you don’t know exactly how many bytes you reserved <span epub:type="pagebreak" title="268" id="Page_268"/>on the stack as a result of the <code>and</code> instruction). However, as you’ll see in the next section, you’ll rarely clean up the stack after an individual procedure call, so you don’t have to worry about the stack cleanup here.</p>
<h3 id="h2-501089c05-0018">5.7.5	Parameter Setup and Cleanup (or “What’s with These Magic Instructions?”)</h3>
<p class="BodyFirst">The Microsoft ABI requires the caller to set up the parameters and then clean them up (remove them from the stack) upon return from the function. In theory, this means that a call to a Microsoft ABI–compliant function is going to look something like the following:</p>
<pre><code>; Make room for parameters. <var>parm_size</var> is a constant
; with the number of bytes of parameters required
; (including 32 bytes for the shadow parameters).

  sub rsp, <var>parm_size</var>

  <var>Code that copies parameters to the stack</var>

  call procedure

; Clean up the stack after the call:

  add rsp, <var>parm_size</var></code></pre>
<p>This allocation and cleanup sequence has two problems. First, you have to repeat the sequence (<code>sub rsp</code><var>, parm_size</var> and <code>add rsp, </code><var>parm_size</var>) for every call in your program (which can be rather inefficient). Second, as you saw in the preceding section, sometimes aligning the stack to a 16-byte boundary forces you to adjust the stack downward by an unknown amount, so you don’t know how many bytes to add to RSP in order to clean up the stack.</p>
<p>If you have several calls sprinkled through a given procedure, you can optimize the process of allocating and deallocating parameters on the stack by doing this operation just once. To understand how this works, consider the following code sequence:</p>
<pre><code>; 1st procedure call:

  sub rsp, <var>parm_size</var>   ; Allocate storage for proc1 parms
  <var>Code that copies parameters to the registers and stack</var>
  call proc1
  add  rsp, <var>parm_size</var>  ; Clean up the stack

; 2nd procedure call:

  sub rsp, <var>parm_size2</var>  ; Allocate storage for proc2 parms
  <var>Code that copies parameters to the registers and stack</var>
  call proc2
  add rsp, <var>parm_size2</var>  ; Clean up the stack</code></pre>
<p>If you study this code, you should be able to convince yourself that the first <code>add</code> and second <code>sub</code> are somewhat redundant. If you were to modify the first <code>sub</code> <span epub:type="pagebreak" title="269" id="Page_269"/>instruction to reduce the stack size by the greater of <var>parm_size</var> and <var>parm_size2</var>, and replace the final <code>add</code> instruction with this same value, you could eliminate the <code>add</code> and <code>sub</code> instructions appearing between the two calls:</p>
<pre><code>; 1st procedure call:

  sub rsp, <var>max_parm_size</var>   ; Allocate storage for all parms
  <var>Code that copies parameters to the registers and stack for proc1</var>
  call proc1

  <var>Code that copies parameters to the registers and stack for proc2</var>
  call proc2
  add rsp, <var>max_parm_size</var>   ; Clean up the stack</code></pre>
<p>If you determine the maximum number of bytes of parameters needed by all calls within your procedure, you can eliminate all the individual stack allocations and cleanups throughout the procedure (don’t forget, the minimum parameter size is 32 bytes, even if the procedure has no parameters at all, because of the shadow storage requirements).</p>
<p>It gets even better, though. If your procedure has local variables, you can combine the <code>sub</code> instruction that allocates local variables with the one that allocates storage for your parameters. Similarly, if you’re using the standard entry/exit sequence, the <code>leave</code> instruction at the end of your procedure will automatically deallocate all the parameters (as well as the local variables) when you exit your procedure.</p>
<p>Throughout this book, you’ve seen lots of “magic” add and subtract instructions that have been offered without much in the way of explanation. Now you know what those instructions have been doing: they’ve been allocating storage for local variables and all the parameter space for the procedures being called as well as keeping the stack 16-byte-aligned. </p>
<p>Here’s one last example of a procedure that uses the standard entry/exit procedure to set up locals and parameter space:</p>
<pre><code>rbxSave  equ   [rbp-8]
someProc proc
         push  rbp
         mov   rbp, rsp
         sub   rsp, 48       ; Also leave stack 16-byte-aligned
         mov   rbxSave, rbx  ; Preserve RBX
          .
          .
          .
         lea   rcx, fmtStr
         mov   rdx, rbx      ; Print value in RBX (presumably)
         call  printf
          .
          .
          .
         mov   rbx, rbxSave  ; Restore RBX
         leave               ; Clean up stack
         ret
someProc endp</code></pre>
<p><span epub:type="pagebreak" title="270" id="Page_270"/>However, if you use this trick to allocate storage for your procedures’ parameters, you will not be able to use the <code>push</code> instructions to move the data onto the stack. The storage has already been allocated on the stack for the parameters; you must use <code>mov</code> instructions to copy the data onto the stack (using the <code>[RSP+</code><var>constant</var><code>]</code> addressing mode) when copying the fifth and greater parameters.</p>
<h2 id="h1-501089c05-0008">	5.8	Functions and Function Results</h2>
<p class="BodyFirst"><em>Functions</em> are procedures that return a result to the caller. In assembly language, few syntactical differences exist between a procedure and a function, which is why MASM doesn’t provide a specific declaration for a function. Nevertheless, there are some semantic differences; although you can declare them the same way in MASM, you use them differently.</p>
<p><em>Procedures</em> are a sequence of machine instructions that fulfill a task. The result of the execution of a procedure is the accomplishment of that activity. Functions, on the other hand, execute a sequence of machine instructions specifically to compute a value to return to the caller. Of course, a function can perform an activity as well, and procedures can undoubtedly compute values, but the main difference is that the purpose of a function is to return a computed result; procedures don’t have this requirement.</p>
<p>In assembly language, you don’t specifically define a function by using special syntax. To MASM, everything is a <code>proc</code>. A section of code becomes a function by virtue of the fact that the programmer explicitly decides to return a function result somewhere (typically in a register) via the procedure’s execution.</p>
<p>The x86-64’s registers are the most common place to return function results. The <code>strlen()</code> routine in the C Standard Library is a good example of a function that returns a value in one of the CPU’s registers. It returns the length of the string (whose address you pass as a parameter) in the RAX register.</p>
<p>By convention, programmers try to return 8-, 16-, 32-, and 64-bit (nonreal) results in the AL, AX, EAX, and RAX registers, respectively. This is where most high-level languages return these types of results, and it’s where the Microsoft ABI states that you should return function results. The exception is floating-point values. The Microsoft ABI states that you should return floating-point values in the XMM0 register.</p>
<p>Of course, there is nothing particularly sacred about the AL, AX, EAX, and RAX registers. You could return function results in any register if it is more convenient to do so. Of course, if you’re calling a Microsoft ABI–compliant function (such as <code>strlen()</code>), you have no choice but to expect the function’s return result in the RAX register (<code>strlen()</code> returns a 64-bit integer in RAX, for example).</p>
<p>If you need to return a function result that is larger than 64 bits, you obviously must return it somewhere other than in RAX (which can hold only 64-bit values). For values slightly larger than 64 bits (for example, 128 bits or maybe even as many as 256 bits), you can split the result into pieces and return those parts in two or more registers. It is common to <span epub:type="pagebreak" title="271" id="Page_271"/>see functions returning 128-bit values in the RDX:RAX register pair. Of course, the XMM/YMM registers are another good place to return large values. Just remember that these schemes are not Microsoft ABI–compliant, so they’re practical only when calling code you’ve written.</p>
<p>If you need to return a large object as a function result (say, an array of 1000 elements), you obviously are not going to be able to return the function result in the registers. You can deal with large function return results in two common ways: either pass the return value as a reference parameter or allocate storage on the heap (for example, using the C Standard Library <code>malloc()</code> function) for the object and return a pointer to it in a 64-bit register. Of course, if you return a pointer to storage you’ve allocated on the heap, the calling program must free this storage when it has finished with it.</p>
<h2 id="h1-501089c05-0009">	5.9	Recursion</h2>
<p class="BodyFirst"><em>Recursion</em> occurs when a procedure calls itself. The following, for example, is a recursive procedure:</p>
<pre><code>Recursive proc

          call Recursive
          ret

Recursive endp</code></pre>
<p>Of course, the CPU will never return from this procedure. Upon entry into <code>Recursive</code>, this procedure will immediately call itself again, and control will never pass to the end of the procedure. In this particular case, runaway recursion results in an infinite loop.<sup class="FootnoteReference"><a id="c05-footnoteref-14" href="#c05-footnote-14">14</a></sup></p>
<p>Like a looping structure, recursion requires a termination condition in order to stop infinite recursion. <code>Recursive</code> could be rewritten with a termination condition as follows:</p>
<pre><code>Recursive proc

          dec  eax
          jz   allDone
          call Recursive
allDone:
          ret

Recursive endp</code></pre>
<p>This modification to the routine causes <code>Recursive</code> to call itself the number of times appearing in the EAX register. On each call, <code>Recursive</code> decrements the EAX register by 1 and then calls itself again. Eventually, <code>Recursive</code> decrements EAX to 0 and returns from each call until it returns to the original caller.</p>
<p><span epub:type="pagebreak" title="272" id="Page_272"/>So far, however, there hasn’t been a real need for recursion. After all, you could efficiently code this procedure as follows:</p>
<pre><code>Recursive proc
iterLp:
          dec  eax
          jnz  iterLp
          ret
Recursive endp</code></pre>
<p>Both examples would repeat the body of the procedure the number of times passed in the EAX register.<sup class="FootnoteReference"><a id="c05-footnoteref-15" href="#c05-footnote-15">15</a></sup> As it turns out, there are only a few recursive algorithms that you cannot implement in an iterative fashion. However, many recursively implemented algorithms are more efficient than their iterative counterparts, and most of the time the recursive form of the algorithm is much easier to understand.</p>
<p>The <em>quicksort algorithm</em> is probably the most famous algorithm that usually appears in recursive form. A MASM implementation of this algorithm appears in <a href="#listing5-15" id="listinganchor5-15">Listing 5-15</a>.</p>
<pre><code>; Listing 5-15
 
; Recursive quicksort.

        option  casemap:none

nl          =       10
numElements =       10

            .const
ttlStr      byte    "Listing 5-15", 0
fmtStr1     byte    "Data before sorting: ", nl, 0
fmtStr2     byte    "%d "   ; Use nl and 0 from fmtStr3
fmtStr3     byte    nl, 0
fmtStr4     byte    "Data after sorting: ", nl, 0

            .data
theArray    dword   1,10,2,9,3,8,4,7,5,6

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

<span epub:type="pagebreak" title="273" id="Page_273"/>; quicksort - Sorts an array using the
;             quicksort algorithm.
 
; Here's the algorithm in C, so you can follow along:
 
  void quicksort(int a[], int low, int high)
  {
      int i,j,Middle;
      if(low &lt; high)
      {
          Middle = a[(low+high)/2];
          i = low;
          j = high;
          do
          {
              while(a[i] &lt;= Middle) i++;
              while(a[j] &gt; Middle) j--;
              if(i &lt;= j)
              {
                  swap(a[i],a[j]);
                  i++;
                  j--;
              }
          } while(i &lt;= j);
   
          // Recursively sort the two subarrays.
 
          if(low &lt; j) quicksort(a,low,j-1);
          if(i &lt; high) quicksort(a,j+1,high);
      }
  }
 
; Args:
    ; RCX (_a):      Pointer to array to sort
    ; RDX (_lowBnd): Index to low bound of array to sort
    ; R8 (_highBnd): Index to high bound of array to sort

_a          equ     [rbp+16]        ; Ptr to array
_lowBnd     equ     [rbp+24]        ; Low bounds of array
_highBnd    equ     [rbp+32]        ; High bounds of array

; Local variables (register save area):

saveR9      equ     [rbp+40]        ; Shadow storage for R9
saveRDI     equ     [rbp-8]
saveRSI     equ     [rbp-16]
saveRBX     equ     [rbp-24]
saveRAX     equ     [rbp-32]

; Within the procedure body, these registers
; have the following meaning:
 
; RCX: Pointer to base address of array to sort.
; EDX: Lower bound of array (32-bit index).
; R8D: Higher bound of array (32-bit index).
 
<span epub:type="pagebreak" title="274" id="Page_274"/>; EDI: index (i) into array.
; ESI: index (j) into array.
; R9D: Middle element to compare against.

quicksort   proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 32

; This code doesn't mess with RCX. No
; need to save it. When it does mess
; with RDX and R8, it saves those registers
; at that point.

; Preserve other registers we use:

            mov     saveRAX, rax
            mov     saveRBX, rbx
            mov     saveRSI, rsi
            mov     saveRDI, rdi
            mov     saveR9, r9

            mov     edi, edx          ; i = low
            mov     esi, r8d          ; j = high

; Compute a pivotal element by selecting the
; physical middle element of the array.

            lea     rax, [rsi+rdi*1]  ; RAX = i+j
            shr     rax, 1            ; (i + j)/2
            mov     r9d, [rcx][rax*4] ; Middle = ary[(i + j)/2]

; Repeat until the EDI and ESI indexes cross one
; another (EDI works from the start toward the end
; of the array, ESI works from the end toward the
; start of the array).

rptUntil:
        
; Scan from the start of the array forward
; looking for the first element greater or equal
; to the middle element):

            dec     edi     ; To counteract inc, below
while1:     inc     edi     ; i = i + 1
            cmp     r9d, [rcx][rdi*4] ; While Middle &gt; ary[i]
            jg      while1

; Scan from the end of the array backward, looking
; for the first element that is less than or equal
; to the middle element.

            inc     esi     ; To counteract dec, below
while2:     dec     esi     ; j = j - 1
<span epub:type="pagebreak" title="275" id="Page_275"/>            cmp     r9d, [rcx][rsi*4] ; While Middle &lt; ary[j]
            jl      while2 

; If we've stopped before the two pointers have
; passed over one another, then we've got two
; elements that are out of order with respect
; to the middle element, so swap these two elements.

            cmp     edi, esi  ; If i &lt;= j
            jnle    endif1

            mov     eax, [rcx][rdi*4] ; Swap ary[i] and ary[j]
            mov     r9d, [rcx][rsi*4]
            mov     [rcx][rsi*4], eax
            mov     [rcx][rdi*4], r9d

            inc     edi       ; i = i + 1
            dec     esi       ; j = j - 1

endif1:     cmp     edi, esi  ; Until i &gt; j
            jng     rptUntil

; We have just placed all elements in the array in
; their correct positions with respect to the middle
; element of the array. So all elements at indexes
; greater than the middle element are also numerically
; greater than this element. Likewise, elements at
; indexes less than the middle (pivotal) element are
; now less than that element. Unfortunately, the
; two halves of the array on either side of the pivotal
; element are not yet sorted. Call quicksort recursively
; to sort these two halves if they have more than one
; element in them (if they have zero or one elements, then
; they are already sorted).

            cmp     edx, esi  ; If lowBnd &lt; j
            jnl     endif2

            ; Note: a is still in RCX,
            ; low is still in RDX.
            ; Need to preserve R8 (high).
            ; Note: quicksort doesn't require stack alignment.

            push    r8
            mov     r8d, esi
            call    quicksort ; (a, low, j)
            pop     r8

endif2:     cmp     edi, r8d  ; If i &lt; high
            jnl     endif3

            ; Note: a is still in RCX,
            ; High is still in R8D.
            ; Need to preserve RDX (low).
            ; Note: quicksort doesn't require stack alignment.

<span epub:type="pagebreak" title="276" id="Page_276"/>            push    rdx
            mov     edx, edi
            call    quicksort ; (a, i, high)
            pop     rdx

; Restore registers and leave:

endif3:
            mov     rax, saveRAX
            mov     rbx, saveRBX
            mov     rsi, saveRSI
            mov     rdi, saveRDI
            mov     r9, saveR9
            leave
            ret
quicksort   endp

; Little utility to print the array elements:

printArray  proc
            push    r15
            push    rbp
            mov     rbp, rsp
            sub     rsp, 40   ; Shadow parameters

            lea     r9, theArray
            mov     r15d, 0
whileLT10:  cmp     r15d, numElements
            jnl     endwhile1

            lea     rcx, fmtStr2
            lea     r9, theArray
            mov     edx, [r9][r15*4]
            call    printf

            inc     r15d
            jmp     whileLT10

endwhile1:  lea     rcx, fmtStr3
            call    printf
            leave
            pop     r15
            ret
printArray  endp

; Here is the "asmMain" function.
        
            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 32   ; Shadow storage

<span epub:type="pagebreak" title="277" id="Page_277"/>; Display unsorted array:

            lea     rcx, fmtStr1
            call    printf
            call    printArray

; Sort the array:

            lea     rcx, theArray
            xor     rdx, rdx                ; low = 0
            mov     r8d, numElements-1      ; high = 9
            call    quicksort               ; (theArray, 0, 9)

; Display sorted results:

            lea     rcx, fmtStr4
            call    printf
            call    printArray

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing5-15">Listing 5-15</a>: Recursive quicksort program</p>
<p>Here is the build command and sample output for the quicksort program:</p>
<pre><code>C:\&gt;<b>build listing5-15</b>

C:\&gt;<b>echo off</b>
 Assembling: listing5-15.asm
c.cpp

C:\&gt;<b>listing5-15</b>
Calling Listing 5-15:
Data before sorting:
1
10
2
9
3
8
4
7
5
6

Data after sorting:
1
2
3
<span epub:type="pagebreak" title="278" id="Page_278"/>4
5
6
7
8
9
10

Listing 5-15 terminated</code></pre>
<p>Note that this quicksort procedure uses registers for all local variables. The quicksort function is a <em>leaf function</em>; it doesn’t call any other functions. Therefore, it doesn’t need to align the stack on a 16-byte boundary. Also, as is a good idea for any pure-assembly procedure (that will be called only by other assembly language procedures), this quicksort procedure preserves all the registers whose values it modifies (even the volatile registers). That’s just good programming practice even if it is a little less efficient.</p>
<h2 id="h1-501089c05-0010">	5.10	Procedure Pointers</h2>
<p class="BodyFirst">The x86-64 call instruction allows three basic forms: PC-relative calls (via a procedure name), indirect calls through a 64-bit general-purpose register, and indirect calls through a quad-word pointer variable. The <code>call</code> instruction supports the following (low-level) syntax:</p>
<pre><code>call <var>proc_name</var>  ; Direct call to procedure <var>proc_name</var>
call reg64      ; Indirect call to procedure whose address
                ; appears in the reg<sub>64</sub>
call qwordVar   ; Indirect call to the procedure whose address
                ; appears in the qwordVar quad-word variable</code></pre>
<p>We’ve been using the first form throughout this book, so there is little need to discuss it here. The second form, the register indirect call, calls the procedure whose address is held in the specified 64-bit register. The address of a procedure is the byte address of the first instruction to execute within that procedure. On a von Neumann architecture machine (like the x86-64), the system stores machine instructions in memory along with other data. The CPU fetches the instruction opcode values from memory prior to executing them. When you execute the register indirect <code>call</code> instruction, the x86-64 first pushes the return address onto the stack and then begins fetching the next opcode byte (instruction) from the address specified by the register’s value.</p>
<p>The third form of the preceding <code>call</code> instruction fetches the address of a procedure’s first instruction from a quad-word variable in memory. Although this instruction suggests that the call uses the direct addressing of the procedure, you should realize that any legal memory addressing mode is also legal here. For example, <code>call procPtrTable[rbx*8]</code> is perfectly legitimate; this statement fetches the quad word from the array of quad words (<code>procPtrTable</code>) and calls the procedure whose address is the value contained within that quad word.</p>
<p><span epub:type="pagebreak" title="279" id="Page_279"/>MASM treats procedure names like static objects. Therefore, you can compute the address of a procedure by using the <code>offset</code> operator along with the procedure’s name or by using the <code>lea</code> instruction. For example, <code>offset </code><var>proc_name</var> is the address of the very first instruction of the <var>proc_name</var> procedure. So, all three of the following code sequences wind up calling the <var>proc_name</var> procedure:</p>
<pre><code>call <var>proc_name</var>
 .
 .
 .
mov  rax, offset <var>proc_name</var>
call rax
 .
 .
 .
lea   rax, <var>proc_name</var>
call  rax</code></pre>
<p>Because the address of a procedure fits in a 64-bit object, you can store such an address into a quad-word variable; in fact, you can initialize a quad-word variable with the address of a procedure by using code like the following:</p>
<pre><code>p     proc
        .
        .
        .
p     endp
        .
        .
        .
       .data
ptrToP qword   offset p
        .
        .
        .
     call ptrToP ; Calls p if ptrToP has not changed</code></pre>
<p>As with all pointer objects, you should not attempt to indirectly call a procedure through a pointer variable unless you’ve initialized that variable with an appropriate address. You can initialize a procedure pointer variable in two ways: <code>.data</code> and <code>.const</code> objects allow an initializer, or you can compute the address of a routine (as a 64-bit value) and store that 64-bit address directly into the procedure pointer at runtime. The following code fragment demonstrates both ways to initialize a procedure pointer:</p>
<pre><code>             .data
ProcPointer  qword  offset p   ; Initialize ProcPointer with 
                               ; the address of p
              .
              .
              .
             call ProcPointer  ; First invocation calls p

<span epub:type="pagebreak" title="280" id="Page_280"/>; Reload ProcPointer with the address of q.

             lea   rax, q
             mov  ProcPointer, rax
              .
              .
              .
             call  ProcPointer ; This invocation calls q</code></pre>
<p>Although all the examples in this section use static variable declarations (<code>.data</code>, <code>.const</code>, <code>.data?</code>), don’t think you can declare simple procedure pointers only in the static variable declaration sections. You can also declare procedure pointers (which are just qword variables) as local variables, pass them as parameters, or declare them as fields of a record or a union.</p>
<h2 id="h1-501089c05-0011">	5.11	Procedural Parameters</h2>
<p class="BodyFirst">One place where procedure pointers are quite invaluable is in parameter lists. Selecting one of several procedures to call by passing the address of a procedure is a common operation. Of course, a <em>procedural parameter</em> is just a quad-word parameter containing the address of a procedure, so this is really no different from using a local variable to hold a procedure pointer (except, of course, that the caller initializes the parameter with the address of the procedure to call indirectly).</p>
<p>When using parameter lists with the MASM <code>proc</code> directive, you can specify a procedure pointer type by using the <code>proc</code> type specifier; for example:</p>
<pre><code>procWithProcParm proc  parm1:word, procParm:proc</code></pre>
<p>You can call the procedure pointed at by this parameter by using the following call instruction:</p>
<pre><code>call procParm</code></pre>
<h2 id="h1-501089c05-0012">	5.12	Saving the State of the Machine, Part II</h2>
<p class="BodyFirst"><span class="xref" itemid="xref_target_“Saving the State of the Machine” on page 220">“Saving the State of the Machine” on page 220</span><span class="xref" itemid="xref_target_"/> described the use of the <code>push</code> and <code>pop</code> instructions to save the state of the registers across a procedure call (callee register preservation). While this is certainly one way to preserve registers across a procedure call, it certainly isn’t the only way, nor is it always (or even usually) the best way to save and restore registers.</p>
<p>The <code>push</code> and <code>pop</code> instructions have a couple of major benefits: they are short (pushing or popping a 64-bit register uses a 1-byte instruction opcode), and they work with constant and memory operands. These instructions do have drawbacks, however: they modify the stack pointer, they work with only 2- or 8-byte registers, they work only with the general-purpose integer registers (and the FLAGS register), and they might be slower than an equivalent instruction that moves the register data onto the stack. Often, a better <span epub:type="pagebreak" title="281" id="Page_281"/>solution is to reserve storage in the local variable space and simply move the registers to/from those local variables on the stack.</p>
<p>Consider the following procedure declaration that preserves registers by using <code>push</code> and <code>pop</code> instructions:</p>
<pre><code>preserveRegs proc
             push   rax
             push   rbx
             push   rcx
               .
               .
               .
             pop    rcx
             pop    rbx
             pop    rax
             ret
preserveRegs endp</code></pre>
<p>You can achieve the same thing with the following code:</p>
<pre><code>preserveRegs proc
saveRAX      textequ &lt;[rsp+16]&gt;
saveRBX      textequ &lt;[rsp+8]&gt;
saveRCX      textequ &lt;[rsp]&gt;

             sub     rsp, 24      ; Make room for locals
             mov     saveRAX, rax
             mov     saveRBX, rbx
             mov     saveRCX, rcx
               .
               .
               .
             mov     rcx, saveRCX
             mov     rbx, saveRBX
             mov     rax, saveRAX
             add     rsp, 24      ; Deallocate locals
             ret
preserveRegs endp</code></pre>
<p>The disadvantage to this code is that two extra instructions are needed to allocate (and deallocate) storage on the stack for the local variables that hold the register values. The <code>push</code> and <code>pop</code> instructions automatically allocate this storage, sparing you from having to supply these extra instructions. For a simple situation such as this, the <code>push</code> and <code>pop</code> instructions probably are the better solution.</p>
<p>For more complex procedures, especially those that expect parameters on the stack or have local variables, the procedure is already setting up the activation record, and subtracting a larger number from RSP doesn’t require any additional instructions:</p>
<pre><code>             option  prologue:PrologueDef
             option  epilogue:EpilogueDef
preserveRegs proc    parm1:byte, parm2:dword
<span epub:type="pagebreak" title="282" id="Page_282"/>             local   localVar1:dword, localVar2:qword
             local   saveRAX:qword, saveRBX:qword
             local   saveRCX:qword

             mov     saveRAX, rax
             mov     saveRBX, rbx
             mov     saveRCX, rcx
               .
               .
               .
             mov     rcx, saveRCX
             mov     rbx, saveRBX
             mov     rax, saveRAX
             ret
preserveRegs endp</code></pre>
<p>MASM automatically generates the code to allocate the storage for <code>saveRAX</code>, <code>saveRBX</code>, and <code>saveRCX</code> (along with all the other local variables) on the stack, as well as clean up the local storage on return.</p>
<p>When allocating local variables on the stack along with storage for any parameters a procedure might pass to functions it calls, pushing and popping registers to preserve them becomes problematic. For example, consider the following procedure:</p>
<pre><code>callsFuncs   proc
saveRAX      textequ &lt;[rbp-8]&gt;
saveRBX      textequ &lt;[rbp-16]&gt;
saveRCX      textequ &lt;[rbp-24]&gt;
             push    rbp
             mov     rbp, rsp
             sub     rsp, 48      ; Make room for locals and parms
             mov     saveRAX, rax ; Preserve registers in
             mov     saveRBX, rbx ; local variables
             mov     saveRCX, rcx

               .
               .
               .
             mov    [rsp], rax    ; Store parm1
             mov    [rsp+8], rbx  ; Store parm2
             mov    [rsp+16], rcx ; Store parm3
             call   theFunction
               .
               .
               .
             mov     rcx, saveRCX ; Restore registers
             mov     rbx, saveRBX
             mov     rax, saveRAX
             leave                ; Deallocate locals
             ret
callsFuncs   endp</code></pre>
<p><span epub:type="pagebreak" title="283" id="Page_283"/>Had this function pushed RAX, RBX, and RCX on the stack after subtracting 48 from RSP, those save registers would have wound up on the stack where the function passes <code>parm1</code>, <code>parm2</code>, and <code>parm3</code> to <code>theFunction</code>. That’s why the <code>push</code> and <code>pop</code> instructions don’t work well when working with functions that build an activation record containing local storage.</p>
<h2 id="h1-501089c05-0013">	5.13	Microsoft ABI Notes</h2>
<p class="BodyFirst">This chapter has all but completed the discussion of the Microsoft calling conventions. Specifically, a Microsoft ABI–compliant function must follow these rules:</p>
<ul>
<li>(Scalar) parameters must be passed in RCX, RDX, R8, and R9, then pushed on the stack. Floating-point parameters substitute XMM0, XMM1, XMM2, and XMM3 for RCX, RDX, R8, and R9, respectively.</li>
<li>Varargs functions (functions with a variable number of parameters, such as <code>printf()</code>) and unprototyped functions must pass floating-point values in both the general-purpose (integer) registers and in the XMM registers. (For what it’s worth, <code>printf()</code> seems to be happy with just passing the floating-point values in the integer registers, though that might be a happy accident with the version of MSVC used in the preparation of this book.)</li>
<li>All parameters must be less than or equal to 64 bits in size; larger parameters must be passed by reference.</li>
<li>On the stack, parameters always consume 64 bits (8 bytes) regardless of their actual size; the HO bits of smaller objects are undefined.</li>
<li>Immediately before a <code>call</code> instruction, the stack must be aligned on a 16-byte boundary.</li>
<li>Registers RAX, RCX, RDX, R8, R9, R10, R11, and XMM0/YMM0 to XMM5/YMM5 are volatile. The caller must preserve the registers across a call if it needs their values to be saved across the call. Also note that the HO 128 bits of YMM0 to YMM15 are volatile, and the caller must preserve these registers if it needs these bits to be preserved across a call.</li>
<li>Registers RBX, RSI, RDI, RBP, RSP, R12 to R15, and XMM6 to XMM15 are nonvolatile. The callee must preserve these registers if it changes their values. As noted earlier, while YMM0L to YMM15L (the LO 128 bits) are nonvolatile, the upper 128 bits of these registers can be considered volatile. However, if a procedure is saving the LO 128 bits of YMM0 to YMM15, it may as well preserve all the bits (this inconsistency in the Microsoft ABI is to support legacy code running on CPUs that don’t support the YMM registers).</li>
<li>Scalar function returns (64 bits or fewer) come back in the RAX register. If the data type is smaller than 64 bits, the HO bits of RAX are undefined.</li>
<li><span epub:type="pagebreak" title="284" id="Page_284"/>Functions that return values larger than 64 bits must allocate storage for the return value and pass the address of that storage in the first parameter (RCX) to the function. On return, the function must return this pointer in the RAX register.</li>
<li>Functions return floating-point results (double or single) in the XMM0 register.</li>
</ul>
<h2 id="h1-501089c05-0014">	5.14	For More Information</h2>
<p class="BodyFirst">The electronic edition of the 32-bit edition this book (found at <a href="https://artofasm.randallhyde.com/" class="LinkURL">https://artofasm.randallhyde.com/</a>)<em> </em>contains a whole “volume” on advanced and intermediate procedures. Though that book covers 32-bit assembly language programming, the concepts apply directly to 64-bit assembly by simply using 64-bit addresses rather than 32-bit addresses.</p>
<p>While the information appearing in this chapter covers 99 percent of the material that assembly programmers typically use, there is additional information on procedures and parameters that you may find interesting. In particular, the electronic edition covers additional parameter-passing mechanisms (pass by value/result, pass by result, pass by name, and pass by lazy evaluation) and goes into greater detail about the places you can pass parameters. The electronic version also covers iterators, thunks, and other advanced procedure types. Finally, a good compiler construction textbook will cover additional details about runtime support for procedures.</p>
<p>For more information on the Microsoft ABI, search for <em>Microsoft calling conventions</em> on the Microsoft website (or on the internet).</p>
<h2 id="h1-501089c05-0015">	5.15	Test Yourself</h2>
<ol class="decimal">
<li value="1">Explain, step by step, how the <code>call</code> instruction works.</li>
<li value="2">Explain, step by step, how the <code>ret</code> instruction works.</li>
<li value="3">What does the <code>ret</code> instruction, with a numeric constant operand, do?</li>
<li value="4">What value is pushed on the stack for a return address?</li>
<li value="5">What is namespace pollution?</li>
<li value="6">How do you define a single global symbol in a procedure?</li>
<li value="7">How would you make all symbols in a procedure non-scoped (that is, all the symbols in a procedure would be global)?</li>
<li value="8">Explain how to use the <code>push</code> and <code>pop</code> instructions to preserve registers in a function.</li>
<li value="9">What is the main disadvantage of caller preservation?</li>
<li value="10">What is the main problem with callee preservation?</li>
<li value="11">What happens if you fail to pop a value in a function that you pushed on the stack at the beginning of the function?</li>
<li value="12"><span epub:type="pagebreak" title="285" id="Page_285"/>What happens if you pop extra data off the stack in a function (data that you did not push on the stack in the function)?</li>
<li value="13">What is an activation record?</li>
<li value="14">What register usually points at an activation record, providing access to the data in that record?</li>
<li value="15">How many bytes are reserved for a typical parameter on the stack when using the Microsoft ABI?</li>
<li value="16">What is the standard entry sequence for a procedure (the instructions)?</li>
<li value="17">What is the standard exit sequence for a procedure (the instructions)?</li>
<li value="18">What instruction can you use to force 16-byte alignment of the stack pointer if the current value in RSP is unknown?</li>
<li value="19">What is the scope of a variable?</li>
<li value="20">What is the lifetime of a variable?</li>
<li value="21">What is an automatic variable?</li>
<li value="22">When does the system allocate storage for an automatic variable?</li>
<li value="23">Explain two ways to declare local/automatic variables in a procedure.</li>
<li value="24">Given the following procedure source code snippet, provide the offsets for each of the local variables:
<pre><code>procWithLocals proc
               local  var1:word, local2:dword, dVar:byte
               local  qArray[2]:qword, rlocal[2]:real4
               local  ptrVar:qword
                 .
                 .   ; Other statements in the procedure.
                 .
          procWithLocals endp</code></pre></li>
<li value="25">What statement(s) would you insert in the source file to tell MASM to automatically generate the standard entry and standard exit sequences for a procedure?</li>
<li value="26">When MASM automatically generates a standard entry sequence for a procedure, how does it determine where to put the code sequence?</li>
<li value="27">When MASM automatically generates a standard exit sequence for a procedure, how does it determine where to put the code sequence?</li>
<li value="28">What value does a pass-by-value parameter pass to a function?</li>
<li value="29">What value does a pass-by-reference parameter pass to a function?</li>
<li value="30">When passing four integer parameters to a function, where does the Windows ABI state those parameters are to be passed?</li>
<li value="31">When passing a floating-point value as one of the first four parameters, where does the Windows ABI insist the values will be passed?</li>
<li value="32">When passing more than four parameters to a function, where does the Windows ABI state the parameters will be passed?</li>
<li value="33"><span epub:type="pagebreak" title="286" id="Page_286"/>What is the difference between a volatile and nonvolatile register in the Windows ABI?</li>
<li value="34">Which registers are volatile in the Windows ABI?</li>
<li value="35">Which registers are nonvolatile in the Windows ABI?</li>
<li value="36">When passing parameters in the code stream, how does a function access the parameter data?</li>
<li value="37">What is a shadow parameter?</li>
<li value="38">How many bytes of shadow storage will a function require if it has a single 32-bit integer parameter?</li>
<li value="39">How many bytes of shadow storage will a function require if it has two 64-bit integer parameters?</li>
<li value="40">How many bytes of shadow storage will a function require if it has six 64-bit integer parameters?</li>
<li value="41">What offsets will MASM associate with each of the parameters in the following <code>proc</code> declaration?
<pre><code>procWithParms proc  parm1:byte, parm2:word, parm3:dword, parm4:qword</code></pre></li>
<li value="42">Suppose that <code>parm4</code> in the preceding question is a pass-by-reference character parameter. How would you load that character into the AL register (provide a code sequence)?</li>
<li value="43">What offsets will MASM associate with each of the local variables in the following <code>proc</code> snippet?
<pre><code>procWithLocals proc
               local lclVar1:byte, lclVar2:word, lclVar3:dword, lclVar4:qword</code></pre></li>
<li value="44">What is the best way to pass a large array to a procedure?</li>
<li value="45">What does <em>ABI</em> stand for?</li>
<li value="46">Where is the most common place to return a function result?</li>
<li value="47">What is a procedural parameter?</li>
<li value="48">How would you call a procedure passed as a parameter to a function/procedure?</li>
<li value="49">If a procedure has local variables, what is the best way to preserve registers within that procedure?</li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-1" href="#c05-footnoteref-1">1.</a></sup> One possible recommendation is to always push registers in the same order: RAX, RBX, RCX, RDX, RSI, RDI, R8, . . . , R15 (leaving out the registers you don’t push). This makes visual inspections of the code easier.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-2" href="#c05-footnoteref-2">2.</a></sup> <em>Stack frame</em> is another term used to describe the activation record.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-3" href="#c05-footnoteref-3">3.</a></sup> Technically speaking, few actual optimizing C/C++ compilers will do this unless you have certain options turned on. However, this chapter ignores such optimizations in favor of an easier-to-understand example.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-4" href="#c05-footnoteref-4">4.</a></sup> Alignment of the stack on a 16-byte boundary is a Microsoft ABI requirement, not a hardware requirement. The hardware is happy with an 8-byte address alignment. However, if you make any calls to Microsoft ABI–compliant code, you will need to keep the stack aligned on a 16-byte boundary.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-5" href="#c05-footnoteref-5">5.</a></sup> This argument against accessing global variables does not apply to other global symbols. It is perfectly reasonable to access global constants, types, procedures, and other objects in your programs.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-6" href="#c05-footnoteref-6">6.</a></sup> The Microsoft ABI doesn’t allow passing objects larger than 64 bits by value. If you’re writing Microsoft ABI–compliant code, the inefficiency of passing large objects is irrelevant.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-7" href="#c05-footnoteref-7">7.</a></sup> Intel has overloaded the meaning of the <em>movsd</em> mnemonic. When it has two operands (the first being an XMM register and the second being a 64-bit memory location), <em>movsd</em> stands for <em>move scalar double-precision</em>. When it has no operands, <em>movsd</em> is a string instruction and stands for <em>move string double</em>.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-8" href="#c05-footnoteref-8">8.</a></sup> This is especially true if the parameter list changes frequently.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-9" href="#c05-footnoteref-9">9.</a></sup> Actually, the x86-64 allows you to push 16-bit operands onto the stack. However, keeping RSP properly aligned on an 8- or 16-byte boundary when using 16-bit push instructions will be a big source of bugs in your program. Furthermore, it winds up taking two instructions to push a 32-bit value with 16-bit push instructions, so it is hardly cost-effective to use those instructions.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-10" href="#c05-footnoteref-10">10.</a></sup> In the Tower of Babel story, from Genesis in the Bible, God changed the spoken languages of the people constructing the tower so they couldn’t communicate with one another.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-11" href="#c05-footnoteref-11">11.</a></sup> It’s important to note here that Intel’s ABI and Microsoft’s ABI are not exactly the same. A compiler that adheres to the Intel ABI is not necessarily compatible with Microsoft languages (and other languages that adhere to the Microsoft ABI).</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-12" href="#c05-footnoteref-12">12.</a></sup> Strictly speaking, this is not true. Offsets in the range ±127 require only a 1-byte encoding, so smaller offsets are preferable to larger offsets. However, having more than 128 bytes of parameters is rare, so this isn’t a big issue for most programs.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-13" href="#c05-footnoteref-13">13.</a></sup> Also called <em>shadow store</em> in various documents.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-14" href="#c05-footnoteref-14">14.</a></sup> Well, not really infinite. The stack will overflow, and Windows will raise an exception at that point.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c05-footnote-15" href="#c05-footnoteref-15">15.</a></sup> The latter version will do it considerably faster because it doesn’t have the overhead of the <span class="LiteralFootnote"><code>call</code></span>/<span class="LiteralFootnote"><code>ret</code></span> instructions.</p></aside>
</section>
</section>
</body></html>