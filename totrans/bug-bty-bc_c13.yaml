- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Server-Side Request Forgery
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端请求伪造
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Server-side request forgery (**SSRF)* is a vulnerability that lets an attacker
    send requests on behalf of a server. During an SSRF, attackers forge the request
    signatures of the vulnerable server, allowing them to assume a privileged position
    on a network, bypass firewall controls, and gain access to internal services.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务器端请求伪造（**SSRF**）* 是一种漏洞，允许攻击者代表服务器发送请求。在 SSRF 攻击中，攻击者伪造受害服务器的请求签名，从而能够在网络中占据特权位置，绕过防火墙控制，并访问内部服务。'
- en: In this chapter, we’ll cover how SSRF works, how to bypass common protections
    for it, and how to escalate the vulnerability when you find one.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 SSRF 的工作原理，如何绕过常见的保护机制，以及当你发现一个漏洞时，如何进行漏洞升级。
- en: Mechanisms
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: 'SSRF vulnerabilities occur when an attacker finds a way to send requests as
    a trusted server in the target’s network. Imagine a public-facing web server on
    *example.com*’s network named *public.example.com*. This server hosts a proxy
    service, located at *public.example.com/proxy*, that fetches the web page specified
    in the `url` parameter and displays it back to the user. For example, when the
    user accesses the following URL, the web application would display the *google.com*
    home page:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: SSRF 漏洞发生在攻击者找到一种方法，能够像目标网络中的受信任服务器一样发送请求。想象一下，*example.com* 网络上有一台面向公众的 Web
    服务器，名为 *public.example.com*。这台服务器托管了一个代理服务，位于 *public.example.com/proxy*，它获取 `url`
    参数指定的网页并将其显示给用户。例如，当用户访问以下 URL 时，Web 应用程序会显示 *google.com* 的首页：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now let’s say *admin.example.com* is an internal server on the network hosting
    an admin panel. To ensure that only employees can access the panel, administrators
    set up access controls to keep it from being reached via the internet. Only machines
    with a valid internal IP, like an employee workstation, can access the panel.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 *admin.example.com* 是网络中的一台内部服务器，托管着一个管理面板。为了确保只有员工能够访问该面板，管理员设置了访问控制，以防止其通过互联网访问。只有具有有效内部
    IP 的机器，如员工工作站，才能访问该面板。
- en: Now, what if a regular user accesses the following URL?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一个普通用户访问以下 URL，会发生什么？
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the `url` parameter is set to the URL of the internal admin panel. With
    no SSRF protection mechanism in place, the web application would display the admin
    panel to the user, because the request to the admin panel is coming from the web
    server, *public.example.com*, a trusted machine on the network.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`url` 参数设置为内部管理面板的 URL。如果没有 SSRF 保护机制，Web 应用程序将显示管理面板给用户，因为对管理面板的请求来自 Web
    服务器，*public.example.com*，这是网络上的一台受信任机器。
- en: Through SSRF, servers accept unauthorized requests that firewall controls would
    normally block, like fetching the admin panel from a non-company machine. Often,
    the protection that exists on the network perimeter, between public-facing web
    servers and internet machines, does not exist between machines on the trusted
    network. Therefore, the protection that hides the admin panel from the internet
    doesn’t apply to requests sent between the web server and the admin panel server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SSRF，服务器接受未经授权的请求，这些请求通常会被防火墙控制阻止，比如从非公司机器上获取管理面板。通常，位于网络边界、面向公众的 Web 服务器和互联网机器之间的防护措施，在可信网络中的机器之间并不存在。因此，隐藏管理面板不让互联网访问的防护措施并不适用于
    Web 服务器和管理面板服务器之间的请求。
- en: By forging requests from trusted servers, an attacker can pivot into an organization’s
    internal network and conduct all kinds of malicious activities. Depending on the
    permissions given to the vulnerable internet-facing server, an attacker might
    be able to read sensitive files, make internal API calls, and access internal
    services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过伪造受信任服务器的请求，攻击者可以突破组织的内部网络，进行各种恶意活动。根据暴露的互联网服务器所授予的权限，攻击者可能能够读取敏感文件，进行内部 API
    调用，以及访问内部服务。
- en: 'SSRF vulnerabilities have two types: regular SSRF and blind SSRF. The mechanisms
    behind both are the same: each exploits the trust between machines on the same
    network. The only difference is that in a blind SSRF, the attacker does not receive
    feedback from the server via an HTTP response or an error message. For instance,
    in the earlier example, we’d know the SSRF worked if we see *admin.example.com*
    displayed. But in a blind SSRF, the forged request executes without any confirmation
    sent to the attacker.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SSRF 漏洞有两种类型：常规 SSRF 和盲 SSRF。两者背后的机制是相同的：都利用了同一网络中机器之间的信任。唯一的区别是，在盲 SSRF 中，攻击者不会通过
    HTTP 响应或错误信息收到服务器的反馈。例如，在前面的例子中，如果我们看到 *admin.example.com* 被显示出来，我们就知道 SSRF 攻击成功了。但在盲
    SSRF 中，伪造的请求执行时不会向攻击者发送任何确认。
- en: 'Let’s say that on *public.example.com* another functionality allows users to
    send requests via its web server. But this endpoint does not return the resulting
    page to the user. If attackers can send requests to the internal network, the
    endpoint suffers from a blind SSRF vulnerability:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在 *public.example.com* 上，另一个功能允许用户通过其 web 服务器发送请求。但此端点不会将结果页面返回给用户。如果攻击者能够向内部网络发送请求，该端点会遭受盲
    SSRF 漏洞：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Although blind SSRFs are harder to exploit, they’re still extremely valuable
    to an attacker, who might be able to perform network scanning and exploit other
    vulnerabilities on the network. We’ll get more into this later.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管盲 SSRF 更难利用，但它仍然对攻击者非常有价值，攻击者可能能够进行网络扫描并利用网络上的其他漏洞。我们稍后会进一步探讨这个问题。
- en: Prevention
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预防
- en: SSRFs happen when servers need to send requests to obtain external resources.
    For example, when you post a link on Twitter, Twitter fetches an image from that
    external site to create a thumbnail. If the server doesn’t stop users from accessing
    internal resources using the same mechanisms, SSRF vulnerabilities occur.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SSRF 漏洞发生在服务器需要发送请求以获取外部资源时。例如，当你在 Twitter 上发布一个链接时，Twitter 会从外部网站获取图片以创建缩略图。如果服务器没有阻止用户使用相同的机制访问内部资源，就会发生
    SSRF 漏洞。
- en: 'Let’s look at another example. Say a page on *public.example.com* allows users
    to upload a profile photo by retrieving it from a URL via this POST request:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。假设 *public.example.com* 的页面允许用户通过此 POST 请求从 URL 中检索并上传个人资料照片：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To fetch *profile.jpeg* from *attacker.com*, the web application would have
    to visit and retrieve contents from *attacker.com.* This is the safe and intended
    behavior of the application. But if the server does not make a distinction between
    internal and external resources, an attacker could just as easily request a local
    file stored on the server, or any other file on the network. For instance, they
    could make the following POST request, which would cause the web server to fetch
    the sensitive file and display it as the user’s profile picture:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 *attacker.com* 获取 *profile.jpeg*，web 应用程序必须访问并从 *attacker.com* 获取内容。这是应用程序的安全预期行为。但如果服务器没有区分内部资源和外部资源，攻击者就可以轻易请求存储在服务器上的本地文件或网络上的其他文件。例如，攻击者可以发出以下
    POST 请求，这将导致 web 服务器获取敏感文件并将其显示为用户的个人资料图片：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Two main types of protection against SSRFs exist: blocklists and allowlists.
    *Blocklists* are lists of banned addresses. The server will block a request if
    it contains a blocklisted address as input. Because applications often need to
    fetch resources from a variety of internet sources, too many to explicitly allow,
    most applications use this method. Companies blocklist internal network addresses
    and reject any request that redirects to those addresses.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 防范 SSRF 漏洞的主要保护方式有两种：黑名单和白名单。*黑名单* 是一个被禁止的地址列表。如果请求中包含黑名单中的地址，服务器将阻止该请求。由于应用程序通常需要从各种互联网源获取资源，黑名单方法适用于大多数应用程序，因为要显式允许的地址过多。公司会将内部网络地址加入黑名单，并拒绝任何重定向到这些地址的请求。
- en: On the other hand, when a site implements *allowlist* protection, the server
    allows only requests that contain URLs found in a predetermined list and rejects
    all other requests. Some servers also protect against SSRFs by requiring special
    headers or secret tokens in internal requests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当站点实施 *允许列表* 保护时，服务器仅允许包含在预定列表中的 URL 请求，拒绝所有其他请求。一些服务器还通过要求内部请求中带有特殊头或秘密令牌来保护免受
    SSRF 攻击。
- en: Hunting for SSRFs
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSRF 漏洞狩猎
- en: The best way to discover SSRF vulnerabilities is through a review of the application’s
    source code, in which you check if the application validates all user-provided
    URLs. But when you can’t obtain the source code, you should focus your efforts
    on testing the features most prone to SSRF.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 发现 SSRF 漏洞的最佳方法是通过审查应用程序的源代码，检查应用程序是否验证所有用户提供的 URL。但当无法获得源代码时，您应集中精力测试那些最容易受到
    SSRF 攻击的功能。
- en: 'Step 1: Spot Features Prone to SSRFs'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：发现易受 SSRF 攻击的功能
- en: SSRFs occur in features that require visiting and fetching external resources.
    These include webhooks, file uploads, document and image processors, link expansions
    or thumbnails, and proxy services. It’s also worth testing any endpoint that processes
    a user-provided URL. And pay attention to potential SSRF entry points that are
    less obvious, like URLs embedded in files that are processed by the application
    (XML files and PDF files can often be used to trigger SSRFs), hidden API endpoints
    that accept URLs as input, and input that gets inserted into HTML tags.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SSRF（服务器端请求伪造）出现在需要访问和获取外部资源的功能中。这些功能包括 webhook、文件上传、文档和图像处理器、链接扩展或缩略图以及代理服务。还应该测试任何处理用户提供的
    URL 的端点。同时，注意那些不太明显的 SSRF 入口点，例如嵌入在应用程序处理的文件中的 URL（XML 文件和 PDF 文件常常被用来触发 SSRF）、接受
    URL 作为输入的隐藏 API 端点以及插入到 HTML 标签中的输入。
- en: '*Webhooks* are custom HTTP callback endpoints used as a notification system
    for certain application events. When an event such as new user sign-up or application
    error occurs, the originating site will make an HTTP request to the webhook URL.
    These HTTP requests help the company collect information about the website’s performance
    and visitors. It also helps organizations keep data in sync across multiple web
    applications.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*Webhook* 是自定义的 HTTP 回调端点，用作某些应用程序事件的通知系统。当发生诸如新用户注册或应用程序错误等事件时，发起方网站将向 webhook
    URL 发出 HTTP 请求。这些 HTTP 请求帮助公司收集有关网站性能和访客的信息，也有助于组织保持多个 Web 应用程序之间的数据同步。'
- en: And in the event that one action from an application needs to trigger an action
    on another application, webhooks are a way of notifying the system to kick-start
    another process. For example, if a company wants to send a welcome email to every
    user who follows its social media account, it can use a webhook to connect the
    two applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的某个操作需要触发另一个应用程序的操作时，webhook 就是一种通知系统，用于启动另一个过程。例如，如果公司想要向每个关注其社交媒体账户的用户发送欢迎电子邮件，可以使用
    webhook 将两个应用程序连接起来。
- en: Many websites allow users to set up their webhook URLs, and these settings pages
    are often vulnerable to SSRF. Most of the time, an application’s webhook service
    is in its developers’ portal. For example, Slack allows application owners to
    set up a webhook via its app configuration page ([https://api.slack.com/apps/](https://api.slack.com/apps/)).
    Under the Event Subscriptions heading, you can specify a URL at which Slack will
    notify you when special events happen ([Figure 13-1](#figure13-1)). The Request
    URL field of these webhook services is often vulnerable to SSRF.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站允许用户设置他们的 webhook URL，这些设置页面通常容易受到 SSRF 攻击。大多数情况下，应用程序的 webhook 服务位于开发者门户中。例如，Slack
    允许应用程序所有者通过其应用配置页面设置 webhook ([https://api.slack.com/apps/](https://api.slack.com/apps/))。在“事件订阅”部分，您可以指定一个
    URL，当特殊事件发生时，Slack 会通知您 ([图 13-1](#figure13-1))。这些 webhook 服务的请求 URL 字段通常容易受到
    SSRF 攻击。
- en: On the other hand, *proxy services* refer to services that act as an intermediary
    between two machines. They sit between the client and the server of a request
    to facilitate or control their communication. Common use cases of proxy services
    are to bypass organization firewalls that block certain websites, browse the internet
    anonymously, or encrypt internet messages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*代理服务* 是指作为两台机器之间中介的服务。它们位于请求的客户端和服务器之间，以促进或控制它们的通信。代理服务的常见用途包括绕过组织防火墙，访问被封锁的网站、匿名浏览互联网或加密互联网消息。
- en: '![f13001](image_fi/501546c13/f13001.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![f13001](image_fi/501546c13/f13001.png)'
- en: 'Figure 13-1: Adding a webhook to Slack'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-1：将 webhook 添加到 Slack
- en: 'Notice these potentially vulnerable features on the target site and record
    them for future reference in a list like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意目标网站上的这些潜在易受攻击的功能，并将它们记录在类似这样的列表中以备将来参考：
- en: '**Potential SSRF Endpoints**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**潜在的 SSRF 端点**'
- en: 'Add a new webhook:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的 webhook：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'File upload via URL:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 URL 上传文件：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Proxy service:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理服务：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Step 2: Provide Potentially Vulnerable Endpoints with Internal URLs'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：提供带有内部 URL 的潜在易受攻击端点
- en: 'Once you’ve identified the potentially vulnerable endpoints, provide internal
    addresses as the URL inputs to these endpoints. Depending on the network configuration,
    you might need to try several addresses before you find the ones in use by the
    network. Here are some common ones reserved for the private network: *localhost*,
    127.0.0.1, 0.0.0.0, 192.168.0.1, and 10.0.0.1.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦识别出潜在的易受攻击端点，提供这些端点的内部地址作为URL输入。根据网络配置，你可能需要尝试多个地址才能找到网络正在使用的地址。以下是一些常见的保留用于私有网络的地址：*localhost*、127.0.0.1、0.0.0.0、192.168.0.1和10.0.0.1。
- en: You can find more reserved IP addresses used to identify machines on the private
    network at [https://en.wikipedia.org/wiki/Reserved_IP_addresses](https://en.wikipedia.org/wiki/Reserved_IP_addresses).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://en.wikipedia.org/wiki/Reserved_IP_addresses](https://en.wikipedia.org/wiki/Reserved_IP_addresses)找到更多用于识别私有网络中机器的保留IP地址。
- en: 'To illustrate, this request tests the webhook functionality:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，以下请求测试了webhook功能：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This request tests the file upload functionality:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求测试文件上传功能：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And this request tests the proxy service:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求测试代理服务：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Step 3: Check the Results'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤3：检查结果
- en: 'In the case of regular SSRF, see if the server returns a response that reveals
    any information about the internal service. For example, does the response contain
    service banners or the content of internal pages? A *service banner* is the name
    and version of the software running on the machine. Check for this by sending
    a request like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规的SSRF情况下，查看服务器是否返回包含任何内部服务信息的响应。例如，响应中是否包含服务横幅或内部页面的内容？*服务横幅*是指运行在机器上的软件的名称和版本。可以通过发送类似这样的请求来检查：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Port 22 is the default port for the Secure Shell Protocol (SSH). This request
    tells the application that the URL of our profile picture is located at 127.0.0.1:22,
    or port 22 of the current machine. This way, we can trick the server into visiting
    its own port 22 and returning information about itself.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 22端口是安全外壳协议（SSH）的默认端口。这个请求告诉应用程序，我们的个人资料图片的URL位于127.0.0.1:22，或者说是当前机器的22端口。通过这种方式，我们可以欺骗服务器访问它自己的22端口，并返回关于它自身的信息。
- en: 'Then look for text like this in the response:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在响应中查找类似以下的文本：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you find a message like this, you can be sure that an SSRF vulnerability
    exists on this endpoint, since you were able to gather information about the localhost.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找到类似的信息，可以确信该端点存在SSRF漏洞，因为你能够收集到关于本地主机的信息。
- en: 'The easiest way of detecting blind SSRFs is through out-of-band techniques:
    you make the target send requests to an external server that you control, and
    then monitor your server logs for requests from the target. One way to do this
    is to use an online hosting service, such as GoDaddy or Hostinger, that provides
    server access logs. You can link your hosted site to a custom domain and submit
    that domain in the SSRF testing payload.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 检测盲目SSRF（服务器端请求伪造）最简单的方法是通过带外技术：你让目标向你控制的外部服务器发送请求，然后监控服务器日志中来自目标的请求。一种方法是使用在线托管服务，如GoDaddy或Hostinger，这些服务提供服务器访问日志。你可以将你的托管站点链接到一个自定义域名，并在SSRF测试负载中提交该域名。
- en: You can also turn your own machine into a listener by using Netcat, a utility
    installed by default on most Linux machines. If you don’t already have Netcat,
    you can install it by using the command `apt-get install netcat`. Then use `nc
    -lp 8080` to start a listener on port 8080\. After this, you can point your SSRF
    payloads to your IP address on port 8080 and monitor for any incoming traffic.
    Another easier way of doing this is to use the Collaborator feature in Burp Suite
    Pro, which automatically generates unique domain names, sends them as payloads
    to the target, and monitors for any interaction associated with the target.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用Netcat将自己的机器变成监听器，Netcat是大多数Linux机器上默认安装的一个工具。如果你还没有Netcat，可以使用命令`apt-get
    install netcat`进行安装。然后使用`nc -lp 8080`在端口8080上启动监听器。之后，你可以将你的SSRF负载指向你的IP地址和8080端口，监控是否有任何流量传入。另一种更简单的方法是使用Burp
    Suite Pro中的Collaborator功能，它会自动生成唯一的域名，将其作为负载发送给目标，并监控与目标相关的任何交互。
- en: However, being able to generate an outbound request from the target server alone
    is not an exploitable issue. Since you cannot use blind SSRFs to read internal
    files or access internal services, you need to confirm their exploitability by
    trying to explore the internal network with the SSRF. Make requests to various
    target ports and see if server behavior differs between commonly open and closed
    ports. For example, ports 22, 80, and 443 are commonly open ports, while port
    11 is not. This will help you determine if an attacker can use the SSRF to access
    the internal network. You can look especially for differences in response time
    and HTTP response codes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅能够从目标服务器生成出站请求并不是一个可利用的问题。由于你无法使用盲目 SSRF 来读取内部文件或访问内部服务，你需要通过尝试用 SSRF 探索内部网络来确认其可利用性。向不同的目标端口发送请求，看看服务器在常见开放端口和关闭端口之间的行为是否有所不同。例如，端口
    22、80 和 443 是常见的开放端口，而端口 11 则不是。这将帮助你判断攻击者是否能够利用 SSRF 访问内部网络。你可以特别关注响应时间和 HTTP
    响应代码的差异。
- en: 'For example, servers use the HTTP status code 200 to indicate that a request
    has succeeded. Often, if a server is able to connect to the specified port, it
    will return a 200 status code. Say the following request results in an HTTP status
    code of 200:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，服务器使用 HTTP 状态码 200 来表示请求已成功。通常，如果服务器能够连接到指定的端口，它会返回 200 状态码。假设以下请求会导致 HTTP
    状态码 200：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following request instead results in an HTTP status code of 500, the status
    code for Internal Server Error. Servers return 500 status codes when they run
    into an error while processing the request, so a 500 status code often indicates
    a closed or protected port:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下请求会导致 HTTP 状态码 500，即内部服务器错误状态码。服务器在处理请求时遇到错误时会返回 500 状态码，因此 500 状态码通常表示端口已关闭或受保护：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can confirm that the server is indeed making requests to these ports and
    responding differently based on port status.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以确认服务器确实正在向这些端口发起请求，并根据端口状态做出不同的响应。
- en: Also look for the time difference between responses. You can see in [Figure
    13-2](#figure13-2) that the Burp repeater shows how long it took for the server
    to respond in the bottom right corner. Here, it took 181 milliseconds for Google
    to return its home page. You can use tools like SSRFmap ([https://github.com/swisskyrepo/SSRFmap/](https://github.com/swisskyrepo/SSRFmap/))
    to automate this process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还要查看响应之间的时间差异。你可以在[图 13-2](#figure13-2)中看到，Burp 重复器在右下角显示了服务器响应所花费的时间。在这里，Google
    返回主页用了 181 毫秒。你可以使用像 SSRFmap ([https://github.com/swisskyrepo/SSRFmap/](https://github.com/swisskyrepo/SSRFmap/))
    这样的工具来自动化这个过程。
- en: '![f13002](image_fi/501546c13/f13002.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![f13002](image_fi/501546c13/f13002.png)'
- en: 'Figure 13-2: Burp repeater shows you how long it took for the server to respond
    to a request.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-2：Burp 重复器向你展示服务器响应请求所花费的时间。
- en: If a port is closed, the server usually responds faster because it drops the
    forwarded traffic immediately, whereas internal firewalls often cause a delay
    in the response. Attackers can use time delays as a metric to figure out a target’s
    internal network structure. If you can identify a significant time difference
    between requests to different ports, you have found an exploitable SSRF.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口关闭，服务器通常会更快地响应，因为它会立即丢弃转发的流量，而内部防火墙通常会导致响应延迟。攻击者可以利用时间延迟作为度量来推测目标的内部网络结构。如果你能识别出不同端口之间请求的显著时间差异，那么你就找到了一个可利用的
    SSRF。
- en: Bypassing SSRF Protection
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过 SSRF 保护
- en: What if you submit an SSRF payload, but the server returns this response?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提交一个 SSRF 负载，但服务器返回了这个响应，怎么办？
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This SSRF was blocked by a protection mechanism, possibly a URL allowlist or
    blocklist. But all is not lost! The site may have protection mechanisms implemented,
    but this doesn’t mean that the protection is complete. Here are a few more things
    you can try to bypass a site’s protection.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 SSRF 被保护机制阻止了，可能是 URL 白名单或黑名单。但是并不是一切都丧失了！该站点可能实现了保护机制，但这并不意味着保护是完整的。这里有一些其他方法，你可以尝试绕过站点的保护。
- en: Bypass Allowlists
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过白名单
- en: Allowlists are generally the hardest to bypass, because they are, by default,
    stricter than blocklists. But getting around them is still possible if you can
    find an open redirect vulnerability within the allowlisted domains. (Visit Chapter
    7 for more information about these vulnerabilities.) If you find one, you can
    request an allowlisted URL that redirects to an internal URL. For example, even
    if the site allows only profile pictures uploaded from one of its subdomains,
    you can induce an SSRF through an open redirect.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 允许列表通常是最难绕过的，因为默认情况下它们比阻止列表更严格。但如果你能够在允许列表域中找到一个开放重定向漏洞，绕过它仍然是可能的。（有关这些漏洞的更多信息，请参阅第
    7 章。）如果你发现了一个漏洞，你可以请求一个允许列表的 URL，该 URL 会重定向到内部 URL。例如，即使该网站只允许从其子域之一上传个人资料图片，你也可以通过开放重定向诱发一个
    SSRF。
- en: 'In the following request, we utilize an open redirect on *pics.example.com*
    to redirect the request to 127.0.0.1, the IP address for the localhost. This way,
    even though the `url` parameter passes the allowlist, it still redirects to a
    restricted internal address:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下请求中，我们利用 *pics.example.com* 上的开放重定向，将请求重定向到 127.0.0.1，这是本地主机的 IP 地址。这样，即使
    `url` 参数通过了允许列表，它仍然会重定向到受限的内部地址：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The server could also have implemented its allowlist via poorly designed regular
    expressions (regexes). Regexes are often used to construct more flexible allowlists.
    For example, instead of checking whether a URL string is equal to `"example.com"`,
    a site can check regex expressions like `.*example.com.*` to match the subdomains
    and filepaths of *example.com* as well. In those cases, you could bypass the regex
    by placing the allowlisted domain in the request URL. For example, this request
    will redirect to 127.0.0.1, since *pics.example.com* is seen as the username portion
    of the URL:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器也可能通过设计不良的正则表达式（regex）实现其允许列表。正则表达式通常用于构建更灵活的允许列表。例如，网站可以检查类似 `.*example.com.*`
    的正则表达式，以匹配 *example.com* 的子域和文件路径，而不是简单地检查 URL 字符串是否等于 `"example.com"`。在这种情况下，如果你能将允许列表域放入请求
    URL 中，你就可以绕过正则表达式。例如，此请求将重定向到 127.0.0.1，因为 *pics.example.com* 被视为 URL 的用户名部分：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following request also redirects to 127.0.0.1, since *pics.example.com*
    is seen as the directory portion of the URL:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下请求也会重定向到 127.0.0.1，因为 *pics.example.com* 被视为 URL 的目录部分：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can test whether a site is using an overly flexible regex allowlist by trying
    URLs like these and seeing if the filter allows it. Note that a regex-based allowlist
    can be secure if the regex is well constructed. And these URLs won’t always succeed!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过尝试像这样的 URL 来测试一个网站是否使用了过于灵活的正则表达式允许列表，看看过滤器是否允许它。请注意，如果正则表达式构造得当，基于正则表达式的允许列表是可以安全的。而且这些
    URL 并不总是成功的！
- en: Bypass Blocklists
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过阻止列表
- en: Since applications often need to fetch resources from a variety of internet
    sources, most SSRF protection mechanisms come in the form of a blocklist. If you’re
    faced with a blocklist, there are many ways of tricking the server.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序通常需要从各种互联网来源获取资源，大多数 SSRF 保护机制以阻止列表的形式存在。如果你遇到阻止列表，还是有很多方法可以欺骗服务器。
- en: Fooling It with Redirects
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过重定向欺骗它
- en: 'First, you can make the server request a URL that you control and that redirects
    to the blocklisted address. For example, you can ask the target server to send
    a request to your server:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以让服务器请求一个你控制的 URL，该 URL 会重定向到被阻止的地址。例如，你可以要求目标服务器向你的服务器发送请求：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, on your server at *https://attacker.com/ssrf*, you can host a file with
    the following content:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你控制的服务器上（*https://attacker.com/ssrf*），你可以托管一个包含以下内容的文件：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a piece of PHP code that redirects the request by setting the document’s
    location to 127.0.0.1\. When you make the target server request *https://attacker.com/ssrf,*
    the target server is redirected to *http://127.0.0.1*, a restricted internal address.
    This attack will bypass blocklists because the URL submitted to the application
    does not itself contain any blocklisted addresses.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 PHP 代码片段，通过将文档的地址设置为 127.0.0.1 来重定向请求。当你发出目标服务器请求 *https://attacker.com/ssrf*
    时，目标服务器将被重定向到 *http://127.0.0.1*，这是一个受限的内部地址。此攻击将绕过阻止列表，因为提交给应用程序的 URL 本身不包含任何被列入阻止列表的地址。
- en: Using IPv6 Addresses
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 IPv6 地址
- en: 'I mentioned in Chapter 3 that IPv6 addresses are a newer alternative to the
    more commonly used IPv4 addresses. The Internet Engineering Task Force (IETF)
    created IPv6 addresses as the world began running out of available IPv4 addresses
    and needed a format that provided a larger number of possible addresses. IPv6
    addresses are 128-bit values represented in hexadecimal notation, and they look
    like this: 64:ff9b::255.255.255.255.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第3章中提到过，IPv6地址是IPv4地址的更新替代方案。随着全球IPv4地址的用尽，互联网工程任务组(IETF)创建了IPv6地址，以提供更多的地址格式。IPv6地址是128位的值，以十六进制表示，看起来像这样：64:ff9b::255.255.255.255。
- en: Sometimes the SSRF protection mechanisms a site has implemented for IPv4 might
    not have been implemented for IPv6\. That means you can try to submit IPv6 addresses
    that point to the local network. For example, the IPv6 address *::1* points to
    the localhost, and *fc00::* is the first address on the private network.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，网站为IPv4实施的SSRF防护机制可能并未为IPv6实施。这意味着你可以尝试提交指向本地网络的IPv6地址。例如，IPv6地址*::1*指向本地主机，而*fc00::*是私有网络中的第一个地址。
- en: 'For more information about how IPv6 works, and about other reserved IPv6 addresses,
    visit Wikipedia: [https://en.wikipedia.org/wiki/IPv6_address](https://en.wikipedia.org/wiki/IPv6_address).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于IPv6如何工作的内容，以及其他保留的IPv6地址，请访问Wikipedia：[https://en.wikipedia.org/wiki/IPv6_address](https://en.wikipedia.org/wiki/IPv6_address)。
- en: Tricking the Server with DNS
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 利用DNS欺骗服务器
- en: You can also try confusing the server with DNS records, which computers use
    to translate hostnames into IP addresses. DNS records come in various types, but
    the ones you’ll hear about most often are A and AAAA records. *A records* point
    a hostname to an IPv4 address, whereas *AAAA records* translate hostnames to an
    IPv6 address.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试通过DNS记录混淆服务器，DNS记录是计算机用于将主机名转换为IP地址的工具。DNS记录有多种类型，但你最常听到的是A记录和AAAA记录。*A记录*将主机名指向IPv4地址，而*AAAA记录*将主机名转换为IPv6地址。
- en: 'Modify the A/AAAA record of a domain you control and make it point to the internal
    addresses on the victim’s network. You can check the current A/AAAA records of
    your domain by running these commands:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你控制的域名的A/AAAA记录，并将其指向受害者网络上的内部地址。你可以通过运行以下命令检查你域名当前的A/AAAA记录：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can usually configure the DNS records of your domain name by using your
    domain registrar or web-hosting service’s settings page. For instance, I use Namecheap
    as my domain service. In Namecheap, you can configure your DNS records by going
    to your account and choosing Domain List▶Manage Domain▶Advanced DNS▶Add New Record.
    Create a custom mapping of hostname to IP address and make your domain resolve
    to 127.0.0.1\. You can do this by creating a new A record for your domain that
    points to 127.0.0.1.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以通过使用域名注册商或网页托管服务的设置页面来配置你的域名的DNS记录。例如，我使用Namecheap作为我的域名服务。在Namecheap中，你可以通过进入账户并选择“域名列表▶管理域名▶高级DNS▶添加新记录”来配置DNS记录。创建一个主机名到IP地址的自定义映射，并使你的域名解析到127.0.0.1。你可以通过为你的域名创建一个新的A记录，使其指向127.0.0.1来实现这一点。
- en: 'Then you can ask the target server to send a request to your server, like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以要求目标服务器向你的服务器发送请求，如下所示：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now when the target server requests your domain, it will think your domain is
    located at 127.0.0.1 and request data from that address.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当目标服务器请求你的域名时，它会认为你的域名位于127.0.0.1，并从该地址请求数据。
- en: Switching Out the Encoding
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切换编码方式
- en: There are many ways of encoding a URL or an address. Character encodings are
    different ways of representing the same character while preserving its meaning.
    They are often used to make data transportation or storage more efficient. These
    encoding methods don’t change how a server interprets the location of the address,
    but they might allow the input to slip under the radar of a blocklist if it bans
    only addresses that are encoded a certain way.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种方式可以对URL或地址进行编码。字符编码是表示相同字符的不同方式，同时保留其含义。它们通常用于使数据传输或存储更加高效。这些编码方法不会改变服务器如何解释地址的位置，但它们可能允许输入绕过阻止列表，特别是当阻止列表只禁止某种特定编码方式的地址时。
- en: 'Possible encoding methods include hex encoding, octal encoding, dword encoding,
    URL encoding, and mixed encoding. If the URL parser of the target server does
    not process these encoding methods appropriately, you might be able to bypass
    SSRF protection. So far, the addresses provided as examples in this book have
    used *decimal encoding*, the base-10 format that uses characters ranging from
    0 to 9\. To translate a decimal-formatted IP address to hex, calculate each dot-delineated
    section of the IP address into its hex equivalent. You could use a decimal-to-hex
    calculator to do this, and then put together the entire address. For example,
    127.0.0.1 in decimal translates to 0x7f.0x0.0x0.0x1 in hex. The 0x at the beginning
    of each section designates it as a hex number. You can then use the hex address
    in the potential SSRF endpoint:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的编码方法包括十六进制编码、八进制编码、dword 编码、URL 编码和混合编码。如果目标服务器的 URL 解析器没有正确处理这些编码方法，你可能能够绕过
    SSRF 保护。到目前为止，本书中提供的示例地址都使用了 *十进制编码*，这是使用 0 到 9 的字符的基数 10 格式。要将十进制格式的 IP 地址转换为十六进制，计算
    IP 地址每一段的十六进制等效值。你可以使用十进制到十六进制的计算器来进行转换，然后将整个地址组合起来。例如，127.0.0.1 的十进制转换为十六进制是
    0x7f.0x0.0x0.0x1。每段前面的 0x 表示它是一个十六进制数。然后，你可以在潜在的 SSRF 端点中使用十六进制地址：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Octal encoding* is a way of representing characters in a base-8 format by
    using characters ranging from 0 to 7\. As with hex, you can translate an IP address
    to octal form by recalculating each section. You can utilize an online calculator
    for this too; just search for *decimal to octal calculator* to find one. For example,
    127.0.0.1 translates to 0177.0.0.01\. In this case, the leading zeros are necessary
    to convey that that section is an octal number. Then use it in the potential SSRF
    endpoint:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*八进制编码* 是一种通过使用 0 到 7 的字符在基数 8 格式中表示字符的方法。与十六进制一样，你可以通过重新计算每一段将 IP 地址转换为八进制形式。你也可以利用在线计算器来完成这个过程；只需搜索
    *十进制到八进制计算器* 来找到一个。例如，127.0.0.1 转换为 0177.0.0.01。在这种情况下，前导零是必要的，以表明该部分是一个八进制数。然后在潜在的
    SSRF 端点中使用它：'
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The *dword*, or *double word*, encoding scheme represents an IP address as a
    single 32-bit integer (called a dword). To translate an address into a dword,
    split the address into four octets (groups of 8 bits), and write out its binary
    representation. For example, 127.0.0.1 is the decimal representation of 01111111.00000000.00000000.00000001\.
    When we translate the entire number, 01111111000000000000000000000001, into one
    single decimal number, we get the IP address in dword format.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*dword*，即 *双字* 编码方案，将一个 IP 地址表示为单个 32 位整数（称为 dword）。要将地址转换为 dword，需要将地址拆分成四个八位字节（8
    位的一组），并写出它的二进制表示。例如，127.0.0.1 的十进制表示为 01111111.00000000.00000000.00000001。当我们将整个数字
    01111111000000000000000000000001 转换为一个单一的十进制数字时，就得到了 dword 格式的 IP 地址。'
- en: 'What is 127.0.0.1 in dword format? It’s the answer for 127 × 256³ + 0 × 256²
    + 0 × 256¹ + 1 × 256⁰, which is 2130706433\. You could use a binary-to-decimal
    calculator to calculate this. If you type *https://2130706433* instead of *https://127.0.0.1*
    in your browser, it would still be understood, and you could use it in the potential
    SSRF endpoint:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`127.0.0.1` 在 dword 格式中是什么？它是通过计算 127 × 256³ + 0 × 256² + 0 × 256¹ + 1 × 256⁰
    得出的答案，结果是 2130706433。你可以使用二进制到十进制的计算器来计算这个。如果你在浏览器中输入 *https://2130706433* 而不是
    *https://127.0.0.1*，它仍然可以被理解，并且你可以在潜在的 SSRF 端点中使用它：'
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When a server blocks requests to internal hostnames like https://localhost,
    try its URL-encoded equivalent:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器阻止访问像 https://localhost 这样的内部主机名时，试试它的 URL 编码等效形式：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, you could use a combination of encoding techniques to try to fool the
    blocklist. For example, in the address 0177.0.0.0x1, the first section uses octal
    encoding, the next two use decimal encoding, and the last section uses hex encoding.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用多种编码技术的组合来试图绕过黑名单。例如，在地址 0177.0.0.0x1 中，第一段使用了八进制编码，接下来的两段使用十进制编码，最后一段使用十六进制编码。
- en: This is just a small portion of bypasses you can try. You can use many more
    creative ways to defeat protection and achieve SSRF. When you can’t find a bypass
    that works, switch your perspective by asking yourself, how would I implement
    a protection mechanism for this feature? Design what you think the protection
    logic would look like. Then try to bypass the mechanism you’ve designed. Is it
    possible? Did you miss anything when implementing the protection? Could the developer
    of the application have missed something too?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是您可以尝试的绕过方法的一小部分。您可以使用更多创造性的方式来击败保护并实现SSRF。当找不到有效的绕过方法时，通过改变视角来问自己：如果我要为此功能实现保护机制，我会怎么做？设计您认为保护逻辑会是什么样子。然后尝试绕过您设计的机制。是否可能？在实施保护时是否遗漏了什么？应用程序的开发人员可能也会遗漏一些东西吗？
- en: Escalating the Attack
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级攻击
- en: SSRFs can vary in impact, but they have a lot of potential if you know how to
    escalate them by chaining them with different bugs. Now that you have the basics
    of SSRFs down, let’s learn to exploit them most effectively.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SSRF的影响可能有所不同，但如果您知道如何通过与不同漏洞链接来升级它们，它们具有很大的潜力。现在您已经掌握了SSRF的基础知识，让我们学习如何最有效地利用它们。
- en: What you can achieve with an SSRF usually depends on the internal services found
    on the network. Depending on the situation, you could use SSRF to scan the network
    for reachable hosts, port-scan internal machines to fingerprint internal services,
    collect instance metadata, bypass access controls, leak confidential data, and
    even execute code on reachable machines.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SSRF（Server-Side Request Forgery，服务端请求伪造）通常可以实现的功能取决于网络中发现的内部服务。根据情况，您可以使用SSRF扫描网络上的可达主机，对内部机器进行端口扫描以识别内部服务，收集实例元数据，绕过访问控制，泄露机密数据，甚至在可达机器上执行代码。
- en: Perform Network Scanning
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行网络扫描
- en: You may sometimes want to scan the network for other reachable machines. *Reachable
    machines* are other network hosts that can be connected to via the current machine.
    These internal machines might host databases, internal websites, and otherwise
    sensitive functionalities that an attacker can exploit to their advantage. To
    perform the scan, feed the vulnerable endpoint a range of internal IP addresses
    and see if the server responds differently to each address. For example, when
    you request the address 10.0.0.1
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能希望扫描网络以查找其他可达机器。*可达机器*是可以通过当前机器连接的其他网络主机。这些内部机器可能托管数据库、内部网站和其他敏感功能，黑客可以利用它们来获取优势。要执行扫描，请向易受攻击的端点提供一系列内部IP地址，并查看服务器是否对每个地址有不同的响应。例如，当您请求地址10.0.0.1时
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'the server may respond with this message:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能会以以下消息响应：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: But when you request the address 10.0.0.2
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当您请求地址10.0.0.2时
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'the server may respond with this message:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能会以以下消息响应：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can deduce that 10.0.0.1 is the address of a valid host on the network,
    while 10.0.0.2 is not. Using the differences in server behavior, you can gather
    info about the network structure, like the number of reachable hosts and their
    IP addresses.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以推断10.0.0.1是网络上有效主机的地址，而10.0.0.2则不是。通过服务器行为的差异，您可以收集关于网络结构的信息，如可达主机的数量及其IP地址。
- en: You can also use SSRF to port-scan network machines and reveal services running
    on those machines. Open ports provide a good indicator of the services running
    on the machine, because services often run on certain ports by default. For example,
    by default, SSH runs on port 22, HTTP runs on port 80, and HTTPS runs on port
    443\. Port-scan results often point you to the ports that you should inspect manually,
    and they can help you plan further attacks tailored to the services found.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用SSRF对网络机器进行端口扫描并揭示这些机器上运行的服务。开放端口通常是机器上运行服务的良好指示，因为服务通常会在某些默认端口上运行。例如，默认情况下，SSH运行在端口22上，HTTP运行在端口80上，HTTPS运行在端口443上。端口扫描结果通常指向您应手动检查的端口，并且可以帮助您计划进一步针对找到的服务的攻击。
- en: Provide the vulnerable endpoint with different port numbers, and then determine
    if the server behavior differs between ports. It’s the same process as scanning
    for hosts, except this time, switch out port numbers rather than hosts. Port numbers
    range from 0 to 65,535.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 向易受攻击的端点提供不同的端口号，然后确定服务器行为在端口之间是否有差异。这与扫描主机的过程相同，只是这次要更换的是端口号而不是主机。端口号范围从0到65535。
- en: 'Let’s say you want to find out which ports are open on an internal machine.
    When you send a request to port 80 on an internal machine, the server responds
    with this message:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想找出内部机器上开放的端口。当您向内部机器的端口80发送请求时，服务器会以以下消息响应：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And when you send a request to port 11 on the same machine, the machine responds
    with this message:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向同一机器的 11 端口发送请求时，机器会以以下信息作出响应：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can deduce that port 80 is open on the machine, while port 11 is not. You
    can also figure out from the response that the machine is running an Apache web
    server and the Ubuntu Linux distribution. You can use the software information
    revealed here to construct further attacks against the system.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以推测机器的 80 端口是开放的，而 11 端口则没有。你还可以从响应中得知该机器正在运行 Apache Web 服务器和 Ubuntu Linux
    发行版。你可以利用这里揭示的软件信息进一步构造针对系统的攻击。
- en: Pull Instance Metadata
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拉取实例元数据
- en: Cloud computing services allow businesses to run their applications on other
    people’s servers. One such service, Amazon Elastic Compute Cloud (EC2), offers
    an instance metadata tool that enables EC2 instances to access data about themselves
    by querying the API endpoint at 169.254.169.254\. *Instances* are virtual servers
    used for running applications on a cloud provider’s infrastructure. Google Cloud
    offers a similar instance metadata API service.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算服务允许企业在他人的服务器上运行其应用程序。Amazon Elastic Compute Cloud (EC2) 提供了一种实例元数据工具，使 EC2
    实例可以通过查询 API 端点 169.254.169.254 来访问有关自身的数据。*实例* 是用于在云提供商基础设施上运行应用程序的虚拟服务器。Google
    Cloud 提供了类似的实例元数据 API 服务。
- en: These API endpoints are accessible by default unless network admins specifically
    block or disable them. The information these services reveal is often extremely
    sensitive and could allow attackers to escalate SSRFs to serious information leaks
    and even RCE.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 API 端点默认是可访问的，除非网络管理员特别阻止或禁用它们。这些服务揭示的信息通常极其敏感，可能会导致攻击者将 SSRF 升级为严重的信息泄露，甚至远程代码执行（RCE）。
- en: Querying EC2 Metadata
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询 EC2 元数据
- en: 'If a company hosts its infrastructure on Amazon EC2, try querying various instance
    metadata about the host using this endpoint. For example, this API request fetches
    all instance metadata from the running instance:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某公司将其基础设施托管在 Amazon EC2 上，请尝试使用此端点查询有关主机的各种实例元数据。例如，此 API 请求将获取运行中的实例的所有元数据：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use this URL in an endpoint vulnerable to SSRF:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在易受 SSRF 攻击的端点中使用此 URL：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These endpoints reveal information such as API keys, Amazon S3 tokens (tokens
    used to access Amazon S3 buckets), and passwords. Try requesting these especially
    useful API endpoints:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点揭示了如 API 密钥、Amazon S3 令牌（用于访问 Amazon S3 存储桶的令牌）和密码等信息。尝试请求这些特别有用的 API 端点：
- en: '*http://169.254.169.254/latest/meta-data/* returns the list of available metadata
    that you can query.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*http://169.254.169.254/latest/meta-data/* 返回可查询的元数据列表。'
- en: '*http://169.254.169.254/latest/meta-data/local-hostname/* returns the internal
    hostname used by the host.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*http://169.254.169.254/latest/meta-data/local-hostname/* 返回主机使用的内部主机名。'
- en: '*http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME*
    returns the security credentials of that role.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME*
    返回该角色的安全凭证。'
- en: '*http://169.254.169.254/latest/dynamic/instance-identity/document/* reveals
    the private IP address of the current instance.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*http://169.254.169.254/latest/dynamic/instance-identity/document/* 揭示当前实例的私有
    IP 地址。'
- en: '*http://169.254.169.254/latest/user-data/* returns user data on the current
    instance.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*http://169.254.169.254/latest/user-data/* 返回当前实例的用户数据。'
- en: You can find the complete documentation for the API endpoint at[https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)找到该
    API 端点的完整文档。
- en: Querying Google Cloud Metadata
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询 Google Cloud 元数据
- en: 'If the company uses Google Cloud, query the Google Instance Metadata API instead.
    Google implements additional security measures for its API endpoints, so querying
    Google Cloud Metadata APIv1 requires one of these special headers:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公司使用的是 Google Cloud，请改为查询 Google 实例元数据 API。Google 为其 API 端点实施了额外的安全措施，因此查询
    Google Cloud Metadata APIv1 时需要使用以下特殊头部之一：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These headers offer protection against SSRFs because most often during an SSRF,
    you cannot specify special headers for the forged request. But you can easily
    bypass this protection, because most endpoints accessible through APIv1 can be
    accessed via the API v1beta1 endpoints instead. *API v1beta1* is an older version
    of the metadata API that doesn’t have the same header requirements. Begin by targeting
    these critical endpoints:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '*http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token*
    returns the access token of the default account on the instance.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*http://metadata.google.internal/computeMetadata/v1beta1/project/attributes/ssh-keys*
    returns SSH keys that can connect to other instances in this project.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the full API documentation at [https://cloud.google.com/compute/docs/storing-retrieving-metadata/](https://cloud.google.com/compute/docs/storing-retrieving-metadata/).
    Note that the API v1beta1 was deprecated in 2020 and is in the process of being
    shut down. In the future, you might be required to query metadata with APIv1 and
    will need to find a way to forge the required headers to request instance metadata
    for targets that use Google Cloud.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Amazon and Google aren’t the only web services that provide metadata APIs. However,
    these two companies control a large share of the market, so the company you’re
    testing is likely on one of these platforms. If not, DigitalOcean and Kubernetes
    clusters are also vulnerable to the same issue. For DigitalOcean, for example,
    you can retrieve a list of metadata endpoints by visiting the *http://169.254.169.254/metadata/v1/*
    endpoint. You can then retrieve key pieces of information such as the instance’s
    hostname and user data. For Kubernetes, try accessing *https://kubernetes.default*
    and *https://kubernetes.default.svc/metrics* for information about the system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Exploit Blind SSRFs
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because blind SSRFs don’t return a response or error message, their exploitation
    is often limited to network mapping, port scanning, and service discovery. Also,
    since you can’t extract information directly from the target server, this exploitation
    relies heavily on inference. Yet by analyzing HTTP status codes and server response
    times, we can often achieve results similar to regular SSRF.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Network and Port Scanning Using HTTP Status Codes
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember from Chapter 5 that HTTP status codes provide information about whether
    the request succeeded. By comparing the response codes returned for requests to
    different endpoints, we can infer which of them are valid. For example, if a request
    for *https://public.example.com/webhook?url=10.0.0.1* results in an HTTP status
    code of 200, while a request for *https://public.example.com/webhook?url=10.0.0.2*
    results in an HTTP status code of 500, we can deduce that 10.0.0.1 is the address
    of a valid host on the network while 10.0.0.2 is not.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with blind SSRF works the same way. If the server returns a 200
    status code for some ports, and 500 for others, the 200 status code might indicate
    open ports on the machine. On the other hand, if all requests return the same
    status code, the site might have implemented protection against SSRF port scanning.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用盲SSRF进行端口扫描的方式与此类似。如果服务器对某些端口返回200状态码，对其他端口返回500状态码，那么200状态码可能表示机器上的开放端口。另一方面，如果所有请求都返回相同的状态码，说明该站点可能已经实施了针对SSRF端口扫描的保护。
- en: Network and Port Scanning Using Server Response Times
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用服务器响应时间进行网络和端口扫描
- en: If the server isn’t returning any useful information in the form of status codes,
    you might still be able to figure out the network structure by examining how long
    the server is taking to respond to your request. If it takes much longer to respond
    for some addresses, those network addresses might be unrouted or hidden behind
    a firewall. *Unrouted addresses* cannot be reached from the current machine. On
    the other hand, unusually short response times may also indicate an unrouted address,
    because the router might have dropped the request immediately.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器没有返回任何有用的信息（例如状态码），你仍然可以通过检查服务器响应请求所花费的时间来推断网络结构。如果某些地址的响应时间明显较长，这些网络地址可能是未路由的，或者隐藏在防火墙后面。*未路由地址*无法从当前机器访问。另一方面，异常短的响应时间也可能表示一个未路由的地址，因为路由器可能会立即丢弃请求。
- en: When performing any kind of network or port scanning, it is important to remember
    that machines behave differently. The key is to look for differences in behavior
    from the machines on the same network, instead of the specific signatures like
    response times or response codes described previously.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何形式的网络或端口扫描时，重要的是要记住不同的机器表现不同。关键是要寻找同一网络上机器行为的差异，而不是像之前提到的响应时间或响应代码等特定标志。
- en: The target machine might also leak sensitive information in outbound requests,
    such as internal IPs, headers, and version numbers of the software used. If you
    can’t access an internal address, you can always try to provide the vulnerable
    endpoint with the address of a server you own and see what you can extract from
    the incoming request.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 目标机器也可能在出站请求中泄露敏感信息，例如内部IP、头信息和所用软件的版本号。如果你无法访问内部地址，你可以尝试向漏洞端点提供你拥有的服务器地址，看看从传入请求中能提取到什么信息。
- en: Attack the Network
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攻击网络
- en: Use what you’ve found by scanning the network, identifying services, and pulling
    instance metadata to execute attacks that have impact. Notably, you may be able
    to bypass access controls, leak confidential information, and execute code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 利用你通过扫描网络、识别服务以及获取实例元数据找到的信息，执行具有影响力的攻击。特别是，你可能能够绕过访问控制、泄露机密信息并执行代码。
- en: 'First, try to bypass access control. Some internal services might control access
    based on IP addresses or internal headers only, so it might be possible to bypass
    controls to sensitive functionalities by simply sending the request from a trusted
    machine. For example, you might be able to access internal websites by proxying
    through a web server:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试绕过访问控制。一些内部服务可能仅根据IP地址或内部头信息控制访问，因此通过简单地从受信任的机器发送请求，可能绕过对敏感功能的控制。例如，你可能能够通过代理一台Web服务器访问内部网站：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also try to execute internal API calls through the SSRF endpoint. This
    type of attack requires knowledge about the internal system and API syntax, which
    you can obtain by conducting recon and via other information leaks from the system.
    For example, let’s say the API endpoint *admin.example.com/delete_user* deletes
    a user and can only be requested by an internal address. You could trigger the
    request if you find an SSRF that lets you send a request from a machine in the
    trusted network:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试通过SSRF端点执行内部API调用。这种攻击需要对内部系统和API语法有一定了解，你可以通过侦察和系统的其他信息泄露获得这些知识。例如，假设API端点*admin.example.com/delete_user*用于删除用户，且只能通过内部地址请求。如果你发现一个允许从受信任网络中的机器发送请求的SSRF漏洞，你就可以触发该请求：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Second, if you were able to find credentials using the SSRF by leaking info
    via headers or by querying instance metadata, use those credentials to access
    confidential information stored on the network. For example, if you were able
    to find Amazon S3 keys, enumerate the company’s private S3 buckets and see if
    you can access them with the credentials you found.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果你通过头部泄露信息或查询实例元数据，利用 SSRF 找到凭证，使用这些凭证访问网络上存储的机密信息。例如，如果你找到了 Amazon S3 密钥，枚举公司的私有
    S3 存储桶，看看你能否使用找到的凭证访问它们。
- en: Third, use the info you gathered to turn SSRF into remote code execution (which
    you’ll learn more about in Chapter 18). For example, if you found admin credentials
    that give you write privileges, try uploading a shell to the web server. Or, if
    you found an unsecured admin panel, see if any features allow the execution of
    scripts. You can also use either classic or blind SSRF to test for other vulnerabilities
    on the target’s network by sending payloads designed to detect well-known vulnerabilities
    to reachable machines.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，利用你收集到的信息，将 SSRF 转变为远程代码执行（你将在第 18 章中学习更多内容）。例如，如果你找到了具有写入权限的管理员凭证，尝试向 Web
    服务器上传一个 shell。或者，如果你发现了一个没有安全保护的管理员面板，看看是否有任何功能允许执行脚本。你还可以使用经典或盲 SSRF 测试目标网络中的其他漏洞，通过发送专门检测已知漏洞的有效负载到可访问的机器。
- en: Finding Your First SSRF!
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到你的第一个 SSRF！
- en: 'Let’s review the steps you can take to find your first SSRF:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你可以采取的步骤，找到你的第一个 SSRF：
- en: Spot the features prone to SSRFs and take notes for future reference.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别易受 SSRF 攻击的特性并做好记录，以备将来参考。
- en: Set up a callback listener to detect blind SSRFs by using an online service,
    Netcat, or Burp’s Collaborator feature.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个回调监听器，使用在线服务、Netcat 或 Burp 的 Collaborator 功能来检测盲 SSRF。
- en: Provide the potentially vulnerable endpoints with common internal addresses
    or the address of your callback listener.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向潜在易受攻击的端点提供常见的内部地址或你的回调监听器地址。
- en: Check if the server responds with information that confirms the SSRF. Or, in
    the case of a blind SSRF, check your server logs for requests from the target
    server.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查服务器是否响应了确认 SSRF 的信息，或者在盲 SSRF 的情况下，检查你的服务器日志中是否有来自目标服务器的请求。
- en: In the case of a blind SSRF, check if the server behavior differs when you request
    different hosts or ports.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于盲 SSRF，检查在请求不同的主机或端口时，服务器行为是否有所不同。
- en: If SSRF protection is implemented, try to bypass it by using the strategies
    discussed in this chapter.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果实施了 SSRF 保护，尝试使用本章讨论的策略绕过它。
- en: Pick a tactic to escalate the SSRF.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一种策略来升级 SSRF。
- en: Draft your first SSRF report!
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撰写你的第一个 SSRF 报告！
