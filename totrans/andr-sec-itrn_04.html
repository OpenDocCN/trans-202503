<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;User Management"><div class="titlepage"><div><div><h1 class="title"><a id="user_management"/>Chapter 4. User Management</h1></div></div></div><p><a id="iddle2254" class="indexterm"/><a id="iddle3018" class="indexterm"/>Android originally targeted personal devices such as smartphones and assumed that each device had only one user. With the increase in popularity of tablets and other shared devices, multi-user support was added in version 4.2 and extended in later versions.</p><p>In this chapter, we’ll discuss how Android manages users who share devices and data. We begin with a look at the types of users Android supports and how it stores user metadata. We then discuss how Android shares installed applications between users while isolating application data and keeping it private to each user. Finally, we cover how Android implements isolated external storage.</p><div class="sect1" title="Multi-User Support Overview"><div class="titlepage"><div><div><h1 class="title"><a id="multi-user_support_overview"/>Multi-User Support Overview</h1></div></div></div><p>Android’s multi-user support allows multiple users to share a single device by providing each user with an isolated, personal environment. Each user <a id="iddle1414" class="indexterm"/><a id="iddle2965" class="indexterm"/><a id="iddle3023" class="indexterm"/>can have their own home screen, widgets, apps, online accounts, and files that are not accessible to other users.</p><p>Users are identified by a unique <span class="emphasis"><em>user ID</em></span> (not to be confused with Linux UIDs) and only the system can switch between users. User switching is normally triggered by selecting a user from the Android lockscreen and (optionally) authenticating using a pattern, PIN, password, and so on (see <a class="xref" href="ch10.html" title="Chapter 10. Device Security">Chapter 10</a>). Applications can get information about the current user via the <code class="literal">UserManager</code> API, but typically code modification is not required in order to support a multi-user environment. Applications that need to modify their behavior when used by a restricted profile are an exception: these applications require additional code that checks what restrictions (if any) are imposed on the current user (see “<a class="xref" href="ch04.html#restricted_profiles" title="Restricted Profiles">Restricted Profiles</a>” for details).</p><p>Multi-user support is built into the core Android platform and is thus available on all devices that run Android 4.2 or later. However, the default platform configuration only allows for a single user, which effectively disables multi-user support. In order to enable support for multiple users, the <span class="emphasis"><em>config_multiuserMaximumUsers</em></span> system resource must be set to a value greater than one, typically by adding a device-specific overlay configuration file. For example, on the Nexus 7 (2013), the overlay is placed in the <span class="emphasis"><em>device/ asus/flo/overlay/frameworks/base/core/res/res/values/config.xml</em></span> file and the <span class="emphasis"><em>config_multiuserMaximumUsers</em></span> setting is defined as shown in <a class="xref" href="ch04.html#enabling_multi-user_support_with_a_resou" title="Example 4-1. Enabling multi-user support with a resource overlay file">Example 4-1</a>, to allow a maximum of eight users.</p><div class="example"><a id="enabling_multi-user_support_with_a_resou"/><p class="title">Example 4-1. Enabling multi-user support with a resource overlay file</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources &gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;!-- Maximum number of supported users --&gt;
    &lt;integer name="config_multiuserMaximumUsers"&gt;8&lt;/integer&gt;
    --<span class="emphasis"><em>snip</em></span>--
&lt;/resources&gt;</pre></div></div><div class="note" title="Note"><h3 class="title"><a id="ch04note01"/>Note</h3><p><span class="emphasis"><em>The Android Compatibility Definition requires that devices that support telephony (such as mobile phones) must not enable multi-user support because “the behavior of the telephony APIs on devices with multiple users is currently undefined.”</em></span><sup>[<a id="ch04fn01" href="#ftn.ch04fn01" class="footnote">29</a>]</sup> <span class="emphasis"><em>Therefore, in current production builds, all handsets are configured as single-user devices.</em></span></p></div><p>When multi-user support is enabled, the system Settings application displays a Users entry that allows the device owner (the first user created, as discussed in the next section) to create and manage users. The user management screen is shown in <a class="xref" href="ch04.html#user_management_screen" title="Figure 4-1. User management screen">Figure 4-1</a>.</p><div class="figure"><a id="user_management_screen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00009"/><img src="figs/web/04fig01.png.jpg" alt="User management screen"/></div></div><p class="title">Figure 4-1. User management screen</p></div><p>As soon as more than one user has been created, the lockscreen shows a user widget that displays the current users and allows switching to a different user. <a class="xref" href="ch04.html#lockscreen_with_user_switcher_widget" title="Figure 4-2. Lockscreen with user switcher widget">Figure 4-2</a> shows how the lockscreen might look on a device with eight users.</p><div class="figure"><a id="lockscreen_with_user_switcher_widget"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00010"/><img src="figs/web/04fig02.png.jpg" alt="Lockscreen with user switcher widget"/></div></div><p class="title">Figure 4-2. Lockscreen with user switcher widget</p></div></div><div class="sect1" title="Types of Users"><div class="titlepage"><div><div><h1 class="title"><a id="types_of_users"/>Types of Users</h1></div></div></div><p><a id="iddle2156" class="indexterm"/><a id="iddle2257" class="indexterm"/><a id="iddle2511" class="indexterm"/><a id="iddle3020" class="indexterm"/>Even though Android lacks the full user management features of most multi-user operating systems, which typically allow users to add multiple administrators and define user groups, it does support configuring user types with different privileges. Each user type and its privileges will be described in the following sections.</p><div class="sect2" title="The Primary User (Owner)"><div class="titlepage"><div><div><h2 class="title"><a id="primary_user_left_parenthesisownerright"/>The Primary User (Owner)</h2></div></div></div><p>The <span class="emphasis"><em>primary user</em></span>, also known as the device <span class="emphasis"><em>owner</em></span>, is the first user created on a multi-user device, or the sole user on single-user devices. The owner is created by default and is always present. The primary user is assigned user ID 0. On single-user devices where the primary user is the only user, Android behaves much like previous versions that lacked multi-user support: directories and UIDs assigned to installed applications maintain <a id="iddle2259" class="indexterm"/><a id="iddle2675" class="indexterm"/><a id="iddle2838" class="indexterm"/><a id="iddle2916" class="indexterm"/><a id="iddle2973" class="indexterm"/><a id="iddle3022" class="indexterm"/><a id="iddle3083" class="indexterm"/><a id="iddle3111" class="indexterm"/><a id="iddle3122" class="indexterm"/>the same format and permissions as in previous versions (see “<a class="xref" href="ch04.html#user_management-id00008" title="User Management">User Management</a>” and “<a class="xref" href="ch04.html#application_sharing" title="Application Sharing">Application Sharing</a>” for details).</p><p>The primary user is assigned all privileges and can create and delete other users, as well as change system settings that affect all users, including settings related to device security, network connectivity, and application management. Device and user management privileges are granted to the primary user by showing the respective settings screens in system settings and hiding them from other users. Additionally, the underlying system services check the identity of the calling user before performing operations that can affect all users, and only allow execution when called by the device owner.</p><p>As of Android version 4.4, the following screens in the Wireless and Networks section of system settings are displayed to only the primary user:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Cell broadcasts</p></li><li class="listitem"><p>Manage mobile plan</p></li><li class="listitem"><p>Mobile network</p></li><li class="listitem"><p>Tethering and portable hotspot</p></li><li class="listitem"><p>VPN</p></li><li class="listitem"><p>WiMAX (shown if supported by the device)</p></li></ul></div><p>The following screens in the Security section are also reserved for the primary user:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Device encryption</p></li><li class="listitem"><p>SIM card lock</p></li><li class="listitem"><p>Unknown sources (controls app sideloading; see <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>)</p></li><li class="listitem"><p>Verify apps (controls package verification; see <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>)</p></li></ul></div></div><div class="sect2" title="Secondary Users"><div class="titlepage"><div><div><h2 class="title"><a id="secondary_users"/>Secondary Users</h2></div></div></div><p>With the exception of restricted profiles (discussed in the next section), all added users are <span class="emphasis"><em>secondary users</em></span>. Each gets a dedicated user directory (see “<a class="xref" href="ch04.html#user_management-id00008" title="User Management">User Management</a>”), their own list of installed apps, and private data directories for each installed app.</p><p>Secondary users cannot add or manage users; they can only set their own username via the Users screen (see <a class="xref" href="ch04.html#user_management_screen" title="Figure 4-1. User management screen">Figure 4-1</a>). Additionally, they cannot perform any privileged operation reserved for the primary user as listed in the previous sections. Otherwise, secondary users can perform all the operations that a primary user can, including installing and using applications, and changing the system appearance and settings.</p><p>Although secondary users are restricted, their actions can still affect device behavior and other users. For example, they can add and connect to a new Wi-Fi network. Because Wi-Fi connectivity state is shared across the system, switching to a different user does not reset the wireless connection, and that user will be connected to the wireless network selected by the previous <a id="iddle1126" class="indexterm"/><a id="iddle1186" class="indexterm"/><a id="iddle1286" class="indexterm"/><a id="iddle1620" class="indexterm"/><a id="iddle1621" class="indexterm"/><a id="iddle1622" class="indexterm"/><a id="iddle1623" class="indexterm"/><a id="iddle1625" class="indexterm"/><a id="iddle1626" class="indexterm"/><a id="iddle1628" class="indexterm"/><a id="iddle1629" class="indexterm"/><a id="iddle1631" class="indexterm"/><a id="iddle1633" class="indexterm"/><a id="iddle2148" class="indexterm"/><a id="iddle2258" class="indexterm"/><a id="iddle2268" class="indexterm"/><a id="iddle2309" class="indexterm"/><a id="iddle2612" class="indexterm"/><a id="iddle2974" class="indexterm"/><a id="iddle2987" class="indexterm"/><a id="iddle3021" class="indexterm"/><a id="iddle3112" class="indexterm"/>user. Secondary users can also toggle airplane mode and NFC, and change the global sound and display settings. Most importantly, as application packages are shared across all users (as discussed in “<a class="xref" href="ch04.html#application_sharing" title="Application Sharing">Application Sharing</a>”), if a secondary user updates an application that adds new permissions, permissions are granted to the application without requiring the consent of other users, and other users are not notified of permission changes.</p></div><div class="sect2" title="Restricted Profiles"><div class="titlepage"><div><div><h2 class="title"><a id="restricted_profiles"/>Restricted Profiles</h2></div></div></div><p>Unlike secondary users, restricted profiles (added in Android 4.3) are based on the primary user and share its applications, data, and accounts, with certain restrictions. As such, the primary user must set up a lockscreen password in order to protect their data. If no lockscreen password is in place when the primary user creates a restricted profile, Android prompts them to set up one.</p><div class="sect3" title="User Restrictions"><div class="titlepage"><div><div><h3 class="title"><a id="user_restrictions"/>User Restrictions</h3></div></div></div><p>Android defines the following default restrictions in order to control what users are allowed to do. All restrictions are <code class="literal">false</code> by default. The list below shows their value for restricted users in parentheses.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="DISALLOW_CONFIG_BLUETOOTH"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_CONFIG_BLUETOOTH</code></strong></span></strong></span>. Specifies whether a user is prevented from configuring Bluetooth. (default: <code class="literal">false</code>)</p></li><li class="listitem"><p title="DISALLOW_CONFIG_CREDENTIALS"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_CONFIG_CREDENTIALS</code></strong></span></strong></span>. Specifies whether a user is prevented from configuring user credentials. When this restriction is set to <code class="literal">true</code>, restricted profiles cannot add trusted CA certificates or import private keys into the system credential store; see <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a> and <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a> for details. (default: <code class="literal">false</code>)</p></li><li class="listitem"><p title="DISALLOW_CONFIG_WIFI"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_CONFIG_WIFI</code></strong></span></strong></span>. Specifies whether a user is prevented from changing Wi-Fi access points. (default: <code class="literal">false</code>)</p></li><li class="listitem"><p title="DISALLOW_INSTALL_APPS"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_INSTALL_APPS</code></strong></span></strong></span>. Specifies whether a user is prevented from installing applications. (default: <code class="literal">false</code>)</p></li><li class="listitem"><p title="DISALLOW_INSTALL_UNKNOWN_SOURCES"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_INSTALL_UNKNOWN_SOURCES</code></strong></span></strong></span>. Specifies whether a user is prevented from enabling the Unknown sources setting (see <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>). (default: <code class="literal">false</code>)</p></li><li class="listitem"><p title="DISALLOW_MODIFY_ACCOUNTS"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_MODIFY_ACCOUNTS</code></strong></span></strong></span>. Specifies whether a user is prevented from adding and removing accounts. (default: <code class="literal">true</code>)</p></li><li class="listitem"><p title="DISALLOW_REMOVE_USER"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_REMOVE_USER</code></strong></span></strong></span>. Specifies whether a user is prevented from removing users. (default: <code class="literal">false</code>)</p></li><li class="listitem"><p title="DISALLOW_SHARE_LOCATION"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_SHARE_LOCATION</code></strong></span></strong></span>. Specifies whether a user is prevented from toggling location sharing. (default: <code class="literal">true</code>)</p></li><li class="listitem"><p title="DISALLOW_UNINSTALL_APPS"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_UNINSTALL_APPS</code></strong></span></strong></span>. Specifies whether a user is prevented from uninstalling applications. (default: <code class="literal">false</code>)</p></li><li class="listitem"><p title="DISALLOW_USB_FILE_TRANSFER"><span class="title"><strong><span class="strong"><strong><code class="literal">DISALLOW_USB_FILE_TRANSFER</code></strong></span></strong></span>. Specifies whether a user is prevented from transferring files over USB. (default: <code class="literal">false</code>)</p></li></ul></div></div><div class="sect3" title="Applying Restrictions"><div class="titlepage"><div><div><h3 class="title"><a id="applying_restrictions"/>Applying Restrictions</h3></div></div></div><p><a id="iddle1624" class="indexterm"/><a id="iddle1630" class="indexterm"/><a id="iddle1632" class="indexterm"/><a id="iddle1967" class="indexterm"/><a id="iddle2611" class="indexterm"/>At runtime, applications can use the <code class="literal">UserManager.getUserRestrictions()</code> method to get a <code class="literal">Bundle</code> (a universal container class that maps string keys to various value types) containing the restrictions imposed on a user. Restrictions are defined as key-value pairs, where the key is the restriction name and the Boolean value specifies whether it is in effect. Applications can use that value in order to disable certain functionality when running within a restricted profile. For example, the system Settings app checks the value of the <code class="literal">DISALLOW_SHARE_LOCATION</code> restriction when displaying location preferences. If the value is <code class="literal">true</code>, it disables the location mode setting. Another example is the <code class="literal">PackageManagerService</code>: it checks the <code class="literal">DISALLOW_INSTALL_APPS</code> and <code class="literal">DISALLOW_UNINSTALL_APPS</code> restrictions before installing or uninstalling apps and returns the <code class="literal">INSTALL_FAILED_USER_RESTRICTED</code> error code if any of those restrictions are set to <code class="literal">true</code> for the calling user.</p><p>The primary user can select which applications will be available to a restricted profile. When a restricted profile is created, all installed applications are initially disabled, and the owner must explicitly enable the ones that they want to make available to the restricted profile (see <a class="xref" href="ch04.html#restricted_profile_management_screen" title="Figure 4-3. Restricted profile management screen">Figure 4-3</a>).</p><div class="figure"><a id="restricted_profile_management_screen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00011"/><img src="figs/web/04fig03.png.jpg" alt="Restricted profile management screen"/></div></div><p class="title">Figure 4-3. Restricted profile management screen</p></div><p><a id="iddle1043" class="indexterm"/><a id="iddle1060" class="indexterm"/><a id="iddle1854" class="indexterm"/><a id="iddle1916" class="indexterm"/><a id="iddle2256" class="indexterm"/><a id="iddle2608" class="indexterm"/><a id="iddle2610" class="indexterm"/><a id="iddle3019" class="indexterm"/>In addition to the built-in restrictions defined by the OS, applications can define custom restrictions by creating a <code class="literal">BroadcastReceiver</code> that receives the <code class="literal">ACTION_GET_RESTRICTION_ENTRIES</code> intent. Android invokes this intent to query all apps for available restrictions and automatically builds a UI that allows device owners to toggle the app’s custom restrictions.</p><p>At runtime, applications can use the <code class="literal">UserManager.getApplicationRestrictions()</code> method to obtain a <code class="literal">Bundle</code> that contains saved restrictions as key-value pairs. The application can then disable or modify certain features based on the applied restrictions. The device owner can toggle system and custom restrictions on the same settings screen used to manage applications available to a restricted profile. For example, in <a class="xref" href="ch04.html#restricted_profile_management_screen" title="Figure 4-3. Restricted profile management screen">Figure 4-3</a>, the single application restriction supported by the Settings app (whether to let apps use location information) is shown below the main application toggle.</p></div><div class="sect3" title="Access to Online Accounts"><div class="titlepage"><div><div><h3 class="title"><a id="access_to_online_accounts"/>Access to Online Accounts</h3></div></div></div><p>Restricted profiles can also access the online accounts of the primary user via the <code class="literal">AccountManager</code> API (see <a class="xref" href="ch08.html" title="Chapter 8. Online Account Management">Chapter 8</a>), but this access is disabled by default. Applications that need access to accounts when running within a restricted profile must explicitly declare the account types they require using the <code class="literal">restrictedAccountType</code> attribute of the <code class="literal">&lt;application&gt;</code> tag, as shown in <a class="xref" href="ch04.html#allowing_access_to_the_ownerapostrophes" title="Example 4-2. Allowing access to the owner’s accounts from a restricted profile">Example 4-2</a>.</p><div class="example"><a id="allowing_access_to_the_ownerapostrophes"/><p class="title">Example 4-2. Allowing access to the owner’s accounts from a restricted profile</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.example.app" ...&gt;
    &lt;application android:restrictedAccountType="com.google" ... &gt;
        --<span class="emphasis"><em>snip</em></span>--
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div><p>On the other hand, applications that do not want to expose account information to restricted profiles can declare this by specifying the account type (an asterisk can be used to match all account types) as the value of the <code class="literal">requiredAccountType</code> attribute of the <code class="literal">&lt;application&gt;</code> tag. If the <code class="literal">requiredAccountType</code> attribute is specified, Android will automatically disable such applications for restricted profiles. For example, because the Android Calendar application declares <code class="literal">android:requiredAccountType="*"</code> in its manifest, it cannot be made available to restricted profiles and is disabled in the restrictions settings screen (see <a class="xref" href="ch04.html#restricted_profile_management_screen" title="Figure 4-3. Restricted profile management screen">Figure 4-3</a>).</p></div></div><div class="sect2" title="Guest User"><div class="titlepage"><div><div><h2 class="title"><a id="guest_user"/>Guest User</h2></div></div></div><p>Android supports a single guest user, but this functionality is disabled by default. While the guest user can be enabled by calling the <code class="literal">UserManager.setGuestEnabled()</code> method, the guest user does not appear to be referenced anywhere other than by the <code class="literal">UserManager</code> and related classes in current <a id="iddle1303" class="indexterm"/><a id="iddle2185" class="indexterm"/><a id="iddle2244" class="indexterm"/><a id="iddle2245" class="indexterm"/><a id="iddle2401" class="indexterm"/><a id="iddle2500" class="indexterm"/><a id="iddle2501" class="indexterm"/><a id="iddle2504" class="indexterm"/><a id="iddle3008" class="indexterm"/><a id="iddle3009" class="indexterm"/><a id="iddle3024" class="indexterm"/>Android versions. Code comments indicate that the guest user might be transient, but as of this writing its exact purpose is not clear. It appears to be a remnant of a proposed feature that was rejected or never fully implemented.</p></div></div><div class="sect1" title="User Management"><div class="titlepage"><div><div><h1 class="title"><a id="user_management-id00008"/>User Management</h1></div></div></div><p>Android users are managed by the <code class="literal">UserManagerService</code>, which is responsible for reading and persisting user information and maintaining the list of active users. Because user management is closely related to package management, the <code class="literal">PackageManagerService</code> calls the <code class="literal">UserManagerService</code> to query or modify users when packages are installed or removed. The <code class="literal">android.os.UserManager</code> class provides a facade to the <code class="literal">UserManagerService</code> and exposes a subset of its functionality to third-party applications. Applications can get the number of users on a system, a user’s serial number, the name and list of restrictions for the current user, as well as the list of restrictions for a package without the need for any special permissions. All other user operations, including querying, adding, removing, or modifying users, require the <code class="literal">MANAGE_USERS</code> system signature permission.</p><div class="sect2" title="Command-Line Tools"><div class="titlepage"><div><div><h2 class="title"><a id="command-line_tools"/>Command-Line Tools</h2></div></div></div><p>User management operations can also be performed on the Android shell with the <code class="literal">pm</code> command. These commands can be run via the shell without root permissions, because the <span class="emphasis"><em>shell</em></span> user (UID 2000) is granted the <code class="literal">MANAGE_USERS</code> permission. You can use the <code class="literal">pm create-user</code> command to create a new user, and the <code class="literal">pm remove-user</code> to remove it. The command <code class="literal">pm get-max-users</code> returns the maximum number of users supported by the OS, and <code class="literal">pm list users</code> lists all users. The output of the <code class="literal">pm list users</code> command might look like <a class="xref" href="ch04.html#listing_users_using_the_pm_list_command" title="Example 4-3. Listing users using the pm list command">Example 4-3</a> on a device with five users. The numbers in curly braces are the user ID, name, and flags, in that order.</p><div class="example"><a id="listing_users_using_the_pm_list_command"/><p class="title">Example 4-3. Listing users using the <code class="literal">pm list</code> command</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>pm list users</strong></span>
Users:
        UserInfo{0:Owner:13}
        UserInfo{10:User1:10}
        UserInfo{11:User2:10}
        UserInfo{12:User3:10}
        UserInfo{13:Profile1:18}</pre></div></div></div><div class="sect2" title="User States and Related Broadcasts"><div class="titlepage"><div><div><h2 class="title"><a id="user_states_and_related_broadcasts"/>User States and Related Broadcasts</h2></div></div></div><p>The <code class="literal">UserManagerService</code> sends several broadcasts to notify other components of user-related events. When a user is added, it sends the <code class="literal">USER_ADDED</code> broadcast, and when a user is removed, it sends <code class="literal">USER_REMOVED</code>. If the user-name or their profile icon is changed, the <code class="literal">UserManagerService</code> sends the <a id="iddle1975" class="indexterm"/><a id="iddle1977" class="indexterm"/><a id="iddle2133" class="indexterm"/><a id="iddle2163" class="indexterm"/><a id="iddle2251" class="indexterm"/><a id="iddle3014" class="indexterm"/><a id="iddle3025" class="indexterm"/><a id="iddle3026" class="indexterm"/><a id="iddle3028" class="indexterm"/><a id="iddle3029" class="indexterm"/><code class="literal">USER_INFO_CHANGED</code> broadcast. Switching users triggers the <code class="literal">USER_BACKGROUND</code>, <code class="literal">USER_FOREGROUND</code>, and <code class="literal">USER_SWITCHED</code> broadcasts, all of which contain the relevant user ID as an extra.</p><p>While Android supports a maximum of eight users, only three users can be running at a time. A user is started when it is first switched to via the lockscreen user switcher. Android stops inactive users based on a least recently used (LRU) cache algorithm to ensure that no more than three users are active.</p><p>When a user is stopped, its processes are killed and it no longer receives any broadcasts. When users are started or stopped, the system sends the <code class="literal">USER_STARTING</code>, <code class="literal">USER_STARTED</code>, <code class="literal">USER_STOPPING</code>, and <code class="literal">USER_STOPPED</code> broadcasts. The primary user is started automatically when the system boots and is never stopped.</p><p>Starting, stopping, and switching users, as well as targeting a specific user with a broadcast, requires the <code class="literal">INTERACT_ACROSS_USERS</code> permission. This is a system permission with signature protection, but it also has the <code class="literal">development</code> flag set (see <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>) so it can be dynamically granted to non-system applications that declare it (using the <code class="literal">pm grant</code> command). The <code class="literal">INTERACT_ACROSS_USERS_FULL</code> signature permission allows sending broadcasts to all users, changing the device administrator, as well as other privileged operations that affect all users.</p></div></div><div class="sect1" title="User Metadata"><div class="titlepage"><div><div><h1 class="title"><a id="user_metadata"/>User Metadata</h1></div></div></div><p>Android stores user data in the <span class="emphasis"><em>/data/system/users/</em></span> directory that hosts metadata about users in XML format, as well as user directories. On a device with five users, its contents may look like <a class="xref" href="ch04.html#contents_of_solidusdatasolidussystemsoli" title="Example 4-4. Contents of /data/system/users/">Example 4-4</a> (timestamps have been omitted).</p><div class="example"><a id="contents_of_solidusdatasolidussystemsoli"/><p class="title">Example 4-4. Contents of <span class="roman">/data/system/users/</span></p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -lF /data/system/users</strong></span>
drwx------ system   system                0➊
-rw------- system   system            230 0.xml➋
drwx------ system   system                10
-rw------- system   system            245 10.xml
drwx------ system   system                11
-rw------- system   system            245 11.xml
drwx------ system   system                12
-rw------- system   system            245 12.xml
drwx------ system   system                13
-rw------- system   system            299 13.xml
-rw------- system   system            212 userlist.xml➌</pre></div></div><div class="sect2" title="The User List File"><div class="titlepage"><div><div><h2 class="title"><a id="user_list_file"/>The User List File</h2></div></div></div><p>As shown in <a class="xref" href="ch04.html#contents_of_solidusdatasolidussystemsoli" title="Example 4-4. Contents of /data/system/users/">Example 4-4</a>, each user has a dedicated directory called the <span class="emphasis"><em>user system directory</em></span> with a name that matches the assigned user ID (➊ for <a id="iddle2252" class="indexterm"/><a id="iddle2294" class="indexterm"/><a id="iddle3004" class="indexterm"/><a id="iddle3015" class="indexterm"/><a id="iddle3070" class="indexterm"/>the primary user) and an XML file that stores metadata about the user, again with a filename based on the user ID (➋ for the primary user). The <span class="emphasis"><em>userlists.xml</em></span> file ➌ holds data about all users created on a system and may look like <a class="xref" href="ch04.html#contents_of_userlistdotxml" title="Example 4-5. Contents of userlist.xml">Example 4-5</a> on a system with five users.</p><div class="example"><a id="contents_of_userlistdotxml"/><p class="title">Example 4-5. Contents of <span class="roman">userlist.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;users nextSerialNumber="19" version="4"&gt;
    &lt;user id="0" /&gt;
    &lt;user id="10" /&gt;
    &lt;user id="11" /&gt;
    &lt;user id="12" /&gt;
    &lt;user id="13" /&gt;
&lt;/users&gt;</pre></div></div><p>The file format is basically a list of <code class="literal">&lt;user&gt;</code> tags holding the ID assigned to each user. The root <code class="literal">&lt;users&gt;</code> element has a <code class="literal">version</code> attribute specifying the current file version and a <code class="literal">nextSerialNumber</code> attribute holding the serial number to be assigned to the next user. The primary user is always assigned user ID 0.</p><p>The fact that UIDs assigned to applications are based on the user ID of the owning user ensures that on single-user devices, UIDs assigned to applications are the same as they were before multi-user support was introduced. (For more on application UIDs, see “<a class="xref" href="ch04.html#application_data_directories" title="Application Data Directories">Application Data Directories</a>”.) Secondary users and restricted profiles are assigned IDs beginning with the number 10.</p></div><div class="sect2" title="User Metadata Files"><div class="titlepage"><div><div><h2 class="title"><a id="user_metadata_files"/>User Metadata Files</h2></div></div></div><p>The attributes of each user are stored in a dedicated XML file. <a class="xref" href="ch04.html#user_metadata_file_contents" title="Example 4-6. User metadata file contents">Example 4-6</a> shows an example for a restricted profile.</p><div class="example"><a id="user_metadata_file_contents"/><p class="title">Example 4-6. User metadata file contents</p><div class="example-contents"><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;
&lt;user id="13"
      serialNumber="18"
      flags="24"
      created="1394551856450"
      lastLoggedIn="1394551882324"
      icon="/data/system/users/13/photo.png"&gt;➊
    &lt;name&gt;Profile1&lt;/name&gt;➋
    &lt;restrictions no_modify_accounts="true" no_share_location="true" /&gt;➌
&lt;/user&gt;</pre></div></div><p>Here, the <code class="literal">&lt;name&gt;</code> tag ➋ holds the user’s name and the <code class="literal">&lt;restrictions&gt;</code> tag ➌ has attributes for each enabled restriction. (See “<a class="xref" href="ch04.html#restricted_profiles" title="Restricted Profiles">Restricted Profiles</a>” for a list of built-in restrictions.) <a class="xref" href="ch04.html#less_thanusergreater_than_element_attrib" title="Table 4-1. &lt;user&gt; Element Attributes">Table 4-1</a> summarizes the attributes of the root <code class="literal">&lt;user&gt;</code> element shown at ➊ in <a class="xref" href="ch04.html#user_metadata_file_contents" title="Example 4-6. User metadata file contents">Example 4-6</a>.</p><div class="table"><a id="less_thanusergreater_than_element_attrib"/><p class="title">Table 4-1. &lt;user&gt; Element Attributes</p><div class="table-contents"><table summary="&lt;user&gt; Element Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1429" class="indexterm"/><a id="iddle1788" class="indexterm"/><a id="iddle1812" class="indexterm"/><a id="iddle1816" class="indexterm"/><a id="iddle1817" class="indexterm"/><a id="iddle1818" class="indexterm"/><a id="iddle1819" class="indexterm"/><a id="iddle1821" class="indexterm"/><a id="iddle1944" class="indexterm"/><a id="iddle1945" class="indexterm"/><a id="iddle2131" class="indexterm"/><a id="iddle2132" class="indexterm"/><a id="iddle2419" class="indexterm"/><a id="iddle2478" class="indexterm"/><a id="iddle2647" class="indexterm"/><a id="iddle2760" class="indexterm"/>Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Format</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">id</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>integer</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>User ID</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">serialNumber</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>integer</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>User serial number</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">flags</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>integer</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Flags that indicate the type of user</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">created</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>milliseconds since the Unix epoch, as per <code class="literal">System.currentTimeMillis()</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>User creation time</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">lastLoggedIn</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>milliseconds since the Unix epoch, as per <code class="literal">System.currentTimeMillis()</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Last login time</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">icon</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>string</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Full path to the user icon file</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">partial</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Boolean</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Indicates that the user is partially initialized. Partial users may not have all of their files and directories created yet.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">pinHash</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>hexadecimal string</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The salted SHA1+MD5 PIN hash for PIN-protected restrictions</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">salt</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>long integer</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The PIN salt for PIN-protected restrictions</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">failedAttempts</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>integer</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The number of failed PIN entry attempts for PIN-protected restrictions</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">lastAttemptMs</code></p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>milliseconds since the Unix epoch, as per <code class="literal">System.currentTimeMillis()</code></p></td><td style="" valign="top"><p>The time of the last PIN entry attempt for PIN-protected restrictions (in milliseconds since the Unix epoch, per <code class="literal">System.currentTimeMillis()</code>)</p></td></tr></tbody></table></div></div><p>The <code class="literal">flags</code> attribute is one of the most important as it determines the user type. As of this writing, six bits of the flag value are used for the user type and the rest are reserved with the following flags currently defined:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong><code class="literal">FLAG_PRIMARY</code> (0x00000001)</strong></span> Marks the primary user.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">FLAG_ADMIN</code> (0x00000002)</strong></span> Marks administrator users. Administrator can create and delete users.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">FLAG_GUEST</code> (0x00000004)</strong></span> Marks the guest user.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">FLAG_RESTRICTED</code> (0x00000008)</strong></span> Marks restricted users.</p></li><li class="listitem"><p><span class="strong"><strong><code class="literal">FLAG_INITIALIZED</code> (0x00000010)</strong></span> Marks a user as fully initialized.</p></li></ul></div><p>While different flag combinations are possible, most combinations don’t represent a valid user type or state, and in practice the attributes for the primary owner are set to 19 (0x13 or <code class="literal">FLAG_INITIALIZED|FLAG_ADMIN|FLAG_PRIMARY</code>), secondary users have flags 16 (0x10 or <code class="literal">FLAG_INITIALIZED</code>), and restricted profiles have flags 24 (0x18 or <code class="literal">FLAG_INITIALIZED|FLAG_RESTRICTED</code>).</p></div><div class="sect2" title="User System Directory"><div class="titlepage"><div><div><h2 class="title"><a id="user_system_directory"/>User System Directory</h2></div></div></div><p><a id="iddle1056" class="indexterm"/><a id="iddle1194" class="indexterm"/><a id="iddle1564" class="indexterm"/><a id="iddle2243" class="indexterm"/><a id="iddle2253" class="indexterm"/><a id="iddle2409" class="indexterm"/><a id="iddle2856" class="indexterm"/><a id="iddle3007" class="indexterm"/><a id="iddle3016" class="indexterm"/>Each user system directory contains user-specific system settings and data but no application data. As we’ll see in the next section, each application that a user installs gets a dedicated data directory under <span class="emphasis"><em>/data</em></span>, much like on single-user devices. (See <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a> for more on application data directories.) For example, in the case of a secondary user with user ID 12, the user system directory would be named <span class="emphasis"><em>/data/system/users/12/</em></span> and might contain the files and directories listed in <a class="xref" href="ch04.html#contents_of_a_user_directory" title="Example 4-7. Contents of a user directory">Example 4-7</a>.</p><div class="example"><a id="contents_of_a_user_directory"/><p class="title">Example 4-7. Contents of a user directory</p><div class="example-contents"><pre class="programlisting">- accounts.db➊
- accounts.db-journal
- appwidgets.xml➋
- device_policies.xml➌
- gesture.key➍
d inputmethod➎
- package-restrictions.xml➏
- password.key➐
- photo.png➑
- settings.db➒
- settings.db-journal
- wallpaper➓
- wallpaper_info.xml</pre></div></div><p>The file <span class="emphasis"><em>accounts.db</em></span> ➊ is an SQLite database that holds online account details. (We discuss online account management in <a class="xref" href="ch08.html" title="Chapter 8. Online Account Management">Chapter 8</a>.) The file <span class="emphasis"><em>appwidgets.xml</em></span> ➋ holds information about widgets that the user has added to their home screen. The <span class="emphasis"><em>device_policies.xml</em></span> ➌ file describes the current device policy (see <a class="xref" href="ch09.html" title="Chapter 9. Enterprise Security">Chapter 9</a> for details), and <span class="emphasis"><em>gesture.key</em></span> ➍ and <span class="emphasis"><em>password.key</em></span> ➐ contain the hash of the currently selected lockscreen pattern or PIN/password, respectively (see <a class="xref" href="ch10.html" title="Chapter 10. Device Security">Chapter 10</a> for format details).</p><p>The <span class="emphasis"><em>inputmethod</em></span> directory ➎ contains information about input methods. The <span class="emphasis"><em>photo.png</em></span> file ➑ stores the user’s profile image or picture. The file <span class="emphasis"><em>settings.db</em></span> ➒ holds system settings specific to that user, and <span class="emphasis"><em>wallpaper</em></span> ➓ is the currently selected wallpaper image. The <span class="emphasis"><em>package-restrictions.xml</em></span> file ➏ defines what applications the user has installed and stores their state. (We discuss application sharing and per-user application data in the next section.)</p></div></div><div class="sect1" title="Per-User Application Management"><div class="titlepage"><div><div><h1 class="title"><a id="per-user_application_management"/>Per-User Application Management</h1></div></div></div><p>As mentioned in “<a class="xref" href="ch04.html#multi-user_support_overview" title="Multi-User Support Overview">Multi-User Support Overview</a>”, besides dedicated accounts and settings, each user gets their own copy of application data that cannot be accessed by other users. Android achieves this by assigning a new, per-user effective UID for each application and creating a dedicated application data directory owned by that UID. We’ll discuss the details of this implementation in the following sections.</p><div class="sect2" title="Application Data Directories"><div class="titlepage"><div><div><h2 class="title"><a id="application_data_directories"/>Application Data Directories</h2></div></div></div><p><a id="iddle1193" class="indexterm"/><a id="iddle2215" class="indexterm"/><a id="iddle2242" class="indexterm"/><a id="iddle2402" class="indexterm"/><a id="iddle3006" class="indexterm"/>As we covered in <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>, Android installs APK packages by copying them to the <span class="emphasis"><em>/data/app/</em></span> directory, and creates a dedicated data directory for each application under <span class="emphasis"><em>/data/data/</em></span>. When multi-user support is enabled, this layout is not changed but extended to support additional users. Application data for the primary user is still stored in <span class="emphasis"><em>/data/data/</em></span> for backward compatibility.</p><p>If other users exist on the system when a new application is being installed, the <code class="literal">PackageManagerService</code> creates application data directories for each user. As with the data directory for the primary user, those directories are created with the help of the <span class="emphasis"><em>installd</em></span> daemon (using the <code class="literal">mkuserdata</code> command) because the <span class="emphasis"><em>system</em></span> user does not have enough privileges to change directory ownership.</p><p>User data directories are stored in <span class="emphasis"><em>/data/user/</em></span> and named after the user’s ID. The device owner directory (<span class="emphasis"><em>0/</em></span>) is a symbolic link to <span class="emphasis"><em>/data/data/</em></span>, as shown in <a class="xref" href="ch04.html#contents_of_solidusdatasolidususersolidu" title="Example 4-8. Contents of /data/user/ on a multi-user device">Example 4-8</a>.</p><div class="example"><a id="contents_of_solidusdatasolidususersolidu"/><p class="title">Example 4-8. Contents of <span class="roman">/data/user/</span> on a multi-user device</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /data/user/</strong></span>
lrwxrwxrwx root     root         0 -&gt; /data/data/
drwxrwx--x system   system       10
drwxrwx--x system   system       11
drwxrwx--x system   system       12
drwxrwx--x system   system       13</pre></div></div><p>The contents of each application data directory are the same as <span class="emphasis"><em>/data/ data/</em></span>, but application directories for each user’s instance of the same application are owned by a different Linux user, as shown in <a class="xref" href="ch04.html#contents_of_application_data_directories" title="Example 4-9. Contents of application data directories for the primary user and one secondary user">Example 4-9</a>.</p><div class="example"><a id="contents_of_application_data_directories"/><p class="title">Example 4-9. Contents of application data directories for the primary user and one secondary user</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /data/data/</strong></span>➊
drwxr-x--x u0_a12   u0_a12                 com.android.apps.tag
drwxr-x--x u0_a0    u0_a0                  com.android.backupconfirm
drwxr-x--x bluetooth bluetooth             com.android.bluetooth
drwxr-x--x u0_a16   u0_a16                 com.android.browser➋
drwxr-x--x u0_a17   u0_a17                 com.android.calculator2
drwxr-x--x u0_a18   u0_a18                 com.android.calendar
--<span class="emphasis"><em>snip</em></span>--
# <span class="strong"><strong>ls -l /data/user/13/</strong></span>➌
ls -l /data/user/13
drwxr-x--x u13_system u13_system           android
drwxr-x--x u13_a12  u13_a12                com.android.apps.tag
drwxr-x--x u13_a0   u13_a0                 com.android.backupconfirm
drwxr-x--x u13_bluetooth u13_bluetooth     com.android.bluetooth
drwxr-x--x u13_a16  u13_a16                com.android.browser➍
drwxr-x--x u13_a17  u13_a17                com.android.calculator2
drwxr-x--x u13_a18  u13_a18                com.android.calendar
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a id="iddle1192" class="indexterm"/><a id="iddle2241" class="indexterm"/><a id="iddle2410" class="indexterm"/><a id="iddle3005" class="indexterm"/>This listing shows the contents of the app data directories for the primary user ➊ and the secondary user with user ID 13 ➌. As you can see, even though both users have data directories for the same apps, such as the browser app (➋ for the owner and ➍ for the secondary user), those directories are owned by different Linux users: <span class="emphasis"><em>u0_a16</em></span> in the case of the owner and <span class="emphasis"><em>u13_a16</em></span> in the case of the secondary user. If we check the UID for those users using the <code class="literal">su</code> and <code class="literal">id</code> commands, we find that <span class="emphasis"><em>u0_a16</em></span> has UID=10016, and <span class="emphasis"><em>u13_a16</em></span> has UID=1310016.</p><p>The fact that both UIDs contain the number 10016 is no coincidence. The repeating part is called the <span class="emphasis"><em>app ID</em></span> and is the same as the UID assigned to the app when first installed on a single-user device. On multiuser devices, the app UID is derived from the user ID and the app ID using the following code:</p><a id="pro_id00003"/><pre class="programlisting">uid = userId * 100000 + (appId % 100000)</pre><p>Because the owner’s user ID is always 0, the UIDs for the device owner’s apps are always the same as their app IDs. When the same application is executed in the context of different users, it executes under the respective UIDs assigned to each user’s application instance. For example, if the browser application is executed simultaneously by the device owner and a secondary user with user ID 13, two separate processes running as the <span class="emphasis"><em>u0_a16</em></span> and <span class="emphasis"><em>u13_a16</em></span> Linux users will be created (UID 10016, for the owner ➊ and UID 1310016, for the secondary user ➋) as shown in <a class="xref" href="ch04.html#process_information_for_the_browser_appl" title="Example 4-10. Process information for the browser application when executed by different device users">Example 4-10</a>.</p><div class="example"><a id="process_information_for_the_browser_appl"/><p class="title">Example 4-10. Process information for the browser application when executed by different device users</p><div class="example-contents"><pre class="programlisting">USER      PID   PPID  VSIZE   RSS   WCHAN    PC         NAME
--<span class="emphasis"><em>snip</em></span>--
u13_a16   1149  180   1020680 72928 ffffffff 4006a58c R com.android.browser➊
--<span class="emphasis"><em>snip</em></span>--
u0_a16    30500 180   1022796 73384 ffffffff 4006b73c S com.android.browser➋
--<span class="emphasis"><em>snip</em></span>--</pre></div></div></div><div class="sect2" title="Application Sharing"><div class="titlepage"><div><div><h2 class="title"><a id="application_sharing"/>Application Sharing</h2></div></div></div><p>While installed applications have a dedicated data directory for each user, the APK files are shared among all users. The APK files are copied to <span class="emphasis"><em>/data/app/</em></span> and are readable by all users; shared libraries used by apps are copied to <span class="emphasis"><em>/data/app-lib/&lt;package name&gt;/</em></span> and are symlinked to <span class="emphasis"><em>/data/ user/&lt;user ID&gt;/&lt;package name&gt;/lib/</em></span>; and the optimized DEX files for each app are stored in <span class="emphasis"><em>/data/dalvik-cache/</em></span> and are also shared by all users. Thus once an application is installed, it is accessible to all device users, and an app data directory is automatically created for each user.</p><p>Android makes it possible for users to have different applications by creating a <span class="emphasis"><em>package-restrictions.xml</em></span> file (➏ in <a class="xref" href="ch04.html#contents_of_a_user_directory" title="Example 4-7. Contents of a user directory">Example 4-7</a>) in the system directory of each user, which it uses to track whether an app is enabled for a user <a id="iddle1963" class="indexterm"/><a id="iddle2403" class="indexterm"/>or not. Besides the install state of packages, this file contains information about the disabled components of each application, as well as a list of preferred applications to start when processing intents that can be handled by more than one application (such as opening a text file, for example). The contents of <span class="emphasis"><em>package-restrictions.xml</em></span> might look like <a class="xref" href="ch04.html#contents_of_the_package-restrictionsdotx" title="Example 4-11. Contents of the package-restrictions.xml file">Example 4-11</a> for a secondary user.</p><div class="example"><a id="contents_of_the_package-restrictionsdotx"/><p class="title">Example 4-11. Contents of the package-restrictions.xml file</p><div class="example-contents"><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;
&lt;package-restrictions&gt;
    &lt;pkg name="com.example.app" inst="false" stopped="true" nl="true" /&gt;➊
    &lt;pkg name="com.example.app2" stopped="true" nl="true" /&gt;➋
    --<span class="emphasis"><em>snip</em></span>--
    &lt;pkg name="com.android.settings"&gt;
        &lt;disabled-components&gt;
            &lt;item name="com.android.settings.CryptKeeper" /&gt;
        &lt;/disabled-components&gt;
    &lt;/pkg&gt;
    &lt;preferred-activities /&gt;
&lt;/package-restrictions&gt;</pre></div></div><p>Here, the <code class="literal">com.example.app</code> package is available on the system but is not installed for that secondary user, as expressed by adding a <code class="literal">&lt;pkg&gt;</code> for the app and setting the <code class="literal">inst</code> attribute to <code class="literal">false</code> ➊. Based on this information, the <code class="literal">PackageManagerService</code> marks the <code class="literal">com.example.app</code> package as not installed for that user and the package doesn’t show up in the launcher or the list of apps in Settings.</p><p>Applications can be installed but still marked as stopped, as shown at ➋. Here, the <code class="literal">com.example.app2</code> package is installed but marked as stopped by setting the <code class="literal">stopped</code> attribute to <code class="literal">true</code>. Android has a special state for applications that have never been launched; a state that is persisted with the <code class="literal">nl</code> attribute of the <code class="literal">&lt;pkg&gt;</code> tag. The device owner can block a package for a certain user, in which case the <code class="literal">blocked</code> attribute is set to <code class="literal">true</code>, though this is not shown in <a class="xref" href="ch04.html#warning_shown_when_the_device_owner_trie" title="Figure 4-4. Warning shown when the device owner tries to uninstall an app for all users">Figure 4-4</a>.</p><p>When a device user installs an application, a <code class="literal">&lt;pkg&gt;</code> tag with <code class="literal">inst="false"</code> is added to the <span class="emphasis"><em>package-restrictions.xml</em></span> files for all users. When another user installs the same application, the <code class="literal">inst</code> attribute is removed and the application is considered installed for that user. (Depending on how the second user started the install process, the APK file in <span class="emphasis"><em>/data/app/</em></span> may be replaced, as it is in an application update.)</p><p>Restricted users cannot install applications, but the same procedure is applied when the device owner enables an app for a restricted user: the application is installed by calling the <code class="literal">PackageManagerService.installExistingPackageAsUser()</code> method, which sets the installed flag for the package and updates <span class="emphasis"><em>package-restrictions.xml</em></span> accordingly.</p><div class="figure"><a id="warning_shown_when_the_device_owner_trie"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00012"/><img src="figs/web/04fig04.png.jpg" alt="Warning shown when the device owner tries to uninstall an app for all users"/></div></div><p class="title">Figure 4-4. Warning shown when the device owner tries to uninstall an app for all users</p></div><p>When a user uninstalls a package, their app data is deleted and the internal per-user package installed flag is set to <code class="literal">false</code>. This state is then persisted by setting <code class="literal">inst="false"</code> to the removed package’s tag in the user’s <span class="emphasis"><em>package-restrictions.xml</em></span> file. The APK file and native library directory are only removed when the last user that has the app installed uninstalls it. However, the owner can see all apps installed on the system in the All tab of the Apps Settings screen, including ones they haven’t installed, and they can uninstall those apps for all users. The <span class="strong"><strong><code class="literal">Uninstall for all users</code></strong></span> action is hidden in the overflow menu so that it isn’t selected accidentally. It produces the warning shown in <a class="xref" href="ch04.html#warning_shown_when_the_device_owner_trie" title="Figure 4-4. Warning shown when the device owner tries to uninstall an app for all users">Figure 4-4</a>. If the owner selects OK in this warning dialog, app directories for all users are removed and the APK file is deleted from the device.</p><p><a id="iddle1712" class="indexterm"/><a id="iddle1782" class="indexterm"/><a id="iddle2248" class="indexterm"/><a id="iddle2295" class="indexterm"/><a id="iddle2472" class="indexterm"/><a id="iddle2672" class="indexterm"/><a id="iddle3012" class="indexterm"/><a id="iddle3138" class="indexterm"/>The app-sharing scheme implemented on multi-user Android devices is backward-compatible with previous versions and saves device space by not copying APK files for all users. However, it has one major disadvantage: any user can update an application, even if it was originally installed by another user.</p><p>This scheme is usually not a problem, because every user’s app instance has a separate data directory, except when the update adds new permissions. Because Android grants permissions at install time, if a user updates an app and accepts a new permission that affects user privacy (for example, <code class="literal">READ_CONTACTS</code>), that permission will apply to all users who use the app. Other users are not notified that the app has been granted a new permission and may never notice the change, unless they manually inspect the app’s details in system Settings. Android does show a warning that notifies users about this fact when they first enable multi-user support, but does not send subsequent notifications about specific apps.</p></div></div><div class="sect1" title="External Storage"><div class="titlepage"><div><div><h1 class="title"><a id="external_storage"/>External Storage</h1></div></div></div><p>Android has included support for external storage since the first public versions. Because the first few generations of Android devices implemented external storage by simply mounting a FAT-formatted removable SD card, external storage is often referred to as “the SD card.” However, the definition of external storage is broader and simply requires that external storage be a “case-insensitive filesystem with immutable POSIX permission classes and modes.”<sup>[<a id="ch04fn02" href="#ftn.ch04fn02" class="footnote">30</a>]</sup> The underlying implementation may be anything that satisfies this definition.</p><div class="sect2" title="External Storage Implementations"><div class="titlepage"><div><div><h2 class="title"><a id="external_storage_implementations"/>External Storage Implementations</h2></div></div></div><p>Newer devices tend to implement external storage by emulation, and some don’t have an SD card slot at all. For example, the last Google Nexus device that had an SD card slot was the Nexus One, released in January 2010, and all Nexus devices released after the Nexus S (which uses a dedicated partition for external storage) implement external storage by emulation. On devices that lack an SD card, external storage is implemented either by directly mounting a FAT-formatted partition, which resides on the same block device as primary storage, or by using a helper daemon to emulate it.</p><p>Beginning with Android version 4.4, apps have been able to manage their package-specific directories (<span class="emphasis"><em>Android/data/com.example.app/</em></span> for an app with the <code class="literal">com.example.app</code> package) on external storage without requiring the <code class="literal">WRITE_EXTERNAL_STORAGE</code> permission, which grants access to all data on external <a id="iddle1328" class="indexterm"/><a id="iddle1411" class="indexterm"/><a id="iddle1781" class="indexterm"/><a id="iddle1810" class="indexterm"/><a id="iddle1840" class="indexterm"/><a id="iddle2247" class="indexterm"/><a id="iddle3011" class="indexterm"/><a id="iddle3071" class="indexterm"/>storage, including camera pictures, videos, and other media. This feature is called <span class="emphasis"><em>synthesized permissions</em></span> and its AOSP implementation is based on a FUSE daemon that wraps the raw device storage and manages file access and permission based on a specified permission emulation mode.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note02"/>Note</h3><p>Filesystem in Userspace<span class="emphasis"><em>, or</em></span> FUSE,<sup>[<a id="ch04fn03" href="#ftn.ch04fn03" class="footnote">31</a>]</sup> <span class="emphasis"><em>is a Linux feature that allows the implementation of a fully functional filesystem in a userspace program. This is achieved by using a generic FUSE kernel module that routes all Virtual Filesystem (VFS) system calls for the target filesystem to its userspace implementation. The kernel module and the user-space implementation communicate via a special file descriptor obtained by opening</em></span> /dev/fuse.</p></div><p>As of Android version 4.4, multiple external storage devices can be accessed by applications, but the applications are only allowed to write arbitrary files on <span class="emphasis"><em>primary external storage</em></span> (if they hold the <code class="literal">WRITE_EXTERNAL_STORAGE</code> permission), and they have only limited access to other external storage devices, referred to as <span class="emphasis"><em>secondary external storage</em></span>. Our discussion will focus on primary external storage as it’s most closely related to multi-user support.</p></div><div class="sect2" title="Multi-User External Storage"><div class="titlepage"><div><div><h2 class="title"><a id="multi-user_external_storage"/>Multi-User External Storage</h2></div></div></div><p>In order to uphold the Android security model in a multi-user environment, the Android Compatibility Definition Document (CDD) places numerous requirements on external storage. The most important of these is that “Each user instance on an Android device MUST have separate and isolated external storage directories.” <sup>[<a id="ch04fn04" href="#ftn.ch04fn04" class="footnote">32</a>]</sup></p><p>Unfortunately, implementing this requirement poses a problem because external storage has traditionally been world-readable and implemented using the FAT filesystem, which does not support permissions. Google’s implementation of multi-user external storage leverages three Linux kernel features in order to provide backward-compatible, per-user external storage: mount namespaces, bind mounts, and shared subtrees.</p><div class="sect3" title="Advanced Linux Mount Features"><div class="titlepage"><div><div><h3 class="title"><a id="advanced_linux_mount_features"/>Advanced Linux Mount Features</h3></div></div></div><p>As in other Unix systems, Linux manages all files from all storage devices as part of a single directory tree. Each filesystem is linked to a specific subtree by mounting it at a specified directory, called the <span class="emphasis"><em>mount point</em></span>. Traditionally, the directory tree has been shared by all processes, and each process sees the same directory hierarchy.</p><p><a id="iddle1277" class="indexterm"/><a id="iddle1397" class="indexterm"/><a id="iddle1398" class="indexterm"/><a id="iddle1780" class="indexterm"/><a id="iddle2225" class="indexterm"/><a id="iddle2232" class="indexterm"/><a id="iddle2234" class="indexterm"/><a id="iddle2246" class="indexterm"/><a id="iddle2977" class="indexterm"/><a id="iddle3010" class="indexterm"/>Linux 2.4.19 and later versions added support for per-process mount namespaces, which allows each process to have its own set of mount points and thus use a directory hierarchy different from that of other processes.<sup>[<a id="ch04fn05" href="#ftn.ch04fn05" class="footnote">33</a>]</sup> The current list of mounts for each process can be read from the <span class="emphasis"><em>/proc/PID/ mounts</em></span> virtual file, where <span class="emphasis"><em>PID</em></span> is the process ID. A forked Linux process can request a separate mount namespace by specifying the <code class="literal">CLONE_NEWNS</code> flag to the Linux-specific <code class="literal">clone()</code><sup>[<a id="ch04fn06" href="#ftn.ch04fn06" class="footnote">34</a>]</sup> and <code class="literal">unshare()</code><sup>[<a id="ch04fn07" href="#ftn.ch04fn07" class="footnote">35</a>]</sup> system calls. In this case, the namespace of the parent process is referred to as the <span class="emphasis"><em>parent namespace</em></span>.</p><p>A <span class="emphasis"><em>bind mount</em></span> allows a directory or file to be mounted at another path in the directory tree, making the same file or directory visible at multiple locations. A bind mount is created by specifying the <code class="literal">MS_BIND</code> flag to the <code class="literal">mount()</code> system call, or by passing the <code class="literal">--bind</code> parameter to the <code class="literal">mount</code> command.</p><p>Finally, <span class="emphasis"><em>shared subtrees</em></span>,<sup>[<a id="ch04fn08" href="#ftn.ch04fn08" class="footnote">36</a>]</sup> which were first introduced in Linux 2.6.15, provide a way to control how filesystem mounts are propagated across mount namespaces. Shared subtrees make it possible for a process to have its own namespace but still access filesystems that are mounted after it starts. Shared subtrees provide four different mount types, of which Android uses the shared and slave mount. A <span class="emphasis"><em>shared mount</em></span> created in a parent namespace propagates to all child namespaces and is thus visible to all processes that have cloned off a namespace. A <span class="emphasis"><em>slave mount</em></span> has a master mount that is a shared mount, and also propagates new mounts. However, the propagation is one-way only: mounts at the master propagate to the slave, but mounts at the slave do not propagate to the master. This scheme allows a process to keep its mounts invisible to any other process, while still being able to see shared system mounts. Shared mounts are created by passing the <code class="literal">MS_SHARED</code> flag to the <code class="literal">mount()</code> system call, while creating slave mounts requires passing the <code class="literal">MS_SLAVE</code> flag.</p></div><div class="sect3" title="Android Implementation"><div class="titlepage"><div><div><h3 class="title"><a id="android_implementation"/>Android Implementation</h3></div></div></div><p>Since Android 4.4, mounting external storage directly is no longer supported but is emulated using the FUSE <span class="emphasis"><em>sdcard</em></span> daemon, even when the underlying device is a physical SD card. We’ll base our discussion on a configuration that is backed by a directory on internal storage, which is typical for devices without a physical SD card. (The official documentation<sup>[<a id="ch04fn09" href="#ftn.ch04fn09" class="footnote">37</a>]</sup> contains more details on other possible configurations.)</p><p>On a device where primary external storage is backed by internal storage, the <span class="emphasis"><em>sdcard</em></span> FUSE daemon uses the <span class="emphasis"><em>/data/media/</em></span> directory as a source and <a id="iddle1713" class="indexterm"/><a id="iddle3165" class="indexterm"/>creates an emulated filesystem at <span class="emphasis"><em>/mnt/shell/emulated</em></span>. <a class="xref" href="ch04.html#sdcard_service_declaration_for_emulated" title="Example 4-12. sdcard service declaration for emulated external storage">Example 4-12</a> shows how the <span class="emphasis"><em>sdcard</em></span> service is declared in the device-specific <span class="emphasis"><em>init.rc</em></span> file in this case ➐.</p><div class="example"><a id="sdcard_service_declaration_for_emulated"/><p class="title">Example 4-12. sdcard service declaration for emulated external storage</p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
on init
    mkdir /mnt/shell/emulated 0700 shell shell➊
    mkdir /storage/emulated 0555 root root➋

    export EXTERNAL_STORAGE /storage/emulated/legacy➌
    export EMULATED_STORAGE_SOURCE /mnt/shell/emulated➍
    export EMULATED_STORAGE_TARGET /storage/emulated➎

    # Support legacy paths
    symlink /storage/emulated/legacy /sdcard➏
    symlink /storage/emulated/legacy /mnt/sdcard
    symlink /storage/emulated/legacy /storage/sdcard0
    symlink /mnt/shell/emulated/0 /storage/emulated/legacy
# virtual sdcard daemon running as media_rw (1023)
service sdcard /system/bin/sdcard -u 1023 -g 1023 -l /data/media /mnt/shell/emulated➐
    class late_start
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>Here, the <code class="literal">-u</code> and <code class="literal">-g</code> options specify the user and group the daemon should run as, and <code class="literal">-l</code> specifies the layout used for emulated storage (discussed later in this section). As you can see at ➊, the <span class="emphasis"><em>/mnt/shell/emulated/</em></span> directory (available via the <code class="literal">EMULATED_STORAGE_SOURCE</code> environment variable ➍) is owned and only accessible by the <span class="emphasis"><em>shell</em></span> user. Its contents might look like <a class="xref" href="ch04.html#contents_of_solidusmntsolidusshellsolidu" title="Example 4-13. Contents of /mnt/shell/emulated/">Example 4-13</a> on a device with five users.</p><div class="example"><a id="contents_of_solidusmntsolidusshellsolidu"/><p class="title">Example 4-13. Contents of <span class="roman">/mnt/shell/emulated/</span></p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /mnt/shell/emulated/</strong></span>
drwxrwx--x root    sdcard_r         0
drwxrwx--x root    sdcard_r         10
drwxrwx--x root    sdcard_r         11
drwxrwx--x root    sdcard_r         12
drwxrwx--x root    sdcard_r         13
drwxrwx--x root    sdcard_r         legacy
drwxrwx--x root    sdcard_r         obb</pre></div></div><p>As with app data directories, each user gets a dedicated external storage data directory named after their user ID. Android uses a combination of mount namespaces and bind mounts in order to make each user’s external storage data directory available only to the applications that the user starts, without showing them other users’ data directories. Because all applications are forked off the <span class="emphasis"><em>zygote</em></span> process (discussed in <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>), external storage setup is implemented in two steps: the first one is common to all processes, and the second is specific to each process. First, mount points <a id="iddle1399" class="indexterm"/><a id="iddle1715" class="indexterm"/><a id="iddle2226" class="indexterm"/><a id="iddle2235" class="indexterm"/>that are shared by all forked app processes are set up in the unique <span class="emphasis"><em>zygote</em></span> process. Then dedicated mount points, which are visible only to that process, are set up as part of each app’s process specialization.</p><p>Let’s first look at the shared part in the <span class="emphasis"><em>zygote</em></span> process. <a class="xref" href="ch04.html#mount_point_setup_in_zygote" title="Example 4-14. Mount point setup in zygote">Example 4-14</a> shows an excerpt of the <code class="literal">initZygote()</code> function (found in <span class="emphasis"><em>dalvik/vm/Init.cpp</em></span>) that highlights mount point setup.</p><div class="example"><a id="mount_point_setup_in_zygote"/><p class="title">Example 4-14. Mount point setup in <span class="roman">zygote</span></p><div class="example-contents"><pre class="programlisting">static bool initZygote()
{
   setpgid(0,0);

   if (unshare(CLONE_NEWNS) == -1) {➊
        return -1;
   }

    // Mark rootfs as being a slave so that changes from default
    // namespace only flow into our children.
    if (mount("rootfs", "/", NULL, (MS_SLAVE | MS_REC), NULL) == -1) {➋
        return -1;
    }

    const char* target_base = getenv("EMULATED_STORAGE_TARGET");
    if (target_base != NULL) {
        if (mount("tmpfs", target_base, "tmpfs", MS_NOSUID | MS_NODEV,➌
                "uid=0,gid=1028,mode=0751") == -1) {
            return -1;
        }
    }
    --<span class="emphasis"><em>snip</em></span>--
    return true;
}</pre></div></div><p>Here, <span class="emphasis"><em>zygote</em></span> passes the <code class="literal">CLONE_NEWNS</code> flag to the <code class="literal">unshare()</code> system call ➊ in order to create a new, private mount namespace that will be shared by all its children (app processes). It then marks the root filesystem (mounted at /) as a slave by passing the <code class="literal">MS_SLAVE</code> flag to the <code class="literal">mount()</code> system call ➋. This ensures that changes from the default mount namespace, such as mounting encrypted containers or removable storage, only propagate to its children, while at the same time making sure that any mounts created by children do not propagate into the default namespace. Finally, <span class="emphasis"><em>zygote</em></span> creates the memory-backed <code class="literal">EMULATED_STORAGE_TARGET</code> (usually <span class="emphasis"><em>/storage/emulated/</em></span>) mount point by creating a <span class="emphasis"><em>tmpfs</em></span> filesystem ➌, which children use to bind mount external storage into their private namespaces.</p><p><a class="xref" href="ch04.html#external_storage_setup_for_app_processes" title="Example 4-15. External storage setup for app processes">Example 4-15</a> shows the process-specific mount point setup found in <span class="emphasis"><em>dalvik/vm/native/dalvik_system_Zygote.cpp</em></span> that is executed when forking each app process off <span class="emphasis"><em>zygote</em></span>. (Error handling, logging, and some variable declarations have been omitted.)</p><div class="example"><a id="external_storage_setup_for_app_processes"/><p class="title">Example 4-15. External storage setup for app processes</p><div class="example-contents"><pre class="programlisting">static int mountEmulatedStorage(uid_t uid, u4 mountMode) {
    userid_t userid = multiuser_get_user_id(uid);➊

    // Create a second private mount namespace for our process
    if (unshare(CLONE_NEWNS) == -1) {➋
        return -1;
    }

    // Create bind mounts to expose external storage
    if (mountMode == MOUNT_EXTERNAL_MULTIUSER
            || mountMode == MOUNT_EXTERNAL_MULTIUSER_ALL) {
        // These paths must already be created by init.rc
        const char* source = getenv("EMULATED_STORAGE_SOURCE");➌
        const char* target = getenv("EMULATED_STORAGE_TARGET");➍
        const char* legacy = getenv("EXTERNAL_STORAGE");➎
        if (source == NULL || target == NULL || legacy == NULL) {
            return -1;
        }
        --<span class="emphasis"><em>snip</em></span>--
        // /mnt/shell/emulated/0
        snprintf(source_user, PATH_MAX, "%s/%d", source, userid);➏
        // /storage/emulated/0
        snprintf(target_user, PATH_MAX, "%s/%d", target, userid);➐
        --<span class="emphasis"><em>snip</em></span>--
        if (mountMode == MOUNT_EXTERNAL_MULTIUSER_ALL) {
            // Mount entire external storage tree for all users
            if (mount(source, target, NULL, MS_BIND, NULL) == -1) {
                return -1;
            }
        } else {
            // Only mount user-specific external storage
            if (mount(source_user, target_user, NULL, MS_BIND, NULL) == -1) {➑
                return -1;
            }
        }
        --<span class="emphasis"><em>snip</em></span>--
        // Finally, mount user-specific path into place for legacy users
        if (mount(target_user, legacy, NULL, MS_BIND | MS_REC, NULL) == -1) {➒
            return -1;
        }

    } else {
        return -1;
    }

    return 0;
}</pre></div></div><p><a id="iddle1094" class="indexterm"/><a id="iddle1400" class="indexterm"/><a id="iddle1714" class="indexterm"/><a id="iddle1716" class="indexterm"/><a id="iddle1784" class="indexterm"/><a id="iddle1870" class="indexterm"/><a id="iddle2223" class="indexterm"/>Here, the <code class="literal">mountEmulatedStorage()</code> function first obtains the current user ID from the process UID ➊, then uses the <code class="literal">unshare()</code> system call to create a new mount namespace for the process by passing the <code class="literal">CLONE_NEWNS</code> flag ➋. The function then obtains the values of the <code class="literal">EMULATED_STORAGE_SOURCE</code> ➌, <code class="literal">EMULATED_STORAGE_TARGET</code> ➍, and <code class="literal">EXTERNAL_STORAGE</code> ➎ environment variables, which are all initialized in the device-specific <span class="emphasis"><em>init.rc</em></span> file (see ➌, ➍, and ➎ in <a class="xref" href="ch04.html#sdcard_service_declaration_for_emulated" title="Example 4-12. sdcard service declaration for emulated external storage">Example 4-12</a>). It then prepares the mount source ➏ and target ➐ directory paths based on the values of <code class="literal">EMULATED_STORAGE_SOURCE</code>, <code class="literal">EMULATED_STORAGE_TARGET</code>, and the current user ID.</p><p>The directories are created if they don’t exist, and then the method bind mounts the source directory (such as <span class="emphasis"><em>/mnt/shell/emulated/0</em></span> for the owner user) at the target path (for example, <span class="emphasis"><em>/storage/emulated/0</em></span> for the owner user) ➑. This ensures that external storage is accessible from the Android shell (started with the <span class="emphasis"><em>adb shell</em></span> command), which is used extensively for application development and debugging.</p><p>The final step is to recursively bind mount the target directory at the fixed legacy directory (<span class="emphasis"><em>/storage/emulated/legacy/</em></span>) ➒. The legacy directory is symlinked to <span class="emphasis"><em>/sdcard/</em></span> in the device-specific <span class="emphasis"><em>init.rc</em></span> file (➏ in <a class="xref" href="ch04.html#sdcard_service_declaration_for_emulated" title="Example 4-12. sdcard service declaration for emulated external storage">Example 4-12</a>) for backward compatibility with apps that hardcode this path (normally obtained using the <code class="literal">android.os.Environment.getExternalStorageDirectory()</code> API).</p><p>After all steps have been executed, the newly created app process is guaranteed to see only the external storage allotted to the user that started it. We can verify this by looking at the list of mounts for two app process executed by different users as shown in <a class="xref" href="ch04.html#list_of_mount_points_for_process_started" title="Example 4-16. List of mount points for process started by different users">Example 4-16</a>.</p><div class="example"><a id="list_of_mount_points_for_process_started"/><p class="title">Example 4-16. List of mount points for process started by different users</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>cat /proc/7382/mounts</strong></span>
--<span class="emphasis"><em>snip</em></span>--
/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,
group_id=1023,default_permissions,allow_other 0 0➊
/dev/fuse /storage/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,
group_id=1023,default_permissions,allow_other 0 0➋
/dev/fuse /storage/emulated/legacy fuse rw,nosuid,nodev,relatime,user_id=1023,
group_id=1023,default_permissions,allow_other 0 0➌

# <span class="strong"><strong>cat /proc/7538/mounts</strong></span>
--<span class="emphasis"><em>snip</em></span>--
/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,
group_id=1023,default_permissions,allow_other 0 0➍
/dev/fuse /storage/emulated/10 fuse rw,nosuid,nodev,relatime,user_id=1023,
group_id=1023,default_permissions,allow_other 0 0➎
/dev/fuse /storage/emulated/legacy fuse rw,nosuid,nodev,relatime,user_id=1023,
group_id=1023,default_permissions,allow_other 0 0➏</pre></div></div><p>Here, the process started by the owner user with PID 7382 has a <span class="emphasis"><em>/storage/ emulated/0</em></span> mount point ➋, which is a bind mount of <span class="emphasis"><em>/mnt/shell/emulated/0/</em></span>, and process 7538 (started by a secondary user) has a <span class="emphasis"><em>/storage/emulated/10</em></span> mount point ➎, which is a bind mount of <span class="emphasis"><em>/mnt/shell/emulated/10/</em></span>.</p><p>Because neither process has a mount point for the other process’s external storage directory, each process can only see and modify its own files. <a id="iddle1783" class="indexterm"/><a id="iddle1869" class="indexterm"/><a id="iddle2161" class="indexterm"/><a id="iddle2249" class="indexterm"/><a id="iddle2452" class="indexterm"/><a id="iddle2567" class="indexterm"/><a id="iddle3013" class="indexterm"/><a id="iddle3139" class="indexterm"/>Both processes have a <span class="emphasis"><em>/storage/emulated/legacy</em></span> mount point (➌ and ➏), but because it is bound to different directories (<span class="emphasis"><em>/storage/emulated/0/</em></span> and <span class="emphasis"><em>/mnt/ shell/emulated/10/</em></span>, respectively), each process sees different contents. Both process can see <span class="emphasis"><em>/mnt/shell/emulated/</em></span> (➊ and ➍), but because this directory is only accessible to the <span class="emphasis"><em>shell</em></span> user (permissions 0700), app processes cannot see its contents.</p></div></div><div class="sect2" title="External Storage Permissions"><div class="titlepage"><div><div><h2 class="title"><a id="external_storage_permissions"/>External Storage Permissions</h2></div></div></div><p>In order to emulate the FAT filesystem that was originally used for external storage, the <span class="emphasis"><em>sdcard</em></span> FUSE daemon assigns fixed owner, group, and access permissions to each file or directory on external storage. Additionally, permissions are not changeable, and symlinks and hardlinks are not supported. The assigned owner and permission are determined by the permission derivation mode that the <span class="emphasis"><em>sdcard</em></span> daemon uses.</p><p>In legacy mode (specified with the <code class="literal">-l</code> option), which is backward-compatible with previous Android versions and which is still the default in Android 4.4, most files and directories are owned by the root user and their group is set to <span class="emphasis"><em>sdcard_r</em></span>. Applications that are granted the <code class="literal">READ_EXTERNAL_STORAGE</code> permission have <span class="emphasis"><em>sdcard_r</em></span> as one of their supplementary groups, and thus can read most files on external storage even if they were originally created by a different application. <a class="xref" href="ch04.html#owner_and_permissions_of_files_on_extern" title="Example 4-17. Owner and permissions of files on external storage">Example 4-17</a> shows the owner and permission of files and directories in the root of external storage.</p><div class="example"><a id="owner_and_permissions_of_files_on_extern"/><p class="title">Example 4-17. Owner and permissions of files on external storage</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /sdcard/</strong></span>
drwxrwx--- root     sdcard_r           Alarms
drwxrwx--x root     sdcard_r           Android
drwxrwx--- root     sdcard_r           DCIM
--<span class="emphasis"><em>snip</em></span>--
-rw-rw---- root     sdcard_r         5 text.txt</pre></div></div><p>In previous versions of Android, all files and directories on external storage were assigned the same owner and permissions, but Android 4.4 treats the application-specific external files directory (<span class="emphasis"><em>Android/data/&lt;package-name&gt;/</em></span>, the exact path is returned by the <code class="literal">Context.getExternalFilesDir()</code> method) differently. Applications don’t have to hold the <code class="literal">WRITE_EXTERNAL_STORAGE</code> permission in order to read and write files in this directory because it is owned by the creating application.</p><p>That said, even in Android 4.4, the application’s external files directory is accessible by any application that holds the <code class="literal">READ_EXTERNAL_STORAGE</code> or <code class="literal">WRITE_EXTERNAL_STORAGE</code> permissions because the group of the directory is set to <span class="emphasis"><em>sdcard_r</em></span>, as shown in <a class="xref" href="ch04.html#owner_and_permissions_of_an_appapostroph" title="Example 4-18. Owner and permissions of an app’s external files directory">Example 4-18</a>.</p><div class="example"><a id="owner_and_permissions_of_an_appapostroph"/><p class="title">Example 4-18. Owner and permissions of an app’s external files directory</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ls -l Android/data/</strong></span>
drwxrwx--- u10_a16  sdcard_r        com.android.browser</pre></div></div><p><a id="iddle1044" class="indexterm"/><a id="iddle1538" class="indexterm"/><a id="iddle2250" class="indexterm"/><a id="iddle3017" class="indexterm"/>Android 4.4 supports a more flexible permission derivation mode that is based on directory structure, and which is specified by passing the <code class="literal">-d</code> option to the <span class="emphasis"><em>sdcard</em></span> daemon. This derivation mode sets dedicated groups to the directories <span class="emphasis"><em>Pictures/</em></span> and <span class="emphasis"><em>Music/</em></span> (<span class="emphasis"><em>sdcard_pics</em></span> ➊ and <span class="emphasis"><em>sdcard_av</em></span> ➋, as shown in <a class="xref" href="ch04.html#directory_owners_and_permission_in_the_n" title="Example 4-19. Directory owners and permission in the new permission derivation mode">Example 4-19</a>), which allows for fine-grained control over which files applications can access. As of this writing, Android doesn’t support such fine-grained access control, but it can easily be implemented by defining additional permissions that map to the <span class="emphasis"><em>sdcard_pics</em></span> and <span class="emphasis"><em>sdcard_av</em></span> groups. In the directory-structure-based permission mode, user directories are hosted under <span class="emphasis"><em>Android/user/</em></span> ➌.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note03"/>Note</h3><p><span class="emphasis"><em>While this new permission derivation mode is supported in Android 4.4, as of this writing, Nexus devices still use the legacy permission mode.</em></span></p></div><div class="example"><a id="directory_owners_and_permission_in_the_n"/><p class="title">Example 4-19. Directory owners and permission in the new permission derivation mode</p><div class="example-contents"><pre class="programlisting">rwxrwx--x root:sdcard_rw     /
rwxrwx--- root:sdcard_pics   /Pictures➊
rwxrwx--- root:sdcard_av     /Music➋

rwxrwx--x root:sdcard_rw     /Android
rwxrwx--x root:sdcard_rw     /Android/data
rwxrwx--- u0_a12:sdcard_rw   /Android/data/com.example.app
rwxrwx--x root:sdcard_rw     /Android/obb/
rwxrwx--- u0_a12:sdcard_rw   /Android/obb/com.example.app

rwxrwx--- root:sdcard_all    /Android/user➌
rwxrwx--x root:sdcard_rw     /Android/user/10
rwxrwx--- u10_a12:sdcard_rw  /Android/user/10/Android/data/com.example.app</pre></div></div></div></div><div class="sect1" title="Other Multi-User Features"><div class="titlepage"><div><div><h1 class="title"><a id="other_multi-user_features"/>Other Multi-User Features</h1></div></div></div><p>Besides dedicated app directories, external storage and settings, other Android features also support a multi-user device configuration. For example, as of version 4.4, Android’s credential storage (which allows for secure management of cryptographic keys) lets each user have their own key storage. (We discuss credential storage in more detail in <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a>.)</p><p>In addition, Android’s online account database, accessible via the <code class="literal">AccountManager</code> API, has been extended to allow secondary users to have their own accounts, as well as to allow restricted profiles to share some of the primary user’s accounts (if the app that needs account access supports it). We discuss online account support and the <code class="literal">AccountManager</code> API in <a class="xref" href="ch08.html" title="Chapter 8. Online Account Management">Chapter 8</a>.</p><p>And finally, Android allows setting different device administration policies for each user. As of version 4.4, it also supports setting up per-user VPNs that only route a single user’s traffic and which are not accessible by other users. (We discuss device administration, VPNs, and other enterprise features in <a class="xref" href="ch09.html" title="Chapter 9. Enterprise Security">Chapter 9</a>.)</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00009"/>Summary</h1></div></div></div><p>Android allows multiple users to share a device by providing dedicated internal and external storage to each user. Multi-user support follows the established security model and each user’s applications are assigned a unique UID and run in dedicated processes that cannot access other user’s data. User isolation is achieved by combining a UID assignment scheme that takes into account the user ID and storage mounting rules that allow each user to only see their own storage.</p><p>As of this writing, multi-user support is only available on devices without telephony support (usually tablets), as the behavior of telephony in a multi-user environment is currently undefined. Most Android features, including account database management, credential storage, device policies, and VPN support are multi-user-aware and allow each user to have their own configuration.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch04fn01" href="#ch04fn01" class="para">29</a>] </sup>Google, <span class="emphasis"><em>Android 4.4 Compatibility Definition,</em></span> “9.5. Multi-User Support,” <span class="emphasis"><em><a class="ulink" href="http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf">http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn02" href="#ch04fn02" class="para">30</a>] </sup>Google, “External Storage Technical Information,” <span class="emphasis"><em><a class="ulink" href="http://source.android.com/devices/tech/storage/index.html">http://source.android.com/devices/tech/storage/index.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn03" href="#ch04fn03" class="para">31</a>] </sup>“Filesystem in Userspace,” <span class="emphasis"><em><a class="ulink" href="http://fuse.sourceforge.net/">http://fuse.sourceforge.net/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn04" href="#ch04fn04" class="para">32</a>] </sup>Google, <span class="emphasis"><em>Android 4.4 Compatibility Definition,</em></span> “9.5. Multi-User Support,” <span class="emphasis"><em><a class="ulink" href="http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf">http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn05" href="#ch04fn05" class="para">33</a>] </sup>Michael Kerrisk, <span class="emphasis"><em>The Linux Programming Interface: A Linux and UNIX System Programming Handbook</em></span>, No Starch Press, 2010, pp. 261</p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn06" href="#ch04fn06" class="para">34</a>] </sup>Ibid., 598</p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn07" href="#ch04fn07" class="para">35</a>] </sup>Ibid., 603</p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn08" href="#ch04fn08" class="para">36</a>] </sup>Linux Kernel, <span class="emphasis"><em>Shared Subtrees</em></span>, <span class="emphasis"><em><a class="ulink" href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt">https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch04fn09" href="#ch04fn09" class="para">37</a>] </sup>Google, “External Storage: Typical Configuration Examples,” <span class="emphasis"><em><a class="ulink" href="http://source.android.com/devices/tech/storage/config-example.html">http://source.android.com/devices/tech/storage/config-example.html</a></em></span></p></div></div></div></body></html>