- en: '**INTRODUCTION**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: My first exposure to programming came in the summer of 1980\. It involved an
    Apple II+ computer. As principal of the local high school, my father was able
    to bring it home for us to play with over the summer. It was the only personal
    computer in the school. I already knew about video games and had an Atari 2600
    game console. But the idea of being able to make the machine do whatever I wanted
    it to was amazing and seductive.
  prefs: []
  type: TYPE_NORMAL
- en: The Apple II+ included a version of unstructured BASIC in ROM called Applesoft.
    As far as BASIC programming languages go, it was somewhat limited. However, it
    opened a new world to me, and I ran with it, writing small program after small
    program as I explored what the Apple II+ was and could do. It could ask questions,
    interpret answers, calculate formulas, plot pictures, and make sounds. And all
    of that power was at the tips of my 14-year-old fingers.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, I wanted one of these godlike machines for my own. My father, likely
    thinking it would put me off, told my younger brother, Bob, and me we could have
    one if we learned how to program it. Challenge accepted!
  prefs: []
  type: TYPE_NORMAL
- en: Months later, we did just that, and for Christmas in 1981, we got our own Apple
    II+. I still have it; it’s sitting on a shelf some five feet from me as I type
    this. And it still works.
  prefs: []
  type: TYPE_NORMAL
- en: My brother and I both ended up in computer science. During high school, I taught
    myself BASIC, 6502 assembly, Pascal, and FORTRAN, all on the Apple II+. I fell
    in love with programming languages and became a programming language junkie. A
    high school friend showed me a cryptic and small but powerful language he had
    for his TRS-80 color computer. He said its name was “Forth.” I kept that in the
    back of my mind for years until I encountered it again in the 1990s. Forth is
    one of the languages we’ll explore in this book, and it was my go-to language
    for most of the 1990s, on a Macintosh no less. My other language at the time was
    Modula-2, a successor of Pascal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thousands of programming languages have been developed over the years. I suspect
    a thorough history of programming languages would occupy several volumes. However,
    the purpose of this book is not history. The purpose of this book is:'
  prefs: []
  type: TYPE_NORMAL
- en: To give you a sense of where programming languages came from and provide some
    context for the languages we use today and the structures they contain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To explain some of the essential elements of programming languages, so you become
    familiar with terms like *Turing machine* and *Turing complete*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To expand your thinking about what a programming language can be and how it
    can express thought and process in creative and elegant ways. We’ll do this by
    exploring various programming languages ranging from the unusual to the downright
    bizarre.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*To have fun!* We’ll create our own programming languages, and see how we can
    use them to implement some algorithms. We’ll even put one on a small computer
    for standalone projects (the BBC micro:bit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “unusual to downright bizarre” programming languages have a name. They’re
    called *esoteric languages* or *esolangs*. Playing with and developing esolangs
    is a hobby for many, and even a serious pursuit for some. Most esolangs are not
    intended for actual work (whatever that might be). However, some languages that
    might be considered on the fringe of the esolang world *are* used for serious
    work. For example, Forth has been used for spacecraft control on several NASA
    missions, and NASA developed a language called CLIPS for expert system development.
    I consider languages like Forth and CLIPS to be “atypical” programming languages,
    with everyday languages like Python, Java, and C/C++ being typical languages.
    Naturally, these labels are subjective and open to debate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Who Is This Book For?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book is for all fans of programming languages. It’s for people enamored
    with the idea of encoding thought in a form usable by a machine.
  prefs: []
  type: TYPE_NORMAL
- en: I hope anyone who codes finds something of value in this book. My primary goal
    is to help you expand your conception of what it means to code, what programming
    actually is, and how coding might be expressed.
  prefs: []
  type: TYPE_NORMAL
- en: This book is truly for anyone who does more than use a computer. If you are
    a professional developer, you’ll appreciate the freedom that comes from thinking
    about your craft in unusual ways. If you are a student, you’ll hopefully see that
    programming can be more than what you may perceive it to be based on your introductory
    programming courses, as necessary as they are. If you’re a hobbyist, you’re likely
    already somewhat familiar with esolangs and are looking to feed your passion.
    Come on in, the water’s fine.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Can You Expect to Learn?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can expect to learn about where the programming languages you use—perhaps
    daily—came from. You can expect to learn about alternate ways to think about programming
    and, by extension, see your everyday programming in a new light.
  prefs: []
  type: TYPE_NORMAL
- en: You can also expect to learn about the essential elements of a programming language,
    something about what makes a programming language complete (that is, capable of
    expressing any program), and something about how we can even know such a thing.
  prefs: []
  type: TYPE_NORMAL
- en: You can expect to learn a little about a lot of programming languages, with
    a focus on esolangs and other “atypical” languages. As I indicated above, I used
    Forth almost exclusively for a decade to write everything from web CGI frameworks
    to scientific analysis tools for functional brain imaging (see [Figure 1](ch00.xhtml#ch00fig1)).
    I (not so) secretly hope a bright mind out there can see how to merge the rule-based
    expert system power of CLIPS with the power of modern deep learning. I suspect
    there’s a case to be made about why the two should work together.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/00fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1: A functional brain imaging analysis program written in Forth (circa
    1998)*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s my belief you’ll learn that developing a programming language is fun, even
    if the language itself is not overly useful. The Filska and Firefly languages
    we’ll create have different potential uses, but if nothing else, Filska can crunch
    numbers, and Firefly can make pretty pictures on a BBC micro:bit. The appendix
    demonstrates that even simple languages like Firefly can be useful for more “advanced”
    pursuits, like genetic programming.
  prefs: []
  type: TYPE_NORMAL
- en: I also expect you’ll take what we do here and expand on it yourself. For example,
    the micro:bit has two pushbuttons. Why not enhance Firefly to use them? Or make
    additions to the ABC implementation beyond what we’ll add in the book, as it’s
    so simplistic that it’s begging for additions. If you do, please share your results
    to *[rkneuselbooks@gmail.com](mailto:rkneuselbooks@gmail.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**What I Expect You to Know Already**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I expect you are already familiar with programming at some level. We’ll use
    Python to implement several esolangs, so it will help if you know something about
    Python. Beyond that, I don’t have any expectation of prior knowledge. The most
    important thing you can bring to this book is curiosity.
  prefs: []
  type: TYPE_NORMAL
- en: It’s said curiosity killed the cat, but you’re not a cat. For us, curiosity
    is what made humans conquer fire, and develop stone tools, civilizations, art,
    music, mathematics, science, and ultimately, a car-sized robot wandering the surface
    of Mars—a robot we named “Curiosity.”
  prefs: []
  type: TYPE_NORMAL
- en: If you’re curious, if you wonder “why?”, then you’ve got all the background
    you need to engage with the material in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**What This Book Is Not**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many books tell you what they are. Few tell you what they are not. I think this
    one should clarify itself, at least a little.
  prefs: []
  type: TYPE_NORMAL
- en: There are university courses and textbooks with titles like “Principles of Programming
    Languages” or just “Programming Languages.” These courses and books are highly
    mathematical treatments of what programming languages are. They are fascinating,
    but very technical, and involve a lot of math and logic. I put them in the category
    of theoretical computer science. This book is not one of these texts. You won’t
    find any deep mathematics here. The logic is implicit in the code, not formal.
    This book is about programming languages from a historical, practical, and, of
    paramount importance, fun perspective—with additional emphasis on the fun.
  prefs: []
  type: TYPE_NORMAL
- en: The end of the book points you toward more academic treatments of programming
    languages. Please do investigate. However, please don’t put this book down believing
    you need to be a computer science graduate student to follow it. You don’t. If
    you happen to be a computer science graduate student, please don’t put the book
    down, either. I promise you’ll have fun with it.
  prefs: []
  type: TYPE_NORMAL
- en: '**About This Book**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The book reads well straight through. However, after [Chapter 3](ch03.xhtml#ch03),
    you can pretty much hop around as you wish. The first three chapters provide background
    and context. After that come three chapters on atypical programming languages
    (Forth, SNOBOL, and CLIPS) followed by five on esolangs (ABC, FRACTRAN, Piet,
    Brainfuck, and Befunge).
  prefs: []
  type: TYPE_NORMAL
- en: In the two chapters after those, we define, implement, and experiment with our
    first homegrown esolang, Filska. The two chapters after that do the same for Firefly.
    Lastly, the book ends by pointing you to more—there’s always more to know.
  prefs: []
  type: TYPE_NORMAL
- en: The appendix explores genetic programming with Firefly. Genetic programming
    evolves programs instead of writing them by hand. The simplicity of Firefly makes
    it well-suited to such experiments—take a look and see.
  prefs: []
  type: TYPE_NORMAL
- en: '**Operating Environment**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We assume Linux as our operating system. Specifically, we assume an Ubuntu distribution,
    at least version 20.04\. None of the languages we’ll explore require much in the
    way of external libraries, so it’s highly likely future versions of Ubuntu will
    work without much effort.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t give explicit instructions here, but many macOS users will be able
    to install the languages as well. Windows users might need to work in a Unix-like
    environment like Cygwin, and will have to expend more effort to find some of the
    language tarballs and work through the installation process. Other options are
    using the Windows Subsystem for Linux or simply running Ubuntu in a virtual machine,
    both of which are easier than using Cygwin.
  prefs: []
  type: TYPE_NORMAL
- en: We need a C compiler to build some of the languages. Ubuntu usually comes with
    the gcc compiler suite for C and C++. You can test it with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Almost any version of gcc will work.
  prefs: []
  type: TYPE_NORMAL
- en: If gcc is not installed, and you get an error from the command above, the simplest
    way to install it is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve done this, repeat the command above to verify that gcc is now present.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also implement some of the languages ourselves using Python 3\. The exact
    version of Python 3 is not critical. Ubuntu 20.04 comes with version 3.8.5,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: so version 3.8.5 or later will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the immortal words of Ms. Frizzle, “Take chances, make mistakes, and
    get messy!” Ready? Let’s go.
  prefs: []
  type: TYPE_NORMAL
