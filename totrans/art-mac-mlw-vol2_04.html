<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_75" aria-label="75"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch3">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">3</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">CODE SIGNING</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">In this chapter, we’ll write code that can extract code signing information from distribution file formats that malware often abuses, such as disk images and packages. Then we’ll turn our attention to the code signing information of on-disk Mach-O binaries and running processes. For each, I’ll show you how to programmatically validate the code signing information and detect any revocations.</p>&#13;
<p class="TX">The behavior-based heuristics covered throughout this book are a powerful approach to detecting malware. But the approach comes with a downside: <i>false positives</i>, which occur when code incorrectly flags something as suspicious.</p>&#13;
<p class="TX">One way to reduce false positives is by examining an item’s code signing information. Apple’s support of cryptographic code signing is unparalleled, and as malware detectors, we can leverage it in a variety of ways, most notably to confirm that items come from known, trusted sources and that these items haven’t been tampered with.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_76" aria-label="76"/>On the flip side, we should closely scrutinize any unsigned or non-notarized item. For example, malware is often either wholly unsigned or signed in an ad hoc manner, meaning with a self-signed or untrusted certificate. While threat actors may occasionally sign their malware with fraudulently obtained or stolen developer certificates, it’s rare for Apple to have notarized the malware as well. Moreover, Apple is often quick to revoke the signing certificate or notarization ticket when it makes a mistake.</p>&#13;
<p class="TX">You can find the majority of code snippets presented in this chapter in the <i>checkSignature</i> project, available in the book’s GitHub repository.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-26"/><span class="SANS_Futura_Std_Bold_B_11">The Importance of Code Signing in Malware Detection</span></h3>&#13;
<p class="TNI">As an example of why code signing is useful for malware detection, imagine that you develop a heuristic to monitor the filesystem for persistent items (a reasonable approach to detecting malware, as the vast majority of Mac malware will persist on an infected host). Say your heuristic triggers when the <i>com.microsoft.update.agent.plist</i> property list is persisted as a launch agent. This property list references an application named <i>MicrosoftAutoUpdate.app</i>, which the operating system will now start automatically each time the user logs in.</p>&#13;
<p class="TX">If your detection capabilities don’t take into account the code signing information of the persisted item, you might generate an alert for what is actually a totally benign persistence event. The question, therefore, becomes: Is this really a Microsoft updater, or is it malware masquerading as such? By checking the application’s code signing signature, you should be able to answer this question conclusively; if Microsoft has indeed signed the item, you can ignore the persistence event, but if not, the item warrants a much closer look.</p>&#13;
<p class="TX">Unfortunately, existing malware detection products may fail to adequately take code signing information into account. For example, consider Apple’s Malware Removal Tool (MRT), a built-in malware detection tool found in certain versions of macOS. This platform binary is, of course, signed by Apple proper. Yet many antivirus engines have, at one point or another, flagged an MRT binary, <i>com.apple.XProtectFramework.plugins.MRTv3</i>, as malicious because their antivirus signatures naively matched MRT’s own embedded viral signatures (<a href="chapter3.xhtml#fig3-1">Figure 3-1</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-1" src="../images/Figure3-1.jpg" alt="" width="1142" height="322"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Apple’s Malicious Removal Tool flagged as malicious</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_77" aria-label="77"/>A rather hilarious false positive indeed. Joking aside, products that incorrectly classify legitimate items as malware may alert the user, causing consternation, or worse, may break legitimate functionality by quarantining the item. While third-party security products luckily can’t delete system components such as MRT, Apple has been known to inadvertently block its own components, disrupting system operations.<sup><a role="doc-noteref" id="chapter3_1" href="#chapter3-1">1</a></sup> In both cases, the detection logic could have simply checked the item’s code signing information to see that it belonged to a trusted source.</p>&#13;
<p class="TX">Code signing information can do more than just reduce false positives. For example, security tools should allow trusted or user-approved items to perform actions that might otherwise trigger an alert. Consider the case of a simple firewall that generates a notification whenever an untrusted item attempts to access the network. To distinguish between trusted and untrusted items, the firewall can check the items’ code signing signatures. Creating firewall rules based on code signing information has a few benefits:</p>&#13;
<ul class="ul">&#13;
<li class="BL">If malware attempts to bypass the firewall by modifying a legitimate item, code signing checks will detect this tampering.</li>&#13;
<li class="BL">If an approved item moves to another location on the filesystem, the rule will still match, as it isn’t tied to the item’s path or specific location.</li>&#13;
</ul>&#13;
<p class="TX">Hopefully, these brief examples have already shown you the value of inspecting the code signing information. For good measure, let’s list a few other ways that code signing information can help us programmatically detect malicious code:</p>&#13;
<blockquote>&#13;
<p class="EX1"><b>Detecting notarization</b> Recent versions of macOS require all downloaded software to be signed in order to run. As such, most malware is now signed, often with an ad hoc certificate or fraudulent developer ID. However, malware is rarely notarized, because notarization requires submitting an item to Apple, which scans it, then issues a notarization ticket if the item doesn’t appear to be malicious.<sup><a role="doc-noteref" id="chapter3_2" href="#chapter3-2">2</a></sup> On the few occasions that Apple has inadvertently notarized malware, it has quickly detected the misstep and revoked the notarization.<sup><a role="doc-noteref" id="chapter3_3" href="#chapter3-3">3</a></sup> These blunders are exceedingly rare, and notarized items are most likely benign. Using code signing, you can quickly determine whether an item is notarized, providing a reliable indication that Apple doesn’t consider it to be malware.</p>&#13;
<p class="EX"><b>Detecting revocations</b> If Apple has revoked an item’s code signing certificate or notarization ticket, it means they have determined that the item should no longer be distributed and run. Although revocation sometimes happens for benign reasons, it’s often because Apple deemed the item malicious. This chapter explains how to programmatically detect revocations.<sup><a role="doc-noteref" id="chapter3_4" href="#chapter3-4">4</a></sup></p>&#13;
<p class="EX2"><b>Linking items to known adversaries</b> Code signing information that researchers have attributed to malicious adversaries, such as team identifiers, can later identify other malware specimens created by the same authors.</p>&#13;
</blockquote>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_78" aria-label="78"/>When detecting malware, you’re generally interested in the following code signing information for an item:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The general status of the information, signing certificate, and notarization ticket. Is the item fully signed and notarized, and are the signing certificate and notarization ticket still in good standing?</li>&#13;
<li class="BL">The code signing authorities describing the chain of signers, as they can provide insight into the origin and trustworthiness of the signed item.</li>&#13;
<li class="BL">The item’s optional team identifier, which specifies the team or company that created the signed item. If the team identifier belongs to a reputable company, you can generally trust the signed item.</li>&#13;
</ul>&#13;
<p class="TX">This chapter won’t cover code signing internals. Rather, it focuses on higher-level concepts, as well as the APIs used to extract code signing information.<sup><a role="doc-noteref" id="chapter3_5" href="#chapter3-5">5</a></sup></p>&#13;
<p class="TX">Keep in mind, however, that not everything on macOS is signed, nor is it signed in the same way. Most notably, developers can’t sign stand-alone scripts (one of the reasons Apple is desperately trying to deprecate them). Nor is the macOS kernel signed per se. Instead, the boot process uses a cryptographic hash to verify that it remains pristine.</p>&#13;
<p class="TX">While developers can and should sign distribution media such as disk images, packages, and zip archives, as well as applications and stand-alone binaries, the tools and APIs that extract the code signing information are often specific to the file type. For example, Apple’s <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> utility and code signing services APIs work on disk images, applications, and binaries, but not on packages, whose information you can examine with the <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> utility or the private <span class="SANS_TheSansMonoCd_W5Regular_11">PackageKit</span> APIs.</p>&#13;
<p class="TX">Let’s consider how to manually and programmatically extract and validate code signing information, starting with distribution media.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1"><span id="sec2"/><span id="h1-27"/><span class="SANS_Futura_Std_Bold_B_11">Disk Images</span></h3>&#13;
<p class="TNI">Both legitimate developers and malware authors often distribute their code as disk images, which have the <i>.dmg</i> extension. Most disk images containing malware are unsigned, and if you encounter an unsigned <i>.dmg</i>, you should at the very least check whether the items it contains are signed and notarized. The presence of code signing information doesn’t mean a disk image is benign, however; nothing stops malware authors from leveraging cryptographic signatures. When you encounter a signed disk image, use its code signing information to identify the creator.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2"><span id="sec3"/><span id="h2-24"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Manually Verifying Signatures</span></h4>&#13;
<p class="TNI">You can manually verify the signature of a disk image with macOS’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> utility. Execute it with the <span class="SANS_TheSansMonoCd_W5Regular_11">--verify</span> command line option (or <span class="SANS_TheSansMonoCd_W5Regular_11">-v</span> for short) and the path of a <i>.dmg</i> file.</p>&#13;
<p class="TX">In the following example, <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> identifies a validly signed disk image containing LuLu, legitimate software from Objective-See. When it <span role="doc-pagebreak" epub:type="pagebreak" id="pg_79" aria-label="79"/>encounters validly signed images, the tool won’t output anything by default; hence, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">-dvv</span> option to display verbose output:</p>&#13;
&#13;
<pre><code>% <b>codesign –-verify LuLu_2.6.0.dmg</b>&#13;
&#13;
% <b>codesign --verify -dvv LuLu_2.6.0.dmg</b>&#13;
Executable=/Users/Patrick/Downloads/LuLu_2.6.0.dmg&#13;
Identifier=LuLu&#13;
Format=disk image&#13;
...&#13;
Authority=Developer ID Application: Objective-See, LLC (VBG97UB4TA)&#13;
Authority=Developer ID Certification Authority&#13;
Authority=Apple Root CA&#13;
</code></pre>&#13;
<p class="TX">The verbose output shows information about the disk image, such as its path, identifier, and format, as well as its code signing status, including the certificate authority chain. From the certificate authority chain, you can see the package has been signed with an Apple Developer ID belonging to Objective-See.</p>&#13;
<p class="TX">If a disk image isn’t signed, the utility will display a <span class="SANS_TheSansMonoCd_W5Regular_11">code object is not signed at all</span> message. Many software items, including most of the malware specimens distributed via disk images, fall into this category; the authors may have signed the software or malware but not its distribution media. For example, take a look at the EvilQuest malware. Distributed via disk images, it contains packages of trojanized applications:</p>&#13;
&#13;
<pre><code>% <b>codesign --verify "EvilQuest/Mixed In Key 8.dmg"</b>&#13;
EvilQuest/Mixed In Key 8.dmg: code object is not signed at all&#13;
</code></pre>&#13;
<p class="TX">Lastly, if Apple has revoked a disk image’s signature, <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> will display <span class="SANS_TheSansMonoCd_W5Regular_11">CSSMERR_TP_CERT_REVOKED</span>. You can see an example of this in the disk image used to distribute the CreativeUpdate malware:</p>&#13;
&#13;
<pre><code>% <b>codesign --verify "CreativeUpdate/Firefox 58.0.2.dmg"</b>&#13;
CreativeUpdate/Firefox 58.0.2.dmg: CSSMERR_TP_CERT_REVOKED&#13;
</code></pre>&#13;
<p class="TX">The malware’s signature is no longer valid.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2"><span id="sec4"/><span id="h2-25"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting Code Signing Information</span></h4>&#13;
<p class="TNI">Let’s programmatically extract and verify the code signing information of a disk image using Apple’s code signing services (<span class="SANS_TheSansMonoCd_W5Regular_11">Sec*</span>) APIs.<sup><a role="doc-noteref" id="chapter3_6" href="#chapter3-6">6</a></sup> In the chapter’s <i>checkSignature</i> project, you’ll find a function named <span class="SANS_TheSansMonoCd_W5Regular_11">checkItem</span> that takes the path to an item to verify, such as a disk image, and returns a dictionary containing the results of the verification. For validly signed items, it also returns information such as the code signing authorities, if any.</p>&#13;
<p class="TX">For the sake of brevity, I’ve omitted basic sanity and error checks from most of the code snippets in this book. However, when it comes to code signing, which provides the means to make crucial decisions about the trustworthiness of items, it’s imperative that the code handle errors appropriately. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_80" aria-label="80"/>Without resilient error-handling mechanisms, the code might inadvertently trust a malicious item masquerading as something benign! Thus, in this chapter, the code snippets don’t omit such important error checks.</p>&#13;
<p class="TX">The first step to extracting the code signing information of any item is to obtain what is referred to as a <i>code object</i> reference that you can then pass to all subsequent code signing API calls. For on-disk items such as disk images, you’ll obtain a static code object of type <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeRef</span>.<sup><a role="doc-noteref" id="chapter3_7" href="#chapter3-7">7</a></sup> For running processes, you’ll instead obtain a dynamic code object of type <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeRef</span>.<sup><a role="doc-noteref" id="chapter3_8" href="#chapter3-8">8</a></sup></p>&#13;
<p class="TX">To obtain a static code reference from a disk image, invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCreateWithPath</span> API with a path to the specified disk image, optional flags, and an out pointer. Once the function returns, this out pointer will contain a <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCode</span> object for use in subsequent API calls (<a href="chapter3.xhtml#Lis3-1">Listing 3-1</a>).<sup><a role="doc-noteref" id="chapter3_9" href="#chapter3-9">9</a></sup> Note that you should free this pointer using <span class="SANS_TheSansMonoCd_W5Regular_11">CFRelease</span> once you’re done with it.</p>&#13;
<span id="Lis3-1"/>&#13;
<pre><code>NSMutableDictionary* checkImage(NSString* item) {&#13;
    SecStaticCodeRef codeRef = NULL;&#13;
    NSMutableDictionary* signingInfo = [NSMutableDictionary dictionary];&#13;
&#13;
  <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span> CFURLRef itemURL = (__bridge CFURLRef)([NSURL fileURLWithPath:item]);&#13;
&#13;
  <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span> OSStatus status = SecStaticCodeCreateWithPath(itemURL, kSecCSDefaultFlags, &amp;codeRef);&#13;
  <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span> if(errSecSuccess != status) {&#13;
        goto bail;&#13;
    }&#13;
    ...&#13;
&#13;
bail:&#13;
    if(nil != codeRef) {&#13;
        CFRelease(codeRef);&#13;
    }&#13;
    return signingInfo;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: Obtaining a static code object for a disk image</span></p>&#13;
<p class="TX">After initializing a URL object containing the path of the disk image we’re to check <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCreateWithPath</span> API <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If this function fails, it will return a nonzero value <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If <span class="SANS_TheSansMonoCd_W5Regular_11">Sec*</span> APIs succeed, they return zero, which maps to the preferred <span class="SANS_TheSansMonoCd_W5Regular_11">errSecSuccess</span> constant. I discuss the error codes that the <span class="SANS_TheSansMonoCd_W5Regular_11">Sec*</span> APIs may return in <span class="Xref">“Code Signing Error Codes” on <a href="chapter3.xhtml#pg_97">page 97</a></span>. They’re also detailed in Apple’s “Code Signing Services Result Codes” documentation.<sup><a role="doc-noteref" id="chapter3_10" href="#chapter3-10">10</a></sup> Also note that when we are done with the code reference, we must release it via <span class="SANS_TheSansMonoCd_W5Regular_11">CFRelease</span>.</p>&#13;
<p class="TX">In this and subsequent code snippets, you’ll see the use of <i>bridging</i>, a mechanism to cast Objective-C objects in a toll-free manner into (and out of) the Core Foundation objects used by Apple’s code signing APIs. For example, in <a href="chapter3.xhtml#Lis3-1">Listing 3-1</a>, the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCreateWithPath</span> API expects a <span class="SANS_TheSansMonoCd_W5Regular_11">CFURLRef</span> as its first argument. After converting the path of the disk image to an <span class="SANS_TheSansMonoCd_W5Regular_11">NSURL</span> object, we bridge it to a <span class="SANS_TheSansMonoCd_W5Regular_11">CFURLRef</span> using <span class="SANS_TheSansMonoCd_W5Regular_11">(__bridge CFURLRef)</span>. You can read more about bridging in Apple’s “Core Foundation Design Concepts.”<sup><a role="doc-noteref" id="chapter3_11" href="#chapter3-11">11</a></sup></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_81" aria-label="81"/>Once we’ve created a static code object for the disk image, we can invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCheckValidity</span> API with the just-created <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCode</span> object to check its validity, saving the result of the call so we can return it to the caller (<a href="chapter3.xhtml#Lis3-2">Listing 3-2</a>).</p>&#13;
<span id="Lis3-2"/>&#13;
<pre><code>...&#13;
#define KEY_SIGNATURE_STATUS @"signatureStatus"&#13;
&#13;
status = SecStaticCodeCheckValidity(codeRef, kSecCSEnforceRevocationChecks, NULL);&#13;
signingInfo[KEY_SIGNATURE_STATUS] = [NSNumber numberWithInt:status];&#13;
if(errSecSuccess != status) {&#13;
    goto bail;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: Checking a disk image’s code signing validity</span></p>&#13;
<p class="TX">You’ll normally see this API invoked with the <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCSDefaultFlags</span> constant, which contains a default set of flags, but to perform certificate revocation checks as part of the validation, you need to pass in <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCSEnforceRevocationChecks</span>.</p>&#13;
<p class="TX">Next, we check that the invocation succeeded. If we fail to perform this validation, malicious code may be able to subvert code signing checks.<sup><a role="doc-noteref" id="chapter3_12" href="#chapter3-12">12</a></sup> If the API fails, for example, with <span class="SANS_TheSansMonoCd_W5Regular_11">errSecCSUnsigned</span>, you’ll likely want to abort the extraction of any further code signing information, which either won’t be present (in the case of unsigned items) or won’t be trustworthy.</p>&#13;
<p class="TX">Once we’ve determined the validity of the disk image’s code signing status, we can extract its code signing information via the <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopySigningInformation</span> API. We pass this API the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCode</span> object, the <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCSSigningInformation</span> flag, and an out pointer to a dictionary to populate with the disk image’s code signing details (<a href="chapter3.xhtml#Lis3-3">Listing 3-3</a>).</p>&#13;
<span id="Lis3-3"/>&#13;
<pre><code>CFDictionaryRef signingDetails = NULL;&#13;
&#13;
status = SecCodeCopySigningInformation(codeRef,&#13;
kSecCSSigningInformation, &amp;signingDetails);&#13;
if(errSecSuccess != status) {&#13;
    goto bail;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: Extracting code signing information</span></p>&#13;
<p class="TX">Now we can extract stored details from the dictionary, such as the certificate authority chain, using the key <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCodeInfoCertificates</span> (<a href="chapter3.xhtml#Lis3-4">Listing 3-4</a>).</p>&#13;
<span id="Lis3-4"/>&#13;
<pre><code>#define KEY_SIGNING_AUTHORITIES @"signatureAuthorities"&#13;
&#13;
signingInfo[KEY_SIGNING_AUTHORITIES] = ((__bridge NSDictionary*)signingDetails)&#13;
[(__bridge NSString*)kSecCodeInfoCertificates];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: Extracting the certificate authority chain</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_82" aria-label="82"/>If the item has an ad hoc signature, it won’t have an entry under the <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCodeInfoCertificates</span> key in its code signing dictionary. Another way to identify ad hoc signatures is to check the <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCodeInfoFlags</span> key, which contains the item’s code signing flags. For ad hoc signatures, we’ll find the second least significant bit (<span class="SANS_TheSansMonoCd_W5Regular_11">2</span>) set in the flag, which, after consulting Apple’s <i>cs_blobs.h</i> header file, we see maps to the constant <span class="SANS_TheSansMonoCd_W5Regular_11">CS_ADHOC</span>.</p>&#13;
<p class="TX">It’s rare to see disk images signed in an ad hoc manner, as they don’t require a signature to begin with, but because apps and binaries must be signed to run, you’ll commonly see malware signed in this way. We can extract the code signing flags in the manner shown in <a href="chapter3.xhtml#Lis3-5">Listing 3-5</a>.</p>&#13;
<span id="Lis3-5"/>&#13;
<pre><code>#define KEY_SIGNING_FLAGS @"flags"&#13;
&#13;
signingInfo[KEY_SIGNING_FLAGS] = [(__bridge NSDictionary*)signingDetails&#13;
objectForKey:(__bridge NSString*)kSecCodeInfoFlags];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-5: Extracting an item’s code signing flags</span></p>&#13;
<p class="TX">We could then check these extracted flags for the value indicating an ad hoc signature (<a href="chapter3.xhtml#Lis3-6">Listing 3-6</a>).</p>&#13;
<span id="Lis3-6"/>&#13;
<pre><code>if([results[KEY_SIGNING_FLAGS] intValue] &amp; CS_ADHOC) {&#13;
    // Code here will run only if item is signed in an ad hoc manner.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-6: Verifying code signing flags</span></p>&#13;
<p class="TX">The dictionary stores these flags in a number object, so we must first convert them to an integer and then perform a bitwise AND operation (<span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span>) to check for the bits specified by <span class="SANS_TheSansMonoCd_W5Regular_11">CS_ADHOC</span>.</p>&#13;
<p class="TX">When we’re finished with the <span class="SANS_TheSansMonoCd_W5Regular_11">CFDictionaryRef</span> dictionary, we must free it via <span class="SANS_TheSansMonoCd_W5Regular_11">CFRelease</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2"><span id="sec5"/><span id="h2-26"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting Notarization Information</span></h4>&#13;
<p class="TNI">To extract the notarization status of the disk images, we can use the <span class="SANS_TheSansMonoCd_W5Regular_11">SecRequirementCreateWithString</span> API, which lets us create a requirement to which an item must conform. In <a href="chapter3.xhtml#Lis3-7">Listing 3-7</a>, we create a requirement with the string <span class="SANS_TheSansMonoCd_W5Regular_11">"notarized"</span>.</p>&#13;
<span id="Lis3-7"/>&#13;
<pre><code>static SecRequirementRef requirement = NULL;&#13;
SecRequirementCreateWithString(CFSTR("notarized"), kSecCSDefaultFlags, &amp;requirement);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-7: Initializing a requirement reference string</span></p>&#13;
<p class="TX">The API generates an object by compiling the code requirement string we pass to it, allowing us to use the requirement multiple times.<sup><a role="doc-noteref" id="chapter3_13" href="#chapter3-13">13</a></sup> If you’re performing a one-time requirement check, you can skip the compilation step and instead use the <span class="SANS_TheSansMonoCd_W5Regular_11">SecTaskValidateForRequirement</span> API, which takes a string-based requirement to validate as a second argument.</p>&#13;
<p class="TX">Now we can call the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCheckValidity</span> API, passing it the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCode</span> object, as well as the requirement reference (<a href="chapter3.xhtml#Lis3-8">Listing 3-8</a>).</p>&#13;
<span id="Lis3-8"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_83" aria-label="83"/>if(errSecSuccess == SecStaticCodeCheckValidity(codeRef, kSecCSDefaultFlags, requirement)) {&#13;
    // Code placed here will run only if the item is notarized.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-8: Checking a notarization requirement</span></p>&#13;
<p class="TX">If the API returns <span class="SANS_TheSansMonoCd_W5Regular_11">errSecSuccess</span>, we know that the item conforms to the requirement we passed in. In our case, this means the disk image is indeed notarized. You can read more about requirements, including useful requirement strings, in Apple’s informative “Code Signing Requirement Language” document.<sup><a role="doc-noteref" id="chapter3_14" href="#chapter3-14">14</a></sup></p>&#13;
<p class="TX">If the notarization validation fails, we should check whether Apple has revoked the item’s notarization ticket, even if the item is validly signed. This nuanced case presents a huge red flag; for an example, see the discussion of the 3CX supply chain attack in <span class="Xref">“On-Disk Applications and Executables” on <a href="chapter3.xhtml#pg_93">page 93</a></span>.</p>&#13;
<p class="TX">Although I’ve asked for one,<sup><a role="doc-noteref" id="chapter3_15" href="#chapter3-15">15</a></sup> Apple has not approved any method of determining whether an item’s notarization ticket has been revoked. However, two undocumented APIs, <span class="SANS_TheSansMonoCd_W5Regular_11">SecAssessmentCreate</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">SecAssessmentTicketLookup</span>, can provide this information. In <a href="chapter3.xhtml#Lis3-9">Listing 3-9</a>, we invoke <span class="SANS_TheSansMonoCd_W5Regular_11">SecAssessmentCreate</span> to check whether an item that has passed other code signing checks has had its notarization ticket revoked.</p>&#13;
<span id="Lis3-9"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> SecAssessmentRef secAssessment = SecAssessmentCreate(itemURL,&#13;
kSecAssessmentDefaultFlags, (__bridge CFDictionaryRef)(@{}), &amp;error);&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if(NULL == secAssessment) {&#13;
    if((CSSMERR_TP_CERT_REVOKED == CFErrorGetCode(error)) ||&#13;
        (errSecCSRevokedNotarization == CFErrorGetCode(error))) {&#13;
        signingInfo[KEY_SIGNING_NOTARIZED] =&#13;
        [NSNumber numberWithInteger:errSecCSRevokedNotarization];&#13;
    }&#13;
}&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if(NULL != secAssessment) {&#13;
    CFRelease(secAssessment);&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-9: Checking whether a notarization ticket has been revoked</span></p>&#13;
<p class="TX">We pass the function the path to the item, such as a disk image; the default assessment flags; an empty but non-<span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> dictionary; and an out pointer to an error variable <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">If Apple has revoked either the notarization ticket or the certificate, the function will set an error to <span class="SANS_TheSansMonoCd_W5Regular_11">CSSMERR_TP_CERT_REVOKED</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">errSecCSRevokedNotarization</span>. The name of the first error is a bit nuanced, as it can return items with valid certificates but revoked notarization tickets, which is what we’re interested in here.</p>&#13;
<p class="TX">If we receive a <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> assessment and either of these error codes <span class="CodeAnnotation" aria-label="annotation2">❷</span>, we know something has been revoked. Moreover, because we’ve already validated the code signing certificates, we know that the revocation refers to the notarization ticket. Once we’re done with the assessment, we make sure to free it if it’s not <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_84" aria-label="84"/>&#13;
<h4 class="H2"><span id="sec6"/><span id="h2-27"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Tool</span></h4>&#13;
<p class="TNI">Let’s compile the <i>checkSignature</i> project and run it against the disk images mentioned earlier in this section:</p>&#13;
&#13;
<pre><code>% <b>./checkSignature LuLu_2.6.0.dmg</b>&#13;
Checking: LuLu_2.6.0.dmg&#13;
Status: signed&#13;
Is notarized: no&#13;
&#13;
Signing auths: (&#13;
    "&lt;cert(0x11100a800) s: Developer ID Application: Objective-See, LLC (VBG97UB4TA)&#13;
    i: Developer ID Certification Authority&gt;",&#13;
    "&lt;cert(0x111808200) s: Developer ID Certification Authority i: Apple Root CA&gt;",&#13;
    "&lt;cert(0x111808a00) s: Apple Root CA i: Apple Root CA&gt;"&#13;
)&#13;
</code></pre>&#13;
<p class="TX">As expected, the code reports that LuLu’s disk image is signed, though it isn’t notarized. The code also extracts the chain of its code signing authorities, which include its developer ID application and its developer ID certification authority. (When detecting malware, you may want to ignore disk images signed via trusted developer IDs unless you’re interested in detecting supply chain attacks.)</p>&#13;
<p class="TX">Now let’s run the code against the EvilQuest malware. As you’ll see, the code matches the results from Apple’s <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> utility, indicating that the disk image is unsigned:</p>&#13;
&#13;
<pre><code>% <b>./checkSignature "EvilQuest/Mixed In Key 8.dmg"</b>&#13;
Checking: Mixed In Key 8.dmg&#13;
Status: unsigned&#13;
</code></pre>&#13;
<p class="TX">Finally, we run the code against the CreativeUpdate malware, whose code signing certificate has been revoked:</p>&#13;
&#13;
<pre><code>% <b>./checkSignature "CreativeUpdate/Firefox 58.0.2.dmg"</b>&#13;
Checking: Firefox 58.0.2.dmg&#13;
Status: revoked&#13;
</code></pre>&#13;
<p class="TX">Now that we can programmatically extract and validate code signing information from disk images, let’s do the same for packages, which unfortunately require a completely different approach.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1"><span id="sec7"/><span id="h1-28"/><span class="SANS_Futura_Std_Bold_B_11">Packages</span></h3>&#13;
<p class="TNI">You can manually verify the signature of a package (<i>.pkg</i>) with the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> utility. Execute it with the <span class="SANS_TheSansMonoCd_W5Regular_11">--check-signature</span> command line option, followed by the path of the <i>.pkg</i> file you’d like to verify. The utility should display the result of the check in a line prefixed with <span class="SANS_TheSansMonoCd_W5Regular_11">Status</span>:</p>&#13;
&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_85" aria-label="85"/>% <b>pkgutil --check-signature GoogleChrome.pkg</b>&#13;
Package "GoogleChrome.pkg":&#13;
   Status: signed by a developer certificate issued by Apple for distribution&#13;
   Notarization: trusted by the Apple notary service&#13;
   Signed with a trusted timestamp on: 05-15 20:46:50 +0000&#13;
   Certificate Chain:&#13;
    1. Developer ID Installer: Google LLC (EQHXZ8M8AV)&#13;
       Expires: 2027-02-01 22:12:15 +0000&#13;
       SHA256 Fingerprint:&#13;
           40 02 6A 12 12 38 F4 E0 3F 7B CE 86 FA 5A 22 2B DA 7A 3A 20 70 FF&#13;
           28 0D 86 AA 4E 02 56 C5 B2 B4&#13;
       -----------------------------------------------------------------------&#13;
    2. Developer ID Certification Authority&#13;
       Expires: 2027-02-01 22:12:15 +0000&#13;
       SHA256 Fingerprint:&#13;
           7A FC 9D 01 A6 2F 03 A2 DE 96 37 93 6D 4A FE 68 09 0D 2D E1 8D 03&#13;
           F2 9C 88 CF B0 B1 BA 63 58 7F&#13;
       -----------------------------------------------------------------------&#13;
    3. Apple Root CA&#13;
       Expires: 2035-02-09 21:40:36 +0000&#13;
       SHA256 Fingerprint:&#13;
           B0 B1 73 0E CB C7 FF 45 05 14 2C 49 F1 29 5E 6E DA 6B CA ED 7E 2C&#13;
           68 C5 BE 91 B5 A1 10 01 F0 24&#13;
</code></pre>&#13;
<p class="TX">The results show that <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> has verified that the package, a Google Chrome installer, is signed and notarized. The tool also displayed the certificate authority chain, which indicates that the package was signed via an Apple Developer ID belonging to Google.</p>&#13;
<p class="TX">Note that you can’t use the <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> utility to check the code signature of packages, as <i>.pkg</i> files use a different mechanism for storing code signing information that <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> doesn’t understand. For example, when run against the same package, it detects no signature:</p>&#13;
&#13;
<pre><code>% <b>codesign –-verify -dvv GoogleChrome.pkg</b>&#13;
GoogleChrome.pkg: code object is not signed at all&#13;
</code></pre>&#13;
<p class="TX">If a package isn’t signed, <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> will display a <span class="SANS_TheSansMonoCd_W5Regular_11">Status: no signature</span> message. Most malware distributed via packages, including EvilQuest, falls into this category. These disk images contain a malicious package, and once the disk image is mounted, we can use <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> to show that this package is unsigned:</p>&#13;
&#13;
<pre><code>% <b>pkgutil --check-signature "EvilQuest/Mixed In Key 8.pkg"</b>&#13;
Package "Mixed In Key 8.pkg":&#13;
   Status: no signature&#13;
</code></pre>&#13;
<p class="TX">Finally, if a package was signed but Apple has revoked its code signing certificate, <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> will display <span class="SANS_TheSansMonoCd_W5Regular_11">Status: revoked signature</span> but will still show <span role="doc-pagebreak" epub:type="pagebreak" id="pg_86" aria-label="86"/>the certificate chain. We find an example of this behavior in a package used to distribute the KeySteal malware:</p>&#13;
&#13;
<pre><code>% <b>pkgutil --check-signature KeySteal/archive.pkg</b>&#13;
Package "archive.pkg":&#13;
   Status: revoked signature&#13;
   Signed with a trusted timestamp on: 10-18 12:58:45 +0000&#13;
   Certificate Chain:&#13;
    1. Developer ID Installer: fenghua he (32W7BZNTSV)&#13;
       Expires: 2027-02-01 22:12:15 +0000&#13;
       SHA256 Fingerprint:&#13;
           EC 7C 85 1D B0 A0 8C ED 45 31 6B 8E 9D 7D 34 0F 45 B8 4E CE 9D 9C&#13;
           97 DB 2F 63 57 C2 D9 71 0C 4E&#13;
       -----------------------------------------------------------------------&#13;
    2. Developer ID Certification Authority&#13;
       Expires: 2027-02-01 22:12:15 +0000&#13;
       SHA256 Fingerprint:&#13;
           7A FC 9D 01 A6 2F 03 A2 DE 96 37 93 6D 4A FE 68 09 0D 2D E1 8D 03&#13;
           F2 9C 88 CF B0 B1 BA 63 58 7F&#13;
       -----------------------------------------------------------------------&#13;
    3. Apple Root CA&#13;
       Expires: 2035-02-09 21:40:36 +0000&#13;
       SHA256 Fingerprint:&#13;
           B0 B1 73 0E CB C7 FF 45 05 14 2C 49 F1 29 5E 6E DA 6B CA ED 7E 2C&#13;
           68 C5 BE 91 B5 A1 10 01 F0 24&#13;
</code></pre>&#13;
<p class="TX">Apple has revoked the signature. In addition, the revoked code signing identifier, fenghua he (32W7BZNTSV), may help you find other malware signed by the same malware author.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2"><span id="sec8"/><span id="h2-28"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reverse Engineering pkgutil</span></h4>&#13;
<p class="TNI">Now, you may be wondering how to programmatically check the signatures of packages. This is a good question, as there are currently no public APIs for verifying a package! Thanks, Cupertino.</p>&#13;
<p class="TX">Luckily, a quick reverse engineering session of the <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> binary reveals exactly how it checks the signature of packages. To begin, we can see that <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> is linked against the private <i>PackageKit</i> framework:</p>&#13;
&#13;
<pre><code>% <b>otool -L /usr/sbin/pkgutil</b>&#13;
/usr/sbin/pkgutil:&#13;
...&#13;
/System/Library/PrivateFrameworks/PackageKit.framework/Versions/A/PackageKit&#13;
...&#13;
</code></pre>&#13;
<p class="TX">The name of this framework suggests that it likely contains relevant APIs. Traditionally found in the <i>/System/Library/PrivateFrameworks/</i> directory, the framework lives in the shared <i>dyld cache</i>, a prelinked shared file containing commonly used libraries, on recent versions of macOS.<sup><a role="doc-noteref" id="chapter3_16" href="#chapter3-16">16</a></sup> Its name and location depend on the version of macOS and the architecture of the system but might look something like <i>dyld_shared_cache_arm64e</i> and <i>/System/Volumes/Preboot/Cryptexes/OS/System/Library/dyld/</i>, respectively.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_87" aria-label="87"/>We must extract the <i>PackageKit</i> framework from the <i>dyld</i> cache before we can reverse engineer it. A tool such as Hopper, shown in <a href="chapter3.xhtml#fig3-2">Figure 3-2</a>, can extract frameworks from the cache.</p>&#13;
<figure class="IMG"><img class="img7" id="fig3-2" src="../images/Figure3-2.jpg" alt="" width="1203" height="862"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Extracting the</span> <span class="SANS_Futura_Std_Book_11">PackageKit</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">framework from the</span> <span class="SANS_Futura_Std_Book_11">dyld</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">cache</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you prefer to use a command line tool to extract libraries, one good option is the <i>dyld-shared-cache-extractor</i>.<sup><a role="doc-noteref" id="chapter3_17" href="#chapter3-17">17</a></sup> After installing this tool, you can execute it with the path of the <i>dyld</i> cache and an output directory, which we specify here as <i>/tmp/libraries</i>:</p>&#13;
&#13;
<pre><code>% <b>dyld-shared-cache-extractor /System/Volumes/Preboot/Cryptexes/OS/System/</b>&#13;
<b>Library/dyld/dyld_shared_cache_arm64e /tmp/libraries</b>&#13;
</code></pre>&#13;
<p class="TX">Once the tool has extracted all of the libraries from the cache, you’ll find the <i>PackageKit</i> framework at <i>/tmp/libraries/System/Library/Private Frameworks/PackageKit.framework</i>.</p>&#13;
<p class="TX">Now we can load the framework into a disassembler to gain insight into its APIs and internals. For example, we find a class named <span class="SANS_TheSansMonoCd_W5Regular_11">PKArchive</span> that contains useful methods, such as <span class="SANS_TheSansMonoCd_W5Regular_11">archiveWithPath:</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">verifyReturningError:</span>, among others:</p>&#13;
&#13;
<pre><code>@interface PKArchive : NSObject&#13;
    +(id)archiveWithPath:(id)arg1;&#13;
    +(id)_allArchiveClasses;&#13;
    -(BOOL)closeArchive;&#13;
    -(BOOL)fileExistsAtPath:(id)arg1;&#13;
    -(BOOL)verifyReturningError:(id*)arg1;&#13;
    ...&#13;
@end&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_88" aria-label="88"/>I won’t cover the full details of reverse engineering the <i>PackageKit</i> framework here, but you can learn more about the process online.<sup><a role="doc-noteref" id="chapter3_18" href="#chapter3-18">18</a></sup> You can also find the entirety of my package verification source code in my What’s Your Sign utility’s <i>Package.h/Package.m</i> file.<sup><a role="doc-noteref" id="chapter3_19" href="#chapter3-19">19</a></sup></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2"><span id="sec9"/><span id="h2-29"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing Framework Functions</span></h4>&#13;
<p class="TNI">To use the methods we’ve discovered in our <i>checkSignature</i> project, we’ll need a header file containing the private class definitions from the <i>PackageKit</i> framework. This will allow us to invoke them directly from our code. In the past, tools such as <span class="SANS_TheSansMonoCd_W5Regular_11">class-dump</span> could easily create such header files,<sup><a role="doc-noteref" id="chapter3_20" href="#chapter3-20">20</a></sup> but this approach isn’t fully compatible with newer Apple Silicon binaries. Instead, you can manually extract these class definitions from a disassembler or by using <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span>. <a href="chapter3.xhtml#Lis3-10">Listing 3-10</a> shows the extracted definitions.</p>&#13;
<span id="Lis3-10"/>&#13;
<pre><code>@interface PKArchive : NSObject&#13;
    +(id)archiveWithPath:(id)arg1;&#13;
    +(id)_allArchiveClasses;&#13;
    -(BOOL)closeArchive;&#13;
    -(BOOL)fileExistsAtPath:(id)arg1;&#13;
    -(BOOL)verifyReturningError:(id*)arg1;&#13;
    ...&#13;
&#13;
    @property(readonly) NSString* archiveDigest;&#13;
    @property(readonly) NSString* archivePath;&#13;
    @property(readonly) NSDate* archiveSignatureDate;&#13;
    @property(readonly) NSArray* archiveSignatures;&#13;
@end&#13;
&#13;
@interface PKArchiveSignature : NSObject&#13;
{&#13;
    struct __SecTrust* _verifyTrustRef;&#13;
}&#13;
&#13;
    -(struct __SecTrust*)verificationTrustRef;&#13;
    -(BOOL)verifySignedDataReturningError:(id *)arg1;&#13;
    -(BOOL)verifySignedData;&#13;
    ...&#13;
&#13;
    @property(readonly) NSString* algorithmType;&#13;
    @property(readonly) NSArray* certificateRefs;&#13;
@end&#13;
...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-10: The</span> <span class="SANS_Futura_Std_Book_11">PackageKit</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">framework’s extracted class and method definitions</span></p>&#13;
<p class="TX">Now we can write code to use these classes, invoking their methods to programmatically verify packages of our choosing. We’ll do this in a function we name <span class="SANS_TheSansMonoCd_W5Regular_11">checkPackage</span>. As its only argument, it takes a path to the package to verify and returns a dictionary containing the results of verification, plus other <span role="doc-pagebreak" epub:type="pagebreak" id="pg_89" aria-label="89"/>code signing information, such as the package’s code signing authorities. The function starts by loading the required <i>PackageKit</i> framework (<a href="chapter3.xhtml#Lis3-11">Listing 3-11</a>).</p>&#13;
<span id="Lis3-11"/>&#13;
<pre><code>#define PACKAGE_KIT @"/System/Library/PrivateFrameworks/PackageKit.framework" <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
NSMutableDictionary* checkPackage(NSString* package) {&#13;
    NSBundle* packageKit = [NSBundle bundleWithPath:PACKAGE_KIT]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    [packageKit load];&#13;
&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-11: Loading the</span> <span class="SANS_Futura_Std_Book_11">PackageKit</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">framework</span></p>&#13;
<p class="TX">First, we define the path to the <i>PackageKit</i> framework <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We then load the framework with the <span class="SANS_TheSansMonoCd_W5Regular_11">NSBundle</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">bundleWithPath:</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">load</span> methods so that we can dynamically resolve and invoke the framework’s methods <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Due to its introspective nature, the Objective-C programming language makes it easy to use private classes and invoke private methods. To access a private class, use the <span class="SANS_TheSansMonoCd_W5Regular_11">NSClassFromString</span> function. For example, <a href="chapter3.xhtml#Lis3-12">Listing 3-12</a> shows how to dynamically obtain the class object for the <span class="SANS_TheSansMonoCd_W5Regular_11">PKArchive</span> class.</p>&#13;
<span id="Lis3-12"/>&#13;
<pre><code><span class="SANS_TheSansMonoCd_W5Regular_11">Class PKArchiveCls = NSClassFromString(@"PKArchive");</span></code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-12: Obtaining the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PKArchive</span> class object</span></p>&#13;
<p class="TX">Reverse engineering <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> revealed that it instantiates an archive object (<span class="SANS_TheSansMonoCd_W5Regular_11">PKXARArchive</span>) using the <span class="SANS_TheSansMonoCd_W5Regular_11">PKArchive</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">archiveWithPath:</span> method, along with the path of the package to validate. In <a href="chapter3.xhtml#Lis3-13">Listing 3-13</a>, our code does the same.</p>&#13;
<span id="Lis3-13"/>&#13;
<pre><code><span class="SANS_TheSansMonoCd_W5Regular_11">PKXARArchive* archive = [PKArchiveCls archiveWithPath:package];</span></code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-13: Instantiating an archive object</span></p>&#13;
<p class="TX">When dealing with private classes such as the <span class="SANS_TheSansMonoCd_W5Regular_11">PKArchive</span> class, note that it’s wise to invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">respondsToSelector:</span> method before invoking its methods. The <span class="SANS_TheSansMonoCd_W5Regular_11">respondsToSelector:</span> method will return a Boolean value that tells you whether you can safely invoke the method on the class or class instance.<sup><a role="doc-noteref" id="chapter3_21" href="#chapter3-21">21</a></sup> If you skip this step and an object doesn’t respond to a method, it will crash your program with an <span class="SANS_TheSansMonoCd_W5Regular_11">unrecognized selector sent to class</span> exception.</p>&#13;
<p class="TX">The following code checks to make sure the <span class="SANS_TheSansMonoCd_W5Regular_11">PKArchive</span> class implements the <span class="SANS_TheSansMonoCd_W5Regular_11">archiveWithPath:</span> method (<a href="chapter3.xhtml#Lis3-14">Listing 3-14</a>).</p>&#13;
<span id="Lis3-14"/>&#13;
<pre><code>if(YES != [PKArchiveCls respondsToSelector:@selector(archiveWithPath:)]) {&#13;
    goto bail;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-14: Checking for a method</span></p>&#13;
<p class="TX">Now we’re ready to perform some basic package validation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_90" aria-label="90"/>&#13;
<h4 class="H2"><span id="sec10"/><span id="h2-30"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating the Package</span></h4>&#13;
<p class="TNI">Again, we mimic <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">PKXARArchive</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">verifyReturningError:</span> method (<a href="chapter3.xhtml#Lis3-15">Listing 3-15</a>).</p>&#13;
<span id="Lis3-15"/>&#13;
<pre><code>NSError* error = nil;&#13;
if(YES != [archive verifyReturningError:&amp;error]) {&#13;
    goto bail;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-15: Performing basic package validation</span></p>&#13;
<p class="TX">Once the package has passed basic verification checks, we can check its signature, which we find in the archive’s <span class="SANS_TheSansMonoCd_W5Regular_11">archiveSignatures</span> instance variable. This variable is an array holding pointers to <span class="SANS_TheSansMonoCd_W5Regular_11">PKArchiveSignature</span> objects. A signed package will have at least one signature (<a href="chapter3.xhtml#Lis3-16">Listing 3-16</a>).</p>&#13;
<span id="Lis3-16"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> NSArray* signatures = archive.archiveSignatures;&#13;
if(0 == signatures.count) {&#13;
    goto bail;&#13;
}&#13;
&#13;
PKArchiveSignature* signature = signatures.firstObject;&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if(YES != [signature verifySignedDataReturningError:&amp;error]) {&#13;
    goto bail;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-16: Verifying a package’s leaf signature</span></p>&#13;
<p class="TX">After ensuring that the package has at least one signature <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we verify the first, or <i>leaf</i>, signature, using the <span class="SANS_TheSansMonoCd_W5Regular_11">PKArchiveSignature</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">verifySignedDataReturningError:</span> method <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Additionally, we evaluate the trust of this signature (<a href="chapter3.xhtml#Lis3-17">Listing 3-17</a>).</p>&#13;
<span id="Lis3-17"/>&#13;
<pre><code>Class PKTrustCls = NSClassFromString(@"PKTrust");&#13;
&#13;
struct __SecTrust* trustRef = [signature verificationTrustRef];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> PKTrust* pkTrust = [[PKTrustCls alloc] initWithSecTrust:trustRef&#13;
usingAppleRoot:YES signatureDate:archive.archiveSignatureDate];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if(YES != [pkTrust evaluateTrustReturningError:&amp;error]) {&#13;
    goto bail;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-17: Evaluating the trust of a signature</span></p>&#13;
<p class="TX">We instantiate a <span class="SANS_TheSansMonoCd_W5Regular_11">PKTrust</span> object with the signature <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">PKTrust</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">evaluateTrustReturningError:</span> method <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If <span class="SANS_TheSansMonoCd_W5Regular_11">verificationTrustRef</span> returns nil, we can validate the package via certificates by using the <span class="SANS_TheSansMonoCd_W5Regular_11">PKTrust</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">initWithCertificates:usingAppleRoot:signatureDate:</span> method. See this chapter’s <i>checkSignature</i> project code for more details. If the signature and signature trust verifications pass, we have a validly signed package.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_91" aria-label="91"/>You could also extract the signature’s certificates, which would allow you to perform actions like checking the name of each signing authority. You can access these certificates through the <span class="SANS_TheSansMonoCd_W5Regular_11">PKArchiveSignature</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">certificateRefs</span> instance variable, which is an array of <span class="SANS_TheSansMonoCd_W5Regular_11">SecCertificateRef</span> objects, and extract their information with the <span class="SANS_TheSansMonoCd_W5Regular_11">SecCertificate*</span> APIs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2"><span id="sec11"/><span id="h2-31"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking Package Notarization</span></h4>&#13;
<p class="TNI">I’ll wrap up this section by showing how to determine whether Apple has notarized a package. Recall that <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> leverages the private <i>PackageKit</i> framework to validate packages. However, reverse engineering revealed that the package notarization checks aren’t implemented in that framework with the rest of the checks, but rather directly in the <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> binary.</p>&#13;
<p class="TX">To check the notarization status of a package, <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">SecAssessmentTicketLookup</span> API. Though this API is undocumented, we find its declaration in Apple’s <i>SecAssessment.h</i> header file. <a href="chapter3.xhtml#Lis3-18">Listing 3-18</a> mimics <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span>’s approach. Given a validated <span class="SANS_TheSansMonoCd_W5Regular_11">PKArchiveSignature</span> object from a package, it determines whether the package has been notarized.</p>&#13;
<span id="Lis3-18"/>&#13;
<pre><code>#import &lt;CommonCrypto/CommonDigest.h&gt;&#13;
&#13;
typedef uint64_t SecAssessmentTicketFlags;&#13;
enum {&#13;
    kSecAssessmentTicketFlagDefault = 0,&#13;
    kSecAssessmentTicketFlagForceOnlineCheck = 1 &lt;&lt; 0,&#13;
    kSecAssessmentTicketFlagLegacyListCheck = 1 &lt;&lt; 1,&#13;
};&#13;
&#13;
Boolean SecAssessmentTicketLookup(CFDataRef hash, SecCSDigestAlgorithm&#13;
hashType, SecAssessmentTicketFlags flags, double* date, CFErrorRef* errors);&#13;
&#13;
BOOL isPackageNotarized(PKArchiveSignature* signature) {&#13;
    CFErrorRef error = NULL;&#13;
    BOOL isItemNotarized = NO;&#13;
    double notarizationDate = 0;&#13;
&#13;
    SecCSDigestAlgorithm hashType = kSecCodeSignatureHashSHA1;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> NSData* hash = [signature signedDataReturningAlgorithm:0x0];&#13;
    if(CC_SHA1_DIGEST_LENGTH == hash.length) {&#13;
        hashType = kSecCodeSignatureHashSHA1;&#13;
    } else if(CC_SHA256_DIGEST_LENGTH == hash.length) {&#13;
        hashType = kSecCodeSignatureHashSHA256;&#13;
    }&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if(YES == SecAssessmentTicketLookup((__bridge CFDataRef)(hash), hashType,&#13;
    kSecAssessmentTicketFlagDefault, &amp;notarizationDate, &amp;error)) {&#13;
        isItemNotarized = YES;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if(YES == SecAssessmentTicketLookup((__bridge CFDataRef)(hash),&#13;
    hashType, kSecAssessmentTicketFlagForceOnlineCheck, &amp;notarizationDate,&#13;
    &amp;error)) {&#13;
        isItemNotarized = YES;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_92" aria-label="92"/>    }&#13;
&#13;
    return isItemNotarized;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-18: A package notarization check</span></p>&#13;
<p class="TX">We declare various variables, most of which we’ll need for the <span class="SANS_TheSansMonoCd_W5Regular_11">SecAssessmentTicketLookup</span> API call. We then invoke the signature’s <span class="SANS_TheSansMonoCd_W5Regular_11">signedDataReturningAlgorithm:</span> method, which returns a data object containing a hash <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">Next, we make the first call to <span class="SANS_TheSansMonoCd_W5Regular_11">SecAssessmentTicketLookup</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, passing it the hash and hash type, which will be either SHA-1 or SHA-256, represented by the <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCodeSignatureHashSHA1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCodeSignatureHashSHA256</span> constants, respectively. We also pass in the assessment flags and an out pointer that will receive the date of the notarization if the package is notarized. The last argument is an optional out pointer to an error variable.</p>&#13;
<p class="TX">Mimicking the <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span> binary, we first invoke the API with the assessment flags set to <span class="SANS_TheSansMonoCd_W5Regular_11">kSecAssessmentTicketFlagDefault</span>. If this call fails to determine whether the package is notarized, we invoke the API again, this time with the flag set to <span class="SANS_TheSansMonoCd_W5Regular_11">kSecAssessmentTicketFlagForceOnlineCheck</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. You can find these and other flag values in the <i>SecAssessment.h</i> header file.</p>&#13;
<p class="TX">If either API invocation returns a nonzero value, the package is notarized, and the Apple notary service trusts it. Because we mimicked <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span>, however, our code doesn’t specify whether a non-notarized package has had its notarization ticket revoked. Given an item’s code signing hash and hash type, we could implement such a check in the manner shown in <a href="chapter3.xhtml#Lis3-19">Listing 3-19</a>.</p>&#13;
<span id="Lis3-19"/>&#13;
<pre><code>CFErrorRef error = NULL;&#13;
&#13;
if(YES != SecAssessmentTicketLookup(hash, hashType,&#13;
kSecAssessmentTicketFlagForceOnlineCheck, NULL, &amp;error)) {&#13;
    if(EACCES == CFErrorGetCode(error)) {&#13;
        // Code placed here will run if the item's notarization ticket has been revoked.&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-19: Checking for revoked notarization tickets</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">SecAssessmentTicketLookup</span> API will set its error variable to the value <span class="SANS_TheSansMonoCd_W5Regular_11">EACCES</span> if the item’s notarization ticket has been revoked.<sup><a role="doc-noteref" id="chapter3_22" href="#chapter3-22">22</a></sup></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2"><span id="sec12"/><span id="h2-32"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Tool</span></h4>&#13;
<p class="TNI">Let’s run the <i>checkSignature</i> tool against the packages mentioned earlier in this chapter:</p>&#13;
&#13;
<pre><code>% <b>./checkSignature GoogleChrome.pkg</b>&#13;
Checking: GoogleChrome.pkg&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_93" aria-label="93"/>Status: signed&#13;
Notarized: yes&#13;
Signing authorities (&#13;
    "&lt;cert(0x11ee0ac30) s: Developer ID Installer: Google LLC (EQHXZ8M8AV)&#13;
    i: Developer ID Certification Authority&gt;",&#13;
    "&lt;cert(0x11ee08360) s: Developer ID Certification Authority i: Apple Root CA&gt;",&#13;
    "&lt;cert(0x11ee07820) s: Apple Root CA i: Apple Root CA&gt;"&#13;
)&#13;
&#13;
% <b>./checkSignature "EvilQuest/Mixed In Key 8.pkg"</b>&#13;
Checking: Mixed In Key 8.pkg&#13;
&#13;
Status: unsigned&#13;
&#13;
% <b>./checkSignature KeySteal/archive.pkg</b>&#13;
Checking: archive.pkg&#13;
&#13;
Status: certificate revoked&#13;
&#13;
Signing authorities: (&#13;
    "&lt;cert(0x151406100) s: Developer ID Installer: fenghua he (32W7BZNTSV)&#13;
    i: Developer ID Certification Authority&gt;",&#13;
    "&lt;cert(0x151406380) s: Developer ID Certification Authority i: Apple Root CA&gt;",&#13;
    "&lt;cert(0x1514082b0) s: Apple Root CA i: Apple Root CA&gt;"&#13;
)&#13;
</code></pre>&#13;
<p class="TX">The output matches the results of Apple’s <span class="SANS_TheSansMonoCd_W5Regular_11">pkgutil</span>. Our code accurately identifies the first package as validly signed and notarized; the second, containing the EvilQuest malware, as unsigned; and the last, containing the KeySteal malware, as revoked.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1"><span id="sec13"/><span id="h1-29"/><span class="SANS_Futura_Std_Bold_B_11">On-Disk Applications and Executables</span></h3>&#13;
<p class="TNI">The majority of macOS malware is distributed as applications or stand-alone Mach-O binaries. We can extract code signing information from an on-disk application bundle or executable binary in the same manner as for disk images: manually, via the <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> utility, or programmatically, via Apple’s Code Signing Services APIs. However, this case presents a few important differences.</p>&#13;
<p class="TX">The first involves the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCheckValidity</span> API, which validates the item’s signature. When the item isn’t a disk image, we must invoke this function with the <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCSCheckAllArchitectures</span> flag (<a href="chapter3.xhtml#Lis3-20">Listing 3-20</a>).</p>&#13;
<span id="Lis3-20"/>&#13;
<pre><code>SecCSFlags flags = kSecCSEnforceRevocationChecks;&#13;
if(NSOrderedSame != [item.pathExtension caseInsensitiveCompare:@"dmg"]) {&#13;
    flags |= kSecCSCheckAllArchitectures;&#13;
}&#13;
status = SecStaticCodeCheckValidity(staticCode, flags, NULL);&#13;
...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-20: Checking an item’s signature</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_94" aria-label="94"/>This flag handles multiarchitecture items like universal binaries, which can include several embedded Mach-O binaries, potentially with different code signers. For a real-world example in which attackers abused a universal binary to bypass insufficient code signing checks, see CVE-2021-30773.<sup><a role="doc-noteref" id="chapter3_23" href="#chapter3-23">23</a></sup> This flag value also enforces revocation checks, as it contains the value <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCSEnforceRevocationChecks</span>.</p>&#13;
<p class="TX">Earlier in this chapter, I showed you how to check whether a specified item conforms to some requirement, such as notarization. You might want to check additional requirements, such as whether Apple proper signed the item (the <i>anchor apple</i> requirement) or whether both Apple and a third-party developer ID have signed it (the <i>anchor apple generic</i> requirement). In each of these cases, your code can invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">SecRequirementCreateWithString</span> function with the requirement you wish to check and then pass this requirement to the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCheckValidity</span> API. To take into account universal binaries, invoke this function with a flag value that contains <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCSCheckAllArchitectures</span>.</p>&#13;
<p class="TX">You should also invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">SecAssessmentCreate</span> API to account for items with valid signatures but revoked notarization tickets. For a real-world example of this situation pertaining to applications, consider the 3CX supply chain attack mentioned previously. In this attack, North Korean attackers compromised the 3CX company network and build server, subverted the 3CX application with malware, signed it with the 3CX code signing certificate, and then tricked Apple into notarizing it. Not wanting to revoke 3CX’s code signing certificate, which would have blocked many other legitimate 3CX apps, Apple merely revoked the subverted application’s notarized ticket.</p>&#13;
<p class="TX">Let’s run the <i>checkSignature</i> project on legitimate applications as well as malware, including the 3CX sample:</p>&#13;
&#13;
<pre><code>% <b>./checkSignature /Applications/LuLu.app</b>&#13;
Checking: LuLu.app&#13;
&#13;
Status: signed&#13;
Notarized: yes&#13;
Signing authorities: : (&#13;
    "&lt;cert(0x13b814800) s: Developer ID Application: Objective-See, LLC (VBG97UB4TA)&#13;
    i: Developer ID Certification Authority&gt;",&#13;
    "&lt;cert(0x13b81c800) s: Developer ID Certification Authority i: Apple Root CA&gt;",&#13;
    "&lt;cert(0x13b81d000) s: Apple Root CA i: Apple Root CA&gt;"&#13;
)&#13;
&#13;
% <b>./checkSignature WindTail/Final_Presentation.app</b>&#13;
Checking: Final_Presentation.app&#13;
&#13;
Status: certificate revoked&#13;
&#13;
% <b>./checkSignature "SmoothOperator/3CX Desktop App.app"</b>&#13;
Checking: 3CX Desktop App.app&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_95" aria-label="95"/>Status: signed&#13;
Notarized: revoked&#13;
&#13;
% ./<b>checkSignature MacMa/client</b>&#13;
Checking: client&#13;
&#13;
Status: unsigned&#13;
</code></pre>&#13;
<p class="TX">We first check Objective-See’s signed and notarized LuLu application, followed by a WindTail malware specimen with a revoked certificate. Next, we test an instance of the trojanized 3CX application; our code correctly detects its revoked notarization status. Finally, we demonstrate that the MacMa malware is unsigned.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1"><span id="sec14"/><span id="h1-30"/><span class="SANS_Futura_Std_Bold_B_11">Running Processes</span></h3>&#13;
<p class="TNI">So far, we’ve examined on-disk items by obtaining static code object references. In this section, we’ll check the code signing information of running processes by using dynamic code object references (<span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeRef</span>).</p>&#13;
<p class="TX">When applicable, you should make use of dynamic code object references for two reasons. The first is efficiency; the operating system will have already validated much of the code signing information for a dynamic instance of an item of interest to ensure conformance with runtime requirements. For us, this means we can avoid the costly file I/O operations associated with static code checks and skip certain computations.</p>&#13;
<p class="TX">The other reason that dynamic code references are preferable to static code references relates to possible discrepancies between an item’s on-disk image and its in-memory one. For example, there is little stopping malware from changing the code signing information of its on-disk item to a benign value. (Of course, this highly anomalous behavior should itself raise a huge red flag.) On the other hand, a running item can’t change its dynamic code signing information.</p>&#13;
<p class="TX">To check whether a running process is signed and then extract its code signing information, we first must obtain a code reference via the <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopyGuestWithAttributes</span> API. Invoke it with the process’s ID, or preferably, with a more secure process audit token (<a href="chapter3.xhtml#Lis3-21">Listing 3-21</a>).</p>&#13;
<span id="Lis3-21"/>&#13;
<pre><code>SecCodeRef dynamicCode = NULL;&#13;
&#13;
NSData* data = [NSData dataWithBytes:token length:sizeof(audit_token_t)]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
NSDictionary* attributes = @{(__bridge NSString*)kSecGuestAttributeAudit:data}; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
status = SecCodeCopyGuestWithAttributes(NULL,&#13;
(__bridge CFDictionaryRef _Nullable)(attributes), kSecCSDefaultFlags, &amp;dynamicCode); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
if(errSecSuccess != status) {&#13;
    goto bail;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-21: Obtaining a code object reference via a process’s audit token</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_96" aria-label="96"/>We first convert the audit token into a data object <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We need this conversion so we can place the audit token in a dictionary, keyed by the string <span class="SANS_TheSansMonoCd_W5Regular_11">kSecGuestAttributeAudit</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We then pass this dictionary to the <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopyGuestWithAttributes</span> API, along with an out pointer to populate with a code object reference <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">With a code object reference in hand, you can validate the process’s code signing information with <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCheckValidity</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCheckValidityWithErrors</span>. Recall that for on-disk items such as universal binaries, we make use of the <span class="SANS_TheSansMonoCd_W5Regular_11">kSecCSCheckAllArchitectures</span> flag value to validate all embedded Mach-Os; for running processes, the dynamic loader will load and execute only one embedded Mach-O, so that flag value is irrelevant and not needed.</p>&#13;
<p class="TX">It’s essential that you validate a process’s code signing information before extracting or acting upon any of it. If you don’t, or if the validation fails, you won’t be able to trust it. If the code signing information is valid, you can extract it via the <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopySigningInformation</span> function that was already discussed.</p>&#13;
<p class="TX">With a code reference for a process, you can also perform other mundane but important tasks in a simple and secure manner. For example, using the <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopyPath</span> API, you can retrieve the process’s path (<a href="chapter3.xhtml#Lis3-22">Listing 3-22</a>).</p>&#13;
<span id="Lis3-22"/>&#13;
<pre><code>CFURLRef path = NULL;&#13;
SecCodeCopyPath(dynamicCode, kSecCSDefaultFlags, &amp;path);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-22: Obtaining a process’s path from a dynamic code object reference</span></p>&#13;
<p class="TX">You can also perform specific validations using requirements, as was discussed for static code object references. Using dynamic code object references, the approach is largely the same, except you’ll make use of the <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCheckValidity</span> API to perform the validation. It is important to note that when you are done with a dynamic code reference, you should release it via <span class="SANS_TheSansMonoCd_W5Regular_11">CFRelease</span>.</p>&#13;
<p class="TX">Because macOS won’t allow a process to execute if either its certificate or its notarization ticket has been revoked, you don’t need to perform this check yourself for running processes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1"><span id="sec15"/><span id="h1-31"/><span class="SANS_Futura_Std_Bold_B_11">Detecting False Positives</span></h3>&#13;
<p class="TNI">At the beginning of the chapter, I noted that various antivirus engines had incorrectly flagged components of Apple’s MRT as malware. If these engines had taken the item’s code signing information into account, they would have identified MRT and its components as a built-in part of macOS signed solely by Apple proper and safely ignored it.</p>&#13;
<p class="TX">I’ll show you how to perform such a check using the APIs introduced in this chapter. Specifically, you’ll make use of the <i>anchor apple</i> requirement string, which holds cryptographically true if and only if nobody but Apple has signed an item.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_97" aria-label="97"/>Let’s assume we’ve obtained a static code reference to the binary that was incorrectly flagged as malware. In <a href="chapter3.xhtml#Lis3-23">Listing 3-23</a>, we first compile the requirement string and then pass it and the code reference to the <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCheckValidity</span> API.</p>&#13;
<span id="Lis3-23"/>&#13;
<pre><code>static SecRequirementRef requirement = NULL;&#13;
SecRequirementCreateWithString(CFSTR("anchor apple"), kSecCSDefaultFlags, &amp;requirement);&#13;
&#13;
if(errSecSuccess ==&#13;
SecStaticCodeCheckValidity(staticCodeRef, kSecCSCheckAllArchitectures, requirement)) {&#13;
    // Code placed here will run only if the item is signed by Apple alone.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-23: Checking the validity of an item against the</span> <span class="SANS_Futura_Std_Book_11">anchor apple</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">requirement</span></p>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_11">SecStaticCodeCheckValidity</span> returns <span class="SANS_TheSansMonoCd_W5Regular_11">errSecSuccess</span>, we know that only Apple proper has signed the item, meaning it belongs to macOS and therefore certainly isn’t malware.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1"><span id="sec16"/><span id="h1-32"/><span class="SANS_Futura_Std_Bold_B_11">Code Signing Error Codes</span></h3>&#13;
<p class="TNI">As mentioned throughout this chapter, it’s important to appropriately handle any errors you encounter when validating an item’s cryptographic signature. You can find the error codes for the code signing services APIs in Apple’s “Code Signing Services Result Codes” developer documentation<sup><a role="doc-noteref" id="chapter3_24" href="#chapter3-24">24</a></sup> or in the <i>CSCommon.h</i> file, found at <i>Security.framework/Versions/A/Headers/</i>. These resources indicate, for example, that the error code <span class="SANS_TheSansMonoCd_W5Regular_11">-66992</span> maps to <span class="SANS_TheSansMonoCd_W5Regular_11">errSecCSRevokedNotarization</span>, signifying that the code has been revoked.</p>&#13;
<p class="TX">If perusing header files isn’t your thing, consult the OSStatus website. This website provides a simple way to map any Apple API error code to its human-readable name.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1"><span id="sec17"/><span id="h1-33"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">Code signing allows us to determine where an item is from and whether the item has been modified. In this chapter, you delved into code signing APIs that can verify, extract, and validate code signing information for items such as disk images, packages, on-disk binaries, and running processes.</p>&#13;
<p class="TX">Understanding these APIs is imperative in the context of detecting malware, especially as heuristic-based approaches can be fraught with false positives. The information provided by code signing can drastically reduce your detection errors. When building antimalware tools, you can use code signing in a myriad of ways, including identifying core operating system components you can trust, detecting items whose certificates or notarization tickets have been revoked, and authenticating clients, such as tool modules attempting to connect to XPC interfaces (a topic covered in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>).</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_98" aria-label="98"/>&#13;
<h3 class="H1"><span id="sec18"/><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-1" href="#chapter3_1">  1</a></span>.  Rich Trouton, “Apple Security Update Blocks Apple Ethernet Drivers on OS X El Capitan,” <i>Der Flounder</i>, February 28, 2016, <a href="https://derflounder.wordpress.com/2016/02/28/apple-security-update-blocks-apple-ethernet-drivers-on-el-capitan/"><i>https://<wbr/>derflounder<wbr/>.wordpress<wbr/>.com<wbr/>/2016<wbr/>/02<wbr/>/28<wbr/>/apple<wbr/>-security<wbr/>-update<wbr/>-blocks<wbr/>-apple<wbr/>-ethernet<wbr/>-drivers<wbr/>-on<wbr/>-el<wbr/>-capitan<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-2" href="#chapter3_2">  2</a></span>.  “Notarizing macOS Software Before Distribution,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/security<wbr/>/notarizing<wbr/>_macos<wbr/>_software<wbr/>_before<wbr/>_distribution</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-3" href="#chapter3_3">  3</a></span>.  Patrick Wardle, “Apple Approved Malware,” Objective-See, August 30, 2020, <a href="https://objective-see.com/blog/blog_0x4E.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.com<wbr/>/blog<wbr/>/blog<wbr/>_0x4E<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-4" href="#chapter3_4">  4</a></span>.  You can read more about the revocation of developer certificates in Jeff Johnson, “Developer ID Certificate Revocation,” <i>Lapcat Software</i>, October 29, 2020, <a href="https://lapcatsoftware.com/articles/revocation.html"><i>https://<wbr/>lapcatsoftware<wbr/>.com<wbr/>/articles<wbr/>/revocation<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-5" href="#chapter3_5">  5</a></span>.  If you’re interested in the technical details of code signing, see Jonathan Levin, “Code Signing—Hashed Out,” <i>NewOSXBook</i>, April 20, 2015, <a href="http://www.newosxbook.com/articles/CodeSigning.pdf"><i>http://<wbr/>www<wbr/>.newosxbook<wbr/>.com<wbr/>/articles<wbr/>/CodeSigning<wbr/>.pdf</i></a>, or “macOS Code Signing in Depth,” Apple Developer Documentation, <a href="https://developer.apple.com/library/archive/technotes/tn2206/_index.html"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/library<wbr/>/archive<wbr/>/technotes<wbr/>/tn2206<wbr/>/<wbr/>_index<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-6" href="#chapter3_6">  6</a></span>.  “Code Signing Services,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/security/code_signing_services"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/security<wbr/>/code<wbr/>_signing<wbr/>_services</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-7" href="#chapter3_7">  7</a></span>.  “SecStaticCodeRef,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/security/secstaticcoderef?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/security<wbr/>/secstaticcoderef<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-8" href="#chapter3_8">  8</a></span>.  “SecCodeRef,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/security/seccoderef?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/security<wbr/>/seccoderef<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-9" href="#chapter3_9">  9</a></span>.  “SecStaticCodeCreateWithPath,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/security/1396899-secstaticcodecreatewithpath"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/security<wbr/>/1396899<wbr/>-secstaticcodecreatewithpath</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-10" href="#chapter3_10">10</a></span>.  “Code Signing Services Result Codes,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/security/1574088-code_signing_services_result_cod"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/security<wbr/>/1574088<wbr/>-code<wbr/>_signing<wbr/>_services<wbr/>_result<wbr/>_cod</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-11" href="#chapter3_11">11</a></span>.  “Core Foundation Design Concepts,” Apple Developer Documentation, <a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/library<wbr/>/archive<wbr/>/documentation<wbr/>/CoreFoundation<wbr/>/Conceptual<wbr/>/CFDesignConcepts<wbr/>/Articles<wbr/>/tollFreeBridgedTypes<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-12" href="#chapter3_12">12</a></span>.  For a real-world example, see Ilias Morad, “CVE-2020–9854: ‘Unauthd,’ ” Objective-See, August 1, 2020, <a href="https://objective-see.org/blog/blog_0x4D.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x4D<wbr/>.html</i></a>, which highlighted this issue in macOS’s <span class="SANS_TheSansMonoCd_W5Regular_11">authd</span>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-13" href="#chapter3_13">13</a></span>.  “SecRequirementCreateWithString,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/security/1394522-secrequirementcreatewithstring"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/security<wbr/>/1394522<wbr/>-secrequirementcreatewithstring</i></a>.</p></li>&#13;
<li><p class="NTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_99" aria-label="99"/><span class="en_tx"><a id="chapter3-14" href="#chapter3_14">14</a></span>.  “Code Signing Requirement Language,” Apple Developer Documentation, <a href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/RequirementLang/RequirementLang.html"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/library<wbr/>/archive<wbr/>/documentation<wbr/>/Security<wbr/>/Conceptual<wbr/>/CodeSigningGuide<wbr/>/RequirementLang<wbr/>/RequirementLang<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-15" href="#chapter3_15">15</a></span>.  Asfdadsfasdfasdfsasdafads, “Programmatically Detected If a Notarization Ticket Has Been Revoked,” Apple Developer Forums, June 2023, <a href="https://developer.apple.com/forums/thread/731675"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/forums<wbr/>/thread<wbr/>/731675<wbr/>.</i></a></p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-16" href="#chapter3_16">16</a></span>.  “dyld Shared Cache Info,” Apple Developer Documentation, <a href="https://developer.apple.com/forums/thread/692383"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/forums<wbr/>/thread<wbr/>/692383</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-17" href="#chapter3_17">17</a></span>.  See <a href="https://github.com/keith/dyld-shared-cache-extractor"><i>https://<wbr/>github<wbr/>.com<wbr/>/keith<wbr/>/dyld<wbr/>-shared<wbr/>-cache<wbr/>-extractor</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-18" href="#chapter3_18">18</a></span>.  See, for example, Patrick Wardle, “Reversing ‘pkgutil’ to Verify PKGs,” <i>Jamf</i>, January 22, 2019, <a href="https://www.jamf.com/blog/reversing-pkgutil-to-verify-pkgs/"><i>https://<wbr/>www<wbr/>.jamf<wbr/>.com<wbr/>/blog<wbr/>/reversing<wbr/>-pkgutil<wbr/>-to<wbr/>-verify<wbr/>-pkgs<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-19" href="#chapter3_19">19</a></span>.  See <a href="https://github.com/objective-see/WhatsYourSign/blob/master/WhatsYourSignExt/FinderSync/Packages.m"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/WhatsYourSign<wbr/>/blob<wbr/>/master<wbr/>/WhatsYourSignExt<wbr/>/FinderSync<wbr/>/Packages<wbr/>.m</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-20" href="#chapter3_20">20</a></span>.  Steve Nygard, “Class-dump,” <a href="http://stevenygard.com/projects/class-dump/"><i>http://<wbr/>stevenygard<wbr/>.com<wbr/>/projects<wbr/>/class<wbr/>-dump<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-21" href="#chapter3_21">21</a></span>.  “respondsToSelector:,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/objectivec/1418956-nsobject/1418583-respondstoselector"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/objectivec<wbr/>/1418956<wbr/>-nsobject<wbr/>/1418583<wbr/>-respondstoselector</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-22" href="#chapter3_22">22</a></span>.  “Notarization,” Apple Developer Documentation, <a href="https://opensource.apple.com/source/Security/Security-59306.120.7/OSX/libsecurity_codesigning/lib/notarization.cpp"><i>https://<wbr/>opensource<wbr/>.apple<wbr/>.com<wbr/>/source<wbr/>/Security<wbr/>/Security<wbr/>-59306<wbr/>.120<wbr/>.7<wbr/>/OSX<wbr/>/libsecurity<wbr/>_codesigning<wbr/>/lib<wbr/>/notarization<wbr/>.cpp</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-23" href="#chapter3_23">23</a></span>.  Linus Henze, “Fugu15: The Journey to Jailbreaking iOS 15.4.1,” paper presented at Objective by the Sea v5, Spain, October 6, 2022, <a href="https://objectivebythesea.org/v5/talks/OBTS_v5_lHenze.pdf"><i>https://<wbr/>objectivebythesea<wbr/>.org<wbr/>/v5<wbr/>/talks<wbr/>/OBTS<wbr/>_v5<wbr/>_lHenze<wbr/>.pdf</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter3-24" href="#chapter3_24">24</a></span>.  “Code Signing Services Result Codes,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/security/1574088-code_signing_services_result_cod"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/security<wbr/>/1574088<wbr/>-code<wbr/>_signing<wbr/>_services<wbr/>_result<wbr/>_cod</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>