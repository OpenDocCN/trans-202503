- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CLASSES</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Classes* are a powerful programming tool for generating multiple objects with
    shared characteristics and behaviors. They’re a core part of *object-oriented
    programming*, a style of coding that revolves around creating objects that contain
    both data and functions for manipulating that data. In an object-oriented multiplayer
    game, for example, you might represent each player as an object of a Player class,
    and each enemy as an object of an Enemy class. The classes would establish what
    kind of data a player or enemy should have and would include functions to make
    the player or enemy do things, like move around or attack.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to create JavaScript classes, and how to use
    those classes to create individual objects. You’ll also learn how to leverage
    *inheritance* to share behavior between different classes. Using classes and object-oriented
    programming in this way gives your code structure and can make it easier to read,
    write, and understand, especially if your program involves lots of entities with
    common behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating Classes and Instances</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *class* is like template for making standardized objects. In [Chapter 3](chapter3.xhtml)
    we discussed how an object is a compound data type consisting of key-value pairs,
    and you saw how to create objects by manually writing out object literals. Classes
    automate that process, allowing you to instead create objects using a syntax similar
    to calling a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class lays out two main things:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  What properties each object of that class should have. (Remember that *property*
    is another term for a key-value pair in an object.)
  prefs: []
  type: TYPE_NORMAL
- en: 2.  What functions the object should have access to. (When they’re defined and
    called as part of a class, functions are called *methods*.)
  prefs: []
  type: TYPE_NORMAL
- en: The Player class in a game, for example, might include properties such as the
    player’s name, health level, position in the environment, and so on. It might
    have methods for moving, firing a weapon, picking up an item, and more. The class
    could be used to create multiple different players.
  prefs: []
  type: TYPE_NORMAL
- en: Objects created from a class are known as *instances* of that class. Each player’s
    character in the game would be an instance of the Player class, for example. Each
    instance fills in the generic template of the class with its own details. A specific
    Player instance would have its own name, health level, and position, distinct
    from those of other Player instances. All instances can use the class’s methods,
    however.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, we’ll create a simple Player class for a hypothetical
    2D game. For now, we’ll just give the player a position, defined by a set of x-
    and y-coordinates, and a method for moving that changes those coordinates. Enter
    the following in the JavaScript console to declare the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We start with the class keyword to indicate we’re declaring a new class, followed
    by the class’s name, Player. It’s customary for class names to start with an uppercase
    letter. Next comes the class body, enclosed in braces, just like a function body.
    Inside the body we define two methods, constructor ❶ and move ❷. Declaring a class
    method is like declaring a function, but we don’t use the function keyword.
  prefs: []
  type: TYPE_NORMAL
- en: If a class has a method called constructor, as our Player class does, that method
    will be called automatically anytime you create an instance of the class. The
    constructor performs any necessary setup for the object being created, including
    receiving any parameters that define the instance and laying out what properties
    the object should have. In this case, our Player class’s constructor takes in
    two parameters, startX and startY, and assigns them to the new instance’s x and
    y properties, which together keep track of the player’s position in the 2D game.
    The this keyword refers to the current instance being created, so this.x = startX
    means “take the value of startX and assign it to the new Player object’s x property.”
    Notice that we’re using the same dot notation we’ve used elsewhere to access the
    properties of an object; the only difference here is that this serves as a placeholder
    for the new object’s name.
  prefs: []
  type: TYPE_NORMAL
- en: The move method updates the player’s position by changing the x and y properties
    based on the provided dx and dy parameters. The *d* in dx and dy is short for
    the Greek letter *delta*, which often refers to the amount something changes,
    as in “change in the x value” and “change in the y value.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve declared the Player class, we can make instances of it. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We create a new instance of the Player class using the new keyword followed
    by the class name. After the class name, we write a set of parentheses, much as
    we would when calling a function. The parentheses contain any arguments that need
    to be passed to the class’s constructor method.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new instance of a class with new, some magic happens. First,
    a new, empty object is created. Then a hidden link from this object to the class
    is created, which is how JavaScript is able to tell which class created the object
    and what methods the object should therefore have access to. Next, the class’s
    constructor method is called automatically. Inside the constructor, the new object
    being created is available via the keyword this, allowing you to set properties
    on the object. Any arguments you provide in the parentheses after the class name
    are passed to the constructor method’s parameters. After the constructor method
    has been called, the new object is returned.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, when we enter let player1 = new Player(0, 0);, JavaScript creates
    a new object and gives it a hidden link to the Player class. It then calls the
    class’s constructor method, passing the arguments 0 and 0 to the constructor’s
    startX and startY parameters. The constructor takes these parameters and uses
    this.x and this.y to set the new object’s x and y properties to 0. Finally, the
    new object is returned and assigned to the player1 variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now interact with the new object. Here, for example, we look up its
    position, tell it to move, then look up its position again to confirm the move
    method worked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We access the object’s x and y properties using player1.x and player1.y, respectively.
    They both show the value 0, since that’s what we passed to the constructor. Next,
    we call the move method, which we defined in the Player class. Because instances
    have a hidden link to the class that created them, they’re able to call methods
    defined on that class. We use dot notation to call the method, just like calling
    the built-in methods associated with strings or arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call a method on an object, the this keyword inside the method definition
    is set to the current object (the receiver). When we call player1.move(3, 4),
    for example, this inside the body of the move method is bound to the player1 object.
    That’s how one method is able to be shared by multiple objects: this becomes whatever
    object is receiving the method call at any given time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The move method updates the object’s x and y properties by adding dx and dy
    to their current values. For example, when we call player1.move(3, 4) we’re setting
    x to 0 + 3 and y to 0 + 4. When we again look up the object’s x and y properties,
    we can see that this worked: player1.x has become 3 and player1.y has become 4.
    If we then made another call to move, for example, player1.move(2, 2), x would
    become 5 and y would become 6.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Inheritance</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Inheritance* is a mechanism in object-oriented programming for defining relationships
    between different classes. Just as a child inherits genes from its parents, a
    “child” class inherits properties and methods from a “parent” class, taking on
    the parent’s properties and methods. This is useful when you have multiple classes
    that should share a general set of behaviors, in addition to each class having
    some unique behaviors of its own. You can define the general behaviors as part
    of a parent class, also called a *superclass*. Then you can define the child classes,
    also called *subclasses*, to inherit these behaviors and augment them with other,
    specialized behaviors. This saves you from having to repeat the general code when
    you define each subclass.'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, in our 2D game, human-controlled players and computer-controlled
    enemies probably have a lot in common. They both need x and y properties representing
    their position, for example, and they both need a move method to change their
    position. However, they also have some differences. Perhaps enemies have the ability
    to attack a player if the player comes too close, but not the other way around—the
    goal of the game is for players to avoid, not kill, the enemies.
  prefs: []
  type: TYPE_NORMAL
- en: We can use inheritance to realize this scheme with minimal code. We’ll create
    a new class called Actor representing *any* participant in the game. It will hold
    the general code both players and enemies should have, such as the move method.
    We’ll then define Player and Enemy as subclasses of Actor. They’ll each inherit
    the general code from the Actor superclass, while also adding their own code particular
    to just players or enemies.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here’s the definition of the Actor class. It’s mostly a copy of our
    previous Player class, but with a new name. We’re also adding another method,
    called distanceTo, that calculates the distance between two participants in the
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The distanceTo method takes another Actor (or any object with an x- and y-coordinate)
    as a parameter and returns the distance to that object. It’s quite common for
    objects to be passed to other objects’ methods in this way. The distance is determined
    by calculating the horizontal distance (otherActor.x - this.x) and the vertical
    distance (otherActor.y - this.y), and then using the built-in Math.hypot method
    to find the length of the hypotenuse of the triangle formed by the two distances.
    This is the standard mathematical technique, based on the Pythagorean theorem,
    for finding the distance between two points on a 2D plane.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s technically possible to create an instance of the Actor class,
    it’s not really meant to be instantiated. Classes like Actor that are just meant
    to be extended by subclasses are sometimes known as *abstract classes*, because
    they represent an abstract concept, like a generic entity in a game. Meanwhile,
    classes that are meant to be instantiated, such as the Player and Enemy classes
    we’ll define momentarily, are sometimes known as *concrete classes*, because they
    represent something solid, such as actual players or enemies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll redefine the Player class to inherit from Actor. We’ll add a new
    property specific to players called hp (for *hit points*), representing the player’s
    health level—the Enemy class doesn’t need this property, since only players, not
    enemies, can be attacked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time we declare the class with the extends keyword to establish Player
    as a subclass of Actor. We have to write only the class’s constructor method,
    since it inherits the move and distanceTo methods from Actor. The constructor
    takes startX and startY parameters, just as before.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do in the constructor is call super(startX, startY). Inside
    a subclass’s constructor method, the super keyword refers to the constructor from
    the superclass—in this case, the Actor class’s constructor. As a result, when
    we create a new instance of Player, the Player constructor is called automatically,
    which in turn calls the Actor constructor (via super). We pass startX and startY
    to the Actor constructor, which uses these values to set the Player object’s x
    and y properties. Then, back in the Player class’s constructor, we set the new
    Player instance’s hp property to 100 ❶. This way each new player will start with
    100 hit points (full health).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll create our Enemy class. It, too, will inherit from the Actor class,
    extending it with an attack method for attacking players (the Player class doesn’t
    need this method, since only enemies can attack):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We declare the Enemy class to extend Actor, just like the Player class. Unlike
    with Player, however, the Enemy class doesn’t have any extra properties (such
    as hp) that need to be set in the constructor. As such, the class doesn’t have
    its own constructor method. When a subclass doesn’t define a constructor, its
    parent class’s constructor is called automatically when a new instance of the
    subclass is created. Thus, new Enemy instances will still be given an initial
    position thanks to the Actor superclass’s constructor method, but we don’t need
    to show this explicitly in the Enemy class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Without a constructor, the Enemy class’s only unique method is attack. It takes
    in a Player object as a parameter and checks the distance to that object, using
    the distanceTo method inherited from the Actor class. (Notice that we call the
    method using this.distanceTo, again using the this keyword to reference the current
    instance of the Enemy class.) If the distance is less than 4, the enemy can attack,
    reducing the player’s hp value by 10. We return true to indicate that this was
    a successful attack. If the attack fails because the player is too far away, we
    return false instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our Player and Enemy classes, we can see how they interact.
    Let’s create an instance of each class, move them around, and have the enemy attack
    the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First we create an instance of each class, at the positions (1, 2) and (3, 4).
    The Player object starts out at full health, as player.hp demonstrates. The two
    objects are about 2.8 units apart, which we confirm by calling enemy .distanceTo(player).
    At this point, the enemy is close enough to successfully attack the player, so
    we call its attack method using enemy.attack(player). The method returns true,
    indicating a hit, and checking player.hp shows the attack has reduced the player’s
    health to 90. Next, we move the player by 5 units in the x and y directions. The
    move puts the player out of range of the enemy, so the enemy’s second attack is
    unsuccessful, returning false. A last check of player.hp shows the player’s health
    remains at 90.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in this code that we’ve called the distanceTo method on an Enemy object
    and the move method on a Player object. These were both methods defined on the
    Actor class, but they’re available on the Enemy and Player classes as well, proving
    the subclasses successfully inherited from their superclass. We can also verify
    this using the instanceof keyword, which tests whether an object is an instance
    of a particular class. Here, for example, we try it out with the player object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you may expect, player is an instance of Player. What might be surprising
    is that player is also an instance of Actor. When a subclass like Player inherits
    from a superclass like Actor, instances of the subclass are also considered to
    be instances of the superclass. On the other hand, player is not an instance of
    Enemy, even though the Player and Enemy classes share a common superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve used a single level of inheritance: an Actor superclass
    with Player and Enemy subclasses. A more sophisticated game might use multiple
    levels of inheritance to create different subtypes of players and enemies. For
    example, there might be Witch, Elf, and Centaur classes, all subclasses of Player
    (which in turn is a subclass of Actor). These subclasses would share some common
    abilities, defined on the Player superclass (as well as any methods defined on
    Actor), while also having their own specialized abilities defined on the individual
    subclasses. Likewise, Enemy might have subclasses such as Troll, Demon, and Harpy.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Prototype-Based Inheritance</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When JavaScript was first created, there were no classes, but it was still
    possible to share behaviors between objects using *prototype-based inheritance*.
    This older system, which still works today alongside the class system, relies
    on two mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  A *constructor* function that creates and returns new objects. In this context,
    a constructor is just a regular, standalone function (not a function defined within
    a class), but it’s called using the new keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  A *prototype*, an example object that the constructor uses as a model for
    the objects it creates. The newly created objects inherit methods and properties
    from the prototype object.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript was one of the only mainstream languages to use prototype-based inheritance
    rather than classes. Recognizing this, the committee that develops the language
    eventually decided to add support for classes, in order to make JavaScript more
    palatable to newcomers with a background in other modern programming languages.
    When they added classes, however, they built the new feature on top of the existing
    support for prototype-based inheritance. In other words, JavaScript’s class-based
    inheritance is essentially an alternative syntax for prototype-based inheritance.
    (This is sometimes known as *syntactic sugar*, because it makes the syntax more
    palatable.)
  prefs: []
  type: TYPE_NORMAL
- en: If you’re comfortable using classes, it isn’t essential that you learn about
    prototype-based inheritance. However, since classes are a relatively new JavaScript
    feature, it’s still common to encounter prototype-based inheritance in older code,
    so it’s worth being able to recognize how it works. Exploring prototype-based
    inheritance also illuminates some of JavaScript’s inner workings, including the
    significance of the mysterious [[Prototype]] property you’ve been seeing in the
    Chrome console. Even if you don’t end up programming with prototype-based inheritance,
    understanding some of these underlying details can make it easier to use classes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Constructors
    and Prototypes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As I mentioned, prototype-based inheritance involves a constructor function
    that creates instances of objects, and a prototype object that the instances inherit
    methods and properties from. This works because JavaScript creates links between
    the constructor, the prototype, and the new instance being created. Let’s take
    a look at this in action. We’ll create a new constructor function called Cat,
    and add a method called sayHello to its prototype. This will allow us to create
    Cat objects that have access to the sayHello method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We first create a constructor function called Cat with a name parameter. Constructor
    functions, like class names, usually start with a capital letter. The constructor’s
    body uses this.name = name to set the new object’s name property to the value
    of the provided name parameter. As with classes, the this keyword in a constructor
    refers to the object being produced.
  prefs: []
  type: TYPE_NORMAL
- en: When the Cat constructor function is created, it’s automatically given a property
    called prototype. It might sound weird that functions can have properties, but
    a JavaScript function is actually a kind of object; the Cat function can have
    a prototype property just like a person object can have name and age properties.
    This property is accessible as Cat.prototype, using the same dot notation we’d
    use to access a property of any other object.
  prefs: []
  type: TYPE_NORMAL
- en: The value of Cat.prototype is itself an object, the prototype that Cat instances
    should be modeled after. By adding methods to this prototype object, we can control
    what methods any Cat instances will inherit. In this case, we use Cat.prototype.sayHello
    to add a sayHello method to the prototype. The method logs a greeting that includes
    the value of this.name to the console. When sayHello is called as a method on
    a particular instance, this in the method definition refers to that instance—just
    as it would in a method defined on a class—so this.name refers to the value of
    the instance’s name property.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Notice that Cat.prototype.sayHello chains multiple dot notations together:
    Cat .prototype refers to the object stored in the Cat function’s prototype property,
    and .sayHello refers to the sayHello property of that object. That property doesn’t
    exist yet, so here we’re adding it to the object and setting its value to a function
    expression.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve created a Cat constructor and added a method to its prototype. Now let’s
    use the constructor to create a new instance that will inherit from the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we create a new object from the Cat constructor by calling it with the
    new keyword, passing "Kiki" as an argument for the constructor’s name parameter.
    We store the resulting object in the kiki variable. Notice that if we’d declared
    Cat as a class rather than a constructor function, the syntax for creating an
    object would be exactly the same: new Cat("Kiki"). The only difference is whether
    we’re thinking of Cat as the name of a function or the name of a class.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the sayHello method on the new instance. Because kiki was created
    using the Cat constructor, it has a hidden link to Cat.prototype, which JavaScript
    uses to locate the sayHello definition. Since sayHello was called as a method
    on the kiki object, the this keyword in sayHello is set to kiki.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although I’m calling the link between instance and prototype “hidden,” the
    Chrome console lets you inspect it via the special [[Prototype]] property. Let’s
    see what we can find out about kiki. Enter kiki; into the console and click the
    arrow at the side to inspect it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of the output tells us that kiki was created with the Cat constructor.
    Next, we see that kiki has a name property with a value of "Kiki" (this was assigned
    when the constructor was called). We also see that kiki has a [[Prototype]] property
    whose value is an object. This is the “hidden” link I’ve been talking about to
    the prototype that this instance inherited from. It’s the same object referenced
    by Cat.prototype (the prototype property of the Cat constructor function). Click
    the arrow to expand [[Prototype]] and see what’s inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the prototype object has three properties. The first, sayHello,
    has a value that’s a function, as the f () indicates. This is the sayHello method
    we added to the prototype. The second, constructor, refers to the Cat constructor
    function. This cements the link between the constructor function and the prototype
    the constructor uses to create new instances. Finally, the prototype itself has
    its own [[Prototype]] property ❶, which we’ll explore shortly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparing Constructors
    and Classes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In prototype-based inheritance, the chain of references from an instance to
    its prototype and a prototype to its constructor is how JavaScript knows where
    to find the methods and properties for that instance. It turns out classes use
    these same techniques. To demonstrate, let’s create a Dog class that mirrors the
    functionality of our Cat constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor method here is equivalent to the Cat constructor function,
    and the sayHello method is equivalent to Cat.prototype.sayHello. Now let’s make
    a Dog instance and compare it to the kiki instance by expanding the [[Prototype]]
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in both cases the sayHello method is found via the [[Prototype]]
    link. There are just some minor differences. For example, with kiki the constructor
    points at a function, whereas for felix it points at a class. Also, the sayHello
    method on felix has a name, whereas for kiki it doesn’t (because we defined sayHello
    using an anonymous function).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you want to access an object’s [[Prototype]] property directly
    in code, it’s available through the name __proto__:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Even though the property is technically called __proto__, we’ll continue to
    call it the [[Prototype]] property, as that’s how it shows up in the Chrome console.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Object.prototype</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Any object that isn’t created with an explicit constructor function is instead
    implicitly created with JavaScript’s built-in Object constructor function. The
    prototype this constructor references, available as Object.prototype, contains
    basic methods that all objects should inherit. This prototype object marks the
    end of the line in the chain of prototype references. All objects eventually trace
    their origin back to Object.prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, while our kiki object was created with the Cat constructor, its
    prototype, Cat.prototype, was never explicitly created with a constructor. Instead,
    JavaScript implicitly created this object using the Object constructor, so its
    prototype is Object.prototype. This is what the inner [[Prototype]] property within
    our view of kiki in the previous code listing is telling us. We can expand that
    inner [[Prototype]] property to examine Object.prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notably, this inner prototype object has a constructor property whose value
    is the Object function ❶, showing that it’s the prototype property of JavaScript’s
    built-in Object constructor. The remaining properties correspond to the many default
    methods that all objects inherit. For example, hasOwnProperty is a method that
    checks if an object has a property defined on itself, rather than on its prototype,
    and toString is a method that returns a string representation of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create an object with an object literal, you aren’t creating it with
    an explicit constructor function, so it, too, is created implicitly with the Object
    constructor and gets Object.prototype for its prototype. When we were inspecting
    objects in the console in [Chapter 3](chapter3.xhtml) and saw they had a [[Prototype]]
    property, that’s what we were seeing. Let’s take another look at one now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we declare a basic person object using an object literal, meaning it’s
    created behind the scenes with the default Object constructor. Inspecting the
    object in the console, we can see that the contents of its [[Prototype]] property
    are exactly the same as the innermost [[Prototype]] of the kiki object. Both objects
    trace their roots to Object.prototype, kiki indirectly through its own prototype
    (Cat.prototype) and person directly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Walking the Prototype
    Chain</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you ask for a property or method from an object, JavaScript first looks
    on the object itself. If it can’t find the property there, it looks on the object’s
    prototype. If JavaScript still can’t find the property, it then checks the prototype’s
    prototype, and so on, until it hits Object.prototype. This process is known as
    *walking the prototype chain*. Let’s look up some properties and methods that
    will walk the prototype chain of our kiki object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we access the name property, which is set directly on kiki itself. Second,
    we call the sayHello method, which is found on the kiki object’s prototype. To
    call this method, JavaScript first checks on kiki and then, not finding it, checks
    on its prototype. Third, we call hasOwnProperty, a method from Object.prototype,
    which is the kiki object’s prototype’s prototype. (The method returns true, since
    the name property is set directly on kiki.) Finally, we call madeUpMethodName,
    a nonexistent method. After walking the entire prototype chain, from kiki to Cat.prototype
    to Object.prototype, JavaScript determines that the method can’t be found and
    throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](chapter6.xhtml#fig6-1) shows a visual representation of the kiki
    object’s prototype chain and the associated constructor functions, Cat and Object.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_6-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: The prototype chain
    for kiki</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each box in the diagram represents an object, with the object’s name as a heading.
    The left column of each box shows the names of the object’s properties, and the
    right column shows the values of those properties. For example, the kiki object’s
    name property has a value of "Kiki", and the Cat .prototype object’s sayHello
    property is a function, denoted by f () (remember that a method is just a function
    that’s a property of an object).
  prefs: []
  type: TYPE_NORMAL
- en: Some of the property values point at, or refer to, other objects. For example,
    all constructor functions have a prototype field that points to the object that
    will be used as the prototype for instances created with that constructor. Thus,
    the Cat constructor’s prototype field points to Cat.prototype. Likewise, objects
    have a link to their prototype through their [[Prototype]] property. For example,
    the [[Prototype]] property of kiki links to Cat.prototype, since kiki was created
    with the Cat constructor. All prototype objects have a constructor field that
    links back to the constructor they belong to. As you can see, the constructor
    field for Cat.prototype connects back to Cat, and the constructor field for Object.prototype
    connects to Object. Instances like kiki don’t have a constructor field defined
    directly on them. Instead, the constructor is looked up on the instance’s prototype
    by walking the prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the Dog example, classes use the same prototype mechanism under
    the hood, so this technique of walking the prototype chain is also how properties
    and methods are looked up on instances of classes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overriding a Method</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Understanding how JavaScript walks the prototype chain to locate an object’s
    methods is important because it allows us to *override* the definition of a method
    that an object would otherwise inherit from its prototype. This technique is useful
    when we want an object to inherit most of its behavior from a prototype, but we
    want to give it some unique behavior as well. When you call a method, JavaScript
    uses the first definition it finds for that method as it walks the prototype chain,
    so if we define a method directly on an object, and that method has the same name
    as a method defined on the object’s prototype, the method on the object itself
    takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you want a new Cat object that says hello in a different way
    from the method defined on Cat.prototype. You could set a separate sayHello method
    directly on that new cat, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a new instance with the Cat constructor and name it moona. Then
    we define a sayHello method on moona itself that logs a greeting in all caps.
    When we then call moona.sayHello(), we can see in the output that the sayHello
    definition set directly on moona takes precedence over the sayHello definition
    on Cat.prototype ❶. This is also known as *shadowing*, because the local method
    casts a kind of shadow over the prototype’s method. Notice, however, that the
    original sayHello method on Cat.prototype remains intact, as you can see from
    the output when we call it on kiki ❷.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned about classes, which help you organize your code
    by sharing functionality between multiple objects. You learned how to create classes,
    how to use them to create instances, and how to extend classes by creating a hierarchy
    of subclasses and superclasses. You also learned about prototype-based inheritance,
    JavaScript’s original system for allowing objects to inherit properties and methods.
    You explored how prototype-based inheritance compares to the newer class system,
    and you saw how to trace an object’s chain of inheritance through the [[Prototype]]
    property in the console.
  prefs: []
  type: TYPE_NORMAL
