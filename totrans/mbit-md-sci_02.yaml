- en: '![Image](../images/common1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common1.jpg)'
- en: '**2**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**SUPER SONIC**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**超音速**'
- en: 'In this chapter, we’ll explore using sound with the micro:bit. We’ll teach
    the micro:bit to play music and even imitate speech, and we’ll get it to hear
    sound by connecting it to a microphone. You’ll try out a couple of experiments
    and create two simple projects: the first project is a musical doorbell that lets
    the Mad Scientist know when visitors have arrived, and the second is a Shout-o-meter
    that measures and displays the volume of sounds it detects.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用 micro:bit 播放声音。我们将教 micro:bit 播放音乐，甚至模仿语音，并通过将其连接到麦克风来让它听到声音。你将尝试几个实验，并创建两个简单的项目：第一个项目是一个音乐门铃，通知疯狂科学家访客到达，第二个项目是一个喊声计，测量并显示它检测到的声音的音量。
- en: '**CONNECTING A LOUDSPEAKER TO A MICRO:BIT**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将扬声器连接到 micro:bit**'
- en: There are a couple of ways to hear sound from your micro:bit. Which one you
    should choose depends on how much sound you want to make.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从 micro:bit 听到声音。你应该选择哪一种，取决于你想发出多少声音。
- en: '**The Quiet Method: Headphones**'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安静方法：耳机**'
- en: Perhaps the easiest way to get sound from your micro:bit is to use alligator
    clip cables to connect the micro:bit to a pair of headphones (see [Figure 2-1](ch02.xhtml#ch2fig1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 也许从 micro:bit 获取声音的最简单方法是使用鳄鱼夹电缆将 micro:bit 连接到一副耳机（参见 [图 2-1](ch02.xhtml#ch2fig1)）。
- en: '![Image](../images/02fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig01.jpg)'
- en: '*Figure 2-1: Alligator clips attached to headphones*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：耳机连接的鳄鱼夹*'
- en: If you look closely at the metal plug on the headphones, you should see that
    it is really made of three pieces separated by rings of plastic. This means the
    plug has three connections. The section closest to the headphones’ wire is the
    ground connection. Connect this to the micro:bit’s GND (0V) connection with an
    alligator clip.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察耳机上的金属插头，你会看到它实际上由三个部分组成，这些部分之间由塑料环隔开。这意味着插头有三个连接点。最靠近耳机线的部分是接地连接。使用鳄鱼夹将其连接到
    micro:bit 的 GND（0V）连接。
- en: 'The other two connectors are the audio signals for your left and right ears.
    If you want to hear sound in both ears, place the alligator clip so that it spans
    both of the two connectors on the end. You can also attach the alligator clip
    to the very tip for sound in just one ear (as shown in [Figure 2-1](ch02.xhtml#ch2fig1)).
    Either way, clip the other end of the alligator clip to any of the three micro:bit
    pins: 0, 1, or 2\. Micro:bit users traditionally use pin 0 for audio.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个连接器是用于左耳和右耳的音频信号。如果你想让两只耳朵都能听到声音，将鳄鱼夹放置在两个连接器之间，这样声音就会传到两个耳朵。你也可以将鳄鱼夹连接到插头的尖端，这样就只会有一只耳朵听到声音（如
    [图 2-1](ch02.xhtml#ch2fig1) 所示）。无论哪种方式，将鳄鱼夹的另一端夹到 micro:bit 上的任意三个引脚之一：0、1 或 2。micro:bit
    用户通常使用引脚 0 来输出音频。
- en: '**NOTE** *Headphones designed for use with a cellphone that include a microphone
    will have four connectors on the plug rather than three. This shouldn’t make a
    difference. You can still use the tip as the audio connection and the connector
    closest to the plug body as the GND connection.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** *设计用于与手机一起使用的耳机，如果带有麦克风，其插头将有四个连接器，而不是三个。这个差异不应影响使用。你仍然可以将插头的尖端作为音频连接，将离插头体最接近的连接器作为接地（GND）连接。*'
- en: '![Image](../images/f0041-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0041-01.jpg)'
- en: To upgrade this method slightly, you can use an *audio jack adapter* like the
    one shown in [Figure 2-2](ch02.xhtml#ch2fig2). Just plug your headphones straight
    into the adapter, with the black wire connected to GND and the other to pin 0\.
    Adapters like this fit directly onto the headphones and provide a more reliable
    connection than alligator clips.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微升级这个方法，你可以使用像 [图 2-2](ch02.xhtml#ch2fig2) 中所示的 *音频插孔适配器*。只需将耳机直接插入适配器，将黑线连接到
    GND，另一根连接到引脚 0。像这样的适配器直接安装到耳机上，提供比鳄鱼夹更可靠的连接。
- en: '![Image](../images/02fig02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig02.jpg)'
- en: '*Figure 2-2: An adapter to connect an alligator clip to a 3.5 mm audio jack*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：连接鳄鱼夹到 3.5 毫米音频插孔的适配器*'
- en: '**The Ghetto Blaster Method: Speaker**'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**低预算音响方法：扬声器**'
- en: 'With an amplified speaker such as the one shown in [Figure 2-3](ch02.xhtml#ch2fig3),
    you can produce a lot more sound using the same connection methods described earlier:
    either connecting directly to the speaker plug or using an audio jack adapter.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 [图 2-3](ch02.xhtml#ch2fig3) 中所示的放大扬声器，你可以使用之前描述的相同连接方法，产生更多的声音：直接连接到扬声器插头或使用音频插孔适配器。
- en: '![Image](../images/02fig03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig03.jpg)'
- en: '*Figure 2-3: Connecting a micro:bit to an amplified speaker*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：将 micro:bit 连接到放大音响*'
- en: Some speakers are designed especially for use with micro:bits. Some of these
    have cables that end in alligator clips to attach to your micro:bit, while others,
    like the Monk Makes Speaker for micro:bit shown in [Figure 2-4](ch02.xhtml#ch2fig4),
    end in pins similar to the micro:bit’s, making it easy to connect the two with
    alligator clip cables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些扬声器是专为与micro:bit配合使用而设计的。它们中的一些扬声器带有以鳄鱼夹结尾的电缆，可以连接到你的micro:bit，而其他扬声器，如[图2-4](ch02.xhtml#ch2fig4)中展示的Monk
    Makes为micro:bit设计的扬声器，则以类似micro:bit引脚的插头结尾，便于通过鳄鱼夹电缆连接两者。
- en: '![Image](../images/02fig04.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig04.jpg)'
- en: '*Figure 2-4: The Monk Makes Speaker for micro:bit*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：Monk Makes为micro:bit设计的扬声器*'
- en: 'Amplified speakers need a power source. In some cases, the amplified speaker
    may have its own batteries or USB cable. Otherwise, the micro:bit itself could
    power the speaker, in which case the devices will have to connect in three places:
    to GND (0V) and 3V on the micro:bit in order to power the speaker and to pin 0
    (or one of the other pins) for the audio signal coming from the micro:bit.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 增强型扬声器需要电源。在某些情况下，增强型扬声器可能有自己的电池或USB电缆。否则，micro:bit本身可以为扬声器供电，届时设备需要在三个地方连接：连接到micro:bit的GND（0V）和3V，以为扬声器供电，并连接到第0引脚（或其他引脚之一），用于传输来自micro:bit的音频信号。
- en: Whatever you’re using for audio output, let’s test it out!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么音频输出设备，我们来测试一下吧！
- en: '**EXPERIMENT 1: GENERATING SOUNDS**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实验1：产生声音**'
- en: '![Image](../images/common2.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common2.jpg)'
- en: In this experiment, you’ll learn how to generate sounds using your micro:bit
    and a loudspeaker or headphones.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，你将学习如何使用micro:bit和扬声器或耳机生成声音。
- en: '**What You’ll Need**'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**你将需要的工具**'
- en: 'To carry out this experiment, you just need:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这个实验，你只需要：
- en: '**Micro:bit**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micro:bit**'
- en: '**Speaker or headphones**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**扬声器或耳机**'
- en: '**Alligator clip cables**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**鳄鱼夹电缆**'
- en: You can find sources for these in the [appendix](app01.xhtml).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[附录](app01.xhtml)中找到这些设备的来源。
- en: Here we’ll assume you’re using a Monk Makes Speaker for micro:bit and a set
    of alligator clips, but any of the speaker connection methods listed earlier will
    work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们假设你使用的是Monk Makes为micro:bit设计的扬声器和一套鳄鱼夹，但之前列出的任何扬声器连接方法都可以使用。
- en: '**Construction**'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**构建**'
- en: Connect the speaker using one of the methods shown in [Figures 2-1](ch02.xhtml#ch2fig1)
    to [2-4](ch02.xhtml#ch2fig4). Then plug your micro:bit into your computer.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[图2-1](ch02.xhtml#ch2fig1)到[图2-4](ch02.xhtml#ch2fig4)中显示的方法之一连接扬声器。然后将micro:bit插入计算机。
- en: 'Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    to access this book’s code repository and click the link for **Experiment 1: Generating
    Sounds**. Once the program has opened, click **Download** and then copy the hex
    file onto your micro:bit. If you get stuck, head back to [Chapter 1](ch01.xhtml#ch01),
    where we discuss the process of getting programs onto your micro:bit in full.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问*[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*来进入本书的代码仓库，然后点击**实验1：产生声音**的链接。一旦程序打开，点击**下载**，然后将.hex文件复制到你的micro:bit上。如果遇到困难，返回[第1章](ch01.xhtml#ch01)，那里详细讲解了如何将程序加载到micro:bit上的过程。
- en: If you prefer to use Python, download the code from the same website. For instructions
    for downloading and using the book’s examples, see “Downloading the Code” on [page
    34](ch01.xhtml#page_34). The Python file for this experiment is *Experiment_01.py*.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用Python，可以从同一个网站下载代码。关于如何下载和使用本书示例的说明，请参见[第34页](ch01.xhtml#page_34)的“下载代码”部分。本实验的Python文件是*Experiment_01.py*。
- en: Once you’ve successfully programmed the micro:bit, press **button A**. You should
    hear a tone through your speaker or headphones!
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功编程micro:bit，按下**按钮A**。你应该能通过扬声器或耳机听到一个音调！
- en: '**Code**'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码**'
- en: You won’t need much code for this experiment. Whether you use Blocks code or
    MicroPython, it’s just a matter of detecting button A being pressed and then playing
    a -.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验不需要太多代码。无论你使用Blocks代码还是MicroPython，都只是检测按钮A是否被按下，然后播放一个音调。
- en: '**Blocks Code**'
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Blocks代码**'
- en: The Blocks code for this experiment is shown here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该实验的Blocks代码如下所示。
- en: '![Image](../images/f0044-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0044-01.jpg)'
- en: The code uses the `on button A pressed` block to run the `play tone` block every
    time button A is pressed. You drop the `play tone` block into the `on button A
    pressed` block so it clicks into place. Then from the drop-down menu, select the
    tone you want to hear (in this case `Middle C`) and the duration of the note (`1
    beat`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `on button A pressed` 块来运行 `play tone` 块，每当按下按钮 A 时都会执行。你将 `play tone`
    块放入 `on button A pressed` 块中，使其卡入到位。然后从下拉菜单中选择你想听的音调（在这种情况下是 `中央 C`）和音符的时长（`1
    拍`）。
- en: '**MicroPython Code**'
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MicroPython 代码**'
- en: 'Here’s the MicroPython version of the code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的 MicroPython 版本：
- en: from microbit import *
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: import music
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: import music
- en: 'while True:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.was_pressed():'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下按钮 A：
- en: music.pitch(262, 1000)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: music.pitch(262, 1000)
- en: 'Python has a huge number of *libraries*, which are collections of code that
    do a specific thing. By asking your code to use these libraries, you get access
    to a lot of functionality without having to write complicated code yourself. The
    music library is an example: it contains functions you can use to make your micro:bit
    make sound. To make MicroPython use the music library, you first import the library
    using the `import music` command.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有大量的 *库*，它们是执行特定任务的代码集合。通过要求你的代码使用这些库，你可以访问许多功能，而不必自己编写复杂的代码。音乐库就是一个例子：它包含了可以让你的
    micro:bit 发出声音的函数。为了让 MicroPython 使用音乐库，你首先需要使用 `import music` 命令导入该库。
- en: While Blocks code will handle some things on its own, like knowing how often
    to run code and what order to run it in, MicroPython requires you to make that
    clear in the code itself. Here, you use a `while True:` loop to tell the micro:bit
    to keep checking whether someone has pressed button A.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Blocks 代码会自动处理一些事情，比如知道多长时间运行一次代码以及以什么顺序运行代码，但 MicroPython 要求你在代码中明确指示这些内容。在这里，你使用
    `while True:` 循环来告诉 micro:bit 一直检查是否有人按下按钮 A。
- en: 'When someone does press button A, the note plays using the `pitch` command,
    which needs two pieces of information: the frequency of the note (`262` is middle
    C) and the duration of the note in milliseconds (in this case, `1000` milliseconds
    or 1 second).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人按下按钮 A 时，音符通过 `pitch` 命令播放，该命令需要两个信息：音符的频率（`262` 是中央 C）和音符的时长（在这种情况下是 `1000`
    毫秒，或者 1 秒）。
- en: '**Things to Try**'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**尝试的事情**'
- en: You might like to try changing the tone produced. If you are using Blocks code,
    go back to the browser and click the **Edit** button to alter the code, then click
    **Middle C**. This will open up a mini keyboard where you can choose a different
    note to play. To change the note in MicroPython, enter a new number instead of
    262 for the frequency. Then click the **Flash** button again. Later in this chapter,
    you’ll learn a better way to choose notes using MicroPython.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想尝试改变产生的音调。如果你使用的是 Blocks 代码，请返回浏览器并点击 **编辑** 按钮来修改代码，然后点击 **中央 C**。这将打开一个迷你键盘，你可以选择一个不同的音符来播放。要在
    MicroPython 中更改音符，请输入一个新的数字来代替 262 作为频率。然后再次点击 **闪烁** 按钮。在本章后面，你将学习一种更好的方法来选择使用
    MicroPython 播放的音符。
- en: You could also try making both buttons A and B play tones and even have them
    play different tones—a chord!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试让按钮 A 和按钮 B 都播放音调，甚至让它们播放不同的音调——一个和弦！
- en: '**How It Works: Frequency and Sound**'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**原理：频率与声音**'
- en: How does the micro:bit create sound in the speaker? Essentially, the micro:bit
    switches a current (the flow of electricity) on and off incredibly fast, causing
    part of the speaker to vibrate, creating sound. The speed at which the micro:bit
    switches the current on and off determines the *frequency* of the sound, and that’s
    what makes different tones. I’ll explain this in more detail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: micro:bit 如何在扬声器中产生声音？本质上，micro:bit 以极快的速度开关电流（电流的流动），导致扬声器的一部分振动，从而产生声音。micro:bit
    开关电流的速度决定了声音的 *频率*，也就是它产生不同音调的原因。我将详细解释这一点。
- en: '[Figure 2-5](ch02.xhtml#ch2fig5) shows the parts of a loudspeaker. A rigid,
    usually metal frame holds a cone in place. The narrow end of this cone is cylindrical
    and has a coil of wire wrapped around it. Around this coil, fixed to the frame
    of the loudspeaker, is a strong magnet.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-5](ch02.xhtml#ch2fig5) 显示了扬声器的各个部分。一个坚固的、通常是金属的框架将锥形固定在适当位置。这个锥形的窄端是圆柱形的，且有一根线圈绕在上面。在线圈的周围，固定在扬声器框架上的，是一个强大的磁铁。'
- en: When a current passes through the coil, it—and hence the whole cone—moves back
    and forth very rapidly. This vibration creates pressure waves in the air that
    we hear as sound.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当电流通过线圈时，它——因此整个锥形——会非常快速地前后振动。这种振动在空气中产生压力波，我们听到的就是声音。
- en: '![Image](../images/02fig05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig05.jpg)'
- en: '*Figure 2-5: A loudspeaker*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：扬声器*'
- en: To make a particular sound, the speaker cone needs to move back and forth a
    certain number of times per second. The number of times per second the speaker
    moves is its frequency, measured in *hertz* (shortened to Hz). The higher the
    frequency, the higher the pitch of the sound. A frequency of 262 Hz corresponds
    to middle C on a piano. The C an octave higher has a frequency of 524 Hz, or double
    middle C. In music, when you go up an octave, you double the frequency.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要发出特定的声音，扬声器的振膜需要每秒前后移动一定次数。扬声器每秒移动的次数就是它的频率，单位是*赫兹*（简写为Hz）。频率越高，声音的音调越高。262
    Hz的频率对应钢琴上的中音C。高一个八度的C频率为524 Hz，即双倍的中音C。在音乐中，当你升高一个八度时，频率也会加倍。
- en: The micro:bit controls the current and therefore the frequency by turning pin
    0 on and off very rapidly. When pin 0 is off, it has an output voltage of 0V,
    and when it is on, it has a voltage of 3V. If you were to draw a chart of the
    output voltage against time, it would look like [Figure 2-6](ch02.xhtml#ch2fig6).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: micro:bit通过快速开关引脚0来控制电流和频率。当引脚0关闭时，输出电压为0V；当引脚0开启时，输出电压为3V。如果你绘制输出电压与时间的关系图，它将像[图
    2-6](ch02.xhtml#ch2fig6)那样。
- en: For obvious reasons, this type of wave is called a *square wave*. Since a micro:bit’s
    outputs can only ever be on or off, this is the only kind of wave that we can
    generate from the micro:bit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 出于显而易见的原因，这种波形被称为*方波*。由于micro:bit的输出只能是开或关，这就是我们从micro:bit生成的唯一类型的波形。
- en: '![Image](../images/02fig06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig06.jpg)'
- en: '*Figure 2-6: A square wave*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：方波*'
- en: When the micro:bit sends its signal to the amplified speaker, the speaker takes
    the low current signal from the micro:bit and increases the current to drive the
    speaker with more power, making everything louder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当micro:bit将信号传输到扩音器时，扬声器会从micro:bit接收低电流信号，并增加电流，以更大功率驱动扬声器，从而使声音变大。
- en: Now let’s experiment with making sounds.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试制作声音。
- en: '**EXPERIMENT 2: IT SPEAKS!**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实验 2：它会说话！**'
- en: '![Image](../images/common2.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common2.jpg)'
- en: The micro:bit’s MicroPython software has a really neat feature that allows you
    to make your micro:bit read out phrases. In this experiment, we will try out this
    feature and have our micro:bit talk to us.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: micro:bit的MicroPython软件有一个非常棒的功能，允许你让micro:bit朗读短语。在这个实验中，我们将尝试这个功能，让micro:bit跟我们说话。
- en: Although the software that generates the speech was designed for use with English,
    by experimenting with the spelling, you should be able to make the library speak
    in other languages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然生成语音的软件是为英语设计的，但通过调整拼写，你应该能够让这个库用其他语言发声。
- en: This feature isn’t (at the time of writing) available through the Blocks code,
    so we’ll be using MicroPython.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前（写作时），这个功能不能通过Blocks代码使用，因此我们将使用MicroPython。
- en: '**What You’ll Need**'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**你将需要的材料**'
- en: This project uses exactly the same hardware as Experiment 1.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目使用的硬件与实验1完全相同。
- en: '**Micro:bit**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micro:bit**'
- en: '**Speaker or headphones**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**扬声器或耳机**'
- en: '**Alligator clip cables**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**鳄鱼夹电缆**'
- en: '**Construction**'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**构建**'
- en: Connect the speaker using one of the methods shown in [Figures 2-1](ch02.xhtml#ch2fig1)
    to [2-4](ch02.xhtml#ch2fig4).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[图 2-1](ch02.xhtml#ch2fig1)到[2-4](ch02.xhtml#ch2fig4)中展示的方法连接扬声器。
- en: This project uses the speech library, which is not available in Blocks code,
    so this experiment code is for Python only. Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    and download the *Experiment_02*.py file. You’ll also find code for the other
    projects and instructions for downloading and using the book’s examples on the
    GitHub page. Flash the program onto your micro:bit.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个项目使用了语音库，而该库在Blocks代码中不可用，因此这个实验代码仅适用于Python。访问*[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*并下载*Experiment_02*.py文件。你还可以在GitHub页面上找到其他项目的代码以及下载和使用书中示例的说明。将程序烧录到你的micro:bit中。
- en: Once the micro:bit has been successfully programmed, press **button A** on the
    micro:bit. You should hear a message being spoken through your speaker or headphones.
    The Mad Scientist likes to hear this voice as it’s a reminder of their dear old
    friend Professor Hawkins, who alas is no longer with us.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦micro:bit成功编程，按下**按钮A**，你应该能通过扬声器或耳机听到语音信息。疯狂科学家喜欢听这个声音，因为它让他们想起了他们亲爱的老朋友霍金教授，遗憾的是他已经不在人世了。
- en: '**Code**'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码**'
- en: 'The MicroPython code for the experiment is listed here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实验的MicroPython代码如下：
- en: from microbit import *
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: import speech
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: import speech
- en: 'while True:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.was_pressed():'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button_a.was_pressed():'
- en: speech.say("Mad Scientists love micro bits")
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: speech.say("疯狂科学家喜欢 micro:bit")
- en: Aside from importing the speech library, getting the micro:bit to speak is as
    simple as putting some text for it to say in the `say` function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了导入语音库外，让 micro:bit 发声只需要将要说的文本放入 `say` 函数中。
- en: The speech library is quite sophisticated—you can even use it to vary the pitch
    to make your micro:bit sing! You can find out all about the library at *[https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html](https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html)*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 语音库相当先进——你甚至可以使用它来调整音调，使你的 micro:bit 唱歌！你可以在*[https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html](https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html)*了解更多关于该库的信息。
- en: '**PROJECT: MUSICAL DOORBELL**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目：音乐门铃**'
- en: '![Image](../images/common3.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common3.jpg)'
- en: '*Difficulty: Easy*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*难度：简单*'
- en: The Mad Scientist is particularly partial to a musical doorbell. In fact, you
    will not be surprised to hear that one of the scientist’s favorite tunes is “Imperial
    March” from *Star Wars*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 疯狂科学家特别喜欢音乐门铃。事实上，你不会感到惊讶，科学家最喜欢的曲子之一就是《星球大战》中的《帝国进行曲》。
- en: In [Chapter 10](ch10.xhtml#ch10), we will revisit this project, adding a second
    micro:bit that will make the doorbell work wirelessly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.xhtml#ch10)中，我们将重新审视这个项目，添加第二个 micro:bit，使门铃能够无线工作。
- en: 'This project (shown in [Figure 2-7](ch02.xhtml#ch2fig7)) is a variation on
    Experiment 1, except that instead of playing a single tone when a button is pressed,
    the doorbell will play tunes. We’ll have button A play one tune and button B play
    another. You can see a short video of the project in action here: *[https://youtu.be/xmLupw4PxYQ/](https://youtu.be/xmLupw4PxYQ/)*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目（如[图 2-7](ch02.xhtml#ch2fig7)所示）是实验 1 的一个变体，区别在于当按钮被按下时，门铃播放的是曲子，而不是单一的音调。我们将让按钮
    A 播放一首曲子，按钮 B 播放另一首。你可以通过这个短视频查看项目的实际效果：*[https://youtu.be/xmLupw4PxYQ/](https://youtu.be/xmLupw4PxYQ/)*。
- en: '![Image](../images/02fig07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig07.jpg)'
- en: '*Figure 2-7: The musical doorbell project*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：音乐门铃项目*'
- en: Giving the visitor two tunes to choose from allows them to indicate the level
    of urgency of their visit. Then if the Mad Scientist is busy, they can just ignore
    the person at the door!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 给访客提供两首曲子供选择，可以让他们表达访问的紧急程度。如果疯狂科学家正忙，他们就可以选择忽略门口的人！
- en: '**What You’ll Need**'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**你需要的材料**'
- en: 'For this project, you will need the following items:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将需要以下物品：
- en: '**Micro:bit** To be the controller for this project and provide two buttons
    to press'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micro:bit** 作为这个项目的控制器，提供两个按钮供按压'
- en: '**3 × Alligator clip cables** To connect the micro:bit to the speaker (Longer
    cables will make this easier)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**3 × 鳄鱼夹电缆** 用于将 micro:bit 连接到扬声器（较长的电缆会更方便）'
- en: '**USB power adapter or 3V battery pack with power switch** To power the micro:bit
    and speaker'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**USB 电源适配器或带电源开关的 3V 电池包** 用于为 micro:bit 和扬声器提供电源'
- en: '**Speaker** To play the doorbell tune (I recommend the Monk Makes Speaker for
    micro:bit)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**扬声器** 播放门铃曲（我推荐使用 Monk Makes Speaker 与 micro:bit 配合使用）'
- en: '**Adhesive putty or self-adhesive pads** To attach the micro:bit to the door
    frame and the speaker to the inside of the door frame'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**粘合胶或自粘垫** 用于将 micro:bit 固定在门框上，扬声器固定在门框内部'
- en: '![Image](../images/f0050-01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0050-01.jpg)'
- en: If you use batteries for this project, it’s a good idea to use a battery box
    with a power switch so that when not in use, the doorbell can be switched off
    to save the batteries. Otherwise, the batteries will be exhausted after only a
    day or so of use. A USB power supply offers a longer-term solution that can be
    left on all the time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用电池进行这个项目，最好使用带电源开关的电池盒，这样在不使用时可以关闭门铃以节省电池电量。否则，电池在使用约一天后就会耗尽。USB 电源提供了一个长期的解决方案，可以一直保持开启状态。
- en: '**Construction**'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**构建**'
- en: When building a new project, it’s always worth constructing and testing it at
    your desk before you fit it into place where it will be used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建新项目时，总是值得在桌面上先进行构建和测试，然后再将其安装到实际使用的地方。
- en: Connect the speaker to the micro:bit using the three alligator cables, as shown
    in [Figure 2-7](ch02.xhtml#ch2fig7).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三根鳄鱼夹电缆将扬声器连接到 micro:bit，如[图 2-7](ch02.xhtml#ch2fig7)所示。
- en: It’s a good idea to use color-coding for your cables, with black for GND, red
    for 3V, and any other color for the audio connection from pin 0 of the micro:bit.
    Using different colors will help you keep track of the connections.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用颜色编码来区分你的电缆是个好主意，黑色表示 GND，红色表示 3V，其他颜色用于从 micro:bit 的 0 引脚连接音频。使用不同的颜色将帮助你跟踪连接。
- en: Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    to access the book’s code repository and click the link for **Musical Doorbell**.
    Once the program has opened, click **Download** and then copy the hex file onto
    your micro:bit. If you get stuck on this, head back to [Chapter 1](ch01.xhtml#ch01),
    where we discuss the process of getting programs onto your micro:bit in full.
    If you prefer to use Python, download the code from the same website, along with
    instructions for downloading and using the book’s examples. The Python file for
    this experiment is *ch_02_Doorbell.py*.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    以获取书中的代码库，并点击 **Musical Doorbell** 的链接。程序打开后，点击 **Download**，然后将 hex 文件复制到你的 micro:bit
    上。如果你遇到困难，可以回到[第1章](ch01.xhtml#ch01)，我们会详细讨论如何将程序加载到你的 micro:bit。如果你更喜欢使用 Python，可以从同一个网站下载代码，并附带下载和使用书中示例的说明。这个实验的
    Python 文件是 *ch_02_Doorbell.py*。
- en: Once the micro:bit has been successfully programmed, press **button A** on the
    micro:bit and you should hear a tune playing (Scott Joplin’s “The Entertainer”).
    Now press **button B** and you will hear Frédéric Chopin’s “Funeral March.”
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 micro:bit 成功编程，按下 **按钮 A**，你应该能听到一段旋律（斯科特·乔普林的《娱乐者》）。现在按下 **按钮 B**，你将听到弗雷德里克·肖邦的《葬礼进行曲》。
- en: 'Once you have everything working, disconnect the micro:bit from your computer
    and plug it into your USB power adapter or battery box. Test it out again to make
    sure you’ve got it working. Then fix the micro:bit part of the project onto one
    side of your door and the speaker side of the project to the other side of the
    door. There are a few things to note here:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦一切都正常工作，断开 micro:bit 与电脑的连接，然后将其插入 USB 电源适配器或电池盒。再次测试，确保它能正常工作。然后将 micro:bit
    部分固定在门的一侧，扬声器部分固定在门的另一侧。这里有几点需要注意：
- en: Firstly, sticking things to walls, even with adhesive putty, can make a mess,
    so make sure you get permission if you need to. This is especially true if you
    are using sticky pads, as these can attach quite permanently to paint.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，即使使用粘性胶垫将东西粘贴到墙上也可能弄得一团糟，所以如果需要，确保你获得了许可。如果你使用的是粘性垫，这一点尤为重要，因为它们可能会永久粘在油漆上。
- en: Secondly, the alligator clips will need to pass from one side of the door to
    the other in such a way that they don’t get too pinched when the door closes.
    So work out where they need to go before you start sticking anything down. In
    [Chapter 10](ch10.xhtml#ch10), we will make another version of this project that
    uses a second micro:bit to provide a wireless link.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其次，鳄鱼夹需要从门的一侧穿过到另一侧，以确保它们在门关闭时不会被夹得太紧。因此，在开始粘贴之前，先弄清楚它们应该放在哪里。在[第10章](ch10.xhtml#ch10)中，我们将制作该项目的另一个版本，使用第二个
    micro:bit 提供无线连接。
- en: Finally, if you are using a USB power adapter, you will need a power outlet
    that’s close enough for the USB power adapter to reach your micro:bit.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，如果你使用的是 USB 电源适配器，你需要一个足够靠近的电源插座，以便 USB 电源适配器能够连接到你的 micro:bit。
- en: '**Code**'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码**'
- en: Now let’s talk through the code for the project.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来讲解这个项目的代码。
- en: '**Blocks Code**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Blocks 代码**'
- en: Here’s the Blocks code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Blocks 代码。
- en: '![Image](../images/f0052-01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0052-01.jpg)'
- en: 'The code is similar to that of Experiment 1, with a few differences. First,
    we have two stacks of code: one for button A and one for button B. Second, we
    choose `once` from the `repeating` menu, because we want the melody to play only
    once.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与实验 1 相似，但有一些不同之处。首先，我们有两组代码：一组用于按钮 A，另一组用于按钮 B。其次，我们从 `repeating` 菜单中选择 `once`，因为我们希望旋律只播放一次。
- en: Third, we use the `start melody` block to play a whole sequence of notes rather
    than just a single note. Notice that these tunes are already available in the
    blocks—you just need to select them from the menu!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们使用 `start melody` 块来播放一整段旋律，而不仅仅是一个单音符。注意，这些旋律已经在块中提供——你只需要从菜单中选择它们！
- en: '**MicroPython Code**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MicroPython 代码**'
- en: 'Here is the MicroPython version of the program:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的 MicroPython 版本：
- en: from microbit import *
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: import music
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: import music
- en: 'while True:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.was_pressed():'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button_a.was_pressed():'
- en: music.play(music.ENTERTAINER)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: music.play(music.ENTERTAINER)
- en: 'elif button_b.was_pressed():'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif button_b.was_pressed():'
- en: music.play(music.FUNERAL)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: music.play(music.FUNERAL)
- en: This works exactly the same as the Blocks code. The `music.play` method is equivalent
    to the `start melody` block, and we use `if` statements to check which button
    was pressed. The `if` statements allow button A and button B to play different
    tunes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Blocks 代码的工作方式完全相同。`music.play` 方法等同于 `start melody` 块，而我们使用 `if` 语句来检查哪个按钮被按下。`if`
    语句允许按钮 A 和按钮 B 播放不同的曲调。
- en: The same predefined tunes are available to play in both Blocks and MicroPython
    code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的预定义音调可以在 Blocks 和 MicroPython 代码中播放。
- en: '**Things to Try**'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**尝试一下**'
- en: Picking from a selection of predefined tunes is all very well, but the Mad Scientist
    may have particular tastes in music. They may want to compose their own tunes!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从预定义的曲调中选择是很不错，但疯狂科学家可能有自己独特的音乐口味。他们可能想创作自己的曲子！
- en: If you are using Blocks code, you can make your own tune by creating a list
    of `play tone` blocks, like the example shown here. You fill out the notes you
    want played, and each note is played in turn.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Blocks 代码，你可以通过创建一系列 `play tone` 块来制作自己的曲调，就像这里展示的例子一样。你填写你想播放的音符，每个音符依次播放。
- en: '![Image](../images/f0053-01.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0053-01.jpg)'
- en: So if you know all the notes for a particular tune, you can create it like this.
    You’ll also need to specify how long each note needs to play. You may have to
    experiment a bit before you get your music to sound just the way you want.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你知道一首特定曲调的所有音符，你可以像这样创建它。你还需要指定每个音符播放的时长。在你让音乐听起来正如你所期望的那样之前，你可能需要做一些实验。
- en: 'Now let’s see how to create a tune in MicroPython:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在 MicroPython 中创建一首曲调：
- en: from microbit import *
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 microbit 的 *导入* *
- en: import music
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 导入音乐
- en: notes = ['A4:4', 'A', 'A', 'F:2', 'C5:2', 'A4:4', 'F:2', 'C5:2', 'A4:4']
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: notes = ['A4:4', 'A', 'A', 'F:2', 'C5:2', 'A4:4', 'F:2', 'C5:2', 'A4:4']
- en: 'while True:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.was_pressed():'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button_a.was_pressed():'
- en: music.play(notes)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: music.play(notes)
- en: The music library for MicroPython takes care of playing whole tunes by letting
    you use a special notation to write your own melodies. Each note is made up of
    a string of characters (see [Chapter 1](ch01.xhtml#ch01) for more information
    on strings). The first character of the string is the note name (a letter A to
    G). Next comes an octave number—middle C is in octave number 4, so you will probably
    want to restrict your tune to around octaves 3, 4, and 5\. The octave number is
    optional, and if you don’t give it, Python will assume you want the first octave.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MicroPython 的音乐库通过允许你使用特殊符号来编写自己的旋律，负责播放整个曲调。每个音符由一串字符组成（有关字符串的更多信息，请参见 [第 1
    章](ch01.xhtml#ch01)）。字符串的第一个字符是音符名称（字母 A 到 G）。接下来是一个八度数——中央 C 属于第 4 八度，所以你可能希望将曲调限制在
    3、4 和 5 八度之间。八度数是可选的，如果你没有提供，Python 将默认使用第一个八度。
- en: Once you specify an octave number, the music library will assume that octave
    applies to all following notes until you specify a different octave number.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你指定了一个八度数，音乐库将假定这个八度数适用于所有后续音符，直到你指定一个不同的八度数。
- en: Next, you can optionally put a colon followed by a duration. The duration is
    measured in quarter-notes. For example, to play middle C for a half-note, you
    would write `C4:2`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以选择性地添加一个冒号，后面跟着一个时长。时长是以四分音符为单位的。例如，要播放中央 C 的半音符，你可以写 `C4:2`。
- en: To string together several notes, you have to create a *list*. So far we’ve
    used variables that hold only a single element. A list is like a variable that
    can hold multiple elements, and you can access and use each element independently.
    To indicate that the `notes` variable contains a list of values, rather than just
    a single value, you’ll separate the array values by commas and enclose the whole
    thing between `[` and `]`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要将多个音符串联起来，你需要创建一个 *列表*。到目前为止，我们使用的变量只包含单个元素。列表就像一个可以包含多个元素的变量，你可以独立地访问和使用每个元素。为了表示
    `notes` 变量包含的是一个值列表，而不仅仅是一个单一的值，你需要用逗号分隔数组中的各个值，并将整个列表用 `[` 和 `]` 括起来。
- en: In our array, each element is a note string. To play the whole sequence of notes,
    you use the `play` function, providing it with the list of notes to play. This
    example plays the opening few notes from the *Star Wars* “Imperial March.”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数组中，每个元素都是一个音符字符串。要播放整个音符序列，您可以使用 `play` 函数，并提供要播放的音符列表。这个例子播放的是 *星球大战*
    中的“帝国进行曲”开头几小节的音符。
- en: Here, you see we import the usual microbit library, as well as the music library.
    We save our tune in a variable called `notes`. Then we make another `while True:`
    loop so that the code keeps running and checking whether the button was pressed.
    We tell the program that if button A is pressed, it should play the `notes` variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了常规的 microbit 库，以及音乐库。我们将我们的旋律保存在一个名为 `notes` 的变量中。然后我们创建了另一个 `while
    True:` 循环，以便代码持续运行并检查按钮是否被按下。我们告诉程序，如果按下 A 按钮，它应该播放 `notes` 变量。
- en: '**PROJECT: SHOUT-O-METER**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目：Shout-O-Meter**'
- en: '![Image](../images/common3.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common3.jpg)'
- en: '*Difficulty: Easy*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*难度：简单*'
- en: The Mad Scientist likes to measure things. To that end, this project makes a
    simple sound meter that indicates the volume of a noise. Then the scientist can
    tell the neighbors off for making too much noise—and prove they really are.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 疯狂的科学家喜欢测量事物。为此，本项目制作了一个简单的声音计，它可以指示噪音的音量。这样，科学家就可以因邻居制造过多噪音而斥责他们——并证明他们确实有过多噪音。
- en: '**What You’ll Need**'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**所需物品**'
- en: For this project, you need a microphone to pick up sounds so you can measure
    their volume. I’m going to use the microphone built into the Monk Makes Sensor,
    which has a bunch of sensors. The sound’s volume then appears on the micro:bit’s
    LED display. The louder the sound, the more LEDs will light up.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目需要一个麦克风来接收声音，以便测量其音量。我将使用 Monk Makes Sensor 中内置的麦克风，它配备了多个传感器。声音的音量随后会显示在
    micro:bit 的 LED 显示屏上。声音越大，点亮的 LED 越多。
- en: 'For this project, you will need the following items:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目需要以下物品：
- en: '**Micro:bit** To be the controller for this project and provide two buttons
    to press'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micro:bit** 作为本项目的控制器，提供两个按钮供按压'
- en: '**3 × Alligator clip cables** To connect the micro:bit to the speaker (Longer
    cables will make this easier)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**3 × 鳄鱼夹电缆** 用于将 micro:bit 连接到扬声器（更长的电缆会使操作更方便）'
- en: '**Any micro:bit power source** Can be the USB computer cable or a battery box'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**任何 micro:bit 电源** 可以是 USB 计算机电缆或电池盒'
- en: '**Monk Makes Sensor for micro:bit** To supply a microphone'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**Monk Makes Sensor for micro:bit** 用于提供麦克风'
- en: '**Construction**'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**构建**'
- en: Connect the sensor board to the micro:bit using the three alligator clips, as
    shown in [Figure 2-8](ch02.xhtml#ch2fig8). You need to connect 3V on the sensor
    to 3V on the micro:bit, GND to GND, and the hole with the microphone picture to
    pin 0 on the micro:bit.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三根鳄鱼夹将传感器板连接到 micro:bit，如[图 2-8](ch02.xhtml#ch2fig8)所示。你需要将传感器上的 3V 连接到 micro:bit
    上的 3V，GND 连接到 GND，并将带有麦克风图标的孔连接到 micro:bit 的引脚 0。
- en: It’s a good idea to stick to the color-coding of the cables, with black for
    GND, red for 3V, and any other color for the microphone connection from pin 0
    of the micro:bit.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最好遵循电缆的颜色编码，黑色用于 GND，红色用于 3V，其他颜色用于从 micro:bit 引脚 0 连接到麦克风。
- en: '![Image](../images/02fig08.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/02fig08.jpg)'
- en: '*Figure 2-8: The Shout-o-meter project*'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 2-8：Shout-o-meter 项目*'
- en: Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    to access the book’s code repository and click the link for **Shout-O-Meter**.
    Once the program has opened, click **Download** and then copy the hex file onto
    your micro:bit. If you get stuck on this, head back to [Chapter 1](ch01.xhtml#ch01),
    where we discuss in detail how to get programs onto your micro:bit.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    获取本书的代码库，并点击 **Shout-O-Meter** 的链接。一旦程序打开，点击 **下载**，然后将 hex 文件复制到你的 micro:bit
    上。如果你在此过程中遇到问题，请回到[第 1 章](ch01.xhtml#ch01)，我们会详细讨论如何将程序加载到 micro:bit 上。
- en: If you prefer to use Python, then download the code from the same website, along
    with instructions for downloading and using the book’s examples. The Python file
    for this experiment is *ch_2_Shoutometer.py*.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用 Python，那么可以从同一网站下载代码，以及下载和使用书中示例的说明。此实验的 Python 文件为 *ch_2_Shoutometer.py*。
- en: 'Once you’ve programmed the micro:bit, try whistling near the microphone ([Figure
    2-9](ch02.xhtml#ch2fig9)) and notice how the LEDs jump in response to the sound
    level. You can also try tapping the microphone. You can see a short video of the
    project in action here: *[https://youtu.be/6pGDSHmfFng/](https://youtu.be/6pGDSHmfFng/)*.![Image](../images/02fig09.jpg)'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程完成后，尝试在麦克风附近吹口哨（见[图 2-9](ch02.xhtml#ch2fig9)），注意 LED 如何响应声音的强度。你也可以尝试轻拍麦克风。你可以在这里看到一个项目运行的视频：
    *[https://youtu.be/6pGDSHmfFng/](https://youtu.be/6pGDSHmfFng/)*。![Image](../images/02fig09.jpg)
- en: '*Figure 2-9: The Monk Makes Sensor for micro:bit microphone*'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 2-9：Monk Makes Sensor for micro:bit 麦克风*'
- en: '**Code**'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**代码**'
- en: The Blocks version of this code is able to make use of the built-in `plot bar
    graph of` block, whereas the MicroPython version is more complicated because we
    have to implement our own version of this feature.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的 Blocks 版本能够利用内置的 `plot bar graph of` 块，而 MicroPython 版本则更为复杂，因为我们必须实现自己的这一功能版本。
- en: '**Blocks Code**'
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Blocks 代码**'
- en: The Blocks language includes a useful block called `plot bar graph of` that
    makes the code for displaying the sound level really easy.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Blocks 语言包括一个名为 `plot bar graph of` 的有用块，它使得显示声音水平的代码变得非常简单。
- en: '![Image](../images/f0057-01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0057-01.jpg)'
- en: We put a `forever` block in, so the code inside is constantly running. Then
    we add the `plot bar graph of` block, which will display the loudness from the
    microphone.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入了一个 `forever` 块，因此里面的代码会不断运行。然后，我们添加了 `plot bar graph of` 块，它将显示来自麦克风的响度。
- en: 'As you can see, the analog value read from pin 0 of the micro:bit has `511`
    subtracted from it before being passed to `plot bar graph of` with a maximum value
    of `up to` set to `512`. The reason for this bit of math is discussed in “How
    It Works: Microphone Output” on [page 59](ch02.xhtml#page_59).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从 micro:bit 的引脚 0 读取的模拟值会减去 `511`，然后传递给 `plot bar graph of` 块，并且最大值设置为
    `up to`，最大值为 `512`。这一部分数学运算的原因在《如何工作：麦克风输出》一节中讨论，详见 [第 59 页](ch02.xhtml#page_59)。
- en: Getting the right blocks assembled can be tricky, especially when it comes to
    math. Fortunately, the editor allows you to freely move blocks around, so if they
    are not in the right place to give you the results you want, you can just drag
    them to where they should be. See [Chapter 1](ch01.xhtml#ch01) for more information
    on editing code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 获取正确的块组合可能有点棘手，特别是在涉及到数学运算时。幸运的是，编辑器允许你自由移动块，因此如果它们没有放在正确的位置以获得你想要的结果，你可以将它们拖动到应该放置的地方。有关编辑代码的更多信息，请参见
    [第 1 章](ch01.xhtml#ch01)。
- en: '**MicroPython Code**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MicroPython 代码**'
- en: The MicroPython version of the code is a little more complicated than the Blocks
    code. MicroPython does not have a built-in bar graph display, so we have to write
    our own. The `plot bar graph of` block provides a nice, smooth display, despite
    rapidly changing data. To get the same result in MicroPython, I had to add code
    to read the maximum sound level from 10 samples.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: MicroPython 版本的代码比 Blocks 版本稍微复杂一些。MicroPython 没有内置的条形图显示功能，因此我们必须自己编写。在 Blocks
    版本中，`plot bar graph of` 块提供了一个平滑的显示，尽管数据变化迅速。而要在 MicroPython 中获得相同的效果，我需要添加代码从
    10 个样本中读取最大声音水平。
- en: from microbit import *
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: 'def sound_level():'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'def sound_level():'
- en: max_level = 0
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: max_level = 0
- en: 'for i in range(0, 10):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(0, 10):'
- en: sound_level = (pin0.read_analog() - 511) / 100
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: sound_level = (pin0.read_analog() - 511) / 100
- en: 'if sound_level > max_level:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'if sound_level > max_level:'
- en: max_level = sound_level
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: max_level = sound_level
- en: return max_level
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: return max_level
- en: 'def bargraph(a):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'def bargraph(a):'
- en: display.clear()
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: display.clear()
- en: 'for y in range(0, 5):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'for y in range(0, 5):'
- en: 'if a > y:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > y:'
- en: 'for x in range(0, 5):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(0, 5):'
- en: display.set_pixel(x, 4-y, 9)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: display.set_pixel(x, 4-y, 9)
- en: 'while True:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: bargraph(sound_level())
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: bargraph(sound_level())
- en: sleep(10)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: sleep(10)
- en: We use the `sound_level` function and make a `for` loop to take 10 samples of
    sound. Each sample value is (as with the Blocks version of the code) the analog
    value with `511` subtracted from it. However in this case, to scale down the number
    of rows to be lit to 0 to 4, we divide the resulting value by 100\. We then compare
    the sound level stored in the variable `sound_level` to the variable `max_level`
    and, if it is greater, `max_level` is changed to be the `sound_level`. When all
    10 samples have been taken, the largest one will be in `max_level`, and this value
    is returned by the function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `sound_level` 函数并创建一个 `for` 循环来采集 10 个声音样本。每个样本值（与 Blocks 版本的代码一样）都是从模拟值中减去
    `511` 得到的。然而，在这个例子中，为了将点亮的行数缩放到 0 到 4，我们将得到的值除以 100。然后，我们将存储在 `sound_level` 变量中的声音级别与
    `max_level` 变量进行比较，如果 `sound_level` 更大，则将 `max_level` 更新为 `sound_level`。当所有 10
    个样本采集完后，最大的值将存储在 `max_level` 中，并且这个值将由函数返回。
- en: The `bargraph` function takes a value, represented by `a`, to display. The higher
    the value, the more LEDs will be lit, indicating a louder noise. This value should
    be between 0 and 4\. However, if it is greater than 4, it doesn’t matter—all the
    LEDs in the display will turn on, but nothing else will happen. The function works
    by looping over each row of the display, and, if the value of `a` is greater than
    the row number, every LED on that row is illuminated by the inner `for` loop that
    asks whether `x` is in the range of 0 to 4.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`bargraph`函数接受一个值，表示为`a`，来进行显示。值越高，点亮的 LED 越多，表示噪音越大。该值应介于 0 和 4 之间。如果大于 4，也没有关系——显示屏上的所有
    LED 会被点亮，但不会有其他变化。该函数通过遍历显示屏的每一行来工作，如果`a`的值大于该行的行号，那么该行上的每个 LED 都会被内部的`for`循环点亮，`for`循环会判断`x`是否在
    0 到 4 的范围内。'
- en: All the main `while` loop has to do is call the function `bargraph`, supplying
    it with the sound level returned by the function `sound_level`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的`while`循环要做的就是调用`bargraph`函数，并传入由`sound_level`函数返回的声音等级。
- en: '**How It Works: Microphone Output**'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**工作原理：麦克风输出**'
- en: '[Figure 2-10](ch02.xhtml#ch2fig10) shows a graph of the output of the microphone
    when it is detecting sound. Voltage is on the vertical axis, and time in on the
    horizontal axis.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-10](ch02.xhtml#ch2fig10) 显示了麦克风在检测声音时输出的图形。电压位于纵轴，时间位于横轴。'
- en: '![Image](../images/02fig10.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/02fig10.jpg)'
- en: '*Figure 2-10: A sample of sound*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-10：声音样本*'
- en: As you can see from the left-hand side of the plot, before the sound starts,
    the output voltage from the sensor is level at about 1.5V. When the sound starts,
    the voltage oscillates above and below this 1.5V value as the microphone picks
    up the pressure waves of the sound. A reading of 1.5V on the micro:bit gives an
    analog value of 511\. This is why we subtract 511 from the reading before displaying
    it on the micro:bit; otherwise, half the LEDs would be on during silence.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从图表的左侧所看到的，在声音开始之前，传感器的输出电压大约在 1.5V 处平稳。当声音开始时，电压在 1.5V 之上和之下振荡，麦克风拾取到声音的压力波。micro:bit
    上的 1.5V 读数对应的模拟值是 511。正因为如此，在将读数显示在 micro:bit 上之前，我们需要从读数中减去 511；否则，在没有声音的情况下，显示屏上会有一半的
    LED 点亮。
- en: '**SUMMARY**'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, the Mad Scientist explored the world of sound, both by producing
    music and speech from the micro:bit and by detecting sound using a microphone.
    We have started our exploration of the micro:bit with a couple of easy projects.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，疯狂科学家探索了声音的世界，既通过 micro:bit 产生音乐和语音，也通过麦克风检测声音。我们已经开始了对 micro:bit 的探索，进行了一些简单的项目。
- en: In the next chapter, we will take a look at light. We’ll measure light with
    a special sensor and use the micro:bit’s LED display. Then we’ll tackle a large
    project, using the multicolored NeoPixel display and combining light with sound
    to make a light-controlled musical instrument. After that, we’ll move on to other,
    even more challenging projects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将看看光。我们将用一个特殊的传感器来测量光，并使用 micro:bit 的 LED 显示屏。接着，我们将进行一个大型项目，使用多色的 NeoPixel
    显示屏，并将光与声音结合，制作一个光控乐器。之后，我们将进入其他更具挑战性的项目。
