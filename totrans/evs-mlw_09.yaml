- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">RUNTIME
    ENVIRONMENT AND VIRTUAL PROCESSOR ANOMALIES</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous three chapters, you’ve seen how malware can query and enumerate
    OS artifacts and configurations to understand its environment and detect that
    it’s being analyzed. This chapter will focus on how malware can actively identify
    analysis sandboxes and VM environments by inspecting the anomalies that malware
    analysis tools introduce, monitoring virtual processor performance and timing,
    and abusing virtual processor instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Analysis and Runtime Anomalies</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When malware is executed in a sandbox or malware analysis environment, the sandbox
    or analysis tools can give away their presence in several ways. Sandboxes sometimes
    rename the malware file to a generic filename, for example. Sandboxes and analysis
    tools might also inject code into or modify code in the malware sample to better
    intercept and analyze the malware’s actions. Some malware variants can detect
    these anomalies in their runtime environment. Let’s look into these techniques
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Run Paths, Filenames,
    and Arguments</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When malware is sent to an automated sandbox to be detonated and analyzed,
    it’s often named something generic such as *sample.exe* or *malware.exe* or assigned
    a hash value like *b3126a1de5401048f5a6ea5a9192126fc7482ff0.* It might also be
    run from a generic directory such as *C:\Users\<user>\Downloads* or *C:\Users\<user>\Desktop*,
    rather than the directory the malware author intended, such as a temporary directory.
    Some malware can identify these anomalies. For example, a malware sample might
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp>
    function to return its own name or the <samp class="SANS_TheSansMonoCd_W5Regular_11">PathFindFileName</samp>
    function to return the full path from where it executed. The following sample
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp> to
    test whether its filename is blocklisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This malware sample calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileNameA</samp>
    function ❶ with three parameters: a buffer that will store the returned filename
    for the malware (<samp class="SANS_TheSansMonoCd_W5Regular_11">fileNameBuffer</samp>),
    the size of this buffer (<samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>),
    and a target module (<samp class="SANS_TheSansMonoCd_W5Regular_11">esi</samp>).
    The target module, when set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    is the currently running process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsstr</samp>
    function ❷ with two parameters: a blocklisted filename (<samp class="SANS_TheSansMonoCd_W5Regular_11">blocklist1</samp>)
    and a pointer to the buffer that stores the malware filename returned from <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp>. The malware
    sample then compares its own filename to a blocklist value. If the result is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, meaning that the returned filename
    doesn’t match the blocklisted filename, the malware jumps to the next comparison.
    It continues to iterate through a list of blocklisted filenames ❸. If it finds
    a match, it assumes it is being analyzed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a generic filename, malware sandboxes and analysts sometimes
    rename the malware file to its hash value—typically in MD5, SHA-1, or SHA256 format.
    When you download malware from malware repositories such as VirusTotal, its filename
    will be in the form of a hash, like *b3126a1de5401048f5a6ea5a9192126fc7482ff0*.
    The malware analyst or sandbox may simply append the file type extension to this
    file before running it: *b3126a1de5401048f5a6ea5a9192126fc7482ff0.exe*. Hashes
    have a set number of characters, such as 32 characters for MD5 hashes and 40 characters
    for SHA-1 hashes. Malware can count the number of characters in its filename,
    and if there are exactly 32 or 40 (plus the file extension characters), the malware
    could assume it’s running in an analysis environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, malware can inspect its run path and filename and compare those
    to the original run path and filename intended by the malware author. For example,
    a malicious Microsoft Word document might attempt to download an executable file
    from the internet and save it in the *C:\Users\<user>\AppData\Roaming* directory,
    with a filename of *abc.exe*. If a malware analyst were to obtain this executable
    file without the original Word document and run it from the *C:\Users\<user>\Downloads*
    directory with a filename of *evil.exe*, the malware sample might notice that
    it was running from an anomalous location with an unknown filename and take evasive
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, malware may inspect its command line arguments. Certain sandboxes
    add their own arguments into the malware process, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">-force</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-analysis</samp>, or -<samp class="SANS_TheSansMonoCd_W5Regular_11">debug</samp>.
    By checking for the presence of these arguments, malware can detect if it’s running
    inside a sandbox environment and alter its behavior accordingly. A variation of
    this technique is malware executing only with specific command line arguments.
    If the malware is executed without them, which might be the case if it’s detonated
    in an automated sandbox environment, it could cease to fully execute or exhibit
    different functionalities. For example, the malware sample *evil.exe* may require
    the command line argument <samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp> argument,
    the malware may not run correctly in the analysis environment. This technique
    usually involves a preliminary malware executable or script that executes the
    primary malware executable with the correct arguments. In this case, you might
    have to do some manual analysis and reverse engineering to identify the command
    line arguments the malware is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bypass many filename and run path evasion checks that malware might use,
    you can simply rename the file to a random word or phrase and run the file from
    a directory that malware is often executed from, such as a temp directory (for
    example, *C:\Users\<username>\AppData\Roaming\*). It’s important to understand
    the full attack chain here too: the malware may be looking for a specific filepath
    or argument, and a quick way to get this path is to investigate all artifacts
    of the attack.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Loaded Modules</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Certain sandboxes and malware analysis tools load modules into the memory address
    space of a running malware process to modify the malware’s behavior or to intercept
    its code. In this case, a *module* is typically a DLL file that is loaded (or
    *injected*) into a target process for various reasons. To determine which modules
    are loaded in its memory space, the malware can use Windows API functions such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp> to enumerate
    its loaded modules and identify any anomalies. <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> are used
    to iterate through all the loaded modules inside the calling process, much like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp> are used to enumerate
    processes. <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>,
    on the other hand, simply takes a module name as a parameter and returns a handle
    to the module if it is loaded. Malware can use it to check for a hardcoded list
    of module names, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This malware sample first pushes the address of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"sbiedll.dll"</samp>
    to the stack, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandleA</samp>.
    If the returned value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    meaning that this module isn’t loaded into the malware’s memory space, the code
    jumps to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_2</samp>, where it
    uses the same instructions to check for the <samp class="SANS_TheSansMonoCd_W5Regular_11">"vmcheck.dll"</samp>
    module. The two modules this sample is looking for are Sandboxie (*sbiedll.dll*),
    a popular sandbox application, and *vmcheck.dll*, a module that’s often loaded
    in a Virtual PC guest.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This technique can be used for other reasons, like looking for anti-malware,
    endpoint detection and response (EDR), and other defense tools; we’ll discuss
    this in [Part IV](part4.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anomalous Strings
    in Memory</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When hooking or monitoring malware, analysis sandboxes and tools sometimes
    leave artifacts in the malware’s process memory space. Malware can enumerate these
    strings in memory, searching for specific analysis tools and other suspicious
    behaviors, as demonstrated by this pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, this malware sample defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">hashedString</samp>.
    This string is simply the SHA-1 hash sum of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">HookLibraryx86.dll</samp>,
    which I’ll discuss in more detail in a moment. Next, the sample will call the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp> function
    with several parameters, the most important of which are a handle to a process
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>), the base address
    from which to begin reading memory inside the process (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddresss</samp>),
    the buffer that will receive the read memory data (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>),
    and the number of bytes to be read from memory (<samp class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>).
    In this case, the process being read from is the malware’s own process. Once the
    data is read from memory and stored in the buffer, the sample calculates a hash
    of this data using the SHA-1 algorithm. Finally, the sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">memcmp</samp>
    to compare the hashed buffer data with the original hashed string.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can either search its entire memory address space for anomalies or target
    a specific memory region. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp>
    value can be any base address within the malware’s process address space.
  prefs: []
  type: TYPE_NORMAL
- en: This malware sample’s usage of hashing makes analysis more difficult because
    we can’t really know what it’s searching for in memory without reversing the hash.
    *HookLibraryx86.dll* is a module that is commonly loaded into memory when the
    tool ScyllaHide is being used to analyze malware. I’ll cover ScyllaHide in more
    detail in [Chapter 10](chapter10.xhtml), but for now, keep in mind that malware
    can scan its own memory for an anomalous string and obfuscate what it’s searching
    for to make analysis more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hooked Functions and
    Acceleration Checks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Automated malware sandboxes and some analysis tools may hook and modify specific
    functions when running malware to bypass certain evasion attempts. One commonly
    hooked function is <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>,
    which malware uses to remain dormant and prevent automated sandboxes from successfully
    analyzing it (because sandboxes often run for only a few minutes). Sandboxes might
    modify the parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    function to change the sleep time from 5 minutes to 30 seconds, for example. Malware
    can check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    function is being tampered with by “sandwiching” it between two timing-based functions,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> (this
    technique is called an *acceleration check*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>,
    followed by a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    for 30,000 milliseconds (30 seconds). Next, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    a second time, then subtracts the first <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    result from the second and stores the difference in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">sub eax, edi</samp>). Finally,
    the malware compares the value in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    to a value of 29,000 milliseconds, which is the minimum length of time that the
    malware expects should have elapsed. If an automated sandbox or tool has tampered
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> values wouldn’t
    be proportionate to this expected length of time, tipping the malware off that
    something is amiss.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Performance and Timing Indicators</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There can be significant timing and performance deviations between real, non-virtualized
    processors and their virtualized counterparts. Non-virtualized processors typically
    execute instructions more quickly and more efficiently than a virtual processor
    using the same hardware specifications. Most of the time, this isn’t noticeable
    to the humans interfacing with these systems. Malware, however, can exploit these
    slight differences to reveal the underlying VM.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The rdtsc Instruction</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Read Time-Stamp Counter*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>,
    is a special assembly instruction with a number of use cases, including performance
    monitoring and metrics gathering. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction is executed on a CPU, the current number of CPU ticks is stored and
    can be referenced and compared to a later <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction. The difference between the two values is the number of ticks since
    the first <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'VMs have a problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction. When <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> is
    executed by a program running on a virtual processor, the virtual processor must
    pass this instruction on to the “real” processor: the hardware CPU that runs the
    host OS. Passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction to the real CPU and back again causes some latency, which in turn
    increases the number of ticks. When malware sees that this returned tick count
    is higher than it would be on a non-virtualized system, it might deduce that it’s
    running inside a VM environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the way malware can use this technique, let’s look at
    an excerpt of some assembly code from a disassembled piece of malware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The malware sample uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction to get the current tick count and stores this value in a buffer (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">rdtsc_1</samp>). Then, it executes another
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction and subtracts
    the result from the original (<samp class="SANS_TheSansMonoCd_W5Regular_11">sub
    eax, [ebp+ rdtsc_1]</samp>). It can use the resulting value to determine whether
    the execution time is within the threshold of a non-virtualized processor.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes malware gets craftier than two simple <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    commands, and some malware families execute multiple iterations of <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    to get a more accurate value. In the next section, we’ll cover a few more use
    cases for <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Function Execution
    Timing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given the timing differences between non-virtualized and virtualized processors,
    some malware runs a function or instruction and compares its execution time to
    a baseline representing a real, non-virtualized processor. If the instructions
    execute more slowly than the baseline, the malware could determine that it’s running
    in a VM.
  prefs: []
  type: TYPE_NORMAL
- en: One technique is for the malware to sandwich a Windows API function call or
    instruction between two <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    functions and compare the results. A long delay between the two <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    functions could signify to the malware that it’s being executed and analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: There are many variations of this technique, including using instructions such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    instead of Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>.
    The takeaway here is that any time you spot malware using timing-based functions
    or instructions, followed by a comparison operation, you should investigate it
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Performance Counters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The CPU maintains *performance counters* to represent the number of instructions
    that have executed since a certain point in time. They can be used legitimately
    to gather performance metrics, but malware can use them to detect VM environments.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryPerformanceCounter</samp>
    function queries the processor’s performance counter and returns the current value.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryPerformanceFrequency</samp>
    returns the performance counter’s *frequency*, a fixed value representing the
    processor’s overall performance. When these instructions are executed in a VM,
    the values returned by these functions may be slightly lower than on a non-virtualized
    system, demonstrating the performance impact of virtualized processors.
  prefs: []
  type: TYPE_NORMAL
- en: If you spot malware using these functions, look for a subsequent comparison
    operation. This may be malware attempting to identify your analysis environment.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Abusing the Virtual Processor</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The virtual processors inside a VM may interpret and execute certain assembly
    instructions in a way that reveals the VM’s presence to malware. In this section,
    we’ll delve into how malware “abuses” these virtual processors by misusing instructions
    or exploiting their design flaws.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Red Pill and No
    Pill Techniques</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Red Pill and No Pill techniques are two well-known methods used by malware
    to detect virtual environments. Both techniques check processor data structures
    for VM-specific values. These techniques are often ineffective in modern analysis
    environments, so they’re seldom used in modern malware, but it’s still good to
    be aware of them.
  prefs: []
  type: TYPE_NORMAL
- en: For the Red Pill technique, malware executes the *Store Interrupt Descriptor
    Table*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sidt</samp>, assembly
    instruction, which writes the value of the Interrupt Descriptor Table register
    to memory, then checks it. The *Interrupt Descriptor Table (IDT)* is a data structure
    the processor uses to determine the correct response to exceptions and interrupts.
    (*Exceptions* signal to a processor that something is wrong with an instruction,
    and *interrupts* allow the processor to respond to a higher-priority event when
    required.) If the malware is running in a VM, the fifth byte of the IDT register
    will contain a specific value indicating that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Red Pill technique is simple to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">sidt [eax]</samp> instruction
    stores the contents of the IDT register, which is 6 bytes long, to a buffer. The
    code reads this value and executes a comparison operation to the fifth byte of
    the buffer, <samp class="SANS_TheSansMonoCd_W5Regular_11">[eax+5]</samp>. The
    fifth byte of the IDT register will be equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">FF</samp>
    (in hexadecimal) if it’s running in a VM.
  prefs: []
  type: TYPE_NORMAL
- en: The No Pill technique uses the *Store Local Descriptor Table*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sldt</samp>,
    instruction to store the *Local Descriptor Table* (*LDT*) register to memory.
    Since normal Windows applications don’t use the LDT, this LDT register should
    have a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. However,
    on some hypervisors, this LDT register value will contain a nonzero value, which
    can be a hint to the malware that it’s running in a VM. Similarly to the Red Pill
    technique, the No Pill technique doesn’t work correctly anymore in modern sandboxes
    and hypervisors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IO Ports</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An *input/output port (IO port)* is a communication method between the physical
    hardware of the machine and the software that’s running on it. Certain hypervisors
    use IO ports for host-to-guest OS communication. VMware, for example, uses the
    VMX IO port. Research from Cisco Talos revealed that malware can identify the
    VMX port to detect whether it is running in a VMware environment. The following
    assembly code shows what this might look like in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This malware sample loads the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">VMXh</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register, then
    loads the magic value of <samp class="SANS_TheSansMonoCd_W5Regular_11">2EF36D4Ch</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> register. This
    magic value can be any hexadecimal value, and it doesn’t matter here. Next, the
    code loads the <samp class="SANS_TheSansMonoCd_W5Regular_11">dx</samp> register
    segment with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">VX</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">5658</samp> in hexadecimal, which
    is the VMX port number. Finally, the malware executes <samp class="SANS_TheSansMonoCd_W5Regular_11">in
    eax, dx</samp>, which uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    assembly instruction to attempt to access the IO port. If this host is running
    the VMware Workstation hypervisor, this instruction will return the magic number,
    which will likely trigger the malware sample to terminate itself or take other
    evasive actions. On a non-virtualized host, the returned value would be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: As with the Red Pill and No Pill techniques, this specific technique is quite
    old and has already been patched in modern versions of VMware. However, it’s important
    to understand this technique and others like it in case you’re analyzing malware
    that uses it or some variation of it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The cpuid Instruction</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> assembly instruction
    returns information about the host’s processors, such as the processor’s features
    and manufacturer. Outside of a VM, executing <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    with EAX set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> will return
    something like <samp class="SANS_TheSansMonoCd_W5Regular_11">Genuineintel</samp>
    for Intel processors or <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthenticAMD</samp>
    for AMD processors. When <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    is executed inside a VM, it often returns the name of the hypervisor. In the case
    of VMware, this string is <samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareVMware</samp>.
    For VirtualBox, the returned string is <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxVBoxVBox</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting EAX to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> prior
    to executing <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> returns
    much more information, stored as a 31-bit block in the ECX and EDX registers.
    The 31st bit in the ECX register will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    if the system’s CPU is physical or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    if the system is using a virtual CPU, indicating a VM environment. Here’s an excerpt
    of assembly code from a malware sample using this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here the malware sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">inc
    eax</samp>), which will be used as a parameter for the <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    instruction following it. After <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    is executed, the malware executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">bt</samp>
    (*bit test*) instruction to move the 31st bit of <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp>
    into the *carry flag* register, which is a special CPU register that can store
    values of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    and is typically used during addition and subtraction operations. Finally, the
    sample checks the carry flag register (<samp class="SANS_TheSansMonoCd_W5Regular_11">jc</samp>),
    and if it’s set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the
    malware will conclude that it’s running in a VM and terminate itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Wikipedia is a great reference for the processor information and feature bits
    returned from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">cpuid</samp>.
    See* [https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/CPUID<wbr>.](https://en.wikipedia.org/wiki/CPUID)'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unsupported Instruction
    Sets</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware may use <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> to
    find out whether a specific instruction set is supported by the processor. For
    example, the 23rd bit within the EDX register specifies whether the processor
    supports the *SSE instruction set*, a set of uncommon assembly instructions that’s
    typically used for graphics processing and scientific computing. Some modern hypervisors
    support instruction sets like SSE, but not all do! This can be a dead giveaway
    for malware that it’s running in a VM or sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some malware, instead of methodically looking through the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>,
    will simply try to execute these instructions, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">movdqa</samp> (Move Aligned
    Double Quadword) instruction is used for moving data to and from *XMM registers*,
    which are those used in the SSE instruction set. In this code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">movdqa</samp>
    instruction moves the data referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp> register and
    again to the <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm1</samp> register.
    Then, it moves this data back from the <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm</samp>
    registers to <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>. If this
    code produces an error (or the malware crashes!), the malware sample may assume
    it’s being run in a virtualized environment.
  prefs: []
  type: TYPE_NORMAL
- en: The SSE instruction set is just an example here, and most modern hypervisors
    support it. The important thing to remember is that any exotic or uncommon assembly
    instructions can be abused by malware for VM and sandbox detection if the hypervisor
    doesn’t support them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of an exotic instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">vpcext</samp>,
    which produces an error if executed outside of the Windows Virtual PC hypervisor.
    If executed inside Virtual PC, however, the instruction will succeed and set the
    EBX register to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The following
    code executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">vpcext</samp>
    instruction, followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    instruction to check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>
    is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Trap Flag and
    Other Techniques</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The trap flag is the eighth bit in the EFLAGS register in the Intel x86 instruction
    set. If it is enabled prior to another instruction call, an exception will be
    triggered. In a VM environment, the hypervisor emulates the trap flag behavior.
    Depending on the hypervisor in use, this emulation may not be correct or complete,
    which will cause the trap flag to be ignored and notify the malware that it’s
    running in a VM. This technique was first discovered in the wild in 2021 by researchers
    at Palo Alto’s Unit 42.
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems that new VM detection methods like this trap flag technique are discovered
    every few years. Most of them have one thing in common: they abuse the way the
    CPU and its architecture were designed to function, causing the hypervisor to
    behave in unexpected or previously unknown ways and ultimately exposing the underlying
    VM. Malware analysts must keep up to date on these techniques to identify when
    malware is using them.'
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Risks of Using Detection Techniques</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen in this chapter and throughout the previous chapters, for malware
    authors there can be many benefits of implementing VM and analysis tool detection
    functionalities. So why might a malware author *not* include them? One reason
    is that these techniques can actually increase the chance of the malware being
    detected by anti-malware or an analyst. The more suspicious the Windows API functions
    or instructions the malware executes, the greater the chance that these behavioral
    anomalies will be noticed.
  prefs: []
  type: TYPE_NORMAL
- en: Another risk is less obvious and, in my opinion, a bit comical. If malware detects
    that it’s running in a VM and subsequently chooses not to infect the host, this
    can be self-defeating in certain circumstances. Many organizations are switching
    to cloud and on-demand infrastructure, where many systems are in fact VMs. Malware
    that can detect VMs to evade malware analysts and sandboxes often is simultaneously
    evading the exact corporate systems it’s designed to infect.
  prefs: []
  type: TYPE_NORMAL
- en: One real-world example is the well-known cybercrime malware Emotet, which featured
    several anti-analysis techniques, one of which was VM and sandbox detection. If
    it deemed the host a VM or sandbox, Emotet would either terminate itself, thus
    preventing infection, or behave differently from how it otherwise would on a real,
    physical system. This led to a lower Emotet infection rate than there would have
    been otherwise and likely saved some organizations running on virtualized infrastructure
    from major harm.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about several techniques that malware can use to
    establish context and detect malware analysis tooling, VMs, and sandboxes. Next,
    we’ll build on what we’ve discussed in this and the previous three chapters. Specifically,
    we’ll examine what malware does to evade and disrupt analysis efforts when it
    discovers it’s running in a virtualized environment or lab.
  prefs: []
  type: TYPE_NORMAL
