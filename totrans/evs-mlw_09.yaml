- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">RUNTIME
    ENVIRONMENT AND VIRTUAL PROCESSOR ANOMALIES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: In the previous three chapters, you’ve seen how malware can query and enumerate
    OS artifacts and configurations to understand its environment and detect that
    it’s being analyzed. This chapter will focus on how malware can actively identify
    analysis sandboxes and VM environments by inspecting the anomalies that malware
    analysis tools introduce, monitoring virtual processor performance and timing,
    and abusing virtual processor instructions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Analysis and Runtime Anomalies</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When malware is executed in a sandbox or malware analysis environment, the sandbox
    or analysis tools can give away their presence in several ways. Sandboxes sometimes
    rename the malware file to a generic filename, for example. Sandboxes and analysis
    tools might also inject code into or modify code in the malware sample to better
    intercept and analyze the malware’s actions. Some malware variants can detect
    these anomalies in their runtime environment. Let’s look into these techniques
    in more detail.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Run Paths, Filenames,
    and Arguments</samp>
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When malware is sent to an automated sandbox to be detonated and analyzed,
    it’s often named something generic such as *sample.exe* or *malware.exe* or assigned
    a hash value like *b3126a1de5401048f5a6ea5a9192126fc7482ff0.* It might also be
    run from a generic directory such as *C:\Users\<user>\Downloads* or *C:\Users\<user>\Desktop*,
    rather than the directory the malware author intended, such as a temporary directory.
    Some malware can identify these anomalies. For example, a malware sample might
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp>
    function to return its own name or the <samp class="SANS_TheSansMonoCd_W5Regular_11">PathFindFileName</samp>
    function to return the full path from where it executed. The following sample
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp> to
    test whether its filename is blocklisted:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This malware sample calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileNameA</samp>
    function ❶ with three parameters: a buffer that will store the returned filename
    for the malware (<samp class="SANS_TheSansMonoCd_W5Regular_11">fileNameBuffer</samp>),
    the size of this buffer (<samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>),
    and a target module (<samp class="SANS_TheSansMonoCd_W5Regular_11">esi</samp>).
    The target module, when set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    is the currently running process.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsstr</samp>
    function ❷ with two parameters: a blocklisted filename (<samp class="SANS_TheSansMonoCd_W5Regular_11">blocklist1</samp>)
    and a pointer to the buffer that stores the malware filename returned from <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp>. The malware
    sample then compares its own filename to a blocklist value. If the result is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, meaning that the returned filename
    doesn’t match the blocklisted filename, the malware jumps to the next comparison.
    It continues to iterate through a list of blocklisted filenames ❸. If it finds
    a match, it assumes it is being analyzed.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码调用了<samp class="SANS_TheSansMonoCd_W5Regular_11">wcsstr</samp>函数❷，该函数有两个参数：一个被列入黑名单的文件名（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">blocklist1</samp>）和一个指向缓冲区的指针，该缓冲区存储了从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetModuleFileName</samp>返回的恶意软件文件名。恶意软件样本随后将其自身的文件名与黑名单中的值进行比较。如果结果为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，即返回的文件名与黑名单中的文件名不匹配，恶意软件将跳到下一个比较。它将继续遍历黑名单中的文件名列表❸。如果找到匹配项，它就会假设自己正在被分析。
- en: 'Instead of using a generic filename, malware sandboxes and analysts sometimes
    rename the malware file to its hash value—typically in MD5, SHA-1, or SHA256 format.
    When you download malware from malware repositories such as VirusTotal, its filename
    will be in the form of a hash, like *b3126a1de5401048f5a6ea5a9192126fc7482ff0*.
    The malware analyst or sandbox may simply append the file type extension to this
    file before running it: *b3126a1de5401048f5a6ea5a9192126fc7482ff0.exe*. Hashes
    have a set number of characters, such as 32 characters for MD5 hashes and 40 characters
    for SHA-1 hashes. Malware can count the number of characters in its filename,
    and if there are exactly 32 or 40 (plus the file extension characters), the malware
    could assume it’s running in an analysis environment.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件沙箱和分析人员有时会将恶意软件文件重命名为其哈希值，而不是使用通用的文件名—通常为MD5、SHA-1或SHA256格式。当你从像VirusTotal这样的恶意软件库下载恶意软件时，它的文件名通常是哈希值的形式，如*b3126a1de5401048f5a6ea5a9192126fc7482ff0*。恶意软件分析人员或沙箱可能会在运行文件之前，简单地将文件扩展名附加到这个文件名上：*b3126a1de5401048f5a6ea5a9192126fc7482ff0.exe*。哈希值有固定的字符数，比如MD5哈希值有32个字符，SHA-1哈希值有40个字符。恶意软件可以计算文件名中的字符数，如果文件名恰好是32个或40个字符（再加上文件扩展名字符），恶意软件可能会假设它正在分析环境中运行。
- en: Additionally, malware can inspect its run path and filename and compare those
    to the original run path and filename intended by the malware author. For example,
    a malicious Microsoft Word document might attempt to download an executable file
    from the internet and save it in the *C:\Users\<user>\AppData\Roaming* directory,
    with a filename of *abc.exe*. If a malware analyst were to obtain this executable
    file without the original Word document and run it from the *C:\Users\<user>\Downloads*
    directory with a filename of *evil.exe*, the malware sample might notice that
    it was running from an anomalous location with an unknown filename and take evasive
    actions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，恶意软件可以检查其运行路径和文件名，并将其与恶意软件作者原本意图的运行路径和文件名进行比较。例如，一个恶意的Microsoft Word文档可能试图从互联网下载一个可执行文件，并将其保存在*C:\Users\<user>\AppData\Roaming*目录下，文件名为*abc.exe*。如果恶意软件分析人员获取到这个可执行文件，而没有原始的Word文档，并且从*C:\Users\<user>\Downloads*目录中以*evil.exe*的文件名运行它，恶意软件样本可能会注意到它从一个异常的位置运行，且文件名未知，从而采取规避措施。
- en: 'Finally, malware may inspect its command line arguments. Certain sandboxes
    add their own arguments into the malware process, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">-force</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-analysis</samp>, or -<samp class="SANS_TheSansMonoCd_W5Regular_11">debug</samp>.
    By checking for the presence of these arguments, malware can detect if it’s running
    inside a sandbox environment and alter its behavior accordingly. A variation of
    this technique is malware executing only with specific command line arguments.
    If the malware is executed without them, which might be the case if it’s detonated
    in an automated sandbox environment, it could cease to fully execute or exhibit
    different functionalities. For example, the malware sample *evil.exe* may require
    the command line argument <samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp>:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件可能会检查其命令行参数。一些沙箱会在恶意软件进程中添加自己的参数，例如<samp class="SANS_TheSansMonoCd_W5Regular_11">-force</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-analysis</samp>，或-samp class="SANS_TheSansMonoCd_W5Regular_11">debug</samp>。通过检查这些参数是否存在，恶意软件可以检测它是否在沙箱环境中运行，并相应地改变其行为。此技术的变种是恶意软件仅在特定命令行参数下执行。如果没有这些参数执行恶意软件（例如在自动化沙箱环境中引爆时），它可能无法完全执行或表现出不同的功能。例如，恶意软件样本*evil.exe*可能需要命令行参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp>：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp> argument,
    the malware may not run correctly in the analysis environment. This technique
    usually involves a preliminary malware executable or script that executes the
    primary malware executable with the correct arguments. In this case, you might
    have to do some manual analysis and reverse engineering to identify the command
    line arguments the malware is expecting.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有<samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp>参数，恶意软件可能在分析环境中无法正常运行。此技术通常涉及一个初步的恶意软件可执行文件或脚本，它使用正确的参数执行主要的恶意软件可执行文件。在这种情况下，你可能需要进行一些手动分析和逆向工程，以确定恶意软件期望的命令行参数。
- en: 'To bypass many filename and run path evasion checks that malware might use,
    you can simply rename the file to a random word or phrase and run the file from
    a directory that malware is often executed from, such as a temp directory (for
    example, *C:\Users\<username>\AppData\Roaming\*). It’s important to understand
    the full attack chain here too: the malware may be looking for a specific filepath
    or argument, and a quick way to get this path is to investigate all artifacts
    of the attack.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过恶意软件可能使用的许多文件名和运行路径规避检查，你可以简单地将文件重命名为一个随机单词或短语，并从一个恶意软件常常执行的目录运行该文件，例如临时目录（例如，*C:\Users\<username>\AppData\Roaming\*）。理解整个攻击链也非常重要：恶意软件可能在寻找特定的文件路径或参数，获取这些路径的快速方法是调查攻击的所有痕迹。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Loaded Modules</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">加载模块</samp>
- en: 'Certain sandboxes and malware analysis tools load modules into the memory address
    space of a running malware process to modify the malware’s behavior or to intercept
    its code. In this case, a *module* is typically a DLL file that is loaded (or
    *injected*) into a target process for various reasons. To determine which modules
    are loaded in its memory space, the malware can use Windows API functions such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp> to enumerate
    its loaded modules and identify any anomalies. <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> are used
    to iterate through all the loaded modules inside the calling process, much like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp> are used to enumerate
    processes. <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>,
    on the other hand, simply takes a module name as a parameter and returns a handle
    to the module if it is loaded. Malware can use it to check for a hardcoded list
    of module names, as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 某些沙箱和恶意软件分析工具将模块加载到正在运行的恶意软件进程的内存地址空间中，以修改恶意软件的行为或拦截其代码。在这种情况下，*模块*通常是一个 DLL
    文件，它被加载（或*注入*）到目标进程中以实现各种目的。为了确定哪些模块已加载到其内存空间中，恶意软件可以使用 Windows API 函数，如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp> 来枚举已加载的模块并识别任何异常。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp>
    用于迭代调用进程中所有已加载的模块，就像 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp> 用于枚举进程一样。另一方面，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp> 仅接受一个模块名作为参数，并在该模块已加载时返回模块的句柄。恶意软件可以利用这一点检查一个硬编码的模块名称列表，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This malware sample first pushes the address of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"sbiedll.dll"</samp>
    to the stack, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandleA</samp>.
    If the returned value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    meaning that this module isn’t loaded into the malware’s memory space, the code
    jumps to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_2</samp>, where it
    uses the same instructions to check for the <samp class="SANS_TheSansMonoCd_W5Regular_11">"vmcheck.dll"</samp>
    module. The two modules this sample is looking for are Sandboxie (*sbiedll.dll*),
    a popular sandbox application, and *vmcheck.dll*, a module that’s often loaded
    in a Virtual PC guest.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件样本首先将字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"sbiedll.dll"</samp>
    的地址推送到栈中，然后调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandleA</samp>。如果返回值是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，意味着该模块未加载到恶意软件的内存空间中，代码将跳转到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_2</samp>，并使用相同的指令检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">"vmcheck.dll"</samp>
    模块。此样本查找的两个模块分别是 Sandboxie（*sbiedll.dll*），一个流行的沙箱应用程序，以及 *vmcheck.dll*，这是一个通常会加载到虚拟
    PC 客户端中的模块。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*This technique can be used for other reasons, like looking for anti-malware,
    endpoint detection and response (EDR), and other defense tools; we’ll discuss
    this in [Part IV](part4.xhtml).*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*此技术还可以用于其他目的，比如寻找反恶意软件、终端检测与响应（EDR）以及其他防御工具；我们将在[第 IV 部分](part4.xhtml)中讨论这一点。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anomalous Strings
    in Memory</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">内存中的异常字符串</samp>
- en: 'When hooking or monitoring malware, analysis sandboxes and tools sometimes
    leave artifacts in the malware’s process memory space. Malware can enumerate these
    strings in memory, searching for specific analysis tools and other suspicious
    behaviors, as demonstrated by this pseudocode:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在钩取或监控恶意软件时，分析沙箱和工具有时会在恶意软件的进程内存空间中留下痕迹。恶意软件可以枚举内存中的这些字符串，搜索特定的分析工具和其他可疑行为，如以下伪代码所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, this malware sample defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">hashedString</samp>.
    This string is simply the SHA-1 hash sum of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">HookLibraryx86.dll</samp>,
    which I’ll discuss in more detail in a moment. Next, the sample will call the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp> function
    with several parameters, the most important of which are a handle to a process
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>), the base address
    from which to begin reading memory inside the process (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddresss</samp>),
    the buffer that will receive the read memory data (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>),
    and the number of bytes to be read from memory (<samp class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>).
    In this case, the process being read from is the malware’s own process. Once the
    data is read from memory and stored in the buffer, the sample calculates a hash
    of this data using the SHA-1 algorithm. Finally, the sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">memcmp</samp>
    to compare the hashed buffer data with the original hashed string.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个恶意软件样本定义了变量<samp class="SANS_TheSansMonoCd_W5Regular_11">hashedString</samp>。这个字符串仅仅是字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HookLibraryx86.dll</samp>的SHA-1哈希值，我稍后会更详细地讨论这一点。接下来，样本将调用函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>，并传入多个参数，其中最重要的参数包括进程的句柄（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>），从进程内开始读取内存的基地址（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddresss</samp>），接收读取内存数据的缓冲区（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lpBuffer</samp>），以及要从内存中读取的字节数（<samp class="SANS_TheSansMonoCd_W5Regular_11">nSize</samp>）。在这种情况下，被读取的进程是恶意软件本身的进程。一旦从内存中读取了数据并将其存储到缓冲区中，样本将使用SHA-1算法对该数据进行哈希计算。最后，样本调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcmp</samp>函数将哈希后的缓冲区数据与原始哈希字符串进行比较。
- en: Malware can either search its entire memory address space for anomalies or target
    a specific memory region. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp>
    value can be any base address within the malware’s process address space.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以搜索其整个内存地址空间中的异常，也可以针对特定的内存区域。<samp class="SANS_TheSansMonoCd_W5Regular_11">lpBaseAddress</samp>值可以是恶意软件进程地址空间内的任何基地址。
- en: This malware sample’s usage of hashing makes analysis more difficult because
    we can’t really know what it’s searching for in memory without reversing the hash.
    *HookLibraryx86.dll* is a module that is commonly loaded into memory when the
    tool ScyllaHide is being used to analyze malware. I’ll cover ScyllaHide in more
    detail in [Chapter 10](chapter10.xhtml), but for now, keep in mind that malware
    can scan its own memory for an anomalous string and obfuscate what it’s searching
    for to make analysis more difficult.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件样本使用哈希技术使得分析变得更加困难，因为在没有反向哈希的情况下，我们无法确切知道它在内存中搜索的内容。*HookLibraryx86.dll*是一个常在使用ScyllaHide工具分析恶意软件时加载到内存中的模块。我将在[第10章](chapter10.xhtml)中更详细地讨论ScyllaHide，但目前请记住，恶意软件可以扫描自身内存中的异常字符串，并将其搜索内容混淆，以增加分析的难度。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hooked Functions and
    Acceleration Checks</samp>
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">钩子函数和加速检查</samp>
- en: 'Automated malware sandboxes and some analysis tools may hook and modify specific
    functions when running malware to bypass certain evasion attempts. One commonly
    hooked function is <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>,
    which malware uses to remain dormant and prevent automated sandboxes from successfully
    analyzing it (because sandboxes often run for only a few minutes). Sandboxes might
    modify the parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    function to change the sleep time from 5 minutes to 30 seconds, for example. Malware
    can check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    function is being tampered with by “sandwiching” it between two timing-based functions,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> (this
    technique is called an *acceleration check*):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化恶意软件沙箱和一些分析工具在运行恶意软件时，可能会钩取并修改特定函数，以绕过某些规避检测的尝试。一个常见的钩取函数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>，恶意软件利用它保持休眠状态，防止自动化沙箱成功分析（因为沙箱通常只运行几分钟）。例如，沙箱可能会修改
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> 函数的参数，将休眠时间从 5 分钟改为
    30 秒。恶意软件可以通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> 函数“夹在”两个基于计时的函数之间，来检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> 函数是否被篡改，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>（这种技术称为
    *加速检查*）：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>,
    followed by a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    for 30,000 milliseconds (30 seconds). Next, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    a second time, then subtracts the first <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    result from the second and stores the difference in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">sub eax, edi</samp>). Finally,
    the malware compares the value in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    to a value of 29,000 milliseconds, which is the minimum length of time that the
    malware expects should have elapsed. If an automated sandbox or tool has tampered
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> values wouldn’t
    be proportionate to this expected length of time, tipping the malware off that
    something is amiss.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件样本调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>，然后调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> 休眠 30,000 毫秒（30 秒）。接着，它第二次调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>，然后将第一次的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> 结果减去第二次的值，并将差值存储在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> 中（<samp class="SANS_TheSansMonoCd_W5Regular_11">sub
    eax, edi</samp>）。最后，恶意软件将 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    中的值与 29,000 毫秒进行比较，这是恶意软件预期经过的最短时间。如果自动化沙箱或工具篡改了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    函数，那么 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> 的值将与预期的时间长度不成比例，从而使恶意软件察觉到有问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Performance and Timing Indicators</samp>
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用性能和计时指示器</samp>
- en: There can be significant timing and performance deviations between real, non-virtualized
    processors and their virtualized counterparts. Non-virtualized processors typically
    execute instructions more quickly and more efficiently than a virtual processor
    using the same hardware specifications. Most of the time, this isn’t noticeable
    to the humans interfacing with these systems. Malware, however, can exploit these
    slight differences to reveal the underlying VM.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的非虚拟化处理器与虚拟化处理器之间可能存在显著的时间和性能偏差。非虚拟化处理器通常比虚拟化处理器使用相同硬件规格时执行指令更快、更高效。大多数情况下，普通用户在与这些系统交互时并不会察觉到这种差异。然而，恶意软件可以利用这些微小的差异来揭示底层的虚拟机。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The rdtsc Instruction</samp>
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">rdtsc 指令</samp>
- en: The *Read Time-Stamp Counter*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>,
    is a special assembly instruction with a number of use cases, including performance
    monitoring and metrics gathering. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction is executed on a CPU, the current number of CPU ticks is stored and
    can be referenced and compared to a later <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction. The difference between the two values is the number of ticks since
    the first <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'VMs have a problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction. When <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> is
    executed by a program running on a virtual processor, the virtual processor must
    pass this instruction on to the “real” processor: the hardware CPU that runs the
    host OS. Passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction to the real CPU and back again causes some latency, which in turn
    increases the number of ticks. When malware sees that this returned tick count
    is higher than it would be on a non-virtualized system, it might deduce that it’s
    running inside a VM environment.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the way malware can use this technique, let’s look at
    an excerpt of some assembly code from a disassembled piece of malware:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The malware sample uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction to get the current tick count and stores this value in a buffer (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">rdtsc_1</samp>). Then, it executes another
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction and subtracts
    the result from the original (<samp class="SANS_TheSansMonoCd_W5Regular_11">sub
    eax, [ebp+ rdtsc_1]</samp>). It can use the resulting value to determine whether
    the execution time is within the threshold of a non-virtualized processor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes malware gets craftier than two simple <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    commands, and some malware families execute multiple iterations of <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    to get a more accurate value. In the next section, we’ll cover a few more use
    cases for <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Function Execution
    Timing</samp>
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given the timing differences between non-virtualized and virtualized processors,
    some malware runs a function or instruction and compares its execution time to
    a baseline representing a real, non-virtualized processor. If the instructions
    execute more slowly than the baseline, the malware could determine that it’s running
    in a VM.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: One technique is for the malware to sandwich a Windows API function call or
    instruction between two <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    functions and compare the results. A long delay between the two <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    functions could signify to the malware that it’s being executed and analyzed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: There are many variations of this technique, including using instructions such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    instead of Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>.
    The takeaway here is that any time you spot malware using timing-based functions
    or instructions, followed by a comparison operation, you should investigate it
    in more detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Performance Counters</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The CPU maintains *performance counters* to represent the number of instructions
    that have executed since a certain point in time. They can be used legitimately
    to gather performance metrics, but malware can use them to detect VM environments.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryPerformanceCounter</samp>
    function queries the processor’s performance counter and returns the current value.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryPerformanceFrequency</samp>
    returns the performance counter’s *frequency*, a fixed value representing the
    processor’s overall performance. When these instructions are executed in a VM,
    the values returned by these functions may be slightly lower than on a non-virtualized
    system, demonstrating the performance impact of virtualized processors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: If you spot malware using these functions, look for a subsequent comparison
    operation. This may be malware attempting to identify your analysis environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Abusing the Virtual Processor</samp>
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The virtual processors inside a VM may interpret and execute certain assembly
    instructions in a way that reveals the VM’s presence to malware. In this section,
    we’ll delve into how malware “abuses” these virtual processors by misusing instructions
    or exploiting their design flaws.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Red Pill and No
    Pill Techniques</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Red Pill and No Pill techniques are two well-known methods used by malware
    to detect virtual environments. Both techniques check processor data structures
    for VM-specific values. These techniques are often ineffective in modern analysis
    environments, so they’re seldom used in modern malware, but it’s still good to
    be aware of them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: For the Red Pill technique, malware executes the *Store Interrupt Descriptor
    Table*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sidt</samp>, assembly
    instruction, which writes the value of the Interrupt Descriptor Table register
    to memory, then checks it. The *Interrupt Descriptor Table (IDT)* is a data structure
    the processor uses to determine the correct response to exceptions and interrupts.
    (*Exceptions* signal to a processor that something is wrong with an instruction,
    and *interrupts* allow the processor to respond to a higher-priority event when
    required.) If the malware is running in a VM, the fifth byte of the IDT register
    will contain a specific value indicating that.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The Red Pill technique is simple to implement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">sidt [eax]</samp> instruction
    stores the contents of the IDT register, which is 6 bytes long, to a buffer. The
    code reads this value and executes a comparison operation to the fifth byte of
    the buffer, <samp class="SANS_TheSansMonoCd_W5Regular_11">[eax+5]</samp>. The
    fifth byte of the IDT register will be equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">FF</samp>
    (in hexadecimal) if it’s running in a VM.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The No Pill technique uses the *Store Local Descriptor Table*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sldt</samp>,
    instruction to store the *Local Descriptor Table* (*LDT*) register to memory.
    Since normal Windows applications don’t use the LDT, this LDT register should
    have a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. However,
    on some hypervisors, this LDT register value will contain a nonzero value, which
    can be a hint to the malware that it’s running in a VM. Similarly to the Red Pill
    technique, the No Pill technique doesn’t work correctly anymore in modern sandboxes
    and hypervisors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IO Ports</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An *input/output port (IO port)* is a communication method between the physical
    hardware of the machine and the software that’s running on it. Certain hypervisors
    use IO ports for host-to-guest OS communication. VMware, for example, uses the
    VMX IO port. Research from Cisco Talos revealed that malware can identify the
    VMX port to detect whether it is running in a VMware environment. The following
    assembly code shows what this might look like in practice:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This malware sample loads the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">VMXh</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register, then
    loads the magic value of <samp class="SANS_TheSansMonoCd_W5Regular_11">2EF36D4Ch</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> register. This
    magic value can be any hexadecimal value, and it doesn’t matter here. Next, the
    code loads the <samp class="SANS_TheSansMonoCd_W5Regular_11">dx</samp> register
    segment with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">VX</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">5658</samp> in hexadecimal, which
    is the VMX port number. Finally, the malware executes <samp class="SANS_TheSansMonoCd_W5Regular_11">in
    eax, dx</samp>, which uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    assembly instruction to attempt to access the IO port. If this host is running
    the VMware Workstation hypervisor, this instruction will return the magic number,
    which will likely trigger the malware sample to terminate itself or take other
    evasive actions. On a non-virtualized host, the returned value would be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: As with the Red Pill and No Pill techniques, this specific technique is quite
    old and has already been patched in modern versions of VMware. However, it’s important
    to understand this technique and others like it in case you’re analyzing malware
    that uses it or some variation of it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The cpuid Instruction</samp>
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> assembly instruction
    returns information about the host’s processors, such as the processor’s features
    and manufacturer. Outside of a VM, executing <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    with EAX set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> will return
    something like <samp class="SANS_TheSansMonoCd_W5Regular_11">Genuineintel</samp>
    for Intel processors or <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthenticAMD</samp>
    for AMD processors. When <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    is executed inside a VM, it often returns the name of the hypervisor. In the case
    of VMware, this string is <samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareVMware</samp>.
    For VirtualBox, the returned string is <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxVBoxVBox</samp>.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting EAX to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> prior
    to executing <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> returns
    much more information, stored as a 31-bit block in the ECX and EDX registers.
    The 31st bit in the ECX register will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    if the system’s CPU is physical or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    if the system is using a virtual CPU, indicating a VM environment. Here’s an excerpt
    of assembly code from a malware sample using this technique:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here the malware sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">inc
    eax</samp>), which will be used as a parameter for the <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    instruction following it. After <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>
    is executed, the malware executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">bt</samp>
    (*bit test*) instruction to move the 31st bit of <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp>
    into the *carry flag* register, which is a special CPU register that can store
    values of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    and is typically used during addition and subtraction operations. Finally, the
    sample checks the carry flag register (<samp class="SANS_TheSansMonoCd_W5Regular_11">jc</samp>),
    and if it’s set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the
    malware will conclude that it’s running in a VM and terminate itself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Wikipedia is a great reference for the processor information and feature bits
    returned from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">cpuid</samp>.
    See* [https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/CPUID<wbr>.](https://en.wikipedia.org/wiki/CPUID)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unsupported Instruction
    Sets</samp>
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware may use <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> to
    find out whether a specific instruction set is supported by the processor. For
    example, the 23rd bit within the EDX register specifies whether the processor
    supports the *SSE instruction set*, a set of uncommon assembly instructions that’s
    typically used for graphics processing and scientific computing. Some modern hypervisors
    support instruction sets like SSE, but not all do! This can be a dead giveaway
    for malware that it’s running in a VM or sandbox.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Some malware, instead of methodically looking through the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>,
    will simply try to execute these instructions, like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">movdqa</samp> (Move Aligned
    Double Quadword) instruction is used for moving data to and from *XMM registers*,
    which are those used in the SSE instruction set. In this code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">movdqa</samp>
    instruction moves the data referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp> register and
    again to the <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm1</samp> register.
    Then, it moves this data back from the <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm</samp>
    registers to <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>. If this
    code produces an error (or the malware crashes!), the malware sample may assume
    it’s being run in a virtualized environment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The SSE instruction set is just an example here, and most modern hypervisors
    support it. The important thing to remember is that any exotic or uncommon assembly
    instructions can be abused by malware for VM and sandbox detection if the hypervisor
    doesn’t support them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of an exotic instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">vpcext</samp>,
    which produces an error if executed outside of the Windows Virtual PC hypervisor.
    If executed inside Virtual PC, however, the instruction will succeed and set the
    EBX register to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The following
    code executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">vpcext</samp>
    instruction, followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    instruction to check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>
    is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Trap Flag and
    Other Techniques</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The trap flag is the eighth bit in the EFLAGS register in the Intel x86 instruction
    set. If it is enabled prior to another instruction call, an exception will be
    triggered. In a VM environment, the hypervisor emulates the trap flag behavior.
    Depending on the hypervisor in use, this emulation may not be correct or complete,
    which will cause the trap flag to be ignored and notify the malware that it’s
    running in a VM. This technique was first discovered in the wild in 2021 by researchers
    at Palo Alto’s Unit 42.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems that new VM detection methods like this trap flag technique are discovered
    every few years. Most of them have one thing in common: they abuse the way the
    CPU and its architecture were designed to function, causing the hypervisor to
    behave in unexpected or previously unknown ways and ultimately exposing the underlying
    VM. Malware analysts must keep up to date on these techniques to identify when
    malware is using them.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Risks of Using Detection Techniques</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen in this chapter and throughout the previous chapters, for malware
    authors there can be many benefits of implementing VM and analysis tool detection
    functionalities. So why might a malware author *not* include them? One reason
    is that these techniques can actually increase the chance of the malware being
    detected by anti-malware or an analyst. The more suspicious the Windows API functions
    or instructions the malware executes, the greater the chance that these behavioral
    anomalies will be noticed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Another risk is less obvious and, in my opinion, a bit comical. If malware detects
    that it’s running in a VM and subsequently chooses not to infect the host, this
    can be self-defeating in certain circumstances. Many organizations are switching
    to cloud and on-demand infrastructure, where many systems are in fact VMs. Malware
    that can detect VMs to evade malware analysts and sandboxes often is simultaneously
    evading the exact corporate systems it’s designed to infect.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: One real-world example is the well-known cybercrime malware Emotet, which featured
    several anti-analysis techniques, one of which was VM and sandbox detection. If
    it deemed the host a VM or sandbox, Emotet would either terminate itself, thus
    preventing infection, or behave differently from how it otherwise would on a real,
    physical system. This led to a lower Emotet infection rate than there would have
    been otherwise and likely saved some organizations running on virtualized infrastructure
    from major harm.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about several techniques that malware can use to
    establish context and detect malware analysis tooling, VMs, and sandboxes. Next,
    we’ll build on what we’ve discussed in this and the previous three chapters. Specifically,
    we’ll examine what malware does to evade and disrupt analysis efforts when it
    discovers it’s running in a virtualized environment or lab.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
