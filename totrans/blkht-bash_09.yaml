- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 9 PRIVILEGE ESCALATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn about the various ways that unintentional system
    misconfigurations and a lack of hardening could help you elevate your privileges
    on a compromised host. We’ll explore how the Linux operating system grants permissions,
    examine a system’s sudo and PATH configurations, automate the search for sensitive
    files, manipulate vulnerable cron jobs, attack system accounts, discover kernel
    exploits, and more.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Privilege Escalation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Privilege escalation* occurs when a low-privileged user is able to perform
    privileged operations that are outside the scope of the current user’s identity
    permissions by abusing misconfigurations, taking over other accounts, or exploiting
    other vulnerabilities. It’s an important stage in the compromise chain, because
    low-privileged accounts limit the actions you can take on a system. The following
    are examples of actions that an attacker might take but that are usually forbidden
    for nonroot users:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading system files that may contain sensitive information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating files and folders in privileged system locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating additional system users or modifying existing ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying or deleting sensitive files, such as logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing system-wide software packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the configuration of services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling, disabling, or restarting services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, if misconfigurations exist on a system, we might be able to perform
    these actions from low-privileged accounts. For example, we might be able to write
    to a directory if it has the wrong permissions set, or read a sensitive file if
    it were copied to a path that is accessible by all system users and happened to
    inherit the permissions of its new location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerous conditions can enable privilege escalation: configuration mistakes,
    a lack of system hardening, poor software design, assumptions about the environment,
    and so on. Here are technical and theoretical examples that could lead to privilege
    escalation conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Using vulnerable software packages or kernel versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting overly lax permissions on dangerous utilities or processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running applications by using privileged context, such as root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming that all users are to be trusted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing reused credentials in files accessible to all users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux File and Directory Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every file and directory has a configuration made up of read (r), write (w),
    and execute (x) permissions. In addition, every file and directory is owned by
    a user and a group. As you learned in the previous chapter, Linux defines users
    in */etc/passwd* and groups in */etc/group*. Administrators grant permissions
    to a particular user, a particular group, and anyone else (also called *others*).
  prefs: []
  type: TYPE_NORMAL
- en: File and directory permissions and ownership can be changed accidentally or
    *made loose* because of a misconfiguration, meaning these resources have the potential
    to be exposed to unauthorized users. It is important to spot these misconfigurations
    when performing penetration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s examine the permission and ownership assignments of the */etc/passwd*
    file as an example. We’ll walk through the bolded part of the output, from left
    to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first character represents the type of resource. A hyphen (-) indicates
    a file, while the d character would represent a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Next, rw- represents the file’s owner permissions. In this case, the permissions
    are set to read (r) and write (w). The last hyphen is a placeholder for the execute
    (x) permission, which isn’t set here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of permissions (r--) belongs to the group and indicates read access
    only. Other users also have only read access. The two instances of root represent
    the identity of the file’s owner and group: the *root* user and the root group.
    [Figure 9-1](chapter9.xhtml#fig9-1) illustrates this permission breakdown in a
    digestible way.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: Basic file permissions'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, these permissions mean that all local accounts can read the file
    but that only the *root* user can modify it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We set Linux file and directory permissions by using the chmod command, and
    set file and directory ownership by using the chown command. To see these commands
    in action, create an empty file named *my_new_file.txt* on your Kali machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set this file’s user and group to *kali*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now set read, write, and execute permissions for the user (u+rwx), read permissions
    for the group (g+r), and read permissions for everyone else (o+r):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also represent file and directory permissions (but not ownership) by
    using *octal representation*, which uses the digits 0 through 7\. We set one digit
    for the user, one for the group, and one for others, producing a value such as
    777, 700, or 440. The permissions correspond to the following octal values:'
  prefs: []
  type: TYPE_NORMAL
- en: The read (r) permission is 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The write (w) permission is 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execute (x) permission is 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The no permission value is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To grant read, write, and execute permissions to everyone (that is, the user
    owner, the group, and anyone else), we’d add the three permission numbers. Read
    (4), write (2), and execute (1) added together equal 7. This means that if you
    set the permission 777, everyone would get read, write, and execute permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to grant only the user read access but deny access to the group
    and everyone else? Here is an example of how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use the octal value of 400, as 4 grants read access to the user and the two
    0 values set zero permissions for the group and everyone else.
  prefs: []
  type: TYPE_NORMAL
- en: Creating File Access Control Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve covered the fundamentals of file and directory permissions and ownership,
    but a few other security mechanisms could also grant or prevent user access.
  prefs: []
  type: TYPE_NORMAL
- en: '*File access control lists (ACLs)* allow you to set additional permissions
    on files and directories at a more granular level. For example, say we have a
    group called *sysadmins* with a few members, such as Alice, Bob, and Eve, and
    we need to grant access to Alice and Bob, but not Eve. Setting the sysadmins group
    on a file or directory would instead grant all members access. ACLs allow us to
    grant or deny access to specific users on top of the existing permission scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example assumes you have a group named *sysadmins* and system users
    named Alice, Bob, and Eve. You can use the following commands to create these
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s create a new empty file and observe its default ACLs. We use the
    getfacl command to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll grant read access to the *sysadmins* group to ensure that Alice and
    Bob, who are members, can access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We pass the modify (-m) flag to setfacl so it modifies permissions, followed
    by the group name, the desired permissions (g:sysadmins:r--), and the target file
    or directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, all members of the group can read the file. How do we now exclude
    a particular user? Run the following command to remove all permissions for Eve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing the ACL permissions again should show that Eve has no access to the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When a file or directory has ACLs set, Linux will show a plus sign (+) when
    you view the file’s permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to be aware that this security control is available.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing SetUID and SetGID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Set User ID (SetUID)* is a special permission that can be set on executable
    files. It allows the executable to run with the permission of the user who owns
    the executable. For example, imagine that a script allows users on the system
    to delete logfiles from the */var/log* path. To do this without granting root
    privileges to users, a sysadmin can set the SetUID bit on the executable file.
    Likewise, the *Set Group ID (SetGID)* permission allows users to run executable
    files with the permissions of the owning group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an executable file has SetUID or SetGID set, you’ll see s instead of x
    in the file’s permissions. One file that uses both SetUID and SetGID is the At
    scheduler binary */usr/bin/at*, which we used in [Chapter 8](chapter8.xhtml) for
    task scheduling when we used the at command. Run the following command to see
    SetUID and SetGID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that SetUID is set, as indicated by the first s in the permissions,
    followed by SetGID, as indicated by the second s. Thus, when users run the at
    command, they run it with the permissions of the *daemon* user and group.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a command that uses the SetUID set to its executable is passwd,
    which changes account passwords. Executables set with SetUID and SetGID can be
    a security risk and are a prime target for privilege escalation. We will demonstrate
    an exploitation example in “Exploiting a SetUID Misconfiguration” on [page 208](#pg_208).
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Sticky Bit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the *sticky bit* is set on a directory, files under that directory can’t
    be deleted by users or groups who don’t own the files, even if the file’s permissions
    would otherwise allow the deletion. A good example of a directory with the sticky
    bit set is */tmp*. Run the following command to see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The t means the sticky bit is set on this directory. To set a sticky bit on
    a directory, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set the SetUID, SetGID, or sticky bit via the octal representation
    by prepending an additional digit before the permission: the sticky bit is 1,
    SetGID is 2, and SetUID is 4. To demonstrate this, let’s copy a binary from the
    system and change its permissions. Copy the *ping* binary into the */tmp* directory
    and name it *ping.backup*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set the file with the octal permission notation of 4700:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This sets SetUID (4), followed by read, write, and execute permissions for the
    user-owner only (700).
  prefs: []
  type: TYPE_NORMAL
- en: Finding Files Based on Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 8](chapter8.xhtml) covered the FHS, which aims to standardize the
    locations of certain files and directories on Linux systems. But files, whether
    they’re configurations or the source code of an application, could live pretty
    much anywhere, so it’s important to figure out what is accessible to our current
    privilege context.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, searching for readable, writable, and executable files and directories
    is quite easy. Tools such as find can even locate files based on permissions.
    Let’s explore how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search for files and directories that are readable by everyone on a system
    (meaning *others*), beginning from the root directory and searching recursively,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To search for files only, pass the -type f flag, and to search directories
    only, pass the -type d flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To suppress any access-denied errors while searching, pipe the standard error
    stream to */dev/null*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To search for files and directories that anyone can write to, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A search for executable files and directories follows the same pattern. To
    search for files and directories that are executable by everyone, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The term *executable directories* may sound confusing, but essentially, setting
    an executable permission (x) on a folder allows users to navigate into the directory
    (for example, with cd).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine these commands into one, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This command finds all globally readable, writable, and executable files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The find command also allows us to search for particular permissions by using
    the -perm flag. We could use this to search for files set with either SetUID or
    SetGID. The following searches for SetGID files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, this command searches for SetUID files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also locate directories set with the sticky bit flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Searching for these special permissions will likely yield results on most Linux
    systems, as some files have these permissions set by default. It’s important to
    become familiar with these files so you can easily distinguish between default
    system files and ones that were modified by the system owner.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting a SetUID Misconfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s exploit a program with the SetUID bit set. On the compromised machines,
    run a system-wide search for SetUID and SetGID files, then perform an internet
    search to figure out which of these files are meant to have these flags set and
    which are misconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: Your search should identify *ELinks*, a web browser that allows users to surf
    websites directly from the command line by displaying results as simple text output.
    [Figure 9-2](chapter9.xhtml#fig9-2) shows what browsing Google looks like when
    using ELinks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg209.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: Browsing Google with the ELinks command line web browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the backup user account of *p-jumpbox-01* (172.16.10.13), you should find
    the ELinks binary located at */usr/bin/elinks.* To verify that the SetUID is set,
    use the ls or the stat command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'ELinks will execute in the *root* context when we run it, so if we’re able
    to get it to do something interesting, like read a local file, we should be able
    to access sensitive files available only to *root*. Explore the ELinks options
    by passing the --help flag to the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the -dump 1 flag to read a website address and print it to the standard
    output stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ELinks should parse data from the website, such as a collection of links, and
    print it to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'How might we exploit this behavior? Well, just as the *http://* or *https://*
    schemes allow us to read data from websites, the *file:///* scheme allows web
    browsers to read files on the local system. Since we’re running as root, we can
    read sensitive paths such as */etc/shadow*, which stores password hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to note that while we abused ELinks, we didn’t exploit a vulnerability
    in ELinks itself; rather, we used a well-known browser feature for malicious purposes
    with the help of the SetUID bit.
  prefs: []
  type: TYPE_NORMAL
- en: Scavenging for Credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we cover places on the system where you might find sensitive
    files containing credentials. Even encrypted credentials could be weak and brute-forceable,
    and you might find them used across multiple servers. Privilege escalation doesn’t
    always involve a highly sophisticated exploit; if you discover credentials lying
    around on disk, you might be able to simply log in to a more powerful account.
  prefs: []
  type: TYPE_NORMAL
- en: Passwords and Secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Passwords and secrets, such as API keys, can live in many places on a system.
    Administrators might run commands that contain their usernames and passwords,
    applications may log credentials in logfiles, and configuration files may contain
    credentials as part of a connection string. Search for credentials in places such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files under the */etc* directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logfiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History files of users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduled tasks, such as cron jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script files written in languages such as bash or Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boot configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System files such as */etc/shadow*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple approaches to uncovering such secrets. We could use bash
    to recursively search for password patterns, craft searches for specific files
    and extensions of interest, or manually inspect sensitive filesystem areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the search techniques introduced in “Finding Files Based on Permissions”
    on [page 207](#pg_207) to look for specific filenames of interest. For example,
    search for readable files with the word *password* in them by using a case-insensitive
    grep filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then search for readable files that contain words such as *api_key*, *token*,
    and *key*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also search for readable files with specific extensions like *.hashes*,
    *.env*, and *.credentials*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Searching for hardcoded credentials without running into false positives is
    an art, but you could use data gleaned from the reconnaissance phase or external
    resources to build more fine-tuned search patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such resource is Nuclei’s inventory of templates for finding interesting
    data (such as passwords, API tokens, and cloud account IDs) in local files: *[https://github.com/projectdiscovery/nuclei-templates/tree/main/file/keys](https://github.com/projectdiscovery/nuclei-templates/tree/main/file/keys)*.
    For instance, the *github-oauth-token.yaml* template searches for the GitHub Open
    Authentication (OAuth) tokens used to log in to GitHub accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This template looks for strings that start with the character sequence gho_
    and are followed by a string of 32 characters. If you don’t want to use Nuclei,
    you could input this regular expression into a grep search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We use grep -E to specify a regular-expression-based filter. Alternatively,
    you could use egrep, a wrapper to the grep command that passes the -E flag under
    the hood, for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also pass the -R flag to perform a recursive search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is useful for searching a directory that has many files, such as a web
    application’s source code directory.
  prefs: []
  type: TYPE_NORMAL
- en: Private Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Private keys are a huge asset to penetration testers. We can use them to connect
    to servers, decrypt files, perform man-in-the-middle attacks, and more. You might
    find private keys in restricted folders, such as */root*, or in an individual
    user’s home directory, depending on its type and owner.
  prefs: []
  type: TYPE_NORMAL
- en: SSH Keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unless modified, SSH private keys are usually named *id_rsa*, after the RSA
    cryptosystem, or *id_dsa*, after the Digital Signature Algorithm (DSA) cryptosystem,
    without an extension. Their corresponding public key is usually either *id_rsa.pub*
    or *id_dsa.pub*. You’ll typically find SSH keys under the hidden directory *.ssh*
    for each user account. For example, the user Eve’s SSH keys would be stored at
    */home/eve/.ssh/id_rsa* and */home/eve/.ssh/id_rsa.pub* if generated using RSA.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH private keys have a well-defined file structure, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The keys use *Privacy-Enhanced Mail (PEM)*, a common format to store and transfer
    cryptographic keys. PEM starts with a header (BEGIN), followed by the key data
    and a footer (END). Here are common headers you may see in the wild:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Recursively searching for these strings in files is fairly easy. For example,
    take a look at this grep command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The -R option searches recursively, and the double dash (--) prior to the search
    pattern "-----BEGIN" signifies the end of the arguments. This allows us to easily
    search for strings that contain dashes, such as the ones in PEM headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also try to search for keys of the following types: ecdsa, ecdsa-sk,
    ed25519, and ed25519-sk. Changing the key type will change the names of the generated
    keys. For rcdsa, the keys are named *id_ecdsa* and *id_ecdsa.pub*, whereas for
    ed25519, they’re named *id_ed25519* and *id_ed25519.pub*.'
  prefs: []
  type: TYPE_NORMAL
- en: Also look for *SSH host keys*, the cryptographic keys that validate a server’s
    identity. When an SSH client connects to an SSH server, the client checks the
    server’s identity by using the public host key, which is stored in the client’s
    *known_hosts* file. If this public key has changed, the SSH client generates an
    alert saying it can’t verify the host.
  prefs: []
  type: TYPE_NORMAL
- en: Public and private SSH host keys are usually stored under the */etc/ssh* directory
    and may have names such as *ssh_host_ecdsa_key*, *ssh_host_rsa_key*, *ssh_host_ed25519_key*,
    *ssh_host_ecdsa_key.pub*, *ssh_host_rsa_key.pub*, or *ssh_host_ed25519_key.pub*.
  prefs: []
  type: TYPE_NORMAL
- en: These keys are usually generated automatically when the server is provisioned,
    though it’s also possible to manually generate them. Compromising SSH host keys
    could allow you to impersonate a server on a network.
  prefs: []
  type: TYPE_NORMAL
- en: PGP Keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Pretty Good Privacy (PGP)* is an encryption scheme used to encrypt files,
    emails, and more. Like SSH keys, PGP private keys use the PEM format. They look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*GNU Privacy Guard (GnuPG)* is an implementation of OpenPGP (defined in RFC
    4880) that provides command line utilities for managing PGP keys. It lets you
    generate keys, import and export keys, verify signatures, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: You can generate a GnuPG key by using the gpg tool and running the gpg --generate-key
    command. When a user generates keys with GnuPG, it stores the keys in a keyring
    that is usually located in a hidden dot directory named *.gnupg* under the user’s
    home directory. (Users can change the keyring’s location by setting the environment
    variable GNUPGHOME to a different directory location.)
  prefs: []
  type: TYPE_NORMAL
- en: Within this directory, the*~/.gnupg/private-keys-v1.d/* folder contains private
    keys, the *~/.gnupg/trustdb.gpg* file contains the GnuPG trust database, and the
    *~/.gnupg/pubring.kbx* file contains metadata. Therefore, you first need to have
    access to an account before being able to list the account’s keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s export PGP keys from one of the lab’s machines. On *p-web-01* (172.16.10.10),
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output any PGP keys accessible to the user, including keys that
    appear to belong to a server account, *arodriguez@acme-infinity-servers.com*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to steal this private key, we could export it to a file in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The --output private.pgp argument writes the content to a file, --armor outputs
    the key in ASCII format, and --export-secret-key arodriguez@acme-infinity-servers.com
    specifies the key to export based on an email address.
  prefs: []
  type: TYPE_NORMAL
- en: In certain cases, however, this export may fail. This is because GnuPG keys
    can be protected if the creator used a passphrase during the key generation, and
    you’ll need to supply the passphrase to perform the export. In Exercise 16, we’ll
    cover a way to bypass this protection by using bash.
  prefs: []
  type: TYPE_NORMAL
- en: Certificates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the post-compromise stage of a penetration test, you may sometimes encounter
    a server that transmits data over encrypted channels. For example, a web server
    might send HTTP data over SSL to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Popular web servers such as Apache or nginx commonly store certificates in */etc/ssl/certs*
    and private keys in */etc/ssl/private*. Certificates usually have the *.crt* extension,
    while private keys have the *.key* or *.pem* extensions. Those PEM files could
    contain just the public key, or they could store the entire certificate chain
    (including the private key, the public key, and root certificates).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have access to an Apache or nginx configuration file, the configuration
    keys listed therein usually point to the location of the certificate and its private
    key. We’ve bolded these keys in the following nginx configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'These keys look like the following in the Apache configuration for an HTTPS-enabled
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You could perform a system-wide search for nginx or Apache configuration files,
    then cross-examine the location of the keys to see whether they’re accessible
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proxies can also be configured to use SSL. Here is an example configuration
    file for HAProxy, with the location of the PEM file shown in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'HAProxy, which performs load balancing, may define a few backend servers, each
    with its own certificate files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can identify these files based on the *ca-file* parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16: Brute-Forcing GnuPG Key Passphrases'
  prefs: []
  type: TYPE_NORMAL
- en: When passphrase protection exists on a GnuPG key, you won’t be able to export
    the key without providing the passphrase. No sweat, though; there is a bash-y
    way to brute-force the passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-1](chapter9.xhtml#Lis9-1) operates on a file named *passphrases.txt*
    containing a bunch of possible passphrases. It assumes the GnuPG key’s ID is the
    email *identity@blackhatbash.com*.'
  prefs: []
  type: TYPE_NORMAL
- en: gnupg_passphrase_bf.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: Brute-forcing protected GnuPG private keys'
  prefs: []
  type: TYPE_NORMAL
- en: In this script, we define a variable named KEY_ID to specify the key ID we want
    to brute-force ❶. At ❷, we list the keys available and grep for the key ID we’ll
    be brute-forcing to ensure it exists. Then we iterate over the *passphrase.txt*
    file line by line by using a while loop, echo the passphrase ❸, and pass it as
    input to the gpg command.
  prefs: []
  type: TYPE_NORMAL
- en: This command takes a bunch of important parameters that allow us to brute-force
    the passphrase in an automated fashion. The --batch --yes flag allows the pgp
    command to execute while unattended, --pinentry-mode loopback allows us to fake
    a pin entry, --passphrase-fd 0 makes pgp read the passphrase from file descriptor
    zero (the standard input stream), --output writes the output to a file of our
    choice, --armor formats the exported key by using ASCII, and --export-secret-key
    is the key identifier to export.
  prefs: []
  type: TYPE_NORMAL
- en: If the pgp command returns an exit code of zero, either the passphrase worked
    or no passphrase was set to begin with, at which point we exit.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can find this chapter’s scripts at* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch09](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch09).'
  prefs: []
  type: TYPE_NORMAL
- en: To take this exploitation further and practice your bash scripting, improve
    the script so it can iterate through all available key identities and brute-force
    them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the sudo Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sudo Linux command elevates a user’s permissions to root without granting
    that user direct access to the root account. Imagine that you’re the administrator
    of a server and want to give another user the ability to add new firewall rules.
    While you could just hand them the root account password, doing so could lead
    to a compromise. With sudo, you could grant permissions to run, say, the iptables
    command or a tool like tcpdump without revealing the root account’s password.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an attacker’s perspective, the sudo configuration is worth exploring,
    as a misconfiguration could grant you access to sensitive resources. On your Kali
    machine, the built-in *kali* user has sudo access by default. You can test it
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should then prompt you to enter your login password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The -l flag lists the current user’s sudo privileges. As you can see, the user
    has (ALL : ALL) ALL, which basically means unlimited privileged access.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sudo command can grant granular permissions thanks to its configuration
    file */etc/sudoers*. Here are a few permission grants you could achieve with advanced
    sudo configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Granting sudo permissions to a particular user or group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting sudo permissions to a particular user or group for a particular system
    command only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting sudo permissions to a particular user or group for a particular script
    only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting sudo permission to run a command without requiring the user to enter
    their password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To supplement */etc/sudoers*, the */etc/sudoers.d* directory can store independent
    sudo configuration files. The main */etc/sudoers* file can import files from this
    directory by using the @includedir instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that */etc/sudoers* can be modified only by privileged users and
    is readable only by the *root* user and root group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you’re able to write to this file or into the directory */etc/sudoers.d*,
    you should be able to grant yourself root access; by default, however, you aren’t
    able to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kali, any member of the *kali-trusted* group is granted sudo access without
    requiring a password, as defined in the */etc/sudoers.d/kali-grant-root* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Since the *kali* user is not part of the *kali-trusted* group, this user has
    sudo privileges but is required to supply a password whenever it’s used.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the *kali* user is part of the *sudo* group, referenced in */etc/sudoers*.
    Users who are members of this group are automatically granted unlimited sudo access,
    as defined by this configuration line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the list of groups the *kali* user is a member of, run the groups command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few examples of sudo configurations that could lead to privilege
    escalation scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The system could grant you sudo permissions on dangerous commands, including
    shell commands that could land you in a root shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system could configure sudo on a script that is writable by all users on
    a system, allowing unauthorized users to add malicious commands that would get
    executed with the root context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups containing a large number of users could be granted sudo, expanding the
    attack surface and adding more ways to gain sudo access (as you could attempt
    to exploit each of the sudo group members).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section should help you understand the dangers of granting sudo access.
  prefs: []
  type: TYPE_NORMAL
- en: Abusing Text Editor Tricks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s walk through an attack that relies on sudo access. As the backup user
    on *p-jumpbox-01* (176.16.10.13), run the sudo -l command and provide the password
    (*backup*) when prompted. Then view the sudo configuration for this user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It looks like we’ve been granted sudo access on vi, a text editor. Granting
    sudo permissions on a text editor may seem innocent, but it’s not.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we could pass a file to the vi command to tell it to write to
    that file. When granted sudo access, we can write to any file we’d like or create
    new files in system locations that are accessible or writable to the *root* user
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a file to a system location that regular users aren’t allowed to
    access under normal circumstances. Enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: A text editor prompt should appear. Press the I key on the keyboard, then enter
    anything you like. When done, press ESC, followed by SHIFT-:. Enter wq! and press
    ENTER to save the file and quit. You’ll notice that we are able to write the file
    to the */etc* directory, which is writable by privileged users only. Similarly,
    we could edit any file on the system, such as */etc/passwd* and */etc/shadow*,
    or even insert a backdoor to an application directly.
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of this access, try dropping yourself into a root shell. vi
    allows the execution of bash commands from within the text editor’s window. This
    feature is convenient when you’re programming and need to execute shell commands
    to see the output or to view files outside the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter sudo vi in the terminal, then press SHIFT-: and enter !bash. You should
    now be in a root shell! Enter the whoami command to confirm you’re the root user.
    At this point, you should set the root account’s password by using the passwd
    command (without any additional parameters) so that you can easily log in to it
    at any point.'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Malicious sudoers Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, you may have noticed that we also have sudo access
    to curl, used to read resources from web servers. You may be asking yourself,
    What could we possibly do with sudo access to a command line–based HTTP client?
    Well, quite a bit!
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the curl manual page, you’ll see it provides an -o (output) flag
    for writing content into files or directories. This means you can download files
    with curl by making a GET request to a website and redirect the output to a file
    by using the -o flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exploit this behavior, we could set up a remote web server that serves a
    configuration file; if we can download this file in a way that overwrites an existing
    file, we could elevate our permissions or gain new access. Let’s exploit *p-jumpbox-01*
    (176.16.10.13) once again to elevate from the backup user to the *root* user.
    Here are a few directions we could take:'
  prefs: []
  type: TYPE_NORMAL
- en: Serving modified versions of */etc/passwd* and */etc/shadow* files that would
    change the password of the *root* user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving a modified version of */etc/sudoers* so it grants sudo permissions to
    the backup user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a new sudo configuration into the */etc/sudoers.d* directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving a cron-job shell script that runs in the context of the system (as root)
    and is tasked with taking privileged actions on our behalf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll take the third option: serving a custom *sudoers* file from the Kali
    machine and inserting it into the target’s */etc/sudoers.d* directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, grab the new sudo configuration file, *add-sudo-to-user*, from the book’s
    GitHub repository and place it somewhere on your filesystem, such as the Kali
    home directory. Next, open a terminal and navigate to the directory where the
    downloaded file is located. Then run the following command to start a web server
    on port 8080:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, as the *p-jumpbox-01* backup user, run the following command to download
    the file from Kali. Kali’s lab IP address should be 172.16.10.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This curl command uses the -s flag (silent) to suppress output such as the download
    progress bar. We then make a GET request to the Kali machine to grab *add-sudo-to-user*.
    The -o (output) flag points to a filesystem destination where the output of the
    GET request will be saved. In this case, we use the */etc/sudoers.d* directory.
    Confirm that the file was successfully pulled by using ls to list the files in
    */etc/sudoers.d*. Then run the sudo -l command to see that you now have full sudo
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that manually modifying the *sudoers* file is quite dangerous.
    Any errors you make could impact your ability to regain sudo access in the future,
    so we highly recommend using a dedicated sudo modification tool like visudo to
    modify sudo configurations. This tool catches syntax errors early so you don’t
    get locked out.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully compromising the root account, we recommend setting the account’s
    password to *passwd* so you can easily switch to the account later.
  prefs: []
  type: TYPE_NORMAL
- en: Hijacking Executables via PATH Misconfigurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PATH environment variable is a colon-separated list of directories in which
    the shell searches for executables by default. For example, when you enter the
    touch command to create a file, the shell searches the PATH to locate the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command on any compromised machine to see its current PATH
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To attempt privilege escalation, we could modify the PATH variable to include
    additional paths. For example, say a system has a dedicated custom script directory
    at */data/scripts*. Modifying the PATH directory to include this script directory
    is quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can append paths to PATH, as in the previous example, but also prepend them.
    In the following example, we prepend the current working directory (.) to the
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, if an executable runs as root and calls an external command as part of
    its logic, it might execute the attacker-controlled file instead of the intended
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s use PATH hijacking to run a custom executable. We’ll target
    the following program written in C, which calls the whoami command. Let’s see
    if we can make it run a different binary of our choosing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: At ❶, the code uses the command system("whoami") to call the whoami command,
    and at ❷, it calls the *whoami* binary directly by using its absolute path, */usr/bin/whoami*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy this code into a new file named *getuser.c* on any of the compromised
    machines. You can also download the file directly from the book’s GitHub repository.
    Next, compile this program and make it executable by using the GNU Compiler Collection
    (GCC):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create a new binary named *getuser*. Let’s set the executable permissions
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set the PATH such that the current directory is prepended to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this output, you can see that the */tmp* directory was prepended to the PATH.
    This is because we were in the */tmp* directory when we executed this command;
    your value might look different if you navigated to a different directory. Make
    sure that the *getuser* binary is located in whatever directory you prepended
    to the PATH.
  prefs: []
  type: TYPE_NORMAL
- en: Since we control one of the directories in the PATH, we can create a fake *whoami*
    script in that path ([Listing 9-2](chapter9.xhtml#Lis9-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: Forging a whoami executable'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *getuser* program will look for the whoami command in the PATH, and since
    */tmp* will be read first, it should pick up the fake program. Run *getuser* to
    see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the program executed the fake *whoami* script. Note, however,
    that the program’s second call to whoami executed the correct command because
    it specified the file’s full path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17: Maliciously Modifying a Cron Job'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](chapter8.xhtml) covered scheduled tasks, including where they typically
    reside on a filesystem and how to execute them. Scheduled tasks generally run
    a custom script designed to perform a desired action, and this script might reference
    other local files for information. Also, the script might run with elevated privileges.
    So, they’re an interesting avenue to explore when looking for privilege escalation
    vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On *p-jumpbox-01* (172.16.10.13), take a look at the contents of the */etc/
    crontab* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the command bash /scripts/backup_data.sh runs every five minutes,
    using the *root* user. Let’s check whether this script is accessible to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It is, so let’s take a look at the script’s contents, shown in [Listing 9-3](chapter9.xhtml#Lis9-3).
    Does anything stand out to you?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: A data backup script'
  prefs: []
  type: TYPE_NORMAL
- en: The script first sets the CURRENT_DATE variable with today’s date ❶. Then a
    for loop iterates over the */tmp* and */data* directories ❷ and tests whether
    the file *extra_cmds.sh* exists in each directory ❸. If the script finds the file,
    the source command copies the *extra_cmds.sh* script ❹ into the currently executing
    script, which runs all its instructions in the same shell. Next, a tar command
    compresses the contents of */data/backup* into a single *tar.gz* file under */data*
    ❺. The script then removes any contents left in */data/backup*.
  prefs: []
  type: TYPE_NORMAL
- en: This script contains a vulnerability; it doesn’t take into consideration that
    */tmp* is a world-accessible directory. If the *extra_cmds.sh* file doesn’t exist,
    someone could potentially create one, then introduce additional instructions for
    the cron job to execute. In addition, the */data* directory is also world-writable
    because of what seems to be a misconfiguration. Run the stat (or ls) command on
    */data* to see the permissions set.
  prefs: []
  type: TYPE_NORMAL
- en: To test this vulnerability, write content to the *extra_cmd.sh* file. [Listing
    9-4](chapter9.xhtml#Lis9-4) provides a simple proof of concept.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: A proof-of-concept script to exploit the vulnerable cron job'
  prefs: []
  type: TYPE_NORMAL
- en: 'An execution of this script by Cron will result in a new file named *proof-of-concept*
    under */tmp* with the content The running user is: followed by the output of the
    whoami command, which in this case should be root.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this file and use chmod to set the executable permissions on it, then
    wait five minutes to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Vulnerabilities in shell scripts aren’t rare, because they’re often written
    with the assumption that the operating environment does not have malicious users
    potentially looking for ways to exploit it. Tools called *linters*, such as ShellCheck
    (*[https://www.shellcheck.net](https://www.shellcheck.net)*), help enforce best
    practices when writing shell scripts. ShellCheck also highlights potential code
    areas that may cause security risks due to code errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further exploit this flaw, consider writing a new *extra_cmd.sh* that takes
    any of the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify a sudo configuration to grant a user of your choice permission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the permissions to a directory of interest, such as a log directory,
    so that your low-privileged user has access to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy files from other users’ home directories to a directory readable to your
    user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding Kernel Exploits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When discovered, high-profile kernel-level vulnerabilities tend to get the security
    industry excited and panicked at the same time. While they’re often disclosed
    responsibly through security disclosure channels, we sometimes learn about them
    only when threat actors attempt to gain privileged access by using a zero day.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*These exploits could crash the kernel, so unless you have explicit permission
    from a client, you’ll want to avoid using them during penetration tests.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel exploits target specific kernel versions, CPU architectures (such as
    x86_64 or ARM), or operating systems, so to use one, you’ll first need to analyze
    the system to determine the kernel version that’s running. On your Kali machine,
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You can find kernel exploits in databases such as *[https://exploit-db.com](https://exploit-db.com)*
    by searching for the specific kernel version of interest. While this can be a
    manual process, automated tools aim to make this search faster and more accurate
    by matching the kernel’s version to a list of CVEs.
  prefs: []
  type: TYPE_NORMAL
- en: SearchSploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*SearchsSploit* is a command line utility built into Kali that interfaces with
    Exploit-DB, allowing you to perform searches from the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command performs a search for Linux kernel exploits for the *Dirty
    COW vulnerability* (CVE-2016-5195), a race condition vulnerability that impacted
    kernel versions before 4.8.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Other tools aim to automate the kernel exploit search by locally analyzing a
    system and matching the kernel version with a database of vulnerable kernels and
    exploits. One such tool is Linux Exploit Suggester 2.
  prefs: []
  type: TYPE_NORMAL
- en: Linux Exploit Suggester 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Linux Exploit Suggester 2* is a Perl script that runs locally on a system.
    It attempts to find exploits that match the currently running kernel version.
    To give it a try, run the following command against your Kali machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the exploit suggester script contains a database of more than
    70 kernel exploits as of this writing. Some examples include a vulnerability in
    OverlayFS (CVE-2015-8660) and a vulnerability in eBPF (CVE-2017-16695).
  prefs: []
  type: TYPE_NORMAL
- en: Attacking Adjacent Accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you land on a compromised host as a nonroot user, you may want to try to
    escalate your privileges by attacking other system accounts. You may even be able
    to gain root access by compromising a nonroot account that happens to have certain
    privileges, such as unrestricted sudo privileges or a certain file in the home
    directory containing credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can attempt to brute-force system accounts by using bash. First, let’s identify
    accounts that have an active shell by performing a grep search for */bin/bash*
    (though remember that there could be other shells as well). Execute the following
    command against *p-jumpbox-01* (172.16.10.13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: For the purpose of this example, we’ll attack the account *jmartinez*. [Listing
    9-5](chapter9.xhtml#Lis9-5) attempts to brute-force the password for that account.
  prefs: []
  type: TYPE_NORMAL
- en: local_account _bf.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: Brute-forcing adjacent accounts'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this script, we set two variables: USER, with the account name to attack
    ❶, and PASSWORD_FILE, a file that will contain a passwords list ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we read the content of PASSWORD_FILE by using a while loop ❸, iterating
    through each password that exists. We echo each password to the standard output
    stream and pipe it to the su command. Then we use su - ${USER} -c 'whoami' to
    attempt to switch to the user and execute the whoami command upon success.
  prefs: []
  type: TYPE_NORMAL
- en: If the whoami command returns the username we’re brute-forcing in the output
    (*jmartinez* in this case), it means we were able to successfully guess the password
    and execute a command as the user. We check that it returned this string by using
    grep -q "${USER}".
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test it. Download and save the script on the *p-jumpbox-01* machine by
    using the methods you’ve learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, write a few passwords to the *passwords.txt* file. Make sure this file
    exists in the same directory as the *local_account_bf.sh* script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the script and observe its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The password was found to be *password123*! Try switching to the user and providing
    the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you should be able to see that this user has sudo access everywhere by
    running sudo -l:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us access to the root account. To confirm we are able to switch
    to the root user, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You successfully compromised this machine.
  prefs: []
  type: TYPE_NORMAL
- en: Privilege Escalation with GTFOBins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use commonly available utilities on Linux-based machines for a variety
    of nefarious purposes. The GTFOBins project (*[https://gtfobins.github.io](https://gtfobins.github.io)*)
    highlights many of these utilities, and in particular, what an attacker can do
    with them if they have permissions such as SetUID or sudo set. As you can see
    in [Figure 9-3](chapter9.xhtml#fig9-3), some utilities allow arbitrary file reads
    and writes, file downloads and uploads, reverse shells, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg228.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: The GTFOBins home page'
  prefs: []
  type: TYPE_NORMAL
- en: When you inspect the filesystem for sudo access or SetUID permissions set on
    particular utilities or binaries, we highly recommend that you search the GTFOBins
    database to learn about possible attack opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18: Mapping GTFOBins Exploits to Local Binaries'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you automate your search of the GTFOBins repository? In this exercise,
    you’ll use bash to map the list of available utilities on a target system to those
    in the GTFOBins database. The GTFOBins project is hosted on GitHub, where each
    binary has its own Markdown documentation file (with the *.md* extension), so
    you’ll need your script to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Perform a search for system and user binaries (in directories such as */bin*,
    */usr/bin*, and */usr/sbin*). For the purpose of this exercise, the search should
    look for SetUID files.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Use filtering commands to extract only the filenames, without their paths.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Perform an HTTP GET request against the GTFOBins database to search for
    the correct documentation file, using the filename.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Print the results to the console or to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your script should be able to output all exploitation methods for the binaries
    it found on the system with matches in the database. You can view an example GTFOBins
    page for the wget binary here: *[https://raw.githubusercontent.com/GTFOBins/GTFOBins.github.io/master/_gtfobins/wget.md](https://raw.githubusercontent.com/GTFOBins/GTFOBins.github.io/master/_gtfobins/wget.md)*.'
  prefs: []
  type: TYPE_NORMAL
- en: If you get stuck, take a look at the example solution, *gtfobins_search.sh*,
    in the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Privilege Escalation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, privilege escalation requires both time and craft.
    Luckily, there are scripts that aim to automate the tedious task of sifting through
    system directories to find misconfigurations or unhardened components.
  prefs: []
  type: TYPE_NORMAL
- en: LinEnum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We ran LinEnum for information gathering in [Chapter 8](chapter8.xhtml). If
    you use the -t (thorough) flag to run a check, it should return details that could
    help you escalate your privileges, such as files that belong to the current user,
    hidden (dot) files, private keys, and Git credential files.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the script’s output can be verbose, because it prints every finding. The
    -k (keyword) option performs a system-wide search for a keyword of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This command searches for the string P@ssw0rd in files accessible to the current
    user.
  prefs: []
  type: TYPE_NORMAL
- en: unix-privesc-check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Albeit a little older, *unix-privesc-check* is another self-contained shell
    script that can search a system for local misconfigurations. Copy the *unix-privesc
    -check* script from your Kali machine (the file should be under */home/kali/tools/unix-privesc-check*
    or */usr/bin/unix-privesc-check*) to any of the compromised hosts, then run a
    scan using the standard option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard option is optimized for speed and will quickly enumerate misconfigurations
    on the system, but it provides less comprehensive enumeration coverage. The detailed
    option is more likely to catch misconfigurations in third-party software found
    on a host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to that of LinEnum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: There are a few other privilege escalation automation tools you should be familiar
    with.
  prefs: []
  type: TYPE_NORMAL
- en: MimiPenguin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MimiPenguin (*[https://github.com/huntergregal/mimipenguin](https://github.com/huntergregal/mimipenguin)*)
    is a scanner for finding the credentials of logged-in users who are connected
    to Linux systems running desktop environments such as the GNOME desktop environment
    and display managers such as LightDM or the GNOME Display Manager. If you come
    from a Windows penetration-testing background, you may be familiar with Mimikatz,
    a popular tool to extract credentials stored in memory. MimiPenguin was created
    to perform equivalent tasks in the Linux world.
  prefs: []
  type: TYPE_NORMAL
- en: Linuxprivchecker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python-based utility Linuxprivchecker (*[https://github.com/sleventyeleven/linuxprivchecker/tree/master](https://github.com/sleventyeleven/linuxprivchecker/tree/master)*),
    developed by Mike Czumak (T_v3rn1x), performs local cleartext password searches,
    finds shell escape opportunities in utilities such as text editors, provides kernel
    exploit recommendations based on the running kernel version, searches for file
    and directory permission misconfigurations, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Bashark
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bashark (*[https://github.com/redcode-labs/Bashark/tree/master](https://github.com/redcode-labs/Bashark/tree/master)*)
    is a shell script developed by wintrmvte. It provides a terminal user interface
    with helper functions for a variety of offensive security tasks, such as the enumeration
    of users, port scanning, reverse shell generation, and host enumeration. Its purpose
    is to facilitate executing common tasks without needing to write scripts and while
    primarily using tools that are commonly available on Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned the fundamentals of privilege escalation, explored
    the basic and advanced file permission features in Linux systems, then scoured
    the local system for misconfigurations in files and directories. You also sifted
    through system locations where credentials are often found and inspected the configurations
    of mechanisms that could lead to privilege escalation vulnerabilities, such as
    sudo, PATH, and cron jobs. Finally, you performed local brute-force attacks against
    other system accounts.
  prefs: []
  type: TYPE_NORMAL
