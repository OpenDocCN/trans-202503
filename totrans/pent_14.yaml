- en: Chapter 10. Client-Side Exploitation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vulnerabilities we’ve studied so far have been low-hanging fruit, and all
    have come up on real engagements. It’s common on penetration tests to find vulnerable
    services listening on ports, unchanged default passwords, misconfigured web servers,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, clients who put a lot of time and effort into their security posture
    may be free from these kinds of vulnerabilities. They may have all security patches
    in place; they may periodically audit passwords and remove any that can be easily
    guessed or cracked. They may control user roles: Regular users may not have administrative
    rights on their workstations, and any software that is installed is investigated
    and maintained by the security staff. As a result, there may not be many services
    to even try to attack.'
  prefs: []
  type: TYPE_NORMAL
- en: Yet, despite the deployment of the latest and greatest security technologies
    and the employment of crack security teams, high-profile companies (with potentially
    high payoffs for attackers) are still being breached. In this chapter we’ll examine
    a few different kinds of attacks that don’t require direct network access. We’ll
    study attacks that target local software on a system—software that is not listening
    on a port.
  prefs: []
  type: TYPE_NORMAL
- en: Because we won’t attack a computer or listening port directly, and because we
    need to come up with another way to attack a device inside a corporate perimeter,
    we need to select our payload accordingly. Whereas a normal bind shell might work
    fine for systems directly exposed to the Internet or listening on a port on our
    local network, we will at the very least be limited to reverse connections here.
  prefs: []
  type: TYPE_NORMAL
- en: But first let’s dive a little deeper into the Metasploit payload system and
    check out some other payloads that may be useful to you.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Filters with Metasploit Payloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous chapters we discussed the Metasploit payload system, including single
    versus staged payloads and bind shells versus reverse shells. We also talked briefly
    about Metasploit’s Meterpreter payload (which we’ll discuss in depth in [Chapter 13](ch13.xhtml
    "Chapter 13. Post Exploitation")). When you use the command `show payloads` on
    a module, you may see several payloads that may be new to you. We’ll look at a
    few in this section that can be used to bypass filtering technologies you may
    encounter on your pentests.
  prefs: []
  type: TYPE_NORMAL
- en: All Ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our network is set up such that our attack and target virtual machines are on
    the same network with no firewalls or other filters blocking communications. However,
    in your pentesting career, you may encounter clients with all sorts of filtering
    setups. Even a reverse connection may not be able to get through the filters and
    connect back to your attack machine on just any port. For example, a client network
    may not allow traffic to leave the network on port 4444, the default for Metasploit
    *reverse_tcp* payloads. It may allow traffic out only on specific ports, such
    as 80 or 443 for web traffic.
  prefs: []
  type: TYPE_NORMAL
- en: If we know which ports are allowed through the filter, we can set the `LPORT`
    option to the relevant port. The Metasploit *reverse_tcp_allports* payloads can
    help us find a port to connect to. As the name suggests, this payload communication
    method will try all ports until it finds a successful connection back to Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test this functionality with the *windows/shell/reverse_tcp_allports*
    payload, as shown in [Example 10-1](ch10.xhtml#windowssolidusshellsolidusreverseundersc
    "Example 10-1. Windows/shell/reverse_tcp_allports payload"). We are using the
    MS08-067 exploit against Windows XP.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-1. Windows/shell/reverse_tcp_allports payload
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `LPORT` ❶ option specifies the first port to try. If that port doesn’t
    work, the payload will try each subsequent port until the connection succeeds.
    If the payload reaches 65535 without success, it starts trying again at port 1
    and runs infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is no filter blocking our traffic, the first port Metasploit tries,
    port 1, creates a successful connection, as shown at ❷. Though this payload will
    work in many cases, some filtering technologies will be able to stop it regardless
    of the port it tries to connect to. One downside to this payload is that it may
    run for a long time in an attempt to find an unfiltered port. If a user sees the
    application hanging, he or she may close it before the payload is successful.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP and HTTPS Payloads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While some filters may allow all traffic out on certain ports, the most advanced
    filtering systems use content inspection to screen for legitimate protocol-specific
    traffic. This can pose a problem for our payloads. Even though our Meterpreter
    payload communication is encrypted—the content inspection won’t be able to say,
    “That’s Metasploit, go away!”—the filter will be able to tell that the traffic
    going out on port 80 doesn’t meet the HTTP specification.
  prefs: []
  type: TYPE_NORMAL
- en: To address this challenge, the developers of Metasploit created HTTP and HTTPS
    payloads. These payloads follow the HTTP and HTTPS specifications so that even
    content-inspection filters will be convinced that our traffic is legitimate. Also,
    these payloads are packet based, rather than stream based like the TCP payloads.
    That means they aren’t limited to a specific connection. If you lose network communication
    briefly and lose all your Metasploit sessions, HTTP and HTTPS sessions can recover
    and reconnect. (We’ll see an example using these payloads in [Java Vulnerability](ch10.xhtml#java_vulnerability
    "Java Vulnerability").)
  prefs: []
  type: TYPE_NORMAL
- en: Though HTTP and HTTPS payloads will get you through most filtering technologies,
    you may find yourself in an even more complex filtering situation. For example,
    I tested one client where only the Internet Explorer process, when started by
    a domain-authenticated user, could reach the Internet. Employees could browse
    the Internet to perform their business, but they were somewhat limited. For instance,
    they couldn’t use an instant messenger client. While this probably annoyed some
    employees, it was a good idea for security reasons. Even if we had been able to
    successfully exploit something, even HTTP and HTTPS payloads could not get out
    to the Internet. (In [Browser Exploitation](ch10.xhtml#browser_exploitation "Browser
    Exploitation"), we’ll look at some attack methods that would allow us to exploit
    the Internet Explorer process when a legitimate domain user is logged in and then
    connect to the outside world.)
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter HTTP and Meterpreter HTTPS use the proxy settings of Internet Explorer
    to navigate any proxies necessary to call out to the Internet. For this reason,
    if your target process is running as the *System* user, these proxy settings may
    not be defined, and these payloads may fail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a Meterpreter payload, reverse_https_proxy, that allows the attacker
    to manually add in any necessary proxy settings.
  prefs: []
  type: TYPE_NORMAL
- en: Client-Side Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s turn our attention to running client-side attacks. Instead of directly
    attacking a service listening on a port, we’ll create a variety of malicious files
    that, when opened in vulnerable software on the target machine, will result in
    a compromise.
  prefs: []
  type: TYPE_NORMAL
- en: So far all of our attacks have involved some sort of service listening on a
    port, be it a web server, FTP server, SMB server, or otherwise. When we began
    our pentest, one of the first things we did was port scan our targets to see which
    services were listening. When we start a pentest, the potential vulnerabilities
    are practically limitless.
  prefs: []
  type: TYPE_NORMAL
- en: As we begin running tools, performing manual analysis, and researching, the
    exploitation possibilities gradually decrease until we’re left with a limited
    number of issues on the target systems. Those issues have been server-side issues—services
    listening on ports. What we are missing is any potentially vulnerable software
    that is not listening on a port—client-side software.
  prefs: []
  type: TYPE_NORMAL
- en: Software like web browsers, document viewers, music players, and so on are subject
    to the same sort of issues as web servers, mail servers, and every other network-based
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, because client-side software isn’t listening on the network, we can’t
    directly attack it, but the general principle is the same. If we can send unexpected
    input to a program to trigger a vulnerability, we can hijack execution, just as
    we exploited server-side programs in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation").
    Because we can’t send input to client-side programs directly over the network,
    we must entice a user to open a malicious file.
  prefs: []
  type: TYPE_NORMAL
- en: As security is taken more seriously and server-side vulnerabilities become more
    difficult to find from an Internet-facing perspective, client-side exploitation
    is becoming key to gaining access to even carefully protected internal networks.
    Client-side attacks are ideal for assets such as workstations or mobile devices
    that lack an Internet-facing IP address. Though from the perspective of the Internet
    we can’t directly access those systems, they can typically call out to the Internet,
    or to a pentester-controlled system, if we can hijack execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the success of client-side attacks relies on somehow making
    sure that our exploit is downloaded and opened in a vulnerable product. In the
    next chapter, we’ll look at some techniques to lure users into opening malicious
    files; for now we’ll look at some client-side exploits, beginning with what must
    be the most popular target for client-side exploitation: web browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: Browser Exploitation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web browsers are made up of code to render web pages. Just as we can send malformed
    input to server software, if we open a web page with malicious code to trigger
    a security issue, we can potentially hijack execution in the browser and execute
    a payload. Though the delivery is a bit different, the fundamental concept is
    the same. All of the most common browsers have been subject to security issues—Internet
    Explorer, Firefox, and even Mobile Safari.
  prefs: []
  type: TYPE_NORMAL
- en: iPhone Jailbreaking via Browser Exploitation
  prefs: []
  type: TYPE_NORMAL
- en: In the past, browser exploitation has been instrumental in iPhone jailbreaking.
    While later versions of iOS implement a security feature called *mandatory code
    signing*, which requires that all executed code be approved by Apple, Mobile Safari
    (the web browser on the iPhone) gets a pass because to render web pages, it must
    be able to run unsigned code. Apple can’t go through all the pages on the Internet
    and sign everything that doesn’t contain malicious code. And if the iPhone can’t
    view web pages, everyone will just go buy an Android phone—the last thing Apple
    wants. When iOS 4 renders PDF documents in Mobile Safari, one of the fonts includes
    a security vulnerability. This client-side attack allows jailbreakers to gain
    a foothold on iPhones just by tricking a user into opening a malicious link in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a famous vulnerability in Internet Explorer. The Aurora exploit
    was used in 2010 against major companies such as Google, Adobe, and Yahoo!. At
    the time of the Aurora attacks, Internet Explorer contained a *zero-day vulnerability*—that
    is, a vulnerability that had not yet been patched. (Even a fully updated version
    of Internet Explorer could be compromised if a user could be tricked into opening
    a malicious web page, triggering the vulnerability.)
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has released patches for Internet Explorer, but as with other security
    patches, users sometimes overlook updating their browsers, and the version of
    Internet Explorer installed on the Windows XP target doesn’t have the necessary
    security patch to protect against the Aurora exploit.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Metasploit to take control of a target machine by attacking a vulnerable
    browser using the Aurora Metasploit module, *exploit/windows/browser/ms10_002_aurora*,
    shown in [Example 10-2](ch10.xhtml#internet_explorer_aurora_metasploit_modu "Example 10-2. Internet
    Explorer Aurora Metasploit module").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Client-side Metasploit modules are fundamentally the same as the server-side
    modules we have used so far, except that the options are a bit different: Instead
    of sending exploits to a remote host on the network, we set up a server and wait
    for a browser to access our page.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-2. Internet Explorer Aurora Metasploit module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the options for the module that instead of `RHOST` we see the `SRVHOST`
    ❶ option. This is the local IP address for the server. By default this address
    is set to 0.0.0.0 to listen on all addresses on the local system. The default
    port to listen on, the `SRVPORT` ❷ option, is 8080\. You can change this port
    number to 80 (the default port for web servers) as long as no other program is
    using the port. You can even use an SSL connection ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If we set the `URIPATH` ❹ option, we can specify a specific URL for the malicious
    page. If we don’t set anything here, a random URL will be used. Because the exploitation
    will take place entirely inside the browser, our exploit will work regardless
    of the version of Windows running ❺, as long as Internet Explorer is subject to
    the Aurora vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Next we set the module options for our environment. The payloads for this module
    are the same as the Windows payloads we’ve already seen. Exploiting the browser
    is no different from exploiting any other program on the system, and we can run
    the same shellcode. We’ll use the *windows/meterpreter/reverse_tcp* payload for
    this example to illustrate some client-side attack concepts, as shown in [Example 10-3](ch10.xhtml#setting_options_and_launching_the_aurora
    "Example 10-3. Setting options and launching the Aurora module").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure the apache2 web server is not running on port 80 with `service apache2
    stop`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-3. Setting options and launching the Aurora module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Example 10-3](ch10.xhtml#setting_options_and_launching_the_aurora
    "Example 10-3. Setting options and launching the Aurora module"), once we’ve set
    the options and run the module, a web server is started in the background on the
    selected `SRVPORT` at the selected `URIPATH` as shown at ❷. Additionally, a handler
    is set up for the selected payload ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll use Internet Explorer on the Windows XP target to browse to the malicious
    site. In Metasploit you should see that the page has been served and is attempting
    to exploit the vulnerability, as shown in [Example 10-4](ch10.xhtml#receiving_a_client-side_session
    "Example 10-4. Receiving a client-side session"). Although our Windows XP browser
    is vulnerable, it may take a couple tries to exploit the browser successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the Aurora vulnerability is not as reliable as exploiting the other
    vulnerabilities we’ve discussed so far in this book. If Internet Explorer crashes,
    but you do not receive a session, try browsing to the exploit page again.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-4. Receiving a client-side session
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Though this exploit may not work every time, the target browser is vulnerable
    and a couple of tries should do it. If the exploit succeeds, you will receive
    a session, as shown at ❶. We are not automatically dropped into the session. Use
    **`sessions -i`** `<session id>` to interact with the Meterpreter session.
  prefs: []
  type: TYPE_NORMAL
- en: Though we have successfully exploited the browser and gained a foothold on the
    target system, our challenges are not over. If you look back at the Windows XP
    machine and try to continue using Internet Explorer, you’ll find that it’s no
    longer functioning. The exploitation involved in getting our session has made
    the browser unusable. The problem for us is that users who have been tricked into
    visiting our malicious site will naturally want to continue using their browsers.
    They may force-quit the browser, or the browser may crash on its own due to its
    unstable state. When the browser closes, we lose our Meterpreter session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our Meterpreter payload resides entirely inside the memory of the exploited
    process. If the browser dies or is closed by the user, our session also dies,
    as you can see at ❶. We can lose our foothold on the system just as quickly as
    we gained it.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to keep our Meterpreter session alive, even if the exploited process—in
    this case, the Internet Explorer browser—dies. But first, we need to stop our
    Metasploit web server so we can make some changes to the malicious page to fix
    this problem, as shown in [Example 10-5](ch10.xhtml#killing_a_background_job_in_metasploit
    "Example 10-5. Killing a background job in Metasploit").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-5. Killing a background job in Metasploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can see everything running in the background in Metasploit by entering **`jobs`**
    ❶. To stop a job running in the background, enter **`kill <`**`job number`**`>`**
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Because Meterpreter lives entirely inside the memory of the exploited process
    and that process is doomed to die, we need some way to move our session out of
    the Internet Explorer process and into one that is more likely to stick around.
  prefs: []
  type: TYPE_NORMAL
- en: Running Scripts in a Meterpreter Session
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike network attacks, where we will see a session right away if our attack
    succeeds, when performing client-side attacks, we must wait until a user accesses
    our malicious page. Even if we find a way to move Meterpreter into another process,
    sessions could come in at any time. We can’t be distracted at any point during
    our pentest or we risk losing a session. It would be ideal if we could automatically
    run commands in our Meterpreter session so that we don’t have to sit idly, waiting
    for a browser to access our malicious server.
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter scripts that can be run in an open session can be found at */usr/share/metasploit-framework/scripts/meterpreter*
    in Kali. We’ll look at more examples of Meterpreter scripts in [Chapter 13](ch13.xhtml
    "Chapter 13. Post Exploitation"), but for now let’s look at one specific Meterpreter
    script that will work well with our current scenario. The script *migrate.rb*
    allows us to move Meterpreter from the memory of one process to another, which
    is exactly what we need here. To run a Meterpreter script inside an active Meterpreter
    session, enter **`run <`**`script name`**`>`**, as shown in [Example 10-6](ch10.xhtml#running_a_meterpreter_script
    "Example 10-6. Running a Meterpreter script"). You may be presented with help
    information about how to use the script correctly, as we are shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-6. Running a Meterpreter script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we attempt to run the *migrate* script, we see a few options. We can launch
    a new process and migrate into that process, as shown at ❶; migrate into a process
    with a given name ❷; or choose the process by process ID, as shown at ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the module and payload options, Metasploit modules have advanced
    parameters. We can see the available advanced parameters with the command `show
    advanced`, as shown in [Example 10-7](ch10.xhtml#metasploit_advanced_parameters
    "Example 10-7. Metasploit advanced parameters").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-7. Metasploit advanced parameters
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One of the advanced settings for our chosen payload is `AutoRunScript` ❶. When
    set, this setting will allow us to automatically run a Meterpreter script when
    a session opens.
  prefs: []
  type: TYPE_NORMAL
- en: We can set this parameter to automatically run the *migrate* script when a Meterpreter
    session opens. This way, when the browser dies, as long as the *migrate* script
    has finished, our session will be safe from the crash. Additionally, by running
    the script automatically, we can migrate whenever a user accesses the malicious
    page, regardless of whether you have your eyes on Msfconsole when the session
    comes in, as shown in [Example 10-8](ch10.xhtml#setting_the_autorunscript_parameter
    "Example 10-8. Setting the AutoRunScript parameter").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-8. Setting the `AutoRunScript` parameter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To set advanced parameters, use the syntax `set <`*`parameter to set`*`> <`*`value`*`>`
    (the same as setting regular options). For example, in [Example 10-8](ch10.xhtml#setting_the_autorunscript_parameter
    "Example 10-8. Setting the AutoRunScript parameter"), we tell the *migrate* script
    to spawn a new process to migrate into with the `-f` flag ❶, and then we start
    the malicious server again.
  prefs: []
  type: TYPE_NORMAL
- en: Now browse to the malicious page from the Windows XP target again (see [Example 10-9](ch10.xhtml#automatically_migrating
    "Example 10-9. Automatically migrating")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-9. Automatically migrating
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This time we get a session saying that the `AutoRunScript` parameter is processed
    automatically ❶. The *migrate* script spawns a *notepad.exe* process and moves
    into it ❷. When Internet Explorer dies, our session remains alive.
  prefs: []
  type: TYPE_NORMAL
- en: Though automatically migrating is a good idea when using a browser exploit,
    it still takes a few seconds for the migration to happen—seconds during which
    the user could close the browser and kill our session. Fortunately, the advanced
    Meterpreter option `PrependMigrate`, shown here, will migrate even faster, before
    the payload is run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can set this option to `true` as an alternative to the `AutoRunScript` we
    used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This has been just one example of a browser exploit. Metasploit has other modules
    for exploiting vulnerabilities in Internet Explorer as well as other popular web
    browsers. As more organizations have hardened their external security posture,
    browser exploitation has given over the keys to the kingdom in many pentests as
    well as attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Aurora vulnerability was patched in 2010, but users and organizations are
    bad at keeping their browsers up to date, so this exploit still finds targets
    today. Additionally, though new remote exploits for operating systems are rare,
    major browsers such as Internet Explorer fall victim to new client-side attacks
    on a regular basis. Use Msfupdate as discussed in [Chapter 4](ch04.xhtml "Chapter 4. Using
    the Metasploit Framework") to get the latest modules for new vulnerabilities,
    some of which may not even be patched by the vendor at the time of the module’s
    release. Note that running Msfupdate may affect how Metasploit works, which may
    make it more difficult to follow along with the book. Therefore, you may not want
    to update Metasploit until after you have read through the book.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at some other client-side software that can be exploited to gain
    command execution on a target system.
  prefs: []
  type: TYPE_NORMAL
- en: PDF Exploits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Portable Document Format (PDF) software can also be exploited. If a user can
    be enticed to open a malicious PDF in a vulnerable viewer, the program can be
    exploited.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular PDF viewer for Windows systems is Adobe Reader. Like browsers,
    Adobe Reader has a history littered with security holes. Also like browsers, even
    when a patch-management process is in place, regularly updating the underlying
    operating system, PDF software is often forgotten, and remains at an older, vulnerable
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting a PDF Vulnerability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our Windows XP target has an outdated version of Adobe Reader 8.1.2 installed
    that is subject to CVE-2008-2992, a stack-based buffer overflow. The corresponding
    Metasploit module is *exploit/windows/fileformat/adobe_utilprintf*.
  prefs: []
  type: TYPE_NORMAL
- en: The options for this module are a bit different than anything we’ve seen thus
    far, as shown in [Example 10-10](ch10.xhtml#metasploit_pdf_exploit "Example 10-10. A
    Metasploit PDF exploit"). This is a client-side attack, so there is no `RHOST`
    option, but unlike our browser attack, there are also no `SRVHOST` or `SRVPORT`
    options. This module simply creates a malicious PDF; hosting it for delivery and
    setting up a payload handler is up to us. Of course, we have all the skills necessary
    to perform both these tasks easily.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-10. A Metasploit PDF exploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only option for the PDF exploit is the name of the malicious
    file to be generated ❶. We can leave the default, *msf.pdf*. For this example,
    we’ll have Metasploit use the default payload, *windows/meterpreter/reverse_tcp*
    on port 4444\. When we enter **`exploit`**, Metasploit generates a PDF that will
    exploit this vulnerability in a vulnerable version of Adobe Reader on Windows
    XP SP3 English ❷. The malicious PDF is stored as */root/.msf4/local/msf.pdf* ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to serve the PDF and set up a handler for the payload, as shown
    in [Example 10-11](ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha "Example 10-11. Serving
    the malicious PDF and using a handler").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-11. Serving the malicious PDF and using a handler
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We copy the file to the Apache web server folder and start the server, if it
    is not already running. We’ll look at ways to lure users into opening malicious
    files later in this chapter, but for now we’ll just open the malicious PDF in
    Adobe Reader 8.1.2 on our Windows XP target. First, though, we need to set up
    a handler for the payload. We can use the *multi/handler* ❶ module as we learned
    in [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit Framework"). (Be sure
    to kill the Aurora job if its handler is also listening on port 4444 to free up
    this port for *multi/handler* use). When we open the malicious PDF, we again receive
    a session ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Typically with an attack like this we won’t be targeting just one user. For
    best results we might use this malicious PDF as part of a social-engineering campaign,
    as discussed in the next chapter, by sending out a few to even hundreds of malicious
    PDFs in an attempt to entice users to open them. The *multi/handler* listener
    we set up previously will close as soon as it sees the first connection, causing
    us to miss any other connections that come in from other users opening the PDF.
    It would be much better if we could leave our listener open to catch additional
    incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, an advanced option for the *multi/handler* module solves this
    problem. As shown in [Example 10-12](ch10.xhtml#keeping_the_handler_open_for_multiple_se
    "Example 10-12. Keeping the handler open for multiple sessions"), the advanced
    option `ExitOnSession`, which is set to `true` by default, specifies whether the
    listener closes after it receives a session. If we set this option to `false`,
    the listener will stay open and allow us to catch multiple sessions with a single
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-12. Keeping the handler open for multiple sessions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Set `ExitOnSession` to `false` in the usual way ❶. One side effect of this option
    is that if we, say, exploit and start the listener in the foreground, it will
    never close, so we will be stuck without an Msfconsole prompt indefinitely. For
    this reason, Metasploit will complain and note that you should use the `-j` option
    with `exploit` ❷ to run the handler as a job, in the background. This way you
    can continue to use Msfconsole while the handler catches any incoming shells in
    the background. To close the handler in the future, use `jobs`, followed by `kill`
    *`<job number>`* as we did in the Aurora example.
  prefs: []
  type: TYPE_NORMAL
- en: This exploit and the Aurora browser example discussed earlier both rely on a
    missing security patch. Here we’ve exploited a security vulnerability to hijack
    control of the program and execute malicious code by tricking the user into letting
    us run malicious code. If the user will allow us to run code, a vulnerability
    in the PDF software becomes unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: PDF Embedded Executable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now for another PDF attack: This time we’ll embed a malicious executable inside
    a PDF. The corresponding Metasploit module is *exploit/windows/fileformat/adobe_pdf_embedded_exe*,
    as shown in [Example 10-13](ch10.xhtml#pdf_embedded_exe_module "Example 10-13. PDF
    embedded EXE module"). Instead of exploiting the software as soon as the PDF is
    opened, the generated PDF will prompt the user for permission to run the embedded
    file. The success of our attack is contingent on the user allowing our executable
    to run.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-13. PDF embedded EXE module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The module lets us specify a prebuilt executable file with the `EXENAME` ❶ option.
    If we don’t set this option, we can embed an .*exe* file created from whatever
    payload we select. We can again change the filename to anything we like or leave
    the value as the default ❷. To use this module, we must use an input PDF for the
    `INFILENAME` ❸ option. The `LAUNCH_MESSAGE` ❹ option is the text that will be
    shown to the user as part of the prompt to run the executable.
  prefs: []
  type: TYPE_NORMAL
- en: Set the relevant options, as shown in [Example 10-14](ch10.xhtml#setting_module_options_and_creating_the
    "Example 10-14. Setting module options and creating the malicious PDF").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-14. Setting module options and creating the malicious PDF
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use a PDF included with Kali Linux for our example: the Metasploit user
    guide at */user/share/set/readme/User_Manual.pdf* ❶. The generated PDF is again
    stored in the */root/msf4/local/* directory ❷. (Be sure to set up a handler for
    the payload with the *multi/handler* module before opening the PDF on the Windows
    XP target. For a refresher, see [Example 10-11](ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha
    "Example 10-11. Serving the malicious PDF and using a handler").)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous exploit may have left Adobe Reader in a bad state, so you may need
    to restart Windows XP to get it to properly load the new PDF.
  prefs: []
  type: TYPE_NORMAL
- en: When the malicious PDF is opened, the user sees a warning like the one shown
    in [Figure 10-1](ch10.xhtml#pdf_embedded_executable_user_warning "Figure 10-1. PDF
    embedded executable user warning"). The user must click Open for the embedded
    executable to run. This attack depends on users being willing to click through
    this warning.
  prefs: []
  type: TYPE_NORMAL
- en: '![PDF embedded executable user warning](httpatomoreillycomsourcenostarchimages2030396.png.jpg)Figure 10-1. PDF
    embedded executable user warning'
  prefs: []
  type: TYPE_NORMAL
- en: Once you click Open in the PDF warning, the payload will run, and you will receive
    a session.
  prefs: []
  type: TYPE_NORMAL
- en: Java Exploits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java vulnerabilities are a prevalent client-side attack vector. In fact, some
    experts suggest that in light of the security issues that plague Java, users should
    uninstall or disable the software in their browsers.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that makes Java attacks so powerful is that one exploit can gain access
    to multiple platforms. Windows, Mac, and even Linux systems running the Java Runtime
    Environment (JRE) in a browser can all be exploited by exactly the same exploit
    when that browser opens a malicious page. Here are some sample exploits.
  prefs: []
  type: TYPE_NORMAL
- en: Java Vulnerability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As exhibit number one, we’ll use the Metasploit module *exploit/multi/browser/java_jre17_jmxbean*,
    as shown in [Example 10-15](ch10.xhtml#setting_up_a_java_exploit "Example 10-15. Setting
    up a Java exploit"). Use of this module is similar to that of the Internet Explorer
    Aurora exploit shown earlier in this chapter. Metasploit sets up a malicious server
    to exploit this cross-platform vulnerability on any browser that arrives at the
    page. Any browser running Java version 7 before update 11 is affected.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-15. Setting up a Java exploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Set the options to match your environment. Set the `SRVHOST` option to the local
    IP address, and change the `SRVPORT`, if you would like. Set the `URIPATH` to
    something that will be easy to type in your target browser.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that because this exploit is multi-platform and the code execution takes
    place entirely inside the JRE, our payload options are Java-based. The usual suspects
    are all here, from staged payloads, inline payloads, bind shells, reverse shells,
    Meterpreter, and so on, as shown in the list of payloads at ❶. We’ll use the payload
    *java/meterpreter/reverse_http*, which uses legitimate HTTP traffic ❷. Its options
    are shown in [Example 10-16](ch10.xhtml#exploiting_a_java_vulnerability_with_an
    "Example 10-16. Exploiting a Java vulnerability with an HTTP payload").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-16. Exploiting a Java vulnerability with an HTTP payload
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These options should look familiar. The default `LPORT` option is now 8080 instead
    of 4444\. Notice that both `SRVPORT` and `LPORT` default to 8080, so we’ll need
    to change at least one of them.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve finished setting options, start the exploit server and browse to
    the malicious page from your Windows 7 target. Either Internet Explorer or Mozilla
    Firefox will fall victim to this attack as long as you have enabled the vulnerable
    Java browser plugin.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great features of the HTTP and HTTPS Meterpreter payloads, aside
    from being legitimate HTTP and HTTPS traffic and thus by-passing even some traffic-inspecting
    filters, is their ability to reattach to a dropped session. (Network problems
    can cause sessions to spontaneously die—a big annoyance for pentesters.) We’ll
    examine other ways to gain persistent access in [Chapter 13](ch13.xhtml "Chapter 13. Post
    Exploitation"), but for now let’s detach our Meterpreter session, as shown in
    [Example 10-17](ch10.xhtml#detaching_the_http_meterpreter_session "Example 10-17. Detaching
    the HTTP Meterpreter session").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-17. Detaching the HTTP Meterpreter session
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the handler for the HTTP Meterpreter payload is still running
    in the background. Wait a few seconds, and you should see a new session open without
    the user needing to revisit the attack page as shown at ❶. Unless the session
    has been formally exited, the payload will continue to try to connect back to
    Metasploit. (You can specify how long the session tries to reconnect with the
    `SessionCommunicationTimeOut` parameter, an advanced option for the payload.)
  prefs: []
  type: TYPE_NORMAL
- en: But what if your pentest target is diligent in updating Java, and there are
    currently no zero-days for the software floating around the Internet?
  prefs: []
  type: TYPE_NORMAL
- en: Signed Java Applet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Much like the attack against PDF users discussed in [PDF Embedded Executable](ch10.xhtml#pdf_embedded_executable
    "PDF Embedded Executable"), we can bypass the need for an unpatched Java vulnerability
    by simply asking users to allow us to run malicious code. You’ve probably seen
    browser warnings like, “This site would like to run this thing in your browser,
    how would you like to proceed?” Sometimes even security-savvy users can be convinced
    to just say “Yes” and bypass this warning without further investigation if they
    can be convinced that what’s on the other side is useful.
  prefs: []
  type: TYPE_NORMAL
- en: The module we’ll use for this example is *exploit/multi/browser/java_signed_applet*.
    As the name implies, this module will create a malicious Java applet, as shown
    in [Example 10-18](ch10.xhtml#metasploit_signed_java_applet_module "Example 10-18. Metasploit
    signed Java applet module").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-18. Metasploit signed Java applet module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Older versions of Java will allow us to use the `CERTCN` option shown at ❶ to
    say that the applet is signed by any entity that we choose. Newer versions of
    Java, like the one installed on the Windows 7 target, will say that the signer
    is unknown unless we sign the applet with a trusted signing certificate, which
    we can specify at ❷. If this option is set, it will override the `CERTCN` option.
    If we have a trusted signing certificate or we’ve compromised a certificate from
    our target, we can make our applet look more legitimate, but we’ll leave our applet
    self-signed for this example.
  prefs: []
  type: TYPE_NORMAL
- en: As shown at ❸, the default target for this module is a Windows system. However,
    as shown in [Example 10-19](ch10.xhtml#using_a_java_payload "Example 10-19. Using
    a Java payload"), we can use payloads for other platforms running JRE.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-19. Using a Java payload
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As with other Java exploits, we can make this attack multi-platform. We can
    change the target to Linux or Mac OS, or use a Java payload ❶ that will target
    them all.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with our PDF examples, the previous exploit has left Java in a bad state,
    and you may need to restart Windows 7 before attempting to run the applet.
  prefs: []
  type: TYPE_NORMAL
- en: Browse to the Metasploit server from your Windows 7 target, and you should be
    prompted to run the applet, as shown in [Figure 10-2](ch10.xhtml#java_applet_attack
    "Figure 10-2. Java applet attack"). The security warning informs you that if this
    applet is malicious, it will have access to the system and lets you know you should
    run the application only if the publisher is trusted. Because we didn’t use a
    signing certificate that is trusted by the browser certificate chain, the warning
    says in big letters that the publisher is unknown. This should stop anyone from
    running the malicious applet, right?
  prefs: []
  type: TYPE_NORMAL
- en: '![Java applet attack](httpatomoreillycomsourcenostarchimages2030398.png.jpg)Figure 10-2. Java
    applet attack'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the warnings, the Social-Engineer Toolkit (which we’ll explore in the
    next chapter) claims that this attack is one of the most successful of the many
    available, even though it doesn’t rely on any unpatched vulnerability in Java
    or the underlying operating system.
  prefs: []
  type: TYPE_NORMAL
- en: browser_autopwn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *browser_autopwn* module is another client-side exploitation option available
    in Metasploit. Although it’s sometimes considered cheating, this module loads
    all the browser and browser add-on modules that it knows of (including Java, Flash,
    and so on) and waits for a browser to connect to the server. Once the browser
    connects, the server fingerprints the browser and serves up all the exploits it
    thinks are likely to succeed. An example is shown in [Example 10-20](ch10.xhtml#starting_browserunderscoreautopwn
    "Example 10-20. Starting browser_autopwn").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-20. Starting browser_autopwn
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our options for this module are the usual client-side attacks. As shown here,
    I’ve set the LHOST for my shells to call back to Kali’s IP address, and URIPATH
    to something easy to remember (`autopwn`). Note that we don’t need to set any
    payloads here; as the individual modules are loaded, Metasploit sets the payload
    options appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: With the server started, browse to the malicious page from a web browser. I
    used Internet Explorer on my Windows 7 target as shown in [Example 10-21](ch10.xhtml#autopwning_a_browser
    "Example 10-21. Autopwning a browser").
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-21. Autopwning a browser
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see Metasploit notices my browser and attempts to detect its version
    and running software ❶. It then sends all the exploits it thinks might be effective
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Once all is said and done, run **`sessions -l`** to see how things turned out.
    In my case, I received four new sessions. Not bad for so little work. As you might
    expect though, all of those exploits overwhelmed the browser and it crashed. (Luckily,
    all of our sessions were automatically migrated.)
  prefs: []
  type: TYPE_NORMAL
- en: Though *browser_autopwn* is not nearly as stealthy or elegant as performing
    reconnaissance and then choosing a particular exploit likely to work against a
    target, it can be a real help in a pinch, which is why it’s worth having in your
    pentesting arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Winamp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far our client-side attacks have basically followed the same pattern. We
    generate a malicious file that exploits a vulnerability in the client software
    or prompts the user for permission to run malicious code. The user opens the file
    with the relevant program, and we get a session in Metasploit. Now for something
    a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we trick the user into replacing a configuration file for the
    Winamp music player program. When the user next opens the program, the evil configuration
    file will be processed regardless of which music file the user opens. The Metasploit
    module we’ll use is *exploit/windows/fileformat/winamp_maki_bof*, which exploits
    a buffer overflow issue in Winamp version 5.55.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see with `show options` in [Example 10-22](ch10.xhtml#metasploit_winamp_exploit
    "Example 10-22. Metasploit Winamp exploit"), this module has no options to set;
    all we need is a Windows payload. The module generates a malicious Maki file for
    use with Winamp skins. As with our PDF examples, it’s up to us to serve the file
    and set up a handler for the payload.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-22. Metasploit Winamp exploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Choose a compatible Windows payload as shown. Once the malicious Maki file has
    been generated, copy it to the Apache web server directory, and set up a payload
    handler. (An example of setting up the handler is included in [Example 10-11](ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha
    "Example 10-11. Serving the malicious PDF and using a handler").) Now we need
    to package this malicious file in such a way that a user may be convinced to load
    it in Winamp. We can create a new Winamp skin by copying one of the skins packaged
    with Winamp. We can replace the *mcvcore.maki* file from our example skin with
    our malicious one. It doesn’t matter what our skin actually looks like, because
    it will cause Winamp to hang and send us our session in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows 7, make a copy of the default Bento Winamp skin folder from *C:\Program
    Files\Winamp\Skins* and copy it to Kali. Rename the folder *Bento* to *Rocketship*.
    Replace the file *Rocketship\scripts\mcvcore.maki* with the malicious file we
    just created in Metasploit. Zip the folder and copy it to the web server. In the
    next chapter we will look at methods of creating believable social-engineering
    campaigns, but suffice it to say, if we can convince users that this malicious
    skin will make their Winamp look like a rocket ship, we might be able to convince
    users to install it.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to Windows 7, download the zipped skin from the Kali web server, unzip
    it, and save the folder to *C:\Program Files\Winamp\Skins* as shown in [Figure 10-3](ch10.xhtml#installing_the_malicious_winamp_skin
    "Figure 10-3. Installing the malicious Winamp skin").
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the malicious Winamp skin](httpatomoreillycomsourcenostarchimages2030400.png.jpg)Figure 10-3. Installing
    the malicious Winamp skin'
  prefs: []
  type: TYPE_NORMAL
- en: Now open Winamp, go to **Options** ▸ **Skins**, and choose **Rocketship**, as
    shown in [Figure 10-4](ch10.xhtml#using_the_malicious_skin "Figure 10-4. Using
    the malicious skin").
  prefs: []
  type: TYPE_NORMAL
- en: Once you select the malicious skin, Winamp will appear to close, and you will
    receive a session in your Metasploit handler.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the malicious skin](httpatomoreillycomsourcenostarchimages2030402.png.jpg)Figure 10-4. Using
    the malicious skin'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attacks we’ve seen in this chapter target software that is not listening
    on a network port. We attacked browsers, PDF viewers, the Java browser plugin,
    and a music player. We generated malicious files that trigger a vulnerability
    in the client-side software when opened by the user, and we looked at examples
    that ask the user for permission to run malicious code instead of relying on an
    unpatched vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet can be a scary place for client-side software. Some of the exploits
    discussed in this chapter were seen in the wild before a patch was issued by the
    vendors. In fact, the Java exploit we used in [Java Vulnerability](ch10.xhtml#java_vulnerability
    "Java Vulnerability") was still a zero-day vulnerability when the Metasploit module
    was added to the framework. Anyone using Java 7 could run afoul of a malicious
    site, even if his or her machine was fully patched, and all an attacker had to
    do was use Metasploit to perform a successful attack.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, disabling or uninstalling Java fixes this problem in the event of
    a zero-day exploit running rampant on the Internet, but that might not be feasible
    for all users and organizations. Though not all sites use Java, popular online
    meeting software such as WebEx and GoToMeeting require Java, and the virtual classroom
    software Blackboard has Java components as well. A lot of network/security appliances
    actually require network/security admins to run outdated versions of Java, which
    makes them perfect targets for client-side attacks. Most readers can probably
    think of at least one site that complains if Java is not installed.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side software is necessary to perform day-to-day tasks in any organization,
    but this software should not be overlooked when evaluating security risks. Keeping
    all client-side software up-to-date with the latest patches can be a daunting
    task on your personal computer, much less on the computers of an entire organization.
    Even organizations that are doing a good job of applying important Windows security
    fixes may miss an update to Java or Adobe Reader and leave company workstations
    open to client-side attacks.
  prefs: []
  type: TYPE_NORMAL
- en: All of the attacks in this chapter depend on a legitimate user taking action
    on the target systems. Although we’ve seen what can happen when users are tricked
    into opening malicious files, we’ve yet to look at the tricks used to make people
    open those files. In the next chapter we’ll study social engineering—that is,
    ways of tricking users into performing harmful actions such as opening a malicious
    file, entering credentials into an attacker-owned site, or giving out sensitive
    information over the phone.
  prefs: []
  type: TYPE_NORMAL
