- en: Chapter 10. Client-Side Exploitation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 10 章。客户端利用
- en: The vulnerabilities we’ve studied so far have been low-hanging fruit, and all
    have come up on real engagements. It’s common on penetration tests to find vulnerable
    services listening on ports, unchanged default passwords, misconfigured web servers,
    and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们研究的漏洞都是易于发现的，而且都出现在真实的项目中。在渗透测试中，发现监听端口上存在漏洞的服务、未更改的默认密码、配置错误的 Web 服务器等情况是很常见的。
- en: 'However, clients who put a lot of time and effort into their security posture
    may be free from these kinds of vulnerabilities. They may have all security patches
    in place; they may periodically audit passwords and remove any that can be easily
    guessed or cracked. They may control user roles: Regular users may not have administrative
    rights on their workstations, and any software that is installed is investigated
    and maintained by the security staff. As a result, there may not be many services
    to even try to attack.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，那些在安全姿态上投入大量时间和精力的客户可能不会受到这类漏洞的影响。他们可能已经安装了所有安全补丁；他们可能会定期审计密码，并删除任何容易猜测或破解的密码。他们可能会控制用户角色：普通用户可能没有在他们的工作站上拥有管理权限，任何安装的软件都会由安全人员调查和维护。因此，甚至可能没有太多服务可供攻击。
- en: Yet, despite the deployment of the latest and greatest security technologies
    and the employment of crack security teams, high-profile companies (with potentially
    high payoffs for attackers) are still being breached. In this chapter we’ll examine
    a few different kinds of attacks that don’t require direct network access. We’ll
    study attacks that target local software on a system—software that is not listening
    on a port.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管部署了最新和最先进的安全技术，并雇佣了破解安全团队，高知名度的公司（对攻击者可能有高回报）仍然遭受入侵。在本章中，我们将研究一些不需要直接网络访问的不同类型的攻击。我们将研究针对系统上的本地软件的攻击——这些软件不在监听端口上。
- en: Because we won’t attack a computer or listening port directly, and because we
    need to come up with another way to attack a device inside a corporate perimeter,
    we need to select our payload accordingly. Whereas a normal bind shell might work
    fine for systems directly exposed to the Internet or listening on a port on our
    local network, we will at the very least be limited to reverse connections here.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不会直接攻击计算机或监听端口，而且我们需要想出另一种方式来攻击公司边界内的设备，因此我们需要相应地选择我们的载荷。虽然对于直接暴露在互联网上或在本地网络上监听端口的系统，正常的绑定
    shell 可能运行良好，但在这里，我们至少会受限于反向连接。
- en: But first let’s dive a little deeper into the Metasploit payload system and
    check out some other payloads that may be useful to you.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先让我们深入了解 Metasploit 载荷系统，并查看一些对您可能有用的其他载荷。
- en: Bypassing Filters with Metasploit Payloads
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Metasploit 载荷绕过过滤器
- en: In previous chapters we discussed the Metasploit payload system, including single
    versus staged payloads and bind shells versus reverse shells. We also talked briefly
    about Metasploit’s Meterpreter payload (which we’ll discuss in depth in [Chapter 13](ch13.xhtml
    "Chapter 13. Post Exploitation")). When you use the command `show payloads` on
    a module, you may see several payloads that may be new to you. We’ll look at a
    few in this section that can be used to bypass filtering technologies you may
    encounter on your pentests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讨论了 Metasploit 载荷系统，包括单个与分阶段载荷以及绑定 shell 与反向 shell。我们还简要讨论了 Metasploit
    的 Meterpreter 载荷（我们将在[第 13 章](ch13.xhtml "第 13 章。后期利用")中深入讨论）。当您在模块上使用命令 `show
    payloads` 时，您可能会看到一些对您来说可能是新的载荷。在本节中，我们将看一些可以用来绕过您在渗透测试中遇到的过滤技术的载荷。
- en: All Ports
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有端口
- en: Our network is set up such that our attack and target virtual machines are on
    the same network with no firewalls or other filters blocking communications. However,
    in your pentesting career, you may encounter clients with all sorts of filtering
    setups. Even a reverse connection may not be able to get through the filters and
    connect back to your attack machine on just any port. For example, a client network
    may not allow traffic to leave the network on port 4444, the default for Metasploit
    *reverse_tcp* payloads. It may allow traffic out only on specific ports, such
    as 80 or 443 for web traffic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络设置是这样的，我们的攻击和目标虚拟机在同一个网络上，没有防火墙或其他过滤器阻止通信。然而，在您的渗透测试职业生涯中，您可能会遇到各种过滤设置的客户。即使是反向连接也可能无法穿过过滤器并连接回您的攻击机器的任何端口。例如，客户网络可能不允许流量在端口
    4444 上离开网络，这是 Metasploit *reverse_tcp* 载荷的默认端口。它可能只允许流量通过特定端口出去，比如 80 或 443 用于网络流量。
- en: If we know which ports are allowed through the filter, we can set the `LPORT`
    option to the relevant port. The Metasploit *reverse_tcp_allports* payloads can
    help us find a port to connect to. As the name suggests, this payload communication
    method will try all ports until it finds a successful connection back to Metasploit.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道哪些端口可以通过过滤器，我们可以将`LPORT`选项设置为相关端口。Metasploit的*reverse_tcp_allports*有效负载可以帮助我们找到可以连接的端口。顾名思义，这种有效负载通信方式会尝试所有端口，直到找到成功连接回Metasploit的端口。
- en: Let’s test this functionality with the *windows/shell/reverse_tcp_allports*
    payload, as shown in [Example 10-1](ch10.xhtml#windowssolidusshellsolidusreverseundersc
    "Example 10-1. Windows/shell/reverse_tcp_allports payload"). We are using the
    MS08-067 exploit against Windows XP.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过*windows/shell/reverse_tcp_allports*有效负载来测试这一功能，如[示例10-1](ch10.xhtml#windowssolidusshellsolidusreverseundersc
    "示例10-1. Windows/shell/reverse_tcp_allports有效负载")所示。我们正在使用MS08-067漏洞攻击Windows
    XP。
- en: Example 10-1. Windows/shell/reverse_tcp_allports payload
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-1. Windows/shell/reverse_tcp_allports有效负载
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `LPORT` ❶ option specifies the first port to try. If that port doesn’t
    work, the payload will try each subsequent port until the connection succeeds.
    If the payload reaches 65535 without success, it starts trying again at port 1
    and runs infinitely.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`LPORT` ❶选项指定了第一个要尝试的端口。如果该端口无法连接，有效负载将尝试后续的每个端口，直到连接成功。如果有效负载尝试了65535个端口仍未成功，它将从端口1重新开始，并无限循环。
- en: Because there is no filter blocking our traffic, the first port Metasploit tries,
    port 1, creates a successful connection, as shown at ❷. Though this payload will
    work in many cases, some filtering technologies will be able to stop it regardless
    of the port it tries to connect to. One downside to this payload is that it may
    run for a long time in an attempt to find an unfiltered port. If a user sees the
    application hanging, he or she may close it before the payload is successful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有过滤器阻挡我们的流量，Metasploit尝试的第一个端口——端口1，成功建立了连接，如❷所示。虽然这种有效负载在很多情况下都能工作，但某些过滤技术无论它尝试连接哪个端口，都会将其拦截。这个有效负载的一个缺点是，它可能需要运行很长时间来尝试找到一个未被过滤的端口。如果用户看到应用程序卡住，可能会在有效负载成功之前关闭它。
- en: HTTP and HTTPS Payloads
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP和HTTPS有效负载
- en: While some filters may allow all traffic out on certain ports, the most advanced
    filtering systems use content inspection to screen for legitimate protocol-specific
    traffic. This can pose a problem for our payloads. Even though our Meterpreter
    payload communication is encrypted—the content inspection won’t be able to say,
    “That’s Metasploit, go away!”—the filter will be able to tell that the traffic
    going out on port 80 doesn’t meet the HTTP specification.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些过滤器可能允许在某些端口上通过所有流量，但最先进的过滤系统使用内容检查来筛选合法的协议特定流量。这可能会给我们的有效负载带来问题。即使我们的Meterpreter有效负载通信是加密的——内容检查无法识别“这是Metasploit，去开除它！”——过滤器还是能识别出从端口80发送的流量不符合HTTP规范。
- en: To address this challenge, the developers of Metasploit created HTTP and HTTPS
    payloads. These payloads follow the HTTP and HTTPS specifications so that even
    content-inspection filters will be convinced that our traffic is legitimate. Also,
    these payloads are packet based, rather than stream based like the TCP payloads.
    That means they aren’t limited to a specific connection. If you lose network communication
    briefly and lose all your Metasploit sessions, HTTP and HTTPS sessions can recover
    and reconnect. (We’ll see an example using these payloads in [Java Vulnerability](ch10.xhtml#java_vulnerability
    "Java Vulnerability").)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Metasploit的开发者创建了HTTP和HTTPS有效负载。这些有效负载遵循HTTP和HTTPS规范，即使是内容检查过滤器也会认为我们的流量是合法的。此外，这些有效负载是基于数据包的，而不像TCP有效负载那样是基于流的。这意味着它们不局限于特定连接。如果你暂时丢失网络通信并失去所有Metasploit会话，HTTP和HTTPS会话可以恢复并重新连接。（我们将在[Java漏洞](ch10.xhtml#java_vulnerability
    "Java漏洞")中看到使用这些有效负载的示例。）
- en: Though HTTP and HTTPS payloads will get you through most filtering technologies,
    you may find yourself in an even more complex filtering situation. For example,
    I tested one client where only the Internet Explorer process, when started by
    a domain-authenticated user, could reach the Internet. Employees could browse
    the Internet to perform their business, but they were somewhat limited. For instance,
    they couldn’t use an instant messenger client. While this probably annoyed some
    employees, it was a good idea for security reasons. Even if we had been able to
    successfully exploit something, even HTTP and HTTPS payloads could not get out
    to the Internet. (In [Browser Exploitation](ch10.xhtml#browser_exploitation "Browser
    Exploitation"), we’ll look at some attack methods that would allow us to exploit
    the Internet Explorer process when a legitimate domain user is logged in and then
    connect to the outside world.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter HTTP and Meterpreter HTTPS use the proxy settings of Internet Explorer
    to navigate any proxies necessary to call out to the Internet. For this reason,
    if your target process is running as the *System* user, these proxy settings may
    not be defined, and these payloads may fail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a Meterpreter payload, reverse_https_proxy, that allows the attacker
    to manually add in any necessary proxy settings.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Client-Side Attacks
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s turn our attention to running client-side attacks. Instead of directly
    attacking a service listening on a port, we’ll create a variety of malicious files
    that, when opened in vulnerable software on the target machine, will result in
    a compromise.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: So far all of our attacks have involved some sort of service listening on a
    port, be it a web server, FTP server, SMB server, or otherwise. When we began
    our pentest, one of the first things we did was port scan our targets to see which
    services were listening. When we start a pentest, the potential vulnerabilities
    are practically limitless.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: As we begin running tools, performing manual analysis, and researching, the
    exploitation possibilities gradually decrease until we’re left with a limited
    number of issues on the target systems. Those issues have been server-side issues—services
    listening on ports. What we are missing is any potentially vulnerable software
    that is not listening on a port—client-side software.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Software like web browsers, document viewers, music players, and so on are subject
    to the same sort of issues as web servers, mail servers, and every other network-based
    program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Of course, because client-side software isn’t listening on the network, we can’t
    directly attack it, but the general principle is the same. If we can send unexpected
    input to a program to trigger a vulnerability, we can hijack execution, just as
    we exploited server-side programs in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation").
    Because we can’t send input to client-side programs directly over the network,
    we must entice a user to open a malicious file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: As security is taken more seriously and server-side vulnerabilities become more
    difficult to find from an Internet-facing perspective, client-side exploitation
    is becoming key to gaining access to even carefully protected internal networks.
    Client-side attacks are ideal for assets such as workstations or mobile devices
    that lack an Internet-facing IP address. Though from the perspective of the Internet
    we can’t directly access those systems, they can typically call out to the Internet,
    or to a pentester-controlled system, if we can hijack execution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着安全问题变得越来越严肃，且服务器端的漏洞从面向互联网的角度变得更难发现，客户端漏洞利用已成为获取即使是精心保护的内部网络访问的关键。客户端攻击非常适用于缺乏面向互联网
    IP 地址的资产，如工作站或移动设备。虽然从互联网的角度我们无法直接访问这些系统，但如果我们能够劫持执行，它们通常可以连接到互联网或连接到一个渗透测试者控制的系统。
- en: 'Unfortunately, the success of client-side attacks relies on somehow making
    sure that our exploit is downloaded and opened in a vulnerable product. In the
    next chapter, we’ll look at some techniques to lure users into opening malicious
    files; for now we’ll look at some client-side exploits, beginning with what must
    be the most popular target for client-side exploitation: web browsers.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，客户端攻击的成功依赖于某种方式确保我们的漏洞利用被下载并在易受攻击的产品中打开。在下一章中，我们将探讨一些技巧，诱使用户打开恶意文件；现在我们先来看看一些客户端漏洞利用，从最流行的客户端漏洞利用目标——网页浏览器开始。
- en: Browser Exploitation
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器漏洞利用
- en: Web browsers are made up of code to render web pages. Just as we can send malformed
    input to server software, if we open a web page with malicious code to trigger
    a security issue, we can potentially hijack execution in the browser and execute
    a payload. Though the delivery is a bit different, the fundamental concept is
    the same. All of the most common browsers have been subject to security issues—Internet
    Explorer, Firefox, and even Mobile Safari.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 网页浏览器由渲染网页的代码组成。就像我们可以向服务器软件发送格式不正确的输入一样，如果我们打开一个带有恶意代码的网页来触发安全问题，我们就有可能劫持浏览器中的执行并执行有效载荷。尽管传递方式有所不同，但基本概念是相同的。所有常见的浏览器都曾受到过安全问题的影响——Internet
    Explorer、Firefox，甚至是 Mobile Safari。
- en: iPhone Jailbreaking via Browser Exploitation
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览器漏洞利用越狱 iPhone
- en: In the past, browser exploitation has been instrumental in iPhone jailbreaking.
    While later versions of iOS implement a security feature called *mandatory code
    signing*, which requires that all executed code be approved by Apple, Mobile Safari
    (the web browser on the iPhone) gets a pass because to render web pages, it must
    be able to run unsigned code. Apple can’t go through all the pages on the Internet
    and sign everything that doesn’t contain malicious code. And if the iPhone can’t
    view web pages, everyone will just go buy an Android phone—the last thing Apple
    wants. When iOS 4 renders PDF documents in Mobile Safari, one of the fonts includes
    a security vulnerability. This client-side attack allows jailbreakers to gain
    a foothold on iPhones just by tricking a user into opening a malicious link in
    the browser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，浏览器漏洞利用在 iPhone 越狱中起到了关键作用。虽然后来的 iOS 版本实施了一项名为 *强制代码签名* 的安全功能，要求所有执行的代码都必须经过
    Apple 审批，但 Mobile Safari（iPhone 上的网页浏览器）则被豁免了，因为它必须能够运行未签名的代码来渲染网页。Apple 不可能浏览整个互联网并签署所有不含恶意代码的页面。如果
    iPhone 无法查看网页，大家就只能去买 Android 手机——这是 Apple 最不想看到的。iOS 4 在 Mobile Safari 中渲染 PDF
    文件时，其中一个字体包含了一个安全漏洞。这个客户端攻击允许越狱者仅仅通过诱骗用户在浏览器中打开一个恶意链接，就能在 iPhone 上获得立足点。
- en: Let’s consider a famous vulnerability in Internet Explorer. The Aurora exploit
    was used in 2010 against major companies such as Google, Adobe, and Yahoo!. At
    the time of the Aurora attacks, Internet Explorer contained a *zero-day vulnerability*—that
    is, a vulnerability that had not yet been patched. (Even a fully updated version
    of Internet Explorer could be compromised if a user could be tricked into opening
    a malicious web page, triggering the vulnerability.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个著名的 Internet Explorer 漏洞。Aurora 漏洞利用在 2010 年被用于攻击像 Google、Adobe 和 Yahoo!
    这样的大公司。在 Aurora 攻击发生时，Internet Explorer 存在一个 *零日漏洞*——即尚未修补的漏洞。（即使是完全更新版本的 Internet
    Explorer，只要用户被诱导打开恶意网页，触发漏洞，也可能被攻破。）
- en: Microsoft has released patches for Internet Explorer, but as with other security
    patches, users sometimes overlook updating their browsers, and the version of
    Internet Explorer installed on the Windows XP target doesn’t have the necessary
    security patch to protect against the Aurora exploit.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已发布针对 Internet Explorer 的补丁，但像其他安全补丁一样，用户有时会忽略更新他们的浏览器，并且安装在 Windows XP 目标系统上的
    Internet Explorer 版本并没有包含防止 Aurora 漏洞的必要安全补丁。
- en: We’ll use Metasploit to take control of a target machine by attacking a vulnerable
    browser using the Aurora Metasploit module, *exploit/windows/browser/ms10_002_aurora*,
    shown in [Example 10-2](ch10.xhtml#internet_explorer_aurora_metasploit_modu "Example 10-2. Internet
    Explorer Aurora Metasploit module").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Metasploit 通过攻击脆弱的浏览器来控制目标机器，方法是利用 Aurora Metasploit 模块 *exploit/windows/browser/ms10_002_aurora*，具体示例请参见
    [示例 10-2](ch10.xhtml#internet_explorer_aurora_metasploit_modu "示例 10-2. Internet
    Explorer Aurora Metasploit 模块")。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Client-side Metasploit modules are fundamentally the same as the server-side
    modules we have used so far, except that the options are a bit different: Instead
    of sending exploits to a remote host on the network, we set up a server and wait
    for a browser to access our page.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端 Metasploit 模块与我们之前使用的服务器端模块基本相同，只是选项稍有不同：我们不是向网络上的远程主机发送漏洞利用代码，而是设置一个服务器并等待浏览器访问我们的页面。
- en: Example 10-2. Internet Explorer Aurora Metasploit module
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-2. Internet Explorer Aurora Metasploit 模块
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice in the options for the module that instead of `RHOST` we see the `SRVHOST`
    ❶ option. This is the local IP address for the server. By default this address
    is set to 0.0.0.0 to listen on all addresses on the local system. The default
    port to listen on, the `SRVPORT` ❷ option, is 8080\. You can change this port
    number to 80 (the default port for web servers) as long as no other program is
    using the port. You can even use an SSL connection ❸.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在该模块的选项中，我们看到的是 `SRVHOST` ❶ 选项，而不是 `RHOST`。这是服务器的本地 IP 地址。默认情况下，此地址设置为 0.0.0.0，以便监听本地系统上的所有地址。监听的默认端口是
    `SRVPORT` ❷ 选项，端口号为 8080。只要没有其他程序占用该端口，你可以将其更改为 80（Web 服务器的默认端口）。你甚至可以使用 SSL 连接
    ❸。
- en: If we set the `URIPATH` ❹ option, we can specify a specific URL for the malicious
    page. If we don’t set anything here, a random URL will be used. Because the exploitation
    will take place entirely inside the browser, our exploit will work regardless
    of the version of Windows running ❺, as long as Internet Explorer is subject to
    the Aurora vulnerability.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置了 `URIPATH` ❹ 选项，就可以为恶意页面指定一个特定的 URL。如果我们没有在这里设置任何内容，则会使用一个随机 URL。由于漏洞利用完全在浏览器内发生，因此我们的攻击无论
    Windows 版本如何 ❺ 都能生效，只要 Internet Explorer 存在 Aurora 漏洞。
- en: Next we set the module options for our environment. The payloads for this module
    are the same as the Windows payloads we’ve already seen. Exploiting the browser
    is no different from exploiting any other program on the system, and we can run
    the same shellcode. We’ll use the *windows/meterpreter/reverse_tcp* payload for
    this example to illustrate some client-side attack concepts, as shown in [Example 10-3](ch10.xhtml#setting_options_and_launching_the_aurora
    "Example 10-3. Setting options and launching the Aurora module").
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的环境设置模块选项。该模块的有效载荷与我们之前看到的 Windows 有效载荷相同。利用浏览器的方式与利用系统中的其他程序没有区别，我们可以运行相同的
    shellcode。在本示例中，我们将使用 *windows/meterpreter/reverse_tcp* 有效载荷来演示一些客户端攻击概念，具体内容请参见
    [示例 10-3](ch10.xhtml#setting_options_and_launching_the_aurora "示例 10-3. 设置选项并启动
    Aurora 模块")。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure the apache2 web server is not running on port 80 with `service apache2
    stop`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 apache2 Web 服务器没有在端口 80 上运行，使用命令 `service apache2 stop` 停止它。
- en: Example 10-3. Setting options and launching the Aurora module
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-3. 设置选项并启动 Aurora 模块
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in [Example 10-3](ch10.xhtml#setting_options_and_launching_the_aurora
    "Example 10-3. Setting options and launching the Aurora module"), once we’ve set
    the options and run the module, a web server is started in the background on the
    selected `SRVPORT` at the selected `URIPATH` as shown at ❷. Additionally, a handler
    is set up for the selected payload ❶.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [示例 10-3](ch10.xhtml#setting_options_and_launching_the_aurora "示例 10-3.
    设置选项并启动 Aurora 模块") 中看到的，一旦我们设置了选项并运行该模块，后台将在所选的 `SRVPORT` 上启动一个 Web 服务器，并在所选的
    `URIPATH` 下显示 ❷ 所示内容。此外，还会为所选的有效载荷设置处理程序 ❶。
- en: Now we’ll use Internet Explorer on the Windows XP target to browse to the malicious
    site. In Metasploit you should see that the page has been served and is attempting
    to exploit the vulnerability, as shown in [Example 10-4](ch10.xhtml#receiving_a_client-side_session
    "Example 10-4. Receiving a client-side session"). Although our Windows XP browser
    is vulnerable, it may take a couple tries to exploit the browser successfully.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 Windows XP 目标机器上的 Internet Explorer 浏览器访问恶意网站。在 Metasploit 中，你应该看到页面已经被服务，并且正在尝试利用漏洞，如
    [示例 10-4](ch10.xhtml#receiving_a_client-side_session "示例 10-4. 接收客户端会话") 所示。尽管我们的
    Windows XP 浏览器存在漏洞，但可能需要尝试几次才能成功利用浏览器。
- en: Exploiting the Aurora vulnerability is not as reliable as exploiting the other
    vulnerabilities we’ve discussed so far in this book. If Internet Explorer crashes,
    but you do not receive a session, try browsing to the exploit page again.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Aurora 漏洞并不像我们在本书中讨论的其他漏洞那样可靠。如果 Internet Explorer 崩溃，但你没有收到会话，尝试再次浏览到漏洞页面。
- en: Example 10-4. Receiving a client-side session
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-4. 接收客户端会话
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Though this exploit may not work every time, the target browser is vulnerable
    and a couple of tries should do it. If the exploit succeeds, you will receive
    a session, as shown at ❶. We are not automatically dropped into the session. Use
    **`sessions -i`** `<session id>` to interact with the Meterpreter session.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个漏洞利用可能不是每次都能成功，目标浏览器存在漏洞，尝试几次应该能够成功。如果漏洞利用成功，你将获得一个会话，如 ❶ 所示。我们不会自动进入会话。使用
    **`sessions -i`** `<session id>` 来与 Meterpreter 会话交互。
- en: Though we have successfully exploited the browser and gained a foothold on the
    target system, our challenges are not over. If you look back at the Windows XP
    machine and try to continue using Internet Explorer, you’ll find that it’s no
    longer functioning. The exploitation involved in getting our session has made
    the browser unusable. The problem for us is that users who have been tricked into
    visiting our malicious site will naturally want to continue using their browsers.
    They may force-quit the browser, or the browser may crash on its own due to its
    unstable state. When the browser closes, we lose our Meterpreter session.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经成功利用了浏览器并在目标系统上获得了立足点，但我们的挑战并未结束。如果你回到 Windows XP 机器并尝试继续使用 Internet Explorer，你会发现它不再工作。获取会话的过程中涉及的利用操作已经使浏览器无法使用。对我们来说的问题是，那些被诱骗访问我们恶意网站的用户自然会希望继续使用浏览器。他们可能会强制退出浏览器，或者浏览器可能因其不稳定状态而自行崩溃。当浏览器关闭时，我们会失去
    Meterpreter 会话。
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our Meterpreter payload resides entirely inside the memory of the exploited
    process. If the browser dies or is closed by the user, our session also dies,
    as you can see at ❶. We can lose our foothold on the system just as quickly as
    we gained it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Meterpreter 有效载荷完全存在于被利用进程的内存中。如果浏览器崩溃或被用户关闭，我们的会话也会随之终止，如 ❶ 所示。我们可以像获得立足点一样迅速失去对系统的控制。
- en: We need a way to keep our Meterpreter session alive, even if the exploited process—in
    this case, the Internet Explorer browser—dies. But first, we need to stop our
    Metasploit web server so we can make some changes to the malicious page to fix
    this problem, as shown in [Example 10-5](ch10.xhtml#killing_a_background_job_in_metasploit
    "Example 10-5. Killing a background job in Metasploit").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法保持 Meterpreter 会话存活，即使被利用的进程——在这个例子中是 Internet Explorer 浏览器——终止。但首先，我们需要停止
    Metasploit 网络服务器，以便我们可以对恶意页面进行一些修改，解决这个问题，如 [示例 10-5](ch10.xhtml#killing_a_background_job_in_metasploit
    "示例 10-5. 在 Metasploit 中终止后台作业") 所示。
- en: Example 10-5. Killing a background job in Metasploit
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-5. 在 Metasploit 中终止后台作业
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see everything running in the background in Metasploit by entering **`jobs`**
    ❶. To stop a job running in the background, enter **`kill <`**`job number`**`>`**
    ❷.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 Metasploit 中输入 **`jobs`** ❶ 查看后台运行的所有任务。要停止后台运行的任务，可以输入 **`kill <`**`job
    number`**`>`** ❷。
- en: Because Meterpreter lives entirely inside the memory of the exploited process
    and that process is doomed to die, we need some way to move our session out of
    the Internet Explorer process and into one that is more likely to stick around.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Meterpreter 完全存在于被利用进程的内存中，而该进程注定会终止，我们需要某种方法将会话从 Internet Explorer 进程转移到一个更可能持续存在的进程中。
- en: Running Scripts in a Meterpreter Session
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Meterpreter 会话中运行脚本
- en: Unlike network attacks, where we will see a session right away if our attack
    succeeds, when performing client-side attacks, we must wait until a user accesses
    our malicious page. Even if we find a way to move Meterpreter into another process,
    sessions could come in at any time. We can’t be distracted at any point during
    our pentest or we risk losing a session. It would be ideal if we could automatically
    run commands in our Meterpreter session so that we don’t have to sit idly, waiting
    for a browser to access our malicious server.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络攻击不同，当我们的攻击成功时，我们可以立刻看到会话；但在进行客户端攻击时，我们必须等到用户访问我们的恶意页面。即便我们找到了一种将 Meterpreter
    迁移到另一个进程的方法，会话仍然随时可能进入。在渗透测试过程中，我们不能分心，否则会有丢失会话的风险。如果我们能在 Meterpreter 会话中自动运行命令，那将是理想的，这样我们就不需要闲坐着等待浏览器访问我们的恶意服务器。
- en: Meterpreter scripts that can be run in an open session can be found at */usr/share/metasploit-framework/scripts/meterpreter*
    in Kali. We’ll look at more examples of Meterpreter scripts in [Chapter 13](ch13.xhtml
    "Chapter 13. Post Exploitation"), but for now let’s look at one specific Meterpreter
    script that will work well with our current scenario. The script *migrate.rb*
    allows us to move Meterpreter from the memory of one process to another, which
    is exactly what we need here. To run a Meterpreter script inside an active Meterpreter
    session, enter **`run <`**`script name`**`>`**, as shown in [Example 10-6](ch10.xhtml#running_a_meterpreter_script
    "Example 10-6. Running a Meterpreter script"). You may be presented with help
    information about how to use the script correctly, as we are shown here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 Kali 的 */usr/share/metasploit-framework/scripts/meterpreter* 路径下找到可以在打开的会话中运行的
    Meterpreter 脚本。我们将在[第 13 章](ch13.xhtml "第 13 章. 后期利用")中查看更多 Meterpreter 脚本的示例，但现在我们先看一个在当前场景下非常有效的脚本。脚本*migrate.rb*允许我们将
    Meterpreter 从一个进程的内存迁移到另一个进程的内存，这正是我们在这里需要的功能。要在活动的 Meterpreter 会话中运行一个脚本，输入**`run
    <`**`script name`**`>`**，如[示例 10-6](ch10.xhtml#running_a_meterpreter_script "示例
    10-6. 运行 Meterpreter 脚本")所示。你可能会看到如何正确使用该脚本的帮助信息，就像我们在这里看到的那样。
- en: Example 10-6. Running a Meterpreter script
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-6. 运行 Meterpreter 脚本
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we attempt to run the *migrate* script, we see a few options. We can launch
    a new process and migrate into that process, as shown at ❶; migrate into a process
    with a given name ❷; or choose the process by process ID, as shown at ❸.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行*migrate*脚本时，会看到几个选项。我们可以启动一个新进程并迁移到该进程中，如❶所示；也可以迁移到一个指定名称的进程中❷；或者通过进程ID选择进程，如❸所示。
- en: Advanced Parameters
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高级参数
- en: In addition to the module and payload options, Metasploit modules have advanced
    parameters. We can see the available advanced parameters with the command `show
    advanced`, as shown in [Example 10-7](ch10.xhtml#metasploit_advanced_parameters
    "Example 10-7. Metasploit advanced parameters").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模块和有效载荷选项外，Metasploit 模块还具有高级参数。我们可以使用命令`show advanced`查看可用的高级参数，如[示例 10-7](ch10.xhtml#metasploit_advanced_parameters
    "示例 10-7. Metasploit 高级参数")所示。
- en: Example 10-7. Metasploit advanced parameters
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-7. Metasploit 高级参数
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One of the advanced settings for our chosen payload is `AutoRunScript` ❶. When
    set, this setting will allow us to automatically run a Meterpreter script when
    a session opens.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的有效载荷的高级设置之一是`AutoRunScript` ❶。当设置此参数时，它将允许我们在会话打开时自动运行 Meterpreter 脚本。
- en: We can set this parameter to automatically run the *migrate* script when a Meterpreter
    session opens. This way, when the browser dies, as long as the *migrate* script
    has finished, our session will be safe from the crash. Additionally, by running
    the script automatically, we can migrate whenever a user accesses the malicious
    page, regardless of whether you have your eyes on Msfconsole when the session
    comes in, as shown in [Example 10-8](ch10.xhtml#setting_the_autorunscript_parameter
    "Example 10-8. Setting the AutoRunScript parameter").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置该参数，使得每当 Meterpreter 会话开启时，自动运行*migrate*脚本。这样，当浏览器崩溃时，只要*migrate*脚本完成，我们的会话就能避免崩溃的影响。此外，通过自动运行脚本，我们可以在用户访问恶意页面时随时迁移，而不管你是否在关注
    Msfconsole，当会话进入时，如[示例 10-8](ch10.xhtml#setting_the_autorunscript_parameter "示例
    10-8. 设置 AutoRunScript 参数")所示。
- en: Example 10-8. Setting the `AutoRunScript` parameter
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-8. 设置`AutoRunScript`参数
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To set advanced parameters, use the syntax `set <`*`parameter to set`*`> <`*`value`*`>`
    (the same as setting regular options). For example, in [Example 10-8](ch10.xhtml#setting_the_autorunscript_parameter
    "Example 10-8. Setting the AutoRunScript parameter"), we tell the *migrate* script
    to spawn a new process to migrate into with the `-f` flag ❶, and then we start
    the malicious server again.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置高级参数，请使用语法`set <`*`parameter to set`*`> <`*`value`*`>`（与设置常规选项相同）。例如，在[示例
    10-8](ch10.xhtml#setting_the_autorunscript_parameter "示例 10-8. 设置AutoRunScript参数")中，我们告诉*migrate*脚本通过`-f`标志
    ❶生成一个新进程并迁移到该进程中，然后我们再次启动恶意服务器。
- en: Now browse to the malicious page from the Windows XP target again (see [Example 10-9](ch10.xhtml#automatically_migrating
    "Example 10-9. Automatically migrating")).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次从Windows XP目标系统浏览到恶意页面（见[示例 10-9](ch10.xhtml#automatically_migrating "示例
    10-9. 自动迁移")）。
- en: Example 10-9. Automatically migrating
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-9. 自动迁移
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This time we get a session saying that the `AutoRunScript` parameter is processed
    automatically ❶. The *migrate* script spawns a *notepad.exe* process and moves
    into it ❷. When Internet Explorer dies, our session remains alive.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们得到了一个会话，表示`AutoRunScript`参数已自动处理 ❶。*migrate*脚本生成了一个*notepad.exe*进程，并迁移到了该进程中
    ❷。当Internet Explorer崩溃时，我们的会话仍然保持活跃。
- en: Though automatically migrating is a good idea when using a browser exploit,
    it still takes a few seconds for the migration to happen—seconds during which
    the user could close the browser and kill our session. Fortunately, the advanced
    Meterpreter option `PrependMigrate`, shown here, will migrate even faster, before
    the payload is run.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在使用浏览器漏洞时自动迁移是一个好主意，但迁移的过程仍然需要几秒钟——这几秒钟内，用户可能会关闭浏览器并结束我们的会话。幸运的是，下面显示的高级Meterpreter选项`PrependMigrate`将更快地进行迁移，甚至在有效负载运行之前。
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can set this option to `true` as an alternative to the `AutoRunScript` we
    used earlier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此选项设置为`true`，作为我们之前使用的`AutoRunScript`的替代方案。
- en: This has been just one example of a browser exploit. Metasploit has other modules
    for exploiting vulnerabilities in Internet Explorer as well as other popular web
    browsers. As more organizations have hardened their external security posture,
    browser exploitation has given over the keys to the kingdom in many pentests as
    well as attacks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是浏览器漏洞利用的一个例子。Metasploit还有其他模块用于利用Internet Explorer以及其他流行网页浏览器中的漏洞。随着更多组织加固了外部安全防护，浏览器漏洞利用已经成为许多渗透测试和攻击中的突破口。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Aurora vulnerability was patched in 2010, but users and organizations are
    bad at keeping their browsers up to date, so this exploit still finds targets
    today. Additionally, though new remote exploits for operating systems are rare,
    major browsers such as Internet Explorer fall victim to new client-side attacks
    on a regular basis. Use Msfupdate as discussed in [Chapter 4](ch04.xhtml "Chapter 4. Using
    the Metasploit Framework") to get the latest modules for new vulnerabilities,
    some of which may not even be patched by the vendor at the time of the module’s
    release. Note that running Msfupdate may affect how Metasploit works, which may
    make it more difficult to follow along with the book. Therefore, you may not want
    to update Metasploit until after you have read through the book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Aurora漏洞在2010年已被修复，但用户和组织在保持浏览器更新方面做得不好，因此这个漏洞利用至今仍能找到目标。此外，尽管新型操作系统远程漏洞较为罕见，但像Internet
    Explorer这样的大型浏览器常常成为新型客户端攻击的受害者。使用如[第4章](ch04.xhtml "第4章. 使用Metasploit框架")所述的Msfupdate获取最新的模块，这些模块可能针对的新漏洞有些甚至在模块发布时，供应商还未修复。请注意，运行Msfupdate可能会影响Metasploit的工作，这可能使你在阅读本书时遇到困难。因此，建议你在读完整本书后再更新Metasploit。
- en: Now let’s look at some other client-side software that can be exploited to gain
    command execution on a target system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一些其他的客户端软件，它们也可能被利用来在目标系统上执行命令。
- en: PDF Exploits
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PDF漏洞利用
- en: Portable Document Format (PDF) software can also be exploited. If a user can
    be enticed to open a malicious PDF in a vulnerable viewer, the program can be
    exploited.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植文档格式（PDF）软件也可以被利用。如果用户被诱导在易受攻击的查看器中打开恶意PDF，程序就可能被利用。
- en: The most popular PDF viewer for Windows systems is Adobe Reader. Like browsers,
    Adobe Reader has a history littered with security holes. Also like browsers, even
    when a patch-management process is in place, regularly updating the underlying
    operating system, PDF software is often forgotten, and remains at an older, vulnerable
    version.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 系统中最流行的 PDF 查看器是 Adobe Reader。像浏览器一样，Adobe Reader 的历史上充满了安全漏洞。同样像浏览器，即使有补丁管理流程，定期更新操作系统时，PDF
    软件经常被忽视，仍然停留在较旧且易受攻击的版本。
- en: Exploiting a PDF Vulnerability
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 利用 PDF 漏洞
- en: Our Windows XP target has an outdated version of Adobe Reader 8.1.2 installed
    that is subject to CVE-2008-2992, a stack-based buffer overflow. The corresponding
    Metasploit module is *exploit/windows/fileformat/adobe_utilprintf*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Windows XP 目标系统安装了过时版本的 Adobe Reader 8.1.2，存在 CVE-2008-2992 漏洞，这是一个基于栈的缓冲区溢出漏洞。对应的
    Metasploit 模块是 *exploit/windows/fileformat/adobe_utilprintf*。
- en: The options for this module are a bit different than anything we’ve seen thus
    far, as shown in [Example 10-10](ch10.xhtml#metasploit_pdf_exploit "Example 10-10. A
    Metasploit PDF exploit"). This is a client-side attack, so there is no `RHOST`
    option, but unlike our browser attack, there are also no `SRVHOST` or `SRVPORT`
    options. This module simply creates a malicious PDF; hosting it for delivery and
    setting up a payload handler is up to us. Of course, we have all the skills necessary
    to perform both these tasks easily.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块的选项与我们之前看到的有些不同，如在[示例 10-10](ch10.xhtml#metasploit_pdf_exploit "示例 10-10.
    一个 Metasploit PDF 漏洞")中所示。这是一个客户端攻击，因此没有`RHOST`选项，但与我们的浏览器攻击不同，这里也没有`SRVHOST`或`SRVPORT`选项。这个模块仅仅是生成一个恶意
    PDF；托管它并交付以及设置有效载荷处理程序则由我们来完成。当然，我们具备完成这两项任务所需的所有技能。
- en: Example 10-10. A Metasploit PDF exploit
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-10. 一个 Metasploit PDF 漏洞
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the only option for the PDF exploit is the name of the malicious
    file to be generated ❶. We can leave the default, *msf.pdf*. For this example,
    we’ll have Metasploit use the default payload, *windows/meterpreter/reverse_tcp*
    on port 4444\. When we enter **`exploit`**, Metasploit generates a PDF that will
    exploit this vulnerability in a vulnerable version of Adobe Reader on Windows
    XP SP3 English ❷. The malicious PDF is stored as */root/.msf4/local/msf.pdf* ❸.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，PDF 漏洞的唯一选项是要生成的恶意文件的名称❶。我们可以保留默认值，*msf.pdf*。在这个例子中，我们将让 Metasploit 使用默认的有效载荷，*windows/meterpreter/reverse_tcp*，监听端口
    4444。当我们输入**`exploit`**时，Metasploit 会生成一个 PDF，利用 Windows XP SP3 英文版中 Adobe Reader
    的易受攻击版本的漏洞❷。这个恶意 PDF 被保存在 */root/.msf4/local/msf.pdf* ❸。
- en: Now we need to serve the PDF and set up a handler for the payload, as shown
    in [Example 10-11](ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha "Example 10-11. Serving
    the malicious PDF and using a handler").
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要服务这个 PDF 并为有效载荷设置处理程序，如在[示例 10-11](ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha
    "示例 10-11. 服务恶意 PDF 并使用处理程序")中所示。
- en: Example 10-11. Serving the malicious PDF and using a handler
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-11. 服务恶意 PDF 并使用处理程序
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We copy the file to the Apache web server folder and start the server, if it
    is not already running. We’ll look at ways to lure users into opening malicious
    files later in this chapter, but for now we’ll just open the malicious PDF in
    Adobe Reader 8.1.2 on our Windows XP target. First, though, we need to set up
    a handler for the payload. We can use the *multi/handler* ❶ module as we learned
    in [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit Framework"). (Be sure
    to kill the Aurora job if its handler is also listening on port 4444 to free up
    this port for *multi/handler* use). When we open the malicious PDF, we again receive
    a session ❷.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件复制到 Apache web 服务器的文件夹中，并启动服务器（如果服务器还没有运行的话）。稍后我们会讨论如何诱使用户打开恶意文件，但现在我们仅仅是在
    Windows XP 目标机上使用 Adobe Reader 8.1.2 打开恶意 PDF。不过，首先，我们需要为有效载荷设置处理程序。我们可以使用 *multi/handler*
    ❶ 模块，正如我们在[第 4 章](ch04.xhtml "第 4 章. 使用 Metasploit 框架")中学到的那样。（如果 Aurora 作业的处理程序也在监听
    4444 端口，请确保终止该作业，以便释放端口供 *multi/handler* 使用）。当我们打开恶意 PDF 时，我们再次收到一个会话 ❷。
- en: Typically with an attack like this we won’t be targeting just one user. For
    best results we might use this malicious PDF as part of a social-engineering campaign,
    as discussed in the next chapter, by sending out a few to even hundreds of malicious
    PDFs in an attempt to entice users to open them. The *multi/handler* listener
    we set up previously will close as soon as it sees the first connection, causing
    us to miss any other connections that come in from other users opening the PDF.
    It would be much better if we could leave our listener open to catch additional
    incoming connections.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常像这样的攻击我们不会只针对一个用户。为了获得最佳效果，我们可能会将这个恶意PDF作为社会工程学攻击的一部分，如下一章所述，通过发送几个甚至数百个恶意PDF来诱使用户打开它们。我们之前设置的*multi/handler*监听器会在接收到第一个连接时关闭，这样就会错过其他用户打开PDF后可能产生的连接。如果我们能够保持监听器打开，以捕获更多的传入连接，那就更好了。
- en: As it turns out, an advanced option for the *multi/handler* module solves this
    problem. As shown in [Example 10-12](ch10.xhtml#keeping_the_handler_open_for_multiple_se
    "Example 10-12. Keeping the handler open for multiple sessions"), the advanced
    option `ExitOnSession`, which is set to `true` by default, specifies whether the
    listener closes after it receives a session. If we set this option to `false`,
    the listener will stay open and allow us to catch multiple sessions with a single
    handler.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，*multi/handler*模块的一个高级选项解决了这个问题。如[示例10-12](ch10.xhtml#keeping_the_handler_open_for_multiple_se
    "示例10-12. 保持处理程序开放以进行多次会话")所示，默认情况下，`ExitOnSession`选项被设置为`true`，它指定监听器在收到会话后是否关闭。如果我们将此选项设置为`false`，监听器将保持打开状态，并允许我们用一个处理程序捕获多个会话。
- en: Example 10-12. Keeping the handler open for multiple sessions
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-12. 保持处理程序开放以进行多次会话
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Set `ExitOnSession` to `false` in the usual way ❶. One side effect of this option
    is that if we, say, exploit and start the listener in the foreground, it will
    never close, so we will be stuck without an Msfconsole prompt indefinitely. For
    this reason, Metasploit will complain and note that you should use the `-j` option
    with `exploit` ❷ to run the handler as a job, in the background. This way you
    can continue to use Msfconsole while the handler catches any incoming shells in
    the background. To close the handler in the future, use `jobs`, followed by `kill`
    *`<job number>`* as we did in the Aurora example.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照通常的方式将`ExitOnSession`设置为`false` ❶。这个选项的副作用是，如果我们，例如，利用漏洞并在前台启动监听器，它将永远不会关闭，这样我们就会在没有Msfconsole提示符的情况下被卡住。因此，Metasploit会抱怨并指出你应该在使用`exploit`时使用`-j`选项
    ❷，将处理程序作为后台任务运行。这样，你可以在后台捕获任何传入的shell的同时继续使用Msfconsole。要关闭处理程序，可以使用`jobs`，然后使用`kill`
    *`<任务编号>`*，如我们在Aurora示例中所做的那样。
- en: This exploit and the Aurora browser example discussed earlier both rely on a
    missing security patch. Here we’ve exploited a security vulnerability to hijack
    control of the program and execute malicious code by tricking the user into letting
    us run malicious code. If the user will allow us to run code, a vulnerability
    in the PDF software becomes unnecessary.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞和前面讨论的Aurora浏览器示例都依赖于缺少的安全补丁。在这里，我们利用了一个安全漏洞，通过欺骗用户让我们运行恶意代码，从而劫持了程序的控制权。如果用户允许我们运行代码，PDF软件中的漏洞就变得不再必要。
- en: PDF Embedded Executable
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PDF嵌入的可执行文件
- en: 'Now for another PDF attack: This time we’ll embed a malicious executable inside
    a PDF. The corresponding Metasploit module is *exploit/windows/fileformat/adobe_pdf_embedded_exe*,
    as shown in [Example 10-13](ch10.xhtml#pdf_embedded_exe_module "Example 10-13. PDF
    embedded EXE module"). Instead of exploiting the software as soon as the PDF is
    opened, the generated PDF will prompt the user for permission to run the embedded
    file. The success of our attack is contingent on the user allowing our executable
    to run.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行另一个PDF攻击：这次我们将在PDF中嵌入一个恶意可执行文件。相应的Metasploit模块是*exploit/windows/fileformat/adobe_pdf_embedded_exe*，如[示例10-13](ch10.xhtml#pdf_embedded_exe_module
    "示例10-13. PDF嵌入的EXE模块")所示。生成的PDF不会在打开时立刻利用软件漏洞，而是会提示用户允许运行嵌入的文件。我们的攻击成功与否取决于用户是否允许执行我们嵌入的可执行文件。
- en: Example 10-13. PDF embedded EXE module
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-13. PDF嵌入的EXE模块
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The module lets us specify a prebuilt executable file with the `EXENAME` ❶ option.
    If we don’t set this option, we can embed an .*exe* file created from whatever
    payload we select. We can again change the filename to anything we like or leave
    the value as the default ❷. To use this module, we must use an input PDF for the
    `INFILENAME` ❸ option. The `LAUNCH_MESSAGE` ❹ option is the text that will be
    shown to the user as part of the prompt to run the executable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块允许我们通过`EXENAME` ❶选项指定一个预构建的可执行文件。如果我们不设置此选项，我们可以嵌入一个从我们选择的任何有效载荷创建的.*exe*文件。我们还可以将文件名更改为任何我们喜欢的名字，或者保持默认值
    ❷不变。要使用此模块，我们必须使用一个输入PDF来设置`INFILENAME` ❸选项。`LAUNCH_MESSAGE` ❹选项是将显示给用户的文本，作为运行可执行文件的提示。
- en: Set the relevant options, as shown in [Example 10-14](ch10.xhtml#setting_module_options_and_creating_the
    "Example 10-14. Setting module options and creating the malicious PDF").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 设置相关选项，如[示例10-14](ch10.xhtml#setting_module_options_and_creating_the "示例10-14.
    设置模块选项并创建恶意PDF")所示。
- en: Example 10-14. Setting module options and creating the malicious PDF
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-14. 设置模块选项并创建恶意PDF
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’ll use a PDF included with Kali Linux for our example: the Metasploit user
    guide at */user/share/set/readme/User_Manual.pdf* ❶. The generated PDF is again
    stored in the */root/msf4/local/* directory ❷. (Be sure to set up a handler for
    the payload with the *multi/handler* module before opening the PDF on the Windows
    XP target. For a refresher, see [Example 10-11](ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha
    "Example 10-11. Serving the malicious PDF and using a handler").)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Kali Linux附带的PDF作为示例：Metasploit用户指南，位于*/user/share/set/readme/User_Manual.pdf*
    ❶。生成的PDF将再次存储在*/root/msf4/local/*目录中 ❷。（在Windows XP目标上打开PDF之前，请确保使用*multi/handler*模块设置好负载处理程序。若需要复习，请参见[示例10-11](ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha
    "示例10-11. 提供恶意PDF并使用处理程序")。）
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The previous exploit may have left Adobe Reader in a bad state, so you may need
    to restart Windows XP to get it to properly load the new PDF.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的漏洞利用可能已将Adobe Reader置于不良状态，因此你可能需要重启Windows XP，以便它正确加载新的PDF。
- en: When the malicious PDF is opened, the user sees a warning like the one shown
    in [Figure 10-1](ch10.xhtml#pdf_embedded_executable_user_warning "Figure 10-1. PDF
    embedded executable user warning"). The user must click Open for the embedded
    executable to run. This attack depends on users being willing to click through
    this warning.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意PDF被打开时，用户会看到类似[图10-1](ch10.xhtml#pdf_embedded_executable_user_warning "图10-1.
    PDF嵌入式可执行文件用户警告")所示的警告。用户必须点击“打开”以便嵌入的可执行文件运行。此攻击依赖于用户愿意点击此警告。
- en: '![PDF embedded executable user warning](httpatomoreillycomsourcenostarchimages2030396.png.jpg)Figure 10-1. PDF
    embedded executable user warning'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![PDF嵌入式可执行文件用户警告](httpatomoreillycomsourcenostarchimages2030396.png.jpg)图10-1.
    PDF嵌入式可执行文件用户警告'
- en: Once you click Open in the PDF warning, the payload will run, and you will receive
    a session.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击PDF警告中的“打开”选项，负载将会运行，你将收到一个会话。
- en: Java Exploits
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java漏洞利用
- en: Java vulnerabilities are a prevalent client-side attack vector. In fact, some
    experts suggest that in light of the security issues that plague Java, users should
    uninstall or disable the software in their browsers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Java漏洞是一个普遍存在的客户端攻击向量。事实上，一些专家建议，鉴于Java所面临的安全问题，用户应该卸载或禁用浏览器中的Java软件。
- en: One thing that makes Java attacks so powerful is that one exploit can gain access
    to multiple platforms. Windows, Mac, and even Linux systems running the Java Runtime
    Environment (JRE) in a browser can all be exploited by exactly the same exploit
    when that browser opens a malicious page. Here are some sample exploits.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Java攻击如此强大的原因之一是，一个漏洞利用可以访问多个平台。运行Java运行时环境（JRE）的Windows、Mac，甚至是Linux系统，只要浏览器打开恶意页面，都可能受到同一漏洞的攻击。以下是一些漏洞利用示例。
- en: Java Vulnerability
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Java漏洞
- en: As exhibit number one, we’ll use the Metasploit module *exploit/multi/browser/java_jre17_jmxbean*,
    as shown in [Example 10-15](ch10.xhtml#setting_up_a_java_exploit "Example 10-15. Setting
    up a Java exploit"). Use of this module is similar to that of the Internet Explorer
    Aurora exploit shown earlier in this chapter. Metasploit sets up a malicious server
    to exploit this cross-platform vulnerability on any browser that arrives at the
    page. Any browser running Java version 7 before update 11 is affected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个示例，我们将使用Metasploit模块*exploit/multi/browser/java_jre17_jmxbean*，如[示例10-15](ch10.xhtml#setting_up_a_java_exploit
    "示例10-15. 设置Java漏洞利用")所示。使用此模块与本章早些时候展示的Internet Explorer Aurora漏洞利用类似。Metasploit设置一个恶意服务器，利用此跨平台漏洞攻击任何到达该页面的浏览器。所有运行Java
    7版本（更新11之前）的浏览器都会受到影响。
- en: Example 10-15. Setting up a Java exploit
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-15. 设置 Java 漏洞利用
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Set the options to match your environment. Set the `SRVHOST` option to the local
    IP address, and change the `SRVPORT`, if you would like. Set the `URIPATH` to
    something that will be easy to type in your target browser.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 设置选项以匹配你的环境。将 `SRVHOST` 选项设置为本地 IP 地址，并根据需要更改 `SRVPORT`。将 `URIPATH` 设置为目标浏览器中易于输入的路径。
- en: Notice that because this exploit is multi-platform and the code execution takes
    place entirely inside the JRE, our payload options are Java-based. The usual suspects
    are all here, from staged payloads, inline payloads, bind shells, reverse shells,
    Meterpreter, and so on, as shown in the list of payloads at ❶. We’ll use the payload
    *java/meterpreter/reverse_http*, which uses legitimate HTTP traffic ❷. Its options
    are shown in [Example 10-16](ch10.xhtml#exploiting_a_java_vulnerability_with_an
    "Example 10-16. Exploiting a Java vulnerability with an HTTP payload").
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于这个漏洞利用是多平台的，且代码执行完全在 JRE 内部进行，因此我们的有效载荷选项是基于 Java 的。常见的选项都在这里，包括分阶段有效载荷、内联有效载荷、绑定
    shell、反向 shell、Meterpreter 等，正如 ❶ 所示的有效载荷列表所示。我们将使用有效载荷 *java/meterpreter/reverse_http*，它使用合法的
    HTTP 流量 ❷。其选项如[示例 10-16](ch10.xhtml#exploiting_a_java_vulnerability_with_an "示例
    10-16. 使用 HTTP 有效载荷利用 Java 漏洞")所示。
- en: Example 10-16. Exploiting a Java vulnerability with an HTTP payload
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-16. 使用 HTTP 有效载荷利用 Java 漏洞
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These options should look familiar. The default `LPORT` option is now 8080 instead
    of 4444\. Notice that both `SRVPORT` and `LPORT` default to 8080, so we’ll need
    to change at least one of them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项应该很熟悉。默认的 `LPORT` 选项现在是 8080，而不是 4444。请注意，`SRVPORT` 和 `LPORT` 都默认为 8080，所以我们需要至少更改其中一个。
- en: After you’ve finished setting options, start the exploit server and browse to
    the malicious page from your Windows 7 target. Either Internet Explorer or Mozilla
    Firefox will fall victim to this attack as long as you have enabled the vulnerable
    Java browser plugin.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 完成选项设置后，启动漏洞利用服务器，并从你的 Windows 7 目标机器上浏览恶意页面。只要启用了易受攻击的 Java 浏览器插件，Internet
    Explorer 或 Mozilla Firefox 都会成为此攻击的受害者。
- en: One of the great features of the HTTP and HTTPS Meterpreter payloads, aside
    from being legitimate HTTP and HTTPS traffic and thus by-passing even some traffic-inspecting
    filters, is their ability to reattach to a dropped session. (Network problems
    can cause sessions to spontaneously die—a big annoyance for pentesters.) We’ll
    examine other ways to gain persistent access in [Chapter 13](ch13.xhtml "Chapter 13. Post
    Exploitation"), but for now let’s detach our Meterpreter session, as shown in
    [Example 10-17](ch10.xhtml#detaching_the_http_meterpreter_session "Example 10-17. Detaching
    the HTTP Meterpreter session").
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 和 HTTPS Meterpreter 有效载荷的一个大特点是，除了它们是合法的 HTTP 和 HTTPS 流量，因而能够绕过一些流量检查过滤器外，它们还能够重新连接到断开的会话。（网络问题可能导致会话自发中断——这对于渗透测试人员来说是一个大麻烦。）我们将在[第
    13 章](ch13.xhtml "第 13 章. 后期利用")中探讨其他持续访问的方法，但现在我们先来分离 Meterpreter 会话，如[示例 10-17](ch10.xhtml#detaching_the_http_meterpreter_session
    "示例 10-17. 分离 HTTP Meterpreter 会话")所示。
- en: Example 10-17. Detaching the HTTP Meterpreter session
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-17. 分离 HTTP Meterpreter 会话
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the handler for the HTTP Meterpreter payload is still running
    in the background. Wait a few seconds, and you should see a new session open without
    the user needing to revisit the attack page as shown at ❶. Unless the session
    has been formally exited, the payload will continue to try to connect back to
    Metasploit. (You can specify how long the session tries to reconnect with the
    `SessionCommunicationTimeOut` parameter, an advanced option for the payload.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，HTTP Meterpreter 有效载荷的处理程序仍在后台运行。稍等几秒钟，你应该能看到一个新会话自动打开，而无需用户重新访问攻击页面，如
    ❶ 所示。除非会话已正式退出，否则有效载荷会继续尝试重新连接 Metasploit。（你可以使用 `SessionCommunicationTimeOut`
    参数指定会话尝试重新连接的时间，这是有效载荷的高级选项。）
- en: But what if your pentest target is diligent in updating Java, and there are
    currently no zero-days for the software floating around the Internet?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你的渗透测试目标在更新 Java 方面非常勤奋，并且目前互联网上没有针对该软件的零日漏洞会怎么样呢？
- en: Signed Java Applet
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 签名的 Java Applet
- en: Much like the attack against PDF users discussed in [PDF Embedded Executable](ch10.xhtml#pdf_embedded_executable
    "PDF Embedded Executable"), we can bypass the need for an unpatched Java vulnerability
    by simply asking users to allow us to run malicious code. You’ve probably seen
    browser warnings like, “This site would like to run this thing in your browser,
    how would you like to proceed?” Sometimes even security-savvy users can be convinced
    to just say “Yes” and bypass this warning without further investigation if they
    can be convinced that what’s on the other side is useful.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与[PDF嵌入式可执行文件](ch10.xhtml#pdf_embedded_executable "PDF嵌入式可执行文件")中讨论的针对PDF用户的攻击类似，我们可以通过简单地要求用户允许我们运行恶意代码来绕过未修补的Java漏洞。你可能见过类似这样的浏览器警告：“此站点希望在您的浏览器中运行此内容，您希望如何操作？”有时即便是安全意识强的用户，如果被说服认为对方内容有用，他们也可能会直接点击“是”并跳过警告，而不做进一步调查。
- en: The module we’ll use for this example is *exploit/multi/browser/java_signed_applet*.
    As the name implies, this module will create a malicious Java applet, as shown
    in [Example 10-18](ch10.xhtml#metasploit_signed_java_applet_module "Example 10-18. Metasploit
    signed Java applet module").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中我们将使用的模块是*exploit/multi/browser/java_signed_applet*。顾名思义，该模块将创建一个恶意的Java小程序，如[示例10-18](ch10.xhtml#metasploit_signed_java_applet_module
    "示例10-18. Metasploit签名的Java小程序模块")所示。
- en: Example 10-18. Metasploit signed Java applet module
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-18. Metasploit签名的Java小程序模块
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Older versions of Java will allow us to use the `CERTCN` option shown at ❶ to
    say that the applet is signed by any entity that we choose. Newer versions of
    Java, like the one installed on the Windows 7 target, will say that the signer
    is unknown unless we sign the applet with a trusted signing certificate, which
    we can specify at ❷. If this option is set, it will override the `CERTCN` option.
    If we have a trusted signing certificate or we’ve compromised a certificate from
    our target, we can make our applet look more legitimate, but we’ll leave our applet
    self-signed for this example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的Java允许我们使用❶所示的`CERTCN`选项，声明小程序由我们选择的任何实体签名。较新的Java版本（如Windows 7目标系统上安装的版本）会显示签名者未知，除非我们使用受信任的签名证书对小程序进行签名，而我们可以在❷处指定该证书。如果设置了此选项，它将覆盖`CERTCN`选项。如果我们拥有受信任的签名证书，或者我们已经突破了目标系统的证书，我们可以让小程序看起来更合法，但在本示例中我们将保持小程序自签名。
- en: As shown at ❸, the default target for this module is a Windows system. However,
    as shown in [Example 10-19](ch10.xhtml#using_a_java_payload "Example 10-19. Using
    a Java payload"), we can use payloads for other platforms running JRE.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如❸所示，本模块的默认目标是Windows系统。然而，如[示例10-19](ch10.xhtml#using_a_java_payload "示例10-19.
    使用Java有效载荷")所示，我们可以使用适用于运行JRE的其他平台的有效载荷。
- en: Example 10-19. Using a Java payload
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-19. 使用Java有效载荷
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As with other Java exploits, we can make this attack multi-platform. We can
    change the target to Linux or Mac OS, or use a Java payload ❶ that will target
    them all.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Java漏洞一样，我们可以将此攻击扩展到多个平台。我们可以将目标更改为Linux或Mac OS，或使用一个Java有效载荷❶来同时针对所有平台。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with our PDF examples, the previous exploit has left Java in a bad state,
    and you may need to restart Windows 7 before attempting to run the applet.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的PDF示例类似，之前的漏洞攻击已使Java处于不良状态，您可能需要在尝试运行小程序之前重新启动Windows 7。
- en: Browse to the Metasploit server from your Windows 7 target, and you should be
    prompted to run the applet, as shown in [Figure 10-2](ch10.xhtml#java_applet_attack
    "Figure 10-2. Java applet attack"). The security warning informs you that if this
    applet is malicious, it will have access to the system and lets you know you should
    run the application only if the publisher is trusted. Because we didn’t use a
    signing certificate that is trusted by the browser certificate chain, the warning
    says in big letters that the publisher is unknown. This should stop anyone from
    running the malicious applet, right?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的Windows 7目标系统浏览到Metasploit服务器，您应该会被提示运行小程序，如[图10-2](ch10.xhtml#java_applet_attack
    "图10-2. Java小程序攻击")所示。安全警告提醒您，如果该小程序是恶意的，它将能够访问系统，并告知您仅在发布者受信的情况下才应运行该应用程序。由于我们没有使用浏览器证书链信任的签名证书，警告会以大字显示发布者未知。这应该会阻止任何人运行恶意小程序，对吧？
- en: '![Java applet attack](httpatomoreillycomsourcenostarchimages2030398.png.jpg)Figure 10-2. Java
    applet attack'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![Java小程序攻击](httpatomoreillycomsourcenostarchimages2030398.png.jpg)图10-2. Java小程序攻击'
- en: Despite the warnings, the Social-Engineer Toolkit (which we’ll explore in the
    next chapter) claims that this attack is one of the most successful of the many
    available, even though it doesn’t rely on any unpatched vulnerability in Java
    or the underlying operating system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有警告，Social-Engineer Toolkit（我们将在下一章中探讨）声称这个攻击是所有可用攻击中最成功的之一，尽管它不依赖于Java或底层操作系统中的任何未修补的漏洞。
- en: browser_autopwn
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: browser_autopwn
- en: The *browser_autopwn* module is another client-side exploitation option available
    in Metasploit. Although it’s sometimes considered cheating, this module loads
    all the browser and browser add-on modules that it knows of (including Java, Flash,
    and so on) and waits for a browser to connect to the server. Once the browser
    connects, the server fingerprints the browser and serves up all the exploits it
    thinks are likely to succeed. An example is shown in [Example 10-20](ch10.xhtml#starting_browserunderscoreautopwn
    "Example 10-20. Starting browser_autopwn").
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*browser_autopwn*模块是Metasploit中另一种客户端攻击选项。尽管有时它被认为是在作弊，但该模块会加载它知道的所有浏览器和浏览器插件模块（包括Java、Flash等），并等待浏览器连接到服务器。一旦浏览器连接，服务器会识别浏览器并提供所有它认为可能成功的漏洞利用。示例见[示例
    10-20](ch10.xhtml#starting_browserunderscoreautopwn "示例 10-20. 启动 browser_autopwn")。'
- en: Example 10-20. Starting browser_autopwn
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-20. 启动 browser_autopwn
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our options for this module are the usual client-side attacks. As shown here,
    I’ve set the LHOST for my shells to call back to Kali’s IP address, and URIPATH
    to something easy to remember (`autopwn`). Note that we don’t need to set any
    payloads here; as the individual modules are loaded, Metasploit sets the payload
    options appropriately.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块的选项是常见的客户端攻击。如图所示，我已经将我的shell的LHOST设置为Kali的IP地址，URIPATH设置为容易记住的内容（`autopwn`）。请注意，我们这里不需要设置任何payload；当各个模块加载时，Metasploit会自动适当地设置payload选项。
- en: With the server started, browse to the malicious page from a web browser. I
    used Internet Explorer on my Windows 7 target as shown in [Example 10-21](ch10.xhtml#autopwning_a_browser
    "Example 10-21. Autopwning a browser").
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动后，从网页浏览器访问恶意页面。我在Windows 7目标上使用了Internet Explorer，如[示例 10-21](ch10.xhtml#autopwning_a_browser
    "示例 10-21. 自动攻陷浏览器")所示。
- en: Example 10-21. Autopwning a browser
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-21. 自动攻陷浏览器
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see Metasploit notices my browser and attempts to detect its version
    and running software ❶. It then sends all the exploits it thinks might be effective
    ❷.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Metasploit会检测到我的浏览器并尝试识别其版本和运行的软件❶。然后，它会发送所有它认为可能有效的漏洞利用❷。
- en: Once all is said and done, run **`sessions -l`** to see how things turned out.
    In my case, I received four new sessions. Not bad for so little work. As you might
    expect though, all of those exploits overwhelmed the browser and it crashed. (Luckily,
    all of our sessions were automatically migrated.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一切结束后，运行**`sessions -l`**来查看结果。在我的案例中，我收到了四个新的会话。对于这么少的工作量来说，表现不错。不过，正如你可能预期的那样，所有这些漏洞利用使浏览器过载并崩溃了。（幸运的是，所有会话都自动迁移了。）
- en: Though *browser_autopwn* is not nearly as stealthy or elegant as performing
    reconnaissance and then choosing a particular exploit likely to work against a
    target, it can be a real help in a pinch, which is why it’s worth having in your
    pentesting arsenal.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*browser_autopwn*远没有执行侦察然后选择针对目标可能有效的特定漏洞利用那样隐蔽或优雅，但它在紧急情况下确实能派上大用场，这也是它值得作为渗透测试工具包的一部分的原因。
- en: Winamp
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Winamp
- en: So far our client-side attacks have basically followed the same pattern. We
    generate a malicious file that exploits a vulnerability in the client software
    or prompts the user for permission to run malicious code. The user opens the file
    with the relevant program, and we get a session in Metasploit. Now for something
    a bit different.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的客户端攻击基本上遵循相同的模式。我们生成一个恶意文件，利用客户端软件中的漏洞，或者提示用户授权运行恶意代码。用户使用相关程序打开文件，然后我们在Metasploit中获得一个会话。现在，来点不一样的。
- en: In this example, we trick the user into replacing a configuration file for the
    Winamp music player program. When the user next opens the program, the evil configuration
    file will be processed regardless of which music file the user opens. The Metasploit
    module we’ll use is *exploit/windows/fileformat/winamp_maki_bof*, which exploits
    a buffer overflow issue in Winamp version 5.55.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过欺骗用户替换Winamp音乐播放器的配置文件。当用户下次打开该程序时，无论用户打开哪个音乐文件，恶意的配置文件都会被处理。我们将使用的Metasploit模块是*exploit/windows/fileformat/winamp_maki_bof*，它利用了Winamp
    5.55版本中的一个缓冲区溢出问题。
- en: As you can see with `show options` in [Example 10-22](ch10.xhtml#metasploit_winamp_exploit
    "Example 10-22. Metasploit Winamp exploit"), this module has no options to set;
    all we need is a Windows payload. The module generates a malicious Maki file for
    use with Winamp skins. As with our PDF examples, it’s up to us to serve the file
    and set up a handler for the payload.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 10-22](ch10.xhtml#metasploit_winamp_exploit "示例 10-22. Metasploit Winamp
    漏洞利用")中的 `show options` 所示，本模块没有需要设置的选项；我们所需的只是一个 Windows 有效载荷。该模块生成一个用于 Winamp
    皮肤的恶意 Maki 文件。与我们的 PDF 示例一样，最终由我们来提供该文件并为有效载荷设置处理程序。
- en: Example 10-22. Metasploit Winamp exploit
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-22. Metasploit Winamp 漏洞利用
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Choose a compatible Windows payload as shown. Once the malicious Maki file has
    been generated, copy it to the Apache web server directory, and set up a payload
    handler. (An example of setting up the handler is included in [Example 10-11](ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha
    "Example 10-11. Serving the malicious PDF and using a handler").) Now we need
    to package this malicious file in such a way that a user may be convinced to load
    it in Winamp. We can create a new Winamp skin by copying one of the skins packaged
    with Winamp. We can replace the *mcvcore.maki* file from our example skin with
    our malicious one. It doesn’t matter what our skin actually looks like, because
    it will cause Winamp to hang and send us our session in Metasploit.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个兼容的 Windows 有效载荷，如所示。一旦生成了恶意的 Maki 文件，将其复制到 Apache Web 服务器目录，并设置有效载荷处理程序。（设置处理程序的示例请参考[示例
    10-11](ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha "示例 10-11. 提供恶意 PDF
    并使用处理程序")）。现在我们需要将这个恶意文件打包，以便说服用户在 Winamp 中加载它。我们可以通过复制 Winamp 打包的皮肤之一来创建一个新的
    Winamp 皮肤。然后将我们示例皮肤中的 *mcvcore.maki* 文件替换为我们恶意的文件。皮肤的外观无关紧要，因为它会导致 Winamp 崩溃并将会话发送到我们的
    Metasploit 中。
- en: In Windows 7, make a copy of the default Bento Winamp skin folder from *C:\Program
    Files\Winamp\Skins* and copy it to Kali. Rename the folder *Bento* to *Rocketship*.
    Replace the file *Rocketship\scripts\mcvcore.maki* with the malicious file we
    just created in Metasploit. Zip the folder and copy it to the web server. In the
    next chapter we will look at methods of creating believable social-engineering
    campaigns, but suffice it to say, if we can convince users that this malicious
    skin will make their Winamp look like a rocket ship, we might be able to convince
    users to install it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 7 中，复制默认的 Bento Winamp 皮肤文件夹（路径为 *C:\Program Files\Winamp\Skins*），并将其复制到
    Kali 中。将文件夹名称从 *Bento* 重命名为 *Rocketship*。将 *Rocketship\scripts\mcvcore.maki* 文件替换为我们在
    Metasploit 中创建的恶意文件。将文件夹压缩并复制到 Web 服务器中。在下一章中，我们将研究如何创建可信的社会工程学攻击，但可以简单地说，如果我们能够说服用户相信这个恶意皮肤会让他们的
    Winamp 看起来像火箭船，那么我们可能能够说服他们安装它。
- en: Switch to Windows 7, download the zipped skin from the Kali web server, unzip
    it, and save the folder to *C:\Program Files\Winamp\Skins* as shown in [Figure 10-3](ch10.xhtml#installing_the_malicious_winamp_skin
    "Figure 10-3. Installing the malicious Winamp skin").
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 Windows 7，从 Kali Web 服务器下载压缩的皮肤，解压缩并将文件夹保存到 *C:\Program Files\Winamp\Skins*，如[图
    10-3](ch10.xhtml#installing_the_malicious_winamp_skin "图 10-3. 安装恶意 Winamp 皮肤")所示。
- en: '![Installing the malicious Winamp skin](httpatomoreillycomsourcenostarchimages2030400.png.jpg)Figure 10-3. Installing
    the malicious Winamp skin'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![安装恶意 Winamp 皮肤](httpatomoreillycomsourcenostarchimages2030400.png.jpg)图 10-3.
    安装恶意 Winamp 皮肤'
- en: Now open Winamp, go to **Options** ▸ **Skins**, and choose **Rocketship**, as
    shown in [Figure 10-4](ch10.xhtml#using_the_malicious_skin "Figure 10-4. Using
    the malicious skin").
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Winamp，进入 **选项** ▸ **皮肤**，选择 **火箭船**，如[图 10-4](ch10.xhtml#using_the_malicious_skin
    "图 10-4. 使用恶意皮肤")所示。
- en: Once you select the malicious skin, Winamp will appear to close, and you will
    receive a session in your Metasploit handler.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了恶意皮肤，Winamp 会显示关闭状态，您将会在 Metasploit 处理程序中接收到一个会话。
- en: '![Using the malicious skin](httpatomoreillycomsourcenostarchimages2030402.png.jpg)Figure 10-4. Using
    the malicious skin'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用恶意皮肤](httpatomoreillycomsourcenostarchimages2030402.png.jpg)图 10-4. 使用恶意皮肤'
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The attacks we’ve seen in this chapter target software that is not listening
    on a network port. We attacked browsers, PDF viewers, the Java browser plugin,
    and a music player. We generated malicious files that trigger a vulnerability
    in the client-side software when opened by the user, and we looked at examples
    that ask the user for permission to run malicious code instead of relying on an
    unpatched vulnerability.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们看到的攻击目标是那些未在网络端口上监听的软件下载。我们攻击了浏览器、PDF查看器、Java浏览器插件以及一个音乐播放器。我们生成了恶意文件，这些文件在用户打开时会触发客户端软件中的漏洞，我们还查看了那些要求用户授权运行恶意代码，而不是依赖未修补漏洞的例子。
- en: The Internet can be a scary place for client-side software. Some of the exploits
    discussed in this chapter were seen in the wild before a patch was issued by the
    vendors. In fact, the Java exploit we used in [Java Vulnerability](ch10.xhtml#java_vulnerability
    "Java Vulnerability") was still a zero-day vulnerability when the Metasploit module
    was added to the framework. Anyone using Java 7 could run afoul of a malicious
    site, even if his or her machine was fully patched, and all an attacker had to
    do was use Metasploit to perform a successful attack.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端软件来说，互联网可能是一个可怕的地方。本章中讨论的一些漏洞在发布厂商补丁之前，已经在野外被发现。事实上，我们在[Java漏洞](ch10.xhtml#java_vulnerability
    "Java Vulnerability")中使用的Java漏洞，在Metasploit模块加入框架时，仍然是一个零日漏洞。即便某个用户的计算机已经完全修补，如果他们使用的是Java
    7，也可能遭遇恶意网站的攻击，而攻击者所需要做的仅仅是使用Metasploit成功发动攻击。
- en: Of course, disabling or uninstalling Java fixes this problem in the event of
    a zero-day exploit running rampant on the Internet, but that might not be feasible
    for all users and organizations. Though not all sites use Java, popular online
    meeting software such as WebEx and GoToMeeting require Java, and the virtual classroom
    software Blackboard has Java components as well. A lot of network/security appliances
    actually require network/security admins to run outdated versions of Java, which
    makes them perfect targets for client-side attacks. Most readers can probably
    think of at least one site that complains if Java is not installed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在出现零日漏洞在互联网上肆虐时，禁用或卸载Java可以解决这个问题，但对于所有用户和组织来说，这可能不可行。尽管并非所有网站都使用Java，但像WebEx和GoToMeeting这样的流行在线会议软件需要Java，而虚拟课堂软件Blackboard也有Java组件。许多网络/安全设备实际上要求网络/安全管理员运行过时版本的Java，这使得它们成为客户端攻击的完美目标。大多数读者或许能想到至少一个在没有安装Java时会发出警告的网站。
- en: Client-side software is necessary to perform day-to-day tasks in any organization,
    but this software should not be overlooked when evaluating security risks. Keeping
    all client-side software up-to-date with the latest patches can be a daunting
    task on your personal computer, much less on the computers of an entire organization.
    Even organizations that are doing a good job of applying important Windows security
    fixes may miss an update to Java or Adobe Reader and leave company workstations
    open to client-side attacks.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端软件对于任何组织的日常工作是必需的，但在评估安全风险时，不应忽视这些软件。保持所有客户端软件更新到最新的补丁版本，可能在个人计算机上已经是一个令人头疼的任务，更不用说整个组织的计算机了。即使一些组织在应用重要的Windows安全修复方面做得很好，也可能错过Java或Adobe
    Reader的更新，从而使公司工作站暴露于客户端攻击之下。
- en: All of the attacks in this chapter depend on a legitimate user taking action
    on the target systems. Although we’ve seen what can happen when users are tricked
    into opening malicious files, we’ve yet to look at the tricks used to make people
    open those files. In the next chapter we’ll study social engineering—that is,
    ways of tricking users into performing harmful actions such as opening a malicious
    file, entering credentials into an attacker-owned site, or giving out sensitive
    information over the phone.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有攻击都依赖于合法用户在目标系统上采取行动。虽然我们已经看到用户被欺骗打开恶意文件后可能发生的情况，但我们尚未深入探讨使人们打开这些文件的技巧。在下一章中，我们将研究社会工程学——即欺骗用户执行有害行为的方式，比如打开恶意文件、将凭据输入到攻击者控制的网站，或通过电话泄露敏感信息。
