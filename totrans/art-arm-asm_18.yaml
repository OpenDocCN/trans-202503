- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 15 MANAGING COMPLEX PROJECTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15 管理复杂项目
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Most assembly language source files are not stand-alone programs. In general,
    you must call various standard library or other routines that are not defined
    in your main program because attempting to write such code as part of your application
    would be far too much work (and poor programming practice).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数汇编语言源文件并不是独立的程序。通常，你必须调用各种标准库或其他例程，而这些例程并未在你的主程序中定义，因为试图将这样的代码写入你的应用程序中会工作量过大（而且是糟糕的编程实践）。
- en: For example, the ARM doesn’t provide machine instructions like read, write,
    or put for doing I/O operations. The functions in this book contain thousands
    of lines of source code to accomplish these operations. For small programs, working
    with a single source file is fine, but for large programs, this gets cumbersome.
    Programming would be formidable if you had to merge these thousands of lines of
    code into your simple programs, which would then compile slowly. Furthermore,
    once you’ve debugged and tested a large section of your code, continuing to assemble
    that same code when you make a small change to another part of your program is
    a waste of time. Imagine having to wait 20 or 30 minutes on a fast PC to assemble
    a program after making a one-line change!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，ARM 并没有提供像读、写或放置等用于 I/O 操作的机器指令。本书中的函数包含了成千上万行的源代码来完成这些操作。对于小程序，使用单个源文件没有问题，但对于大型程序来说，这就变得很繁琐。如果你必须将成千上万行代码合并到你的简单程序中，这将使编程变得相当困难，而且编译速度也会变得很慢。此外，一旦你调试并测试了程序的一个大型部分，在对程序的其他部分进行小改动时，还需要重新组装这部分代码，简直是浪费时间。试想一下，在一台快速的
    PC 上，仅仅做了一行代码的修改后，你可能要等 20 或 30 分钟才能重新组装程序！
- en: '*Programming in the large* is the term software engineers have coined to describe
    the processes, methodologies, and tools for reducing the development time of large
    software projects. While everyone has their own idea of what “large” is, *separate
    compilation* is one of the more popular techniques that support programming in
    the large. First, you break your large source files into manageable chunks. Then
    you compile the separate files into object code modules. Finally, you link the
    object modules together to form a complete program. If you need to make a small
    change to one of the modules, you need to reassemble only that one module rather
    than the entire program.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*大型编程*是软件工程师用来描述减少大型软件项目开发时间的过程、方法和工具的术语。虽然每个人对“庞大”的定义不同，*分离编译*是支持大型编程的更流行技术之一。首先，你将大型源文件拆分成可管理的块。然后你将单独的文件编译成目标代码模块。最后，你将目标模块链接在一起形成完整的程序。如果你需要对其中一个模块进行小改动，你只需要重新组装那个模块，而不是整个程序。'
- en: This chapter describes the tools that Gas and your OS provide for separate compilation
    and how to effectively employ these tools in your programs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 Gas 和操作系统提供的分离编译工具，以及如何有效地在程序中使用这些工具。
- en: 15.1 The .include Directive
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1 .include 指令
- en: The .include directive, when encountered in a source file, switches program
    input from the current file to the file specified in the operand field of the
    include directive. Section 1.5, “The *aoaa.inc* Include File,” on [page 10](chapter1.xhtml#pg_10)
    described the .include directive as a way to include code from separate source
    files into the current assembly, allowing you to construct text files containing
    common constants, types, source code, and other Gas items into the assembly. As
    noted in that section, the syntax for the .include directive is
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: .include 指令在源文件中出现时，会将程序输入从当前文件切换到 .include 指令操作数字字段中指定的文件。第 1.5 节，“*aoaa.inc*
    包含文件”，在 [第 10 页](chapter1.xhtml#pg_10) 中描述了 .include 指令，它允许你将来自不同源文件的代码包含到当前汇编中，从而构建包含公共常量、类型、源代码和其他
    Gas 项目的文本文件。正如该节中所提到的，.include 指令的语法是：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where filename must be a valid filename.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，文件名必须是一个有效的文件名。
- en: By this book’s convention, Gas include files have a *.inc* (include) suffix.
    Gas, however, does not require include files to have this suffix; any filename
    containing Gas assembly language source will work. Gas merges the specified file
    into the compilation at the point of the .include directive. You can nest .include
    statements inside files you include; that is, a file being included into another
    file during assembly may itself include a third file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本书的约定，Gas 包含文件有 *.inc*（包含）后缀。然而，Gas 并不要求包含文件必须有这个后缀；任何包含 Gas 汇编语言源代码的文件名都可以使用。Gas
    会在 .include 指令的位置将指定的文件合并到编译过程中。你可以在包含的文件中嵌套 .include 语句；也就是说，在汇编过程中被包含进另一个文件的文件可以再包含第三个文件。
- en: 'Using the .include directive by itself does not provide separate compilation.
    You *could* use .include to break up a large source file into separate modules
    and join these modules together when you compile your file. The following example
    would include the *print.inc* and *getTitle.inc* files during the compilation
    of your program:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用 .include 指令并不会提供独立编译。你*可以*使用 .include 将一个大源文件拆分成多个模块，在编译时将这些模块合并。以下示例将在编译程序时包含
    *print.inc* 和 *getTitle.inc* 文件：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your program will now benefit from modularity. Alas, you will not save any development
    time. The .include directive inserts the source file at the point of the .include
    during compilation, exactly as though you had typed that code yourself. Gas still
    has to compile the code, and that takes time. If you are including a large number
    of source files (such as a huge library) into your assembly, the compilation process
    could take *forever*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的程序将从模块化中受益。遗憾的是，你并不会节省任何开发时间。 .include 指令会在编译时将源文件插入到 .include 的位置，正如你亲自输入了这些代码一样。Gas
    仍然需要编译代码，而这需要时间。如果你要将大量源文件（比如一个庞大的库）包含到你的汇编中，编译过程可能需要*永远*。
- en: In general, you should *not* use the .include directive to include source code
    as shown in the previous example, as this code won’t allow you to take advantage
    of separate compilation. Instead, use the .include directive to insert a common
    set of constants, types, external procedure declarations, and other such items
    into a program. Typically, an assembly language include file does *not* contain
    any machine code (outside of a macro; see [Chapter 13](chapter13.xhtml) for details).
    The purpose of using .include files in this manner will become clearer after you
    see how the external declarations work (see section 15.3, “Assembly Units and
    External Directives,” on the next page).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你*不应该*使用 .include 指令来包含源代码，如前面的示例所示，因为这样做的代码无法利用独立编译。相反，应该使用 .include
    指令将一组公共常量、类型、外部过程声明及其他类似项目插入到程序中。通常，汇编语言的包含文件*不包含*任何机器代码（宏之外；有关详细信息，请参见[第13章](chapter13.xhtml)）。以这种方式使用
    .include 文件的目的将在你看到外部声明如何工作后变得更加清晰（请参见下一页第15.3节，“汇编单元与外部指令”）。
- en: 'If your assembly language source files have a *.S* suffix, you can also use
    the #include "filename" directive to include a source file. This is generally
    preferable because you can use the CPP directives in such include files (you can’t
    in a standard .include file). The rest of this chapter assumes the use of the
    #include directive rather than .include.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你的汇编语言源文件有 *.S* 后缀，你也可以使用 #include "filename" 指令来包含源文件。这通常更可取，因为你可以在这样的包含文件中使用
    CPP 指令（而在标准 .include 文件中无法使用）。本章的其余部分假定使用 #include 指令，而不是 .include。'
- en: 15.2 Ignoring Duplicate Include Operations
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2 忽略重复的包含操作
- en: 'As you begin to develop sophisticated modules and libraries, you will eventually
    discover a big problem: some header files need to include other header files.
    Technically, this is fine in and of itself, but issues arise when one header file
    includes another, and that second header file includes another, and so on, such
    that the final header file includes the first header file.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始开发复杂的模块和库时，最终你会发现一个大问题：有些头文件需要包含其他头文件。技术上来说，这本身并没有问题，但问题出现在一个头文件包含了另一个头文件，而那个第二个头文件又包含了另一个头文件，依此类推，最终导致最后一个头文件又包含了第一个头文件。
- en: There are two problems with a header file indirectly including itself. First,
    this creates an infinite loop in the compiler. The compiler will happily go on
    about its business including all these files over and over again until it runs
    out of memory or another error occurs. Second, when Gas includes a header file
    for the second time, it starts complaining bitterly about duplicate symbol definitions.
    After all, the first time it reads the header file, it processes all the declarations
    in that file; the second time around, it views all those symbols as duplicate
    symbols.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件间接包含自身有两个问题。首先，这会在编译器中创建一个无限循环。编译器会不断地重复包含这些文件，直到内存耗尽或发生其他错误。其次，当Gas第二次包含头文件时，它会开始对重复的符号定义进行强烈抱怨。毕竟，第一次读取头文件时，它处理了文件中的所有声明；第二次读取时，它将所有这些符号视为重复符号。
- en: 'The standard technique for resolving recursively included files, well-known
    to C/C++ programmers, is to use conditional assembly to have Gas ignore the content
    of an include file. (See [Chapter 13](chapter13.xhtml) for a discussion of conditional
    assembly for CPP and the Gas CTL.) The trick is to place an #ifdef (if defined)
    statement around all statements in the include file. Specify an undefined symbol
    as the #ifdef operand (I tend to use the include file’s filename, substituting
    underlines for periods). Then, immediately after the #ifdef statement, define
    that symbol; using a numeric equate and assigning the symbol the constant 1 is
    typical. Here’s an example of this #ifdef usage in action:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决递归包含文件的标准技术，是使用条件汇编让Gas忽略包含文件的内容，这一点C/C++程序员十分熟悉。（请参见[第13章](chapter13.xhtml)，了解有关CPP和Gas
    CTL的条件汇编讨论。）技巧是将一个#ifdef（如果已定义）语句放在包含文件的所有语句周围。指定一个未定义的符号作为#ifdef操作数（我通常使用包含文件的文件名，将句点替换为下划线）。然后，在#ifdef语句之后立即定义该符号；通常使用数字等式，并将符号赋值为常量1。以下是该#ifdef用法的一个示例：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you attempt to include *myinclude.inc* a second time, the #ifdef directive
    will cause Gas (actually, the CPP) to skip over all the text up to the corresponding
    #endif directive, thus avoiding the duplicate definition errors.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试第二次包含*myinclude.inc*，#ifdef指令将导致Gas（实际上是CPP）跳过所有文本，直到对应的#endif指令，从而避免重复定义错误。
- en: 15.3 Assembly Units and External Directives
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3 汇编单元与外部指令
- en: An *assembly unit* is the assembly of a source file plus any files it directly
    or indirectly includes. An assembly unit produces a single *.o* (object) file
    after assembly. The linker takes multiple object files (produced by Gas or other
    compilers, such as GCC) and combines those object files into a single executable
    file. The main purpose of this section, and, indeed, this whole chapter, is to
    describe how these assembly units (*.o* files) communicate linkage information
    to one another during the linking process. Assembly units are the basis for creating
    modular programs in assembly language.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*汇编单元*是源文件及其直接或间接包含的任何文件的集合。一个汇编单元在汇编后生成一个单独的*.o*（目标）文件。链接器将多个目标文件（由Gas或其他编译器，如GCC生成）合并为一个可执行文件。本节的主要目的，实际上也是整章的目的，是描述这些汇编单元（*.o*文件）在链接过程中如何相互传递链接信息。汇编单元是创建汇编语言模块化程序的基础。'
- en: To use Gas’s assembly unit facilities, you must create at least two source files.
    One file contains a set of variables and procedures used by the second. The second
    file uses those variables and procedures without knowing how they’re implemented.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Gas的汇编单元功能，你必须创建至少两个源文件。一个文件包含第二个文件使用的一组变量和过程。第二个文件使用这些变量和过程，而无需知道它们是如何实现的。
- en: 'Technically, the #include directive provides you with all the facilities you
    need to create such modular programs. You can create several modules, each containing
    a specific routine, and include those modules, as necessary, in your assembly
    language programs by using the #include directive. However, if you use this method,
    including a routine you’ve debugged in a compilation will still waste time because
    Gas must recompile bug-free code whenever you assemble the main program. A much
    better solution is to preassemble the debugged modules and link the object code
    modules together, using Gas’s .global and .extern directives, which this section
    covers.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，#include指令为您提供了创建此类模块化程序所需的所有功能。您可以创建多个模块，每个模块包含一个特定的例程，并通过使用#include指令根据需要将这些模块包含到您的汇编语言程序中。然而，如果您使用这种方法，在编译时包含一个已调试的例程仍然会浪费时间，因为每当您汇编主程序时，Gas都必须重新编译无错误的代码。一个更好的解决方案是预先汇编已调试的模块，并将目标代码模块链接在一起，使用Gas的.global和.extern指令，本节将介绍这些内容。
- en: 'All the programs appearing in this book up to this point have been separately
    assembled modules that happen to link with a C/C++ main program rather than another
    assembly language module. In every program thus far, the assembly language “main
    program” has been named asmMain, which is nothing but a C++-compatible function
    that the generic *c.cpp* program has called from its main program. For example,
    consider the body of asmMain from Listing 1-3 on [page 9](chapter1.xhtml#pg_9)
    (for Linux and Pi OS systems):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书到目前为止出现的所有程序都是独立的模块，这些模块链接到一个C/C++主程序，而不是另一个汇编语言模块。在每个程序中，汇编语言的“主程序”都命名为asmMain，它实际上是一个与C++兼容的函数，这个函数是由通用的*c.cpp*程序从其主程序中调用的。例如，考虑[第9页](chapter1.xhtml#pg_9)中的Listing
    1-3中的asmMain主体（适用于Linux和Pi OS系统）：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This .global asmMain statement has been included in every program that has had
    an asmMain function without any definition or explanation. It’s now time to deal
    with that oversight.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个.global asmMain语句已经包含在每个拥有asmMain函数但没有定义或解释的程序中。现在是时候处理这个疏漏了。
- en: Normal symbols in a Gas source file are *private* to that particular source
    file and are inaccessible from other source files (that don’t directly include
    the file containing those private symbols, of course). That is, the *scope* of
    most symbols in a source file is limited to those lines of code within that particular
    source file and any files it includes. The .global directive tells Gas to make
    the specified symbol *global* to the assembly unit—accessible by other assembly
    units during the link phase. By placing the .global asmFunc statement in the example
    programs appearing throughout this book, these sample programs have made the asmMain
    symbol global to the source file containing them so that the *c.cpp* program can
    call the asmMain function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Gas源文件中的普通符号对该特定源文件是*私有*的，其他源文件无法访问（当然，除非这些源文件直接包含了包含这些私有符号的文件）。也就是说，大多数符号的*作用域*仅限于该特定源文件中的代码行以及它包含的任何文件。
    .global指令告诉Gas使指定符号对汇编单元*全局*，即在链接阶段，其他汇编单元也能访问这个符号。通过在本书中的示例程序中放置.global asmFunc语句，这些示例程序使asmMain符号对包含它们的源文件全局化，以便*c.cpp*程序可以调用asmMain函数。
- en: 'As you may recall, macOS requires an underscore prefix in front of the global
    name. This means you would use .global _asmMain and _asmMain: if you wanted this
    source file to assemble under macOS. The *aoaa.inc* header file resolves this
    issue in a portable fashion, but the code from *Listing1-3.S* does not include
    *aoaa.inc*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，macOS要求全局名称前面加上下划线前缀。这意味着，如果您希望该源文件在macOS下进行汇编，您应该使用.global _asmMain和_asmMain：。*aoaa.inc*头文件以可移植的方式解决了这个问题，但*Listing1-3.S*中的代码没有包含*aoaa.inc*。
- en: 'Simply making a symbol public is insufficient to use that symbol in another
    source file. The source file that wants to use the symbol must also declare that
    symbol as *external*. This notifies the linker that it will have to patch in the
    address of a public symbol whenever the file with the external declaration uses
    that symbol. For example, the *c.cpp* source file defines the asmMain symbol as
    external in the following lines of code (for what it’s worth, this declaration
    also defines the external symbol getTitle):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅将符号设为公共是无法在另一个源文件中使用该符号的。想要使用该符号的源文件还必须声明该符号为*外部*。这会通知链接器，在外部声明的文件使用该符号时，它将需要修补公共符号的地址。例如，*c.cpp*源文件在以下代码行中将asmMain符号声明为外部（顺便提一下，这个声明也定义了外部符号getTitle）：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, readLine is actually a C++ function defined in the *c.cpp*
    source file. C/C++ does not have an explicit public declaration. Instead, if you
    supply the source code for a function in a source file that declares that function
    to be external, C/C++ will automatically make that symbol public by virtue of
    the external declaration.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，readLine 实际上是一个在 *c.cpp* 源文件中定义的 C++ 函数。C/C++ 并没有明确的公共声明。相反，如果你在源文件中提供了一个函数的源代码，并声明该函数为外部符号，C/C++
    会通过外部声明自动将该符号设置为公共符号。
- en: When you place an .extern directive in your program, Gas treats that declaration
    the same as any other symbol declaration. If the symbol already exists, Gas will
    generate a symbol redefinition error. Generally, you should place all external
    declarations near the beginning of the source file to avoid any scoping / forward
    reference issues.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在程序中放置 `.extern` 指令时，Gas 会将该声明视为任何其他符号声明。如果该符号已存在，Gas 会生成符号重定义错误。通常，你应将所有外部声明放在源文件的开头，以避免作用域/前向引用问题。
- en: Technically speaking, using the .extern directive is optional, as Gas assumes
    that any symbol you use that is not defined in a source file is an external symbol.
    The linker will report actual undefined symbols if it fails to find a symbol when
    linking in all the other object code modules. However, it is good programming
    style to explicitly define your external symbols with .extern in order to make
    your intentions clear to others reading your source code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，使用 `.extern` 指令是可选的，因为 Gas 假设你使用的任何符号如果在源文件中没有定义，都是外部符号。如果链接器在链接所有其他目标代码模块时未找到符号，它将报告实际的未定义符号。然而，显式地使用
    `.extern` 定义外部符号是良好的编程风格，可以明确表达你的意图，方便其他人阅读你的源代码。
- en: Because the .global directive does not actually define the symbol, its placement
    is not as critical as the .extern directive’s is. Some programmers put all the
    global declarations at the beginning of a source file; others put the global declaration
    right before the definition of the symbol (as I’ve done with the asmMain symbol
    in most of the same programs). Either is fine.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `.global` 指令并不会真正定义符号，所以它的位置不像 `.extern` 指令那样重要。一些程序员将所有全局声明放在源文件的开头；也有一些程序员将全局声明放在符号定义之前（如我在大多数相同程序中对
    asmMain 符号所做的那样）。这两种做法都可以。
- en: 'Because a public symbol from one source file can be used by many assembly units,
    a problem develops: you have to replicate the .extern directive in all the files
    that use that symbol. For a small number of symbols, this is not much of an issue.
    However, as the number of external symbols increases, maintaining all these external
    symbols across multiple source files becomes burdensome.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一个源文件中的公共符号可以被多个汇编单元使用，所以会出现一个问题：你必须在所有使用该符号的文件中重复 `.extern` 指令。对于少数符号来说，这不是一个大问题。然而，随着外部符号数量的增加，在多个源文件中维护这些外部符号变得繁琐。
- en: 'The Gas solution is the same as the C/C++ solution: *header files*. These are
    simply include files containing external (and other) declarations that are common
    among multiple assembly units. Header files get their name from the fact that
    the include statement that injects their code into a source file usually appears
    at the beginning (the “head”) of the source file that uses them. This turns out
    to be the primary use of include files in Gas.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 解决方案与 C/C++ 解决方案相同：*头文件*。这些文件只是包含外部（以及其他）声明的包含文件，这些声明在多个汇编单元中是共同的。头文件之所以得名，是因为包含它们的
    `include` 语句通常出现在源文件的开头（“头”部分），用来将它们的代码注入到源文件中。这也恰好是 Gas 中包含文件的主要用途。
- en: 15.4 Creating a String Library with Separate Compilation
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4 使用单独编译创建字符串库
- en: '[Chapter 14](chapter14.xhtml) provided several examples of string-handling
    functions along with macros and the string structure. The problem with these functions
    and declarations is that they must be cut and pasted into any source file that
    wants to use them. It would be far better to create a header file containing the
    macros, structures, and external symbol definitions and then compile the individual
    functions into *.o* files to link with those programs that want to use those functions.
    This section describes how to create linkable object modules for these string
    functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](chapter14.xhtml)提供了几个字符串处理函数的示例，附带宏和字符串结构体。这些函数和声明的问题在于，它们必须被剪切并粘贴到任何希望使用它们的源文件中。创建一个包含宏、结构体和外部符号定义的头文件，然后将各个函数编译成
    *.o* 文件以便与那些希望使用这些函数的程序链接，显然是更好的选择。本节描述了如何为这些字符串函数创建可链接的目标模块。'
- en: 'The header file for the strings library is *strings.inc*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串库的头文件是 *strings.inc*：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The source file for the str.cpy function is in *str.cpy.S*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*str.cpy* 函数的源文件在 *str.cpy.S* 中：'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *str.cpy.S* source file is created by including the *strings.inc* header
    file ❶ and cutting and pasting the str.cpy function ❷ from Listing 14-2 on [page
    819](chapter14.xhtml#pg_819). Note the public argument after the proc macro. This
    causes the proc macro to emit a .global directive for the str.cpy symbol so that
    the function is available to other source files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*str.cpy.S* 源文件是通过包含 *strings.inc* 头文件 ❶ 并从 [第14章第819页](chapter14.xhtml#pg_819)
    的列表 14-2 中剪切粘贴 str.cpy 函数 ❷ 创建的。注意 proc 宏后的 public 参数。这会导致 proc 宏为 str.cpy 符号发出
    .global 指令，使得该函数可以被其他源文件访问。'
- en: The *str.cmp.S*, *str.substr.S*, *str.alloc.S*, *str.free.S*, and *str.bufInit.S*
    source files are created from their corresponding functions (in [Chapter 14](chapter14.xhtml))
    in a similar fashion. I won’t include those source files here because they are
    redundant and consume too much space, but you can find copies in the online source
    files at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*str.cmp.S*、*str.substr.S*、*str.alloc.S*、*str.free.S* 和 *str.bufInit.S* 源文件是以类似方式从它们对应的函数（在
    [第14章](chapter14.xhtml) 中）创建的。我不会在这里包含这些源文件，因为它们是冗余的并且占用太多空间，但你可以在在线源文件中找到副本，网址是
    *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*。'
- en: 'If you try to use the usual build command to assemble any of these modules,
    you get an error from the system complaining about missing symbols. This is because
    these modules are not stand-alone assembly language programs. In the following
    section, I describe the correct way to build these library modules; in the meantime,
    here are some cheesy commands that will assemble these files without error (though
    there will be a warning):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用常规构建命令来组装这些模块中的任何一个，系统会报错，提示缺少符号。这是因为这些模块不是独立的汇编语言程序。在接下来的部分，我会描述如何正确构建这些库模块；与此同时，这里有一些简单的命令可以在不出错的情况下组装这些文件（尽管会有警告）：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will assemble the files without running the linker (-c means *compile only*),
    generating the files *str.cpy.o*, *str.cmp.o*, *str.substr.o*, *str.bufInit.o*,
    *str.alloc.o*, and *str.free.o*, respectively. Of course, the next question is
    how to link these files with an application program. Listing 15-1 is an amalgamation
    of various asmMain functions from [Chapter 14](chapter14.xhtml) that make calls
    to the str.cpy, str.cmp, and str.substr functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将组装文件而不运行链接器（-c 表示*仅编译*），分别生成文件 *str.cpy.o*、*str.cmp.o*、*str.substr.o*、*str.bufInit.o*、*str.alloc.o*
    和 *str.free.o*。当然，下一个问题是如何将这些文件与应用程序链接。列表 15-1 是从 [第14章](chapter14.xhtml) 中各种
    asmMain 函数的合并版本，它们调用了 str.cpy、str.cmp 和 str.substr 函数。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you try to build this program with the following command
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用以下命令来构建这个程序
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'the system will complain that it cannot locate the symbols str.cpy, str.cmp,
    and str.substr in the object files provided. Unfortunately, the *build* shell
    script doesn’t support linking in multiple object modules (other than the *c.cpp*
    and the specified file’s object files). Therefore, you must specify an explicit
    g++ command to process all the files:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会抱怨它无法在提供的目标文件中找到符号 str.cpy、str.cmp 和 str.substr。不幸的是，*build* shell 脚本不支持在多个目标模块之间链接（除了
    *c.cpp* 和指定文件的目标文件）。因此，你必须指定一个明确的 g++ 命令来处理所有文件：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The -DisMacOS command line argument should be changed to -DisLinux when compiling
    the code under Linux or Pi OS (rather than macOS). As you may recall from section
    1.10.1, “Assembling Programs Under Multiple OSes,” on [page 36](chapter1.xhtml#pg_36),
    the *build* shell script determines the OS and emits a g++ command line define
    (the -Dxxxx option) to make the OS known to the assembly source file (and, especially,
    the *aoaa.inc* header file). As this g++ command will attempt to assemble the
    *Listing15-1.S* source file (which includes *aoaa.inc*), the command line must
    include a definition of either isMacOS or isLinux, or the assembly will fail.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 或 Pi OS（而不是 macOS）下编译代码时，命令行参数 -DisMacOS 应该更改为 -DisLinux。正如你在第1.10.1节“在多个操作系统下汇编程序”中从
    [第36页](chapter1.xhtml#pg_36) 回忆的那样，*build* shell 脚本会确定操作系统并发出一个 g++ 命令行定义（-Dxxxx
    选项），以使操作系统对汇编源文件（特别是 *aoaa.inc* 头文件）可知。由于这个 g++ 命令会尝试汇编 *Listing15-1.S* 源文件（其中包含
    *aoaa.inc*），因此命令行必须包含 isMacOS 或 isLinux 的定义，否则汇编将失败。
- en: This g++ command will compile *c.cpp*, assemble *Listing15-1.S*, and link their
    object files together with the *str.cpy.o*, *str.cmp.o*, and *str.substr.o* object
    files. This assumes, of course, that you’ve already assembled the *str.*.S* source
    files and that their object files are sitting in the current directory. The sample
    program in Listing 15-1 does not call the str.alloc, str.free, or str.bufInit
    functions, so there was no need to link in their respective object code files,
    though doing so would not have generated an error.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 g++ 命令将编译 *c.cpp*，汇编 *Listing15-1.S*，并将它们的目标文件与 *str.cpy.o*、*str.cmp.o* 和
    *str.substr.o* 目标文件链接在一起。当然，这假设你已经汇编了 *str.*.S* 源文件，并且它们的目标文件位于当前目录。Listing 15-1
    中的示例程序并没有调用 str.alloc、str.free 或 str.bufInit 函数，因此无需将它们各自的目标代码文件链接进来，尽管这么做不会产生错误。
- en: 'Here’s the full set of commands needed to build all these files and generate
    and run the Listing 15-1 executable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建所有这些文件并生成和运行 Listing 15-1 可执行文件所需的完整命令集：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Granted, that’s a lot of typing in order to compile and link a simple source
    file. You could remedy this by putting all the commands into a text file and executing
    them as a shell script (similar to the *build* script), but there’s a better way:
    makefiles.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，为了编译和链接一个简单的源文件，这需要大量的输入。你可以通过将所有命令放入一个文本文件并作为 shell 脚本执行（类似于*build*脚本）来解决这个问题，但有一个更好的方法：makefile。
- en: 15.5 Introducing Makefiles
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5 引入 Makefile
- en: The *build* file used throughout this book has been far more convenient than
    the manual commands needed to build the example of the previous section. Unfortunately,
    the build mechanism that *build* supports is good for only a few fixed source
    files. While you could easily construct a shell script to compile all the files
    in a large assembly project, it would largely defeat the purpose of using separate
    assembly, as running the script file would reassemble every source file in the
    project. Although you can use complex command line functions to avoid some of
    this, it’s easier to use makefiles.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的*build*文件比手动命令要方便得多，用于构建上一节中的示例。不幸的是，*build* 支持的构建机制仅适用于少数固定的源文件。虽然你可以轻松地构建一个
    shell 脚本来编译大型汇编项目中的所有文件，但这在很大程度上违背了使用单独汇编文件的目的，因为运行脚本文件会重新汇编项目中的每个源文件。虽然你可以使用复杂的命令行功能来避免部分问题，但使用
    makefile 会更加简便。
- en: A *makefile* is a script in a language (designed in early releases of Unix)
    that specifies how to execute a series of commands based on certain conditions.
    In its simplest form, a makefile can behave exactly like a shell script; you can
    list a sequence of commands in a text file and have the make program execute them.
    Of course, there would be no benefit over using a shell script if you did this;
    you should take advantage of make’s features if you’re going to use makefiles.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*makefile* 是一种脚本语言（最早在 Unix 发布时设计）用于指定如何基于某些条件执行一系列命令。最简单的形式下，makefile 可以完全像
    shell 脚本一样运行；你可以在文本文件中列出一系列命令，并让 make 程序执行它们。当然，如果你仅仅这样做，那么使用 shell 脚本并不会带来额外的好处；如果你打算使用
    makefile，应该利用 make 的特性。'
- en: 'The make program is an executable, just like Gas (as) or GCC. As make is not
    a part of the Linux or macOS system, you must obtain a make program before you
    can use it. Fortunately, make comes preinstalled on most Linux and macOS distributions
    (if you can run GCC, you can certainly run make). Execute it from a command line
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: make 程序是一个可执行文件，就像 Gas (as) 或 GCC 一样。由于 make 并不是 Linux 或 macOS 系统的一部分，因此在使用之前，你必须先获取
    make 程序。幸运的是，大多数 Linux 和 macOS 发行版都预装了 make（如果你能运行 GCC，当然也能运行 make）。你可以通过命令行执行它，像这样：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you execute make on a command line without any arguments, make will search
    for a file named *Makefile* and attempt to process the commands in that file.
    For many projects, this is very convenient. If you put all your source files in
    a single directory (potentially with subdirectories) along with a single makefile
    (named *Makefile*), you can then change into that directory and execute make,
    building the project with minimal fuss.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行执行 make 时没有任何参数，make 会查找一个名为 *Makefile* 的文件，并尝试处理该文件中的命令。对于许多项目来说，这非常方便。如果你将所有源文件放在一个目录中（可能包含子目录），并将一个名为
    *Makefile* 的单一 makefile 放在其中，那么你只需进入该目录并执行 make，就可以在最小的麻烦下构建项目。
- en: 'If you like, you can use a different filename than *Makefile*. Rather than
    simply placing the filename after make on the command line, however, you must
    preface the filename with the make -f option as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以使用与*Makefile*不同的文件名。不过，必须注意的是，使用命令行时，你必须在文件名之前加上 make -f 选项，像这样：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You don’t need to give your filename the *.mak* extension, but this is a popular
    convention when using makefiles with custom names.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要给文件名加上 *.mak* 扩展名，但这是使用自定义名称的 makefile 时的常见约定。
- en: The make program provides many command line options, and you can list common
    ones by using --help. You can look up make documentation online (or type man make
    from the command line) for a description of the other command line options, but
    most of them are advanced and unnecessary for most tasks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: make 程序提供了许多命令行选项，你可以使用 --help 列出常用选项。你可以在线查阅 make 文档（或在命令行中输入 man make）以了解其他命令行选项的说明，但它们大多数是高级选项，通常在大多数任务中不需要。
- en: Of course, to make practical use of make, you need to create makefiles. The
    following subsections describe the make scripting language and some common conventions
    for makefiles.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要实际使用 make，你需要创建 makefile。以下小节描述了 make 脚本语言及一些常见的 makefile 约定。
- en: 15.5.1 Basic Makefile Syntax
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.1 基本 Makefile 语法
- en: 'A makefile is a standard ASCII text file containing a sequence of lines (or
    a set of multiple occurrences of this sequence) as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: makefile 是一个标准的 ASCII 文本文件，包含如下格式的多行（或多次出现此序列）：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All components of this code—target, dependencies, and commands—are optional.
    The target item is an identifier or filename of some sort that, if present, must
    begin in column 1 of its source line. The dependencies item is a list of filenames
    on which the target depends in order to be built properly. The commands item is
    a list of one or more command line commands, which must have at least one tab
    character in front of them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的所有组件——目标、依赖项和命令——都是可选的。目标项是某种标识符或文件名，如果存在，必须从源行的第1列开始。依赖项项是目标正确构建所依赖的文件名列表。命令项是一个或多个命令行命令的列表，命令前必须至少有一个制表符。
- en: 'Consider the following makefile, which builds a set of string library functions
    (note that a tab appears before each g++ command):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 makefile，它构建了一组字符串库函数（注意，每个 g++ 命令前都有一个制表符）：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If these commands appear in a file named *Makefile* and you execute make, they
    will execute exactly as the command line interpreter would have executed them,
    had they appeared in a shell script.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些命令出现在一个名为 *Makefile* 的文件中，并且你执行 make，它们将像命令行解释器那样执行，假如它们出现在 shell 脚本中。
- en: 'Consider the following modification of the previous makefile:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对前一个 makefile 的以下修改：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This separates the build commands into two groups: one specified by the executable
    label and another specified by the library label.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建命令分成两组：一组由可执行文件标签指定，另一组由库标签指定。
- en: If you run make without any command line options, it will execute only the commands
    appearing after the first target in the file. Therefore, in this example, if you
    run make by itself, it will assemble *Listing15-1.S*, compile *c.cpp*, and attempt
    to link (the resulting) *c.obj* with *str.cpy.o*, *str.cmp.o*, *str.substr.o*,
    and *Listing15-1.o*. Assuming you had previously compiled the string functions,
    this should successfully produce the Listing15-1 executable (without having to
    recompile the string functions).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 make 而不指定任何命令行选项，它只会执行文件中第一个目标后面的命令。因此，在这个例子中，如果你单独运行 make，它将汇编 *Listing15-1.S*，编译
    *c.cpp*，并尝试将（生成的）*c.obj* 与 *str.cpy.o*、*str.cmp.o*、*str.substr.o* 和 *Listing15-1.o*
    链接在一起。假设你之前已经编译过字符串函数，这应该能够成功生成 Listing15-1 可执行文件（无需重新编译字符串函数）。
- en: 'To convince make to process the commands after the library target, you must
    specify the target name as a make command line argument:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 make 处理库目标之后的命令，你必须将目标名称作为 make 命令行参数指定：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This make command compiles *str.cpy.S*, *str.cmp.S*, and *str.substr.S*. If
    you execute this command once (and never change the string functions thereafter),
    you need only execute the make command by itself to generate the executable file.
    You can also use make executable if you want to explicitly state that you are
    building the executable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 make 命令编译 *str.cpy.S*、*str.cmp.S* 和 *str.substr.S*。如果你执行一次这个命令（并且此后不再更改字符串函数），只需单独执行
    make 命令即可生成可执行文件。如果你想明确表示自己在构建可执行文件，也可以使用 make executable。
- en: The ability to specify which targets you want to build on the command line is
    useful. However, as your projects get larger, with many source files and library
    modules, keeping track of which source files you need to recompile all the time
    can be burdensome and error-prone. If you’re not careful, you’ll forget to compile
    an obscure library module after you’ve made changes to it and wonder why the application
    is still failing. The make dependencies option helps you avoid these problems
    by allowing you to automate the build process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上指定你想要构建的目标是非常有用的。然而，随着项目变大，源文件和库模块增多，时刻跟踪哪些源文件需要重新编译可能会变得繁琐且容易出错。如果你不小心，在修改了某个不常见的库模块之后，可能会忘记重新编译它，然后不明白为什么应用程序仍然失败。make的依赖选项通过让你自动化构建过程，帮助你避免这些问题。
- en: 'A list of one or more whitespace-separated dependencies can follow a target
    in a makefile:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在makefile中，目标后可以跟一个或多个由空格分隔的依赖关系：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Dependencies are either target names (of targets appearing in that makefile)
    or filenames. If a dependency is a target name (that is not also a filename),
    make will go execute the commands associated with that target. Consider the following
    makefile (if compiling under Linux or Pi OS, be sure to change the -DisMacOS command
    line option to -DisLinux in this example and all that follow):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系可以是目标名称（出现在该makefile中的目标）或文件名。如果依赖关系是目标名称（且不是文件名），make将执行与该目标相关的命令。考虑以下makefile（如果在Linux或Pi
    OS下编译，请确保将这个例子中的-DisMacOS命令行选项更改为-DisLinux）：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The all target in this code does not have any commands associated with it. Instead,
    the all target depends on the library and executable targets, so it will go execute
    the commands associated with those targets, beginning with library. This is because
    the library object files must be built before the associated object modules can
    be linked into the executable program). The all identifier is a common target
    in makefiles. Indeed, it is often the first or second target to appear in a makefile.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码中的all目标没有任何与之相关的命令。相反，all目标依赖于库和可执行目标，因此它将执行与这些目标相关的命令，从库开始。这是因为在将关联的对象模块链接成可执行程序之前，必须先构建库的目标文件。all标识符是makefile中常见的目标。事实上，它通常是makefile中出现的第一个或第二个目标。
- en: 'If a target: dependencies line becomes too long to be readable (make doesn’t
    care much about line length), you can break the line into multiple lines by putting
    a backslash character (\) as the last character on a line. The make program will
    combine source lines that end with a backslash with the next line in the makefile.
    The backslash must be the very last character on the line; whitespace characters
    (tabs and spaces) are not allowed to follow the backslash.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个目标：依赖关系行变得过长，导致难以阅读（make不太关心行的长度），你可以通过在行的末尾加上反斜杠字符（\）来将该行分为多行。make程序会将以反斜杠结尾的源行与makefile中的下一行合并。反斜杠必须是行的最后一个字符；行尾不允许有空白字符（制表符和空格）。
- en: 'Target names and dependencies can also be filenames. Specifying a filename
    as a target name is generally done to tell the make system how to build that particular
    file. For example, you could rewrite the current example as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 目标名称和依赖关系也可以是文件名。将文件名指定为目标名称通常是为了告诉make系统如何构建该特定文件。例如，你可以将当前的示例重写如下：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When dependencies are associated with a target that is a filename, you can
    read the target: dependencies statement as “target depends on dependencies.” When
    processing a command, make compares the modification date/timestamp of the files
    specified as target and dependency filenames.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖关系与一个文件名目标相关联时，你可以将目标：依赖关系语句理解为“目标依赖于依赖关系”。在处理命令时，make会比较作为目标和依赖关系文件名指定的文件的修改日期/时间戳。
- en: If the date/time of the target is older than *any* of the dependencies (or the
    target file doesn’t exist), make will execute the commands after the target. If
    the target file’s modification date/time is later (newer) than *all* of the dependent
    files, make will not execute the commands. If one of the dependencies after a
    target is itself a target elsewhere, make will first execute that command (to
    see if it modifies the target object, changing its modification date/time, and
    possibly causing make to execute the current target’s commands). If a target or
    dependency is just a label (not a filename), make will treat its modification
    date/time as older than any file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标的日期/时间比*任何*依赖项都要旧（或者目标文件不存在），make将执行目标后面的命令。如果目标文件的修改日期/时间比*所有*依赖文件都要新，make将不会执行命令。如果目标后的某个依赖项本身是其他地方的目标，make将首先执行那个命令（以查看它是否修改了目标对象，改变其修改日期/时间，可能导致make执行当前目标的命令）。如果目标或依赖项只是一个标签（而不是文件名），make将把它的修改日期/时间视为比任何文件都旧。
- en: 'Consider the following modification to the running makefile example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下对正在运行的makefile示例的修改：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code has removed all and library targets, as they turn out to be unnecessary,
    and changed executable to Listing15-1, the final target executable file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码删除了所有和库的目标，因为它们被证明是不必要的，并将可执行文件更改为Listing15-1，即最终的目标可执行文件。
- en: Because str.cpy.o, str.cmp.o, str.substr.o, and Listing15-1.o are all targets
    (as well as filenames), make will first go process those targets. After that,
    make will compare the modification date/time of Listing15-1 against that of the
    four object files. If Listing15-1 is older than any of those object files, make
    will execute the command following the Listing15-1 target line (to compile *c.cpp*
    and link it with the object files). If Listing15-1 is newer than its dependent
    object files, make will not execute the command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为str.cpy.o、str.cmp.o、str.substr.o和Listing15-1.o都是目标（以及文件名），make将首先处理这些目标。之后，make会将Listing15-1的修改日期/时间与这四个目标文件的修改日期/时间进行比较。如果Listing15-1比任何一个目标文件旧，make将执行Listing15-1目标行之后的命令（编译*c.cpp*并将其与目标文件链接）。如果Listing15-1比其依赖的目标文件新，make将不执行该命令。
- en: The same process happens, recursively, for each of the dependent object files
    following the Listing15-1 target. While processing the Listing15-1 target, make
    will also process the str.cpy.o, str.cmp.o, str.substr.o, and Listing15-1.o targets
    (in that order). In each case, make compares the modification date/time of the
    *.o* file with the corresponding *.S* file. If the *.o* file is newer than the
    *.S* file, make returns to processing the Listing15-1 target without doing anything;
    if the *.o* file is older than the *.S* file (or doesn’t exist), make executes
    the corresponding g++ command to generate a new *.o* file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有依赖的目标文件，在处理Listing15-1目标时，同样的过程会递归发生。处理Listing15-1目标时，make还会处理str.cpy.o、str.cmp.o、str.substr.o和Listing15-1.o目标（按此顺序）。在每种情况下，make会将*.o*文件的修改日期/时间与相应的*.S*文件进行比较。如果*.o*文件的修改日期/时间比*.S*文件新，make将返回并继续处理Listing15-1目标，而不执行任何操作；如果*.o*文件比*.S*文件旧（或不存在），make将执行相应的g++命令生成新的*.o*文件。
- en: If Listing15-1 is newer than all the *.o* files (and they are all newer than
    the *.S* files), then executing make simply reports that Listing15-1 is up-to-date,
    but it will not execute any of the commands in the makefile. If any of the files
    are out-of-date (because they’ve been modified), this makefile will compile and
    link only the files necessary to bring Listing15-1 up-to-date.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Listing15-1比所有*.o*文件更新（并且它们都比*.S*文件更新），那么执行make时只会报告Listing15-1是最新的，但不会执行makefile中的任何命令。如果任何文件是过时的（因为它们已被修改），这个makefile将只编译和链接必要的文件，以使Listing15-1保持最新。
- en: 'The makefiles have a pretty serious defect thus far: they are missing an important
    dependency. Since all the *.S* files include the *aoaa.inc* file, a change to
    *aoaa.inc* could possibly require a recompilation of these *.S* files. Listing
    15-2 adds this dependency to the *Listing15-2.mak* makefile, and it also demonstrates
    how to include comments in a makefile by using the # character at the beginning
    of a line.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，makefile有一个相当严重的缺陷：缺少一个重要的依赖项。由于所有的*.S*文件都包含*aoaa.inc*文件，因此*aoaa.inc*的更改可能会要求重新编译这些*.S*文件。Listing
    15-2在*Listing15-2.mak* makefile中添加了这个依赖，并演示了如何在makefile中通过在行首使用#字符来添加注释。
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s an example of executing make (under macOS):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行make（在macOS下）的一个示例：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To execute this command under Linux or Pi OS, don’t forget to change all the
    -DisMacOS command line options to -DisLinux in the makefile and make sure all
    commands have a tab in column 1\. If you want to be able to automatically compile
    the code for any OS, simply steal the code from the *build* script that sets up
    a shell variable with the appropriate command line option, as shown in Listing
    15-3.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 或 Pi OS 下执行此命令时，请不要忘记将所有 `-DisMacOS` 命令行选项改为 `-DisLinux`，并确保所有命令在第一列有一个制表符。如果希望能够自动为任何操作系统编译代码，只需复制
    *构建* 脚本中的代码，该脚本设置了带有适当命令行选项的 shell 变量，如列表 15-3 所示。
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first statement ❶ is an example of a makefile *macro* (or *variable*). The
    OS command uname will display the OS (kernel) name. Under Linux systems, this
    will be replaced by the string Linux, and on macOS systems by the string Darwin
    (the internal name of the macOS kernel).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句 ❶ 是一个 makefile *宏*（或 *变量*）的示例。OS 命令 `uname` 将显示操作系统（内核）名称。在 Linux 系统下，这将被替换为字符串
    `Linux`，而在 macOS 系统下则为字符串 `Darwin`（macOS 内核的内部名称）。
- en: 'Makefile macros use deferred execution. This means that the macro unamestr
    actually contains the text `uname` and that the uname command will execute in
    place when the make program expands the unamestr macro. The make program will
    expand the -D$(unamestr) command line option, producing -D`uname` ❷. The backticks
    (`) tell make to execute the command and replace it with the text printed by the
    command: the OS kernel name.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 宏使用延迟执行。这意味着宏 `unamestr` 实际上包含了文本 `uname`，而 `uname` 命令将在 make 程序展开
    `unamestr` 宏时执行。make 程序将展开 `-D$(unamestr)` 命令行选项，生成 `-D` `uname` ❷。反引号（`）告诉 make
    执行该命令并用命令打印的文本替换它：操作系统内核名称。
- en: 'The only issue is that the uname command prints Linux or Darwin, so the -D
    command defines one of these two symbols. The *build* script translates these
    strings to isMacOS and isLinux. I originally did this because the symbol Linux
    would likely appear in a Linux-based assembly language program. Unfortunately,
    the symbol translation trick didn’t work out in a makefile, so I modified *aoaa.inc*
    to accept Linux and Darwin as well as inLinux and inMacOS. I modified *aoaa.inc*
    to do the translation and undefine Linux or Darwin, should those symbols get used:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是 `uname` 命令会打印出 Linux 或 Darwin，因此 `-D` 命令定义了这两个符号之一。*构建* 脚本将这些字符串转换为 `isMacOS`
    和 `isLinux`。我最初这样做是因为在基于 Linux 的汇编语言程序中，符号 `Linux` 可能会出现。不幸的是，这种符号翻译技巧在 makefile
    中无法生效，因此我修改了 *aoaa.inc*，使其既接受 `Linux` 和 `Darwin`，也接受 `inLinux` 和 `inMacOS`。我修改了
    *aoaa.inc* 来进行翻译，并在使用这些符号时取消定义 `Linux` 或 `Darwin`：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the execution of the make command to build the code for Listing 15-3
    (assuming no object files were already created):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行 `make` 命令以构建列表 15-3 中代码的过程（假设没有已经创建的目标文件）：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that -D`uname` is translated to either -DLinux or -DDarwin, depending on
    the OS.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`-D` `uname` 会根据操作系统的不同翻译为 `-DLinux` 或 `-DDarwin`。
- en: 15.5.2 Make Clean and Touch
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.2 Make Clean 和 Touch
- en: One common target you will find in most professionally made makefiles is clean,
    which deletes an appropriate set of files to force the entire system to be remade
    the next time you execute the makefile. This command typically deletes all the
    *.o* and executable files associated with the project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数专业制作的 makefile 中，你会发现一个常见的目标是 `clean`，它删除一组适当的文件，以便下次执行 makefile 时强制重新构建整个系统。该命令通常会删除与项目相关的所有
    `*.o` 文件和可执行文件。
- en: Listing 15-4 provides an example clean target for the makefile appearing in
    Listing 15-3.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-4 提供了一个针对列表 15-3 中 makefile 的示例清理目标。
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Issuing the command
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: will delete all the executable and object code files associated with the project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将删除与项目相关的所有可执行文件和目标文件。
- en: To force the recompilation of a single file (without manually editing and modifying
    it), you can use the Unix utility touch. This program accepts a filename as its
    argument and updates the modification date/time of the file (without otherwise
    modifying the file). For example, after building *Listing15-1.S* using the makefile
    in Listing 15-4, were you to execute the command
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制重新编译单个文件（而不手动编辑和修改它），可以使用 Unix 工具 `touch`。该程序接受一个文件名作为参数，并更新文件的修改日期/时间（不会修改文件内容）。例如，在使用列表
    15-4 中的 makefile 构建 *Listing15-1.S* 后，如果执行以下命令
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: and then re-execute the makefile in Listing 15-4, make would reassemble the
    code in *Listing15-1.S*, recompile *c.cpp*, and produce a new executable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新执行列表 15-4 中的 makefile，make 将重新汇编 *Listing15-1.S* 中的代码，重新编译 *c.cpp*，并生成一个新的可执行文件。
- en: 15.6 Generating Library Files with the Archiver Program
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.6 使用归档程序生成库文件
- en: 'Many common projects reuse code the developers created long ago, or code from
    a source outside the developer’s organization. These libraries of code are relatively
    *static*: they rarely change during the development of a project that uses them.
    In particular, you would not usually incorporate the building of the libraries
    into a given project’s makefile. A specific project might list the library files
    as dependencies in the makefile, but the assumption is that the library files
    are built elsewhere and supplied as a whole to the project.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的项目重用开发者很久以前创建的代码，或者来自开发者组织外部的代码。这些代码库相对*静态*：在使用它们的项目开发过程中，它们很少发生变化。特别地，通常不会将库的构建包含在某个特定项目的makefile中。一个特定的项目可能会在makefile中列出库文件作为依赖项，但假设这些库文件已经在其他地方构建，并作为整体提供给项目。
- en: 'Beyond that, there is one major difference between a library and a set of object
    code files: packaging. Dealing with a myriad of separate object files becomes
    troublesome when you’re working with large sets of library object files. A library
    may contain tens, hundreds, or even thousands of object files. Listing all these
    object files (or even just the ones a project uses) is a lot of work and can lead
    to consistency errors.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，库与一组目标代码文件之间有一个主要的区别：打包。当你在处理大量独立的目标文件时，尤其是当你需要处理大量的库目标文件时，事情变得麻烦。一个库可能包含几十、几百甚至几千个目标文件。列出所有这些目标文件（或者仅列出一个项目使用的文件）是一个繁琐的工作，可能会导致一致性错误。
- en: 'The common way to deal with this problem is to combine object files into a
    separate package (file) known as a *library file*. Under Linux and macOS, library
    files typically have a *.a* suffix (where *a* stands for *archive*). For many
    projects, you will be given a library file that packages together a specific library
    module. You supply this file to the linker when building your program, and the
    linker automatically picks out the object modules it needs from the library. This
    is an important point: including a library while building an executable does not
    automatically insert all the code from that library into the executable. The linker
    is smart enough to extract only the object files it needs and to ignore the object
    files it doesn’t use (remember, a library is just a package containing a bunch
    of object files).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的常见方法是将目标文件组合成一个单独的包（文件），称为*库文件*。在Linux和macOS下，库文件通常有一个*.a*后缀（其中*a*代表*归档*）。对于许多项目，你会得到一个库文件，它将特定的库模块打包在一起。你将这个文件提供给链接器，当构建程序时，链接器会自动从库中提取它需要的目标模块。这是一个重要的点：在构建可执行文件时包含一个库并不会自动将库中的所有代码插入到可执行文件中。链接器足够智能，能够仅提取它需要的目标文件，忽略它不使用的目标文件（记住，库只是一个包含大量目标文件的包）。
- en: How do you create a library file? The short answer is, “By using the archiver
    program (ar).” Here is its basic syntax
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建一个库文件？简短的回答是：“通过使用归档程序（ar）。”以下是它的基本语法
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'where libname.a is the name of the library file you want to produce and list-of-.o-files
    is a (space-separated) list of object filenames you want to collect together into
    the library. For example, here’s the command to combine the *print.o* and *getTitle.o*
    files into a library module (*aoaalib.a*):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，libname.a 是你想要生成的库文件的名称，而 list-of-.o-files 是你想要收集到库中的目标文件名称列表（以空格分隔）。例如，以下命令将
    *print.o* 和 *getTitle.o* 文件合并成一个库模块（*aoaalib.a*）：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The rcs component is actually a series of three command options. The r option
    tells the command to replace existing (if present) object files in the archive;
    c says to create the archive (you generally don’t specify this option if you are
    adding object files to an existing archive file); and s says to add an index to
    the archive file, or update the index if it already exists. (For more ar command
    line options, see section 15.9, “For More Information,” on [page 887](chapter15.xhtml#pg_887).)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: rcs组件实际上是一系列三个命令选项。r选项告诉命令替换归档中已有的（如果有）目标文件；c选项表示创建归档（如果你是将目标文件添加到现有归档文件中，通常不需要指定此选项）；s选项表示为归档文件添加索引，或者如果索引已存在，则更新索引。（有关更多ar命令行选项，请参阅第15.9节“更多信息”，见[第887页](chapter15.xhtml#pg_887)。）
- en: 'Once you have a library module, you can specify it on a linker (or ld or gcc)
    command line just as you would an object file. For example, if you build a *strings.a*
    library module to hold the *str.cpy.o*, *str.cmp.o*, *str.substr.o*, *str.bufInit.o*,
    *str.free.o*, and *str.alloc.o* object files, and you want to link *strings.a*
    with the program in Listing 15-1, you could use the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个库模块，你可以像指定目标文件一样在链接器（或ld或gcc）的命令行中指定它。例如，如果你构建了一个*strings.a*库模块来保存*str.cpy.o*、*str.cmp.o*、*str.substr.o*、*str.bufInit.o*、*str.free.o*和*str.alloc.o*目标文件，并且你想要将*strings.a*与Listing
    15-1中的程序链接，你可以使用以下命令：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Listing 15-5 is an example of a makefile that will build the *strings.a* library
    file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-5是一个makefile的示例，它将构建*strings.a*库文件。
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Listing 15-6 modifies the Listing 15-5 makefile that builds the code by using
    the *strings.a* library module.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-6修改了Listing 15-5的makefile，通过使用*strings.a*库模块来构建代码。
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that the clean command does not delete the library files. If you want
    a clean library build, just specify the lib command line option when running make:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，clean命令不会删除库文件。如果你想进行干净的库构建，只需在运行make时指定lib命令行选项：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As a general rule, you build the library code independently of the application
    code. Most of the time, the library is prebuilt, and you don’t have to rebuild
    it. However, *strings.a* must be a dependency of the application, because if the
    library changes, you’ll probably need to rebuild the application as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该独立构建库代码和应用程序代码。大多数时候，库是预构建的，你不需要重新构建它。然而，*strings.a*必须是应用程序的依赖项，因为如果库发生变化，你很可能也需要重新构建应用程序。
- en: 'One more Unix utility is useful for processing library files: nm (names). The
    nm utility will list all the global names found in a library module. For example,
    the command'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在处理库文件时有用的Unix工具是nm（names）。nm工具会列出库模块中找到的所有全局名称。例如，命令
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: lists all the (global) symbols found in the *strings.a* library file (it’s rather
    long, so I won’t provide the printout here).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了在*strings.a*库文件中找到的所有（全局）符号（它比较长，我这里不提供打印输出）。
- en: 15.7 Managing the Impact of Object Files on Program Size
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7 管理目标文件对程序大小的影响
- en: The basic unit of linkage in a program is the object file. When combining object
    files to form an executable, the linker will take all the data from a single object
    file and merge it into the final executable. This is true even if the main program
    doesn’t call all the functions (directly or indirectly) in the object module or
    use all the data in that object file. If you put 100 routines in a single assembly
    language source file and compile them into an object module, the linker will therefore
    include the code for all 100 routines in your final executable, even if you use
    only one of them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的链接基本单元是目标文件。当将目标文件组合成可执行文件时，链接器会将单个目标文件中的所有数据合并到最终的可执行文件中。即使主程序没有调用目标模块中的所有函数（直接或间接）或没有使用该目标文件中的所有数据，这一点仍然成立。如果你把100个例程放入一个汇编语言源文件中，并将其编译成目标模块，那么链接器将在最终的可执行文件中包含所有100个例程的代码，即使你只使用其中的一个。
- en: To avoid this situation, you can break those 100 routines into 100 separate
    object modules and combine the resulting 100 object files into a single library.
    When the linker processes that library file, it will pick out the single object
    file containing the function the program uses and incorporate only that file into
    the final executable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，你可以将这100个例程拆分成100个单独的目标模块，并将生成的100个目标文件合并成一个库文件。当链接器处理这个库文件时，它会挑选出包含程序使用的函数的单个目标文件，并只将该文件合并到最终的可执行文件中。
- en: Generally, this is far more efficient than linking in a single object file with
    100 functions buried in it. However, in some cases, there are good reasons to
    combine multiple functions into a single object file. First, consider what happens
    when the linker merges an object file into an executable. To ensure proper alignment,
    whenever the linker takes a section/segment (for example, the .code section) from
    an object file, it adds sufficient padding so that the data in that section is
    aligned on that section’s specified alignment boundary. Most sections have a default
    16-byte section alignment. This means that the linker will align each section
    from the object file it links on a 16-byte boundary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Normally, this isn’t much of a problem, especially if your procedures are large.
    However, if those 100 procedures are all really short (a few bytes each), you
    wind up wasting a lot of space. Granted, on modern machines, a few hundred bytes
    of wasted space isn’t a big deal. Still, it might be more practical to combine
    several of these procedures into a single object module (even if you don’t call
    all of them) to fill in some of the wasted space. Look for elements that are naturally
    paired or otherwise used together or have a dependency, such as alloc and free.
    Don’t go overboard, though. Once you’ve gone beyond the alignment, whether you’re
    wasting space because of padding or wasting space because you’re including code
    that never gets called, you’re still wasting space.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 15.8 Moving On
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you write large applications in assembly language, you’ll want to break the
    source code into various modules and automate building the application from those
    modules. This chapter began by discussing Gas’s mechanisms for sharing external
    and public symbols between modules. It then introduced the make application for
    building applications from multiple source files, then covered how to build library
    modules by using the linker and archiver applications.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: One large source of library code is the OS kernel (macOS, Linux, or Pi OS).
    However, don’t link OS library functions into your applications; that code is
    already present in memory when your application runs. To call an OS function,
    you use an OS API invocation sequence. The next chapter discusses how to call
    OS functions in the Linux (Pi OS) and macOS (Darwin) kernels.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 15.9 For More Information
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For information about makefiles, check out the following websites:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer Hope: *[https://<wbr>www<wbr>.computerhope<wbr>.com<wbr>/unix<wbr>/umake<wbr>.htm](https://www.computerhope.com/unix/umake.htm)*'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GNU make: *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/make<wbr>/](https://www.gnu.org/software/make/)*'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wikipedia: *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Make<wbr>_(software)](https://en.wikipedia.org/wiki/Make_(software))*'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also check out the following books on make:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Robert Mecklenburg, *Managing Projects with GNU Make: The Power of GNU Make
    for Building Anything*, 3rd edition (O’Reilly Media, 2004). You can also access
    this book online at *[https://<wbr>www<wbr>.oreilly<wbr>.com<wbr>/openbook<wbr>/make3<wbr>/book<wbr>/index<wbr>.csp](https://www.oreilly.com/openbook/make3/book/index.csp)*.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: John Graham-Cumming, *The GNU Make Book,* 1st edition (No Starch Press, 2015)
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Andrew Oram and Steve Talbott, *Managing Projects with Make* (O’Reilly & Associates,
    2004)
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: See *[https://<wbr>man7<wbr>.org<wbr>/linux<wbr>/man<wbr>-pages<wbr>/man1<wbr>/ar<wbr>.1<wbr>.html](https://man7.org/linux/man-pages/man1/ar.1.html)*
    for a complete list of the ar command line options. You can also enter ar --help
    or man ar for online help.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
