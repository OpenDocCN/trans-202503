- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 15 MANAGING COMPLEX PROJECTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most assembly language source files are not stand-alone programs. In general,
    you must call various standard library or other routines that are not defined
    in your main program because attempting to write such code as part of your application
    would be far too much work (and poor programming practice).
  prefs: []
  type: TYPE_NORMAL
- en: For example, the ARM doesn’t provide machine instructions like read, write,
    or put for doing I/O operations. The functions in this book contain thousands
    of lines of source code to accomplish these operations. For small programs, working
    with a single source file is fine, but for large programs, this gets cumbersome.
    Programming would be formidable if you had to merge these thousands of lines of
    code into your simple programs, which would then compile slowly. Furthermore,
    once you’ve debugged and tested a large section of your code, continuing to assemble
    that same code when you make a small change to another part of your program is
    a waste of time. Imagine having to wait 20 or 30 minutes on a fast PC to assemble
    a program after making a one-line change!
  prefs: []
  type: TYPE_NORMAL
- en: '*Programming in the large* is the term software engineers have coined to describe
    the processes, methodologies, and tools for reducing the development time of large
    software projects. While everyone has their own idea of what “large” is, *separate
    compilation* is one of the more popular techniques that support programming in
    the large. First, you break your large source files into manageable chunks. Then
    you compile the separate files into object code modules. Finally, you link the
    object modules together to form a complete program. If you need to make a small
    change to one of the modules, you need to reassemble only that one module rather
    than the entire program.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes the tools that Gas and your OS provide for separate compilation
    and how to effectively employ these tools in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 The .include Directive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The .include directive, when encountered in a source file, switches program
    input from the current file to the file specified in the operand field of the
    include directive. Section 1.5, “The *aoaa.inc* Include File,” on [page 10](chapter1.xhtml#pg_10)
    described the .include directive as a way to include code from separate source
    files into the current assembly, allowing you to construct text files containing
    common constants, types, source code, and other Gas items into the assembly. As
    noted in that section, the syntax for the .include directive is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where filename must be a valid filename.
  prefs: []
  type: TYPE_NORMAL
- en: By this book’s convention, Gas include files have a *.inc* (include) suffix.
    Gas, however, does not require include files to have this suffix; any filename
    containing Gas assembly language source will work. Gas merges the specified file
    into the compilation at the point of the .include directive. You can nest .include
    statements inside files you include; that is, a file being included into another
    file during assembly may itself include a third file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the .include directive by itself does not provide separate compilation.
    You *could* use .include to break up a large source file into separate modules
    and join these modules together when you compile your file. The following example
    would include the *print.inc* and *getTitle.inc* files during the compilation
    of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Your program will now benefit from modularity. Alas, you will not save any development
    time. The .include directive inserts the source file at the point of the .include
    during compilation, exactly as though you had typed that code yourself. Gas still
    has to compile the code, and that takes time. If you are including a large number
    of source files (such as a huge library) into your assembly, the compilation process
    could take *forever*.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should *not* use the .include directive to include source code
    as shown in the previous example, as this code won’t allow you to take advantage
    of separate compilation. Instead, use the .include directive to insert a common
    set of constants, types, external procedure declarations, and other such items
    into a program. Typically, an assembly language include file does *not* contain
    any machine code (outside of a macro; see [Chapter 13](chapter13.xhtml) for details).
    The purpose of using .include files in this manner will become clearer after you
    see how the external declarations work (see section 15.3, “Assembly Units and
    External Directives,” on the next page).
  prefs: []
  type: TYPE_NORMAL
- en: 'If your assembly language source files have a *.S* suffix, you can also use
    the #include "filename" directive to include a source file. This is generally
    preferable because you can use the CPP directives in such include files (you can’t
    in a standard .include file). The rest of this chapter assumes the use of the
    #include directive rather than .include.'
  prefs: []
  type: TYPE_NORMAL
- en: 15.2 Ignoring Duplicate Include Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you begin to develop sophisticated modules and libraries, you will eventually
    discover a big problem: some header files need to include other header files.
    Technically, this is fine in and of itself, but issues arise when one header file
    includes another, and that second header file includes another, and so on, such
    that the final header file includes the first header file.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two problems with a header file indirectly including itself. First,
    this creates an infinite loop in the compiler. The compiler will happily go on
    about its business including all these files over and over again until it runs
    out of memory or another error occurs. Second, when Gas includes a header file
    for the second time, it starts complaining bitterly about duplicate symbol definitions.
    After all, the first time it reads the header file, it processes all the declarations
    in that file; the second time around, it views all those symbols as duplicate
    symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard technique for resolving recursively included files, well-known
    to C/C++ programmers, is to use conditional assembly to have Gas ignore the content
    of an include file. (See [Chapter 13](chapter13.xhtml) for a discussion of conditional
    assembly for CPP and the Gas CTL.) The trick is to place an #ifdef (if defined)
    statement around all statements in the include file. Specify an undefined symbol
    as the #ifdef operand (I tend to use the include file’s filename, substituting
    underlines for periods). Then, immediately after the #ifdef statement, define
    that symbol; using a numeric equate and assigning the symbol the constant 1 is
    typical. Here’s an example of this #ifdef usage in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you attempt to include *myinclude.inc* a second time, the #ifdef directive
    will cause Gas (actually, the CPP) to skip over all the text up to the corresponding
    #endif directive, thus avoiding the duplicate definition errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 15.3 Assembly Units and External Directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *assembly unit* is the assembly of a source file plus any files it directly
    or indirectly includes. An assembly unit produces a single *.o* (object) file
    after assembly. The linker takes multiple object files (produced by Gas or other
    compilers, such as GCC) and combines those object files into a single executable
    file. The main purpose of this section, and, indeed, this whole chapter, is to
    describe how these assembly units (*.o* files) communicate linkage information
    to one another during the linking process. Assembly units are the basis for creating
    modular programs in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: To use Gas’s assembly unit facilities, you must create at least two source files.
    One file contains a set of variables and procedures used by the second. The second
    file uses those variables and procedures without knowing how they’re implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, the #include directive provides you with all the facilities you
    need to create such modular programs. You can create several modules, each containing
    a specific routine, and include those modules, as necessary, in your assembly
    language programs by using the #include directive. However, if you use this method,
    including a routine you’ve debugged in a compilation will still waste time because
    Gas must recompile bug-free code whenever you assemble the main program. A much
    better solution is to preassemble the debugged modules and link the object code
    modules together, using Gas’s .global and .extern directives, which this section
    covers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the programs appearing in this book up to this point have been separately
    assembled modules that happen to link with a C/C++ main program rather than another
    assembly language module. In every program thus far, the assembly language “main
    program” has been named asmMain, which is nothing but a C++-compatible function
    that the generic *c.cpp* program has called from its main program. For example,
    consider the body of asmMain from Listing 1-3 on [page 9](chapter1.xhtml#pg_9)
    (for Linux and Pi OS systems):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This .global asmMain statement has been included in every program that has had
    an asmMain function without any definition or explanation. It’s now time to deal
    with that oversight.
  prefs: []
  type: TYPE_NORMAL
- en: Normal symbols in a Gas source file are *private* to that particular source
    file and are inaccessible from other source files (that don’t directly include
    the file containing those private symbols, of course). That is, the *scope* of
    most symbols in a source file is limited to those lines of code within that particular
    source file and any files it includes. The .global directive tells Gas to make
    the specified symbol *global* to the assembly unit—accessible by other assembly
    units during the link phase. By placing the .global asmFunc statement in the example
    programs appearing throughout this book, these sample programs have made the asmMain
    symbol global to the source file containing them so that the *c.cpp* program can
    call the asmMain function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall, macOS requires an underscore prefix in front of the global
    name. This means you would use .global _asmMain and _asmMain: if you wanted this
    source file to assemble under macOS. The *aoaa.inc* header file resolves this
    issue in a portable fashion, but the code from *Listing1-3.S* does not include
    *aoaa.inc*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply making a symbol public is insufficient to use that symbol in another
    source file. The source file that wants to use the symbol must also declare that
    symbol as *external*. This notifies the linker that it will have to patch in the
    address of a public symbol whenever the file with the external declaration uses
    that symbol. For example, the *c.cpp* source file defines the asmMain symbol as
    external in the following lines of code (for what it’s worth, this declaration
    also defines the external symbol getTitle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, readLine is actually a C++ function defined in the *c.cpp*
    source file. C/C++ does not have an explicit public declaration. Instead, if you
    supply the source code for a function in a source file that declares that function
    to be external, C/C++ will automatically make that symbol public by virtue of
    the external declaration.
  prefs: []
  type: TYPE_NORMAL
- en: When you place an .extern directive in your program, Gas treats that declaration
    the same as any other symbol declaration. If the symbol already exists, Gas will
    generate a symbol redefinition error. Generally, you should place all external
    declarations near the beginning of the source file to avoid any scoping / forward
    reference issues.
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, using the .extern directive is optional, as Gas assumes
    that any symbol you use that is not defined in a source file is an external symbol.
    The linker will report actual undefined symbols if it fails to find a symbol when
    linking in all the other object code modules. However, it is good programming
    style to explicitly define your external symbols with .extern in order to make
    your intentions clear to others reading your source code.
  prefs: []
  type: TYPE_NORMAL
- en: Because the .global directive does not actually define the symbol, its placement
    is not as critical as the .extern directive’s is. Some programmers put all the
    global declarations at the beginning of a source file; others put the global declaration
    right before the definition of the symbol (as I’ve done with the asmMain symbol
    in most of the same programs). Either is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because a public symbol from one source file can be used by many assembly units,
    a problem develops: you have to replicate the .extern directive in all the files
    that use that symbol. For a small number of symbols, this is not much of an issue.
    However, as the number of external symbols increases, maintaining all these external
    symbols across multiple source files becomes burdensome.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gas solution is the same as the C/C++ solution: *header files*. These are
    simply include files containing external (and other) declarations that are common
    among multiple assembly units. Header files get their name from the fact that
    the include statement that injects their code into a source file usually appears
    at the beginning (the “head”) of the source file that uses them. This turns out
    to be the primary use of include files in Gas.'
  prefs: []
  type: TYPE_NORMAL
- en: 15.4 Creating a String Library with Separate Compilation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 14](chapter14.xhtml) provided several examples of string-handling
    functions along with macros and the string structure. The problem with these functions
    and declarations is that they must be cut and pasted into any source file that
    wants to use them. It would be far better to create a header file containing the
    macros, structures, and external symbol definitions and then compile the individual
    functions into *.o* files to link with those programs that want to use those functions.
    This section describes how to create linkable object modules for these string
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header file for the strings library is *strings.inc*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The source file for the str.cpy function is in *str.cpy.S*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The *str.cpy.S* source file is created by including the *strings.inc* header
    file ❶ and cutting and pasting the str.cpy function ❷ from Listing 14-2 on [page
    819](chapter14.xhtml#pg_819). Note the public argument after the proc macro. This
    causes the proc macro to emit a .global directive for the str.cpy symbol so that
    the function is available to other source files.
  prefs: []
  type: TYPE_NORMAL
- en: The *str.cmp.S*, *str.substr.S*, *str.alloc.S*, *str.free.S*, and *str.bufInit.S*
    source files are created from their corresponding functions (in [Chapter 14](chapter14.xhtml))
    in a similar fashion. I won’t include those source files here because they are
    redundant and consume too much space, but you can find copies in the online source
    files at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to use the usual build command to assemble any of these modules,
    you get an error from the system complaining about missing symbols. This is because
    these modules are not stand-alone assembly language programs. In the following
    section, I describe the correct way to build these library modules; in the meantime,
    here are some cheesy commands that will assemble these files without error (though
    there will be a warning):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will assemble the files without running the linker (-c means *compile only*),
    generating the files *str.cpy.o*, *str.cmp.o*, *str.substr.o*, *str.bufInit.o*,
    *str.alloc.o*, and *str.free.o*, respectively. Of course, the next question is
    how to link these files with an application program. Listing 15-1 is an amalgamation
    of various asmMain functions from [Chapter 14](chapter14.xhtml) that make calls
    to the str.cpy, str.cmp, and str.substr functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you try to build this program with the following command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'the system will complain that it cannot locate the symbols str.cpy, str.cmp,
    and str.substr in the object files provided. Unfortunately, the *build* shell
    script doesn’t support linking in multiple object modules (other than the *c.cpp*
    and the specified file’s object files). Therefore, you must specify an explicit
    g++ command to process all the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The -DisMacOS command line argument should be changed to -DisLinux when compiling
    the code under Linux or Pi OS (rather than macOS). As you may recall from section
    1.10.1, “Assembling Programs Under Multiple OSes,” on [page 36](chapter1.xhtml#pg_36),
    the *build* shell script determines the OS and emits a g++ command line define
    (the -Dxxxx option) to make the OS known to the assembly source file (and, especially,
    the *aoaa.inc* header file). As this g++ command will attempt to assemble the
    *Listing15-1.S* source file (which includes *aoaa.inc*), the command line must
    include a definition of either isMacOS or isLinux, or the assembly will fail.
  prefs: []
  type: TYPE_NORMAL
- en: This g++ command will compile *c.cpp*, assemble *Listing15-1.S*, and link their
    object files together with the *str.cpy.o*, *str.cmp.o*, and *str.substr.o* object
    files. This assumes, of course, that you’ve already assembled the *str.*.S* source
    files and that their object files are sitting in the current directory. The sample
    program in Listing 15-1 does not call the str.alloc, str.free, or str.bufInit
    functions, so there was no need to link in their respective object code files,
    though doing so would not have generated an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full set of commands needed to build all these files and generate
    and run the Listing 15-1 executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Granted, that’s a lot of typing in order to compile and link a simple source
    file. You could remedy this by putting all the commands into a text file and executing
    them as a shell script (similar to the *build* script), but there’s a better way:
    makefiles.'
  prefs: []
  type: TYPE_NORMAL
- en: 15.5 Introducing Makefiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *build* file used throughout this book has been far more convenient than
    the manual commands needed to build the example of the previous section. Unfortunately,
    the build mechanism that *build* supports is good for only a few fixed source
    files. While you could easily construct a shell script to compile all the files
    in a large assembly project, it would largely defeat the purpose of using separate
    assembly, as running the script file would reassemble every source file in the
    project. Although you can use complex command line functions to avoid some of
    this, it’s easier to use makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: A *makefile* is a script in a language (designed in early releases of Unix)
    that specifies how to execute a series of commands based on certain conditions.
    In its simplest form, a makefile can behave exactly like a shell script; you can
    list a sequence of commands in a text file and have the make program execute them.
    Of course, there would be no benefit over using a shell script if you did this;
    you should take advantage of make’s features if you’re going to use makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The make program is an executable, just like Gas (as) or GCC. As make is not
    a part of the Linux or macOS system, you must obtain a make program before you
    can use it. Fortunately, make comes preinstalled on most Linux and macOS distributions
    (if you can run GCC, you can certainly run make). Execute it from a command line
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you execute make on a command line without any arguments, make will search
    for a file named *Makefile* and attempt to process the commands in that file.
    For many projects, this is very convenient. If you put all your source files in
    a single directory (potentially with subdirectories) along with a single makefile
    (named *Makefile*), you can then change into that directory and execute make,
    building the project with minimal fuss.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you like, you can use a different filename than *Makefile*. Rather than
    simply placing the filename after make on the command line, however, you must
    preface the filename with the make -f option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to give your filename the *.mak* extension, but this is a popular
    convention when using makefiles with custom names.
  prefs: []
  type: TYPE_NORMAL
- en: The make program provides many command line options, and you can list common
    ones by using --help. You can look up make documentation online (or type man make
    from the command line) for a description of the other command line options, but
    most of them are advanced and unnecessary for most tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, to make practical use of make, you need to create makefiles. The
    following subsections describe the make scripting language and some common conventions
    for makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.1 Basic Makefile Syntax
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A makefile is a standard ASCII text file containing a sequence of lines (or
    a set of multiple occurrences of this sequence) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All components of this code—target, dependencies, and commands—are optional.
    The target item is an identifier or filename of some sort that, if present, must
    begin in column 1 of its source line. The dependencies item is a list of filenames
    on which the target depends in order to be built properly. The commands item is
    a list of one or more command line commands, which must have at least one tab
    character in front of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following makefile, which builds a set of string library functions
    (note that a tab appears before each g++ command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If these commands appear in a file named *Makefile* and you execute make, they
    will execute exactly as the command line interpreter would have executed them,
    had they appeared in a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following modification of the previous makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This separates the build commands into two groups: one specified by the executable
    label and another specified by the library label.'
  prefs: []
  type: TYPE_NORMAL
- en: If you run make without any command line options, it will execute only the commands
    appearing after the first target in the file. Therefore, in this example, if you
    run make by itself, it will assemble *Listing15-1.S*, compile *c.cpp*, and attempt
    to link (the resulting) *c.obj* with *str.cpy.o*, *str.cmp.o*, *str.substr.o*,
    and *Listing15-1.o*. Assuming you had previously compiled the string functions,
    this should successfully produce the Listing15-1 executable (without having to
    recompile the string functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'To convince make to process the commands after the library target, you must
    specify the target name as a make command line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This make command compiles *str.cpy.S*, *str.cmp.S*, and *str.substr.S*. If
    you execute this command once (and never change the string functions thereafter),
    you need only execute the make command by itself to generate the executable file.
    You can also use make executable if you want to explicitly state that you are
    building the executable.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to specify which targets you want to build on the command line is
    useful. However, as your projects get larger, with many source files and library
    modules, keeping track of which source files you need to recompile all the time
    can be burdensome and error-prone. If you’re not careful, you’ll forget to compile
    an obscure library module after you’ve made changes to it and wonder why the application
    is still failing. The make dependencies option helps you avoid these problems
    by allowing you to automate the build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of one or more whitespace-separated dependencies can follow a target
    in a makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Dependencies are either target names (of targets appearing in that makefile)
    or filenames. If a dependency is a target name (that is not also a filename),
    make will go execute the commands associated with that target. Consider the following
    makefile (if compiling under Linux or Pi OS, be sure to change the -DisMacOS command
    line option to -DisLinux in this example and all that follow):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The all target in this code does not have any commands associated with it. Instead,
    the all target depends on the library and executable targets, so it will go execute
    the commands associated with those targets, beginning with library. This is because
    the library object files must be built before the associated object modules can
    be linked into the executable program). The all identifier is a common target
    in makefiles. Indeed, it is often the first or second target to appear in a makefile.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a target: dependencies line becomes too long to be readable (make doesn’t
    care much about line length), you can break the line into multiple lines by putting
    a backslash character (\) as the last character on a line. The make program will
    combine source lines that end with a backslash with the next line in the makefile.
    The backslash must be the very last character on the line; whitespace characters
    (tabs and spaces) are not allowed to follow the backslash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Target names and dependencies can also be filenames. Specifying a filename
    as a target name is generally done to tell the make system how to build that particular
    file. For example, you could rewrite the current example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When dependencies are associated with a target that is a filename, you can
    read the target: dependencies statement as “target depends on dependencies.” When
    processing a command, make compares the modification date/timestamp of the files
    specified as target and dependency filenames.'
  prefs: []
  type: TYPE_NORMAL
- en: If the date/time of the target is older than *any* of the dependencies (or the
    target file doesn’t exist), make will execute the commands after the target. If
    the target file’s modification date/time is later (newer) than *all* of the dependent
    files, make will not execute the commands. If one of the dependencies after a
    target is itself a target elsewhere, make will first execute that command (to
    see if it modifies the target object, changing its modification date/time, and
    possibly causing make to execute the current target’s commands). If a target or
    dependency is just a label (not a filename), make will treat its modification
    date/time as older than any file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following modification to the running makefile example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code has removed all and library targets, as they turn out to be unnecessary,
    and changed executable to Listing15-1, the final target executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Because str.cpy.o, str.cmp.o, str.substr.o, and Listing15-1.o are all targets
    (as well as filenames), make will first go process those targets. After that,
    make will compare the modification date/time of Listing15-1 against that of the
    four object files. If Listing15-1 is older than any of those object files, make
    will execute the command following the Listing15-1 target line (to compile *c.cpp*
    and link it with the object files). If Listing15-1 is newer than its dependent
    object files, make will not execute the command.
  prefs: []
  type: TYPE_NORMAL
- en: The same process happens, recursively, for each of the dependent object files
    following the Listing15-1 target. While processing the Listing15-1 target, make
    will also process the str.cpy.o, str.cmp.o, str.substr.o, and Listing15-1.o targets
    (in that order). In each case, make compares the modification date/time of the
    *.o* file with the corresponding *.S* file. If the *.o* file is newer than the
    *.S* file, make returns to processing the Listing15-1 target without doing anything;
    if the *.o* file is older than the *.S* file (or doesn’t exist), make executes
    the corresponding g++ command to generate a new *.o* file.
  prefs: []
  type: TYPE_NORMAL
- en: If Listing15-1 is newer than all the *.o* files (and they are all newer than
    the *.S* files), then executing make simply reports that Listing15-1 is up-to-date,
    but it will not execute any of the commands in the makefile. If any of the files
    are out-of-date (because they’ve been modified), this makefile will compile and
    link only the files necessary to bring Listing15-1 up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: 'The makefiles have a pretty serious defect thus far: they are missing an important
    dependency. Since all the *.S* files include the *aoaa.inc* file, a change to
    *aoaa.inc* could possibly require a recompilation of these *.S* files. Listing
    15-2 adds this dependency to the *Listing15-2.mak* makefile, and it also demonstrates
    how to include comments in a makefile by using the # character at the beginning
    of a line.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of executing make (under macOS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To execute this command under Linux or Pi OS, don’t forget to change all the
    -DisMacOS command line options to -DisLinux in the makefile and make sure all
    commands have a tab in column 1\. If you want to be able to automatically compile
    the code for any OS, simply steal the code from the *build* script that sets up
    a shell variable with the appropriate command line option, as shown in Listing
    15-3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first statement ❶ is an example of a makefile *macro* (or *variable*). The
    OS command uname will display the OS (kernel) name. Under Linux systems, this
    will be replaced by the string Linux, and on macOS systems by the string Darwin
    (the internal name of the macOS kernel).
  prefs: []
  type: TYPE_NORMAL
- en: 'Makefile macros use deferred execution. This means that the macro unamestr
    actually contains the text `uname` and that the uname command will execute in
    place when the make program expands the unamestr macro. The make program will
    expand the -D$(unamestr) command line option, producing -D`uname` ❷. The backticks
    (`) tell make to execute the command and replace it with the text printed by the
    command: the OS kernel name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only issue is that the uname command prints Linux or Darwin, so the -D
    command defines one of these two symbols. The *build* script translates these
    strings to isMacOS and isLinux. I originally did this because the symbol Linux
    would likely appear in a Linux-based assembly language program. Unfortunately,
    the symbol translation trick didn’t work out in a makefile, so I modified *aoaa.inc*
    to accept Linux and Darwin as well as inLinux and inMacOS. I modified *aoaa.inc*
    to do the translation and undefine Linux or Darwin, should those symbols get used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the execution of the make command to build the code for Listing 15-3
    (assuming no object files were already created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that -D`uname` is translated to either -DLinux or -DDarwin, depending on
    the OS.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5.2 Make Clean and Touch
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One common target you will find in most professionally made makefiles is clean,
    which deletes an appropriate set of files to force the entire system to be remade
    the next time you execute the makefile. This command typically deletes all the
    *.o* and executable files associated with the project.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-4 provides an example clean target for the makefile appearing in
    Listing 15-3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Issuing the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: will delete all the executable and object code files associated with the project.
  prefs: []
  type: TYPE_NORMAL
- en: To force the recompilation of a single file (without manually editing and modifying
    it), you can use the Unix utility touch. This program accepts a filename as its
    argument and updates the modification date/time of the file (without otherwise
    modifying the file). For example, after building *Listing15-1.S* using the makefile
    in Listing 15-4, were you to execute the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: and then re-execute the makefile in Listing 15-4, make would reassemble the
    code in *Listing15-1.S*, recompile *c.cpp*, and produce a new executable.
  prefs: []
  type: TYPE_NORMAL
- en: 15.6 Generating Library Files with the Archiver Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many common projects reuse code the developers created long ago, or code from
    a source outside the developer’s organization. These libraries of code are relatively
    *static*: they rarely change during the development of a project that uses them.
    In particular, you would not usually incorporate the building of the libraries
    into a given project’s makefile. A specific project might list the library files
    as dependencies in the makefile, but the assumption is that the library files
    are built elsewhere and supplied as a whole to the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond that, there is one major difference between a library and a set of object
    code files: packaging. Dealing with a myriad of separate object files becomes
    troublesome when you’re working with large sets of library object files. A library
    may contain tens, hundreds, or even thousands of object files. Listing all these
    object files (or even just the ones a project uses) is a lot of work and can lead
    to consistency errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The common way to deal with this problem is to combine object files into a
    separate package (file) known as a *library file*. Under Linux and macOS, library
    files typically have a *.a* suffix (where *a* stands for *archive*). For many
    projects, you will be given a library file that packages together a specific library
    module. You supply this file to the linker when building your program, and the
    linker automatically picks out the object modules it needs from the library. This
    is an important point: including a library while building an executable does not
    automatically insert all the code from that library into the executable. The linker
    is smart enough to extract only the object files it needs and to ignore the object
    files it doesn’t use (remember, a library is just a package containing a bunch
    of object files).'
  prefs: []
  type: TYPE_NORMAL
- en: How do you create a library file? The short answer is, “By using the archiver
    program (ar).” Here is its basic syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'where libname.a is the name of the library file you want to produce and list-of-.o-files
    is a (space-separated) list of object filenames you want to collect together into
    the library. For example, here’s the command to combine the *print.o* and *getTitle.o*
    files into a library module (*aoaalib.a*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The rcs component is actually a series of three command options. The r option
    tells the command to replace existing (if present) object files in the archive;
    c says to create the archive (you generally don’t specify this option if you are
    adding object files to an existing archive file); and s says to add an index to
    the archive file, or update the index if it already exists. (For more ar command
    line options, see section 15.9, “For More Information,” on [page 887](chapter15.xhtml#pg_887).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a library module, you can specify it on a linker (or ld or gcc)
    command line just as you would an object file. For example, if you build a *strings.a*
    library module to hold the *str.cpy.o*, *str.cmp.o*, *str.substr.o*, *str.bufInit.o*,
    *str.free.o*, and *str.alloc.o* object files, and you want to link *strings.a*
    with the program in Listing 15-1, you could use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Listing 15-5 is an example of a makefile that will build the *strings.a* library
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Listing 15-6 modifies the Listing 15-5 makefile that builds the code by using
    the *strings.a* library module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the clean command does not delete the library files. If you want
    a clean library build, just specify the lib command line option when running make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As a general rule, you build the library code independently of the application
    code. Most of the time, the library is prebuilt, and you don’t have to rebuild
    it. However, *strings.a* must be a dependency of the application, because if the
    library changes, you’ll probably need to rebuild the application as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more Unix utility is useful for processing library files: nm (names). The
    nm utility will list all the global names found in a library module. For example,
    the command'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: lists all the (global) symbols found in the *strings.a* library file (it’s rather
    long, so I won’t provide the printout here).
  prefs: []
  type: TYPE_NORMAL
- en: 15.7 Managing the Impact of Object Files on Program Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic unit of linkage in a program is the object file. When combining object
    files to form an executable, the linker will take all the data from a single object
    file and merge it into the final executable. This is true even if the main program
    doesn’t call all the functions (directly or indirectly) in the object module or
    use all the data in that object file. If you put 100 routines in a single assembly
    language source file and compile them into an object module, the linker will therefore
    include the code for all 100 routines in your final executable, even if you use
    only one of them.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this situation, you can break those 100 routines into 100 separate
    object modules and combine the resulting 100 object files into a single library.
    When the linker processes that library file, it will pick out the single object
    file containing the function the program uses and incorporate only that file into
    the final executable.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, this is far more efficient than linking in a single object file with
    100 functions buried in it. However, in some cases, there are good reasons to
    combine multiple functions into a single object file. First, consider what happens
    when the linker merges an object file into an executable. To ensure proper alignment,
    whenever the linker takes a section/segment (for example, the .code section) from
    an object file, it adds sufficient padding so that the data in that section is
    aligned on that section’s specified alignment boundary. Most sections have a default
    16-byte section alignment. This means that the linker will align each section
    from the object file it links on a 16-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, this isn’t much of a problem, especially if your procedures are large.
    However, if those 100 procedures are all really short (a few bytes each), you
    wind up wasting a lot of space. Granted, on modern machines, a few hundred bytes
    of wasted space isn’t a big deal. Still, it might be more practical to combine
    several of these procedures into a single object module (even if you don’t call
    all of them) to fill in some of the wasted space. Look for elements that are naturally
    paired or otherwise used together or have a dependency, such as alloc and free.
    Don’t go overboard, though. Once you’ve gone beyond the alignment, whether you’re
    wasting space because of padding or wasting space because you’re including code
    that never gets called, you’re still wasting space.
  prefs: []
  type: TYPE_NORMAL
- en: 15.8 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you write large applications in assembly language, you’ll want to break the
    source code into various modules and automate building the application from those
    modules. This chapter began by discussing Gas’s mechanisms for sharing external
    and public symbols between modules. It then introduced the make application for
    building applications from multiple source files, then covered how to build library
    modules by using the linker and archiver applications.
  prefs: []
  type: TYPE_NORMAL
- en: One large source of library code is the OS kernel (macOS, Linux, or Pi OS).
    However, don’t link OS library functions into your applications; that code is
    already present in memory when your application runs. To call an OS function,
    you use an OS API invocation sequence. The next chapter discusses how to call
    OS functions in the Linux (Pi OS) and macOS (Darwin) kernels.
  prefs: []
  type: TYPE_NORMAL
- en: 15.9 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For information about makefiles, check out the following websites:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer Hope: *[https://<wbr>www<wbr>.computerhope<wbr>.com<wbr>/unix<wbr>/umake<wbr>.htm](https://www.computerhope.com/unix/umake.htm)*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GNU make: *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/make<wbr>/](https://www.gnu.org/software/make/)*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wikipedia: *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Make<wbr>_(software)](https://en.wikipedia.org/wiki/Make_(software))*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also check out the following books on make:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Robert Mecklenburg, *Managing Projects with GNU Make: The Power of GNU Make
    for Building Anything*, 3rd edition (O’Reilly Media, 2004). You can also access
    this book online at *[https://<wbr>www<wbr>.oreilly<wbr>.com<wbr>/openbook<wbr>/make3<wbr>/book<wbr>/index<wbr>.csp](https://www.oreilly.com/openbook/make3/book/index.csp)*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: John Graham-Cumming, *The GNU Make Book,* 1st edition (No Starch Press, 2015)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Andrew Oram and Steve Talbott, *Managing Projects with Make* (O’Reilly & Associates,
    2004)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: See *[https://<wbr>man7<wbr>.org<wbr>/linux<wbr>/man<wbr>-pages<wbr>/man1<wbr>/ar<wbr>.1<wbr>.html](https://man7.org/linux/man-pages/man1/ar.1.html)*
    for a complete list of the ar command line options. You can also enter ar --help
    or man ar for online help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
