## **14**

**TRANSITIONS AND ANIMATIONS**

![Image](graphics/common-01.jpg)

We often think of web pages as having three layers: content (HTML), presentation (CSS), and behavior (JavaScript), and the general understanding is that these layers should all be kept absolutely separate—don’t use presentational or behavioral rules in the content layer (in other words, no CSS or JavaScript inline in the markup). This separation is not quite as clear cut as it seems, however—for a start, CSS has always included some behavioral aspects (the `:hover` pseudo-class being a prime example).

This line between presentation and behavior was blurred even further when the WebKit developers introduced two new behavioral modules that have been adopted as CSS3 components: Transitions and Animations. These modules allow for the animation of element properties, adding movement to otherwise static pages even when JavaScript is not available.

Some have argued—and perhaps still do—about whether the Transitions and Animations Modules should be included in CSS, as they fall firmly in the behavioral layer. But, as the W3C has decided to offer them for discussion as an “official” part of CSS3, we no longer need to debate the ethics of them—we can just have fun with them, instead!

The difference between transitions and animations is that the former are *implicit* and the latter are *declared*. That means transitions only take effect when the property they are applied to changes value, whereas animations are explicitly executed when applied to an element.

I’ll start this chapter with a look at the Transitions Module, as it is the simpler of the two modules; however, both modules have a lot of syntax in common, so much of what you learn from one can be directly applied to the other.

### **Transitions**

CSS2.1 has no in-between states: When the value of a property changes, the change is abrupt. Consider an element with a width of 10em, which changes to a width of 20em when you hover your mouse over it. You’ll notice the element does not progress smoothly between the two states but jumps instantly between them. CSS3 changes this behavior with the introduction of the Transitions Module (*[http://www.w3.org/TR/css3-transitions/](http://www.w3.org/TR/css3-transitions/)*). In CSS, a *transition* is an animation that moves a property between two states.

As I mentioned in the introduction to this chapter, transitions are an *implicit* animation, which means they are triggered only when a new value is set for a CSS property—this could be when new values are applied on hover or through JavaScript manipulation. For a transition to occur, four conditions must be in place: an initial value, an end value, the transition itself, and a trigger.

Here’s an example of those four conditions in a simple transition (don’t worry about the properties I’ve used just yet; I’ll explain everything in due course):

```
div {
    background-color: black;
    transition: background-color 2s;
}
div:hover { background-color: silver; }
```

The `div` element provides the initial value (`background-color: black`) and the transition (`background-color 2s`). The trigger is the `:hover` pseudo-class, which sets the end value (`silver`) for the `background-color` property.

So here we have a `div` element with a black background that, when the mouse is passed over it, transitions smoothly to silver. All transitions act in reverse when the trigger is no longer active, so when the mouse is moved off of the `div`, the background smoothly transitions back to black.

Now that you have a general idea of how transitions work, I’ll explore each of the transition properties in turn.

**NOTE**
*The transition properties are implemented in all modern browsers, including mobile, without vendor prefix. To cater to older versions of WebKit-based browsers, however—especially Safari and versions previous to 4.4 of Android—you should also duplicate your rules with the* `*-webkit-*` *prefix.*

#### ***transition-property***

The first new property, `transition-property`, specifies which property (or properties) of an element will be animated (that’s the most number of times I’ve ever said *property* in a single sentence). Here’s the syntax:

```
E { transition-property: keyword; }
```

An acceptable keyword value is either `all` or `none` or a valid CSS property. The default value is `all`, which means every valid property will be animated. I stress *valid* CSS property because not every property can be transitioned; the specification has a full list of the ones that can at *[http://www.w3.org/TR/css3-transitions/#properties-from-css-/](http://www.w3.org/TR/css3-transitions/#properties-from-css-/)*.

Here’s an example of `transition-property`:

```
h1 {
    font-size: 150%;
    transition-property: font-size;
}
```

This code sets an initial value of `150%` on the `font-size` property and declares this is the property that will be transitioned when the (not yet specified) trigger is activated. Note that I will add properties to this example throughout the rest of this section before showing the completed example in action in “[The Complete Transition Example](ch14.html#ch14leve1sec172)” on [page 173](ch14.html#page_173).

#### ***transition-duration***

The next property is `transition-duration`, which defines the length of time that the transition takes to complete. Here’s the syntax:

```
E { transition-duration: time; }
```

The `*time*` value is a number with a unit of *ms* (*milliseconds*) or *s* (*seconds*). Because 1000 milliseconds equals 1 second, a value of `1.25s` is the same as `1250ms`. The default value is `0` (zero), meaning this property is the only one required to create a transition. A transition can occur if you declare a `transition-duration` without a `transition-property` (as that defaults to `all`, so all valid properties will animate) but not vice versa.

To make the example transition from the previous section happen over a period of two seconds, you add this code:

```
h1 {
    font-size: 150%;
    transition-property: font-size;
    transition-duration: 2s;
}
```

Although you can supply negative values to this property, they will be interpreted as the default `0`.

#### ***transition-timing-function***

To control the manner in which an element transitions between states, you use the `transition-timing-function` property. This property allows for variations in speed along the duration of the transition, which gives you control over the animation’s pace. This property has three different value types: a keyword, the `cubic-bezier()` function, or the `steps()` function. I’ll discuss those two functions in detail, but to begin, I’ll focus on the keywords.

##### **Timing Function Keywords**

The syntax of the `transition-timing-function` property when used with a keyword is quite straightforward:

```
E { transition-timing-function: keyword; }
```

The possible keyword values are `ease`, `linear`, `ease-in`, `ease-out`, and `ease-in-out`. The default value is `ease`, which starts slowly, accelerates quickly, and slows down again at the end. The `linear` value progresses steadily from the start of the transition to the end, with no variation in speed. With the `ease-in` value, the animation begins slowly and then speeds up toward the end, and the `ease-out` value acts in reverse. Finally, `ease-in-out` starts slowly, speeds up through the middle, and then slows down again at the end, similar to—but less dramatic than—the `ease` value.

With that explained, let’s add a simple timing function to the example transition:

```
h1 {
    font-size: 150%;
    transition-property: font-size;
    transition-duration: 2s;
    transition-timing-function: ease-out;
}
```

##### **The Cubic Bézier Curve**

If you want finer control over the `transition-timing-function` property, you should use the `cubic-bezier()` function. In case you’re not familiar with cubic Bézier curves—and indeed, why would you be?—allow me to explain. First, here’s the syntax:

```
E { transition-timing-function: cubic-bezier(x1, y1, x2, y2); }
```

A cubic Bézier curve is a smooth, continuous curve that passes through four points plotted on a grid that goes from 0 to 1 along both axes. The four points are known as *P[0]*, *P[1]*, *P[2]*, and *P[3]*. They define curvature and are plotted with pairs of (*x*, *y*) coordinates, where the first (*P[0]*) is always at (0, 0) and the last (*P[3]*) is always at (1, 1). The other two points are defined in the function: (*x1*, *y1*) and (*x2*, *y2*). An example, shown in [Figure 14-1](ch14.html#ch14fig1), illustrates this best.

![Image](graphics/f14-01.jpg)

*Figure 14-1: An example of a cubic Bézier curve*

[Figure 14-1](ch14.html#ch14fig1) shows the four points mapped onto the grid to create a Bézier curve. The coordinates of each point are shown in [Table 14-1](ch14.html#ch14table1).

**Table 14-1:** The Coordinate Points Used to Plot a Bézier Curve

| **Point** | **Coordinates (x, y)** |
| *P[0]* | (0, 0) |
| *P[1]* | (0.6, 0.1) |
| *P[2]* | (0.15, 0.7) |
| *P[3]* | (1.0, 1.0) |

You would use the following CSS to represent this curve (remember, you don’t need to define *P[0]* and *P[3]* because they always have the same values):

```
E { transition-timing-function: cubic-bezier(0.6, 0.1, 0.15, 0.7); }
```

A linear animation progresses in a straight line from (0, 0) to (1, 1), but this example animation follows the progression of the curve toward the final point over the set duration. If you imagine the duration to be 1 second, you can see the speed gradually increases at the start, between 0 and (roughly) 0.5 seconds, and then increases sharply to about 0.7 seconds, and then assumes a slower rate until the end of the animation.

All of the `transition-timing-function` keywords described earlier are produced with cubic Bézier curves. [Table 14-2](ch14.html#ch14table2) shows each of the keywords and their corresponding values for the `cubic-bezier()` function.

**Table 14-2:** Comparing `transition-timing-function` Keywords with Their Equivalent Cubic Bézier Values

| **Keyword Value** | **Cubic Bézier Value** |
| `ease` | 0.25, 0.1, 0.25, 1 |
| `linear` | 0, 0, 1, 1 |
| `ease-in` | 0.42, 0, 1, 1 |
| `ease-out` | 0, 0, 0.58, 1 |
| `ease-in-out` | 0.42, 0, 0.58, 1 |

As with the transformation matrices I introduced in [Chapter 13](ch13.html#ch13), `cubic-bezier()` functions can be quite daunting if you’re not used to math. But don’t worry—you can always use the keyword values, which will be more than sufficient in most cases.

A great tool to make cubic Bézier curves a little easier is Lea Verou’s *[http://cubic-bezier.com/](http://cubic-bezier.com/)*. This tool allows you to create your own curves using a visual interface, see them run in real time compared to the keyword aliases, and export them as `cubic-bezier()` functions—a really useful aid to understanding.

##### **The steps() Function**

An alternative to smooth, eased transitions is to use the `steps()` function, which runs the animation in a series of staggered intervals. The syntax of the function looks like this:

```
E { transition-timing-function: steps(count, direction); }
```

The `*count*` value is an integer that states how many intervals the animation should run through, and the optional `*direction*` is one of two keywords—`start` or `end` (the default)—that sets the point at which the change happens in each interval. That probably doesn’t make a lot of sense right now, but bear with me.

Let’s see a very simple example of how the `steps()` works. Take a look at the following rule, in which the `steps()` function has a step count argument of `4` and uses the simple form of the function by omitting the optional direction keyword:

```
E { transition-timing-function: steps(4); }
```

Visualized on the timing function grid used for the `cubic-bezier()` function, it would look like [Figure 14-2](ch14.html#ch14fig2). So rather than a single line of transition, steps are like seeing snapshots of the animation in action.

![Image](graphics/f14-02.jpg)

*Figure 14-2: A transition over four stepped intervals*

When an animation is displayed in steps, use the `*direction*` keyword to select when the change of each step occurs: the default `end` keyword means the change happens at the end of the step (pause, then change), and the alternative `start` means the change happens at the start of the step (change, then pause).

This process is also easier to visualize on the timing function grid; in the following code, the same step count is shown with differing direction keywords:

```
E { transition-timing-function: steps(4, start); }
E { transition-timing-function: steps(4, end); }
```

You can see the difference in [Figure 14-3](ch14.html#ch14fig3), and I strongly urge you to take a look, if you can, at the accompanying example file (available from *[http://thebookofcss3.com/](http://thebookofcss3.com/)*)—seeing the two in action is the best way to understand the difference.

![Image](graphics/f14-03.jpg)

*Figure 14-3: Comparing direction keywords:* `*start*` *(left) and* `*end*` *(right)*

#### ***transition-delay***

The final property in the `transition-*` family is `transition-delay`, which sets the time when the transition starts. Here’s the syntax:

```
E { transition-delay: time; }
```

As with `transition-duration`, the `*time*` value is a number with a unit of either milliseconds (`ms`) or seconds (`s`). The default value is `0` (zero), meaning the transition happens as soon as the trigger is … well, triggered. Any other positive value starts the transition after the specified length of time has passed.

For example, if you wanted to set a delay of a quarter of a second at the start of the example transition, here’s the code you would use:

```
h1 {
    font-size: 150%;
    transition-property: font-size;
    transition-duration: 2s;
    transition-timing-function: ease-out;
    transition-delay: 250ms;
}
```

You can also use negative values for `transition-delay`, which has an interesting effect: The transition begins immediately but skips ahead by the amount of the negative value. To illustrate what I mean, let’s consider a transition with a duration of `4s` but a delay of `-2s`:

```
E {
    transition-duration: 4s;
    transition-delay: -2s;
}
```

When triggered, the transition starts immediately, but as if two seconds had already passed (two seconds being the duration minus the delay). In this case, the animation would start halfway through the transition.

#### ***The transition Shorthand Property***

Throughout this section, I’ve built an example transition property by property. So far, the code looks like this:

```
h1 {
    transition-property: font-size;
    transition-duration: 2s;
    transition-timing-function: ease-out;
    transition-delay: 250ms;
}
```

This code seems like quite a lot to write for each transition. But, as with all of the other CSS properties that are part of a “family” (`background-*`, `border-*`, and so on), the `transition-*` family has a shorthand. Here’s the syntax:

```
E { transition: property duration timing-function delay; }
```

One important thing to be aware of here is that there are two time values: `transition-duration` and `transition-delay`, which must be declared in that order. If only one is declared, the syntax presumes it is `transition-duration`, and the `transition-delay` will be set at the default (or inherited) value.

If you use the values from the example transition with the shorthand property, here’s the result:

```
h1 { transition: font-size 2s ease-out 250ms; }
```

It’s quite apparent that this is a lot less code to write.

#### ***The Complete Transition Example***

Now that I’ve explained all of the component properties, let’s take a look at the example transition in action. The full code is shown here:

```
h1 {
    font-size: 150%;
    transition: font-size 2s ease-out 250ms;
}
h1:hover { font-size: 600%; }
```

[Figure 14-4](ch14.html#ch14fig4) shows what happens when I pass my mouse over the `h1` element.

![Image](graphics/f14-04.jpg)

*Figure 14-4: Three stages of an animated transition on the* `*font-size*` *property*

Obviously, I can’t show the full animation on the printed page, but the illustration shows three stages of the transition: the initial, pre-transition stage (left) with a font size of 150 percent; an intermediate, mid-transition stage (center), which is just under two seconds into the animation when the font size has increased; and the final, post-transition stage (right) where the font size is 600 percent.

As I’ve already mentioned, transitions act in reverse when the condition that acts as a trigger is no longer being met, so when you remove your mouse from over the `h1` element, you can read this example from right to left to see what will happen.

#### ***Multiple Transitions***

You can easily add multiple transitions to an element by providing a list of comma-separated values to the individual or shorthand properties. That being the case, both of the following code examples are valid:

```
E {
    transition-property: border-width, height, padding;
    transition-duration: 4s, 500ms, 4s;
}
E { transition: border-width 4s, height 500ms, padding 4s; }
```

Note that if a property has fewer values than the others, that list of values will be looped. With that in mind, you could rewrite this code example slightly:

```
E {
    transition-property: border-width, height, padding;
    transition-duration: 4s, 500ms;
}
```

Here, `transition-property` has three values, whereas `transition-duration` has only two. This means the third value of the former (`padding`) is matched with the first value of the latter (`4s`), matching what was supplied in the first example.

Here’s a practical example:

```
.widget {
    background-color: black;
    left: 10%;
    top: 60%;
    transition: background-color 4s linear, left 2s ease-in-out, top 2s ease-in-out;
}
div:hover .widget {
    background-color: silver;
    left: 75%;
    top: 10%;
}
```

Here, I’ve used the `transition` shorthand to apply three transitions. The first transition changes the `background-color` from `black` to `silver` in a `linear` timing function, and the next two change the `left` and `top` properties with `ease-in-out` timing functions. The `background-color` transition takes place over four seconds, and the others, over two.

[Figure 14-5](ch14.html#ch14fig5) shows three stages of the transition: The first stage (left) shows the element pre-transition, with a black background and positioned at the bottom left of its parent element; the next stage (center) is mid-transition, as the element is changing color and moving to the top right of its parent; and the final stage (right) shows the element post-transition, with a silver background and in its final position.

![Image](graphics/f14-05.jpg)

*Figure 14-5: Three stages of an animated transition on the* `*background-color*`, `*left*`*, and* `*top*` *properties*

### **Animations**

Transitions are good but naturally limited; they are only applied when a property value changes. The CSS3 Animations Module (*[http://www.w3.org/TR/css3-animations/](http://www.w3.org/TR/css3-animations/)*) goes beyond what is possible with transitions, allowing animations to be applied directly to elements with a syntax that is more flexible and permits more granular control. Animations and transitions have quite a lot of syntax in common, but the process for creating animations is very different: First, you define the properties and timings, and then you add the animation controls to the elements that will be animated.

**NOTE**
*CSS animations are implemented in IE10+ and all other modern browsers, but, as of the time of writing, you’ll still need to use the* `*-webkit-*` *vendor prefix for Chrome and Safari, on both desktop and mobile.*

#### ***Keyframes***

You can think of CSS animations as a series of transitions, chained into a sequence. The first step in creating your own animations is to define your *keyframes*, which are the points that set the start and end of a transition. The most simple animation has two keyframes—one at the start and one at the end—whereas more complex ones have multiple keyframes in between. [Figure 14-6](ch14.html#ch14fig6) illustrates how an animation with three keyframes would appear.

In CSS, keyframes are declared in the `@keyframes` rule, which has the following syntax:

```
@keyframes name {
    selector { property : value; }
}
```

![Image](graphics/f14-06.jpg)

*Figure 14-6: An animation with three keyframes and transitions between each*

**NOTE**
*Remember you’ll also have to duplicate your keyframe ruleset to accommodate WebKit-based browsers. Use the WebKit prefix:* `*@-webkit-keyframes*`.

The first value for the `@keyframes` rule is `*name*`; this unique identifier is used to call the animation, which I’ll discuss later. You can use pretty much any value here (use hyphen separation, not spaces, if you want a name with multiple words), although I suggest using a word or term that is relevant to the animation it describes—your stylesheets will be much easier to follow if you do.

The next value, `*selector*`, sets the position along the duration of the animation that the keyframe will occur. The usual value here is a percentage value; for example, if you want the keyframe to occur halfway through your animation, use `50%`. You can also use one of the keywords, `from` or `to`, which are analogous to 0 percent and 100 percent, respectively.

Within each keyframe selector is a CSS declaration or series of declarations that are applied to a selected element at the specified stage of the animation. If this is all blowing your mind, let me clarify with an example. The following code describes a simple animation, which I’ve named *expand*, with three keyframes:

```
  @keyframes expand {
➊ from { border-width: 4px; }
➋ 50% { border-width: 12px; }
➌ to {
➍     border-width: 4px;
          height: 100%;
          width: 100%;
      }
  }
```

At the beginning of the animation (➊), the selected element has a border that is `4px` wide; halfway through the animation (➋), the border is increased to a width of `12px`; and at the end of the animation(➌), the border is back to `4px` wide, and the height and width are both `100%`. Between each of the keyframes, the elements are animated gradually, so between the start and halfway through the animation, the border is animated to change width smoothly from `4px` to `12px`.

Note that inheritance operates on individual keyframes, so if you want a change to persist between frames, you need to specify it in each frame. If I hadn’t specified `border-width` again in the `to` keyframe (➍), it would default to the inherited value of the element the animation was applied to, meaning the animation would be quite different.

Keyframe selectors can be chained just like other CSS selectors, so I could write the previous code example like this:

```
@keyframes expand {
    from, to { border-width: 4px; }
    50% { border-width: 12px; }
    to {
        height: 100%;
        width: 100%;
    }
}
```

Likewise, you are not required to list the keyframe selectors in time order; putting `to` before `from` is perfectly acceptable (although harder to maintain, I bet), and any declaration conflicts are resolved by using the cascade: Rules declared later take preference. For example, take a look at the following keyframe ruleset where two keyframes have been defined at the same point:

```
@keyframes example {
    10% { background-color: red; }
    10% { background: green; }
}
```

When the animation is applied, the element’s background color will be `green` at the `10%` point, as the rule declared later would apply.

Once you’ve defined the keyframes, the next step is to apply animation control properties to the elements you want to animate. As I mentioned in the introduction to this section, many of the animation properties share syntax with their counterparts in the `transition-*` family, so you should already be pretty familiar with them.

#### ***animation-name***

The `animation-name` property refers to an animation that’s been defined with the `@keyframes` rule, and, as such, the syntax is quite straightforward:

```
E { animation-name: name; }
```

You can see it requires only a single value, which is the name of an already defined animation. To call the animation created in the previous section, you use this:

```
div { animation-name: expand; }
```

The only other permissible value (and the default) is `none`, which prevents any animations from occurring on this element.

#### ***animation-duration***

The duration of an animation is set by the `animation-duration` property, which is functionally identical to the `transition-duration` property introduced earlier in this chapter:

```
E { animation-duration: time; }
```

As with `transition-duration`, the `*time*` value is a number with a unit of either ms or s, or a `0` (zero), which prevents the animation from running. (Negative values are also implemented as `0`.) To extend the example animation so it’s six seconds in duration, you add this line:

```
div { animation-duration: 6s; }
```

#### ***animation-timing-function***

Another property that should be familiar is `animation-timing-function`, which again is functionally identical to its counterpart `transition-timing-function`:

```
E { animation-timing-function: value; }
```

Permitted values are the timing function keywords (`ease`, `linear`, `ease-in`, `ease-out`, and `ease-in-out`), the `cubic-bezier()` function (explained in “[The Cubic Bézier Curve](ch14.html#ch14leve1sec168)” on [page 168](ch14.html#page_168)), or the `steps()` function (explained in “[The `steps()` Function](ch14.html#ch14leve1sec169)” on [page 170](ch14.html#page_170)). Therefore, if you want to make your animation “ease in” at the start, you add this code:

```
div { animation-timing-function: ease-in; }
```

#### ***animation-delay***

Yet another familiar property is `animation-delay`, which is identical in function to its counterpart, the `transition-delay` property:

```
E { animation-delay: time; }
```

Like `animation-duration` (and the two corresponding `transition-*` properties), the time value is a number with a unit of either ms or s, which sets the delay before an animation begins. A `0` (zero) means no delay. As with `transition-duration`, negative values cause the animation to “skip” by that amount.

To delay the example animation by two seconds, you include this code:

```
div { animation-delay: 2s; }
```

#### ***animation-iteration-count***

Unlike a transition, which only happens once (or twice, if you want to count the reverse), an animation can be repeated any number of times. The number of repetitions is set by the `animation-iteration-count` property, which has this syntax:

```
E { animation-iteration-count: count; }
```

The `*count*` value in this syntax is either a whole number or the keyword `infinite`. A number value sets how many times the animation repeats. The default value is `1` (one), meaning the animation plays from start to end once and then stops. The `infinite` value means the animation loops indefinitely or at least until another condition is met that changes this value. A value of `0` (zero) or any negative number prevents the animation from playing.

To continue with the example I’ve built throughout this section, if I want the animation to repeat 10 times, I need to add the following declaration:

```
div { animation-iteration-count: 10; }
```

#### ***animation-direction***

Animations play from start to finish, but they can also play in reverse. You can set whether your animation always plays in one direction or alternates playing forward and backward. To do this, use the `animation-direction` property:

```
E { animation-direction: keyword; }
```

The keyword value has two options: `normal` or `alternate`. The default is `normal`, which always plays the animation forward: The animation plays through from start to finish, and then, if it is set to repeat, it plays again from the start. If the `alternate` value is used, the animation plays from start to finish and then plays in reverse before starting over again. If you consider each iteration of the animation as a “cycle,” the odd-numbered cycles play forward and the even-numbered play backward. You can see the difference in [Figure 14-7](ch14.html#ch14fig7).

To complete the example animation, let’s set the animation to `alternate` forward and backward:

```
div { animation-direction: alternate; }
```

![Image](graphics/f14-07.jpg)

*Figure 14-7: An animation played in the* `*normal*` *direction repeats itself from start to finish; when played using* `*alternate*`*, each second cycle plays finish to start.*

#### ***animation-fill-mode***

If your animation is finite—that is, if it doesn’t have an infinite value for the `animation-iteration-count` property—then you use the `animation-fill-mode` property to set how the element appears outside of the animation cycle. To show you what I mean by that, let’s consider the following style rules:

```
@keyframes example {
    from { background-color: red; }
    to { background-color: blue; }
}
E {
    animation-delay: 1s;
    animation-duration: 1s;
    animation-iteration-count: 2;
    animation-name: example;
    background-color: green;
}
```

In this rule, element `*E*` will be `green` for the `1s` delay before the animation is triggered, then instantly change to `red`, then transition to `blue`, iterating twice (`2`), and then at the end revert back to the initial `green`.

You can change this behavior with `animation-fill-mode`. The syntax looks like this:

```
E { animation-fill-mode: keyword; }
```

The permitted keywords are `none` (the default), `backwards`, `forwards`, or `both`. If you use `backwards`, the declarations specified in the `0%` (or `from`) keyframe will be applied to the element before the animation begins; if you use `forwards`, the declarations in the `100%` (or `to`) keyframe will be applied when the animation ends; or if you use `both`, the `0%` declarations will apply before the animation and the `100%`, after.

So returning to the previous example code, if you add the following rule:

```
E { animation-fill-mode: both ; }
```

then element `*E*` would begin `red`, before transitioning to `blue` and staying that color at the end of the animation; its original `green` wouldn’t be applied at any point.

#### ***animation-play-state***

The `animation-play-state` property sets whether an animation is active. Here’s the syntax:

```
E { animation-play-state: keyword; }
```

The keyword value has two options: `running` means the animation is playing, and `paused` means it isn’t. You can use this property to perform a play/pause action:

```
E:hover { animation-play-state: paused; }
```

In this example, if you presume that element `*E*` has an animation applied, passing the mouse over the element pauses the animation until the mouse is moved off, at which time the animation continues.

#### ***The animation Shorthand***

Throughout this section, I’ve assembled an example animation one property at a time. Here’s how all the properties combined appear:

```
div {
    animation-name: expand;
    animation-duration: 6s;
    animation-timing-function: ease-in;
    animation-delay: 2s;
    animation-iteration-count: 10;
    animation-direction: alternate;
    animation-fill-mode: forwards;
    animation-play-state: running;
}
```

That’s a lot of properties to declare for each animation. Once again, however, you can take advantage of a shorthand property called `animation`, and here’s the syntax:

```
E { animation: name duration timing-function delay iteration-count direction
fill-mode play-state; }
```

As with the `transition` shorthand, `animation-duration` and `animation-delay` must be specified in order. If either is left out, the syntax presumes it is `animation-delay`, which receives a default value of `0`.

To make the example I’ve been building in this chapter somewhat more compact, I can use this shorthand code:

```
div { animation: expand 6s ease-in 2s 10 alternate both running; }
```

That may still seem verbose, but at its most simple, only two values are required for the `animation` property to function: the name of the keyframe and a duration:

```
div { animation: expand 6s; }
```

#### ***The Complete Animations Example***

With all of the properties explained, let’s take a look at the full example animation in action. Here’s the CSS (some rules have been omitted for brevity; see the example files for the complete code):

```
  @keyframes expand {
➊ 0% { border-width: 4px; }
➋ 50% { border-width: 12px; }
➌ 100% {
           border-width: 4px;
           height: 100%;
           width: 100%;
      }
  }
  div {
      …
      animation: expand 6s ease 0 infinite alternate;
  }
```

Unfortunately, I can’t show animation in this book, so I’ll settle for describing it. [Figure 14-8](ch14.html#ch14fig8) shows the state of the element at three of the animation’s keyframes: The keyframe at `0%` (➊) shows the element with a `border-width` of `4px` and the inherited `height` and `width` (`100px` each, not shown here); in the `50%` keyframe (➋), the `border-width` is increased to `12px`; and in the final, `100%` keyframe (➌), the `border-width` returns to `4px` and both height and width have changed to `100%`.

![Image](graphics/f14-08.jpg)

*Figure 14-8: Three stages of an animation affecting the* `*border-width*`, `*height*`*, and* `*width*` *properties*

Because my `animation-direction` value is `alternate`, the animation would then play in reverse, shrinking back to its original dimensions, and then continue growing and shrinking infinitely because of the value of `animation-iteration-count`.

#### ***Multiple Animations***

You can add multiple animations to an element using a comma-separated list. This method works for each of the subproperties and the shorthand property, so both of these examples are valid:

```
E {
    animation-name: first-anim, second-anim;
    animation-duration: 6s, 1.25ms;
    animation-delay: 0, 750ms;
}
E { animation: first-anim 6s, second-anim 1.25ms 750ms; }
```

Here, lists of values are looped through to ensure that all properties have the same number of values applied, in exactly the same way as described in “[Multiple Transitions](ch14.html#ch14leve1sec173)” on [page 174](ch14.html#page_174).

### **Summary**

Adding animations to CSS was originally considered a contentious move, but I think the syntax used by the writers of these modules is pretty graceful and adds a lot of flexibility without being overwhelmingly complicated.

Developers expressed concern that transitions and animations would be misused and that we’d end up with a lot of garish, unusable websites. Although a genuine concern, one really can’t stop people from doing that now with the existing CSS properties (and, indeed, many do!). But used sparingly and appropriately, these powerful new tools can add vibrancy to web pages.

### **Transitions and Animations: Browser Support**

|  | **Chrome** | **Firefox** | **Safari** | **IE** |
| Transitions | Yes | Yes | Yes | IE10 |
| Animations | Yes^([*](ch14.html#footnote32a)) | Yes | Yes^([*](ch14.html#footnote32a)) | IE10 |

[*](ch14.html#footnote_32a) With vendor prefix