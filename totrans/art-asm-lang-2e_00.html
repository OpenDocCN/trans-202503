<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;HELLO, WORLD OF ASSEMBLY LANGUAGE"><div class="titlepage"><div><div><h1 class="title"><a id="hello_comma_world_of_assembly_language"/>Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e200"/><img alt="HELLO, WORLD OF ASSEMBLY LANGUAGE" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p>This chapter is a "quick-start" chapter that lets you start writing basic assembly language programs as rapidly as possible. This chapter does the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Presents the basic syntax of an HLA (High Level Assembly) program</p></li><li class="listitem"><p>Introduces you to the Intel CPU architecture</p></li><li class="listitem"><p>Provides a handful of data declarations, machine instructions, and high-level control statements</p></li><li class="listitem"><p>Describes some utility routines you can call in the HLA Standard Library</p></li><li class="listitem"><p>Shows you how to write some simple assembly language programs</p></li></ul></div><p>By the conclusion of this chapter, you should understand the basic syntax of an HLA program and should understand the prerequisites that are needed to start learning new assembly language features in the chapters that follow.</p><div class="sect1" title="1.1 The Anatomy of an HLA Program"><div class="titlepage"><div><div><h1 class="title"><a id="the_anatomy_of_an_hla_program"/>1.1 The Anatomy of an HLA Program</h1></div></div></div><p>A typical HLA program takes the form shown in <a class="xref" href="ch01.html#basic_hla_program" title="Figure 1-1. Basic HLA program">Figure 1-1</a>.<a class="indexterm" id="IDX-CHP-1-0001"/><a class="indexterm" id="IDX-CHP-1-0002"/><a class="indexterm" id="IDX-CHP-1-0003"/></p><div class="figure"><a id="basic_hla_program"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e248"/><img alt="Basic HLA program" src="tagoreillycom20100401nostarchimages577855.png.jpg"/></div></div><p class="title">Figure 1-1. Basic HLA program</p></div><p><em class="replaceable"><code>pgmID</code></em> in the template above is a user-defined program identifier. You must pick an appropriate descriptive name for your program. In particular, <em class="replaceable"><code>pgmID</code></em> would be a horrible choice for any real program. If you are writing programs as part of a course assignment, your instructor will probably give you the name to use for your main program. If you are writing your own HLA program, you will have to choose an appropriate name for your project.</p><p>Identifiers in HLA are very similar to identifiers in most high-level languages. HLA identifiers may begin with an underscore or an alphabetic character and may be followed by zero or more alphanumeric or underscore characters. HLA's identifiers are <span class="emphasis"><em>case neutral</em></span>. This means that the identifiers are case sensitive insofar as you must always spell an identifier exactly the same way in your program (even with respect to upper- and lowercase). However, unlike in case-sensitive languages such as C/C++, you may not declare two identifiers in the program whose name differs only by alphabetic case.</p><p>A traditional first program people write, popularized by Kernighan and Ritchie's <span class="emphasis"><em>The C Programming Language</em></span>, is the "Hello, world!" program. This program makes an excellent concrete example for someone who is learning a new language. <a class="xref" href="ch01.html#the_helloworld_program" title="Example 1-1. The helloWorld program">Example 1-1</a> presents the HLA <span class="emphasis"><em>helloWorld</em></span> program.</p><div class="example"><a id="the_helloworld_program"/><p class="title">Example 1-1. The <span class="emphasis"><em>helloWorld</em></span> program</p><div class="example-contents"><pre class="programlisting">program helloWorld;
#include( "stdlib.hhf" );

begin helloWorld;

    stdout.put( "Hello, World of Assembly Language", nl );

end helloWorld;</pre></div></div><p>The <code class="literal">#include</code> statement in this program tells the HLA compiler to include a set of declarations from the <span class="emphasis"><em>stdlib.hhf</em></span> (standard library, HLA Header File). Among other things, this file contains the declaration of the <code class="literal">stdout.put</code> code that this program uses.<a class="indexterm" id="IDX-CHP-1-0004"/><a class="indexterm" id="IDX-CHP-1-0005"/><a class="indexterm" id="IDX-CHP-1-0006"/><a class="indexterm" id="IDX-CHP-1-0007"/><a class="indexterm" id="IDX-CHP-1-0008"/><a class="indexterm" id="IDX-CHP-1-0009"/><a class="indexterm" id="IDX-CHP-1-0010"/></p><p>The <code class="literal">stdout.put</code> statement is the print statement for the HLA language. You use it to write data to the standard output device (generally the console). To anyone familiar with I/O statements in a high-level language, it should be obvious that this statement prints the phrase <code class="literal">Hello, World of Assembly Language</code>. The <code class="literal">nl</code> appearing at the end of this statement is a constant, also defined in <span class="emphasis"><em>stdlib.hhf</em></span>, that corresponds to the newline sequence.</p><p>Note that semicolons follow the <code class="literal">program</code>, <code class="literal">begin</code>, <code class="literal">stdout.put</code>, and <code class="literal">end</code> statements. Technically speaking, a semicolon does not follow the <code class="literal">#include</code> statement. It is possible to create include files that generate an error if a semicolon follows the <code class="literal">#include</code> statement, so you may want to get in the habit of not putting a semicolon here.<a class="indexterm" id="IDX-CHP-1-0011"/></p><p>The <code class="literal">#include</code> is your first introduction to HLA declarations. The <code class="literal">#include</code> itself isn't actually a declaration, but it does tell the HLA compiler to substitute the file <span class="emphasis"><em>stdlib.hhf</em></span> in place of the <code class="literal">#include</code> directive, thus inserting several declarations at this point in your program. Most HLA programs you will write will need to include one or more of the HLA Standard Library header files (<span class="emphasis"><em>stdlib.hhf</em></span> actually includes all the standard library definitions into your program).</p><p>Compiling this program produces a <span class="emphasis"><em>console</em></span> application. Running this program in a command window prints the specified string, and then control returns to the command-line interpreter (or <span class="emphasis"><em>shell</em></span> in Unix terminology).</p><p>HLA is a free-format language. Therefore, you may split statements across multiple lines if this helps to make your programs more readable. For example, you could write the <code class="literal">stdout.put</code> statement in the <span class="emphasis"><em>helloWorld</em></span> program as follows:</p><a id="I_programlisting1_d1e392"/><pre class="programlisting">stdout.put
     (
          "Hello, World of Assembly Language",
          nl
     );</pre><p>Another construction you'll see appearing in example code throughout this text is that HLA automatically concatenates any adjacent string constants it finds in your source file. Therefore, the statement above is also equivalent to</p><a id="I_programlisting1_d1e396"/><pre class="programlisting">stdout.put
     (
          "Hello, "
          "World of Assembly Language",
          nl
     );</pre><p>Indeed, <code class="literal">nl</code> (the newline) is really nothing more than a string constant, so (technically) the comma between the <code class="literal">nl</code> and the preceding string isn't necessary. You'll often see the above written as</p><a id="I_programlisting1_d1e406"/><pre class="programlisting">stdout.put( "Hello, World of Assembly Language" nl );</pre><p>Notice the lack of a comma between the string constant and <code class="literal">nl</code>; this turns out to be legal in HLA, though it applies only to certain constants; you may not, in general, drop the comma. <a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a> explains in detail how this works. This discussion appears here because you'll probably see this "trick" employed by sample code prior to the formal explanation.</p></div></div>
<div class="sect1" title="1.2 Running Your First HLA Program"><div class="titlepage"><div><div><h1 class="title"><a id="running_your_first_hla_program"/>1.2 Running Your First HLA Program</h1></div></div></div><p>The whole purpose of the "Hello, world!" program is to provide a simple example by which someone who is learning a new programming language can figure out how to use the tools needed to compile and run programs in that language. True, the <span class="emphasis"><em>helloWorld</em></span> program in <a class="xref" href="ch01.html#the_anatomy_of_an_hla_program" title="1.1 The Anatomy of an HLA Program">1.1 The Anatomy of an HLA Program</a> helps demonstrate the format and syntax of a simple HLA program, but the real purpose behind a program like <span class="emphasis"><em>helloWorld</em></span> is to learn how to create and run a program from beginning to end. Although the previous section presents the layout of an HLA program, it did not discuss how to edit, compile, and run that program. This section will briefly cover those details.</p><p>All of the software you need to compile and run HLA programs can be found at <a class="ulink" href="http://randallhyde.com/">http://randallhyde.com/</a> or at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a>. Select <span class="strong"><strong>High Level Assembly</strong></span> from the Quick Navigation Panel and then the Download HLA link from that page. HLA is currently available for Windows, Mac OS X, Linux, and FreeBSD. Download the appropriate version of the HLA software for your system. From the Download HLA web page, you will also be able to download all the software associated with this book. If the HLA download doesn't include them, you will probably want to download the HLA reference manual and the HLA Standard Library reference manual along with HLA and the software for this book. This text does not describe the entire HLA language, nor does it describe the entire HLA Standard Library. You'll want to have these reference manuals handy as you learn assembly language using HLA.</p><p>This section will not describe how to install and set up the HLA system because those instructions change over time. The HLA download page for each of the operating systems describes how to install and use HLA. Please consult those instructions for the exact installation procedure.</p><p>Creating, compiling, and running an HLA program is very similar to the process you'd use when creating, compiling, or running a program in any computer language. First, because HLA is not an <span class="emphasis"><em>integrated development environment (IDE)</em></span> that allows you to edit, compile, test and debug, and run your application all from within the same program, you'll create and edit HLA programs using a text editor.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-1" id="CHP-1-FN-1">1</a>]</sup></p><p>Windows, Mac OS X, Linux, and FreeBSD offer many text editor options. You can even use the text editor provided with other IDEs to create and edit HLA programs (such as those found in Visual C++, Borland's Delphi, Apple's Xcode, and similar languages). The only restriction is that HLA expects ASCII text files, so the editor you use must be capable of manipulating and saving text files. Under Windows you can always use Notepad to create HLA programs. If you're working under Linux and FreeBSD you can use joe, vi, or emacs. Under Mac OS X you can use XCode or Text Wrangler or another editor of your preference.<a class="indexterm" id="IDX-CHP-1-0012"/><a class="indexterm" id="IDX-CHP-1-0013"/><a class="indexterm" id="IDX-CHP-1-0014"/><a class="indexterm" id="IDX-CHP-1-0015"/></p><p>The HLA compiler<sup>[<a class="footnote" href="#ftn.CHP-1-FN-2" id="CHP-1-FN-2">2</a>]</sup> is a traditional <span class="emphasis"><em>command-line compiler</em></span>, which means that you need to run it from a Windows <span class="emphasis"><em>command-line prompt</em></span> or a Linux/FreeBSD/Mac OS X <span class="emphasis"><em>shell</em></span>. To do so, enter something like the following into the command-line prompt or shell window:<a class="indexterm" id="IDX-CHP-1-0016"/></p><a id="I_programlisting1_d1e487"/><pre class="programlisting">hla hw.hla</pre><p>This command tells HLA to compile the <span class="emphasis"><em>hw.hla</em></span> (<span class="emphasis"><em>helloWorld</em></span>) program to an executable file. Assuming there are no errors, you can run the resulting program by typing the following command into your command prompt window (Windows):</p><a id="I_programlisting1_d1e497"/><pre class="programlisting">hw</pre><p>or into the shell interpreter window (Linux/FreeBSD/Mac OS X):</p><a id="I_programlisting1_d1e502"/><pre class="programlisting">./hw</pre><p>If you're having problems getting the program to compile and run properly, please see the HLA installation instructions on the HLA download page. These instructions describe in great detail how to install, set up, and use HLA.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-1" id="ftn.CHP-1-FN-1">1</a>] </sup>HIDE (HLA Integrated Development Environment) is an IDE available for Windows users. See the High Level Assembly web page for details on downloading HIDE.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-2" id="ftn.CHP-1-FN-2">2</a>] </sup>Traditionally, programmers have always called translators for assembly languages <span class="emphasis"><em>assemblers</em></span> rather than <span class="emphasis"><em>compilers</em></span>. However, because of HLA's high-level features, it is more proper to call HLA a compiler rather than an assembler.</p></div></div></div>
<div class="sect1" title="1.3 Some Basic HLA Data Declarations"><div class="titlepage"><div><div><h1 class="title"><a id="some_basic_hla_data_declarations"/>1.3 Some Basic HLA Data Declarations</h1></div></div></div><p>HLA provides a wide variety of constant, type, and data declaration statements. Later chapters will cover the declaration sections in more detail, but it's important to know how to declare a few simple variables in an HLA program.</p><p>HLA predefines several different signed integer types including int8, int16, and int32, corresponding to 8-bit (1-byte) signed integers, 16-bit (2-byte) signed integers, and 32-bit (4-byte) signed integers, respectively.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-3" id="CHP-1-FN-3">3</a>]</sup> Typical variable declarations occur in the HLA <span class="emphasis"><em>static variable section</em></span>. A typical set of variable declarations takes the form shown in <a class="xref" href="ch01s03.html#static_variable_declarations" title="Figure 1-2. Static variable declarations">Figure 1-2</a>.</p><div class="figure"><a id="static_variable_declarations"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e527"/><img alt="Static variable declarations" src="tagoreillycom20100401nostarchimages577857.png.jpg"/></div></div><p class="title">Figure 1-2. Static variable declarations</p></div><p>Those who are familiar with the Pascal language should be comfortable with this declaration syntax. This example demonstrates how to declare three separate integers: <code class="literal">i8</code>, <code class="literal">i16</code><span class="emphasis"><em>,</em></span> and <code class="literal">i32</code>. Of course, in a real program you should use variable names that are more descriptive. While names like <span class="emphasis"><em>i8</em></span> and <span class="emphasis"><em>i32</em></span> describe the type of the object, they do not describe its purpose. Variable names should describe the purpose of the object.</p><p>In the <span class="emphasis"><em>static declaration section</em></span>, you can also give a variable an initial value that the operating system will assign to the variable when it loads the program into memory. <a class="xref" href="ch01s03.html#static_variable_initialization" title="Figure 1-3. Static variable initialization">Figure 1-3</a> provides the syntax for this.<a class="indexterm" id="IDX-CHP-1-0017"/><a class="indexterm" id="IDX-CHP-1-0018"/></p><div class="figure"><a id="static_variable_initialization"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e569"/><img alt="Static variable initialization" src="tagoreillycom20100401nostarchimages577859.png.jpg"/></div></div><p class="title">Figure 1-3. Static variable initialization</p></div><p>It is important to realize that the expression following the assignment operator (<code class="literal">:=</code>) must be a constant expression. You cannot assign the values of other variables within a static variable declaration.</p><p>Those familiar with other high-level languages (especially Pascal) should note that you can declare only one variable per statement. That is, HLA does not allow a comma-delimited list of variable names followed by a colon and a type identifier. Each variable declaration consists of a single identifier, a colon, a type ID, and a semicolon.</p><p><a class="xref" href="ch01s03.html#variable_declaration_and_use" title="Example 1-2. Variable declaration and use">Example 1-2</a> provides a simple HLA program that demonstrates the use of variables within an HLA program.</p><div class="example"><a id="variable_declaration_and_use"/><p class="title">Example 1-2. Variable declaration and use</p><div class="example-contents"><pre class="programlisting">Program DemoVars;
#include( "stdlib.hhf" )

static
    InitDemo:       int32 := 5;
    NotInitialized: int32;

begin DemoVars;

    // Display the value of the pre-initialized variable:

    stdout.put( "InitDemo's value is ", InitDemo, nl );

    // Input an integer value from the user and display that value:

    stdout.put( "Enter an integer value: " );
    stdin.get( NotInitialized );
    stdout.put( "You entered: ", NotInitialized, nl );

end DemoVars;</pre></div></div><p>In addition to static variable declarations, this example introduces three new concepts. First, the <code class="literal">stdout.put</code> statement allows multiple parameters. If you specify an integer value, <code class="literal">stdout.put</code> will convert that value to its string representation on output.<a class="indexterm" id="IDX-CHP-1-0019"/><a class="indexterm" id="IDX-CHP-1-0020"/><a class="indexterm" id="IDX-CHP-1-0021"/><a class="indexterm" id="IDX-CHP-1-0022"/><a class="indexterm" id="IDX-CHP-1-0023"/><a class="indexterm" id="IDX-CHP-1-0024"/></p><p>The second new feature introduced in <a class="xref" href="ch01s03.html#variable_declaration_and_use" title="Example 1-2. Variable declaration and use">Example 1-2</a> is the <code class="literal">stdin.get</code> statement. This statement reads a value from the standard input device (usually the keyboard), converts the value to an integer, and stores the integer value into the <code class="literal">NotInitialized</code> variable. Finally, <a class="xref" href="ch01s03.html#variable_declaration_and_use" title="Example 1-2. Variable declaration and use">Example 1-2</a> also introduces the syntax for (one form of) HLA comments. The HLA compiler ignores all text from the <code class="literal">//</code> sequence to the end of the current line. (Those familiar with Java, C++, and Delphi should recognize these comments.)<a class="indexterm" id="IDX-CHP-1-0025"/><a class="indexterm" id="IDX-CHP-1-0026"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-3" id="ftn.CHP-1-FN-3">3</a>] </sup>A discussion of bits and bytes will appear in <a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a> for those who are unfamiliar with these terms.</p></div></div></div>
<div class="sect1" title="1.4 Boolean Values"><div class="titlepage"><div><div><h1 class="title"><a id="boolean_values"/>1.4 Boolean Values</h1></div></div></div><p>HLA and the HLA Standard Library provide limited support for boolean objects. You can declare boolean variables, use boolean literal constants, use boolean variables in boolean expressions, and you can print the values of boolean variables.</p><p>Boolean literal constants consist of the two predefined identifiers <code class="literal">true</code> and <code class="literal">false</code>. Internally, HLA represents the value true using the numeric value <code class="literal">1</code>; HLA represents false using the value <code class="literal">0</code>. Most programs treat <code class="literal">0</code> as false and anything else as true, so HLA's representations for true and false should prove sufficient.<a class="indexterm" id="IDX-CHP-1-0027"/><a class="indexterm" id="IDX-CHP-1-0028"/></p><p>To declare a boolean variable, you use the <code class="literal">boolean</code> data type. HLA uses a single byte (the least amount of memory it can allocate) to represent boolean values. The following example demonstrates some typical declarations:</p><a id="I_programlisting1_d1e682"/><pre class="programlisting">static
     BoolVar:     boolean;
     HasClass:    boolean := false;
     IsClear:     boolean := true;</pre><p>As this example demonstrates, you can initialize boolean variables if you desire.</p><p>Because boolean variables are byte objects, you can manipulate them using any instructions that operate directly on 8-bit values. Furthermore, as long as you ensure that your boolean variables only contain <code class="literal">0</code> and <code class="literal">1</code> (for false and true, respectively), you can use the 80x86 <code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">xor</code>, and <code class="literal">not</code> instructions to manipulate these boolean values (these instructions are covered in <a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a>).</p><p>You can print boolean values by making a call to the <code class="literal">stdout.put</code> routine. For example:<a class="indexterm" id="IDX-CHP-1-0029"/><a class="indexterm" id="IDX-CHP-1-0030"/><a class="indexterm" id="IDX-CHP-1-0031"/><a class="indexterm" id="IDX-CHP-1-0032"/></p><a id="I_programlisting1_d1e730"/><pre class="programlisting">stdout.put( BoolVar )</pre><p>This routine prints the text <code class="literal">true</code> or <code class="literal">false</code> depending upon the value of the boolean parameter (<code class="literal">0</code> is false; anything else is true). Note that the HLA Standard Library does not allow you to read boolean values via <code class="literal">stdin.get</code>.</p></div>
<div class="sect1" title="1.5 Character Values"><div class="titlepage"><div><div><h1 class="title"><a id="character_values"/>1.5 Character Values</h1></div></div></div><p>HLA lets you declare 1-byte ASCII character objects using the <code class="literal">char</code> data type. You may initialize character variables with a literal character value by surrounding the character with a pair of apostrophes. The following example demonstrates how to declare and initialize character variables in HLA:</p><a id="I_programlisting1_d1e754"/><pre class="programlisting">static
     c: char;
     LetterA: char := 'A';</pre><p>You can print character variables use the <code class="literal">stdout.put</code> routine, and you can read character variables using the <code class="literal">stdin.get</code> procedure call.</p></div>
<div class="sect1" title="1.6 An Introduction to the Intel 80x86 CPU Family"><div class="titlepage"><div><div><h1 class="title"><a id="an_introduction_to_the_intel_80x86_cpu_f"/>1.6 An Introduction to the Intel 80x86 CPU Family</h1></div></div></div><p>Thus far, you've seen a couple of HLA programs that will actually compile and run. However, all the statements appearing in programs to this point have been either data declarations or calls to HLA Standard Library routines. There hasn't been any <span class="emphasis"><em>real</em></span> assembly language. Before we can progress any further and learn some real assembly language, a detour is necessary; unless you understand the basic structure of the Intel 80x86 CPU family, the machine instructions will make little sense.</p><p>The Intel CPU family is generally classified as a <span class="emphasis"><em>Von Neumann Architecture Machine</em></span>. Von Neumann computer systems contain three main building blocks: the <span class="emphasis"><em>central processing unit (CPU)</em></span>, <span class="emphasis"><em>memory</em></span>, and <span class="emphasis"><em>input/output (I/0) devices</em></span>. These three components are interconnected using the <span class="emphasis"><em>system bus</em></span> (consisting of the address, data, and control buses). The block diagram in <a class="xref" href="ch01s06.html#von_neumann_computer_system_block_diagra" title="Figure 1-4. Von Neumann computer system block diagram">Figure 1-4</a> shows this relationship.<a class="indexterm" id="IDX-CHP-1-0033"/><a class="indexterm" id="IDX-CHP-1-0034"/><a class="indexterm" id="IDX-CHP-1-0035"/><a class="indexterm" id="IDX-CHP-1-0036"/></p><p>The CPU communicates with memory and I/O devices by placing a numeric value on the address bus to select one of the memory locations or I/O device port locations, each of which has a unique binary numeric <span class="emphasis"><em>address</em></span>. Then the CPU, memory, and I/O devices pass data among themselves by placing the data on the data bus. The control bus contains signals that determine the direction of the data transfer (to/from memory and to/from an I/O device).<a class="indexterm" id="IDX-CHP-1-0037"/><a class="indexterm" id="IDX-CHP-1-0038"/><a class="indexterm" id="IDX-CHP-1-0039"/><a class="indexterm" id="IDX-CHP-1-0040"/><a class="indexterm" id="IDX-CHP-1-0041"/><a class="indexterm" id="IDX-CHP-1-0042"/><a class="indexterm" id="IDX-CHP-1-0043"/><a class="indexterm" id="IDX-CHP-1-0044"/></p><div class="figure"><a id="von_neumann_computer_system_block_diagra"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e842"/><img alt="Von Neumann computer system block diagram" src="tagoreillycom20100401nostarchimages577861.png"/></div></div><p class="title">Figure 1-4. Von Neumann computer system block diagram</p></div><p>The 80x86 CPU registers can be broken down into four categories: general-purpose registers, special-purpose application-accessible registers, segment registers, and special-purpose kernel-mode registers. Because the segment registers aren't used much in modern 32-bit operating systems (such as Windows, Mac OS X, FreeBSD, and Linux) and because this text is geared to writing programs written for 32-bit operating systems, there is little need to discuss the segment registers. The special-purpose kernel-mode registers are intended for writing operating systems, debuggers, and other system-level tools. Such software construction is well beyond the scope of this text.<a class="indexterm" id="IDX-CHP-1-0045"/><a class="indexterm" id="IDX-CHP-1-0046"/><a class="indexterm" id="IDX-CHP-1-0047"/><a class="indexterm" id="IDX-CHP-1-0048"/><a class="indexterm" id="IDX-CHP-1-0049"/><a class="indexterm" id="IDX-CHP-1-0050"/></p><p>The 80x86 (Intel family) CPUs provide several general-purpose registers for application use. These include eight 32-bit registers that have the following names: EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP.<a class="indexterm" id="IDX-CHP-1-0051"/><a class="indexterm" id="IDX-CHP-1-0052"/><a class="indexterm" id="IDX-CHP-1-0053"/><a class="indexterm" id="IDX-CHP-1-0054"/><a class="indexterm" id="IDX-CHP-1-0055"/><a class="indexterm" id="IDX-CHP-1-0056"/><a class="indexterm" id="IDX-CHP-1-0057"/><a class="indexterm" id="IDX-CHP-1-0058"/><a class="indexterm" id="IDX-CHP-1-0059"/><a class="indexterm" id="IDX-CHP-1-0060"/><a class="indexterm" id="IDX-CHP-1-0061"/><a class="indexterm" id="IDX-CHP-1-0062"/></p><p>The <span class="emphasis"><em>E</em></span> prefix on each name stands for <span class="emphasis"><em>extended</em></span>. This prefix differentiates the 32-bit registers from the eight 16-bit registers that have the following names: AX, BX, CX, DX, SI, DI, BP, and SP.<a class="indexterm" id="IDX-CHP-1-0063"/></p><p>Finally, the 80x86 CPUs provide eight 8-bit registers that have the following names: AL, AH, BL, BH, CL, CH, DL, and DH.<a class="indexterm" id="IDX-CHP-1-0064"/><a class="indexterm" id="IDX-CHP-1-0065"/><a class="indexterm" id="IDX-CHP-1-0066"/><a class="indexterm" id="IDX-CHP-1-0067"/><a class="indexterm" id="IDX-CHP-1-0068"/><a class="indexterm" id="IDX-CHP-1-0069"/></p><p>Unfortunately, these are not all separate registers. That is, the 80x86 does not provide 24 independent registers. Instead, the 80x86 overlays the 32-bit registers with the 16-bit registers, and it overlays the 16-bit registers with the 8-bit registers. <a class="xref" href="ch01s06.html#x86_open_parenthesis_intel_cpu_close_par" title="Figure 1-5. 80x86 (Intel CPU) general-purpose registers">Figure 1-5</a> shows this relationship.</p><p>The most important thing to note about the general-purpose registers is that they are not independent. Modifying one register may modify as many as three other registers. For example, modification of the EAX register may very well modify the AL, AH, and AX registers. This fact cannot be overemphasized here. A very common mistake in programs written by beginning assembly language programmers is register value corruption because the programmer did not completely understand the ramifications of the relationship shown in <a class="xref" href="ch01s06.html#x86_open_parenthesis_intel_cpu_close_par" title="Figure 1-5. 80x86 (Intel CPU) general-purpose registers">Figure 1-5</a>.<a class="indexterm" id="IDX-CHP-1-0070"/><a class="indexterm" id="IDX-CHP-1-0071"/></p><div class="figure"><a id="x86_open_parenthesis_intel_cpu_close_par"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e957"/><img alt="80x86 (Intel CPU) general-purpose registers" src="tagoreillycom20100401nostarchimages577863.png"/></div></div><p class="title">Figure 1-5. 80x86 (Intel CPU) general-purpose registers</p></div><p>The EFLAGS register is a 32-bit register that encapsulates several single-bit boolean (true/false) values. Most of the bits in the EFLAGS register are either reserved for kernel mode (operating system) functions or are of little interest to the application programmer. Eight of these bits (or <span class="emphasis"><em>flags</em></span>) are of interest to application programmers writing assembly language programs. These are the overflow, direction, interrupt disable,<sup>[<a class="footnote" href="#ftn.CHP-1-FN-4" id="CHP-1-FN-4">4</a>]</sup> sign, zero, auxiliary carry, parity, and carry flags. <a class="xref" href="ch01s06.html#layout_of_the_flags_register_open_parent" title="Figure 1-6. Layout of the FLAGS register (lower 16 bits of EFLAGS)">Figure 1-6</a> shows the layout of the flags within the lower 16 bits of the EFLAGS register.<a class="indexterm" id="IDX-CHP-1-0072"/><a class="indexterm" id="IDX-CHP-1-0073"/><a class="indexterm" id="IDX-CHP-1-0074"/><a class="indexterm" id="IDX-CHP-1-0075"/><a class="indexterm" id="IDX-CHP-1-0076"/></p><div class="figure"><a id="layout_of_the_flags_register_open_parent"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e998"/><img alt="Layout of the FLAGS register (lower 16 bits of EFLAGS)" src="tagoreillycom20100401nostarchimages577865.png"/></div></div><p class="title">Figure 1-6. Layout of the FLAGS register (lower 16 bits of EFLAGS)</p></div><p>Of the eight flags that are of interest to application programmers, four flags in particular are extremely valuable: the overflow, carry, sign, and zero flags. Collectively, we will call these four flags the <span class="emphasis"><em>condition codes</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-5" id="CHP-1-FN-5">5</a>]</sup> The state of these flags lets you test the result of previous computations. For example, after comparing two values, the condition code flags will tell you whether one value is less than, equal to, or greater than a second value.<a class="indexterm" id="IDX-CHP-1-0077"/></p><p>One important fact that comes as a surprise to those just learning assembly language is that almost all calculations on the 80x86 CPU involve a register. For example, to add two variables together, storing the sum into a third variable, you must load one of the variables into a register, add the second operand to the value in the register, and then store the register away in the destination variable. Registers are a middleman in nearly every calculation. Therefore, registers are very important in 80x86 assembly language programs.<a class="indexterm" id="IDX-CHP-1-0078"/></p><p>Another thing you should be aware of is that although the registers have the name "general purpose," you should not infer that you can use any register for any purpose. All the 80x86 registers have their own special purposes that limit their use in certain contexts. The SP/ESP register pair, for example, has a very special purpose that effectively prevents you from using it for anything else (it's the <span class="emphasis"><em>stack pointer</em></span>). Likewise, the BP/EBP register has a special purpose that limits its usefulness as a general-purpose register. For the time being, you should avoid the use of the ESP and EBP registers for generic calculations; also, keep in mind that the remaining registers are not completely interchangeable in your programs.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-4" id="ftn.CHP-1-FN-4">4</a>] </sup>Application programs cannot modify the interrupt flag, but we'll look at this flag in <a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a>; hence the discussion of this flag here.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-5" id="ftn.CHP-1-FN-5">5</a>] </sup>Technically the parity flag is also a condition code, but we will not use that flag in this text.</p></div></div></div>
<div class="sect1" title="1.7 The Memory Subsystem"><div class="titlepage"><div><div><h1 class="title"><a id="the_memory_subsystem"/>1.7 The Memory Subsystem</h1></div></div></div><p>A typical 80x86 processor running a modern 32-bit OS can access a maximum of 2<sup>32</sup> different memory locations, or just over 4 billion bytes. A few years ago, 4 gigabytes of memory would have seemed like infinity; modern machines, however, exceed this limit. Nevertheless, because the 80x86 architecture supports a maximum 4GB address space when using a 32-bit operating system like Windows, Mac OS X, FreeBSD, or Linux, the following discussion will assume the 4GB limit.</p><p>Of course, the first question you should ask is, "What exactly is a memory location?" The 80x86 supports <span class="emphasis"><em>byte-addressable memory</em></span>. Therefore, the basic memory unit is a byte, which is sufficient to hold a single character or a (very) small integer value (we'll talk more about that in <a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a>).</p><p>Think of memory as a linear array of bytes. The address of the first byte is 0 and the address of the last byte is 2<sup>32</sup>−1. For an 80x86 processor, the following pseudo-Pascal array declaration is a good approximation of memory:</p><a id="I_programlisting1_d1e1048"/><pre class="programlisting">Memory: array [0..4294967295] of byte;</pre><p>C/C++ and Java users might prefer the following syntax:</p><a id="I_programlisting1_d1e1052"/><pre class="programlisting">byte Memory[4294967296];</pre><p>To execute the equivalent of the Pascal statement <code class="literal">Memory [125] := 0;</code> the CPU places the value 0 on the data bus, places the address 125 on the address bus, and asserts the write line (this generally involves setting that line to 0), as shown in <a class="xref" href="ch01s07.html#memory_write_operation" title="Figure 1-7. Memory write operation">Figure 1-7</a>.<a class="indexterm" id="IDX-CHP-1-0079"/><a class="indexterm" id="IDX-CHP-1-0080"/><a class="indexterm" id="IDX-CHP-1-0081"/></p><div class="figure"><a id="memory_write_operation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e1077"/><img alt="Memory write operation" src="tagoreillycom20100401nostarchimages577867.png"/></div></div><p class="title">Figure 1-7. Memory write operation</p></div><p>To execute the equivalent of <code class="literal">CPU := Memory [125];</code> the CPU places the address 125 on the address bus, asserts the read line (because the CPU is reading data from memory), and then reads the resulting data from the data bus (see <a class="xref" href="ch01s07.html#memory_read_operation" title="Figure 1-8. Memory read operation">Figure 1-8</a>).<a class="indexterm" id="IDX-CHP-1-0082"/></p><div class="figure"><a id="memory_read_operation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e1097"/><img alt="Memory read operation" src="tagoreillycom20100401nostarchimages577869.png"/></div></div><p class="title">Figure 1-8. Memory read operation</p></div><p>This discussion applies <span class="emphasis"><em>only</em></span> when accessing a single byte in memory. So what happens when the processor accesses a word or a double word? Because memory consists of an array of bytes, how can we possibly deal with values larger than a single byte? Easy—to store larger values, the 80x86 uses a sequence of consecutive memory locations. <a class="xref" href="ch01s07.html#byte_comma_word_comma_and_double-word_st" title="Figure 1-9. Byte, word, and double-word storage in memory">Figure 1-9</a> shows how the 80x86 stores bytes, words (2 bytes), and double words (4 bytes) in memory. The memory address of each of these objects is the address of the first byte of each object (that is, the lowest address).</p><p>Modern 80x86 processors don't actually connect directly to memory. Instead, there is a special memory buffer on the CPU known as the <span class="emphasis"><em>cache</em></span> (pronounced "cash") that acts as a high-speed intermediary between the CPU and main memory. Although the cache handles the details automatically for you, one fact you should know is that accessing data objects in memory is sometimes more efficient if the address of the object is an even multiple of the object's size. Therefore, it's a good idea to <span class="emphasis"><em>align</em></span> 4-byte objects (double words) on addresses that are multiples of 4. Likewise, it's most efficient to align 2-byte objects on even addresses. You can efficiently access single-byte objects at any address. You'll see how to set the alignment of memory objects in <a class="xref" href="ch03s04.html" title="3.4 HLA Support for Data Alignment">3.4 HLA Support for Data Alignment</a>.</p><div class="figure"><a id="byte_comma_word_comma_and_double-word_st"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e1123"/><img alt="Byte, word, and double-word storage in memory" src="tagoreillycom20100401nostarchimages577871.png"/></div></div><p class="title">Figure 1-9. Byte, word, and double-word storage in memory</p></div><p>Before leaving this discussion of memory objects, it's important to understand the correspondence between memory and HLA variables. One of the nice things about using an assembler/compiler like HLA is that you don't have to worry about numeric memory addresses. All you need to do is declare a variable in HLA, and HLA takes care of associating that variable with some unique set of memory addresses. For example, if you have the following declaration section:</p><a id="I_programlisting1_d1e1130"/><pre class="programlisting">static
     i8          :int8;
     i16         :int16;
     i32         :int32;</pre><p>HLA will find some unused 8-bit byte in memory and associate it with the <code class="literal">i8</code> variable; it will find a pair of consecutive unused bytes and associate <code class="literal">i16</code> with them; finally, HLA will find 4 consecutive unused bytes and associate the value of <code class="literal">i32</code> with those 4 bytes (32 bits). You'll always refer to these variables by their name. You generally don't have to concern yourself with their numeric address. Still, you should be aware that HLA is doing this for you behind your back.</p></div>
<div class="sect1" title="1.8 Some Basic Machine Instructions"><div class="titlepage"><div><div><h1 class="title"><a id="some_basic_machine_instructions"/>1.8 Some Basic Machine Instructions</h1></div></div></div><p>The 80x86 CPU family provides from just over a hundred to many thousands of different machine instructions, depending on how you define a machine instruction. Even at the low end of the count (greater than 100), it appears as though there are far too many machine instructions to learn in a short time. Fortunately, you don't need to know all the machine instructions. In fact, most assembly language programs probably use around 30 different machine instructions.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-6" id="CHP-1-FN-6">6</a>]</sup> Indeed, you can certainly write several meaningful programs with only a few machine instructions. The purpose of this section is to provide a small handful of machine instructions so you can start writing simple HLA assembly language programs right away.<a class="indexterm" id="IDX-CHP-1-0083"/></p><p>Without question, the <code class="literal">mov</code> instruction is the most oft-used assembly language statement. In a typical program, anywhere from 25 percent to 40 percent of the instructions are <code class="literal">mov</code> instructions. As its name suggests, this instruction moves data from one location to another.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-7" id="CHP-1-FN-7">7</a>]</sup> The HLA syntax for this instruction is:<a class="indexterm" id="IDX-CHP-1-0084"/></p><a id="I_programlisting1_d1e1178"/><pre class="programlisting">mov( <em class="replaceable"><code>source_operand</code></em>, <em class="replaceable"><code>destination_operand</code></em> );</pre><p>The <em class="replaceable"><code>source_operand</code></em> can be a register, a memory variable, or a constant. The <em class="replaceable"><code>destination_operand</code></em> may be a register or a memory variable. Technically the 80x86 instruction set does not allow both operands to be memory variables. HLA, however, will automatically translate a <code class="literal">mov</code> instruction with two-word or double-word memory operands into a pair of instructions that will copy the data from one location to another. In a high-level language like Pascal or C/C++, the <code class="literal">mov</code> instruction is roughly equivalent to the following assignment statement:</p><a id="I_programlisting1_d1e1200"/><pre class="programlisting"><em class="replaceable"><code>destination_operand</code></em> = <em class="replaceable"><code>source_operand</code></em> ;</pre><p>Perhaps the major restriction on the <code class="literal">mov</code> instruction's operands is that they must both be the same size. That is, you can move data between a pair of byte (8-bit) objects, word (16-bit) objects, or double-word (32-bit) objects; you may not, however, mix the sizes of the operands. <a class="xref" href="ch01s08.html#legal_80x86_mov_instruction_operands" title="Table 1-1. Legal 80x86 mov Instruction Operands">Table 1-1</a> lists all the legal combinations for the <code class="literal">mov</code> instruction.</p><p>You should study this table carefully because most of the general-purpose 80x86 instructions use this syntax.</p><div class="table"><a id="legal_80x86_mov_instruction_operands"/><p class="title">Table 1-1. Legal 80x86 <code class="literal">mov</code> Instruction Operands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Legal 80x86 mov Instruction Operands"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Source<a class="indexterm" id="IDX-CHP-1-0085"/><a class="indexterm" id="IDX-CHP-1-0086"/><a class="indexterm" id="IDX-CHP-1-0087"/></p></th><th style="text-align: left" valign="bottom"><p>Destination</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Reg<sub>8</sub><sup>[<a class="footnote" href="#ftn.CHP-1-TFN-1" id="CHP-1-TFN-1">a</a>]</sup></p></td><td style="text-align: left" valign="top"><p>Reg<sub>8</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Reg<sub>8</sub></p></td><td style="text-align: left" valign="top"><p>Mem<sub>8</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Mem<sub>8</sub></p></td><td style="text-align: left" valign="top"><p>Reg<sub>8</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Constant<sup>[<a class="footnote" href="#ftn.CHP-1-TFN-2" id="CHP-1-TFN-2">b</a>]</sup></p></td><td style="text-align: left" valign="top"><p>Reg<sub>8</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Constant</p></td><td style="text-align: left" valign="top"><p>Mem<sub>8</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Reg<sub>16</sub></p></td><td style="text-align: left" valign="top"><p>Reg<sub>16</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Reg<sub>16</sub></p></td><td style="text-align: left" valign="top"><p>Mem<sub>16</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Mem<sub>16</sub></p></td><td style="text-align: left" valign="top"><p>Reg<sub>16</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Constant</p></td><td style="text-align: left" valign="top"><p>Reg<sub>16</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Constant</p></td><td style="text-align: left" valign="top"><p>Mem<sub>16</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Reg<sub>32</sub></p></td><td style="text-align: left" valign="top"><p>Reg<sub>32</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Reg<sub>32</sub></p></td><td style="text-align: left" valign="top"><p>Mem<sub>32</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Mem<sub>32</sub></p></td><td style="text-align: left" valign="top"><p>Reg<sub>32</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Constant</p></td><td style="text-align: left" valign="top"><p>Reg<sub>32</sub></p></td></tr><tr><td style="text-align: left" valign="top"><p>Constant</p></td><td style="text-align: left" valign="top"><p>Mem<sub>32</sub></p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-TFN-1" id="ftn.CHP-1-TFN-1">a</a>] </sup>The suffix denotes the size of the register or memory location.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-TFN-2" id="ftn.CHP-1-TFN-2">b</a>] </sup>The constant must be small enough to fit in the specified destination operand.</p></div></td></tr></tbody></table></div></div><p>The 80x86 <code class="literal">add</code> and <code class="literal">sub</code> instructions let you add and subtract two operands. Their syntax is nearly identical to the <code class="literal">mov</code> instruction:<a class="indexterm" id="IDX-CHP-1-0088"/><a class="indexterm" id="IDX-CHP-1-0089"/></p><a id="I_programlisting1_d1e1429"/><pre class="programlisting">add( <em class="replaceable"><code>source_operand</code></em>, <em class="replaceable"><code>destination_operand</code></em> );
     sub( <em class="replaceable"><code>source_operand</code></em>, <em class="replaceable"><code>destination_operand</code></em> );</pre><p>The <code class="literal">add</code> and <code class="literal">sub</code> operands take the same form as the <code class="literal">mov</code> instruction.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-8" id="CHP-1-FN-8">8</a>]</sup> The <code class="literal">add</code> instruction does the following:</p><a id="I_programlisting1_d1e1468"/><pre class="programlisting"><em class="replaceable"><code>destination_operand</code></em> = <em class="replaceable"><code>destination_operand</code></em> + <em class="replaceable"><code>source_operand</code></em> ;
     <em class="replaceable"><code>destination_operand</code></em> += <em class="replaceable"><code>source_operand</code></em>;  // For those who prefer C syntax.</pre><p>The <code class="literal">sub</code> instruction does the calculation:</p><a id="I_programlisting1_d1e1489"/><pre class="programlisting"><em class="replaceable"><code>destination_operand</code></em> = <em class="replaceable"><code>destination_operand</code></em> - <em class="replaceable"><code>source_operand</code></em> ;
     <em class="replaceable"><code>destination_operand</code></em> -= <em class="replaceable"><code>source_operand</code></em> ;  // For C fans.</pre><p>With nothing more than these three instructions, plus the HLA control structures that the next section discusses, you can actually write some sophisticated programs. <a class="xref" href="ch01s08.html#demonstration_of_the_mov_comma_add_comma" title="Example 1-3. Demonstration of the mov, add, and sub instructions">Example 1-3</a> provides a sample HLA program that demonstrates these three instructions.</p><div class="example"><a id="demonstration_of_the_mov_comma_add_comma"/><p class="title">Example 1-3. Demonstration of the <code class="literal">mov</code>, <code class="literal">add</code>, and <code class="literal">sub</code> instructions</p><div class="example-contents"><pre class="programlisting">program DemoMOVaddSUB;

#include( "stdlib.hhf" )

static
    i8:     int8    := −8;
    i16:    int16   := −16;
    i32:    int32   := −32;

begin DemoMOVaddSUB;

    // First, print the initial values
    // of our variables.

    stdout.put
    (
        nl,
        "Initialized values: i8=", i8,
        ", i16=", i16,
        ", i32=", i32,
        nl
    );

    // Compute the absolute value of the
    // three different variables and
    // print the result.
    // Note: Because all the numbers are
    // negative, we have to negate them.
    // Using only the mov, add, and sub
    // instructions, we can negate a value
    // by subtracting it from zero.

    mov( 0, al );   // Compute i8 := -i8;
    sub( i8, al );
    mov( al, i8 );

    mov( 0, ax );   // Compute i16 := -i16;
    sub( i16, ax );
    mov( ax, i16 );

    mov( 0, eax );  // Compute i32 := -i32;
    sub( i32, eax );
    mov( eax, i32 );

    // Display the absolute values:

    stdout.put
    (
        nl,
        "After negation: i8=", i8,
        ", i16=", i16,
        ", i32=", i32,
        nl
    );

    // Demonstrate add and constant-to-memory
    // operations:

    add( 32323200, i32 );
    stdout.put( nl, "After add: i32=", i32, nl );



end DemoMOVaddSUB;</pre></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-6" id="ftn.CHP-1-FN-6">6</a>] </sup>Different programs may use a different set of 30 instructions, but few programs use more than 30 distinct instructions.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-7" id="ftn.CHP-1-FN-7">7</a>] </sup>Technically, <code class="literal">mov</code> actually copies data from one location to another. It does not destroy the original data in the source operand. Perhaps a better name for this instruction would have been <code class="literal">copy</code>. Alas, it's too late to change it now.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-8" id="ftn.CHP-1-FN-8">8</a>] </sup>Remember, though, that <code class="literal">add</code> and <code class="literal">sub</code> do not support memory-to-memory operations.</p></div></div></div>
<div class="sect1" title="1.9 Some Basic HLA Control Structures"><div class="titlepage"><div><div><h1 class="title"><a id="some_basic_hla_control_structures"/>1.9 Some Basic HLA Control Structures</h1></div></div></div><p>The <code class="literal">mov</code>, <code class="literal">add</code>, and <code class="literal">sub</code> instructions, while valuable, aren't sufficient to let you write meaningful programs. You will need to complement these instructions with the ability to make decisions and create loops in your HLA programs before you can write anything other than a simple program. HLA provides several high-level control structures that are very similar to control structures found in high-level languages. These include <code class="literal">if..then..elseif..else..endif</code>, <code class="literal">while..endwhile</code>, <code class="literal">repeat..until</code>, and so on. By learning these statements you will be armed and ready to write some real programs.<a class="indexterm" id="IDX-CHP-1-0090"/><a class="indexterm" id="IDX-CHP-1-0091"/><a class="indexterm" id="IDX-CHP-1-0092"/><a class="indexterm" id="IDX-CHP-1-0093"/><a class="indexterm" id="IDX-CHP-1-0094"/><a class="indexterm" id="IDX-CHP-1-0095"/><a class="indexterm" id="IDX-CHP-1-0096"/><a class="indexterm" id="IDX-CHP-1-0097"/><a class="indexterm" id="IDX-CHP-1-0098"/><a class="indexterm" id="IDX-CHP-1-0099"/><a class="indexterm" id="IDX-CHP-1-0100"/><a class="indexterm" id="IDX-CHP-1-0101"/><a class="indexterm" id="IDX-CHP-1-0102"/><a class="indexterm" id="IDX-CHP-1-0103"/><a class="indexterm" id="IDX-CHP-1-0104"/><a class="indexterm" id="IDX-CHP-1-0105"/><a class="indexterm" id="IDX-CHP-1-0106"/><a class="indexterm" id="IDX-CHP-1-0107"/><a class="indexterm" id="IDX-CHP-1-0108"/><a class="indexterm" id="IDX-CHP-1-0109"/></p><p>Before discussing these high-level control structures, it's important to point out that these are not real 80x86 assembly language statements. HLA compiles these statements into a sequence of one or more real assembly language statements for you. In <a class="xref" href="ch07.html" title="Chapter 7. LOW-LEVEL CONTROL STRUCTURES">Chapter 7</a>, you'll learn how HLA compiles the statements, and you'll learn how to write pure assembly language code that doesn't use them. However, there is a lot to learn before you get to that point, so we'll stick with these high-level language statements for now.</p><p>Another important fact to mention is that HLA's high-level control structures are <span class="emphasis"><em>not</em></span> as high level as they first appear. The purpose behind HLA's high-level control structures is to let you start writing assembly language programs as quickly as possible, not to let you avoid the use of assembly language altogether. You will soon discover that these statements have some severe restrictions associated with them, and you will quickly outgrow their capabilities. This is intentional. Once you reach a certain level of comfort with HLA's high-level control structures and decide you need more power than they have to offer, it's time to move on and learn the real 80x86 instructions behind these statements.</p><p>Do not let the presence of high-level-like statements in HLA confuse you. Many people, after learning about the presence of these statements in the HLA language, erroneously come to the conclusion that HLA is just some special high-level language and not a true assembly language. This isn't true. HLA is a full low-level assembly language. HLA supports all the same machine instructions as any other 80x86 assembler. The difference is that HLA has some <span class="emphasis"><em>extra</em></span> statements that allow you to do <span class="emphasis"><em>more</em></span> than is possible with those other 80x86 assemblers. Once you learn 80x86 assembly language with HLA, you may elect to ignore all these extra (high-level) statements and write only low-level 80x86 assembly language code if this is your desire.</p><p>The following sections assume that you're familiar with at least one high-level language. They present the HLA control statements from that perspective without bothering to explain how you actually use these statements to accomplish something in a program. One prerequisite this text assumes is that you already know how to use these generic control statements in a high-level language; you'll use them in HLA programs in an identical manner.</p><div class="sect2" title="1.9.1 Boolean Expressions in HLA Statements"><div class="titlepage"><div><div><h2 class="title"><a id="boolean_expressions_in_hla_statements"/>1.9.1 Boolean Expressions in HLA Statements</h2></div></div></div><p>Several HLA statements require a boolean (true or false) expression to control their execution. Examples include the <code class="literal">if</code>, <code class="literal">while</code>, and <code class="literal">repeat..until</code> statements. The syntax for these boolean expressions represents the greatest limitation of the HLA high-level control structures. This is one area where your familiarity with a high-level language will work against you—you'll want to use the fancy expressions you use in a high-level language, yet HLA supports only some basic forms.<a class="indexterm" id="IDX-CHP-1-0110"/></p><p>HLA boolean expressions take the following forms:<sup>[<a class="footnote" href="#ftn.CHP-1-FN-9" id="CHP-1-FN-9">9</a>]</sup></p><a id="I_programlisting1_d1e1671"/><pre class="programlisting">flag_specification
!flag_specification
register
!register
Boolean_variable
!Boolean_variable
mem_reg relop mem_reg_const
register in LowConst..HiConst
register not in LowConst..HiConst</pre><p>A <code class="literal">flag_specification</code> may be one of the symbols that are described in <a class="xref" href="ch01s09.html#symbols_for_flag_underscore_specificatio" title="Table 1-2. Symbols for flag_specification">Table 1-2</a>.</p><div class="table"><a id="symbols_for_flag_underscore_specificatio"/><p class="title">Table 1-2. Symbols for <code class="literal">flag_specification</code></p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Symbols for flag_specification"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Symbol</p></th><th style="text-align: left" valign="bottom"><p>Meaning</p></th><th style="text-align: left" valign="bottom"><p>Explanation</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">@c</code><a class="indexterm" id="IDX-CHP-1-0111"/><a class="indexterm" id="IDX-CHP-1-0112"/></p></td><td style="text-align: left" valign="top"><p>Carry</p></td><td style="text-align: left" valign="top"><p>True if the carry is set (1); false if the carry is clear (0).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nc</code><a class="indexterm" id="IDX-CHP-1-0113"/><a class="indexterm" id="IDX-CHP-1-0114"/></p></td><td style="text-align: left" valign="top"><p>No carry</p></td><td style="text-align: left" valign="top"><p>True if the carry is clear (0); false if the carry is set (1).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@z</code><a class="indexterm" id="IDX-CHP-1-0115"/><a class="indexterm" id="IDX-CHP-1-0116"/></p></td><td style="text-align: left" valign="top"><p>Zero</p></td><td style="text-align: left" valign="top"><p>True if the zero flag is set; false if it is clear.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nz</code><a class="indexterm" id="IDX-CHP-1-0117"/><a class="indexterm" id="IDX-CHP-1-0118"/></p></td><td style="text-align: left" valign="top"><p>Not zero</p></td><td style="text-align: left" valign="top"><p>True if the zero flag is clear; false if it is set.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@o</code><a class="indexterm" id="IDX-CHP-1-0119"/><a class="indexterm" id="IDX-CHP-1-0120"/></p></td><td style="text-align: left" valign="top"><p>Overflow</p></td><td style="text-align: left" valign="top"><p>True if the overflow flag is set; false if it is clear.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@no</code><a class="indexterm" id="IDX-CHP-1-0121"/><a class="indexterm" id="IDX-CHP-1-0122"/></p></td><td style="text-align: left" valign="top"><p>No overflow</p></td><td style="text-align: left" valign="top"><p>True if the overflow flag is clear; false if it is set.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@s</code><a class="indexterm" id="IDX-CHP-1-0123"/><a class="indexterm" id="IDX-CHP-1-0124"/></p></td><td style="text-align: left" valign="top"><p>Sign</p></td><td style="text-align: left" valign="top"><p>True if the sign flag is set; false if it is clear.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@ns</code><a class="indexterm" id="IDX-CHP-1-0125"/><a class="indexterm" id="IDX-CHP-1-0126"/></p></td><td style="text-align: left" valign="top"><p>No sign</p></td><td style="text-align: left" valign="top"><p>True if the sign flag is clear; false if it is set.</p></td></tr></tbody></table></div></div><p>The use of the flag values in a boolean expression is somewhat advanced. You will begin to see how to use these boolean expression operands in the next chapter.<a class="indexterm" id="IDX-CHP-1-0127"/><a class="indexterm" id="IDX-CHP-1-0128"/><a class="indexterm" id="IDX-CHP-1-0129"/><a class="indexterm" id="IDX-CHP-1-0130"/><a class="indexterm" id="IDX-CHP-1-0131"/><a class="indexterm" id="IDX-CHP-1-0132"/></p><p>A register operand can be any of the 8-bit, 16-bit, or 32-bit general-purpose registers. The expression evaluates false if the register contains a zero; it evaluates true if the register contains a nonzero value.</p><p>If you specify a boolean variable as the expression, the program tests it for zero (false) or nonzero (true). Because HLA uses the values zero and one to represent false and true, respectively, the test works in an intuitive fashion. Note that HLA requires such variables be of type <code class="literal">boolean</code>. HLA rejects other data types. If you want to test some other type against zero/not zero, then use the general boolean expression discussed next.</p><p>The most general form of an HLA boolean expression has two operands and a relational operator. <a class="xref" href="ch01s09.html#legal_boolean_expressions" title="Table 1-3. Legal Boolean Expressions">Table 1-3</a> lists the legal combinations.</p><div class="table"><a id="legal_boolean_expressions"/><p class="title">Table 1-3. Legal Boolean Expressions</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Legal Boolean Expressions"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Left Operand</p></th><th style="text-align: left" valign="bottom"><p>Relational Operator</p></th><th style="text-align: left" valign="bottom"><p>Right Operand</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Memory variable or register</p></td><td style="text-align: left" valign="top"><p>= or ==</p>
<p>&lt;&gt; or !=</p>
<p>&lt;</p>
<p>&lt;=</p>
<p>&gt;</p>
<p>&gt;=</p></td><td style="text-align: left" valign="top"><p>Variable, register, or constant</p></td></tr></tbody></table></div></div><p>Note that both operands cannot be memory operands. In fact, if you think of the <span class="emphasis"><em>right operand</em></span> as the source operand and the <span class="emphasis"><em>left operand</em></span> as the destination operand, then the two operands must be the same that <code class="literal">add</code> and <code class="literal">sub</code> allow.</p><p>Also like the <code class="literal">add</code> and <code class="literal">sub</code> instructions, the two operands must be the same size. That is, they must both be byte operands, they must both be word operands, or they must both be double-word operands. If the right operand is a constant, its value must be in the range that is compatible with the left operand.</p><p>There is one other issue: if the left operand is a register and the right operand is a positive constant or another register, HLA uses an <span class="emphasis"><em>unsigned</em></span> comparison. The next chapter will discuss the ramifications of this; for the time being, do not compare negative values in a register against a constant or another register. You may not get an intuitive result.</p><p>The <code class="literal">in</code> and <code class="literal">not in</code> operators let you test a register to see if it is within a specified range. For example, the expression <code class="literal">eax in 2000..2099</code> evaluates true if the value in the EAX register is between 2,000 and 2,099 (inclusive). The <code class="literal">not in</code> (two words) operator checks to see if the value in a register is outside the specified range. For example, <code class="literal">al not in 'a'..'z'</code> evaluates true if the character in the AL register is not a lowercase alphabetic character.<a class="indexterm" id="IDX-CHP-1-0133"/></p><p>Here are some examples of legal boolean expressions in HLA:</p><a id="I_programlisting1_d1e1983"/><pre class="programlisting">@c
Bool_var
al
esi
eax &lt; ebx
ebx &gt; 5
i32 &lt; −2
i8 &gt; 128
al &lt; i8
eax in 1..100
ch not in 'a'..'z'</pre></div><div class="sect2" title="1.9.2 The HLA if..then..elseif..else..endif Statement"><div class="titlepage"><div><div><h2 class="title"><a id="the_hla_if..then..elseif..else..endif_st"/>1.9.2 The HLA if..then..elseif..else..endif Statement</h2></div></div></div><p>The HLA <code class="literal">if</code> statement uses the syntax shown in <a class="xref" href="ch01s09.html#hla_if_statement_syntax" title="Figure 1-10. HLA if statement syntax">Figure 1-10</a>.<a class="indexterm" id="IDX-CHP-1-0134"/><a class="indexterm" id="IDX-CHP-1-0135"/></p><div class="figure"><a id="hla_if_statement_syntax"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e2009"/><img alt="HLA if statement syntax" src="tagoreillycom20100401nostarchimages577873.png.jpg"/></div></div><p class="title">Figure 1-10. HLA <code class="literal">if</code> statement syntax</p></div><p>The expressions appearing in an <code class="literal">if</code> statement must take one of the forms from the previous section. If the boolean expression is true, the code after the <code class="literal">then</code> executes; otherwise control transfers to the next <code class="literal">elseif</code> or <code class="literal">else</code> clause in the statement.</p><p>Because the <code class="literal">elseif</code> and <code class="literal">else</code> clauses are optional, an <code class="literal">if</code> statement could take the form of a single <code class="literal">if..then</code> clause, followed by a sequence of statements and a closing <code class="literal">endif</code> clause. The following is such a statement:</p><a id="I_programlisting1_d1e2045"/><pre class="programlisting">if( eax = 0 ) then

     stdout.put( "error: NULL value", nl );

endif;</pre><p>If, during program execution, the expression evaluates true, then the code between the <code class="literal">then</code> and the <code class="literal">endif</code> executes. If the expression evaluates false, then the program skips over the code between the <code class="literal">then</code> and the <code class="literal">endif</code>.</p><p>Another common form of the <code class="literal">if</code> statement has a single <code class="literal">else</code> clause. The following is an example of an <code class="literal">if</code> statement with an optional <code class="literal">else</code> clause:</p><a id="I_programlisting1_d1e2075"/><pre class="programlisting">if( eax = 0 ) then

     stdout.put( "error: NULL pointer encountered", nl );

else

     stdout.put( "Pointer is valid", nl );

endif;</pre><p>If the expression evaluates true, the code between the <code class="literal">then</code> and the <code class="literal">else</code> executes; otherwise the code between the <code class="literal">else</code> and the <code class="literal">endif</code> clauses executes.</p><p>You can create sophisticated decision-making logic by incorporating the <code class="literal">elseif</code> clause into an <code class="literal">if</code> statement. For example, if the CH register contains a character value, you can select from a menu of items using code like the following:</p><a id="I_programlisting1_d1e2100"/><pre class="programlisting">if( ch = 'a' ) then

     stdout.put( "You selected the 'a' menu item", nl );

elseif( ch = 'b' ) then

     stdout.put( "You selected the 'b' menu item", nl );

elseif( ch = 'c' ) then

     stdout.put( "You selected the 'c' menu item", nl );

else

     stdout.put( "Error: illegal menu item selection", nl );

endif;</pre><p>Although this simple example doesn't demonstrate it, HLA does not require an <code class="literal">else</code> clause at the end of a sequence of <code class="literal">elseif</code> clauses. However, when making multiway decisions, it's always a good idea to provide an <code class="literal">else</code> clause just in case an error arises. Even if you think it's impossible for the <code class="literal">else</code> clause to execute, just keep in mind that future modifications to the code could void this assertion, so it's a good idea to have error-reporting statements in your code.</p></div><div class="sect2" title="1.9.3 Conjunction, Disjunction, and Negation in Boolean Expressions"><div class="titlepage"><div><div><h2 class="title"><a id="conjunction_comma_disjunction_comma_and"/>1.9.3 Conjunction, Disjunction, and Negation in Boolean Expressions</h2></div></div></div><p>Some obvious omissions in the list of operators in the previous sections are the conjunction (logical <code class="literal">and</code>), disjunction (logical <code class="literal">or</code>), and negation (logical <code class="literal">not</code>) operators. This section describes their use in boolean expressions (the discussion had to wait until after describing the <code class="literal">if</code> statement in order to present realistic examples).<a class="indexterm" id="IDX-CHP-1-0136"/></p><p>HLA uses the <code class="literal">&amp;&amp;</code> operator to denote logical <code class="literal">and</code> in a runtime boolean expression. This is a dyadic (two-operand) operator, and the two operands must be legal runtime boolean expressions. This operator evaluates to true if both operands evaluate to true. For example:</p><a id="I_programlisting1_d1e2144"/><pre class="programlisting">if( eax &gt; 0 &amp;&amp; ch = 'a' ) then

          mov( eax, ebx );
          mov( ' ', ch );

     endif;</pre><p>The two <code class="literal">mov</code> statements above execute only if EAX is greater than zero <span class="emphasis"><em>and</em></span> CH is equal to the character <span class="emphasis"><em>a</em></span>. If either of these conditions is false, then program execution skips over these <code class="literal">mov</code> instructions.</p><p>Note that the expressions on either side of the <code class="literal">&amp;&amp;</code> operator may be any legal boolean expressions; these expressions don't have to be comparisons using the relational operators. For example, the following are all legal expressions:</p><a id="I_programlisting1_d1e2165"/><pre class="programlisting">@z &amp;&amp; al in 5..10
     al in 'a'..'z' &amp;&amp; ebx
     boolVar &amp;&amp; !eax</pre><p>HLA uses <span class="emphasis"><em>short-circuit evaluation</em></span> when compiling the <code class="literal">&amp;&amp;</code> operator. If the leftmost operand evaluates false, then the code that HLA generates does not bother evaluating the second operand (because the whole expression must be false at that point). Therefore, in the last expression above, the code will not check EAX against zero if <code class="literal">boolVar</code> evaluates false.</p><p>Note that an expression like <code class="literal">eax &lt; 10 &amp;&amp; ebx &lt;&gt; eax</code> is itself a legal boolean expression and, therefore, may appear as the left or right operand of the <code class="literal">&amp;&amp;</code> operator. Therefore, expressions like the following are perfectly legal:</p><a id="I_programlisting1_d1e2186"/><pre class="programlisting">eax &lt; 0  &amp;&amp;  ebx &lt;&gt; eax    &amp;&amp;    !ecx</pre><p>The <code class="literal">&amp;&amp;</code> operator is left associative, so the code that HLA generates evaluates the expression above in a left-to-right fashion. If EAX is less than zero, the CPU will not test either of the remaining expressions. Likewise, if EAX is not less than zero but EBX is equal to EAX, this code will not evaluate the third expression because the whole expression is false regardless of ECX's value.</p><p>HLA uses the <code class="literal">||</code> operator to denote disjunction (logical <code class="literal">or</code>) in a runtime boolean expression. Like the <code class="literal">&amp;&amp;</code> operator, this operator expects two legal runtime boolean expressions as operands. This operator evaluates true if either (or both) operands evaluate true. Like the <code class="literal">&amp;&amp;</code> operator, the disjunction operator uses short-circuit evaluation. If the left operand evaluates true, then the code that HLA generates doesn't bother to test the value of the second operand. Instead, the code will transfer to the location that handles the situation when the boolean expression evaluates true. Here are some examples of legal expressions using the <code class="literal">||</code> operator:<a class="indexterm" id="IDX-CHP-1-0137"/><a class="indexterm" id="IDX-CHP-1-0138"/></p><a id="I_programlisting1_d1e2218"/><pre class="programlisting">@z || al = 10
     al in 'a'..'z' || ebx
     !boolVar || eax</pre><p>Like the <code class="literal">&amp;&amp;</code> operator, the disjunction operator is left associative, so multiple instances of the <code class="literal">||</code> operator may appear within the same expression. Should this be the case, the code that HLA generates will evaluate the expressions from left to right. For example:</p><a id="I_programlisting1_d1e2228"/><pre class="programlisting">eax &lt; 0  ||  ebx &lt;&gt; eax    ||   !ecx</pre><p>The code above evaluates to true if EAX is less than zero, EBX does not equal EAX, or ECX is zero. Note that if the first comparison is true, the code doesn't bother testing the other conditions. Likewise, if the first comparison is false and the second is true, the code doesn't bother checking to see if ECX is zero. The check for ECX equal to zero occurs only if the first two comparisons are false.</p><p>If both the conjunction and disjunction operators appear in the same expression, then the <code class="literal">&amp;&amp;</code> operator takes precedence over the <code class="literal">||</code> operator. Consider the following expression:</p><a id="I_programlisting1_d1e2240"/><pre class="programlisting">eax &lt; 0 || ebx &lt;&gt; eax  &amp;&amp; !ecx</pre><p>The machine code HLA generates evaluates this as</p><a id="I_programlisting1_d1e2244"/><pre class="programlisting">eax &lt; 0 || (ebx &lt;&gt; eax  &amp;&amp; !ecx)</pre><p>If EAX is less than zero, then the code HLA generates does not bother to check the remainder of the expression, and the entire expression evaluates true. However, if EAX is not less than zero, then both of the following conditions must evaluate true in order for the overall expression to evaluate true.</p><p>HLA allows you to use parentheses to surround subexpressions involving <code class="literal">&amp;&amp;</code> and <code class="literal">||</code> if you need to adjust the precedence of the operators. Consider the following expression:</p><a id="I_programlisting1_d1e2257"/><pre class="programlisting">(eax &lt; 0 || ebx &lt;&gt; eax)  &amp;&amp; !ecx</pre><p>For this expression to evaluate true, ECX must contain zero and either EAX must be less than zero or EBX must not equal EAX. Contrast this to the result the expression produces without the parentheses.<a class="indexterm" id="IDX-CHP-1-0139"/><a class="indexterm" id="IDX-CHP-1-0140"/><a class="indexterm" id="IDX-CHP-1-0141"/><a class="indexterm" id="IDX-CHP-1-0142"/><a class="indexterm" id="IDX-CHP-1-0143"/></p><p>HLA uses the <code class="literal">!</code> operator to denote logical negation. However, the <code class="literal">!</code> operator may only prefix a register or boolean variable; you may not use it as part of a larger expression (e.g., <code class="literal">!eax &lt; 0</code>). To achieve logical negative of an existing boolean expression, you must surround that expression with parentheses and prefix the parentheses with the <code class="literal">!</code> operator. For example:</p><a id="I_programlisting1_d1e2294"/><pre class="programlisting">!( eax &lt; 0 )</pre><p>This expression evaluates true if EAX is not less than zero.</p><p>The logical <code class="literal">not</code> operator is primarily useful for surrounding complex expressions involving the conjunction and disjunction operators. While it is occasionally useful for short expressions like the one above, it's usually easier (and more readable) to simply state the logic directly rather than convolute it with the logical <code class="literal">not</code> operator.</p><p>Note that HLA also provides the <code class="literal">|</code> and <code class="literal">&amp;</code> operators, but they are distinct from <code class="literal">||</code> and <code class="literal">&amp;&amp;</code> and have completely different meanings. See the HLA reference manual for more details on these (compile-time) operators.</p></div><div class="sect2" title="1.9.4 The while..endwhile Statement"><div class="titlepage"><div><div><h2 class="title"><a id="the_while..endwhile_statement"/>1.9.4 The while..endwhile Statement</h2></div></div></div><p>The <code class="literal">while</code> statement uses the basic syntax shown in <a class="xref" href="ch01s09.html#hla_while_statement_syntax" title="Figure 1-11. HLA while statement syntax">Figure 1-11</a>.</p><div class="figure"><a id="hla_while_statement_syntax"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e2336"/><img alt="HLA while statement syntax" src="tagoreillycom20100401nostarchimages577875.png.jpg"/></div></div><p class="title">Figure 1-11. HLA <code class="literal">while</code> statement syntax</p></div><p>This statement evaluates the boolean expression. If it is false, control immediately transfers to the first statement following the <code class="literal">endwhile</code> clause. If the value of the expression is true, then the CPU executes the body of the loop. After the loop body executes, control transfers back to the top of the loop, where the <code class="literal">while</code> statement retests the loop control expression. This process repeats until the expression evaluates false.</p><p>Note that the <code class="literal">while</code> loop, like its high-level-language counterpart, tests for loop termination at the top of the loop. Therefore, it is quite possible that the statements in the body of the loop will not execute (if the expression is false when the code first executes the <code class="literal">while</code> statement). Also note that the body of the <code class="literal">while</code> loop must, at some point, modify the value of the boolean expression or an infinite loop will result.</p><p>Here's an example of an HLA <code class="literal">while</code> loop:<a class="indexterm" id="IDX-CHP-1-0144"/><a class="indexterm" id="IDX-CHP-1-0145"/><a class="indexterm" id="IDX-CHP-1-0146"/><a class="indexterm" id="IDX-CHP-1-0147"/></p><a id="I_programlisting1_d1e2381"/><pre class="programlisting">mov( 0, i );
while( i &lt; 10 ) do

     stdout.put( "i=", i, nl );
     add( 1, i );

endwhile;</pre></div><div class="sect2" title="1.9.5 The for..endfor Statement"><div class="titlepage"><div><div><h2 class="title"><a id="the_for..endfor_statement"/>1.9.5 The for..endfor Statement</h2></div></div></div><p>The HLA <code class="literal">for</code> loop takes the following general form:</p><a id="I_programlisting1_d1e2391"/><pre class="programlisting">for( <em class="replaceable"><code>Initial_Stmt</code></em>; <em class="replaceable"><code>Termination_Expression</code></em>; <em class="replaceable"><code>Post_Body_Statement</code></em> ) do

     &lt;&lt; Loop body &gt;&gt;

endfor;</pre><p>This is equivalent to the following <code class="literal">while</code> statement:</p><a id="I_programlisting1_d1e2407"/><pre class="programlisting"><em class="replaceable"><code>Initial_Stmt</code></em>;
while( <em class="replaceable"><code>Termination_Expression</code></em> ) do

     &lt;&lt; Loop body &gt;&gt;

     <em class="replaceable"><code>Post_Body_Statement</code></em>;

endwhile;</pre><p><em class="replaceable"><code>Initial_Stmt</code></em> can be any single HLA/80x86 instruction. Generally this statement initializes a register or memory location (the loop counter) with zero or some other initial value. <em class="replaceable"><code>Termination_Expression</code></em> is an HLA boolean expression (same format that <code class="literal">while</code> allows). This expression determines whether the loop body executes. <em class="replaceable"><code>Post_Body_Statement</code></em> executes at the bottom of the loop (as shown in the <code class="literal">while</code> example above). This is a single HLA statement. Usually an instruction like <code class="literal">add</code> modifies the value of the loop control variable.</p><p>The following gives a complete example:</p><a id="I_programlisting1_d1e2438"/><pre class="programlisting">for( mov( 0, i ); i &lt; 10; add(1, i )) do

     stdout.put( "i=", i, nl );

endfor;</pre><p>The above, rewritten as a while loop, becomes:<a class="indexterm" id="IDX-CHP-1-0148"/><a class="indexterm" id="IDX-CHP-1-0149"/></p><a id="I_programlisting1_d1e2450"/><pre class="programlisting">mov( 0, i );
while( i &lt; 10 ) do

     stdout.put( "i=", i, nl );

     add( 1, i );

endwhile;</pre></div><div class="sect2" title="1.9.6 The repeat..until Statement"><div class="titlepage"><div><div><h2 class="title"><a id="the_repeat..until_statement"/>1.9.6 The repeat..until Statement</h2></div></div></div><p>The HLA <code class="literal">repeat..until</code> statement uses the syntax shown in <a class="xref" href="ch01s09.html#hla_repeat..until_statement_syntax" title="Figure 1-12. HLA repeat..until statement syntax">Figure 1-12</a>. C/C++/C# and Java users should note that the <code class="literal">repeat..until</code> statement is very similar to the <code class="literal">do..while</code> statement.</p><div class="figure"><a id="hla_repeat..until_statement_syntax"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e2475"/><img alt="HLA repeat..until statement syntax" src="tagoreillycom20100401nostarchimages577877.png.jpg"/></div></div><p class="title">Figure 1-12. HLA <code class="literal">repeat..until</code> statement syntax</p></div><p>The HLA <code class="literal">repeat..until</code> statement tests for loop termination at the bottom of the loop. Therefore, the statements in the loop body always execute at least once. Upon encountering the <code class="literal">until</code> clause, the program will evaluate the expression and repeat the loop if the expression is false (that is, it repeats while false). If the expression evaluates true, the control transfers to the first statement following the <code class="literal">until</code> clause.</p><p>The following simple example demonstrates the <code class="literal">repeat..until</code> statement:</p><a id="I_programlisting1_d1e2496"/><pre class="programlisting">mov( 10, ecx );
repeat

     stdout.put( "ecx = ", ecx, nl );
     sub( 1, ecx );

until( ecx = 0 );</pre><p>If the loop body will always execute at least once, then it is usually more efficient to use a <code class="literal">repeat..until</code> loop rather than a <code class="literal">while</code> loop.</p></div><div class="sect2" title="1.9.7 The break and breakif Statements"><div class="titlepage"><div><div><h2 class="title"><a id="the_break_and_breakif_statements"/>1.9.7 The break and breakif Statements</h2></div></div></div><p>The <code class="literal">break</code> and <code class="literal">breakif</code> statements provide the ability to prematurely exit from a loop. <a class="xref" href="ch01s09.html#hla_break_and_breakif_syntax" title="Figure 1-13. HLA break and breakif syntax">Figure 1-13</a> shows the syntax for these two statements.<a class="indexterm" id="IDX-CHP-1-0150"/><a class="indexterm" id="IDX-CHP-1-0151"/><a class="indexterm" id="IDX-CHP-1-0152"/><a class="indexterm" id="IDX-CHP-1-0153"/><a class="indexterm" id="IDX-CHP-1-0154"/><a class="indexterm" id="IDX-CHP-1-0155"/><a class="indexterm" id="IDX-CHP-1-0156"/><a class="indexterm" id="IDX-CHP-1-0157"/><a class="indexterm" id="IDX-CHP-1-0158"/></p><div class="figure"><a id="hla_break_and_breakif_syntax"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e2562"/><img alt="HLA break and breakif syntax" src="tagoreillycom20100401nostarchimages577879.png"/></div></div><p class="title">Figure 1-13. HLA <code class="literal">break</code> and <code class="literal">breakif</code> syntax</p></div><p>The <code class="literal">break</code> statement exits the loop that immediately contains the <code class="literal">break</code>. The <code class="literal">breakif</code> statement evaluates the boolean expression and exits the containing loop if the expression evaluates true.</p><p>Note that the <code class="literal">break</code> and <code class="literal">breakif</code> statements do not allow you to break out of more than one nested loop. HLA does provide statements that do this, the <code class="literal">begin..end</code> block and the <code class="literal">exit</code>/<code class="literal">exitif</code> statements. Please consult the HLA reference manual for more details. HLA also provides the <code class="literal">continue</code>/<code class="literal">continueif</code> pair that lets you repeat a loop body. Again, see the HLA reference manual for more details.</p></div><div class="sect2" title="1.9.8 The forever..endfor Statement"><div class="titlepage"><div><div><h2 class="title"><a id="the_forever..endfor_statement"/>1.9.8 The forever..endfor Statement</h2></div></div></div><p><a class="xref" href="ch01s09.html#hla_forever_loop_syntax" title="Figure 1-14. HLA forever loop syntax">Figure 1-14</a> shows the syntax for the <code class="literal">forever</code> statement.</p><div class="figure"><a id="hla_forever_loop_syntax"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e2617"/><img alt="HLA forever loop syntax" src="tagoreillycom20100401nostarchimages577881.png.jpg"/></div></div><p class="title">Figure 1-14. HLA <code class="literal">forever</code> loop syntax</p></div><p>This statement creates an infinite loop. You may also use the <code class="literal">break</code> and <code class="literal">breakif</code> statements along with <code class="literal">forever..endfor</code> to create a loop that tests for loop termination in the middle of the loop. Indeed, this is probably the most common use of this loop, as the following example demonstrates:</p><a id="I_programlisting1_d1e2633"/><pre class="programlisting">forever

     stdout.put( "Enter an integer less than 10: ");
     stdin.get( i );
     breakif( i &lt; 10 );
     stdout.put( "The value needs to be less than 10!", nl );

endfor;</pre></div><div class="sect2" title="1.9.9 The try..exception..endtry Statement"><div class="titlepage"><div><div><h2 class="title"><a id="the_try..exception..endtry_statement"/>1.9.9 The try..exception..endtry Statement</h2></div></div></div><p>The HLA <code class="literal">try..exception..endtry</code> statement provides very powerful <span class="emphasis"><em>exception handling</em></span> capabilities. The syntax for this statement appears in <a class="xref" href="ch01s09.html#hla_try..exception..endtry_statement_syn" title="Figure 1-15. HLA try..exception..endtry statement syntax">Figure 1-15</a>.<a class="indexterm" id="IDX-CHP-1-0159"/><a class="indexterm" id="IDX-CHP-1-0160"/><a class="indexterm" id="IDX-CHP-1-0161"/><a class="indexterm" id="IDX-CHP-1-0162"/><a class="indexterm" id="IDX-CHP-1-0163"/><a class="indexterm" id="IDX-CHP-1-0164"/></p><div class="figure"><a id="hla_try..exception..endtry_statement_syn"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e2681"/><img alt="HLA try..exception..endtry statement syntax" src="tagoreillycom20100401nostarchimages577883.png.jpg"/></div></div><p class="title">Figure 1-15. HLA <code class="literal">try..exception..endtry</code> statement syntax</p></div><p>The <code class="literal">try..endtry</code> statement protects a block of statements during execution. If the statements between the <code class="literal">try</code> clause and the first <code class="literal">exception</code> clause (the <span class="emphasis"><em>protected block</em></span>), execute without incident, control transfers to the first statement after the <code class="literal">endtry</code> immediately after executing the last statement in the protected block. If an error (exception) occurs, then the program interrupts control at the point of the exception (that is, the program <span class="emphasis"><em>raises</em></span> an exception). Each exception has an unsigned integer constant associated with it, known as the <span class="emphasis"><em>exception ID</em></span>. The <span class="emphasis"><em>excepts.hhf</em></span> header file in the HLA Standard Library predefines several exception IDs, although you may create new ones for your own purposes. When an exception occurs, the system compares the exception ID against the values appearing in each of the exception clauses following the protected code. If the current exception ID matches one of the exception values, control continues with the block of statements immediately following that exception. After the exception-handling code completes execution, control transfers to the first statement following the <code class="literal">endtry</code>.<a class="indexterm" id="IDX-CHP-1-0165"/></p><p>If an exception occurs and there is no active <code class="literal">try..endtry</code> statement, or the active <code class="literal">try..endtry</code> statements do not handle the specific exception, the program will abort with an error message.</p><p>The following code fragment demonstrates how to use the <code class="literal">try..endtry</code> statement to protect the program from bad user input:</p><a id="I_programlisting1_d1e2734"/><pre class="programlisting">repeat

     mov( false, GoodInteger );   // Note: GoodInteger must be a boolean var.
     try

          stdout.put( "Enter an integer: " );
          stdin.get( i );
          mov( true, GoodInteger );

     exception( ex.ConversionError );

          stdout.put( "Illegal numeric value, please re-enter", nl );

     exception( ex.ValueOutOfRange );

          stdout.put( "Value is out of range, please re-enter", nl );

     endtry;

until( GoodInteger );</pre><p>The <code class="literal">repeat..until</code> loop repeats this code as long as there is an error during input. Should an exception occur because of bad input, control transfers to the exception clauses to see if a conversion error (e.g., illegal characters in the number) or a numeric overflow occurs. If either of these exceptions occur, then they print the appropriate message, control falls out of the <code class="literal">try..endtry</code> statement, and the <code class="literal">repeat..until</code> loop repeats because the code will not have set <code class="literal">GoodInteger</code> to true. If a different exception occurs (one that is not handled in this code), then the program aborts with the specified error message.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-10" id="CHP-1-FN-10">10</a>]</sup></p><p><a class="xref" href="ch01s09.html#exceptions_provided_in_excepts.hhf" title="Table 1-4. Exceptions Provided in excepts.hhf">Table 1-4</a> lists the exceptions provided in the <span class="emphasis"><em>excepts.hhf</em></span> header file at the time this was being written. See the <span class="emphasis"><em>excepts.hhf</em></span> header file provided with HLA for the most current list of exceptions.</p><div class="table"><a id="exceptions_provided_in_excepts.hhf"/><p class="title">Table 1-4. Exceptions Provided in <span class="emphasis"><em>excepts.hhf</em></span></p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Exceptions Provided in excepts.hhf"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Exception</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.StringOverflow</code><a class="indexterm" id="IDX-CHP-1-0166"/></p></td><td style="text-align: left" valign="top"><p>Attempt to store a string that is too large into a string variable.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.StringIndexError</code><a class="indexterm" id="IDX-CHP-1-0167"/></p></td><td style="text-align: left" valign="top"><p>Attempt to access a character that is not present in a string.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.StringOverlap</code><a class="indexterm" id="IDX-CHP-1-0168"/></p></td><td style="text-align: left" valign="top"><p>Attempt to copy a string onto itself.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.StringMetaData</code><a class="indexterm" id="IDX-CHP-1-0169"/></p></td><td style="text-align: left" valign="top"><p>Corrupted string value.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.StringAlignment</code><a class="indexterm" id="IDX-CHP-1-0170"/></p></td><td style="text-align: left" valign="top"><p>Attempt to store a string an at unaligned address.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.StringUnderflow</code><a class="indexterm" id="IDX-CHP-1-0171"/></p></td><td style="text-align: left" valign="top"><p>Attempt to extract "negative" characters from a string.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.IllegalStringOperation</code><a class="indexterm" id="IDX-CHP-1-0172"/></p></td><td style="text-align: left" valign="top"><p>Operation not permitted on string data.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.ValueOutOfRange</code><a class="indexterm" id="IDX-CHP-1-0173"/></p></td><td style="text-align: left" valign="top"><p>Value is too large for the current operation.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.IllegalChar</code><a class="indexterm" id="IDX-CHP-1-0174"/></p></td><td style="text-align: left" valign="top"><p>Operation encountered a character code whose ASCII code is not in the range 0..127.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.TooManyCmdLnParms</code><a class="indexterm" id="IDX-CHP-1-0175"/></p></td><td style="text-align: left" valign="top"><p>Command line contains too many program parameters.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.BadObjPtr</code><a class="indexterm" id="IDX-CHP-1-0176"/></p></td><td style="text-align: left" valign="top"><p>Pointer to class object is illegal.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.InvalidAlignment</code><a class="indexterm" id="IDX-CHP-1-0177"/><a class="indexterm" id="IDX-CHP-1-0178"/></p></td><td style="text-align: left" valign="top"><p>Argument was not aligned on a proper memory address.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.InvalidArgument</code><a class="indexterm" id="IDX-CHP-1-0179"/></p></td><td style="text-align: left" valign="top"><p>Function call (generally OS API call) contains an invalid argument value.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.BufferOverflow</code><a class="indexterm" id="IDX-CHP-1-0180"/></p></td><td style="text-align: left" valign="top"><p>Buffer or blob object exceeded declared size.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.BufferUnderflow</code><a class="indexterm" id="IDX-CHP-1-0181"/></p></td><td style="text-align: left" valign="top"><p>Attempt to retrieve nonexistent data from a blob or buffer.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.IllegalSize</code><a class="indexterm" id="IDX-CHP-1-0182"/></p></td><td style="text-align: left" valign="top"><p>Argument's data size is incorrect.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.ConversionError</code><a class="indexterm" id="IDX-CHP-1-0183"/></p></td><td style="text-align: left" valign="top"><p>String-to-numeric conversion operation contains illegal (nonnumeric) characters.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.BadFileHandle</code><a class="indexterm" id="IDX-CHP-1-0184"/></p></td><td style="text-align: left" valign="top"><p>Program attempted a file access using an invalid file handle value.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.FileNotFound</code><a class="indexterm" id="IDX-CHP-1-0185"/></p></td><td style="text-align: left" valign="top"><p>Program attempted to access a nonexistent file.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.FileOpenFailure</code><a class="indexterm" id="IDX-CHP-1-0186"/></p></td><td style="text-align: left" valign="top"><p>Operating system could not open the file (file not found).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.FileCloseError</code><a class="indexterm" id="IDX-CHP-1-0187"/></p></td><td style="text-align: left" valign="top"><p>Operating system could not close the file.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.FileWriteError</code><a class="indexterm" id="IDX-CHP-1-0188"/></p></td><td style="text-align: left" valign="top"><p>Error writing data to a file.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.FileReadError</code><a class="indexterm" id="IDX-CHP-1-0189"/></p></td><td style="text-align: left" valign="top"><p>Error reading data from a file.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.FileSeekError</code><a class="indexterm" id="IDX-CHP-1-0190"/></p></td><td style="text-align: left" valign="top"><p>Attempted to seek to a nonexistent position in a file.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.DiskFullError</code><a class="indexterm" id="IDX-CHP-1-0191"/></p></td><td style="text-align: left" valign="top"><p>Attempted to write data to a full disk.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.AccessDenied</code><a class="indexterm" id="IDX-CHP-1-0192"/></p></td><td style="text-align: left" valign="top"><p>User does not have sufficient priviledges to access file data.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.EndOfFile</code><a class="indexterm" id="IDX-CHP-1-0193"/></p></td><td style="text-align: left" valign="top"><p>Program attempted to read beyond the end of file.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.CannotCreateDir</code><a class="indexterm" id="IDX-CHP-1-0194"/></p></td><td style="text-align: left" valign="top"><p>Attempt to create a directory failed.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.CannotRemoveDir</code><a class="indexterm" id="IDX-CHP-1-0195"/></p></td><td style="text-align: left" valign="top"><p>Attempt to delete a directory failed.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.CannotRemoveFile</code><a class="indexterm" id="IDX-CHP-1-0196"/></p></td><td style="text-align: left" valign="top"><p>Attempt to delete a file failed.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.CDFailed</code><a class="indexterm" id="IDX-CHP-1-0197"/></p></td><td style="text-align: left" valign="top"><p>Attempt to change to a new directory failed.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.CannotRenameFile</code><a class="indexterm" id="IDX-CHP-1-0198"/></p></td><td style="text-align: left" valign="top"><p>Attempt to rename a file failed.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.MemoryAllocationFailure</code><a class="indexterm" id="IDX-CHP-1-0199"/></p></td><td style="text-align: left" valign="top"><p>Insufficient system memory for allocation request.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.MemoryFreeFailure</code><a class="indexterm" id="IDX-CHP-1-0200"/></p></td><td style="text-align: left" valign="top"><p>Could not free the specified memory block (corrupted memory management system).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.MemoryAllocationCorruption</code><a class="indexterm" id="IDX-CHP-1-0201"/></p></td><td style="text-align: left" valign="top"><p>Corrupted memory management system.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.AttemptToFreeNULL</code><a class="indexterm" id="IDX-CHP-1-0202"/></p></td><td style="text-align: left" valign="top"><p>Caller attempted to free a NULL pointer.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.AttemptToDerefNULL</code><a class="indexterm" id="IDX-CHP-1-0203"/></p></td><td style="text-align: left" valign="top"><p>Program attempted to access data indirectly using a NULL pointer.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.BlockAlreadyFree</code><a class="indexterm" id="IDX-CHP-1-0204"/></p></td><td style="text-align: left" valign="top"><p>Caller attempted to free a block that was already freed.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.CannotFreeMemory</code><a class="indexterm" id="IDX-CHP-1-0205"/></p></td><td style="text-align: left" valign="top"><p>Memory free operation failure.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.PointerNotInHeap</code><a class="indexterm" id="IDX-CHP-1-0206"/></p></td><td style="text-align: left" valign="top"><p>Caller attempted to free a block of memory that was not allocated on the heap.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.WidthTooBig</code><a class="indexterm" id="IDX-CHP-1-0207"/></p></td><td style="text-align: left" valign="top"><p>Format width for numeric to string conversion was too large.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.FractionTooBig</code><a class="indexterm" id="IDX-CHP-1-0208"/></p></td><td style="text-align: left" valign="top"><p>Format size for fractional portion in floating-point-to-string conversion was too large.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.ArrayShapeViolation</code><a class="indexterm" id="IDX-CHP-1-0209"/></p></td><td style="text-align: left" valign="top"><p>Attempted operation on two arrays whose dimensions don't match.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.ArrayBounds</code><a class="indexterm" id="IDX-CHP-1-0210"/></p></td><td style="text-align: left" valign="top"><p>Attempted to access an element of an array, but the index was out of bounds.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.InvalidDate</code><a class="indexterm" id="IDX-CHP-1-0211"/></p></td><td style="text-align: left" valign="top"><p>Attempted date operation with an illegal date.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.InvalidDateFormat</code><a class="indexterm" id="IDX-CHP-1-0212"/></p></td><td style="text-align: left" valign="top"><p>Conversion from string to date contains illegal characters.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.TimeOverflow</code><a class="indexterm" id="IDX-CHP-1-0213"/></p></td><td style="text-align: left" valign="top"><p>Overflow during time arithmetic.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.InvalidTime</code><a class="indexterm" id="IDX-CHP-1-0214"/></p></td><td style="text-align: left" valign="top"><p>Attempted time operation with an illegal time.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.InvalidTimeFormat</code><a class="indexterm" id="IDX-CHP-1-0215"/></p></td><td style="text-align: left" valign="top"><p>Conversion from string to time contains illegal characters.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.SocketError</code><a class="indexterm" id="IDX-CHP-1-0216"/></p></td><td style="text-align: left" valign="top"><p>Network communication failure.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.ThreadError</code><a class="indexterm" id="IDX-CHP-1-0217"/></p></td><td style="text-align: left" valign="top"><p>Generic thread (multitasking) error.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.AssertionFailed</code><a class="indexterm" id="IDX-CHP-1-0218"/></p></td><td style="text-align: left" valign="top"><p><code class="literal">assert</code> statement encountered a failed assertion.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.ExecutedAbstract</code><a class="indexterm" id="IDX-CHP-1-0219"/></p></td><td style="text-align: left" valign="top"><p>Attempt to execute an abstract class method.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.AccessViolation</code><a class="indexterm" id="IDX-CHP-1-0220"/></p></td><td style="text-align: left" valign="top"><p>Attempt to access an illegal memory location.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.InPageError</code><a class="indexterm" id="IDX-CHP-1-0221"/></p></td><td style="text-align: left" valign="top"><p>OS memory access error.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.NoMemory</code><a class="indexterm" id="IDX-CHP-1-0222"/></p></td><td style="text-align: left" valign="top"><p>OS memory failure.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.InvalidHandle</code><a class="indexterm" id="IDX-CHP-1-0223"/></p></td><td style="text-align: left" valign="top"><p>Bad handle passed to OS API call.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.ControlC</code><a class="indexterm" id="IDX-CHP-1-0224"/></p></td><td style="text-align: left" valign="top"><p><span class="keycap"><strong>ctrl</strong></span>-C was pressed on system console (functionality is OS specific).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.Breakpoint</code><a class="indexterm" id="IDX-CHP-1-0225"/></p></td><td style="text-align: left" valign="top"><p>Program executed a breakpoint instruction (INT 3).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.SingleStep</code><a class="indexterm" id="IDX-CHP-1-0226"/></p></td><td style="text-align: left" valign="top"><p>Program is operating with the trace flag set.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.PrivInstr</code><a class="indexterm" id="IDX-CHP-1-0227"/></p></td><td style="text-align: left" valign="top"><p>Program attempted to execute a kernel-only instruction.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.IllegalInstr</code><a class="indexterm" id="IDX-CHP-1-0228"/></p></td><td style="text-align: left" valign="top"><p>Program attempted to execute an illegal machine instruction.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.BoundInstr</code><a class="indexterm" id="IDX-CHP-1-0229"/></p></td><td style="text-align: left" valign="top"><p>Bound instruction execution with "out of bounds" value.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.IntoInstr</code><a class="indexterm" id="IDX-CHP-1-0230"/></p></td><td style="text-align: left" valign="top"><p>Into instruction execution with the overflow flag set.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.DivideError</code><a class="indexterm" id="IDX-CHP-1-0231"/></p></td><td style="text-align: left" valign="top"><p>Program attempted division by zero or other divide error.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.fDenormal</code><a class="indexterm" id="IDX-CHP-1-0232"/></p></td><td style="text-align: left" valign="top"><p>Floating point exception (see <a class="xref" href="ch06.html" title="Chapter 6. ARITHMETIC">Chapter 6</a>).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.fDivByZero</code><a class="indexterm" id="IDX-CHP-1-0233"/></p></td><td style="text-align: left" valign="top"><p>Floating point exception (see <a class="xref" href="ch06.html" title="Chapter 6. ARITHMETIC">Chapter 6</a>).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.fInexactResult</code><a class="indexterm" id="IDX-CHP-1-0234"/></p></td><td style="text-align: left" valign="top"><p>Floating point exception (see <a class="xref" href="ch06.html" title="Chapter 6. ARITHMETIC">Chapter 6</a>).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.fInvalidOperation</code><a class="indexterm" id="IDX-CHP-1-0235"/></p></td><td style="text-align: left" valign="top"><p>Floating point exception (see <a class="xref" href="ch06.html" title="Chapter 6. ARITHMETIC">Chapter 6</a>).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.fOverflow</code><a class="indexterm" id="IDX-CHP-1-0236"/></p></td><td style="text-align: left" valign="top"><p>Floating point exception (see <a class="xref" href="ch06.html" title="Chapter 6. ARITHMETIC">Chapter 6</a>).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.fStackCheck</code><a class="indexterm" id="IDX-CHP-1-0237"/></p></td><td style="text-align: left" valign="top"><p>Floating point exception (see <a class="xref" href="ch06.html" title="Chapter 6. ARITHMETIC">Chapter 6</a>).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.fUnderflow</code><a class="indexterm" id="IDX-CHP-1-0238"/></p></td><td style="text-align: left" valign="top"><p>Floating point exception (see <a class="xref" href="ch06.html" title="Chapter 6. ARITHMETIC">Chapter 6</a>).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ex.InvalidHandle</code></p></td><td style="text-align: left" valign="top"><p>OS reported an invalid handle for some operation.</p></td></tr></tbody></table></div></div><p>Most of these exceptions occur in situations that are well beyond the scope of this chapter. Their appearance here is strictly for completeness. See the HLA reference manual, the HLA Standard Library documentation, and the HLA Standard Library source code for more details concerning these exceptions. The <code class="literal">ex.ConversionError</code><span class="emphasis"><em>,</em></span> <code class="literal">ex.ValueOutOfRange</code>, and <code class="literal">ex.StringOverflow</code> exceptions are the ones you'll most commonly use.</p><p>We'll return to the discussion of the <code class="literal">try..endtry</code> statement in <a class="xref" href="ch01s11.html" title="1.11 Additional Details About try..endtry">1.11 Additional Details About try..endtry</a>. First, however, we need to cover a little more material.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-9" id="ftn.CHP-1-FN-9">9</a>] </sup>There are a few additional forms that we'll cover in <a class="xref" href="ch06.html" title="Chapter 6. ARITHMETIC">Chapter 6</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-10" id="ftn.CHP-1-FN-10">10</a>] </sup>An experienced programmer may wonder why this code uses a boolean variable rather than a <code class="literal">breakif</code> statement to exit the <code class="literal">repeat..until</code> loop. There are some technical reasons for this that you will learn about in <a class="xref" href="ch01s11.html" title="1.11 Additional Details About try..endtry">1.11 Additional Details About try..endtry</a>.</p></div></div></div>
<div class="sect1" title="1.10 Introduction to the HLA Standard Library"><div class="titlepage"><div><div><h1 class="title"><a id="introduction_to_the_hla_standard_library"/>1.10 Introduction to the HLA Standard Library</h1></div></div></div><p>There are two reasons HLA is much easier to learn and use than standard assembly language. The first reason is HLA's high-level syntax for declarations and control structures. This leverages your high-level language knowledge, allowing you to learn assembly language more efficiently. The other half of the equation is the HLA Standard Library. The HLA Standard Library provides many common, easy-to-use, assembly language routines that you can call without having to write this code yourself (and, more importantly, having to learn how to write yourself). This eliminates one of the larger stumbling blocks many people have when learning assembly language: the need for sophisticated I/O and support code in order to write basic statements. Prior to the advent of a standardized assembly language library, it often took considerable study before a new assembly language programmer could do as much as print a string to the display. With the HLA Standard Library, this roadblock is removed, and you can concentrate on learning assembly language concepts rather than learning low-level I/O details that are specific to a given operating system.<a class="indexterm" id="IDX-CHP-1-0239"/><a class="indexterm" id="IDX-CHP-1-0240"/><a class="indexterm" id="IDX-CHP-1-0241"/></p><p>A wide variety of library routines is only part of HLA's support. After all, assembly language libraries have been around for quite some time.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-11" id="CHP-1-FN-11">11</a>]</sup> HLA's Standard Library complements HLA by providing a high-level language interface to these routines. Indeed, the HLA language itself was originally designed specifically to allow the creation of a high-level set of library routines. This high-level interface, combined with the high-level nature of many of the routines in the library, packs a surprising amount of power in an easy-to-use package.</p><p>The HLA Standard Library consists of several modules organized by category. <a class="xref" href="ch01s10.html#hla_standard_library_modules" title="Table 1-5. HLA Standard Library Modules">Table 1-5</a> lists many of the modules that are available.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-12" id="CHP-1-FN-12">12</a>]</sup></p><div class="table"><a id="hla_standard_library_modules"/><p class="title">Table 1-5. HLA Standard Library Modules</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="HLA Standard Library Modules"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Name</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">args</code></p></td><td style="text-align: left" valign="top"><p>Command-line parameter-parsing support routines.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">arrays</code></p></td><td style="text-align: left" valign="top"><p>Array declarations and operations.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">bits</code></p></td><td style="text-align: left" valign="top"><p>Bit-manipulation functions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">blobs</code></p></td><td style="text-align: left" valign="top"><p>Binary large objects—operations on large blocks of binary data.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">bsd</code></p></td><td style="text-align: left" valign="top"><p>OS API calls for FreeBSD (HLA FreeBSD version only).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">chars</code></p></td><td style="text-align: left" valign="top"><p>Operations on character data.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">console</code></p></td><td style="text-align: left" valign="top"><p>Portable console (text screen) operations (cursor movement, screen clears, etc.).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">conv</code></p></td><td style="text-align: left" valign="top"><p>Various conversions between strings and other values.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">coroutines</code></p></td><td style="text-align: left" valign="top"><p>Support for coroutines ("cooperative multitasking").</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">cset</code></p></td><td style="text-align: left" valign="top"><p>Character set functions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">DateTime</code></p></td><td style="text-align: left" valign="top"><p>Calendar, date, and time functions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">env</code><a class="indexterm" id="IDX-CHP-1-0242"/><a class="indexterm" id="IDX-CHP-1-0243"/><a class="indexterm" id="IDX-CHP-1-0244"/></p></td><td style="text-align: left" valign="top"><p>Access to OS environment variables.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">excepts</code></p></td><td style="text-align: left" valign="top"><p>Exception-handling routines.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fileclass</code></p></td><td style="text-align: left" valign="top"><p>Object-oriented file input and output.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fileio</code></p></td><td style="text-align: left" valign="top"><p>File input and output routines.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">filesys</code></p></td><td style="text-align: left" valign="top"><p>Access to the OS file system.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">hla</code></p></td><td style="text-align: left" valign="top"><p>Special HLA constants and other values.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Linux</code></p></td><td style="text-align: left" valign="top"><p>Linux system calls (HLA Linux version only).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">lists</code></p></td><td style="text-align: left" valign="top"><p>An HLA class for manipulating linked lists.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">mac</code></p></td><td style="text-align: left" valign="top"><p>OS API calls for Mac OS X (HLA Mac OS X version only).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">math</code></p></td><td style="text-align: left" valign="top"><p>Extended-precision arithmetic, transcendental functions, and other mathematical functions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">memmap</code></p></td><td style="text-align: left" valign="top"><p>Memory-mapped file operations.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">memory</code></p></td><td style="text-align: left" valign="top"><p>Memory allocation, deallocation, and support code.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">patterns</code></p></td><td style="text-align: left" valign="top"><p>The HLA pattern-matching library.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">random</code></p></td><td style="text-align: left" valign="top"><p>Pseudo-random number generators and support code.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sockets</code></p></td><td style="text-align: left" valign="top"><p>A set of network communication functions and classes.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">stderr</code></p></td><td style="text-align: left" valign="top"><p>Provides user output and several other support functions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">stdin</code></p></td><td style="text-align: left" valign="top"><p>User input routines.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">stdio</code></p></td><td style="text-align: left" valign="top"><p>A support module for stderr, stdin, and stdout.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">stdout</code></p></td><td style="text-align: left" valign="top"><p>Provides user output and several other support routines.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">strings</code></p></td><td style="text-align: left" valign="top"><p>HLA's powerful string library.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">tables</code></p></td><td style="text-align: left" valign="top"><p>Table (associative array) support routines.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">threads</code></p></td><td style="text-align: left" valign="top"><p>Support for multithreaded applications and process synchronization.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">timers</code></p></td><td style="text-align: left" valign="top"><p>Support for timing events in an application.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">win32</code></p></td><td style="text-align: left" valign="top"><p>Constants used in Windows calls (HLA Windows version only).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">x86</code></p></td><td style="text-align: left" valign="top"><p>Constants and other items specific to the 80x86 CPU.</p></td></tr></tbody></table></div></div><p>Later sections of this text will explain many of these modules in greater detail. This section will concentrate on the most important routines (at least to beginning HLA programmers), the <code class="literal">stdio</code> library.</p><div class="sect2" title="1.10.1 Predefined Constants in the stdio Module"><div class="titlepage"><div><div><h2 class="title"><a id="predefined_constants_in_the_stdio_module"/>1.10.1 Predefined Constants in the stdio Module</h2></div></div></div><p>Perhaps the first place to start is with a description of some common constants that the <code class="literal">stdio</code> module defines for you. Consider the following (typical) example:</p><a id="I_programlisting1_d1e4140"/><pre class="programlisting">stdout.put( "Hello World", nl );</pre><p>The <code class="literal">nl</code> appearing at the end of this statement stands for <span class="emphasis"><em>newline</em></span>. The <code class="literal">nl</code> identifier is not a special HLA reserved word, nor is it specific to the <code class="literal">stdout.put</code> statement. Instead, it's simply a predefined constant that corresponds to the string containing the standard end-of-line sequence (a carriage return/line feed pair under Windows or just a line feed under Linux, FreeBSD, and Mac OS X).<a class="indexterm" id="IDX-CHP-1-0245"/></p><p>In addition to the <code class="literal">nl</code> constant, the HLA standard I/O library module defines several other useful character constants, as listed in <a class="xref" href="ch01s10.html#character_constants_defined_by_the_hla_s" title="Table 1-6. Character Constants Defined by the HLA Standard I/O Library">Table 1-6</a>.</p><div class="table"><a id="character_constants_defined_by_the_hla_s"/><p class="title">Table 1-6. Character Constants Defined by the HLA Standard I/O Library</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Character Constants Defined by the HLA Standard I/O Library"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Character</p></th><th style="text-align: left" valign="bottom"><p>Definition</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">stdio.bell</code><a class="indexterm" id="IDX-CHP-1-0246"/></p></td><td style="text-align: left" valign="top"><p>The ASCII bell character; beeps the speaker when printed<a class="indexterm" id="IDX-CHP-1-0247"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">stdio.bs</code><a class="indexterm" id="IDX-CHP-1-0248"/></p></td><td style="text-align: left" valign="top"><p>The ASCII backspace character<a class="indexterm" id="IDX-CHP-1-0249"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">stdio.tab</code><a class="indexterm" id="IDX-CHP-1-0250"/></p></td><td style="text-align: left" valign="top"><p>The ASCII tab character<a class="indexterm" id="IDX-CHP-1-0251"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">stdio.lf</code><a class="indexterm" id="IDX-CHP-1-0252"/></p></td><td style="text-align: left" valign="top"><p>The ASCII linefeed character<a class="indexterm" id="IDX-CHP-1-0253"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">stdio.cr</code><a class="indexterm" id="IDX-CHP-1-0254"/></p></td><td style="text-align: left" valign="top"><p>The ASCII carriage return character<a class="indexterm" id="IDX-CHP-1-0255"/></p></td></tr></tbody></table></div></div><p>Except for <code class="literal">nl</code>, these characters appear in the <code class="literal">stdio</code> namespace<sup>[<a class="footnote" href="#ftn.CHP-1-FN-13" id="CHP-1-FN-13">13</a>]</sup> (and therefore require the <code class="literal">stdio</code>. prefix). The placement of these ASCII constants within the <code class="literal">stdio</code> namespace helps avoid naming conflicts with your own variables. The <code class="literal">nl</code> name does not appear within a namespace because you will use it very often, and typing <code class="literal">stdio.nl</code> would get tiresome very quickly.</p></div><div class="sect2" title="1.10.2 Standard In and Standard Out"><div class="titlepage"><div><div><h2 class="title"><a id="standard_in_and_standard_out"/>1.10.2 Standard In and Standard Out</h2></div></div></div><p>Many of the HLA I/O routines have a <code class="literal">stdin</code> or <code class="literal">stdout</code> prefix. Technically, this means that the standard library defines these names in a namespace. In practice, this prefix suggests where the input is coming from (the standard input device) or going to (the standard output device). By default, the standard input device is the system keyboard. Likewise, the default standard output device is the console display. So, in general, statements that have <code class="literal">stdin</code> or <code class="literal">stdout</code> prefixes will read and write data on the console device.<a class="indexterm" id="IDX-CHP-1-0256"/><a class="indexterm" id="IDX-CHP-1-0257"/></p><p>When you run a program from the command-line window (or shell), you have the option of <span class="emphasis"><em>redirecting</em></span> the standard input and/or standard output devices. A command-line parameter of the form <code class="literal">&gt;outfile</code> redirects the standard output device to the specified file (outfile). A command-line parameter of the form <code class="literal">&lt;infile</code> redirects the standard input so that its data comes from the specified input file (infile). The following examples demonstrate how to use these parameters when running a program named <span class="emphasis"><em>testpgm</em></span> in the command window:<sup>[<a class="footnote" href="#ftn.CHP-1-FN-14" id="CHP-1-FN-14">14</a>]</sup></p><a id="I_programlisting1_d1e4334"/><pre class="programlisting">testpgm &lt;input.data
                    testpgm &gt;output.txt
                    testpgm &lt;in.txt &gt;output.txt</pre></div><div class="sect2" title="1.10.3 The stdout.newln Routine"><div class="titlepage"><div><div><h2 class="title"><a id="the_stdout.newln_routine"/>1.10.3 The stdout.newln Routine</h2></div></div></div><p>The <code class="literal">stdout.newln</code> procedure prints a newline sequence to the standard output device. This is functionally equivalent to saying <code class="literal">stdout.put( nl );</code>. The call to <code class="literal">stdout.newln</code> is sometimes a little more convenient. For example:<a class="indexterm" id="IDX-CHP-1-0258"/><a class="indexterm" id="IDX-CHP-1-0259"/><a class="indexterm" id="IDX-CHP-1-0260"/><a class="indexterm" id="IDX-CHP-1-0261"/><a class="indexterm" id="IDX-CHP-1-0262"/><a class="indexterm" id="IDX-CHP-1-0263"/><a class="indexterm" id="IDX-CHP-1-0264"/><a class="indexterm" id="IDX-CHP-1-0265"/><a class="indexterm" id="IDX-CHP-1-0266"/></p><a id="I_programlisting1_d1e4386"/><pre class="programlisting">stdout.newln();</pre></div><div class="sect2" title="1.10.4 The stdout.putiX Routines"><div class="titlepage"><div><div><h2 class="title"><a id="the_stdout.putix_routines"/>1.10.4 The stdout.putiX Routines</h2></div></div></div><p>The <code class="literal">stdout.puti8</code>, <code class="literal">stdout.puti16</code>, and <code class="literal">stdout.puti32</code> library routines print a single parameter (one byte, two bytes, or four bytes, respectively) as a signed integer value. The parameter may be a constant, a register, or a memory variable, as long as the size of the actual parameter is the same as the size of the formal parameter.<a class="indexterm" id="IDX-CHP-1-0267"/><a class="indexterm" id="IDX-CHP-1-0268"/><a class="indexterm" id="IDX-CHP-1-0269"/></p><p>These routines print the value of their specified parameter to the standard output device. These routines will print the value using the minimum number of print positions possible. If the number is negative, these routines will print a leading minus sign. Here are some examples of calls to these routines:</p><a id="I_programlisting1_d1e4419"/><pre class="programlisting">stdout.puti8( 123 );
                    stdout.puti16( dx );
                    stdout.puti32( i32Var );</pre></div><div class="sect2" title="1.10.5 The stdout.putiXSize Routines"><div class="titlepage"><div><div><h2 class="title"><a id="the_stdout.putixsize_routines"/>1.10.5 The stdout.putiXSize Routines</h2></div></div></div><p>The <code class="literal">stdout.puti8Size</code>, <code class="literal">stdout.puti16Size</code>, and <code class="literal">stdout.puti32Size</code> routines output signed integer values to the standard output, just like the <code class="literal">stdout.puti</code><em class="replaceable"><code>X</code></em> routines. These routines, however, provide more control over the output; they let you specify the (minimum) number of print positions the value will require on output. These routines also let you specify a padding character should the print field be larger than the minimum needed to display the value. These routines require the following parameters:<a class="indexterm" id="IDX-CHP-1-0270"/><a class="indexterm" id="IDX-CHP-1-0271"/><a class="indexterm" id="IDX-CHP-1-0272"/></p><a id="I_programlisting1_d1e4456"/><pre class="programlisting">stdout.puti8Size( <em class="replaceable"><code>Value8</code></em>, <em class="replaceable"><code>width</code></em>, <em class="replaceable"><code>padchar</code></em> );
                    stdout.puti16Size( <em class="replaceable"><code>Value16</code></em>, <em class="replaceable"><code>width</code></em>, <em class="replaceable"><code>padchar</code></em> );
                    stdout.puti32Size( <em class="replaceable"><code>Value32</code></em>, <em class="replaceable"><code>width</code></em>, <em class="replaceable"><code>padchar</code></em> );</pre><p>The <em class="replaceable"><code>Value*</code></em> parameter can be a constant, a register, or a memory location of the specified size. The <em class="replaceable"><code>width</code></em> parameter can be any signed integer constant that is between −256 and +256; this parameter may be a constant, register (32-bit), or memory location (32-bit). The <em class="replaceable"><code>padchar</code></em> parameter should be a single-character value.</p><p>Like the <code class="literal">stdout.puti</code><em class="replaceable"><code>X</code></em> routines, these routines print the specified value as a signed integer constant to the standard output device. These routines, however, let you specify the <span class="emphasis"><em>field width</em></span> for the value. The field width is the minimum number of print positions these routines will use when printing the value. The <code class="literal">width</code> parameter specifies the minimum field width. If the number would require more print positions (e.g., if you attempt to print <code class="literal">1234</code> with a field width of 2), then these routines will print however many characters are necessary to properly display the value. On the other hand, if the <em class="replaceable"><code>width</code></em> parameter is greater than the number of character positions required to display the value, then these routines will print some extra padding characters to ensure that the output has at least <em class="replaceable"><code>width</code></em> character positions. If the <em class="replaceable"><code>width</code></em> value is negative, the number is left justified in the print field; if the <em class="replaceable"><code>width</code></em> value is positive, the number is right justified in the print field.</p><p>If the absolute value of the <em class="replaceable"><code>width</code></em> parameter is greater than the minimum number of print positions, then these <code class="literal">stdout.puti</code><em class="replaceable"><code>X</code></em><code class="literal">Size</code> routines will print a padding character before or after the number. The <em class="replaceable"><code>padchar</code></em> parameter specifies which character these routines will print. Most of the time you would specify a space as the pad character; for special cases, you might specify some other character. Remember, the <em class="replaceable"><code>padchar</code></em> parameter is a character value; in HLA character constants are surrounded by apostrophes, not quotation marks. You may also specify an 8-bit register as this parameter.</p><p><a class="xref" href="ch01s10.html#tabular_output_demonstration_using_stdio" title="Example 1-4. Tabular output demonstration using stdio.Puti32Size">Example 1-4</a> provides a short HLA program that demonstrates the use of the <code class="literal">stdout.puti32Size</code> routine to display a list of values in tabular form.</p><div class="example"><a id="tabular_output_demonstration_using_stdio"/><p class="title">Example 1-4. Tabular output demonstration using <code class="literal">stdio.Puti32Size</code></p><div class="example-contents"><pre class="programlisting">program NumsInColumns;

#include( "stdlib.hhf" )

var
    i32:    int32;
    ColCnt: int8;

begin NumsInColumns;

    mov( 96, i32 );
    mov( 0, ColCnt );
    while( i32 &gt; 0 ) do

        if( ColCnt = 8 ) then

            stdout.newln();
            mov( 0, ColCnt );

        endif;
        stdout.puti32Size( i32, 5, ' ' );
        sub( 1, i32 );
        add( 1, ColCnt );

    endwhile;
    stdout.newln();

end NumsInColumns;</pre></div></div></div><div class="sect2" title="1.10.6 The stdout.put Routine"><div class="titlepage"><div><div><h2 class="title"><a id="the_stdout.put_routine"/>1.10.6 The stdout.put Routine</h2></div></div></div><p>The <code class="literal">stdout.put</code> routine<sup>[<a class="footnote" href="#ftn.CHP-1-FN-15" id="CHP-1-FN-15">15</a>]</sup> is the one of the most flexible output routines in the standard output library module. It combines most of the other output routines into a single, easy-to-use procedure.<a class="indexterm" id="IDX-CHP-1-0273"/></p><p>The generic form for the <code class="literal">stdout.put</code> routine is the following:</p><a id="I_programlisting1_d1e4584"/><pre class="programlisting">stdout.put( <em class="replaceable"><code>list_of_values_to_output</code></em> );</pre><p>The <code class="literal">stdout.put</code> parameter list consists of one or more constants, registers, or memory variables, each separated by a comma. This routine displays the value associated with each parameter appearing in the list. Because we've already been using this routine throughout this chapter, you've already seen many examples of this routine's basic form. It is worth pointing out that this routine has several additional features not apparent in the examples appearing in this chapter. In particular, each parameter can take one of the following two forms:</p><a id="I_programlisting1_d1e4594"/><pre class="programlisting"><em class="replaceable"><code>value</code></em>
<em class="replaceable"><code>value</code></em>:<em class="replaceable"><code>width</code></em></pre><p>The <em class="replaceable"><code>value</code></em> may be any legal constant, register, or memory variable object. In this chapter, you've seen string constants and memory variables appearing in the <code class="literal">stdout.put</code> parameter list. These parameters correspond to the first form above. The second parameter form above lets you specify a minimum field width, similar to the <code class="literal">stdout.puti</code><em class="replaceable"><code>X</code></em><code class="literal">Size</code> routines.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-16" id="CHP-1-FN-16">16</a>]</sup> The program in <a class="xref" href="ch01s10.html#demonstration_of_the_stdout.put_field_wi" title="Example 1-5. Demonstration of the stdout.put field width specification">Example 1-5</a> produces the same output as the program in <a class="xref" href="ch01s10.html#tabular_output_demonstration_using_stdio" title="Example 1-4. Tabular output demonstration using stdio.Puti32Size">Example 1-4</a>; however, <a class="xref" href="ch01s10.html#demonstration_of_the_stdout.put_field_wi" title="Example 1-5. Demonstration of the stdout.put field width specification">Example 1-5</a> uses <code class="literal">stdout.put</code> rather than <code class="literal">stdout.puti32Size</code>.</p><div class="example"><a id="demonstration_of_the_stdout.put_field_wi"/><p class="title">Example 1-5. Demonstration of the <code class="literal">stdout.put</code> field width specification</p><div class="example-contents"><pre class="programlisting">program NumsInColumns2;

#include( "stdlib.hhf" )

var
    i32:    int32;
    ColCnt: int8;

begin NumsInColumns2;

    mov( 96, i32 );
    mov( 0, ColCnt );
    while( i32 &gt; 0 ) do

        if( ColCnt = 8 ) then

            stdout.newln();
            mov( 0, ColCnt );

        endif;
        stdout.put( i32:5 );
        sub( 1, i32 );
        add( 1, ColCnt );

    endwhile;
    stdout.put( nl );

end NumsInColumns2;</pre></div></div><p>The <code class="literal">stdout.put</code> routine is capable of much more than the few attributes this section describes. This text will introduce those additional capabilities as appropriate.</p></div><div class="sect2" title="1.10.7 The stdin.getc Routine"><div class="titlepage"><div><div><h2 class="title"><a id="the_stdin.getc_routine"/>1.10.7 The stdin.getc Routine</h2></div></div></div><p>The <code class="literal">stdin.getc</code> routine reads the next available character from the standard input device's input buffer.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-17" id="CHP-1-FN-17">17</a>]</sup> It returns this character in the CPU's AL register. The program in <a class="xref" href="ch01s10.html#demonstration_of_the_stdin.getc_open_par" title="Example 1-6. Demonstration of the stdin.getc() routine">Example 1-6</a> demonstrates a simple use of this routine.<a class="indexterm" id="IDX-CHP-1-0274"/></p><div class="example"><a id="demonstration_of_the_stdin.getc_open_par"/><p class="title">Example 1-6. Demonstration of the <code class="literal">stdin.getc()</code> routine</p><div class="example-contents"><pre class="programlisting">program charInput;

#include( "stdlib.hhf" )

var
    counter: int32;

begin charInput;

    // The following repeats as long as the user
    // confirms the repetition.

    repeat

        // Print out 14 values.

        mov( 14, counter );
        while( counter &gt; 0 ) do

            stdout.put( counter:3 );
            sub( 1, counter );

        endwhile;

        // Wait until the user enters 'y' or 'n'.

        stdout.put( nl, nl, "Do you wish to see it again? (y/n):" );
        forever

            stdin.readLn();
            stdin.getc();
            breakif( al = 'n' );
            breakif( al = 'y' );
            stdout.put( "Error, please enter only 'y' or 'n': " );

        endfor;
        stdout.newln();

    until( al = 'n' );

end charInput;</pre></div></div><p>This program uses the <code class="literal">stdin.ReadLn</code> routine to force a new line of input from the user. A description of <code class="literal">stdin.ReadLn</code> appears in <a class="xref" href="ch01s10.html#the_stdin.readln_and_stdin.flushinput_ro" title="1.10.9 The stdin.readLn and stdin.flushInput Routines">1.10.9 The stdin.readLn and stdin.flushInput Routines</a>.</p></div><div class="sect2" title="1.10.8 The stdin.geti X Routines"><div class="titlepage"><div><div><h2 class="title"><a id="the_stdin.geti_x_routines"/>1.10.8 The stdin.geti X Routines</h2></div></div></div><p>The <code class="literal">stdin.geti8</code>, <code class="literal">stdin.geti16</code>, and <code class="literal">stdin.geti32</code> routines read 8-, 16-, and 32-bit signed integer values from the standard input device. These routines return their values in the AL, AX, or EAX register, respectively. They provide the standard mechanism for reading signed integer values from the user in HLA.<a class="indexterm" id="IDX-CHP-1-0275"/><a class="indexterm" id="IDX-CHP-1-0276"/></p><p>Like the <code class="literal">stdin.getc</code> routine, these routines read a sequence of characters from the standard input buffer. They begin by skipping over any whitespace characters (spaces, tabs, and so on) and then convert the following stream of decimal digits (with an optional leading minus sign) into the corresponding integer. These routines raise an exception (that you can trap with the <code class="literal">try..endtry</code> statement) if the input sequence is not a valid integer string or if the user input is too large to fit in the specified integer size. Note that values read by <code class="literal">stdin.geti8</code> must be in the range −128..+127; values read by <code class="literal">stdin.geti16</code> must be in the range −32,768..+32,767; and values read by <code class="literal">stdin.geti32</code> must be in the range −2,147,483,648..+2,147,483,647.</p><p>The sample program in <a class="xref" href="ch01s10.html#stdin.getix_example_code" title="Example 1-7. stdin.getiX example code">Example 1-7</a> demonstrates the use of these routines.</p><div class="example"><a id="stdin.getix_example_code"/><p class="title">Example 1-7. <code class="literal">stdin.getiX</code> example code</p><div class="example-contents"><pre class="programlisting">program intInput;

#include( "stdlib.hhf" )

var
    i8:     int8;
    i16:    int16;
    i32:    int32;

begin intInput;

    // Read integers of varying sizes from the user:

    stdout.put( "Enter a small integer between −128 and +127: " );
    stdin.geti8();
    mov( al, i8 );

    stdout.put( "Enter a small integer between −32768 and +32767: " );
    stdin.geti16();
    mov( ax, i16 );

    stdout.put( "Enter an integer between +/− 2 billion: " );
    stdin.geti32();
    mov( eax, i32 );

    // Display the input values.

    stdout.put
    (
        nl,
        "Here are the numbers you entered:", nl, nl,
        "Eight-bit integer: ", i8:12, nl,
        "16-bit integer:    ", i16:12, nl,
        "32-bit integer:    ", i32:12, nl
    );



end intInput;</pre></div></div><p>You should compile and run this program and then test what happens when you enter a value that is out of range or enter an illegal string of characters.<a class="indexterm" id="IDX-CHP-1-0277"/><a class="indexterm" id="IDX-CHP-1-0278"/></p></div><div class="sect2" title="1.10.9 The stdin.readLn and stdin.flushInput Routines"><div class="titlepage"><div><div><h2 class="title"><a id="the_stdin.readln_and_stdin.flushinput_ro"/>1.10.9 The stdin.readLn and stdin.flushInput Routines</h2></div></div></div><p>Whenever you call an input routine like <code class="literal">stdin.getc</code> or <code class="literal">stdin.geti32</code>, the program does not necessarily read the value from the user at that moment. Instead, the HLA Standard Library buffers the input by reading a whole line of text from the user. Calls to input routines will fetch data from this input buffer until the buffer is empty. While this buffering scheme is efficient and convenient, sometimes it can be confusing. Consider the following code sequence:</p><a id="I_programlisting1_d1e4770"/><pre class="programlisting">stdout.put( "Enter a small integer between −128 and +127: " );
stdin.geti8();
mov( al, i8 );

stdout.put( "Enter a small integer between −32768 and +32767: " );
stdin.geti16();
mov( ax, i16 );</pre><p>Intuitively, you would expect the program to print the first prompt message, wait for user input, print the second prompt message, and wait for the second user input. However, this isn't exactly what happens. For example, if you run this code (from the sample program in the previous section) and enter the text <strong class="userinput"><code>123 456</code></strong> in response to the first prompt, the program will not stop for additional user input at the second prompt. Instead, it will read the second integer (456) from the input buffer read during the execution of the <code class="literal">stdin.geti16</code> call.<a class="indexterm" id="IDX-CHP-1-0279"/></p><p>In general, the <code class="literal">stdin</code> routines read text from the user only when the input buffer is empty. As long as the input buffer contains additional characters, the input routines will attempt to read their data from the buffer. You can take advantage of this behavior by writing code sequences such as the following:</p><a id="I_programlisting1_d1e4790"/><pre class="programlisting">stdout.put( "Enter two integer values: " );
stdin.geti32();
mov( eax, intval );
stdin.geti32();
mov( eax, AnotherIntVal );</pre><p>This sequence allows the user to enter both values on the same line (separated by one or more whitespace characters), thus preserving space on the screen. So the input buffer behavior is desirable every now and then. The buffered behavior of the input routines can be counterintuitive at other times.</p><p>Fortunately, the HLA Standard Library provides two routines, <code class="literal">stdin.readLn</code> and <code class="literal">stdin.flushInput</code>, that let you control the standard input buffer. The <code class="literal">stdin.readLn</code> routine discards everything that is in the input buffer and immediately requires the user to enter a new line of text. The <code class="literal">stdin.flushInput</code> routine simply discards everything that is in the buffer. The next time an input routine executes, the system will require a new line of input from the user. You would typically call <code class="literal">stdin.readLn</code> immediately before some standard input routine; you would normally call <code class="literal">stdin.flushInput</code> immediately after a call to a standard input routine.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If you are calling <code class="literal">stdin.readLn</code> and you find that you are having to input your data twice, this is a good indication that you should be calling <code class="literal">stdin.flushInput</code> rather than <code class="literal">stdin.readLn</code>. In general, you should always be able to call <code class="literal">stdin.flushInput</code> to flush the input buffer and read a new line of data on the next input call. The <code class="literal">stdin.readLn</code> routine is rarely necessary, so you should use <code class="literal">stdin.flushInput</code> unless you really need to immediately force the input of a new line of text.</p></div></div><div class="sect2" title="1.10.10 The stdin.get Routine"><div class="titlepage"><div><div><h2 class="title"><a id="the_stdin.get_routine"/>1.10.10 The stdin.get Routine</h2></div></div></div><p>The <code class="literal">stdin.get</code> routine combines many of the standard input routines into a single call, just as the <code class="literal">stdout.put</code> combines all of the output routines into a single call. Actually, <code class="literal">stdin.get</code> is a bit easier to use than <code class="literal">stdout.put</code> because the only parameters to this routine are a list of variable names.</p><p>Let's rewrite the example given in the previous section:<a class="indexterm" id="IDX-CHP-1-0280"/><a class="indexterm" id="IDX-CHP-1-0281"/><a class="indexterm" id="IDX-CHP-1-0282"/></p><a id="I_programlisting1_d1e4869"/><pre class="programlisting">stdout.put( "Enter two integer values: " );
stdin.geti32();
mov( eax, intval );
stdin.geti32();
mov( eax, AnotherIntVal );</pre><p>Using the <code class="literal">stdin.get</code> routine, we could rewrite this code as:</p><a id="I_programlisting1_d1e4876"/><pre class="programlisting">stdout.put( "Enter two integer values: " );
stdin.get( intval, AnotherIntVal );</pre><p>As you can see, the <code class="literal">stdin.get</code> routine is a little more convenient to use.</p><p>Note that <code class="literal">stdin.get</code> stores the input values directly into the memory variables you specify in the parameter list; it does not return the values in a register unless you actually specify a register as a parameter. The <code class="literal">stdin.get</code> parameters must all be variables or registers.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-11" id="ftn.CHP-1-FN-11">11</a>] </sup>For example, see the UCR Standard Library for 80x86 Assembly Language Programmers.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-12" id="ftn.CHP-1-FN-12">12</a>] </sup>Because the HLA Standard Library is expanding, this list is probably out of date. See the HLA documentation for a current list of Standard Library modules.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-13" id="ftn.CHP-1-FN-13">13</a>] </sup>Namespaces are the subject of <a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-14" id="ftn.CHP-1-FN-14">14</a>] </sup>For Linux, FreeBSD, and Mac OS X users, depending on how your system is set up, you may need to type <code class="literal">./</code> in front of the program's name to actually execute the program (e.g., <code class="literal">./testpgm &lt;input.data)</code>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-15" id="ftn.CHP-1-FN-15">15</a>] </sup><code class="literal">stdout.put</code> is actually a macro, not a procedure. The distinction between the two is beyond the scope of this chapter. <a class="xref" href="ch09.html" title="Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE">Chapter 9</a> describes their differences.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-16" id="ftn.CHP-1-FN-16">16</a>] </sup>Note that you cannot specify a padding character when using the <code class="literal">stdout.put</code> routine; the padding character defaults to the space character. If you need to use a different padding character, call the <code class="literal">stdout.puti</code><em class="replaceable"><code>X</code></em><code class="literal">Size</code> routines.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-17" id="ftn.CHP-1-FN-17">17</a>] </sup><span class="emphasis"><em>Buffer</em></span> is just a fancy term for an array.</p></div></div></div>
<div class="sect1" title="1.11 Additional Details About try..endtry"><div class="titlepage"><div><div><h1 class="title"><a id="additional_details_about_try..endtry"/>1.11 Additional Details About try..endtry</h1></div></div></div><p>As you may recall, the <code class="literal">try..endtry</code> statement surrounds a block of statements in order to capture any exceptions that occur during the execution of those statements. The system raises exceptions in one of three ways: through a hardware fault (such as a divide-by-zero error), through an operating system-generated exception, or through the execution of the HLA <code class="literal">raise</code> statement. You can write an exception handler to intercept specific exceptions using the <code class="literal">exception</code> clause. The program in <a class="xref" href="ch01s11.html#try..endtry_example" title="Example 1-8. try..endtry example">Example 1-8</a> provides a typical example of the use of this statement.<a class="indexterm" id="IDX-CHP-1-0283"/></p><div class="example"><a id="try..endtry_example"/><p class="title">Example 1-8. <code class="literal">try..endtry</code> example</p><div class="example-contents"><pre class="programlisting">program testBadInput;
#include( "stdlib.hhf" )

static
    u:      int32;


begin testBadInput;

    try

        stdout.put( "Enter a signed integer:" );
        stdin.get( u );
        stdout.put( "You entered: ", u, nl );

      exception( ex.ConversionError )

        stdout.put( "Your input contained illegal characters" nl );

      exception( ex.ValueOutOfRange )

        stdout.put( "The value was too large" nl );

    endtry;


end testBadInput;</pre></div></div><p>HLA refers to the statements between the <code class="literal">try</code> clause and the first <code class="literal">exception</code> clause as the <span class="emphasis"><em>protected</em></span> statements. If an exception occurs within the protected statements, then the program will scan through each of the exceptions and compare the value of the current exception against the value in the parentheses after each of the <code class="literal">exception</code> clauses.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-18" id="CHP-1-FN-18">18</a>]</sup> This exception value is simply a 32-bit value. The value in the parentheses after each <code class="literal">exception</code> clause, therefore, must be a 32-bit value. The HLA <span class="emphasis"><em>excepts.hhf</em></span> header file predefines several exception constants. Although it would be an incredibly bad style violation, you could substitute the numeric values for the two <code class="literal">exception</code> clauses above.<a class="indexterm" id="IDX-CHP-1-0284"/><a class="indexterm" id="IDX-CHP-1-0285"/><a class="indexterm" id="IDX-CHP-1-0286"/><a class="indexterm" id="IDX-CHP-1-0287"/></p><div class="sect2" title="1.11.1 Nesting try..endtry Statements"><div class="titlepage"><div><div><h2 class="title"><a id="nesting_try..endtry_statements"/>1.11.1 Nesting try..endtry Statements</h2></div></div></div><p>If the program scans through all the <code class="literal">exception</code> clauses in a <code class="literal">try..endtry</code> statement and does not match the current exception value, then the program searches through the <code class="literal">exception</code> clauses of a <span class="emphasis"><em>dynamically nested</em></span> <code class="literal">try..endtry</code> block in an attempt to find an appropriate exception handler. For example, consider the code in <a class="xref" href="ch01s11.html#nested_try..endtry_statements" title="Example 1-9. Nested try..endtry statements">Example 1-9</a>.</p><div class="example"><a id="nested_try..endtry_statements"/><p class="title">Example 1-9. Nested <code class="literal">try..endtry</code> statements</p><div class="example-contents"><pre class="programlisting">program testBadInput2;
#include( "stdlib.hhf" )

static
    u:      int32;

begin testBadInput2;

    try

        try

            stdout.put( "Enter a signed integer: " );
            stdin.get( u );
            stdout.put( "You entered: ", u, nl );

          exception( ex.ConversionError )

            stdout.put( "Your input contained illegal characters" nl );

        endtry;

        stdout.put( "Input did not fail due to a value out of range" nl );


      exception( ex.ValueOutOfRange )

        stdout.put( "The value was too large" nl );

    endtry;

end testBadInput2;</pre></div></div><p>In <a class="xref" href="ch01s11.html#nested_try..endtry_statements" title="Example 1-9. Nested try..endtry statements">Example 1-9</a> one <code class="literal">try</code> statement is nested inside another. During the execution of the <code class="literal">stdin.get</code> statement, if the user enters a value greater than four billion and some change, then <code class="literal">stdin.get</code> will raise the <code class="literal">ex.ValueOutOfRange</code> exception. When the HLA runtime system receives this exception, it first searches through all the exception clauses in the <code class="literal">try..endtry</code> statement immediately surrounding the statement that raised the exception (this would be the nested <code class="literal">try..endtry</code> in the example above). If the HLA runtime system fails to locate an exception handler for <code class="literal">ex.ValueOutOfRange</code>, then it checks to see if the current <code class="literal">try..endtry</code> is nested inside another <code class="literal">try..endtry</code> (as is the case in <a class="xref" href="ch01s11.html#nested_try..endtry_statements" title="Example 1-9. Nested try..endtry statements">Example 1-9</a>). If so, the HLA runtime system searches for the appropriate exception clause in the outer <code class="literal">try..endtry</code> statement. Within the <code class="literal">try..endtry</code> block appearing in <a class="xref" href="ch01s11.html#nested_try..endtry_statements" title="Example 1-9. Nested try..endtry statements">Example 1-9</a> the program finds an appropriate exception handler, so control transfers to the statements after the <code class="literal">exception( ex.ValueOutOfRange )</code> clause.<a class="indexterm" id="IDX-CHP-1-0288"/></p><p>After leaving a <code class="literal">try..endtry</code> block, the HLA runtime system no longer considers that block active and will not search through its list of exceptions when the program raises an exception.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-19" id="CHP-1-FN-19">19</a>]</sup> This allows you to handle the same exception differently in other parts of the program.</p><p>If two <code class="literal">try..endtry</code> statements handle the same exception, and one of the <code class="literal">try..endtry</code> blocks is nested inside the protected section of the other <code class="literal">try..endtry</code> statement, and the program raises an exception while executing in the innermost <code class="literal">try..endtry</code> sequence, then HLA transfers control directly to the exception handler provided by the innermost <code class="literal">try..endtry</code> block. HLA does not automatically transfer control to the exception handler provided by the outer <code class="literal">try..endtry</code> sequence.</p><p>In the previous example (<a class="xref" href="ch01s11.html#nested_try..endtry_statements" title="Example 1-9. Nested try..endtry statements">Example 1-9</a>) the second <code class="literal">try..endtry</code> statement was statically nested inside the enclosing <code class="literal">try..endtry</code> statement.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-20" id="CHP-1-FN-20">20</a>]</sup> As mentioned without comment earlier, if the most recently activated <code class="literal">try..endtry</code> statement does not handle a specific exception, the program will search through the <code class="literal">exception</code> clauses of any dynamically nesting <code class="literal">try..endtry</code> blocks. Dynamic nesting does not require the nested <code class="literal">try..endtry</code> block to physically appear within the enclosing <code class="literal">try..endtry</code> statement. Instead, control could transfer from inside the enclosing <code class="literal">try..endtry</code> protected block to some other point in the program. Execution of a <code class="literal">try..endtry</code> statement at that other point dynamically nests the two <code class="literal">try</code> statements. Although there are many ways to dynamically nest code, there is one method you are probably familiar with from your high-level language experience: the procedure call. In <a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a>, when you learn how to write procedures (functions) in assembly language, you should keep in mind that any call to a procedure within the protected section of a <code class="literal">try..endtry</code> block can create a dynamically nested <code class="literal">try..endtry</code> if the program executes a <code class="literal">try..endtry</code> within that procedure.<a class="indexterm" id="IDX-CHP-1-0289"/></p></div><div class="sect2" title="1.11.2 The unprotected Clause in a try..endtry Statement"><div class="titlepage"><div><div><h2 class="title"><a id="the_unprotected_clause_in_a_try..endtry"/>1.11.2 The unprotected Clause in a try..endtry Statement</h2></div></div></div><p>Whenever a program executes the <code class="literal">try</code> clause, it preserves the current exception environment and sets up the system to transfer control to the <code class="literal">exception</code> clauses within that <code class="literal">try..endtry</code> statement should an exception occur. If the program successfully completes the execution of a <code class="literal">try..endtry</code> protected block, the program restores the original exception environment and control transfers to the first statement beyond the <code class="literal">endtry</code> clause. This last step, restoring the execution environment, is very important. If the program skips this step, any future exceptions will transfer control to this <code class="literal">try..endtry</code> statement even though the program has already left the <code class="literal">try..endtry</code> block. <a class="xref" href="ch01s11.html#improperly_exiting_a_try..endtry_stateme" title="Example 1-10. Improperly exiting a try..endtry statement">Example 1-10</a> demonstrates this problem.</p><div class="example"><a id="improperly_exiting_a_try..endtry_stateme"/><p class="title">Example 1-10. Improperly exiting a <code class="literal">try..endtry</code> statement</p><div class="example-contents"><pre class="programlisting">program testBadInput3;
#include( "stdlib.hhf" )

static
    input:  int32;

begin testBadInput3;

    // This forever loop repeats until the user enters
    // a good integer and the break statement below
    // exits the loop.

    forever

        try

            stdout.put( "Enter an integer value: " );
            stdin.get( input );
            stdout.put( "The first input value was: ", input, nl );
            break;

          exception( ex.ValueOutOfRange )

            stdout.put( "The value was too large, re-enter." nl );

          exception( ex.ConversionError )

            stdout.put( "The input contained illegal characters, re-enter." nl );

        endtry;

    endfor;

    // Note that the following code is outside the loop and there
    // is no try..endtry statement protecting this code.

    stdout.put( "Enter another number: " );
    stdin.get( input );
    stdout.put( "The new number is: ", input, nl );

end testBadInput3;</pre></div></div><p>This example attempts to create a robust input system by putting a loop around the <code class="literal">try..endtry</code> statement and forcing the user to reenter the data if the <code class="literal">stdin.get</code> routine raises an exception (because of bad input data). While this is a good idea, there is a big problem with this implementation: the <code class="literal">break</code> statement immediately exits the <code class="literal">forever..endfor</code> loop without first restoring the exception environment. Therefore, when the program executes the second <code class="literal">stdin.get</code> statement, at the bottom of the program, the HLA exception-handling code still thinks that it's inside the <code class="literal">try..endtry</code> block. If an exception occurs, HLA transfers control back into the <code class="literal">try..endtry</code> statement looking for an appropriate exception handler. Assuming the exception was <code class="literal">ex.ValueOutOfRange</code> or <code class="literal">ex.ConversionError</code>, the program in <a class="xref" href="ch01s11.html#improperly_exiting_a_try..endtry_stateme" title="Example 1-10. Improperly exiting a try..endtry statement">Example 1-10</a> will print an appropriate error message <span class="emphasis"><em>and then force the user to re-enter the first value</em></span>. This isn't desirable.<a class="indexterm" id="IDX-CHP-1-0290"/><a class="indexterm" id="IDX-CHP-1-0291"/><a class="indexterm" id="IDX-CHP-1-0292"/><a class="indexterm" id="IDX-CHP-1-0293"/></p><p>Transferring control to the wrong <code class="literal">try..endtry</code> exception handlers is only part of the problem. Another big problem with the code in <a class="xref" href="ch01s11.html#improperly_exiting_a_try..endtry_stateme" title="Example 1-10. Improperly exiting a try..endtry statement">Example 1-10</a> has to do with the way HLA preserves and restores the exception environment: specifically, HLA saves the old execution environment information in a special region of memory known as the <span class="emphasis"><em>stack</em></span>. If you exit a <code class="literal">try..endtry</code> without restoring the exception environment, this leaves the old execution environment information on the stack, and this extra data on could cause your program to malfunction.</p><p>Although this discussion makes it quite clear that a program should not exit from a <code class="literal">try..endtry</code> statement in the manner that <a class="xref" href="ch01s11.html#improperly_exiting_a_try..endtry_stateme" title="Example 1-10. Improperly exiting a try..endtry statement">Example 1-10</a> uses, it would be nice if you could use a loop around a <code class="literal">try..endtry</code> block to force the reentry of bad data as this program attempts to do. To allow for this, HLA's <code class="literal">try..endtry</code> statement provides an <code class="literal">unprotected</code> section. Consider the code in <a class="xref" href="ch01s11.html#the_try..endtry_unprotected_section" title="Example 1-11. The try..endtry unprotected section">Example 1-11</a>.</p><div class="example"><a id="the_try..endtry_unprotected_section"/><p class="title">Example 1-11. The <code class="literal">try..endtry</code> unprotected section</p><div class="example-contents"><pre class="programlisting">program testBadInput4;
#include( "stdlib.hhf" )

static
    input:  int32;

begin testBadInput4;

    // This forever loop repeats until the user enters
    // a good integer and the break statement below
    // exits the loop. Note that the break statement
    // appears in an unprotected section of the try..endtry
    // statement.

    forever

        try

            stdout.put( "Enter an integer value: " );
            stdin.get( input );
            stdout.put( "The first input value was: ", input, nl );

          unprotected

            break;

          exception( ex.ValueOutOfRange )

            stdout.put( "The value was too large, re-enter." nl );

          exception( ex.ConversionError )

            stdout.put( "The input contained illegal characters, re-enter." nl );

        endtry;

    endfor;

    // Note that the following code is outside the loop and there
    // is no try..endtry statement protecting this code.

    stdout.put( "Enter another number: " );
    stdin.get( input );
    stdout.put( "The new number is: ", input, nl );

end testBadInput4;</pre></div></div><p>Whenever the <code class="literal">try..endtry</code> statement hits the <code class="literal">unprotected</code> clause, it immediately restores the exception environment. As the phrase suggests, the execution of statements in the <code class="literal">unprotected</code> section is no longer protected by that <code class="literal">try..endtry</code> block (note, however, that any dynamically nesting <code class="literal">try..endtry</code> statements will still be active; <code class="literal">unprotected</code> turns off only the exception handling of the <code class="literal">try..endtry</code> statement containing the <code class="literal">unprotected</code> clause). Because the <code class="literal">break</code> statement in <a class="xref" href="ch01s11.html#the_try..endtry_unprotected_section" title="Example 1-11. The try..endtry unprotected section">Example 1-11</a> appears inside the <code class="literal">unprotected</code> section, it can safely transfer control out of the <code class="literal">try..endtry</code> block without "executing" the <code class="literal">endtry</code> because the program has already restored the former exception environment.</p><p>Note that the <code class="literal">unprotected</code> keyword must appear in the <code class="literal">try..endtry</code> statement immediately after the <code class="literal">protected</code> block. That is, it must precede all <code class="literal">exception</code> keywords.<a class="indexterm" id="IDX-CHP-1-0294"/><a class="indexterm" id="IDX-CHP-1-0295"/></p><p>If an exception occurs during the execution of a <code class="literal">try..endtry</code> sequence, HLA automatically restores the execution environment. Therefore, you may execute a <code class="literal">break</code> statement (or any other instruction that transfers control out of the <code class="literal">try..endtry</code> block) within an <code class="literal">exception</code> clause.</p><p>Because the program restores the exception environment upon encountering an <code class="literal">unprotected</code> block or an <code class="literal">exception</code> block, an exception that occurs within one of these areas immediately transfers control to the previous (dynamically nesting) active <code class="literal">try..endtry</code> sequence. If there is no nesting <code class="literal">try..endtry</code> sequence, the program aborts with an appropriate error message.</p></div><div class="sect2" title="1.11.3 The anyexception Clause in a try..endtry Statement"><div class="titlepage"><div><div><h2 class="title"><a id="the_anyexception_clause_in_a_try..endtry"/>1.11.3 The anyexception Clause in a try..endtry Statement</h2></div></div></div><p>In a typical situation, you will use a <code class="literal">try..endtry</code> statement with a set of <code class="literal">exception</code> clauses that will handle all possible exceptions that can occur in the protected section of the <code class="literal">try..endtry</code> sequence. Often, it is important to ensure that a <code class="literal">try..endtry</code> statement handles all possible exceptions to prevent the program from prematurely aborting due to an unhandled exception. If you have written all the code in the protected section, you will know the exceptions it can raise, so you can handle all possible exceptions. However, if you are calling a library routine (especially a third-party library routine), making a OS API call, or otherwise executing code that you have no control over, it may not be possible for you to anticipate all possible exceptions this code could raise (especially when considering past, present, and future versions of the code). If that code raises an exception for which you do not have an <code class="literal">exception</code> clause, this could cause your program to fail. Fortunately, HLA's <code class="literal">try..endtry</code> statement provides the <code class="literal">anyexception</code> clause that will automatically trap any exception the existing <code class="literal">exception</code> clauses do not handle.</p><p>The <code class="literal">anyexception</code> clause is similar to the <code class="literal">exception</code> clause except it does not require an exception number parameter (because it handles any exception). If the <code class="literal">anyexception</code> clause appears in a <code class="literal">try..endtry</code> statement with other <code class="literal">exception</code> sections, the <code class="literal">anyexception</code> section must be the last exception handler in the <code class="literal">try..endtry</code> statement. An <code class="literal">anyexception</code> section may be the only exception handler in a <code class="literal">try..endtry</code> statement.</p><p>If an otherwise unhandled exception transfers control to an <code class="literal">anyexception</code> section, the EAX register will contain the exception number. Your code in the <code class="literal">anyexception</code> block can test this value to determine the cause of the exception.</p></div><div class="sect2" title="1.11.4 Registers and the try..endtry Statement"><div class="titlepage"><div><div><h2 class="title"><a id="registers_and_the_try..endtry_statement"/>1.11.4 Registers and the try..endtry Statement</h2></div></div></div><p>The <code class="literal">try..endtry</code> statement preserves several bytes of data whenever you enter a <code class="literal">try..endtry</code> statement. Upon leaving the <code class="literal">try..endtry</code> block (or hitting the <code class="literal">unprotected</code> clause), the program restores the exception environment. As long as no exception occurs, the <code class="literal">try..endtry</code> statement does not affect the values of any registers upon entry to or upon exit from the <code class="literal">try..endtry</code> statement. However, this claim is not true if an exception occurs during the execution of the protected statements.</p><p>Upon entry into an <code class="literal">exception</code> clause, the EAX register contains the exception number, but the values of all other general-purpose registers are undefined. Because the operating system may have raised the exception in response to a hardware error (and, therefore, has played around with the registers), you can't even assume that the general-purpose registers contain whatever values they happened to contain at the point of the exception. The underlying code that HLA generates for exceptions is subject to change in different versions of the compiler, and certainly it changes across operating systems, so it is never a good idea to experimentally determine what values registers contain in an exception handler and depend on those values in your code.</p><p>Because entry into an exception handler can scramble the register values, you must ensure that you reload important registers if the code following your <code class="literal">endtry</code> clause assumes that the registers contain certain values (i.e., values set in the protected section or values set prior to executing the <code class="literal">try..endtry</code> statement). Failure to do so will introduce some nasty defects into your program (and these defects may be very intermittent and difficult to detect because exceptions rarely occur and may not always destroy the value in a particular register). The following code fragment provides a typical example of this problem and its solution:</p><a id="I_programlisting1_d1e5465"/><pre class="programlisting">static
     sum: int32;
          .
          .
          .
     mov( 0, sum );
     for( mov( 0, ebx ); ebx &lt; 8; inc( ebx )) do

          push( ebx );  // Must preserve ebx in case there is an exception.
          forever
               try

                    stdin.geti32();
                    unprotected break;

                 exception( ex.ConversionError )

                    stdout.put( "Illegal input, please re-enter value: " );

               endtry;
          endfor;
          pop( ebx );  // Restore ebx's value.
          add( ebx, eax );
          add( eax, sum );

     endfor;</pre><p>Because the HLA exception-handling mechanism messes with the registers, and because exception handling is a relatively inefficient process, you should never use the <code class="literal">try..endtry</code> statement as a generic control structure (e.g., using it to simulate a <code class="literal">switch/case</code> statement by raising an integer exception value and using the exception clauses as the cases to process). Doing so will have a very negative impact on the performance of your program and may introduce subtle defects because exceptions scramble the registers.<a class="indexterm" id="IDX-CHP-1-0296"/></p><p>For proper operation, the <code class="literal">try..endtry</code> statement assumes that you use the EBP register only to point at <span class="emphasis"><em>activation records</em></span> (<a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a> discusses activation records). By default, HLA programs automatically use EBP for this purpose; as long as you do not modify the value in EBP, your programs will automatically use EBP to maintain a pointer to the current activation record. If you attempt to use the EBP register as a general-purpose register to hold values and compute arithmetic results, HLA's exception-handling capabilities will no longer function properly (along with other possible problems). Therefore, you should never use the EBP register as a general-purpose register. Of course, this same discussion applies to the ESP register.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-18" id="ftn.CHP-1-FN-18">18</a>] </sup>Note that HLA loads this value into the EAX register. So upon entry into an <code class="literal">exception</code> clause, EAX contains the exception number.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-19" id="ftn.CHP-1-FN-19">19</a>] </sup>Unless, of course, the program re-enters the <code class="literal">try..endtry</code> block via a loop or other control structure.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-20" id="ftn.CHP-1-FN-20">20</a>] </sup><span class="emphasis"><em>Statically nested</em></span> means that one statement is physically nested within another in the source code. When we say one statement is nested within another, this typically means that the statement is statically nested within the other statement.</p></div></div></div>
<div class="sect1" title="1.12 High-Level Assembly Language vs. Low-Level Assembly Language"><div class="titlepage"><div><div><h1 class="title"><a id="high-level_assembly_language_vs._low-lev"/>1.12 High-Level Assembly Language vs. Low-Level Assembly Language</h1></div></div></div><p>Before concluding this chapter, it's important to remind you that none of the control statements appearing in this chapter are "real" assembly language. The 80x86 CPU does not support machine instructions like <code class="literal">if</code>, <code class="literal">while</code>, <code class="literal">repeat</code>, <code class="literal">for</code>, <code class="literal">break</code>, <code class="literal">breakif</code>, and <code class="literal">try</code>. Whenever HLA encounters these statements, it <span class="emphasis"><em>compiles</em></span> them into a sequence of one or more true machine instructions that do the operation as the high-level statements you've used. While these statements are convenient to use, and in many cases just as efficient as the sequence of low-level machine instructions into which HLA translates them, don't lose sight of the fact that they are not true machine instructions.</p><p>The purpose of this text is to teach you low-level assembly language programming; these high-level control structures are simply a means to that end. Remember, learning the HLA high-level control structures allows you to leverage your high-level language knowledge early on in the educational process so you don't have to learn everything about assembly language all at once. By using high-level control structures that you're already comfortable with, this text can put off the discussion of the actual machine instructions you'd normally use for control flow until much later. By doing so, this text can regulate how much material it presents, so, hopefully, you'll find learning assembly language to be much more pleasant. However, you must always remember that these high-level control statements are just a pedagogical tool to help you learn assembly language. Though you're free to use them in your assembly programs once you master the real control-flow statements, you really must learn the low-level control statements if you want to learn assembly language programming. Since, presumably, that's why you're reading this book, don't allow the high-level control structures to become a crutch. When you get to the point where you learn how to really write low-level control statements, embrace and use them (exclusively). As you gain experience with the low-level control statements and learn their advantages and disadvantages, you'll be in a good position to decide whether a high-level or low-level code sequence is most appropriate for a given application. However, until you gain considerable experience with the low-level control structures, you'll not be able to make an educated decision. Remember, you can't really call yourself an assembly language programmer unless you've mastered the low-level statements.</p><p>Another thing to keep in mind is that the HLA Standard Library functions are not part of the assembly <span class="emphasis"><em>language</em></span>. They're just some convenient functions that have been prewritten for you. Although there is nothing wrong with calling these functions, always remember that they are not machine instructions and that there is nothing special about these routines; as you gain experience writing assembly language code, you can write your own versions of each of these routines (and even write them more efficiently).</p><p>If you're learning assembly language because you want to write the most efficient programs possible (either the fastest or the smallest code), you need to understand that you won't achieve this goal completely if you're using high-level control statements and making a lot of calls to the HLA Standard Library. HLA's code generator and the HLA Standard Library aren't <span class="emphasis"><em>horribly</em></span> inefficient, but the only true way to write efficient programs in assembly language is to <span class="emphasis"><em>think</em></span> in assembly language. HLA's high-level control statements and many of the routines in the HLA Standard Library are great because they let you <span class="emphasis"><em>avoid</em></span> thinking in assembly language. While this is great while you're first learning assembly, if your ultimate goal is to write efficient code, then you have to learn to think in assembly language. This text will get you to that point (and will do so much more rapidly because it uses HLA's high-level features), but don't forget that your ultimate goal is to give up these high-level features in favor of low-level coding.</p></div>
<div class="sect1" title="1.13 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information"/>1.13 For More Information</h1></div></div></div><p>This chapter has covered a lot of ground! While you still have a lot to learn about assembly language programming, this chapter, combined with your knowledge of high-level languages, provides just enough information to let you start writing real assembly language programs.</p><p>Although this chapter has covered many different topics, the three primary topics of interest are the 80x86 CPU architecture, the syntax for simple HLA programs, and the HLA Standard Library. For additional topics on this subject, please consult the (unabridged) electronic version of this text, the HLA reference manual, and the HLA Standard Library manual. All three are available at <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> and <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a>.</p></div></body></html>