<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="825" id="Page_825"/>14</span><br/>
<span class="ChapterTitle">The String Instructions</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">A <em>string</em> is a collection of values stored in contiguous memory locations. The x86-64 CPUs can process four types of strings: byte strings, word strings, double-word strings, and quad-word strings. </p>
<p>The x86-64 microprocessor family supports several instructions specifically designed to cope with strings. They can move strings, compare strings, search for a specific value within a string, initialize a string to a fixed value, and do other primitive operations on strings. The x86-64’s string instructions are also useful for assigning and comparing arrays, tables, and records, and they may speed up your array-manipulation code considerably. This chapter explores various uses of the string instructions.</p>
<h2 id="h1-501089c14-0001"><span epub:type="pagebreak" title="826" id="Page_826"/>	14.1	The x86-64 String Instructions</h2>
<p class="BodyFirst">All members of the x86-64 family support five string instructions: <code>movs</code><var>x</var>, <code>cmps</code><var>x</var>, <code>scas</code><var>x</var>, <code>lods</code><var>x</var>, and <code>stos</code><var>x</var>.<sup class="FootnoteReference"><a id="c14-footnoteref-1" href="#c14-footnote-1">1</a></sup> (<var>x</var> = <code>b</code>, <code>w</code>, <code>d</code>, or <code>q</code> for byte, word, double word, or quad word, respectively; this book generally drops the <var>x</var> suffix when talking about these string instructions in a general sense.) Moving, comparing, scanning, loading, and storing are the primitives on which you can build most other string operations. </p>
<p>The string instructions operate on <em>blocks</em> (contiguous linear arrays) of memory. For example, the <code>movs</code> instruction moves a sequence of bytes from one memory location to another, the <code>cmps</code> instruction compares two blocks of memory, and the <code>scas</code> instruction scans a block of memory for a particular value. The source and destination blocks (and any other values an instruction needs) are not provided as explicit operands, however. Instead, the string instructions use specific registers as operands:</p>
<ul>
<li>RSI (source index) register</li>
<li>RDI (destination index) register</li>
<li>RCX (count) register</li>
<li>AL, AX, EAX, and RAX registers</li>
<li>The direction flag in the FLAGS register</li>
</ul>
<p>For example, the <code>movs</code> (<em>move string</em>) instruction copies RCX elements from the source address specified by RSI to the destination address specified by RDI. Likewise, the <code>cmps</code> instruction compares the string pointed at by RSI, of length RCX, to the string pointed at by RDI.</p>
<p>The sections that follow describe how to use these five instructions, starting with a prefix that makes the instructions do what you’d expect: repeat their operation for each value in the string pointed to by RSI.<sup class="FootnoteReference"><a id="c14-footnoteref-2" href="#c14-footnote-2">2</a></sup></p>
<h3 id="h2-501089c14-0001">14.1.1	The rep, repe, repz, and the repnz and repne Prefixes</h3>
<p class="BodyFirst">By themselves, the string instructions do not operate on strings of data. For example, the <code>movs</code> instruction will only copy a single byte, word, double word, or quad word. The repeat prefixes tell the x86-64 to do a multi-byte string operation—specifically, to repeat a string operation up to RCX times.<sup class="FootnoteReference"><a id="c14-footnoteref-3" href="#c14-footnote-3">3</a></sup></p>
<p>The syntax for the string instructions with repeat prefixes is as follows:</p>
<pre><code>rep prefix: 
     rep  movs<var>x</var><em> </em>(<var>x</var> is b, w, d, or q)
<span epub:type="pagebreak" title="827" id="Page_827"/>     rep  stos<var>x</var>

repe prefix: (Note: repz is a synonym for repe)
     repe  cmps<var>x</var> 
     repe  scas<var>x</var>

repne prefix: (Note: repnz is a synonym for repne)
     repne  cmps<var>x</var>
     repne  scas<var>x</var></code></pre>
<p>You don’t normally use the repeat prefixes with the <code>lods</code> instruction.</p>
<p>The <code>rep</code> prefix tells the CPU to “repeat this operation the number of times specified by the RCX register.” The <code>repe</code> prefix says to “repeat this operation while the comparison is equal, or up to the number of times specified by RCX (whichever condition fails first).” The <code>repne</code> prefix’s action is “repeat this operation while the comparison is not equal, or up to the number of times specified by RCX.” As it turns out, you’ll use <code>repe</code> for most character string comparisons; <code>repne</code> is used mainly with the <code>scas</code><var>x</var> instructions to locate a specific character within a string (such as a zero-terminating byte).</p>
<p>You can use repeat prefixes to process entire strings with a single instruction. You can use the string instructions, without the repeat prefix, as string primitive operations to synthesize more powerful string operations.</p>
<h3 id="h2-501089c14-0002">14.1.2	The Direction Flag</h3>
<p class="BodyFirst">The <em>direction flag</em> in the FLAGS register controls how the CPU processes strings. If the direction flag is clear, the CPU increments RSI and RDI after operating on each string element. For example, executing <code>movs</code> will move the byte, word, double word, or quad word at RSI to RDI and then increment RSI and RDI by 1, 2, 4, or 8 (respectively). When specifying the <code>rep</code> prefix before this instruction, the CPU increments RSI and RDI for each element in the string (the count in RCX specifies the number of elements). At completion, the RSI and RDI registers will be pointing at the first item beyond the strings.</p>
<p>If the direction flag is set, the x86-64 decrements RSI and RDI after it processes each string element (again, RCX specifies the number of string elements for a repeated string operation). Afterward, the RSI and RDI registers will be pointing at the first byte, word, or double word before the strings.</p>
<p>You can change the direction flag’s value by using the <code>cld</code> (<em>clear direction flag</em>) and <code>std</code> (<em>set direction flag</em>) instructions. </p>
<p>The Microsoft ABI requires that the direction flag be clear upon entry into a (Microsoft ABI–compliant) procedure. Therefore, if you set the direction flag within a procedure, you should always clear that flag when you are finished using it (and especially before calling any other code or returning from the procedure).</p>
<h3 id="h2-501089c14-0003">14.1.3	The movs Instruction</h3>
<p class="BodyFirst">The <code>movs</code> instruction uses the following syntax:</p>
<pre><code>movsb
movsw
movsd
<span epub:type="pagebreak" title="828" id="Page_828"/>movsq
rep  movsb
rep  movsw
rep  movsd
rep  movsq</code></pre>
<p>The <code>movsb</code> (<em>move string, bytes</em>) instruction fetches the byte at address RSI, stores it at address RDI, and then increments or decrements the RSI and RDI registers by 1. If the <code>rep</code> prefix is present, the CPU checks RCX to see whether it contains 0. If not, it moves the byte from RSI to RDI and decrements the RCX register. This process repeats until RCX becomes 0. If RCX contains 0 upon initial execution, the <code>movsb</code> instruction will not copy any data bytes.</p>
<p>The <code>movsw</code> (<em>move string, words</em>) instruction fetches the word at address RSI, stores it at address RDI, and then increments or decrements RSI and RDI by 2. If there is a <code>rep</code> prefix, the CPU repeats this procedure RCX times.</p>
<p>The <code>movsd</code> instruction operates in a similar fashion on double words. It increments or decrements RSI and RDI by 4 after each data movement.</p>
<p>Finally, the <code>movsq</code> instruction does the same thing on quad words. It increments or decrements RSI and RDI by 8 after each data movement.</p>
<p>For example, this code segment copies 384 bytes from <code>CharArray1</code> to <code>CharArray2</code>:</p>
<pre><code>CharArray1  byte 384 dup (?) 
CharArray2  byte 384 dup (?)
             . 
             . 
             . 
            cld
            lea  rsi, CharArray1
            lea  rdi, CharArray2
            mov  rcx, lengthof(CharArray1) ; = 384
        rep movsb</code></pre>
<p>If you substitute <code>movsw</code> for <code>movsb</code>, the preceding code will move 384 words (768 bytes) rather than 384 bytes:</p>
<pre><code>WordArray1  word 384 dup (?) 
WordArray2  word 384 dup (?)
             . 
             . 
             . 
            cld
            lea  rsi, WordArray1
            lea  rdi, WordArray2
            mov  rcx, lengthof(WordArray1) ; = 384
        rep movsw</code></pre>
<p>Remember, the RCX register contains the element count, not the byte count; fortunately, the MASM <code>lengthof</code> operator returns the number of array elements (words), not the number of bytes.</p>
<p>If you’ve set the direction flag before executing a <code>movsq</code>, <code>movsb</code>, <code>movsw</code>, or <code>movsd</code> instruction, the CPU decrements the RSI and RDI registers after moving each string element. This means that the RSI and RDI registers must <span epub:type="pagebreak" title="829" id="Page_829"/>point at the last element of their respective strings before executing a <code>movsb</code>, <code>movsw</code>, <code>movsd</code>, or <code>movsq</code> instruction. For example:</p>
<pre><code>CharArray1 byte  384 dup (?) 
CharArray2 byte  384 dup (?) 
            . 
            . 
            . 
           std
           lea rsi, CharArray1[lengthof(CharArray1) - 1] 
           lea rdi, CharArray2[lengthof(CharArray1) - 1]
           mov rcx, lengthof(CharArray1);
       rep movsb
           cld</code></pre>
<p>Although sometimes processing a string from tail to head is useful (see <span class="xref" itemid="xref_target_“Comparing Extended-Precision Integers” on page 834">“Comparing Extended-Precision Integers” on page 834</span>), generally you’ll process strings in the forward direction. For one class of string operations, being able to process strings in both directions is mandatory: moving strings when the source and destination blocks overlap. Consider what happens in the following code:</p>
<pre><code>CharArray1  byte ? 
CharArray2  byte 384 dup (?) 
             . 
             . 
             . 
            cld
            lea rsi, CharArray1
            lea rdi, CharArray2
            mov rcx, lengthof(CharArray2);
        rep movsb</code></pre>
<p>This sequence of instructions treats <code>CharArray1</code> and <code>CharArray2</code> as a pair of 384-byte strings. However, the last 383 bytes in the <code>CharArray1</code> array overlap the first 383 bytes in the <code>CharArray2</code> array. Let’s trace the operation of this code byte by byte.</p>
<p>When the CPU executes the <code>movsb</code> instruction, it does the following:</p>
<ol class="decimal">
<li value="1">Copies the byte at RSI (<code>CharArray1</code>) to the byte pointed at by RDI (<code>CharArray2</code>).</li>
<li value="2">Increments RSI and RDI, and decrements RCX by 1. Now the RSI register points at <code>CharArray1 + 1 </code>(which is the address of <code>CharArray2</code>), and the RDI register points at <code>CharArray2 + 1</code>. </li>
<li value="3">Copies the byte pointed at by RSI to the byte pointed at by RDI. However, this is the byte originally copied from location <code>CharArray1</code>. So, the <code>movsb</code> instruction copies the value originally in location <code>CharArray1</code> to both locations <code>CharArray2</code> and <code>CharArray2 + 1</code>. </li>
<li value="4">Again increments RSI and RDI, and decrements RCX.</li>
<li value="5">Copies the byte from location <code>CharArray1 + 2</code> (<code>CharArray2 + 1</code>) to location <code>CharArray2 + 2</code>. Once again, this is the value that originally appeared in location <code>CharArray1</code>. </li>
</ol>
<p><span epub:type="pagebreak" title="830" id="Page_830"/>Each repetition of the loop copies the next element in <code>CharArray1</code> to the next available location in the <code>CharArray2</code> array. Pictorially, it looks something like <a href="#figure14-1" id="figureanchor14-1">Figure 14-1</a>. The result is that the <code>movsb</code> instruction replicates <code>X</code> throughout the string.</p>
<figure>
<img src="image_fi/501089c14/f14001.png" alt="f14001" class=""/>
<figcaption><p><a id="figure14-1">Figure 14-1</a>: Copying data between two overlapping arrays (forward direction)</p></figcaption>
</figure>
<p>If you really want to move one array into another when they overlap like this, you should move each element of the source string to the destination string, starting at the end of the two strings, as shown in <a href="#figure14-2" id="figureanchor14-2">Figure 14-2</a>.</p>
<figure>
<img src="image_fi/501089c14/f14002.png" alt="f14002" class=""/>
<figcaption><p><a id="figure14-2">Figure 14-2</a>: Using a backward copy to copy data in overlapping arrays</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="831" id="Page_831"/>Setting the direction flag and pointing RSI and RDI at the end of the strings will allow you to (correctly) move one string to another when the two strings overlap and the source string begins at a lower address than the destination string. If the two strings overlap and the source string begins at a higher address than the destination string, clear the direction flag and point RSI and RDI at the beginning of the two strings.</p>
<p>If the two strings do not overlap, you can use either technique to move the strings around in memory. Generally, operating with the direction flag clear is the easiest.</p>
<p>You shouldn’t use the <code>movs</code><var>x</var> instruction to fill an array with a single byte, word, double-word, or quad-word value. Another string instruction, <code>stos</code>, is much better for this purpose.</p>
<p>If you are moving a large number of bytes from one array to another, the copy operation will be faster if you can use the <code>movsq</code> instruction rather than the <code>movsb</code> instruction. If the number of bytes you wish to move is an even multiple of 8, this is a trivial change; just divide the number of bytes to copy by 8, load this value into RCX, and then use the <code>movsq</code> instruction. If the number of bytes is not evenly divisible by 8, you can use the <code>movsq</code> instruction to copy all but the last 1, 2, . . . , 7 bytes of the array (that is, the remainder after you divide the byte count by 8). For example, if you want to efficiently move 4099 bytes, you can do so with the following instruction sequence:</p>
<pre><code>     lea  rsi, Source 
     lea  rdi, Destination 
     mov  rcx, 512     ; Copy 512 qwords = 4096 bytes
 rep movsq
     movsw             ; Copy bytes 4097 and 4098
     movsb             ; Copy the last byte</code></pre>
<p>Using this technique to copy data never requires more than four <code>movs</code><var>x</var> instructions because you can copy 1, . . . , 7 bytes with no more than one (each) of the <code>movsb</code>, <code>movsw</code>, and <code>movsd</code> instructions. The preceding scheme is most efficient if the two arrays are aligned on quad-word boundaries. If not, you might want to move the <code>movsb</code>, <code>movsw</code>, or <code>movsd</code> instruction (or all three) before or after the <code>movsq</code> instruction so that <code>movsq</code> works with quad-word–aligned data.</p>
<p>If you do not know the size of the block you are copying until the program executes, you can still use code like the following to improve the performance of a block move of bytes:</p>
<pre><code>     lea  rsi, Source
     lea  rdi, Destination
     mov  rcx, Length
     shr  rcx, 3       ; Divide by 8
     jz   lessThan8    ; Execute movsq only if 8 or more bytes

 rep movsq             ; Copy the qwords

<span epub:type="pagebreak" title="832" id="Page_832"/>lessThan8: 
     mov  rcx, Length 
     and  rcx, 111b      ; Compute (Length mod 8)
     jz   divisibleBy8   ; Execute movsb only if # of bytes/8 &lt;&gt; 0

 rep movsb             ; Copy the remaining 1 to 7 bytes

divisibleBy8: </code></pre>
<p>On many computer systems, the <code>movsq</code> instruction provides about the fastest way to copy bulk data from one location to another. While there are, arguably, faster ways to copy data on certain CPUs, ultimately the memory bus performance is the limiting factor, and the CPUs are generally much faster than the memory bus. Therefore, unless you have a special system, writing fancy code to improve memory-to-memory transfers is probably a waste of time. </p>
<p>Also, Intel has improved the performance of the <code>movs</code><var>x</var> instructions on later processors so that <code>movsb</code> operates as efficiently as <code>movsw</code>, <code>movsd</code>, and <code>movsq</code> when copying the same number of bytes. On these later processors, it may be more efficient to use <code>movsb</code> to copy the specified number of bytes rather than go through all the complexity outlined previously. </p>
<p>The bottom line is this: if the speed of a block move matters to you, try it several different ways and pick the fastest (or the simplest, if they all run the same speed, which is likely).</p>
<h3 id="h2-501089c14-0004">14.1.4	The cmps Instruction</h3>
<p class="BodyFirst">The <code>cmps</code> instruction compares two strings. The CPU compares the value referenced by RDI to the value pointed at by RSI. RCX contains the number of elements in the source string when using the <code>repe</code> or <code>repne</code> prefix to compare entire strings. Like the <code>movs</code> instruction, MASM allows several forms of this instruction:</p>
<pre><code>cmpsb
cmpsw
cmpsd
cmpsq

repe   cmpsb
repe   cmpsw
repe   cmpsd
repe   cmpsq

repne  cmpsb
repne  cmpsw
repne  cmpsd
repne  cmpsq</code></pre>
<p>Without a repeat prefix, the <code>cmps</code> instruction subtracts the value at location RDI from the value at RSI and updates the flags according to the result <span epub:type="pagebreak" title="833" id="Page_833"/>(which it discards). After comparing the two locations, <code>cmps</code> increments or decrements the RSI and RDI registers by 1, 2, 4, or 8 (for <code>cmpsb</code>, <code>cmpsw</code>, <code>cmpsd</code>, and <code>cmpsq</code>, respectively). <code>cmps</code> increments the RSI and RDI registers if the direction flag is clear and decrements them otherwise.</p>
<p>Remember, the value in the RCX register determines the number of elements to process, not the number of bytes. Therefore, when using <code>cmpsw</code>, RCX specifies the number of words to compare. Likewise, for <code>cmpsd</code> and <code>cmpsq</code>, RCX contains the number of double and quad words to process.</p>
<p>The <code>repe</code> prefix compares successive elements in a string as long as they are equal and RCX is greater than 0. The <code>repne</code> prefix does the same as long the elements are not equal.</p>
<p>After the execution of <code>repne cmps</code>, either the RCX register is 0 (in which case the two strings are totally different), or the RCX contains the number of elements compared in the two strings until a match is found. While this form of the <code>cmps</code> instruction isn’t particularly useful for comparing strings, it is useful for locating the first pair of matching items in a couple of byte, word, or double-word arrays. </p>
<h4 id="h3-501089c14-0001">14.1.4.1	Comparing Character Strings</h4>
<p class="BodyFirst">Character strings are usually compared using <em>lexicographical ordering</em>, the standard alphabetical ordering you’ve grown up with. We compare corresponding elements until encountering a character that doesn’t match or the end of the shorter string. If a pair of corresponding characters does not match, compare the two strings based on that single character. If the two strings match up to the length of the shorter string, compare their length. The two strings are equal if and only if their lengths are equal and each corresponding pair of characters in the two strings is identical. The length of a string affects the comparison only if the two strings are identical up to the length of the shorter string. For example, <code>Zebra</code> is less than <code>Zebras</code> because it is the shorter of the two strings; however, <code>Zebra</code> is greater than <code>AAAAAAAAAAH!</code> even though <code>Zebra</code> is shorter. </p>
<p>For (ASCII) character strings, use the <code>cmpsb</code> instruction in the following manner: </p>
<ol class="decimal">
<li value="1">Clear the direction flag.</li>
<li value="2">Load the RCX register with the length of the smaller string.</li>
<li value="3">Point the RSI and RDI registers at the first characters in the two strings you want to compare.</li>
<li value="4">Use the <code>repe</code> prefix with the <code>cmpsb</code> instruction to compare the strings on a byte-by-byte basis. <aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Even if the strings contain an even number of characters, you cannot use the <code>cmpsw</code> or <code>cmpsd</code> instructions, because they do not compare strings in lexicographical order. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside></li>
<li value="5">If the two strings are equal, compare their lengths. </li>
</ol>
<p><span epub:type="pagebreak" title="834" id="Page_834"/>The following code compares a couple of character strings:</p>
<pre><code>       cld
       mov  rsi, AdrsStr1
       mov  rdi, AdrsStr2
       mov  rcx, LengthSrc
       cmp  rcx, LengthDest
       jbe  srcIsShorter        ; Put the length of the 
                                ; shorter string in RCX
       mov  rcx, LengthDest 

srcIsShorter:
  repe cmpsb
       jnz   notEq              ; If equal to the length of the 
                                ; shorter string, cmp lengths
       mov   rcx, LengthSrc
       cmp   rcx, LengthDest

notEq: </code></pre>
<p>If you’re using bytes to hold the string lengths, you should adjust this code appropriately (that is, use a <code>movzx</code> instruction to load the lengths into RCX). </p>
<h4 id="h3-501089c14-0002">14.1.4.2	Comparing Extended-Precision Integers</h4>
<p class="BodyFirst">You can also use the <code>cmps</code> instruction to compare multi-word integer values (that is, extended-precision integer values). Because of the setup required for a string comparison, this isn’t practical for integer values less than six or eight double words in length, but for large integer values, it’s excellent. </p>
<p>Unlike with character strings, we cannot compare integer strings by using lexicographical ordering. When comparing strings, we compare the characters from the least significant byte to the most significant byte. When comparing integers, we must compare the values from the most significant byte, word, or double word down to the least significant. So, to compare two 32-byte (256-bit) integer values, use the following code:</p>
<pre><code>     std
     lea  rsi, SourceInteger[3 * 8]
     lea  rdi, DestInteger[3 * 8]
     mov  rcx, 4
repe cmpsq
     cld</code></pre>
<p>This code compares the integers from their most significant qword down to the least significant qword. The <code>cmpsq</code> instruction finishes when the two values are unequal or upon decrementing RCX to 0 (implying that the two values are equal). Once again, the flags provide the result of the comparison.</p>
<h3 id="h2-501089c14-0005"><span epub:type="pagebreak" title="835" id="Page_835"/>14.1.5	The scas Instruction</h3>
<p class="BodyFirst">The <code>scas</code> (<em>scan string</em>) instruction is used to search for a particular element within a string—for example, to quickly scan for a 0 throughout another string.</p>
<p>Unlike the <code>movs</code> and <code>cmps</code> instructions, <code>scas</code> requires only a destination string (pointed at by RDI). The source operand is the value in the AL (<code>scasb</code>), AX (<code>scasw</code>), EAX (<code>scasd</code>), or RAX (<code>scasq</code>) register. The <code>scas</code> instruction compares the value in the accumulator (AL, AX, EAX, or RAX) against the value pointed at by RDI and then increments (or decrements) RDI by 1, 2, 4, or 8. The CPU sets the flags according to the result of the comparison.</p>
<p>The <code>scas</code> instructions take the following forms:</p>
<pre><code>scasb
scasw
scasd
scasq

repe   scasb
repe   scasw
repe   scasd
repe   scasq

repne  scasb
repne  scasw
repne  scasd
repne  scasq</code></pre>
<p>With the <code>repe</code> prefix, <code>scas</code> scans the string, searching for an element that does not match the value in the accumulator. When using the <code>repne</code> prefix, <code>scas</code> scans the string, searching for the first element that is equal to the value in the accumulator. This is counterintuitive, because <code>repe</code> <code>scas</code> actually scans through the string while the value in the accumulator is equal to the string operand, and <code>repne</code> <code>scas</code> scans through the string while the accumulator is not equal to the string operand. </p>
<p>Like the <code>cmps</code> and <code>movs</code> instructions, the value in the RCX register specifies the number of elements, not bytes, to process when using a repeat prefix.</p>
<h3 id="h2-501089c14-0006">14.1.6	The stos Instruction</h3>
<p class="BodyFirst">The <code>stos</code> instruction stores the value in the accumulator at the location specified by RDI. After storing the value, the CPU increments or decrements RDI depending on the state of the direction flag. Although the <code>stos</code> instruction has many uses, its primary use is to initialize arrays and strings to a constant value. For example, if you have a 256-byte array that you want to clear out with 0s, use the following code:</p>
<pre><code>     cld
     lea  rdi, DestArray
     mov  rcx, 32          ; 32 quad words = 256 bytes
     xor  rax, rax         ; Zero out RAX
rep  stosq</code></pre>
<p><span epub:type="pagebreak" title="836" id="Page_836"/>This code writes 32 quad words rather than 256 bytes because a single <code>stosq</code> operation is faster (on some older CPUs) than four <code>stosb</code> operations.</p>
<p>The <code>stos</code> instructions take eight forms:</p>
<pre><code>stosb
stosw
stosd
stosq

rep  stosb
rep  stosw
rep  stosd
rep  stosq</code></pre>
<p>The <code>stosb</code> instruction stores the value in the AL register into the specified memory location(s), <code>stosw</code> stores the AX register into the specified memory location(s), <code>stosd</code> stores EAX into the specified location(s), and <code>stosq</code> stores RAX into the specified location(s). With the <code>rep</code> prefix, this process repeats the number of times specified by the RCX register.</p>
<p>If you need to initialize an array with elements that have different values, you cannot (easily) use <code>stos</code>.</p>
<h3 id="h2-501089c14-0007">14.1.7	The lods Instruction</h3>
<p class="BodyFirst">The <code>lods</code> instruction copies the byte, word, double word, or quad word pointed at by RSI into the AL, AX, EAX, or RAX register, after which it increments or decrements the RSI register by 1, 2, 4, or 8. Use <code>lods</code> to fetch bytes (<code>lodsb</code>), words (<code>lodsw</code>), double words (<code>lodsd</code>), or quad words (<code>lodsq</code>) from memory for further processing. </p>
<p>Like <code>stos</code>, the <code>lods</code> instructions take eight forms:</p>
<pre><code>lodsb
lodsw
lodsd
lodsq

rep  lodsb
rep  lodsw
rep  lodsd
rep  lodsq</code></pre>
<p>You will probably never use a repeat prefix with this instruction, because the accumulator register will be overwritten each time <code>lods</code> repeats. At the end of the repeat operation, the accumulator will contain the last value read from memory.<sup class="FootnoteReference"><a id="c14-footnoteref-4" href="#c14-footnote-4">4</a></sup> </p>
<h3 id="h2-501089c14-0008"><span epub:type="pagebreak" title="837" id="Page_837"/>14.1.8	Building Complex String Functions from lods and stos</h3>
<p class="BodyFirst">You can use the <code>lods</code> and <code>stos</code> instructions to generate any particular string operation. For example, suppose you want a string operation that converts all the uppercase characters in a string to lowercase. You could use the following code:</p>
<pre><code>     mov rsi, StringAddress  ; Load string address into RSI
     mov rdi, rsi            ; Also point RDI here
     mov rcx, stringLength   ; Presumably, this was precomputed 
     jrcxz skipUC            ; Don't do anything if length is 0
rpt:
     lodsb                   ; Get the next character in the string
     cmp   al, 'A'
     jb    notUpper
     cmp   al, 'Z'
     ja    notUpper
     or    al, 20h           ; Convert to lowercase
notUpper:
     stosb                   ; Store converted char into string
     dec   rcx
     jnz   rpt               ; Zero flag is set when RCX is 0
skipUC:</code></pre>
<p>The <code>rpt</code> loop fetches the byte at the location specified by RSI, tests whether it is an uppercase character, converts it to lowercase if it is (leaving it unchanged if it is not), stores the resulting character at the location specified by RDI, and then repeats this process the number of times specified by the value in RCX.</p>
<p>Because the <code>lods</code> and <code>stos</code> instructions use the accumulator as an intermediary location, you can use any accumulator operation to quickly manipulate string elements. This could be something as simple as a <code>toLower</code> (or <code>toUpper</code>) function or as complex as data encryption. You might even use this instruction sequence to compute a hash, checksum, or CRC value while moving data from one string to another. Any operation you would do on a string on a character-by-character basis while moving the string data around is a candidate.</p>
<h2 id="h1-501089c14-0002">	14.2	Performance of the x86-64 String Instructions</h2>
<p class="BodyFirst">In the early x86-64 processors, the string instructions provided the most efficient way to manipulate strings and blocks of data. However, these instructions are not part of Intel’s RISC Core instruction set and can be slower (though more compact) than if you did the same operations with discrete instructions. Intel has optimized <code>movs</code> and <code>stos</code> on later processors so that they operate as rapidly as possible, but the other string instructions can be fairly slow. </p>
<p>As always, it’s a good idea to implement performance-critical algorithms by using different algorithms (with and without the string instructions) and comparing their performance to determine which solution to use. Because <span epub:type="pagebreak" title="838" id="Page_838"/>the string instructions run at different speeds relative to other instructions depending on which processor you’re using, try your experiments on the processors where you expect your code to run. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	On most processors, the <code>movs</code> instruction is faster than the corresponding discrete instructions. Intel has worked hard to keep <code>movs</code> optimized because so much performance-critical code uses it.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501089c14-0003">	14.3	SIMD String Instructions</h2>
<p class="BodyFirst">The SSE4.2 instruction set extensions include four powerful instructions for manipulating character strings. These instructions were first introduced in 2008, so some computers in use today still might not support them. Always use <code>cpuid</code> to determine if these instructions are available before attempting to use them in wide-distribution commercial applications (see <span class="xref" itemid="xref_target_“Using cpuid to Differentiate Instruction Sets” in Chapter 11">“Using cpuid to Differentiate Instruction Sets” in Chapter 11</span>).</p>
<p>The four SSE4.2 instructions that process text and string fragments are as follows:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>PCMPESTRI</code></span> </span>  Packed compare explicit-length strings, return index</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>PCMPESTRM</code></span> </span>  Packed compare explicit-length strings, return mask</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>PCMPISTRI</code></span></span>  	Packed compare implicit-length strings, return index</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>PCMPISTRM</code></span> </span>  Packed compare implicit-length strings, return mask</li>
</ol>
<p><em>Implicit-length strings</em> use a sentinel (trailing) byte to mark the end of the string, specifically, a zero-terminating byte (or word, in the case of Unicode characters). <em>Explicit-length strings</em> are those for which you supply a string length.</p>
<p>Instructions that produce an index return the index of the first (or last) matching occurrence within the source string. Instructions that return a bit mask return an array of 0 or (all) 1 bits that mark each occurrence of the match within the two input strings.</p>
<p>The packed compare string instructions are among the most complex in the x86-64 instruction set. The syntax for these instructions is</p>
<pre><code>pcmp<var>X</var>str<var>Y</var>  <var>xmm</var><sub>src1</sub>, <var>xmm</var><sub>src2</sub>/<var>mem</var><sub>src2</sub>, <var>imm</var><sub>8</sub>
vpcmp<var>X</var>str<var>Y</var> <var>xmm</var><sub>src1</sub>, <var>xmm</var><sub>src2</sub>/<var>mem</var><sub>src2</sub>, <var>imm</var><sub>8</sub></code></pre>
<p class="BodyContinued">where <var>X</var> is <code>E</code> or <code>I</code>, and <var>Y</var> is <code>I</code> or <code>M</code>. Both forms use 128-bit operands (no 256-bit YMM registers for the <code>v</code>-prefixed form in this case), and, unlike most SSE instructions, the <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instructions allow memory operands that are not aligned on a 16-byte boundary (they would be nearly useless for their intended operation if they required 16-byte-aligned memory operands).</p>
<p>The <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instructions compare corresponding bytes or words in a pair of XMM registers, combine the results of the individual comparisons into a vector (bit mask), and return the results for all the comparisons. The <var>imm</var><sub>8</sub> operand controls various comparison attributes as described in <span class="xref" itemid="xref_target_“Type of Comparison” on the following page">“Type of Comparison” on the following page</span>.</p>
<h3 id="h2-501089c14-0009"><span epub:type="pagebreak" title="839" id="Page_839"/>14.3.1	Packed Compare Operand Sizes</h3>
<p class="BodyFirst">Bits 0 and 1 of the immediate operand specify the size and type of the string elements. The elements can be bytes or words, or they can be treated as unsigned or signed values for the comparison (see <a href="#table14-1" id="tableanchor14-1">Table 14-1</a>).</p>
<p>Bit 0 specifies word (Unicode) or byte (ASCII) operands. Bit 1 specifies whether the operands are signed or unsigned. Generally, for character strings, you use unsigned comparisons. However, in certain situations (or when processing strings of integers rather than characters), you may want to specify signed comparisons.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table14-1">Table 14-1</a>: Packed Compare <var>imm</var><sub>8</sub> Bits 0 and 1</p></figcaption>
<table id="table-501089c14-0001" border="1">
<thead>
<tr>
<td><b>Bit(s)</b></td>
<td><b>Bit value</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0–1</td>
<td>00</td>
<td>Both source operands contain 16 unsigned bytes.</td>
</tr>
<tr>
<td/>
<td>01</td>
<td>Both source operands contain 8 unsigned words.</td>
</tr>
<tr>
<td/>
<td>10</td>
<td>Both source operands contain 16 signed bytes.</td>
</tr>
<tr>
<td/>
<td>11</td>
<td>Both source operands contain 8 signed words.</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="h2-501089c14-0010">14.3.2	Type of Comparison</h3>
<p class="BodyFirst">Bits 2 and 3 of the immediate operand specify how the instruction will compare the two strings. There are four comparison types, which test characters from one string against the set of characters in the second, test characters from one string against a range of characters, do a straight string comparison, or search for a substring within another string (see <a href="#table14-2" id="tableanchor14-2">Table 14-2</a>).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table14-2">Table 14-2</a>: Packed Compare <var>imm</var><sub>8</sub> Bits 2 and 3</p></figcaption>
<table id="table-501089c14-0002" border="1">
<thead>
<tr>
<td><b>Bit(s)</b></td>
<td><b>Bit value</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>2–3</td>
<td>00</td>
<td>Equal any: compares each character in the second source string against a set of characters appearing in the first source operand.</td>
</tr>
<tr>
<td/>
<td>01</td>
<td>Ranges: compares each value in the second source operand against a set of ranges specified by the first source operand.</td>
</tr>
<tr>
<td/>
<td>10</td>
<td>Equal each: compares each corresponding element for equality (character-by-character comparison of the two operands).</td>
</tr>
<tr>
<td/>
<td>11</td>
<td>Equal ordered: searches for the substring specified by the first operand within the string specified by the second operand.</td>
</tr>
</tbody>
</table>
</figure>
<p>Bits 2 to 3 specify the type of comparison to perform (the <em>aggregate operation</em> in Intel terminology). <em>Equal each</em> (10b) is probably the easiest comparison to understand. The packed compare instruction will compare each corresponding character in the string (up to the length of the string—more on that later) and set a Boolean flag for the result of the comparison of each byte or word in the string, as shown in <a href="#figure14-3" id="figureanchor14-3">Figure 14-3</a>. This is comparable to the operation of the C/C++ <code>memcmp()</code> or <code>strcmp()</code> functions.</p>
<span epub:type="pagebreak" title="840" id="Page_840"/><figure>
<img src="image_fi/501089c14/f14003.png" alt="f14003" class=""/>
<figcaption><p><a id="figure14-3">Figure 14-3</a>: Equal each aggregate comparison operation</p></figcaption>
</figure>
<p>The <em>equal any</em> comparison compares each byte in the second source operand to see whether it is any of the characters found in the first source operand (XMM<sub>src2</sub>/mem<sub>src2</sub>). For example, if XMM<sub>src1</sub> contains the string <code>abcdefABCDEF</code> (and four 0 bytes), and XMM<sub>src2</sub>/mem<sub>src2</sub> contains <code>12AF89C0</code>, the resulting comparison would yield 00101100b (1s in the character positions corresponding to the A, F, and C characters). Also note that the first character (1) maps to bit 0, and the A and F characters map to bits 2 and 3. This is similar to the <code>strspn()</code> and <code>strcspn()</code> functions in the C Standard Library.</p>
<p>The <em>equal ordered</em> comparison searches for each occurrence of the string in XMM<sub>src1 </sub>that can be found in the XMM<sub>src2</sub>/mem<sub>src2</sub> operand. For example, if the XMM<sub>src2</sub>/mem<sub>src2</sub> operand contains the string <code>never need shine</code> and the XMM<sub>src1 </sub>operand has the string <code>ne</code> (padded with 0s), then the equal ordered comparison produces the vector 0100000001000001b. This is similar to the <code>strstr()</code> function in the C Standard Library.</p>
<p>The <em>ranges</em> comparison aggregate operation breaks the entries in the XMM<sub>src1</sub> operand into pairs (at even and odd indexes in the register). The first element (byte or word) specifies a lower bound, and the second entry specifies an upper bound. The XMM<sub>src1</sub> register supports up to eight byte ranges or four word ranges (if you need fewer ranges, pad the remaining pairs with 0s). This aggregate operation compares each character in the XMM<sub>src2</sub>/mem<sub>src2</sub> operand against each of these ranges and stores true in the resultant vector if the character is within one of the specified ranges (inclusive) and false if it is outside all of these ranges.</p>
<h3 id="h2-501089c14-0011">14.3.3	Result Polarity</h3>
<p class="BodyFirst">Bits 4 and 5 of the immediate operand specify the result polarity (see <a href="#table14-3" id="tableanchor14-3">Table 14-3</a>). This chapter will fully discuss the meaning of these bits in a moment (some additional commentary is necessary).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table14-3">Table 14-3</a>: Packed Compare <var>imm</var><sub>8</sub> Bits 4 and 5</p></figcaption>
<table id="table-501089c14-0003" border="1">
<thead>
<tr>
<td><b>Bit(s)</b></td>
<td><b>Bit value</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>4–5</td>
<td>00</td>
<td>Positive polarity</td>
</tr>
<tr>
<td/>
<td>01</td>
<td>Negative polarity</td>
</tr>
<tr>
<td/>
<td>10</td>
<td>Positive masked</td>
</tr>
<tr>
<td/>
<td>11</td>
<td>Negative masked</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="h2-501089c14-0012"><span epub:type="pagebreak" title="841" id="Page_841"/>14.3.4	Output Processing</h3>
<p class="BodyFirst">Bit 6 of the immediate operand specifies the instruction result (see <a href="#table14-4" id="tableanchor14-4">Table 14-4</a>). The packed compare instructions do not use bit 7; it should always be 0.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table14-4">Table 14-4</a>: Packed Compare <var>imm</var><sub>8</sub> Bit 6 (and 7)</p></figcaption>
<table id="table-501089c14-0004" border="1">
<thead>
<tr>
<td><b>Bit(s)</b></td>
<td><b>Bit value</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>0</td>
<td><code>(v)pcom</code><var>X</var><code>stri</code> only, the index returned in ECX is the first result.<br/>
<code>(v)pcom</code><var>X</var><code>strm</code> only, the mask appears in the LO bits of XMM0 with zero extension to 128 bits.</td>
</tr>
<tr>
<td/>
<td>1</td>
<td><code>(v)pcom</code><var>X</var><code>stri</code> only, the index returned in ECX is the last result.<br/>
<code>(v)pcom</code><var>X</var><code>strm</code> only, expand the bit mask into a byte or word mask.</td>
</tr>
<tr>
<td>7</td>
<td>0</td>
<td>This bit is reserved and should always be 0.</td>
</tr>
</tbody>
</table>
</figure>
<p>The <code>(v)pcmpestrm</code> and <code>(v)pcmpistrm</code> instructions produce a bit-mask result and store it into the XMM0 register (this is fixed—the CPU does not determine this by the operands to these instructions). If bit 6 of the <var>imm</var><span class="SubscriptLiteral">8</span> operand contains a 0, these two instructions pack this bit mask into 8 or 16 bits and store them into the LO 8 (or 16) bits of XMM0, zero-extending that value through the upper bits of XMM0. If <var>imm</var><span class="SubscriptLiteral">8</span> bit 6 contains a 1, these instructions will store the bit mask (all 1 bits per byte or word) throughout the XMM0 register.<sup class="FootnoteReference"><a id="c14-footnoteref-5" href="#c14-footnote-5">5</a></sup> </p>
<p>The <code>(v)pcmpestri</code> and <code>(v)pcmpistri</code> instructions produce an index result and return this value in the ECX register.<sup class="FootnoteReference"><a id="c14-footnoteref-6" href="#c14-footnote-6">6</a></sup> If bit 6 of the <var>imm</var><span class="SubscriptLiteral">8</span> operand contains a 0, these two instructions return the index of the LO set bit in the result bit mask (that is, the first matching comparison). If bit 6 of the <var>imm</var><span class="SubscriptLiteral">8</span> operand is 1, these instructions return the index of the highest-order set bit in the resultant bit mask (that is, the last matching comparison). If there are no set bits in the result bit mask, these instructions return 16 (for byte comparisons) or 8 (for word comparisons) in the ECX register. Although these instructions internally generate a bit mask result in order to calculate the index, they do not overwrite the XMM0 register (as do the <code>(v)pcmpestrm</code> and <code>(v)pcmpistrm</code> instructions).</p>
<h3 id="h2-501089c14-0013">14.3.5	Packed String Compare Lengths</h3>
<p class="BodyFirst">The <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instructions have a 16-byte (XMM register size) comparison limit. This is true even on AVX processors with 32-byte YMM registers. To compare larger strings requires executing multiple <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instructions.</p>
<p>The <code>(v)pcmpistri</code> and <code>(v)pcmpistrm</code> instructions use an implicit string length. The strings appear in the XMM registers or memory with the first character (if any) appearing in the LO byte followed by the remaining <span epub:type="pagebreak" title="842" id="Page_842"/>characters in the string. The strings end with a zero-terminating byte or word. If there are more than 16 characters (if byte strings, or 8 characters if word strings), then the register (or 128-bit memory) size delimits the string. </p>
<p>The <code>(v)pcmpestri</code> and <code>(v)pcmpestrm</code> instructions use explicitly supplied string lengths. The RAX and EAX registers specify the string length for the string appearing in XMM<sub>src1</sub>, and the RDX and EDX registers specify the string length for the string appearing in XMM<sub>src2</sub>/mem<sub>src2</sub>. If the string length is greater than 16 (for byte strings) or 8 (for word strings), the instruction saturates the length at 16 or 8. Also, the <code>(v)pcmpestri</code> and <code>(v)pcmpestrm</code> instructions take the absolute value of the length, so –1 to –16 is equivalent to 1 to 16. </p>
<p>The reason the explicit-length instructions saturate the length to 16 (or 8) is to allow a program to process larger strings in a loop. By processing 16 bytes (or 8 words) at a time in a loop and decrementing the overall string length (from some large value down to 0), the packed string operations will operate on 16 or 8 characters per loop iteration until the very last loop iteration. At that point, the instructions will process the remaining (total length mod 16 or 8) characters in the string.</p>
<p>The reason the explicit-length instructions take the absolute value of the length is to allow code that processes large strings to either decrement the loop counter (from a large positive value) to 0 or increment the loop counter (from a negative value) toward 0, whichever is more convenient for the program.</p>
<p>Whenever the length (implicit or explicit) is less than 16 (for bytes) or 8 (for words), certain characters in the XMM register (or 128-bit memory location) will be invalid. Specifically, every character after the zero-terminating character (for implicit-length strings) or beyond the count in RAX and EAX or RDX and EDX will be invalid. Regardless of the presence of invalid characters, the packed compare instructions still produce an intermediate bit vector result by comparing all characters in the string. </p>
<p>Because the string lengths of the two input strings (in XMM<sub>src1</sub> and XMM<sub>src2</sub>/mem<sub>src2</sub>) are not necessarily equal, there are four possible situations: <code>src1</code> and <code>src2</code> are both invalid, exactly one of the two source operands is invalid (and the other is valid, so there are two cases here), or both are valid. Depending on which operands are valid or invalid, the packed compare instructions may force the result to true or false. <a href="#table14-5" id="tableanchor14-5">Table 14-5</a> lists how these instructions force results, based on the type of comparison (aggregate operation) specified by the <var>imm</var><span class="SubscriptLiteral">8</span> operand.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table14-5">Table 14-5</a>: Comparison Result When Source 1 and Source 2 Are Valid or Invalid</p></figcaption>
<table id="table-501089c14-0005" border="1">
<thead>
<tr>
<td><b>Src1</b></td>
<td><b>Src2</b></td>
<td><b>Equal any</b></td>
<td><b>Ranges</b></td>
<td><b>Equal each</b></td>
<td><b>Equal ordered</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Invalid</td>
<td>Invalid</td>
<td>Force false</td>
<td>Force false</td>
<td>Force true</td>
<td>Force true</td>
</tr>
<tr>
<td>Invalid</td>
<td>Valid</td>
<td>Force false</td>
<td>Force false</td>
<td>Force false</td>
<td>Force true</td>
</tr>
<tr>
<td>Valid</td>
<td>Invalid</td>
<td>Force false</td>
<td>Force false</td>
<td>Force false</td>
<td>Force false</td>
</tr>
<tr>
<td>Valid</td>
<td>Valid</td>
<td>Result</td>
<td>Result</td>
<td>Result</td>
<td>Result</td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="843" id="Page_843"/>To understand the entries in this table, you must consider each comparison type individually.</p>
<p>The <em>equal any</em> comparison checks whether each character appearing in <code>src2</code> appears anywhere in the set of characters specified by <code>src1</code>. If a character in <code>src1</code> is invalid, that means the instructions are comparing against a character that is not in the set; in this situation, you want to return false (regardless of <code>src2</code>’s validity). If <code>src1</code> is valid but <code>src2</code> is invalid, you’re at (or beyond) the end of the string; that’s not a valid comparison, so equal any also forces a false result in this situation.</p>
<p>The <em>ranges</em> comparison is also (in a sense) comparing a source string (<code>src2</code>) against a set of characters (specified by the ranges in <code>src1</code>). Therefore, the packed compare instructions force false if either (or both) operands are invalid for the same reasons as <em>equal any</em> comparisons.</p>
<p>The <em>equal each</em> comparison is the traditional string comparison operation, comparing the string in <code>src2</code> to the string in <code>src1</code>. If the corresponding character in both strings is invalid, you’ve moved beyond the end of both strings. The packed compare instructions force the result to true in this situation because these instructions are, effectively, comparing empty strings at this point (and empty strings are equal). If a character in one string is valid but the corresponding character in the other string is invalid, you’re comparing actual characters against an empty string, which is always <em>not equal</em>; hence, the packed string comparison instructions force a false result.</p>
<p>The <em>equal ordered</em> operation searches for the substring XMM<sub>src1</sub> within the larger string XMM<sub>src2</sub>/mem<sub>src2</sub>. If you’ve gone beyond the end of both strings, you’re comparing empty strings (and one empty string is always a substring of another empty string), so the packed comparison instructions return a true result. If you’ve reached the end of the string in <code>src1</code> (the substring to search for), the result is true even if there are more characters in <code>src2</code>; hence, the packed comparisons return true in this situation. However, if you’ve reached the end of the <code>src2</code> string but not the end of the <code>src1</code> (substring) string, there is no way that <em>equal ordered</em> will return true, so the packed comparison instructions force a false in this situation.</p>
<p>If the polarity bits (bits 4 to 5 of <var>imm</var><span class="SubscriptLiteral">8</span>) contain 00b or 10b, the polarity bits do not affect the comparison operation. If the polarity bits are 01b, the packed string comparison instructions invert all the bits in the temporary bit map result before copying the data to XMM0 (<code>(v)pcmpistrm </code>and <code>(v)pcmpestrm</code>) or calculating the index (<code>(v)pcmpestri </code>and <code>(v)pcmpistri</code>). If the polarity setting is 11b, the packed string comparison instructions invert the resultant bit if and only if the corresponding <code>src2</code> character is valid.</p>
<h3 id="h2-501089c14-0014">14.3.6	Packed String Comparison Results</h3>
<p class="BodyFirst">The last thing to note about the packed string comparison instructions is how they affect the CPU flags. These instructions are unusual among the SSE/AVX instructions insofar as they affect the condition codes. However, they do not affect the condition codes in standard ways (for example, you cannot use the carry and zero flags to test for string less than or greater <span epub:type="pagebreak" title="844" id="Page_844"/>than, as you can with the <code>cmps</code> instructions). Instead, these instructions overload the meanings of the carry, zero, sign, and overflow flags; furthermore, each instruction defines the meaning of these flags independently.</p>
<p>All eight instructions—<code>(v)pcmpestri</code>, <code>(v)pcmpistri</code>, <code>(v)pcmpestrm</code>, and <code>(v)pcmpistrm</code>—clear the carry flag if all of the bits in the (internal) result bit map are 0 (no comparison); these instructions set the carry flag if there is at least 1 bit set in the bit map. Note that the carry flag is set or cleared after the application of the polarity. </p>
<p>The zero flag indicates whether the <code>src2</code> length is less than 16 (8 for word characters). For the <code>(v)pcmpestri</code> and <code>(v)pcmpestrm </code>instructions, the zero flag is set if EDX is less than 16 (8); for the <code>(v)pcmpistri</code> and <code>(v)pcmpistrm</code> instructions, the zero flag is set if XMM<sub>src2</sub>/mem<sub>src2</sub> contains a null character.</p>
<p>The sign flag indicates whether the <code>src1</code> length is less than 16 (8 for word characters). For the <code>(v)pcmpestri</code> and <code>(v)pcmpestrm </code>instructions, the sign flag is set if EAX is less than 16 (8); for the <code>(v)pcmpistri</code> and <code>(v)pcmpistrm</code> instructions, the zero flag is set if XMM<sub>src1</sub> contains a null character.</p>
<p>The overflow flag contains the setting for bit 0 of the result bit map (that is, whether the first character of the source string was a match). This can be useful after an equal ordered comparison to see if the substring is a prefix of the larger string (for example).</p>
<h2 id="h1-501089c14-0004">	14.4	Alignment and Memory Management Unit Pages</h2>
<p class="BodyFirst">The <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instructions are nice insofar as they do not require their memory operand to be 16-byte aligned. However, this lack of alignment creates a special problem of its own: it is possible for a single <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instruction memory access to cross an MMU page boundary. As noted in <span class="xref" itemid="xref_target_“Memory Access and 4K Memory Management Unit Pages” in Chapter 3">“Memory Access and 4K Memory Management Unit Pages” in Chapter 3</span>, some MMU pages might not be accessible and will generate a general protection fault if the CPU attempts to read data from them. </p>
<p>If the string is less than 16 bytes in length and ends before the page boundary, using <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> to access that data may cause an inadvertent page fault when it reads a full 16 bytes from memory, including data beyond the end of the string. Though accessing data beyond the string that crosses into a new, inaccessible MMU page is a rare situation, it can happen, so you want to ensure you don’t access data across MMU page boundaries unless the next MMU page contains actual data.</p>
<p>If you have aligned an address on a 16-byte boundary and you access 16 bytes from memory starting at that address, you never have to worry about crossing into a new MMU page. MMU pages contain an integral multiple of 16 bytes (there are 256 16-byte blocks in an MMU page). If the CPU accesses 16 bytes starting at a 16-byte boundary, the last 15 bytes of that block will fall into the same MMU page as the first byte. This is why most SSE memory accesses are okay: they require 16-byte-aligned memory operands. The exceptions are the unaligned move instructions and the <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instructions.</p>
<p><span epub:type="pagebreak" title="845" id="Page_845"/>You typically use the unaligned move instructions (for example, <code>movdqu</code> and <code>movupd</code>) to move 16 actual bytes of data into an SSE/AVX register; therefore, these instructions don’t usually access extra bytes in memory. The <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instructions, however, often access data bytes beyond the end of the actual string. These instructions read a full 16 bytes from memory even if the string consumes fewer than 16 of those bytes. Therefore, when using the <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instructions (and the other unaligned moves, if you’re using them to read beyond the end of a data structure), you should ensure that the memory address you are supplying is at least 16 bytes before the end of an MMU page, or that the next page in memory contains valid data. </p>
<p>As <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> notes, there is no machine instruction that lets you test a page in memory to see if the application can legally access that page. So you have to ensure that no memory accesses by the <code>(v)pcmp</code><var>X</var><code>str</code><var>Y</var> instructions will cross a page boundary. The next chapter provides several examples.</p>
<h2 id="h1-501089c14-0005">	14.5	For More Information</h2>
<p class="BodyFirst">Agner Fog is one of the world’s foremost experts on optimization of x86(-64) assembly language. His website (<a href="https://www.agner.org/optimize/#manuals/" class="LinkURL">https://www.agner.org/optimize/#manuals/</a>) has a lot to say about optimizing memory moves and other string instructions. This website is highly recommended if you want to write fast string code in x86 assembly language.</p>
<p>T. Herselman has spent a huge amount of time writing fast <code>memcpy</code> functions. You can find his results at <a href="https://www.codeproject.com/Articles/1110153/Apex-memmove-the-fastest-memcpy-memmove-on-x-x-EVE/" class="LinkURL">https://www.codeproject.com/Articles/1110153/Apex-memmove-the-fastest-memcpy-memmove-on-x-x-EVE/</a> (or just search the web for <em>Apex memmove</em>). The length of this code will, undoubtedly, convince you to stick with the <code>movs</code> instruction (which runs fairly fast on modern x86-64 CPUs).</p>
<h2 id="h1-501089c14-0006">	14.6	Test Yourself</h2>
<ol class="decimal">
<li value="1">What size operands do the generic string instructions support?</li>
<li value="2">What are the five general-purpose string instructions?</li>
<li value="3">What size operands do the <code>pcmp</code><var>X</var><code>str</code><var>Y</var> instructions support?</li>
<li value="4">What registers does the <code>rep</code> <code>movsb</code> instruction use?</li>
<li value="5">What registers does the <code>cmpsw</code> instruction use?</li>
<li value="6">What registers does the <code>repne</code> <code>scasb</code> instruction use?</li>
<li value="7">What registers does the <code>stosd</code> instruction use?</li>
<li value="8">If you want to increment the RSI and RDI registers after each string operation, what direction flag setting do you use?</li>
<li value="9">If you want to decrement the RSI and RDI registers after each string operation, what direction flag setting do you use?</li>
<li value="10">If a function or procedure modifies the direction flag, what should that function do before returning? </li>
<li value="11"><span epub:type="pagebreak" title="846" id="Page_846"/>The Microsoft ABI requires a function to <span class="Underline">_</span> the direction flag before returning if it modifies the flag’s value. </li>
<li value="12">Which string instructions have Intel optimized for performance on later x86-64 CPUs? </li>
<li value="13">When would you want to set the direction flag prior to using a <code>movs</code> instruction? </li>
<li value="14">When would you want to clear the direction flag prior to using a <code>movs</code> instruction?</li>
<li value="15">What can happen if the direction flag is not set properly when you are executing a <code>movs</code> instruction? </li>
<li value="16">Which string prefix would you normally use with <code>cmpsb</code> to test two strings to see if they are equal?</li>
<li value="17">When comparing two character strings, how should the direction flag normally be set?</li>
<li value="18">Do you need to test whether RCX is 0 before executing a string instruction with a repeat prefix?</li>
<li value="19">If you wanted to search for a zero-terminating byte in a C/C++ string, what (general-purpose) string instruction would be most appropriate? </li>
<li value="20">If you wanted to fill a block of memory with 0s, what string instruction would be most appropriate?</li>
<li value="21">If you wanted to concoct your own string operations, what string instruction(s) would you use?</li>
<li value="22">Which string instruction would you typically never use with a repeat prefix? </li>
<li value="23">Before using one of the <code>pcmp</code><var>X</var><code>str</code><var>Y</var> instructions, what should you do? </li>
<li value="24">Which SSE string instructions automatically handle zero-terminated strings? </li>
<li value="25">Which SSE string instructions require an explicit length value? </li>
<li value="26">Where do you pass explicit lengths to the <code>pcmp</code><var>X</var><code>str</code><var>Y</var> instructions?</li>
<li value="27">Which <code>pcmp</code><var>X</var><code>str</code><var>Y</var> aggregate operation searches for characters belonging to a set of characters?</li>
<li value="28">Which <code>pcmp</code><var>X</var><code>str</code><var>Y</var> aggregate operation compares two strings? </li>
<li value="29">Which <code>pcmp</code><var>X</var><code>str</code><var>Y</var> aggregate operation checks whether one string is a substring of another?</li>
<li value="30">What is the problem with the <code>pcmp</code><var>X</var><code>str</code><var>Y</var> instruction and MMU pages?</li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c14-footnote-1" href="#c14-footnoteref-1">1.</a></sup> The x86-64 processor supports two additional string instructions: <span class="LiteralFootnote"><code>ins</code></span>, which inputs strings of data from an input port, and <span class="LiteralFootnote"><code>outs</code></span>, which outputs strings of data to an output port. We do not consider these because they are privileged instructions, and you cannot execute them in a standard 64-bit OS application.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c14-footnote-2" href="#c14-footnoteref-2">2.</a></sup> MASM overloads the meanings of the <span class="LiteralFootnote"><code>movsd</code></span> and <span class="LiteralFootnote"><code>cmpsd</code></span> instructions. With no operands, these are the <em>move string double</em> and <em>compare string double</em> instructions; with operands, they are the <em>move scalar double</em> and <em>compare scalar double</em> instructions.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c14-footnote-3" href="#c14-footnoteref-3">3.</a></sup> The exceptions are the <span class="LiteralFootnote"><code>cmps</code></span> and <span class="LiteralFootnote"><code>scas</code></span> instructions, which repeat <em>at most</em> the number of times specified in the RCX register.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c14-footnote-4" href="#c14-footnoteref-4">4.</a></sup> The repeat prefixes appear here simply because they are allowed. They’re not very useful, but they are allowed. About the only use for this form of the instruction is to “touch” items in the cache so they are preloaded into the cache. However, there are better ways to accomplish this.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c14-footnote-5" href="#c14-footnoteref-5">5.</a></sup> Byte comparisons will require 16 bits or 16 bytes, while word comparisons will require 8 bits or 8 bytes to hold the bit mask.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c14-footnote-6" href="#c14-footnoteref-6">6.</a></sup> Zero-extended into RCX; that is, the upper 32 bits of RCX will contain 0 after the packed compare instructions that produce an index value.</p></aside>
</section>
</section>
</body></html>