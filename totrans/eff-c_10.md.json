["```\ntypedef struct collection * collection_type;\n// function declarations\nextern errno_t create_collection(collection_type *result);\nextern void destroy_collection(collection_type col);\nextern errno_t add_to_collection(\n  collection_type col, const void *data, size_t byteCount\n);\nextern errno_t remove_from_collection(\n  collection_type col, const void *data, size_t byteCount\n);\nextern errno_t find_in_collection(\n  const collection_type col, const void *data, size_t byteCount\n);\n// `--snip--`\n```", "```\nstruct node_type {\n  void *data;\n  size_t size;\n  struct node_type *next;\n};\n\nstruct collection_type {\n  size_t num_elements;\n struct node_type *head;\n};\n```", "```\nstatic int i; // i has explicit internal linkage\nextern void foo(int j) {\n  // foo has explicit external linkage\n  // j has no linkage because it is a parameter\n}\n```", "```\nvoid func(int i) {// implicit external linkage\n  // i has no linkage\n}\nstatic void bar(); // internal linkage, different bar from bar.c\nextern void bar() {\n  // bar still has internal linkage because the initial declaration\n  // was declared as static; this extern specifier has no effect\n}\n```", "```\nextern void func(int i); // explicit external linkage\nstatic void bar() {  // internal linkage; different bar from foo.c\n  func(12); // calls func from foo.c\n}\nint i; // external linkage; doesnâ€™t conflict with i from foo.c or bar.c\nvoid baz(int k) {// implicit external linkage\n  bar(); // calls bar from bar.c, not foo.c\n}\n```", "```\n// print command line help text\nstatic void print_help() {\n  puts(\"primetest num1 [num2 num3 ... numN]\\n\");\n  puts(\"Tests positive integers for primality.\");\n  printf(\"Tests numbers in the range [2-%llu].\\n\", ULLONG_MAX);\n}\n```", "```\n// converts a string argument arg to an unsigned long long value referenced by val\n// returns true if the argument conversion succeeds and false if it fails\nstatic bool convert_arg(const char *arg, unsigned long long *val) {\n  char *end;\n\n  // strtoull returns an in-band error indicator; clear errno before the call\n  errno = 0;\n  *val = strtoull(arg, &end, 10);\n\n  // check for failures where the call returns a sentinel value and sets errno\n  if ((*val == ULLONG_MAX) && errno) return false;\n  if (*val == 0 && errno) return false;\n  if (end == arg) return false;\n\n  // If we got here, the argument conversion was successful.\n  // However, we want to allow only values greater than one,\n  // so we reject values <= 1.\n  if (*val <= 1) return false;\n  return true;\n}\n```", "```\nstatic unsigned long long *convert_cmd_line_args(int argc,\n                                                 const char *argv[],\n                                                 size_t *num_args) {\n  *num_args = 0;\n\n  if (argc <= 1) {\n    // no command line arguments given (the first argument is the\n    // name of the program being executed)\n    print_help();\n    return nullptr;\n  }\n\n  // We know the maximum number of arguments the user could have passed,\n  // so allocate an array large enough to hold all the elements. Subtract\n  // one for the program name itself. If the allocation fails, treat it as\n  // a failed conversion (it is OK to call free(nullptr)).\n unsigned long long *args =\n      (unsigned long long *)malloc(sizeof(unsigned long long) * (argc - 1));\n  bool failed_conversion = (args == nullptr);\n  for (int i = 1; i < argc && !failed_conversion; ++i) {\n    // Attempt to convert the argument to an integer. If we\n    // couldn't convert it, set failed_conversion to true.\n    unsigned long long one_arg;\n    failed_conversion |= !convert_arg(argv[i], &one_arg);\n    args[i - 1] = one_arg;\n  }\n\n  if (failed_conversion) {\n    // free the array, print the help, and bail out\n    free(args);\n    print_help();\n    return nullptr;\n  }\n\n  *num_args = argc - 1;\n  return args;\n}\n```", "```\nstatic unsigned long long power(unsigned long long x, unsigned long long y,\n                                unsigned long long p) {\n  unsigned long long result = 1;\n  x %= p;\n\n  while (y) {\n    if (y & 1) result = (result * x) % p;\n    y >>= 1;\n    x = (x * x) % p;\n  }\n return result;\n}\n\nstatic bool miller_rabin_test(unsigned long long d, unsigned long long n) {\n  unsigned long long a = 2 + rand() % (n - 4);\n  unsigned long long x = power(a, d, n);\n\n  if (x == 1 || x == n - 1) return true;\n\n  while (d != n - 1) {\n    x = (x * x) % n;\n    d *= 2;\n\n    if (x == 1) return false;\n    if (x == n - 1) return true;\n  }\n  return false;\n}\n```", "```\nbool is_prime(unsigned long long n, unsigned int k) {\n  if (n <= 1 || n == 4) return false;\n  if (n <= 3) return true;\n\n  unsigned long long d = n - 1;\n  while (d % 2 == 0) d /= 2;\n\n  for (; k != 0; --k) {\n    if (!miller_rabin_test(d, n)) return false;\n  }\n  return true;\n}\n```", "```\nint main(int argc, char *argv[]) {\n  size_t num_args;\n  unsigned long long *vals = convert_cmd_line_args(argc, argv, &num_args);\n\n if (!vals) return EXIT_FAILURE;\n\n  for (size_t i = 0; i < num_args; ++i) {\n    printf(\"%llu is %s.\\n\", vals[i],\n           is_prime(vals[i], 100) ? \"probably prime\" : \"not prime\");\n  }\n\n  free(vals);\n  return EXIT_SUCCESS;\n}\n```", "```\n#ifndef PRIMETEST_IS_PRIME_H\n#define PRIMETEST_IS_PRIME_H\n\nbool is_prime(unsigned long long n, unsigned k);\n\n#endif // PRIMETEST_IS_PRIME_H\n```", "```\n% **cc -c -std=c23 -Wall -Wextra -pedantic isprime.c -o bin/isprime.o**\n% **cc -c -std=c23 -Wall -Wextra -pedantic driver.c -o bin/driver.o**\n```", "```\nunable to open output file 'bin/isprime.o': 'No such file or directory'\n```", "```\n% **ar rcs bin/libPrimalityUtilities.a bin/isprime.o**\n```", "```\n% **cc bin/driver.o -Lbin -lPrimalityUtilities -o bin/primetest**\n```", "```\n% **./bin/primetest 899180**\n899180 is not prime\n% **./bin/primetest 8675309**\n8675309 is probably prime\n% **./bin/primetest 0**\nprimetest num1 [num2 num3 ... numN]\n\nTests positive integers for primality.\nTests numbers in the range [2-18446744073709551615].\n```"]