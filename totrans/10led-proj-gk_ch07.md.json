["```\n  /* StarfieldEffect.ino\n    by Adam Wolf\n\n    Uses a SmartMatrix SD Shield, a 32 by 32 RGB LED display,\n    and a Teensy to show a starfield effect.\n  */\n\n➊ #include <SmartMatrix3.h>\n  #define COLOR_DEPTH 24\n  const uint8_t kMatrixWidth = 32;\n  const uint8_t kMatrixHeight = 32;\n  const uint8_t kRefreshDepth = 36;\n  const uint8_t kDmaBufferRows = 4;\n  const uint8_t kPanelType = SMARTMATRIX_HUB75_32ROW_MOD16SCAN;\n  const uint8_t kMatrixOptions = (SMARTMATRIX_OPTIONS_NONE);\n  const uint8_t kBackgroundLayerOptions =\n   (SM_BACKGROUND_OPTIONS_NONE);\n  const uint8_t kScrollingLayerOptions =\n   (SM_SCROLLING_OPTIONS_NONE);\n  const uint8_t kIndexedLayerOptions = (SM_INDEXED_OPTIONS_NONE);\n  SMARTMATRIX_ALLOCATE_BUFFERS(matrix, kMatrixWidth,\n   kMatrixHeight, kRefreshDepth, kDmaBufferRows, \n   kPanelType, kMatrixOptions);\n  SMARTMATRIX_ALLOCATE_BACKGROUND_LAYER(backgroundLayer,\n   kMatrixWidth, kMatrixHeight, COLOR_DEPTH, \n   kBackgroundLayerOptions);\n  SMARTMATRIX_ALLOCATE_SCROLLING_LAYER(scrollingLayer,\n   kMatrixWidth, kMatrixHeight, COLOR_DEPTH, \n   kScrollingLayerOptions);\n  SMARTMATRIX_ALLOCATE_INDEXED_LAYER(indexedLayer, kMatrixWidth,\n   kMatrixHeight, COLOR_DEPTH, kIndexedLayerOptions);\n\n  struct Star {\n    int16_t x;\n    int16_t y;\n    float z;\n  };\n\n  #define NUM_STARS 32\n  struct Star stars[NUM_STARS];\n\n  const int X_RANGE = 400;\n  const int Y_RANGE = 400;\n  const int HALF_X_RANGE = X_RANGE / 2;\n  const int HALF_Y_RANGE = Y_RANGE / 2;\n  const int MAX_Z = 16;\n\n  const uint8_t SCREEN_WIDTH = 32;\n  const uint8_t SCREEN_HEIGHT = 32;\n  const uint8_t HALF_SCREEN_WIDTH = SCREEN_WIDTH / 2;\n  const uint8_t HALF_SCREEN_HEIGHT = SCREEN_HEIGHT / 2;\n\n  const float SPEED = 0.1;\n\n➋ void randomizeStarPosition(struct Star* s) {\n    s->x = random(-HALF_X_RANGE, HALF_X_RANGE);\n    s->y = random(-HALF_Y_RANGE, HALF_Y_RANGE);\n    s->z = MAX_Z; // Put the star in the back.\n  }\n\n  void drawStar(struct Star* s) {\n    uint8_t display_x = (int) (s->x / s->z);\n    uint8_t display_y = (int) (s->y / s->z);\n\n➌  display_x = display_x + HALF_SCREEN_WIDTH;\n    display_y = display_y + HALF_SCREEN_HEIGHT;\n\n    // Let's check if our calculated point should be displayed.\n    if (display_x >= 0 &&\n      display_y >= 0 && \n      display_x < SCREEN_WIDTH &&\n      display_y < SCREEN_HEIGHT) {\n      uint8_t brightness = map(s->z, 0, MAX_Z, 255, 0);\n      drawPoint(display_x, display_y, brightness); // It fits,\n                                                   // so draw it!\n    } else {\n      randomizeStarPosition(s);  // It does not fit,\n                                 // so make a new star.\n    }\n  }\n\n  void advanceStar(struct Star* s) {\n    s->z -= SPEED;\n\n    if (s->z <= 0) {\n      randomizeStarPosition(s);  // If the star has passed us,\n                                 // make a new one.\n    }\n  }\n\n  void setup() {\n➍   randomSeed(analogRead(A1));\n\n    for (int i = 0; i < NUM_STARS; i++) {\n      Star* current_star = &stars[i];\n      randomizeStarPosition(current_star);\n➎    current_star->z = random(0, MAX_Z);\n    }\n   setupDisplay();\n  }\n\n  void loop() {\n    clearDisplay();\n\n    for (int i = 0; i < NUM_STARS; i++) {\n      drawStar(&stars[i]);\n    }\n    paintDisplay();\n    for (int i = 0; i < NUM_STARS; i++) {\n      advanceStar(&stars[i]);\n    }\n  }\n\n  uint16_t distanceToStar(struct Star* s) {      // distance\n    return sqrt(sq(s->x) + sq(s->y) + sq(s->z)); // from (0, 0, 0)\n  }\n\n  void clearDisplay() {\n    backgroundLayer.fillScreen({0x00, 0x00, 0x00});\n  }\n\n  void drawPoint(uint8_t x, uint8_t y, uint8_t brightness) {\n    // Note this doesn't actually show it on the display.\n    backgroundLayer.drawPixel(x, y, \n     {brightness, brightness, brightness});\n  }\n\n  void paintDisplay() {\n    // Send the image we've built up to the screen.\n    backgroundLayer.swapBuffers(false);\n  }\n\n➏ void setupDisplay() {\n    matrix.addLayer(&backgroundLayer);\n    matrix.addLayer(&scrollingLayer);\n    matrix.addLayer(&indexedLayer);\n    matrix.begin();\n\n    backgroundLayer.enableColorCorrection(true);\n  }\n```"]