- en: Web Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building your First Website**
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll build a simple website with headings, paragraphs, images,
    links, and buttons. You’ll use HTML to create the page and CSS to style it how
    you want. The skills you’ll learn here can be used to build any website you’d
    like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0181-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE PROJECT FILES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project you won’t need any circuitry; everything is done in your Raspberry
    Pi desktop computer. You’ll use the Text Editor program to create HTML and CSS
    files. To access the Text Editor, from the desktop’s main menu go to **Accessories**
    ▸ **Text Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: This project requires several files, so we suggest you create a folder specifically
    for this project. Create a new folder inside your *Projects* directory called
    *Web_Applications*, and then create a project folder called *Project_15*.
  prefs: []
  type: TYPE_NORMAL
- en: After opening the Text Editor, create two blank files with CTRL-N; you’ll have
    to do this once for each file. Then save those files within the *Project_15* folder,
    and name them *index.html* and *style.css* as shown in [Figure 15-1](ch15.xhtml#ch15fig1).
    You can download the scripts a*t [https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0182-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 15-1:** Creating the HTML and CSS files'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP AN HTML WEB PAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*HTML*, short for *HyperText Markup Language*, is the predominant markup language
    used to create web pages. Web browsers were designed to read HTML *tags*, which
    tell the browser how to display content on the page. Let’s take a look at how
    tags work.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up the Basic Content**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following snippet shows the basic structure of an HTML document. Open your
    *index.html* file using the Text Editor and enter the content from [Listing 15-1](ch15.xhtml#ch15list1).
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 15-1:** The basic structure of an HTML web page'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This document is simply a list of HTML tags, denoted by the enclosing `< >`
    symbols. The first line of any HTML document is always `<!DOCTYPE html>`. This
    tells the web browser this document is an HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining structure needs to be sandwiched between the tags `<html>` ➊ and
    `</html>`, the former indicating the beginning of a web page and the latter indicating
    the end of the page. Note that the closing tag must have a `/` after the `<` symbol;
    this is true of all HTML closing tags. Not all HTML tags need a closing tag, however,
    as you’ll see later.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML documents have two main parts: the head and the body. The *head*, which
    goes within the tags `<head>` ➋ and `</head>`, is where you insert data about
    the HTML document that is not directly visible on the page but that adds functionality
    to the web page, like the title that shows up in the browser tab, scripts, styles,
    and more. The *body*, which falls within the tags `<body>` ➌ and `</body>`, includes
    the content of the page, such as headings, text, images, tables, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding the Title, Headings, and Paragraphs**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To see how your web page looks, go to the taskbar menu and open Chromium, and
    then drag the *index.html* file into the Chromium web browser. At the moment,
    you should see only a blank page, because you haven’t added anything to the HTML
    file yet. In this section, you’ll add the title, headings, and paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Title Tags**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The title goes between the `<title>` and `</title>` tags, which should go within
    the `<head>` and `</head>` tags. Add a title to your file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Instead of dragging the file into the browser again, you can simply refresh
    the web page after saving the HTML; the changes are updated immediately.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you save *index.html* and again drag the file into your browser, don’t be
    surprised to still see a blank page. The title shows in the web browser tab, not
    on the page itself. We titled our web page “Max – The Dog,” but you can title
    your page whatever you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Heading Tags**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can use headings to structure the text on the web page. Heading tags begin
    with an `h` followed by a number that indicates the heading level. For example,
    `<h1>` and `</h1>` are the tags for heading 1, or the top level; `<h2>` and `</h2>`
    are for heading 2, and so on until heading 6, which is the bottom level of heading.
    Heading tags should go between the `<body>` and `</body>` tags. Make a couple
    of headings and place them in the body of your file now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve added two headings to our page: “MAX – THE DOG” at the top level and
    “About Max” at a level below that. Now it’s time to put some text under those
    headings.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Paragraph Tags**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You should put most of your readable content in paragraphs. Every paragraph
    needs to go between the `<p>` and `</p>` tags. Add a paragraph or two to your
    file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You now have your very own web page! Feel free to add as many paragraphs and
    headings as you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: '**Seeing Your Web Page**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Save your *index.html* document and refresh the web page. [Figure 15-2](ch15.xhtml#ch15fig2)
    shows how Max’s web page looks at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0184-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 15-2:** A simple HTML page'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, HTML doesn’t do much besides adding raw text to your page; it’s
    mainly a series of paragraphs and doesn’t look pretty at all. You’re going to
    use CSS in a later section to style details and make your page look attractive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Links, Images, and Buttons**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Any self-respecting website should contain way more than just text. We’ll show
    you how to add images, buttons, more pages, and links to other pages too.
  prefs: []
  type: TYPE_NORMAL
- en: '**Including Hyperlinks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To add a hyperlink to another page on the internet, add the `<a>` tag anywhere
    between the `<body>` and `</body>` tags. For example, you can insert a hyperlink
    to the Inspector Rex Wikipedia page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `a` stands for *anchor* and the text that goes between these tags is called
    *anchor text*, which is `Inspector Rex` in this case. Inside the `<a>` tag, we’ve
    included the `href` attribute, which specifies where the link should go. The anchor
    text is what the page’s visitors see on the page; when they click that text, the
    Inspector Rex Wikipedia web page opens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most websites have multiple pages you can navigate through. That navigation
    between pages is also done using hyperlinks. For example, if you want to insert
    a new page—say, a photo gallery for Max—you would link to it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On its own, this link won’t take you anywhere because the page it’s pointing
    to doesn’t yet exist. You have to create the *gallery.html* file and save it in
    the same folder as your *index.html* file. You won’t create another page in this
    project, but now you know how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Including Images**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Images make any website more appealing. To insert an image, you use the `<img>`
    tag, which doesn’t have a closing tag because you list the image you want shown
    within the angle brackets, `<>`. The file for the image you want to include has
    to be saved in the website’s folder—in this case, *Project_15*—to make it onto
    the web page. To insert an image called *max.jpg*, you use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `src` indicates the location of the image file. Because we have the image
    stored in the website’s folder, we can just use the image filename. Replace `max.jpg`
    in the code with your own image filename. You can also use a hyperlink to an image
    by replacing `max.jpg` with the hyperlink.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can resize your image either by editing the image file manually or by using
    the `height` attribute within the `<img>` tag. For example, to resize the image
    to 350 pixels in height, you use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The width adjusts automatically according to the height. You could also change
    the width with the `width` attribute and the height would readjust automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The `<img>` tag must be inside a `<p>` or a `<div>` tag—you can use a `<div>`
    tag to create a section inside your body content (see this in [Listing 15-2](ch15.xhtml#ch15list2)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Including Buttons**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To include a button on your page, insert the label you want for your button
    between the `<button>` and `</button>` tags. We want to insert a button that leads
    to a funny police dog chase video, so we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the button clickable so it redirects you to the video page, insert
    the button tags between the `<a>` hyperlink tags to the video in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Viewing Max’s HTML File**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve added an image, a link, and a button to Max’s web page. The code in [Listing
    15-2](ch15.xhtml#ch15list2) shows how the HTML document looks at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 15-2:** The HTML document for Max’s web page with a link, an image,
    and a button'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we’ve added three new tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<header>` ➊ and `</header>` ➍ contain introductory content. Inside these tags
    is the first-level heading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<div class="title">` ➋ and `</div>` ➌ define a division or section. The `class`
    attribute called `title` indicates that an HTML element is a member of a particular
    class—in this case, the `title` class, but you can give it any name you want.
    Using the `class` attribute is useful because it allows you to define the same
    style in CSS for multiple elements that belong to the same class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<main>` ➎ and `</main>` ➏ specify the main content of a document. This is
    where you should place content that is unique to the document—that is, content
    that isn’t repeated in the website. A single HTML document shouldn’t have more
    than one `<main>` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We structured the HTML content this way because it makes it easier to use CSS
    later to format the page. [Figure 15-3](ch15.xhtml#ch15fig3) shows how the web
    page looks with the HTML file in [Listing 15-2](ch15.xhtml#ch15list2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0188-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 15-3:** Max’s web page with a link, an image, and a button'
  prefs: []
  type: TYPE_NORMAL
- en: '**STYLING YOUR PAGE WITH CSS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you’ll add *CSS*, or *Cascading Style Sheets*, a style sheet language used
    to describe how the elements in a web page will look when rendered. You can add
    CSS either directly to the HTML file or in a separate file that you reference
    in the HTML file. In this project, you’ll create a separate file for the CSS document;
    this way, it’ll be easier to read both the CSS and HTML files and understand what
    they do.
  prefs: []
  type: TYPE_NORMAL
- en: '**Embedding a Style Sheet**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before getting to the CSS document itself, you need to embed the style sheet
    in the *index.html* file so that the HTML knows to reference an external CSS file.
    To do this, add the following line between the `<head>` and `</head>` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This `<link>` tag tells the HTML file that you’re using an external style sheet
    to format how the page looks. The `rel` attribute specifies the nature of the
    external file, in this case that it is a style sheet—the CSS file—that will be
    used to alter the appearance of the page. The `type` attribute is set to `"text/css"`
    to indicate that you’re using a CSS file for the styles. The `href` attribute
    indicates the file location; again, since the file is in the website’s folder,
    you just need to reference the filename.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve added the link to refer to the style sheet, your header should
    look like [Listing 15-3](ch15.xhtml#ch15list3).
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 15-3:** Linking to a CSS style sheet in your HTML document'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this extra tag, the style sheet is connected to the HTML document. Creating
    a separate style sheet is useful because you can embed the same style sheet in
    several web pages with just one line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Styling Your HTML Content**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To style your HTML content, CSS uses *selectors* that define which elements
    a set of CSS rules applies to. They have *properties*, which in turn have *values*.
    The code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The set of rules that defines the style for a certain selector should go between
    curly brackets, `{}`. You attribute a value to a property with a colon (`:`),
    and every value should end with a semicolon (`;`). Each selector can have, and
    normally does have, more than one property.
  prefs: []
  type: TYPE_NORMAL
- en: '**Styling the Header**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve been following the instructions, you should have a *style.css* file
    inside the *Project_15* folder along with your *index.html* file. Open your *style.css*
    file and edit the header by entering the content in [Listing 15-4](ch15.xhtml#ch15list4).
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 15-4:** Styling the header with CSS'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, `header` is the selector, which means that the style rules
    you’re going to describe between curly brackets will apply to the header section
    of your web page. Remember that the header section is what goes between the `<header>`
    and `</header>` tags and includes the introductory content. Here we insert a background
    image—a beautiful photo of Max. For that, we use the `background` property, whose
    value is `url(background.jpg)` ➊; inside the `url()` you write the path directory
    for the image. Replace `background.jpg` with the name of the image you want to
    use as the background. Since you’re going to save the image file in the same folder
    as the HTML and CSS files, you reference only the image filename.
  prefs: []
  type: TYPE_NORMAL
- en: Assign the `cover` value to the `background-size` property ➋. This says that
    the background image should fill the entire header section.
  prefs: []
  type: TYPE_NORMAL
- en: The `height` property has a value of `70vh` ➌, which specifies the height of
    the header. You can use one of several units for the height, but we are using
    `vh` (viewport height), which is relative to 1 percent of the height of the viewport
    and ensures the header elements can fit into the viewport. This instruction means
    the header fills 70 percent of the web browser’s window regardless of its size.
    Experiment with other percentage values and see how your page looks.
  prefs: []
  type: TYPE_NORMAL
- en: Save the CSS file and refresh the browser tab that contains the HTML document
    in order to see how your newly styled web page looks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Styling the title Class**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ll edit the `title` class, which includes any content that goes between
    the `<div class="title">` and `</div>` tags. These tags are between the `<header>`
    and `</header>` tags, which means that the `header` is an *ancestor* of the `title`
    class. Add the snippet in [Listing 15-5](ch15.xhtml#ch15list5) to your CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 15-5:** Styling the `title` class'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To select elements with a specific class, use a period (`.`) followed by the
    class name, like `.title`. We’ll walk you through each element.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adjusting Positions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can position elements using the `top`, `bottom`, `left`, and `right` properties,
    but first you need to set the `position` property ➊.
  prefs: []
  type: TYPE_NORMAL
- en: The way the elements are positioned on the page works differently depending
    on whether the `position` value is set to `static`, `relative`, `fixed`, or `absolute`.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE POSITION PROPERTY**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `position` property can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: An element with the `static` value is positioned according to the normal flow
    of the page and is not affected by the `top`, `bottom`, `left`, and `right` properties.
    By default, HTML elements are `static`.
  prefs: []
  type: TYPE_NORMAL
- en: relative
  prefs: []
  type: TYPE_NORMAL
- en: An element with the `relative` value is positioned relative to its default position
    using the `top`, `bottom`, `left`, and `right` properties.
  prefs: []
  type: TYPE_NORMAL
- en: fixed
  prefs: []
  type: TYPE_NORMAL
- en: An element with the `fixed` value remains in the same position even when the
    page is scrolled. To position the elements on the viewport, use the `top`, `bottom`,
    `left`, and `right` properties.
  prefs: []
  type: TYPE_NORMAL
- en: absolute
  prefs: []
  type: TYPE_NORMAL
- en: An element with the `absolute` value is positioned relative to its nearest ancestor.
    To adjust the position, use the `top`, `bottom`, `left`, and `right` properties.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using the `absolute` value. This means each element is
    positioned relative to its nearest ancestor, in this case the header section.
    Take a look at [Figure 15-4](ch15.xhtml#ch15fig4) to understand how the `title`
    class elements are positioned in relation to the header.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0191-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 15-4:** Positioning the `title` class elements inside the header section'
  prefs: []
  type: TYPE_NORMAL
- en: The `top` ➋ and `left` ➌ properties specify where each element is positioned
    in relation to its ancestor, given as a percentage, which represents how far across
    the page it appears, with `0%` being the far left and top edge of its ancestor.
    The `50%` values for `top` and `left` move the top-left corner of the `title`
    class section to the middle of its ancestor. This means the top-left corner of
    the `title` class section, rather than its center point, will be positioned at
    the center of the header section; take a look at [Figure 15-4](ch15.xhtml#ch15fig4)
    (A). You can adjust this with the `transform` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `transform` property ➍, with the `translate(–50%, –40%)` values, shifts
    the position of the element. The `–``50%` value moves the `title` class element
    50 percent to the left in relation to its size, which will center it horizontally
    inside the header section—take a look at [Figure 15-4](ch15.xhtml#ch15fig4) (B).
    We also apply `–``40%` to the vertical position, to move it 40 percent up from
    the bottom (see [Figure 15-4](ch15.xhtml#ch15fig4) (C)). Try this with different
    values and see how it changes. The `–``50%` and `–``40%` work just fine for Max’s
    page, but you may want to move the text to a different position depending on your
    background image.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Text Color and Alignment**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `color` ➎ and `text-align` ➏ properties define text color and text alignment,
    respectively. You can set colors with their name—HTML recognizes basic color names—or
    by using a hexadecimal or RGB color code. We’re using hexadecimal. You can google
    *hexadecimal color picker* for a hexadecimal reference to a specific color. The
    `text-align` property takes several values like `left`, `right`, `center`, and
    `justify`, to align text to the left or right or center or justify it, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Styling the Headings, Paragraphs, and Links**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 15-6](ch15.xhtml#ch15list6) styles the headings, paragraphs, and links.
    Add these styles to your CSS document.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 15-6:** Styling headings, paragraphs, and hyperlinks'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To define the text size, use the `font-size` property ➊. There are several units
    to define the font size, but we’re going to use the `rem` unit. *Rem* is the computed
    value of `font-size` on the root element—we use one font size as a reference across
    the page. This means all font sizes are relative to each other, reducing issues
    arising from older font size units, which would cause irregularities when viewing
    the page on devices with different screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: When used in the `font-size` property of the root element, the rem units refer
    to the property’s initial value. So 1 rem is equal to the font size of the HTML
    element—that is, 16 pixels by default in most browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 15-6](ch15.xhtml#ch15list6), we define `4`, `2.5`, and `1.3` rem
    font size for the heading 1, heading 2, and paragraphs, respectively, to make
    each heading level subsequently smaller than the one above, with the lowest level
    slightly larger than the default text.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` section formats the main content of your page ➋. We’re setting the
    maximum width of content to `500px`. Defining the width of an element prevents
    the element from stretching to the boundaries of its container; in this case,
    it prevents the text from spreading horizontally on the web browser window. Then,
    we set the margins with `auto` to center the element horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperlinks are underlined by default. Set `text-``decoration` to `none` ➌ to
    remove the underline.
  prefs: []
  type: TYPE_NORMAL
- en: '**Styling the Button**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To style the button, copy the styles in [Listing 15-7](ch15.xhtml#ch15list7)
    to your *style.css* document file.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 15-7:** Styling the button'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Setting `display` to `block` ensures the button is displayed as a block element,
    like a paragraph; so, for example, the button will not be on the same line as
    a text element. We use the `padding` property to add space around content. We
    define a padding of `10px` for the top and bottom margins of the button and `20px`
    for the right and left margins—this sets how much space surrounds the button’s
    content. Notice that here we’re using the hexadecimal color code for setting the
    color of the button text and the button background color. The other button properties
    are self-explanatory. Play with these properties to style the button to your liking.
    You can also search for *button properties CSS* on the web for more properties
    and values.
  prefs: []
  type: TYPE_NORMAL
- en: Save your *style.css* file and refresh your browser to see the changes you’ve
    made. You should now have a simple web page similar to the one shown at the beginning
    of this project.
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This project was just a quick introduction on how to build a simple web page
    with HTML and CSS. There are endless ways in which you can edit and improve it.
    We encourage you to play around with all the options introduced here. For inspiration,
    you could:'
  prefs: []
  type: TYPE_NORMAL
- en: Add multiple pages to your main page with hyperlinks to each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a web page that showcases one of your Raspberry Pi projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search the web for more CSS properties and values and edit the way your page
    looks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connecting your Electronics to the Web**
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll create your own Internet of Things web server you can
    use to control a lamp remotely from your phone. The simple web server you’ll build
    can then be added to other projects so you can control other electronic appliances.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0196-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Relay module HL-52S
  prefs: []
  type: TYPE_NORMAL
- en: 12 V lamp and holder
  prefs: []
  type: TYPE_NORMAL
- en: 12 V power adapter
  prefs: []
  type: TYPE_NORMAL
- en: Male DC bar rel power jack
  prefs: []
  type: TYPE_NORMAL
- en: Plastic box enclosure
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**SOFTWARE REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Flask framework
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’re going to create your own web server to control your electronics
    through a browser. You’ll control a 12 V lamp using a dynamic web page with buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING WEB SERVERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A web server is a computer that provides web pages. It stores the website’s
    files, including all HTML documents and related assets like images, CSS style
    sheets, fonts, and video. It also brings those files to the user’s device web
    browser when the user makes a request to the server’s URL.
  prefs: []
  type: TYPE_NORMAL
- en: When you access a web page in your browser, you’re actually sending a request
    via *Hypertext Transfer Protocol (HTTP)* to a server. This is simply a process
    for requesting and returning information on the internet. The server sends back
    the web page you requested—also through HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll use your Raspberry Pi to host a web server on the local
    network, as illustrated in [Figure 16-1](ch16.xhtml#ch16fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0197-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 16-1:** Your Raspberry Pi running a web server'
  prefs: []
  type: TYPE_NORMAL
- en: As a server, your Raspberry Pi can provide some output through its GPIO pins.
    In other words, using a browser on your local network, you can access the Pi web
    server to remotely control the GPIOs and turn something on.
  prefs: []
  type: TYPE_NORMAL
- en: Web servers can serve *static* or *dynamic* content. The content of a static
    website doesn’t change unless you edit its HTML file. The website built in [Project
    15](ch15.xhtml#ch15) is an example of a static website. With a dynamic website,
    the content changes based on user interactions. In this project, you’ll create
    a dynamic website that controls and shows the current state of a 12 V lamp connected
    to a relay, which we’ll look at more closely in a second.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Only devices that are connected to the same router as your Pi can access a
    web page hosted in your Pi through a browser. Accessing your web server from*
    outside *your network is more difficult. You can make your Raspberry Pi web server
    accessible from any computer anywhere by using a technique called* router port
    forwarding, *but that subject is beyond the book’s scope.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING THE RELAY MODULE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *relay* is an electrically operated switch that can be turned on or off, letting
    the current go through or not, and can be controlled with low voltages, like the
    3.3 V provided by the Raspberry Pi. The relay module you’ll use in this project
    has two relays—the two blue cubes shown in [Figure 16-2](ch16.xhtml#ch16fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0198-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 16-2:** Relay module with two channels'
  prefs: []
  type: TYPE_NORMAL
- en: The six pins on the left side of the relay module connect high voltage, and
    the pins on the right side connect the component that requires low voltage—the
    Raspberry Pi GPIOs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Relay Pinout**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The high-voltage side has two connectors, each with three sockets: *common
    (COM)*, *normally closed (NC)*, and *normally open (NO)*. The normally closed
    configuration is used when you want the relay to be closed by default, meaning
    the current is flowing unless you send a signal from the Pi to the relay module
    to open the circuit and stop the current. The normally open configuration works
    the other way around: the relay is always open, so the circuit is broken unless
    you send a signal from the Pi to close it.'
  prefs: []
  type: TYPE_NORMAL
- en: The low-voltage side has a set of four pins and a set of three pins. The first
    set consists of VCC and GND to power up the module, and input 1 (IN1) and input
    2 (IN2) to control the bottom and top relays, respectively. The second set of
    pins consists of GND, VCC, and JD-VCC pins. The JD-VCC pin powers the electromagnet
    of the relay. Notice that the module has a jumper cap connecting the VCC and JD-VCC
    pins; the one shown here is blue, but yours may be a different color.
  prefs: []
  type: TYPE_NORMAL
- en: The jumper cap allows you to choose whether the circuit is physically connected
    to the Pi circuit or not, and you can choose to have it on or not. With the jumper
    cap on, the VCC and JD-VCC pins are connected. That means the relay electromagnet
    is directly powered from the Pi’s power pin, so the relay module and the Raspberry
    Pi circuits are not physically isolated from each other. This is the configuration
    we’ll use. Without the jumper cap, you need to provide an independent power source
    to power up the relay’s electromagnet through the JD-VCC pin. That configuration
    physically isolates the relays from the Raspberry Pi with the module’s built-in
    optocoupler, which prevents damage to the Pi in case of electrical spikes.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OPTOCOUPLER**'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go into too much detail about the optocoupler. It is basically a component
    that allows you to send signals between two isolated circuits so that you can
    control high voltages with low voltages without actually having a physical connection
    between those two circuits. The optocoupler makes the “connection” between the
    circuits using an LED that emits light and a phototransistor that receives the
    light and then activates or deactivates the relay.
  prefs: []
  type: TYPE_NORMAL
- en: '**Relay Usage**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll use a normally open configuration for this project. You want to light
    the lamp only when you choose to, so the circuit should be broken until you say
    otherwise. For this, you use the COM and NO sockets.
  prefs: []
  type: TYPE_NORMAL
- en: In a normally open configuration, there is no contact between the COM and NO
    sockets unless you trigger the relay. The relay is triggered when the input goes
    below about 2 V. That means if you send a LOW signal from the Pi, the relay turns
    on, and if you send a HIGH signal, the relay turns off; this is called *inverted
    logic*. You’ll control just one relay, so you’ll connect IN1 to one of the Pi’s
    GPIO pins.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re not comfortable dealing with higher voltages like 12 V, but you
    want to do the project, you can replace the relay module with an LED. You’ll also
    need to make some minor changes to the Python script, since the relay works with
    inverted logic and the LED doesn’t.*'
  prefs: []
  type: TYPE_NORMAL
- en: The hardware for the project involves connecting an AC 12 V power adapter that
    can provide 1 A to a relay module to control a 12 V lamp. We’ll use a DC barrel
    power jack to make the connections between the adapter and the relay easier. The
    barrel jack connects perfectly to the power adapter terminal, as shown in [Figure
    16-3](ch16.xhtml#ch16fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0199-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 16-3:** Power adapter terminal and DC barrel power jack'
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT OVERVIEW**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before getting into building this project, let’s go through a quick overview
    so you better understand each step (see [Figure 16-4](ch16.xhtml#ch16fig4)). You
    should also know the basics of HTML and CSS, so we recommend that you complete
    [Project 15](ch15.xhtml#ch15) if you haven’t already before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0200-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 16-4:** Project overview'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll create your web server with Flask, a Python web framework, by creating
    a file called *app.py*. When you access the Raspberry Pi IP address, port 80,
    your web browser requests the web page files stored in your Raspberry Pi—*index.html*
    and *style.css*—and then displays the web page. Your web page will have ON and
    OFF buttons that trigger an event that turns the lamp on and off, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For safety reasons, you’ll want to place your relay inside a plastic box enclosure.
    You may need to drill some holes in the plastic box for the wires—one hole for
    the Pi wires, another for the lamp wires, and one for the power adapter. [Figure
    16-5](ch16.xhtml#ch16fig5) shows how the enclosure looks without the lid. The
    Raspberry Pi wires will go through a hole on the lid.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0200-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 16-5:** Circuit with the relay in a plastic box enclosure'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Make sure you have the jumper cap on the JD-VCC and VCC pins.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With your Pi powered *off*, follow these instructions to build the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect one of the lamp holder terminals to the negative (–) terminal on the
    DC barrel power jack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the DC barrel power jack positive (+) terminal to the relay COM socket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other lamp terminal to the relay NO socket. You need a screwdriver
    to connect the relay sockets tightly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the table to wire the Raspberry Pi to the relay, and make sure your completed
    setup matches [Figure 16-6](ch16.xhtml#ch16fig6).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **RELAY** | **RASPBERRY PI** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | 5 V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| IN2 | Don’t connect |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| IN1 | GPIO 17 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '![image](../images/f0201-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 16-6:** Controlling a 12 V lamp with the Raspberry Pi using a relay'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not touch the relay or any live wires while they are connected to 12 V.
    If something isn’t working and you decide to make changes to the circuit, remove
    the 12 V power adapter plug from the socket before touching anything.*'
  prefs: []
  type: TYPE_NORMAL
- en: After completing the circuit and double-checking all the connections, apply
    power to the Raspberry Pi, connect a 12 V power adapter to the DC barrel power
    jack, and apply power by plugging the 12 V power adapter into a wall socket.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to control an LED instead, use the [Project 1](ch01.xhtml#ch01)
    schematic diagram on [page 41](ch01.xhtml#page_41) as a reference, connecting
    the LED to GPIO 17.
  prefs: []
  type: TYPE_NORMAL
- en: '**PREPARING YOUR PI TO RUN A WEB SERVER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Raspberry Pi supports a number of web servers, but we’re going to use Flask,
    a Python web framework, to turn the Pi into a dynamic web server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Flask**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To install Flask, you need to have pip, a tool to install libraries from the
    Python Package Index. Open the terminal and run the following commands to update
    your Pi and install pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use pip to install Flask and its dependencies by entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If Flask installs correctly, the terminal will display the message `successfully
    installed Flask`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizing Your Files**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Keeping your files organized is essential in this project because Flask needs
    your files structured in a particular way to work correctly. Create a folder specifically
    for this project called *Project_16* inside the *Web_Applications* folder. Then
    create the folders and files you’ll need by following the structure shown in [Figure
    16-7](ch16.xhtml#ch16fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0202-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 16-7:** Files and folders structure'
  prefs: []
  type: TYPE_NORMAL
- en: Create the *index.html* and *style.css* files using the Text Editor and the
    *app.py* file using Python 3 (IDLE). The *static* folder will store static files
    like the CSS file. The *templates* folder will store files that can be changed;
    for example, the *index.html* file is a template that dynamically changes the
    relay status label according to user input.
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE SCRIPTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need to write three scripts for this project: a Python script that will
    create your Pi web server, an HTML file that builds your web page, and a CSS file
    to style your web page.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Web Server**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the web server, open your *app.py* file, currently empty, and enter
    the code in [Listing 16-1](ch16.xhtml#ch16list1). This code creates the web server
    on Raspberry Pi port 80 and generates a web page that you can access on the local
    network, from any web browser. You can download all the code used throughout this
    project at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 16-1:** Creating a web server with Flask'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First you import the needed libraries ➊, and then you create a Flask object
    called `app` ➋. You initialize the relay on GPIO 17 ➌ and set the relay as *off*
    by default. The relay works with inverted logic, so you use `relay.on()` to turn
    it off.
  prefs: []
  type: TYPE_NORMAL
- en: The `@app.route('/')` decorator ➍ runs the `main()` function when someone accesses
    the root URL—the main Pi IP address of the server. In Python, a *decorator* starts
    with the `@` symbol and goes above a function definition. A decorator is basically
    a function that takes in another function, but you don’t need to worry about this
    for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: You render the *index.html* file to the web browser and print the current relay
    state, using the `relay_state` variable value on the HTML file ➎. Then you add
    a dynamic route with `action` as a variable ➏. This runs the `control()` function
    when someone accesses the dynamic route. If the action from the URL is `on`, the
    program turns the relay on and saves the current relay state ➐. This means when
    you access your Raspberry Pi IP address followed by `/on` (for example, `http://192.168.1.112/on`),
    the relay turns on. You’ll fetch your own IP address shortly.
  prefs: []
  type: TYPE_NORMAL
- en: If the action from the URL is `off`, the program turns the relay off and saves
    the current relay state. The server is listening on port 80 and the debug is set
    to `True` to report any errors ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing the HTML File**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-2](ch16.xhtml#ch16list2) is a simple HTML document that structures
    the web page. Feel free to add more paragraphs and headings to personalize it
    using what you learned in [Project 15](ch15.xhtml#ch15). Copy this code to your
    *index.html* file, which should be located in the *templates* folder as shown
    earlier in [Figure 16-7](ch16.xhtml#ch16fig7).'
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 16-2:** Writing the HTML file for your web page'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple HTML structure, and we won’t go into too much detail in this
    HTML code, because you should already be familiar with most of it from [Project
    15](ch15.xhtml#ch15). You can always refer back to that project for a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: The `<meta>` tag and the given attributes make your web page responsive in any
    mobile browser ➊. With this tag, the browser will render the width of the page
    to the width of the mobile screen. At line ➋, between double curly brackets `{{
    }}`, is `relay_state`, the variable we’re using in *app.py* to save the current
    relay state. This paragraph displays the state saved in the `relay_state` variable.
    When you click the ON button, you are redirected to `/on` root ➌, which turns
    the relay on, as seen in *app.py*. When you click the OFF button, you are redirected
    to the `/off` root ➍, which turns the relay off.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing the CSS File**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-3](ch16.xhtml#ch16list3) styles your web page. This is just an
    example of how you can style your page; you can edit the properties as you like.
    Your *style.css* file should be inside the *static* folder, as you saw earlier
    in [Figure 16-7](ch16.xhtml#ch16fig7).'
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 16-3:** Styling the web page with CSS'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In summary, we’ve set font sizes for the heading 2 and the paragraph ➊. Then,
    we’ve aligned all our page body ➋. Finally, we’ve edited the appearance of the
    ON and OFF buttons ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**Launching Your Web Server**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the Python script, HTML file, and CSS file completed, it’s time to run
    your web server. Open the terminal window and navigate to the *Project_16* folder
    by entering this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run *app.py* with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Your web server is now running. Open any browser on the local network and enter
    your Raspberry Pi IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find your Pi’s IP address, go to the terminal and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This prints the Pi’s IP address.
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit ready and your server running, open a browser and navigate
    to your Raspberry Pi IP address. Your browser will display the web server page.
    Now click the buttons to remotely control the lamp! [Figure 16-8](ch16.xhtml#ch16fig8)
    shows the web page in a smartphone’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0207-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 16-8:** Raspberry Pi web server page on a smartphone’s browser'
  prefs: []
  type: TYPE_NORMAL
- en: To stop the web server, simply press CTRL-C.
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this project, you learned how to use a relay and how to set up a web server
    to serve a web page, as well as put your HTML and CSS skills into practice. Here
    are some ideas for taking these concepts further:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit this project to control more than one output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit the CSS and HTML files to suit your own tastes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control other electronic appliances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit previous projects to control lamps connected to relays instead of LEDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**17'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internet of Things Control Center with Node-RED**
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll create an Internet of Things app to control your favorite
    household electronics from a web server using Node-RED, a powerful and easy-to-use
    tool for Internet of Things applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0209-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: DHT22 temperature and humidity sensor
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 kΩ resistor
  prefs: []
  type: TYPE_NORMAL
- en: Two 5 mm LEDs
  prefs: []
  type: TYPE_NORMAL
- en: Two 330 Ω resistor
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**SOFTWARE REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Node-RED DHT node
  prefs: []
  type: TYPE_NORMAL
- en: Node-RED dashboard
  prefs: []
  type: TYPE_NORMAL
- en: You’re going to create a Node-RED application that controls outputs and reads
    inputs in the local network. You’ll use it to control LEDs, as well as to read
    and display temperature and humidity values using the DHT22 sensor—all remotely
    through a web server.
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING NODE-RED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Node-RED is an open source visual wiring tool for building IoT applications
    that comes already installed on your Pi’s operating system and is designed to
    run perfectly with the Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Node-RED uses visual programming, with blocks called *nodes* that you wire together
    to perform a certain task, simplifying much of the programming significantly.
    Node-RED allows you to prototype a complex home automation system quickly and
    simply, giving you more time to spend on designing and making cool stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t cover everything that Node-RED can do in this project, but here’s
    a brief breakdown if you want to explore further:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the Pi’s GPIOs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish a connection with other boards like the Arduino and ESP8266.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a responsive graphical user interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicate with third-party services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve data from the web.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create time-triggered events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store and retrieve data from a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installing the DHT22 Nodes**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although the Node-RED software comes already installed with the Pi’s operating
    system, it doesn’t come with a node able to read from the DHT22 sensor. We need
    to install that first, by installing npm (Node Package Management) like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When prompted, type Y and press ENTER. The installation may take a few minutes.
    Then, enter the following command to upgrade npm to the latest 3.x version, which
    is the version recommended for use with Node-RED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These commands will output a warning message, but don’t worry—it’s harmless,
    so you can ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: Next you’ll download and unzip a C library for the Raspberry Pi. You need this
    library to control DHT22 through Node-RED. At the time of writing, the latest
    version of the library is 1.55\. Before you install the library, go to *[http://www.airspayce.com/mikem/bcm2835/](http://www.airspayce.com/mikem/bcm2835/)*
    and check the latest version. Then, enter the following commands, replacing the
    `1.55` highlighted in italics with the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, enter the following list of commands to compile and install the nodes
    needed to control the DHT22 sensor and add dashboard support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With all of that installed, reboot your Pi. Now we’ll give you a quick tour
    of Node-RED.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting Started with Node-RED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To open Node-RED, go to the terminal and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Your terminal window should show something like [Figure 17-1](ch17.xhtml#ch17fig1).
    The highlighted line shows your localhost’s Raspberry Pi IP address followed by
    the number of the port the Node-RED server is running on. *Localhost* is a hostname
    that means “this computer” and resolves to the IP address shown in the terminal
    window: http://127.0.0.1\. Using this IP address you can access Node-RED only
    in your Raspberry Pi browser. To access Node-RED in any browser on your local
    network, you need to find your Pi’s IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Usually, instead of going to the terminal, you can open Node-RED by going
    to the taskbar main menu and clicking **Programming ▸ Node-RED**. However, in
    this project, you need to start Node-RED from the terminal because DHT22 nodes
    require administrator permission.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0212-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-1:** Starting Node-RED from the terminal'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find your Raspberry Pi IP address, enter the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Open Chromium and enter *http://<Pi IP address>:1880/*, replacing *<Pi IP address>*
    with your Raspberry Pi’s IP address. Your Node-RED page server should open as
    shown in [Figure 17-2](ch17.xhtml#ch17fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0212-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-2:** The Node-RED editor in your browser'
  prefs: []
  type: TYPE_NORMAL
- en: On the left you’ll see a list of blocks, or nodes. Nodes are grouped according
    to their function; scroll down the list to see what you have. We’ll just cover
    a small number of existing nodes in this project, including nodes from the input,
    Raspberry_Pi, function, and dashboard sections, illustrated in [Figure 17-3](ch17.xhtml#ch17fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0213-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-3:** Some of the Node-RED nodes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The center box of your Node-RED page is the *flow* section; this is where you
    drag the nodes and wire them together to build your application. On the right
    are several tabs: the *info* tab shows information about a selected node, the
    *debug* tab is used for debugging purposes, and the *dashboard* tab is where you
    organize the user interface widgets of your application. Finally, the *Deploy*
    button saves the changes made to the flow and executes it. Next you’ll wire up
    your hardware, and then put together your flow in Node-RED.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should already be familiar with LEDs and the DHT22 sensor, but for a refresher
    on the DHT22 sensor, check [Project 12](ch12.xhtml#ch12). To wire the circuit,
    follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect 5 V and GND from the Pi to a red and blue breadboard rail, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert two LEDs into the breadboard. Wire the shorter lead of each LED to the
    GND rail through a 330 Ω resistor. Wire the longer lead of one LED to GPIO 18,
    and the longer lead of the other LED to GPIO 17.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the DHT22 into the breadboard (with the raised side facing you) and wire
    it according to the following table. Your completed circuit should match [Figure
    17-4](ch17.xhtml#ch17fig4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **DHT22** | **RASPBERRY PI** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 3.3 V |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | GPIO 4 and 3.3 V (via 4.7 kΩ resistor) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Don’t connect |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | GND |'
  prefs: []
  type: TYPE_TB
- en: '![image](../images/f0214-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-4:** Wiring the DHT22 and two LEDs to the Pi'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE FLOW**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The script, in this case, is the flow you’ll make in Node-RED. This flow will
    allow you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Control an LED with an on and off switch. This LED will also be time-sensitive,
    which means it will automatically light up and turn off at a specific time that
    you set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control another LED with PWM using a slider to act as a dimmer switch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the temperature from the DHT22 sensor and display it on a time-versus-temperature
    chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the humidity from the DHT22 sensor and display it on a gauge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First you’ll make the user interface you’ll use to control the components from
    your server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Dashboard User Interface**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Nodes from the dashboard section provide widgets that show up in your application
    user interface (UI) to control components. Every widget—like a button, slider,
    or chart—you add to the flow has to be associated with a *group* that tells the
    widget where it should appear on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need tabs, which are like pages in your application (like tabs in
    a browser). Groups are sections within a tab, where you can group widgets together.
    In any project, you’ll need to create tabs and groups in your dashboard to organize
    the widgets in the UI. You’ll build a tab called “Home” with one group called
    “Dashboard.”
  prefs: []
  type: TYPE_NORMAL
- en: Using [Figure 17-5](ch17.xhtml#ch17fig5) as a reference, select the **dashboard**
    tab ➊ in the top right and then press the **+ tab** button ➋ to create a new tab
    under the Tabs list. Click **edit** to edit the tab ➌ and enter the name Home.
    Once that’s created, press the **+ group** button ➍ to create a new group; then
    click **edit** ➎ and enter the name Dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0215-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-5:** Creating tabs and groups in the dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: To see how your dashboard currently looks, go to *http://<Pi IP address>:1880/ui*
    in your browser, replacing *<Pi IP address>* with your Raspberry Pi’s IP address
    you got earlier. As you can see in [Figure 17-6](ch17.xhtml#ch17fig6), your user
    interface is empty at the moment because you haven’t added any widgets, so let’s
    add some functionality next.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0216-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-6:** The Node-RED user interface'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wiring the Nodes**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’re going to add nodes to your flow. Your flow will control the LEDs
    connected to the Raspberry Pi GPIOs and read temperature and humidity from the
    DHT22 sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding a Switch and Scheduling Events**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Go back to the Node-RED editor and add two inject nodes from the input section
    by dragging them into the flow. When you drop them in the flow, their name will
    change to *timestamp*. Add a switch from the dashboard section, and an rpi gpio
    output node (the one with a joint on the left side) from the Raspberry_Pi nodes
    section. Arrange the nodes and wire them as shown in [Figure 17-7](ch17.xhtml#ch17fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0216-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-7:** The flow for controlling LED 1'
  prefs: []
  type: TYPE_NORMAL
- en: This set of nodes controls the LED connected to GPIO 17\. This LED can be controlled
    remotely with an on and off switch, and it is also time sensitive; timestamp 1
    determines the time the LED lights up, and timestamp 2 determines the time the
    LED turns off.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you double-click a node, a new window will open that allows you to edit
    the node’s properties. Double-click the first timestamp node and edit its properties
    like so: set the payload number to **1**, which sends 1 to the Raspberry Pi GPIO
    17 when this node is triggered. In the repeat field, select **at a specific time**
    and choose the time and day you want your LED to light up; you’ll choose the time
    to turn it off in timestamp 2\. We chose 19:00 (7 PM) for all days of the week.
    You can choose whatever times and days you want. The name field lets you name
    the node, and in our case we’ve called it **On at 7PM**. When you’re done editing
    your node, click the **Done** button. [Figure 17-8](ch17.xhtml#ch17fig8) shows
    the properties we set for this node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0217-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-8:** Editing the inject node properties'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the other nodes’ properties to match those in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **NODE** | **PROPERTIES** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| timestamp | Payload: number 1 Repeat: at a specific time'
  prefs: []
  type: TYPE_NORMAL
- en: 'At: 19:00'
  prefs: []
  type: TYPE_NORMAL
- en: 'On: select all days |'
  prefs: []
  type: TYPE_NORMAL
- en: '| timestamp | Payload: number 0 Repeat: at a specific time'
  prefs: []
  type: TYPE_NORMAL
- en: 'At: 23:00'
  prefs: []
  type: TYPE_NORMAL
- en: 'On: select all days |'
  prefs: []
  type: TYPE_NORMAL
- en: '| switch | Group: Dashboard [Home] Label: LED 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Payload: number 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Off Payload: number 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: LED 1 – Switch |'
  prefs: []
  type: TYPE_NORMAL
- en: '| pin | GPIO: GPIO17 – 11 Type: Digital output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: LED 1 – GPIO 17 |'
  prefs: []
  type: TYPE_NORMAL
- en: To run your Node-RED application, click the **Deploy** button at the top right.
    This will also save the changes. To see how your application looks, go to *http://<Pi
    IP address>:1880/ui* in the browser. At this point, it should look like [Figure
    17-9](ch17.xhtml#ch17fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0218-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-9:** The user interface with the LED 1 control switch'
  prefs: []
  type: TYPE_NORMAL
- en: Click the switch to test whether you can control the LED connected to GPIO 17\.
    If not, go back and make sure you’ve wired your nodes correctly and set the right
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding a Slider**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now, you’ll add the nodes to control the brightness of the LED connected to
    GPIO 18\. Drag a slider and an rpi gpio output node into the flow, and arrange
    them as in [Figure 17-10](ch17.xhtml#ch17fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0218-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-10:** The flow for controlling LED 1 and LED 2'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the new nodes’ properties as shown in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **NODE** | **PROPERTIES** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| slider | Group: Dashboard [Home] Label: LED 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Range: min:0; max:100; step:1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: LED 2 – Slider |'
  prefs: []
  type: TYPE_NORMAL
- en: '| pin | GPIO: 12 – GPIO18 Type: PWM output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: LED 2 – GPIO 18 |'
  prefs: []
  type: TYPE_NORMAL
- en: This new set of nodes controls the LED connected to GPIO 18 using PWM. Moving
    the slider will change the LED brightness. Click the **Deploy** button, go to
    the Node-RED UI, and test your application. It should look something like [Figure
    17-11](ch17.xhtml#ch17fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0219-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-11:** The user interface with the LED 1 switch and the LED 2 slider'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding a Temperature Chart and Humidity Gauge**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, to create a temperature chart and a humidity gauge, drag an inject
    node, rpi dht22 node, function node, a chart, and a gauge to the flow. The chart
    and the gauge are dashboard nodes. Arrange the nodes so your flow looks like [Figure
    17-13](ch17.xhtml#ch17fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0219-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-12:** The complete Node-RED flow'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the new nodes’ properties with the settings in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **NODE** | **PROPERTIES** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| timestamp | Payload: Boolean true Repeat: interval'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every: 1 minute'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Read DHT22 |'
  prefs: []
  type: TYPE_NORMAL
- en: '| rpi-dht22 | Sensor model: DHT22 Pin numbering: BCM GPIO'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pin number: 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: DHT22 – GPIO 4 |'
  prefs: []
  type: TYPE_NORMAL
- en: '| chart | Group: Dashboard [Home] Label: Temperature'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type: Line Chart'
  prefs: []
  type: TYPE_NORMAL
- en: 'X-axis: 1 hour'
  prefs: []
  type: TYPE_NORMAL
- en: 'X-axis Label: HH:mm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Temperature – Chart |'
  prefs: []
  type: TYPE_NORMAL
- en: '| f | Name: Get humidity Function:'
  prefs: []
  type: TYPE_NORMAL
- en: msg.payload = msg.humidity;
  prefs: []
  type: TYPE_NORMAL
- en: return msg; |
  prefs: []
  type: TYPE_NORMAL
- en: '| gauge | Group: Dashboard [Home] Type: Gauge'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Humidity'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value format: {{value}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Units: %'
  prefs: []
  type: TYPE_NORMAL
- en: 'Range: min:0; max:100'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Humidity - Gauge |'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Deploy** button and once again test your application. Remember,
    if you run into any trouble, make sure that your properties match the tables here
    and double-check the wiring of your nodes against the figures.
  prefs: []
  type: TYPE_NORMAL
- en: '**RUNNING YOUR APPLICATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Congratulations! You’ve built your first IoT application with Node-RED. Go to
    *http://<Pi IP address>:1880/ui* to see how your user interface looks. You can
    access this URL using any browser on the local network, whether that’s on your
    computer or smartphone. [Figure 17-13](ch17.xhtml#ch17fig13) shows the final circuit
    you can control using your Node-RED application.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0221-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 17-13:** IoT project with Node-RED'
  prefs: []
  type: TYPE_NORMAL
- en: Your application has a switch to control LED 1, which is also time sensitive;
    a slider to control the brightness of LED 2; and a chart and gauge to display
    temperature and humidity.
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This project just scratched the surface of what Node-RED can do. Here are some
    ideas for taking this project further:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the time-sensitive LED with a relay and a lamp (refer to [Project 16](ch16.xhtml#ch16)
    for an introduction to the relay module).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add more sensor readings to your application, like the smoke sensor and movement
    detection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
