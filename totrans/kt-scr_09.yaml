- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 6 RECURSIVE FUNCTIONS AND FRACTALS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/icon.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fractals are enchanting geometric shapes where the real meets the imaginary
    (imaginary numbers, that is). Repeating patterns keep emerging forever as we continue
    to zoom in on them. Mathematicians are still trying to define fractals precisely,
    but they agree on these key features: self-similarity (the way smaller parts of
    a fractal echo the whole) and the ability to scale ad infinitum.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use Kotlin to draw a variety of fractals and explore
    their enigmatic beauty. Our main goal will be to codify the mathematical logic
    embedded in the design of each fractal, re-create those fractals, and possibly
    discover new ones by playing with the design parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '### The Concept of Fractals'
  prefs: []
  type: TYPE_NORMAL
- en: The notion of fractals is full of dualisms and contradictions. Benoit Mandelbrot,
    considered the father of fractal geometry, coined the term *fractal* from the
    Latin word *fractus*, meaning fractured or broken, yet detailed images of fractals
    are hardly fractured, instead showing a continuous flow of intricate patterns.
    Well-known fractals such as the Julia set and the Mandelbrot set display extremely
    complex patterns, yet the equations that generate those patterns are very simple.
    The fact that a fractal map contains an infinite amount of information that can
    be condensed into a single equation is a major discovery of the 20th century,
    a wonder that reveals the hidden beauty of mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: Fractals aren’t just exotic mathematical objects, however. They help us see
    the “geometry of nature,” a term popularized by Mandelbrot. Indeed, fractal patterns
    are abundant throughout nature, seen in snowflakes, the branching of trees, the
    human nervous and circulatory systems, coastlines, clouds, hurricanes, and the
    spiral shapes of galaxies. The theory of fractals also has found applications
    in the physical and biological sciences, engineering, and information technology
    and given birth to new areas of research, such as chaos theory and its application
    in studying complex dynamic systems.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start coding, let’s review a simple fractal to explore a couple of
    its key features. [Figure 6-1](chapter6.xhtml#fig6-1) shows the Sierpiński triangle,
    a geometric fractal named after the famous Polish mathematician Wacław Sierpiński,
    who created it in 1915\. This fractal is constructed by repeatedly connecting
    the midpoints of the three sides of an equilateral triangle and all the resulting
    subtriangles.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: The Sierpiński triangle'
  prefs: []
  type: TYPE_NORMAL
- en: 'The inherent beauty of this fractal derives from its self-similarity: look
    at any of the smaller triangles inside the outermost triangle and you’ll see a
    mini version of the original figure. Moreover, if we amplify or scale up one of
    the smaller triangles, we’ll find many more of the same inside it. For example,
    [Figure 6-2](chapter6.xhtml#fig6-2) shows a zoomed-in view of just the triangle
    formed by points A, D, and E from [Figure 6-1](chapter6.xhtml#fig6-1). The result
    is the same as the original triangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: A zoomed-in section of the Sierpiński triangle, illustrating the
    fractal’s ability to scale'
  prefs: []
  type: TYPE_NORMAL
- en: No theoretical limit is placed on how deep we can go—even the smallest triangle
    from the original figure, when amplified, produces the same result. A fractal
    can scale up forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fractals also have an interesting property called *fractal dimension*. Unlike
    familiar geometric objects such as lines, areas, and volumes that have one, two,
    and three dimensions, respectively, a fractal can have a fractional number of
    dimensions. The Sierpiński triangle, for example, has 1.585 dimensions: it’s more
    than a one-dimensional line but less than a two-dimensional area. This is because
    it fits in a 2D plane but doesn’t completely fill the area that defines the fractal
    boundary. You can find a more formal and in-depth discussion of this topic in
    many of the excellent resources listed at the end of the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most efficient way to draw a self-similar pattern that can theoretically
    keep repeating itself forever is to use a *recursive function*. This is a function
    that continues to call itself from within its own function body until a stopping
    condition is met. Once we identify the basic building block of a fractal, we can
    write a function to draw that building block and then let the function repeatedly
    call itself, until the fractal pattern is sufficiently developed. In the sections
    that follow, we’ll use this approach to generate several well-known geometric
    fractals, including the Sierpiński triangle, the Sierpiński carpet, and a fractal
    tree. But first, let’s get a feel for how recursion works by writing a function
    to calculate the factorial of an arbitrary positive integer *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The factorial of a number *n* is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*  n*! = *n* × (*n* – 1) × (*n* – 2) × ... × 3 × 2 × 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, *n*! equals the product of all integers from 1 to *n*. For
    example, 3! = 3 × 2 × 1 = 6, 4! = 4 × 3 × 2 × 1 = 24, and so on (by convention,
    1! = 1). Thinking recursively, we can also define the factorial of *n* as the
    product of *n* and the factorial of the next smaller integer (*n* – 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '*  n*! = *n* × (*n* – 1)!'
  prefs: []
  type: TYPE_NORMAL
- en: Using this modified form of the equation, we can write a recursive function
    to calculate the factorial of *n*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Something interesting is happening here. The function getFactorial(n) calls
    itself from inside the function body ❶ and thus kicks off a loop that runs until
    the most recent value of n equals 1. At that point, the last call to the function
    returns 1 and the loop terminates, returning the value of the factorial.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-1](chapter6.xhtml#tab6-1) shows how the key function parameters change
    at each iteration, leading to the factorial value in the end.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Anatomy of the Recursive Function getFactorial(n) for n = 5'
  prefs: []
  type: TYPE_NORMAL
- en: '| Iteration | Argument (n) | Test (n == 1) | Returned value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 5 | False | 5 × getFactorial(4) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 4 | False | 5 × 4 × getFactorial(3) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | False | 5 × 4 × 3 × getFactorial(2) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2 | False | 5 × 4 × 3 × 2 × getFactorial(1) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1 | True | 5 × 4 × 3 × 2 × 1 = 120 |'
  prefs: []
  type: TYPE_TB
- en: Notice that a recursive function is essentially a loop that keeps on calling
    itself. We must therefore provide a stopping condition (in this case, n <= 1).
    Without one, the function will be trapped in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be obvious just yet, but recursive functions can make coding significantly
    simpler (the alternative would be to use complex nested loops). This becomes especially
    true when the recursive function needs to make multiple calls to itself, using
    different state variables. We’ll see this idea in the upcoming projects.
  prefs: []
  type: TYPE_NORMAL
- en: '*Tail recursion* is a technique in which a recursive function implements tail
    call optimization (TCO). This allows the compiler to avoid consuming additional
    *stack space* (a region in memory that stores information in a last-in, first-out
    order) for each recursive call. Instead, the compiler reuses the same stack space
    for each call, which can help prevent stack overflow errors.'
  prefs: []
  type: TYPE_NORMAL
- en: To use tail recursion in Kotlin, the recursive call must be the very last call
    of the method. This means that the function must return the result of the recursive
    call directly, without performing any additional operations on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of an alternative version of the code that calculates the
    factorial of a number by using tail recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, the main() function remains unchanged, but the getFactorial()
    function has been modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the getFactorial() function is defined with the tailrec keyword
    ❶, which indicates that it should be optimized for tail call recursion. The function
    takes two arguments: n, which is the number whose factorial will be calculated,
    and result, which is the current result of the calculation. If n is 0 or 1, the
    function returns result. Otherwise, it calls itself recursively with n - 1 as
    the new value of n and n * result as the new value of result. This continues until
    n is 0 or 1, at which point the final result is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: For large numbers (n), this implementation not only saves memory but may also
    require less time to complete the computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 22: The “Hello, World!” of Fractals'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first foray into the world of fractals will be a simple one: we’ll write
    a recursive function to draw a series of concentric squares, each one smaller
    than and located symmetrically inside the previous one. We’ll visualize the fractal
    by using the canvas feature of JavaFX.'
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The JavaFX canvas allows us to draw a polygon based on the coordinates of its
    vertices. We need a way to calculate the four vertices of a square, given the
    x- and y-coordinates of one of the vertices and the length of any side (for a
    square, they’re all equal). We’ll use the scheme outlined in [Figure 6-3](chapter6.xhtml#fig6-3).
    Keep in mind that the default origin (0, 0) of the canvas is located at the top-left
    corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: The strategy for drawing concentric squares'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by choosing the coordinates for the top-left vertex of the outermost
    square, *x* and *y*. Given those, calculating the square’s other coordinates is
    simply a matter of adding the side length *s* as appropriate. This gives us everything
    we need to draw the outermost square.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll call a recursive function to draw the inner square or squares by
    using the following function parameters: the x- and y-coordinates for the top-left
    vertex of the most recently drawn square; the side length of that square, *s*;
    and a shrinkage factor, *k* (a percentage setting how much smaller the sides of
    the next square should be). We’ll use this information to calculate *d* in [Figure
    6-3](chapter6.xhtml#fig6-3), the distance from the top of one square to the top
    of the next, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*  d* = *ks/*2'
  prefs: []
  type: TYPE_NORMAL
- en: 'That in turn will let us update the top-left coordinates and the side length
    of the next square as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*  x* = *x* + *d*'
  prefs: []
  type: TYPE_NORMAL
- en: '*  y* = *y* + *d*'
  prefs: []
  type: TYPE_NORMAL
- en: '*  s* = *s* – 2*d*'
  prefs: []
  type: TYPE_NORMAL
- en: To prevent our recursive function from devolving into an infinite loop, we’ll
    provide a stopping condition in the form of a global constant limiting the number
    of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Following the steps we just discussed, we first create the required variables
    and draw the outer square.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code places the top-left corner of the outer square at (50, 50) relative
    to the origin and sizes the square to 400×400\. (The canvas itself is 500×500,
    as we’ll see later.) At each iteration, the sides of the inner square will be
    reduced by 15 percent ❶; feel free to play with this value. The squares will be
    drawn in black, as specified by Color.BLACK, on a white background (the default).
    Calling gc.strokePolygon() draws a square ❷ (gc is the GraphicsContext object
    needed to draw to the canvas). This method requires that the coordinates of the
    vertices be passed in two separate DoubleArrays, one for the x-values and one
    for the y-values; the last parameter indicates the number of vertices—in this
    case, for a square, four.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s implement our recursive drawSquares() function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The algorithm starts by checking the stopping condition: if iter, which has
    an initial value of 1 and is incremented by 1 per recursion, exceeds the maximum
    number of iterations set by ITER_MAX, then the loop will stop drawing squares
    on the canvas, and the program will terminate normally. Otherwise, we calculate
    a new set of parameters and proceed to draw another square. Notice that we used
    an underscore as a prefix for the x- and y-coordinates of the top-left vertex,
    as well as for the length of the side, while receiving parameter values. This
    naming convention allows us to use the same variable names inside the function
    as we did outside in the application class.'
  prefs: []
  type: TYPE_NORMAL
- en: We then recursively call the drawSquares() function with the updated parameter
    values to draw the next inner square ❶. [Figure 6-4](chapter6.xhtml#fig6-4) shows
    the program output with an ITER_MAX value of 22, which means that 22 squares are
    inside the outermost square.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: A simple fractal made from concentric, nonrotating squares'
  prefs: []
  type: TYPE_NORMAL
- en: Our concentric squares are a simple example of a geometric fractal. It exhibits
    self-similarity in that if we removed a few of the outer squares, the resulting
    image, when scaled up, would look the same, even if we iterated many more times.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the complete code for the app, including the boilerplate JavaFX components
    adapted for Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By introducing minor variations to this code, you can create other, similar
    geometric fractals, such as concentric rectangles or circles. Before you attempt
    the practice exercise, I encourage you to experiment with these variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 23: Draw the Sierpiński Triangle'
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we’ll draw the Sierpiński triangle (see [Figure 6-1](chapter6.xhtml#fig6-1))
    using an approach similar to [Project 22](chapter6.xhtml#pre-22). First, we’ll
    identify the defining features of the fractal, including its geometric properties,
    and then write a recursive function to do most of the hard work. We’ll use the
    same JavaFX template we used for [Project 22](chapter6.xhtml#pre-22) to create
    the graphical output.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the Sierpiński triangle is made by taking a triangle and joining
    the midpoints of its sides, producing three child triangles, then joining the
    midpoints of the child triangles’ sides, and so on, recursively, ad infinitum.
    Typically, the triangles are equilateral, meaning they have three equal sides
    and internal angles of 60 degrees. We’ll make use of these basic properties to
    come up with an efficient strategy for creating the fractal. However, working
    with equilateral triangles isn’t strictly required; you can use the steps outlined
    in this section to create an isosceles Sierpiński triangle, with minor adjustments
    to the code.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To draw the Sierpiński triangle, we need a few key parameters: the x- and y-coordinates
    of the parent (outermost) triangle’s top vertex, where the two inclined sides
    meet, and the parent triangle’s base (*b*) and height (*h*). [Figure 6-5](chapter6.xhtml#fig6-5)
    shows these parameters, including some additional ones for the child triangles
    that will be used in our code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: The strategy for drawing the Sierpiński triangle'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first draw the parent triangle, as we did for the concentric squares example.
    We’ll then call a recursive function to connect the midpoints of the triangle’s
    three sides, whose coordinates are calculated in terms of the parent triangle’s
    base, height, and top vertex. Since this creates three smaller child triangles
    (as opposed to one smaller square), the recursive function will have to call itself
    multiple times, once for each of the child triangles ❶ ❷ ❸. We’ll keep using recursion
    until a stopping condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: '#### The Code'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss the code in three parts. First, we’ll import the required math
    functions and declare some global parameters and a data class (we’ll reuse the
    rest of the JavaFX-specific codes from [Project 22](chapter6.xhtml#pre-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first global parameter, BASE, represents the base of the parent (outer)
    triangle, which is set to 500\. The second parameter, DEPTH, is the number of
    iterations (how many times inner triangles are drawn), but we use it only to calculate
    our real stopping condition, baseMin. This is the smallest base length of the
    inner triangles when we stop recursion. It’s more practical to think in terms
    of a minimum side length because how small an object we can draw is limited by
    the pixel size of the screen, as well as by our ability to see small objects.
    It wouldn’t make sense to let the recursion run an arbitrary number of times (say,
    50 or 100 times) while creating a static image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The baseMin parameter is linked to the number of iterations DEPTH as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ ![](../images/pg236-1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: This means baseMin decreases exponentially as DEPTH increases, which is why
    just 5 to 10 iterations can be adequate for bringing out the key features of simple
    geometric fractals. In this case, since we’re using a DEPTH value of 7 and a BASE
    of 500, baseMin will be 3.906.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the data class Vertices to store and return the vertices of internal
    triangles, with the help of the getVertices() function (which we’ll discuss shortly).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a look at the problem-specific code segment that defines and
    draws the parent triangle. The top vertex is set to (300.0, 50.0), and the base
    *b* and height *h* are set to be 500.0 and 500 sin(*θ*), respectively, where *θ*
    is π/3 radians (or 60 degrees).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We draw the parent triangle with a call to the gc.strokePolygon() function,
    passing the x- and y-coordinates of the three vertices and the number of vertices
    (in this case, three). We then make a single call to the recursive function drawTriangle()
    to generate the child triangles. Notice we’re following the same basic steps we
    used in [Project 22](chapter6.xhtml#pre-22) to draw the concentric squares.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll define our recursive function to draw the inner triangles. We’ll
    also define a helper function for calculating the midpoints of a triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our drawTriangle() function follows a similar pattern to our drawSquares() function
    from [Project 22](chapter6.xhtml#pre-22), but a couple of important differences
    exist. First, the stopping condition is now set with respect to baseMin ❶ instead
    of the maximum number of iterations (we’ve already discussed why that is the case).
    Second, we make three separate recursive calls inside the drawTriangle() function
    (instead of a single recursive call as in the previous project) to make sure that
    all three child triangles generated at each step contribute to creating the final
    fractal image. To see how this works, have a look at [Figure 6-6](chapter6.xhtml#fig6-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: Evolution of the Sierpiński triangle with recursive calls (n =
    7)'
  prefs: []
  type: TYPE_NORMAL
- en: If we made only the first recursive call ❷ from inside the drawTriangle() function,
    the final figure will subdivide only the top child triangles, as shown on the
    left side of [Figure 6-6](chapter6.xhtml#fig6-6). The center image shows what
    would happen if we made two recursive calls ❷ ❸; now the top and left child triangles
    are subdivided. Finally, the image on the right is what we want—the complete Sierpiński
    triangle, created by making three back-to-back recursive calls to the drawTriangle()
    function, ❷ ❸ ❹, with updated parameter values for the child triangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 24: Create a Fractal Tree'
  prefs: []
  type: TYPE_NORMAL
- en: As the final project on simple geometric fractals, we’ll draw a beautiful fractal
    tree. The tree will start as a single line (the trunk) that splits into two branches.
    Then each branch will itself split into two more branches, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The core strategy for this project is straightforward: draw a line, then recursively
    draw two more lines from the endpoint of that line, each at an angle relative
    to the parent line. [Figure 6-7](chapter6.xhtml#fig6-7) outlines the strategy
    and the features we’ll have to incorporate into the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: The strategy for drawing the fractal tree'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll choose a starting point (*x1*, *y1*) for the parent line, a length
    *l*, and *θ*, the parent line’s angle with respect to the x-axis. Using trigonometry,
    we calculate the coordinates for the endpoint of the parent line (which is also
    the starting point of the two child lines) as *x1* + *l* cos(*θ*) and *y1* + *l*
    sin(*θ*). The child lines are shorter than the parent line (we’ll choose a shrinkage
    factor) and branch out from the parent line by some arbitrary angle *φ*, such
    that the new lines will be drawn at angles (*θ* + *φ*) and (*θ* – *φ*) relative
    to the x-axis, respectively. Keep calculating endpoints, drawing new lines, and
    branching out until a stopping condition is met (for example, when the new branches
    become too small).
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this example, we do not have any global variables or parameters, and the
    import block for math functions looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Hence, the first code snippet we’ll discuss covers the problem-specific parameter
    values within the application class and the call to the recursive function drawTree().
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We center the starting point of the parent line horizontally on the canvas and
    place it 100 pixels above the bottom (we’re assuming a canvas size of 600×600).
    The starting angle (angle) of –π/2 draws the tree in an upright position. We set
    the branch-out angle of the child lines relative to the parent line, *φ* (phi),
    to π/10, which produces optimal branching for the given parameters. Unlike in
    our previous fractal projects, we haven’t drawn anything yet. This time, the parent
    line is drawn inside the recursive function, since it uses the same code as drawing
    the child lines. We’ll define that function next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The termination condition stops recursion when the len parameter passed into
    the function becomes less than or equal to 10 ❶. At each iteration, we calculate
    the endpoint of the current line and draw it with the gc.strokeLine() function.
    We then make two recursive calls ❷ ❸, reducing the length of the child lines by
    four pixels (approximately 7 percent of the original parent line length). When
    the stopping condition is met, instead of terminating the drawTree() function
    immediately, the app draws small circles at the end of all final child lines.
    With a proper selection of colors, the result can resemble a blossoming cherry
    tree. The grayscale version of this tree is shown in [Figure 6-8](chapter6.xhtml#fig6-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-8: A blossoming fractal tree'
  prefs: []
  type: TYPE_NORMAL
- en: For all the fractal projects we’ve worked on so far, and for this project in
    particular, the parameter values you choose will have a significant effect on
    the final appearance of the image. If you copy the parameter values verbatim from
    the book’s code snippets, you’ll be able to reproduce the exact same figures presented
    in this chapter. However, there are numerous possible combinations of parameter
    values you could use. I encourage you to play with the parameters; who knows,
    you might discover a whole new fractal family that no one has seen yet!
  prefs: []
  type: TYPE_NORMAL
- en: The L-System and Turtle Graphics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Closely related to fractals is the *L-system*, a technique for generating complex
    strings of characters over a series of iterative steps. The characters are then
    interpreted as different geometric operations, such as drawing lines or turning
    left or right. The L-system was introduced by Aristid Lindenmayer, a Hungarian
    biologist, in 1968 to study the development of simple organisms and model plant
    morphology and growth. Lindenmayer proposed that plant development over time can
    be described by “natural” algorithms that are responsible for the geometric features
    seen in the arrangements of branches, leaves, petals, and flowers. (We’ll discuss
    several other nature-inspired algorithms in [Chapters 8](chapter8.xhtml) and [9](chapter9.xhtml).)
    Another feature of plant growth (incorporated in the L-system) that researchers
    were quick to notice was the prevalence of self-similarity—the same pattern being
    replicated at different scales. No wonder the L-system was soon picked up by mathematicians
    and computer scientists to study and visualize the beautiful geometry of nature
    that Mandelbrot succinctly called fractals.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll study the components of an L-system and develop our own
    L-system simulator in Kotlin. We’ll also learn about Turtle Graphics, a common
    computer programming model used for visualizing the shapes and patterns created
    by L-systems. Since Kotlin’s standard library doesn’t include a Turtle Graphics
    package, we’ll combine JavaFX canvas with Kotlin to create our own Turtle class.
  prefs: []
  type: TYPE_NORMAL
- en: Formalizing the L-System
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An L-system requires a few ingredients to generate a string of characters interpretable
    as geometric instructions for drawing fractal objects: an alphabet, an axiom,
    a set of rules, and a depth. The *alphabet* is the set of characters that are
    available for use in the string, each with an associated meaning. For example,
    F might signify drawing a line, + might signify turning right, and so on (we’ll
    define our full alphabet later). The *axiom* is an initial sequence of characters
    that the L-system starts from, and the *rules* establish techniques for transforming
    the axiom (or subsequent strings) over a series of iterations. When there are
    multiple rules, they’re applied in sequence, and the substrings created by each
    rule are concatenated in the same order to form the new string. The depth sets
    the number of iterations over which to apply the rules before you arrive at the
    final string. [Table 6-2](chapter6.xhtml#tab6-2) summarizes the components of
    an L-system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-2: L-System Components'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Function | Example | Interpretation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Alphabet | A set of allowable characters | F, G, J, +, -, [,], X | See [Table
    6-3](chapter6.xhtml#tab6-3). |'
  prefs: []
  type: TYPE_TB
- en: '| Axiom | An initial set of characters to start off production (to apply the
    rules recursively) | F++F | Move forward from the current position, turn right
    by a specified angle twice, and move forward again. |'
  prefs: []
  type: TYPE_TB
- en: '| Rules | Directions on how to create a new string from a given axiom or string
    | F -> F-F++F-F | Replace every instance of F in a string with the set of characters
    that follow the arrow (->); add other characters not specified in the rule as
    is. |'
  prefs: []
  type: TYPE_TB
- en: '| Depth | The number of times the rules are applied (axiom is assumed to have
    a depth of zero) | 5 | Apply the rules five times before creating the corresponding
    figure. |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the components mentioned in [Table 6-2](chapter6.xhtml#tab6-2),
    we need to set two other parameters: the length of the lines to be drawn (or the
    distance to jump over without drawing a line) and the angle of rotation. Typically,
    the length decreases with each iteration because the larger (outer) elements of
    a fractal are often drawn first, followed by finer (inner) elements. Reducing
    the length may also be required to limit the size of the final figure. The angle
    of rotation *θ* for a particular fractal remains constant throughout the process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example to illustrate how to use L-system notations
    and procedures: drawing a triangle. For this exercise, the L-system parameters
    and associated steps are outlined in [Figure 6-9](chapter6.xhtml#fig6-9).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-9: The L-system for drawing an equilateral triangle'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start at (*x1*, *y1*) on the canvas, facing in the positive x-axis direction,
    at angle 0 relative to the x-axis. Our axiom is just a single character, F, and
    our rule, F -> F++F++F, tells us that with each iteration we should replace any
    instance of the character F with the string F++F++F. After applying the rule for
    a depth of 1 (meaning apply the rule only once to the axiom before stopping),
    we have our final string: F++F++F.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now follow this string of instructions: from our initial position, move
    forward (F) a specified length, *l*, to arrive at (*x2*, *y2*), then perform two
    right turns (++), each by a specified angle, *θ*, and move forward (F) again to
    arrive at (*x3*, *y3*). Finally, take two more right turns (++) and move forward
    (F), which brings us back to the starting point and completes the triangle. Each
    time we move forward from one point to another, we trace the path (connect the
    two points) with a line.'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing L-System Patterns with Turtle Graphics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Turtle Graphics is a drawing system that imagines a turtle moving around a
    graphics window. The turtle has at least two properties: its location in terms
    of x- and y-coordinates and its orientation measured by an angle relative to the
    positive direction of the x-axis. The turtle drags around a pen. When the pen
    is down, it draws lines on the window as the turtle moves; when the pen is up,
    the turtle moves without tracing its path.'
  prefs: []
  type: TYPE_NORMAL
- en: Turtle Graphics was originally part of an educational programming language called
    Logo, but the idea has also been implemented in other languages, including Python.
    It’s used to teach concepts related to programming and the movement and animation
    of simple objects in a graphics window. It can also be used creatively to teach
    Euclidian geometry and to generate interesting patterns through recursion. Perhaps
    the most well-known application of Turtle Graphics in research is for visualizing
    the strings of instructions created by L-systems of geometric fractals.
  prefs: []
  type: TYPE_NORMAL
- en: When a language has built-in support for Turtle Graphics, we only need to import
    the relevant package or class and make use of its methods or functions to move
    the turtle around and draw lines, shapes, and patterns. Since the Kotlin standard
    library doesn’t include a Turtle package, we’ll develop a simple Turtle class
    that will work seamlessly with the Canvas object of JavaFX and deliver the same
    functionality. The broader goal of this exercise is to build a minimalist L-system
    simulator capable of generating L-system strings of arbitrary depth and realizing
    them with the help of the Turtle class to produce well-known geometric fractals.
    [Table 6-3](chapter6.xhtml#tab6-3) shows the L-system notations (characters) we’ll
    work with and the corresponding Turtle class methods that we’ll need to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-3: L-System Characters and Turtle Graphics Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Character(s) | Desired action | Turtle command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| F, G | Move the turtle forward, and draw a line to connect old and new positions.
    Though F and G have identical actions, rules may not apply the same way to F and
    G. | turtle.lineTo() |'
  prefs: []
  type: TYPE_TB
- en: '| J | Jump forward to a new position without drawing a line. | turtle.moveTo()
    |'
  prefs: []
  type: TYPE_TB
- en: '| + | Turn the turtle to the right by a specified angle. | turtle.turnRight()
    |'
  prefs: []
  type: TYPE_TB
- en: '| - | Turn the turtle to the left by a specified angle. | turtle.turnLeft()
    |'
  prefs: []
  type: TYPE_TB
- en: '| [ | Push (save) the turtle’s current state (location, angle) to the stack.
    | turtle.push() |'
  prefs: []
  type: TYPE_TB
- en: '| ] | Pull the last saved state from the stack (while also removing it from
    the stack) and set that as the turtle’s current state. | turtle.pop() |'
  prefs: []
  type: TYPE_TB
- en: '| X | Do nothing. Skip to the next instruction. | No turtle call |'
  prefs: []
  type: TYPE_TB
- en: While drawing complex shapes, the L-system strings may require the turtle to
    branch out in different directions from a base location. For this, the turtle
    needs to save its current state so it can later return to the base and choose
    another direction. The push() method helps with saving the current state, while
    the pull() method retrieves a saved state so that the turtle can start a new branch
    from there. These methods will rely on a *stack*, a data structure where the most
    recent item added is the first to be retrieved, commonly called last in, first
    out (LIFO). This way, the turtle will return to more recent states first, to complete
    subbranches, before returning to earlier saved states to start drawing new main
    branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 25: Design an L-System Simulator'
  prefs: []
  type: TYPE_NORMAL
- en: An L-system simulator is made up of several functions or classes that help interpret
    L-system rules, generate the final string of instructions, and draw the resulting
    image on a graphics window. Ideally, these components would be coded in a problem-independent
    manner, with some mechanism for the user to input the initial parameters for the
    L-system, perhaps through a file or at the command line. For simplicity’s sake,
    we’ll instead embed these parameters into the code itself, using values that will
    generate a snowflake pattern, but the rest of the code will be generic. All you’ll
    have to do is update these problem-specific parameters to simulate different L-system
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll begin our L-system simulator code with some global declarations to keep
    our data organized, then define the problem-specific parameters for generating
    a particular L-system object. Next, we’ll declare some helper functions to generate
    the L-system string based on rules and draw the final L-system string on the canvas.
    We’ll also declare our Turtle class with methods for rendering the image and then
    tie everything together with an LSystemApp class.
  prefs: []
  type: TYPE_NORMAL
- en: Global Declarations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll start by declaring two data classes to organize L-system data, plus a
    special array type to create the stack functionality required for the push() and
    pull() methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Rule data class will define each L-system rule by using the key and apply
    members, both of type String. The key property will hold the character that will
    be replaced if present when a rule is applied, and the apply property will hold
    the string that will replace the key. For example, for a rule F -> F++F++F, the
    values of key and apply would be F and F++F++F, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The second data class, State, saves the state of the turtle—specifically, its
    x- and y-coordinates and the direction it’s facing relative to the x-axis. Finally,
    stack is declared by using Kotlin’s ArrayDeque class, which implements a resizable
    (mutable) array of the deque (short for *double-ended queue*) data structure.
    This class has methods to facilitate the LIFO feature of the stack. The array’s
    members will be of our custom State data type.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Problem Definition'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll declare the problem-specific parameters of an L-system, including
    its axiom and rules. The parameters we’re using here will generate a simple fractal
    pattern that looks like a snowflake. Feel free to replace them with parameters
    for other well-known L-systems or to experiment with your own.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the axiom, or starting string, for a snowflake fractal ❶. Earlier,
    we used this same string, F++F++F, to draw an equilateral triangle. We then create
    a list of type Rule called rules, where we keep all the rules pertaining to the
    L-system ❷. The snowflake requires only a single rule, but the comments inside
    listOf() show how to add more rules if needed. We set the initial value of line
    to 100 pixels based on a canvas size of 600×600, but the line length will shrink
    by one-third with each iteration. We also set the turning angle, ANGLE, to 60
    degrees and the number of iterations, depth, to 5.
  prefs: []
  type: TYPE_NORMAL
- en: We only need to create a single instance of the Turtle class ❸. We set its initial
    position to (150.0, 200.0), with an initial angle of 0.0 (facing toward the positive
    x-direction). Notice that as the turtle begins to move, both its location and
    its orientation (angle) may change. Finally, we set finalString to an empty string
    at the start; its content will change after each iteration, and only the final
    value will be used to draw the fractal.
  prefs: []
  type: TYPE_NORMAL
- en: The generate() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The generate() function is a core component of the simulator. It executes the
    L-system rules for a given axiom and depth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We first declare an empty string called nextString, where we’ll save interim
    values of the final string. We then use two for loops to iterate one character
    at a time through the most recent version of finalString ❶ and apply any relevant
    rules to that character ❷. The Boolean variable match tracks if a particular rule
    should be applied. When a selected character matches the key of the current rule
    ❸, we set match to true and add the replacement string specified by the apply
    element of the rule to nextString. This is followed by the break statement to
    break out of the inner for loop (only one rule will be applicable to a character
    for each iteration of the outer for loop). If none of the rules apply, we add
    the current character to nextString unchanged ❹. Once we’ve iterated over all
    the characters in finalString, we reset its value to nextString ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The draw() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The draw() function draws the final image on the canvas by reading the characters
    in finalString and making corresponding calls to the methods of our Turtle class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We elegantly implement the drawing process inside a single for loop ❶ and a
    compact when block ❷, which is much less verbose than a traditional multilevel
    if...else block. The for loop scans the characters of the variable finalString
    one at a time and passes them to the when block as letter. Next, we conduct a
    series of tests until a match is found with one of the possible L-system codes.
    Based on the match, we call the related Turtle method to draw or move on the canvas.
    For example, we match characters F and G to the lineTo() method and J to the moveTo()
    method. Notice that different method calls require different parameters, and the
    last three calls inside the when block don’t require any! We’ll see what happens
    when those methods are called next.
  prefs: []
  type: TYPE_NORMAL
- en: The Turtle Class and Its Methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now we’ll implement our Turtle class, where all the methods for carrying out
    the final drawing live. To keep the main body of our L-system application short
    and tidy, we’ll declare this class in a separate file called *Turtle.kt*. We begin
    the file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The import block gives us access to the required JavaFX and Kotlin library
    components. The primary class constructor, which is part of the class header ❶,
    creates an instance of the Turtle class using three values: the turtle’s starting
    x- and y-coordinates and its initial orientation (angle of the turtle). We set
    the first two parameters as var because their values will be updated each time
    the turtle moves or changes its direction. We keep the third parameter angle as
    val (not explicitly declared but implied), which is used to define a mutable property,
    angleRad.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the class body defines the seven different methods that can be called
    to perform different Turtle object tasks. See [Table 6-3](chapter6.xhtml#tab6-3)
    for a summary of these methods and their corresponding L-system characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The lineTo() method is the only one that actually draws anything on the canvas.
    It draws a straight line of length line, based on the same sine and cosine calculations
    we used to draw segments of the fractal tree in [Project 24](chapter6.xhtml#pre-24).
    All the other methods either move the turtle without drawing a line, change its
    direction, or save or restore its state. The final method simply prints the current
    state of the turtle, which is useful for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The push() and pop() methods rely on methods of the ArrayDeque class, which
    we used to implement our stack. The push() method calls the addLast() function,
    while pop() calls the removeLast() function to add or remove an item to the end
    of the stack array, enforcing the LIFO rule. In both cases, we encapsulate the
    state information by using our custom State data class.
  prefs: []
  type: TYPE_NORMAL
- en: The LSystemApp Class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, we’ll bring the different components of the L-system simulator together
    to form a complete application, organized around an LSystemApp class. The following
    listing shows the full body of this class, as well as the main() function. The
    listing also shows where all the other components we discussed earlier fit (except
    for the Turtle class, which is in a separate file).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Other than the generate() and draw() functions, much of the LSystemApp consists
    of the boilerplate JavaFX code. What’s different this time is the addition of
    a couple of extra lines that relocate the origin of the canvas to the bottom-left
    corner ❶ and let the positive direction of the y-axis point upward ❷. These simple
    changes make testing previously published L-systems that provide axioms, rules,
    and initial conditions for many well-known fractals very convenient. Published
    L-system parameters are almost always based on the assumption that we draw the
    resulting fractals in the first quadrant of the coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: The code managing the L-system revolves around an if block that checks if depth
    is greater than 0 ❸. If not, we simply draw the axiom itself, without applying
    any rules. Otherwise, we call the generate() function depth times to apply the
    rules over the appropriate number of iterations. We then use the final content
    of finalString to draw the fractal. Notice that we set the length of the lines
    to be drawn based on depth ❹. This dynamic adjustment allows us to keep the size
    of the fractal limited to the size of the canvas. If you prefer to use a larger
    or smaller canvas size (we’re using 600×600), you may have to adjust the initial
    line length, as well as the initial position of the turtle.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re now ready to put our brand-new L-system simulator to the test. Since we’ve
    already included problem-specific parameters for a snowflake fractal, we can run
    the simulator with different depths to see how the image gets more complex and
    manifests self-similar patterns as the depth increases. [Figure 6-10](chapter6.xhtml#fig6-10)
    shows the evolution of the snowflake for depths 1, 3, and 5.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-10: The evolution of a snowflake, using the L-system simulator'
  prefs: []
  type: TYPE_NORMAL
- en: Researchers have developed so many interesting L-systems over the years that
    you could spend days playing with those systems in your simulator and looking
    at the intriguing patterns they generate. For example, [Table 6-4](chapter6.xhtml#tab6-4)
    lists the L-system parameters necessary for creating three more fractals with
    different features. Some of these incorporate a wider range of symbols, and they
    all involve multiple rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-4: Additional L-System Examples'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Fractal name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sierpiński triangle | Pattern with rectangles | Fractal plant |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Axiom | F+G+G | F-F-F-F | X |'
  prefs: []
  type: TYPE_TB
- en: '| Rules | F -> F+G-F-G+F G -> GG | F -> F-J+FF-F-FF-FJ-FF+J-FF+F+FF+FJ+FFF
    J -> JJJJJJ | X -> F+[[X]-X]-F[-FX]+X F -> FF |'
  prefs: []
  type: TYPE_TB
- en: '| Line | +150.0 | +15.0 | +20.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Scaling | 0.5 | 0.5 | 0.7 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle | 120 | 90 | 25 |'
  prefs: []
  type: TYPE_TB
- en: '| Depth | 6 | 2 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| Turtle | 150.0, 200.0, 0.0 | 150.0, 450.0, 0.0 | 100.0, 50.0, 65.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Canvas | 600.0×600.0 | 600.0×600.0 | 600.0×600.0 |'
  prefs: []
  type: TYPE_TB
- en: The first set of parameters in [Table 6-4](chapter6.xhtml#tab6-4) will create
    the familiar Sierpiński triangle. The second set, with a depth of only two, is
    for a geometric pattern that involves drawing multiple unconnected rectangles
    (see [Figure 6-11](chapter6.xhtml#fig6-11), left). The third set is for a fractal
    plant, a popular object among fractal enthusiasts (see [Figure 6-11](chapter6.xhtml#fig6-11),
    right). It involves a number of push and pull operations ([and]) to keep track
    of the plant’s various branches.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-11: A rectangular pattern (left) and a fractal plant (right) generated
    by the L-system simulator'
  prefs: []
  type: TYPE_NORMAL
- en: You can extend the basic L-system simulator we’ve developed in this section
    to generate 3D fractals, such as a space-filling Hilbert curve. Check out the
    resources listed at the end of this chapter to learn more about those advanced
    implementations. The primary benefit of the L-system simulator, however, is that
    it allows you to experiment with your own axioms and rules. Perhaps you’ll come
    up with a brand-new fractal that no one has seen before and name it after yourself!
  prefs: []
  type: TYPE_NORMAL
- en: The Mighty Mandelbrot Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No discussion of fractals would be complete without examining the Mandelbrot
    set, or M-set, and appreciating its complexity and beauty. The M-set differs from
    the other fractals we’ve discussed so far in two important ways. First, it’s a
    nonlinear fractal, meaning its building blocks are made up of pixels organized
    in complex patterns instead of only straight lines. Second, it’s mapped on a complex
    plane, so it requires us to use complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The M-set hinges on the iterative properties of the deceptively simple quadratic
    function, shown in Equation 6.1.
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (6.1) ![](../images/eq6-1.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Here *c* is a constant. By “iterative properties,” I mean the way the value
    of *f*(*z*) changes if we start with some initial seed value for *z* and then
    recursively feed the value of the equation back into itself as the new *z* value.
    Equation 6.2 shows the recursive form of this function.
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (6.2) ![](../images/eq6-2.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: The list of numbers generated by repeated iterations of Equation 6.2, given
    a particular seed value *z*[0] and constant *c*, is known as the *orbit* of the
    function. [Table 6-5](chapter6.xhtml#tab6-5) shows the orbits for a few different
    (*z*[0], *c*) combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-5: Selected Orbits of Quadratic Function f(z) = z2 + c'
  prefs: []
  type: TYPE_NORMAL
- en: '| n (iteration) | Case 1: z0 = 0, c = 1 | Case 2: z0 = 0, c = –1 | Case 3:
    z0 = 0, c = –0.65 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | –1 | –0.65 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 0 | –0.22749999 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 5 | –1 | –0.59824375 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 26 | 0 | –0.29210441 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 677 | –1 | –0.56467501 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 458,330 | 0 | –0.33114213 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Very large number! | –1 | –0.54034488 |'
  prefs: []
  type: TYPE_TB
- en: 'Each case in [Table 6-5](chapter6.xhtml#tab6-5) uses a seed value of 0 but
    a different constant. Notice how minor variations in the value of the constant
    can set the orbit off on a completely different path. In general, the orbit will
    either diverge, meaning the function values will become increasingly large due
    to exponential growth (as in case 1), or remain bounded, such that the orbit values
    stay within a certain range. If the latter, several variations are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: The orbit cycles through a fixed set of values (as in case 2, where the cycle
    has a period of 2).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The orbit converges toward a fixed value; in case 3, the function value converges
    to –0.4486 after approximately 100 iterations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The orbit remains fixed on a single value (for example, when z[0] = 0 and c
    = 0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The orbit values remain bounded but behave chaotically, showing no apparent
    pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All this hidden complexity is governed by the constant *c* as it takes on different
    values. So far, however, we’ve used only real numbers as values of *c*. It’s time
    to introduce complex numbers into the mix—values of *c* that satisfy this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (6.3) ![](../images/eq6-3.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Here *x* and *y* are real numbers, and *i* is √–1\. [Table 6-6](chapter6.xhtml#tab6-6)
    shows a few examples of our quadratic function using complex values of *c*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-6: Selected Orbits of Quadratic Function f(z) = z2 + c, Where c = x
    + iy'
  prefs: []
  type: TYPE_NORMAL
- en: '| n (iteration) | Case 1: z0 = 0, c = 0 + i | Case 2: z0 = 0, c = 0 + 2i |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | i | 2i |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | –1 + i | –4 + 2i |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | –i | 12 – 14i |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | –1 + i | –52 – 334i |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | –i | –108,852 + 34,738i |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | –1 + i | Far away from (0, 0) |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | –i | Very far away from (0, 0) |'
  prefs: []
  type: TYPE_TB
- en: '| M-set membership | Member | Nonmember |'
  prefs: []
  type: TYPE_TB
- en: 'As with real values of *c*, complex values also produce two types of orbits:
    bounded (like case 1) or unbounded (like case 2). Given this, we’re now ready
    to define the Mandelbrot set as the set of all complex numbers *c* for which the
    corresponding orbit generated by recursive function *f*(*z*) = *z*² + *c* remains
    bounded, given a seed of *z*[0] = 0\. Thus, looking at [Table 6-6](chapter6.xhtml#tab6-6),
    *c* = 0 + *i* is a member of the Mandelbrot set, while *c* = 0 + 2*i* is not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We visualize the Mandelbrot set by plotting the set’s members on a *complex
    plane*, a coordinate system where the x-axis represents the real component of
    a complex number (*x* in Equation 6.3) and the y-axis represents the imaginary
    component (*y* in Equation 6.3). Given these x- and y-values, the magnitude of
    the orbit of a complex number is calculated as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (6.4) ![](../images/eq6-4.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: When a complex number is plotted as a point on the complex plane, the magnitude
    of the orbit would be the distance of that point from the origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 26: Code and Visualize the Mandelbrot Set'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s turn our attention to creating an app that will help us visualize the
    M-set. Our definition of the M-set provides some clues about what’s required:
    we need to find and plot the complex values of *c* that cause our quadratic function
    (Equation 6.1) to remain bounded as it iterates. However, we still need a few
    clarifications. First, what region of the complex plane should we investigate?
    It would help to know if the M-set members are clustered in a certain region or
    dispersed over a large area. Also, since the quadratic function can continue iterating
    ad infinitum, it isn’t clear when exactly we should conclude that an orbit is
    bounded or unbounded. We could limit ourselves to a certain number of iterations,
    consult the magnitude of the orbit as defined by Equation 6.4, or both.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, researchers have already uncovered helpful facts about the M-set
    that we can draw on to make our search efficient and practical. First, from numerous
    plots of the M-set already created, we know that the search space can be limited
    to an area bounded by [–2.0, 1.0] along the real axis (x-axis) and [–1.5, 1.5]
    along the imaginary axis (y-axis). Second, it’s also known that the M-set is a
    closed set entirely contained inside a circle of radius 2 around the origin. This
    means that a complex number *c* can’t be a member of the set if |*z*n| > 2 for
    any *n* > 0\. We’ll use this as a termination condition for the bounded/unbounded
    test. Otherwise, if we complete some threshold number of iterations (iterMax)
    without |*z*n| exceeding 2, we’ll consider *c* to be a member of the M-set.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll set iterMax to 400 for a relatively clean image of the M-set, but I encourage
    you to experiment by setting iterMax lower or higher. In general, lower iterMax
    values will likely show more noise as well as various zones of convergence. As
    the number of iterations increases (the test condition becomes more stringent),
    the fractal boundary tends to become crisper.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Despite the sophisticated nature of the concept, the code for creating the
    M-set is relatively minimal. The app we’ll create will have the following features
    and functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: The problem definition (done through a small number of global variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to iterate over the search space point by point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to check M-set membership conditions for each of those points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to draw the point on the canvas with a chosen color scheme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we’ll need to adjust the scale of the image to ensure that the
    search space is properly mapped onto a canvas of a given size.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Global Variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First, we’ll declare some global variables. This code segment defines the bounds
    for the real and imaginary axes, sets the canvas size, determines the search increment
    along the x- and y-axes, and limits the number of iterations for the quadratic
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We set xMin and xMax as the lower and upper bounds for the real values of *c*;
    similarly, yMin and yMax are the lower and upper bounds for the imaginary part
    of *c*. The corresponding ranges (xRange and yRange) define a rectangular search
    space we’ll explore to find potential M-set members.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the width of the canvas, canvasW, to 600 pixels and the height
    of the canvas, canvasH, to a value that will maintain the proportionality of the
    image (meaning that the M-set, when plotted, won’t look distorted). The benefit
    of this approach is that you only need to adjust canvasW if you want to create
    a larger or smaller image.
  prefs: []
  type: TYPE_NORMAL
- en: We set the last two parameters, increment and iterMax, to 0.003 and 400, respectively.
    These values will determine the overall image quality. It’s possible to link the
    increment parameter to canvasW and have it automatically calculated—you’re welcome
    to try that out as a simple experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Finding and Drawing M-Set Members
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll now declare a function to iterate over the search space, check whether
    a particular complex number *c* is within the M-set, and mark the corresponding
    points on the canvas by using a color scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The drawMSet() function uses a nested pair of while loops to iterate over the
    search space. The outer loop ❶ iterates along the y-axis, starting with the minimum
    y value, yMin, and ending when y reaches the upper bound, yMax, incrementing y
    by increment (which we set to 0.003) each time. The inner while loop ❷ does the
    same along the x-axis. With each iteration, we get an (*x, y*) pair representing
    a complex number (as defined by Equation 6.3), which we pass to the getConvergence()
    function ❸ to check if that number belongs to the M-set (we’ll look at that function
    next).
  prefs: []
  type: TYPE_NORMAL
- en: Calling getConvergence() returns the number of iterations of the quadratic function
    it carried out. We divide this by iterMax to measure how quickly the convergence
    decision was made ❹. If this resulting value (speed) is 1, the number of iterations
    must have been iterMax, indicating that the orbit of *c* remained bounded. Therefore,
    we’ll count this particular complex number as a member of the M-set. If speed
    is less than 1, however, that would mean the orbit jumped outside the circle of
    radius 2 before reaching the maximum number of iterations, so we won’t consider
    that number to be an M-set member.
  prefs: []
  type: TYPE_NORMAL
- en: We subtract speed from 1 and use the result (factor) to set the color of the
    corresponding point on the canvas, according to a grayscale scheme where (1, 1,
    1) means white and (0, 0, 0) means black. If the orbit diverged very quickly,
    factor will be close to 1, so the point on the canvas representing this number
    will be marked with a white or nearly white pixel. Conversely, if the orbit diverged
    only after many more iterations (but before reaching the maximum allowed), factor
    will be closer to 0, so the corresponding point would be marked with a darker
    pixel. Of course, if the orbit remains bounded, factor will be exactly 0, and
    the corresponding point will be marked with a pure black pixel, signifying that
    the point belongs to the M-set.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we plot the number by mapping its (*x*, *y*) coordinate pair onto a
    pixel location on the canvas ❺, using the scaling factor illustrated in [Figure
    6-12](chapter6.xhtml#fig6-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-12: Mapping the x-coordinate of c to the x-value of the pixel on the
    canvas'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using the proportionality rule to map the x-coordinate to a point on the
    canvas designated as *w*. We apply the same principle to the y-coordinate as well.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Convergence
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The getConvergence() function takes in an (*x*, *y*) pair as arguments and checks
    if the corresponding complex number belongs to the M-set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To follow the logic of the code, we need a bit of algebra. Recall from Equation
    6.2 that the recursive form of our quadratic function is *z*n = *z*²n [– 1] +
    *c*. For any value of *n* > 1, *z*n [– 1] will be a complex number that can be
    expressed as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (6.5) ![](../images/eq6-5.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'In Equation 6.5, *zx*n [– 1] is the real part of *z*n [– 1], and *zy*n [– 1]
    is the complex part. We can now rewrite Equation 6.2 by using Equations 6.3 and
    6.5\. After simplification, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (6.6) ![](../images/eq6-6.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Equation 6.6 can be further simplified as:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (6.7) ![](../images/eq6-7.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: where *X* = (*zx*²n [– 1] – *zy*²n [– 1] + *x*) and *Y* = (2*zx*n [– 1] *zy*n
    [– 1] + *y*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking back to Equation 6.4, we check if the magnitude of *z*n lies outside
    a circle of radius 2 by confirming whether:'
  prefs: []
  type: TYPE_NORMAL
- en: $Equation$ (6.8) ![](../images/eq6-8.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our code, we start by setting real and imaginary components zx
    and zy to 0, the equivalent of setting seed value *z*[0] to 0\. Next, the for
    loop ❶ iterates over Equation 6.7, calculating the values of X and Y. With each
    iteration, we check if the magnitude of *z*n exceeds 2 ❷, per Equation 6.8\. If
    so, the complex number *c* represented by the (*x*, *y*) pair isn’t a member of
    the M-set, and we return the number of iterations it took to reach that conclusion.
    Otherwise, the iteration continues until we reach iterMax. If *z*n remains bounded
    the whole time, we return iterMax to indicate that the number is a member of the
    M-set.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing Everything Together
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s take a look at how all these code segments fit together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Other than our global declarations and our two function definitions, the only
    other problem-specific code is a single call to drawMSet() to create and draw
    a fractal. It’s remarkable that despite the M-set’s complexity, only a few lines
    of code are required to generate the fractal.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s use our app to explore the Mandelbrot set, which remains one of the most
    enigmatic mathematical objects ever discovered. Given the parameter values we
    used in “Declaring Global Variables” on [page 255](#pg_255), [Figure 6-13](chapter6.xhtml#fig6-13)
    shows the core M-set (the dark region) and some of its features.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-13: The Mandelbrot set'
  prefs: []
  type: TYPE_NORMAL
- en: The central, heart-shaped part of the M-set is called the *cardioid*. The circular
    part to the left of the cardioid is called the main *bulb*. It’s a circle centered
    at (–1.0, 0.0), with a radius of 0.25\. Numerous other bulbs are attached to the
    main bulb and the cardioid all around their boundaries, and those bulbs seem to
    have antennas or tentacles. When we zoom in on them, we notice intricate patterns
    and even smaller cardioid-like features with their own bulbs and tentacles. In
    other words, some features of the M-set are replicated again and again, no matter
    how small the scale is (even though the replication is not exact)—a defining feature
    of any fractal.
  prefs: []
  type: TYPE_NORMAL
- en: The finer patterns, visible after sufficient magnification, aren’t simple geometric
    shapes; instead, they’re beautifully intricate and detailed in nature. [Figure
    6-14](chapter6.xhtml#fig6-14) shows magnified versions of two specific regions
    of interest, the *seahorse valley* and the *elephant valley*, as identified in
    [Figure 6-13](chapter6.xhtml#fig6-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-14: The seahorse valley (left) and the elephant valley (right)'
  prefs: []
  type: TYPE_NORMAL
- en: You can generate both of these figures by changing the search region and using
    appropriate parameter values in your app, as summarized in [Table 6-7](chapter6.xhtml#tab6-7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-7: Search Region and Parameter Values for Select Regions of the M-set'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Seahorse valley | Elephant valley |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| xMin | -0.8 | 0.275 |'
  prefs: []
  type: TYPE_TB
- en: '| xMax | -0.7 | 0.325 |'
  prefs: []
  type: TYPE_TB
- en: '| yMin | -0.2 | -0.05 |'
  prefs: []
  type: TYPE_TB
- en: '| yMax | -0.1 | 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| canvasW | 600 | 600 |'
  prefs: []
  type: TYPE_TB
- en: '| increment | 0.0001 | 0.00005 |'
  prefs: []
  type: TYPE_TB
- en: '| iterMax | 200 | 200 |'
  prefs: []
  type: TYPE_TB
- en: Enjoy exploring the M-set by using these parameters, or come up with your own
    parameter values and see what other features you can find.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you used Kotlin to explore the enigmatic beauty of fractals.
    You learned how to design recursive functions to help draw simple geometric fractals,
    and you developed an L-system simulator to generate intricate self-similar patterns
    based on strings of instructions and a few transformation rules. Finally, you
    created an application for visualizing the famous Mandelbrot set.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what the mathematical properties of a fractal are, you now have the
    tools to put together a few lines of code in Kotlin and JavaFX to render it. We’ve
    barely scratched the surface of fractal geometry, however. In particular, you
    have a lot to learn about the M-set that’s beyond the scope of this book. If this
    chapter has aroused your interest in fractals, I encourage you to check out the
    listed resources for further reading.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Devaney, Robert L. *An Introduction to Chaotic Dynamical Systems*. 3rd ed.
    Boca Raton, FL: CRC Press, 2022.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Feldman, David P. *Chaos and Fractals: An Elementary Introduction*. Oxford,
    UK: Oxford University Press, 2012.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flake, Gary William. *The Computational Beauty of Nature: Computer Explorations
    of Fractals, Chaos, Complex Systems, and Adaptation*. Cambridge, MA: MIT Press,
    2000.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mandelbrot, Benoit B. *The Fractal Geometry of Nature*. San Francisco: W. H.
    Freeman & Co., 1982.'
  prefs: []
  type: TYPE_NORMAL
- en: Ponce Campuzano, Juan Carlos. “The Mandelbrot Set.” *Complex Analysis*. 2019\.
    Accessed June 15, 2024\. *[https://complex-analysis.com/content/mandelbrot_set.xhtml](https://complex-analysis.com/content/mandelbrot_set.xhtml)*.
  prefs: []
  type: TYPE_NORMAL
- en: Prusinkiewicz, Przemyslaw, and Aristid Lindenmayer. *The Algorithmic Beauty
    of Plants*. Electronic version, 2004\. Accessed June 15, 2024\. *[http://<wbr>algorithmicbotany<wbr>.org<wbr>/papers<wbr>/abop<wbr>/abop<wbr>.pdf](http://algorithmicbotany.org/papers/abop/abop.pdf)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prusinkiewicz, Przemyslaw, Aristid Lindenmayer, and F. David Fracchia. “Synthesis
    of Space-Filling Curves on the Square Grid.” In *Fractals in the Fundamental and
    Applied Sciences*, edited by Heinz-Otto Peitgen, José Marques Henriques, and Luís
    Filipe Penedo, 334–366\. North-Holland: Elsevier, 1991.'
  prefs: []
  type: TYPE_NORMAL
- en: Weisstein, Eric W. “Mandelbrot Set.” Wolfram MathWorld. Accessed June 15, 2024\.
    *[https://mathworld.wolfram.com/MandelbrotSet.xhtml](https://mathworld.wolfram.com/MandelbrotSet.xhtml)*.
  prefs: []
  type: TYPE_NORMAL
