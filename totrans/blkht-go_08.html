<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch8"><span epub:type="pagebreak" id="page_173"/><span class="big">8</span><br/>RAW PACKET PROCESSING</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">In this chapter, you’ll learn how to capture and process network packets. You can use packet processing for many purposes, including to capture cleartext authentication credentials, alter the application functionality of the packets, or spoof and poison traffic. You can also use it for SYN scanning and for port scanning through SYN-flood protections, among other things.</p>&#13;
<p class="indent">We’ll introduce you to the excellent <span class="literal">gopacket</span> package from Google, which will enable you to both decode packets and reassemble the stream of traffic. This package allows you to filter traffic by using the Berkeley Packet Filter (BPF), also called tcpdump syntax; read and write <em>.pcap</em> files; inspect various layers and data; and manipulate packets.</p>&#13;
<p class="indent">We’ll walk through several examples to show you how to identify devices, filter results, and create a port scanner that can bypass SYN-flood protections.</p>&#13;
<h3 class="h3" id="ch8lev1sec1"><span epub:type="pagebreak" id="page_174"/>Setting Up Your Environment</h3>&#13;
<p class="noindent">Before working through the code in this chapter, you need to set up your environment. First, install <span class="literal">gopacket</span> by entering the following:</p>&#13;
<pre>$ <span class="codestrong1">go get github.com/google/gopacket</span></pre>&#13;
<p class="indent">Now, <span class="literal">gopacket</span> relies on external libraries and drivers to bypass the operating system’s protocol stack. If you intend to compile the examples in this chapter for use on Linux or macOS, you’ll need to install <span class="literal">libpcap-dev</span>. You can do this with most package management utilities such as <span class="literal">apt</span>, <span class="literal">yum</span>, or <span class="literal">brew</span>. Here’s how you install it by using <span class="literal">apt</span> (the installation process looks similar for the other two options):</p>&#13;
<pre>$ <span class="codestrong1">sudo apt-get install libpcap-dev</span></pre>&#13;
<p class="indent">If you intend to compile and run the examples in this chapter on Windows, you have a couple of options, based on whether you’re going to cross-compile or not. Setting up a development environment is simpler if you don’t cross-compile, but in that case, you’ll have to create a Go development environment on a Windows machine, which can be unattractive if you don’t want to clutter another environment. For the time being, we’ll assume you have a working environment that you can use to compile Windows binaries. Within this environment, you’ll need to install WinPcap. You can download an installer for free from <em><a href="https://www.winpcap.org">https://www.winpcap.org</a>/</em>.</p>&#13;
<h3 class="h3" id="ch8lev1sec2">Identifying Devices by Using the pcap Subpackage</h3>&#13;
<p class="noindent">Before you can capture network traffic, you must identify available devices on which you can listen. You can do this easily using the <span class="literal">gopacket/pcap</span> subpackage, which retrieves them with the following helper function: <span class="literal">pcap.FindAllDevs() (ifs []Interface, err error)</span>. <a href="ch08.xhtml#ch8list1">Listing 8-1</a> shows how you can use it to list all available interfaces. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.)</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "log"&#13;
&#13;
    "github.com/google/gopacket/pcap"&#13;
)&#13;
&#13;
func main() {&#13;
 <span class="ent">❶</span> devices, err := pcap.FindAllDevs()&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }&#13;
<span epub:type="pagebreak" id="page_175"/> <span class="ent">❷</span> for _, device := range devices {&#13;
        fmt.Println(device.Name<span class="ent">❸</span>)&#13;
     <span class="ent">❹</span> for _, address := range device.Addresses {&#13;
         <span class="ent">❺</span> fmt.Printf("    IP:      %s\n", address.IP)&#13;
            fmt.Printf("    Netmask: %s\n", address.Netmask)&#13;
        }  &#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch8list1"><em>Listing 8-1: Listing the available network devices (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-8/identify/main.go">/ch-8/identify/main.go</a><em>)</em></p>&#13;
<p class="indent">You enumerate your devices by calling <span class="literal">pcap.FindAllDevs()</span> <span class="ent">❶</span>. Then you loop through the devices found <span class="ent">❷</span>. For each device, you access various properties, including the <span class="literal">device.Name</span> <span class="ent">❸</span>. You also access their IP addresses through the <span class="literal">Addresses</span> property, which is a slice of type <span class="literal">pcap.InterfaceAddress</span>. You loop through these addresses <span class="ent">❹</span>, displaying the IP address and netmask to the screen <span class="ent">❺</span>.</p>&#13;
<p class="indent">Executing your utility produces output similar to <a href="ch08.xhtml#ch8list2">Listing 8-2</a>.</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
enp0s5&#13;
    IP:      10.0.1.20&#13;
    Netmask: ffffff00&#13;
    IP:      fe80::553a:14e7:92d2:114b&#13;
    Netmask: ffffffffffffffff0000000000000000&#13;
any&#13;
lo&#13;
    IP:      127.0.0.1&#13;
    Netmask: ff000000&#13;
    IP:      ::1&#13;
    Netmask: ffffffffffffffffffffffffffffffff</pre>&#13;
<p class="caption" id="ch8list2"><em>Listing 8-2: Output showing the available network interfaces</em></p>&#13;
<p class="indent">The output lists the available network interfaces—<span class="literal">enp0s5</span>, <span class="literal">any</span>, and <span class="literal">lo</span>—as well as their IPv4 and IPv6 addresses and netmasks. The output on your system will likely differ from these network details, but it should be similar enough that you can make sense of the information.</p>&#13;
<h3 class="h3" id="ch8lev1sec3">Live Capturing and Filtering Results</h3>&#13;
<p class="noindent">Now that you know how to query available devices, you can use <span class="literal">gopacket</span>’s features to capture live packets off the wire. In doing so, you’ll also filter the set of packets by using BPF syntax. BPF allows you to limit the contents of what you capture and display so that you see only relevant traffic. It’s commonly used to filter traffic by protocol and port. For example, you could create a filter to see all TCP traffic destined for port 80. You can also filter traffic by destination host. A full discussion of BPF syntax is beyond the scope of this book. For additional ways to use BPF, take a peek at <a href="http://www.tcpdump.org/manpages/pcap-filter.7.html"><em>http://www.tcpdump.org/manpages/pcap-filter.7.html</em></a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_176"/><a href="ch08.xhtml#ch8list3">Listing 8-3</a> shows the code, which filters traffic so that you capture only TCP traffic sent to or from port 80.</p>&#13;
<pre>   package main&#13;
  &#13;
   import (&#13;
       "fmt"&#13;
       "log"&#13;
  &#13;
       "github.com/google/gopacket"&#13;
       "github.com/google/gopacket/pcap"&#13;
   )&#13;
  &#13;
<span class="ent">❶</span> var (&#13;
       iface    = "enp0s5"&#13;
       snaplen  = int32(1600)&#13;
       promisc  = false&#13;
       timeout  = pcap.BlockForever&#13;
       filter   = "tcp and port 80"&#13;
       devFound = false&#13;
   )  &#13;
      &#13;
   func main() {&#13;
       devices, err := pcap.FindAllDevs()<span class="ent">❷</span>&#13;
       if err != nil {&#13;
           log.Panicln(err)&#13;
       }&#13;
      &#13;
    <span class="ent">❸</span> for _, device := range devices {&#13;
           if device.Name == iface {&#13;
               devFound = true&#13;
           }&#13;
       }&#13;
       if !devFound {&#13;
           log.Panicf("Device named '%s' does not exist\n", iface)&#13;
       }&#13;
      &#13;
     <span class="ent">❹</span> handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)&#13;
       if err != nil {&#13;
           log.Panicln(err)&#13;
       }&#13;
       defer handle.Close()&#13;
          &#13;
    <span class="ent">❺</span> if err := handle.SetBPFFilter(filter); err != nil {&#13;
           log.Panicln(err)&#13;
       }&#13;
      &#13;
    <span class="ent">❻</span> source := gopacket.NewPacketSource(handle, handle.LinkType())&#13;
       for packet := range source.Packets()<span class="ent">❼</span> {&#13;
           fmt.Println(packet)&#13;
       }&#13;
   }</pre>&#13;
<p class="caption" id="ch8list3"><em>Listing 8-3: Using a BPF filter to capture specific network traffic (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-8/filter/main.go">/ch-8/filter/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_177"/>The code starts by defining several variables necessary to set up the packet capture <span class="ent">❶</span>. Included among these is the name of the interface on which you want to capture data, the snapshot length (the amount of data to capture for each frame), the <span class="literal">promisc</span> variable (which determines whether you’ll be running promiscuous mode), and your time-out. Also, you define your BPF filter: <span class="literal">tcp and port 80</span>. This will make sure you capture only packets that match those criteria.</p>&#13;
<p class="indent">Within your <span class="literal">main()</span> function, you enumerate the available devices <span class="ent">❷</span>, looping through them to determine whether your desired capture interface exists in your device list <span class="ent">❸</span>. If the interface name doesn’t exist, then you panic, stating that it’s invalid.</p>&#13;
<p class="indent">What remains in the rest of the <span class="literal">main()</span> function is your capturing logic. From a high-level perspective, you need to first obtain or create a <span class="literal">*pcap.Handle</span>, which allows you to read and inject packets. Using this handle, you can then apply a BPF filter and create a new packet data source, from which you can read your packets.</p>&#13;
<p class="indent">You create your <span class="literal">*pcap.Handle</span> (named <span class="literal">handle</span> in the code) by issuing a call to <span class="literal">pcap.OpenLive()</span> <span class="ent">❹</span>. This function receives an interface name, a snapshot length, a boolean value defining whether it’s promiscuous, and a time-out value. These input variables are all defined prior to the <span class="literal">main()</span> function, as we detailed previously. Call <span class="literal">handle.SetBPFFilter(filter)</span> to set the BPF filter for your handle <span class="ent">❺</span>, and then use <span class="literal">handle</span> as an input while calling <span class="literal">gopacket.NewPacketSource(handle, handle.LinkType())</span> to create a new packet data source <span class="ent">❻</span>. The second input value, <span class="literal">handle.LinkType()</span>, defines the decoder to use when handling packets. Lastly, you actually read packets from the wire by using a loop on <span class="literal">source.Packets()</span> <span class="ent">❼</span>, which returns a channel.</p>&#13;
<p class="indent">As you might recall from previous examples in this book, looping on a channel causes the loop to block when it has no data to read from the channel. When a packet arrives, you read it and print its contents to screen.</p>&#13;
<p class="indent">The output should look like <a href="ch08.xhtml#ch8list4">Listing 8-4</a>. Note that the program requires elevated privileges because we’re reading raw content off the network.</p>&#13;
<pre>$ <span class="codestrong1">go build -o filter &amp;&amp; sudo ./filter</span>&#13;
PACKET: 74 bytes, wire length 74 cap length 74 @ 2020-04-26 08:44:43.074187 -0500 CDT&#13;
- Layer 1 (14 bytes) = Ethernet   {Contents=[..14..] Payload=[..60..]&#13;
SrcMAC=00:1c:42:cf:57:11 DstMAC=90:72:40:04:33:c1 EthernetType=IPv4 Length=0}&#13;
- Layer 2 (20 bytes) = IPv4       {Contents=[..20..] Payload=[..40..] Version=4 IHL=5&#13;
TOS=0 Length=60 Id=998 Flags=DF FragOffset=0 TTL=64 Protocol=TCP Checksum=55712&#13;
SrcIP=10.0.1.20 DstIP=54.164.27.126 Options=[] Padding=[]}&#13;
- Layer 3 (40 bytes) = TCP        {Contents=[..40..] Payload=[] SrcPort=51064&#13;
DstPort=80(http) Seq=3543761149 Ack=0 DataOffset=10 FIN=false SYN=true RST=false&#13;
PSH=false ACK=false URG=false ECE=false CWR=false NS=false Window=29200&#13;
Checksum=23908 Urgent=0 Options=[..5..] Padding=[]}&#13;
&#13;
PACKET: 74 bytes, wire length 74 cap length 74 @ 2020-04-26 08:44:43.086706 -0500 CDT&#13;
- Layer 1 (14 bytes) = Ethernet   {Contents=[..14..] Payload=[..60..]&#13;
SrcMAC=00:1c:42:cf:57:11 DstMAC=90:72:40:04:33:c1 EthernetType=IPv4 Length=0}&#13;
- Layer 2 (20 bytes) = IPv4       {Contents=[..20..] Payload=[..40..] Version=4 IHL=5&#13;
TOS=0 Length=60 Id=23414 Flags=DF FragOffset=0 TTL=64 Protocol=TCP Checksum=16919&#13;
SrcIP=10.0.1.20 DstIP=204.79.197.203 Options=[] Padding=[]}&#13;
<span epub:type="pagebreak" id="page_178"/>- Layer 3 (40 bytes) = TCP        {Contents=[..40..] Payload=[] SrcPort=37314&#13;
DstPort=80(http) Seq=2821118056 Ack=0 DataOffset=10 FIN=false SYN=true RST=false&#13;
PSH=false ACK=false URG=false ECE=false CWR=false NS=false Window=29200&#13;
Checksum=40285 Urgent=0 Options=[..5..] Padding=[]}</pre>&#13;
<p class="caption" id="ch8list4"><em>Listing 8-4: Captured packets logged to stdout</em></p>&#13;
<p class="indent">Although the raw output isn’t very digestible, it certainly contains a nice separation of each layer. You can now use utility functions, such as <span class="literal">packet.ApplicationLayer()</span> and <span class="literal">packet.Data()</span>, to retrieve the raw bytes for a single layer or the entire packet. When you combine the output with <span class="literal">hex.Dump()</span>, you can display the contents in a much more readable format. Play around with this on your own.</p>&#13;
<h3 class="h3" id="ch8lev1sec4">Sniffing and Displaying Cleartext User Credentials</h3>&#13;
<p class="noindent">Now let’s build on the code you just created. You’ll replicate some of the functionality provided by other tools to sniff and display cleartext user credentials.</p>&#13;
<p class="indent">Most organizations now operate by using switched networks, which send data directly between two endpoints rather than as a broadcast, making it harder to passively capture traffic in an enterprise environment. However, the following cleartext sniffing attack can be useful when paired with something like Address Resolution Protocol (ARP) poisoning, an attack that can coerce endpoints into communicating with a malicious device on a switched network, or when you’re covertly sniffing outbound traffic from a compromised user workstation. In this example, we’ll assume you’ve compromised a user workstation and focus solely on capturing traffic that uses FTP to keep the code brief.</p>&#13;
<p class="indent">With the exception of a few small changes, the code in <a href="ch08.xhtml#ch8list5">Listing 8-5</a> is nearly identical to the code in <a href="ch08.xhtml#ch8list3">Listing 8-3</a>.</p>&#13;
<pre><span class="gray">package main</span>&#13;
&#13;
<span class="gray">import (</span>&#13;
    <span class="gray">"bytes"</span>&#13;
    <span class="gray">"fmt"</span>&#13;
    <span class="gray">"log"</span>&#13;
&#13;
    <span class="gray">"github.com/google/gopacket"</span>&#13;
    <span class="gray">"github.com/google/gopacket/pcap"</span>&#13;
<span class="gray">)</span>&#13;
&#13;
<span class="gray">var (</span>&#13;
    <span class="gray">iface    = "enp0s5"</span>&#13;
    <span class="gray">snaplen  = int32(1600)</span>&#13;
    <span class="gray">promisc  = false</span>&#13;
    <span class="gray">timeout  = pcap.BlockForever</span>&#13;
 <span class="ent">❶</span> filter   = "tcp and dst port 21"&#13;
    <span class="gray">devFound = false</span>&#13;
<span class="gray">)</span>&#13;
<span epub:type="pagebreak" id="page_179"/>&#13;
<span class="gray">func main() {</span>&#13;
    <span class="gray">devices, err := pcap.FindAllDevs()</span>&#13;
    <span class="gray">if err != nil {</span>&#13;
        <span class="gray">log.Panicln(err)</span>&#13;
    <span class="gray">}</span>&#13;
&#13;
    <span class="gray">for _, device := range devices {</span>&#13;
        <span class="gray">if device.Name == iface {</span>&#13;
            <span class="gray">devFound = true</span>&#13;
        <span class="gray">}</span>&#13;
    <span class="gray">}</span>&#13;
    <span class="gray">if !devFound {</span>&#13;
        <span class="gray">log.Panicf("Device named '%s' does not exist\n", iface)</span>&#13;
    <span class="gray">}</span>&#13;
&#13;
    <span class="gray">handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)</span>&#13;
    <span class="gray">if err != nil {</span>&#13;
        <span class="gray">log.Panicln(err)</span>&#13;
    <span class="gray">}</span>&#13;
    <span class="gray">defer handle.Close()</span>&#13;
&#13;
    <span class="gray">if err := handle.SetBPFFilter(filter); err != nil {</span>&#13;
        <span class="gray">log.Panicln(err)</span>&#13;
    <span class="gray">}</span>&#13;
&#13;
    <span class="gray">source := gopacket.NewPacketSource(handle, handle.LinkType())</span>&#13;
    <span class="gray">for packet := range source.Packets() {</span>&#13;
     <span class="ent">❷</span> appLayer := packet.ApplicationLayer()&#13;
        if appLayer == nil {&#13;
            continue&#13;
        }  &#13;
     <span class="ent">❸</span> payload := appLayer.Payload()&#13;
     <span class="ent">❹</span> if bytes.Contains(payload, []byte("USER")) {&#13;
            fmt.Print(string(payload))&#13;
        } else if bytes.Contains(payload, []byte("PASS")) {&#13;
            fmt.Print(string(payload))&#13;
        }  &#13;
    <span class="gray">}</span>&#13;
<span class="gray">}</span></pre>&#13;
<p class="caption" id="ch8list5"><em>Listing 8-5: Capturing FTP authentication credentials (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-8/ftp/main.go">/ch-8/ftp/main.go</a><em>)</em></p>&#13;
<p class="indent">The changes you made encompass only about 10 lines of code. First, you change your BPF filter to capture only traffic destined for port 21 (the port commonly used for FTP traffic) <span class="ent">❶</span>. The rest of the code remains the same until you process the packets.</p>&#13;
<p class="indent">To process packets, you first extract the application layer from the packet and check to see whether it actually exists <span class="ent">❷</span>, because the application layer contains the FTP commands and data. You look for the application layer by examining whether the response value from <span class="literal">packet.ApplicationLayer()</span> is <span class="literal">nil</span>. Assuming the application layer exists in the packet, you extract the payload (the FTP commands/data) from the layer by calling <span class="literal">appLayer.Payload()</span> <span class="ent">❸</span>. <span epub:type="pagebreak" id="page_180"/>(There are similar methods for extracting and inspecting other layers and data, but you only need the application layer payload.) With your payload extracted, you then check whether the payload contains either the <span class="literal">USER</span> or <span class="literal">PASS</span> commands <span class="ent">❹</span>, indicating that it’s part of a login sequence. If it does, display the payload to the screen.</p>&#13;
<p class="indent">Here’s a sample run that captures an FTP login attempt:</p>&#13;
<pre>$ <span class="codestrong1">go build -o ftp &amp;&amp; sudo ./ftp</span>&#13;
USER someuser&#13;
PASS passw0rd</pre>&#13;
<p class="indent">Of course, you can improve this code. In this example, the payload will be displayed if the words <span class="literal">USER</span> or <span class="literal">PASS</span> exist anywhere in the payload. Really, the code should be searching only the beginning of the payload to eliminate false-positives that occur when those keywords appear as part of file contents transferred between client and server or as part of a longer word such as <span class="literal">PASSAGE</span> or <span class="literal">ABUSER</span>. We encourage you to make these improvements as a learning exercise.</p>&#13;
<h3 class="h3" id="ch8lev1sec5">Port Scanning Through SYN-flood Protections</h3>&#13;
<p class="noindent">In <a href="ch02.xhtml#ch2">Chapter 2</a>, you walked through the creation of a port scanner. You improved the code through multiple iterations until you had a high-performing implementation that produced accurate results. However, in some instances, that scanner can still produce incorrect results. Specifically, when an organization employs SYN-flood protections, typically all ports—open, closed, and filtered alike—produce the same packet exchange to indicate that the port is open. These protections, known as SYN <em>cookies</em>, prevent SYN-flood attacks and obfuscate the attack surface, producing false-positives.</p>&#13;
<p class="indent">When a target is using SYN cookies, how can you determine whether a service is listening on a port or a device is falsely showing that the port is open? After all, in both cases, the TCP three-way handshake is completed. Most tools and scanners (Nmap included) look at this sequence (or some variation of it, based on the scan type you’ve chosen) to determine the status of the port. Therefore, you can’t rely on these tools to produce accurate results.</p>&#13;
<p class="indent">However, if you consider what happens after you’ve established a connection—an exchange of data, perhaps in the form of a service banner—you can deduce whether an actual service is responding. SYN-flood protections generally won’t exchange packets beyond the initial three-way handshake unless a service is listening, so the presence of any additional packets might indicate that a service exists.</p>&#13;
<h4 class="h4" id="ch8lev2sec1">Checking TCP Flags</h4>&#13;
<p class="noindent">To account for SYN cookies, you have to extend your port-scanning capabilities to look beyond the three-way handshake by checking to see whether <span epub:type="pagebreak" id="page_181"/>you receive any additional packets from the target after you’ve established a connection. You can accomplish this by sniffing the packets to see if any of them were transmitted with a TCP flag value indicative of additional, legitimate service communications.</p>&#13;
<p class="indent"><em>TCP flags</em> indicate information about the state of a packet transfer. If you look at the TCP specification, you’ll find that the flags are stored in a single byte at position 14 in the packet’s header. Each bit of this byte represents a single flag value. The flag is “on” if the bit at that position is set to 1, and “off” if the bit is set to 0. <a href="ch08.xhtml#ch8tab1">Table 8-1</a> shows the positions of the flags in the byte, as per the TCP specification.</p>&#13;
<p class="tabcap" id="ch8tab1"><strong>Table 8-1:</strong> TCP Flags and Their Byte Positions</p>&#13;
<table class="topbot-d2">&#13;
<colgroup>&#13;
<col style="width:12%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba"><strong>Bit</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">7</p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">6</p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">5</p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">4</p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ha1"><p class="taba"><strong>Flag</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-ha1"><p class="taba">CWR</p></td>&#13;
<td style="vertical-align: top;" class="table-ha1"><p class="taba">ECE</p></td>&#13;
<td style="vertical-align: top;" class="table-ha1"><p class="taba">URG</p></td>&#13;
<td style="vertical-align: top;" class="table-ha1"><p class="taba">ACK</p></td>&#13;
<td style="vertical-align: top;" class="table-ha1"><p class="taba">PSH</p></td>&#13;
<td style="vertical-align: top;" class="table-ha1"><p class="taba">RST</p></td>&#13;
<td style="vertical-align: top;" class="table-ha1"><p class="taba">SYN</p></td>&#13;
<td style="vertical-align: top;" class="table-ha1"><p class="taba">FIN</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Once you know the positions of the flags you care about, you can create a filter that checks them. For example, you can look for packets containing the following flags, which might indicate a listening service:</p>&#13;
<ul>&#13;
<li><p class="noindent">ACK and FIN</p></li>&#13;
<li><p class="noindent">ACK</p></li>&#13;
<li><p class="noindent">ACK and PSH</p></li>&#13;
</ul>&#13;
<p class="indent">Because you have the ability to capture and filter certain packets by using the <span class="literal">gopacket</span> library, you can build a utility that attempts to connect to a remote service, sniffs the packets, and displays only the services that communicate packets with these TCP headers. Assume all other services are falsely “open” because of SYN cookies.</p>&#13;
<h4 class="h4" id="ch8lev2sec2">Building the BPF Filter</h4>&#13;
<p class="noindent">Your BPF filter needs to check for the specific flag values that indicate packet transfer. The flag byte has the following values if the flags we mentioned earlier are turned on:</p>&#13;
<ul>&#13;
<li><p class="noindent">ACK and FIN: 00010001 (0x11)</p></li>&#13;
<li><p class="noindent">ACK: 00010000 (0x10)</p></li>&#13;
<li><p class="noindent">ACK and PSH: 00011000 (0x18)</p></li>&#13;
</ul>&#13;
<p class="indent">We included the hex equivalent of the binary value for clarity, as you’ll use the hex value in your filter.</p>&#13;
<p class="indent">To summarize, you need to check the 14th byte (offset 13 for a 0-based index) of the TCP header, filtering only for packets whose flags are 0x11, 0x10, or 0x18. Here’s what the BPF filter looks like:</p>&#13;
<pre>tcp[13] == 0x11 or tcp[13] == 0x10 or tcp[13] == 0x18</pre>&#13;
<p class="indent">Excellent. You have your filter.</p>&#13;
<h4 class="h4" id="ch8lev2sec3"><span epub:type="pagebreak" id="page_182"/>Writing the Port Scanner</h4>&#13;
<p class="noindent">Now you’ll use the filter to build a utility that establishes a full TCP connection and inspects packets beyond the three-way handshake to see whether other packets are transmitted, indicating that an actual service is listening. The program is shown in <a href="ch08.xhtml#ch8list6">Listing 8-6</a>. For the sake of simplicity, we’ve opted to not optimize the code for efficiency. However, you can greatly improve this code by making optimizations similar to those we made in <a href="ch02.xhtml#ch2">Chapter 2</a>.</p>&#13;
<pre>var ( <span class="ent">❶</span>&#13;
    snaplen  = int32(320)&#13;
    promisc  = true&#13;
    timeout  = pcap.BlockForever&#13;
    filter   = "tcp[13] == 0x11 or tcp[13] == 0x10 or tcp[13] == 0x18"&#13;
    devFound = false&#13;
    results  = make(map[string]int)&#13;
)&#13;
&#13;
func capture(iface, target string) { <span class="ent">❷</span>&#13;
    handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }&#13;
&#13;
    defer handle.Close()&#13;
&#13;
    if err := handle.SetBPFFilter(filter); err != nil {&#13;
        log.Panicln(err)&#13;
    }  &#13;
&#13;
    source := gopacket.NewPacketSource(handle, handle.LinkType())&#13;
    fmt.Println("Capturing packets")&#13;
    for packet := range source.Packets() {&#13;
        networkLayer := packet.NetworkLayer() <span class="ent">❸</span>&#13;
        if networkLayer == nil {&#13;
            continue&#13;
        }&#13;
        transportLayer := packet.TransportLayer()&#13;
        if transportLayer == nil {&#13;
            continue&#13;
        }&#13;
&#13;
        srcHost := networkLayer.NetworkFlow().Src().String() <span class="ent">❹</span>&#13;
        srcPort := transportLayer.TransportFlow().Src().String()&#13;
&#13;
        if srcHost != target { <span class="ent">❺</span>&#13;
            continue&#13;
        }&#13;
        results[srcPort] += 1 <span class="ent">❻</span>&#13;
    }  &#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="page_183"/>func main() {&#13;
&#13;
    if len(os.Args) != 4 {&#13;
        log.Fatalln("Usage: main.go &lt;capture_iface&gt; &lt;target_ip&gt; &lt;port1,port2,port3&gt;")&#13;
    }  &#13;
&#13;
    devices, err := pcap.FindAllDevs()&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }  &#13;
&#13;
    iface := os.Args[1]&#13;
    for _, device := range devices {&#13;
        if device.Name == iface {&#13;
            devFound = true&#13;
        }&#13;
    }  &#13;
    if !devFound {&#13;
        log.Panicf("Device named '%s' does not exist\n", iface)&#13;
    }  &#13;
&#13;
    ip := os.Args[2]&#13;
    go capture(iface, ip) <span class="ent">❼</span>&#13;
    time.Sleep(1 * time.Second)&#13;
&#13;
    ports, err := explode(os.Args[3])&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }  &#13;
&#13;
    for _, port := range ports { <span class="ent">❽</span>&#13;
        target := fmt.Sprintf("%s:%s", ip, port)&#13;
        fmt.Println("Trying", target)&#13;
        c, err := net.DialTimeout("tcp", target, 1000*time.Millisecond) <span class="ent">❾</span>&#13;
        if err != nil {&#13;
            continue&#13;
        }&#13;
        c.Close()&#13;
    }&#13;
    time.Sleep(2 * time.Second)&#13;
&#13;
    for port, confidence := range results { <span class="ent">❿</span>&#13;
        if confidence &gt;= 1 {&#13;
            fmt.Printf("Port %s open (confidence: %d)\n", port, confidence)&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
/* Extraneous code omitted for brevity */</pre>&#13;
<p class="caption" id="ch8list6"><em>Listing 8-6: Scanning and processing packets with SYN-flood protections (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-8/syn-flood/main.go">/ch-8/syn-flood/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_184"/>Broadly speaking, your code will maintain a count of packets, grouped by port, to represent how confident you are that the port is indeed open. You’ll use your filter to select only packets with the proper flags set. The greater the count of matching packets, the higher your confidence that the service is listening on the port.</p>&#13;
<p class="indent">Your code starts by defining several variables for use throughout <span class="ent">❶</span>. These variables include your filter and a map named <span class="literal">results</span> that you’ll use to track your level of confidence that the port is open. You’ll use target ports as keys and maintain a count of matching packets as the map value.</p>&#13;
<p class="indent">Next you define a function, <span class="literal">capture()</span>, that accepts the interface name and target IP for which you’re testing <span class="ent">❷</span>. The function itself bootstraps the packet capture much in the same way as previous examples. However, you must use different code to process each packet. You leverage the <span class="literal">gopacket</span> functionality to extract the packet’s network and transport layers <span class="ent">❸</span>. If either of these layers is absent, you ignore the packet; that’s because the next step is to inspect the source IP and port of the packet <span class="ent">❹</span>, and if there’s no transport or network layer, you won’t have that information. You then confirm that the packet source matches the IP address that you’re targeting <span class="ent">❺</span>. If the packet source and IP address don’t match, you skip further processing. If the packet’s source IP and port match your target, you increment your confidence level for the port <span class="ent">❻</span>. Repeat this process for each subsequent packet. Each time you get a match, your confidence level increases.</p>&#13;
<p class="indent">In your <span class="literal">main()</span> function, use a goroutine to call your <span class="literal">capture()</span> function <span class="ent">❼</span>. Using a goroutine ensures that your packet capture and processing logic runs concurrently without blocking. Meanwhile, your <span class="literal">main()</span> function proceeds to parse your target ports, looping through them one by one <span class="ent">❽</span> and calling <span class="literal">net.DialTimeout</span> to attempt a TCP connection against each <span class="ent">❾</span>. Your goroutine is running, actively watching these connection attempts, looking for packets that indicate a service is listening.</p>&#13;
<p class="indent">After you’ve attempted to connect to each port, process all of your results by displaying only those ports that have a confidence level of 1 or more (meaning at least one packet matches your filter for that port) <span class="ent">❿</span>. The code includes several calls to <span class="literal">time.Sleep()</span> to ensure you’re leaving adequate time to set up the sniffer and process packets.</p>&#13;
<p class="indent">Let’s look at a sample run of the program, shown in <a href="ch08.xhtml#ch8list7">Listing 8-7</a>.</p>&#13;
<pre>$ <span class="codestrong1">go build -o syn-flood &amp;&amp; sudo ./syn-flood enp0s5 10.1.100.100</span>&#13;
<span class="codestrong1">80,443,8123,65530</span>&#13;
Capturing packets&#13;
Trying 10.1.100.100:80&#13;
Trying 10.1.100.100:443&#13;
Trying 10.1.100.100:8123&#13;
Trying 10.1.100.100:65530&#13;
Port 80 open (confidence: 1)&#13;
Port 443 open (confidence: 1)</pre>&#13;
<p class="caption" id="ch8list7"><em>Listing 8-7: Port-scanning results with confidence ratings</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_185"/>The test successfully determines that both port 80 and 443 are open. It also confirms that no service is listening on ports 8123 and 65530. (Note that we’ve changed the IP address in the example to protect the innocent.)</p>&#13;
<p class="indent">You could improve the code in several ways. As learning exercises, we challenge you to add the following enhancements:</p>&#13;
<ol>&#13;
<li><p class="noindent">Remove the network and transport layer logic and source checks from the <span class="literal">capture()</span> function. Instead, add additional parameters to the BPF filter to ensure that you capture only packets from your target IP and ports.</p></li>&#13;
<li><p class="noindent">Replace the sequential logic of port scanning with a concurrent alternative, similar to what we demonstrated in previous chapters. This will improve efficiency.</p></li>&#13;
<li><p class="noindent">Rather than limiting the code to a single target IP, allow the user to supply a list of IPs or network blocks.</p></li>&#13;
</ol>&#13;
<h3 class="h3" id="ch8lev1sec6">Summary</h3>&#13;
<p class="noindent">We’ve completed our discussion of packet captures, focusing primarily on passive sniffing activities. In the next chapter, we’ll focus on exploit development.<span epub:type="pagebreak" id="page_186"/></p>&#13;
</div>



  </body></html>