- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EXPRESSIONS
    AND OPERATORS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn about operators and how to write simple expressions
    to perform operations on various object types. An *operator* is a keyword or one
    or more punctuation characters used to perform an operation. When an operator
    is applied to one or more operands, it becomes an expression that computes a value
    and that might have side effects. *Expressions* are sequences of operators and
    operands that compute a value or accomplish another purpose. The operands can
    be identifiers, constants, string literals, and other expressions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discuss simple assignment before stepping back to examine
    the mechanics of expressions (operators and operands, value computations, side
    effects, precedence, and order of evaluation). We then consider specific operators
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>, arithmetic,
    bitwise, cast, conditional, alignment, relational, compound assignment, and the
    comma operator. We’ve introduced many of these operators and expressions in previous
    chapters; here, we detail their behavior and how best to use them. Finally, we
    end the chapter with a discussion of pointer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Simple Assignment</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *simple assignment* replaces the value stored in the object designated by
    the left operand with the right operand. The value of the right operand is converted
    to the type of the assignment expression. Simple assignment has three components:
    the left operand, the assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>)
    operator, and the right operand, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines are *declarations* that define and initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    with the value 21 and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> with
    the value 7\. Initialization is different from simple assignment despite having
    similar syntax. An *initializer* is an optional part of a declaration; when present,
    it provides the initial value for the object. If the initializer is not present,
    objects (with automatic storage duration) are uninitialized.
  prefs: []
  type: TYPE_NORMAL
- en: The third line contains a simple assignment. You must define or declare all
    identifiers that appear in an expression (such as a simple assignment) for your
    code to compile.
  prefs: []
  type: TYPE_NORMAL
- en: The left operand in a simple assignment is always an expression (with an object
    type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>), referred
    to as an *lvalue*. The *l* in lvalue originally comes from it being the *left*
    operand, but it may be more correct to think of it as standing for *locator value*,
    because it must designate an object. The right operand is also an expression,
    but it can simply be a value and doesn’t need to identify an object. We refer
    to this value as an *rvalue* (*right* operand) or *expression value*. In this
    example, the identifiers for both objects <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> are lvalues. An lvalue
    can also be an expression, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">*(p
    + 4)</samp>, provided it references an object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: In a simple assignment, the rvalue is converted to the type of the lvalue and
    then stored in the object designated by the lvalue. In the assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>,
    the value is read from <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    and written to <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. Because
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    are the same type (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>),
    no conversion is necessary. The assignment expression has the value of the result
    of the assignment and the type of the lvalue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rvalue does not need to refer to an object, as you can see in the following
    statement, which uses the types and values from the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    is not an lvalue, because there is no underlying object storing the result. Instead,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> by itself is an lvalue
    that is automatically converted into an rvalue to be used as an operand to the
    addition operation. The resulting value from the addition operation (which has
    no memory location associated with it) is also an rvalue. C constrains where lvalues
    and rvalues may appear. The following statements illustrate the correct and incorrect
    use of lvalues and rvalues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    doesn’t compile because the rvalue must always appear on the right side of the
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the right operand has a different type from the assignment
    expression, so the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    is first converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>
    type. The value of the expression enclosed in parentheses is then converted to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> type and assigned
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Assignment must deal with real-world constraints. Specifically, simple assignment
    can result in truncation if a value is converted to a narrower type. As mentioned
    in [Chapter 3](chapter3.xhtml), each object requires a fixed number of bytes of
    storage. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> can
    always be represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    (a larger type of the same signedness). However, in this example, the value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> (the type of the assignment expression <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>).
    The value of the expression enclosed in parentheses is then converted to the type
    of the outer assignment expression—that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> type. If your implementation’s <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> type has insufficient width to fully represent the value stored in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, values greater than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp> are truncated, and the
    value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> (−1) is
    truncated. To prevent values from being truncated, make sure that you choose sufficiently
    wide types that can represent any value that might arise.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evaluations</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve looked at simple assignment, let’s step back for a moment and
    look at how expressions are evaluated. *Evaluation* mostly means simplifying an
    expression down to a single value. The evaluation of an expression can include
    both value computations and the initiation of side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *value computation* is the calculation of the value that results from the
    evaluation of the expression. Computing the final value may involve determining
    the identity of the object or reading the value previously assigned to an object.
    For example, the following expression contains several value computations to determine
    the identity of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is a function
    and not an object, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp>
    doesn’t involve determining the identity of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>.
    The value computations of operands must occur before the value computation of
    the result of the operator. In this example, separate value computations read
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> and determine
    the value returned by the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    function. A third computation then sums these values to obtain the value returned
    by the overall expression. If <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp>
    is an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the result of the expression will have the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '*Side effects* are changes to the state of the execution environment. Side
    effects include writing to an object, accessing (reading or writing) a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    object, input/output (I/O), assignment, or calling a function that does any of
    these things. We can slightly modify the previous example to add an assignment.
    Updating the stored value of <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    is a side effect of the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The assignment to <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is
    a side effect that changes the state of the execution environment. Depending on
    the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> function,
    the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> may also have
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Function Invocation</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *function designator* is an expression that has a function type and is used
    to invoke a function. In the following function invocation, <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    is the function designator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> function returns
    the larger of its two arguments. In an expression, a function designator is converted
    to a *pointer-to-function returning type* at compile time. The value of each argument
    must be of a type that can be assigned to an object with (the unqualified version
    of) the type of its corresponding parameter. The number and type of each argument
    must agree with the number and type of each parameter accepted by the function.
    Here, that means two integer arguments. C also supports *variadic functions*,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>, which accept
    a variable number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We can also pass one function to another, as shown by [Listing 4-1](chapter4.xhtml#Lis4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: Passing one function
    to another function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code passes the address of a function designated by <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to another function, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>. The
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> accepts a pointer
    to a function that accepts no arguments and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    A function passed as an argument is implicitly converted to a function pointer.
    The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> makes
    this explicit; an equivalent declaration is <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    g(int func(void))</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Increment and Decrement Operators</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *increment* (<samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>) and
    *decrement* (<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>) operators
    increment and decrement a modifiable lvalue, respectively. Both are *unary operators*
    because they take a single operand.
  prefs: []
  type: TYPE_NORMAL
- en: These operators can be used as either *prefix operators*, which appear before
    the operand, or *postfix operators*, which come after the operand. The prefix
    and postfix operators have different behaviors, which means they are commonly
    used as trick questions in quizzes and interviews. A prefix increment performs
    the increment before returning the value, whereas a postfix increment returns
    the value and then performs the increment. [Listing 4-2](chapter4.xhtml#Lis4-2)
    illustrates these behaviors by performing a prefix or postfix increment or decrement
    operation and then assigning the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: The prefix and
    postfix increment and decrement operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp> operation in this
    example returns the unchanged value <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>,
    which is then assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.
    The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is then incremented
    as a side effect of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *prefix* increment operator increments the value of the operand, and the
    expression returns the new value of the operand after it has been incremented.
    Consequently, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp>
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    except that <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is evaluated
    only once. The <samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp> operation
    in this example returns the incremented value <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>,
    which is then assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.  ##
    <samp class="SANS_Futura_Std_Bold_B_11">Operator Precedence and Associativity</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics and computer programming, the *order of operations* (or *operator
    precedence*) is a collection of rules that dictates the order in which operations
    are performed during the evaluation of an expression. For example, multiplication
    is granted a higher precedence than addition. Therefore, the expression 2 + 3
    × 4 is interpreted to have the value 2 + (3 × 4) = 14, not (2 + 3) × 4 = 20.
  prefs: []
  type: TYPE_NORMAL
- en: '*Associativity* determines how operators of the same precedence are grouped
    when no parentheses are used. C associativity differs from mathematics associativity.
    For example, while floating-point addition and multiplication are both commutative
    (*a* + *b* = *b* + *a* and *a* × *b* = *b* × *a*), they are not necessarily associative.
    If adjacent operators have equal precedence, the choice of which operation to
    apply first is determined by the associativity. *Left-associative* operators cause
    the operations to be grouped from the left, while *right-associative* operators
    cause the operations to be grouped from the right. You can think of grouping as
    the implicit introduction of parentheses. For example, the addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    operator has left associativity, so the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">((a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>.
    The assignment operator is right-associative, so the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">(a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c))</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-1](chapter4.xhtml#tab4-1), derived from the C Operator Precedence
    table at the C++ References website (*[https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/language<wbr>/operator<wbr>_precedence](https://en.cppreference.com/w/c/language/operator_precedence)*),
    lists the precedence and associativity of C operators, as specified by the language
    syntax. Operators are listed in order of descending precedence (that is, higher
    rows have higher precedence).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Operator
    Precedence and Associativity</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Associativity</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">(...)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Forced grouping</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">Postfix
    increment and decrement</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">()</samp> | <samp class="SANS_Futura_Std_Book_11">Function
    call</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> | <samp class="SANS_Futura_Std_Book_11">Array
    subscripting</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> | <samp class="SANS_Futura_Std_Book_11">Structure
    and union member access</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> | <samp class="SANS_Futura_Std_Book_11">Structure
    and union member access through pointer</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">){</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> | <samp class="SANS_Futura_Std_Book_11">Compound
    literal</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">Prefix
    increment and decrement</samp> | <samp class="SANS_Futura_Std_Book_11">Right</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    | <samp class="SANS_Futura_Std_Book_11">Unary plus and minus</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">! ~</samp> | <samp class="SANS_Futura_Std_Book_11">Logical
    NOT and bitwise NOT</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> | <samp class="SANS_Futura_Std_Book_11">Type
    cast</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">Indirection
    (dereference)</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> | <samp class="SANS_Futura_Std_Book_11">Address-of</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> | <samp class="SANS_Futura_Std_Book_11">Size
    of</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp> | <samp
    class="SANS_Futura_Std_Book_11">Alignment requirement</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">*
    / %</samp> | <samp class="SANS_Futura_Std_Book_11">Multiplication, division, and
    remainder</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">Addition
    and subtraction</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><<
    >></samp> | <samp class="SANS_Futura_Std_Book_11">Bitwise left shift and right
    shift</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    <=</samp> | <samp class="SANS_Futura_Std_Book_11">Relational operators < and ≤</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">> >=</samp> | <samp class="SANS_Futura_Std_Book_11">Relational
    operators > and ≥</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">Equal
    to and not equal to</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise AND</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise XOR (exclusive or)</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise OR (inclusive or)</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">11</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    | <samp class="SANS_Futura_Std_Book_11">Logical AND</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp>
    | <samp class="SANS_Futura_Std_Book_11">Logical OR</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">13</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp> | <samp class="SANS_Futura_Std_Book_11">Conditional operator</samp> |
    <samp class="SANS_Futura_Std_Book_11">Right</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">14</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Simple assignment</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Assignment by sum and difference</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp> | <samp class="SANS_Futura_Std_Book_11">Assignment
    by product, quotient, and remainder</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Assignment by bitwise left shift and right
    shift</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">&= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Assignment by bitwise AND, XOR, and OR</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    | <samp class="SANS_Futura_Std_Book_11">Expression sequencing</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Sometimes operator precedence can be intuitive, and sometimes it can be misleading.
    For example, the postfix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operators have higher
    precedence than both the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operators, which in
    turn have the same precedence as the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    operator. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    is a pointer, then <samp class="SANS_TheSansMonoCd_W5Regular_11">*p++</samp> is
    equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(p++)</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp> is equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">++(*p)</samp>, because both the prefix
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> operator and the unary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator are right-associative.
    If two operators have the same precedence and associativity, they are evaluated
    from left to right. [Listing 4-3](chapter4.xhtml#Lis4-3) illustrates the precedence
    rules among these operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: The operator precedence
    rules</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The pointer in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp>
    is first dereferenced, producing the <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    character. This value is then incremented, resulting in the character <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>.
    In this case, the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    operator operates on the object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and not the
    pointer. On the other hand, the pointer in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*q++</samp>
    is incremented first, so it refers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    character. However, the result of *postfix* increment operators is the value of
    the operand so that the original pointer value is dereferenced, producing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> character. Consequently,
    this code prints out the characters <samp class="SANS_TheSansMonoCd_W5Regular_11">dx</samp>.
    You can use parentheses to change or clarify the order of operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Order of Evaluation</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *order of evaluation* of the operands of any C operator, including the order
    of evaluation of any subexpressions, is generally unspecified. The compiler will
    evaluate them in any order and may choose a different order when the same expression
    is evaluated again. This latitude allows the compiler to produce faster code by
    choosing the most efficient order. The order of evaluation is constrained by operator
    precedence and associativity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-4](chapter4.xhtml#Lis4-4) demonstrates the order of evaluation for
    function arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: The order of evaluation
    for function arguments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Both functions <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp> access the global variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">glob</samp>, meaning they rely on a shared
    state. Because the order of evaluation of functions <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> is unspecified, the
    arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> may
    differ between compilations. If <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    is called first, it will return 10, but if it’s called last, it will return 52\.
    Function <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> always returns
    42 regardless of the order of evaluation. Consequently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    function (which returns the greater of the two values) may return either 42 or
    52, depending on the order of evaluation of its arguments. The only *sequencing
    guarantees* provided by this code are that both <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> are called before <samp
    class="SANS_TheSansMonoCd_W5Regular_11">max</samp> and that the executions of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    do not interleave.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite this code as follows to ensure it always behaves in a predictable,
    portable manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this revised program, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    is called to initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">f_val</samp>
    variable. This is guaranteed to be sequenced before the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>,
    which is called in the subsequent declaration to initialize the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">g_val</samp>. If one evaluation is *sequenced
    before* another evaluation, the first evaluation must complete before the second
    evaluation can begin. You can use sequence points (discussed in the following
    subsections) to guarantee that an object will be written before it is read. The
    execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is guaranteed
    to be sequenced before the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    because a sequence point exists between the evaluation of one full expression
    and the next full expression.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsequenced and Indeterminately
    Sequenced Evaluations</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The executions of unsequenced evaluations can *interleave*, meaning that the
    instructions can be executed in any order, provided that reads and writes are
    performed in the order specified by the program. A program that performs reads
    and writes in the order specified by the program is *sequentially consistent*
    (Lamport 1979).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some evaluations are *indeterminately sequenced*, which means they cannot interleave
    but can still be executed in any order. For example, the following statement contains
    several value computations and side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The values of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    must be read before their values can be incremented or decremented. This means
    that the reading of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> must
    be sequenced before the increment side effect, for example. Similarly, all side
    effects for the operands of the multiplication operation need to complete before
    the multiplication can occur. The multiplication must complete before the addition
    because of operator precedence rules. Finally, all side effects on the operands
    of the addition operation must complete before the addition can occur. These constraints
    produce a partial ordering among these operations because they don’t require that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> be incremented before <samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp> is decremented, for example.
    Unsequenced evaluations in this expression can be performed in any order, which
    allows the compiler to both reorder operations and to cache values in registers,
    allowing for faster overall execution. Function executions, on the other hand,
    are indeterminately sequenced and do not interleave with each other.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sequence Points</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *sequence point* is the juncture at which all side effects will have completed.
    These are implicitly defined by the language, but you can control when they occur
    by how you code.
  prefs: []
  type: TYPE_NORMAL
- en: The sequence points are enumerated in Annex C of the C Standard. A sequence
    point occurs between the evaluation of one *full expression* (an expression that
    is not part of another expression or declarator) and the next full expression
    to be evaluated. A sequence point also occurs upon entering or exiting a called
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a side effect is unsequenced relative to either a different side effect
    on the same scalar or a value computation that uses the value of the same scalar
    object, the code has undefined behavior. A *scalar type* is either an arithmetic
    type or pointer type. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">* i++</samp> performs two unsequenced
    operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> as the following
    code snippet shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You might think this code will produce the value 30, but because it has undefined
    behavior, that outcome isn’t guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conservatively, we can ensure that side effects have completed before the value
    is read by placing every side-effecting operation in its own full expression.
    We can rewrite that code as follows to eliminate the undefined behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This example now contains a sequence point between every side-effecting operation.
    However, it’s impossible to tell whether this rewritten code represents the programmer’s
    original intent because the original code had no defined meaning. If you choose
    to omit sequence points, you must be sure you completely understand the sequencing
    of side effects. We also can write this same code as follows without changing
    the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have described the mechanics of expressions, we’ll return to discussing
    specific operators.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">sizeof Operator</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator
    to find the size in bytes of its operand; specifically, it returns an unsigned
    integer of <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type that
    represents the size. Knowing the correct size of an operand is necessary for most
    memory operations, including allocating and copying storage. The <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    type is defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>
    as well as in other header files. We need to include one of these header files
    to compile any code that references the <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator an unevaluated expression of a complete object type or a parenthesized
    name of such a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It’s always safe to parenthesize the operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>,
    because parenthesizing an expression doesn’t change the way the size of the operand
    is calculated. The result of invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator is a constant expression unless the operand is a variable-length array.
    The operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> is
    not evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to determine the number of bits of storage available, you can multiply
    the size of an object by <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>,
    which gives the number of bits contained in a byte. For example, the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT * sizeof(int)</samp> will
    produce the number of bits in an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arithmetic Operators</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators that perform arithmetic operations on arithmetic types are detailed
    in the following sections. We can also use some of these operators with nonarithmetic
    operands.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unary + and –</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *unary* <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp> *operators* operate on a single
    operand of arithmetic type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    operator returns the negative of its operand (that is, it behaves as though the
    operand were multiplied by –1). The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator just returns the value. These operators exist primarily to express positive
    and negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: If the operand has a small integer type, it’s promoted (see [Chapter 3](chapter3.xhtml)),
    and the result of the operation has the result of the promoted type. As a point
    of trivia, C has no negative integer literals. A value such as <samp class="SANS_TheSansMonoCd_W5Regular_11">–25</samp>
    is actually an rvalue of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp> preceded
    by the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> operator.
    However, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-25</samp>
    is guaranteed to be a constant integer expression.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logical Negation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The result of the unary logical negation operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>)
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> if the evaluated value
    of its operand is not <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> if the evaluated value
    of its operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operand is a scalar type. The result has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    for historical reasons. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp> is equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>.
    The logical negation operator is frequently used to check for null pointers; for
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">!p</samp> is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">(nullptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p)</samp>. Null pointers may not
    hold the value zero but are guaranteed to evaluate to false.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Additive</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The binary additive operators include addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    and subtraction (<samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp>). We can
    apply addition and subtraction to two operands of arithmetic types, but we can
    also use them to perform scaled pointer arithmetic. I’ll discuss pointer arithmetic
    near the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The binary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator sums
    its two operands. The binary <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    operator subtracts the right operand from the left operand. The usual arithmetic
    conversions are performed on operands of arithmetic type for both operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplicative</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The binary multiplicative operators include multiplication (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>),
    division (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>), and remainder
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>). The usual arithmetic
    conversions are implicitly performed on multiplicative operands to find a common
    type. You can multiply and divide both floating-point and integer operands, but
    remainder operates only on integer operands.
  prefs: []
  type: TYPE_NORMAL
- en: Various programming languages implement different kinds of integer division
    operations, including Euclidean, flooring, and truncating. In *Euclidean division*,
    the remainder is always nonnegative (Boute 1992). In *flooring division*, the
    quotient is rounded toward negative infinity (Knuth 1997). In *truncating division*,
    the fractional part of the quotient is discarded, which is often referred to as
    *truncation toward zero*.
  prefs: []
  type: TYPE_NORMAL
- en: The C programming language implements truncating division, meaning that the
    remainder always has the same sign as the dividend, as shown in [Table 4-2](chapter4.xhtml#tab4-2).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp> <samp class="SANS_Futura_Std_Book_11">Truncating
    Division</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">/</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Quotient</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">%</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Remainder</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">  10 / 3</samp> | <samp class="SANS_Futura_Std_Book_11">  3</samp>
    | <samp class="SANS_Futura_Std_Book_11">  10 % 3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">  10 / –3</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">  10 % –3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">–10 / 3</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–10 % 3</samp> | <samp class="SANS_Futura_Std_Book_11">–1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">–10 / –3</samp> | <samp class="SANS_Futura_Std_Book_11">  3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–10 % –3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: To generalize, if the quotient <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp> is representable, then the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(a
    / b) * b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    % b</samp> equals <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. Otherwise,
    if the value of the divisor is equal to 0 or <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp> overflows, both <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">a % b</samp> will result in
    undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth taking the time to understand the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    operator to avoid surprises. For example, the following code defines a faulty
    function called <samp class="SANS_TheSansMonoCd_W5Regular_11">is_odd</samp> that
    attempts to test whether an integer is odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Because the result of the remainder operation always has the sign of the dividend
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>, when <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    is negative and odd, <samp class="SANS_TheSansMonoCd_W5Regular_11">n % 2</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>, and the function
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'A correct, alternative solution is to test that the remainder is not <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (because a remainder of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> is the same regardless of the
    sign of the dividend):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Many central processing units (CPUs) implement remainder as part of the division
    operator, which can overflow if the dividend is equal to the minimum negative
    value for the signed integer type and the divisor is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>.
    This occurs even though the mathematical result of such a remainder operation
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The C standard library provides floating-point remainder, truncation, and rounding
    functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">fmod</samp>,
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bitwise Operators</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use *bitwise operators* to manipulate the bits of an object or any integer
    expression. Bitwise operators (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>) treat the bits as a pure
    binary model without concern for the values represented by these bits. Typically,
    they’re used on objects that represent *masks* or *bitmaps* where each bit indicates
    that something is “on” or “off,” “enabled” or “disabled,” or some other binary
    pairing. Using a mask, multiple bits can be set, unset, or inverted in a single
    bitwise operation. Masks and bitmaps are best represented as unsigned integer
    types, as the sign bit can be better used as a value and unsigned operations are
    less prone to undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Complement</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *unary complement operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>)
    works on a single operand of integer type and returns the *bitwise complement*
    of its operand—that is, a value in which each bit of the original value is flipped.
    The complement operator is used in applying the POSIX <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp>,
    for example. The <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp> masks
    or subtracts permissions. For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">077</samp> turns off read, write,
    and execute permissions for the group and others. A file’s permission mode is
    the result of a logical AND operation between the complement of the mask and the
    process’s requested permission mode setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer promotions are performed on the operand of the complement operator,
    and the result has the promoted type. For example, the following code snippet
    applies the <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operator to
    a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On an architecture with an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type and 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp> is assigned the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>. When <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp>
    is used as the operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp> is promoted
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> by zero-extending
    it to 32 bits, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000000FF</samp>.
    The complement of this value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFF00</samp>.
    Therefore, on this platform, complementing an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> type always results in a negative value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>. As a general policy and to avoid surprises such as this, bitwise operations
    should operate only on values of sufficiently wide unsigned integer types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shift</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Shift operations* shift the value of each bit of an operand of integer type
    by a specified number of positions. Shifting is commonly performed in system programming,
    where bitmasks are common. Shift operations may also be used in code that manages
    network protocols or file formats to pack or unpack data. They include left-shift
    operations of the form'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'and right-shift operations of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The *shift expression* is the value to be shifted, and the *additive expression*
    is the number of bits by which to shift the value. [Figure 4-1](chapter4.xhtml#fig4-1)
    illustrates a logical left shift of 1 bit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f04001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A logical left
    shift of 1 bit</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The additive expression determines the number of bits by which to shift the
    value. For example, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1
    << E2</samp> is the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    left-shifted <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> bit positions;
    vacated bits are filled with zeros. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    has an unsigned type, the resulting value is <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>. Values that cannot be represented
    in the resulting type will wrap around. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    has a signed type and nonnegative value and if <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp> is representable in the
    result type, then that is the resulting value; otherwise, it is undefined behavior.
    Similarly, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1 >> E2</samp>
    is the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> right-shifted
    <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> bit positions. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has an unsigned type or if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has a signed type and a nonnegative
    value, the value of the result is the integral part of the quotient of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1/2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    has a signed type and a negative value, the resulting value is implementation
    defined and may be either an arithmetic (sign-extended) shift or a logical (unsigned)
    shift, as shown in [Figure 4-2](chapter4.xhtml#fig4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f04002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: An arithmetic (signed)
    right shift and a logical (unsigned) right shift of 1 bit</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In both shift operations, the integer promotions are performed on the operands,
    each of which has an integer type. The type of the result is that of the promoted
    left operand. The usual arithmetic conversions are *not* performed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-5](chapter4.xhtml#Lis4-5) shows how to perform right-shift operations
    on signed and unsigned integers that are free from undefined behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Correct right-shift
    operations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For signed integers ❶, you must ensure that the number of bits shifted is not
    negative, greater than, or equal to the width of the promoted left operand. For
    unsigned integers ❷, you omit the test for negative values, as unsigned integers
    can never be negative. You can perform safe left-shift operations in a similar
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise AND</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The binary *bitwise AND operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    returns the bitwise AND of two operands of integer type. The usual arithmetic
    conversions are performed on both operands. Each bit in the result is set if and
    only if each of the corresponding bits in the converted operands is set, as shown
    in [Table 4-3](chapter4.xhtml#tab4-3).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise
    AND Truth Table</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise Exclusive
    OR</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The *bitwise exclusive OR operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>)
    returns the bitwise exclusive OR of the operands of integer type. The operands
    must be integers, and the usual arithmetic conversions are performed on both.
    Each bit in the result is set if and only if exactly one of the corresponding
    bits in the converted operands is set, as shown in [Table 4-4](chapter4.xhtml#tab4-4).
    You can also think of this operation as “one or the other, but not both.”
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-4:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise
    Exclusive OR Truth Table</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">^</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: Exclusive OR is equivalent to the addition operation on the integers modulo
    2—that is, because of wraparound 1 + 1 mod 2 = 0 (Lewin 2012).
  prefs: []
  type: TYPE_NORMAL
- en: Beginners commonly mistake the exclusive OR operator for an exponent operator,
    erroneously believing that the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>
    will compute 2 raised to the power of 7\. The correct way to raise a number to
    a certain power in C is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp>
    functions defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>,
    as shown in [Listing 4-6](chapter4.xhtml#Lis4-6). The <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp>
    functions operate on floating-point arguments and return a floating-point result,
    so be aware that these functions might fail to produce the expected results because
    of truncation or other errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Using the</samp>
    <samp class="I">pow</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">functions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp>
    function to compute 2 raised to the power of 7\. Because 2⁷ equals 128, this program
    will print <samp class="SANS_TheSansMonoCd_W5Regular_11">equal</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise Inclusive
    OR</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *bitwise inclusive OR* (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>)
    *operator* returns the bitwise inclusive OR of two operands. Each bit in the result
    is set if and only if at least one of the corresponding bits in the converted
    operands is set, as shown in [Table 4-5](chapter4.xhtml#tab4-5).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-5:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise
    Inclusive OR Truth Table</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&#124;</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: The operands must be integers, and the usual arithmetic conversions are performed
    on both.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Logical Operators</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *logical AND* (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>)
    and *OR* (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>) *operators*
    are used primarily for logically joining two or more expressions of scalar type.
    They’re commonly used in condition tests to combine multiple comparisons together,
    such as in the first operand of the conditional operator, the controlling expression
    of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, or the
    controlling expression of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. You shouldn’t use logical operators with bitmap operands, as they are intended
    primarily for Boolean logic.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> operator returns
    1 if neither of its operands is equal to 0 and returns 0 otherwise. Logically,
    this means that <samp class="SANS_TheSansMonoCd_W5Regular_11">a && b</samp> is
    true only if both <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is true
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is true.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operator returns
    1 if either of its operands is not equal to 0 and returns 0 otherwise. Logically,
    this means that <samp class="SANS_TheSansMonoCd_W5Regular_11">a || b</samp> is
    true if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is true, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is true, or both <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are true.
  prefs: []
  type: TYPE_NORMAL
- en: The C standard defines both operations in terms of “not equal to zero” because
    the operands can have values other than 0 and 1\. Both operators accept operands
    of scalar type (integers, floats, and pointers), and the result of the operation
    has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the corresponding bitwise binary operators, the logical AND operator
    and logical OR operator guarantee left-to-right evaluation. Both operators *short-circuit*:
    The second operand is not evaluated if the result can be deduced solely by evaluating
    the first operand. If the second operand is evaluated, there is a sequence point
    between the evaluations of the first and second operands. For example, the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0 && unevaluated</samp> returns
    0 regardless of the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp>
    because there is no possible value for <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp>
    that produces a different result. Because of this, <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp>
    is not evaluated to determine its value. The same is true for <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    || unevaluated</samp> because this expression always returns 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Short-circuiting is commonly used in operations with pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code tests the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is null, the second
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> operand is not evaluated,
    preventing a null pointer dereference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Short-circuiting can also be used to avoid unnecessary computing. In the following
    expression, the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp>
    predicate function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if the file is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp>
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, the
    second <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operand is not
    evaluated, as there is no need to prepare the file. This avoids potential errors
    or, when <samp class="SANS_TheSansMonoCd_W5Regular_11">prepare_file</samp> is
    idempotent, unnecessary computing, assuming the cost of determining whether the
    file is ready is less than the cost of preparing the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers should exercise caution if the second operand contains side effects,
    because it may not be apparent whether these side effects occur. For example,
    in the following code, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    is incremented only when <samp class="SANS_TheSansMonoCd_W5Regular_11">i >=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code may be correct, but it’s likely a programmer error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Cast Operators</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Casts* (also known as *type casts*) explicitly convert a value of one type
    to a value of another type. To perform a cast, we precede an expression with a
    parenthesized type name, which converts the value of the expression to the unqualified
    version of the named type. The following code illustrates an explicit conversion,
    or cast, of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> from type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Unless the type name specifies a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type, the type name must be a qualified or unqualified scalar type. The operand
    must also have scalar type; a pointer type cannot be converted to any floating-point
    type, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Casts are extremely powerful and must be used carefully. For one thing, casts
    may reinterpret the existing bits as a value of the specified type without changing
    the bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Casts may also change these bits into whatever bits are needed to represent
    the original value in the resulting type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Casts can also disable diagnostics. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following diagnostic when compiled with Visual C++ 2022
    with warning level <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    disables the diagnostic without fixing the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To mitigate these risks, C++ defines its own casts, which are less powerful.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conditional Operator</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *conditional operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>) is the only C operator that takes three operands. It returns a result
    based on the condition. You can use the conditional operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The conditional operator evaluates the first operand, called the *condition*.
    The second operand (<samp class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfTrue</samp>)
    is evaluated if the condition is true, or the third operand (<samp class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfFalse</samp>)
    is evaluated if the condition is false. The result is the value of either the
    second or third operand (depending on which operand was evaluated).
  prefs: []
  type: TYPE_NORMAL
- en: This result is converted to a common type based on the second and third operands.
    There is a sequence point between the evaluation of the first operand and the
    evaluation of the second or third operand (whichever is evaluated) so that the
    compiler will ensure that all side effects resulting from evaluating the condition
    have completed before the second or third operand is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The conditional operator is similar to an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    control flow block but returns a value as a function does. Unlike with an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> control flow block, you
    can use the conditional operator to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first operand to the conditional operator must have scalar type. The second
    and third operands must have compatible types (roughly speaking). For more details
    on the constraints for this operator and the specifics of determining the return
    type, refer to Section 6.5.15 of the C standard (ISO/IEC 9899:2024).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">alignof Operator</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp> operator yields
    an integer constant representing the alignment requirement of its operand’s declared
    complete object type. It does not evaluate the operand. When applied to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp> type, it returns the alignment
    requirement of the element type. An alternative spelling of <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp>
    is available for this operator. Prior to C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    spelling was available through a convenience macro provided in the header <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stdalign.h></samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    operator is useful in static assertions that are used to verify assumptions about
    your program (discussed further in [Chapter 11](chapter11.xhtml)). The purpose
    of these assertions is to diagnose situations in which your assumptions are invalid.
    [Listing 4-7](chapter4.xhtml#Lis4-7) demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: The</samp> <samp
    class="I">alignof</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple program doesn’t accomplish anything particularly useful. It declares
    an array <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> of four integers
    followed by a static assertion concerning the alignment of the array and a runtime
    assertion concerning the alignment of <samp class="SANS_TheSansMonoCd_W5Regular_11">max_align_t</samp>
    (an object type whose alignment is the greatest fundamental alignment). It then
    prints out these values. This program will not compile if either static assertion
    is false, or it will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'These alignments are characteristic of the x86-64 architecture.  ## <samp class="SANS_Futura_Std_Bold_B_11">Relational
    Operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The *relational operators* include equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>),
    not equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>), less than
    (<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>), greater than (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp>), less than or equal to (<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>), and greater than or equal
    to (<samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>). Each returns 1 if
    the specified relationship is true and 0 if it is false. The result has type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, again, for historical reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that C does not interpret the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    < b < c</samp> to mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> but less
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, as ordinary mathematics
    does. Instead, the expression is interpreted to mean <samp class="SANS_TheSansMonoCd_W5Regular_11">(a
    < b) < c</samp>. In English, if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, the compiler
    should compare <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp>; otherwise, it compares <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    If this is your intent, include the parentheses to make that clear to any potential
    code reviewer. Some compilers such as GCC and Clang provide the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wparentheses</samp>
    flag to diagnose those problems. To determine whether <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> but less
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, you can write this
    test: <samp class="SANS_TheSansMonoCd_W5Regular_11">(a < b) && (b < c)</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The equality and inequality operators have lower precedence than the relational
    operators—and assuming otherwise is a common mistake. This means that the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c < d</samp> is evaluated the same
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">(a < b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(c < d)</samp>. In both cases, the
    comparisons <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">c < d</samp> are evaluated first, and
    the resulting values (either <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>) are compared for equality.
  prefs: []
  type: TYPE_NORMAL
- en: We can use these operators to compare arithmetic types or pointers. When we
    compare two pointers, the result depends on the relative locations in the address
    space of the objects pointed to. If both pointers point to the same object, they
    are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equality and inequality operators differ from the other relational operators.
    For example, you cannot use the other relational operators on two pointers to
    unrelated objects, because doing so makes no sense and is consequently undefined
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You might compare pointers, for example, to determine whether you have reached
    the too-far element of an array.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compound Assignment Operators</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Compound assignment operators*, shown in [Table 4-6](chapter4.xhtml#tab4-6),
    modify the current value of an object by performing an operation on it.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-6:</samp> <samp class="SANS_Futura_Std_Book_11">Compound
    Assignment Operators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assignment
    by</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Sum and difference</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp> | <samp class="SANS_Futura_Std_Book_11">Product,
    quotient, and remainder</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise left shift and right shift</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise AND, XOR, and OR</samp> |'
  prefs: []
  type: TYPE_TB
- en: A compound assignment of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> *=* <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp>
    is equivalent to the simple assignment expression <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(E2)</samp>,
    except that <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> is evaluated
    only once. Compound assignments are primarily used as shorthand notation. There
    are no compound assignment operators for logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comma Operator</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C, we use commas in two distinct ways: as operators and to separate items
    in a list (such as arguments to functions or lists of declarations). The *comma*
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>) *operator* is a way to
    evaluate one expression before another. First, the left operand of a comma operator
    is evaluated as a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> expression.
    There is a sequence point between the evaluation of the left operand and the evaluation
    of the right operand. Then, the right operand is evaluated after the left. The
    comma operation has the type and value of the right operand—mostly because it
    is the last expression evaluated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t use the comma operator in contexts in which a comma might separate
    items in a list. Instead, you would include a comma within a parenthesized expression
    or within the second expression of a conditional operator. For example, assume
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> each have type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in the following call to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first comma separates the first and second arguments to the function. The
    second comma is a comma operator. The assignment is evaluated first, followed
    by the addition. Because of the sequence point, the assignment is guaranteed to
    complete before the addition takes place. The result of the comma operation has
    the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. The third comma separates the
    second and third arguments to the function.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pointer Arithmetic</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, we mentioned that the additive operators (addition
    and subtraction) can be used with either arithmetic operands or object pointers.
    In this section, we discuss adding a pointer and an integer, subtracting two pointers,
    and subtracting an integer from a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding or subtracting an expression that has an integer type to or from a pointer
    returns a value with the type of the pointer operand. If the pointer operand points
    to an element of an array, then the result points to an element offset from the
    original element. If the resulting pointer is beyond the bounds of the array,
    undefined behavior occurs. The difference of the array subscripts of the resulting
    and original array elements equals the integer expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Pointer arithmetic is automatically *scaled* to the size of the array element,
    rather than individual bytes. C allows a pointer to be formed to each element
    of an array, including one past the last element of the array object (also referred
    to as the *too-far* pointer). While this might seem unusual or unnecessary, many
    early C programs incremented a pointer until it was equal to the too-far pointer,
    and the C standards committee didn’t want to break all this code, which is also
    idiomatic in C++ iterators. [Figure 4-3](chapter4.xhtml#fig4-3) illustrates forming
    the *too-far* pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f04003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: One past the last
    element of an array object</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If both the pointer operand and the result point to elements of the same array
    object or the too-far pointer, the evaluation did not overflow; otherwise, the
    behavior is undefined. To satisfy the too-far requirement, an implementation need
    only provide one extra byte (which can overlap another object in the program)
    just after the end of the object.
  prefs: []
  type: TYPE_NORMAL
- en: C also allows objects to be treated as an array containing only a single element,
    allowing you to obtain a too-far pointer from a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The too-far special case allows us to advance a pointer until it is equal to
    the too-far pointer, as in the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement
    (explained in detail in the next chapter) in the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum_m_elems</samp>
    function loops while <samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp> is
    less than the address of the too-far pointer for the array <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>.
    The pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp> is incremented
    at the end of each iteration of the loop until the too-far pointer is formed,
    causing the loop condition to evaluate to 0 when tested.
  prefs: []
  type: TYPE_NORMAL
- en: When we subtract one pointer from another, both must point to elements of the
    same array object or the too-far element. This operation returns the difference
    of the subscripts of the two array elements. The type of the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp>
    (a signed integer type). You should take care when subtracting pointers, because
    the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp> may
    not be sufficient to represent the difference of pointers to elements of very
    large character arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use operators to write simple expressions
    that perform operations on various object types. Along the way, you learned about
    some core C concepts, such as lvalues, rvalues, value computations, and side effects,
    which determine how expressions are evaluated. You also learned how operator precedence,
    associativity, order of evaluation, sequencing, and interleaving can affect the
    total order in which a program is executed. In the next chapter, you’ll learn
    more about how to control the execution of your program by using selection, iteration,
    and jump statements.
  prefs: []
  type: TYPE_NORMAL
