- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EXPRESSIONS
    AND OPERATORS</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">表达式与运算符</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, you’ll learn about operators and how to write simple expressions
    to perform operations on various object types. An *operator* is a keyword or one
    or more punctuation characters used to perform an operation. When an operator
    is applied to one or more operands, it becomes an expression that computes a value
    and that might have side effects. *Expressions* are sequences of operators and
    operands that compute a value or accomplish another purpose. The operands can
    be identifiers, constants, string literals, and other expressions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习运算符以及如何编写简单的表达式来对各种对象类型进行操作。*运算符*是用于执行操作的关键字或一个或多个标点符号。当运算符应用于一个或多个操作数时，它会成为一个计算值的表达式，并且可能具有副作用。*表达式*是由运算符和操作数组成的序列，用来计算一个值或完成其他目的。操作数可以是标识符、常量、字符串字面量或其他表达式。
- en: In this chapter, we discuss simple assignment before stepping back to examine
    the mechanics of expressions (operators and operands, value computations, side
    effects, precedence, and order of evaluation). We then consider specific operators
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>, arithmetic,
    bitwise, cast, conditional, alignment, relational, compound assignment, and the
    comma operator. We’ve introduced many of these operators and expressions in previous
    chapters; here, we detail their behavior and how best to use them. Finally, we
    end the chapter with a discussion of pointer arithmetic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在深入探讨表达式的机制（包括运算符与操作数、值计算、副作用、优先级以及求值顺序）之前，先讨论简单赋值。接着，我们会讨论具体的运算符，包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>、算术运算符、按位运算符、强制类型转换运算符、条件运算符、对齐运算符、关系运算符、复合赋值运算符以及逗号运算符。我们在前几章中已经介绍了这些运算符和表达式；在这一章，我们详细讲解它们的行为及最佳使用方式。最后，我们将以指针运算的讨论结束本章内容。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Simple Assignment</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">简单赋值</samp>
- en: 'A *simple assignment* replaces the value stored in the object designated by
    the left operand with the right operand. The value of the right operand is converted
    to the type of the assignment expression. Simple assignment has three components:
    the left operand, the assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>)
    operator, and the right operand, as shown in the following example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单赋值*将左操作数指定的对象中的值替换为右操作数的值。右操作数的值会被转换为赋值表达式的类型。简单赋值有三个组成部分：左操作数、赋值（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>）运算符和右操作数，如下例所示：'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first two lines are *declarations* that define and initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    with the value 21 and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> with
    the value 7\. Initialization is different from simple assignment despite having
    similar syntax. An *initializer* is an optional part of a declaration; when present,
    it provides the initial value for the object. If the initializer is not present,
    objects (with automatic storage duration) are uninitialized.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行是*声明*，它们将变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 初始化为 21，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> 初始化为 7。初始化不同于简单赋值，尽管它们具有相似的语法。*初始化器*是声明中的可选部分；如果存在，它会为对象提供初始值。如果没有初始化器，具有自动存储周期的对象将未初始化。
- en: The third line contains a simple assignment. You must define or declare all
    identifiers that appear in an expression (such as a simple assignment) for your
    code to compile.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行包含一个简单赋值。为了使代码能够编译，你必须定义或声明所有在表达式中出现的标识符（例如在简单赋值中）。
- en: The left operand in a simple assignment is always an expression (with an object
    type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>), referred
    to as an *lvalue*. The *l* in lvalue originally comes from it being the *left*
    operand, but it may be more correct to think of it as standing for *locator value*,
    because it must designate an object. The right operand is also an expression,
    but it can simply be a value and doesn’t need to identify an object. We refer
    to this value as an *rvalue* (*right* operand) or *expression value*. In this
    example, the identifiers for both objects <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> are lvalues. An lvalue
    can also be an expression, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">*(p
    + 4)</samp>, provided it references an object in memory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In a simple assignment, the rvalue is converted to the type of the lvalue and
    then stored in the object designated by the lvalue. In the assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>,
    the value is read from <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    and written to <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. Because
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    are the same type (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>),
    no conversion is necessary. The assignment expression has the value of the result
    of the assignment and the type of the lvalue.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The rvalue does not need to refer to an object, as you can see in the following
    statement, which uses the types and values from the preceding example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>
    is not an lvalue, because there is no underlying object storing the result. Instead,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> by itself is an lvalue
    that is automatically converted into an rvalue to be used as an operand to the
    addition operation. The resulting value from the addition operation (which has
    no memory location associated with it) is also an rvalue. C constrains where lvalues
    and rvalues may appear. The following statements illustrate the correct and incorrect
    use of lvalues and rvalues:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    doesn’t compile because the rvalue must always appear on the right side of the
    operator.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the right operand has a different type from the assignment
    expression, so the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    is first converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>
    type. The value of the expression enclosed in parentheses is then converted to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> type and assigned
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Assignment must deal with real-world constraints. Specifically, simple assignment
    can result in truncation if a value is converted to a narrower type. As mentioned
    in [Chapter 3](chapter3.xhtml), each object requires a fixed number of bytes of
    storage. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> can
    always be represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    (a larger type of the same signedness). However, in this example, the value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> (the type of the assignment expression <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>).
    The value of the expression enclosed in parentheses is then converted to the type
    of the outer assignment expression—that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> type. If your implementation’s <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> type has insufficient width to fully represent the value stored in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, values greater than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp> are truncated, and the
    value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> (−1) is
    truncated. To prevent values from being truncated, make sure that you choose sufficiently
    wide types that can represent any value that might arise.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evaluations</samp>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve looked at simple assignment, let’s step back for a moment and
    look at how expressions are evaluated. *Evaluation* mostly means simplifying an
    expression down to a single value. The evaluation of an expression can include
    both value computations and the initiation of side effects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'A *value computation* is the calculation of the value that results from the
    evaluation of the expression. Computing the final value may involve determining
    the identity of the object or reading the value previously assigned to an object.
    For example, the following expression contains several value computations to determine
    the identity of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp>:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is a function
    and not an object, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp>
    doesn’t involve determining the identity of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>.
    The value computations of operands must occur before the value computation of
    the result of the operator. In this example, separate value computations read
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> and determine
    the value returned by the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    function. A third computation then sums these values to obtain the value returned
    by the overall expression. If <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp>
    is an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the result of the expression will have the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '*Side effects* are changes to the state of the execution environment. Side
    effects include writing to an object, accessing (reading or writing) a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    object, input/output (I/O), assignment, or calling a function that does any of
    these things. We can slightly modify the previous example to add an assignment.
    Updating the stored value of <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
    is a side effect of the assignment:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The assignment to <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is
    a side effect that changes the state of the execution environment. Depending on
    the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> function,
    the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> may also have
    side effects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Function Invocation</samp>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *function designator* is an expression that has a function type and is used
    to invoke a function. In the following function invocation, <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    is the function designator:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> function returns
    the larger of its two arguments. In an expression, a function designator is converted
    to a *pointer-to-function returning type* at compile time. The value of each argument
    must be of a type that can be assigned to an object with (the unqualified version
    of) the type of its corresponding parameter. The number and type of each argument
    must agree with the number and type of each parameter accepted by the function.
    Here, that means two integer arguments. C also supports *variadic functions*,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>, which accept
    a variable number of arguments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: We can also pass one function to another, as shown by [Listing 4-1](chapter4.xhtml#Lis4-1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: Passing one function
    to another function</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: This code passes the address of a function designated by <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to another function, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>. The
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> accepts a pointer
    to a function that accepts no arguments and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    A function passed as an argument is implicitly converted to a function pointer.
    The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> makes
    this explicit; an equivalent declaration is <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    g(int func(void))</samp>.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Increment and Decrement Operators</samp>
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *increment* (<samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>) and
    *decrement* (<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>) operators
    increment and decrement a modifiable lvalue, respectively. Both are *unary operators*
    because they take a single operand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: These operators can be used as either *prefix operators*, which appear before
    the operand, or *postfix operators*, which come after the operand. The prefix
    and postfix operators have different behaviors, which means they are commonly
    used as trick questions in quizzes and interviews. A prefix increment performs
    the increment before returning the value, whereas a postfix increment returns
    the value and then performs the increment. [Listing 4-2](chapter4.xhtml#Lis4-2)
    illustrates these behaviors by performing a prefix or postfix increment or decrement
    operation and then assigning the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: The prefix and
    postfix increment and decrement operators</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp> operation in this
    example returns the unchanged value <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>,
    which is then assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.
    The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is then incremented
    as a side effect of the operation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The *prefix* increment operator increments the value of the operand, and the
    expression returns the new value of the operand after it has been incremented.
    Consequently, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp>
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    except that <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is evaluated
    only once. The <samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp> operation
    in this example returns the incremented value <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>,
    which is then assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.  ##
    <samp class="SANS_Futura_Std_Bold_B_11">Operator Precedence and Associativity</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*前缀*递增运算符增加操作数的值，并且该表达式返回递增后的操作数的新值。因此，表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp>等同于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，唯一的区别是<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>只会被评估一次。此示例中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">++i</samp>操作返回递增后的值<samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>，然后将其赋值给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">e</samp>。  ## <samp class="SANS_Futura_Std_Bold_B_11">运算符优先级与结合性</samp>'
- en: In mathematics and computer programming, the *order of operations* (or *operator
    precedence*) is a collection of rules that dictates the order in which operations
    are performed during the evaluation of an expression. For example, multiplication
    is granted a higher precedence than addition. Therefore, the expression 2 + 3
    × 4 is interpreted to have the value 2 + (3 × 4) = 14, not (2 + 3) × 4 = 20.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学和计算机编程中，*运算顺序*（或*运算符优先级*）是一组规则，规定了在求值表达式时，操作执行的顺序。例如，乘法的优先级高于加法。因此，表达式2 +
    3 × 4的值为2 + (3 × 4) = 14，而不是(2 + 3) × 4 = 20。
- en: '*Associativity* determines how operators of the same precedence are grouped
    when no parentheses are used. C associativity differs from mathematics associativity.
    For example, while floating-point addition and multiplication are both commutative
    (*a* + *b* = *b* + *a* and *a* × *b* = *b* × *a*), they are not necessarily associative.
    If adjacent operators have equal precedence, the choice of which operation to
    apply first is determined by the associativity. *Left-associative* operators cause
    the operations to be grouped from the left, while *right-associative* operators
    cause the operations to be grouped from the right. You can think of grouping as
    the implicit introduction of parentheses. For example, the addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    operator has left associativity, so the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">((a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>.
    The assignment operator is right-associative, so the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">(a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c))</samp>.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-1](chapter4.xhtml#tab4-1), derived from the C Operator Precedence
    table at the C++ References website (*[https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/language<wbr>/operator<wbr>_precedence](https://en.cppreference.com/w/c/language/operator_precedence)*),
    lists the precedence and associativity of C operators, as specified by the language
    syntax. Operators are listed in order of descending precedence (that is, higher
    rows have higher precedence).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Operator
    Precedence and Associativity</samp>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Associativity</samp>
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">(...)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Forced grouping</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp>
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">(...)</samp>
    | <samp class="SANS_Futura_Std_Book_11">强制分组</samp> | <samp class="SANS_Futura_Std_Book_11">左侧</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">Postfix
    increment and decrement</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp>
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">后缀递增与递减</samp>
    | <samp class="SANS_Futura_Std_Book_11">左侧</samp> |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">()</samp> | <samp class="SANS_Futura_Std_Book_11">Function
    call</samp> |  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">()</samp> | <samp class="SANS_Futura_Std_Book_11">函数调用</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> | <samp class="SANS_Futura_Std_Book_11">Array
    subscripting</samp> |  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> | <samp class="SANS_Futura_Std_Book_11">数组下标</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> | <samp class="SANS_Futura_Std_Book_11">Structure
    and union member access</samp> |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> | <samp class="SANS_Futura_Std_Book_11">结构体与联合体成员访问</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> | <samp class="SANS_Futura_Std_Book_11">Structure
    and union member access through pointer</samp> |  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> | <samp class="SANS_Futura_Std_Book_11">通过指针访问结构体与联合体成员</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">){</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> | <samp class="SANS_Futura_Std_Book_11">Compound
    literal</samp> |  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">){</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> | <samp class="SANS_Futura_Std_Book_11">复合字面量</samp>
    |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">Prefix
    increment and decrement</samp> | <samp class="SANS_Futura_Std_Book_11">Right</samp>
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> | <samp class="SANS_Futura_Std_Book_11">前缀递增与递减</samp>
    | <samp class="SANS_Futura_Std_Book_11">右侧</samp> |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    | <samp class="SANS_Futura_Std_Book_11">Unary plus and minus</samp> |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    | <samp class="SANS_Futura_Std_Book_11">一元加与减</samp> |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">! ~</samp> | <samp class="SANS_Futura_Std_Book_11">Logical
    NOT and bitwise NOT</samp> |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">! ~</samp> | <samp class="SANS_Futura_Std_Book_11">逻辑非与按位非</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> | <samp class="SANS_Futura_Std_Book_11">Type
    cast</samp> |  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> | <samp class="SANS_Futura_Std_Book_11">类型转换</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">Indirection
    (dereference)</samp> |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">间接寻址（解引用）</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> | <samp class="SANS_Futura_Std_Book_11">Address-of</samp>
    |  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> | <samp class="SANS_Futura_Std_Book_11">取地址</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> | <samp class="SANS_Futura_Std_Book_11">Size
    of</samp> |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> | <samp class="SANS_Futura_Std_Book_11">大小</samp>
    |  |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp> | <samp
    class="SANS_Futura_Std_Book_11">Alignment requirement</samp> |  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp> | <samp
    class="SANS_Futura_Std_Book_11">对齐要求</samp> |  |'
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">*
    / %</samp> | <samp class="SANS_Futura_Std_Book_11">Multiplication, division, and
    remainder</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">Addition
    and subtraction</samp> |  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><<
    >></samp> | <samp class="SANS_Futura_Std_Book_11">Bitwise left shift and right
    shift</samp> |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><
    <=</samp> | <samp class="SANS_Futura_Std_Book_11">Relational operators < and ≤</samp>
    |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">> >=</samp> | <samp class="SANS_Futura_Std_Book_11">Relational
    operators > and ≥</samp> |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">Equal
    to and not equal to</samp> |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise AND</samp> |  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise XOR (exclusive or)</samp> |  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise OR (inclusive or)</samp> |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">11</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    | <samp class="SANS_Futura_Std_Book_11">Logical AND</samp> |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">12</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp>
    | <samp class="SANS_Futura_Std_Book_11">Logical OR</samp> |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">13</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp> | <samp class="SANS_Futura_Std_Book_11">Conditional operator</samp> |
    <samp class="SANS_Futura_Std_Book_11">Right</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">14</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Simple assignment</samp> |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Assignment by sum and difference</samp>
    |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp> | <samp class="SANS_Futura_Std_Book_11">Assignment
    by product, quotient, and remainder</samp> |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Assignment by bitwise left shift and right
    shift</samp> |  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">&= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Assignment by bitwise AND, XOR, and OR</samp>
    |  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    | <samp class="SANS_Futura_Std_Book_11">Expression sequencing</samp> | <samp class="SANS_Futura_Std_Book_11">Left</samp>
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: Sometimes operator precedence can be intuitive, and sometimes it can be misleading.
    For example, the postfix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operators have higher
    precedence than both the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operators, which in
    turn have the same precedence as the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    operator. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    is a pointer, then <samp class="SANS_TheSansMonoCd_W5Regular_11">*p++</samp> is
    equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(p++)</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp> is equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">++(*p)</samp>, because both the prefix
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> operator and the unary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator are right-associative.
    If two operators have the same precedence and associativity, they are evaluated
    from left to right. [Listing 4-3](chapter4.xhtml#Lis4-3) illustrates the precedence
    rules among these operators.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: The operator precedence
    rules</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The pointer in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp>
    is first dereferenced, producing the <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    character. This value is then incremented, resulting in the character <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>.
    In this case, the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    operator operates on the object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and not the
    pointer. On the other hand, the pointer in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*q++</samp>
    is incremented first, so it refers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    character. However, the result of *postfix* increment operators is the value of
    the operand so that the original pointer value is dereferenced, producing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> character. Consequently,
    this code prints out the characters <samp class="SANS_TheSansMonoCd_W5Regular_11">dx</samp>.
    You can use parentheses to change or clarify the order of operations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Order of Evaluation</samp>
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *order of evaluation* of the operands of any C operator, including the order
    of evaluation of any subexpressions, is generally unspecified. The compiler will
    evaluate them in any order and may choose a different order when the same expression
    is evaluated again. This latitude allows the compiler to produce faster code by
    choosing the most efficient order. The order of evaluation is constrained by operator
    precedence and associativity.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-4](chapter4.xhtml#Lis4-4) demonstrates the order of evaluation for
    function arguments.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: The order of evaluation
    for function arguments</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Both functions <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp> access the global variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">glob</samp>, meaning they rely on a shared
    state. Because the order of evaluation of functions <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> is unspecified, the
    arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> may
    differ between compilations. If <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    is called first, it will return 10, but if it’s called last, it will return 52\.
    Function <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> always returns
    42 regardless of the order of evaluation. Consequently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    function (which returns the greater of the two values) may return either 42 or
    52, depending on the order of evaluation of its arguments. The only *sequencing
    guarantees* provided by this code are that both <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> are called before <samp
    class="SANS_TheSansMonoCd_W5Regular_11">max</samp> and that the executions of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    do not interleave.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite this code as follows to ensure it always behaves in a predictable,
    portable manner:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this revised program, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    is called to initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">f_val</samp>
    variable. This is guaranteed to be sequenced before the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>,
    which is called in the subsequent declaration to initialize the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">g_val</samp>. If one evaluation is *sequenced
    before* another evaluation, the first evaluation must complete before the second
    evaluation can begin. You can use sequence points (discussed in the following
    subsections) to guarantee that an object will be written before it is read. The
    execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is guaranteed
    to be sequenced before the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    because a sequence point exists between the evaluation of one full expression
    and the next full expression.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsequenced and Indeterminately
    Sequenced Evaluations</samp>
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The executions of unsequenced evaluations can *interleave*, meaning that the
    instructions can be executed in any order, provided that reads and writes are
    performed in the order specified by the program. A program that performs reads
    and writes in the order specified by the program is *sequentially consistent*
    (Lamport 1979).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Some evaluations are *indeterminately sequenced*, which means they cannot interleave
    but can still be executed in any order. For example, the following statement contains
    several value computations and side effects:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The values of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    must be read before their values can be incremented or decremented. This means
    that the reading of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> must
    be sequenced before the increment side effect, for example. Similarly, all side
    effects for the operands of the multiplication operation need to complete before
    the multiplication can occur. The multiplication must complete before the addition
    because of operator precedence rules. Finally, all side effects on the operands
    of the addition operation must complete before the addition can occur. These constraints
    produce a partial ordering among these operations because they don’t require that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> be incremented before <samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp> is decremented, for example.
    Unsequenced evaluations in this expression can be performed in any order, which
    allows the compiler to both reorder operations and to cache values in registers,
    allowing for faster overall execution. Function executions, on the other hand,
    are indeterminately sequenced and do not interleave with each other.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sequence Points</samp>
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *sequence point* is the juncture at which all side effects will have completed.
    These are implicitly defined by the language, but you can control when they occur
    by how you code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The sequence points are enumerated in Annex C of the C Standard. A sequence
    point occurs between the evaluation of one *full expression* (an expression that
    is not part of another expression or declarator) and the next full expression
    to be evaluated. A sequence point also occurs upon entering or exiting a called
    function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'If a side effect is unsequenced relative to either a different side effect
    on the same scalar or a value computation that uses the value of the same scalar
    object, the code has undefined behavior. A *scalar type* is either an arithmetic
    type or pointer type. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">* i++</samp> performs two unsequenced
    operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> as the following
    code snippet shows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You might think this code will produce the value 30, but because it has undefined
    behavior, that outcome isn’t guaranteed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Conservatively, we can ensure that side effects have completed before the value
    is read by placing every side-effecting operation in its own full expression.
    We can rewrite that code as follows to eliminate the undefined behavior:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This example now contains a sequence point between every side-effecting operation.
    However, it’s impossible to tell whether this rewritten code represents the programmer’s
    original intent because the original code had no defined meaning. If you choose
    to omit sequence points, you must be sure you completely understand the sequencing
    of side effects. We also can write this same code as follows without changing
    the behavior:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we have described the mechanics of expressions, we’ll return to discussing
    specific operators.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">sizeof Operator</samp>
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator
    to find the size in bytes of its operand; specifically, it returns an unsigned
    integer of <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type that
    represents the size. Knowing the correct size of an operand is necessary for most
    memory operations, including allocating and copying storage. The <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    type is defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>
    as well as in other header files. We need to include one of these header files
    to compile any code that references the <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator an unevaluated expression of a complete object type or a parenthesized
    name of such a type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s always safe to parenthesize the operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>,
    because parenthesizing an expression doesn’t change the way the size of the operand
    is calculated. The result of invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator is a constant expression unless the operand is a variable-length array.
    The operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> is
    not evaluated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: If you need to determine the number of bits of storage available, you can multiply
    the size of an object by <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>,
    which gives the number of bits contained in a byte. For example, the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT * sizeof(int)</samp> will
    produce the number of bits in an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arithmetic Operators</samp>
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators that perform arithmetic operations on arithmetic types are detailed
    in the following sections. We can also use some of these operators with nonarithmetic
    operands.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unary + and –</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *unary* <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp> *operators* operate on a single
    operand of arithmetic type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    operator returns the negative of its operand (that is, it behaves as though the
    operand were multiplied by –1). The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator just returns the value. These operators exist primarily to express positive
    and negative numbers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: If the operand has a small integer type, it’s promoted (see [Chapter 3](chapter3.xhtml)),
    and the result of the operation has the result of the promoted type. As a point
    of trivia, C has no negative integer literals. A value such as <samp class="SANS_TheSansMonoCd_W5Regular_11">–25</samp>
    is actually an rvalue of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp> preceded
    by the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> operator.
    However, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-25</samp>
    is guaranteed to be a constant integer expression.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logical Negation</samp>
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The result of the unary logical negation operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>)
    is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> if the evaluated value
    of its operand is not <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> if the evaluated value
    of its operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operand is a scalar type. The result has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    for historical reasons. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp> is equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>.
    The logical negation operator is frequently used to check for null pointers; for
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">!p</samp> is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">(nullptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">p)</samp>. Null pointers may not
    hold the value zero but are guaranteed to evaluate to false.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Additive</samp>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The binary additive operators include addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    and subtraction (<samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp>). We can
    apply addition and subtraction to two operands of arithmetic types, but we can
    also use them to perform scaled pointer arithmetic. I’ll discuss pointer arithmetic
    near the end of this chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The binary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator sums
    its two operands. The binary <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    operator subtracts the right operand from the left operand. The usual arithmetic
    conversions are performed on operands of arithmetic type for both operations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplicative</samp>
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The binary multiplicative operators include multiplication (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>),
    division (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>), and remainder
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>). The usual arithmetic
    conversions are implicitly performed on multiplicative operands to find a common
    type. You can multiply and divide both floating-point and integer operands, but
    remainder operates only on integer operands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Various programming languages implement different kinds of integer division
    operations, including Euclidean, flooring, and truncating. In *Euclidean division*,
    the remainder is always nonnegative (Boute 1992). In *flooring division*, the
    quotient is rounded toward negative infinity (Knuth 1997). In *truncating division*,
    the fractional part of the quotient is discarded, which is often referred to as
    *truncation toward zero*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The C programming language implements truncating division, meaning that the
    remainder always has the same sign as the dividend, as shown in [Table 4-2](chapter4.xhtml#tab4-2).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp> <samp class="SANS_Futura_Std_Book_11">Truncating
    Division</samp>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">/</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Quotient</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">%</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Remainder</samp>
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">  10 / 3</samp> | <samp class="SANS_Futura_Std_Book_11">  3</samp>
    | <samp class="SANS_Futura_Std_Book_11">  10 % 3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">  10 / –3</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">  10 % –3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">–10 / 3</samp> | <samp class="SANS_Futura_Std_Book_11">–3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–10 % 3</samp> | <samp class="SANS_Futura_Std_Book_11">–1</samp>
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">–10 / –3</samp> | <samp class="SANS_Futura_Std_Book_11">  3</samp>
    | <samp class="SANS_Futura_Std_Book_11">–10 % –3</samp> | <samp class="SANS_Futura_Std_Book_11">  1</samp>
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: To generalize, if the quotient <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp> is representable, then the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(a
    / b) * b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    % b</samp> equals <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. Otherwise,
    if the value of the divisor is equal to 0 or <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp> overflows, both <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">a % b</samp> will result in
    undefined behavior.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth taking the time to understand the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    operator to avoid surprises. For example, the following code defines a faulty
    function called <samp class="SANS_TheSansMonoCd_W5Regular_11">is_odd</samp> that
    attempts to test whether an integer is odd:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because the result of the remainder operation always has the sign of the dividend
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>, when <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    is negative and odd, <samp class="SANS_TheSansMonoCd_W5Regular_11">n % 2</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>, and the function
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'A correct, alternative solution is to test that the remainder is not <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (because a remainder of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> is the same regardless of the
    sign of the dividend):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Many central processing units (CPUs) implement remainder as part of the division
    operator, which can overflow if the dividend is equal to the minimum negative
    value for the signed integer type and the divisor is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>.
    This occurs even though the mathematical result of such a remainder operation
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The C standard library provides floating-point remainder, truncation, and rounding
    functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">fmod</samp>,
    among others.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bitwise Operators</samp>
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use *bitwise operators* to manipulate the bits of an object or any integer
    expression. Bitwise operators (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>) treat the bits as a pure
    binary model without concern for the values represented by these bits. Typically,
    they’re used on objects that represent *masks* or *bitmaps* where each bit indicates
    that something is “on” or “off,” “enabled” or “disabled,” or some other binary
    pairing. Using a mask, multiple bits can be set, unset, or inverted in a single
    bitwise operation. Masks and bitmaps are best represented as unsigned integer
    types, as the sign bit can be better used as a value and unsigned operations are
    less prone to undefined behavior.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Complement</samp>
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *unary complement operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>)
    works on a single operand of integer type and returns the *bitwise complement*
    of its operand—that is, a value in which each bit of the original value is flipped.
    The complement operator is used in applying the POSIX <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp>,
    for example. The <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp> masks
    or subtracts permissions. For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">077</samp> turns off read, write,
    and execute permissions for the group and others. A file’s permission mode is
    the result of a logical AND operation between the complement of the mask and the
    process’s requested permission mode setting.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer promotions are performed on the operand of the complement operator,
    and the result has the promoted type. For example, the following code snippet
    applies the <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operator to
    a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    type:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On an architecture with an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type and 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp> is assigned the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>. When <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp>
    is used as the operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp> is promoted
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> by zero-extending
    it to 32 bits, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000000FF</samp>.
    The complement of this value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFF00</samp>.
    Therefore, on this platform, complementing an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> type always results in a negative value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>. As a general policy and to avoid surprises such as this, bitwise operations
    should operate only on values of sufficiently wide unsigned integer types.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shift</samp>
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Shift operations* shift the value of each bit of an operand of integer type
    by a specified number of positions. Shifting is commonly performed in system programming,
    where bitmasks are common. Shift operations may also be used in code that manages
    network protocols or file formats to pack or unpack data. They include left-shift
    operations of the form'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'and right-shift operations of the form:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *shift expression* is the value to be shifted, and the *additive expression*
    is the number of bits by which to shift the value. [Figure 4-1](chapter4.xhtml#fig4-1)
    illustrates a logical left shift of 1 bit.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f04001.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A logical left
    shift of 1 bit</samp>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The additive expression determines the number of bits by which to shift the
    value. For example, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1
    << E2</samp> is the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    left-shifted <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> bit positions;
    vacated bits are filled with zeros. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    has an unsigned type, the resulting value is <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>. Values that cannot be represented
    in the resulting type will wrap around. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    has a signed type and nonnegative value and if <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp> is representable in the
    result type, then that is the resulting value; otherwise, it is undefined behavior.
    Similarly, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1 >> E2</samp>
    is the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> right-shifted
    <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> bit positions. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has an unsigned type or if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has a signed type and a nonnegative
    value, the value of the result is the integral part of the quotient of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1/2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    has a signed type and a negative value, the resulting value is implementation
    defined and may be either an arithmetic (sign-extended) shift or a logical (unsigned)
    shift, as shown in [Figure 4-2](chapter4.xhtml#fig4-2).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f04002.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: An arithmetic (signed)
    right shift and a logical (unsigned) right shift of 1 bit</samp>'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In both shift operations, the integer promotions are performed on the operands,
    each of which has an integer type. The type of the result is that of the promoted
    left operand. The usual arithmetic conversions are *not* performed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-5](chapter4.xhtml#Lis4-5) shows how to perform right-shift operations
    on signed and unsigned integers that are free from undefined behavior.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Correct right-shift
    operations</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: For signed integers ❶, you must ensure that the number of bits shifted is not
    negative, greater than, or equal to the width of the promoted left operand. For
    unsigned integers ❷, you omit the test for negative values, as unsigned integers
    can never be negative. You can perform safe left-shift operations in a similar
    manner.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise AND</samp>
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The binary *bitwise AND operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    returns the bitwise AND of two operands of integer type. The usual arithmetic
    conversions are performed on both operands. Each bit in the result is set if and
    only if each of the corresponding bits in the converted operands is set, as shown
    in [Table 4-3](chapter4.xhtml#tab4-3).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise
    AND Truth Table</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise Exclusive
    OR</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The *bitwise exclusive OR operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>)
    returns the bitwise exclusive OR of the operands of integer type. The operands
    must be integers, and the usual arithmetic conversions are performed on both.
    Each bit in the result is set if and only if exactly one of the corresponding
    bits in the converted operands is set, as shown in [Table 4-4](chapter4.xhtml#tab4-4).
    You can also think of this operation as “one or the other, but not both.”
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-4:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise
    Exclusive OR Truth Table</samp>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">^</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: Exclusive OR is equivalent to the addition operation on the integers modulo
    2—that is, because of wraparound 1 + 1 mod 2 = 0 (Lewin 2012).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Beginners commonly mistake the exclusive OR operator for an exponent operator,
    erroneously believing that the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>
    will compute 2 raised to the power of 7\. The correct way to raise a number to
    a certain power in C is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp>
    functions defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>,
    as shown in [Listing 4-6](chapter4.xhtml#Lis4-6). The <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp>
    functions operate on floating-point arguments and return a floating-point result,
    so be aware that these functions might fail to produce the expected results because
    of truncation or other errors.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Using the</samp>
    <samp class="I">pow</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">functions</samp>'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: This code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp>
    function to compute 2 raised to the power of 7\. Because 2⁷ equals 128, this program
    will print <samp class="SANS_TheSansMonoCd_W5Regular_11">equal</samp>.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise Inclusive
    OR</samp>
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *bitwise inclusive OR* (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>)
    *operator* returns the bitwise inclusive OR of two operands. Each bit in the result
    is set if and only if at least one of the corresponding bits in the converted
    operands is set, as shown in [Table 4-5](chapter4.xhtml#tab4-5).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-5:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise
    Inclusive OR Truth Table</samp>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">y</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&#124;</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">y</samp> |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: The operands must be integers, and the usual arithmetic conversions are performed
    on both.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Logical Operators</samp>
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *logical AND* (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>)
    and *OR* (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>) *operators*
    are used primarily for logically joining two or more expressions of scalar type.
    They’re commonly used in condition tests to combine multiple comparisons together,
    such as in the first operand of the conditional operator, the controlling expression
    of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, or the
    controlling expression of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. You shouldn’t use logical operators with bitmap operands, as they are intended
    primarily for Boolean logic.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> operator returns
    1 if neither of its operands is equal to 0 and returns 0 otherwise. Logically,
    this means that <samp class="SANS_TheSansMonoCd_W5Regular_11">a && b</samp> is
    true only if both <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is true
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is true.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operator returns
    1 if either of its operands is not equal to 0 and returns 0 otherwise. Logically,
    this means that <samp class="SANS_TheSansMonoCd_W5Regular_11">a || b</samp> is
    true if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is true, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is true, or both <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are true.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The C standard defines both operations in terms of “not equal to zero” because
    the operands can have values other than 0 and 1\. Both operators accept operands
    of scalar type (integers, floats, and pointers), and the result of the operation
    has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the corresponding bitwise binary operators, the logical AND operator
    and logical OR operator guarantee left-to-right evaluation. Both operators *short-circuit*:
    The second operand is not evaluated if the result can be deduced solely by evaluating
    the first operand. If the second operand is evaluated, there is a sequence point
    between the evaluations of the first and second operands. For example, the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0 && unevaluated</samp> returns
    0 regardless of the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp>
    because there is no possible value for <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp>
    that produces a different result. Because of this, <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp>
    is not evaluated to determine its value. The same is true for <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    || unevaluated</samp> because this expression always returns 1.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Short-circuiting is commonly used in operations with pointers:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code tests the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is null, the second
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> operand is not evaluated,
    preventing a null pointer dereference.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Short-circuiting can also be used to avoid unnecessary computing. In the following
    expression, the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp>
    predicate function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if the file is ready:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp>
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, the
    second <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operand is not
    evaluated, as there is no need to prepare the file. This avoids potential errors
    or, when <samp class="SANS_TheSansMonoCd_W5Regular_11">prepare_file</samp> is
    idempotent, unnecessary computing, assuming the cost of determining whether the
    file is ready is less than the cost of preparing the file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers should exercise caution if the second operand contains side effects,
    because it may not be apparent whether these side effects occur. For example,
    in the following code, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    is incremented only when <samp class="SANS_TheSansMonoCd_W5Regular_11">i >=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code may be correct, but it’s likely a programmer error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Cast Operators</samp>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Casts* (also known as *type casts*) explicitly convert a value of one type
    to a value of another type. To perform a cast, we precede an expression with a
    parenthesized type name, which converts the value of the expression to the unqualified
    version of the named type. The following code illustrates an explicit conversion,
    or cast, of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> from type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unless the type name specifies a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type, the type name must be a qualified or unqualified scalar type. The operand
    must also have scalar type; a pointer type cannot be converted to any floating-point
    type, and vice versa.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Casts are extremely powerful and must be used carefully. For one thing, casts
    may reinterpret the existing bits as a value of the specified type without changing
    the bits:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Casts may also change these bits into whatever bits are needed to represent
    the original value in the resulting type:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Casts can also disable diagnostics. For example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This generates the following diagnostic when compiled with Visual C++ 2022
    with warning level <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp>:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Adding a cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    disables the diagnostic without fixing the problem:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To mitigate these risks, C++ defines its own casts, which are less powerful.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conditional Operator</samp>
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *conditional operator* (<samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>) is the only C operator that takes three operands. It returns a result
    based on the condition. You can use the conditional operator like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The conditional operator evaluates the first operand, called the *condition*.
    The second operand (<samp class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfTrue</samp>)
    is evaluated if the condition is true, or the third operand (<samp class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfFalse</samp>)
    is evaluated if the condition is false. The result is the value of either the
    second or third operand (depending on which operand was evaluated).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This result is converted to a common type based on the second and third operands.
    There is a sequence point between the evaluation of the first operand and the
    evaluation of the second or third operand (whichever is evaluated) so that the
    compiler will ensure that all side effects resulting from evaluating the condition
    have completed before the second or third operand is evaluated.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The conditional operator is similar to an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp>
    control flow block but returns a value as a function does. Unlike with an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> control flow block, you
    can use the conditional operator to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first operand to the conditional operator must have scalar type. The second
    and third operands must have compatible types (roughly speaking). For more details
    on the constraints for this operator and the specifics of determining the return
    type, refer to Section 6.5.15 of the C standard (ISO/IEC 9899:2024).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">alignof Operator</samp>
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp> operator yields
    an integer constant representing the alignment requirement of its operand’s declared
    complete object type. It does not evaluate the operand. When applied to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp> type, it returns the alignment
    requirement of the element type. An alternative spelling of <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp>
    is available for this operator. Prior to C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    spelling was available through a convenience macro provided in the header <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stdalign.h></samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    operator is useful in static assertions that are used to verify assumptions about
    your program (discussed further in [Chapter 11](chapter11.xhtml)). The purpose
    of these assertions is to diagnose situations in which your assumptions are invalid.
    [Listing 4-7](chapter4.xhtml#Lis4-7) demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    operator.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: The</samp> <samp
    class="I">alignof</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple program doesn’t accomplish anything particularly useful. It declares
    an array <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> of four integers
    followed by a static assertion concerning the alignment of the array and a runtime
    assertion concerning the alignment of <samp class="SANS_TheSansMonoCd_W5Regular_11">max_align_t</samp>
    (an object type whose alignment is the greatest fundamental alignment). It then
    prints out these values. This program will not compile if either static assertion
    is false, or it will output the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'These alignments are characteristic of the x86-64 architecture.  ## <samp class="SANS_Futura_Std_Bold_B_11">Relational
    Operators</samp>'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The *relational operators* include equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>),
    not equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>), less than
    (<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>), greater than (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp>), less than or equal to (<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>), and greater than or equal
    to (<samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>). Each returns 1 if
    the specified relationship is true and 0 if it is false. The result has type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, again, for historical reasons.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that C does not interpret the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    < b < c</samp> to mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> but less
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, as ordinary mathematics
    does. Instead, the expression is interpreted to mean <samp class="SANS_TheSansMonoCd_W5Regular_11">(a
    < b) < c</samp>. In English, if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, the compiler
    should compare <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp>; otherwise, it compares <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    If this is your intent, include the parentheses to make that clear to any potential
    code reviewer. Some compilers such as GCC and Clang provide the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wparentheses</samp>
    flag to diagnose those problems. To determine whether <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> but less
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, you can write this
    test: <samp class="SANS_TheSansMonoCd_W5Regular_11">(a < b) && (b < c)</samp>.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The equality and inequality operators have lower precedence than the relational
    operators—and assuming otherwise is a common mistake. This means that the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c < d</samp> is evaluated the same
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">(a < b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(c < d)</samp>. In both cases, the
    comparisons <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">c < d</samp> are evaluated first, and
    the resulting values (either <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>) are compared for equality.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: We can use these operators to compare arithmetic types or pointers. When we
    compare two pointers, the result depends on the relative locations in the address
    space of the objects pointed to. If both pointers point to the same object, they
    are equal.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Equality and inequality operators differ from the other relational operators.
    For example, you cannot use the other relational operators on two pointers to
    unrelated objects, because doing so makes no sense and is consequently undefined
    behavior:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You might compare pointers, for example, to determine whether you have reached
    the too-far element of an array.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compound Assignment Operators</samp>
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Compound assignment operators*, shown in [Table 4-6](chapter4.xhtml#tab4-6),
    modify the current value of an object by performing an operation on it.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-6:</samp> <samp class="SANS_Futura_Std_Book_11">Compound
    Assignment Operators</samp>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assignment
    by</samp> |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Sum and difference</samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp> | <samp class="SANS_Futura_Std_Book_11">Product,
    quotient, and remainder</samp> |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise left shift and right shift</samp>
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;=</samp>
    | <samp class="SANS_Futura_Std_Book_11">Bitwise AND, XOR, and OR</samp> |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: A compound assignment of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> *=* <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp>
    is equivalent to the simple assignment expression <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(E2)</samp>,
    except that <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> is evaluated
    only once. Compound assignments are primarily used as shorthand notation. There
    are no compound assignment operators for logical operators.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comma Operator</samp>
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C, we use commas in two distinct ways: as operators and to separate items
    in a list (such as arguments to functions or lists of declarations). The *comma*
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>) *operator* is a way to
    evaluate one expression before another. First, the left operand of a comma operator
    is evaluated as a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> expression.
    There is a sequence point between the evaluation of the left operand and the evaluation
    of the right operand. Then, the right operand is evaluated after the left. The
    comma operation has the type and value of the right operand—mostly because it
    is the last expression evaluated.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t use the comma operator in contexts in which a comma might separate
    items in a list. Instead, you would include a comma within a parenthesized expression
    or within the second expression of a conditional operator. For example, assume
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> each have type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in the following call to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first comma separates the first and second arguments to the function. The
    second comma is a comma operator. The assignment is evaluated first, followed
    by the addition. Because of the sequence point, the assignment is guaranteed to
    complete before the addition takes place. The result of the comma operation has
    the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. The third comma separates the
    second and third arguments to the function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pointer Arithmetic</samp>
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, we mentioned that the additive operators (addition
    and subtraction) can be used with either arithmetic operands or object pointers.
    In this section, we discuss adding a pointer and an integer, subtracting two pointers,
    and subtracting an integer from a pointer.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding or subtracting an expression that has an integer type to or from a pointer
    returns a value with the type of the pointer operand. If the pointer operand points
    to an element of an array, then the result points to an element offset from the
    original element. If the resulting pointer is beyond the bounds of the array,
    undefined behavior occurs. The difference of the array subscripts of the resulting
    and original array elements equals the integer expression:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Pointer arithmetic is automatically *scaled* to the size of the array element,
    rather than individual bytes. C allows a pointer to be formed to each element
    of an array, including one past the last element of the array object (also referred
    to as the *too-far* pointer). While this might seem unusual or unnecessary, many
    early C programs incremented a pointer until it was equal to the too-far pointer,
    and the C standards committee didn’t want to break all this code, which is also
    idiomatic in C++ iterators. [Figure 4-3](chapter4.xhtml#fig4-3) illustrates forming
    the *too-far* pointer.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f04003.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: One past the last
    element of an array object</samp>'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: If both the pointer operand and the result point to elements of the same array
    object or the too-far pointer, the evaluation did not overflow; otherwise, the
    behavior is undefined. To satisfy the too-far requirement, an implementation need
    only provide one extra byte (which can overlap another object in the program)
    just after the end of the object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: C also allows objects to be treated as an array containing only a single element,
    allowing you to obtain a too-far pointer from a scalar.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'The too-far special case allows us to advance a pointer until it is equal to
    the too-far pointer, as in the following function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement
    (explained in detail in the next chapter) in the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum_m_elems</samp>
    function loops while <samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp> is
    less than the address of the too-far pointer for the array <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>.
    The pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp> is incremented
    at the end of each iteration of the loop until the too-far pointer is formed,
    causing the loop condition to evaluate to 0 when tested.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: When we subtract one pointer from another, both must point to elements of the
    same array object or the too-far element. This operation returns the difference
    of the subscripts of the two array elements. The type of the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp>
    (a signed integer type). You should take care when subtracting pointers, because
    the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp> may
    not be sufficient to represent the difference of pointers to elements of very
    large character arrays.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use operators to write simple expressions
    that perform operations on various object types. Along the way, you learned about
    some core C concepts, such as lvalues, rvalues, value computations, and side effects,
    which determine how expressions are evaluated. You also learned how operator precedence,
    associativity, order of evaluation, sequencing, and interleaving can affect the
    total order in which a program is executed. In the next chapter, you’ll learn
    more about how to control the execution of your program by using selection, iteration,
    and jump statements.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
