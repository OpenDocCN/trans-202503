["```\n% **security cms -D -i BlockBlock.app/Contents/embedded.provisionprofile**\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n...\n<plist version=\"1.0\">\n<dict>\n    <key>AppIDName</key>\n    <string>BlockBlock</string>\n    <key>DeveloperCertificates</key>\n    <array>\n        <data> ... </data>\n    </array>\n    <key>Entitlements</key>\n    <dict>\n        <key>com.apple.developer.endpoint-security.client</key>\n        <true/>\n        <key>com.apple.application-identifier</key>\n        <string>VBG97UB4TA.com.objective-see.blockblock</string>\n        ...\n    </dict>\n    ... \n```", "```\n% **codesign -d --entitlements - BlockBlock.app**\nExecutable=BlockBlock.app/Contents/MacOS/BlockBlock\n[Dict]\n    [Key] com.apple.application-identifier\n    [Value]\n        [String] VBG97UB4TA.com.objective-see.blockblock\n    [Key] **com.apple.developer.endpoint-security.client**\n    [Value]\n        [Bool] true\n    ... \n```", "```\n<dict>\n   <key>description</key>\n   <string>Launch D &amp; A</string>\n   <key>paths</key>\n   <array>\n      <string>^(\\/System|\\/Users\\/[^\\/]+|)\\/Library\\/(LaunchDaemons|\n      LaunchAgents)\\/.+\\.(?i)plist$</string>\n   </array>\n   <key>class</key>\n   <string>Launchd</string>\n   <key>alert</key>\n   <string>installed a launch daemon or agent</string>\n   ...\n</dict> \n```", "```\n-(id)initWithParams:(NSDictionary*)watchItemInfo {\n    ...\n    NSMutableArray* regexes = [NSMutableArray array];\n for(NSString* regex in watchItemInfo[@\"paths\"]) {\n        NSRegularExpression* compiledRegex =\n        [NSRegularExpression regularExpressionWithPattern:regex\n        options:NSRegularExpressionCaseInsensitive error:NULL];\n\n        [self.regexes addObject:compiledRegex];\n    }\n\n    self.alertMsg = watchItemInfo[@\"alert\"];\n    self.description = watchItemInfo[@\"description\"];\n    ...\n    return self;\n} \n```", "```\n-(BOOL)isMatch:(File*)file {\n    __block BOOL matched = NO;\n    NSString* path = file.destinationPath;\n\n  ❶ [self.regexes enumerateObjectsWithOptions:NSEnumerationConcurrent\n    usingBlock:^(NSRegularExpression* _Nonnull regex, NSUInteger idx, BOOL\n    * _Nonnull stop) {\n\n      ❷ NSTextCheckingResult* match = [regex firstMatchInString:path options:0\n        range:NSMakeRange(0, path.length)];\n        if((nil == match) || (NSNotFound == match.range.location)) {\n            return;\n        }\n\n      ❸ matched = YES;\n        *stop = YES;\n    }];\n\n    return matched;\n} \n```", "```\nes_event_type_t events[] = {ES_EVENT_TYPE_NOTIFY_CREATE, ES_EVENT_TYPE_NOTIFY_WRITE,\nES_EVENT_TYPE_NOTIFY_RENAME, ES_EVENT_TYPE_NOTIFY_EXEC, ES_EVENT_TYPE_NOTIFY_EXIT}; ❶\n\nFileCallbackBlock block = ^(File* file) {\n    ...\n    [self processEvent:file plugin:nil message:nil]; ❷\n};\n\nFileMonitor* fileMon = [[FileMonitor alloc] init];\n[fileMon start:events count:sizeof(events)/sizeof(events[0]) csOption:csNone callback:block];\n... \n```", "```\nes_event_type_t btmESEvents[] = {ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD}; ❶\n\nes_new_client(&_endpointClient, ^(es_client_t* client, const es_message_t* message) { ❷\n    // Message handler code removed for brevity ❸\n});\n\nes_subscribe(self.endpointClient, btmESEvents, sizeof(btmESEvents)/sizeof(btmESEvents[0])); ❹ \n```", "```\nes_new_client(&_endpointClient, ^(es_client_t* client, const es_message_t* message) {\n    File* file = [[File alloc] init:(es_message_t*)message csOption:csNone]; ❶\n\n    if((ES_BTM_ITEM_TYPE_AGENT == message->event.btm_launch_item_add->item->item_type) || ❷\n        (ES_BTM_ITEM_TYPE_DAEMON == message->event.btm_launch_item_add->item->item_type)) {\n        file.destinationPath =\n        convertStringToken(&message->event.btm_launch_item_add->item->item_url);\n    }\n    es_message_t* messageCopy = NULL;\n\n    if(@available(macOS 11.0, *)) { ❸\n        es_retain_message(message);\n        messageCopy = (es_message_t*)message;\n    } else {\n messageCopy = es_copy_message(message);\n    }\n    [monitor processEvent:file plugin:btmPlugin message:messageCopy]; ❹\n}); \n```", "```\n-(NSString*)itemObject:(Event*)event {\n    NSString* itemObject = nil;\n\n    if((ES_BTM_ITEM_TYPE_AGENT ==\n    event.esMessage->event.btm_launch_item_add->item->item_type) || ❶\n    (ES_BTM_ITEM_TYPE_DAEMON ==\n    event.esMessage->event.btm_launch_item_add->item->item_type)) {\n        itemObject =\n        convertStringToken(&event.esMessage->event.btm_launch_item_add->executable_path);\n    } else {\n        NSString* stringToken =\n        convertStringToken(&event.esMessage->event.btm_launch_item_add->item->item_url); ❷\n        itemObject = [[NSURL URLWithString:stringToken] path];\n    }\n    return itemObject;\n} \n```", "```\n-(BOOL)block:(Event*)event {\n    __block BOOL wasBlocked = NO;\n\n    switch(event.esMessage->event.btm_launch_item_add->item->item_type) {\n      ❶ case ES_BTM_ITEM_TYPE_APP:\n        case ES_BTM_ITEM_TYPE_LOGIN_ITEM: {\n            LoginItem* loginItem = [[LoginItem alloc] init];\n            wasBlocked = [loginItem block:event];\n            break;\n        }\n      ❷ case ES_BTM_ITEM_TYPE_AGENT:\n        case ES_BTM_ITEM_TYPE_DAEMON: {\n            Launchd* launchItem = [[Launchd alloc] init];\n            wasBlocked = [launchItem block:event];\n            break;\n        }\n        ...\n     }\n     return wasBlocked;\n} \n```", "```\n@interface XPCListener : NSObject <NSXPCListenerDelegate>\n    @property(weak)NSXPCConnection* client;\n    @property(nonatomic, retain)NSXPCListener* listener;\n    ...\n} \n```", "```\n#define DAEMON_MACH_SERVICE @\"com.objective-see.blockblock\"\n\nself.listener = [[NSXPCListener alloc] initWithMachServiceName:DAEMON_MACH_SERVICE]; \n```", "```\nself.listener.delegate = self;\n[self.listener resume]; \n```", "```\n-(BOOL)listener(NSXPCListener*)listener shouldAcceptNewConnection:\n(NSXPCConnection*)newConnection {\n    BOOL shouldAccept = NO;\n\n    // Code to authorize the client, and ignore unauthorized ones, removed for brevity\n\n    [newConnection resume];\n    shouldAccept = YES;\n\nbail:\n    return shouldAccept;\n} \n```", "```\n@interface ExtendedNSXPCConnection : NSXPCConnection {\n    audit_token_t auditToken;\n}\n    @property audit_token_t auditToken;\n@end \n```", "```\n-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:(NSXPCConnection*)\nnewConnection {\n    ...\n    audit_token_t auditToken = ((ExtendedNSXPCConnection*)newConnection).auditToken;\n    ...\n} \n```", "```\n\" ❶ anchor apple generic and ❷ identifier \\\"com.objective-see.blockblock\n.helper\\\" and ❸ certificate leaf [subject.CN] = \\\"Developer ID Application:\nObjective-See, LLC (VBG97UB4TA)\\\" and ❹ info [CFBundleShortVersionString]\n>= \\\"2.0.0\\\"\"; \n```", "```\n#define HELPER_ID @\"com.objective-see.blockblock.helper\"\n#define SIGNING_AUTH @\"Developer ID Application: Objective-See, LLC (VBG97UB4TA)\"\n\n-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:(NSXPCConnection*)\nnewConnection {\n    BOOL shouldAccept = NO;\n    audit_token_t auditToken = ((ExtendedNSXPCConnection*)newConnection).auditToken;\n\n    OSStatus status = SecCodeCopyGuestWithAttributes(NULL, (__bridge CFDictionaryRef _Nullable)\n    (@{(__bridge NSString*)kSecGuestAttributeAudit : [NSData dataWithBytes:&auditToken\n    length:sizeof(audit_token_t)]}), kSecCSDefaultFlags, &codeRef);\n    if(errSecSuccess != status) {\n        goto bail;\n    }\n\n    status = SecCodeCheckValidity(codeRef, kSecCSDefaultFlags, NULL);\n    if(errSecSuccess != status)  {\n        goto bail;\n    }\n\n    status = SecCodeCopySigningInformation(codeRef, kSecCSDynamicInformation, &csInfo);\n    if(errSecSuccess != status)  {\n        goto bail;\n    }\n\n    uint32_t csFlags = [((__bridge NSDictionary*)csInfo)[(__bridge NSString*)\n    kSecCodeInfoStatus] unsignedIntValue];\n    if(!(CS_VALID & csFlags) && !(CS_RUNTIME & csFlags)) {\n        goto bail;\n    }\n\n    NSString* requirement = [NSString stringWithFormat:@\"anchor apple generic and\n    identifier \\\"%@\\\" and certificate leaf [subject.CN] = \\\"%@\\\" and info\n    [CFBundleShortVersionString] >= \\\"2.0.0\\\"\", HELPER_ID, SIGNING_AUTH];\n\n    SecTaskRef taskRef = SecTaskCreateWithAuditToken(NULL, ((ExtendedNSXPCConnection*)\n    newConnection).auditToken);\n\n    status = SecTaskValidateForRequirement(taskRef, (__bridge CFStringRef)(requirement));\n    if(errSecSuccess != status) {\n        goto bail;\n    }\n\n    shouldAccept = YES;\n\n    // Add code here to configure and finalize the NSXPCConnection.\n\nbail:\n    return shouldAccept;\n} \n```", "```\n#define DAEMON_MACH_SERVICE @\"com.objective-see.blockblock\"\n#define HELPER_ID @\"com.objective-see.blockblock.helper\"\n#define SIGNING_AUTH @\"Developer ID Application: Objective-See, LLC (VBG97UB4TA)\"\n\nself.listener = [[NSXPCListener alloc] initWithMachServiceName:DAEMON_MACH_SERVICE];\n\nif(@available(macOS 13.0, *)) {\n    NSString* requirement = [NSString stringWithFormat:@\"anchor apple generic and\n    identifier \\\"%@\\\" and certificate leaf [subject.CN] = \\\"%@\\\" and info\n    [CFBundleShortVersionString] >= \\\"2.0.0\\\"\", HELPER_ID, SIGNING_AUTH]; ❶\n\n    [self.listener setConnectionCodeSigningRequirement:requirement]; ❷\n}\n\nself.listener.delegate = self;\n[self.listener resume]; \n```", "```\nDefault     0x0     56198  0    BlockBlock: (libxpc.dylib) **Bogus check-in attempt. Ignoring**.\n```", "```\n@protocol XPCDaemonProtocol\n    -(void)getPreferences:(void (^)(NSDictionary*))reply;\n    -(void)updatePreferences:(NSDictionary*)preferences;\n    -(void)getRules:(void (^)(NSData*))reply;\n    -(void)deleteRule:(Rule*)rule reply:(void (^)(NSData*))reply;\n    -(void)alertReply:(NSDictionary*)alert;\n@end \n```", "```\n-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:\n(NSXPCConnection*)newConnection {\n    // Code to authorize the client, and ignore unauthorized ones, removed for brevity\n\n    newConnection.exportedInterface =\n    [NSXPCInterface interfaceWithProtocol:@protocol(XPCDaemonProtocol)];\n    ... \n```", "```\n-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:\n(NSXPCConnection*)newConnection {\n    // Code to authorize the client, and ignore unauthorized ones, removed for brevity\n    ...\n    newConnection.exportedObject = [[XPCDaemon alloc] init];\n    ... \n```", "```\n@interface XPCDaemon : NSObject <**XPCDaemonProtocol**>\n@end \n```", "```\n-(void)getRules:(void (^)(NSData*))reply {\n    NSData* archivedRules = [NSKeyedArchiver archivedDataWithRootObject:\n    rules.rules requiringSecureCoding:YES error:nil];\n\n    reply(archivedRules);\n} \n```", "```\n-(void)alertReply:(NSDictionary*)alert {\n    Event* event = nil;\n    @synchronized(events.reportedEvents) {\n      ❶ event = events.reportedEvents[alert[ALERT_UUID]];\n    }\n\n  ❷ event.action = [alert[ALERT_ACTION] unsignedIntValue];\n    if(BLOCK_EVENT == event.action) {\n      ❸ [event.plugin block:event];\n    }\n    ...\n    if(YES != [alert[ALERT_TEMPORARY] boolValue]) {\n      ❹ [rules add:event];\n    }\n} \n```", "```\n@protocol XPCUserProtocol\n    -(void)alertShow:(NSDictionary*)alert;\n    ...\n@end \n```", "```\n-(BOOL)listener:(NSXPCListener*)listener shouldAcceptNewConnection:\n(NSXPCConnection*)newConnection {\n    // Code to authorize the client, and ignore unauthorized ones, removed for brevity\n    ...\n    newConnection.remoteObjectInterface =\n    [NSXPCInterface interfaceWithProtocol:@protocol(XPCUserProtocol)]; \n```", "```\n#define DAEMON_MACH_SERVICE @\"com.objective-see.blockblock\"\nNSXPCConnection* daemon = [[NSXPCConnection alloc]\ninitWithMachServiceName:DAEMON_MACH_SERVICE options:0]; \n```", "```\n#define DAEMON_MACH_SERVICE @\"com.objective-see.blockblock\"\n\nNSXPCConnection* daemon = [[NSXPCConnection alloc]\ninitWithMachServiceName:DAEMON_MACH_SERVICE options:0];\n\ndaemon.remoteObjectInterface =\n[NSXPCInterface interfaceWithProtocol: @protocol(XPCDaemonProtocol)]; ❶\n\ndaemon.exportedInterface = [NSXPCInterface interfaceWithProtocol:@protocol(XPCUserProtocol)];\ndaemon.exportedObject = [[XPCUser alloc] init]; ❷\n\n[daemon resume]; ❸ \n```", "```\nXPCDaemonClient* xpcDaemonClient = [[XPCDaemonClient alloc] init];\nNSArray* rules = [[xpcDaemonClient getRules]; \n```", "```\n-(NSArray*)getRules {\n    __block NSDictionary* unarchivedRules = nil;\n    ...\n    [[self.daemon synchronousRemoteObjectProxyWithErrorHandler:^(NSError* proxyError) { ❶\n        // Code to handle any errors removed for brevity ❷\n    }] getRules:^(NSData* archivedRules) {\n        // Code to process the serialized rules from the daemon removed for brevity ❸\n    }];\n    ...\n    return rules;\n} \n```"]