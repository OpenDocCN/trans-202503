- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">USING
    MULTIPLE I</samp><samp class="SANS_Dogma_OT_Bold_B-SUP_11">2</samp><samp class="SANS_Dogma_OT_Bold_B_11">C
    DEVICES WITH THE SAME ADDRESS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: In your Arduino journey, you’ve likely come across devices that interface via
    the I²C bus, a simple two-wire data bus for which the Arduino is considered the
    *primary* device, and each additional device or IC on the bus is a *secondary*
    device. Each secondary device has its own address that allows the Arduino to communicate
    with it. If two or more devices have the same bus address, however, you simply
    can’t use them together on the same bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter shows you how to use two or more devices with the same bus address
    with the help of the TCA9548A I²C switch IC. You’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Build an I²C address scanner to determine device bus addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use compact graphic organic light-emitting diode (OLED) displays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the BMP180 temperature and air pressure sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine the BMP180 and OLED devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To prepare you to work with multiple I²C devices at once, I’ll first introduce
    a simple tool that reports the bus address of a device connected to the Arduino’s
    I²C bus: the I²C bus scanner.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’re not familiar with the I* *²**C bus, you can review Chapter 19 of*
    Arduino Workshop*, 2nd edition.*'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #30: Using an I²C Bus Scanner</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll learn to use an I²C bus scanner. This tool helps you
    gather information on parts or devices whose documentation you can’t find, such
    as the part’s bus address. It’s also ideal for quick I²C bus testing once you’ve
    connected a device to the bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard or mounting for the I²C device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hardware connection will depend on the I²C device under test. As an example,
    I’ll use the BMP180 sensor for temperature, barometric pressure, and altitude,
    as shown in [Figure 10-1](chapter10.xhtml#fig10-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![A BMP180 TEMPERATURE SENSOR CONNECTED TO AN ARDUINO UNO WITH WIRES AND A
    SOLDERLESS BREADBOARD](../images/fig10-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: The BMP180 sensor
    board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also use the BMP180 later in the chapter and elsewhere in this book,
    but for this project, you can use any I²C device that’s 5 V tolerant. If your
    device isn’t a module, don’t forget to use pull-up resistors as you normally would.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch for this project is provided with the Arduino IDE. Open and upload
    the i2c_scanner sketch included with the Wire library examples, by selecting **File**
    ![](../images/arr.png) **Examples** ![](../images/arr.png) **Wire** ![](../images/arr.png)
    **i2c_scanner**.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch should interrogate the bus and report the address (or addresses)
    found in the Serial Monitor, as shown in [Figure 10-2](chapter10.xhtml#fig10-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREEN CAPTURE OF THE I2C SCANNER SKETCH OUTPUT ON THE SERIAL MONITOR](../images/fig10-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The results of
    the I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">C scanner sketch</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you have two or more devices on the bus, the scanner will report both addresses,
    but you won’t know which device belongs to which address. For example, [Figure
    10-3](chapter10.xhtml#fig10-3) shows the bus addresses for the two devices connected
    to the bus. When you’re using two or more devices at once with the scanner, it’s
    okay to remove one or more devices even when the power is on, as the I²C bus is
    capable of “hot swapping.” That is, it’s designed to allow for devices to be connected
    or removed while operating.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREEN CAPTURE OF THE I2C SCANNER SKETCH OUTPUT ON THE SERIAL MONITOR,
    SHOWING TWO DEVICES’ BUS ADDRESSES](../images/fig10-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: The results of
    the I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">C scanner sketch with two devices</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch is quite simple. Let’s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The sketch starts and finishes an I²C connection to every possible I²C address
    location (0 through 127) ❶. If a device exists on the address being tested, the
    sketch returns an error code of 0 ❷; if an error occurs, it returns a 4 ❸. If
    it doesn’t find any devices, it prints the message <samp class="SANS_TheSansMonoCd_W5Regular_11">No
    I2C devices found</samp> ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to connect an I²C device or two to the bus, let’s get
    started with the TCA9548A.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The TCA9548A Breakout Board</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TCA9548A, shown on a breakout board in [Figure 10-4](chapter10.xhtml#fig10-4),
    allows you to connect the single I²C bus from your Arduino to one of eight separate
    buses that emanate from the TCA9548A, each of which operates in the same manner
    as the Arduino’s original I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A TCA9548A BREAKOUT BOARD](../images/fig10-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: The TCA9548A breakout
    board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The TCA9548A also handles voltage translation, enabling you to use devices with
    the host Arduino that operate on different voltages—a convenient benefit, since
    an increasing number of devices operate only at 3.3 V or 1.8 V. Unfortunately,
    the TCA9548A is available in surface-mount format only, so it can’t be used with
    a solderless breadboard or prototyping board. Instead, you’ll need to use the
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The TCA9548A breakout board should include a pair of inline header pins that
    are not yet soldered to the board. Let’s solder them in now. To line up the pins
    properly, you can drop them into a solderless breadboard, as shown in [Figure
    10-5](chapter10.xhtml#fig10-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![A TCA9548A BREAKOUT BOARD WITH INLINE HEADER PINS IN A SOLDERLESS BREADBOARD](../images/fig10-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: The TCA9548A breakout
    board with inline header pins before soldering</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After you solder in the pins, your board is ready for use in solderless breadboards
    and other hardware solutions, as shown in [Figure 10-6](chapter10.xhtml#fig10-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![A TCA9548A BREAKOUT BOARD WITH INLINE HEADER PINS SOLDERED TO PCB PADS](../images/fig10-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: The TCA9548A breakout
    board with inline header pins soldered to PCB pads</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The pinouts on the board match the schematic diagram shown in [Figure 10-7](chapter10.xhtml#fig10-7),
    which also includes the connections you should make to your Arduino Uno or compatible
    board.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE TCA9548A BREAKOUT BOARD SCHEMATIC](../images/fig10-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-7: The TCA9548A schematic</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The TCA9548A requires pull-up resistors between the I²C bus and the positive
    power rail; these resistors are included on the breakout board.
  prefs: []
  type: TYPE_NORMAL
- en: The pins labeled A0 to A2 in the schematic are used to define the bus address
    for the TCA9548A. As you can see, the schematic sets them all to GND. If you run
    the port scanner, it will return an address of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>.
    If necessary, you can change the address by connecting the pins A0 to A2 to combinations
    of GND or 5V, as listed in [Table 10-1](chapter10.xhtml#tab10-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">TCA9548A
    Address Configuration</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">A0</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">A1</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">A2</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Address</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x70</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x71</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x72</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x73</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x74</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x75</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x76</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x77</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The eight I²C bus pairs in the schematic are labeled as SC0/SD0 through SC7/SD7
    (Clock and Data, respectively). The TCA9548A treats them each as a physically
    separate I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the TCA9548A in your sketch requires just one additional step before
    using your I²C devices as normal: instructing the TCA9548A to use one of the eight
    buses it controls. To do this, you’ll send a byte of data to the TCA9548A’s I²C
    bus register, which will determine which of the eight buses you want to use. Each
    bit of the byte is used to turn the bus on or off, with the most significant bit
    (MSB) for bus 7, and the least significant bit (LSB) for bus 0\. For example,
    sending B00000001 (in binary) or 0 in decimal activates bus 0, while sending B00010000
    activates bus 5\. The TCA9548A then channels all data in and out of the bus to
    the Arduino on the selected bus; the TCA9548A itself is transparent to the Arduino.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Send the bus selection data only when you want to change buses. To simplify
    this process, you can use the following function to select the required bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts a bus number and places a 1 in the TCA9548A’s bus register,
    matching our requirements. Insert this function right before you need to access
    a device on a particular I²C bus. For example, you’d use this function to access
    a device on bus 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the function to access a device on bus 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to select the required bus, I’ll introduce a neat display
    that you’ll use in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Graphic OLED Displays</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be familiar with classic 16 × 2–character LCDs, as they’re quite popular
    and inexpensive. However, they are also somewhat bulky and old fashioned. The
    OLED display is a sleeker, more contemporary option that can display both text
    and graphics in various sizes.
  prefs: []
  type: TYPE_NORMAL
- en: For the projects in this chapter, you’ll use a compact 128 × 32–pixel OLED display
    with a diagonal display size of 0.91 inches, such as PMD Way part 35998841A, shown
    in [Figure 10-8](chapter10.xhtml#fig10-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A COMPACT OLED DISPLAY WITH INLINE HEADER PINS](../images/fig10-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-8: A compact OLED
    display with inline header pins</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Inline headers for using with a solderless breadboard are included with the
    example board from PMD Way and are usually included with others, but check with
    the supplier. You can easily solder these to the breadboard by mounting the pins
    and the OLED in a breadboard, as shown in [Figure 10-9](chapter10.xhtml#fig10-9).
    Supporting the other end of the OLED with something to keep the display level,
    such as another group of inline header pins, as shown in [Figure 10-9](chapter10.xhtml#fig10-9),
    helps to ensure the pins are straight.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A COMPACT OLED DISPLAY SITTING IN INLINE HEADER PINS, READY FOR
    SOLDERING](../images/fig10-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-9: A compact OLED
    display sitting in inline header pins, ready for soldering</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re ready to use the OLED, remove the plastic screen protector by pulling
    the blue tag, as shown in [Figure 10-10](chapter10.xhtml#fig10-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF A COMPACT OLED DISPLAY WITH ITS INLINE HEADER PINS SOLDERED](../images/fig10-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-10: Ready-to-use
    OLED</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To use the OLED, you’ll need to install an Arduino library. Search for **u8g2**
    in the Library Manager, and then click **Install** at the bottom of the library
    description.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed the library, test the OLED by running the I²C scanner
    sketch. It should return the address 0x3C, but if you get a different result,
    make a note of it for later. Next, connect the OLED to your Arduino Uno or compatible
    board using the connections listed in [Table 10-2](chapter10.xhtml#tab10-2).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-2:</samp> <samp class="SANS_Futura_Std_Book_11">OLED
    to Arduino Connections</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">OLED</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Arduino
    Uno</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">SDA</samp> | <samp class="SANS_Futura_Std_Book_11">A4</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">SCL</samp> | <samp class="SANS_Futura_Std_Book_11">A5</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">VCC</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Now enter and upload the [Listing 10-1](#LiT-10-1) sketch, which you can find
    in the downloadable code files on this book’s web page. After a few moments, the
    display should scroll between displaying “Count!” and an integer, as shown in
    [Figure 10-11](chapter10.xhtml#fig10-11). If your display had a different bus
    address to 0x3C, insert the new address into the “address” field in the line <samp
    class="SANS_TheSansMonoCd_W5Regular_11">u8g2_2.setI2CAddress(0x3D);</samp> in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, then uncomment
    the line and save and re-upload the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF OLED DISPLAYS, SHOWING TEXT (“COUNT!”)AND DIGITS (“30434”)](../images/fig10-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-11: Example displays
    from [Listing 10-1](#LiT-10-1)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-1](#LiT-10-1) shows how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Using graphic
    OLED displays</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, the sketch includes the u8g2 library and includes the OLED library ❶,
    after which it creates the instance of an OLED. The OLED’s specifications are
    defined in this file so the library knows which type of OLED you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then initializes the OLED ❷ and selects a font for the display ❸.
    The sketch uses a font that’s 32 pixels high, which works well for this OLED,
    but you can replace it with any of the fonts available at [*https://<wbr>github<wbr>.com<wbr>/olikraus<wbr>/u8g2<wbr>/wiki<wbr>/fntlistall*](https://github.com/olikraus/u8g2/wiki/fntlistall).
  prefs: []
  type: TYPE_NORMAL
- en: The sketch controls the OLED by drawing up the intended display in its memory
    and then sending the contents of the memory to the display. After the OLED’s memory
    is cleared, the function ❹ accepts the lower x- and y-coordinates of the OLED
    display and then starts drawing the text itself. The sketch then prints the contents
    of the OLED memory to the display.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch clears the memory again after a short delay and displays a number
    by first setting the cursor position and then printing the number to the memory,
    followed by another <samp class="SANS_TheSansMonoCd_W5Regular_11">sendBuffer()</samp>
    function to display the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve mastered the OLED display, I’ll introduce a sensor that you’ll
    use along with an OLED in your final project.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">BMP180 Sensors</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The BMP180 sensor is an inexpensive, easy-to-use I²C device that measures ambient
    temperature and air pressure. This chapter’s final project uses a compact BMP180
    module with pull-up resistors like the one used in Project #30, such as PMD Way
    part 18000001, shown in [Figure 10-12](chapter10.xhtml#fig10-12).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE BMP180 TEMPERATURE AND HUMIDITY SENSOR PLACED IN A SOLDERLESS
    BREADBOARD](../images/fig10-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-12: The BMP180 sensor
    module</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As with the OLED display, begin by soldering the BMP180’s header pins to the
    board. Next, find the **Adafruit BMP180** library in the Arduino Library Manager
    and install it.
  prefs: []
  type: TYPE_NORMAL
- en: During the process of installing the BMP180 library, you may be asked to install
    some missing dependencies. Click **Install All** if prompted to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Now enter and upload the [Listing 10-2](#LiT-10-2) sketch. Once the upload is
    complete, open the Serial Monitor in the IDE, where you’ll find the current temperature
    in degrees Celsius, along with the air pressure in hectopascals. In some regions,
    the unit of air pressure is the millibar. One hectopascal equals one millibar.
    [Figure 10-13](chapter10.xhtml#fig10-13) shows an example of this output.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF AN EXAMPLE TEMPERATURE AND PRESSURE READINGS OUTPUT IN SERIAL
    MONITOR](../images/fig10-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-13: Example output
    from [Listing 10-2](#LiT-10-2)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-2](#LiT-10-2) shows how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Using BMP180
    temperature and air pressure sensors</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To set up the BMP180, the sketch first includes the requisite library and creates
    an instance of the sensor ❶. Two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">temperature</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pressure</samp>, store the sensor
    data. This is followed by initialization of the sensor ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch can then retrieve the data from the sensor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">read
    Temperature()</samp> ❸ and <samp class="SANS_TheSansMonoCd_W5Regular_11">readPressure()</samp>
    ❹ functions. The temperature and air pressure readings (with the latter divided
    by 100 to convert it to hectopascals) are then sent to the Serial Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #31: Creating a Temperature
    and Air Pressure Display</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This project combines all the techniques you’ve learned in this chapter so
    far, using multiple I²C buses to display the BMP180’s temperature and air pressure
    readings with an OLED. You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 128 × 32–pixel, 0.91-inch OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BMP180 temperature and air pressure sensor board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TCA9548A breakout board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 10-14](chapter10.xhtml#fig10-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT 31](../images/fig10-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-14: The schematic
    for Project #31</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter and upload the Project #31 sketch. The temperature and air pressure
    should alternately display on the OLED, as shown in [Figure 10-15](chapter10.xhtml#fig10-15).'
  prefs: []
  type: TYPE_NORMAL
- en: '![EXAMPLES OF THE OLED DISPLAYING TEMPERATURE (“25 C”) AND HUMIDITY (“999 H”)](../images/fig10-15.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-15: Example output
    from Project #31</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first includes the required libraries ❶ and configures the OLED type
    to use, temperature sensor, and required variables, as covered previously. It
    then defines a custom function to select the I²C bus from the TCA9548A ❷. It starts
    the I²C and OLED functions ❸, selects the OLED font ❹, and starts the temperature
    sensor ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then switches the TCA9548A to the first of its I²C buses to retrieve
    data from the BMP180 ❻ and then to the second I²C bus ❼ so that the temperature
    and pressure data can be displayed on the OLED ❽ ❾.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to harness multiple devices on an I²C bus, alongside
    adding a new sensor and display to your tool kit. You might use these skills to
    make a large, multiple-time-zone clock with many OLEDs and a real-time clock IC,
    or you could use many temperature sensors in one area to determine the variations
    of temperature inside a refrigerator. No matter the project, you’re no longer
    limited by inexpensive devices with a single I²C bus address.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll use an Arduino Leonardo or compatible board to emulate
    a USB mouse and keyboard, which opens up many interesting and useful possibilities.
  prefs: []
  type: TYPE_NORMAL
