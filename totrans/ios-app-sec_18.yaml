- en: '**14**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MOBILE PRIVACY CONCERNS**'
  prefs: []
  type: TYPE_NORMAL
- en: People tend to carry location-aware mobile devices wherever they go, and they
    store tons of personal data on these devices, making privacy a constant concern
    in mobile security. Modern iOS devices allow applications (upon request) to read
    people’s location data, use the microphone, read contacts, access the M7 motion
    processor, and much more. Using these APIs responsibly not only is important to
    users but also can help reduce liability and increase the chances of the application
    being gracefully accepted into the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: I discussed a fair bit of privacy-related content in [Chapter 10](ch10.html#ch10);
    this was largely in regard to accidental data leakage. In this chapter, I’ll cover
    privacy issues that affect both users and app authors when intentionally gathering
    and monitoring user data, as well as mitigations for some potential pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dangers of Unique Device Identifiers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: iOS’s *unique device identifiers (UDIDs)* stand as something of a cautionary
    tale. For most of iOS’s history, the UDID was used to uniquely identify an individual
    iOS device, which many applications then used to track user activity or associate
    a user ID with particular hardware. Some companies used these identifiers as access
    tokens to remote services, which turned out to be a spectacularly bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: Because many organizations were in possession of a device’s UDID and because
    UDIDs weren’t considered sensitive, companies that did use the UDID effectively
    as an authenticator were suddenly in a situation where thousands of third parties
    had their users’ credentials. Software developers also widely assumed that the
    UDID was immutable, but tools had long been available to spoof UDIDs, either globally
    or to a specific application.
  prefs: []
  type: TYPE_NORMAL
- en: '***Solutions from Apple***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a result of those issues, Apple now rejects newly submitted applications
    that use the `uniqueIdentifier` API, directing developers to instead use the `identifierForVendor`
    API. This API returns an instance of the `NSUUID` class. The `identifierForVendor`
    mechanism should return the same UUID for all applications written by the same
    vendor on an iOS device, and that UUID will be backed up and restored via iTunes.
    It is not immutable, however, and can be reset by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Older applications in the App Store that use `uniqueIdentifier` are returned
    a string starting with `FFFFFFFF`, followed by the string normally returned by
    `identifierForVendor`. Similarly, applications using `gethostuuid` are now rejected
    from the App Store, and existing apps receive the `identifierForVendor` value
    when calling this function.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that use the `NET_RT_IFLIST` sysctl or the `SIOCGIFCONF` ioctl
    to read the device’s MAC address now receive `02:00:00:00:00:00` instead. Of course,
    using a MAC address as any kind of token or authenticator has always been a terrible
    idea; MAC addresses leak over every network you connect to, and they’re easy to
    change. The nonspecific return value appropriately punishes developers who have
    taken this approach.
  prefs: []
  type: TYPE_NORMAL
- en: For advertising and tracking purposes, Apple introduced the property `advertisingIdentifier`
    of the `ASIdentifierManager` class. This property returns an NSUUID that is available
    to all application vendors, but like `uniqueIdentifier`, that NSUUID can be wiped
    or changed (as shown in [Figure 14-1](ch14.html#ch14fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f14-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The user interface for indicating that the* `advertisingIdentifier`
    *should be used for limited purposes*'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between this system and the original `uniqueIdentifier` API is
    that `advertisingIdentifier` is explicitly
  prefs: []
  type: TYPE_NORMAL
- en: • only for advertising and tracking;
  prefs: []
  type: TYPE_NORMAL
- en: • not immutable; and
  prefs: []
  type: TYPE_NORMAL
- en: • subject to user preferences.
  prefs: []
  type: TYPE_NORMAL
- en: These aspects of `advertisingIdentifier` ostensibly give the user control over
    what tracking advertisers are allowed to use the mechanism for. Apple states that
    an application must check the value of `advertisingTrackingEnabled`, and if set
    to `NO`, the identifier can be used only for “frequency capping, conversion events,
    estimating the number of unique users, security and fraud detection, and debugging.”^([1](footnote.html#fn119))
    Unfortunately, that list could encompass pretty much anything advertisers want
    to do with the `advertisingIdentifier`.
  prefs: []
  type: TYPE_NORMAL
- en: You can determine the value of `advertisingTrackingEnabled` as shown in [Listing
    14-1](ch14.html#ch14ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-1: Determining whether limited ad tracking is enabled and fetching
    the* `advertisingIdentifier`'
  prefs: []
  type: TYPE_NORMAL
- en: The call to `advertisingTrackingEnabled` at ➊ reads the user preference for
    the advertising tracking ID before reading the `advertisingIdentifier` itself
    at ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rules for Working with Unique Identifiers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a few general rules to follow when working with unique identifiers
    of any type. First, never assume identifiers are immutable. Any identifier supplied
    by the device can be changed by someone in physical possession of the device.
    Second, never assume a 1:1 relationship between devices and identifiers. Identifiers
    can be moved from one device to another and as such cannot be trusted to uniquely
    identify a single device. Because identifiers can change, aren’t unique, and may
    be widely distributed, you also shouldn’t use them to authenticate users. Finally,
    keep identifiers as anonymous as possible. They might be useful for tracking general
    trends in user behavior, but don’t tie an identifier to a user identity unless
    there’s a compelling need to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile Safari and the Do Not Track Header**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with iOS 6, Mobile Safari includes the option to enable the Do Not
    Track mechanism,^([2](footnote.html#fn120)) which tells the remote server that
    the user wants to opt out of being tracked by certain parties. This option is
    expressed with the `HTTP_DNT` header. When set to 1, the header indicates that
    the user consents to being tracked only by the site that is currently being visited.
    When set to 0, it indicates that the user doesn’t want to be tracked by any party.
    Users can enable this mode in the Safari settings ([Figure 14-2](ch14.html#ch14fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f14-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: The user interface for enabling Do Not Track*'
  prefs: []
  type: TYPE_NORMAL
- en: At a minimum, it makes sense to assume that users want to protect details of
    their activity from third-party advertisers or analytics firms. This is the behavior
    specified by an `HTTP_DNT` value of 1, which is the header that iOS sends by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the definition of tracking varies. The specification for the Do Not Track
    mechanism itself notes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The WG has not come to consensus regarding the definition of tracking and the
    scope of DNT. As such, a site cannot actually say with any confidence whether
    or not it is tracking, let alone describe the finer details in a tracking status
    resource.^([3](footnote.html#fn121))
  prefs: []
  type: TYPE_NORMAL
- en: According to the specification, websites can prompt the user to opt into specific
    tracking scenarios using the `storeSiteSpecificTrackingException` JavaScript API,
    but this functionality is not widely implemented at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cookie Acceptance Policy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cookies on iOS are managed via the `NSHTTPCookieStorage` API. The method `sharedHTTPCookieStorage`
    returns the cookie store, but despite the method’s name, iOS cookie storage is
    specific to each application. Cookies actually live in a database under the application
    main bundle directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The name* `*sharedHTTPCookieStorage*` *originates from OS X, where the OS
    uses a global cookie store shared among all applications.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cookies used by the URL loading system are accepted according to a systemwide
    shared `cookieAcceptPolicy`, which any application can specify. This policy can
    be set to any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**NSHTTPCookieAcceptPolicyAlways**` Accept and store all received cookies.
    This is the default.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain**` Accept only first-party
    cookies.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**NSHTTPCookieAcceptPolicyNever**` Never accept cookies.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that on devices running anything older than iOS 7, the cookie acceptance
    policy is shared among applications, which could cause problems for your application.
    On such devices, when another running application changes its acceptance policy,
    your app’s policy changes as well. For example, an application that relies on
    third-party cookies for advertising revenue might repeatedly set its cookie policy
    to `NSHTTPCookieAcceptPolicyAlways`, changing yours to the same policy in the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you can specify your preferred `cookieAcceptPolicy` using events
    such as `didFinishLaunchingWithOptions`, and you can monitor for changes to the
    cookie acceptance policy while your program is running, as shown in [Listing 14-2](ch14.html#ch14ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-2: Registering to receive notifications when the cookie acceptance
    policy changes*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-2](ch14.html#ch14ex2) registers an `NSNotificationCenter` at ➊,
    which listens for `NSHTTPCookieManagerAcceptPolicyChangedNotification`. If the
    policy changes, the selector identified at ➊, `cookieNotificationHandler`, will
    be called. In the `cookieNotificationHandler`, you set the policy to `NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain`
    at ➋.'
  prefs: []
  type: TYPE_NORMAL
- en: In iOS 7 and later, changes in cookie management policy affect only the running
    application. Applications can also specify different cookie management policies
    for different HTTP sessions via `NSURLSession`. For more on this, see “[Using
    NSURLSession](ch07.html#ch07lev1sec02)” on [page 117](ch07.html#page_117).
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitoring Location and Movement**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most useful features of mobile platforms is their ability to make
    information and functionality relevant to a user’s current physical location and
    method of movement. iOS devices primarily determine location based on Wi-Fi and
    GPS, and they monitor body movement with the M7 motion processor.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering location and movement data has dangers, however. In this section,
    I’ll discuss how gathering both types of data works and why you should take care
    when storing such information.
  prefs: []
  type: TYPE_NORMAL
- en: '***How Geolocation Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Wi-Fi geolocation scans for available wireless access points and queries a database
    that has a record of access points and their GPS coordinates. These databases
    are built by third parties that effectively wardrive entire cities and note the
    coordinates of each discovered access point. Of course, this can result in inaccurate
    results in some circumstances. For example, if someone travels with network equipment,
    or relocates it, the location data may not get updated for some time.
  prefs: []
  type: TYPE_NORMAL
- en: GPS can provide more specific navigation information, as well as motion information,
    to track users in transit. This requires the ability to contact GPS satellites,
    which is not always possible, so GPS is often used as a fallback or when a high
    degree of accuracy is required. GPS is also required to determine information
    such as speed or altitude.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Risks of Storing Location Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Few aspects of mobile privacy have generated as much negative press as tracking
    users via geolocation data. While useful for an array of location-aware services,
    a number of issues arise when location data is recorded and stored over time.
    Most obvious are privacy concerns: users may object to their location data being
    stored long-term and correlated with other personal information.^([4](footnote.html#fn122))
    Aside from PR concerns, some European countries have strict privacy and data protection
    laws, which must be taken into account.'
  prefs: []
  type: TYPE_NORMAL
- en: A less obvious problem is that storing location data linked to specific users
    could leave you legally vulnerable. When you store location data along with data
    that links it to a specific individual, that data could be subpoenaed by law enforcement
    or litigators. This often occurs in divorce cases, where lawyers attempt to demonstrate
    infidelity by showing the physical comings and goings of one of the parties in
    the course of a relationship; toll authorities that use electronic tracking have
    had to respond to these inquiries for years.
  prefs: []
  type: TYPE_NORMAL
- en: '***Restricting Location Accuracy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because precise historical location data raises such privacy and liability
    concerns, it’s important to use the least degree of accuracy necessary for your
    intended purpose. For example, if your application is designed to determine what
    city or neighborhood a user is in for the purpose of making a dinner reservation,
    you’ll only need to get a user’s location within a kilometer or so. If your purpose
    is to find the nearest ATM to a user, you’ll want to use something significantly
    narrower. The following are the geolocation accuracy constants available via the
    Core Location API:'
  prefs: []
  type: TYPE_NORMAL
- en: • `kCLLocationAccuracyBestForNavigation`
  prefs: []
  type: TYPE_NORMAL
- en: • `kCLLocationAccuracyBest`
  prefs: []
  type: TYPE_NORMAL
- en: • `kCLLocationAccuracyNearestTenMeters`
  prefs: []
  type: TYPE_NORMAL
- en: • `kCLLocationAccuracyHundredMeters`
  prefs: []
  type: TYPE_NORMAL
- en: • `kCLLocationAccuracyKilometer`
  prefs: []
  type: TYPE_NORMAL
- en: • `kCLLocationAccuracyThreeKilometers`
  prefs: []
  type: TYPE_NORMAL
- en: Restricting location accuracy to the least degree necessary is not only a best
    practice for privacy and legal reasons but also reduces power consumption. This
    is because less accurate methods use the rather quick Wi-Fi detection mechanisms
    and update less frequently, while the highest accuracy settings will often use
    GPS and update frequently.
  prefs: []
  type: TYPE_NORMAL
- en: If you do need to store multiple instances of a user’s location over time, ensure
    that procedures are in place to prune this data eventually. For instance, if you
    need to reference only a month’s worth of location data at a time, ensure that
    older data is properly sanitized or erased. If you’re using location data for
    analytics that don’t require linking to a specific user, omit or remove any data
    that uniquely identifies the user.
  prefs: []
  type: TYPE_NORMAL
- en: '***Requesting Location Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Permission data is requested using `CLLocationManager`, which specifies an accuracy
    constant as well as whether your app needs location data when it’s backgrounded.
    [Listing 14-3](ch14.html#ch14ex3) shows an example invocation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-3: Requesting location data permissions*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, a `CLLocationManager` is allocated ➊ and its delegate is set to `self`
    ➋. Then the desired accuracy of about 100 meters is set at ➌. At ➍, the permission
    request is sent, which will cause the authorization prompt to appear to the user.
    Finally, at ➎, there’s a request for the manager to start monitoring the user’s
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Note that as of iOS 8, the location manager won’t actually start unless you
    have a description of why you need location data. This is specified in your *Info.plist*
    file, using either `NSLocationWhenInUseUsageDescription` if you need to access
    location data only when the app is in use or `NSLocationAlwaysUsageDescription`
    if you’ll also need to get location information from the background. Add one of
    these to your plist file, along with a concise but specific rationale to be displayed
    to the user when they’re prompted to grant permission to location data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Managing Health and Motion Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the most sensitive information that applications can handle is health
    information about the user. On iOS, this data can be retrieved using the HealthKit
    API and the APIs provided by the device’s M7 motion processor, if it has one.
    You’ll take a brief look at how to read and write this data and how to request
    the minimum privileges necessary for an app to function.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As of iOS 9, HealthKit is available only on iPhones, not on iPads.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading and Writing Data from HealthKit***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HealthKit information can be requested either for reading or for both reading
    and writing (somewhat confusingly called *sharing* by Apple). In keeping with
    requesting only the permissions that are absolutely necessary, request read-only
    access if possible. [Listing 14-4](ch14.html#ch14ex4) shows how permissions for
    specific health data are requested.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-4: Requesting health data permissions*'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ and ➋, you specify two types of data that you’d like to access, namely,
    heart rate and date of birth. At ➌, you request authorization to access these,
    with a `completion` block to handle success or failure. Note that the `requestAuthorizationToShareTypes`
    is requesting read/write access, presumably because this application is intended
    to track and record the user’s heart rate. The `readTypes` parameter specifies
    that you want to monitor the user’s heart rate but not write to it. In this case,
    you’re requesting the user’s date of birth (something rather unlikely to change)
    to infer their age. Finally, to allow you to distribute the application, you’ll
    need to enable the HealthKit entitlement in Xcode, as shown in [Figure 14-3](ch14.html#ch14fig3).
  prefs: []
  type: TYPE_NORMAL
- en: While HealthKit shows how to record steps, but there are more detailed ways
    to get motion data to help guess exactly what kind of activity the user is engaged
    in. This more detailed data can be retrieved using the M7 motion tracker.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f14-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Enabling the HealthKit entitlement in Xcode*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The M7 Motion Processor***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The iPhone 5s introduced the M7 motion-tracking processor, which allows for
    the recording of detailed information about small movements while reducing the
    battery drain that this has incurred in the past. Fitness applications could use
    this data to determine the type of physical activity the user is currently engaging
    in and how many steps they’ve taken. Applications that monitor sleep quality could
    also take advantage of this to determine how deep the user is sleeping based upon
    slight movements. Obviously, the ability to determine when a user is asleep and
    what they’re doing outside of using the phone is a significant responsibility.
    Apple details the degree to which users can be tracked via the M7 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: M7 knows when you’re walking, running, or even driving. For example, Maps switches
    from driving to walking turn-by-turn navigation if, say, you park and continue
    on foot. Since M7 can tell when you’re in a moving vehicle, iPhone 5s won’t ask
    you to join Wi-Fi networks you pass by. And if your phone hasn’t moved for a while,
    like when you’re asleep, M7 reduces network pinging to spare your battery.^([5](footnote.html#fn123))
  prefs: []
  type: TYPE_NORMAL
- en: 'Use of the M7 processor is granted in a manner similar to basic geolocation
    permissions. But M7 has a quirk not present in other geolocation data access:
    applications have access to data that was recorded before they were granted permission
    to access location data. If you’re going to use this historic data, inform the
    user in your permissions message and, ideally, give them a choice as to whether
    to use or disregard this data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requesting Permission to Collect Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When attempting to access sensitive data such as a user’s contacts, calendar,
    reminders, microphone, or motion data, the user will be prompted with an alert
    to grant or deny this access. To ensure that the user is presented with useful
    information as to why you need this access, define strings to be delivered to
    the user as part of the access prompt. Make these explanations simple but descriptive,
    as in [Figure 14-4](ch14.html#ch14fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f14-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Delivering the request to the user*'
  prefs: []
  type: TYPE_NORMAL
- en: You can set those messages in your app’s *Info.plist* file through Xcode, shown
    in [Figure 14-5](ch14.html#ch14fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f14-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Describing needs for various kinds of access in an* Info.plist'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, ensure that your application handles the refusal of these permissions
    gracefully. Unlike Android, where permission granting is an all-or-nothing affair,
    iOS applications are expected by Apple to be able to handle having some permissions
    granted and others refused.
  prefs: []
  type: TYPE_NORMAL
- en: '**Proximity Tracking with iBeacons**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apple’s iBeacons are designed to measure your proximity to hardware and take
    certain actions when you’re within range. For example, an app could use the beacons
    to track your movements through a mall or store, or indicate that the car that
    just pulled up next to you is the Uber car you requested. iBeacon functionality
    is part of the Core Location API, which uses Bluetooth Low Energy (BTLE) on compatible
    devices to manage proximity monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll first discuss how some applications check for iBeacons
    and how iOS devices can become iBeacons. I’ll end on privacy issues you should
    consider when using iBeacons in your own apps.
  prefs: []
  type: TYPE_NORMAL
- en: '***Monitoring for iBeacons***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Monitoring for iBeacons is accomplished by instantiating a Core Location `CLLocationManager`
    and passing a `CLBeaconRegion` to the manager’s `startMonitoringForRegion` method,
    as in [Listing 14-5](ch14.html#ch14ex5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-5: Initiating monitoring for a specific region defined by a UUID*'
  prefs: []
  type: TYPE_NORMAL
- en: The NSUUID generated at ➊ is assigned to a `CLBeaconRegion` ➋ and will be used
    to uniquely identify that beacon. The identifier ➌ will specify the symbolic name
    for the beacon. Note you can register to monitor for multiple regions with the
    same `CLLocationManager`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can use the* `*uuidgen(1)*` *command in the terminal to generate a unique
    UUID to use as a beacon identifier.*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to implement a `locationManager` delegate method, as in [Listing
    14-6](ch14.html#ch14ex6), to handle location updates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-6: An example* `locationManager` *delegate method*'
  prefs: []
  type: TYPE_NORMAL
- en: This method will be called whenever a device running your application enters
    an iBeacon’s registered region; your app can then perform whatever logic is appropriate
    upon entering that region. Once the application gets the notification that the
    device has entered the range of a beacon, it can start *ranging*, or measuring
    the distance between the device and the beacon.
  prefs: []
  type: TYPE_NORMAL
- en: After an application has begun ranging a beacon, the `locationManager:didRangeBeacons:inRegion`
    delegate method ([Listing 14-7](ch14.html#ch14ex7)) will be called periodically,
    allowing the application to make decisions based on the proximity of the beacon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-7: The* `locationManager` *callback for examining beacons*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four constants representing proximity: `CLProximityImmediate`, `CLProximityNear`,
    `CLProximityFar`, and `CLProximityUnknown`. See [Table 14-1](ch14.html#ch14tab1)
    for the meanings of these values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-1:** Region Proximity (Range) Measurements'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Item class** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CLProximityUnknown` | The range is undetermined. |'
  prefs: []
  type: TYPE_TB
- en: '| `CLProximityImmediate` | The device is right next to the beacon. |'
  prefs: []
  type: TYPE_TB
- en: '| `CLProximityNear` | The device is within a few meters of the beacon. |'
  prefs: []
  type: TYPE_TB
- en: '| `CLProximityFar` | The device is within range but near the edge of the region.
    |'
  prefs: []
  type: TYPE_TB
- en: '***Turning an iOS Device into an iBeacon***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: BTLE iOS devices can also act as iBeacons, broadcasting their presence to the
    outside world, which can be used to detect and measure proximity between iOS devices.
    This is done via the CoreBluetooth framework, using a `CBPeripheralManager` instance
    and giving it a `CLBeaconRegion` with a chosen UUID ([Listing 14-8](ch14.html#ch14ex8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-8: Turning your application into an iBeacon*'
  prefs: []
  type: TYPE_NORMAL
- en: The code generates a UUID at ➊ and a symbolic name at ➋, and then defines a
    region at ➌. At ➍, the `peripheralDataWithMeasuredPower` method returns a dictionary
    with the information needed to advertise the beacon (the `nil` parameter just
    tells the code to use the default signal strength parameters for the device).
    At ➎, an instance of `CBPeripheralManager` is instantiated and finally the `peripheralData`
    ➏ is passed to the manager so it can begin advertising.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve taken a look at how iBeacons are managed, let’s look at some
    of the privacy implications of implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: '***iBeacon Considerations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Obviously, iBeacons provide extremely detailed information about a user’s whereabouts.
    Beacons don’t have to be dumb transmitters; they can also be programmable devices
    or other iOS devices that can record location updates and deliver them to central
    servers. Users are likely to object to this data being tracked over the long term,
    so as with other geolocation data, avoid keeping any beacon logs for any longer
    than they’re specifically needed. Also, don’t tie the time and beacon information
    in such a way that they can be correlated with a specific user in the long term.
  prefs: []
  type: TYPE_NORMAL
- en: Your app should turn the device it’s installed on into a beacon sparingly. Becoming
    a beacon makes the device discoverable, so be sure to inform the user of your
    intentions in a manner that communicates that fact. If possible, perform Bluetooth
    advertising for only a limited time window, ceasing it once necessary data has
    been exchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve looked at some of the many ways apps gather information about
    users, let’s look at some of the policy guidelines that will dictate how those
    apps handle personal data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Establishing Privacy Policies**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For your own protection, always explicitly state a privacy policy in your application.
    If your app is set to Made for Kids, a privacy policy is both an App Store requirement
    and a legal one, as required by the Children’s Online Privacy Protection Act (COPPA).
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m no lawyer, so of course, I can’t give specific legal advice on how your
    policy should be implemented. However, I would advise you to include the following
    in your privacy policy:'
  prefs: []
  type: TYPE_NORMAL
- en: • The information your app gathers and whether it is identifying or non-identifying
    (that is, whether it can be tied back to a specific user)
  prefs: []
  type: TYPE_NORMAL
- en: • The mechanisms by which information is gathered
  prefs: []
  type: TYPE_NORMAL
- en: • The reasons for gathering each type of data
  prefs: []
  type: TYPE_NORMAL
- en: • How that data is processed and stored
  prefs: []
  type: TYPE_NORMAL
- en: • The retention policy of the data (that is, how long data is stored)
  prefs: []
  type: TYPE_NORMAL
- en: • If and how the information you gather is shared with third parties
  prefs: []
  type: TYPE_NORMAL
- en: • How users can change data collection settings if desired
  prefs: []
  type: TYPE_NORMAL
- en: • Security mechanisms in place to protect user data
  prefs: []
  type: TYPE_NORMAL
- en: • A history of changes to the privacy policy
  prefs: []
  type: TYPE_NORMAL
- en: The Electronic Frontier Foundation (EFF) provides a good template for developing
    an effective and informative privacy policy, which you can find at *[https://www.eff.org/policy](https://www.eff.org/policy)*.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that Apple has some specific requirements for how to implement privacy
    policies in the application and how they should be made available. Specifically,
    all applications that offer autorenewed or free subscriptions and apps that are
    categorized as Made for Kids must include a URL to a privacy policy. If the application
    is set to Made for Kids, the policy needs to be localized for each localization
    within the application.^([6](footnote.html#fn124))
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In light of disclosures about massive government surveillance in the United
    States and abroad, consumer awareness and concern about companies gathering and
    correlating their personal information and habits is likely to increase. It’s
    also become clear that the more information you gather on your users, the greater
    your company risks exposure. Companies with the most detailed information on their
    users are those most attractive to government intrusion, either by subpoena, monitoring,
    or active hacking by intelligence agencies.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, always clearly define your intentions and minimize data gathered
    to limit your exposure and to build and maintain trust with consumers.
  prefs: []
  type: TYPE_NORMAL
