<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_15" title="15"/>2</span><br/>&#13;
<span class="ChapterTitle">I<sup>2</sup>C Protocol</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">The I<sup>2</sup>C bus definition is quite a bit more than electrical levels appearing on a bus. Equally important is the definition of the signals appearing on those two lines. This chapter discusses the data protocols associated with the I<sup>2</sup>C bus—that is, the speed at which the data transmission takes place, how a device can force the controller to wait for it, and how controllers do the following:</p>&#13;
<ul>&#13;
<li>Transmit bits to and from devices</li>&#13;
<li>Specify the device’s address</li>&#13;
<li>Specify the data direction</li>&#13;
<li>Specify the end of the data transmission</li>&#13;
</ul>&#13;
<p><span epub:type="pagebreak" id="Page_16" title="16"/>The order and definition of the bits appearing on the bus, and how they are clocked on the bus, are determined by the I<sup>2</sup>C <em>protocol</em>. This chapter describes that protocol and discusses some useful topics such as resetting the I<sup>2</sup>C bus and detecting peripherals on the bus.</p>&#13;
<h2 id="h1-502468c02-0001">	2.1	Data on the I<sup>2</sup>C Bus</h2>&#13;
<p class="BodyFirst">The I<sup>2</sup>C bus transmits data serially on the SDA line, clocked by the SCL signal (see <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>). The data on the SDA line must be stable (0 or 1) when SCL is high (1); data may change on the SDA line only while SCL is low (see <a href="#figure2-1">Figure 2-1</a>).</p>&#13;
<figure>&#13;
<img alt="" class="" height="281" src="image_fi/502468c02/f02001.png" width="694"/>&#13;
<figcaption><p><a id="figure2-1">Figure 2-1</a>: Serial data transmission on the I<sup>2</sup>C bus</p></figcaption>&#13;
</figure>&#13;
<p>Data transmissions on the I<sup>2</sup>C bus consist of a start signal, followed by one or more bytes of data, and end with a stop signal. Between data transmissions, the SDA and SCL lines are in their unasserted state (that is, both signals are pulled high). As noted in the previous chapter, if the SCL line is high for longer than a one-half clock period, the bus is currently unused.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	A one-half clock period value determines whether the bus is being used because if the bus is being used, the SCL line will switch low after about a one-half clock period, as a full clock period consists of 50 percent SCL high and 50 percent SCL low.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>A start condition consists of a controller pulling the SDA line low while the SCL line has been high for some period of time (see <a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a>). As mentioned earlier (see <a href="#figure2-1">Figure 2-1</a>), the SDA line normally must be stable while the clock line is high. This is to allow devices on the I<sup>2</sup>C bus to detect a start (and as you will soon see, a stop) condition.</p>&#13;
<p>Generally, SCL must be high for the duration of between one-quarter and one-half clock period before SDA can go low to signal a start condition. Specifically, this start setup time is one of the following:</p>&#13;
<ul>&#13;
<li>For standard mode (10-μsec clock period): 4.7 μsec</li>&#13;
<li>For fast mode (2.5-μsec clock period): 0.6 μsec</li>&#13;
<li>For fast-plus mode (1-μsec clock period): 0.26 μsec</li>&#13;
</ul>&#13;
<p><span epub:type="pagebreak" id="Page_17" title="17"/>Once the data line has gone low, signifying the start condition, the controller can pull the SCL line low to begin clocking in data after the following startup hold times:</p>&#13;
<ul>&#13;
<li>For standard mode: 4.0 μsec</li>&#13;
<li>For fast mode: 0.6 μsec</li>&#13;
<li>For fast-plus mode: 0.26 μsec</li>&#13;
</ul>&#13;
<figure>&#13;
<img alt="" class="" height="304" src="image_fi/502468c02/F02002.png" width="694"/>&#13;
<figcaption><p><a id="figure2-2">Figure 2-2</a>: Start condition on the I<sup>2</sup>C bus</p></figcaption>&#13;
</figure>&#13;
<p>A byte transmission consists of 8 data bits and an acknowledgment bit (see <a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a>). The 8-bit data byte is shipped with the most significant bit (MSB) appearing first on the SDA line and the least significant bit (LSB) following eight clock periods later. Immediately following the byte data is a single acknowledgment bit. This bit is always 0 if the receiving device is acknowledging the data. It is a 1 (NAK, or negative acknowledgment) if there was a transmission error.</p>&#13;
<figure>&#13;
<img alt="" class="" height="248" src="image_fi/502468c02/F02003.png" width="693"/>&#13;
<figcaption><p><a id="figure2-3">Figure 2-3</a>: Byte transmission on the I<sup>2</sup>C bus</p></figcaption>&#13;
</figure>&#13;
<p>Note that either the controller or the peripheral could be placing the data on the data bus. For a write operation, the controller is responsible for placing the data on the SDA line; for a read operation, the peripheral is responsible for placing the data on the SDA line. For the acknowledgment, <span epub:type="pagebreak" id="Page_18" title="18"/>the roles are reversed: for reads, the controller pulls the SDA low to acknowledge the read from the peripheral, while for writes, the peripheral pulls the SDA line low to acknowledge the write operation. If the transmission is bad for whatever reason, the device accepting the data does not pull the SDA line low for the acknowledgment. This leaves the SDA line high (which is a NAK). The next section, “I<sup>2</sup>C Addresses and Read/Write Control,” will discuss how the controller specifies whether a read or write operation is taking place.</p>&#13;
<p>A stop condition consists of changing the SDA line from low to high while the SCL line is held high (remember, data normally must be stable while the clock line is high). This typically consists of setting the SDA line low before the last rising edge of the SCL line at the end of the data transmission and then pulling the SDA line high afterward, as <a href="#figure2-4" id="figureanchor2-4">Figure 2-4</a> shows. Similar to the start condition, the SCL line must be high for a certain amount of time (the <em>setup time for the stop condition</em>) before transitioning the SDA line from low to high. These setup times are the same as for the start condition, specifically:</p>&#13;
<ul>&#13;
<li>For standard mode: 4.7 μsec</li>&#13;
<li>For fast mode: 0.6 μsec</li>&#13;
<li>For fast-plus mode: 0.26 μsec</li>&#13;
</ul>&#13;
<p>Once the controller generates the stop condition, the I<sup>2</sup>C bus is free, and after an appropriate start setup time, a controller can obtain it and use it again.</p>&#13;
<figure>&#13;
<img alt="" class="" height="327" src="image_fi/502468c02/f02004.png" width="694"/>&#13;
<figcaption><p><a id="figure2-4">Figure 2-4</a>: I<sup>2</sup>C stop condition (S<sub>p</sub>)</p></figcaption>&#13;
</figure>&#13;
<p>A stop condition does not occur after every byte. Instead, a stop condition marks the completion of a string of byte transmissions over the I<sup>2</sup>C bus. Specifically, a single (atomic) transmission consists of a start condition, followed by one or more byte transmissions (each with their own ACK or NAK bit), and a stop condition at termination. This transmission is considered atomic because the controller driving the transmission has <span epub:type="pagebreak" id="Page_19" title="19"/>complete control of the I<sup>2</sup>C bus for the entire duration of the transmission; during this time, no other controller can take possession of the I<sup>2</sup>C bus.</p>&#13;
<h2 id="h1-502468c02-0002">	2.2	I<sup>2</sup>C Addresses and Read/Write Control</h2>&#13;
<p class="BodyFirst">The first byte appearing on the I<sup>2</sup>C bus after a start condition is special. This byte contains the I<sup>2</sup>C device address and the read/write state. <a href="#figure2-5" id="figureanchor2-5">Figure 2-5</a> shows the format for the peripheral address and R/W (read/write) byte (the overbar on the W indicates that the write signal is active low [0]).</p>&#13;
<figure>&#13;
<img alt="" class="" height="247" src="image_fi/502468c02/f02005.png" width="695"/>&#13;
<figcaption><p><a id="figure2-5">Figure 2-5</a>: First byte following a start condition (peripheral address and R/W bit)</p></figcaption>&#13;
</figure>&#13;
<p>The upper 7 bits of this byte contain the address of the peripheral for whom this transmission is intended. Because there are 7 bits, you can specify a maximum of 128 peripheral addresses in this peripheral address byte (though see section 2.5, “Special Addresses,” later in this chapter for information about a 10-bit address on the I<sup>2</sup>C bus). The LO bit of the byte contains an R/W flag. A 0 in this bit position specifies a write operation, and a 1 in this position specifies a read operation.</p>&#13;
<p>The R/W bit determines the data transfer directions of all the bytes following the peripheral address byte. If this bit is 0 (write operation), then the controller will supply all the data on the SDA line in the following bytes; if this bit is 1 (read operation), then the peripheral will place the data on the SDA line during the transmission. Regardless of the data direction, the controller is still responsible for driving the SCL line (though see section 2.4, “Clock Stretching,” later in this chapter).</p>&#13;
<p>Generally, this book will write I<sup>2</sup>C addresses as 7-bit binary or hexadecimal values (using C notation, 0x<em>nn</em> or 0b<em>nnnnnnn</em>). The full address and R/W byte will normally be written in 8-bit hexadecimal form.</p>&#13;
<h2 id="h1-502468c02-0003">	2.3	Repeated Start Conditions</h2>&#13;
<p class="BodyFirst">In some special cases, a controller might need to write data to some particular peripheral and then immediately read data back from that peripheral as an atomic operation, without the possibility of some other controller accessing the peripheral between the write and read operations. Because the data <span epub:type="pagebreak" id="Page_20" title="20"/>direction is specified by the LO bit of the first byte after a start condition, a controller must send another start condition to change the direction. However, if the controller completes the current transfer by issuing a stop condition before sending another start condition, this gives a different controller the opportunity to seize the bus before the second transmission. This means the controller needs a way to hold onto the bus by not sending a stop condition. This is accomplished with a repeated start condition.</p>&#13;
<p>A <em>repeated start condition</em>, as its name implies, is a second start condition (SDA high-to-low while SCL is high) without an intervening stop condition on the I<sup>2</sup>C bus. Until a stop condition comes along (which is what waiting controllers look for while waiting for the I<sup>2</sup>C bus), the current controller owns the bus. Therefore, a controller can use a sequence of repeated starts during a data transmission to reverse the data direction, or even to communicate with multiple peripherals, without giving up the I<sup>2</sup>C bus. When the atomic operations are complete, the controller can yield the bus by issuing a stop condition.</p>&#13;
<p>In a multicontroller environment, a controller should take care not to monopolize the I<sup>2</sup>C bus. For operations that do not require atomicity, the controller should use stop conditions between transfers so that different controllers can gain access to the bus in a fair manner.</p>&#13;
<h2 id="h1-502468c02-0004">	2.4	Clock Stretching</h2>&#13;
<p class="BodyFirst">As mentioned in the previous chapter, clock stretching is a technique whereby a peripheral device can force the controller to wait while the peripheral is processing data. For example, a simple peripheral device polling the SDA and SCL lines and manually processing incoming data might need a small amount of time after each byte. During that time the controller might ship additional data that could be lost while the peripheral is busy processing the data. To resolve this problem, the peripheral can use clock stretching to force the controller to pause while the peripheral’s CPU deals with the incoming data. This effectively adds <em>wait states</em> to the data transmission.</p>&#13;
<p>A peripheral can stretch the clock by pulling the SCL line low. Technically, this can occur at any time. However, when transmitting data from the controller to the peripheral, the peripheral usually pulls the SCL line low when the SCL line is also low just after the acknowledge bit, as this is when the peripheral has received the entire byte and will need to process it. Transmitting data from the peripheral to the controller is also a good time for the peripheral to pull the SCL line low after a complete byte transmission if the peripheral needs additional time to produce the next byte to transmit.</p>&#13;
<p>Note that clock stretching is an optional feature in the I<sup>2</sup>C standard. In fact, most peripheral devices don’t support clock stretching, as they can handle the data transmissions as fast as the controller sends them. Although it should be rare, a controller might not support clock <span epub:type="pagebreak" id="Page_21" title="21"/>stretching in certain situations, such as when someone uses a simple microcontroller device to build a multifunction I<sup>2</sup>C controller that has to handle many different activities, which results in performance problems. See “For More Information” at the end of this chapter for details on how to deal with this situation.</p>&#13;
<h2 id="h1-502468c02-0005">	2.5	Special Addresses</h2>&#13;
<p class="BodyFirst">With 7 address bits you would get the impression that the I<sup>2</sup>C bus supports up to 128 devices. In fact, this is not the case, for two reasons. First, the I<sup>2</sup>C standard reserves two groups of 8 addresses (0 through 7 and 120 through 127) for special purposes. Second, I<sup>2</sup>C uses a couple of those reserved addresses to allow extended addresses up to 10 bits in length. In theory, this allows an additional 1,024 devices on the bus.</p>&#13;
<p><a href="#table2-1" id="tableanchor2-1">Table 2-1</a> lists the special addresses currently defined for the I<sup>2</sup>C bus. Don’t-care bits (<em>xx</em>) appearing in these addresses can be 0b00, 0b01, 0b10, or 0b11. Most of the time, programs supply 0b00 for these bits.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table2-1">Table 2-1</a>: Special I<sup>2</sup>C Addresses</p></figcaption>&#13;
<table border="1" id="table-502468c02-0001">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Address bits</b></td>&#13;
<td><b>R/W</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0000-000</td>&#13;
<td>0</td>&#13;
<td>General call address</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0000-000</td>&#13;
<td>1</td>&#13;
<td>Start byte</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0000-001</td>&#13;
<td>x<sup class="FootnoteReference"><a href="#c02-footnote-001" id="c02-footnoteref-001">*</a></sup></td>&#13;
<td>CBUS addresses</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0000-010</td>&#13;
<td>x</td>&#13;
<td>Reserved for different bus format</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0000-011</td>&#13;
<td>x</td>&#13;
<td>Reserved for future purposes</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0000-1xx</td>&#13;
<td>x</td>&#13;
<td>High-speed mode controller code</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1111-0aa</td>&#13;
<td>R/W</td>&#13;
<td>10-bit peripheral addressing (see section 2.5.6, “10-Bit Peripheral Addressing,” later in this chapter for discussion of aa bits)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1111-1xx</td>&#13;
<td>1</td>&#13;
<td>Device ID</td>&#13;
</tr>&#13;
</tbody>&#13;
<tfoot>&#13;
<tr>&#13;
<td colspan="3"><p class="TableFootnote"><sup class="FootnoteReference"><a href="#c02-footnoteref-001" id="c02-footnote-001">*</a></sup>x = “don’t care” and can be 0 or 1</p>&#13;
</td>&#13;
</tr>&#13;
</tfoot>&#13;
</table>&#13;
</figure>&#13;
<p>The following subsections describe the general call address (including hardware general calls), start byte, CBUS, high-speed controller mode, 10-bit addressing, and device ID special addresses in greater detail. Several addresses are also reserved for future device expansion. Existing controllers should not use these addresses until their use is defined within the I<sup>2</sup>C standard.</p>&#13;
<h3 id="h2-502468c02-0001">2.5.1	The General Call Address  </h3>&#13;
<p class="BodyFirst">The <em>general call address</em> (0x00 with R/W = 0) is a special broadcast address that can address all devices on the bus. The R/W bit is always 0 (write) because you can never read from all the devices at the same time, as their return values would scramble one another. </p>&#13;
<p><span epub:type="pagebreak" id="Page_22" title="22"/>The general call operation always consists of at least two bytes: the general call address (0x00) followed by a command byte (see <a href="#figure2-6" id="figureanchor2-6">Figure 2-6</a>). Generally, systems use this command to initialize all the peripherals that respond to the general call operation with a single bus command.</p>&#13;
<figure>&#13;
<img alt="" class="" height="83" src="image_fi/502468c02/F02006.png" width="844"/>&#13;
<figcaption><p><a id="figure2-6">Figure 2-6</a>: General call command format</p></figcaption>&#13;
</figure>&#13;
<p>When bit B is 0, the I<sup>2</sup>C protocol currently defines the following commands (<code>ccccccc</code> bits):</p>&#13;
<ol class="none">&#13;
<li><code>ccccccc</code> = 0b0000011: Reset and set peripheral programmable address.</li>&#13;
<li><code>ccccccc</code> = 0b0000010: Set peripheral programmable address but do not reset.</li>&#13;
<li><code>ccccccc</code> = 0b0000000: Illegal command code, not allowed as second byte.</li>&#13;
</ol>&#13;
<p>A <em>peripheral programmable address</em> is an address that can be set by hardware pins on the peripheral device. Many devices include pins on the IC package that can specify one of several different I<sup>2</sup>C addresses to which the device responds. This allows a designer, for example, to put several of the same ICs on the I<sup>2</sup>C bus and have them respond to different addresses by setting these pins high or low. For example, the MCP4725 DAC contains a pin that allows you to select one of two different I<sup>2</sup>C addresses by tying the pin to Vcc or Gnd. The general call commands 0x00/0x07 (<code>ccccccc</code> = 0b0000011, <code>B</code> = 0) and 0x00/0x05 (<code>ccccccc</code> = 0b0000010, <code>B</code> = 0) instruct such chips to load the address from these pins, as appropriate (the 0x00/0x06 command also instructs the peripheral to reset itself).</p>&#13;
<p>Most peripheral ICs set their programmed addresses on a power-up operation, and the address never changes after that point, so most peripheral devices will ignore this command or simply do a reset operation for the (0x00, 0x06) command.</p>&#13;
<p>Note that peripheral devices do not have to support the general call command—that is, its implementation is optional. If a device does not support the general call command, it must ignore it. </p>&#13;
<p>Because of the open-drain nature of the I<sup>2</sup>C SDA line, if any device acknowledges the general call address and the command byte, the controller will see an ACK. Only if none of the devices acknowledge the general call command will the controller see a NAK response.</p>&#13;
<p>The commands other than (0x00, 0x00), (0x00, 0x04), and (0x00, 0x06) are reserved for future use and devices must ignore them. However, if you are creating your own custom peripherals for a custom system, you could create your own general call commands. You could even pass along additional data after the command byte to broadcast to all the devices you’ve created that respond to the commands. Just keep in mind that future revisions of <span epub:type="pagebreak" id="Page_23" title="23"/>the I<sup>2</sup>C protocol may conflict with your definitions. Also keep in mind that you can write data only with the broadcast (general call) command.</p>&#13;
<h3 id="h2-502468c02-0002">2.5.2	Hardware General Calls</h3>&#13;
<p class="BodyFirst">Hardware general calls are a special form of the general call that support peer-to-peer communication. If the <code>B</code> bit in <a href="#figure2-6">Figure 2-6</a> is a 1, the 2-byte sequence is a <em>hardware general call</em>. The <code>ccccccc</code> bits specify the controller’s address that it is broadcasting to all the devices, which could be followed by 0 or more bytes of additional data. Some other device on the bus could read this data and interpret it accordingly. Generally, a hardware general call is a way for one controller device to communicate with a different controller device and pass it a block of data. However, for this scheme to work, the second controller device receiving the data must be looking for the first controller’s address within the hardware general call.</p>&#13;
<p>You won’t find too many commercially available devices that support the hardware general call. Typically, custom-programmed controllers that communicate with one another in the system would use these messages. </p>&#13;
<p>To be honest, rather than design this protocol into your system, you’d probably be better off using the CANBUS or some other peer-to-peer networking scheme to transmit data between controllers in a system. As you might expect, very few devices take advantage of this feature in the I<sup>2</sup>C protocol. Most devices ignore hardware general calls.</p>&#13;
<h3 id="h2-502468c02-0003">2.5.3	Start Byte </h3>&#13;
<p class="BodyFirst">The start byte (adrs = 0, R/W = 1) is a software mechanism for introducing delays in an I<sup>2</sup>C communication between a fast controller and a slow-responding peripheral. Some low-cost peripheral devices poll only the SDA line occasionally to see if a start condition exists. If the peripheral is otherwise preoccupied when the actual start condition arrives, the peripheral could miss a message intended for it. A start byte is the sequence 0x01 (that is, address 0 with the R/W bit high). These seven 0 bits, which will be spread over 70 μsec when using a 100-kHz clock, should give the peripheral sufficient time to detect that the SDA line has gone low.</p>&#13;
<p>Start bytes are always followed by a repeated start condition and the actual peripheral address byte (see <a href="#figure2-7" id="figureanchor2-7">Figure 2-7</a>). Note that start bytes are never acknowledged—a NAK always follows in the ninth bit after the start byte. Also note that the start byte shares the same address as the general call function (see <a href="#figure2-6">Figure 2-6</a>). The difference is in the R/W bit; the start byte sequence always has a 1 in the R/W position, and the general call operation has a 0 in this position.</p>&#13;
<figure>&#13;
<img alt="" class="" height="103" src="image_fi/502468c02/F02007.png" width="844"/>&#13;
<figcaption><p><a id="figure2-7">Figure 2-7</a>: Start byte sequence</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_24" title="24"/>If a peripheral device is slow and requires a start byte prefix, the controller must explicitly transmit the start byte before communicating with the peripheral. Likewise, if the peripheral device is slow, its software must recognize the tail end of a start sequence and be ready to read the following address from the bus.</p>&#13;
<p>Be aware that not all peripheral ICs support the start byte. This means that if you send a start byte on the I<sup>2</sup>C bus to communicate with a slow device, other devices on the bus may misinterpret this signal. If you’re going to use this feature in the I<sup>2</sup>C protocol, ensure that all the devices on the bus will respond properly (meaning, at the very least, they ignore the start byte).</p>&#13;
<h3 id="h2-502468c02-0004">2.5.4	CBUS and Reserved Addresses </h3>&#13;
<p class="BodyFirst">The CBUS (adrs = 1, R/W = x [don’t care]) is an old, obsolete variant of the I<sup>2</sup>C bus. The CBUS address was originally used to activate CBUS devices on the I<sup>2</sup>C bus. However, this address is no longer used for this purpose, and modern controllers should not place this address on the bus.</p>&#13;
<h3 id="h2-502468c02-0005">2.5.5	High-Speed Mode Controller Code </h3>&#13;
<p class="BodyFirst">High-speed mode controller codes (adrs = 4 through 7, R/W = x) are special addresses that the I<sup>2</sup>C protocol uses to switch between high-speed and slower (standard, fast, fast+) modes. Because very few devices operate on the I<sup>2</sup>C bus in high-speed mode, this book largely ignores the high-speed and ultra-fast modes. For more information on the high-speed controller modes, consult the I<sup>2</sup>C bus specification and user manual (see “For More Information”).</p>&#13;
<h3 id="h2-502468c02-0006">2.5.6	10-Bit Peripheral Addressing </h3>&#13;
<p class="BodyFirst">To many people, the 7-bit addressing scheme on the I<sup>2</sup>C bus, which supports up to 112 devices, seems limiting. For a variety of reasons, this turns out to be far more than sufficient. However, the I<sup>2</sup>C bus does define a special extension that allows the use of a 10-bit address on the bus, allowing up to 1,024 additional addresses on a single bus (adrs = 0x78 through 0x7B).</p>&#13;
<p>When one of the special addresses 0b1111000 (0x78), 0b1111001 (0x79), 0b1111010 (0x7A), or 0b1111011 (0x7B) appears as the first byte after a start condition, this is the start of a 2-byte address sequence. The LO two bits of this address become the most significant (HO) 2 bits of the result. A second byte follows this byte that contains the remaining (LO) 8 bits of the address. See <a href="#figure2-8" id="figureanchor2-8">Figure 2-8</a> for the details.</p>&#13;
<figure>&#13;
<img alt="" class="" height="84" src="image_fi/502468c02/F02008.png" width="818"/>&#13;
<figcaption><p><a id="figure2-8">Figure 2-8</a>: 10-bit address format</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_25" title="25"/>The peripheral device constructs the 10-bit address from the two bytes that begin with 0b11110<em>aa</em>. The remainder of the transmission starting with the third byte is identical to an I<sup>2</sup>C transmission with a 7-bit address, following the first byte.</p>&#13;
<p>Although having a 10-bit address scheme seems reasonable, in the real world it’s almost useless. First, few commercially available peripheral devices support 10-bit addresses. In theory, you could create your own custom peripheral device that looks for a 10-bit address. However, this would buy you almost nothing, as it’s probably just as easy to find an unused 7-bit address in your system and use that. This saves the extra 100 μsec (at 100 kHz) required to transmit the extra address information, and I<sup>2</sup>C transmissions are slow enough as it is.</p>&#13;
<p>Another issue is the fact that 112 unique addresses are far more than enough for the I<sup>2</sup>C bus. Because of bus capacitance limitations, it would be nearly impossible to put that many devices on the same physical bus lines. Forget about adding another 1,024 devices; that’s way beyond the electrical capabilities of the bus. </p>&#13;
<p>The only argument for 10-bit addresses is that it expands the peripheral designer’s ability to put several copies of the same device on the bus with less chance of creating address conflicts with other devices. For example, you might want to put four copies of a digital-to-analog converter on the I<sup>2</sup>C bus, but doing so might create address conflict with other chips you’d like to use. Using 10-bit addresses gives you more breathing room to spread out the addresses of the peripherals. However, as almost no peripheral ICs support extended addressing, this isn’t useful.</p>&#13;
<p>Note that if you really want to include multiple copies of the same IC in your design with possible address conflicts, there is another solution: the I<sup>2</sup>C multiplexer. See Chapter 12 for more information.</p>&#13;
<h3 id="h2-502468c02-0007">2.5.7	Device ID</h3>&#13;
<p class="BodyFirst">The device ID is another really good idea that, unfortunately, a large percentage of devices don’t support. The concept is to have a controller transmit the “device bus ID” (0xF8, which is address 0x7C plus R/W = 0), followed by the peripheral address. Then the controller does a restart, transmits 0xF9 (0x7C plus R/W = 1), and then reads 3 bytes back from the peripheral device: 12 bits that specify the manufacturer (a value specified by NXP Semiconductors), 9 bits that specify the part number (assigned by the manufacturer), and 3 bits that specify the die (IC) revision.</p>&#13;
<p>In theory, this would be a nice feature to use to identify devices on the bus. In practice, because so few chips support it, it’s a nearly useless feature. Nevertheless, if a particular part does support it, obtaining the die revision information can be useful as it may help you program work-arounds for bugs in various revisions of the chip.</p>&#13;
<p>For more information about the device ID command, see the I<sup>2</sup>C bus specifications and user manual in “For More Information.”</p>&#13;
<h2 id="h1-502468c02-0006"><span epub:type="pagebreak" id="Page_26" title="26"/>	2.6	Resetting the I<sup>2</sup>C Bus</h2>&#13;
<p class="BodyFirst">Because of bugs in application software, device drivers, or firmware or hardware on the device, some peripheral chips have been known to “latch up” and enter an unknown, that is, illegal state. Sometimes this means you lose the functionality of that chip until it is reset. Even worse, sometimes that chip stops while pulling the SDA or SCL line low, meaning the I<sup>2</sup>C bus is useless from that point forward. In such situations, you’ll want to reset the device.</p>&#13;
<p>Of course, you can use the general call command to send a reset command to all the devices in the system. However, this approach suffers from a couple problems:</p>&#13;
<ul>&#13;
<li>Not all devices respond to the general call/reset command.</li>&#13;
<li>The general call/reset command resets <em>every</em> device that is listening for it. You may not want to do this as you’d have to reinitialize all the devices on the bus.</li>&#13;
<li>If the device itself is hung up, it may not respond to a software command sent over the I<sup>2</sup>C bus. This is especially true if it is pulling the SDA or SCL line low, which means the command would never arrive.</li>&#13;
</ul>&#13;
<p>Resetting the I<sup>2</sup>C bus calls for a hardware solution. A few devices support a <em>reset pin</em> on the IC. Typically, pulling such a pin low will reset the device and initialize it to a power-up state. The device may require further initialization once it has reached that state, but this is better than having to reset the whole system to make the chip recover. Connecting the device’s reset pin to an available <em>general-purpose I/O (GPIO)</em> pin on the main CPU would allow you to programmatically reset the device under program control.</p>&#13;
<p>Of course, you could run a single reset line to all the devices that provide a reset pin. However, this runs into the same problem as the general call/reset command—you reset all the devices and have to reinitialize all of them to correct the problems with a single IC.</p>&#13;
<p>The biggest problem with the hardware reset approach is that not every I<sup>2</sup>C peripheral device out there has a reset pin on it. For those devices that don’t have a reset chip, another solution is to temporarily turn off the power to the IC for a bit and then reapply power. This will certainly reset the chip to its power-on state. You could wire some transistors to do this. Another solution is an off-the-shelf device like the SparkFun Qwiic Power Switch (<a class="LinkURL" href="https://www.sparkfun.com/products/16740">https://www.sparkfun.com/products/16740</a>). This is an I<sup>2</sup>C peripheral that lets you turn on and off the power to other I<sup>2</sup>C devices, either for resetting or for low-power standby operation.</p>&#13;
<h2 id="h1-502468c02-0007">	2.7	Detecting I<sup>2</sup>C Peripherals on the Bus</h2>&#13;
<p class="BodyFirst">One common desire programmers have is to determine whether a peripheral is present at some address on the I<sup>2</sup>C bus. In theory, the Device ID operation (see section 2.5.7, “Device ID,” earlier in this chapter) would provide this <span epub:type="pagebreak" id="Page_27" title="27"/>capability. A controller could send the Device ID special address (0xF8) on the bus followed by the device address to check. If the response is a NAK, then no device is at that address; if an ID response comes back, then the controller knows a device is present at that address, and the ID information exactly specifies the device.</p>&#13;
<p>The only problem with using the Device ID approach is that supporting the Device ID command is optional in a peripheral. If a peripheral does not support the Device ID command, it simply doesn’t acknowledge the request. Therefore, although the peripheral is actually present, the Device ID command suggests that it is not. As a large percentage of I<sup>2</sup>C peripheral ICs do not support the Device ID command, this isn’t a practical way to detect such peripherals.</p>&#13;
<p>A common solution is to send a start condition, an address byte with the R/W bit high (a read operation), and then immediately send a stop condition without waiting for any data from the peripheral. The peripheral will acknowledge the address byte. However, the stop condition will prevent the peripheral device from actually transmitting data back to the controller. The controller can check for an ACK or NAK and use that response to determine if a peripheral is present at the specified address. This won’t tell the controller which peripheral is present, but it will, at least, give a “something is there” or “nothing is there” response. This is how many utilities, such as the Linux <code>i2cdetect</code> utility, work.</p>&#13;
<p>There are a couple show-stopper problems with this approach to detection. One issue is that SMBus peripherals (SMBus is a variant of the I<sup>2</sup>C bus; see section 5.1, “SMBus,” in Chapter 5), according to the standard, can use the R/W bit as a data element. For example, the R/W bit can turn some external device on or off based on whether you read the address or write to it. If you send a read command immediately followed by a stop condition to such a peripheral, it could change the state of that device. If the state had previously been off, sending the read command might change the state to on (assuming the peripheral copies the value of the R/W bit directly to the state where 1 = on = R and 0 = off = W). Clearly, using a read command to detect the presence of the device is bad because the detection could also change its state.</p>&#13;
<p>One solution to this problem is to use both the Device ID and “read with immediate stop condition” commands. The SMBus standard requires all devices to support the Device ID command. If you <em>first</em> issue a Device ID command and an SMBus device is present, it will respond with appropriate identification information. If you get a NAK from the Device ID, then an SMBus device does not appear at that address, and you can try the read operation to see if you get a response. If you still get a NAK, you can probably assume that there is no device at the given address.</p>&#13;
<p>This assumes, of course, that only the devices that use the R/W bit as data will also support the Device ID command. The only place I’ve ever seen using the R/W bit as data has been in the SMBus documentation, so it’s probably a safe assumption. Of course, if you create your own peripheral device and use the R/W bit as data, you should probably support the Device ID command to allow detection software to work around this issue. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<span epub:type="pagebreak" id="Page_28" title="28"/><h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Existing detection software may not use this two-phase (trying Device ID and then the read command) approach to device detection. For example, the Linux <code>i2cdetect</code> utility does not use this approach.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Another problem with putting a read command on the bus and checking for a response is that <em>write-only</em> devices may not respond to a read command. The Linux <code>i2cdetect</code> utility solves this problem by doing reads to certain addresses and writes to others, as well as providing command line options to force certain types of detection algorithms. Check out the source code for the <code>i2cdetect</code> application for more information on their technique (see “For More Information” for additional details on <code>i2cdetect</code>).</p>&#13;
<p>The bottom line is that there is no <em>perfect</em> way to detect peripheral devices on the I<sup>2</sup>C bus. Some schemes will fail to detect a device that is present; others may change the state of a device that is present. Ultimately, the best way to detect things is by design: know what devices are installed in your system and intentionally program for them.</p>&#13;
<h2 id="h1-502468c02-0008">	2.8	Creating Custom Devices</h2>&#13;
<p class="BodyFirst">For most real-world applications, you can probably find an IC that interfaces to the I<sup>2</sup>C bus and does just what you need. However, it’s also possible that you have such a specialized application that no such peripheral could possibly exist. Fortunately, you don’t have to rely solely on off-the-shelf parts: you can create your own I<sup>2</sup>C peripheral devices instead. There are several ways to do this, and this book covers a couple of them. The next chapter, for example, will discuss how to implement I<sup>2</sup>C controller and peripheral devices totally in software. Later chapters will discuss how to use the I<sup>2</sup>C hardware present on various SBCs to create such devices. You’re limited only by your imagination.</p>&#13;
<h2 id="h1-502468c02-0009">	2.9	Chapter Summary</h2>&#13;
<p class="BodyFirst">This chapter discussed the format of the data on the I<sup>2</sup>C bus—the I<sup>2</sup>C protocol. This includes a description of data on the I<sup>2</sup>C bus, I<sup>2</sup>C addresses and R/W control, and special patterns to start and end I<sup>2</sup>C transmissions (start and stop conditions). This chapter also described a small optimization, repeated start conditions, and how to introduce wait states in an I<sup>2</sup>C transmission via clock stretching.</p>&#13;
<p>The I<sup>2</sup>C bus supports several features using special addresses. This includes the general call address, hardware general calls, the start byte, high-speed control, 10-bit peripheral addressing, and device ID. See the appropriate sections in this chapter for more details.</p>&#13;
<p>This chapter concluded with a discussion of resetting the I<sup>2</sup>C bus and detecting peripherals on the I<sup>2</sup>C bus, along with a brief discussion of creating custom I<sup>2</sup>C peripherals.</p>&#13;
<p><span epub:type="pagebreak" id="Page_29" title="29"/>The next chapter uses the information from this chapter to describe how to implement the I<sup>2</sup>C protocol using software. The code present in that chapter also provides another view of the I<sup>2</sup>C protocol, clarifying it for those who prefer to see a formal (code) description of the protocol.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>For More Information</h2>&#13;
<ol class="none">&#13;
<li>Clock stretching: <a class="LinkURL" href="https://www.silabs.com/documents/public/application-notes/an1095-i2c-master-does-not-support-clock-stretching.pdf">https://www.silabs.com/documents/public/application-notes/an1095-i2c-master-does-not-support-clock-stretching.pdf</a></li>&#13;
<li><code>i2cdetect</code> documentation: <a class="LinkURL" href="https://linux.die.net/man/8/i2cdetect">https://linux.die.net/man/8/i2cdetect</a></li>&#13;
<li><code>i2cdetect</code> source code: <a class="LinkURL" href="https://kernel.googlesource.com/pub/scm/utils/i2c-tools/i2c-tools/+/v3.1.2/tools/i2cdetect.c">https://kernel.googlesource.com/pub/scm/utils/i2c-tools/i2c-tools/+/v3.1.2/tools/i2cdetect.c</a></li>&#13;
<li>High-speed and ultra-fast I<sup>2</sup>C modes in the <em>I</em><sup><em>2</em></sup><em>C Bus Specification and User Manual:</em> <a class="LinkURL" href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">https://www.nxp.com/docs/en/user-guide/UM10204.pdf</a></li>&#13;
<li><em>UM10204 I</em><sup><em>2</em></sup><em>C Bus Specification and User Manual:</em> <a class="LinkURL" href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">https://www.nxp.com/docs/en/user-guide/UM10204.pdf</a></li>&#13;
<li>The I<sup>2</sup>C Bus: <a class="LinkURL" href="https://www.i2c-bus.org">https://www.i2c-bus.org</a></li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>