<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="appa"><span epub:type="pagebreak" id="page_374"/><span class="big">A</span><br/>A CRASH COURSE ON X86 ASSEMBLY</h2>&#13;
<p class="startpara">Because assembly language is the standard representation of the machine instructions you’ll find in binaries, many binary analyses are based on disassembly. Therefore, it’s important that you’re familiar with the basics of x86 assembly language to get the most out of this book. This appendix introduces you to the essentials that you need to know to follow along.</p>&#13;
<p class="indent">The purpose of this appendix is not to teach you how to write assembly programs (there are books dedicated to that subject) but to show you the essentials you need to know to understand disassembled programs. You’ll learn how assembly programs and x86 instructions are structured and how they behave at runtime. Moreover, you’ll see how common code constructs from C/C++ programs are represented at the assembly level. I’ll only cover basic 64-bit user-mode x86 instructions, not floating-point instructions or extended instruction sets like SSE or MMX. For brevity, I’ll refer to the 64-bit variant of x86 (x86-64 or x64) simply as x86, since that’s the focus of this book.</p>&#13;
<h3 class="h3" id="appa_1"><span epub:type="pagebreak" id="page_375"/>A.1 Layout of an Assembly Program</h3>&#13;
<p class="noindent"><a href="appa.xhtml#appalist1">Listing A-1</a> shows a simple C program, and <a href="appa.xhtml#appalist2">Listing A-2</a> shows the corresponding assembly program produced by <span class="literal">gcc</span> 5.4.0. (<a href="ch01.xhtml#ch01">Chapter 1</a> explains how compilers transform C programs into assembly listings and eventually into binaries.)</p>&#13;
<p class="indent">When you disassemble a binary, the disassembler essentially tries to translate it back into an accurate assembly listing resembling the compiler-generated assembly as closely as possible. For now, let’s take a look at the <em>layout</em> of the assembly program without going into details on the assembly instructions yet.</p>&#13;
<p class="listing1" id="appalist1"><em>Listing A-1: “Hello, world!” in C</em></p>&#13;
<p class="programs">  #include &lt;stdio.h&gt;<br/><br/>  int<br/><span class="ent">➊</span> main(int argc, char *argv[])<br/>  {<br/>     <span class="ent">➋</span>printf(<span class="ent">➌</span>"Hello, world!\n");<br/><br/>     return 0;<br/>  }</p>&#13;
<p class="listing1" id="appalist2"><em>Listing A-2: Assembly generated by</em> <span class="codeitalic">gcc</span></p>&#13;
<p class="programs">      .file "hello.c"<br/>      .intel_syntax noprefix<br/><span class="ent">➍</span>    .section .rodata<br/>  .LC0:<br/><span class="ent">➎</span>    .string "Hello, world!"<br/><span class="ent">➏</span>    .text<br/>     .globl  main<br/>     .type   main, @function<br/><span class="ent">➐</span> main<br/>      push    rbp<br/>      mov     rbp, rsp<br/>      sub     rsp, 16<br/>      mov     DWORD PTR [rbp-4], edi<br/>      mov     QWORD PTR [rbp-16], rsi<br/><span class="ent">➑</span>    mov     edi, OFFSET FLAT:.LC0<br/><span class="ent">➒</span>    call    puts<br/>      mov     eax, 0<br/>      leave<br/>      ret<br/>      .size    main, .-main<br/>      .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9)"<br/>      .section .note.GNU-stack,"",@progbits</p>&#13;
<p class="indent"><a href="appa.xhtml#appalist1">Listing A-1</a> consists of a <span class="literal">main</span> function <span class="ent">➊</span> that calls <span class="literal">printf</span> <span class="ent">➋</span> to print a constant <span class="literal">"Hello, world!"</span> string <span class="ent">➌</span>. At a high level, the corresponding assembly program consists of four types of components: instructions, directives, labels, and comments.</p>&#13;
<h4 class="h4" id="appa_1_1"><em>A.1.1 Assembly Instructions, Directives, Labels, and Comments</em></h4>&#13;
<p class="noindent"><a href="appa.xhtml#appatab1">Table A-1</a> shows examples of each component type. Note that the exact syntax for each component varies per assembler or disassembler. For the purposes of this book, you won’t need to be intimately familiar with any assembler’s syntactical quirks; you’ll only need to learn to read and analyze <span epub:type="pagebreak" id="page_376"/>disassembled code, not write your own assembly code. Here, I’ll stick to the assembly syntax produced by <span class="literal">gcc</span> with the <span class="literal">-masm=intel</span> option.</p>&#13;
<p class="tab-caption" id="appatab1"><strong>Table A-1:</strong> Components of an Assembly Program</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Type</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Example</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Meaning</strong></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>Instruction</td>&#13;
<td><span class="literal">mov eax, 0</span></td>&#13;
<td>Move zero into <span class="literal">eax</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Directive</td>&#13;
<td><span class="literal">.section .text</span></td>&#13;
<td>Place the following content into the <span class="literal">.text</span> section</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Directive</td>&#13;
<td><span class="literal">.string "foobar"</span></td>&#13;
<td>Define an ASCII string containing <span class="literal">"foobar"</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Directive</td>&#13;
<td><span class="literal">.long 0x12345678</span></td>&#13;
<td>Define a doubleword with value <span class="literal">0x12345678</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Label</td>&#13;
<td><span class="literal">foo: .string "foobar"</span></td>&#13;
<td>Define the <span class="literal">"foobar"</span> string with symbolic name <span class="literal">foo</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;">Comment</td>&#13;
<td style="border-bottom: solid 0.2em;"><span class="literal"># this is a comment</span></td>&#13;
<td style="border-bottom: solid 0.2em;">A human-readable comment</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><em>Instructions</em> are the actual operations that the CPU executes. <em>Directives</em> are commands that tell the assembler to produce a particular piece of data, place instructions or data in a particular section, and so on. Finally, <em>labels</em> are symbolic names that you can use to refer to instructions or data in the assembly program, and <em>comments</em> are human-readable strings for documentation purposes. After the program is assembled and linked into a binary, all symbolic names are replaced by addresses.</p>&#13;
<p class="indent">The assembly program in <a href="appa.xhtml#appalist2">Listing A-2</a> directs the assembler to place the <span class="literal">"Hello, world!"</span> string in the <span class="literal">.rodata</span> section <span class="ent">➍</span><span class="ent">➎</span>, which is a section dedicated to storing constant data. The directive <span class="literal">.section</span> tells the assembler in which section to place the following content, while <span class="literal">.string</span> is a directive that allows you to define an ASCII string. There are also directives to define other types of data, such as <span class="literal">.byte</span> (define a byte), <span class="literal">.word</span> (a 2-byte word), <span class="literal">.long</span> (a 4-byte doubleword), and <span class="literal">.quad</span> (an 8-byte quadword).</p>&#13;
<p class="indent">The <span class="literal">main</span> function is placed in the <span class="literal">.text</span> section <span class="ent">➏</span><span class="ent">➐</span>, dedicated to storing code. The <span class="literal">.text</span> directive is shorthand for <span class="literal">.section .text</span>, and <span class="literal">main:</span> introduces a symbolic label for the <span class="literal">main</span> function.</p>&#13;
<p class="indent">The label is followed by the actual instructions that <span class="literal">main</span> contains. These instructions can refer symbolically to previously declared data, such as <span class="literal">.LC0</span> <span class="ent">➑</span> (the symbolic name <span class="literal">gcc</span> chose for the <span class="literal">"Hello, world!"</span> string). Because the program prints a constant string (without variadic arguments), <span class="literal">gcc</span> replaces the <span class="literal">printf</span> call with a call to <span class="literal">puts</span> <span class="ent">➒</span>, a simpler function that prints a given string to screen.</p>&#13;
<h4 class="h4" id="appa_1_2"><em>A.1.2 Separation Between Code and Data</em></h4>&#13;
<p class="noindent">One key observation you can make in <a href="appa.xhtml#appalist2">Listing A-2</a> is that compilers usually separate code and data into different sections. That’s convenient when you’re disassembling or analyzing a binary because you know which bytes in the program to interpret as code and which to interpret as data. However, there’s nothing inherent in the x86 architecture preventing you from mixing code and data in the same section, and in practice, some compilers or handwritten assembly programs do exactly that.</p>&#13;
<h4 class="h4" id="appa_1_3"><em>A.1.3 <span epub:type="pagebreak" id="page_377"/>AT&amp;T vs. Intel Syntax</em></h4>&#13;
<p class="noindent">As mentioned, different assemblers use different syntaxes for assembly programs. On top of that, there are two different syntax formats in use to represent x86 machine instructions: <em>Intel syntax</em> and <em>AT&amp;T syntax</em>.</p>&#13;
<p class="indent">AT&amp;T syntax explicitly prefixes every register name with the <span class="literal">%</span> symbol and every constant with a <span class="literal">$</span> symbol, while Intel syntax omits these symbols. In this book, I use Intel syntax because it’s less verbose. The most crucial difference between AT&amp;T and Intel is that they order instruction operands in exactly opposite ways. In AT&amp;T syntax, the source operand comes before the destination so that moving a constant into the <span class="literal">edi</span> register looks like this:</p>&#13;
<p class="programs">mov    $0x6,%edi</p>&#13;
<p class="indent">In contrast, Intel syntax represents the same instruction as follows, with the destination operand first:</p>&#13;
<p class="programs">mov    edi,0x6</p>&#13;
<p class="indent">It’s important to keep the operand ordering in mind because you’ll probably encounter both syntax styles as you delve further into binary analysis.</p>&#13;
<h3 class="h3" id="appa_2">A.2 Structure of an x86 Instruction</h3>&#13;
<p class="noindent">Now that you have an idea of how assembly programs are structured, let’s take a look at the format of assembly instructions. You’ll also see the structure of the machine-level instructions that the assembly represents.</p>&#13;
<h4 class="h4" id="appa_2_1"><em>A.2.1 Assembly-Level Representation of x86 Instructions</em></h4>&#13;
<p class="noindent">At the assembly level, x86 instructions generally have the form <span class="literal">mnemonic destination, source</span>. The mnemonic is a human-readable representation of a machine instruction, and source and destination are the operands of the instruction. For example, the assembly instruction <span class="literal">mov rbx, rax</span> copies the value from the <span class="literal">rax</span> register into <span class="literal">rbx</span>. Note that not all instructions have exactly two operands; some even have no operands at all, as you’ll see shortly.</p>&#13;
<p class="indent">As mentioned, mnemonics are higher-level representations of the machine instructions the CPU understands. Let’s take a brief look at how x86 instructions are structured at the machine level. That’s useful to know in some binary analysis situations, such as when you’re modifying an existing binary.</p>&#13;
<h4 class="h4" id="appa_2_2"><em>A.2.2 Machine-Level Structure of x86 Instructions</em></h4>&#13;
<p class="noindent">The x86 ISA uses variable-length instructions; there are x86 instructions that consist of only 1 byte, but also multibyte instructions, ranging up to a <span epub:type="pagebreak" id="page_378"/>maximum instruction length of 15 bytes. Moreover, instructions can start at any memory address. This means that the CPU doesn’t enforce any particular code alignment, although compilers often do align code to optimize the performance of fetching instructions from memory. <a href="appa.xhtml#appafig1">Figure A-1</a> shows the machine-level structure of an x86 instruction.</p>&#13;
<div class="image"><a id="appafig1"/><img src="Images/f377-01.jpg" alt="image" width="688" height="153"/></div>&#13;
<p class="fig-caption"><em>Figure A-1: Structure of an x86 instruction</em></p>&#13;
<p class="indent">An x86 instruction consists of optional prefixes, an opcode, and zero or more operands. Note that all parts except for the opcode are optional.</p>&#13;
<p class="indent">The opcode is the main designator for the instruction type. For instance, the opcode <span class="literal">0x90</span> encodes a <span class="literal">nop</span> instruction, which does nothing, while the opcodes <span class="literal">0x00</span>–<span class="literal">0x05</span> encode various types of <span class="literal">add</span> instructions. Prefixes can modify the behavior of an instruction, for example, causing it to repeat multiple times or access a different memory segment. Finally, the operands are the data that the instruction operates on.</p>&#13;
<p class="indent">The <em>addressing mode</em> byte, also known as the <em>MOD-R/M</em> or <em>MOD-REGR/M</em> byte, contains metadata about the instruction’s operand types. The <em>SIB (scale/index/base)</em> bytes and the <em>displacement</em> are used to encode memory operands, and the <em>immediate</em> field can contain an immediate operand (a constant numeric value). You’ll see what these fields mean in more detail shortly.</p>&#13;
<p class="indent">In addition to the <em>explicit operands</em> shown in <a href="appa.xhtml#appafig1">Figure A-1</a>, some instructions have <em>implicit operands</em>. These aren’t explicitly encoded in the instruction but are innate to the opcode. For example, the destination operand of opcode <span class="literal">0x05</span> (an <span class="literal">add</span> instruction) is always <span class="literal">rax</span>, and only the source operand is variable and needs to be explicitly encoded. As another example, the <span class="literal">push</span> instruction implicitly updates <span class="literal">rsp</span> (the stack pointer register).</p>&#13;
<p class="indent">On x86, instructions can have three different types of operands: register operands, memory operands, and immediates. Let’s take a look at each of the valid operand types.</p>&#13;
<h4 class="h4" id="appa_2_3"><em>A.2.3 Register Operands</em></h4>&#13;
<p class="noindent"><em>Registers</em> are small, quickly accessible pieces of storage located on the CPU itself. Some registers have a special purpose, such as the instruction pointer that tracks the current execution address or the stack pointer that tracks the top of the stack. Others are general-purpose storage units for variables used by whatever program the CPU is executing.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_379"/>General-Purpose Registers</h5>&#13;
<p class="noindent">In the original 8086 instruction set on which x86 is based, registers were 16 bits wide. The 32-bit x86 ISA extended these registers to 32 bits, and x86-64 extended them further to 64 bits. To retain backward compatibility, the registers used in the newer instruction sets are a superset of the older registers.</p>&#13;
<p class="indent">To specify a register operand in assembly, you use the register’s name. For example, <span class="literal">mov rax,64</span> moves the value 64 into the <span class="literal">rax</span> register. <a href="appa.xhtml#appafig2">Figure A-2</a> shows how the 64-bit <span class="literal">rax</span> register is subdivided into legacy 32-bit and 16-bit registers. The lower 32 bits of <span class="literal">rax</span> form a register named <span class="literal">eax</span>, and the lower 16 bits of that form the original 8086 register <span class="literal">ax</span>. You can access the lower byte in <span class="literal">ax</span> through the register name <span class="literal">al</span> and the higher byte through <span class="literal">ah</span>.</p>&#13;
<div class="image"><a id="appafig2"/><img src="Images/f378-01.jpg" alt="image" width="374" height="165"/></div>&#13;
<p class="fig-caption"><em>Figure A-2: Subdivision of the x86-64</em> <span class="literal">rax</span> <em>register</em></p>&#13;
<p class="indent">Other registers have similar naming schemes. <a href="appa.xhtml#appatab2">Table A-2</a> shows the names of the general-purpose registers available on x86-64, as well as the available legacy “subregisters.” The <span class="literal">r8</span>–<span class="literal">r15</span> registers were added in x86-64 and aren’t available in earlier x86 variants. Note that if you set a 32-bit subregister like <span class="literal">eax</span>, this automatically zeros out the other bits in the parent register (in this case, <span class="literal">rax</span>); setting smaller subregisters like <span class="literal">ax</span>, <span class="literal">al</span>, and <span class="literal">ah</span> retains the other bits.</p>&#13;
<p class="tab-caption" id="appatab2"><strong>Table A-2:</strong> x86 General-Purpose Registers</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Description</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>64-bit</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Lower 32 bits</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Lower 16 bits</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Lower byte</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>2nd byte</strong></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>Accumulator</td>&#13;
<td><span class="literal">rax</span></td>&#13;
<td><span class="literal">eax</span></td>&#13;
<td><span class="literal">ax</span></td>&#13;
<td><span class="literal">al</span></td>&#13;
<td><span class="literal">ah</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Base</td>&#13;
<td><span class="literal">rbx</span></td>&#13;
<td><span class="literal">ebx</span></td>&#13;
<td><span class="literal">bx</span></td>&#13;
<td><span class="literal">bl</span></td>&#13;
<td><span class="literal">bh</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Counter</td>&#13;
<td><span class="literal">rcx</span></td>&#13;
<td><span class="literal">ecx</span></td>&#13;
<td><span class="literal">cx</span></td>&#13;
<td><span class="literal">cl</span></td>&#13;
<td><span class="literal">ch</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Data</td>&#13;
<td><span class="literal">rdx</span></td>&#13;
<td><span class="literal">edx</span></td>&#13;
<td><span class="literal">dx</span></td>&#13;
<td><span class="literal">dl</span></td>&#13;
<td><span class="literal">dh</span></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>Stack</td>&#13;
<td><span class="literal">pointer</span></td>&#13;
<td><span class="literal">rsp</span></td>&#13;
<td><span class="literal">esp</span></td>&#13;
<td><span class="literal">sp</span></td>&#13;
<td><span class="literal">spl</span></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>Base</td>&#13;
<td><span class="literal">pointer</span></td>&#13;
<td><span class="literal">rbp</span></td>&#13;
<td><span class="literal">ebp</span></td>&#13;
<td><span class="literal">bp</span></td>&#13;
<td><span class="literal">bpl</span></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>Source index</td>&#13;
<td><span class="literal">rsi</span></td>&#13;
<td><span class="literal">esi</span></td>&#13;
<td><span class="literal">si</span></td>&#13;
<td><span class="literal">sil</span></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>Destination index</td>&#13;
<td><span class="literal">rdi</span></td>&#13;
<td><span class="literal">edi</span></td>&#13;
<td><span class="literal">di</span></td>&#13;
<td><span class="literal">dil</span></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;">x86-64 GP registers</td>&#13;
<td style="border-bottom: solid 0.2em;"><span class="literal">r8–r15</span></td>&#13;
<td style="border-bottom: solid 0.2em;"><span class="literal">r8d–r15d</span></td>&#13;
<td style="border-bottom: solid 0.2em;"><span class="literal">r8w–r15w</span></td>&#13;
<td style="border-bottom: solid 0.2em;"><span class="literal">r8l–r15l</span></td>&#13;
<td style="border-bottom: solid 0.2em;"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Don’t put too much weight on the description column for most registers. Those descriptions stem from the 8086 instruction set, but nowadays most of the registers shown in <a href="appa.xhtml#appatab2">Table A-2</a> are simply used interchangeably. As <span epub:type="pagebreak" id="page_380"/>you can see in <a href="appa.xhtml#appa_4_1">Section A.4.1</a>, the stack pointer (<span class="literal">rsp</span>) and base pointer (<span class="literal">rbp</span>) are considered special because they’re used to track the layout of the stack, even though you can in principle use them as general-purpose registers.</p>&#13;
<h5 class="h5">Other Registers</h5>&#13;
<p class="noindent">In addition to the registers shown in <a href="appa.xhtml#appatab2">Table A-2</a>, x86 CPUs contain other registers that aren’t general purpose. The two most important are <span class="literal">rip</span> (called <span class="literal">eip</span> on 32-bit x86 and <span class="literal">ip</span> on 8086) and <span class="literal">rflags</span> (called <span class="literal">eflags</span> or <span class="literal">flags</span> in older ISAs). The instruction pointer always points to the next instruction address and is automatically set by the CPU; you can’t manually write it. On x86-64 you can read the value of the instruction pointer, but on 32-bit x86 you can’t even do that. The status flags register is used for comparisons and conditional branches and tracks things like whether the last operation yielded zero, resulted in an overflow, and so on.</p>&#13;
<p class="indent">The x86 ISA also has <em>segment registers</em> named <span class="literal">cs</span>, <span class="literal">ds</span>, <span class="literal">ss</span>, <span class="literal">es</span>, <span class="literal">fs</span>, and <span class="literal">gs</span> that you can use to divide memory into different segments. Segmentation has largely fallen into disuse, and x86-64 has mostly dropped support for it, so I won’t go into details on segmentation here. If you’re interested in learning more, a dedicated book on x86 assembly should cover this topic.</p>&#13;
<p class="indent">There are also <em>control registers</em> such as <span class="literal">cr0</span>–<span class="literal">cr10</span> that the kernel uses to control the CPU’s behavior, for instance, to switch between protected mode and real mode. Additionally, registers <span class="literal">dr0</span>–<span class="literal">dr7</span> are <em>debug registers</em> that provide hardware support for debugging features such as breakpoints. On x86, control and debug registers are not accessible from user mode; only the kernel can access them. Therefore, I won’t cover these registers further in this appendix.</p>&#13;
<p class="indent">There are also various <em>model-specific registers (MSRs)</em> and registers used in extended instruction sets like SSE and MMX that aren’t present on all x86 CPUs. You can use the <span class="literal">cpuid</span> instruction to find out which features the CPU supports and use the <span class="literal">rdmsr</span> and <span class="literal">wrmsr</span> instructions to read or write model-specific registers. Because many of these special registers are available only from the kernel, you won’t have to deal with them in this book.</p>&#13;
<h4 class="h4" id="appa_2_4"><em>A.2.4 Memory Operands</em></h4>&#13;
<p class="noindent"><em>Memory operands</em> specify a memory address where the CPU should fetch one or more bytes. The x86 ISA supports only one explicit memory operand per instruction. That is, you can’t directly <span class="literal">mov</span> bytes from one memory location to another in one instruction. To accomplish that, you have to use a register as intermediate storage.</p>&#13;
<p class="indent">On x86, you specify memory operands with <span class="literal">[</span><em>base</em> <span class="literal">+</span> <em>index</em><span class="literal">*</span><em>scale</em> <span class="literal">+</span> <em>displacement</em><span class="literal">]</span>, where <em>base</em> and <em>index</em> are 64-bit registers, <em>scale</em> is an integer with the value 1, 2, 4, or 8, and <em>displacement</em> is a 32-bit constant or a symbol. All of these components are optional. The CPU computes the result of the memory operand expression, yielding the final memory address. The base, index, and scale are encoded in the instruction’s SIB byte, while the displacement is encoded in the field of the same name. The scale defaults to 1, while the displacement defaults to 0.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_381"/>This memory operand format is flexible enough to allow many common code paradigms in a straightforward way. For instance, you can use an instruction like <span class="literal">mov eax, DWORD PTR [rax*4 + arr]</span> to access an array element, where <span class="literal">arr</span> is a displacement containing the array’s starting address, <span class="literal">rax</span> contains the index of the element you want to access, and each array element is 4 bytes long. Here, <span class="literal">DWORD PTR</span> tells the assembler that you want to fetch 4 bytes (a doubleword or DWORD) from memory. Similarly, one way to access a field in a <span class="literal">struct</span> is to store the <span class="literal">struct</span>’s starting address in a base register and add the displacement of the field you want to access.</p>&#13;
<p class="indent">On x86-64, you’re allowed to use <span class="literal">rip</span> (the instruction pointer) as the base in a memory operand, though in that case you can’t use an index register. Compilers make frequent use of this possibility for position-independent code and data accesses, among other things, so you’ll see lots of <span class="literal">rip</span>-relative addressing in x86-64 binaries.</p>&#13;
<h4 class="h4" id="appa_2_5"><em>A.2.5 Immediates</em></h4>&#13;
<p class="noindent"><em>Immediates</em> are constant integer operands hardcoded in the instruction. For example, in the instruction <span class="literal">add rax, 42</span>, the value 42 is an immediate.</p>&#13;
<p class="indent">On x86, immediates are encoded in little-endian format; the least significant byte of a multibyte integer comes first in memory. In other words, if you write an assembly-level instruction like <span class="literal">mov ecx, 0x10203040</span>, the corresponding machine-level instruction encodes the immediate with the bytes reversed, as <span class="literal">0x40302010</span>.</p>&#13;
<p class="indent">To encode signed integers, x86 uses two’s complement notation, which encodes a negative value by taking the positive version of that value and then flipping all the bits and adding 1 while ignoring overflows. For example, to encode a 4-byte integer with the value −1, you take the integer <span class="literal">0x00000001</span> (the hexadecimal representation of 1), flip all the bits to produce <span class="literal">0xfffffffe</span>, and then add 1 to yield the final two’s complement representation <span class="literal">0xffffffff</span>. When you’re disassembling code and you see an immediate or memory value that starts with lots of <span class="literal">0xff</span> bytes, you’re often dealing with a negative value.</p>&#13;
<p class="indent">Now that you’re familiar with the general format and workings of x86 instructions, let’s take a look at the semantics of some of the common instructions you’ll encounter in this book and your own binary analysis projects.</p>&#13;
<h3 class="h3" id="appa_3">A.3 Common x86 Instructions</h3>&#13;
<p class="noindent"><a href="appa.xhtml#appatab3">Table A-3</a> describes common x86 instructions. To learn more about an instruction not listed in this table, look it up in an online reference such as <em><a href="http://ref.x86asm.net/">http://ref.x86asm.net/</a></em> or in the Intel manual at <em><a href="https://software.intel.com/en-us/articles/intel-sdm/">https://software.intel.com/en-us/articles/intel-sdm/</a></em>. Most of the instructions listed in the table are self-explanatory, but a few deserve a more detailed discussion.</p>&#13;
<p class="tab-caption" id="appatab3"><span epub:type="pagebreak" id="page_382"/><strong>Table A-3:</strong> Common x86 Instructions</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Instruction</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Description</strong></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Data transfer</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➊</span> <span class="literal">mov dst, src</span></td>&#13;
<td><em>dst = src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">xchg dst1, dst2</span></td>&#13;
<td>Swap <em>dst1</em> and <em>dst2</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➋</span> <span class="literal">push src</span></td>&#13;
<td>Push <em>src</em> onto the stack and decrement <span class="literal">rsp</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">pop dst</span></td>&#13;
<td>Pop value from stack into <em>dst</em> and increment <span class="literal">rsp</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Arithmetic</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">add dst, src</span></td>&#13;
<td><em>dst += src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">sub dst, src</span></td>&#13;
<td><em>dst –= src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">inc dst</span></td>&#13;
<td><em>dst += 1</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">dec dst</span></td>&#13;
<td><em>dst –= 1</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">neg dst</span></td>&#13;
<td><em>dst = –dst</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➌</span> <span class="literal">cmp src1, src2</span></td>&#13;
<td>Set status flags based on <em>src1 – src2</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Logical/bitwise</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">and dst, src</span></td>&#13;
<td><em>dst &amp;= src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">or dst, src</span></td>&#13;
<td><em>dst |= src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">xor dst, src</span></td>&#13;
<td><em>dst ^= src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">not dst</span></td>&#13;
<td><em>dst = ~dst</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➍</span> <span class="literal">test src1, src2</span></td>&#13;
<td>Set status flags based on <em>src1 &amp; src2</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Unconditional branches</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">jmp addr</span></td>&#13;
<td>Jump to address</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">call addr</span></td>&#13;
<td>Push return address on stack, then call function at address</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">ret</span></td>&#13;
<td>Pop return address from stack and return to that address</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➎</span> <span class="literal">syscall</span></td>&#13;
<td>Enter the kernel to perform a system call</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Conditional branches (based on status flags)</strong><br/><span class="literal">jcc addr</span> jumps to address only if condition <em>cc</em> holds, else it falls through<br/><span class="literal">jncc</span> inverts the condition, jumping if it does not hold</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➏</span> <span class="literal">je addr</span>/<span class="literal">jz addr</span></td>&#13;
<td>Jump if zero flag is set (for example, operands were equal in last <span class="literal">cmp</span>)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">ja addr</span></td>&#13;
<td>Jump if <em>dst &gt; src</em> (“above”) in last comparison (unsigned)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">jb addr</span></td>&#13;
<td>Jump if <em>dst &lt; src</em> (“below”) in last comparison (unsigned)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">jg addr</span></td>&#13;
<td>Jump if <em>dst &gt; src</em> (“greater than”) in last comparison (signed)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">jl addr</span></td>&#13;
<td>Jump if <em>dst &lt; src</em> (“less than”) in last comparison (signed)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">jge addr</span></td>&#13;
<td>Jump if <em>dst &gt;= src</em> in last comparison (signed)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">jle addr</span></td>&#13;
<td>Jump of <em>dst &lt;= src</em> in last comparison (signed)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <span class="literal">js addr</span></td>&#13;
<td>Jump if last comparison set the sign bit (meaning the result was negative)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Miscellaneous</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;"><span class="ent">➐</span> <span class="literal">lea dst, src</span></td>&#13;
<td style="border-bottom: solid 0.2em;">Load memory address into <em>dst</em> (<em>dst = &amp;src</em>, where <em>src</em> must be in memory) <span class="literal">nop</span> Do nothing (for example for code padding)</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_383"/>First, it’s worth noting that <span class="literal">mov</span> <span class="ent">➊</span> is a bit of a misnomer because it doesn’t technically <em>move</em> the source operand into the destination. Rather, it copies it, leaving the source operand intact. The <span class="literal">push</span> and <span class="literal">pop</span> instructions <span class="ent">➋</span> have special significance with regard to stack management and function calls, as you’ll see shortly.</p>&#13;
<h4 class="h4" id="appa_3_1"><em>A.3.1 Comparing Operands and Setting Status Flags</em></h4>&#13;
<p class="noindent">The <span class="literal">cmp</span> instruction <span class="ent">➌</span> is important for implementing conditional branches. It subtracts the second operand from the first, but instead of storing the outcome of that operation somewhere, it sets status flags in the <span class="literal">rflags</span> register based on the outcome. Subsequent conditional branches check these status flags to decide whether the branch should be taken. Important flags include the <em>zero flag (ZF)</em>, the <em>sign flag (SF)</em>, and the <em>overflow flag (OF)</em>, which indicate whether the outcome of the comparison was zero, negative, or resulted in an overflow, respectively.</p>&#13;
<p class="indent">The <span class="literal">test</span> instruction <span class="ent">➍</span> is similar to <span class="literal">cmp</span>, but it sets status flags based on the bitwise AND of its operands, rather than the subtraction. It’s worth noting that some other instructions, besides <span class="literal">cmp</span> and <span class="literal">test</span>, set status flags as well. The Intel manual or online instruction reference show exactly which flags each instruction sets.</p>&#13;
<h4 class="h4" id="appa_3_2"><em>A.3.2 Implementing System Calls</em></h4>&#13;
<p class="noindent">To perform a system call, you use the <span class="literal">syscall</span> instruction <span class="ent">➎</span>. Before using it, you have to prepare the system call by selecting its number and setting its operands as specified by the operating system. For example, to perform a <span class="literal">read</span> system call on Linux, you load the value 0 (the system call number for <span class="literal">read</span>) into <span class="literal">rax</span>; then load the file descriptor, buffer address, and number of bytes to read into <span class="literal">rdi</span>, <span class="literal">rsi</span>, and <span class="literal">rdx</span>, respectively; and finally execute a <span class="literal">syscall</span> instruction.</p>&#13;
<p class="indent">To find out how to configure system calls on Linux, refer to <span class="literal">man syscalls</span> or an online reference like <em><a href="https://filippo.io/linux-syscall-table/">https://filippo.io/linux-syscall-table/</a></em>. Note that on 32-bit x86, you make a system call using <span class="literal">sysenter</span> or <span class="literal">int 0x80</span> (which triggers a software interrupt for interrupt vector <span class="literal">0x80</span>) instead of <span class="literal">syscall</span>. Also, system call conventions can differ on operating systems other than Linux.</p>&#13;
<h4 class="h4" id="appa_3_3"><em>A.3.3 Implementing Conditional Jumps</em></h4>&#13;
<p class="noindent">Conditional jump instructions <span class="ent">➏</span> implement branches by working in unison with earlier instructions that set status flags, like <span class="literal">cmp</span> or <span class="literal">test</span>. They jump to a specified address or label if the given condition holds or fall through to the next instruction if the condition does not hold. For example, to jump to a program location named <em>label</em> if <span class="literal">rax &lt; rbx</span> (using an unsigned comparison), you typically use an instruction sequence like this:</p>&#13;
<p class="programs">cmp rax, rbx<br/>jb label</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_384"/>Similarly, to jump to <em>label</em> if <span class="literal">rax</span> is not zero, you can use the following:</p>&#13;
<p class="programs">test rax, rax<br/>jnz label</p>&#13;
<h4 class="h4" id="appa_3_4"><em>A.3.4 Loading Memory Addresses</em></h4>&#13;
<p class="noindent">Finally, the <span class="literal">lea</span> instruction <span class="ent">➐</span> (<em>load effective address</em>) computes the address resulting from a memory operand (formatted as <span class="literal">[base + index*scale + displacement]</span>) and stores it in a register but does not dereference the address. This is equivalent to the address-of operator (<span class="literal">&amp;</span>) in C/C++. For example, <span class="literal">lea r12, [rip+0x2000]</span> loads the address resulting from the expression <span class="literal">rip+0x2000</span> into the <span class="literal">r12</span> register.</p>&#13;
<p class="indent">Now that you’re familiar with the most important x86 instructions, let’s see how these instructions come together to implement common C/C<strong>++</strong> code constructs.</p>&#13;
<h3 class="h3" id="appa_4">A.4 Common Code Constructs in Assembly</h3>&#13;
<p class="noindent">Compilers like <span class="literal">gcc</span>, <span class="literal">clang</span>, and Visual Studio emit common code patterns for constructs like function calls, <span class="literal">if</span>/<span class="literal">else</span> branches, and loops. You’ll also see these same code patterns in handwritten assembly code. It helps to be familiar with them so that you can quickly understand what a piece of assembly or disassembled code is doing. Let’s take a look at code patterns emitted by <span class="literal">gcc 5.4.0</span>. Other compilers use similar patterns.</p>&#13;
<p class="indent">The first code construct you’ll see are function calls. But before you can understand how function calls are implemented at the assembly level, you need to be familiar with how <em>the stack</em> works on x86.</p>&#13;
<h4 class="h4" id="appa_4_1"><em>A.4.1 The Stack</em></h4>&#13;
<p class="noindent">The stack is a memory region reserved for storing data related to function calls, such as return addresses, function arguments, and local variables. On most operating systems, each thread has its own stack.</p>&#13;
<p class="indent">The stack gets its name from the way it’s accessed. Rather than writing values at random places in the stack, you do so in a <em>last-in-first-out (LIFO)</em> order. That is, you can write values by <em>pushing</em> them to the top of the stack and remove values by <em>popping</em> them from the top. This makes sense for function calls because it matches the way you invoke and return from functions: the last function you call returns first. <a href="appa.xhtml#appafig3">Figure A-3</a> illustrates the stack access pattern.</p>&#13;
<p class="indent">In <a href="appa.xhtml#appafig3">Figure A-3</a>, the stack starts at address <span class="literal">0x7fffffff8000</span><sup><a id="appafn_1a" href="footnote.xhtml#appafn_1">1</a></sup> and initially contains five values: <em>a</em>–<em>e</em>. The rest of the stack contains uninitialized memory (marked with “?”). On x86, the stack grows toward lower memory addresses, which means that newly pushed values are at lower addresses than older <span epub:type="pagebreak" id="page_385"/>values. The stack pointer register (<span class="literal">rsp</span>) always points to the top of the stack, where the most recently pushed value is. Initially, that’s <em>e</em> at address <span class="literal">0x7fffffff7fe0</span>.</p>&#13;
<div class="image"><a id="appafig3"/><img src="Images/f384-01.jpg" alt="image" width="673" height="323"/></div>&#13;
<p class="fig-caption"><em>Figure A-3: Pushing the value</em> f <em>onto the stack and then popping it into</em> <span class="literal">rax</span></p>&#13;
<p class="indent">Now, when you push a new value <em>f</em>, it ends up at the top of the stack, and <span class="literal">rsp</span> is decremented to point there. There are special instructions on x86 called <span class="literal">push</span> and <span class="literal">pop</span> that insert or remove a value on the stack and automatically update <span class="literal">rsp</span>. Similarly, the x86 <span class="literal">call</span> instruction automatically pushes the return address onto the stack, and <span class="literal">ret</span> pops the return address and returns there.</p>&#13;
<p class="indent">When you execute a <span class="literal">pop</span> instruction, it copies the value at the top of the stack into the <span class="literal">pop</span> operand and then increments <span class="literal">rsp</span> to reflect the new top of the stack. For example, the <span class="literal">pop rax</span> instruction in <a href="appa.xhtml#appafig3">Figure A-3</a> copies <em>f</em> from the stack into <span class="literal">rax</span> and then updates <span class="literal">rsp</span> to point to <em>e</em>, the new top of the stack. You can push an arbitrary number of values onto the stack before popping anything. Of course, this is subject to the available memory reserved for the stack.</p>&#13;
<p class="indent">Note that popping a value from the stack doesn’t clean it up; it merely copies the value and updates <span class="literal">rsp</span>. After the <span class="literal">pop</span>, <em>f</em> is technically still in memory until it’s overwritten by a later <span class="literal">push</span>. It’s important to realize that if you place sensitive information on the stack, it might still be accessible later unless you explicitly clean it up.</p>&#13;
<p class="indent">Now that you know how the stack works, let’s look at how function calls use it to store their arguments, return address, and local variables.</p>&#13;
<h4 class="h4" id="appa_4_2"><em>A.4.2 Function Calls and Function Frames</em></h4>&#13;
<p class="noindent"><a href="appa.xhtml#appalist3">Listing A-3</a> shows a simple C program that contains two function calls, omitting any error-checking code for brevity. First, it calls <span class="literal">getenv</span> to get the value of an environment variable specified in <span class="literal">argv[1]</span>. Then, it prints this value with <span class="literal">printf</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_386"/><a href="appa.xhtml#appalist4">Listing A-4</a> shows the corresponding assembly code, obtained by compiling the C program with <span class="literal">gcc 5.4.0</span> and then disassembling it with <span class="literal">objdump</span>. Note that for this example, I’ve compiled the program with <span class="literal">gcc</span>’s default options, and the output will look different if you enable optimizations or use another compiler.</p>&#13;
<p class="listing1" id="appalist3"><em>Listing A-3: Function calls in C</em></p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>  printf("%s=%s\n",<br/>         argv[1], getenv(argv[1]));<br/>                                <br/>  return 0;<br/>}</p>&#13;
<p class="listing1" id="appalist4"><em>Listing A-4: Function calls in assembly</em></p>&#13;
<p class="programs">   Contents of section .rodata:<br/>    400630 01000200 <span class="ent">➊</span>25733d25 730a00 ....%s=%s..<br/><br/>   Contents of section .text:<br/>   0000000000400566 &lt;main&gt;:<br/><span class="ent">➋</span>   400566:  push    rbp<br/>     400567:  mov     rbp,rsp<br/><span class="ent">➌</span>   40056a:  sub     rsp,0x10<br/><span class="ent">➍</span>   40056e:  mov     DWORD PTR [rbp-0x4],edi<br/>     400571:  mov     QWORD PTR [rbp-0x10],rsi<br/>     400575:  mov     rax,QWORD PTR [rbp-0x10]<br/>     400579:  add     rax,0x8<br/>     40057d:  mov     rax,QWORD PTR [rax]<br/><span class="ent">➎</span>   400580:  mov     rdi,rax<br/><span class="ent">➏</span>   400583:  call    400430 &lt;getenv@plt&gt;<br/><span class="ent">➐</span>   400588:  mov     rdx,rax<br/>     40058b:  mov     rax,QWORD PTR [rbp-0x10]<br/>     40058f:  add     rax,0x8<br/>     400593:  mov     rax,QWORD PTR [rax]<br/><span class="ent">➑</span>   400596:  mov     rsi,rax<br/>     400599:  mov     edi,0x400634<br/>     40059e:  mov     eax,0x0<br/><span class="ent">➒</span>   4005a3:  call    400440 &lt;printf@plt&gt;<br/><span class="ent">➓</span>   4005a8:  mov     eax,0x0<br/>     4005ad:  leave<br/>     4005ae:  ret</p>&#13;
<p class="indent">The compiler stores the string constant <span class="literal">%s=%s</span> used in the <span class="literal">printf</span> call separately from the code, in the <span class="literal">.rodata</span> (read-only data) section <span class="ent">➊</span> at address <span class="literal">0x400634</span>. You’ll see this address used later in the code as a <span class="literal">printf</span> argument.</p>&#13;
<p class="indent">In principle, each function in an x86 Linux program has its own <em>function frame</em> (also called <em>stack frame</em>) on the stack, delimited by <span class="literal">rbp</span> (the base pointer) pointing to the base of that function frame and <span class="literal">rsp</span> pointing to the top. Function frames are used to store the function’s stack-based data. Note that with certain optimizations, compilers may omit the base pointer (making all stack accesses relative to <span class="literal">rsp</span>) and use <span class="literal">rbp</span> as an extra general-purpose register. However, the following example assumes that all functions use full function frames.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_387"/><a href="appa.xhtml#appafig4">Figure A-4</a> shows the function frames created for <span class="literal">main</span> and <span class="literal">getenv</span> when you run the program shown in <a href="appa.xhtml#appalist4">Listing A-4</a>. To understand how this works, let’s go over the assembly listing and see how it produces the function frames shown in the figure.</p>&#13;
<div class="image"><a id="appafig4"/><img src="Images/f386-01.jpg" alt="image" width="687" height="403"/></div>&#13;
<p class="fig-caption"><em>Figure A-4: Example of x86 function frames on a Linux system</em></p>&#13;
<p class="indent">As explained in <a href="ch02.xhtml#ch02">Chapter 2</a>, <span class="literal">main</span> isn’t really the first function that runs in a typical Linux program. For now, all you need to know is that <span class="literal">main</span> is invoked by a <span class="literal">call</span> instruction that places a return address on the stack where <span class="literal">main</span> returns when it’s done (shown at the top left of <a href="appa.xhtml#appafig4">Figure A-4</a>).</p>&#13;
<h5 class="h5">Function Prologues, Local Variables, and Reading Arguments</h5>&#13;
<p class="noindent">The first thing <span class="literal">main</span> does is run a <em>prologue</em> that sets up its function frame. This prologue starts by saving the contents of the <span class="literal">rbp</span> register on the stack and then copying <span class="literal">rsp</span> into <span class="literal">rbp</span> <span class="ent">➋</span> (see <a href="appa.xhtml#appalist4">Listing A-4</a>). This has the effect of saving the start address of the previous function frame and creating a fresh function frame at the top of the stack. Because the instruction sequence <span class="literal">push rbp; mov rbp,rsp</span> is so common, x86 has a shorthand instruction called <span class="literal">enter</span> (not used in <a href="appa.xhtml#appalist4">Listing A-4</a>) that does the same thing.</p>&#13;
<p class="indent">On x86-64 Linux, the registers <span class="literal">rbx</span> and <span class="literal">r12</span>–<span class="literal">r15</span> are guaranteed not to be polluted by any functions you call. That means that if a function does pollute these registers, it must take care to restore them to their original values before returning. Typically, functions achieve that by pushing any registers that need to be saved onto the stack just after the saved base pointer and popping them back off just before returning. In <a href="appa.xhtml#appalist4">Listing A-4</a>, <span class="literal">main</span> doesn’t do this because it doesn’t use any of the registers in question.</p>&#13;
<p class="indent">After setting up a basic function frame, <span class="literal">main</span> decrements <span class="literal">rsp</span> by <span class="literal">0x10</span> bytes to reserve room for two 8-byte local variables on the stack <span class="ent">➌</span>. Even though the C version of the program doesn’t explicitly reserve any local variables, <span class="literal">gcc</span> generated them automatically to serve as temporary storage for <span class="literal">argc</span> <span epub:type="pagebreak" id="page_388"/>and <span class="literal">argv</span>. On x86-64 Linux systems, the first six arguments to a function are passed in <span class="literal">rdi</span>, <span class="literal">rsi</span>, <span class="literal">rdx</span>, <span class="literal">rcx</span>, <span class="literal">r8</span>, and <span class="literal">r9</span>, respectively.<sup><a id="appafn_2a" href="footnote.xhtml#appafn_2">2</a></sup> If there are more than six arguments or some arguments don’t fit in a 64-bit register, the remaining arguments are pushed onto the stack in reverse order (compared to the order they appear in the argument list), as follows:</p>&#13;
<p class="programs">mov rdi, param1<br/>mov rsi, param2<br/>mov rdx, param3<br/>mov rcx, param4<br/>mov r8, param5<br/>mov r9, param6<br/>push param9<br/>push param8<br/>push param7</p>&#13;
<p class="indent">Note that some popular 32-bit x86 calling conventions (such as cdecl) pass all arguments on the stack in reverse order (without using any registers), while other calling conventions (such as fastcall) pass some arguments in registers.</p>&#13;
<p class="indent">After reserving room on the stack, <span class="literal">main</span> copies <span class="literal">argc</span> (stored in <span class="literal">rdi</span>) into one of the local variables and <span class="literal">argv</span> (stored in <span class="literal">rsi</span>) into the other <span class="ent">➍</span>. The left side of <a href="appa.xhtml#appafig4">Figure A-4</a> shows the layout of the stack after <span class="literal">main</span>’s prologue is done.</p>&#13;
<h5 class="h5">The Red Zone</h5>&#13;
<p class="noindent">You may notice the 128-byte “red zone” at the top of the stack in <a href="appa.xhtml#appafig4">Figure A-4</a>. On x86-64, functions are allowed to use the red zone as scratch space with the guarantee that the operating system won’t touch it (for instance, if a signal handler needs to set up a new function frame). Subsequently called functions do overwrite the red zone as part of their own function frame, so the red zone is most useful for so-called <em>leaf functions</em> that don’t call any other functions. As long as leaf functions don’t use more than 128 bytes of stack space, the red zone frees these functions from having to explicitly set up a function frame, thereby reducing execution time. On 32-bit x86, there’s no concept of a red zone.</p>&#13;
<h5 class="h5">Preparing Arguments and Calling a Function</h5>&#13;
<p class="noindent">After the prologue, <span class="literal">main</span> loads <span class="literal">argv[1]</span> into <span class="literal">rax</span> by first loading the address of <span class="literal">argv[0]</span> and then adding 8 bytes (the size of a pointer) and dereferencing the resulting pointer to <span class="literal">argv[1]</span>. It copies this pointer into <span class="literal">rdi</span> to serve as the argument for <span class="literal">getenv</span> <span class="ent">➎</span> and then calls <span class="literal">getenv</span> <span class="ent">➏</span> (see <a href="appa.xhtml#appalist4">Listing A-4</a>). The <span class="literal">call</span> instruction automatically pushes the return address (the address of the instruction right after the <span class="literal">call</span>) onto the stack, where <span class="literal">getenv</span> can find it when it returns. I won’t go into details on <span class="literal">getenv</span>’s code here since it’s a library function. Let’s simply assume that it sets up a standard function <span epub:type="pagebreak" id="page_389"/>frame by saving <span class="literal">rbp</span>, possibly saving some registers and reserving room for local variables. The center part of <a href="appa.xhtml#appafig4">Figure A-4</a> shows the stack layout after <span class="literal">getenv</span> is called and has completed its prologue, assuming that it didn’t push any registers to save.</p>&#13;
<p class="indent">After <span class="literal">getenv</span> completes, it saves its return value in <span class="literal">rax</span> (the standard register designated for that purpose) and then cleans up its local variables from the stack by incrementing <span class="literal">rsp</span>. It then pops the saved base pointer from the stack into <span class="literal">rbp</span>, restoring <span class="literal">main</span>’s function frame. At this point, the top of the stack is the saved return address, which is <span class="literal">0x400588</span> in <span class="literal">main</span> in this case. Finally, <span class="literal">getenv</span> executes a <span class="literal">ret</span> instruction that pops the return address from the stack and returns there, restoring control to <span class="literal">main</span>. The right side of <a href="appa.xhtml#appafig4">Figure A-4</a> shows the stack layout just after <span class="literal">getenv</span> returns.</p>&#13;
<h5 class="h5">Reading Return Values</h5>&#13;
<p class="noindent">The <span class="literal">main</span> function copies the return value (a pointer to the requested environment string) into <span class="literal">rdx</span> to serve as the third argument of the <span class="literal">printf</span> call <span class="ent">➐</span>. Next, <span class="literal">main</span> loads <span class="literal">argv[1]</span> again in the same way as before and stores it in <span class="literal">rsi</span> as the second argument for <span class="literal">printf</span> <span class="ent">➑</span>. The first argument (in <span class="literal">rdi</span>) is the address <span class="literal">0x400634</span> of the format string <span class="literal">%s=%s</span> in the <span class="literal">.rodata</span> section you saw earlier.</p>&#13;
<p class="indent">Note that unlike the call to <span class="literal">getenv</span>, <span class="literal">main</span> sets <span class="literal">rax</span> to zero before calling <span class="literal">printf</span>. That’s because <span class="literal">printf</span> is a variadic function, which assumes that <span class="literal">rax</span> specifies the number of floating-point arguments passed in via vector registers (in this case there are none). After preparing the arguments, <span class="literal">main</span> calls <span class="literal">printf</span> <span class="ent">➒</span>, pushing the return address for <span class="literal">printf</span>.</p>&#13;
<h5 class="h5">Returning from a Function</h5>&#13;
<p class="noindent">After <span class="literal">printf</span> completes, <span class="literal">main</span> prepares its own return value (the exit status) by zeroing out the <span class="literal">rax</span> register <span class="ent">➓</span>. Then, it executes a <span class="literal">leave</span> instruction, which is x86’s shorthand instruction for <span class="literal">mov rsp,rbp; pop rbp</span>. This is a standard function epilogue that does the opposite of the prologue. It cleans up the function frame by pointing <span class="literal">rsp</span> to the frame base (where the saved <span class="literal">rbp</span> is) and restoring the previous frame’s <span class="literal">rbp</span>. Finally, <span class="literal">main</span> executes a <span class="literal">ret</span> instruction, which pops the saved return address from the top of the stack and returns there, ending <span class="literal">main</span> and passing control back to whatever function called <span class="literal">main</span>.</p>&#13;
<h4 class="h4" id="appa_4_3"><em>A.4.3 Conditional Branches</em></h4>&#13;
<p class="noindent">Next, let’s take a look at another important construct: conditional branches. <a href="appa.xhtml#appalist5">Listing A-5</a> shows a C program containing an <span class="literal">if</span>/<span class="literal">else</span> branch that prints the message <span class="literal">argc &gt; 5</span> if <span class="literal">argc</span> is greater than 5 or the message <span class="literal">argc &lt;= 5</span> otherwise. <a href="appa.xhtml#appalist6">Listing A-6</a> shows the corresponding assembly-level implementation produced by <span class="literal">gcc 5.4.0</span> with default options, as recovered from the binary with <span class="literal">objdump</span>.</p>&#13;
<p class="listing1" id="appalist5"><span epub:type="pagebreak" id="page_390"/><em>Listing A-5: A conditional branch in C</em></p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>  if(argc &gt; 5) {<br/>    printf("argc &gt; 5\n");<br/>  } else {<br/>    printf("argc &lt;= 5\n");<br/>  }<br/><br/>  return 0;<br/>}</p>&#13;
<p class="listing1" id="appalist6"><em>Listing A-6: A conditional branch in assembly</em></p>&#13;
<p class="programs">  Contents of section .rodata:<br/>   4005e0 01000200 <span class="ent">➊</span>61726763 ....argc<br/>   4005e8 203e2035 00<span class="ent">➋</span>617267  &gt; 5.arg<br/>   4005f0 63203c3d 203500    c &lt;= 5.<br/>   <br/>  Contents of section .text:<br/>  0000000000400526 &lt;main&gt;:<br/>    400526:  push   rbp<br/>    400527:  mov    rbp,rsp<br/>    40052a:  sub    rsp,0x10<br/>    40052e:  mov    DWORD PTR [rbp-0x4],edi<br/>    400531:  mov    QWORD PTR [rbp-0x10],rsi<br/><span class="ent">➌</span>  400535:  cmp     DWORD PTR [rbp-0x4],0x5<br/><span class="ent">➍</span>  400539:  jle     400547 &lt;main+0x21&gt;<br/>    40053b:  mov    edi,0x4005e4<br/>    400540:  call   400400 &lt;puts@plt&gt;<br/><span class="ent">➎</span>  400545:  jmp     400551 &lt;main+0x2b&gt;<br/>    400547:  mov    edi,0x4005ed<br/>    40054c:  call   400400 &lt;puts@plt&gt;<br/>    400551:  mov    eax,0x0<br/>    400556:  leave<br/>    400557:  ret</p>&#13;
<p class="indent">Just like you saw in <a href="appa.xhtml#appa_4_2">Section A.4.2</a>, the compiler stored the <span class="literal">printf</span> format strings in the <span class="literal">.rodata</span> section <span class="ent">➊</span><span class="ent">➋</span>, away from the code, which is in the <span class="literal">.text</span> section. The <span class="literal">main</span> function starts with a prologue and copies <span class="literal">argc</span> and <span class="literal">argv</span> into local variables.</p>&#13;
<p class="indent">The conditional branch implementation starts with the <span class="literal">cmp</span> instruction at <span class="ent">➌</span>, which compares the local variable containing <span class="literal">argc</span> to the immediate value <span class="literal">0x5</span>. It’s followed by a <span class="literal">jle</span> instruction that jumps to address <span class="literal">0x400547</span> if <span class="literal">argc</span> is less than or equal to <span class="literal">0x5</span> <span class="ent">➍</span> (the <span class="literal">else</span> branch). At that address, there’s a call to <span class="literal">puts</span> that prints the string <span class="literal">argc &lt;= 5</span>, followed by <span class="literal">main</span>’s epilogue and <span class="literal">ret</span> instruction.</p>&#13;
<p class="indent">If <span class="literal">argc</span> is greater than <span class="literal">0x5</span>, the <span class="literal">jle</span> is not taken but falls through to the next instruction sequence at address <span class="literal">0x40053b</span> (the <span class="literal">if</span> branch). It calls <span class="literal">puts</span> to print the string <span class="literal">argc &gt; 5</span> and then jumps to <span class="literal">main</span>’s epilogue at address <span class="literal">0x400551</span> <span class="ent">➎</span>. Note that this last <span class="literal">jmp</span> is necessary to jump over the code for the <span class="literal">else</span> branch at address <span class="literal">0x400547</span>.</p>&#13;
<h4 class="h4" id="appa_4_4"><em>A.4.4 Loops</em></h4>&#13;
<p class="noindent">At the assembly level, you can think of loops as special cases of conditional branches. Just like regular branches, loops are implemented with <span class="literal">cmp</span>/<span class="literal">test</span> and conditional jump instructions. <a href="appa.xhtml#appalist7">Listing A-7</a> shows a <span class="literal">while</span> loop in C that <span epub:type="pagebreak" id="page_391"/>loops over all given command line arguments and prints them in reverse order. <a href="appa.xhtml#appalist8">Listing A-8</a> shows a corresponding assembly program.</p>&#13;
<p class="listing1" id="appalist7"><em>Listing A-7: A</em> <span class="codeitalic">while</span> <em>loop in C</em></p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>                      <br/>int                    <br/>main(int argc, char *argv[])<br/>{                          <br/>  while(argc &gt; 0) {<br/>    printf("%s\n",    <br/>           argv[(unsigned)--argc]);<br/>  }                                <br/>                              <br/>  return 0;                  <br/>}                              </p>&#13;
<p class="listing1" id="appalist8"><em>Listing A-8: A</em> <span class="codeitalic">while</span> <em>loop in assembly</em></p>&#13;
<p class="programs">   0000000000400526 &lt;main&gt;:<br/>     400526:  push   rbp<br/>     400527:  mov    rbp,rsp<br/>     40052a:  sub    rsp,0x10<br/>     40052e:  mov    DWORD PTR [rbp-0x4],edi<br/>     400531:  mov    QWORD PTR [rbp-0x10],rsi<br/><span class="ent">➊</span>   400535:  jmp    40055a &lt;main+0x34&gt;<br/>     400537:  sub    DWORD PTR [rbp-0x4],0x1<br/>     40053b:  mov    eax,DWORD PTR [rbp-0x4]<br/>     40053e:  mov    eax,eax<br/>     400540:  lea    rdx,[rax*8+0x0]<br/>     400548:  mov    rax,QWORD PTR [rbp-0x10]<br/>     40054c:  add    rax,rdx<br/>     40054f:  mov    rax,QWORD PTR [rax]<br/>     400552:  mov    rdi,rax<br/>     400555:  call   400400 &lt;puts@plt&gt;<br/><span class="ent">➋</span>   40055a:  cmp    DWORD PTR [rbp-0x4],0x0<br/><span class="ent">➌</span>   40055e:  jg     400537 &lt;main+0x11&gt;<br/>     400560:  mov    eax,0x0<br/>     400565:  leave<br/>     400566:  ret</p>&#13;
<p class="indent">In this case, the compiler chose to place the code that checks the loop condition at the end of the loop. So, the loop begins by jumping to address <span class="literal">0x40055a</span> where the loop condition is checked <span class="ent">➊</span>.</p>&#13;
<p class="indent">This check is implemented with a <span class="literal">cmp</span> instruction that compares <span class="literal">argc</span> to the value zero <span class="ent">➋</span>. If <span class="literal">argc</span> is greater than zero, the code jumps to address <span class="literal">0x400537</span> where the loop body begins <span class="ent">➌</span>. The loop body decrements <span class="literal">argc</span>, prints the next string from <span class="literal">argv</span>, and then ends up at the loop condition check again.</p>&#13;
<p class="indent">The loop continues until <span class="literal">argc</span> is zero, at which point the <span class="literal">jg</span> instruction in the loop condition check falls through into <span class="literal">main</span>’s epilogue, where <span class="literal">main</span> cleans up its stack frame and returns.</p>&#13;
</div></body></html>