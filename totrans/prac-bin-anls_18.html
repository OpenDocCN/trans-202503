<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="appa"><span epub:type="pagebreak" id="page_374"/><span class="big">A</span><br/>A CRASH COURSE ON X86 ASSEMBLY</h2>&#13;
<p class="startpara">Because assembly language is the standard representation of the machine instructions you’ll find in binaries, many binary analyses are based on disassembly. Therefore, it’s important that you’re familiar with the basics of x86 assembly language to get the most out of this book. This appendix introduces you to the essentials that you need to know to follow along.</p>&#13;
<p class="indent">The purpose of this appendix is not to teach you how to write assembly programs (there are books dedicated to that subject) but to show you the essentials you need to know to understand disassembled programs. You’ll learn how assembly programs and x86 instructions are structured and how they behave at runtime. Moreover, you’ll see how common code constructs from C/C++ programs are represented at the assembly level. I’ll only cover basic 64-bit user-mode x86 instructions, not floating-point instructions or extended instruction sets like SSE or MMX. For brevity, I’ll refer to the 64-bit variant of x86 (x86-64 or x64) simply as x86, since that’s the focus of this book.</p>&#13;
<h3 class="h3" id="appa_1"><span epub:type="pagebreak" id="page_375"/>A.1 Layout of an Assembly Program</h3>&#13;
<p class="noindent"><a href="appa.xhtml#appalist1">Listing A-1</a> shows a simple C program, and <a href="appa.xhtml#appalist2">Listing A-2</a> shows the corresponding assembly program produced by <code>gcc</code> 5.4.0. (<a href="ch01.xhtml#ch01">Chapter 1</a> explains how compilers transform C programs into assembly listings and eventually into binaries.)</p>&#13;
<p class="indent">When you disassemble a binary, the disassembler essentially tries to translate it back into an accurate assembly listing resembling the compiler-generated assembly as closely as possible. For now, let’s take a look at the <em>layout</em> of the assembly program without going into details on the assembly instructions yet.</p>&#13;
<p class="listing1" id="appalist1"><em>Listing A-1: “Hello, world!” in C</em></p>&#13;
<pre>  #include &lt;stdio.h&gt;<br/><br/>  int<br/><span class="ent">➊</span> main(int argc, char *argv[])<br/>  {<br/>     <span class="ent">➋</span>printf(<span class="ent">➌</span>"Hello, world!\n");<br/><br/>     return 0;<br/>  }</pre>&#13;
<p class="listing1" id="appalist2"><em>Listing A-2: Assembly generated by</em> <span class="codeitalic">gcc</span></p>&#13;
<pre>      .file "hello.c"<br/>      .intel_syntax noprefix<br/><span class="ent">➍</span>    .section .rodata<br/>  .LC0:<br/><span class="ent">➎</span>    .string "Hello, world!"<br/><span class="ent">➏</span>    .text<br/>     .globl  main<br/>     .type   main, @function<br/><span class="ent">➐</span> main<br/>      push    rbp<br/>      mov     rbp, rsp<br/>      sub     rsp, 16<br/>      mov     DWORD PTR [rbp-4], edi<br/>      mov     QWORD PTR [rbp-16], rsi<br/><span class="ent">➑</span>    mov     edi, OFFSET FLAT:.LC0<br/><span class="ent">➒</span>    call    puts<br/>      mov     eax, 0<br/>      leave<br/>      ret<br/>      .size    main, .-main<br/>      .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9)"<br/>      .section .note.GNU-stack,"",@progbits</pre>&#13;
<p class="indent"><a href="appa.xhtml#appalist1">Listing A-1</a> consists of a <code>main</code> function <span class="ent">➊</span> that calls <code>printf</code> <span class="ent">➋</span> to print a constant <code>"Hello, world!"</code> string <span class="ent">➌</span>. At a high level, the corresponding assembly program consists of four types of components: instructions, directives, labels, and comments.</p>&#13;
<h4 class="h4" id="appa_1_1"><em>A.1.1 Assembly Instructions, Directives, Labels, and Comments</em></h4>&#13;
<p class="noindent"><a href="appa.xhtml#appatab1">Table A-1</a> shows examples of each component type. Note that the exact syntax for each component varies per assembler or disassembler. For the purposes of this book, you won’t need to be intimately familiar with any assembler’s syntactical quirks; you’ll only need to learn to read and analyze <span epub:type="pagebreak" id="page_376"/>disassembled code, not write your own assembly code. Here, I’ll stick to the assembly syntax produced by <code>gcc</code> with the <code>-masm=intel</code> option.</p>&#13;
<p class="tab-caption" id="appatab1"><strong>Table A-1:</strong> Components of an Assembly Program</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Type</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Example</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Meaning</strong></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>Instruction</td>&#13;
<td><code>mov eax, 0</code></td>&#13;
<td>Move zero into <code>eax</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Directive</td>&#13;
<td><code>.section .text</code></td>&#13;
<td>Place the following content into the <code>.text</code> section</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Directive</td>&#13;
<td><code>.string "foobar"</code></td>&#13;
<td>Define an ASCII string containing <code>"foobar"</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Directive</td>&#13;
<td><code>.long 0x12345678</code></td>&#13;
<td>Define a doubleword with value <code>0x12345678</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Label</td>&#13;
<td><code>foo: .string "foobar"</code></td>&#13;
<td>Define the <code>"foobar"</code> string with symbolic name <code>foo</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;">Comment</td>&#13;
<td style="border-bottom: solid 0.2em;"><code># this is a comment</code></td>&#13;
<td style="border-bottom: solid 0.2em;">A human-readable comment</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><em>Instructions</em> are the actual operations that the CPU executes. <em>Directives</em> are commands that tell the assembler to produce a particular piece of data, place instructions or data in a particular section, and so on. Finally, <em>labels</em> are symbolic names that you can use to refer to instructions or data in the assembly program, and <em>comments</em> are human-readable strings for documentation purposes. After the program is assembled and linked into a binary, all symbolic names are replaced by addresses.</p>&#13;
<p class="indent">The assembly program in <a href="appa.xhtml#appalist2">Listing A-2</a> directs the assembler to place the <code>"Hello, world!"</code> string in the <code>.rodata</code> section <span class="ent">➍</span><span class="ent">➎</span>, which is a section dedicated to storing constant data. The directive <code>.section</code> tells the assembler in which section to place the following content, while <code>.string</code> is a directive that allows you to define an ASCII string. There are also directives to define other types of data, such as <code>.byte</code> (define a byte), <code>.word</code> (a 2-byte word), <code>.long</code> (a 4-byte doubleword), and <code>.quad</code> (an 8-byte quadword).</p>&#13;
<p class="indent">The <code>main</code> function is placed in the <code>.text</code> section <span class="ent">➏</span><span class="ent">➐</span>, dedicated to storing code. The <code>.text</code> directive is shorthand for <code>.section .text</code>, and <code>main:</code> introduces a symbolic label for the <code>main</code> function.</p>&#13;
<p class="indent">The label is followed by the actual instructions that <code>main</code> contains. These instructions can refer symbolically to previously declared data, such as <code>.LC0</code> <span class="ent">➑</span> (the symbolic name <code>gcc</code> chose for the <code>"Hello, world!"</code> string). Because the program prints a constant string (without variadic arguments), <code>gcc</code> replaces the <code>printf</code> call with a call to <code>puts</code> <span class="ent">➒</span>, a simpler function that prints a given string to screen.</p>&#13;
<h4 class="h4" id="appa_1_2"><em>A.1.2 Separation Between Code and Data</em></h4>&#13;
<p class="noindent">One key observation you can make in <a href="appa.xhtml#appalist2">Listing A-2</a> is that compilers usually separate code and data into different sections. That’s convenient when you’re disassembling or analyzing a binary because you know which bytes in the program to interpret as code and which to interpret as data. However, there’s nothing inherent in the x86 architecture preventing you from mixing code and data in the same section, and in practice, some compilers or handwritten assembly programs do exactly that.</p>&#13;
<h4 class="h4" id="appa_1_3"><em>A.1.3 <span epub:type="pagebreak" id="page_377"/>AT&amp;T vs. Intel Syntax</em></h4>&#13;
<p class="noindent">As mentioned, different assemblers use different syntaxes for assembly programs. On top of that, there are two different syntax formats in use to represent x86 machine instructions: <em>Intel syntax</em> and <em>AT&amp;T syntax</em>.</p>&#13;
<p class="indent">AT&amp;T syntax explicitly prefixes every register name with the <code>%</code> symbol and every constant with a <code>$</code> symbol, while Intel syntax omits these symbols. In this book, I use Intel syntax because it’s less verbose. The most crucial difference between AT&amp;T and Intel is that they order instruction operands in exactly opposite ways. In AT&amp;T syntax, the source operand comes before the destination so that moving a constant into the <code>edi</code> register looks like this:</p>&#13;
<pre>mov    $0x6,%edi</pre>&#13;
<p class="indent">In contrast, Intel syntax represents the same instruction as follows, with the destination operand first:</p>&#13;
<pre>mov    edi,0x6</pre>&#13;
<p class="indent">It’s important to keep the operand ordering in mind because you’ll probably encounter both syntax styles as you delve further into binary analysis.</p>&#13;
<h3 class="h3" id="appa_2">A.2 Structure of an x86 Instruction</h3>&#13;
<p class="noindent">Now that you have an idea of how assembly programs are structured, let’s take a look at the format of assembly instructions. You’ll also see the structure of the machine-level instructions that the assembly represents.</p>&#13;
<h4 class="h4" id="appa_2_1"><em>A.2.1 Assembly-Level Representation of x86 Instructions</em></h4>&#13;
<p class="noindent">At the assembly level, x86 instructions generally have the form <code>mnemonic destination, source</code>. The mnemonic is a human-readable representation of a machine instruction, and source and destination are the operands of the instruction. For example, the assembly instruction <code>mov rbx, rax</code> copies the value from the <code>rax</code> register into <code>rbx</code>. Note that not all instructions have exactly two operands; some even have no operands at all, as you’ll see shortly.</p>&#13;
<p class="indent">As mentioned, mnemonics are higher-level representations of the machine instructions the CPU understands. Let’s take a brief look at how x86 instructions are structured at the machine level. That’s useful to know in some binary analysis situations, such as when you’re modifying an existing binary.</p>&#13;
<h4 class="h4" id="appa_2_2"><em>A.2.2 Machine-Level Structure of x86 Instructions</em></h4>&#13;
<p class="noindent">The x86 ISA uses variable-length instructions; there are x86 instructions that consist of only 1 byte, but also multibyte instructions, ranging up to a <span epub:type="pagebreak" id="page_378"/>maximum instruction length of 15 bytes. Moreover, instructions can start at any memory address. This means that the CPU doesn’t enforce any particular code alignment, although compilers often do align code to optimize the performance of fetching instructions from memory. <a href="appa.xhtml#appafig1">Figure A-1</a> shows the machine-level structure of an x86 instruction.</p>&#13;
<div class="image"><a id="appafig1"/><img src="Images/f377-01.jpg" alt="image" width="688" height="153"/></div>&#13;
<p class="fig-caption"><em>Figure A-1: Structure of an x86 instruction</em></p>&#13;
<p class="indent">An x86 instruction consists of optional prefixes, an opcode, and zero or more operands. Note that all parts except for the opcode are optional.</p>&#13;
<p class="indent">The opcode is the main designator for the instruction type. For instance, the opcode <code>0x90</code> encodes a <code>nop</code> instruction, which does nothing, while the opcodes <code>0x00</code>–<code>0x05</code> encode various types of <code>add</code> instructions. Prefixes can modify the behavior of an instruction, for example, causing it to repeat multiple times or access a different memory segment. Finally, the operands are the data that the instruction operates on.</p>&#13;
<p class="indent">The <em>addressing mode</em> byte, also known as the <em>MOD-R/M</em> or <em>MOD-REGR/M</em> byte, contains metadata about the instruction’s operand types. The <em>SIB (scale/index/base)</em> bytes and the <em>displacement</em> are used to encode memory operands, and the <em>immediate</em> field can contain an immediate operand (a constant numeric value). You’ll see what these fields mean in more detail shortly.</p>&#13;
<p class="indent">In addition to the <em>explicit operands</em> shown in <a href="appa.xhtml#appafig1">Figure A-1</a>, some instructions have <em>implicit operands</em>. These aren’t explicitly encoded in the instruction but are innate to the opcode. For example, the destination operand of opcode <code>0x05</code> (an <code>add</code> instruction) is always <code>rax</code>, and only the source operand is variable and needs to be explicitly encoded. As another example, the <code>push</code> instruction implicitly updates <code>rsp</code> (the stack pointer register).</p>&#13;
<p class="indent">On x86, instructions can have three different types of operands: register operands, memory operands, and immediates. Let’s take a look at each of the valid operand types.</p>&#13;
<h4 class="h4" id="appa_2_3"><em>A.2.3 Register Operands</em></h4>&#13;
<p class="noindent"><em>Registers</em> are small, quickly accessible pieces of storage located on the CPU itself. Some registers have a special purpose, such as the instruction pointer that tracks the current execution address or the stack pointer that tracks the top of the stack. Others are general-purpose storage units for variables used by whatever program the CPU is executing.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_379"/>General-Purpose Registers</h5>&#13;
<p class="noindent">In the original 8086 instruction set on which x86 is based, registers were 16 bits wide. The 32-bit x86 ISA extended these registers to 32 bits, and x86-64 extended them further to 64 bits. To retain backward compatibility, the registers used in the newer instruction sets are a superset of the older registers.</p>&#13;
<p class="indent">To specify a register operand in assembly, you use the register’s name. For example, <code>mov rax,64</code> moves the value 64 into the <code>rax</code> register. <a href="appa.xhtml#appafig2">Figure A-2</a> shows how the 64-bit <code>rax</code> register is subdivided into legacy 32-bit and 16-bit registers. The lower 32 bits of <code>rax</code> form a register named <code>eax</code>, and the lower 16 bits of that form the original 8086 register <code>ax</code>. You can access the lower byte in <code>ax</code> through the register name <code>al</code> and the higher byte through <code>ah</code>.</p>&#13;
<div class="image"><a id="appafig2"/><img src="Images/f378-01.jpg" alt="image" width="374" height="165"/></div>&#13;
<p class="fig-caption"><em>Figure A-2: Subdivision of the x86-64</em> <code>rax</code> <em>register</em></p>&#13;
<p class="indent">Other registers have similar naming schemes. <a href="appa.xhtml#appatab2">Table A-2</a> shows the names of the general-purpose registers available on x86-64, as well as the available legacy “subregisters.” The <code>r8</code>–<code>r15</code> registers were added in x86-64 and aren’t available in earlier x86 variants. Note that if you set a 32-bit subregister like <code>eax</code>, this automatically zeros out the other bits in the parent register (in this case, <code>rax</code>); setting smaller subregisters like <code>ax</code>, <code>al</code>, and <code>ah</code> retains the other bits.</p>&#13;
<p class="tab-caption" id="appatab2"><strong>Table A-2:</strong> x86 General-Purpose Registers</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Description</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>64-bit</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Lower 32 bits</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Lower 16 bits</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Lower byte</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>2nd byte</strong></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>Accumulator</td>&#13;
<td><code>rax</code></td>&#13;
<td><code>eax</code></td>&#13;
<td><code>ax</code></td>&#13;
<td><code>al</code></td>&#13;
<td><code>ah</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Base</td>&#13;
<td><code>rbx</code></td>&#13;
<td><code>ebx</code></td>&#13;
<td><code>bx</code></td>&#13;
<td><code>bl</code></td>&#13;
<td><code>bh</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Counter</td>&#13;
<td><code>rcx</code></td>&#13;
<td><code>ecx</code></td>&#13;
<td><code>cx</code></td>&#13;
<td><code>cl</code></td>&#13;
<td><code>ch</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td>Data</td>&#13;
<td><code>rdx</code></td>&#13;
<td><code>edx</code></td>&#13;
<td><code>dx</code></td>&#13;
<td><code>dl</code></td>&#13;
<td><code>dh</code></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>Stack</td>&#13;
<td><code>pointer</code></td>&#13;
<td><code>rsp</code></td>&#13;
<td><code>esp</code></td>&#13;
<td><code>sp</code></td>&#13;
<td><code>spl</code></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>Base</td>&#13;
<td><code>pointer</code></td>&#13;
<td><code>rbp</code></td>&#13;
<td><code>ebp</code></td>&#13;
<td><code>bp</code></td>&#13;
<td><code>bpl</code></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>Source index</td>&#13;
<td><code>rsi</code></td>&#13;
<td><code>esi</code></td>&#13;
<td><code>si</code></td>&#13;
<td><code>sil</code></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td>Destination index</td>&#13;
<td><code>rdi</code></td>&#13;
<td><code>edi</code></td>&#13;
<td><code>di</code></td>&#13;
<td><code>dil</code></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;">x86-64 GP registers</td>&#13;
<td style="border-bottom: solid 0.2em;"><code>r8–r15</code></td>&#13;
<td style="border-bottom: solid 0.2em;"><code>r8d–r15d</code></td>&#13;
<td style="border-bottom: solid 0.2em;"><code>r8w–r15w</code></td>&#13;
<td style="border-bottom: solid 0.2em;"><code>r8l–r15l</code></td>&#13;
<td style="border-bottom: solid 0.2em;"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Don’t put too much weight on the description column for most registers. Those descriptions stem from the 8086 instruction set, but nowadays most of the registers shown in <a href="appa.xhtml#appatab2">Table A-2</a> are simply used interchangeably. As <span epub:type="pagebreak" id="page_380"/>you can see in <a href="appa.xhtml#appa_4_1">Section A.4.1</a>, the stack pointer (<code>rsp</code>) and base pointer (<code>rbp</code>) are considered special because they’re used to track the layout of the stack, even though you can in principle use them as general-purpose registers.</p>&#13;
<h5 class="h5">Other Registers</h5>&#13;
<p class="noindent">In addition to the registers shown in <a href="appa.xhtml#appatab2">Table A-2</a>, x86 CPUs contain other registers that aren’t general purpose. The two most important are <code>rip</code> (called <code>eip</code> on 32-bit x86 and <code>ip</code> on 8086) and <code>rflags</code> (called <code>eflags</code> or <code>flags</code> in older ISAs). The instruction pointer always points to the next instruction address and is automatically set by the CPU; you can’t manually write it. On x86-64 you can read the value of the instruction pointer, but on 32-bit x86 you can’t even do that. The status flags register is used for comparisons and conditional branches and tracks things like whether the last operation yielded zero, resulted in an overflow, and so on.</p>&#13;
<p class="indent">The x86 ISA also has <em>segment registers</em> named <code>cs</code>, <code>ds</code>, <code>ss</code>, <code>es</code>, <code>fs</code>, and <code>gs</code> that you can use to divide memory into different segments. Segmentation has largely fallen into disuse, and x86-64 has mostly dropped support for it, so I won’t go into details on segmentation here. If you’re interested in learning more, a dedicated book on x86 assembly should cover this topic.</p>&#13;
<p class="indent">There are also <em>control registers</em> such as <code>cr0</code>–<code>cr10</code> that the kernel uses to control the CPU’s behavior, for instance, to switch between protected mode and real mode. Additionally, registers <code>dr0</code>–<code>dr7</code> are <em>debug registers</em> that provide hardware support for debugging features such as breakpoints. On x86, control and debug registers are not accessible from user mode; only the kernel can access them. Therefore, I won’t cover these registers further in this appendix.</p>&#13;
<p class="indent">There are also various <em>model-specific registers (MSRs)</em> and registers used in extended instruction sets like SSE and MMX that aren’t present on all x86 CPUs. You can use the <code>cpuid</code> instruction to find out which features the CPU supports and use the <code>rdmsr</code> and <code>wrmsr</code> instructions to read or write model-specific registers. Because many of these special registers are available only from the kernel, you won’t have to deal with them in this book.</p>&#13;
<h4 class="h4" id="appa_2_4"><em>A.2.4 Memory Operands</em></h4>&#13;
<p class="noindent"><em>Memory operands</em> specify a memory address where the CPU should fetch one or more bytes. The x86 ISA supports only one explicit memory operand per instruction. That is, you can’t directly <code>mov</code> bytes from one memory location to another in one instruction. To accomplish that, you have to use a register as intermediate storage.</p>&#13;
<p class="indent">On x86, you specify memory operands with <code>[</code><em>base</em> <code>+</code> <em>index</em><code>*</code><em>scale</em> <code>+</code> <em>displacement</em><code>]</code>, where <em>base</em> and <em>index</em> are 64-bit registers, <em>scale</em> is an integer with the value 1, 2, 4, or 8, and <em>displacement</em> is a 32-bit constant or a symbol. All of these components are optional. The CPU computes the result of the memory operand expression, yielding the final memory address. The base, index, and scale are encoded in the instruction’s SIB byte, while the displacement is encoded in the field of the same name. The scale defaults to 1, while the displacement defaults to 0.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_381"/>This memory operand format is flexible enough to allow many common code paradigms in a straightforward way. For instance, you can use an instruction like <code>mov eax, DWORD PTR [rax*4 + arr]</code> to access an array element, where <code>arr</code> is a displacement containing the array’s starting address, <code>rax</code> contains the index of the element you want to access, and each array element is 4 bytes long. Here, <code>DWORD PTR</code> tells the assembler that you want to fetch 4 bytes (a doubleword or DWORD) from memory. Similarly, one way to access a field in a <code>struct</code> is to store the <code>struct</code>’s starting address in a base register and add the displacement of the field you want to access.</p>&#13;
<p class="indent">On x86-64, you’re allowed to use <code>rip</code> (the instruction pointer) as the base in a memory operand, though in that case you can’t use an index register. Compilers make frequent use of this possibility for position-independent code and data accesses, among other things, so you’ll see lots of <code>rip</code>-relative addressing in x86-64 binaries.</p>&#13;
<h4 class="h4" id="appa_2_5"><em>A.2.5 Immediates</em></h4>&#13;
<p class="noindent"><em>Immediates</em> are constant integer operands hardcoded in the instruction. For example, in the instruction <code>add rax, 42</code>, the value 42 is an immediate.</p>&#13;
<p class="indent">On x86, immediates are encoded in little-endian format; the least significant byte of a multibyte integer comes first in memory. In other words, if you write an assembly-level instruction like <code>mov ecx, 0x10203040</code>, the corresponding machine-level instruction encodes the immediate with the bytes reversed, as <code>0x40302010</code>.</p>&#13;
<p class="indent">To encode signed integers, x86 uses two’s complement notation, which encodes a negative value by taking the positive version of that value and then flipping all the bits and adding 1 while ignoring overflows. For example, to encode a 4-byte integer with the value −1, you take the integer <code>0x00000001</code> (the hexadecimal representation of 1), flip all the bits to produce <code>0xfffffffe</code>, and then add 1 to yield the final two’s complement representation <code>0xffffffff</code>. When you’re disassembling code and you see an immediate or memory value that starts with lots of <code>0xff</code> bytes, you’re often dealing with a negative value.</p>&#13;
<p class="indent">Now that you’re familiar with the general format and workings of x86 instructions, let’s take a look at the semantics of some of the common instructions you’ll encounter in this book and your own binary analysis projects.</p>&#13;
<h3 class="h3" id="appa_3">A.3 Common x86 Instructions</h3>&#13;
<p class="noindent"><a href="appa.xhtml#appatab3">Table A-3</a> describes common x86 instructions. To learn more about an instruction not listed in this table, look it up in an online reference such as <em><a href="http://ref.x86asm.net/">http://ref.x86asm.net/</a></em> or in the Intel manual at <em><a href="https://software.intel.com/en-us/articles/intel-sdm/">https://software.intel.com/en-us/articles/intel-sdm/</a></em>. Most of the instructions listed in the table are self-explanatory, but a few deserve a more detailed discussion.</p>&#13;
<p class="tab-caption" id="appatab3"><span epub:type="pagebreak" id="page_382"/><strong>Table A-3:</strong> Common x86 Instructions</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Instruction</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Description</strong></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Data transfer</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➊</span> <code>mov dst, src</code></td>&#13;
<td><em>dst = src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>xchg dst1, dst2</code></td>&#13;
<td>Swap <em>dst1</em> and <em>dst2</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➋</span> <code>push src</code></td>&#13;
<td>Push <em>src</em> onto the stack and decrement <code>rsp</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>pop dst</code></td>&#13;
<td>Pop value from stack into <em>dst</em> and increment <code>rsp</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Arithmetic</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>add dst, src</code></td>&#13;
<td><em>dst += src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>sub dst, src</code></td>&#13;
<td><em>dst –= src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>inc dst</code></td>&#13;
<td><em>dst += 1</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>dec dst</code></td>&#13;
<td><em>dst –= 1</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>neg dst</code></td>&#13;
<td><em>dst = –dst</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➌</span> <code>cmp src1, src2</code></td>&#13;
<td>Set status flags based on <em>src1 – src2</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Logical/bitwise</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>and dst, src</code></td>&#13;
<td><em>dst &amp;= src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>or dst, src</code></td>&#13;
<td><em>dst |= src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>xor dst, src</code></td>&#13;
<td><em>dst ^= src</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>not dst</code></td>&#13;
<td><em>dst = ~dst</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➍</span> <code>test src1, src2</code></td>&#13;
<td>Set status flags based on <em>src1 &amp; src2</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Unconditional branches</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>jmp addr</code></td>&#13;
<td>Jump to address</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>call addr</code></td>&#13;
<td>Push return address on stack, then call function at address</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>ret</code></td>&#13;
<td>Pop return address from stack and return to that address</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➎</span> <code>syscall</code></td>&#13;
<td>Enter the kernel to perform a system call</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Conditional branches (based on status flags)</strong><br/><code>jcc addr</code> jumps to address only if condition <em>cc</em> holds, else it falls through<br/><code>jncc</code> inverts the condition, jumping if it does not hold</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="ent">➏</span> <code>je addr</code>/<code>jz addr</code></td>&#13;
<td>Jump if zero flag is set (for example, operands were equal in last <code>cmp</code>)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>ja addr</code></td>&#13;
<td>Jump if <em>dst &gt; src</em> (“above”) in last comparison (unsigned)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>jb addr</code></td>&#13;
<td>Jump if <em>dst &lt; src</em> (“below”) in last comparison (unsigned)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>jg addr</code></td>&#13;
<td>Jump if <em>dst &gt; src</em> (“greater than”) in last comparison (signed)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>jl addr</code></td>&#13;
<td>Jump if <em>dst &lt; src</em> (“less than”) in last comparison (signed)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>jge addr</code></td>&#13;
<td>Jump if <em>dst &gt;= src</em> in last comparison (signed)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>jle addr</code></td>&#13;
<td>Jump of <em>dst &lt;= src</em> in last comparison (signed)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>    <code>js addr</code></td>&#13;
<td>Jump if last comparison set the sign bit (meaning the result was negative)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="center" colspan="2" style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Miscellaneous</strong></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;"><span class="ent">➐</span> <code>lea dst, src</code></td>&#13;
<td style="border-bottom: solid 0.2em;">Load memory address into <em>dst</em> (<em>dst = &amp;src</em>, where <em>src</em> must be in memory) <code>nop</code> Do nothing (for example for code padding)</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_383"/>First, it’s worth noting that <code>mov</code> <span class="ent">➊</span> is a bit of a misnomer because it doesn’t technically <em>move</em> the source operand into the destination. Rather, it copies it, leaving the source operand intact. The <code>push</code> and <code>pop</code> instructions <span class="ent">➋</span> have special significance with regard to stack management and function calls, as you’ll see shortly.</p>&#13;
<h4 class="h4" id="appa_3_1"><em>A.3.1 Comparing Operands and Setting Status Flags</em></h4>&#13;
<p class="noindent">The <code>cmp</code> instruction <span class="ent">➌</span> is important for implementing conditional branches. It subtracts the second operand from the first, but instead of storing the outcome of that operation somewhere, it sets status flags in the <code>rflags</code> register based on the outcome. Subsequent conditional branches check these status flags to decide whether the branch should be taken. Important flags include the <em>zero flag (ZF)</em>, the <em>sign flag (SF)</em>, and the <em>overflow flag (OF)</em>, which indicate whether the outcome of the comparison was zero, negative, or resulted in an overflow, respectively.</p>&#13;
<p class="indent">The <code>test</code> instruction <span class="ent">➍</span> is similar to <code>cmp</code>, but it sets status flags based on the bitwise AND of its operands, rather than the subtraction. It’s worth noting that some other instructions, besides <code>cmp</code> and <code>test</code>, set status flags as well. The Intel manual or online instruction reference show exactly which flags each instruction sets.</p>&#13;
<h4 class="h4" id="appa_3_2"><em>A.3.2 Implementing System Calls</em></h4>&#13;
<p class="noindent">To perform a system call, you use the <code>syscall</code> instruction <span class="ent">➎</span>. Before using it, you have to prepare the system call by selecting its number and setting its operands as specified by the operating system. For example, to perform a <code>read</code> system call on Linux, you load the value 0 (the system call number for <code>read</code>) into <code>rax</code>; then load the file descriptor, buffer address, and number of bytes to read into <code>rdi</code>, <code>rsi</code>, and <code>rdx</code>, respectively; and finally execute a <code>syscall</code> instruction.</p>&#13;
<p class="indent">To find out how to configure system calls on Linux, refer to <code>man syscalls</code> or an online reference like <em><a href="https://filippo.io/linux-syscall-table/">https://filippo.io/linux-syscall-table/</a></em>. Note that on 32-bit x86, you make a system call using <code>sysenter</code> or <code>int 0x80</code> (which triggers a software interrupt for interrupt vector <code>0x80</code>) instead of <code>syscall</code>. Also, system call conventions can differ on operating systems other than Linux.</p>&#13;
<h4 class="h4" id="appa_3_3"><em>A.3.3 Implementing Conditional Jumps</em></h4>&#13;
<p class="noindent">Conditional jump instructions <span class="ent">➏</span> implement branches by working in unison with earlier instructions that set status flags, like <code>cmp</code> or <code>test</code>. They jump to a specified address or label if the given condition holds or fall through to the next instruction if the condition does not hold. For example, to jump to a program location named <em>label</em> if <code>rax &lt; rbx</code> (using an unsigned comparison), you typically use an instruction sequence like this:</p>&#13;
<pre>cmp rax, rbx<br/>jb label</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_384"/>Similarly, to jump to <em>label</em> if <code>rax</code> is not zero, you can use the following:</p>&#13;
<pre>test rax, rax<br/>jnz label</pre>&#13;
<h4 class="h4" id="appa_3_4"><em>A.3.4 Loading Memory Addresses</em></h4>&#13;
<p class="noindent">Finally, the <code>lea</code> instruction <span class="ent">➐</span> (<em>load effective address</em>) computes the address resulting from a memory operand (formatted as <code>[base + index*scale + displacement]</code>) and stores it in a register but does not dereference the address. This is equivalent to the address-of operator (<code>&amp;</code>) in C/C++. For example, <code>lea r12, [rip+0x2000]</code> loads the address resulting from the expression <code>rip+0x2000</code> into the <code>r12</code> register.</p>&#13;
<p class="indent">Now that you’re familiar with the most important x86 instructions, let’s see how these instructions come together to implement common C/C<strong>++</strong> code constructs.</p>&#13;
<h3 class="h3" id="appa_4">A.4 Common Code Constructs in Assembly</h3>&#13;
<p class="noindent">Compilers like <code>gcc</code>, <code>clang</code>, and Visual Studio emit common code patterns for constructs like function calls, <code>if</code>/<code>else</code> branches, and loops. You’ll also see these same code patterns in handwritten assembly code. It helps to be familiar with them so that you can quickly understand what a piece of assembly or disassembled code is doing. Let’s take a look at code patterns emitted by <code>gcc 5.4.0</code>. Other compilers use similar patterns.</p>&#13;
<p class="indent">The first code construct you’ll see are function calls. But before you can understand how function calls are implemented at the assembly level, you need to be familiar with how <em>the stack</em> works on x86.</p>&#13;
<h4 class="h4" id="appa_4_1"><em>A.4.1 The Stack</em></h4>&#13;
<p class="noindent">The stack is a memory region reserved for storing data related to function calls, such as return addresses, function arguments, and local variables. On most operating systems, each thread has its own stack.</p>&#13;
<p class="indent">The stack gets its name from the way it’s accessed. Rather than writing values at random places in the stack, you do so in a <em>last-in-first-out (LIFO)</em> order. That is, you can write values by <em>pushing</em> them to the top of the stack and remove values by <em>popping</em> them from the top. This makes sense for function calls because it matches the way you invoke and return from functions: the last function you call returns first. <a href="appa.xhtml#appafig3">Figure A-3</a> illustrates the stack access pattern.</p>&#13;
<p class="indent">In <a href="appa.xhtml#appafig3">Figure A-3</a>, the stack starts at address <code>0x7fffffff8000</code><sup><a id="appafn_1a" href="footnote.xhtml#appafn_1">1</a></sup> and initially contains five values: <em>a</em>–<em>e</em>. The rest of the stack contains uninitialized memory (marked with “?”). On x86, the stack grows toward lower memory addresses, which means that newly pushed values are at lower addresses than older <span epub:type="pagebreak" id="page_385"/>values. The stack pointer register (<code>rsp</code>) always points to the top of the stack, where the most recently pushed value is. Initially, that’s <em>e</em> at address <code>0x7fffffff7fe0</code>.</p>&#13;
<div class="image"><a id="appafig3"/><img src="Images/f384-01.jpg" alt="image" width="673" height="323"/></div>&#13;
<p class="fig-caption"><em>Figure A-3: Pushing the value</em> f <em>onto the stack and then popping it into</em> <code>rax</code></p>&#13;
<p class="indent">Now, when you push a new value <em>f</em>, it ends up at the top of the stack, and <code>rsp</code> is decremented to point there. There are special instructions on x86 called <code>push</code> and <code>pop</code> that insert or remove a value on the stack and automatically update <code>rsp</code>. Similarly, the x86 <code>call</code> instruction automatically pushes the return address onto the stack, and <code>ret</code> pops the return address and returns there.</p>&#13;
<p class="indent">When you execute a <code>pop</code> instruction, it copies the value at the top of the stack into the <code>pop</code> operand and then increments <code>rsp</code> to reflect the new top of the stack. For example, the <code>pop rax</code> instruction in <a href="appa.xhtml#appafig3">Figure A-3</a> copies <em>f</em> from the stack into <code>rax</code> and then updates <code>rsp</code> to point to <em>e</em>, the new top of the stack. You can push an arbitrary number of values onto the stack before popping anything. Of course, this is subject to the available memory reserved for the stack.</p>&#13;
<p class="indent">Note that popping a value from the stack doesn’t clean it up; it merely copies the value and updates <code>rsp</code>. After the <code>pop</code>, <em>f</em> is technically still in memory until it’s overwritten by a later <code>push</code>. It’s important to realize that if you place sensitive information on the stack, it might still be accessible later unless you explicitly clean it up.</p>&#13;
<p class="indent">Now that you know how the stack works, let’s look at how function calls use it to store their arguments, return address, and local variables.</p>&#13;
<h4 class="h4" id="appa_4_2"><em>A.4.2 Function Calls and Function Frames</em></h4>&#13;
<p class="noindent"><a href="appa.xhtml#appalist3">Listing A-3</a> shows a simple C program that contains two function calls, omitting any error-checking code for brevity. First, it calls <code>getenv</code> to get the value of an environment variable specified in <code>argv[1]</code>. Then, it prints this value with <code>printf</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_386"/><a href="appa.xhtml#appalist4">Listing A-4</a> shows the corresponding assembly code, obtained by compiling the C program with <code>gcc 5.4.0</code> and then disassembling it with <code>objdump</code>. Note that for this example, I’ve compiled the program with <code>gcc</code>’s default options, and the output will look different if you enable optimizations or use another compiler.</p>&#13;
<p class="listing1" id="appalist3"><em>Listing A-3: Function calls in C</em></p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>  printf("%s=%s\n",<br/>         argv[1], getenv(argv[1]));<br/>                                <br/>  return 0;<br/>}</pre>&#13;
<p class="listing1" id="appalist4"><em>Listing A-4: Function calls in assembly</em></p>&#13;
<pre>   Contents of section .rodata:<br/>    400630 01000200 <span class="ent">➊</span>25733d25 730a00 ....%s=%s..<br/><br/>   Contents of section .text:<br/>   0000000000400566 &lt;main&gt;:<br/><span class="ent">➋</span>   400566:  push    rbp<br/>     400567:  mov     rbp,rsp<br/><span class="ent">➌</span>   40056a:  sub     rsp,0x10<br/><span class="ent">➍</span>   40056e:  mov     DWORD PTR [rbp-0x4],edi<br/>     400571:  mov     QWORD PTR [rbp-0x10],rsi<br/>     400575:  mov     rax,QWORD PTR [rbp-0x10]<br/>     400579:  add     rax,0x8<br/>     40057d:  mov     rax,QWORD PTR [rax]<br/><span class="ent">➎</span>   400580:  mov     rdi,rax<br/><span class="ent">➏</span>   400583:  call    400430 &lt;getenv@plt&gt;<br/><span class="ent">➐</span>   400588:  mov     rdx,rax<br/>     40058b:  mov     rax,QWORD PTR [rbp-0x10]<br/>     40058f:  add     rax,0x8<br/>     400593:  mov     rax,QWORD PTR [rax]<br/><span class="ent">➑</span>   400596:  mov     rsi,rax<br/>     400599:  mov     edi,0x400634<br/>     40059e:  mov     eax,0x0<br/><span class="ent">➒</span>   4005a3:  call    400440 &lt;printf@plt&gt;<br/><span class="ent">➓</span>   4005a8:  mov     eax,0x0<br/>     4005ad:  leave<br/>     4005ae:  ret</pre>&#13;
<p class="indent">The compiler stores the string constant <code>%s=%s</code> used in the <code>printf</code> call separately from the code, in the <code>.rodata</code> (read-only data) section <span class="ent">➊</span> at address <code>0x400634</code>. You’ll see this address used later in the code as a <code>printf</code> argument.</p>&#13;
<p class="indent">In principle, each function in an x86 Linux program has its own <em>function frame</em> (also called <em>stack frame</em>) on the stack, delimited by <code>rbp</code> (the base pointer) pointing to the base of that function frame and <code>rsp</code> pointing to the top. Function frames are used to store the function’s stack-based data. Note that with certain optimizations, compilers may omit the base pointer (making all stack accesses relative to <code>rsp</code>) and use <code>rbp</code> as an extra general-purpose register. However, the following example assumes that all functions use full function frames.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_387"/><a href="appa.xhtml#appafig4">Figure A-4</a> shows the function frames created for <code>main</code> and <code>getenv</code> when you run the program shown in <a href="appa.xhtml#appalist4">Listing A-4</a>. To understand how this works, let’s go over the assembly listing and see how it produces the function frames shown in the figure.</p>&#13;
<div class="image"><a id="appafig4"/><img src="Images/f386-01.jpg" alt="image" width="687" height="403"/></div>&#13;
<p class="fig-caption"><em>Figure A-4: Example of x86 function frames on a Linux system</em></p>&#13;
<p class="indent">As explained in <a href="ch02.xhtml#ch02">Chapter 2</a>, <code>main</code> isn’t really the first function that runs in a typical Linux program. For now, all you need to know is that <code>main</code> is invoked by a <code>call</code> instruction that places a return address on the stack where <code>main</code> returns when it’s done (shown at the top left of <a href="appa.xhtml#appafig4">Figure A-4</a>).</p>&#13;
<h5 class="h5">Function Prologues, Local Variables, and Reading Arguments</h5>&#13;
<p class="noindent">The first thing <code>main</code> does is run a <em>prologue</em> that sets up its function frame. This prologue starts by saving the contents of the <code>rbp</code> register on the stack and then copying <code>rsp</code> into <code>rbp</code> <span class="ent">➋</span> (see <a href="appa.xhtml#appalist4">Listing A-4</a>). This has the effect of saving the start address of the previous function frame and creating a fresh function frame at the top of the stack. Because the instruction sequence <code>push rbp; mov rbp,rsp</code> is so common, x86 has a shorthand instruction called <code>enter</code> (not used in <a href="appa.xhtml#appalist4">Listing A-4</a>) that does the same thing.</p>&#13;
<p class="indent">On x86-64 Linux, the registers <code>rbx</code> and <code>r12</code>–<code>r15</code> are guaranteed not to be polluted by any functions you call. That means that if a function does pollute these registers, it must take care to restore them to their original values before returning. Typically, functions achieve that by pushing any registers that need to be saved onto the stack just after the saved base pointer and popping them back off just before returning. In <a href="appa.xhtml#appalist4">Listing A-4</a>, <code>main</code> doesn’t do this because it doesn’t use any of the registers in question.</p>&#13;
<p class="indent">After setting up a basic function frame, <code>main</code> decrements <code>rsp</code> by <code>0x10</code> bytes to reserve room for two 8-byte local variables on the stack <span class="ent">➌</span>. Even though the C version of the program doesn’t explicitly reserve any local variables, <code>gcc</code> generated them automatically to serve as temporary storage for <code>argc</code> <span epub:type="pagebreak" id="page_388"/>and <code>argv</code>. On x86-64 Linux systems, the first six arguments to a function are passed in <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, and <code>r9</code>, respectively.<sup><a id="appafn_2a" href="footnote.xhtml#appafn_2">2</a></sup> If there are more than six arguments or some arguments don’t fit in a 64-bit register, the remaining arguments are pushed onto the stack in reverse order (compared to the order they appear in the argument list), as follows:</p>&#13;
<pre>mov rdi, param1<br/>mov rsi, param2<br/>mov rdx, param3<br/>mov rcx, param4<br/>mov r8, param5<br/>mov r9, param6<br/>push param9<br/>push param8<br/>push param7</pre>&#13;
<p class="indent">Note that some popular 32-bit x86 calling conventions (such as cdecl) pass all arguments on the stack in reverse order (without using any registers), while other calling conventions (such as fastcall) pass some arguments in registers.</p>&#13;
<p class="indent">After reserving room on the stack, <code>main</code> copies <code>argc</code> (stored in <code>rdi</code>) into one of the local variables and <code>argv</code> (stored in <code>rsi</code>) into the other <span class="ent">➍</span>. The left side of <a href="appa.xhtml#appafig4">Figure A-4</a> shows the layout of the stack after <code>main</code>’s prologue is done.</p>&#13;
<h5 class="h5">The Red Zone</h5>&#13;
<p class="noindent">You may notice the 128-byte “red zone” at the top of the stack in <a href="appa.xhtml#appafig4">Figure A-4</a>. On x86-64, functions are allowed to use the red zone as scratch space with the guarantee that the operating system won’t touch it (for instance, if a signal handler needs to set up a new function frame). Subsequently called functions do overwrite the red zone as part of their own function frame, so the red zone is most useful for so-called <em>leaf functions</em> that don’t call any other functions. As long as leaf functions don’t use more than 128 bytes of stack space, the red zone frees these functions from having to explicitly set up a function frame, thereby reducing execution time. On 32-bit x86, there’s no concept of a red zone.</p>&#13;
<h5 class="h5">Preparing Arguments and Calling a Function</h5>&#13;
<p class="noindent">After the prologue, <code>main</code> loads <code>argv[1]</code> into <code>rax</code> by first loading the address of <code>argv[0]</code> and then adding 8 bytes (the size of a pointer) and dereferencing the resulting pointer to <code>argv[1]</code>. It copies this pointer into <code>rdi</code> to serve as the argument for <code>getenv</code> <span class="ent">➎</span> and then calls <code>getenv</code> <span class="ent">➏</span> (see <a href="appa.xhtml#appalist4">Listing A-4</a>). The <code>call</code> instruction automatically pushes the return address (the address of the instruction right after the <code>call</code>) onto the stack, where <code>getenv</code> can find it when it returns. I won’t go into details on <code>getenv</code>’s code here since it’s a library function. Let’s simply assume that it sets up a standard function <span epub:type="pagebreak" id="page_389"/>frame by saving <code>rbp</code>, possibly saving some registers and reserving room for local variables. The center part of <a href="appa.xhtml#appafig4">Figure A-4</a> shows the stack layout after <code>getenv</code> is called and has completed its prologue, assuming that it didn’t push any registers to save.</p>&#13;
<p class="indent">After <code>getenv</code> completes, it saves its return value in <code>rax</code> (the standard register designated for that purpose) and then cleans up its local variables from the stack by incrementing <code>rsp</code>. It then pops the saved base pointer from the stack into <code>rbp</code>, restoring <code>main</code>’s function frame. At this point, the top of the stack is the saved return address, which is <code>0x400588</code> in <code>main</code> in this case. Finally, <code>getenv</code> executes a <code>ret</code> instruction that pops the return address from the stack and returns there, restoring control to <code>main</code>. The right side of <a href="appa.xhtml#appafig4">Figure A-4</a> shows the stack layout just after <code>getenv</code> returns.</p>&#13;
<h5 class="h5">Reading Return Values</h5>&#13;
<p class="noindent">The <code>main</code> function copies the return value (a pointer to the requested environment string) into <code>rdx</code> to serve as the third argument of the <code>printf</code> call <span class="ent">➐</span>. Next, <code>main</code> loads <code>argv[1]</code> again in the same way as before and stores it in <code>rsi</code> as the second argument for <code>printf</code> <span class="ent">➑</span>. The first argument (in <code>rdi</code>) is the address <code>0x400634</code> of the format string <code>%s=%s</code> in the <code>.rodata</code> section you saw earlier.</p>&#13;
<p class="indent">Note that unlike the call to <code>getenv</code>, <code>main</code> sets <code>rax</code> to zero before calling <code>printf</code>. That’s because <code>printf</code> is a variadic function, which assumes that <code>rax</code> specifies the number of floating-point arguments passed in via vector registers (in this case there are none). After preparing the arguments, <code>main</code> calls <code>printf</code> <span class="ent">➒</span>, pushing the return address for <code>printf</code>.</p>&#13;
<h5 class="h5">Returning from a Function</h5>&#13;
<p class="noindent">After <code>printf</code> completes, <code>main</code> prepares its own return value (the exit status) by zeroing out the <code>rax</code> register <span class="ent">➓</span>. Then, it executes a <code>leave</code> instruction, which is x86’s shorthand instruction for <code>mov rsp,rbp; pop rbp</code>. This is a standard function epilogue that does the opposite of the prologue. It cleans up the function frame by pointing <code>rsp</code> to the frame base (where the saved <code>rbp</code> is) and restoring the previous frame’s <code>rbp</code>. Finally, <code>main</code> executes a <code>ret</code> instruction, which pops the saved return address from the top of the stack and returns there, ending <code>main</code> and passing control back to whatever function called <code>main</code>.</p>&#13;
<h4 class="h4" id="appa_4_3"><em>A.4.3 Conditional Branches</em></h4>&#13;
<p class="noindent">Next, let’s take a look at another important construct: conditional branches. <a href="appa.xhtml#appalist5">Listing A-5</a> shows a C program containing an <code>if</code>/<code>else</code> branch that prints the message <code>argc &gt; 5</code> if <code>argc</code> is greater than 5 or the message <code>argc &lt;= 5</code> otherwise. <a href="appa.xhtml#appalist6">Listing A-6</a> shows the corresponding assembly-level implementation produced by <code>gcc 5.4.0</code> with default options, as recovered from the binary with <code>objdump</code>.</p>&#13;
<p class="listing1" id="appalist5"><span epub:type="pagebreak" id="page_390"/><em>Listing A-5: A conditional branch in C</em></p>&#13;
<pre>#include &lt;stdio.h&gt;<br/><br/>int<br/>main(int argc, char *argv[])<br/>{<br/>  if(argc &gt; 5) {<br/>    printf("argc &gt; 5\n");<br/>  } else {<br/>    printf("argc &lt;= 5\n");<br/>  }<br/><br/>  return 0;<br/>}</pre>&#13;
<p class="listing1" id="appalist6"><em>Listing A-6: A conditional branch in assembly</em></p>&#13;
<pre>  Contents of section .rodata:<br/>   4005e0 01000200 <span class="ent">➊</span>61726763 ....argc<br/>   4005e8 203e2035 00<span class="ent">➋</span>617267  &gt; 5.arg<br/>   4005f0 63203c3d 203500    c &lt;= 5.<br/>   <br/>  Contents of section .text:<br/>  0000000000400526 &lt;main&gt;:<br/>    400526:  push   rbp<br/>    400527:  mov    rbp,rsp<br/>    40052a:  sub    rsp,0x10<br/>    40052e:  mov    DWORD PTR [rbp-0x4],edi<br/>    400531:  mov    QWORD PTR [rbp-0x10],rsi<br/><span class="ent">➌</span>  400535:  cmp     DWORD PTR [rbp-0x4],0x5<br/><span class="ent">➍</span>  400539:  jle     400547 &lt;main+0x21&gt;<br/>    40053b:  mov    edi,0x4005e4<br/>    400540:  call   400400 &lt;puts@plt&gt;<br/><span class="ent">➎</span>  400545:  jmp     400551 &lt;main+0x2b&gt;<br/>    400547:  mov    edi,0x4005ed<br/>    40054c:  call   400400 &lt;puts@plt&gt;<br/>    400551:  mov    eax,0x0<br/>    400556:  leave<br/>    400557:  ret</pre>&#13;
<p class="indent">Just like you saw in <a href="appa.xhtml#appa_4_2">Section A.4.2</a>, the compiler stored the <code>printf</code> format strings in the <code>.rodata</code> section <span class="ent">➊</span><span class="ent">➋</span>, away from the code, which is in the <code>.text</code> section. The <code>main</code> function starts with a prologue and copies <code>argc</code> and <code>argv</code> into local variables.</p>&#13;
<p class="indent">The conditional branch implementation starts with the <code>cmp</code> instruction at <span class="ent">➌</span>, which compares the local variable containing <code>argc</code> to the immediate value <code>0x5</code>. It’s followed by a <code>jle</code> instruction that jumps to address <code>0x400547</code> if <code>argc</code> is less than or equal to <code>0x5</code> <span class="ent">➍</span> (the <code>else</code> branch). At that address, there’s a call to <code>puts</code> that prints the string <code>argc &lt;= 5</code>, followed by <code>main</code>’s epilogue and <code>ret</code> instruction.</p>&#13;
<p class="indent">If <code>argc</code> is greater than <code>0x5</code>, the <code>jle</code> is not taken but falls through to the next instruction sequence at address <code>0x40053b</code> (the <code>if</code> branch). It calls <code>puts</code> to print the string <code>argc &gt; 5</code> and then jumps to <code>main</code>’s epilogue at address <code>0x400551</code> <span class="ent">➎</span>. Note that this last <code>jmp</code> is necessary to jump over the code for the <code>else</code> branch at address <code>0x400547</code>.</p>&#13;
<h4 class="h4" id="appa_4_4"><em>A.4.4 Loops</em></h4>&#13;
<p class="noindent">At the assembly level, you can think of loops as special cases of conditional branches. Just like regular branches, loops are implemented with <code>cmp</code>/<code>test</code> and conditional jump instructions. <a href="appa.xhtml#appalist7">Listing A-7</a> shows a <code>while</code> loop in C that <span epub:type="pagebreak" id="page_391"/>loops over all given command line arguments and prints them in reverse order. <a href="appa.xhtml#appalist8">Listing A-8</a> shows a corresponding assembly program.</p>&#13;
<p class="listing1" id="appalist7"><em>Listing A-7: A</em> <span class="codeitalic">while</span> <em>loop in C</em></p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>                      <br/>int                    <br/>main(int argc, char *argv[])<br/>{                          <br/>  while(argc &gt; 0) {<br/>    printf("%s\n",    <br/>           argv[(unsigned)--argc]);<br/>  }                                <br/>                              <br/>  return 0;                  <br/>}                              </pre>&#13;
<p class="listing1" id="appalist8"><em>Listing A-8: A</em> <span class="codeitalic">while</span> <em>loop in assembly</em></p>&#13;
<pre>   0000000000400526 &lt;main&gt;:<br/>     400526:  push   rbp<br/>     400527:  mov    rbp,rsp<br/>     40052a:  sub    rsp,0x10<br/>     40052e:  mov    DWORD PTR [rbp-0x4],edi<br/>     400531:  mov    QWORD PTR [rbp-0x10],rsi<br/><span class="ent">➊</span>   400535:  jmp    40055a &lt;main+0x34&gt;<br/>     400537:  sub    DWORD PTR [rbp-0x4],0x1<br/>     40053b:  mov    eax,DWORD PTR [rbp-0x4]<br/>     40053e:  mov    eax,eax<br/>     400540:  lea    rdx,[rax*8+0x0]<br/>     400548:  mov    rax,QWORD PTR [rbp-0x10]<br/>     40054c:  add    rax,rdx<br/>     40054f:  mov    rax,QWORD PTR [rax]<br/>     400552:  mov    rdi,rax<br/>     400555:  call   400400 &lt;puts@plt&gt;<br/><span class="ent">➋</span>   40055a:  cmp    DWORD PTR [rbp-0x4],0x0<br/><span class="ent">➌</span>   40055e:  jg     400537 &lt;main+0x11&gt;<br/>     400560:  mov    eax,0x0<br/>     400565:  leave<br/>     400566:  ret</pre>&#13;
<p class="indent">In this case, the compiler chose to place the code that checks the loop condition at the end of the loop. So, the loop begins by jumping to address <code>0x40055a</code> where the loop condition is checked <span class="ent">➊</span>.</p>&#13;
<p class="indent">This check is implemented with a <code>cmp</code> instruction that compares <code>argc</code> to the value zero <span class="ent">➋</span>. If <code>argc</code> is greater than zero, the code jumps to address <code>0x400537</code> where the loop body begins <span class="ent">➌</span>. The loop body decrements <code>argc</code>, prints the next string from <code>argv</code>, and then ends up at the loop condition check again.</p>&#13;
<p class="indent">The loop continues until <code>argc</code> is zero, at which point the <code>jg</code> instruction in the loop condition check falls through into <code>main</code>’s epilogue, where <code>main</code> cleans up its stack frame and returns.</p>&#13;
</div></body></html>