- en: '9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TESTING WITH PESTER
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There’s no way around it: you need to test your code. It’s easy to assume your
    code has no flaws; it’s even easier to be proven wrong. When you test with Pester,
    you can stop assuming and start knowing.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing has been a feature of traditional software development for decades.
    But while concepts like *unit*, *functional*, *integration*, and *acceptance*
    testing may be familiar to seasoned software developers, they’re relatively new
    to scripters—those of us who want to automate with PowerShell but don’t hold a
    software engineer job title. Since many organizations are depending more on PowerShell
    code to run critical production systems, we’ll take a page from the programming
    world and apply it to PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to create tests for your scripts and modules
    so you can be sure your code works, and stays working when you’ve changed it.
    You’ll do this with the testing framework known as Pester.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Pester
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Pester* is an open source testing PowerShell module available in the PowerShell
    Gallery. Because it’s effective, and written in PowerShell, it’s become the de
    facto standard for testing in PowerShell. It allows you to write multiple types
    of tests, including unit, integration, and acceptance tests. If these test names
    don’t ring a bell, don’t worry. In this book, we’ll use Pester only to test environmental
    changes such as whether a virtual machine was created with the right name, whether
    IIS was installed, or whether the proper operating system was installed. We’ll
    refer to these tests as *infrastructure tests*.'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t cover how to test for things like whether a function was called, whether
    a variable was set correctly, or whether a script returned a specific object type—that’s
    all in the world of *unit testing*. If you’re curious about unit testing with
    Pester and want to learn how to use Pester in different situations, check out
    *The Pester Book* (LeanPub, 2019, *[https://leanpub.com/pesterbook/](https://leanpub.com/pesterbook/)*),
    which explains just about everything you need to know about testing with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Pester Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use Pester, you must first get it installed. If you have Windows 10, Pester
    is installed by default, but it’s also available in the PowerShell Gallery if
    you’re on another Windows operating system. If you’re on Windows 10, chances are
    Pester will be outdated anyway, so you might as well grab the latest copy from
    the PowerShell Gallery. Since Pester is available via the PowerShell Gallery,
    you can run `Install-Module -Name Pester` to download and install it. Once installed,
    it will have all the commands you need.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth repeating that you’ll be using Pester to write and run infrastructure
    tests, which are meant to validate any expected changes a script performs against
    its environment. For example, you might run an infrastructure test after creating
    a new file path by using `Test-Path` to ensure that the file path was created.
    Infrastructure tests are safeguards put in place to confirm that your code did
    what you expected it to do.
  prefs: []
  type: TYPE_NORMAL
- en: A Pester File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In its most basic form, a Pester test script consists of a PowerShell script
    ending in *.Tests.ps1*. You can name the main script anything you like; the naming
    convention and test structure are entirely up to you. Here, you’ll name the script
    *Sample.Tests.ps1*.
  prefs: []
  type: TYPE_NORMAL
- en: The basic structure of a Pester test script is one or more `describe` blocks
    that each contain (optional) `context` blocks that each contain `it` blocks that
    each contain assertions. If that was a lot to process, [Listing 9-1](ch09.xhtml#ch9list1)
    provides a visual guide.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: A basic Pester test structure*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through each of these parts.
  prefs: []
  type: TYPE_NORMAL
- en: The describe Block
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `describe` block is a way to group like tests together. In [Listing 9-2](ch09.xhtml#ch9list2),
    you create a `describe` block called `IIS`, which you could use to include all
    the code to test things like Windows features, app pools, and websites.
  prefs: []
  type: TYPE_NORMAL
- en: The basic syntax for a `describe` block is the word `describe` followed by a
    name, in single quotes, followed by an opening and closing curly bracket.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2: A Pester `describe` block*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this structure looks like an `if/then` condition, don’t be fooled!
    This is a scriptblock that is passed to the `describe` function under the covers.
    Note that if you’re the type who prefers curly brackets on a new line, you’re
    out of luck: the opening curly bracket must come on the same line as the `describe`
    keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: The context Block
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you create the `describe` block, you can add an optional `context` block.
    The `context` block groups together similar `it` blocks, which helps organize
    tests when infrastructure testing. In [Listing 9-3](ch09.xhtml#ch9list3), you’ll
    add a `context` block that will contain all the tests for Windows features. It’s
    a good idea to classify tests this way in `context` blocks to more easily manage
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3: A Pester `context` block*'
  prefs: []
  type: TYPE_NORMAL
- en: Although optional, the `context` block will become invaluable later when you’ve
    created tests to test dozens or hundreds of components!
  prefs: []
  type: TYPE_NORMAL
- en: The it Block
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s add an `it` block inside the `context` block. An `it` block is a smaller
    component that labels the actual test. Its syntax, shown in [Listing 9-4](ch09.xhtml#ch9list4),
    has a name followed by a block, just as you saw with the `describe` block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-4: A Pester `describe` block with a `context` and `it` block*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that so far, you more or less just added different labels for the test,
    in varying scopes. In the next section, you’ll add the test itself.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Inside the `it` block, you include one or more assertions. An *assertion* can
    be thought of as the actual test, or the code that compares the expected state
    to an actual state. The most common assertion in Pester is the `should` assertion.
    The `should` assertion has different operators that can be used with it, such
    as `be`, `bein`, `belessthan`, and so on. If you’d like a full list of available
    operators, the Pester wiki (*[https://github.com/pester/Pester/wiki/](https://github.com/pester/Pester/wiki/)*)
    has a full list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our IIS example, let’s check whether the app pool named `test` was created
    on our server. To do that, you first have to write the code to find the current
    state of the `Web-Server` Windows feature on the server (we’ll call it `WEBSRV1`).
    After a little investigation by browsing through the available PowerShell commands
    with `Get-Command` and sifting through the `Get-WindowsFeature` command’s help
    text, you find that the code to do so looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You know that if the `Web-Server` feature is installed, the `Installed` property
    will return `True`; otherwise, it will return `False`. Knowing this, you can then
    assert that when you run this `Get-WindowsFeature` command, you expect the `Installed`
    property to be `True`. You want to test whether this command’s output will *be*
    equal to `True`. You can represent this scenario inside an `it` block, as shown
    in [Listing 9-5](ch09.xhtml#ch9list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-5: Asserting a test condition with Pester*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you created a rudimentary Pester test to test whether a Windows feature
    is installed. You first enter the test you want to run, and then pass the results
    of that test through the pipeline to your testing condition, which, in this case,
    is `should be $true`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s much more to writing Pester tests, and I encourage you to learn the
    details via *The Pester Book* (*[https://leanpub.com/pesterbook/](https://leanpub.com/pesterbook/)*)
    or perhaps a series of articles on 4sysops (*[https://4sysops.com/archives/powershell-pester-testing-getting-started/](https://4sysops.com/archives/powershell-pester-testing-getting-started/)*).
    This should be enough for you to be able to read the tests I provide with this
    book. Once you finish this book, writing your own Pester tests will be a good
    way to test your PowerShell skills.
  prefs: []
  type: TYPE_NORMAL
- en: You have a Pester script now. And of course, once you have a script, you need
    to run it!
  prefs: []
  type: TYPE_NORMAL
- en: Executing a Pester Test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common way to execute tests with Pester is by using the `Invoke-Pester`
    command. This command is a part of the Pester module and allows the tester to
    pass it a path to the test script, which Pester will then interpret and execute,
    as in [Listing 9-6](ch09.xhtml#ch9list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-6: Running a Pester test*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the `Invoke-Pester` command has executed the *Sample.Tests.ps1*
    script and has provided basic information such as displaying the name of the `describe`
    block, the result of the test, as well as a summary of all the tests that ran
    during that test run. Note that the `Invoke-Pester` command will always show a
    summary of the status of each test performed. In this case, the `installs the
    Web-Server Windows feature` test was successful, indicated by the `+` symbol and
    a green output.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered the basics of the Pester testing framework. You downloaded,
    installed, and built a simple Pester test. This should help you understand how
    a Pester test is structured and how to execute it. In the coming chapters, you’ll
    use this framework over and over again. You’ll be adding lots of `describe` blocks,
    `it` blocks, and various assertions, but the basic structure will remain relatively
    unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up our final chapter of [Part I](part1.xhtml#part1). You’ve seen
    the fundamental syntax and concepts you’ll use when scripting with PowerShell.
    Now let’s get to the good stuff in [Part II](part2.xhtml#part2), where you’ll
    get hands-on experience and start looking at real-world problems!
  prefs: []
  type: TYPE_NORMAL
