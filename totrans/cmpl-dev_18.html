<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch16">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch16">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_253" aria-label=" Page 253. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">RUNNING AUTOMATED TESTS IN DOCKER</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In this short final chapter, you’ll write a couple of automated tests that verify the state of the Food Finder application. Then you’ll configure a Docker service to continuously run them.</p>&#13;
<p class="TX">We’ll focus on evaluating the application’s header by using a snapshot test and mocking the user session. We won’t create tests for the other components or our middleware, services, or APIs. However, I encourage you to build these on your own. Try using browser-based end-to-end tests, with a specialized framework such as Cypress or Playwright, to test entire pages. You can find installation instructions and examples for both frameworks at <a href="https://nextjs.org/docs/testing"><i>https://<wbr/>nextjs<wbr/>.org<wbr/>/docs<wbr/>/testing</i></a>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-94"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_254" aria-label=" Page 254. "/><samp class="SANS_Futura_Std_Bold_B_11">Adding Jest to the Project</samp></h3>&#13;
<p class="TNI">Install the Jest libraries with npm:</p>&#13;
&#13;
<pre class="pre-270"><code>$ <b>docker exec -it foodfinder-application npm install --save-dev jest \</b>&#13;
<b>jest-environment-jsdom @testing-library/react @testing-library/jest-dom</b>&#13;
</code></pre>&#13;
<p class="TX">Next, configure Jest to work with our Next.js setup by creating a new file called <i>jest.config.js</i> containing the code in <a href="chapter16.xhtml#Lis16-1">Listing 16-1</a>. Save the file in the application’s root folder.</p>&#13;
<span id="Lis16-1"/>&#13;
<pre class="pre-271"><code>const nextJest = require("next/jest");&#13;
&#13;
const createJestConfig = nextJest({&#13;
    dir: "./",&#13;
});&#13;
&#13;
const customJestConfig = {&#13;
    moduleDirectories: ["node_modules", "&lt;rootDir&gt;/"],&#13;
    testEnvironment: "jest-environment-jsdom",&#13;
};&#13;
&#13;
module.exports = createJestConfig(customJestConfig);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 16-1: The</span> <span class="Futura_Std_Book_11">jest.config.js</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We leverage the built-in Next.js Jest configuration, so we need to configure the project’s base directory to load the <i>config</i> and <i>.env</i> files into the test environment. Then we set the location of the module directories and the global test environment. We use a global setting here because our snapshot tests will require a DOM environment.</p>&#13;
<p class="TX">Now we want to be able to run the tests with npm commands. Therefore, add the two commands in <a href="chapter16.xhtml#Lis16-2">Listing 16-2</a> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">scripts</samp> property of the project’s <i>package.json</i> file.</p>&#13;
<span id="Lis16-2"/>&#13;
<pre class="pre-272"><code>    "test": "jest ",&#13;
    "testWatch": "jest --watchAll"&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 16-2: Two commands added to the</span> <span class="Futura_Std_Book_11">package.json</span> <span class="Futura_Std_Book_Oblique_BI_11">file’s</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">scripts</samp> <span class="Futura_Std_Book_Oblique_BI_11">property</span></p>&#13;
<p class="TX">The first command executes all available tests once, and the second continuously watches for file changes and then reruns the tests if it detects one.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-95"/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up Docker</samp></h3>&#13;
<p class="TNI">To run the tests using Docker, add another service to <i>docker-compose.yml</i> that uses the Node.js image. On startup, this service will run <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run testWatch</samp>, the command we just defined. In doing so, we’ll continuously run the tests and get instant feedback about the application’s state. Modify the file to match the code in <a href="chapter16.xhtml#Lis16-3">Listing 16-3</a>.</p>&#13;
<span id="Lis16-3"/>&#13;
<pre class="pre-273"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label=" Page 255. "/>version: "3.0"&#13;
services:&#13;
&#13;
    backend:&#13;
        container_name: foodfinder-backend&#13;
        image: mongo:latest&#13;
        restart: always&#13;
        environment:&#13;
            DB_NAME: foodfinder&#13;
            MONGO_INITDB_DATABASE: foodfinder&#13;
        ports:&#13;
            - 27017:27017&#13;
        volumes:&#13;
            - "./.docker/foodfinder-backend/seed-mongodb.js:&#13;
/docker-entrypoint-initdb.d/seed-mongodb.js"&#13;
            - mongodb_data_container:/data/db&#13;
&#13;
    application:&#13;
        container_name: foodfinder-application&#13;
        image: node:lts-alpine&#13;
        working_dir: /home/node/code/foodfinder-application&#13;
        ports:&#13;
            - "3000:3000"&#13;
        volumes:&#13;
            - ./code:/home/node/code&#13;
        depends_on:&#13;
            - backend&#13;
        environment:&#13;
            - HOST=0.0.0.0&#13;
            - CHOKIDAR_USEPOLLING=true&#13;
            - CHOKIDAR_INTERVAL=100&#13;
        tty: true&#13;
        command: "npm run dev"&#13;
&#13;
    <b>jest:</b>&#13;
<b>        container_name: foodfinder-jest</b>&#13;
<b>        image: node:lts-alpine</b>&#13;
<b>        working_dir: /home/node/code/foodfinder-application</b>&#13;
<b>        volumes:</b>&#13;
<b>            - ./code:/home/node/code</b>&#13;
<b>        depends_on:</b>&#13;
<b>            - backend</b>&#13;
<b>            - application</b>&#13;
<b>        environment:</b>&#13;
<b>            - NODE_ENV=test</b>&#13;
<b>        tty: true</b>&#13;
<b>        command: "npm run testWatch"</b>&#13;
&#13;
volumes:&#13;
    mongodb_data_container:&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 16-3: The modified</span> <span class="Futura_Std_Book_11">docker-compose.yml</span> <span class="Futura_Std_Book_Oblique_BI_11">file with the</span> <span class="Futura_Std_Book_11">jest</span> <span class="Futura_Std_Book_Oblique_BI_11">service</span></p>&#13;
<p class="TX">Our small service, named <i>jest</i>, uses the official Node.js Alpine image we’ve used previously. We set the working directory and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">volumes</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label=" Page 256. "/>property to make our code available in this container as well. Unlike our application’s service, however, the <i>jest</i> service sets the Node.js environment to <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> and runs the <samp class="SANS_TheSansMonoCd_W5Regular_11">testWatch</samp> command.</p>&#13;
<p class="TX">Restart the Docker containers; the console should indicate that Jest is watching our files.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H1" id="sec3"><span id="h1-96"/><samp class="SANS_Futura_Std_Bold_B_11">Writing Snapshot Tests for the Header Element</samp></h3>&#13;
<p class="TNI">As in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, create the <i>__tests__</i> folder to hold our test files in the application’s root directory. Then add the <i>header.snapshot.test.tsx</i> file containing the code in <a href="chapter16.xhtml#Lis16-4">Listing 16-4</a>.</p>&#13;
<span id="Lis16-4"/>&#13;
<pre class="pre-274"><code>import {act, render} from "@testing-library/react";&#13;
import {useSession} from "next-auth/react";&#13;
import Header from "components/header";&#13;
&#13;
jest.mock("next-auth/react");&#13;
describe("The Header component", () =&gt; {&#13;
    it("renders unchanged when logged out", async () =&gt; {&#13;
        (useSession as jest.Mock).mockReturnValueOnce({&#13;
            data: {user: {}},&#13;
            status: "unauthenticated",&#13;
        });&#13;
        let container: HTMLElement | undefined = undefined;&#13;
        await act(async () =&gt; {&#13;
            container = render(&lt;Header /&gt;).container;&#13;
        });&#13;
        expect(container).toMatchSnapshot();&#13;
    });&#13;
&#13;
    it("renders unchanged when logged in", async () =&gt; {&#13;
        (useSession as jest.Mock).mockReturnValueOnce({&#13;
            data: {&#13;
                user: {&#13;
                    name: "test user",&#13;
                    fdlst_private_userId: "rndmusr",&#13;
                },&#13;
            },&#13;
            status: "authenticated",&#13;
        });&#13;
        let container: HTMLElement | undefined = undefined;&#13;
        await act(async () =&gt; {&#13;
            container = render(&lt;Header /&gt;).container;&#13;
        });&#13;
        expect(container).toMatchSnapshot();&#13;
    });&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 16-4: The</span> <span class="Futura_Std_Book_11">__tests__/header.snapshot.test.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">This test should resemble those you wrote in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>. Note that we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook from <i>next-auth/react</i> and then use <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp> to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label=" Page 257. "/>replace it in the <i>arrange</i> step of each test. By replacing the session with a mocked one that returns the state, we can verify that the header component behaves as expected for both logged-in and logged-out users. We describe the test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Header</samp> component by using the arrange, act, and assert pattern and verify that the rendered component matches the stored snapshot.</p>&#13;
<p class="TX">The first test case uses an empty session and the <i>unauthenticated</i> status to render the header in a logged-out state. The second test case uses a session with minimal data and sets the user’s status to <i>authenticated</i>. This lets us verify that an existing session shows a different user interface than an empty session does.</p>&#13;
<p class="TX">If you write additional tests, make sure to add them to the <i>__tests__</i> folder.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H1" id="sec4"><span id="h1-97"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">You’ve successfully added a few simple snapshot tests to verify that the Food Finder application works as intended. Using an additional Docker service, you can continuously verify that additional developments won’t break the application.</p>&#13;
<p class="TX">Congratulations! You’ve successfully created your first full-stack application with TypeScript, React, Next.js, Mongoose, and MongoDB. You’ve used Docker to containerize your application and Jest to test it. With the knowledge gained in the book and its exercises, you’ve laid the foundation for your career as a full-stack developer.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>