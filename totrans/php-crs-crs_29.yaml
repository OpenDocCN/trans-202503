- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 24 LOGGING EVENTS, MESSAGES, AND TRANSACTIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Almost all live, commercial web applications keep a *log*, a record of messages,
    errors, events, performance summaries, and other information generated by the
    application while it runs. In this chapter, we’ll explore how to maintain logs
    for PHP web applications so you can analyze application performance and respond
    to problems when they occur. You’ll learn about PHP’s built-in resources for logging,
    as well as Monolog, a popular third-party PHP logging package, and you’ll see
    how to log messages to various locations.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a log records events for auditing purposes, such as to review electronic
    monetary transactions for irregularities. Other times, transactions are logged
    for backup and recovery purposes. For example, if something goes wrong while writing
    information to a database, the database can be returned to a correct state by
    reverting to a backup (called an *image*, or *snapshot*) from a known point in
    time and then rerunning the sequence of transactions logged after that snapshot
    was created. Logging also goes hand in hand with exceptions, which we discussed
    in the preceding chapter. When an exception is thrown, it can be recorded in the
    system log for later analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in PHP Resources for Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logging is such a core part of server programming that PHP provides many resources
    to facilitate it. These include a set of predefined constants corresponding to
    various log severity levels, as well as built-in functions for logging messages
    to files. We’ll explore these features now.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined Constants for Severity Levels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most computer logging systems allow messages to be classified according to a
    particular level of urgency or importance. To that end, PHP comes with eight predefined
    constants establishing levels of logging severity. These severity levels, numbered
    0 through 7, from most to least urgent, correspond to the eight levels laid out
    in RFC 5424, a widely used standard for the syslog protocol set by the IETF. You
    can find this protocol at *[https://www.rfc-editor.org/rfc/rfc5424](https://www.rfc-editor.org/rfc/rfc5424)*.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the PHP constants in conjunction with the built-in syslog() function,
    which we’ll discuss next, to generate log messages of the appropriate severity
    level. [Table 24-1](#tab24-1) shows the eight severity levels, their RFC 5424
    level names, and a summary of their meanings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 24-1: Levels of Severity for Log Messages from RFC 5424'
  prefs: []
  type: TYPE_NORMAL
- en: '| Syslog severity value | RFC 5424 log level | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Emergency | The system is unusable or unavailable. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Alert | A problem has happened, and immediate action is required. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Critical | A problem is about to happen and must be addressed immediately.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Error | A failure has occurred that is non-urgent but needs action in
    a given time frame. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Warning | An event requires action, since it is likely to lead to an
    error. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Notice | An expected but significant event has occurred that warrants
    logging, but no action is required. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Info | An expected event has occurred for reporting and measurement.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Debug | Used by software developers to record detailed information supporting
    current debugging and code analysis. |'
  prefs: []
  type: TYPE_TB
- en: '[Table 24-2](#tab24-2) shows the eight named PHP constants corresponding to
    the RFC 5424 log levels as well as the integer values of these constants for macOS,
    Unix, and Windows systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 24-2: PHP Log-Level Constants'
  prefs: []
  type: TYPE_NORMAL
- en: '| PHP constant | macOS and Unix value | Windows value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LOG_EMERG | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| LOG_ALERT | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| LOG_CRIT | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| LOG_ERR | 3 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| LOG_WARNING | 4 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| LOG_NOTICE | 5 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| LOG_INFO | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| LOG_DEBUG | 7 | 6 |'
  prefs: []
  type: TYPE_TB
- en: On macOS and Unix systems, each constant has an integer value corresponding
    to one of the eight severity levels. For example, the LOG_EMERG constant has a
    value of 0 in macOS and Unix. If you’re running PHP on a Windows server, the values
    of these constants are slightly different, because of different standards for
    system header files. For all systems, however, the severity of the log level increases
    as the value of the constant decreases, in line with the principles of RFC 5424\.
    We’ll refer to the macOS and Unix values throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The various severity levels have their own conventional uses. When testing and
    debugging code, for example, it’s customary to use LOG_DEBUG severity and perhaps
    to direct these log entries to their own debugging logfile. You might log messages
    about standard, noncritical issues, such as a user trying to upload files that
    are too big or of the wrong file type, with a severity of LOG_INFO or LOG_NOTICE.
    This way, user-interface or file-size improvements could be considered if the
    same issues occur many times. Much thought should go into events likely to lead
    to errors, and these should be logged as LOG_ERR severity. Likewise, it’s always
    important when coding for exceptions to identify those that might impact the overall
    functioning of the web application and log them with LOG_EMERG, LOG_ALERT, or
    LOG_CRIT severity.
  prefs: []
  type: TYPE_NORMAL
- en: Classifying log messages by severity level allows you to design computer systems
    with logic to respond to new log messages of different importance in different
    ways. For example, when a new log message occurs at the top three severity levels
    (Emergency, Alert, or Critical), the logging system rules might perform actions
    such as sending text messages and automated phone calls to the site technicians
    listed as being on call. Meanwhile, messages of lower importance might be written
    to archive files or perhaps sent via a web API to a cloud logging system. We’ll
    explore an example of creating customized responses for different severity in
    “Managing Logs According to Severity” on [page 466](#pg_466).
  prefs: []
  type: TYPE_NORMAL
- en: '#### Logging Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP has two built-in functions for logging messages: error_log() and syslog().
    They differ based on where the messages get logged.'
  prefs: []
  type: TYPE_NORMAL
- en: The error_log() function appends to the PHP error logfile, whose location is
    defined by the error_log path in your *php.ini* file or your server log settings,
    or to another location that can be passed as a parameter when calling the function.
    (See [Appendix A](appendix-a.xhtml) for information on how to locate your system’s
    *php.ini* file.)
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the syslog() function appends messages to your computer system’s
    general syslog file. [Table 24-3](#tab24-3) shows the default name and location
    of this file on macOS, Unix, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 24-3: Default Names and Locations of Syslog Files'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operating system | Filename | Location |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | system.log | /var/log |'
  prefs: []
  type: TYPE_TB
- en: '| Unix | syslog | /etc |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | SysEvent.evt | C:\WINDOWS\system32\config\ |'
  prefs: []
  type: TYPE_TB
- en: 'When setting up an application, choosing where to log messages can be difficult:
    Do you want to have dedicated logfiles just for this application, do you want
    to log your PHP web application messages to the same location as other PHP logs,
    or do you want logs from the application to be added to the computer system’s
    general logging system? As you’ll see in “Logging to the Cloud” on [page 472](#pg_472),
    using a third-party logging library provides even more options to select from:
    choosing the filename and location, using multiple files for different log types,
    or even logging to a web API.'
  prefs: []
  type: TYPE_NORMAL
- en: The decision partly depends on the nature of the project. For personal project
    development, logging to your local machine might make sense, whereas for mission-critical
    reporting of a live production system, logging to files on a web server or the
    cloud is probably more appropriate and may be mandated by the requirements and
    standards of the organization you’re working for.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of logging to the system’s general syslog file, as with PHP’s syslog()
    function, is that logs for all applications and processes will be in one place,
    so you can look at issues with your web application in relation to other system
    issues (such as memory or processing speed problems). Also, you can use a range
    of applications for viewing, searching, and analyzing the general logging system,
    whether it be for Windows, macOS, or Unix. However, general logs are large and
    constantly being appended to by running processes, so when developing and even
    when running a production site, targeting logs for the web application to a dedicated
    file, as with the error_log() function, can make a lot of sense. With this in
    mind, let’s take a look at how the two built-in PHP logging functions work.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can log a message to the PHP error logfile with error_log() by writing
    a statement such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass the message you want to log as an argument to the function. By default,
    this message will be appended to the file specified in your *php.ini* settings.
    You can view that file from the command line by using cat (macOS/Unix) or type
    (Windows), followed by the filename. For example, here’s the entry added to the
    logfile on my macOS laptop (which logs to a file named *php_error.log*) by the
    previous error_log() call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The log entry starts with a timestamp, followed by the message string passed
    as an argument to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syslog() function takes two arguments. The first is one of the integers
    (0 through 7) indicating the severity level, or a constant declared with that
    integer value. This is where the built-in PHP constants discussed earlier come
    in. The second argument is a string message to be logged to the system’s general
    syslog file. Here’s an example call to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use the LOG_WARNING constant as the first argument, which PHP defines with
    a value of 4, corresponding to the fifth level on the RFC 5424 severity scale.
    This event requires action since it’s likely to lead to an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syslog file often contains hundreds or even thousands of entries, logging
    many events and actions from many system programs and applications. Rather than
    display the whole logfile, filtering it to just the entries you want is helpful.
    For macOS or Unix, you can use grep to see entries containing a certain string.
    Windows has an equivalent findstr command. Here’s an example of using grep to
    view the log entry just created with the syslog() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here I’ve used grep to show only log entries containing the string "from Matt".
    (In Windows, the command would be findstr "from Matt" SysEvent.evt.) On my Apple
    MacBook, the log entry created by syslog() begins with a formatted date, followed
    by the computer name (matts-MacBook-Pro-2). Next comes the program or service
    appending to the log (in this case, php), followed by the process ID (4304), a
    number assigned by the operating system to uniquely identify each active process.
    Finally, the entry ends with the message string passed to the syslog() function.
    The contents of each syslog entry are similar for Windows, containing the event
    type, event ID, source, message, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '> NOTE'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you aren’t comfortable perusing syslog files at the command line, many
    applications are available for viewing, filtering, and analyzing these files.
    For example, Windows has Event Viewer, and macOS has Console.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Monolog Logging Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logging is so common in web applications that several third-party PHP libraries
    exist to help with it, including the popular Monolog library. The majority of
    PHP web frameworks and cloud logging systems provide integration with Monolog.
    It’s usually the first, and sometimes only, logging system many PHP programmers
    learn to use. The library makes it easy to develop customized, sophisticated logging
    strategies, with different types of log entries handled in different ways, and
    messages being logged to a variety of locations, including local files, cloud-based
    systems, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Monolog is compliant with PSR-3, a standards recommendation for PHP logging
    systems. This standard uses the same eight levels of log severity as the RFC 5424
    syslog standard. To be PSR-3 compliant, a logging interface should have methods
    for each of the eight log levels. Each method should require a string argument
    containing the message to be logged and an optional array for more information
    about the context of the message.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Monolog’s source code and documentation can be found on GitHub at* [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog)*,
    and you can learn more about the PSR-3 standard at* [https://www.php-fig.org/psr/psr-3/](https://www.php-fig.org/psr/psr-3/)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an example project that uses Monolog to log messages. Create a
    new project folder and then use the command composer require monolog/monolog to
    add the Monolog library. You should now have a *composer.json* file and a *vendor*
    folder with an autoloader and the Monolog library classes. Next, create an index
    script in *public/index.php* containing the code in [Listing 24-1](#lis24-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 24-1: Setting up and using Monolog in public/index.php'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, our index script begins by requiring the autoloader script. Then we
    provide use statements for the Monolog Logger and StreamHandler classes. Next,
    we declare a path to *mylogs.log* in the *logs* folder for this project; this
    is where we’ll log our messages, but you could provide a path to any file you
    wish. The first time Monolog tries to append a message to this file, it will create
    the file and directory if they don’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: We next create a new Logger object to manage the logging, providing the channel
    name demo. We’ll explore channels and why they’re useful in the next section.
    Every Logger object needs one or more *log handler* classes to tell it what to
    do with log entries, so we also create a log handler by calling the Logger object’s
    pushHandler() method, passing in a new object of Monolog’s StreamHandler class.
    This is a class for logging messages to files (in our case, the *logs/mylogs.log*
    file specified in the $logFile variable), but Monolog has different handler classes
    for other actions, such as logging to the browser, a cloud API, or a database.
    We’ll explore another log handler in “Logging to the Cloud” on [page 472](#pg_472).
  prefs: []
  type: TYPE_NORMAL
- en: Since Monolog is PSR-3 compliant, Logger objects have methods for logging messages
    with each of the eight standard severity levels. We use two of these methods.
    First, we use warning() to create a warning log entry with the text 'I am a warning.'❶
    Then we use the error() method to create an error log entry with the text 'I am
    a test error!'
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the index script, the contents of *logs/mylogs.log* should
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Remember, you can view the file at the command line via cat (macOS and Unix)
    or type (Windows).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each log entry generated by Monolog starts with a timestamp, followed
    by the channel name and severity level (for example, demo .WARNING), followed
    by the log message. The empty square brackets at the end of each log entry indicate
    no additional information was provided. We’ll add more information about the context
    of the log message in “Logging Exceptions” on [page 469](#pg_469).
  prefs: []
  type: TYPE_NORMAL
- en: Organizing Logs with Channels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Larger systems are organized into well-defined subsystems, and knowing which
    subsystems have generated which log entries greatly aids debugging, error tracking,
    and code evaluations. Monolog makes this possible by giving each Logger object
    a channel name. By creating multiple Logger objects with unique channel names,
    you can organize your log based on the source of the entries. For example, an
    online shop might have channels like security, database, and payments for logging
    different kinds of system events.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we created our Logger object to be part of the demo
    channel, and we saw how this channel name was included in each log entry. Let’s
    now modify our project to distinguish between two channels: demo and security.
    Update *public/index.php* to match the contents of [Listing 24-2](#lis24-2).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 24-2: Logging to two separate channels in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new Logger object called $demoLogger for a channel named demo and
    set its log handler to be a StreamHandler to the *logs/mylogs.log* file. Then
    we create a second Logger object with a channel named security. Next, we use the
    $demoLogger object’s withName() method to create a clone of the object with a
    channel name of security ❶. This saves us from having to create the second Logger
    object and its log handler (which points to the same file as $demoLogger) from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have two Logger objects, $demoLogger (channel name demo) and $securityLogger
    (channel name security). Both of these Logger objects use the same log handler,
    writing logs to *logs/mylogs.log*. Depending on which Logger object we use, we
    can ensure that log entries are marked with the appropriate channel to aid later
    logfile analysis. We finish the script by logging a message to each channel. The
    resulting contents of the *logs/mylogs.log* file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the error log entry went to the demo channel, while the warning
    entry went to the security channel. We could filter the logfile to show entries
    from just one of the channels by using the Unix grep or Windows findstr commands.
    For example, we could search for security channel entries by entering findstr
    "security." logs/mylogs.log in a Windows command terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Logs According to Severity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Beyond sorting entries into channels, we can add even more sophistication to
    our logging strategy by treating log entries differently according to their level
    of severity. Monolog can do this by adding multiple log handlers, collectively
    referred to as a *stack*, to the same Logger object. When we add a log handler,
    we can optionally specify which severity levels it applies to. We could, for example,
    have one log handler for the three most severe levels that works with a web API
    to automatically notify IT staff via text message to address the problem immediately.
    A second log handler could respond to lower severity levels and record the messages
    to a logfile.
  prefs: []
  type: TYPE_NORMAL
- en: Monolog handlers also have an optional feature called *bubbling* that allows
    log entries to be processed by one handler and also passed (*bubbled*) down the
    stack to be processed again by other log handlers. In addition to high-severity
    log entries triggering automated messages to IT staff phones, for example, those
    same log entries could also be stored to a logfile for archive and analysis purposes,
    along with the low-severity entries. [Figure 24-1](#fig24-1) shows an example
    log handler stack that uses bubbling and manages log entries according to severity.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure24-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 24-1: Using bubbling and severity levels to create a sophisticated logging
    strategy'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram illustrates a stack of three log handlers. At the top of the stack,
    handler1 catches any log entries of Critical or more importance (severity levels
    0 through 2) and records them in *immediateActions.log*. This first handler has
    bubbling enabled, so the high-severity log entries are also passed further down
    the stack for additional processing.
  prefs: []
  type: TYPE_NORMAL
- en: Next in the stack is handler2, which catches all log entries of Info or more
    importance (levels 0 through 6) and records them in *infoActions.log*. Thanks
    to bubbling, the high-severity log entries will therefore be recorded in two separate
    files. Bubbling is turned off for handler2, so any log entries this handler processes
    won’t be sent down the stack for further action. As a result, the only log entries
    arriving at the bottom of the log handler stack are those of severity level 7
    (Debug). These are received by handler3 and recorded in *debug.log*. Notice that
    handler3 is set to receive log entries of any severity, but in practice it will
    receive only debug entries because all other severity levels stop at handler2.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s modify our project to implement the stack of these three log handlers.
    To make sure the stack works as expected, we’ll generate log entries for all eight
    levels of severity and check the contents of the three logs. Update *public/index.php*
    as shown in [Listing 24-3](#lis24-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 24-3: Managing log entries by severity level with a stack of three
    log handlers in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have added a use statement to give us access to the constants in the
    Monolog\Level class ❶. We declare three variables for the filepaths to *immediateActions.log*,
    *infoActions.log*, and *debug.log* ❷. Then we create three variables referencing
    three StreamHandler objects ❸. These will be the three log handlers in our stack.
  prefs: []
  type: TYPE_NORMAL
- en: For the first, $handler1, we pass the path to the immediate actions logfile,
    and we use the constant Level::Critical as the second argument to assign this
    handler to entries of Critical or greater importance. The handler has bubbling
    enabled by default. We provide $handler2 the path to the info actions file and
    use Level::Info to assign it to Info-level log entries or greater (all logs except
    Debug entries). The third argument of false turns bubbling off for handler2.
  prefs: []
  type: TYPE_NORMAL
- en: To create $handler3, we simply pass the path to the debug logfile and omit the
    other arguments. By default, all log entries will be processed by this handler
    and bubbling will be enabled. However, the handler will receive only Debug-level
    entries, and since it will be at the bottom of the stack, no other log handler
    exists for log entries to bubble down to.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new Logger object ❹ and assign all three log handlers to it,
    one at a time. When multiple handlers are added to the same Logger object, the
    last one added is considered to be at the top of the stack and will get the chance
    to process all log entries first. Therefore, we add the handlers in reverse order,
    starting with $handler3 and ending with $handler1. Finally, we log eight messages
    ❺, one for each level of severity, with a message confirming the level number
    and name.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the index script, the *logs/immediateActions.log* file should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Only Critical, Alert, and Emergency logs were processed and written to *immediateActions.log*
    by $handler1 at the top of the log handler stack. Here are the contents of *logs/infoActions.log*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All logs from levels 0 to 6 were processed and written to *infoActions.log*
    by $handler2 from the middle of the log handler stack. Since we’ve already seen
    the level 0, 1, and 2 logs in *immediateActions.log* from $handler1, seeing them
    again in *infoActions.log* confirms that the bubbling mechanism has worked, allowing
    these logs to also be received by $handler2. Finally, here are the contents of
    the *logs/debug.log* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Only the entry for severity level 7 (Debug) can be seen in *debug.log*. This
    demonstrates that $handler3 at the bottom of the stack received only this single
    log entry.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common use of logs is to record when exceptions occur during program execution.
    In [Chapter 23](chapter23.xhtml), we explored how programs can be organized around
    try...catch statements: a try statement with the code that should execute under
    normal circumstances, and a catch statement for handling exceptions. When an application
    uses logging, the exceptions are logged as part of the catch statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a simple, single-class project to illustrate how to do this. Our
    project will have a Product class that throws an exception when we try to create
    a Product object with a negative price. We’ll use Monolog to log those exceptions
    to a *logs/debug.log* file. We’ll begin by declaring the Product class. Create
    a new project with *src/Product.php* containing the code in [Listing 24-4](#lis24-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 24-4: A Product class that throws an exception'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the Product class in the Mattsmithdev namespace and give it two private
    properties, name and price. The class’s constructor method takes in $name and
    $price values for the new object being created. Within the constructor, we validate
    the $price argument and throw an exception if its value is negative ❶. For this
    simple example, we’re using PHP’s root Exception class.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to create a *composer.json* file to autoload the class. [Listing
    24-5](#lis24-5) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 24-5: The composer.json file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use Composer at the command line to generate the autoloader scripts and
    add the Monolog library to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to write an index script that attempts to create a Product object
    and logs the exception if the attempt is unsuccessful. Create *public/index.php*
    to match [Listing 24-6](#lis24-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 24-6: Attempting to create an invalid Product object in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: First, we read and execute the autoloader and add use statements for the classes
    we need. Then we get set up for logging by creating a variable for the *logs/debug.log*
    filepath, creating a new Logger object for a channel named demo and giving it
    a log handler. Next, inside a try block, we create a new Product object, passing
    -1 for the price. In the related catch block, we log an entry of Error-level severity
    with the Logger object if creating the product fails ❶.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to providing a message to log ('problem creating new product'),
    we include an array as the second argument to log additional information. Specifically,
    we pass the entire Exception object $e and give it the key exception. In the Monolog
    documentation, this optional array is called the *context* of the log entry. It
    can contain multiple elements with keys of your choosing, which can be helpful
    when reviewing the logs and analyzing them for patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the index script, the *logs/debug.log* file should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An Error-level log has been added to the logfile for the demo channel, with
    the message problem creating new product. The log entry also contains the details
    of the Exception object that was thrown by the Product constructor method, including
    the message associated with the exception (attempting to set price to a negative
    value) and the location of the exception-triggering code.  ### Logging to the
    Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve been logging messages to files, but most large-scale web applications
    log to a dedicated cloud-based logging system rather than to files on the server.
    One popular cloud logging system is Mezmo (previously LogDNA). Using a cloud logging
    API such as Mezmo provides many benefits, including historical storage of logs,
    powerful filtering and search features, and comprehensive analytical and reporting
    features. Cloud logging APIs such as Mezmo can also be linked to alert notification
    systems such as Atlassian’s Opsgenie to send the email or text alerts for log
    entries requiring immediate actions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a project that sends log entries to Mezmo. We’ll log to two separate
    channels and try out entries of each severity level. First, visit the Mezmo website
    (*[https://www.mezmo.com](https://www.mezmo.com)*) and create a free account.
    Make a note of the unique hexadecimal Mezmo ingestion key created for you in your
    account details; you’ll need to reference it in your script.
  prefs: []
  type: TYPE_NORMAL
- en: To interact with Mezmo from your PHP code, we’ll use the monolog -logdna package,
    maintained by Nicolas Vanheuverzwijn. This package adds Mezmo API communication
    capabilities to Monolog. Create a new project folder and add the package by entering
    composer require nvanheuverzwijn/monolog-logdna at the command line. You should
    now have a *composer.json* file and a *vendor* folder containing an autoloader
    and the Monolog and other library classes for logging to the Mezmo API. Now create
    an index script in *public/index.php* containing the code in [Listing 24-7](#lis24-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 24-7: Setting up and using Monolog in public/index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We provide use statements for Monolog’s Logger class and for LogDnaHandler,
    the log handler needed to log to Mezmo. Then we declare a variable for the necessary
    Mezmo ingestion key; be sure to fill in your own key here ❶. Next, we create a
    new Logger object named $generalLogger, providing general as the channel name,
    and we give it a log handler, passing the ingestion key and naming the host source
    of logs as host-mgw.com (short for My Great Website, as usual). Different web
    applications or subsites could use different hostnames in their handlers, to further
    differentiate the source of logs.
  prefs: []
  type: TYPE_NORMAL
- en: We log eight messages to our $generalLogger object ❷, one for each level of
    severity, with a message confirming the level number and name. Then we save a
    bit of work by using the withName() method to create a clone of the $generalLogger
    object called $securityLogger with a channel name of security ❸. Both Logger objects
    use the same log handler and so can send logs to the Mezmo API. We use this second
    object to log a debug entry, passing a second argument of a single-element array
    with the 'context-1' key and 'some data' data string. This tests how we might
    record extra data in a log entry.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 24-2](#fig24-2) shows the logs from our executed index script, received
    and displayed on the Mezmo site.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure24-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 24-2: Log entries on the Mezmo cloud service'
  prefs: []
  type: TYPE_NORMAL
- en: Mezmo shows timestamped logs from the general and security channels, with all
    entries coming from host-mgw. Each entry is marked with its severity level. The
    details of the final log, to the security channel, have been expanded in the figure,
    revealing the context data we passed to the Logger object via an array.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ve seen in this chapter, you can create logs for a web application in
    several ways, from simple error_log() function calls to the sophisticated Monolog
    open source logging library package to APIs like Mezmo for cloud storage and analytics.
    The scale and importance of each project will determine the most appropriate approach
    to take, but for almost all projects that you need to quality-assure and maintain,
    you’ll probably have to adopt some form of logging to record and manage errors
    and exceptions, and to collect historical data about use and performance of the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Create message entries by using both the syslog() and error_log() functions.
    Locate the files that these functions write to on your computer system and view
    your messages in the logfiles.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Create a new project and use Composer to add the Monolog package. In your
    index script, create a new Logger object for a channel named general, and add
    a StreamHandler to append logs to the *logs/mylogs.log* file. Log several entries
    of different severity levels, and view the log entries in your logfile after executing
    your index script.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Create a new project with a stack of two handlers: handler1 (appending
    to the *urgent.log* file) and handler2 (appending to the *other.log* file). Add
    handler2 first so that handler1 will be on the top of the stack. Turn off bubbling
    for handler1 and configure it to catch all log entries of Critical or more importance.
    Generate log entries for all eight levels of severity. You should see log entries
    of severity 0, 1, and 2 in *urgent.log*, and all others (3 through 7) in *other.log*.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Create an account at a cloud logging site such as Mezmo, and update the
    project from Exercise 3 to log entries to that site’s API. View the logs online
    to confirm that your program successfully sent them via the API.
  prefs: []
  type: TYPE_NORMAL
