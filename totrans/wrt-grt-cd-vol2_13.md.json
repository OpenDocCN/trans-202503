["```\n\n\t\t\t// Compare the value in EAX to the value in EBX\n\n        cmp( eax, ebx );\n\n// Branch to label EAXequalsEBX if EAX==EBX\n\n        je EAXequalsEBX;\n\n        mov( 4, ebx );      // Drop down here if EAX != EBX\n            .\n            .\n            .\nEAXequalsEBX:\n```", "```\n\n\t\t\treadonly\n    jmpTable: dword[4] := [&label1, &label2, &label3, &label4];\n            .\n            .\n            .\n        jmp( jmpTable[ ebx*4 ] );\n```", "```\n\n\t\t\tcmp( ebx, 0 );\nje label1;\ncmp( ebx, 1 );\nje label2;\ncmp( ebx, 2 );\nje label3;\ncmp( ebx, 3 );\nje label4;\n\n// Results are undefined if EBX <> 0, 1, 2, or 3\n```", "```\n\n\t\t\tif( a == b || c < d )\n{\n    << execute some number of statements >>\n\n    if( x == y )\n    {\n        << execute some statements if x == y >>\n    }\n    else\n    {\n        << execute some statements if x != y >>\n    }\n}\nelse\n{\n    << execute the same sequence of statements\n       that the code executes if x!= y in the\n       previous else section >>\n}\n```", "```\n\n\t\t\tif( a == b || c < d )\n{\n    << execute some number of statements >>\n\n    if( x != y ) goto DuplicatedCode;\n\n    << execute some statements if x == y >>\n}\nelse\n{\nDuplicatedCode:\n    << execute the same sequence of statements\n       if x != y or the original\n       Boolean expression is false >>\n}\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int a;\nstatic int b;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\nint main( void )\n{\n    if( a==f(x))\n    {\n        if( b==g(y))\n        {\n            a=0;\n        }\n        else\n        {\n            printf( \"%d %d\\n\", a, b );\n            a=1;\n            b=0;\n        }\n    }\n    else\n    {\n        printf( \"%d %d\\n\", a, b );\n        a=1;\n        b=0;\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\t        ; f(x):\n\n        lwz r3,0(r9)\n        bl L_f$stub\n\n        ; Compute a==f(x), jump to L2 if false\n\n        lwz r4,0(r30)\n        cmpw cr0,r4,r3\n        bne+ cr0,L2\n\n        ; g(y):\n\n        addis r9,r31,ha16(L_y$non_lazy_ptr-L1$pb)\n        addis r29,r31,ha16(_b-L1$pb)\n        lwz r9,lo16(L_y$non_lazy_ptr-L1$pb)(r9)\n        la r29,lo16(_b-L1$pb)(r29)\n        lwz r3,0(r9)\n        bl L_g$stub\n\n        ; Compute b==g(y), jump to L3 if false:\n\n        lwz r5,0(r29)\n        cmpw cr0,r5,r3\n        bne- cr0,L3\n\n        ; a=0\n        li r0,0\n        stw r0,0(r30)\n        b L5\n\n        ; Set up a and b parameters if\n        ; a==f(x) but b!=g(y):\n\nL3:\n        lwz r4,0(r30)\n        addis r3,r31,ha16(LC0-L1$pb)\n        b L6\n\n        ; Set up parameters if a!=f(x):\nL2:\n        addis r29,r31,ha16(_b-L1$pb)\n        addis r3,r31,ha16(LC0-L1$pb)\n        la r29,lo16(_b-L1$pb)(r29)\n        lwz r5,0(r29)\n\n        ; Common code shared by both\n        ; ELSE sections:\nL6:\n        la r3,lo16(LC0-L1$pb)(r3) ; Call printf\n        bl L_printf$stub\n        li r9,1                 ; a=1\n        li r0,0                 ; b=0\n        stw r9,0(r30)           ; Store a\n        stw r0,0(r29)           ; Store b\nL5:\n```", "```\n\n\t\t\tswitch( a == b || c < d )\n{\n    case 1:\n        << execute some number of statements >>\n\n        if( x == y )\n        {\n            << execute some statements if x == y >>\n            break;\n        }\n        // Fall through if x != y\n\n    case 0:\n\n        << execute some statements if x!= y or\n            if !( a == b || c < d )  >>\n}\n```", "```\n\n\t\t\tif( EAX = EBX ) then begin\n\n    writeln( 'EAX is equal to EBX' );\n    i := i + 1;\n\nend;\n```", "```\n\n\t\t\t    cmp( EAX, EBX );\n    jne skipIfBody;\n    stdout.put( \"EAX is equal to EBX\", nl );\n    inc( i );\nskipIfBody:\n```", "```\n\n\t\t\tif( some_boolean_expression ) then\n\n    << Statements to execute if the expression is true >>\n\nelse\n\n    << Statements to execute if the expression is false >>\n\nendif\n```", "```\n\n\t\t\tif( EAX == EBX )\n{\n    printf( \"EAX is equal to EBX\\n\" );\n    ++i;\n}\nelse\n{\n    printf( \"EAX is not equal to EBX\\n\" );\n}\n```", "```\n\n\t\t\t    cmp( EAX, EBX );        // See if EAX == EBX\n    jne doElse;             // Branch around \"then\" code\n    stdout.put( \"EAX is equal to EBX\", nl );\n    inc( i );\n    jmp skipElseBody;        // Skip over \"else\" section.\n\n// if they are not equal.\n\ndoElse:\n    stdout.put( \"EAX is not equal to EBX\", nl );\n\nskipElseBody:\n```", "```\n\n\t\t\tif( EAX = EBX ) then\n\n    stdout.put( \"EAX is equal to EBX\" nl );\n    inc( i );\n\nelseif( EAX = ECX ) then\n\n    stdout.put( \"EAX is equal to ECX\" nl );\n\nelse\n\n    stdout.put( \"EAX is not equal to EBX or ECX\" nl);\n\nendif;\n```", "```\n\n\t\t\t// Test to see if EAX = EBX\n\n    cmp( eax, ebx );\n    jne tryElseif;    // Skip \"then\" section if equal\n\n    // Start of the \"then\" section\n\n    stdout.put( \"EAX is equal to EBX\", nl );\n    inc( i );\n    jmp skipElseBody  // End of \"then\" section, skip\n                      // over the elseif clause.\ntryElseif:\n    cmp( eax, ecx );  // ELSEIF test for EAX = ECX\n    jne doElse;       // Skip \"then\" clause if not equal\n\n    // elseif \"then\" clause\n\n    stdout.put( \"EAX is equal to ECX\", nl );\n    jmp skipElseBody; // Skip over the \"else\" section\n\ndoElse: // else clause begins here\n    stdout.put( \"EAX is not equal to EBX or ECX\", nl );\n\nskipElseBody:\n```", "```\n\n\t\t\t// if( eax == ebx ) then\n//    //<likely case>\n//    stdout.put( \"EAX is equal to EBX\", nl );\n// else\n//    // unlikely case\n//    stdout.put( \"EAX is not equal to EBX\" nl );\n// endif;\n\n    cmp( EAX, EBX );\n    jne goDoElse;\n    stdout.put( \"EAX is equal to EBX\", nl );\nbackFromElse:\n        .\n        .\n        .\n// Somewhere else in the code (not in the direct path of the above):\n\ngoDoElse:\n    stdout.put( \"EAX is not equal to EBX\", nl );\n    jmp backFromElse\n```", "```\n\n\t\t\tif( eax != ebx ) goto doElseStuff;\n\n    // << body of the if statement goes here>>\n    // (statements between then and else)\nendOfIF:\n// << statements following the if..endif statement >>\n    .\n    .\n    .\n// Somewhere outside the direct execution path of the above\n\ndoElseStuff:\n    << Code to do if the expression is false >>\n    goto endOfIF;\n```", "```\n\n\t\t\tif( eax == ebx )\n{\n    // Set i to some value along this execution path.\n\n    i = j+5;\n}\nelse\n{\n    // Set i to a different value along this path\n\n    i = 0;\n}\n```", "```\n\n\t\t\t        cmp( eax, ebx );\n        jne doElse;\n        mov( j, edx );\n        add( 5, edx );\n        mov( edx, i );\n        jmp ifDone;\n\ndoElse:\n        mov( 0, i );\nifDone:\n```", "```\n\n\t\t\ti = 0;\nif( eax == ebx )\n{\n    i = j + 5;\n}\n```", "```\n\n\t\t\t        mov( 0, i );\n        cmp( eax, ebx );\n        jne skipIf;\n        mov( j, edx );\n        add( 5, edx );\n        mov( edx, i );\nskipIf:\n```", "```\n\n\t\t\tif( (i < g(y)) and (k > f(x)) ) then begin\n\n    i := 0;\n\nend;\n```", "```\n\n\t\t\tlexpr := i < g(y);\nrexpr := k > f(x);\nif( lexpr AND rexpr ) then begin\n\n    i := 0;\n\nend;\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    int lExpr;\n    int rExpr;\n\n    lExpr = i < g(y);\n    rExpr = k > f(x);\n    if( lExpr && rExpr )\n    {\n        printf( \"Hello\" );\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tmain    PROC\n\n$LN7:\n        mov     QWORD PTR [rsp+8], rbx\n        push    rdi\n        sub     rsp, 32                                 ; 00000020H\n\n; eax = g(y)\n        mov     ecx, DWORD PTR y\n        call    g\n; ebx (lExpr) = i < g(y)\n        xor     edi, edi\n        cmp     DWORD PTR i, eax\n        mov     ebx, edi ; ebx = 0\n        setl    bl ;if i < g(y), set EBX to 1.\n\n; eax = f(x)\n        mov     ecx, DWORD PTR x\n        call    f\n\n; EDI = k > f(x)\n\n        cmp     DWORD PTR k, eax\n        setg    dil ; Sets EDI to 1 if k > f(x)\n\n; See if lExpr is false:\n\n        test    ebx, ebx\n        je      SHORT $LN4@main\n\n; See if rExpr is false:\n\n        test    edi, edi\n        je      SHORT $LN4@main\n\n; \"then\" section of the if statement:\n\n        lea     rcx, OFFSET FLAT:$SG7893\n        call    printf\n $LN4@main:\n\n; return(0);\n        xor     eax, eax\n\n        mov     rbx, QWORD PTR [rsp+48]\n        add     rsp, 32                                 ; 00000020H\n        pop     rdi\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    if( i < g(y) && k > f(x) )\n    {\n        printf( \"Hello\" );\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tmain    PROC\n\n$LN7:\n        sub     rsp, 40                                 ; 00000028H\n\n; if (!(i < g(y))) then bail on the rest of the code:\n\n        mov     ecx, DWORD PTR y\n        call    g\n        cmp     DWORD PTR i, eax\n        jge     SHORT $LN4@main\n\n; if (!(k > f(x))) then skip printf:\n\n        mov     ecx, DWORD PTR x\n        call    f\n        cmp     DWORD PTR k, eax\n        jle     SHORT $LN4@main\n\n; Here's the body of the if statement.\n\n        lea     rcx, OFFSET FLAT:$SG7891\n        call    printf\n$LN4@main:\n\n; return 0\n        xor     eax, eax\n\n        add     rsp, 40                                 ; 00000028H\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    if( i < g(y) & k > f(x) )\n    {\n        printf( \"Hello\" );\n    }\n    return( 0 );\n}\n```", "```\n\n\t\t\tmain    PROC\n\n$LN6:\n        mov     QWORD PTR [rsp+8], rbx\n        push    rdi\n        sub     rsp, 32                                 ; 00000020H\n\n        mov     ecx, DWORD PTR x\n        call    f\n        mov     ecx, DWORD PTR y\n        xor     edi, edi\n        cmp     DWORD PTR k, eax\n        mov     ebx, edi\n        setg    bl\n        call    g\n        cmp     DWORD PTR i, eax\n        setl    dil\n        test    edi, ebx\n        je      SHORT $LN4@main\n\n        lea     rcx, OFFSET FLAT:$SG7891\n        call    printf\n$LN4@main:\n\n        xor     eax, eax\n\n        mov     rbx, QWORD PTR [rsp+48]\n        add     rsp, 32                                 ; 00000020H\n        pop     rdi\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\t#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n\nint main( int argc, char **argv )\n{\n    int boolResult;\n\n    boolResult = !!argc;\n    printf( \"!!(argc) = %d\\n\", boolResult );\n    return 0;\n}\n```", "```\n\n\t\t\tmain    PROC\n$LN4:\n        sub     rsp, 40      ; 00000028H\n\n        xor     edx, edx     ; EDX = 0\n        test    ecx, ecx     ; System passes ARGC in ECX register\n        setne   dl           ; If ECX==0, sets EDX=1, else EDX=0\n\n        lea     rcx, OFFSET FLAT:$SG7886 ; Zero flag unchanged!\n        call    printf       ; printf parm1 in RCX, parm2 in EDX\n\n; Return 0;\n        xor     eax, eax\n\n        add     rsp, 40                   ; 00000028H\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\tif( (ptrVar <> NIL) AND (ptrVar^ < 0) ) then begin\n\n    ptrVar^ := 0;\n\nend;\n```", "```\n\n\t\t\tif( ptrVar <> NIL ) then begin\n\n    if( ptrVar^ < 0 ) then begin\n\n        ptrVar^ := 0;\n end;\n\nend;\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    if( i < g(y) || k > f(x) )\n    {\n        printf( \"Hello\" );\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tmain    PROC\n\n$LN8:\n        sub     rsp, 40             ; 00000028H\n\n        mov     ecx, DWORD PTR y\n        call    g\n        cmp     DWORD PTR i, eax\n        jl      SHORT $LN3@main\n        mov     ecx, DWORD PTR x\n        call    f\n        cmp     DWORD PTR k, eax\n        jle     SHORT $LN6@main\n$LN3@main:\n\n        lea     rcx, OFFSET FLAT:$SG6880\n        call    printf\n$LN6@main:\n\n        xor     eax, eax\n\n        add     rsp, 40              ; 00000028H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    int temp;\n\n        // Compute left subexpression and\n        // save.\n\n    temp = i < g(y);\n\n        // If the left subexpression\n        // evaluates to false, then try\n        // the right subexpression.\n\n    if( !temp )\n    {\n        temp = k > f(x);\n    }\n\n        // If either subexpression evaluates\n        // to true, then print \"Hello\"\n\n    if( temp )\n    {\n        printf( \"Hello\" );\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tmain    PROC\n\n$LN9:\n        sub     rsp, 40         ; 00000028H\n\n        mov     ecx, DWORD PTR y\n        call    g\n        xor     ecx, ecx\n        cmp     DWORD PTR i, eax\n        setl    cl\n        test    ecx, ecx\n\n        jne     SHORT $LN7@main\n\n        mov     ecx, DWORD PTR x\n        call    f\n        xor     ecx, ecx\n        cmp     DWORD PTR k, eax\n        setg    cl\n        test    ecx, ecx\n\n        je      SHORT $LN5@main\n$LN7@main:\n\n        lea     rcx, OFFSET FLAT:$SG6881\n        call    printf\n$LN5@main:\n\n        xor     eax, eax\n\n        add     rsp, 40            ; 00000028H\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    if( i < g(y)) goto IntoIF;\n    if( k > f(x) )\n    {\n      IntoIF:\n\n        printf( \"Hello\" );\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tmain    PROC\n\n$LN8:\n        sub     rsp, 40         ; 00000028H\n\n        mov     ecx, DWORD PTR y\n        call    g\n        cmp     DWORD PTR i, eax\n        jl      SHORT $IntoIF$9\n\n        mov     ecx, DWORD PTR x\n        call    f\n        cmp     DWORD PTR k, eax\n        jle     SHORT $LN6@main\n$IntoIF$9:\n\n        lea     rcx, OFFSET FLAT:$SG6881\n        call    printf\n$LN6@main:\n\n        xor     eax, eax\n\n        add     rsp, 40         ; 00000028H\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\tswitch( expression )\n{\n  case 0:\n    << statements to execute if the\n       expression evaluates to 0 >>\n    break;\n\n  case 1:\n    << statements to execute if the\n       expression evaluates to 1 >>\n    break;\n\n  case 2:\n    << statements to execute if the\n       expression evaluates to 2>>\n    break;\n\n  <<etc>>\n\n  default:\n    << statements to execute if the expression is\n       not equal to any of these cases >>\n}\n```", "```\n\n\t\t\tcase ( expression ) of\n  0: begin\n    << statements to execute if the\n       expression evaluates to 0 >>\n    end;\n\n  1: begin\n    << statements to execute if the\n       expression evaluates to 1 >>\n    end;\n\n  2: begin\n    << statements to execute if the\n       expression evaluates to 2>>\n    end;\n\n  <<etc>>\n\n  else\n    << statements to execute if\n       REG32 is not equal to any of these cases >>\n\nend; (* case *)\n```", "```\n\n\t\t\tswitch( REG32 )\n\n  case( 0 )\n    << statements to execute if\n       REG32 contains 0 >>\n\n  case( 1 )\n    << statements to execute\n       REG32 contains 1 >>\n\n  case( 2 )\n    << statements to execute if\n       REG32 contains 2>>\n\n  <<etc>>\n\n  default\n    << statements to execute if\n       REG32 is not equal to any of these cases >>\n\nendswitch;\n```", "```\n\n\t\t\tif( expression = 0 ) then begin\n\n  << statements to execute if expression is 0 >>\n\nend\nelse if( expression = 1 ) then begin\n\n  << statements to execute if expression is 1 >>\n\nend\nelse if( expression = 2 ) then begin\n\n  << statements to execute if expression is 2 >>\n\nend\nelse\n  << statements to execute if expression is not 1 or 2 >>\n\nend;\n```", "```\n\n\t\t\t// Conversion of\n//    switch(i)\n//    { case 0:...case 1:...case 2:...case 3:...}\n// into assembly\n\nstatic\n  jmpTable: dword[4] :=\n    [ &label0, &label1, &label2, &label3 ];\n      .\n      .\n      .\n    // jmps to address specified by jmpTable[i]\n\n    mov( i, eax );\n    jmp( jmpTable[ eax*4 ] );\n\nlabel0:\n    << code to execute if i = 0 >>\n    jmp switchDone;\n\nlabel1:\n    << code to execute if i = 1 >>\n    jmp switchDone;\n\nlabel2:\n    << code to execute if i = 2 >>\n    jmp switchDone;\n\nlabel3:\n    << code to execute if i = 3 >>\n\nswitchDone:\n  << Code that follows the switch statement >>\n```", "```\n\n\t\t\tcase( i ) of\n\n  0: begin\n      << statements to execute if i = 0 >>\n     end;\n\n  1: begin\n      << statements to execute if i = 1 >>\n     end;\n  5: begin\n      << statements to execute if i = 5 >>\n     end;\n\n  8: begin\n      << statements to execute if i = 8 >>\n     end;\n\nend; (* case *)\n```", "```\n\n\t\t\t// Conversion of\n//    switch(i)\n//    { case 0:...case 1:...case 5:...case 8:}\n// into assembly\n\nstatic\n  jmpTable: dword[9] :=\n          [\n            &label0, &label1, &switchDone,\n            &switchDone, &switchDone,\n            &label5, &switchDone, &switchDone,\n            &label8\n          ];\n      .\n      .\n      .\n    // jumps to address specified by jmpTable[i]\n\n    mov( i, eax );\n    jmp( jmpTable[ eax*4 ] );\n\nlabel0:\n    << code to execute if i = 0 >>\n    jmp switchDone;\n\nlabel1:\n    << code to execute if i = 1 >>\n    jmp switchDone;\nlabel5:\n    << code to execute if i = 5 >>\n    jmp switchDone;\n\nlabel8:\n    << code to execute if i = 8 >>\n\nswitchDone:\n  << Code that follows the switch statement >>\n```", "```\n\n\t\t\t// Conversion of\n//    switch(i)\n//    { case 0:...case 1:...case 5:...case 8:}\n// into assembly, that automatically\n// handles values greater than 8.\n\nstatic\n  jmpTable: dword[9] :=\n          [\n            &label0, &label1, &switchDone,\n            &switchDone, &switchDone,\n            &label5, &switchDone, &switchDone,\n            &label8\n          ];\n      .\n      .\n      .\n    // Check to see if the value is outside the range\n    // of values allowed by this switch/case stmt.\n\n    mov( i, eax );\n    cmp( eax, 8 );\n    ja switchDone;\n\n    // jmps to address specified by jmpTable[i]\n\n    jmp( jmpTable[ eax*4 ] );\n\n      .\n      .\n      .\n\nswitchDone:\n  << Code that follows the switch statement >>\n```", "```\n\n\t\t\t// Conversion of\n//    switch(i)\n//    { case 10:...case 11:...case 12:...case 15:...case 16:}\n// into assembly, that automatically handles values\n// greater than 16 and values less than 10.\n\nstatic\n  jmpTable: dword[7] :=\n          [\n            &label10, &label11, &label12,\n            &switchDone, &switchDone,\n            &label15, &label16\n          ];\n      .\n      .\n      .\n    // Check to see if the value is outside the\n    // range 10..16.\n\n    mov( i, eax );\n    cmp( eax, 10 );\n    jb switchDone;\n    cmp( eax, 16 );\n    ja switchDone;\n\n    // The \"- 10*4\" part of the following expression\n    // adjusts for the fact that EAX starts at 10\n    // rather than 0, but we still need a zero-based\n    // index into our array.\n\n    jmp( jmpTable[ eax*4 - 10*4] );\n\n      .\n      .\n      .\n\nswitchDone:\n  << Code that follows the switch statement >>\n```", "```\n\n\t\t\tswitch( i )\n{\n  case 0:\n      << statements to execute if i == 0 >>\n      break;\n\n  case 1:\n      << statements to execute if i == 1 >>\n      break;\n\n  case 10:\n      << statements to execute if i == 10 >>\n      break;\n\n  case 100:\n      << statements to execute if i == 100 >>\n      break;\n\n  case 1000:\n      << statements to execute if i == 1000 >>\n      break;\n\n  case 10000:\n      << statements to execute if i == 10000 >>\n      break;\n}\n```", "```\n\n\t\t\tcase( i ) of\n  0: begin\n      << statements to execute if i = 0 >>\n     end;\n\n  1: begin\n      << statements to execute if i = 1 >>\n     end;\n\n  2: begin\n      << statements to execute if i = 2 >>\n     end;\n\n  3: begin\n      << statements to execute if i = 3 >>\n     end;\n\n  4: begin\n      << statements to execute if i = 4 >>\n     end;\n\n  1000: begin\n      << statements to execute if i = 1000 >>\n        end;\nend; (* case *)\n```", "```\n\n\t\t\t    mov( i, eax );\n    cmp( eax, 4 );\n    ja try1000;\n    jmp( jmpTable[ eax*4 ] );\n      .\n      .\n      .\ntry1000:\n    cmp( eax, 1000 );\n    jne switchDone;\n    << code to do if i = 1000 >>\nswitchDone:\n```", "```\n\n\t\t\textern void f( void );\nextern void g( void );\nextern void h( void );\nint main( int argc, char **argv )\n{\n    int boolResult;\n\n    switch( argc )\n    {\n        case 1:\n            f();\n            break;\n\n        case 2:\n            g();\n            break;\n\n        case 10:\n            h();\n            break;\n\n        case 11:\n            f();\n            break;\n    }\n    return 0;\n}\n```", "```\n\n\t\t\t_main   proc    near\n?live1@0:\n   ;\n   ;    int main( int argc, char **argv )\n   ;\n@1:\n    push      ebp\n    mov       ebp,esp\n   ;\n   ;    {\n   ;        int boolResult;\n   ;\n   ;        switch( argc )\n   ;\n\n; Is argc == 1?\n\n    mov       eax,dword ptr [ebp+8]\n    dec       eax\n    je        short @7\n\n; Is argc == 2?\n\n    dec       eax\n    je        short @6\n\n; Is argc == 10?\n\n    sub       eax,8\n    je        short @5\n\n; Is argc == 11?\n\n    dec       eax\n    je        short @4\n\n; If none of the above\n\n    jmp       short @2\n   ;\n   ;        {\n   ;            case 1:\n   ;                f();\n   ;\n@7:\n    call      _f\n   ;\n   ;                break;\n   ;\n    jmp       short @8\n   ;\n   ;\n   ;            case 2:\n   ;                g();\n   ;\n@6:\n    call      _g\n   ;\n   ;                break;\n   ;\n    jmp       short @8\n   ;\n   ;\n   ;            case 10:\n   ;                h();\n   ;\n@5:\n    call      _h\n   ;\n   ;                break;\n   ;\n    jmp       short @8\n   ;\n   ;\n   ;            case 11:\n   ;                f();\n   ;\n@4:\n    call      _f\n   ;\n   ;                break;\n   ;\n   ;        }\n   ;        return 0;\n   ;\n@2:\n@8:\n    xor       eax,eax\n   ;\n   ;    }\n   ;\n@10:\n@9:\n    pop       ebp\n    ret\n_main   endp\n```", "```\n\n\t\t\t#include <stdio.h>\n\nextern void f( void );\nint main( int argc, char **argv )\n{\n    int boolResult;\n\n    switch( argc )\n    {\n        case 1:\n            f();\n            break;\n\n        case 10:\n            f();\n            break;\n\n        case 100:\n            f();\n            break;\n\n        case 1000:\n            f();\n            break;\n\n        case 10000:\n            f();\n            break;\n\n        case 100000:\n            f();\n            break;\n\n        case 1000000:\n            f();\n            break;\n\n        case 10000000:\n            f();\n            break;\n\n        case 100000000:\n            f();\n            break;\n\n        case 1000000000:\n            f();\n            break;\n    }\n    return 0;\n}\n```", "```\n\n\t\t\tmain    PROC\n\n$LN18:\n        sub     rsp, 40                                 ; 00000028H\n\n; >+ 100,000?\n        cmp     ecx, 100000                             ; 000186a0H\n        jg      SHORT $LN15@main\n        je      SHORT $LN10@main\n\n; handle cases where argc is less than 100,000\n;\n; Check for argc = 1\n\n        sub     ecx, 1\n        je      SHORT $LN10@main\n\n; check for argc = 10\n\n        sub     ecx, 9\n        je      SHORT $LN10@main\n\n;check for argc = 100\n\n        sub     ecx, 90                                 ; 0000005aH\n        je      SHORT $LN10@main\n\n; check for argc = 1000\n\n        sub     ecx, 900                                ; 00000384H\n        je      SHORT $LN10@main\n\n; check for argc = 1000\n        cmp     ecx, 9000                               ; 00002328H\n\n        jmp     SHORT $LN16@main\n$LN15@main:\n\n; Check for argc = 100,000\n\n      cmp     ecx, 1000000                              ; 000f4240H\n        je      SHORT $LN10@main\n\n; check for argc = 1,000,000\n        cmp     ecx, 10000000                           ; 00989680H\n        je      SHORT $LN10@main\n\n; check for argc = 10,000,000\n        cmp     ecx, 100000000                          ; 05f5e100H\n        je      SHORT $LN10@main\n\n; check for argc = 100,000,000\n\n        cmp     ecx, 1000000000                         ; 3b9aca00H\n$LN16@main:\n        jne     SHORT $LN2@main\n$LN10@main:\n\n        call    f\n$LN2@main:\n\n        xor     eax, eax\n\n        add     rsp, 40                                 ; 00000028H\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\t_main   PROC\n\n        mov     eax, DWORD PTR _argc$[esp-4] ; argc is passed on stack in 32-bit code\n\n; Start with >100,000, = 100,000, or < 100,000\n\n        cmp     eax, 100000                  ; 000186a0H\n        jg      SHORT $LN15@main             ; Go if >100,000\n        je      SHORT $LN4@main              ; Match if equal\n\n; Handle cases where argc < 100,000\n;\n; Divide it into >100 and < 100\n\n        cmp     eax, 100                     ; 00000064H\n        jg      SHORT $LN16@main             ; Branch if > 100\n        je      SHORT $LN4@main              ; = 100\n\n; Down here if < 100\n\n        sub     eax, 1\n        je      SHORT $LN4@main              ; branch if it was 1\n\n        sub     eax, 9                       ; Test for 10\n        jmp     SHORT $LN18@main\n\n; Come down here if >100 and <100,000\n$LN16@main:\n\n        cmp     eax, 1000                    ; 000003e8H\n        je      SHORT $LN4@main              ; Branch if 1000\n        cmp     eax, 10000                   ; 00002710H\n        jmp     SHORT $LN18@main             ; Handle =10,000 or not in range\n\n; Handle > 100,000 here.\n\n$LN15@main:\n        cmp     eax, 100000000               ; 05f5e100H\n        jg      SHORT $LN17@main             ; > 100,000,000\n        je      SHORT $LN4@main              ; = 100,000\n\n; Handle < 100,000,000 and > 100,000 here:\n\n        cmp     eax, 1000000                 ; 000f4240H\n        je      SHORT $LN4@main              ; =1,000,000\n        cmp     eax, 10000000                ; 00989680H\n\n        jmp     SHORT $LN18@main             ; Handle 10,000,000 or not in range\n\n; Handle > 100,000,000 here\n$LN17@main:\n; check for 1,000,000,000\n        cmp     eax, 1000000000              ; 3b9aca00H\n$LN18@main:\n        jne     SHORT $LN2@main\n$LN4@main:\n\n        call    _f\n$LN2@main:\n\n        xor     eax, eax\n\n        ret     0\n_main   ENDP\n```", "```\n\n\t\t\tpublic class Welcome\n{\n    public static void f(){}\n    public static void main( String[] args )\n    {\n        int i = 10;\n        switch (i)\n        {\n            case 1:\n                f();\n                break;\n\n            case 10:\n                f();\n                break;\n\n            case 100:\n                f();\n                break;\n\n            case 1000:\n                f();\n                break;\n\n            case 10000:\n                f();\n                break;\n\n            case 100000:\n                f();\n                break;\n\n            case 1000000:\n                f();\n                break;\n\n            case 10000000:\n                f();\n                break;\n\n            case 100000000:\n                f();\n                break;\n\n            case 1000000000:\n                f();\n                break;\n\n        }\n    }\n}\n\n// JBC output:\n\nCompiled from \"Welcome.java\"\npublic class Welcome extends java.lang.Object{\npublic Welcome();\n  Code:\n   0:   aload_0\n   1:   invokespecial   #1; //Method java/lang/Object.\"<init>\":()V\n   4:   return\n\npublic static void f();\n  Code:\n   0:   return\n\npublic static void main(java.lang.String[]);\n  Code:\n   0:   bipush  10\n   2:   istore_1\n   3:   iload_1\n   4:   lookupswitch{ //10\n        1: 96;\n        10: 102;\n        100: 108;\n        1000: 114;\n        10000: 120;\n        100000: 126;\n        1000000: 132;\n        10000000: 138;\n        100000000: 144;\n        1000000000: 150;\n        default: 153 }\n   96:  invokestatic    #2; //Method f:()V\n   99:  goto    153\n   102: invokestatic    #2; //Method f:()V\n   105: goto    153\n   108: invokestatic    #2; //Method f:()V\n   111: goto    153\n   114: invokestatic    #2; //Method f:()V\n   117: goto    153\n   120: invokestatic    #2; //Method f:()V\n   123: goto    153\n   126: invokestatic    #2; //Method f:()V\n   129: goto    153\n   132: invokestatic    #2; //Method f:()V\n   135: goto    153\n   138: invokestatic    #2; //Method f:()V\n   141: goto    153\n   144: invokestatic    #2; //Method f:()V\n   147: goto    153\n   150: invokestatic    #2; //Method f:()V\n   153: return\n}\n```", "```\n\n\t\t\tswitch( argc )\n    {\n        case 1:\n            f();\n            break;\n\n        case 2:\n            g();\n            break;\n\n        case 10:\n            h();\n            break;\n\n        case 11:\n            f();\n            break;\n\n    }\n```", "```\n\n\t\t\t; File t.c\n; Line 13\n;\n; Use ARGC as an index into the $L1240 table,\n; which returns an offset into the $L1241 table:\n\n    mov eax, DWORD PTR _argc$[esp-4]\n    dec eax         ; --argc, 1=0, 2=1, 10=9, 11=10\n    cmp eax, 10     ; Out of range of cases?\n    ja  SHORT $L1229\n    xor ecx, ecx\n    mov cl, BYTE PTR $L1240[eax]\n    jmp DWORD PTR $L1241[ecx*4]\n\n    npad    3\n$L1241:\n    DD  $L1232  ; cases that call f\n    DD  $L1233  ; cases that call g\n    DD  $L1234  ; cases that call h\n    DD  $L1229  ; Default case\n\n$L1240:\n    DB  0   ; case 1 calls f\n    DB  1   ; case 2 calls g\n    DB  3   ; default\n    DB  3   ; default\n    DB  3   ; default\n    DB  3   ; default\n    DB  3   ; default\n    DB  3   ; default\n    DB  3   ; default\n    DB  2   ; case 10 calls h\n    DB  0   ; case 11 calls f\n\n; Here is the code for the various cases:\n\n$L1233:\n; Line 19\n    call    _g\n; Line 31\n    xor eax, eax\n; Line 32\n    ret 0\n\n$L1234:\n; Line 23\n    call    _h\n; Line 31\n    xor eax, eax\n; Line 32\n    ret 0\n\n$L1232:\n; Line 27\n    call    _f\n$L1229:\n; Line 31\n    xor eax, eax\n; Line 32\n    ret 0\n```", "```\n\n\t\t\tmain    PROC\n\n$LN12:\n        sub     rsp, 40                                 ; 00000028H\n\n; ARGC is passed in ECX\n\n        sub     ecx, 1\n        je      SHORT $LN4@main  ; case 1\n        sub     ecx, 1\n        je      SHORT $LN5@main  ; case 2\n        sub     ecx, 8\n        je      SHORT $LN6@main  ; case 10\n        cmp     ecx, 1\n        jne     SHORT $LN10@main ; case 11\n$LN4@main:\n\n        call    f\n$LN10@main:\n\n        xor     eax, eax\n\n        add     rsp, 40                                 ; 00000028H\n        ret     0\n$LN6@main:\n\n        call    h\n\n        xor     eax, eax\n\n        add     rsp, 40                                 ; 00000028H\n        ret     0\n$LN5@main:\n\n        call    g\n\n        xor     eax, eax\n\n        add     rsp, 40                                 ; 00000028H\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\tif( i = 1000 ) then begin\n\n  << statements to execute if i = 1000 >>\n\nend\nelse begin\n\n  case( i ) of\n    0: begin\n        << statements to execute if i = 0 >>\n       end;\n\n    1: begin\n        << statements to execute if i = 1 >>\n       end;\n\n    2: begin\n        << statements to execute if i = 2 >>\n       end;\n\n    3: begin\n        << statements to execute if i = 3 >>\n       end;\n\n    4: begin\n        << statements to execute if i = 4 >>\n       end;\n  end; (* case *)\nend; (* if *)\n```", "```\n\n\t\t\tswitch( i )\n{\n  case 0:\n      << statements to execute if i == 0 >>\n      break;\n\n  case 1:\n      << statements to execute if i == 1 >>\n      break;\n\n  case 2:\n      << statements to execute if i == 2 >>\n      break;\n\n  case 3:\n      << statements to execute if i == 3 >>\n      break;\n\n  case 4:\n      << statements to execute if i == 4 >>\n     break;\n\n  default:\n    if( i == 1000 )\n    {\n      << statements to execute if i == 1000 >>\n    }\n    else\n    {\n      << Statements to execute if none of the cases match >>\n    }\n}\n```", "```\n\n\t\t\tif( i == 15 )\n{\n  // If i = 15 better than 50% of the time,\n  // then we only execute a single test\n  // better than 50% of the time:\n}\nelse if( i == 20 )\n{\n  // if i == 20 better than 25% of the time,\n  // then we only execute one or\n  // two comparisons 75% of the time.\n}\nelse if etc....\n```"]