- en: '![](../images/pg117.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-14.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">IF
    STATEMENTS AND CONDITIONAL EXPRESSIONS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the last chapter, you learned how to compile programs that execute a list
    of statements. But most C programs have a more complicated execution path; they
    often need to decide what statements to execute at runtime based on the current
    state of the program. The order in which a program executes statements is its
    *control flow*, and the language constructs that let you change a program’s control
    flow are called *control structures*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll implement your first control structure: <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements. You’ll also implement *conditional expressions*. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, conditional expressions let you control what code to run. For example,
    the conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0)
    ? 3 : 4</samp> evaluates to 3 if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and 4 otherwise.
    We laid a lot of the groundwork for <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions when we implemented the short-circuiting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    operators in [Chapter 4](chapter4.xhtml). We already have TACKY constructs that
    let us conditionally run or skip over code, so we don’t need to change any stages
    after TACKY generation. Let’s get started!'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add four tokens in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">if</samp> | A keyword indicating
    the start of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">else</samp> | A keyword indicating
    the start of the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause
    in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> | A question mark,
    the delimiter between the first and second operands in a conditional expression
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">:</samp> | A colon, the delimiter
    between the second and third operands in a conditional expression |'
  prefs: []
  type: TYPE_TB
- en: Once your lexer supports these four tokens, you can test it out.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll update the parser to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions. Because these are two distinct language
    constructs, we’ll handle them one at a time, beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing if Statements</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start by extending the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements.
    [Listing 6-1](chapter6.xhtml#list6-1) gives the updated definition of this node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: The definition
    for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp> constructor
    takes three arguments. The <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    expression, sometimes called the *controlling expression*, determines whether
    the body of the statement is executed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>
    statement is the first clause of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, which executes when the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    is nonzero. The second clause, the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statement, is optional. If it’s present, it executes when the result of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> is 0.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned in the previous chapter, each clause in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is itself a single statement. Although it may look like multiple statements,
    the body of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    like the one in [Listing 6-2](chapter6.xhtml#list6-2) is really a single compound
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    whose body is a compound statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t implemented compound statements yet, so at this point we can’t compile
    code like [Listing 6-2](chapter6.xhtml#list6-2). [Listing 6-3](chapter6.xhtml#list6-3)
    gives an example of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement that we can compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    that doesn’t contain any compound statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can also compile <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements nested inside other <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, like [Listing 6-4](chapter6.xhtml#list6-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    nested inside another</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the AST definition in [Listing 6-1](chapter6.xhtml#list6-1) doesn’t
    have an <samp class="SANS_TheSansMonoCd_W5Regular_11">else if</samp> construct,
    because an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement can
    have at most one <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause.
    An <samp class="SANS_TheSansMonoCd_W5Regular_11">else if</samp> clause is really
    just an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause that
    contains another <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement.
    Take [Listing 6-5](chapter6.xhtml#list6-5) as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    nested inside an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">clause</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s reformat this in a way that better reflects how it will be parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The AST for [Listing 6-5](chapter6.xhtml#list6-5) will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 6-6](chapter6.xhtml#list6-6) shows the changes to the grammar, which
    exactly mirror the changes to the AST.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: The grammar rules
    for statements, including</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can handle this new production rule with straightforward recursive descent
    parsing. Interestingly, this rule is ambiguous, but that ambiguity won’t pose
    any problems for our parser. Let’s take another look at [Listing 6-4](chapter6.xhtml#list6-4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to parse this listing that both follow our new grammar rule:
    we could group the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause
    with either the first or the second <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. In other words, we could parse this listing like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could parse it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The C standard clarifies that the first of these alternatives is correct; an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause should always
    be grouped with the closest <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. However, the grammar by itself doesn’t tell us which of these options
    to choose. This quirk of the grammar is called the *dangling else* ambiguity,
    and it can cause problems for parser generators that automatically convert formal
    grammars into parsing code.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the dangling else ambiguity isn’t an issue for handwritten recursive
    descent parsers like ours. Whenever we parse an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, we’ll look for an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    keyword right after the statement body; if we find one, we’ll go ahead and parse
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause. In cases
    like [Listing 6-4](chapter6.xhtml#list6-4), this means that we’ll end up parsing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause as part of
    the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, which
    is the correct behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and implement this production rule now; then, we’ll move on to conditional
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Conditional
    Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The conditional <samp class="SANS_TheSansMonoCd_W5Regular_11">: ?</samp> operator
    is a *ternary* operator, which takes three operands. In [Listing 6-7](chapter6.xhtml#list6-7),
    we add this operator to the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST node.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: The definition
    for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including conditional expressions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 6-8](chapter6.xhtml#list6-8), we add it to the <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    grammar rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: The grammar rule
    for expressions, including conditional expressions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to figure out its precedence and associativity. It’s not immediately
    obvious how precedence and associativity work for a ternary expression. The trick
    is to think of it as a binary expression where the operator in the middle is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"?" <exp> ":"</samp>. The “operator” is
    easy to parse because it’s delimited by <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> tokens; it just happens
    to include an entire subexpression. (You should think of it this way only during
    parsing, not during later stages. We can *parse* this like a binary expression,
    but we’ll *evaluate* it completely differently!) This lets us define the conditional
    operator’s precedence relative to other binary operators: it has higher precedence
    than assignment and lower precedence than everything else. For example, the expression'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: is parsed as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: but
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'is parsed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The same logic applies for the third operand. We parse
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: but we parse
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The semantic analysis pass will reject this last expression, since <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    ? 2 : a</samp> isn’t a valid lvalue. However, any expression can appear between
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>
    tokens, even an assignment expression. Those tokens act like parentheses, delimiting
    where an expression starts and ends. So, the conditional expression'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The same logic applies when you nest one conditional expression inside another,
    meaning
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'is parsed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s look at associativity. The conditional operator is right-associative,
    so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'is parsed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since conditional expressions can be parsed like weird binary expressions, we
    can (almost) handle them with our existing precedence climbing code. First, we’ll
    add <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> to our precedence table;
    [Table 6-1](chapter6.xhtml#tab6-1) lists all our precedence values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Binary and Ternary Operators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp> | <samp
    class="SANS_Futura_Std_Book_11">5</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: We look at only the first token of the <samp class="SANS_TheSansMonoCd_W5Regular_11">?
    <exp> :</samp> “operator” during precedence climbing, so <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    goes in the table but <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll update our precedence climbing code again. In the previous chapter,
    we handled assignment as a special case so we could use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    AST node for it. Now we’ll treat conditional expressions as a special case too.
    [Listing 6-9](chapter6.xhtml#list6-9) shows the updated precedence climbing pseudocode.
    Changes from the previous version of this algorithm, in [Listing 5-8](chapter5.xhtml#list5-8),
    are bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Precedence climbing
    with support for conditional expressions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_conditional_middle</samp>
    function, which I haven’t included code for here, should just consume the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp> token, then parse an expression
    (with the minimum precedence reset to 0), then consume the <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>
    token. Next, we parse the third operand the same way we parse the right-hand side
    of any other expression: by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    recursively. Since the conditional operator is right-associative, like assignment,
    we set the minimum precedence on the recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp>,
    not <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Finally, we construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">Conditional</samp>
    AST node from our three operands.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-10](chapter6.xhtml#list6-10) gives the complete AST definition,
    with the changes to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions bolded. These are the same changes we introduced
    earlier in this section; I’ve pulled them all together here for easier reference.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-10: The abstract
    syntax tree with conditional expressions and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-11](chapter6.xhtml#list6-11) shows the corresponding changes to
    the grammar.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-11: The grammar with
    conditional expressions and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve implemented these changes, you’re ready to test your parser.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variable Resolution</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The changes to this pass are minor. You’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> to handle
    the new constructs we added in this chapter, traversing their substatements and
    subexpressions. That will update variable names in <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions in exactly the same way as variables that
    appear in other constructs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can implement <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements
    and conditional expressions with our existing TACKY instructions. We’ll use the
    same basic approach here as for the short-circuiting <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators in [Chapter
    4](chapter4.xhtml): first we’ll evaluate the controlling expression, then we’ll
    use conditional jumps to go to the appropriate clause of the statement or expression.
    Let’s implement <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting if Statements
    to TACKY</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A statement of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)
    then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement></samp>
    should translate to the TACKY in [Listing 6-12](chapter6.xhtml#list6-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-12: The TACKY for
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! First, we evaluate the controlling expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>.
    If the result is 0, we jump to the end of the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Otherwise, we execute the instructions for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement></samp>.
    If the statement also has an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    clause, the resulting TACKY is only a tiny bit more complicated. The statement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">) then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement2></samp>
    translates to the TACKY in [Listing 6-13](chapter6.xhtml#list6-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-13: The TACKY for
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    with an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">clause</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Just like in [Listing 6-12](chapter6.xhtml#list6-12), we evaluate the controlling
    expression, then perform a conditional jump if the result is 0\. But instead of
    jumping to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, in this case we jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">else_label</samp>,
    then execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement2></samp>.
    If the controlling expression evaluates to a nonzero value, we execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement1></samp>,
    then jump to the end of the entire statement. We can handle conditional expressions
    in a similar way; we’ll look at those next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Conditional
    Expressions to TACKY</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For conditional expressions, like short-circuiting expressions, the C standard
    provides guarantees about which subexpressions are executed and when. To evaluate
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>,
    you have to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    first, then evaluate either <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>, depending
    on the result of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>.
    You can’t, for example, evaluate both clauses, then evaluate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    to decide which result to use, since that might produce unexpected side effects.
    The upshot is that we’ll handle conditional expressions very similarly to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. The only difference
    is that an expression, unlike a statement, produces a result that we need to store
    in the right destination. The expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><e1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><e2></samp>
    will produce the TACKY in [Listing 6-14](chapter6.xhtml#list6-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-14: The TACKY for
    a conditional expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This looks almost exactly like the TACKY in [Listing 6-13](chapter6.xhtml#list6-13).
    The only difference is that we end each clause by copying the result into the
    temporary <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> variable.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, all the labels and temporary variable names you generate while handling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional
    expressions should be unique. Once your TACKY generation stage is working, you’ll
    be able to compile this chapter’s test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Labeled Statements and
    goto</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have some practice adding new kinds of statements, you have the
    option to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>,
    the statement everyone loves to hate. You’ll also need to add support for labeled
    statements so that <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> has
    somewhere to go to. You can implement these two statements without changing anything
    after the TACKY generation stage; however, you’ll need to detect a few new error
    cases, like using the same label for two labeled statements in the same function.
    I recommend writing a new semantic analysis pass to catch these errors, rather
    than trying to catch them in the variable resolution stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test out this feature, run the test script with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--goto</samp>
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve implemented the extra credit features in the previous chapters as
    well, you can test all of them at once by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag instead.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve just implemented your first control structures! All your work in the
    early chapters is starting to pay off. The basic TACKY instructions you added
    to support <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    let you easily implement the more complex features in this chapter. You also built
    on the parsing techniques you learned earlier, extending your precedence climbing
    code to handle ternary operators. But the sorts of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements you can compile are still very limited; you can’t declare variables
    or execute longer blocks of code in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement body. In the next chapter, you’ll remove those limitations by adding
    support for compound statements. The most exciting changes will be in the semantic
    analysis stage, where you’ll learn how to deal with nested scopes.
  prefs: []
  type: TYPE_NORMAL
