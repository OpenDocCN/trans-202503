- en: '![](../images/pg117.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-14.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">IF
    STATEMENTS AND CONDITIONAL EXPRESSIONS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: In the last chapter, you learned how to compile programs that execute a list
    of statements. But most C programs have a more complicated execution path; they
    often need to decide what statements to execute at runtime based on the current
    state of the program. The order in which a program executes statements is its
    *control flow*, and the language constructs that let you change a program’s control
    flow are called *control structures*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll implement your first control structure: <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements. You’ll also implement *conditional expressions*. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, conditional expressions let you control what code to run. For example,
    the conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0)
    ? 3 : 4</samp> evaluates to 3 if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and 4 otherwise.
    We laid a lot of the groundwork for <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions when we implemented the short-circuiting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    operators in [Chapter 4](chapter4.xhtml). We already have TACKY constructs that
    let us conditionally run or skip over code, so we don’t need to change any stages
    after TACKY generation. Let’s get started!'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add four tokens in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">if</samp> | A keyword indicating
    the start of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">else</samp> | A keyword indicating
    the start of the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause
    in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> | A question mark,
    the delimiter between the first and second operands in a conditional expression
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">:</samp> | A colon, the delimiter
    between the second and third operands in a conditional expression |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: Once your lexer supports these four tokens, you can test it out.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll update the parser to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions. Because these are two distinct language
    constructs, we’ll handle them one at a time, beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing if Statements</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start by extending the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements.
    [Listing 6-1](chapter6.xhtml#list6-1) gives the updated definition of this node.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: The definition
    for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp> constructor
    takes three arguments. The <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    expression, sometimes called the *controlling expression*, determines whether
    the body of the statement is executed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>
    statement is the first clause of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, which executes when the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp>
    is nonzero. The second clause, the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statement, is optional. If it’s present, it executes when the result of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> is 0.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned in the previous chapter, each clause in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is itself a single statement. Although it may look like multiple statements,
    the body of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    like the one in [Listing 6-2](chapter6.xhtml#list6-2) is really a single compound
    statement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    whose body is a compound statement</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t implemented compound statements yet, so at this point we can’t compile
    code like [Listing 6-2](chapter6.xhtml#list6-2). [Listing 6-3](chapter6.xhtml#list6-3)
    gives an example of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement that we can compile.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    that doesn’t contain any compound statements</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: We can also compile <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements nested inside other <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, like [Listing 6-4](chapter6.xhtml#list6-4).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以编译嵌套在其他 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句内的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句，就像 [列表 6-4](chapter6.xhtml#list6-4)
    中那样。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    nested inside another</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-4：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句嵌套在另一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句内</samp>
- en: Note that the AST definition in [Listing 6-1](chapter6.xhtml#list6-1) doesn’t
    have an <samp class="SANS_TheSansMonoCd_W5Regular_11">else if</samp> construct,
    because an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement can
    have at most one <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause.
    An <samp class="SANS_TheSansMonoCd_W5Regular_11">else if</samp> clause is really
    just an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause that
    contains another <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement.
    Take [Listing 6-5](chapter6.xhtml#list6-5) as an example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[列表 6-1](chapter6.xhtml#list6-1) 中的 AST 定义没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">else
    if</samp> 构造，因为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句最多只能有一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 子句。<samp class="SANS_TheSansMonoCd_W5Regular_11">else
    if</samp> 子句实际上只是一个包含另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句的 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 子句。以 [列表 6-5](chapter6.xhtml#list6-5)
    为例。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: An</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    nested inside an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">clause</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-5：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句嵌套在一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">子句内</samp>
- en: 'Let’s reformat this in a way that better reflects how it will be parsed:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一种更能反映其解析方式的格式重新排版：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The AST for [Listing 6-5](chapter6.xhtml#list6-5) will look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-5](chapter6.xhtml#list6-5) 的 AST 将如下所示：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Listing 6-6](chapter6.xhtml#list6-6) shows the changes to the grammar, which
    exactly mirror the changes to the AST.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-6](chapter6.xhtml#list6-6) 显示了语法的变化，这些变化与抽象语法树（AST）的变化完全一致。'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: The grammar rules
    for statements, including</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-6：语句的语法规则，包括</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: 'We can handle this new production rule with straightforward recursive descent
    parsing. Interestingly, this rule is ambiguous, but that ambiguity won’t pose
    any problems for our parser. Let’s take another look at [Listing 6-4](chapter6.xhtml#list6-4):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的递归下降解析法来处理这个新的产生式规则。有趣的是，这个规则是模糊的，但这种模糊性不会对我们的解析器造成任何问题。让我们再看看 [列表
    6-4](chapter6.xhtml#list6-4)：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are two ways to parse this listing that both follow our new grammar rule:
    we could group the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause
    with either the first or the second <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. In other words, we could parse this listing like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以解析这个列表，两种方法都遵循我们新的语法规则：我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    子句与第一个或第二个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句组合在一起。换句话说，我们可以这样解析这个列表：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or we could parse it like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们也可以这样解析：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The C standard clarifies that the first of these alternatives is correct; an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause should always
    be grouped with the closest <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. However, the grammar by itself doesn’t tell us which of these options
    to choose. This quirk of the grammar is called the *dangling else* ambiguity,
    and it can cause problems for parser generators that automatically convert formal
    grammars into parsing code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the dangling else ambiguity isn’t an issue for handwritten recursive
    descent parsers like ours. Whenever we parse an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, we’ll look for an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    keyword right after the statement body; if we find one, we’ll go ahead and parse
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause. In cases
    like [Listing 6-4](chapter6.xhtml#list6-4), this means that we’ll end up parsing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause as part of
    the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, which
    is the correct behavior.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and implement this production rule now; then, we’ll move on to conditional
    expressions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Conditional
    Expressions</samp>
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The conditional <samp class="SANS_TheSansMonoCd_W5Regular_11">: ?</samp> operator
    is a *ternary* operator, which takes three operands. In [Listing 6-7](chapter6.xhtml#list6-7),
    we add this operator to the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST node.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: The definition
    for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including conditional expressions</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 6-8](chapter6.xhtml#list6-8), we add it to the <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    grammar rule.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: The grammar rule
    for expressions, including conditional expressions</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to figure out its precedence and associativity. It’s not immediately
    obvious how precedence and associativity work for a ternary expression. The trick
    is to think of it as a binary expression where the operator in the middle is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"?" <exp> ":"</samp>. The “operator” is
    easy to parse because it’s delimited by <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> tokens; it just happens
    to include an entire subexpression. (You should think of it this way only during
    parsing, not during later stages. We can *parse* this like a binary expression,
    but we’ll *evaluate* it completely differently!) This lets us define the conditional
    operator’s precedence relative to other binary operators: it has higher precedence
    than assignment and lower precedence than everything else. For example, the expression'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: is parsed as
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: but
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'is parsed as:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The same logic applies for the third operand. We parse
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: as
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: but we parse
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'as:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The semantic analysis pass will reject this last expression, since <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    ? 2 : a</samp> isn’t a valid lvalue. However, any expression can appear between
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>
    tokens, even an assignment expression. Those tokens act like parentheses, delimiting
    where an expression starts and ends. So, the conditional expression'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'is equivalent to:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The same logic applies when you nest one conditional expression inside another,
    meaning
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'is parsed as:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, let’s look at associativity. The conditional operator is right-associative,
    so
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'is parsed as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since conditional expressions can be parsed like weird binary expressions, we
    can (almost) handle them with our existing precedence climbing code. First, we’ll
    add <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> to our precedence table;
    [Table 6-1](chapter6.xhtml#tab6-1) lists all our precedence values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Binary and Ternary Operators</samp>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp> | <samp
    class="SANS_Futura_Std_Book_11">5</samp> |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp> | <samp
    class="SANS_Futura_Std_Book_11">5</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp>
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
- en: We look at only the first token of the <samp class="SANS_TheSansMonoCd_W5Regular_11">?
    <exp> :</samp> “operator” during precedence climbing, so <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    goes in the table but <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> doesn’t.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在优先级爬升中，我们只考虑 <samp class="SANS_TheSansMonoCd_W5Regular_11">? <exp> :</samp>
    的“操作符”的第一个标记，所以 <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> 放在表中而 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp> 不放。
- en: Next, we’ll update our precedence climbing code again. In the previous chapter,
    we handled assignment as a special case so we could use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    AST node for it. Now we’ll treat conditional expressions as a special case too.
    [Listing 6-9](chapter6.xhtml#list6-9) shows the updated precedence climbing pseudocode.
    Changes from the previous version of this algorithm, in [Listing 5-8](chapter5.xhtml#list5-8),
    are bolded.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将再次更新我们的优先级爬升代码。在上一章中，我们将赋值作为特殊情况处理，以便我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    AST 节点。现在，我们也将条件表达式视为特殊情况处理。[列表 6-9](chapter6.xhtml#list6-9) 显示了更新后的优先级爬升伪代码。与此算法的上一个版本，[列表
    5-8](chapter5.xhtml#list5-8)，相比，已经用粗体标记出来。
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Precedence climbing
    with support for conditional expressions</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-9：支持条件表达式的优先级爬升</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_conditional_middle</samp>
    function, which I haven’t included code for here, should just consume the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp> token, then parse an expression
    (with the minimum precedence reset to 0), then consume the <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>
    token. Next, we parse the third operand the same way we parse the right-hand side
    of any other expression: by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    recursively. Since the conditional operator is right-associative, like assignment,
    we set the minimum precedence on the recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp>,
    not <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Finally, we construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">Conditional</samp>
    AST node from our three operands.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_conditional_middle</samp>，这里没有包含代码，应该只消耗
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> 标记，然后解析表达式（将最小优先级重置为 0），然后消耗
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> 标记。接下来，我们像解析其他表达式的右侧一样解析第三个操作数：通过递归调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>。由于条件运算符是右结合的，就像赋值一样，我们在递归调用中将最小优先级设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp>，而不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。最后，我们从这三个操作数构造一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Conditional</samp> AST 节点。
- en: '[Listing 6-10](chapter6.xhtml#list6-10) gives the complete AST definition,
    with the changes to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions bolded. These are the same changes we introduced
    earlier in this section; I’ve pulled them all together here for easier reference.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-10: The abstract
    syntax tree with conditional expressions and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-11](chapter6.xhtml#list6-11) shows the corresponding changes to
    the grammar.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-11: The grammar with
    conditional expressions and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve implemented these changes, you’re ready to test your parser.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variable Resolution</samp>
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The changes to this pass are minor. You’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> to handle
    the new constructs we added in this chapter, traversing their substatements and
    subexpressions. That will update variable names in <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and conditional expressions in exactly the same way as variables that
    appear in other constructs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can implement <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements
    and conditional expressions with our existing TACKY instructions. We’ll use the
    same basic approach here as for the short-circuiting <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators in [Chapter
    4](chapter4.xhtml): first we’ll evaluate the controlling expression, then we’ll
    use conditional jumps to go to the appropriate clause of the statement or expression.
    Let’s implement <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements
    first.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting if Statements
    to TACKY</samp>
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A statement of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)
    then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement></samp>
    should translate to the TACKY in [Listing 6-12](chapter6.xhtml#list6-12).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-12: The TACKY for
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! First, we evaluate the controlling expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>.
    If the result is 0, we jump to the end of the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Otherwise, we execute the instructions for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement></samp>.
    If the statement also has an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    clause, the resulting TACKY is only a tiny bit more complicated. The statement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">) then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement2></samp>
    translates to the TACKY in [Listing 6-13](chapter6.xhtml#list6-13).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-13: The TACKY for
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    with an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">clause</samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Just like in [Listing 6-12](chapter6.xhtml#list6-12), we evaluate the controlling
    expression, then perform a conditional jump if the result is 0\. But instead of
    jumping to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, in this case we jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">else_label</samp>,
    then execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement2></samp>.
    If the controlling expression evaluates to a nonzero value, we execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><statement1></samp>,
    then jump to the end of the entire statement. We can handle conditional expressions
    in a similar way; we’ll look at those next.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Conditional
    Expressions to TACKY</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For conditional expressions, like short-circuiting expressions, the C standard
    provides guarantees about which subexpressions are executed and when. To evaluate
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>,
    you have to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    first, then evaluate either <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>, depending
    on the result of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>.
    You can’t, for example, evaluate both clauses, then evaluate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    to decide which result to use, since that might produce unexpected side effects.
    The upshot is that we’ll handle conditional expressions very similarly to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. The only difference
    is that an expression, unlike a statement, produces a result that we need to store
    in the right destination. The expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><e1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><e2></samp>
    will produce the TACKY in [Listing 6-14](chapter6.xhtml#list6-14).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-14: The TACKY for
    a conditional expression</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: This looks almost exactly like the TACKY in [Listing 6-13](chapter6.xhtml#list6-13).
    The only difference is that we end each clause by copying the result into the
    temporary <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> variable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: As usual, all the labels and temporary variable names you generate while handling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional
    expressions should be unique. Once your TACKY generation stage is working, you’ll
    be able to compile this chapter’s test cases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Labeled Statements and
    goto</samp>'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have some practice adding new kinds of statements, you have the
    option to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>,
    the statement everyone loves to hate. You’ll also need to add support for labeled
    statements so that <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> has
    somewhere to go to. You can implement these two statements without changing anything
    after the TACKY generation stage; however, you’ll need to detect a few new error
    cases, like using the same label for two labeled statements in the same function.
    I recommend writing a new semantic analysis pass to catch these errors, rather
    than trying to catch them in the variable resolution stage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'To test out this feature, run the test script with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--goto</samp>
    flag:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you’ve implemented the extra credit features in the previous chapters as
    well, you can test all of them at once by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve just implemented your first control structures! All your work in the
    early chapters is starting to pay off. The basic TACKY instructions you added
    to support <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    let you easily implement the more complex features in this chapter. You also built
    on the parsing techniques you learned earlier, extending your precedence climbing
    code to handle ternary operators. But the sorts of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements you can compile are still very limited; you can’t declare variables
    or execute longer blocks of code in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement body. In the next chapter, you’ll remove those limitations by adding
    support for compound statements. The most exciting changes will be in the semantic
    analysis stage, where you’ll learn how to deal with nested scopes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
