<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="35" id="Page_35"/>2</span><br/>
<span class="ChapterTitle">Reaching Out, Touching Me, Touching You: Hardware Peripheral Interfaces</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Most embedded devices use standardized communication interfaces to interact with other chips, users, and the world. Since those interfaces are generally low level, rarely externally accessible, and dependent on interoperability between different manufacturers, they generally don’t have any protections, obfuscations, or encryption applied to them. In this chapter, we’ll discuss some electrical basics that are helpful for understanding how these various interface types work.</p>
<p>After that, we’ll look at examples from three groups of communications interfaces: low-speed serial interfaces, parallel interfaces, and high-speed serial interfaces. The easiest to monitor or emulate are the <em>low-speed serial interfaces</em> used for most basic communications. Devices that require greater performance or bandwidth can be more difficult to interact with and tend to use <em>parallel interfaces</em>. Parallel interfaces are rapidly transitioning to <em>high-speed serial interfaces</em>, which can reliably run in the gigahertz range even on the cheapest embedded devices, but interacting with them often requires specialized hardware.</p>
<p><span epub:type="pagebreak" title="36" id="Page_36"/>When analyzing embedded systems, you need to be aware of the many interconnected components that need to communicate and then decide whether the components and communication channels are trusted. These interfaces are one of the most critical aspects of embedded security, and yet embedded systems designers often assume attackers don’t have physical access to these communication channels, so they assume they can trust any interface. This assumption provides attackers with an opportunity to listen in passively or participate actively, impacting the device’s security.</p>
<h2 id="h1-278748c02-0001">Electricity Basics</h2>
<p class="BodyFirst">When interacting with different kinds of interfaces, it’s helpful to understand some basic electricity terms. If you’re familiar with voltage, current, resistance, reactance, impedance, inductance, and capacitance, and if you know that AC/DC is not only the name of an Australian rock band, feel free to skip this section. (If you are unfamiliar with the Australian rock band AC/DC, we recommend getting started with the high-voltage song “Thunderstruck.”)</p>
<h3 id="h2-278748c02-0001">Voltage</h3>
<p class="BodyFirst">The<em> volt</em> (<em>V</em>, expressed in units V and named after Alessandro Volta) is the electrical unit of voltage. It refers to <em>electric potential</em>, or how hard the electrons are pushing to get from point A to point B. Think of voltage on a wire as analogous to water pressure in a hose, or how hard the water is pushing to get from point A to point B.</p>
<p>Voltage is always measured between two points. For example, if you take a multimeter and an AA battery, you can measure the voltage between negative and positive and observe that the differential is 1.5 V (if it’s lower than 1.3 V, it’s probably time to get a new battery). If you switch the two measurement probes, you’ll see a differential of –1.5 V.</p>
<p>When people mention only one point with regard to voltage, they are actually talking about the voltage of that point relative to the so-called <em>ground</em>. Ground is normally the common reference for a system; in such a case, ground is by definition at 0 V.</p>
<h3 id="h2-278748c02-0002">Current</h3>
<p class="BodyFirst">The <em>ampere</em> (<em>I</em>, expressed in units A and named after André-Marie Ampère) is the measure of <em>electrical flow </em>or <em>current</em>, which refers to the number of electrons moving past a certain point in a given amount of time. Current in a wire is analogous to water flow in a hose, but instead of measuring the water that passes through a cross section of the hose, with electrical circuits, you count the electrons that pass through a cross section of a wire. Everything else being equal, more water pressure means more water would flow through the hose in the same amount of time. Likewise, more voltage across a wire means more current would flow through it in the same amount of time.</p>
<p><span epub:type="pagebreak" title="37" id="Page_37"/>For humans, 100 mA is roughly what’s needed to stop their hearts, and in embedded devices, you can easily encounter currents of multiple amps. Luckily, the voltage needs to be much higher than the common voltages used in electronics in order to push that current through your body. Although both authors have lived through 110 V zaps to tell this story, the unpleasantness of those experiences leads us to recommend against touching live circuits, even when you think it’s a safe voltage.</p>
<h3 id="h2-278748c02-0003">Resistance</h3>
<p class="BodyFirst">The <em>ohm</em> (<em>R</em>, expressed in units Ω and named after Georg Simon Ohm) is the measure of <em>electrical resistance</em>, or how difficult it is for electrons to pass between two points. Continuing with the water flow analogy, resistance is comparable to how wide or narrow a hose is (or how clogged the inside of the hose might be).</p>
<h3 id="h2-278748c02-0004">Ohm’s Law</h3>
<p class="BodyFirst">Volts, amps, and ohms are closely related. <em>Ohm’s law</em> summarizes this relationship as <em>V</em> = <em>I </em>× <em>R</em>, which<em> </em>states that knowing any two parameters allows you to calculate the third parameter.</p>
<p>This means if you know the voltage on a wire (potential), as well as the ohm value of the wire (resistance), you can calculate the amperage across the wire (flow).</p>
<h3 id="h2-278748c02-0005">AC/DC</h3>
<p class="BodyFirst"><em>Direct current (DC)</em> and <em>alternating current (AC)</em> refer to constant and varying currents, respectively. Modern electronics are powered from DC sources, such as batteries and DC power supplies. AC is a sinusoidally varying voltage (and thus current), generally seen on the 240 V or 110 V power grid, but sinusoidally varying voltages are also used in electronic equipment, such as switched power supplies. In this book, we measure variations in current as determined by the varying activities in the device’s circuitry. The constant current consumption is the DC component of this measurement, and the variation of that supply current, in which we are very interested, is what can loosely be termed the AC component.</p>
<h3 id="h2-278748c02-0006">Picking Apart Resistance</h3>
<p class="BodyFirst"><em>Impedance</em> in AC is equivalent to resistance in DC. In AC, impedance is a complex number made up of resistance and reactance, and it depends on the AC signal’s frequency. <em>Reactance</em> is a function of inductance and capacitance.</p>
<p><em>Inductance </em>is the resistance (as in “objection”) by the circuit to a change in current. Returning to the water analogy, if water is flowing in one direction, it’ll take some energy to push the water in the opposite direction due to the flowing water’s kinetic energy. With inductance, this energy resides in the magnetic field around a wire that has current flowing through it, and it needs a “push” in the opposite direction before the <span epub:type="pagebreak" title="38" id="Page_38"/>current’s direction is reversed. Inductance causes a voltage proportional to the variation (change) in current. The unit of inductance is the <em>henry</em>, after Joseph Henry.</p>
<p><em>Capacitance </em>is the resistance to a change in voltage. Consider a vertical pipe connected to a tank and connected to a horizontal pipe with flowing water (see <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>).</p>
<figure>
<img src="image_fi/278748c02/f02001.png" alt="f02001"/>
<figcaption><p><a id="figure2-1">Figure 2-1</a>: If electricity is like water, a capacitor is like a water tank. On the left, the tank is “charging,” and on the right the tank is “discharging.”</p></figcaption>
</figure>
<p>While there is high input pressure on the pipe (<a href="#figure2-1">Figure 2-1</a>, left), water is constantly flowing into the tank, until it is full. If the pressure drops at the input, the tank starts to drain until it is empty. The analogy here is that the pressure in the vertical pipe relates to the voltage over the capacitor, and the amount of water in the tank relates to the charge held by the capacitor. If the voltage over the capacitor is high enough to “push the water level up,” the capacitor will take in charge. If it’s too low, the capacitor will “drain water” and release charge. Up to its capacity, the tank will counteract pressure changes at the output, and the capacitor will counteract voltage changes at the output. Capacitance is related to the ability of an electrical component to store charge, and it causes a current proportional to the variation (change) in voltage. The unit of capacitance is the <em>farad,</em> named for Michael Faraday.</p>
<h3 id="h2-278748c02-0007">Power</h3>
<p class="BodyFirst">Power is the amount of energy in <em>Joules</em> consumed per second, expressed as <em>P</em> in units of <em>W</em> (<em>watts</em>, after James Watt). In electronic circuits, this energy is almost exclusively turned into heat. This is called <em>power dissipation</em>, and the <em>power rule</em> for a given load, which is <em>P</em> = <em>I</em> × <em>I</em> × <em>R</em>, expresses it. The power dissipation <em>P</em> increases by the square of the current <em>I</em> and linearly with resistance <em>R</em>. This is called <em>static power consumption</em>. With Ohm’s law, we can also <span epub:type="pagebreak" title="39" id="Page_39"/>reformulate the power rule into measurements of current and voltage. Thus, we can measure power by measuring the current through a circuit and voltage across the load as <em>P</em> = <em>I</em> × <em>V</em>.</p>
<p>You may have observed that your computer gets hot when it does a lot of work: this is <em>dynamic power consumption</em>. In your CPU, lots of transistors are switching when it’s working, and that requires additional power (which your computer converts to heat, requiring you to move the laptop off the blankets). A digital gate is like a switch with a small series resistor, and every wire acts (approximately) as a small capacitor. When a digital gate drives the wire, it needs to charge and discharge that capacitor, which costs energy. The faster a digital gate switches from high to low and back to high, the harder the gate has to work, and the more power the gate will dissipate through the small series resistor.</p>
<p>More physics are at play than we want to describe in this book, but remember one rule, as it will relate to side-channel analysis later: if you model a wire as a capacitance <em>C</em>, switching a square wave between 0 V and <em>V</em> volt at frequency <em>f</em> requires <em>P</em> = <em>C</em> × <em>V</em> × <em>V</em> × <em>f</em>. In other words, switching faster, increasing voltage, or increasing capacitance each makes for more required power on a CPU, and that is something we can observe in a side channel.</p>
<h2 id="h1-278748c02-0002">Interface with Electricity</h2>
<p class="BodyFirst">Now that we’ve reviewed the basics, let’s explore how to use electricity to build a communications channel. The interfaces you encounter will use different electrical properties to be able to communicate in different ways, and each way has its own pros and cons.</p>
<h3 id="h2-278748c02-0008">Logic Levels</h3>
<p class="BodyFirst">In digital communication, parties exchange <em>symbols</em> (for example, the letters of the alphabet). The sender and listener agree on a set of symbols to represent letters and words. When using wires for communication, differences in voltage encode these symbols and send them from one side of the wire to the other. The other side can observe the voltage changes, reconstructing the symbols and thereby the message.</p>
<p>Morse code, one of the first means of communicating over wires, illustrates this principle. The symbols in Morse code are dots and dashes. Each symbol is mapped to a voltage level or shape. In Morse code, the dots are short high voltage pulses, and the dashes are long high voltage pulses.</p>
<p>When communicating via Morse code, the sender has a button, and the receiver has either a buzzer or a marker that writes on a paper tape. When the sender presses the button, the wire connects to a power source, which creates a voltage differential on the wire and causes the buzzer to buzz when it’s powered on the other end. Deriving words and letters means interpreting the sequence of dots and dashes and spaces (the short and long high-voltage pulses) with silence on the wire in between (see <a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a>).</p>
<span epub:type="pagebreak" title="40" id="Page_40"/><figure>
<img src="image_fi/278748c02/f02002.png" alt="f02002"/>
<figcaption><p><a id="figure2-2">Figure 2-2</a>: Morse code over the wire</p></figcaption>
</figure>
<p>In modern signaling schemes, the symbols are bits (ones and zeros). A complete communication scheme may also use additional special symbols (for example, to indicate the start and end of a transmission or to help detect transmission errors). You can represent a “one” bit with a high logic level and a “zero” bit with a low logic level. Let’s agree that 0 V represents a zero and that 5 V represents a one. However, because of resistance in the wire, you might not see a full 5 V on the other end, perhaps only 4.5 V. With that in mind, let’s agree that anything less than 0.8 V is a zero and anything greater than 2 V is a one, giving us a large margin of error to work with. If we were to switch to a lower voltage source that could output only 3.3 V, we could still talk, as long as we could create a voltage greater than 2 V.</p>
<p>The 0.8 V and 2 V parameters are the <em>switching thresholds</em> we have agreed upon. The most common set of thresholds you’re likely to see is the <em>transistor-transistor logic (TTL) </em>set of thresholds. The term TTL is often generically used to indicate that some low-voltage signals are present, where 0 V represents a logic zero, and a higher voltage (that would range from 1 V to 5 V, depending on the specific standard) represents a logic one.</p>
<p>Another reason for switching thresholds is that despite our depiction of perfect voltages, any analog system will have <em>noise</em> in it. This means even if the sender attempts to send a perfect 5 V, you may observe a signal that fluctuates between 4.7 V and 4.8 V, seemingly randomly, at the receiving end. This is noise. Noise is generated at the sender, captured from the ether during transmission and then measured at the receiving end. If our switching threshold is 2 V, this noise isn’t a big deal, and together with <em>error correcting codes</em>, communication is possible. The problem is when <em>adversarial noise</em> is introduced: instead of mother nature creating random noise, an attacker injects noise that confuses the receiving end into seeing an attacker-controlled message. This can silently corrupt communication unless <em>cryptographic signatures</em> are being used. Fault injection can be considered adversarial noise as well.</p>
<p>You actually could encounter many logic thresholds, and they may not all talk to each other intelligibly (see <a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a>).</p>
<p>Several voltage levels are defined in <a href="#figure2-3">Figure 2-3</a>. VCC is supply voltage, and when driving a one, the output voltage should be between VCC and V<sub>OH</sub><span epub:type="pagebreak" title="41" id="Page_41"/>, and for a zero, it should be between V<sub>OL</sub> and GND. On the receiver side, any signal between VCC and V<sub>IH</sub> should be interpreted as a one, and any signal between V<sub>IL</sub> and GND should be interpreted as a zero.</p>
<figure>
<img src="image_fi/278748c02/f02003.png" alt="f02003"/>
<figcaption><p><a id="figure2-3">Figure 2-3</a>: Different standard voltage thresholds. Legend: VCC = supply voltage, V<sub>OH</sub> = required minimum high output voltage, V<sub>IH</sub> = required minimum high input voltage, V<sub>IL</sub> = required maximum low input voltage, V<sub>OL</sub> = required maximum low output voltage, and GND = ground.</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p> 	When checking device datasheets, you are likely to encounter LVCMOS devices, where LV stands for low voltage. This is to cater to the lowering of the original TTL and CMOS 5 V specs to 3.3 V or lower.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-278748c02-0009">High Impedance, Pullups, and Pulldowns</h3>
<p class="BodyFirst">Integrated devices aren’t like social media friends who seem to be always on and connected. Sometimes devices actually go quiet, which in electronics terms is called a <em>high impedance</em> state (as with resistance, the unit is also measured in Ω). This quiet state is not the same as being at 0 V. If you connect 0 V and 5 V together, current would flow from the 5 V end to the 0 V end, but if you connect high impedance to 5 V, little or no current would flow. As explained earlier, high impedance is the AC equivalent of high resistance; this is why the current does not flow. Think of 0 V as like measuring the pressure at the surface of a puddle of water; high impedance is like closing the tap on the hose.</p>
<p><span epub:type="pagebreak" title="42" id="Page_42"/>A high impedance state also means that a signal is very susceptible to swinging between high and low voltages, due to interferences even as minimal as crosstalk or radio signals. Sometimes we refer to these signals as floating; it’s like a raindrop hitting a water pressure sensor floating in the air, causing it to give meaningless and erratic readings.</p>
<p>To ensure that devices don’t interpret random and errant signals as valid data, we can use pullups and pulldowns to prevent those signals from “floating” unpredictably. A <em>pullup</em> is a resistor that attaches the signal to a high voltage, and a <em>pulldown</em> is a resistor that attaches a signal to ground or 0 V. Strong pullups (often around 50 Ω to 470 Ω) are designed to produce a strong signal that would need a powerful interference signal to be overridden. Weak pullups (often around 10 kΩ to 100 kΩ) will hold the signal high as long as no other more powerful signal drives it to low or high voltages. Some chips are designed with weak internal pullups at inputs to avoid signals from flapping around in the digital breeze. Note that pullup and pulldown resistors are used only to prevent random interference signals from being seen as an intended signal; they don’t prevent the stronger intended signals from being seen.</p>
<h3 id="h2-278748c02-0010">Push-Pull vs. Tristate vs. Open Collector or Open Drain</h3>
<p class="BodyFirst">In order to have bidirectional communication, or even multiple senders and receivers on one wire, we need to do a bit more. Let’s say we have two parties that want to communicate, henceforth referred to as “I” and “you.” If I want to send data only to you, the simple 0 V to 5 V method used earlier would work fine. This is called a <em>push-pull output</em>, because I will push your input to 5 V, or I will pull your input to 0 V. You get no say in the matter, and neither does anyone else.</p>
<p>But what if you now want to reverse direction and send data to me over the same interconnecting wires? I would need to keep quiet and go into high-impedance mode so that you’d have the opportunity to respond to me. For communication to happen, one party must be talking, while the other party must be listening. Though this seems elementary, talking and listening needs to be engineered in any communication system, and legions of humans also have not yet mastered this.</p>
<p>To communicate, I can be in the one state or the zero state (talking) or in the high impedance state (listening), which is also referred to as <em>Hi-Z</em> (impedance is abbreviated as Z) or <em>tristate</em> (since it’s a third state). Even better, if we coordinate when we “tristate,” we could allow several other devices to communicate on our wires. These groups of interconnecting wires are called <em>buses</em>. Buses share wires that everyone takes turns using. <a href="#figure2-4" id="figureanchor2-4">Figure 2-4</a> is a diagram of two communicating devices.</p>
<p>In the upper circuit in <a href="#figure2-4">Figure 2-4</a>, Device 2 is controlling the wire because EN<sub>2</sub> = 1 and EN<sub>1</sub> = 0 (Hi-Z). It sets the value <em>B</em> on the wire, which Device 1 then sees. On the bottom, Device 1 is sending <em>A</em>, because EN<sub>1</sub> = 1 and EN<sub>2</sub> = 0 (Hi-Z).</p>
<span epub:type="pagebreak" title="43" id="Page_43"/><figure>
<img src="image_fi/278748c02/f02004.png" alt="f02004"/>
<figcaption><p><a id="figure2-4">Figure 2-4</a>: Two devices communicating via tristate buffers</p></figcaption>
</figure>
<p><em>Open collector</em> and <em>open drain</em> refer to different ways of connecting transistors to wires. Instead of having zero and one outputs, open collector transistors have zero and Hi-Z states. If we combine several transistor collector outputs on a wire with a single pullup resistor, any one of those connected collectors can pull the wire to 0 V to send one bit of information along the common wire to the next input. This signal has to be carefully synchronized with the other collectors, which should remain in the Hi-Z state when the signal is being sent. This technique allows for communication using transistors.</p>
<h3 id="h2-278748c02-0011">Asynchronous vs. Synchronous vs. Embedded Clock</h3>
<p class="BodyFirst">One aspect we glossed over in our TTL communication example is <em>clocking</em>. If we alternately spit out 0 V and 5 V on the line, how do you know the difference between the sequence of ones and zeros represented like this: 10101 and 10010111? They will both look like 1 V, 0 V, 1 V, 0 V, 1 V because the repeated signals simply appear as one.</p>
<p>When we use <em>asynchronous</em> communication, I won’t electrically be telling you when to expect data. At some point, I’ll just start sending data. If I actually did want to send 10010111 to you over an asynchronous wire intelligibly, we would need to agree ahead of time on the <em>data rate</em> at which I would be signaling you. The data rate specifies how long I will keep my signal high or low in order to represent one bit. For instance, if I specify that you’ll receive one bit every second, you would know that 0 V for one second means 0, but 0 V for three seconds means 000.</p>
<p><span epub:type="pagebreak" title="44" id="Page_44"/><em>Synchronous</em><em> </em>communication is the situation where we share a clock that allows us to synchronize the start and end of transmitted bits, but there are a number of different methods for sharing a clock.</p>
<p><em>Common clock</em> means that there’s a universal metronome ticking somewhere in our systems—a clock to which we both adhere. A clock in this sense is also carried by electrical signals: a high-voltage <em>tick</em> and a low-voltage <em>tock</em>. When the clock ticks, I set the communication line to 5 V. When it tocks, you read the 5 V and decode a “1.” When the clock ticks again, I can leave the line at 5 V, and on the second tock, you know I’ve now sent “11.” This can become complicated if different interfaces in the system require different clock speeds.</p>
<p><em>Source synchronous clock</em> appears the same for the receiving party, but unlike a common clock, the sender sets the metronome. If I am the sender, I tick before setting a value, then I tock when done. You listen on the other end and check the value every time I tock. One benefit to a source synchronous clock is that, if I have nothing to say or need some time to compose my bits, I can just pause the clock. You, in your machine-like infinite patience and obedience, will wait an eternity until I am ready to continue. The downside of both common and source synchronous clocking is that you need extra pins on chips and extra wires on your boards over which to transmit the clock signal.</p>
<p><em>Embedded clock</em> or <em>self-clocking</em> signals include data and clock information in the same signal. Instead of saying 5 V is one and 0 V is zero, we could use more complicated patterns that incorporate the clock information. For example, <a href="#figure2-5" id="figureanchor2-5">Figure 2-5</a> shows how <em>Manchester encoding</em> defines one as a high voltage transitioning to a low voltage and zero as a low voltage transitioning to a high voltage.</p>
<figure>
<img src="image_fi/278748c02/f02005.png" alt="f02005"/>
<figcaption><p><a id="figure2-5">Figure 2-5</a>: Example of Manchester encoding, which combines data and clock in one signal</p></figcaption>
</figure>
<p>Every single bit that gets transferred over equal periods includes a transition in the middle that allows the receiver to recover the clock.</p>
<h3 id="h2-278748c02-0012"><span epub:type="pagebreak" title="45" id="Page_45"/>Differential Signaling</h3>
<p class="BodyFirst">Everything we’ve discussed so far refers to <em>single-ended signaling</em>, which means we’re using a single wire to represent a stream of ones and zeros. This is easy to design and works well at low speeds with simple devices. If I begin to transmit single-ended signals to you into the MHz range, instead of seeing square waves with distinct high and low voltages, you’ll start seeing high and low levels with rounded edges and eventually have a hard time discerning high from low, as shown in <a href="#figure2-6" id="figureanchor2-6">Figure 2-6</a>.</p>
<figure>
<img src="image_fi/278748c02/f02006.png" alt="f02006"/>
<figcaption><p><a id="figure2-6">Figure 2-6</a>: Square pulses distorted at high frequencies</p></figcaption>
</figure>
<p>These edges are called <em>ringing effects</em>, and they are caused by impedance and capacitance of the transmission wire. Ringing effects make the signal less clearly digital and introduce an element of analog variation. Under the right conditions, lengths of wire can act as antennae and pick up environmental noise, thereby introducing analog variation into what was meant to be a purely digital signal.</p>
<p><em>Differential signaling</em> is a way of embracing the analog nature of signals and using it to cancel out the noise and interference. Instead of one wire, I use two wires that will carry inverted voltage levels: when one wire goes high, the other goes low, and vice versa. The reason for this is if I run the two wires right next to each other, they’ll experience the same interference from outside sources, which will be the same on both wires and therefore won’t be inverted with respect to each other. At the receiver end, I simply subtract one signal from the other to cancel out the analog part of the signals and leave behind the original digital signal. If I’m equipped with a differential transmitter, and you are equipped with a differential receiver, we can easily communicate in the GHz data rate over a pair of wires, as opposed to communicating in the MHz range over a single wire.</p>
<p>At this point, we’ve described a variety of different ways to use wires to transmit and receive data at an electrical level. Don’t worry if this knowledge doesn’t all stick. Although it’s not essential for understanding and interacting with the different interfaces on a system, it will be helpful to know why we need to interact between various interfaces in different ways. It also will help you determine how to approach a new protocol you might encounter.</p>
<h2 id="h1-278748c02-0003"><span epub:type="pagebreak" title="46" id="Page_46"/>Low-Speed Serial Interfaces</h2>
<p class="BodyFirst">Would you believe us if we told you that you could access the root filesystem on a vast number of embedded systems by connecting only three wires? (The root filesystem contains the files and directories critical for system operation.) What if we told you that you can get a pristine copy of a device’s firmware with only four wires? You would just need to spend $30 or less on hardware (computer excluded) to do it. These attacks rely on your ability to communicate with the target device, a communication method we’ll also use for both power analysis and fault injection, so next let’s look at the various communications interfaces you’ll need to know.</p>
<h3 id="h2-278748c02-0013">Universal Asynchronous Receiver/Transmitter Serial</h3>
<p class="BodyFirst">This protocol is known by several names—serial, RS-232, TTL Serial, and UART—but they all refer to the same thing with only minor potential differences.</p>
<p><em>UART</em> stands for <em>universal asynchronous receiver/transmitter</em> (sometimes called <em>USART</em> if it supports synchronous operation as well). Be sure not to confuse this with <em>universal serial bus (USB)</em>, which is a much more complicated protocol. The term <em>universal</em> is appropriate, because it is one of the most commonly encountered serial interfaces, and it’s easily identifiable if you’re observing the signal on a wire, such as by probing with an oscilloscope. The word <em>asynchronous </em>means it doesn’t carry its own clock; parties need to agree on a clock speed beforehand if they intend to communicate via UART. <em>Receiver/transmitter</em> refers to the fact that one device can communicate both ways if both wires in the serial cable are connected.</p>
<p>A bidirectional UART interface needs two wires (and ground) for Device A and Device B to communicate (see <a href="#figure2-7" id="figureanchor2-7">Figure 2-7</a>).</p>
<figure>
<img src="image_fi/278748c02/f02007.png" alt="f02007"/>
<figcaption><p><a id="figure2-7">Figure 2-7</a>: Three wires for UART, connecting transmit (TX) to receive (RX) and connecting grounds</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="47" id="Page_47"/><em>RS-232</em> is the most ubiquitous UART standard, but it has an interesting quirk. Designed many years ago for linking devices over cables that were several meters long, it defines logic one (which is also called a <em>mark</em>) as anything between –3 V and –15 V and logic zero (which is also called a <em>space</em>) as anything between +3 V and +15 V. At the far end of the cable, you were expected to be tolerant of any voltage between +25 V and –25 V in case of voltage drift, which is way out of the signal ranges in today’s low-voltage systems that rarely range far beyond 0 V and 3 V. You can imagine that these devices end up being rather unhappy if you connect a true higher-voltage RS-232 device directly to their logic level inputs. On the other hand, doing so did allow for multiplayer <em>Doom</em> across two different kids’ bedrooms. </p>
<p><em>TTL serial</em>,<em> </em>using the TTL 0 V/5 V logic levels, is otherwise identical to RS-232 in format. This means you can use a UART to communicate without the need for any additional voltage converter chips. You may find people specifying different voltage levels (such as “3.3 V TTL serial”) to show they’re not using the classic 0 V/5 V logic level, but rather a 0 V/3.3 V logic level.</p>
<p>The UART protocol is relatively straightforward. Getting back to our two-party communication scenario, if I am idle, I’ll continuously transmit a logic one (mark). When I’m ready to send you a byte’s worth of bits, I’ll begin with a logic zero “start bit” to signal the start of my transmission. I’ll follow that with the rest of my bits, the least significant bit in each byte being sent first. (A <em>byte </em>is a grouping of bits.) I can optionally include parity information for error detection in the byte. Finally, I can send one or more logic one “stop bits” to signal the end of my byte. In order for you to interpret my transmission properly, we need to agree on a few parameters:</p>
<ol class="none">
<li><span class="RunInHead">Baud rate</span>  The number of bits per second that I will transmit and you will receive.</li>
<li><span class="RunInHead">Byte length</span>  The number of bits in a byte. This is almost universally eight now, but UART supports alternate lengths.</li>
<li><span class="RunInHead">Parity</span>  N for no parity, E for even, and O for odd—the parity bit is added as an error detection measure to indicate whether the total number of ones in the byte is even or odd.</li>
<li><span class="RunInHead">Stop bits</span>  The length of the stop signal bit, which is often 1, 1.5, or 2.</li>
</ol>
<p>For example, if I specified 9600/8N1, you should expect to see 9,600 bits per second, 8-bit bytes, no parity bit, and one stop bit (see <a href="#figure2-8" id="figureanchor2-8">Figure 2-8</a>).</p>
<p>Moving up from the electrical layer to the logical level, once you have connected your TX, RX, and ground and have connected your serial cable to your system, you can treat this interconnection the same way you would treat any other character-generating device. In *nix operating systems, the interconnection appears as a TTY device; in Windows operating systems, it appears as a COM port.</p>
<span epub:type="pagebreak" title="48" id="Page_48"/><figure>
<img src="image_fi/278748c02/f02008.png" alt="f02008"/>
<figcaption><p><a id="figure2-8">Figure 2-8</a>: Example of the byte 0x71/bits 0b01110001 transmitted using a UART at 9600/8N1</p></figcaption>
</figure>
<p>While a UART is most often used as a debug console on embedded devices, it is also frequently used to interface with communications equipment. Some phones or embedded systems with cellular communications use the UART protocol to communicate with a cellular radio using the Hayes AT command set developed for modem control. Many GPS modules communicate via NMEA 0183, a text protocol that depends on a UART for the data link layer.</p>
<h3 id="h2-278748c02-0014">Serial Peripheral Interface</h3>
<p class="BodyFirst">The<em> serial peripheral interface (SPI)</em> is a low pin-count, controller-peripheral, source-synchronous serial interface. Typically, it contains one <em>controller </em>on a bus and one or more <em>peripheral</em> devices. Whereas UART is a peer-to-peer interface, SPI is controller-peripheral, meaning that the peripheral only ever responds to the controller’s requests and can’t initiate communication. Also, unlike UART, SPI is source synchronous, so the SPI controller transmits the clock to the peripheral receiver. This means the peripheral and controller don’t need to agree ahead of time on baud rate (clock frequency) since it is provided. SPI usually runs much faster than UART protocols (UART typically runs at 115.2 kHz; SPI typically runs at 1–100 MHz).</p>
<p><a href="#figure2-9" id="figureanchor2-9">Figure 2-9</a> shows the four wires that carry the signals for SPI communication between C (controller) and P (peripheral)—SCK (serial clock), COPI (controller out peripheral in), CIPO (controller in peripheral out), and *CS (chip select)—as well as GND (ground).</p>
<p>As you might notice from the pinout names, no ambiguity or swapping of transmit and receive pins exists, since either side has a clearly defined controller and peripheral. Electrically, all the SPI outputs are push-pull, which is fine, because the SPI interface is designed to have only one controller on the wire.</p>
<span epub:type="pagebreak" title="49" id="Page_49"/><figure>
<img src="image_fi/278748c02/f02009.png" alt="f02009"/>
<figcaption><p><a id="figure2-9">Figure 2-9</a>: Four wires for SPI, plus ground</p></figcaption>
</figure>
<p>The <em>chip select</em> pin is labeled with an asterisk (*CS) to indicate that it’s active-low, meaning the high voltage is false and 0 V is true. If you were the peripheral device on an SPI interface, you would need to sit quietly (in high impedance mode) until I assert *CS by setting it to 0 V. At that point, you would have to listen to SCK and COPI for your commands, and only when it’s your turn could you respond on the CIPO pin.</p>
<p>An advantage of having a *CS pin is that I, as a controller, might actually have several different *CS pins, one for each peripheral. Since you’re required to stay in high impedance mode until your *CS pin is selected, other peripherals can share the SCK, COPI, and CIPO pins. This allows adding more SPI peripheral devices to a single controller at the cost of only the single additional *CS wire per peripheral.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The active-low notation will commonly be one of three options. The pin name will have an overline above it (<span class="Overline">CS</span>), the pin will have a slash in front of it (/CS), or the pin will have an asterisk in front of it, as used with the *CS example.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>SPI is most frequently used to interface with EEPROMs. The BIOS/EFI code on nearly every personal computer is stored in an SPI EEPROM. Many network routers and USB devices store their entire firmware in an <span epub:type="pagebreak" title="50" id="Page_50"/>SPI EEPROM. SPI is well suited to devices that don’t necessarily need high speed or frequent interaction. Environmental sensors, cryptographic modules, wireless radios, and other devices are all available as SPI devices.</p>
<p>You may notice some devices use only the notation <em>serial data out (SDO)</em> and <em>serial data in (SDI)</em>. This notation clarifies which pin is an output or input for a given device (there’s no confusion as to whether a device is the controller or peripheral), but the protocol is typically the same, regardless of the names used for the pins. You may also find devices that use MOSI instead of COPI, MISO instead of CIPO, and SS instead of CS, referring to main/secondary terminology.</p>
<h3 id="h2-278748c02-0015">Inter-IC Interface</h3>
<p class="BodyFirst">The <em>inter-IC interface</em>, also called IIC, I2C, I<sup>2</sup>C (pronounced “I-square-C”), two-wire (TWI), and SMBus, is a low pin-count, multicontroller, source-synchronous bus. The multitude of names is primarily due to minor differences and trademark issues. I<sup>2</sup>C was a claimed trademark, so companies used a different name for the same bus. You’ll see I2C is very similar to SPI in most respects, and you’re likely to find exactly the same devices with either SPI or I2C interfaces.</p>
<p>You might notice, however, that I2C is “multicontroller,” whereas SPI is “controller-peripheral.” <a href="#figure2-10" id="figureanchor2-10">Figure 2-10</a> helps clarify this.</p>
<figure>
<img src="image_fi/278748c02/f02010.png" alt="f02010"/>
<figcaption><p><a id="figure2-10">Figure 2-10</a>: Two wires for I2C communication between controllers and peripherals</p></figcaption>
</figure>
<p>The complete “bus” consists of two wires: SDA and SCL. Each wire connects to every SDA or SCL pin of all I2C ports connected to the bus. Each wire has a single pullup resistor. An inactive I2C port will put both SDA and SCL pins into high-impedance mode. This means if no other devices are talking, both lines will sit at logic one, and any device can take ownership of the bus by pulling down the SCA line. An I2C device can be a controller <span epub:type="pagebreak" title="51" id="Page_51"/>only, a peripheral only, or it can act as a controller or a peripheral at different points in time.</p>
<p>Let’s pretend you and I are two bus controllers on an I2C bus, connected to an I2C peripheral EEPROM. If we want to access the EEPROM, we check to see what the SDA and SCL lines are doing. If they’re both sitting at logic one, the bus is not in use, and I can take control of it by sending a START condition (that is, by setting SDA to 0, while SCL stays at 1). At this point, you need to stand back and wait until I’m done with the bus. I’ll signal this with a STOP condition by setting SDA to 1 while SCL stays at 1. <a href="#figure2-11" id="figureanchor2-11">Figure 2-11</a> shows the STOP conditions on the SCA and SCL lines.</p>
<figure>
<img src="image_fi/278748c02/f02011.png" alt="f02011"/>
<figcaption><p><a id="figure2-11">Figure 2-11</a>: STOP conditions on I2C lines SDA and SCL</p></figcaption>
</figure>
<p>Once I’ve taken control of the bus, you, the EEPROM, and everyone else have to sit and listen for me to send out an address.</p>
<p>Each device has a unique 7-bit address. Usually several bits are hardcoded, and the remainder are programmable via flash or pullup/pulldown resistors to differentiate multiple identical components connected to the same I2C bus. Following the 7-bit address comes a Read/*Write bit to indicate the direction the next byte of data will go. In order to read data from the EEPROM, I first tell the EEPROM from which memory address I want to read (which is a write operation—that is, a one on the eighth bit), then I have to tell the EEPROM to send the data at that memory location (which is a read operation—that is, a zero on the eighth bit). After every byte has been transferred over I2C, the recipient is required to acknowledge the byte. The sender releases the SDA line, and the controller toggles the SCL line. If the receiver has received all eight bits, it should set the SDA line to zero during this time. <a href="#figure2-12" id="figureanchor2-12">Figure 2-12</a> shows what SDA and SCL look like over time as the entire transaction takes place.</p>
<span epub:type="pagebreak" title="52" id="Page_52"/><figure>
<img src="image_fi/278748c02/f02012.png" alt="f02012"/>
<figcaption><p><a id="figure2-12">Figure 2-12</a>: I2C Read register sequence</p></figcaption>
</figure>
<p>A complete sequence on SCA between a controller device and an EEPROM looks like the following:</p>
<ol class="decimal">
<li value="1"><b>Start sequence</b>: The controller tells everyone else to be quiet and to listen for their device address.</li>
<li value="2"><b>Peripheral address</b>: The controller sends the 7-bit device address of the EEPROM it wants to read.</li>
<li value="3"><b>R/*W bit</b>: The controller sends a zero because we first need to write an EEPROM memory address.</li>
<li value="4"><b>Acknowledge</b>: The controller releases SDA and expects the EEPROM to signal reception of the device address by setting SDA to 0.</li>
<li value="5"><b>EEPROM address</b>: The controller sends the 8-bit byte, which is the EEPROM memory address.</li>
<li value="6"><b>Acknowledge</b>: The controller releases SDA and expects the EEPROM to signal reception of the memory address by setting SDA to 0.</li>
<li value="7"><b>Start sequence</b>: The controller repeats the start sequence because it now wants to read.</li>
<li value="8"><b>Peripheral address</b>: The controller resends the 7-bit EEPROM device address.</li>
<li value="9"><b>R/*W bit</b>: The controller sends a one because it now wants to read data from the memory address it has just set.</li>
<li value="10"><b>Acknowledge</b>: The controller releases SDA and expects the EEPROM to signal reception of the device address by setting SDA to zero.</li>
<li value="11"><b>EEPROM data</b>: The EEPROM sends the 8 data bits from the memory address on SDA to the controller at the moment the controller toggles SCL.</li>
<li value="12"><b>Acknowledge</b>: The controller sets SDA to zero to acknowledge it has received the byte.</li>
<li value="13"><b>Repeat</b>: As long as the controller keeps toggling SDA and acknowledging at the right time, the EEPROM will continue to send successive <span epub:type="pagebreak" title="53" id="Page_53"/>bytes of data to the controller. When enough bytes are read, the controller will send a Not Acknowledge (NACK) to communicate to the peripheral.</li>
<li value="14"><b>Stop sequence</b>: The controller tells everyone it is done, giving others a turn on the bus.</li>
</ol>
<p>During the entire sequence, the controller toggles SCL in order to synchronize its communication with the peripheral.</p>
<p>One great advantage of this multicontroller bus is that it requires only two wires, no matter how many devices share it. A downside is that because there’s only a single pullup and all the devices need to be listening on the line at all times, the effective maximum throughput has to be lower than the design speed at which the SPI can communicate due to dividing the throughput among the devices. For this reason, you’re more likely to find only SPI EEPROMs at bus speeds greater than 1 MHz, while most other devices are equally likely to have plain SPI or I2C interfaces.</p>
<p>Since it requires only two wires, I2C can be squeezed into a wide number of hardware applications. For example, VGA, DVI, and even HDMI connectors use I2C in order to read a data structure from the monitor that describes the monitor’s output capabilities. In most systems, this I2C bus is even accessible from software in the event that you want to plug auxiliary devices into your system via spare VGA ports.</p>
<p>Since I2C is a multicontroller bus, there is no problem whatsoever with jumping onto an I2C bus and acting as the controller, which is an option that does not always work as expected on an SPI bus.</p>
<h3 id="h2-278748c02-0016">Secure Digital Input/Output and Embedded Multimedia Cards</h3>
<p class="BodyFirst"><em>Secure Digital Input/Output (SDIO)</em> uses the physical and electrical <em>SD card</em> interface for I/O operations. <em>Embedded multimedia cards (eMMCs)</em> are surface-mount chips that provide the same interface and protocol as memory cards, but without the need for a socket and extra packaging. MMC and SD are two closely related and overlapping specifications that are very commonly used for storage in embedded systems.</p>
<p>SD cards are backward compatible with SPI. As long as you connect the SPI pins we previously discussed to any SD card (and most MMC cards too), you will be able to read and write data on the card.</p>
<p>SD modified the SPI by trading the COPI and CIPO lines for bidirectional control and data lines. SD also expanded from these two lines to include modes with two or four bidirectional data lines. eMMC expands these two or four lines further to include eight bidirectional data lines, and SDIO expands on the basic low-level protocol further by using the interface to interact with another device besides a storage device, and it adds an interrupt line.</p>
<p>During the progressive iterations of these specifications, a lowly 1 MHz, 1-bit SPI bus has expanded to up to eight parallel bits and clocks as high as 208 MHz. It may no longer be a “low-speed serial bus,” but conveniently, almost all devices are backward compatible, and when you can run them at <span epub:type="pagebreak" title="54" id="Page_54"/>low-speed SPI, you can still use low-cost sniffers to extract useful information from those devices. For various memory cards that still support SPI, <a href="#table2-1" id="tableanchor2-1">Table 2-1</a> shows the CS, COPI, CIPO, and SCLK pin locations for MMC, SD, miniSD, and microSD cards.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-1">Table 2-1</a>: SPI Communication Pinouts for MMC, SD, miniSD, and microSD Cards (from <a href="https://en.wikipedia.org/wiki/SD_card" class="LinkURL">https://en.wikipedia.org/wiki/SD_card</a>, CC-BY 3.0 License)</p></figcaption>
<table id="table-278748c02-0001" border="1">
<thead>
<tr>
<td><b>MMC</b><br/>
<b>pin</b></td>
<td><b>SD</b><br/>
<b>Pin</b></td>
<td><b>miniSD</b><br/>
<b>pin</b></td>
<td><b>microSD</b><br/>
<b>pin</b></td>
<td><b>Name</b></td>
<td><b>I/O</b></td>
<td><b>Logic</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>nCS</td>
<td>I</td>
<td>PP</td>
<td>SPI Card Select [CS] (negative logic)</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>DI</td>
<td>I</td>
<td>PP</td>
<td>SPI Serial Data In [COPI]</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>3</td>
<td class="gray"/>
<td>VSS</td>
<td>S</td>
<td>S</td>
<td>Ground</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>VDD</td>
<td>S</td>
<td>S</td>
<td>Power</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>CLK</td>
<td>I</td>
<td>PP</td>
<td>SPI Serial Clock [SCLK]</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>VSS</td>
<td>S</td>
<td>S</td>
<td>Ground</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>DO</td>
<td>O</td>
<td>PP</td>
<td>SPI Serial Data Out [CIPO]</td>
</tr>
<tr>
<td class="gray"/>
<td>8</td>
<td>8</td>
<td>8</td>
<td>NC<br/>
nIRQ</td>
<td>.<br/>
O</td>
<td>.<br/>
OD</td>
<td>Unused (memory cards)<br/>
Interrupt (SDIO cards, negative logic)</td>
</tr>
<tr>
<td class="gray"/>
<td>9</td>
<td>9</td>
<td>1</td>
<td>NC</td>
<td>.</td>
<td>.</td>
<td>Unused</td>
</tr>
<tr>
<td class="gray"/>
<td class="gray"/>
<td>10</td>
<td class="gray"/>
<td>NC</td>
<td>.</td>
<td>.</td>
<td>Reserved</td>
</tr>
<tr>
<td class="gray"/>
<td class="gray"/>
<td>11</td>
<td class="gray"/>
<td>NC</td>
<td>.</td>
<td>.</td>
<td>Reserved</td>
</tr>
</tbody>
</table>
</figure>
<p>You can see the basic pins are shared between them, meaning that the naming of the device as an SD card, microSD card, MMC, or eMMC device really declares the upper boundary of the device protocol and performance. For most hardware work we’ll do, we can interact with the devices in the same fashion, as we’re not concerned with the highest possible performance. <a href="#figure2-13" id="figureanchor2-13">Figure 2-13</a> shows the physical pin locations corresponding to the table.</p>
<p>You’ll notice there is some physical alignment between standards, such that an MMC card plugged in to an SD card reader still makes contact with pins 1–7. Watch the odd numbering of the miniSD if you are interfacing directly with a miniSD card as well, because pins 10 and 11 are snuck in between pins 3 and 4!</p>
<span epub:type="pagebreak" title="55" id="Page_55"/><figure>
<img src="image_fi/278748c02/f02013.png" alt="f02013"/>
<figcaption><p><a id="figure2-13">Figure 2-13</a>: Physical locations of the SPI pins shown in <a href="#table2-1">Table 2-1</a></p></figcaption>
</figure>
<h3 id="h2-278748c02-0017">CAN Bus</h3>
<p class="BodyFirst">Many automotive applications use the <em>controller area network (CAN)</em> bus to connect microcontrollers that talk to sensors and actuators. For instance, buttons on a steering wheel may use CAN to send commands to the car stereo. You also can read out real-time engine data and diagnostics with CAN, which means you can use CAN to access the engine control via a compromised cellular connection to one of the vehicle’s microcontrollers. For an example, see “Remote Exploitation of an Unaltered Passenger Vehicle” by Dr. Charlie Miller and Chris Valasek. We were tinkering with the communication between an eBike display and its motor controller and also found out that it uses CAN.</p>
<p>CAN uses differential signaling, because the electrical environment in a car is noisy, and robustness is a strong safety requirement. A few variants of CAN exist, but the main ones are high- and low-speed fault-tolerant CAN. Both use a differential pair of wires called CAN high and CAN low, <span epub:type="pagebreak" title="56" id="Page_56"/>but the wire names do not relate to low-speed or high-speed CAN. Instead, a differential signal is sent across the two CAN pins, and the names correspond to voltage levels used for a logical one or zero:</p>
<ul>
<li>High-speed CAN has bit rates from 40Kbps to 1Mbps and uses CAN high = CAN low = 2.5 V for a logical one and CAN high = 3.75 V and CAN low = 1.25 V for a logical zero.</li>
<li>Low-speed CAN has bit rates from 40Kbps to 125Kbps and uses CAN high = 5 V and CAN low = 0 V for a logical one and CAN high ≤ 3.85 V and CAN low ≥  1.15 V for a logical zero.</li>
</ul>
<p>These voltages are specified for ideal circumstances and can vary in practice. An updated version of CAN called <em>CAN flexible data-rate (FD)</em> increases the speed up to 12Mbps, while also increasing the maximum bytes transferred in one packet to 64.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you’re interested in car hacking in particular, No Starch Press publishes the <em>Car Hacker’s Handbook</em> (2016) by Craig Smith. This book covers many details of car hacking that are a perfect complement to the low-level details of embedded work that we talk about in this book. The OpenGarages website also provides a free PDF of the book, but it’s worth getting a physical copy.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-278748c02-0018">JTAG and Other Debugging Interfaces</h3>
<p class="BodyFirst">The <em>Joint Test Action Group (JTAG) </em>is a common hardware debugging interface and is critical to security. The JTAG created the IEEE 1149.1 standard, titled “Standard Test Access Port and Boundary-Scan Architecture.”<em> </em>The goal was to standardize a means for testing/debugging chips, as well as for testing printed circuit boards (PCBs) for manufacturing errors. Full coverage of JTAG is beyond the scope of this book, but we’ll provide an overview so you can find other resources.</p>
<p>Why is this testing or debugging required? With the increased use of multilayer PCBs in the 1980s, it became necessary to provide a means to test freshly baked PCBs in the manufacturing facility without exposing the inner layers to the outside world. Engineers came up with the idea to use the existing chips on the PCB to test the connections.</p>
<p>When you’re performing a <em>boundary scan</em>, you basically disable the actual functionality of each chip but enable control from a test apparatus over each of the chip pins. For example, if chip A pin 6 is connected to chip B pin 9, you can let chip A drive pin 6 low and then high, and you can then observe on chip B pin 9 whether that signal actually arrives. Extending this to all chips and all pins, you can verify correct manufacturing of a PCB by daisy-chaining all chips using the JTAG pins. To do a boundary scan properly, you need a definition of all chips on the daisy chain, which is specified in a <em>boundary scan description language (BSDL)</em> file. You can find these chip definitions online if you’re lucky.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	An interesting tidbit is that BSDL is a subset of VHDL, a hardware design language.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="57" id="Page_57"/>A boundary scan lets you touch the PCB, not the chip itself, so it’s useful to consider using if you’re trying to access the PCB’s inner layers. Technically, you can do fun things like toggle SPI or I2C pins and speak those protocols over JTAG, but it’ll be pretty slow, so you may be better off actually connecting to the SPI or I2C wires where you can. Using boundary scan is fast enough to view UART or other lower-speed traffic, and if you use JTAG in the sample mode, it runs passively, which is to say it doesn’t take control of the chip and the chip continues to function normally.</p>
<p>Tools for toggling port pins on a device given a BSDL file exist; well-known examples include UrJTAG (open source) and TopJTAG (low-cost with free trial, GUI based). These tools can be very helpful for PCB reverse engineering, as you can toggle a given pin on a chip and see what happens on the PCB. You can also drive nets or map a known pattern to a chip pin. <a href="#figure2-14" id="figureanchor2-14">Figure 2-14</a> shows an example of using TopJTAG to view a serial data waveform.</p>
<figure>
<img src="image_fi/278748c02/f02014.png" alt="f02014"/>
<figcaption><p><a id="figure2-14">Figure 2-14</a>: Using boundary scan to inspect a tiny BGA device we can’t easily probe</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="58" id="Page_58"/>An open source tool called JTAG Boundary Scanner by Viveris Technologies provides a simple library along with a Windows GUI for accessing pins based on the pin name learned from a BSDL file. If you would like to automate more complex tasks, such as recording power-on sequences or sending SPI commands over JTAG, the JTAG Boundary Scanner tool is a good starting point for this work. It’s the basis for the open source pyjtagbs (<a href="https://github.com/colinoflynn/pyjtagbs/" class="LinkURL">https://github.com/colinoflynn/pyjtagbs/</a>)<em> </em>Python bindings as well, allowing you to perform similar functionality through the JTAG port.</p>
<p>If using boundary scan mode, you have a choice of running a <code>SAMPLE</code> instruction that allows you to view the I/O pin state or an <code>EXTEST</code><em> </em>instruction that allows you to control the I/O. Typically the <code>EXTEST</code> instruction may disable other features (such as the CPU core), so if you’re trying to inspect a running system, you should use the boundary scan tools in <code>SAMPLE</code> mode.</p>
<p>The more chip-centric (not just I/O pin) control happens through the JTAG <em>test access port (TAP)</em> controller, which is what provides on-chip debugging capabilities. The good news is that it’s standardized up to a point; the bad news is that this level of standardization is rather low. Basically, the TAP controller can do IC resets and write and read from two registers: the <em>instruction register (IR)</em> and the <em>data register</em> <em>(DR)</em>. Debugging facilities, such as memory dumps, breakpoints, single stepping, and so on, are proprietary additions on top of this standard interface. Much of this has been reverse engineered and is available in software, such as OpenOCD. This means if you have a supported target, you can connect OpenOCD to a JTAG adapter and then use GDB to connect to OpenOCD<em> </em>and debug a CPU in place!</p>
<p>JTAG uses four to six pins:</p>
<ul>
<li><b>Test data in (TDI)</b>  Shifts data into the JTAG daisy chain.</li>
<li><b>Test data out (TDO)</b>  Shifts data out of the JTAG daisy chain.</li>
<li><b>Test clock (TCK)</b>  Clocks all test logic on the JTAG chain.</li>
<li><b>Test mode select (TMS)</b>  Selects a mode of operation for all devices (for example, boundary chain operations versus TAP operations).</li>
<li><b>Test reset (TRST, optional)</b>  Resets the test logic. Another way of resetting is holding TMS=1 for five clock cycles.</li>
<li><b>System reset (SRST, optional)</b>  Resets the entire system.</li>
</ul>
<p>JTAG has several standard headers. For instance, ARM has a standard 20-pin connector. You can also identify JTAG by tracing suspected chip JTAG pins. If you’re not sure whether a set of pins is JTAG, try a tool like Joe Grand’s JTAGulator, which uses a clever algorithm to identify each of JTAG’s pins. (We give an example of several of these headers in Appendix B.)</p>
<p>You may wonder whether full debug access to a CPU is terribly insecure. The answer is yes. That’s why manufacturers who care about security do various things to disable JTAG, and those various things give an attacker more to do in order to attack the system (see <a href="#table2-2" id="tableanchor2-2">Table 2-2</a>).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-2">Table 2-2</a>: Overview of JTAG Port Disablement Measures and Attacks<span epub:type="pagebreak" title="59" id="Page_59"/></p></figcaption>
<table id="table-278748c02-0002" border="1">
<thead>
<tr>
<td><b>JTAG protection measure</b></td>
<td><b>Attack on protection</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Remove the PCB header.</td>
<td>Re-solder a header onto the PCB.</td>
</tr>
<tr>
<td>Remove the PCB traces.</td>
<td>Re-attach wires to JTAG pins on the CPU directly, which is a bit trickier for chip packages that don’t directly expose their pins.</td>
</tr>
<tr>
<td>Disable JTAG for secure operations.<br/>
An example is the SPIDEN input signal on ARM cores, which can disable Secure World debugging. A separate input signal, SPNIDEN, can disable Normal World debugging.</td>
<td>If these CPU signals are brought out on a package pin, push them high.</td>
</tr>
<tr>
<td>Use an OTP fuse configuration in the chip that is burned to disable JTAG after manufacturing.</td>
<td>Fault injection on the fuse readout or shadow register.</td>
</tr>
<tr>
<td>Put an authorization protocol on JTAG before enabling it.</td>
<td>Side channel on the crypto key used in case of a challenge/response protocol or fault the authorization.</td>
</tr>
</tbody>
</table>
</figure>
<p>With this nice set of JTAG defenses and attacks, note that JTAG is far from the only debug interface you’ll see used. Manufacturers of other debug interfaces include the protocol used by the Atmel AVR (SPI-based protocol), the protocol used by the Atmel XMEGA (Atmel’s Program and Debug Interface, or PDI, which is something like SPI but with a single data line), and the TI Chipcon series.</p>
<p>You’ll also find that some interfaces will support only the on-chip debug mode and not the JTAG boundary scan mode (or vice versa). For example, the Microchip SAM3U has a physical pin called JTAGSEL that selects the JTAG port it runs in on-chip debug mode or boundary scan mode. If you want to use a nondefault mode, you may need to modify the board to pull this pin to the desired level. You may also find that some devices disable the JTAG debug mode but leave the JTAG boundary scan mode enabled. This is not directly a security flaw, but the boundary scan mode can be very helpful for all sorts of reverse engineering work. Technically, everything you can do in boundary scan mode you can also do by probing the physical PCB (which is why it’s not a security issue to leave boundary scan mode enabled), but using that mode can make your life easier.</p>
<p>We introduced ROM-based bootloaders in Chapter 1. In some cases, you can use these bootloaders for programming, and sometimes they provide debug support by allowing you to read out memory locations.</p>
<h2 id="h1-278748c02-0004">Parallel Interfaces</h2>
<p class="BodyFirst">Low-speed serial interfaces don’t always cut it. If you need to load only 4MB of compressed firmware once at boot, they are suitable, but if you have a 128MB writable filesystem or want a low-latency interface to external dynamic RAM (DRAM), serial buses won’t provide reasonable <span epub:type="pagebreak" title="60" id="Page_60"/>performance. Increasing the interface’s clock speed has real limits, and you still need to deserialize the data before you can use it. Using several data wires in parallel is a much more scalable approach. Laying down 8 or 16 wires makes many times more bandwidth available for memory access or fast storage. One of the main applications of parallel buses is for memory.</p>
<p>An extract from the i.MX6 Rex board shown in <a href="#figure2-15" id="figureanchor2-15">Figure 2-15</a> depicts the many parallel bus lines from the chip to the external DRAM.</p>
<figure>
<img src="image_fi/278748c02/f02015.png" alt="f02015"/>
<figcaption><p><a id="figure2-15">Figure 2-15</a>: An extract from the i.MX6 Rex open source board</p></figcaption>
</figure>
<p>See the pinout going to a double data rate (DDR) memory bus? Many data and address lines (labeled DRAM_D and DRAM_A, respectively) are shown as well.</p>
<h3 id="h2-278748c02-0019">Memory Interfaces</h3>
<p class="BodyFirst">Unlike serial interfaces, where you can simply hook up two to four wires, a parallel bus may come with multiple lines for address, data, and control signals. For instance, you may find a flash chip with 24 address bits, 16 data input/output bits, and 8 or more control signals. You’re in for a larger probing party than with serial interfaces; for the really brave, DDR4 has 288 pins. Because various standards exist for bitrates, pin/wire assignments, and so on, it helps to research your target first (see Chapter 3). You’ll mostly encounter memory interfaces implemented as parallel buses, be it for DRAM or for flash, as shown in the example of a DDR interface in <a href="#figure2-15">Figure 2-15</a>.</p>
<p>A few options are available for connecting to parallel interfaces in circuit. If the pitch of pins is wide enough, you might be able to use a few dozen grabber probes and a rat’s nest of wires to connect to a logic analyzer or a universal programmer (see Appendix A for sample vendors). More often than not, you will find that when devices have many pins, the pins are <span epub:type="pagebreak" title="61" id="Page_61"/>much smaller and are routed to inner PCB layers. Most chips come in standard sizes, and although they may be expensive, you can buy in-circuit clips for most devices. Unlike the clips for less-dense components, these usually have a flexible printed circuit ribbon that carries all the traces out to a separate breakout board, which you might be able to adapt to your analyzer or programmer.</p>
<p>As long as you can reach the pins, you should be able to figure out some way to connect to them. A logic analyzer would let you capture all the traffic that goes across the interface for later analysis, if it’s fast enough, and then only for a passive analysis.</p>
<p>If you do need full control of the interface and can’t isolate it from the rest of the system, or if your target device is a ball grid array (BGA) package with no accessible pins, you might have to remove the chip from the board to read or write to it. De-soldering and replacing a device without damaging anything certainly isn’t foolproof and probably doesn’t sound easy, but with practice (or the help of a talented friend), you can do it reliably with a relatively low risk of failure. (Chapter 3 details readout of flash chips further, and Appendix A lists some useful tools.)</p>
<h2 id="h1-278748c02-0005">High-Speed Serial Interfaces</h2>
<p class="BodyFirst">We’ve discussed how it’s easier to lay down eight times as many traces than it is to run one wire reliably at eight times the speed. Although the term <em>high-speed serial interface</em> may sound like a contradiction, it isn’t. In the previous section, we described single-ended signals, and earlier in this chapter, we mentioned that differential signals can be run in the GHz range reliably in conditions where single-ended signals would be limited to a few MHz.</p>
<p>High-speed serial interfaces have facilitated most of the data rate increases in the past decade. Parallel ATA cables with 40 pins maxed out at 133 MHz were replaced by seven-pin Serial ATA cables that now run at 6 GHz. PCI slots with 32 data lines made it to 33 or 66 MHz, but they were superseded by PCIe lanes that now run up to 8 GHz. This is the case for a few reasons.</p>
<p>First, with parallel wires, you need to make sure that all the signals are stable at the receiver end within one cycle of the clock. This becomes trickier with increasing frequencies, as that means all the wires must have very similar physical properties, such as length and electrical characteristics. Second, parallel wires suffer from crosstalk, which means one wire acts as an antenna and the adjacent wires as receivers, leading to data errors. Those issues have less impact in single wires than when dealing with parallel wires, and using differential signaling reduces the impact even further.</p>
<p>The downside of all this progress is that it’s far more difficult to observe or inject data on a 6 GHz differential signal than it is on a 400 kHz single-ended signal. This difficulty usually translates to “more expensive.” You can easily sniff that 6 GHz signal, but you need a logic analyzer the price of a mid-size sedan.</p>
<p><span epub:type="pagebreak" title="62" id="Page_62"/>The silver lining is that all of these interfaces are electrically very similar, and they are designed to perform reliably even in less-than-optimal conditions. This means if the probe you’ve attached to a PCIe lane loads it so much that it can no longer function at full speed, it will automatically retrain at a lower speed without the rest of the system even noticing.</p>
<h3 id="h2-278748c02-0020">Universal Serial Bus</h3>
<p class="BodyFirst">USB was the first major external interface that used high-speed differential signaling, and it set a few excellent precedents. First, if you plug in a USB device to a host equipped with a different version of the USB standard, both ends of the connection automatically settle at the highest common standard. Second, if transmissions are lost, missed, or interrupted, they are automatically retried. Finally, USB actually defines many characteristics, such as the connector shapes and pinouts, the electrical protocol, and the data protocol, all the way up to device classes and how to interface with them. An example is the USB <em>Human Interface Device (HID)</em> specification used for equipment like keyboards and mice, which allows the operating system (OS) to have one driver for all USB keyboards, instead of one per manufacturer.</p>
<p>USB connections feature one host and up to 127 devices (including hubs). USB versions are capable of different bit rates, from 12Mbps at USB 1.1, 480Mbps at USB 2.0, and up to 5, 10, and 20Gbps in USB 3.0, 3.1, and 3.2, respectively. For data rates up to 480Mbps, four wires are used. Above 480Mbps, five additional wires are needed. All nine wires are as follows:</p>
<ol class="none">
<li><span class="RunInHead">VBUS</span>  A 5 V line that can be used to power a device.</li>
<li><span class="RunInHead">D+ and D-</span>  The differential pair for communication up to version USB 2.0.</li>
<li><span class="RunInHead">GND</span>  Venerable ground (for power).</li>
<li><span class="RunInHead">SSRX+, SSRX-, SSTX+, SSTX-</span>  Two differential pairs, one for reception and one for transmission (USB 3.0 and above).</li>
<li><span class="RunInHead">GND_DRAIN</span>  Another ground for signal; this additional ground has less noise than the power ground, which may be dealing with much larger currents (USB 3.0 and above).</li>
</ol>
<p>The USB’s power line provides a minimum of 100 mA at 5 V, which you can tap to power things in your setup. Depending on the USB standard and the host, this available current can go up to 5 A at 48 V (5 A × 48 V = 240 W), but you actually need to talk to the USB host digitally before it will allow you that amount of juice.</p>
<p>Now, for fun, grab your nearest USB 2.0 micro-cable and count the number of pins. You’ll find five, whereas only four are needed for USB 2.0. The fifth pin is the ID pin, originally used for USB On-The-Go (OTG). Devices that can be both host or peripheral use OTG, and they come with a special OTG cable with a host and a peripheral end.</p>
<p><span epub:type="pagebreak" title="63" id="Page_63"/>The ID pin signals which end is inserted so the device can sense whether its role should be host or peripheral: a grounded ID pin signals “host,” and a floating ID pin signals “peripheral.” However, as Michael Ossmann and Kyle Osborn showed in their 2013 Black Hat talk “Multiplexed Wired Attack Surfaces” (<a href="https://www.youtube.com/watch?v=jYa6-R-piZ4" class="LinkURL">https://www.youtube.com/watch?v=jYa6-R-piZ4</a>), you can enable hidden functionality through resistance values other than “grounded” or “floating.” They show that if you present a Galaxy Nexus (GT-I9250M) with 150 kΩ resistance on the ID pin, it then turns USB off and a TTL serial UART on, which then provides debugging access.</p>
<p>USB is pervasive and has been around for two decades, so it’s likely to be the best example of a high-speed serial interface that you can observe or manipulate as readily as other much simpler and slower interfaces. It also has the advantage of standard communications protocols, which means you can request specific information from almost any USB device. The USB stack itself is relatively complicated, so fuzzing often produces interesting results, which fault injection can push further. Micah Scott has an excellent demonstration of this, which you can see in a video titled “Glitchy Descriptor Firmware Grab – scanlime:015” (<a href="https://www.youtube.com/watch?v=TeCQatNcF20" class="LinkURL">https://www.youtube.com/watch?v=TeCQatNcF20</a>).</p>
<h3 id="h2-278748c02-0021">PCI Express</h3>
<p class="BodyFirst"><em>PCI Express (PCIe) </em>is the high-speed serial evolution of the old PCI bus, and its architecture is surprisingly similar to USB. Both use high-speed differential pairs to make point-to-point links. Both have clearly defined hierarchies and protocols for enumerating devices. Both are backward compatible and automatically negotiate the optimal interface.</p>
<p>Although PCIe was designed with personal computers rather than embedded systems in mind, ARM and MIPS-based System-on-Chips (SoCs) currently on the market support PCIe, and you can find them in embedded systems costing as little as $20. PCIe starts at 2.5 GHz instead of only 12 MHz, as is the case with USB, so a simple sniffer isn’t going to cut it. However, a few PCIe devices are versatile enough to enable some unintended uses.</p>
<p>A unique characteristic of PCIe is that it’s usually very tightly coupled with the CPU or SoC. Whereas USB doesn’t work without all the applicable drivers in place, PCIe usually gets full access to system memory as well as to all other PCIe devices and other devices in the system. If you can manage to get a rogue PCI device into your target system, you might be able to control all of the hardware in the entire system. See <a href="https://github.com/ufrisk/pcileech/" class="LinkURL">https://github.com/ufrisk/pcileech/</a> for some examples on how to use PCIe to get memory dumps.</p>
<h3 id="h2-278748c02-0022">Ethernet</h3>
<p class="BodyFirst">Ethernet was first standardized in 1983 for creating computer networks. It has variants in terms of physical cables, speeds, and frame types, but the most common types you’ll encounter on an embedded system are 100BASE-TX (100Mbps) and 1000BASE-T (1Gbps) with the familiar 8P8C <span epub:type="pagebreak" title="64" id="Page_64"/>plug. This plug connects to a cable that contains four <em>twisted pairs </em>of wires. Each pair is used for differential signaling, and the twisting reduces crosstalk and external interference.</p>
<p>Both standards run at a 125 MHz line baud rate, which means if you hook up an oscilloscope, you’ll see 125 MHz signals. The 10 times speed difference between 100BASE-TX and 1000BASE-T is because 100BASE-TX uses +1 V, 0 V, or −1 V over a single wire pair, whereas 1000BASE-T uses −2 V, −1 V, 0 V, +1 V, and +2 V levels on all four wire pairs.</p>
<h2 id="h1-278748c02-0006">Measurement</h2>
<p class="BodyFirst">No hardware book is complete without some basics on measurement. You’ll use measurements to learn more about your target, but more important, understanding measurements will help you debug all the connection mishaps you may encounter. Let’s look at some basic tools—the trusty old multimeter, flashy oscilloscopes, and tragically hip logic analyzers—and discuss why and how to use them, what can go wrong, and some references for good additions to your lab.</p>
<h3 id="h2-278748c02-0023">Multimeter: Volt</h3>
<p class="BodyFirst">Measuring voltage is important for determining supply voltages or communication voltages. If you intend to power a chip yourself using a lab supply, using a voltmeter is a good sanity check before attaching the power supply (where you’ve found the voltage from the device datasheet hopefully). Similarly, for communication voltages, you may need to match the voltages on the PCB to your communication interface using <em>level shifters</em>.</p>
<p>Set your multimeter to measure DC voltage. The multimeter’s AC measurement setting doesn’t come into play in the types of circuits we are interested in here. Some meters will have auto-ranging functions, and some meters will need you to set a “maximum range.” For measuring a 3.3 V voltage, you would need to set the range switch to above the 3.3 V, so a 10 V, 20 V, and 200 V range would all work. Consult your user manual for more details. Measure the voltage between ground (normally you can put the black probe on the chassis, but sometimes that isn’t ground) and the point where you want to know the voltage level.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Warning</span></h2>
<p>	You may have multiple input leads on your multimeter. For measuring current, there is often a shunt input that allows you to replace a piece of wire with your multimeter leads (the multimeter goes in series with the circuit). Don’t leave your test leads in the current measurement (shunt) connections, because if you accidently attempt to measure a voltage while they are plugged in to the current measurement ports, you are actually just applying a direct short across your device! Connecting your nice red probe to a high-power source and taking the black probe to ground, may lead to blue smoke, fireworks, and bricked devices/multimeters (just ask Jasper’s high-school administration department, which apparently was sharing a fuse in the fuse box with the science department).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-278748c02-0024"><span epub:type="pagebreak" title="65" id="Page_65"/>Multimeter: Continuity</h3>
<p class="BodyFirst">Measuring <em>continuity </em>lets you find out whether two points are connected, which can be useful for tracing wires, headers, pins, and so on, on a PCB. To measure continuity, set the multimeter to ohm, because a resistance close to zero means that two points are electrically connected. Again, check your manual on exactly how to connect it. Power down the target when you measure resistance so that there is almost no risk of damaging anything. Put the two probes on two points, and if the resistance is close to zero (or you hear a beep), you have a connection. Get a multimeter that beeps when there is a connection so you don’t need to monitor its screen all the time.</p>
<p>The continuity test is done by running a small current through the probe leads and measuring the voltage. If you attempt to measure a device that still has power, you will often get false readings since the meter will “see” a voltage that is actually supplied by your circuit under test.</p>
<h3 id="h2-278748c02-0025">Digital Oscilloscope</h3>
<p class="BodyFirst">An <em>oscilloscope</em> measures and visualizes analog signals in the form of variations in voltage over time. When we say oscilloscope or scope, we mean <em>digital </em>sampling oscilloscopes, as analog scopes don’t have the features we need. Scopes can measure digital communication channels (although a logic analyzer is a more fitting tool), and with the right probes and target preparation scopes can measure power consumption or electromagnetic (EM) radiation when you’re performing side-channel analysis. It’s a critical tool for discovering what’s going on in your PCB’s analog domain. Appendix A describes oscilloscopes from the perspective of their features. Here we focus on their usage.</p>
<p>A scope has a number of <em>input channels </em>that are<em> </em>connected via one or more <em>probes</em><em> </em>to a signal source, which can be a PCB trace or header, a pin of a microcontroller, or simply a coil to measure EM signals. A probe often <em>attenuates </em>(reduces the amplitude of) the signal source before forwarding the signal to the oscilloscope. For the probes that come with a scope, this attenuation is usually 10× and should be marked on your probe somewhere. This means that a 1 V differential in your signal results in a 0.1 V differential on the input to your scope; however, your scope probe may be switchable between 1× (which does not attenuate) and 10× (which does attenuate).</p>
<p>The big advantage of attenuation is that it reduces the loading on your circuit and increases the frequency response of the scope. Using a scope probe in 1× mode typically means a low bandwidth (cannot measure high-frequency signals), and the electrical load of the scope probe may affect your circuit under test. For this reason, many high-performance oscilloscope probes are fixed in 10× mode, as most users prefer the high-frequency response advantage of the 10× mode.</p>
<p>Any probe also needs to be <em>impedance matched </em>with your scope. The scope will have an <em>input impedance </em>(for example, 50 <span class="NSSymbol">Ω</span> or 1 M<span class="NSSymbol">Ω</span>), and your probe’s impedance needs to be the same to avoid signal degradation. <span epub:type="pagebreak" title="66" id="Page_66"/>Imagine two pipes connected together. If one pipe is much narrower than the other, a wave of water cannot properly propagate between the pipes; part of the wave energy bounces back at the connection point. In measurement terms, RG58U probe cables have a 50 <span class="NSSymbol">Ω</span> characteristic impedance, meaning that for very fast changes (such as steep edges), the cable looks like a 50 <span class="NSSymbol">Ω</span> termination. If you leave the scope at 1 M<span class="NSSymbol">Ω</span>, then the discontinuity causes the edge to reflect (bounce back) when it arrives at the scope. This distorts the measurement.</p>
<p>The impedance on the scope may be fixed or configurable, and that of the probe is fixed. Normal oscilloscope probes are designed for 1 M<span class="NSSymbol">Ω</span> impedance. If you have fancy (expensive) oscilloscopes, they may automatically detect the type of probe attached. You may need an <em>impedance matcher</em> if you have a mismatch. Some special probes (such as current probes) require a 50 <span class="NSSymbol">Ω</span> impedance, for example, and if your oscilloscope doesn’t have this option, you’ll need such an impedance matcher.</p>
<p>Both the scope and the probe will also have an analog <em>bandwidth</em>, expressed in Hz, which represents the maximum frequency they can measure. The probe and scope don’t need to be matched, but the total bandwidth of the probe and scope is limited by the component with the lowest bandwidth. The signal you want to measure should be within that bandwidth. For instance, with side-channel analysis, make sure your scope’s bandwidth is higher than your crypto’s clock frequency. (This, however, is not a hard requirement; sometimes crypto will leak at frequencies lower than the clock.)</p>
<p>You can insert a <em>low-pass filter</em> to limit the bandwidth artificially, which can be handy to filter out noise in your signal. Similarly, you can add a <em>high-pass filter</em>, often used to remove DC or low-frequency components (many power supplies have low-frequency noise, for example). Select these filters based on frequency analysis of earlier measurements or knowledge of the target signal. The Mini-Circuits brand has some easy-to-use analog filters; make sure to impedance-match those with the scope and probe.</p>
<p>You can configure the scope channel in AC or DC coupling mode. <em>DC coupling</em> means it can measure all the way down to 0 Hz voltage (<em>DC offsets</em>), whereas <em>AC coupling</em> means very low frequencies are filtered out. For side-channel analysis, it’s usually not a big difference, so AC is a bit easier to use, as you don’t need to center the signal.</p>
<p>Now that an analog signal is entering the scope, it needs to be converted to a digital signal using an <em>analog-to-digital converter (ADC)</em>. These have a resolution normally measured in bits. For instance, many scopes have an 8-bit ADC, which means the voltage range of the scope is divided into 256 equally <em>quantized </em>ranges. <a href="#figure2-16" id="figureanchor2-16">Figure 2-16</a> shows a simple example of a 3-bit ADC output, where a nice sine wave input is converted to a digital output (resembling the world of a once-popular 8-bit computer game featuring an Italian plumber).</p>
<p>This digital output has only fixed values; thus, the ADC doesn’t perfectly represent the input signal. The amount of error depends partly on the resolution; for example, if we have an 8-bit ADC instead of a 3-bit ADC, the “staircase” in the output of <a href="#figure2-16">Figure 2-16</a> would have much smaller steps. However, the error in terms of absolute voltage depends also on the total range we are <span epub:type="pagebreak" title="67" id="Page_67"/>asking the ADC to represent. A 10 V range represented in 3 bits (eight steps) means each bit is 1.25 V, but a 1 V range in the same 3 bits would mean each step is 0.125 V.</p>
<figure>
<img src="image_fi/278748c02/f02016.png" alt="f02016"/>
<figcaption><p><a id="figure2-16">Figure 2-16</a>: The sine wave input is converted to the step sequence of the digital output.</p></figcaption>
</figure>
<p>The scope will have a minimum and maximum voltage, denoted by the <em>voltage range</em>, which is often configurable. Almost every scope will have an adjustable <em>span</em>, but some will also have an adjustable <em>input offset</em> too. The span would show the maximum range we could measure; for example, a 10 V span could mean we measure from –5 V to 5 V. If we have an input offset, we could shift that same span to mean a measurement of 0 V to 10 V instead. Be sure to configure it so that it narrowly hugs the signal in which you’re interested. If you make the range too small, you’ll <em>clip</em> the signal as its voltage goes outside the range. If you make the range too large, you’ll get a large <em>quantization error</em>. If you are using only 10 percent of the range, you’re making use of only about 10 percent of 256 of the possible same values. Different scopes will have different ranges of the input offset and spans.</p>
<p>These ADCs operate at a programmable <em>sampling rate</em>, which means the number of times per second they output a new sample. A <em>sample</em> is simply one measurement output. Normally, the sampling rate should be at least twice as fast as the highest frequency you want to capture, as stated in the Nyquist-Shannon sampling theorem. In practice, sampling higher than twice the highest frequency is better; go up to five times higher. If your oscilloscope measurement is <em>synchronous</em> to the target device, where each sample point occurs on the target clock cycle, you can get away with reduced sample rates.</p>
<p>A series of samples is called a <em>trace</em>. A digital oscilloscope has a buffer to record traces, called the <em>memory depth</em>. Once the recording fills up the memory, traces either need to be sent to a PC for processing or be discarded for the next measurement.</p>
<p><span epub:type="pagebreak" title="68" id="Page_68"/>The depth and sampling rate together determine the maximum length of a trace. For efficiency, it’s important to limit the trace length. The length of the trace is configured by the number of samples to acquire in a single trace.</p>
<p>An oscilloscope can be continuously measuring (recording) data, or else it can be started by an external stimulus called the <em>trigger</em>. The trigger is a digital signal that also comes into the scope through a dedicated trigger channel or normal probe channel. Once a scope is <em>armed</em>, it waits for the trigger signal to go above a configurable <em>trigger level</em>, after which the oscilloscope starts measuring a trace. If the scope does not observe a high trigger before the <em>trigger timeout</em>, it assumes a <em>trigger miss</em> and starts a measurement anyway. Setting the trigger timeout to something noticeable (like 10 seconds) is useful. If you see your <em>acquisition campaign</em> (taking lots of measurements) slow down to one trace every 10 seconds, you know you’re missing triggers. Initially, measuring and also looking at the <em>trigger channel </em>trace is helpful in order to debug any trigger issues.</p>
<p>In lab situations, the target itself often generates the trigger. For instance, if you want to measure a particular cryptographic operation, first pull the trigger high through an external general-purpose input/output (GPIO) pin and then start the operation. This way, the scope starts capturing just before the operation starts.</p>
<p>Once the trace is fully captured, high-end scopes have a built-in display for visualization, while more simple USB scopes send the digital signal to a PC for visualization. Both can send the traces to a PC for analysis—for instance, for finding side channels!</p>
<p>Just like when you’re measuring voltages with a multimeter, your target needs to be powered on, so take precautions not to hurt yourself or your equipment. Also, make doubly sure all of these tools are properly configured. Misconfiguring a scope is not always self-evident, so be a good person and save your future self a lot of time spent redoing borked measurements.</p>
<p>Common errors include failing to ground the scope leads correctly. If you’re using multiple scope probes, each one should be grounded, and you must ensure you are grounding each one to the same ground plane (otherwise, current will flow through your oscilloscope). If you will be working with high frequency or low noise measurements, a good ground is essential. Many oscilloscope probes have a little <em>spring ground </em>option, as shown in <a href="#figure2-17" id="figureanchor2-17">Figure 2-17</a>.</p>
<figure>
<img src="image_fi/278748c02/f02017.png" alt="f02017"/>
<figcaption><p><a id="figure2-17">Figure 2-17</a>: A spring ground lead on a small oscilloscope probe</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="69" id="Page_69"/>With this grounding method, there is a small spacing between the ground on the PCB and the oscilloscope probe. It often requires bending the spring lead to fit your PCB, but it’s a low-cost and simple way of getting good high-frequency performance.</p>
<p>When setting up your measurements, you also want your connections to be physically robust. Scope probes hanging off a bench may get snagged by clothing (or any lab pets) and pull your expensive development board and the scope off with it. Temporary cable ties, hot glue, sticky tape, or even just heavy objects, are perfect for ensuring your probe wires aren’t about to be snagged by a passing body.</p>
<p>As much as possible, it’s best to change equipment settings or probe positions with the circuit off. It’s easy to slip when attaching a scope probe, and shorting out a power supply with a probe tip will often lead to pitting of the probe tip itself if an arc forms. Even the low voltages present in typical development boards can cause small arcs that damage your probe tips. Of course, you can also damage your device under test by shorting it out—or even shorting a higher voltage (such as a 12 V input voltage) to the low-voltage circuitry.</p>
<h3 id="h2-278748c02-0026">Logic Analyzer</h3>
<p class="BodyFirst">A <em>logic analyzer</em> is a device that allows you to capture digital signals. It’s like the digital variant of an oscilloscope. With it, you can capture and decode communications channels that use voltages for encoding data. You could use a logic analyzer to decode I2C, SPI, or UART communications, or to probe much wider communication buses at various baud rates. Like an oscilloscope, a logic analyzer has a number of channels, a sampling rate, voltage levels, and an (optional) trigger (see <a href="#figure2-18" id="figureanchor2-18">Figure 2-18</a>).</p>
<figure>
<img src="image_fi/278748c02/f02018.png" alt="f02018"/>
<figcaption><p><a id="figure2-18">Figure 2-18</a>: Sample time series measurement from logic analyzer</p></figcaption>
</figure>
<p>Some oscilloscopes do rudimentary logic capture and protocol analysis, but they are more limited in the number of channels. Conversely, some logic analyzers do rudimentary analog signal capture, but at very low bandwidths and sampling rates.</p>
<p><span epub:type="pagebreak" title="70" id="Page_70"/>Not much can go wrong with logic analyzers. Like with a scope, you need to use it on a powered-on system, so all safety precautions apply.</p>
<h2 id="h1-278748c02-0007">Summary</h2>
<p class="BodyFirst">This chapter discussed a range of topics relating to hardware interfaces: electrical basics, using those basics for communication, as well as the different types of communication ports and protocols you may encounter on embedded devices. We’ve covered more than you’ll need to be able to communicate with a single device, so think of this chapter as a reference to browse through later, when you’ll have questions about what a volt is, what differential signaling is, or what that six-pin header on the PCB might be (more on that in <span class="xref" itemid="xref_target_Appendix B">Appendix B</span> as well). This book comes with an index to help you identify where to look for particular information. We’ll be using the most well-known interfaces in the labs later in this book, but when it comes time to do work, you’ll need to communicate with all sorts of devices. With some practice, connecting to interfaces becomes just a small hurdle to leap over before getting to the interesting work of actually sending data on the interfaces (and eventually getting secrets out of them). In the meantime, use your knowledge of measurements (digital or analog) to debug the inevitable connection issues you’ll have. Just beware of the blue smoke! </p>
</section>
</body></html>