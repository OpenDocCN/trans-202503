- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automated Infrared Remote Control by Kaas Baichtal
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll use infrared LEDs and a Raspberry Pi to automatically
    operate a remote controlled device.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0111-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**HOW IT WORKS: INFRARED LIGHT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the early 1800s, astronomer William Herschel discovered that sunlight split
    into colors by a prism is noticeably warmer the closer it is to the red end of
    the spectrum. However, the area of the spectrum beyond red is even warmer. It
    turns out there is another, warmer color of light—called *infrared (IR)*—which
    humans can feel but not see.
  prefs: []
  type: TYPE_NORMAL
- en: Infrared means “below red,” so named because it has a lower *frequency* (waves
    per second) than visible red light. The electromagnetic spectrum chart in [Figure
    6-1](ch06.xhtml#ch06fig1) shows the relationships between all radiant energies,
    including light, radio waves, microwaves, gamma rays, and X-rays.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0112-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-1:** The electromagnetic spectrum'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrared LEDs**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Infrared LEDs have been around since the early 1960s. In fact, they were invented
    a year or two before LEDs that emit visible light. [Figure 6-2](ch06.xhtml#ch06fig2)
    shows an example of an infrared LED.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0112-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-2:** An infrared LED. The larger section visible inside corresponds
    to the negative lead.'
  prefs: []
  type: TYPE_NORMAL
- en: Like all diodes, an LED is a semiconductor. Current passes through a diode more
    easily in the forward direction than it would in reverse. It also emits a small
    quantity of electromagnetic radiation as it moves forward through the diode. Where
    this emission lies on the electromagnetic spectrum depends upon what materials
    were used to manufacture the diode. Regular diodes made of silicon and germanium
    do not tend to emit light, while other semiconductor materials can emit various
    colors of visible light, as well as ultraviolet and infrared. Infrared LEDs are
    usually made with gallium arsenide (GaAs) or aluminum gallium arsenide (AlGaAs).
  prefs: []
  type: TYPE_NORMAL
- en: When an LED is reverse-biased (hooked up backward), no light will be produced.
  prefs: []
  type: TYPE_NORMAL
- en: '**Line-of-Sight Communications**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Infrared LEDs have dozens of important applications, including data communications.
    Circuits that send data using IR LEDs are called *transmitters*. Circuits that
    receive the infrared light and convert it back to data are called *receivers*.
  prefs: []
  type: TYPE_NORMAL
- en: Because infrared components transmit and receive light, they need to be able
    to “see” each other to successfully communicate (see [Figure 6-3](ch06.xhtml#ch06fig3)).
    This is commonly referred to as *line-of-sight communications*. Nothing opaque
    can be in the way, and the narrower the light beam the transmitting LED emits,
    the more precisely the transmitter needs to be aimed at its receiver. There are
    ways to steer or reflect light in non-line-of-sight directions when necessary,
    however—for example, through the use of mirrors, fiber optics, and light pipes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0113-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-3:** This IR remote has a hole for its transmitter’s LED to beam
    out, while the air conditioner it controls has a small red window to allow IR
    light to shine in upon its receiver.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it may seem like a disadvantage, the line-of-sight nature of infrared
    communications actually has its pluses: the IR transmissions are unlikely to interfere
    with other IR communications happening in completely different rooms or buildings.
    Anybody who has ever had their ceiling fans turned on and off by a neighbor’s
    radio remote will be able to appreciate that!'
  prefs: []
  type: TYPE_NORMAL
- en: For this project we will use simple line-of-sight communications, orienting
    the IR transmitter attached to our Raspberry Pi so that it can be seen by the
    air conditioner without problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Transmission**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the simplest possible sense, an IR transmitter communicates data by turning
    its LED on and off. For example, it would be possible to communicate using Morse
    code with an LED. However, several complicated languages and systems, called *protocols*,
    have been developed specifically for data communication over IR. Over the decades,
    more and more information has needed to be conveyed through the messaging sent
    by remotes. This has sparked many inventive ways of increasing the signal-to-noise
    ratio, error correction, and data carrying capacity. Here’s an overview of some
    of the things that might be included in a protocol specification:'
  prefs: []
  type: TYPE_NORMAL
- en: The frequency of infrared light used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The carrier frequency or frequencies used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of devices supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of commands per device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of bits used in encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The encoding procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key-to-code mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data rate, which may be variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modulation schemes of the transmitted pulses and/or the spaces between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before the advent of programmable microcontrollers, transmitters and receivers
    needed additional circuitry to accomplish everything a protocol required. A general
    lack of compatibility led to the development of “universal remotes,” which either
    have the payloads of many other remotes preprogrammed into them, or simply record
    the signals of other remotes and parrot them back upon command. This latter is
    the procedure we’ll be using in this project to begin “teaching” the Raspberry
    Pi how to control the A/C, using a USB IR Toy (see [Figure 6-4](ch06.xhtml#ch06fig4)).
    The USB IR Toy has a transmitter and receiver on the same circuit board, so we
    can use it to record the signals from the air conditioner’s remote as well as
    mimic them.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0115-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6-4:** The USB IR Toy'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET THE PARTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The instructions in this project will use the equipment listed here. New to
    electronics projects? Stick with this parts list and I’ll make it easy!
  prefs: []
  type: TYPE_NORMAL
- en: If you have more experience and are able to modify the steps, feel free to substitute
    your own transmitter, receiver, computer, OS, and A/C or other item to be controlled.
  prefs: []
  type: TYPE_NORMAL
- en: 'USB IR transmitter and receiver (I used a Dangerous Prototypes USB IR Toy 2,
    which is available either prebuilt or in kit form. The prebuilt ones are available
    at Seeed Studios with SKU #102990037; *[https://www.seeedstudio.com/USB-Infrared-Toy-v2-p-831.html](https://www.seeedstudio.com/USB-Infrared-Toy-v2-p-831.html)*.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USB cable with A and mini-B connectors (for example, Adafruit P/N 260)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi (Any model will work, but it will need to have Raspbian installed
    via NOOBS—see “[Getting Started with the Raspberry Pi](intro.xhtml#lev12)” on
    [page 13](intro.xhtml#page_13) for instructions on setting that up.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An air conditioner that has an IR remote (I used a Haier HWR08XC7.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of this section deals with modifications, so if you’re using the parts
    listed, feel free to skip to “[Build It](ch06.xhtml#lev90)” on [page 117](ch06.xhtml#page_117).
  prefs: []
  type: TYPE_NORMAL
- en: Any computer that has a USB port for the IR Toy 2 and is capable of running
    LIRC (Linux Infrared Remote Control) will work for this project. I chose a Raspberry
    Pi because I could get one bundled with a case, power supply, and NOOBS SD card
    cheaply on Amazon. Raspbian is the distribution being used for other projects
    in this book, so that’s what I’ll be providing instructions for, but everything
    we do here should be modifiable to work on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you use, you’ll need the LIRC package (*[http://www.lirc.org](http://www.lirc.org)*/)
    for this project. LIRC is handy for this kind of task because 1) it can be installed
    on many flavors of Unix-like and Windows OSes; 2) it allows multiple programs
    to listen to one receiver; 3) it comes with helpful tools for memorizing remote
    controls and sending commands manually; and 4) its website has plenty of hardware
    compatibility info, so you can easily adapt this project to work with other hardware.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there are lots of preconfigured *.conf* files for different handheld
    remotes, located at *[http://lirc-remotes.sourceforge.net/remotes-table.html](http://lirc-remotes.sourceforge.net/remotes-table.html)*.
    In theory, you can control any device that works with one of those listed IR remotes
    without doing any coding or even having to scrabble in your couch cushions to
    find the remote. But few of those preconfigured remotes are intended for air conditioners,
    so for this project we’ll just create our own *.conf* file and not stress about
    finding a matching one.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, since we’ll be creating our own *.conf* file anyway, you could use
    any IR-controllable device and the procedure will be exactly the same, as long
    as you still have its physical remote to imitate the codes from. Xbox? Roomba?
    DVD player? No problem!
  prefs: []
  type: TYPE_NORMAL
- en: If you intend to buy an A/C unit for the project, just go for one that, besides
    having the IR capability, meets your cooling needs and is a common everyday brand
    where you live.
  prefs: []
  type: TYPE_NORMAL
- en: 'For my IR transmitter and receiver, I chose the USB IR Toy 2 by Dangerous Prototypes
    for three reasons: it’s fully compatible with LIRC; it’s relatively inexpensive
    at $20 for a preassembled version (or almost nothing if you want to assemble it
    yourself); and finally, since it has both a transmitter and a receiver, I only
    have to deal with one device. Although actually controlling the air conditioner
    requires just a transmitter, we need the receiver as well since we’re creating
    our own initial configuration files.'
  prefs: []
  type: TYPE_NORMAL
- en: '**BUILD IT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s make the project! The following steps assume you already have an assembled
    IR transmitter and receiver, A/C unit and remote, and `sudo` root privileges on
    your Pi. (Raspbian provides the “pi” user for this purpose.)
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*At the time of this writing, there were also user-contributed versions v23
    and v24, which could be found in the forums on the website.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Upgrade your USB IR Toy 2’s firmware.** Follow the directions on the Dangerous
    Prototypes website’s USB IR Toy 2 page (*[http://dangerousprototypes.com/docs/USB_IR_Toy_firmware_update](http://dangerousprototypes.com/docs/USB_IR_Toy_firmware_update)*)
    to upgrade its firmware to the latest version, which was officially v22 at the
    time of this writing. Performing a firmware upgrade could save you a lot of trouble
    depending on which revision your unit shipped with, as some earlier versions did
    not support transmitting!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can upgrade your firmware via the USB port using almost any computer. After
    downloading and unzipping the firmware upgrade package from the Dangerous Prototypes
    website, follow the instructions provided on the site. The procedure and results
    will vary depending on your setup, so I won’t go into a lot of detail except to
    say that on my Windows 7 desktop I had to manually install the driver included
    in the *inf-driver* subdirectory, a detail not mentioned in the instructions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the computer recognizes the USB IR Toy 2, run the *update-USBIRToy.v22.bat*
    file in the firmware subdirectory and, when it asks, give it the port number assigned
    to your device (see Note for details).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*If you did not receive a COM port, and can’t find it listed as a COM port
    in your Device Manager or equivalent, just press ENTER when you get to this question.
    You only need the port number if you were automatically assigned one.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I found it helpful to pause momentarily every time I plugged in or changed anything,
    as Windows re-recognized the USB IR Toy 2 more than once during this process,
    and the interruption caused the firmware updater to not find the device. Once
    the device was successfully recognized, the firmware upgrade process was quick
    and easy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Upgrade the Raspberry Pi’s OS and firmware.** I recommend making sure your
    operating system is 100% patched/upgraded and the Raspberry Pi has also had its
    firmware fully updated to the latest version before you begin.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Check LIRC’s dependencies.** Now make sure your system has everything LIRC
    requires. The list can be found at *[http://www.lirc.org/html/install.html#dependencies](http://www.lirc.org/html/install.html#dependencies)*.
    I checked by entering the following lines on the Linux command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each command should produce the full path of the item in question. If there
    is no response, the item is missing from the system. Two more checks you should
    perform are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have these, you should see some information about the package in question;
    if you don’t, you should see a complaint saying the packages were not found. My
    fresh NOOBS install of Raspbian lacked both of these latter packages as well as
    xsltproc from the preceding list, so I installed the necessary items as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Install LIRC.** Next, download the LIRC source, which can be obtained on
    SourceForge at *[https://sourceforge.net/projects/lirc/files/LIRC/](https://sourceforge.net/projects/lirc/files/LIRC/)*.
    Choose the directory with the most recent version of the code, save the *.tar.gz*
    file for that version, and then go to the save location. To extract and install
    LIRC, enter the following on the Linux command line, inserting your correct version
    number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Connect the USB IR Toy 2.** Now, power down your Pi, then plug in the USB
    IR Toy 2\. Make sure to power the Pi down every time you plug and unplug your
    Toy, or you risk blowing stuff up! After rebooting your machine, look in the `dmesg`
    logfile to see if the Pi found your device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see output like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This output shows that the Pi found my USB IR Toy 2 and was able to automatically
    find and load the correct kernel-level driver for it, `cdc_acm`. If your machine
    doesn’t load a kernel-level driver after finding the Toy, you can modify your
    system to load it each time the machine is booted. If you’re using Raspbian, you
    can do this by editing the file */etc/modules* and adding the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*If you’re using a completely different IR transmitter/receiver for your project,
    you’ll quite likely have a different kernel-level driver. That too can be loaded
    in*/etc/modules.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once that’s working, you can use `dmesg` as follows to find the device name
    that’s been assigned to the USB IR Toy 2 (which you’ll need in the next step):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'My output gave me the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, my USB IR Toy 2 has been assigned to device */dev/ttyACM0*. Write
    down your device assignment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Configure *lirc_options.conf*.** LIRC has put some default configuration
    files in */usr/local/etc/lirc*. For this step you need to edit */usr/local/etc/lirc/lirc_options.conf*
    as superuser and change the `driver` parameter (not the kernel-level driver in
    this case, but the LIRC plug-in) to `irtoy` and the `device` parameter to the
    full path of the one you saw in your `dmesg`. Open your */usr/local/etc/lirc/lirc_options.conf*
    file and change those parameters to match the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using something besides a USB IR Toy 2, you can find a list of all
    other available plug-ins using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While you’re in there, you may also need to change the default locations for
    `pidfile` and `output` so they match where they were actually installed on your
    system. In my case, the NOOBS-installed Raspbian, I had to prepend */usr/local*
    to each one. You’ll know you failed if LIRC complains it can’t write the PID file
    when you try to run it!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Paranoia check.** To make sure you’re on track, check that you used the right
    device and driver with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Point any IR remote at the USB IR Toy 2 and push some buttons. You should see
    results flow across the screen, indicating that serial data is available on the
    Pi as a result of your button pushing. Mine started out like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you’re done, press CTRL-C to exit that program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Pick names for your buttons.** The information on each remote control your
    LIRC knows about will be stored in the *.conf* files located in */usr/local/etc/lirc/lircd.conf.d*.
    The next step is to create a file there for the air conditioner. We’ll do this
    using a program called *irrecord*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each button on your remote will need a name in the configuration file. Write
    your choices down so they’ll be handy when you go to record your button presses.
    LIRC has some standardized button names that you can either use or disable; for
    simplicity we’ll use these standard names in this project. You can get the list
    by entering:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For my buttons I chose and wrote down the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Extra credit: get the model number of your remote.** While not strictly necessary
    for this project, it’s a nice touch (and LIRC convention) to have your config
    file named after the remote you are using. I was able to find the model number
    of mine, a Haier AC-5620-30, by scrutinizing the spare parts section on Haier’s
    website and finding a match.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*If at any time during the recording process the USB IR Toy 2 stops functioning,
    I would recommend power-cycling your Pi and unplugging/replugging the USB IR Toy
    2’s cable while the power is off. I don’t know where the fault lies, but recording
    can be a bit dodgy!*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Record the codes sent by the remote.** Now you’ll create a crude initial
    configuration file for your air conditioner’s remote by naming the buttons and
    pushing them such that the raw (not decoded yet) code is recorded and associated
    with its correct button name. Recording the raw signal will allow LIRC to reproduce
    it as an output later when you program your computer to control the A/C.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First move to a scratch directory where you have write privileges:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With your remote in hand and the USB IR Toy 2 arranged so the LEDs point toward
    you, enter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to use your correct driver and device names. The program will step
    you through some processes to gather technical information on the signals your
    particular remote sends. First you’ll be asked to enter the name of your remote.
    Then it will ask you to push many random buttons, which will allow it to see how
    buttons generally work in this new and unfamiliar remote’s unknown protocol. Once
    it is confident it can tell one button push from another, it will ask you to enter
    your chosen button names one by one, and demonstrate the button push for each
    entry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Follow all the instructions through to the end. When it finishes, the contents
    will be saved to a file that starts with the remote model name you provided, and
    ends in *.lircd.conf*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you later find that some button(s) did not record properly, you can re-record
    just those ones by specifying the config file to be updated using `-u`. For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This technique can also be used to adapt someone else’s config file for your
    own remote, if they are compatible enough.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Edit your *.lirc.conf* file.** Using your favorite text editor, open your
    newly created config file, and you should see that it has three sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First comes a comments area, surrounded by hash marks (#), with annotated blanks
    for you to fill in your remote and other relevant details. The LIRC community
    likes this information to be in this uniform format and fully fleshed out in the
    event that you decide to share the file with others. If you intend to keep the
    file to yourself, however, filling in the comments is optional.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, directly under `begin remote`, there should be a section with your remote’s
    name and some basic serial communications characteristics of its signal. This
    information was gathered by irrecord during the process you went through in step
    10, and will be different for different kinds of remotes. Mine looked like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Third, there will be a list of the button names you chose, each accompanied
    by a block of code that irrecord has associated with that button. You may notice
    that some of them look suspiciously short, or otherwise dramatically different
    from their fellows. These may well turn out to be misrecorded ones. You’ll find
    out for sure in the next step. Here’s my first button from that section:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**Test your *.lirc.conf* file.** Move a copy of your *.lirc.conf* file to the
    configuration directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you’re not using the default config file, *devinput.lircd.conf*, for anything,
    you may wish to change its name to something like *devinput.lircd.conf.unused*
    so LIRC doesn’t try to use it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s test the config file. Start LIRC by entering:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With LIRC running, test your new config file by entering:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now push the buttons on your remote while pointing at the USB IR Toy 2\. Test
    each button and check that the name you chose for it pops up on the screen when
    you push it. Make a note if any button press comes up with the wrong name, or
    if any buttons cause the system to get confused (you’ll know because it won’t
    say anything and there will be a long pause before any more pushes work). Those
    are probably misrecorded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you are finished testing, press CTRL-C to get out of `irw`, then kill
    the LIRC process using:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Take your list of erroneous buttons and use the `–u` technique described at
    the end of step 10 to re-record them. If irrecord won’t connect to the USB IR
    Toy 2, you may have to power-cycle the Pi and USB IR Toy 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you are done re-recording, run sudo lircd again. Then run sudo irw again
    and test the buttons. Repeat this step until your config file is 100% accurate!
    This is the file LIRC will look at when you ask it to generate codes to control
    your air conditioner with the USB IR Toy 2, so it pays to get this part right.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Test control of the A/C.** Next you must verify that the recorded commands
    are accurate enough to control the air conditioner itself when reproduced by LIRC.
    You can do this using the `irsend` command. First, start LIRC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now enter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a list of any remote names in your config file(s)—in my case,
    just the one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can list the commands available for a given remote by inserting its name
    exactly as shown in the list:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For me, this produces the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The similarity with my list of chosen button names from step 8 is no coincidence!
    It is reading the names from the config file we created. It should now be possible
    to take one of those button names and combine it with the remote name to send
    a command like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Boom! My air conditioner comes on. If you’re going to be using this to control
    something long-term, you’ll want to test all your buttons vigorously to make sure
    your LIRC and USB IR Toy 2 work together stably.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**PATCHING AN UNSTABLE LIRC**'
  prefs: []
  type: TYPE_NORMAL
- en: The first time I reached this step with LIRC 0.9.4d, I found it very unstable.
    Both LIRC and the USB IR Toy 2 would die with an error message every several commands.
    If I replugged the USB IR Toy 2 and reran LIRC it would work again—for several
    commands. If you encounter this problem like I did, there is a patch available
    at *[https://sourceforge.net/u/bengtmartensson/lirc/ci/experimental-irtoy/](https://sourceforge.net/u/bengtmartensson/lirc/ci/experimental-irtoy/)*
    that should fix it. Although diff patches are designed to be applied automatically,
    you’ll likely have to apply this one manually due to differences in versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the patch, first back up your *lirc_options.conf* file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then go back to the directory where you compiled LIRC, *~/lirc-0.9.4d/* in
    my case. From there, edit *./plugins/irtoy.c* and make the additions and subtractions
    specified in the green and red lines of the diff. Then clean up the directory
    and recompile like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When done recompiling, reinstate your own *lirc_options.conf* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you changed the name of *devinput.lircd.conf* before, you’ll have to delete
    the new copy the compilation added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now repeat step 13 and see if the system now performs reliably. The patch cleared
    up the problem completely for me!
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyze your *.conf* file.** When you are 100% satisfied with the performance
    of your *.conf* file, you can tell LIRC to analyze the remote’s protocol much
    more thoroughly by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Technically you could have tried this immediately after recording the first
    time, but personally I found it worked much better if any errors or missing buttons
    were taken care of first. Once analyzed, my entire file had shrunk considerably
    and now looked like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Not only is this much more compact and easier to read than the raw version shown
    (partially) in step 11, but much more is now known about the protocol used by
    the A/C. In addition to the header, frequency, and so on, the actual commands
    have been decoded, and are expressed in hex instead of as blinks of various lengths
    to be imitated. This means that LIRC actually knows what it is doing now, instead
    of parroting stuff it doesn’t understand. That can only be a good thing when it
    comes to accurately controlling the A/C!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Cut and paste the analysis to replace the raw content in your original *.lircd.conf*
    file and kill and then restart LIRC to give it a try. It should work brilliantly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*If nothing changed or happened when you tried to analyze your file, LIRC wasn’t
    able to figure out your protocol. Just keep using your raw* .conf *file in that
    case.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Run LIRC automatically.** Once you have LIRC configured properly, you can
    run it one last time and leave it running. You might also want to set it up to
    start automatically when you start your Pi, if you plan to set up tasks for your
    air conditioner controller that need to keep working if the machine gets rebooted.
    To do that on a Raspbian system, edit your */etc/rc.local* file as superuser and
    add the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Program the Pi to run your A/C.** Now that you have your USB IR Toy 2 talking
    to LIRC and have proven you can control your air conditioner with it, you have
    lots of interesting options for automating the actual running of the A/C. Go to
    *[http://www.lirc.org/software.html](http://www.lirc.org/software.html)* for a
    list of LIRC-related and compatible software and applications that let you manipulate
    your A/C in different ways or integrate it with your multimedia setup. I like
    using the command line, so my example script will be written in bash. But don’t
    let that stop you from experimenting with everything out there!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s say that the room your A/C is in heats up in the daytime while you’re
    at work or school. The air conditioner can be left on to keep the room cool all
    day, but it would be much more economical to have it turn on right before you
    come home. So let’s say you want it to come on at 4:30 PM. Linux has a daemon
    called `cron` that can run programs on schedules. You could write a `cron` job
    to accomplish your goal by entering:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add a line like this to your crontab:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This specifies that a script named *air_conditioner.sh* on the path specified
    will be run at 30 minutes after the 16th hour each day. (If you want to do more
    with `cron`, try reading `man crontab`!)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create the actual script in your text editor and save it as *air_conditioner.sh*.
    An example of a bash script to turn on the air conditioner might be as simple
    as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This assumes that the A/C is always off when you leave in the morning. Since
    it is an *open-loop* control system (meaning the computer has no way of knowing
    whether the A/C was on or off to begin with), the beginning state has to be known
    for it to work right. Therefore, some things you want to do may require cleverness
    on your part to ensure the starting state is always known.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**TAKE IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One option for modifying this project is to make it a *closed-loop* system where
    the Pi can actually check on the state of the A/C. You could set up a temperature
    sensor in the room, or an inductive current sensor on the air conditioner’s power
    cord, then have the Pi read the signals from those to determine what the A/C is
    doing. You could even have the Pi visually check for the state of the LEDs on
    the front of the A/C, if you are feeling ambitious and have a camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you keep it an open-loop system, there are ways to make use of external
    information to add power to your automation. Here’s an experiment you can try
    right now: say you want the A/C to come on at 4:30 only if it’s over 90 degrees
    outside. You could power it off in the mornings, and have your Pi check the NOAA
    (National Oceanic and Atmospheric Administration) website for current conditions
    in your area, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Like all websites, NOAA’s may change its URL or content, which may break your
    script. If that happens, modify the URL and/or sed pattern matching in your script
    to get the information you want.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless you live in L.A., you’ll want to change the URL to the one for your
    own city once you have this working. The following commands will strip off the
    saved website, leaving only the current temperature from the current day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s useful to add logging functionality, so you can see if the Pi tried to
    send a power on command or not. You can do so with the `logger` command, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting it all together, I present this sample program for you to edit and
    play with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**SUMMARY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned about infrared light and infrared LEDs, and a few—hopefully!—tantalizing
    bits about communications protocols. You created a system to control an air conditioner
    remotely from a computer using infrared light. I hope that you’ll explore further
    in books and online because there is a lot to learn about serial communications,
    circuit design, and LED technology. To learn the nitty-gritty of designing electronics
    circuits from discrete components, including LEDs, I recommend *The Art of Electronics*
    by Horowitz and Hill.
  prefs: []
  type: TYPE_NORMAL
