- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: Automated Infrared Remote Control by Kaas Baichtal
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动红外遥控，由Kaas Baichtal编写
- en: In this project, you’ll use infrared LEDs and a Raspberry Pi to automatically
    operate a remote controlled device.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用红外LED和树莓派自动操作遥控设备。
- en: '![image](../images/f0111-01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0111-01.jpg)'
- en: '**HOW IT WORKS: INFRARED LIGHT**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**工作原理：红外光**'
- en: In the early 1800s, astronomer William Herschel discovered that sunlight split
    into colors by a prism is noticeably warmer the closer it is to the red end of
    the spectrum. However, the area of the spectrum beyond red is even warmer. It
    turns out there is another, warmer color of light—called *infrared (IR)*—which
    humans can feel but not see.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在19世纪初，天文学家威廉·赫歇尔发现，通过棱镜分解的阳光，越接近红色光谱端的部分温度越高。然而，红色之外的光谱区域则更热。原来有一种温度更高的光——称为*红外（IR）*——人类能感觉到，但看不见。
- en: Infrared means “below red,” so named because it has a lower *frequency* (waves
    per second) than visible red light. The electromagnetic spectrum chart in [Figure
    6-1](ch06.xhtml#ch06fig1) shows the relationships between all radiant energies,
    including light, radio waves, microwaves, gamma rays, and X-rays.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 红外意味着“低于红色”，因其频率（每秒波数）低于可见红光。电磁波谱图在[图6-1](ch06.xhtml#ch06fig1)中展示了所有辐射能量之间的关系，包括光、电波、微波、伽马射线和X射线。
- en: '![image](../images/f0112-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0112-01.jpg)'
- en: '**FIGURE 6-1:** The electromagnetic spectrum'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-1：** 电磁波谱'
- en: '**Infrared LEDs**'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**红外LED**'
- en: Infrared LEDs have been around since the early 1960s. In fact, they were invented
    a year or two before LEDs that emit visible light. [Figure 6-2](ch06.xhtml#ch06fig2)
    shows an example of an infrared LED.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 红外LED自20世纪60年代初就已经存在。事实上，它们的发明比发出可见光的LED早一到两年。[图6-2](ch06.xhtml#ch06fig2)展示了一个红外LED的例子。
- en: '![image](../images/f0112-02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0112-02.jpg)'
- en: '**FIGURE 6-2:** An infrared LED. The larger section visible inside corresponds
    to the negative lead.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-2：** 一个红外LED。内部较大的部分对应于负极引脚。'
- en: Like all diodes, an LED is a semiconductor. Current passes through a diode more
    easily in the forward direction than it would in reverse. It also emits a small
    quantity of electromagnetic radiation as it moves forward through the diode. Where
    this emission lies on the electromagnetic spectrum depends upon what materials
    were used to manufacture the diode. Regular diodes made of silicon and germanium
    do not tend to emit light, while other semiconductor materials can emit various
    colors of visible light, as well as ultraviolet and infrared. Infrared LEDs are
    usually made with gallium arsenide (GaAs) or aluminum gallium arsenide (AlGaAs).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有二极管一样，LED是一种半导体。电流在正向方向通过二极管的阻力较小，而在反向方向则较大。当电流通过二极管时，它还会发出少量电磁辐射。该辐射位于电磁波谱中的位置取决于制造二极管时所使用的材料。由硅和锗制成的常规二极管通常不发光，而其他半导体材料则可以发出各种颜色的可见光，以及紫外光和红外光。红外LED通常由砷化镓（GaAs）或铝镓砷（AlGaAs）制成。
- en: When an LED is reverse-biased (hooked up backward), no light will be produced.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当LED被反向偏置（反向连接时），不会产生光。
- en: '**Line-of-Sight Communications**'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**视距通信**'
- en: Infrared LEDs have dozens of important applications, including data communications.
    Circuits that send data using IR LEDs are called *transmitters*. Circuits that
    receive the infrared light and convert it back to data are called *receivers*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 红外LED有许多重要应用，包括数据通信。使用IR LED发送数据的电路称为*发射器*。接收红外光并将其转换回数据的电路称为*接收器*。
- en: Because infrared components transmit and receive light, they need to be able
    to “see” each other to successfully communicate (see [Figure 6-3](ch06.xhtml#ch06fig3)).
    This is commonly referred to as *line-of-sight communications*. Nothing opaque
    can be in the way, and the narrower the light beam the transmitting LED emits,
    the more precisely the transmitter needs to be aimed at its receiver. There are
    ways to steer or reflect light in non-line-of-sight directions when necessary,
    however—for example, through the use of mirrors, fiber optics, and light pipes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因为红外组件传输和接收光，它们需要能够“看到”彼此才能成功通信（见[图6-3](ch06.xhtml#ch06fig3)）。这通常被称为*视距通信*。传输LED发出的光束越窄，发射器就越需要精确对准接收器。没有什么不透明物体可以阻碍光的传播，然而，在必要时，光也可以通过使用镜子、光纤和光导管等方式引导或反射到非视距方向。
- en: '![image](../images/f0113-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0113-01.jpg)'
- en: '**FIGURE 6-3:** This IR remote has a hole for its transmitter’s LED to beam
    out, while the air conditioner it controls has a small red window to allow IR
    light to shine in upon its receiver.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-3：** 这个红外遥控器有一个孔用于发射器的LED发射光束，而它控制的空调则有一个小红色窗口，允许红外光照射到接收器上。'
- en: 'While it may seem like a disadvantage, the line-of-sight nature of infrared
    communications actually has its pluses: the IR transmissions are unlikely to interfere
    with other IR communications happening in completely different rooms or buildings.
    Anybody who has ever had their ceiling fans turned on and off by a neighbor’s
    radio remote will be able to appreciate that!'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来像是一个劣势，但红外通信的视距特性实际上有其优点：红外传输不太可能干扰到发生在完全不同房间或建筑中的其他红外通信。任何曾经被邻居的遥控器开关天花板风扇的用户，都会理解这一点！
- en: For this project we will use simple line-of-sight communications, orienting
    the IR transmitter attached to our Raspberry Pi so that it can be seen by the
    air conditioner without problems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将使用简单的视距通信，将附加在树莓派上的红外发射器定向，使其可以毫无问题地被空调接收。
- en: '**Data Transmission**'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**数据传输**'
- en: 'In the simplest possible sense, an IR transmitter communicates data by turning
    its LED on and off. For example, it would be possible to communicate using Morse
    code with an LED. However, several complicated languages and systems, called *protocols*,
    have been developed specifically for data communication over IR. Over the decades,
    more and more information has needed to be conveyed through the messaging sent
    by remotes. This has sparked many inventive ways of increasing the signal-to-noise
    ratio, error correction, and data carrying capacity. Here’s an overview of some
    of the things that might be included in a protocol specification:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的角度来看，红外发射器通过开启和关闭LED来传输数据。例如，用LED发送摩尔斯电码也是可能的。然而，为了通过红外进行数据通信，已经开发了几种复杂的语言和系统，称为*协议*。几十年来，遥控器发送的消息需要传递越来越多的信息。这激发了许多提高信噪比、错误校正和数据承载能力的创新方法。以下是协议规范中可能包含的一些内容的概述：
- en: The frequency of infrared light used
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的红外光频率
- en: The carrier frequency or frequencies used
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的载波频率
- en: Number of devices supported
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的设备数量
- en: Number of commands per device
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个设备的命令数量
- en: Number of bits used in encoding
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码中使用的位数
- en: The encoding procedure
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码过程
- en: The key-to-code mapping
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键到码的映射
- en: The data rate, which may be variable
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输速率，可能是可变的
- en: Modulation schemes of the transmitted pulses and/or the spaces between them
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输脉冲的调制方案和/或它们之间的间隔
- en: Before the advent of programmable microcontrollers, transmitters and receivers
    needed additional circuitry to accomplish everything a protocol required. A general
    lack of compatibility led to the development of “universal remotes,” which either
    have the payloads of many other remotes preprogrammed into them, or simply record
    the signals of other remotes and parrot them back upon command. This latter is
    the procedure we’ll be using in this project to begin “teaching” the Raspberry
    Pi how to control the A/C, using a USB IR Toy (see [Figure 6-4](ch06.xhtml#ch06fig4)).
    The USB IR Toy has a transmitter and receiver on the same circuit board, so we
    can use it to record the signals from the air conditioner’s remote as well as
    mimic them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在可编程微控制器出现之前，发射器和接收器需要额外的电路来完成协议所要求的一切。普遍缺乏兼容性导致了“万能遥控器”的发展，这些遥控器要么预先编程了许多其他遥控器的负载，要么只是记录其他遥控器的信号，并在命令下将它们原样播放。这后一种方法是我们在本项目中开始“教”树莓派如何控制空调时所使用的过程，利用一个USB红外玩具（见[图6-4](ch06.xhtml#ch06fig4)）。USB红外玩具在同一电路板上集成了发射器和接收器，因此我们可以用它来记录空调遥控器的信号并模仿它们。
- en: '![image](../images/f0115-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0115-01.jpg)'
- en: '**FIGURE 6-4:** The USB IR Toy'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-4：** USB红外玩具'
- en: '**GET THE PARTS**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取零件**'
- en: The instructions in this project will use the equipment listed here. New to
    electronics projects? Stick with this parts list and I’ll make it easy!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中的说明将使用这里列出的设备。电子项目新手？坚持使用这个零件清单，我会让你轻松搞定！
- en: If you have more experience and are able to modify the steps, feel free to substitute
    your own transmitter, receiver, computer, OS, and A/C or other item to be controlled.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有更多经验，能够修改步骤，随时可以替换你自己的发射器、接收器、计算机、操作系统和空调或其他要控制的设备。
- en: 'USB IR transmitter and receiver (I used a Dangerous Prototypes USB IR Toy 2,
    which is available either prebuilt or in kit form. The prebuilt ones are available
    at Seeed Studios with SKU #102990037; *[https://www.seeedstudio.com/USB-Infrared-Toy-v2-p-831.html](https://www.seeedstudio.com/USB-Infrared-Toy-v2-p-831.html)*.)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'USB 红外发射器和接收器（我使用的是 Dangerous Prototypes USB IR Toy 2，它有预装版本和套件版。预装版可在 Seeed
    Studios 购买，SKU 编号为 #102990037；* [https://www.seeedstudio.com/USB-Infrared-Toy-v2-p-831.html](https://www.seeedstudio.com/USB-Infrared-Toy-v2-p-831.html)
    *）。'
- en: USB cable with A and mini-B connectors (for example, Adafruit P/N 260)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配有 A 型和迷你 B 型连接器的 USB 电缆（例如，Adafruit P/N 260）
- en: Raspberry Pi (Any model will work, but it will need to have Raspbian installed
    via NOOBS—see “[Getting Started with the Raspberry Pi](intro.xhtml#lev12)” on
    [page 13](intro.xhtml#page_13) for instructions on setting that up.)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi（任何型号都可以使用，但需要通过 NOOBS 安装 Raspbian—有关设置说明，请参阅 [Raspberry Pi 入门](intro.xhtml#lev12)，详见
    [第 13 页](intro.xhtml#page_13)）。
- en: An air conditioner that has an IR remote (I used a Haier HWR08XC7.)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台带有红外遥控器的空调（我使用的是海尔 HWR08XC7 型号）。
- en: The rest of this section deals with modifications, so if you’re using the parts
    listed, feel free to skip to “[Build It](ch06.xhtml#lev90)” on [page 117](ch06.xhtml#page_117).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余内容涉及修改，如果你使用的是列出的零件，可以跳到 [“动手制作”](ch06.xhtml#lev90) 部分，详见 [第 117 页](ch06.xhtml#page_117)。
- en: Any computer that has a USB port for the IR Toy 2 and is capable of running
    LIRC (Linux Infrared Remote Control) will work for this project. I chose a Raspberry
    Pi because I could get one bundled with a case, power supply, and NOOBS SD card
    cheaply on Amazon. Raspbian is the distribution being used for other projects
    in this book, so that’s what I’ll be providing instructions for, but everything
    we do here should be modifiable to work on your machine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有 USB 端口并支持运行 LIRC（Linux 红外遥控控制）的计算机都可以用于这个项目。我选择了 Raspberry Pi，因为我可以在亚马逊上以较低的价格购买带有外壳、电源和
    NOOBS SD 卡的套件。Raspbian 是本书中其他项目使用的操作系统，因此我将提供基于该系统的说明，但我们在这里所做的一切应该都能修改适配你的机器。
- en: Whatever you use, you’ll need the LIRC package (*[http://www.lirc.org](http://www.lirc.org)*/)
    for this project. LIRC is handy for this kind of task because 1) it can be installed
    on many flavors of Unix-like and Windows OSes; 2) it allows multiple programs
    to listen to one receiver; 3) it comes with helpful tools for memorizing remote
    controls and sending commands manually; and 4) its website has plenty of hardware
    compatibility info, so you can easily adapt this project to work with other hardware.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么设备，你都需要 LIRC 包（* [http://www.lirc.org](http://www.lirc.org) *）来完成这个项目。LIRC
    对于这种任务非常有用，因为 1) 它可以安装在多种类 Unix 系统和 Windows 操作系统上；2) 它允许多个程序监听一个接收器；3) 它附带有用于记忆遥控器和手动发送命令的有用工具；4)
    它的网站有丰富的硬件兼容信息，因此你可以轻松地调整这个项目来适配其他硬件。
- en: For example, there are lots of preconfigured *.conf* files for different handheld
    remotes, located at *[http://lirc-remotes.sourceforge.net/remotes-table.html](http://lirc-remotes.sourceforge.net/remotes-table.html)*.
    In theory, you can control any device that works with one of those listed IR remotes
    without doing any coding or even having to scrabble in your couch cushions to
    find the remote. But few of those preconfigured remotes are intended for air conditioners,
    so for this project we’ll just create our own *.conf* file and not stress about
    finding a matching one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有很多预配置的 *.conf* 文件，适用于不同的手持遥控器，存放在 *[http://lirc-remotes.sourceforge.net/remotes-table.html](http://lirc-remotes.sourceforge.net/remotes-table.html)*
    网站上。理论上，你可以控制任何与这些列出的红外遥控器兼容的设备，无需编写任何代码，甚至不必翻找沙发垫下的遥控器。但很少有预配置的遥控器是为空调设计的，因此在本项目中，我们将创建自己的
    *.conf* 文件，而不必为找匹配的文件而烦恼。
- en: In fact, since we’ll be creating our own *.conf* file anyway, you could use
    any IR-controllable device and the procedure will be exactly the same, as long
    as you still have its physical remote to imitate the codes from. Xbox? Roomba?
    DVD player? No problem!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，由于我们反正会创建自己的 *.conf* 文件，你可以使用任何支持红外控制的设备，操作步骤完全相同，只要你仍然拥有它的物理遥控器来模拟代码即可。Xbox？Roomba？DVD
    播放器？没问题！
- en: If you intend to buy an A/C unit for the project, just go for one that, besides
    having the IR capability, meets your cooling needs and is a common everyday brand
    where you live.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算为这个项目购买空调，选择一个除了具有红外功能外，还能满足你制冷需求的，并且是你所在地区常见的品牌即可。
- en: 'For my IR transmitter and receiver, I chose the USB IR Toy 2 by Dangerous Prototypes
    for three reasons: it’s fully compatible with LIRC; it’s relatively inexpensive
    at $20 for a preassembled version (or almost nothing if you want to assemble it
    yourself); and finally, since it has both a transmitter and a receiver, I only
    have to deal with one device. Although actually controlling the air conditioner
    requires just a transmitter, we need the receiver as well since we’re creating
    our own initial configuration files.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的红外发射器和接收器，我选择了Dangerous Prototypes的USB IR Toy 2，原因有三：它与LIRC完全兼容；它的价格相对便宜，预组装版只需$20（如果你自己组装几乎不花钱）；最后，由于它同时具有发射器和接收器，我只需要处理一个设备。虽然实际上控制空调只需要发射器，但由于我们正在创建自己的初始配置文件，所以也需要接收器。
- en: '**BUILD IT**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建它**'
- en: Let’s make the project! The following steps assume you already have an assembled
    IR transmitter and receiver, A/C unit and remote, and `sudo` root privileges on
    your Pi. (Raspbian provides the “pi” user for this purpose.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这个项目吧！以下步骤假设你已经拥有一个组装好的红外发射器和接收器、空调设备和遥控器，并且你的树莓派拥有`sudo`根权限。（Raspbian提供了“pi”用户用于此目的。）
- en: '**NOTE**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**'
- en: '*At the time of this writing, there were also user-contributed versions v23
    and v24, which could be found in the forums on the website.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*在撰写本文时，也有用户贡献的v23和v24版本，它们可以在网站的论坛中找到。*'
- en: '**Upgrade your USB IR Toy 2’s firmware.** Follow the directions on the Dangerous
    Prototypes website’s USB IR Toy 2 page (*[http://dangerousprototypes.com/docs/USB_IR_Toy_firmware_update](http://dangerousprototypes.com/docs/USB_IR_Toy_firmware_update)*)
    to upgrade its firmware to the latest version, which was officially v22 at the
    time of this writing. Performing a firmware upgrade could save you a lot of trouble
    depending on which revision your unit shipped with, as some earlier versions did
    not support transmitting!'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**升级你的USB IR Toy 2固件。** 请按照Dangerous Prototypes网站上USB IR Toy 2页面的说明（*[http://dangerousprototypes.com/docs/USB_IR_Toy_firmware_update](http://dangerousprototypes.com/docs/USB_IR_Toy_firmware_update)*)，将其固件升级到最新版本，在撰写本文时，官方版本是v22。根据你的设备附带的固件版本，进行固件升级可能会避免很多麻烦，因为一些早期版本并不支持发射功能！'
- en: You can upgrade your firmware via the USB port using almost any computer. After
    downloading and unzipping the firmware upgrade package from the Dangerous Prototypes
    website, follow the instructions provided on the site. The procedure and results
    will vary depending on your setup, so I won’t go into a lot of detail except to
    say that on my Windows 7 desktop I had to manually install the driver included
    in the *inf-driver* subdirectory, a detail not mentioned in the instructions.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过USB端口使用几乎任何计算机来升级固件。在从Dangerous Prototypes网站下载并解压固件升级包后，按照网站提供的说明操作。具体过程和结果会根据你的设置有所不同，因此我不会详细讲解，除了提到在我的Windows
    7桌面上，我必须手动安装*inf-driver*子目录中的驱动程序，而这个细节在说明中并没有提到。
- en: Once the computer recognizes the USB IR Toy 2, run the *update-USBIRToy.v22.bat*
    file in the firmware subdirectory and, when it asks, give it the port number assigned
    to your device (see Note for details).
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦计算机识别到USB IR Toy 2，运行固件子目录中的*update-USBIRToy.v22.bat*文件，并在系统提示时，提供分配给设备的端口号（详情请参见备注）。
- en: '**NOTE**'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**备注**'
- en: '*If you did not receive a COM port, and can’t find it listed as a COM port
    in your Device Manager or equivalent, just press ENTER when you get to this question.
    You only need the port number if you were automatically assigned one.*'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*如果你没有收到COM端口，并且在设备管理器或类似工具中找不到它作为COM端口列出，只需在此问题出现时按ENTER键即可。如果你是自动分配端口号的，才需要端口号。*'
- en: I found it helpful to pause momentarily every time I plugged in or changed anything,
    as Windows re-recognized the USB IR Toy 2 more than once during this process,
    and the interruption caused the firmware updater to not find the device. Once
    the device was successfully recognized, the firmware upgrade process was quick
    and easy.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我发现每次插入或更改任何内容时稍作暂停会很有帮助，因为在这个过程中，Windows会多次重新识别USB IR Toy 2，而这个中断会导致固件更新程序无法找到设备。一旦设备成功识别，固件升级过程便又快速又简单。
- en: '**Upgrade the Raspberry Pi’s OS and firmware.** I recommend making sure your
    operating system is 100% patched/upgraded and the Raspberry Pi has also had its
    firmware fully updated to the latest version before you begin.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**升级树莓派的操作系统和固件。** 我建议在开始之前，确保你的操作系统已经100%打上补丁/升级，树莓派的固件也已经更新到最新版本。'
- en: '**Check LIRC’s dependencies.** Now make sure your system has everything LIRC
    requires. The list can be found at *[http://www.lirc.org/html/install.html#dependencies](http://www.lirc.org/html/install.html#dependencies)*.
    I checked by entering the following lines on the Linux command line:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查LIRC的依赖项。** 现在，确保你的系统具备LIRC所需的所有内容。相关列表可以在*[http://www.lirc.org/html/install.html#dependencies](http://www.lirc.org/html/install.html#dependencies)*找到。我通过在Linux命令行输入以下命令来检查：'
- en: '[PRE0]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each command should produce the full path of the item in question. If there
    is no response, the item is missing from the system. Two more checks you should
    perform are:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个命令应该输出相关项目的完整路径。如果没有响应，说明该项目在系统中缺失。你还应进行两个检查：
- en: '[PRE1]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have these, you should see some information about the package in question;
    if you don’t, you should see a complaint saying the packages were not found. My
    fresh NOOBS install of Raspbian lacked both of these latter packages as well as
    xsltproc from the preceding list, so I installed the necessary items as follows:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你有这些，你应该看到关于该软件包的一些信息；如果没有，你应该看到一个抱怨，提示找不到这些软件包。我的新安装的Raspbian系统缺少这些软件包，以及前面提到的xsltproc，因此我按如下方式安装了必要的项目：
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Install LIRC.** Next, download the LIRC source, which can be obtained on
    SourceForge at *[https://sourceforge.net/projects/lirc/files/LIRC/](https://sourceforge.net/projects/lirc/files/LIRC/)*.
    Choose the directory with the most recent version of the code, save the *.tar.gz*
    file for that version, and then go to the save location. To extract and install
    LIRC, enter the following on the Linux command line, inserting your correct version
    number:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装LIRC。** 接下来，下载LIRC源代码，可以在SourceForge上获得，地址是*[https://sourceforge.net/projects/lirc/files/LIRC/](https://sourceforge.net/projects/lirc/files/LIRC/)*。选择最新版本的代码所在的目录，保存该版本的*.tar.gz*文件，然后进入保存位置。要解压并安装LIRC，请在Linux命令行输入以下命令，替换为你的正确版本号：'
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Connect the USB IR Toy 2.** Now, power down your Pi, then plug in the USB
    IR Toy 2\. Make sure to power the Pi down every time you plug and unplug your
    Toy, or you risk blowing stuff up! After rebooting your machine, look in the `dmesg`
    logfile to see if the Pi found your device:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接USB IR Toy 2。** 现在，关闭你的Pi电源，然后插入USB IR Toy 2。每次插入或拔出你的Toy时，确保关闭Pi的电源，否则可能会损坏设备！重新启动机器后，查看`dmesg`日志文件，看看Pi是否找到了你的设备：'
- en: '[PRE4]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see output like this:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到类似这样的输出：
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This output shows that the Pi found my USB IR Toy 2 and was able to automatically
    find and load the correct kernel-level driver for it, `cdc_acm`. If your machine
    doesn’t load a kernel-level driver after finding the Toy, you can modify your
    system to load it each time the machine is booted. If you’re using Raspbian, you
    can do this by editing the file */etc/modules* and adding the following line:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个输出表明Pi找到了我的USB IR Toy 2，并且能够自动找到并加载正确的内核级驱动程序`cdc_acm`。如果你的机器在找到Toy后没有加载内核级驱动程序，你可以修改系统，使其每次启动时加载此驱动程序。如果你使用的是Raspbian，可以通过编辑文件*/etc/modules*并添加以下行来实现：
- en: '**NOTE**'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using a completely different IR transmitter/receiver for your project,
    you’ll quite likely have a different kernel-level driver. That too can be loaded
    in*/etc/modules.'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*如果你为你的项目使用了完全不同的IR发射器/接收器，你很可能会有不同的内核级驱动程序。这个驱动程序也可以在*/etc/modules*中加载。*'
- en: '[PRE6]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once that’s working, you can use `dmesg` as follows to find the device name
    that’s been assigned to the USB IR Toy 2 (which you’ll need in the next step):'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦这一步正常工作，你可以使用`dmesg`如下操作来查找分配给USB IR Toy 2的设备名称（这是下一步需要的）：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'My output gave me the following:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的输出给出了以下内容：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, my USB IR Toy 2 has been assigned to device */dev/ttyACM0*. Write
    down your device assignment.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我的USB IR Toy 2已被分配到设备*/dev/ttyACM0*。记录下你的设备分配。
- en: '**Configure *lirc_options.conf*.** LIRC has put some default configuration
    files in */usr/local/etc/lirc*. For this step you need to edit */usr/local/etc/lirc/lirc_options.conf*
    as superuser and change the `driver` parameter (not the kernel-level driver in
    this case, but the LIRC plug-in) to `irtoy` and the `device` parameter to the
    full path of the one you saw in your `dmesg`. Open your */usr/local/etc/lirc/lirc_options.conf*
    file and change those parameters to match the following:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置*lirc_options.conf*。** LIRC已经将一些默认配置文件放在*/usr/local/etc/lirc*中。此步骤需要以超级用户身份编辑*/usr/local/etc/lirc/lirc_options.conf*，并将`driver`参数（此处不是内核级驱动程序，而是LIRC插件）更改为`irtoy`，将`device`参数更改为你在`dmesg`中看到的设备的完整路径。打开*/usr/local/etc/lirc/lirc_options.conf*文件，并将这些参数更改为如下所示：'
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you are using something besides a USB IR Toy 2, you can find a list of all
    other available plug-ins using the following command:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的不是 USB IR Toy 2，你可以使用以下命令找到所有其他可用插件的列表：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While you’re in there, you may also need to change the default locations for
    `pidfile` and `output` so they match where they were actually installed on your
    system. In my case, the NOOBS-installed Raspbian, I had to prepend */usr/local*
    to each one. You’ll know you failed if LIRC complains it can’t write the PID file
    when you try to run it!
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你进行此操作时，你可能还需要更改 `pidfile` 和 `output` 的默认位置，以便它们与系统实际安装位置匹配。以我使用的 NOOBS 安装的
    Raspbian 为例，我必须在每个位置前面加上 */usr/local*。如果 LIRC 报告无法写入 PID 文件，说明你失败了！
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Paranoia check.** To make sure you’re on track, check that you used the right
    device and driver with the following command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**偏执检查。** 为了确保你没有偏离轨道，请通过以下命令检查你使用的设备和驱动程序是否正确：'
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Point any IR remote at the USB IR Toy 2 and push some buttons. You should see
    results flow across the screen, indicating that serial data is available on the
    Pi as a result of your button pushing. Mine started out like this:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将任何 IR 遥控器对准 USB IR Toy 2 并按下几个按钮。你应该会看到屏幕上出现流动的数据，表示通过按键操作，Pi 上的串行数据已经可用。我的开始是这样的：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you’re done, press CTRL-C to exit that program.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成后，按 CTRL-C 退出该程序。
- en: '**Pick names for your buttons.** The information on each remote control your
    LIRC knows about will be stored in the *.conf* files located in */usr/local/etc/lirc/lircd.conf.d*.
    The next step is to create a file there for the air conditioner. We’ll do this
    using a program called *irrecord*.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为你的按钮选择名称。** 你所有遥控器的信息将存储在 *.conf* 文件中，位于 */usr/local/etc/lirc/lircd.conf.d*
    目录下。接下来的步骤是在这里为空调创建一个文件。我们将使用一个名为 *irrecord* 的程序来完成这项工作。'
- en: 'Each button on your remote will need a name in the configuration file. Write
    your choices down so they’ll be handy when you go to record your button presses.
    LIRC has some standardized button names that you can either use or disable; for
    simplicity we’ll use these standard names in this project. You can get the list
    by entering:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你遥控器上的每个按钮都需要在配置文件中有一个名称。写下你的选择，以便在录制按键时方便查看。LIRC 有一些标准的按钮名称，你可以选择使用或禁用；为了简单起见，我们在这个项目中将使用这些标准名称。你可以通过输入以下命令获取列表：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For my buttons I chose and wrote down the following:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我的按钮，我选择并记录了以下内容：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Extra credit: get the model number of your remote.** While not strictly necessary
    for this project, it’s a nice touch (and LIRC convention) to have your config
    file named after the remote you are using. I was able to find the model number
    of mine, a Haier AC-5620-30, by scrutinizing the spare parts section on Haier’s
    website and finding a match.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**额外加分：获取遥控器的型号。** 虽然对于这个项目来说这不是严格必要的，但为了好看（也是 LIRC 的惯例），将配置文件命名为你正在使用的遥控器的名字是个不错的做法。我通过仔细查看海尔官网的备件部分并找到匹配项，找到了我的遥控器型号，Haier
    AC-5620-30。'
- en: '**NOTE**'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If at any time during the recording process the USB IR Toy 2 stops functioning,
    I would recommend power-cycling your Pi and unplugging/replugging the USB IR Toy
    2’s cable while the power is off. I don’t know where the fault lies, but recording
    can be a bit dodgy!*'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*如果在录制过程中 USB IR Toy 2 停止工作，我建议在 Pi 断电的情况下重启 Pi，并拔掉/重新插上 USB IR Toy 2 的电缆。我不确定问题出在哪里，但录制可能会有些不稳定！*'
- en: '**Record the codes sent by the remote.** Now you’ll create a crude initial
    configuration file for your air conditioner’s remote by naming the buttons and
    pushing them such that the raw (not decoded yet) code is recorded and associated
    with its correct button name. Recording the raw signal will allow LIRC to reproduce
    it as an output later when you program your computer to control the A/C.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**记录遥控器发送的代码。** 现在，你将通过命名按钮并按下它们来创建一个粗略的初始配置文件，以便将原始（尚未解码的）代码记录并与其正确的按钮名称关联。记录原始信号将允许
    LIRC 在你编程让电脑控制空调时，之后将其作为输出重现。'
- en: 'First move to a scratch directory where you have write privileges:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，移动到一个你有写权限的临时目录：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With your remote in hand and the USB IR Toy 2 arranged so the LEDs point toward
    you, enter:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 手持遥控器，并将 USB IR Toy 2 安排好，使其 LED 指向你，输入：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Make sure to use your correct driver and device names. The program will step
    you through some processes to gather technical information on the signals your
    particular remote sends. First you’ll be asked to enter the name of your remote.
    Then it will ask you to push many random buttons, which will allow it to see how
    buttons generally work in this new and unfamiliar remote’s unknown protocol. Once
    it is confident it can tell one button push from another, it will ask you to enter
    your chosen button names one by one, and demonstrate the button push for each
    entry.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保使用正确的驱动程序和设备名称。程序会引导你通过一些步骤收集你的遥控器发送的信号的技术信息。首先它会要求你输入遥控器的名称。然后它会要求你按下许多随机按钮，这样它就能了解这些按钮在新遥控器的未知协议中如何工作。一旦它确认能区分不同的按钮按压，它将要求你一一输入你选择的按钮名称，并为每个按钮展示按压操作。
- en: Follow all the instructions through to the end. When it finishes, the contents
    will be saved to a file that starts with the remote model name you provided, and
    ends in *.lircd.conf*.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照所有指示操作直到完成。完成后，内容会保存到一个以你提供的遥控器型号为开头，以 *.lircd.conf* 结尾的文件中。
- en: 'If you later find that some button(s) did not record properly, you can re-record
    just those ones by specifying the config file to be updated using `-u`. For example:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你之后发现某些按钮没有正确录制，你可以通过指定要更新的配置文件并使用 `-u` 重新录制那些按钮。例如：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This technique can also be used to adapt someone else’s config file for your
    own remote, if they are compatible enough.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术也可以用来将他人的配置文件适配到你的遥控器，只要它们足够兼容。
- en: '**Edit your *.lirc.conf* file.** Using your favorite text editor, open your
    newly created config file, and you should see that it has three sections:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑你的 *.lirc.conf* 文件。** 使用你喜欢的文本编辑器打开你新创建的配置文件，你应该会看到它有三个部分：'
- en: First comes a comments area, surrounded by hash marks (#), with annotated blanks
    for you to fill in your remote and other relevant details. The LIRC community
    likes this information to be in this uniform format and fully fleshed out in the
    event that you decide to share the file with others. If you intend to keep the
    file to yourself, however, filling in the comments is optional.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是一个注释区域，用井号 (#) 括起来，里面有空白处供你填写遥控器和其他相关细节。LIRC 社区希望这些信息以统一格式填写完整，以防你决定将文件与他人分享。如果你打算将文件保留为个人使用，填写注释是可选的。
- en: 'Next, directly under `begin remote`, there should be a section with your remote’s
    name and some basic serial communications characteristics of its signal. This
    information was gathered by irrecord during the process you went through in step
    10, and will be different for different kinds of remotes. Mine looked like this:'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在 `begin remote` 下面，应该有一个部分，包含遥控器的名称和一些信号的基本串行通信特性。这个信息是在你执行第 10 步时，irrecord
    收集到的，并且不同类型的遥控器会有所不同。我的配置看起来是这样的：
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Third, there will be a list of the button names you chose, each accompanied
    by a block of code that irrecord has associated with that button. You may notice
    that some of them look suspiciously short, or otherwise dramatically different
    from their fellows. These may well turn out to be misrecorded ones. You’ll find
    out for sure in the next step. Here’s my first button from that section:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三部分会列出你选择的按钮名称，每个按钮旁边都有 irrecord 关联的代码块。你可能会注意到其中一些看起来异常简短，或者与其他按钮明显不同。这些可能是录制错误的按钮。你将在下一步确认这一点。这是我在该部分的第一个按钮：
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Test your *.lirc.conf* file.** Move a copy of your *.lirc.conf* file to the
    configuration directory as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试你的 *.lirc.conf* 文件。** 将 *.lirc.conf* 文件的副本移动到配置目录，方法如下：'
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you’re not using the default config file, *devinput.lircd.conf*, for anything,
    you may wish to change its name to something like *devinput.lircd.conf.unused*
    so LIRC doesn’t try to use it.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你没有使用默认的配置文件 *devinput.lircd.conf*，你可能希望将其更名为 *devinput.lircd.conf.unused*，这样
    LIRC 就不会尝试使用它。
- en: 'Next, let’s test the config file. Start LIRC by entering:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，让我们测试配置文件。通过输入以下命令启动 LIRC：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With LIRC running, test your new config file by entering:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 LIRC 运行时，通过输入以下命令测试你的新配置文件：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now push the buttons on your remote while pointing at the USB IR Toy 2\. Test
    each button and check that the name you chose for it pops up on the screen when
    you push it. Make a note if any button press comes up with the wrong name, or
    if any buttons cause the system to get confused (you’ll know because it won’t
    say anything and there will be a long pause before any more pushes work). Those
    are probably misrecorded.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在按下遥控器上的按钮，并对准 USB IR Toy 2。测试每个按钮，确保当你按下它时，屏幕上出现你为它选择的名称。如果有任何按钮按下后显示错误的名称，或者有按钮导致系统混乱（你会知道，因为它不会显示任何内容，而且在再次按下按钮之前会有很长时间的停顿），请做个记号。这些按钮可能是记录错误的。
- en: 'When you are finished testing, press CTRL-C to get out of `irw`, then kill
    the LIRC process using:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试完成后，按 CTRL-C 退出`irw`，然后使用以下命令终止 LIRC 进程：
- en: '[PRE24]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Take your list of erroneous buttons and use the `–u` technique described at
    the end of step 10 to re-record them. If irrecord won’t connect to the USB IR
    Toy 2, you may have to power-cycle the Pi and USB IR Toy 2.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 拿着你列出的错误按钮，并使用第 10 步最后描述的 `–u` 技巧重新录制它们。如果 irrecord 无法连接到 USB IR Toy 2，你可能需要断电重启
    Pi 和 USB IR Toy 2。
- en: When you are done re-recording, run sudo lircd again. Then run sudo irw again
    and test the buttons. Repeat this step until your config file is 100% accurate!
    This is the file LIRC will look at when you ask it to generate codes to control
    your air conditioner with the USB IR Toy 2, so it pays to get this part right.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成重新录制后，再次运行 sudo lircd。然后再次运行 sudo irw，测试按钮。重复此步骤，直到你的配置文件 100% 准确！这是 LIRC
    在你要求它生成用于控制空调的代码时会查看的文件，因此这部分必须做好。
- en: '**Test control of the A/C.** Next you must verify that the recorded commands
    are accurate enough to control the air conditioner itself when reproduced by LIRC.
    You can do this using the `irsend` command. First, start LIRC:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试空调控制。** 接下来，你必须验证录制的命令是否足够准确，以便在 LIRC 重现时能控制空调。你可以使用 `irsend` 命令来做到这一点。首先，启动
    LIRC：'
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now enter:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在输入：
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see a list of any remote names in your config file(s)—in my case,
    just the one:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该能看到配置文件中列出的任何遥控器名称——在我的例子中，只有一个：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can list the commands available for a given remote by inserting its name
    exactly as shown in the list:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过精确插入其名称，列出某个遥控器可用的命令，如列表中所示：
- en: '[PRE28]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For me, this produces the following:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对我来说，这会产生以下内容：
- en: '[PRE29]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The similarity with my list of chosen button names from step 8 is no coincidence!
    It is reading the names from the config file we created. It should now be possible
    to take one of those button names and combine it with the remote name to send
    a command like this:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我从第 8 步选择的按钮名称与这个列表的相似性绝非巧合！它是从我们创建的配置文件中读取名称的。现在应该可以取其中一个按钮名称，并将其与遥控器名称组合，发送如下命令：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Boom! My air conditioner comes on. If you’re going to be using this to control
    something long-term, you’ll want to test all your buttons vigorously to make sure
    your LIRC and USB IR Toy 2 work together stably.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哇！我的空调开了。如果你打算长期使用这个来控制某些设备，你需要充分测试所有按钮，确保你的 LIRC 和 USB IR Toy 2 能够稳定地配合工作。
- en: '**PATCHING AN UNSTABLE LIRC**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**修补不稳定的 LIRC**'
- en: The first time I reached this step with LIRC 0.9.4d, I found it very unstable.
    Both LIRC and the USB IR Toy 2 would die with an error message every several commands.
    If I replugged the USB IR Toy 2 and reran LIRC it would work again—for several
    commands. If you encounter this problem like I did, there is a patch available
    at *[https://sourceforge.net/u/bengtmartensson/lirc/ci/experimental-irtoy/](https://sourceforge.net/u/bengtmartensson/lirc/ci/experimental-irtoy/)*
    that should fix it. Although diff patches are designed to be applied automatically,
    you’ll likely have to apply this one manually due to differences in versions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次使用 LIRC 0.9.4d 达到这一步时，发现它非常不稳定。每执行几条命令，LIRC 和 USB IR Toy 2 都会死机并显示错误信息。如果我重新插拔
    USB IR Toy 2 并重新运行 LIRC，它又会正常工作——持续几个命令。如果你像我一样遇到这个问题，可以在 *[https://sourceforge.net/u/bengtmartensson/lirc/ci/experimental-irtoy/](https://sourceforge.net/u/bengtmartensson/lirc/ci/experimental-irtoy/)*
    上找到一个补丁，应该可以修复这个问题。尽管 diff 补丁设计成可以自动应用，但由于版本的不同，你可能需要手动应用这个补丁。
- en: 'To apply the patch, first back up your *lirc_options.conf* file as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用补丁，首先备份你的 *lirc_options.conf* 文件，如下所示：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then go back to the directory where you compiled LIRC, *~/lirc-0.9.4d/* in
    my case. From there, edit *./plugins/irtoy.c* and make the additions and subtractions
    specified in the green and red lines of the diff. Then clean up the directory
    and recompile like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后返回到你编译 LIRC 的目录，在我的例子中是 *~/lirc-0.9.4d/*。从那里，编辑 *./plugins/irtoy.c*，并根据 diff
    中的绿色和红色行进行增减。接着清理目录并像下面这样重新编译：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When done recompiling, reinstate your own *lirc_options.conf* file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译完成后，恢复你自己的*lirc_options.conf*文件：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you changed the name of *devinput.lircd.conf* before, you’ll have to delete
    the new copy the compilation added:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前更改过*devinput.lircd.conf*的名称，你需要删除编译后添加的新副本：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now repeat step 13 and see if the system now performs reliably. The patch cleared
    up the problem completely for me!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重复第13步，看看系统是否现在能可靠运行。补丁完全解决了我的问题！
- en: '**Analyze your *.conf* file.** When you are 100% satisfied with the performance
    of your *.conf* file, you can tell LIRC to analyze the remote’s protocol much
    more thoroughly by using the following commands:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析你的*.conf*文件。** 当你对*.conf*文件的性能100%满意时，你可以通过以下命令告诉LIRC更彻底地分析遥控器的协议：'
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Technically you could have tried this immediately after recording the first
    time, but personally I found it worked much better if any errors or missing buttons
    were taken care of first. Once analyzed, my entire file had shrunk considerably
    and now looked like this:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从技术上讲，你本可以在第一次录制后立即尝试这个方法，但就我个人而言，我发现如果先处理任何错误或缺失的按钮会更有效。一旦分析完毕，我的整个文件已经大大缩小，现在看起来像这样：
- en: '[PRE36]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Not only is this much more compact and easier to read than the raw version shown
    (partially) in step 11, but much more is now known about the protocol used by
    the A/C. In addition to the header, frequency, and so on, the actual commands
    have been decoded, and are expressed in hex instead of as blinks of various lengths
    to be imitated. This means that LIRC actually knows what it is doing now, instead
    of parroting stuff it doesn’t understand. That can only be a good thing when it
    comes to accurately controlling the A/C!
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不仅比第11步中显示的原始版本（部分）更简洁、更易读，而且现在关于空调所使用的协议有了更多的了解。除了头部、频率等信息外，实际的命令已经被解码，并以十六进制的形式表示，而不是模仿不同长度的闪烁信号。这意味着LIRC现在真正知道它在做什么，而不是重复它无法理解的内容。对于准确控制空调来说，这无疑是件好事！
- en: Cut and paste the analysis to replace the raw content in your original *.lircd.conf*
    file and kill and then restart LIRC to give it a try. It should work brilliantly.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将分析结果剪切并粘贴到原始的*.lircd.conf*文件中，然后杀死并重新启动LIRC来尝试一下，应该能正常工作。
- en: '**NOTE**'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If nothing changed or happened when you tried to analyze your file, LIRC wasn’t
    able to figure out your protocol. Just keep using your raw* .conf *file in that
    case.*'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*如果在尝试分析文件时没有任何变化或发生任何事情，说明LIRC无法识别你的协议。在这种情况下，继续使用原始的*.conf*文件。*'
- en: '**Run LIRC automatically.** Once you have LIRC configured properly, you can
    run it one last time and leave it running. You might also want to set it up to
    start automatically when you start your Pi, if you plan to set up tasks for your
    air conditioner controller that need to keep working if the machine gets rebooted.
    To do that on a Raspbian system, edit your */etc/rc.local* file as superuser and
    add the line:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自动运行LIRC。** 一旦你正确配置了LIRC，你可以最后一次运行它并让它保持运行。如果你计划设置任务来控制空调，且希望机器重启后能够继续工作，你还可以设置它在启动Pi时自动运行。要在Raspbian系统上做到这一点，作为超级用户编辑*/etc/rc.local*文件，并添加以下行：'
- en: '[PRE37]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Program the Pi to run your A/C.** Now that you have your USB IR Toy 2 talking
    to LIRC and have proven you can control your air conditioner with it, you have
    lots of interesting options for automating the actual running of the A/C. Go to
    *[http://www.lirc.org/software.html](http://www.lirc.org/software.html)* for a
    list of LIRC-related and compatible software and applications that let you manipulate
    your A/C in different ways or integrate it with your multimedia setup. I like
    using the command line, so my example script will be written in bash. But don’t
    let that stop you from experimenting with everything out there!'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编程Pi来控制空调。** 现在你已经让USB IR Toy 2与LIRC通信，并证明可以用它控制空调，你有很多有趣的选项来自动化空调的实际运行。请访问*[http://www.lirc.org/software.html](http://www.lirc.org/software.html)*，查看与LIRC相关的兼容软件和应用程序，允许你以不同的方式操作空调，或将其与多媒体设备集成。我喜欢使用命令行，所以我的示例脚本将使用bash编写。但不要让这个限制了你对所有可能工具的尝试！'
- en: 'Let’s say that the room your A/C is in heats up in the daytime while you’re
    at work or school. The air conditioner can be left on to keep the room cool all
    day, but it would be much more economical to have it turn on right before you
    come home. So let’s say you want it to come on at 4:30 PM. Linux has a daemon
    called `cron` that can run programs on schedules. You could write a `cron` job
    to accomplish your goal by entering:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设你的空调所在的房间在白天升温，而你在上班或上学时不在家。你可以让空调整天开着以保持房间凉爽，但如果在你回家前才开空调，经济性会更好。那么假设你希望空调在下午4:30开启。Linux有一个叫做`cron`的守护进程，可以按计划运行程序。你可以写一个`cron`任务来实现这个目标，输入：
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then add a line like this to your crontab:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在你的crontab中添加类似这样的行：
- en: '[PRE39]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This specifies that a script named *air_conditioner.sh* on the path specified
    will be run at 30 minutes after the 16th hour each day. (If you want to do more
    with `cron`, try reading `man crontab`!)
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这指定了一个名为*air_conditioner.sh*的脚本，将在每天16点30分运行。（如果你想更深入了解`cron`，可以尝试阅读`man crontab`！）
- en: 'Next, create the actual script in your text editor and save it as *air_conditioner.sh*.
    An example of a bash script to turn on the air conditioner might be as simple
    as:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，创建实际的脚本并在文本编辑器中保存为*air_conditioner.sh*。一个打开空调的bash脚本示例可能是非常简单的：
- en: '[PRE40]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This assumes that the A/C is always off when you leave in the morning. Since
    it is an *open-loop* control system (meaning the computer has no way of knowing
    whether the A/C was on or off to begin with), the beginning state has to be known
    for it to work right. Therefore, some things you want to do may require cleverness
    on your part to ensure the starting state is always known.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这假设空调在你早上离开时总是关闭的。由于这是一个*开环*控制系统（意味着计算机无法知道空调最初是开着还是关着），为了使其正常工作，必须知道初始状态。因此，一些你想要做的事情可能需要你自己动脑筋，确保初始状态总是已知的。
- en: '**TAKE IT FURTHER**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步操作**'
- en: One option for modifying this project is to make it a *closed-loop* system where
    the Pi can actually check on the state of the A/C. You could set up a temperature
    sensor in the room, or an inductive current sensor on the air conditioner’s power
    cord, then have the Pi read the signals from those to determine what the A/C is
    doing. You could even have the Pi visually check for the state of the LEDs on
    the front of the A/C, if you are feeling ambitious and have a camera.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 修改这个项目的一个选择是将其变成一个*闭环*系统，在这个系统中，树莓派实际上可以检查空调的状态。你可以在房间里安装一个温度传感器，或者在空调电源线安装一个感应电流传感器，然后让树莓派读取这些信号来确定空调的工作状态。如果你有摄像头，并且有些雄心壮志，你甚至可以让树莓派通过检查空调前面板上的LED灯状态来判断空调的工作情况。
- en: 'Even if you keep it an open-loop system, there are ways to make use of external
    information to add power to your automation. Here’s an experiment you can try
    right now: say you want the A/C to come on at 4:30 only if it’s over 90 degrees
    outside. You could power it off in the mornings, and have your Pi check the NOAA
    (National Oceanic and Atmospheric Administration) website for current conditions
    in your area, like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你保持开环系统，还是有办法利用外部信息为自动化提供动力。这里有一个你现在可以尝试的实验：假设你希望空调只有在外面气温超过90华氏度时才在4:30开启。你可以在早上关闭空调，并让你的树莓派检查NOAA（美国国家海洋和大气管理局）网站，获取你所在地区的当前天气状况，像这样：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**NOTE**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Like all websites, NOAA’s may change its URL or content, which may break your
    script. If that happens, modify the URL and/or sed pattern matching in your script
    to get the information you want.*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*像所有网站一样，NOAA网站的URL或内容可能会发生变化，这可能会导致你的脚本失效。如果发生这种情况，请修改URL和/或脚本中的sed模式匹配，以获取你想要的信息。*'
- en: 'Unless you live in L.A., you’ll want to change the URL to the one for your
    own city once you have this working. The following commands will strip off the
    saved website, leaving only the current temperature from the current day:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你住在洛杉矶，否则当你完成这一部分时，想要更改为你自己城市的URL。以下命令将去掉保存的网址，仅保留当天的当前温度：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It’s useful to add logging functionality, so you can see if the Pi tried to
    send a power on command or not. You can do so with the `logger` command, like
    this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 添加日志功能是很有用的，这样你就可以看到树莓派是否尝试发送开机命令。你可以使用`logger`命令来实现，比如：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Putting it all together, I present this sample program for you to edit and
    play with:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容结合起来，我为你提供了这个示例程序，供你编辑和尝试：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**SUMMARY**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter you learned about infrared light and infrared LEDs, and a few—hopefully!—tantalizing
    bits about communications protocols. You created a system to control an air conditioner
    remotely from a computer using infrared light. I hope that you’ll explore further
    in books and online because there is a lot to learn about serial communications,
    circuit design, and LED technology. To learn the nitty-gritty of designing electronics
    circuits from discrete components, including LEDs, I recommend *The Art of Electronics*
    by Horowitz and Hill.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了红外光和红外LED，以及一些——希望！——引人入胜的通信协议知识。你创建了一个系统，通过红外光从计算机远程控制空调。我希望你能在书籍和网上进一步探索，因为串行通信、电路设计和LED技术有很多值得学习的内容。要深入学习如何从离散元件设计电子电路，包括LED，我推荐霍罗维茨和希尔的*《电子艺术》*。
