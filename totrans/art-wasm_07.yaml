- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Applications
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter will help you understand how WebAssembly interacts with the DOM
    through JavaScript. Although it might seem cumbersome, it’s a necessary evil to
    understand WebAssembly and its strengths and weaknesses. If you’re using a WebAssembly
    toolchain, you need to know how much additional code that toolchain will generate
    as JavaScript glue code. From this point forward, most of the examples will run
    from a web page instead of using `node` from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by creating a simple static web server using Node.js. WebAssembly
    web applications cannot be loaded directly from the filesystem in a web browser;
    instead, they require you to run a web server. Node.js provides all the tools
    we need to create a web server. We’ll then write our first WebAssembly web application.
  prefs: []
  type: TYPE_NORMAL
- en: The second web application we’ll write reuses functions we wrote in Chapter
    5 to take in a number from an input element in the HTML and pass it into WebAssembly,
    which converts the number into a decimal, hexadecimal, and binary string.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand the basics of writing a web application
    that loads and instantiates a WebAssembly module and then calls functions from
    within that module. The applications will also write data from those modules to
    DOM elements. The examples in this chapter aren’t representative of the types
    of applications you would typically write with WebAssembly. They only demonstrate
    how a web page can load, instantiate, and interact with WebAssembly modules.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern web-based applications are so sophisticated it’s easy to forget that
    an HTML page, at its core, is a simple document. The web was conceived as a means
    to share documents and information, but it soon became apparent that we needed
    a standard method for dynamically updating those documents using a language like
    JavaScript or Java. The DOM was designed as a language-independent interface for
    manipulating HTML and XML documents. Because an HTML document is a tree structure,
    the DOM represents a document as a logical tree. The DOM is how JavaScript and
    other languages modify the HTML in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: The WebAssembly 1.0 release has no means of directly manipulating the DOM, so
    the JavaScript must make all modifications to the HTML document. If you’re using
    a toolchain, such as Rust or Emscripten, manipulation of the DOM is usually done
    from JavaScript glue code. As a general rule, the WebAssembly portion of a web
    application should focus on working with numeric data, but with the DOM most of
    the data processing will likely be string manipulation. The performance of string
    manipulation from within WebAssembly is entirely dependent on the library you
    use for the task. For this reason, DOM heavy work is usually best kept in the
    JavaScript portion of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Simple Node Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To set up a static web server with Node.js, create a folder for your project
    and open it in VS Code or your choice of IDE. We need to install two packages
    using `npm`. Install the first package, `connect`, using the command in [Listing
    7-1](#listing7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: Use `npm` to install the connect package.'
  prefs: []
  type: TYPE_NORMAL
- en: Install the second package, `serve-static`, using the command in [Listing 7-2](#listing7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: Use `npm` to install `serve-static`.'
  prefs: []
  type: TYPE_NORMAL
- en: With the packages installed, create a file named *server.js* and enter the code
    in [Listing 7-3](#listing7-3) to define a static web server.
  prefs: []
  type: TYPE_NORMAL
- en: '**server.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: Node.js http server code'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve created a static server that serves files from the current directory,
    but we don’t yet have any files to serve. Use VS Code to create a file named *index.html*
    and enter some HTML,something like the code in [Listing 7-4](#listing7-4).
  prefs: []
  type: TYPE_NORMAL
- en: '**index.html**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: A simple web page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can run your Node.js web server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A web server starts running on port 8080\. Test this by entering *localhost:8080*
    into your browser; you should see something like [Figure 7-1](#figure7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07001](Images/f07001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: Testing our simple static server'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a working Node.js web server, let’s create our first WebAssembly
    web app.
  prefs: []
  type: TYPE_NORMAL
- en: Our First WebAssembly Web Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll begin with a simple web app that takes two number inputs, adds them together,
    and then displays those values. The final version of this app is available at
    [https://wasmbook.com/add_message.html](https://wasmbook.com/add_message.html).
  prefs: []
  type: TYPE_NORMAL
- en: This app demonstrates how WebAssembly interacts with the DOM. You’ll find that
    we don’t change the way the WebAssembly module works, but instead change the embedding
    environment while the WebAssembly remains none the wiser.
  prefs: []
  type: TYPE_NORMAL
- en: To create a web app, we must run a web server, write an HTML page with JavaScript
    that will interact with the DOM, and load the WebAssembly module using the `instantiateStreaming`
    function (instead of using `instantiate` as we did in previous chapters). We’ll
    define a WebAssembly module that adds two integers together and an HTML file that
    loads and runs that WebAssembly module. In Listing 1-8, JavaScript ran the `AddInt`
    function using Node.js to load and execute the WebAssembly module. In this app,
    the HTML file will contain that JavaScript, and a browser will be required to
    run the app.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-5](#listing7-5) shows the WAT module with the adding functionality.
    Create the file *add_message.wat* and add the code in [Listing 7-5](#listing7-5).'
  prefs: []
  type: TYPE_NORMAL
- en: '**add_message.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: The *add_message.wat* file adds two numbers and calls a JavaScript
    log function.'
  prefs: []
  type: TYPE_NORMAL
- en: This WAT module should look very familiar at this point. It imports `log_add_message`
    1 from the JavaScript and defines the function `add_message` 2 that will be exported
    to the embedding environment. It also takes two `i32` parameters 3. These two
    parameters are added 4 together and stored in a local variable `$sum`. It then
    calls the JavaScript function `log_add_message` 5, passing in the `$a` and `$b`
    parameters, as well as `$sum` 6, the sum of those two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might be wondering how the WebAssembly interacts with the
    DOM. The unfortunate truth is that WebAssembly 1.0 doesn’t directly interact with
    the DOM. It must rely on the embedding environment (JavaScript) to perform all
    the interaction. All the differences between calling a WebAssembly module from
    Node.js and a web page will be in the embedding environment. The WebAssembly module
    can only make function calls to the embedding environment. We’ll create JavaScript
    functions inside the HTML page. The WebAssembly module will call these JavaScript
    functions, which will update the DOM. Compile *add_message.wat* using `wat2wasm`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the HTML Header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create our HTML page. When we’ve previously used Node.js as our embedding
    environment, we could work in pure JavaScript, but for a static website, you need
    an HTML page. A web browser doesn’t execute JavaScript directly in the same way
    as Node.js. Web browsers load HTML pages, which embed JavaScript inside `<script``>`
    tags. I’ll assume you have some familiarity with the basics of HTML, but this
    example should be fairly easy to follow if not. Create a new file *add_message.html*
    and add the code in [Listing 7-6](#listing7-6).
  prefs: []
  type: TYPE_NORMAL
- en: '**add_message.html (part 1 of 3)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: The HTML header for the *add_message* app is mostly HTML boilerplate.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the HTML opening tag and header information. It simply sets some font
    configuration and displays the app name, `Add Message`, as the title.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before ending the head element, we include a `script` tag for the JavaScript.
    Similar to when we used Node.js, JavaScript code is required to instantiate and
    execute functions in the WebAssembly module. An HTML page uses a `script` tag
    to contain this JavaScript, as shown in [Listing 7-7](#listing7-7).
  prefs: []
  type: TYPE_NORMAL
- en: '**add_message.html (part 2 of 3)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: The JavaScript that loads a WebAssembly module is inside a `script`
    tag.'
  prefs: []
  type: TYPE_NORMAL
- en: When building a web page, we need to be aware of when all the web page elements
    have completed loading and the time it takes to stream and instantiate our WebAssembly
    module.
  prefs: []
  type: TYPE_NORMAL
- en: This application writes messages to the paragraph tag `output`. The output paragraph
    hasn’t yet loaded when the JavaScript executes, because it’s further down the
    HTML page. The WebAssembly module will be streamed and loaded asynchronously,
    so you can’t be sure whether the WebAssembly module is instantiated before or
    after the page load completes.
  prefs: []
  type: TYPE_NORMAL
- en: To test that this function works no matter what order these events occur, we
    create a `sleep` 1 function at the beginning to force the JavaScript to wait.
    This function is commented out here. To test load order, uncomment `sleep` here
    as well as inside the IIFE or the `onPageLoad` function.
  prefs: []
  type: TYPE_NORMAL
- en: We create the `add_message_function` variable as a placeholder that will change
    to point to the `add_message` function inside our WebAssembly module as soon as
    the module is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define `log_add_message` 2, which contains an arrow function that checks
    whether `output` is set to something other than `null`. The default value for
    `output` is `null`, but as soon as the page is loaded, `output` is set to the
    paragraph element with an `id` of `output`; so this function will log a message
    if the function runs before the page has finished loading. The `log_add_message`
    4 function is imported by and called from the WebAssembly module, which passes
    to `log_add_message` the two parameters to add and the sum of those parameters.
    This function then writes those values to the `output` 3 HTML paragraph tag from
    [Listing 7-8](#listing7-8).
  prefs: []
  type: TYPE_NORMAL
- en: In the IIFE, the `sleep` 5 function is commented out, but you can restore it
    for testing. However, when loading a WebAssembly module from a web page, you use
    `WebAssembly.instantiateStreaming` 6 combined with a call to `fetch` to retrieve
    the module. Once the module is instantiated, the `add_message_button` 7 element
    is retrieved from the DOM and made visible when we set its `style.display` attribute
    to `block`. The user will now be able to click this button to run the WebAssembly
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we define the `onPageLoad` 8 function, which executes when the
    HTML `body` is finished loading. This function sets the `output` a variable defined
    near the top of [Listing 7-7](#listing7-7) to the paragraph tag with an `id` of
    `output`. Prior to the page loading, the output variable has a value of `null`.
    If a function that requires the `output` tag executes before the page has finished
    loading, it can check for `null` before using it. This prevents the code from
    trying to use the paragraph tag before it has loaded. We included an optional
    `sleep` 9 function, which can be used to delay setting the `output` variable.
    That allows us to simulate what happens when the page takes longer than expected
    to finish loading.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML Body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HTML `body` tag contains the DOM elements that will be displayed on our
    web page. Add the code in [Listing 7-8](#listing7-8) inside *add_message.html*
    below the `script` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '**add_message.html (part 3 of 3)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: The DOM elements in the HTML `body` tag'
  prefs: []
  type: TYPE_NORMAL
- en: The `body` 1 tag includes an `onload` attribute that calls the JavaScript `onPageLoad`
    function. This ensures that the `output` variable in our JavaScript isn’t set
    until the `output` paragraph tag exists.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have two `input` elements with the `id` inputs `a_val` 2 and `b_val`
    3. The values in these inputs are passed to the WebAssembly when the `button`
    4 element is clicked. The button attribute `onclick` 5 is set to call the `add_message_function`,
    which calls the `add_message` function in the WebAssembly module once the module
    is instantiated. The `add_message` function is called, passing in the values in
    the two input fields (`a_val` and `b_val`) above the `button`. In addition, we
    have a paragraph tag with an `id` of `output` 6 that we’ll populate with values
    from the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Our Completed Web App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should now be able to run our web application. As mentioned earlier, we must
    serve the web page from a web server, so first make sure the web server in [Listing
    7-3](#listing7-3) is running by using the command in [Listing 7-9](#listing7-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: Run the simple web server.'
  prefs: []
  type: TYPE_NORMAL
- en: If you receive the error in [Listing 7-10](#listing7-10), you already have a
    web server running on that port.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: The web server error if the port is already in use'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting this error likely means you’re running *server.js* from a different
    command line. With your web server running, open the following URL in a browser:
    [http://localhost:8080/add_message.html](http://localhost:8080/add_message.html).'
  prefs: []
  type: TYPE_NORMAL
- en: You should see something like the screen in [Figure 7-2](#figure7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07002](Images/f07002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: The *add_message.html* web app'
  prefs: []
  type: TYPE_NORMAL
- en: Set values in the two number fields, and click **Add Values** to see the results
    of that addition ([Figure 7-3](#figure7-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07003](Images/f07003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: Two addition messages added with the app'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the WebAssembly module called JavaScript functions, as was done
    in other chapters. You didn’t have to learn any new commands in WAT in this chapter.
    Because working directly with the DOM isn’t possible from within Wasm 1.0, we
    made all our changes to the DOM inside the JavaScript. Even though this was the
    first time we used an HTML page, it didn’t affect what WebAssembly does. WebAssembly
    1.0 is fairly limited and is most useful for increasing performance for math-heavy
    applications. This characteristic will change with later WebAssembly releases
    as more features are added. But for now, you need to keep these limitations in
    mind as you decide which applications are best suited for this new technology.
  prefs: []
  type: TYPE_NORMAL
- en: Hex and Binary Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll continue and create a second app that uses our functions from Chapter
    5 to convert numeric data into decimal, hexadecimal, and binary strings, and display
    them to a web page. See the final app at [https://wasmbook.com/hex_and_binary.html](https://wasmbook.com/hex_and_binary.html)*.*
  prefs: []
  type: TYPE_NORMAL
- en: The HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HTML is pretty much the same as [Listing 7-6](#listing7-6) but with different
    `title`contents. Create a file named *hex_and_binary.html* and add the code in
    [Listing 7-11](#listing7-11).
  prefs: []
  type: TYPE_NORMAL
- en: '**hex_and_binary.html (part 1 of 3)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-11: The boilerplate at the beginning of *hex_and_binary.html*'
  prefs: []
  type: TYPE_NORMAL
- en: The `title`tag here contains `Hex` `and Binary` 1. Next, in [Listing 7-12](#listing7-12),
    we add the `script` tag and the JavaScript code that will instantiate and call
    the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: '**hex_and_binary.html (part 2 of 3)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-12: JavaScript for the *hex_and_binary.html* file'
  prefs: []
  type: TYPE_NORMAL
- en: The `script` tag first creates the variable `setOutput` 1 and sets it to an
    arrow function that logs `"function not available"` 2 to the console. This message
    will display if the user clicks the **Set Numbers** button before the WebAssembly
    module has finished loading.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the `setNumbers` 3 function that will be called when the user
    clicks the **Set Numbers** button. If the page load hasn’t finished, the `output`
    is still `null` 4 at the button click, and we return from this function. The `setNumbers`
    function then calls `setOutput` 5 in the WebAssembly module, which creates an
    HTML string from the number passed in and returns the length of that string, which
    we’ll use to retrieve the string from linear memory. We take the `bytes` that
    will be used to create the display string from the linear memory `buffer` 6.
  prefs: []
  type: TYPE_NORMAL
- en: Then the `output` tag’s `innerHTML` 7 attribute is set to the display string
    generated from those `bytes` using a `TextDecoder` object, which displays the
    string in the web page.
  prefs: []
  type: TYPE_NORMAL
- en: We define the `onPageLoad` 8 function, which the `body` tag executes once it
    has finished loading. That function sets the `output` 9 variable used to display
    the output string from the WebAssembly module. It also instantiates the WebAssembly
    module and sets the `setOutput` a variable to the `setOutput` function in the
    WebAssembly module, so we can call `setOutput` from the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need the `body` tag, which contains an `output` tag to display the
    output from the WebAssembly function call, a number `input` to take in the user
    input, and a `button` to click that will call the `setNumbers` function. [Listing
    7-13](#listing7-13) shows that code.
  prefs: []
  type: TYPE_NORMAL
- en: '**hex_and_binary.html (part 3 of 3)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-13: The UI elements of the HTML page'
  prefs: []
  type: TYPE_NORMAL
- en: The `onload` 1 attribute tells the browser to execute `onPageLoad` when the
    `body` has completed loading. The tag 2 `<div` `id``="output">` is where the output
    from the WebAssembly module will be displayed. The number `input` tag 3, `<input`
    `type="number" id="val"` `value="0">` is where the user enters the number to convert
    to hexadecimal and binary. The `button` 4 calls the WebAssembly module when it’s
    clicked using the `onclick` 5 attribute. Now that we have our HTML page, we can
    create the WAT file for this application.
  prefs: []
  type: TYPE_NORMAL
- en: The WAT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a lot of WAT code in this app, so we’ll break it into four sections.
    Also, you’ll need to copy several functions from Chapter 5. Create a file named
    *hex_and_binary.wat* and add the code in [Listing 7-14](#listing7-14).
  prefs: []
  type: TYPE_NORMAL
- en: '**hex_and_binary.wat (part 1 of 4)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-14: String data definitions at the beginning of the module'
  prefs: []
  type: TYPE_NORMAL
- en: We define a series of data sections, pointers, and data lengths that will be
    used to assemble decimal, hexadecimal, and binary strings from integer data. The
    `$digit_ptr` 1 global variable is a pointer to the data segment that contains
    the 16 hexadecimal digits 0 to F defined at linear memory location `128`. This
    data is used for all three conversions from integer to string. We also have a
    length and pointer global variable, as well as a data segment for our decimal
    2, hexadecimal 3, and binary 4 string. Much of the code we’ll use is taken from
    sections in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have several strings that represent HTML tags. There are opening 5
    and closing 6 `H1` tag pointers, length and data segments, as well as opening
    7 and closing 8 data for `H4` tags. These strings will be used to assemble our
    HTML output string that will be stored in the linear memory position `1024` 9,
    which I chose because it was unused.
  prefs: []
  type: TYPE_NORMAL
- en: As we copy string data to the output string, we’ll need to keep track of the
    new length of this string and pass that value to the JavaScript; so we use the
    global variable `$out_str_len` to keep track of the output string length. Instead
    of including the code for the original functions from Chapter 5, I include an
    ellipsis (…) and a comment indicating the listing number that has the function
    code to copy. Copy and paste the function code from the original listing for all
    six of the functions in [Listing 7-15](#listing7-15).
  prefs: []
  type: TYPE_NORMAL
- en: '**hex_and_binary.wat (part 2 of 4)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-15: Functions reused from Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: First are the number-to-string conversion functions. The `$set_bin_string` 1
    function converts a number into a binary string. As parameters it takes an `i32
    $num` to be converted into a binary string and `$string_len` as the length of
    the output string, which includes nibble padding with spaces (Listing 5-35). Next
    is `$set_hex_string` 2, which converts the number and length to a hexadecimal
    string prefixed with a `0x` to indicate that the string represents a hexadecimal
    number (Listing 5-30). Then `$set_dec_string` 3 converts a number to a decimal
    string (Listing 5-24).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next are the three copy functions that copy a byte at a time, eight bytes at
    a time, and strings. Each takes three parameters: the `$source` parameter is the
    string that we’re copying from, the `$dest` parameter is the string we’re copying
    to, and `$len` is the length of the string. First is the `$byte_copy` 4 function,
    which copies data one byte at a time (Listing 5-17). The `$byte_copy_i64` 5 function
    copies eight bytes at a time (Listing 5-18). The `$string_copy` 6 function copies
    bytes eight at a time using `$byte_copy_i64` until there are less than eight bytes
    remaining and then copies the remaining bytes one by one using `$byte_copy` (Listing
    5-17).'
  prefs: []
  type: TYPE_NORMAL
- en: There is one final copy command not in [Listing 7-15](#listing7-15). This is
    the `$append_out` function that will always append a given source string to the
    output string by copying it to the end of the current output string. Add the code
    in [Listing 7-16](#listing7-16) to *hex_and_binary.wat*.
  prefs: []
  type: TYPE_NORMAL
- en: '**hex_and_binary.wat (part 3 of 4)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-16: The `$append_out` function appends to the output string.'
  prefs: []
  type: TYPE_NORMAL
- en: The `$append_out` 1 function appends the source string to the end of the output
    string using `$string_copy` 2 and then adds the length of the string just appended
    to the `$out_str_len` 3, which represents the output string length.
  prefs: []
  type: TYPE_NORMAL
- en: The final function in this module is `setOutput`, which creates the string we
    use to set the `output` `div` tag. This is exported so it can be called from JavaScript.
    Add the code in [Listing 7-17](#listing7-17) to the end of the WAT file.
  prefs: []
  type: TYPE_NORMAL
- en: '**hex_and_binary.wat (part 4 of 4)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-17: The `setOutput` function exported to be called from JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: The first three calls made by the `set_output` function in [Listing 7-17](#listing7-17)
    are to `$set_dec_string` 1, `$set_hex_string` 2, and `$set_bin_string` 3. These
    functions take the number passed into `setOutput` and convert it into a decimal
    string, a hexadecimal string, and a binary string in linear memory. Once these
    strings are set, the global variable `$out_str_len` 4 is set to `0`, which resets
    the output string so that appending to the output string writes over the string
    currently in memory. After we reset the value, we can begin to append to the output
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Next are nine calls to `$append_out`, grouped into three blocks. The first three
    calls append an opening and closing `H1` tag with the decimal 5 string inside
    it. This creates the HTML string to display the decimal numeric value in our web
    page. The next block of three appends the hexadecimal 6 string inside an `H4`
    element, and then the binary 7 string is appended inside an `H4` element. Finally,
    the length of the output string is loaded on the stack using a call to `global.get`
    `$out_str_len` 8, which returns it to the calling JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and Run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WAT module is complete, so use `wat2wasm` to compile your *hex_and_binary.wasm*
    file, as shown in [Listing 7-18](#listing7-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-18: Compiling *hex_and_binary.wat* using `wat2wasm`'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that you’re running your *server.js*, and open *hex_and_binary.html*
    in a browser using the address *http://localhost:8080/hex_and_binary.html*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-4](#figure7-4) shows something similar to what you should see onscreen.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f07004](Images/f07004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: Converting decimal to hexadecimal and binary'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a number and give it a go. For example, in [Figure 7-5](#figure7-5), I
    entered the number 1025 and clicked Set Numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07005](Images/f07005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: Convert 1025 to hexadecimal and binary'
  prefs: []
  type: TYPE_NORMAL
- en: This application used several WebAssembly functions we created in Chapter 5
    to convert a decimal number to hexadecimal and binary strings. We added some additional
    functionality that created HTML tags in the WebAssembly module so we could pass
    HTML to the JavaScript and display it on the web page. As you can tell, working
    with strings and manipulating the DOM from WAT is rather cumbersome. If you’re
    working with a toolchain, much of this hard work is done for you. Some of this
    functionality might compile into JavaScript glue code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebAssembly 1.0 doesn’t directly work with user interfaces. Its sweet spot is
    math-intensive applications. When interacting with the DOM from a web application
    built on top of WebAssembly, manipulating the DOM is primarily a task for the
    JavaScript portion. Working with strings from within WebAssembly entirely depends
    on the implementation. WebAssembly is still an excellent choice for many web applications,
    especially graphical applications, such as games. But in its current state, it’s
    not designed to work directly with the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: We began this chapter by creating a simple JavaScript web server to run using
    Node.js. You can’t load a WebAssembly web app from the filesystem but instead
    must serve your page using a web server. We wrote our first WebAssembly web application,
    which added two numbers together and then logged those numbers to the DOM in a
    paragraph tag called `output`.
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference between web applications and Node.js applications is
    in the embedding environment. Node.js command line apps are written entirely in
    JavaScript, where the web application has its JavaScript inside an HTML web page.
    Node.js can load the WebAssembly module directly from the filesystem, whereas
    the web application uses `instantiateStreaming` and `fetch` to instantiate a WebAssembly
    module streaming it from a web server. A Node.js application would have logged
    its output to the console, whereas the HTML page updated the `innerHTML` of a
    DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: The second application we wrote displayed the decimal, hexadecimal, and binary
    representations of a number passed into the WebAssembly module. This was done
    by assembling a string containing the HTML elements to be displayed in the application.
    This application reused several functions created in Chapter 5 for string manipulation.
    The JavaScript in this application wrote the string to the `innerHTML` of a `div`
    tag on our web page.
  prefs: []
  type: TYPE_NORMAL
- en: Neither of the applications we wrote is a particularly good use case for WebAssembly.
    My goal in this chapter was to create our first few WebAssembly web apps, not
    necessarily to make web applications that made sense to create using WebAssembly.
    In the next chapter, we’ll render to the HTML canvas and examine collision detection
    between a large number of objects on that canvas. These tasks, commonly found
    in web games, better represent what WebAssembly 1.0 can do to improve your web
    application’s performance.
  prefs: []
  type: TYPE_NORMAL
