<html><head></head><body>
<section>
<header><h1 class="FrontmatterTitle" id="fm-501089f07-0001"><span epub:type="pagebreak" title="xxvii" id="Page_xxvii"/>Introduction</h1></header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This book is the culmination of 30 years’ work. The very earliest versions of this book were notes I copied for my students at Cal Poly Pomona and UC Riverside under the title “How to Program the IBM PC Using 8088 Assembly Language.” I had lots of input from students and a good friend of mine, Mary Philips, that softened the edges a bit. Bill Pollock rescued that early version from obscurity on the internet, and with the help of Karol Jurado, the first edition of <em>The Art of Assembly Language</em> became a reality in 2003.</p>
<p>Thousands of readers (and suggestions) later, along with input from Bill Pollock, Alison Peterson, Ansel Staton, Riley Hoffman, Megan Dunchak, <span epub:type="pagebreak" title="xxviii" id="Page_xxviii"/>Linda Recktenwald, Susan Glinert Stevens, and Nancy Bell at No Starch Press (and a technical review by Nathan Baker), the second edition of this book arrived in 2010.</p>
<p>Ten years later, <em>The Art of Assembly Language</em> (or <em>AoA</em> as I refer to it) was losing popularity because it was tied to the 35-year-old 32-bit design of the Intel x86. Today, someone who was going to learn 80x86 assembly language would want to learn 64-bit assembly on the newer x86-64 CPUs. So in early 2020, I began the process of translating the old 32-bit <em>AoA</em> (based on the use of the High-Level Assembler, or HLA) to 64 bits by using the Microsoft Macro Assembler (MASM). </p>
<p>When I first started the project, I thought I’d translate a few HLA programs to MASM, tweak a little text, and wind up with <em>The Art of 64-Bit Assembly</em> with minimal effort. I was wrong. Between the folks at No Starch Press wanting to push the envelope on readability and understanding, and the incredible job Tony Tribelli has done in his technical review of every line of text and code in this book, this project turned out to be as much work as writing a new book from scratch. That’s okay; I think you’ll really appreciate the work that has gone into this book.</p>
<h2 id="h1-501089f07-0001">	A Note About the Source Code in This Book</h2>
<p class="BodyFirst">A considerable amount of x86-64 assembly language (and C/C++) source code is presented throughout this book. Typically, source code comes in three flavors: code snippets, single assembly language procedures or functions, and full-blown programs. </p>
<p><em>Code snippets</em> are fragments of a program; they are not stand-alone, and you cannot compile (assemble) them using MASM (or a C++ compiler in the case of C/C++ source code). Code snippets exist to make a point or provide a small example of a programming technique. Here is a typical example of a code snippet you will find in this book:</p>
<pre><code>someConst = 5
   .
   .
   .
mov eax, someConst</code></pre>
<p>The vertical ellipsis (. . .) denotes arbitrary code that could appear in its place (not all snippets use the ellipsis, but it’s worthwhile to point this out).</p>
<p><em>Assembly language procedures</em> are also not stand-alone code. While you can assemble many assembly language procedures appearing in this book (by simply copying the code straight out of the book into an editor and then running MASM on the resulting text file), they will not execute on their own. Code snippets and assembly language procedures differ in one major way: procedures appear as part of the downloadable source files for this book (at <a href="https://artofasm.randallhyde.com/" class="LinkURL">https://artofasm.randallhyde.com/</a>).</p>
<p><em>Full-blown programs</em>, which you can compile and execute, are labeled as <em>listings</em> in this book. They have a listing number/identifier of the form <span epub:type="pagebreak" title="xxix" id="Page_xxix"/>“Listing <em>C</em>-<em>N</em>,” where <em>C</em> is the chapter number and <em>N</em> is a sequentially increasing listing number, starting at 1 for each chapter. Here is an example of a program listing that appears in this book:</p>
<pre><code>; Listing 1-3

; A simple MASM module that contains
; an empty function to be called by
; the C++ code in Listing 1-2.

        .CODE
        
; The "option casemap:none" statement
; tells MASM to make all identifiers
; case-sensitive (rather than mapping
; them to uppercase). This is necessary
; because C++ identifiers are case-
; sensitive.

        option  casemap:none

; Here is the "asmFunc" function.

        public  asmFunc
asmFunc PROC

; Empty function just returns to C++ code.
        
        ret     ; Returns to caller
        
asmFunc ENDP
        END</code></pre>
<p class="CodeListingCaption">Listing 1: A MASM program that the C++ program in Listing 1-2 calls</p>
<p>Like procedures, all listings are available in electronic form at my website: <a href="https://artofasm.randallhyde.com/" class="LinkURL">https://artofasm.randallhyde.com/</a>. This link will take you to the page containing all the source files and other support information for this book (such as errata, electronic chapters, and other useful information). A few chapters attach listing numbers to procedures and macros, which are not full programs, for legibility purposes. A couple of listings demonstrate MASM syntax errors or are otherwise unrunnable. The source code still appears in the electronic distribution under that listing name.</p>
<p>Typically, this book follows executable listings with a build command and sample output. Here is a typical example (user input is given in a boldface font):</p>
<pre><code>C:\&gt;<b>build listing4-7</b>

C:\&gt;<b>echo off</b>
 Assembling: listing4-7.asm
c.cpp

<span epub:type="pagebreak" title="xxx" id="Page_xxx"/>C:\&gt;<b>listing4-7</b>
Calling Listing 4-7:
aString: maxLen:20, len:20, string data:'Initial String Data'
Listing 4-7 terminated</code></pre>
<p>Most of the programs in this text run from a Windows <em>command line</em> (that is, inside the <em>cmd.exe</em> application). By default, this book assumes you’re running the programs from the root directory on the C: drive. Therefore, every build command and sample output typically has the text prefix <code>C:\&gt;</code> before any command you would type from the keyboard on the command line. However, you can run the programs from any drive or directory.</p>
<p>If you are completely unfamiliar with the Windows command line, please take a little time to learn about the Windows command line interpreter (CLI). You can start the CLI by executing the <em>cmd.exe</em> program from the Windows <code>run</code> command. As you’re going to be running the CLI frequently while reading this book, I recommend creating a shortcut to <em>cmd.exe</em> on your desktop. In Appendix C, I describe how to create this shortcut to automatically set up the environment variables you will need to easily run MASM (and the Microsoft Visual C++ compiler). Appendix D provides a quick introduction to the Windows CLI for those who are unfamiliar with it.</p>
</section>
</body></html>