<html><head></head><body>
<h2 class="h2" id="overture"><span epub:type="pagebreak" id="page_xxxvi"/><span epub:type="pagebreak" id="page_xxxvii"/><strong>AN OVERTURE TO C PROGRAMMERS</strong></h2>&#13;
<p class="quote"><em>A<small>RTHUR</small> D<small>ENT</small>: What’s the matter with him? H<small>IG</small> H<small>URTENFLURST</small>: His feet are the wrong size for his shoes.<br/>—Douglas Adams</em>, The Hitchhiker’s Guide to the Galaxy, “<em>Fit the Eleventh</em>”</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This preface is meant for experienced C programmers who are considering whether or not to read this book. Non–C programmers are welcome to skip this prelude.</p>&#13;
<p class="indent">Bjarne Stroustrup developed C++ from the C programming language. Although C++ isn’t completely compatible with C, well-written C programs are often also valid C++ programs. Case in point, every example in <em>The C Programming Language</em> by Brian Kernighan and Dennis Ritchie is a legal C++ program.</p>&#13;
<p class="indent">One primary reason for C’s ubiquity in the system-programming community is that C allows programmers to write at a higher level of abstraction than assembly programming does. This tends to produce clearer, less error-prone, and more maintainable code.</p>&#13;
<p class="indent">Generally, system programmers aren’t willing to pay overhead for programming convenience, so C adheres to the zero-overhead principle: <em>what you don’t use, you don’t pay for</em>. The strong type system is a prime example of a zero-overhead abstraction. It’s used only at compile time to check for program correctness. After compile time, the types will have disappeared, and the emitted assembly code will show no trace of the type system.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xxxviii"/>As a descendant of C, C++ also takes zero-overhead abstraction and direct mapping to hardware very seriously. This commitment goes beyond just the C language features that C++ supports. Everything that C++ builds on top of C, including new language features, upholds these principles, and departures from either are made very deliberately. In fact, some C++ features incur even less overhead than corresponding C code. The <code>constexpr</code> keyword is one such example. It instructs the compiler to evaluate the expression at compile time (if possible), as shown in the program in <a href="anoverture.xhtml#anovertureex01">Listing 1</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
constexpr int isqrt(int n) {&#13;
  int i=1;&#13;
  while (i*i&lt;n) ++i;&#13;
  return i-(i*i!=n);&#13;
}&#13;
&#13;
int main() {&#13;
  constexpr int x = isqrt(1764); <span class="ent">➊</span>&#13;
  printf("%d", x);&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex01"/><em>Listing 1: A program illustrating <code>constexpr</code></em></p>&#13;
<p class="indent">The <code>isqrt</code> function computes the square root of the argument <code>n</code>. Starting at <code>1</code>, the function increments the local variable <code>i</code> until <code>i*i</code> is greater than or equal to <code>n</code>. If <code>i*i == n</code>, it returns <code>i</code>; otherwise, it returns <code>i-1</code>. Notice that the invocation of <code>isqrt</code> has a literal value, so the compiler could theoretically compute the result for you. The result will only ever take on one value <span class="ent">➊</span>.</p>&#13;
<p class="indent">Compiling <a href="anoverture.xhtml#anovertureex01">Listing 1</a> on GCC 8.3 targeting x86-64 with <code>-O2</code> yields the assembly in <a href="anoverture.xhtml#anovertureex02">Listing 2</a>.</p>&#13;
<pre>.LC0:&#13;
        .string "%d"&#13;
main:&#13;
        sub     rsp, 8&#13;
        mov     esi, 42 <span class="ent">➊</span>&#13;
        mov     edi, OFFSET FLAT:.LC0&#13;
        xor     eax, eax&#13;
        call    printf&#13;
        xor     eax, eax&#13;
        add     rsp, 8&#13;
        ret</pre>&#13;
<p class="listing"><a id="anovertureex02"/><em>Listing 2: The assembly produced after compiling <a href="anoverture.xhtml#anovertureex01">Listing 1</a></em></p>&#13;
<p class="indent">The salient result here is the second instruction in <code>main</code> <span class="ent">➊</span>; rather than evaluating the square root of <code>1764</code> at runtime, the compiler evaluates it and outputs instructions to treat <code>x</code> as <code>42</code>. Of course, you could calculate the square root using a calculator and insert the result manually, but using <code>constexpr</code> provides lots of benefits. This approach can mitigate many errors associated with manually copying and pasting, and it makes your code more expressive.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_xxxix"/><em>If you’re not familiar with x86 assembly, refer to</em> The Art of Assembly Language, <em>2nd Edition, by Randall Hyde and</em> Professional Assembly Language <em>by Richard Blum</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="anoverturelev1sec1"><strong>Upgrading to Super C</strong></h3>&#13;
<p class="noindent">Modern C++ compilers will accommodate most of your C programming habits. This makes it easy to embrace a few of the tactical niceties that the C++ language affords you while deliberately avoiding the language’s deeper themes. This style of C++—let’s call it <em>Super C</em>—is important to discuss for several reasons. First, seasoned C programmers can immediately benefit from applying simple, tactical-level C++ concepts to their programs. Second, Super C is <em>not</em> idiomatic C++. Simply sprinkling references and instances of <code>auto</code> around a C program might make your code more robust and readable, but you’ll need to learn other concepts to take full advantage of it. Third, in some austere environments (for example, embedded software, some operating system kernels, and heterogeneous computing), the available tool chains have incomplete C++ support. In such situations, it’s possible to benefit from at least some C++ idioms, and Super C is likely to be supported. This section covers some Super C concepts you can apply to your code immediately.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Some C-supported constructs won’t work in C++. See the links section of this book’s companion site,</em> <a href="https://ccc.codes">https://ccc.codes</a>.</p>&#13;
</div>&#13;
<h4 class="h4" id="anoverturelev2sec1"><strong><em>Function Overloading</em></strong></h4>&#13;
<p class="noindent">Consider the following conversion functions from the standard C library:</p>&#13;
<pre>char* itoa(int value, char* str, int base);&#13;
char* ltoa(long value, char* buffer, int base);&#13;
char* ultoa(unsigned long value, char* buffer, int base);</pre>&#13;
<p class="indent">These functions achieve the same goal: they convert an integral type to a C-style string. In C, each function must have a unique name. But in C++ functions can share names as long as their arguments differ; this is called <em>function overloading</em>. You can use function overloading to create your own conversion functions, as <a href="anoverture.xhtml#anovertureex03">Listing 3</a> illustrates.</p>&#13;
<pre>char* toa(int value, char* buffer, int base) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
char* toa(long value, char* buffer, int base)&#13;
  --<a id="_idTextAnchor003"/><span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
char* toa(unsigned long value, char* buffer, int base) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="page_xl"/>int main() {&#13;
  char buff[10];&#13;
  int a = 1; <span class="ent">➊</span>&#13;
  long b = 2; <span class="ent">➋</span>&#13;
  unsigned long c = 3; <span class="ent">➌</span>&#13;
  toa(a, buff, 10);&#13;
  toa(b, buff, 10);&#13;
  toa(c, buff, 10);&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex03"/><em>Listing 3: Calling overloaded functions</em></p>&#13;
<p class="indent">The data type of the first argument in each of the functions differs, so the C++ compiler has enough information from the arguments passed into <code>toa</code> to call the correct function. Each <code>toa</code> call is to a unique function. Here, you create the variables <code>a</code> <span class="ent">➊</span>, <code>b</code> <span class="ent">➋</span>, and <code>c</code> <span class="ent">➌</span>, which are different types of <code>int</code> objects that correspond with one of the three <code>toa</code> functions. This is more convenient than defining separately named functions, because you just need to remember one name and the compiler figures out which function to call.</p>&#13;
<h4 class="h4" id="anoverturelev2sec2"><strong><em>References</em></strong></h4>&#13;
<p class="noindent">Pointers are a crucial feature of C (and by extension most system programming). They enable you to handle large amounts of data efficiently by passing around data addresses instead of the actual data. Pointers are equally crucial to C++, but you have additional safety features available that defend against null dereferences and unintentional pointer reassignments.</p>&#13;
<p class="indent"><em>References</em> are a major improvement to handling pointers. They’re similar to pointers, but with some key differences. Syntactically, references differ from pointers in two important ways. First, you declare them with <code>&amp;</code> rather than <code>*</code>, as <a href="anoverture.xhtml#anovertureex04">Listing 4</a> illustrates.</p>&#13;
<pre>struct HolmesIV {&#13;
  bool is_sentient;&#13;
  int sense_of_humor_rating;&#13;
};&#13;
void make_sentient(HolmesIV*); // Takes a pointer to a HolmesIV&#13;
void make_sentient(HolmesIV&amp;); // Takes a reference to a HolmesIV</pre>&#13;
<p class="listing"><a id="anovertureex04"/><em>Listing 4: Code illustrating how to declare functions taking pointers and references</em></p>&#13;
<p class="indent">Second, you interact with members using the dot operator <code>.</code> rather than the arrow operator <code>-&gt;</code>, as <a href="anoverture.xhtml#anovertureex05">Listing 5</a> illustrates.</p>&#13;
<pre>void make_sentient(HolmesIV* mike) {&#13;
  mike-&gt;is_sentient = true;&#13;
}&#13;
&#13;
void make_sentient(HolmesIV&amp; mike) {&#13;
  mike.is_sentient = true;&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex05"/><em>Listing 5: A program illustrating the use of the dot and arrow operators</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xli"/>Under the hood, references are equivalent to pointers because they’re also a zero-overhead abstraction. The compiler produces similar code. To illustrate this, consider the results of compiling the <code>make_sentient</code> functions on GCC 8.3 targeting x86-64 with <code>-O2</code>. <a href="anoverture.xhtml#anovertureex06">Listing 6</a> contains the assembly generated by compiling <a href="anoverture.xhtml#anovertureex05">Listing 5</a>.</p>&#13;
<pre>make_sentient(HolmesIV*):&#13;
        mov     BYTE PTR [rdi], 1&#13;
        ret&#13;
make_sentient(HolmesIV&amp;):&#13;
        mov     BYTE PTR [rdi], 1&#13;
        ret</pre>&#13;
<p class="listing"><a id="anovertureex06"/><em>Listing 6: The assembly generated from compiling <a href="anoverture.xhtml#anovertureex05">Listing 5</a></em></p>&#13;
<p class="indent">However, at compile time, references provide some safety over raw pointers because, generally speaking, they cannot be null.</p>&#13;
<p class="indent">With pointers, you might add a <code>nullptr</code> check to be safe. For example, you might add a check to <code>make_sentient</code>, as in <a href="anoverture.xhtml#anovertureex07">Listing 7</a>.</p>&#13;
<pre>void make_sentient(HolmesIV* mike) {&#13;
  if(mike == nullptr) return;&#13;
  mike-&gt;is_sentient = true;&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex07"/><em>Listing 7: A refactor of <code>make_sentient</code> from <a href="anoverture.xhtml#anovertureex05">Listing 5</a> so it performs a <code>nullptr</code> check</em></p>&#13;
<p class="indent">Such a check is unnecessary when taking a reference; however, this doesn’t mean that references are always valid. Consider the following function:</p>&#13;
<pre>HolmesIV&amp; not_dinkum() {&#13;
  HolmesIV mike;&#13;
  return mike;&#13;
}</pre>&#13;
<p class="indent">The <code>not_dinkum</code> function returns a reference, which is guaranteed to be non-null. But it’s pointing to garbage memory (probably in the returned-from stack frame of <code>not_dinkum</code>). You must never do this. The result will be utter misery, also known as <em>undefined runtime behavior:</em> it might crash, it might give you an error, or it might do something completely unexpected.</p>&#13;
<p class="indent">One other safety feature of references is that they can’t be <em>reseated</em>. In other words, once a reference is initialized, it can’t be changed to point to another memory address, as <a href="anoverture.xhtml#anovertureex08">Listing 8</a> shows.</p>&#13;
<pre>int main() {&#13;
  int a = 42;&#13;
  int&amp; a_ref = a; <span class="ent">➊</span>&#13;
  int b = 100;&#13;
  a_ref = b; <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex08"/><em>Listing 8: A program illustrating that references cannot be reseated</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xlii"/>You declare <code>a_ref</code> as a reference to <code>int a</code> <span class="ent">➊</span>. There is no way to reseat <code>a_ref</code> to point to another <code>int</code>. You might try to reseat <code>a</code> with <span class="codeitalic">operator=</span> <span class="ent">➋</span>, but this actually sets the value of <code>a</code> to the value of <code>b</code> instead of setting <code>a_ref</code> to reference <code>b.</code> After the snippet is run both <code>a</code> and <code>b</code> are equal to <code>100</code>, and <code>a_ref</code> still points to <code>a</code>. <a href="anoverture.xhtml#anovertureex09">Listing 9</a> contains equivalent code using pointers instead.</p>&#13;
<pre>int main() {&#13;
  int a = 42;&#13;
  int* a_ptr = &amp;a; <span class="ent">➊</span>&#13;
  int b = 100;&#13;
  *a_ptr = b; <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex09"/><em>Listing 9: An equivalent program to <a href="anoverture.xhtml#anovertureex08">Listing 8</a> using pointers</em></p>&#13;
<p class="indent">Here, you declare the pointer with a <code>*</code> instead of a <code>&amp;</code> <span class="ent">➊</span>. You assign the value of <code>b</code> to the memory pointed to by <code>a_ptr</code> <span class="ent">➋</span>. With references, you don’t need any decoration on the left side of the equal sign. But if you omit the <code>*</code> in <code>*a_ptr</code>, the compiler would complain that you’re trying to assign an <code>int</code> to a pointer type.</p>&#13;
<p class="indent">References are just pointers with extra safety precautions and a sprinkle of syntactic sugar. When you put a reference on the left side of an equal sign, you’re setting the pointed-to value equal to the right side of the equal sign.</p>&#13;
<h4 class="h4" id="anoverturelev2sec3"><strong><em>auto Initialization</em></strong></h4>&#13;
<p class="noindent">C often requires you to repeat type information more than once. In C++, you can express a variable’s type information just once by utilizing the <code>auto</code> keyword. The compiler will know the variable’s type because it knows the type of the value being used to initialize the variable. Consider the following C++ variable initializations:</p>&#13;
<pre>int x = 42;&#13;
auto y = 42;</pre>&#13;
<p class="indent">Here, <code>x</code> and <code>y</code> are both of <code>int</code> type. You might be surprised to know that the compiler can deduce the type of <code>y</code>, but consider that 42 is an integer literal. With <code>auto</code>, the compiler deduces the type on the right side of the equal sign <code>=</code> and sets the variable’s type to the same. Because an integer literal is of <code>int</code> type, in this example the compiler deduces that the type of <code>y</code> is also an <code>int</code>. This doesn’t seem like much of a benefit in such a simple example, but consider initializing a variable with a function’s return value, as <a href="anoverture.xhtml#anovertureex10">Listing 10</a> illustrates.</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
&#13;
struct HolmesIV {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
HolmesIV* make_mike(int sense_of_humor) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  auto mike = make_mike(1000);&#13;
  free(mike);&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_xliii"/><a id="anovertureex10"/><em>Listing 10: A toy program initializing a variable with the return value of a function</em></p>&#13;
<p class="indent">The <code>auto</code> keyword is easier to read and is more amenable to code refactoring than explicitly declaring a variable’s type. If you use <code>auto</code> freely while declaring a function, there will be less work to do later if you need to change the return type of <code>make_mike</code>. The case for <code>auto</code> strengthens with more complex types, such as those involved with the template-laden code of the stdlib. The <code>auto</code> keyword makes the compiler do all the work of type deduction for you.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can also add <code>const</code>, <code>volatile</code>, <code>&amp;</code>, and <code>*</code> qualifiers to <code>auto</code>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="anoverturelev2sec4"><strong><em>Namespaces and Implicit typedef of struct, union, and enum</em></strong></h4>&#13;
<p class="noindent">C++ treats type tags as implicit <code>typedef</code> names. In C, when you want to use a <code>struct</code>, <code>union</code>, or <code>enum</code>, you have to assign a name to the type you’ve created using the <code>typedef</code> keyword. For example:</p>&#13;
<pre>typedef struct Jabberwocks {&#13;
  void* tulgey_wood<a id="_idTextAnchor004"/>;&#13;
  int is_galumphing;&#13;
} Jabberwock;</pre>&#13;
<p class="indent">In C++ land, you chortle at such code. Because the <code>typedef</code> keyword can be implicit, C++ allows you instead to declare the <code>Jabberwock</code> type like this:</p>&#13;
<pre>struct Jabberwock {&#13;
  void* tulgey_wood;&#13;
  int is_galumphing;&#13;
};</pre>&#13;
<p class="indent">This is more convenient and saves some typing. What happens if you also want to define a <code>Jabberwock</code> function? Well, you shouldn’t, because reusing the same name for a data type and a function is likely to cause confusion. But if you’re really committed to it, C++ allows you to declare a <code>namespace</code> to create different scopes for identifiers. This helps to keep user types and functions tidy, as shown in <a href="anoverture.xhtml#anovertureex11">Listing 11</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace Creature { <span class="ent">➊</span>&#13;
  struct Jabberwock {&#13;
    void* tulgey_wood;&#13;
    int is_galumphing;&#13;
  };&#13;
}&#13;
namespace Func { <span class="ent">➋</span>&#13;
  void Jabberwock() {&#13;
    printf("Burble!");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_xliv"/><a id="anovertureex11"/><em>Listing 11: Using namespaces to disambiguate functions and types with identical names</em></p>&#13;
<p class="indent">In this example, <code>Jabberwock</code> the <code>struct</code> and <code>Jabberwock</code> the function now live together in frabjous harmony. By placing each element in its own <code>namespace</code>—the <code>struct</code> in the <code>Creature</code> namespace <span class="ent">➊</span> and the function in the <code>Func</code> namespace <span class="ent">➋</span>—you can disambiguate which Jabberwock you mean. You can do such disambiguation in several ways. The simplest is to qualify the name with its <code>namespace</code>, for example:</p>&#13;
<pre>Creature::Jabberwock x;&#13;
Func::Jabberwock();</pre>&#13;
<p class="indent">You can also employ a <code>using</code> directive to import all the names in a <code>namespace</code>, so you’d no longer need to use the fully qualified element name. <a href="anoverture.xhtml#anovertureex12">Listing 12</a> uses the <code>Creature</code> <code>namespace</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
namespace Creature {&#13;
  struct Jabberwock {&#13;
    void* tulgey_wood;&#13;
    int is_galumphing;&#13;
  };&#13;
}&#13;
&#13;
namespace Func {&#13;
  void Jabberwock() {&#13;
    printf("Burble!");&#13;
  }&#13;
}&#13;
&#13;
using namespace Creature; <span class="ent">➊</span>&#13;
&#13;
int main() {&#13;
  Jabberwock x; <span class="ent">➋</span>&#13;
  Func::Jabberwock();&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex12"/><em>Listing 12: Employing <code>using namespace</code> to refer to a type within the <code>Creature</code> namespace</em></p>&#13;
<p class="indent">The <code>using namespace</code> <span class="ent">➊</span> enables you to omit the <code>namespace</code> qualification <span class="ent">➋</span>. But you still need a qualifier on <code>Func::Jabberwock</code>, because it isn’t part of the <code>Creature</code> <code>namespace</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xlv"/>Use of a <code>namespace</code> is idiomatic C++ and is a zero-overhead abstraction. Just like the rest of a type’s identifiers, the <code>namespace</code> is erased by the compiler when emitting assembly code. In large projects, it’s incredibly helpful for separating code in different libraries.</p>&#13;
<h4 class="h4" id="anoverturelev2sec5"><strong><em>Intermingling C and C++ Object Files</em></strong></h4>&#13;
<p class="noindent">C and C++ code can coexist peacefully if you’re careful. Sometimes, it’s necessary for a C compiler to link object files emitted by a C++ compiler (and vice versa). Although this is possible, it requires a bit of work.</p>&#13;
<p class="indent">Two issues are related to linking the files. First, the calling conventions in the C and C++ code could potentially be mismatched. For example, the protocols for how the stack and registers are set when you call a function could be different. These calling conventions are language-level mismatches and aren’t generally related to how you’ve written your functions. Second, C++ compilers emit different symbols than C compilers do. Sometimes the linker must identify an object by name. C++ compilers assist by decorating the object, associating a string called a <em>decorated name</em> with the object. Because of function overloads, calling conventions, and <code>namespace</code> usage, the compiler must encode additional information about a function beyond just its name through decoration. This is done to ensure that the linker can uniquely identify the function. Unfortunately, there is no standard for how this decoration occurs in C++ (which is why you should use the same tool chain and settings when linking between translation units). C linkers know nothing about C++ name decoration, which can cause problems if decoration isn’t suppressed whenever you link against C code within C++ (and vice versa).</p>&#13;
<p class="indent">The fix is simple. You wrap the code you want to compile with C-style linkages using the statement <code>extern "C"</code>, as in <a href="anoverture.xhtml#anovertureex13">Listing 13</a>.</p>&#13;
<pre>// header.h&#13;
#ifdef __cplusplus&#13;
extern "C" {&#13;
#endif&#13;
void extract_arkenstone();&#13;
&#13;
struct MistyMountains {&#13;
  int goblin_count;&#13;
};&#13;
#ifdef __cplusplus&#13;
}&#13;
#endif</pre>&#13;
<p class="listing"><a id="anovertureex13"/><em>Listing 13: Employing C-style linkage</em></p>&#13;
<p class="indent">This header can be shared between C and C++ code. It works because <code>__cplusplus</code> is a special identifier that the C++ compiler defines (but the C compiler doesn’t). Accordingly, the C compiler sees the code in <a href="anoverture.xhtml#anovertureex14">Listing 14</a> after preprocessing completes. <a href="anoverture.xhtml#anovertureex14">Listing 14</a> illustrates the code that remains.</p>&#13;
<pre>void extract_arkenstone();&#13;
&#13;
struct MistyMountains {&#13;
  int goblin_count;&#13;
};</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_xlvi"/><a id="anovertureex14"/><em>Listing 14: The code remaining after the preprocessor processes <a href="anoverture.xhtml#anovertureex13">Listing 13</a> in a C environment</em></p>&#13;
<p class="indent">This is just a simple C header. The code between the <code>#ifdef __cplusplus</code> statements is removed during preprocessing, so the <code>extern "C"</code> wrapper isn’t visible. For the C++ compiler, <code>__cplusplus</code> <em>is</em> defined in <code>header.h</code>, so it sees the contents of <a href="anoverture.xhtml#anovertureex15">Listing 15</a>.</p>&#13;
<pre>extern "C" {&#13;
  void extract_arkenstone();&#13;
&#13;
  struct MistyMountains {&#13;
    int goblin_count;&#13;
  };&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex15"/><em>Listing 15: The code remaining after the preprocessor processes <a href="anoverture.xhtml#anovertureex13">Listing 13</a> in a C++ environment</em></p>&#13;
<p class="indent">Both <code>extract_arkenstone</code> and <code>MistyMountains</code> are now wrapped with <code>extern "C"</code>, so the compiler knows to use C linkage. Now your C source can call into compiled C++ code, and your C++ source can call into compiled C code.</p>&#13;
<h3 class="h3" id="anoverturelev1sec2"><strong>C++ Themes</strong></h3>&#13;
<p class="noindent">This section takes you on a brief tour of some core themes that make C++ the premier system-programming language. Don’t worry too much about the details. The point of the following subsections is to whet your appetite.</p>&#13;
<h4 class="h4" id="anoverturelev2sec6"><strong><em>Expressing Ideas Concisely and Reusing Code</em></strong></h4>&#13;
<p class="noindent">Well-crafted C++ code has an elegant, compact quality. Consider the evolution from ANSI-C to modern C++ in the following simple operation: looping over some array <code>v</code> with <code>n</code> elements, as <a href="anoverture.xhtml#anovertureex16">Listing 16</a> illustrates.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
&#13;
int main() {&#13;
  const size_t n{ 100 };&#13;
  int v[n];&#13;
&#13;
  // ANSI-C&#13;
  size_t i;&#13;
  for (i=0; i&lt;n; i++) v[i] = 0; <span class="ent">➊</span>&#13;
  // C99&#13;
  for (size_t i=0; i&lt;n; i++)  v[i] = 0; <span class="ent">➋</span>&#13;
&#13;
  // C++17&#13;
  for (auto&amp; x : v) x = 0; <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_xlvii"/><a id="anovertureex16"/><em>Listing 16: A program illustrating several ways to iterate over an array</em></p>&#13;
<p class="indent">This code snippet shows the different ways to declare loops in ANSI-C, C99, and C++. The index variable <code>i</code> in the ANSI-C <span class="ent">➊</span> and C99 <span class="ent">➋</span> examples are ancillary to what you’re trying to accomplish, which is to access each element of <code>v</code>. The C++ version <span class="ent">➌</span> utilizes a <em>range-based</em> <code>for</code> loop, which loops over in the range of values in <code>v</code> while hiding the details of how iteration is achieved. Like a lot of the zero-overhead abstractions in C++, this construct enables you to focus on meaning rather than syntax. Range-based <code>for</code> loops work with many types, and you can even make them work with user-defined types.</p>&#13;
<p class="indent">Speaking of user-defined types, they allow you to express ideas directly in code. Suppose you want to design a function, <code>navigate_to</code>, that tells a hypothetical robot to navigate to some position given x and y coordinates. Consider the following prototype function:</p>&#13;
<pre>void navigate_to(double x, double y);</pre>&#13;
<p class="indent">What are <code>x</code> and <code>y</code>? What are their units? Your user must read the documentation (or possibly the source) to find out. Compare the following improved prototype:</p>&#13;
<pre>struct Position{&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
void navigate_to(const Position&amp; p);</pre>&#13;
<p class="indent">This function is far clearer. There is no ambiguity about what <code>navigate_to</code> accepts. As long as you have a validly constructed <code>Position</code>, you know exactly how to call <code>navigate_to</code>. Worrying about units, conversions, and so on is now the responsibility of whoever constructs the <code>Position</code> class.</p>&#13;
<p class="indent">You can also come close to this clarity in C99/C11 using a <code>const</code> pointer, but C++ also makes return types compact and expressive. Suppose you want to write a corollary function for the robot called <code>get_position</code> that—you guessed it—gets the position. In C, you have two options, as shown in <a href="anoverture.xhtml#anovertureex17">Listing 17</a>.</p>&#13;
<pre>Position* get_position(); <span class="ent">➊</span>&#13;
void get_position(Position* p); <span class="ent">➋</span></pre>&#13;
<p class="listing"><a id="anovertureex17"/><em>Listing 17: A C-style API for returning a user-defined type</em></p>&#13;
<p class="indent">In the first option, the caller is responsible for cleaning up the return value <span class="ent">➊</span>, which has probably incurred a dynamic allocation (although this is unclear from the code). The caller is responsible for allocating a <code>Position</code> <span epub:type="pagebreak" id="page_xlviii"/>somewhere and passing it into <code>get_position</code> <span class="ent">➋</span>. This latter approach is more idiomatic C-style, but the language is getting in the way: you’re just trying to get a position object, but you have to worry about whether the caller or the called function is responsible for allocating and deallocating memory. C++ lets you do all of this succinctly by returning user-defined types directly from functions, as shown in <a href="anoverture.xhtml#anovertureex18">Listing 18</a>.</p>&#13;
<pre>Position<span class="ent">➊</span> get_position() {&#13;
  <span class="codeitalic1">--snip--</span>&#13;
}&#13;
void navigate() {&#13;
  auto p = get_position(); <span class="ent">➋</span>&#13;
  // p is now available for use&#13;
  <span class="codeitalic1">--snip--</span>&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex18"/><em>Listing 18: Returning a user-defined type by value in C++</em></p>&#13;
<p class="indent">Because <code>get_position</code> returns a value <span class="ent">➊</span>, the compiler can <em>elide the copy</em>, so it’s as if you’ve constructed an automatic <code>Position</code> variable directly <span class="ent">➋</span>; there’s no runtime overhead. Functionally, you’re in very similar territory to the C-style pass by reference of <a href="anoverture.xhtml#anovertureex17">Listing 17</a>.</p>&#13;
<h4 class="h4" id="anoverturelev2sec7"><strong><em>The C++ Standard Library</em></strong></h4>&#13;
<p class="noindent">The C++ Standard Library (stdlib) is a major reason for migrating from C. It contains high-performance, generic code that is guaranteed to be available right out of the standards-conforming box. The three broad components of the stdlib are containers, iterators, and algorithms.</p>&#13;
<p class="indent"><em>Containers</em> are the data structures. They’re responsible for holding sequences of objects. They’re correct, safe, and (usually) at least as efficient as what you could accomplish manually, meaning that writing your own versions of these containers would take great effort and wouldn’t turn out better than the stdlib containers. Containers are neatly partitioned into two categories: <em>sequence containers</em> and <em>associative containers</em>. The sequence containers are conceptually similar to arrays; they provide accesses to sequences of elements. Associative containers contain key/value pairs, so elements in the containers can be looked up by key.</p>&#13;
<p class="indent">The stdlib <em>algorithms</em> are general-purpose functions for common programming tasks, such as counting, searching, sorting, and transforming. Much like containers, the stdlib algorithms are extremely high quality and broadly applicable. Users should very rarely have to implement their own version, and using the stdlib algorithms greatly increases programmer productivity, code safety, and readability.</p>&#13;
<p class="indent"><em>Iterators</em> connect containers with algorithms. For many stdlib algorithm applications, the data you want to operate on resides in a container. Containers expose iterators to provide an even, common interface, and the algorithms consume the iterators, keeping programmers (including the implementers of the stdlib) from having to implement a custom algorithm for each container type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xlix"/><a href="anoverture.xhtml#anovertureex19">Listing 19</a> shows how to sort a container of values using a few lines of code.</p>&#13;
<pre>#include &lt;vector&gt;&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;iostream&gt;&#13;
&#13;
int main() {&#13;
  std::vector&lt;int&gt; x{ 0, 1, 8, 13, 5, 2, 3 }; <span class="ent">➊</span>&#13;
  x[0] = 21; <span class="ent">➋</span>&#13;
  x.push_back(1); <span class="ent">➌</span>&#13;
  std::sort(x.begin(), x.end()); <span class="ent">➍</span>&#13;
  std::cout &lt;&lt; "Printing " &lt;&lt; x.size() &lt;&lt; " Fibonacci numbers.\n"; <span class="ent">➎</span>&#13;
  for (auto number : x) {&#13;
    std::cout &lt;&lt; number &lt;&lt; std::endl; <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex19"/><em>Listing 19: Sorting a container of values using the stdlib</em></p>&#13;
<p class="indent">A good amount of computation is going on in the background, yet the code is compact and expressive. First, you initialize a <code>std::vector</code> container <span class="ent">➊</span>. <em>Vectors</em> are the stdlib’s dynamically sized arrays. The <em>initializer braces</em> (the <code>{0, 1, ...}</code>) set the initial values contained in <code>x</code>. You can access the elements of a <code>vector</code> just like the elements of an array using brackets (<code>[]</code>) and the index number. You use this technique to set the first element equal to <code>21</code> <span class="ent">➋</span>. Because <code>vector</code> arrays are dynamically sized, you can append values to them using the <code>push_back</code> method <span class="ent">➌</span>. The seemingly magical invocation of <code>std::sort</code> showcases the power of the algorithms in stdlib <span class="ent">➍</span>. The methods <code>x.begin()</code> and <code>x.end()</code> return iterators that <code>std::sort</code> uses to sort <code>x</code> in place. The <code>sort</code> algorithm is decoupled from <code>vector</code> through the use of iterators.</p>&#13;
<p class="indent">Thanks to iterators, you can use other containers in stdlib similarly. For example, you could use a <code>list</code> (the stdlib’s doubly linked list) rather than using a <code>vector</code>. Because <code>list</code> also exposes iterators through <code>.begin()</code> and <code>.end()</code> methods, you could call <code>sort</code> on the list iterators in the same way.</p>&#13;
<p class="indent">Additionally, <a href="anoverture.xhtml#anovertureex19">Listing 19</a> uses iostreams. <em>Iostreams</em> are the stdlib’s mechanism for performing buffered input and output. You use the put-to operator (<code>&lt;&lt;</code>) to stream the value of <code>x.size()</code> (the number of elements in <code>x</code>), some string literals, and the Fibonacci element <code>number</code> to <code>std::cout</code>, which encapsulates stdout <span class="ent">➎</span> <span class="ent">➏</span>. The <code>std::endl</code> object is an I/O manipulator that writes <code>\n</code> and flushes the buffer, ensuring that the entire stream is written to stdout before executing the next instruction.</p>&#13;
<p class="indent">Now, just imagine all the hoops you’d have to jump through to write an equivalent program in C, and you’ll see why the stdlib is such a valuable tool.</p>&#13;
<h4 class="h4" id="anoverturelev2sec8"><strong><em>Lambdas</em></strong></h4>&#13;
<p class="noindent"><em>Lambdas</em>, also called <em>unnamed</em> or <em>anonymous functions</em> in some circles, are another powerful language feature that improve the locality of code. In some cases, you should pass pointers to functions to use a pointer as the target of a newly created thread or to perform some transformation on each element of a sequence. It’s generally inconvenient to define a one-time-use <span epub:type="pagebreak" id="page_l"/>free function. That’s where lambdas come in. A lambda is a new, custom function <em>defined inline with the other parameters of an invocation</em>. Consider the following one-liner, which computes the count of even numbers in <code>x</code>:</p>&#13;
<pre>auto n_evens = std::count_if(x.begin(), x.end(),&#13;
                             [] (auto number) { return number % 2 == 0; });</pre>&#13;
<p class="indent">This snippet uses the stdlib’s <code>count_if</code> algorithm to count the even numbers in <code>x</code>. The first two arguments to <code>std::count_if</code> match <code>std::sort</code>; they’re the iterators that define the range over which the algorithm will operate. The third argument is the lambda. The notation probably looks a bit foreign, but the basics are quite simple:</p>&#13;
<pre>[<span class="codeitalic1">capture</span>] (<span class="codeitalic1">arguments</span>) { <span class="codeitalic1">body</span> }</pre>&#13;
<p class="indent"><em>Capture</em> contains any objects you need from the scope where the lambda is defined to perform computation in the body. <em>Arguments</em> define the names and types of arguments the lambda expects to be invoked with. The <em>body</em> contains any computation that you want completed upon invocation. It might or might not return a value. The compiler will deduce the function prototype based on the types you’ve implied.</p>&#13;
<p class="indent">In the <code>std::count_if</code> invocation above, the lambda didn’t need to capture any variables. All the information it needs is taken as a single argument <code>number</code>. Because the compiler knows the type of the elements contained in <code>x</code>, you declare the type of <code>number</code> with <code>auto</code> so the compiler can deduce it for you. The lambda is invoked with each element of <code>x</code> passed in as the <code>number</code> parameter. In the body, the lambda returns <code>true</code> only when <code>number</code> is divisible by <code>2</code>, so only the even numbers are included in the count.</p>&#13;
<p class="indent">Lambdas don’t exist in C, and it’s not really possible to reconstruct them. You’d need to declare a separate function each time you need a function object, and it’s not possible to capture objects into a function in the same way.</p>&#13;
<h4 class="h4" id="anoverturelev2sec9"><strong><em>Generic Programming with Templates</em></strong></h4>&#13;
<p class="noindent"><em>Generic programming</em> is writing code once that works with different types rather than having to repeat the same code multiple times by copying and pasting each type you want to support. In C++, you use <em>templates</em> to produce generic code. Templates are a special kind of parameter that tells the compiler to represent a wide range of possible types.</p>&#13;
<p class="indent">You’ve already used templates: all of the stdlib’s containers use templates. For the most part, the type of the objects in these containers doesn’t matter. For example, the logic for determining the number of elements in a container or returning its first element doesn’t depend on the element’s type.</p>&#13;
<p class="indent">Suppose you want to write a function that adds three numbers of the same type. You want to accept any addable type. In C++, this is a straight-forward generic programming problem that you can solve directly with templates, as <a href="anoverture.xhtml#anovertureex20">Listing 20</a> illustrates.</p>&#13;
<pre>template &lt;typename T&gt;&#13;
T add(T x, T y, T z) { <span class="ent">➊</span>&#13;
  return x + y + z;&#13;
}&#13;
&#13;
int main() {&#13;
  auto a = add(1, 2, 3);       // a is an int&#13;
  auto b = add(1L, 2L, 3L);    // b is a long&#13;
  auto c = add(1.F, 2.F, 3.F); // c is a float&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex20"/><em>Listing 20: Using templates to create a generic <code>add</code> function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_li"/>When you declare <code>add</code> <span class="ent">➊</span>, you don’t need to know <code>T</code>. You only need to know that all the arguments and the return value are of type <code>T</code> and that <code>T</code> is addable. When the compiler encounters <code>add</code> being called, it deduces <code>T</code> and generates a bespoke function on your behalf. That’s some serious code reuse!</p>&#13;
<h4 class="h4" id="anoverturelev2sec10"><strong><em>Class Invariants and Resource Management</em></strong></h4>&#13;
<p class="noindent">Perhaps the single greatest innovation C++ brings to system programming is the <em>object life cycle</em>. This concept has its roots in C, where objects have different storage durations depending on how you declare them in your code.</p>&#13;
<p class="indent">C++ builds on top of this memory management model with constructors and destructors. These special functions are methods that belong to <em>user-defined types</em>. User-defined types are the basic building blocks of C++ applications. Think of them as <code>struct</code> objects that can also have functions.</p>&#13;
<p class="indent">An object’s constructor is called just after its storage duration begins, and the destructor is called just before its storage duration ends. Both the constructor and destructor are functions with no return type and the same name as the enclosing class. To declare a destructor, add a <code>~</code> to the beginning of the class name, as <a href="anoverture.xhtml#anovertureex21">Listing 21</a> illustrates.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Hal {&#13;
  Hal() : version{ 9000 } { // Constructor <span class="ent">➊</span>&#13;
    printf("I'm completely operational.\n");&#13;
  }&#13;
  ~Hal() { // Destructor <span class="ent">➋</span>&#13;
    printf("Stop, Dave.\n");&#13;
  }&#13;
  const int version;&#13;
};</pre>&#13;
<p class="listing"><a id="anovertureex21"/><em>Listing 21: A <code>Hal</code> class containing a constructor and a destructor</em></p>&#13;
<p class="indent">The first method in <code>Hal</code> is the <em>constructor</em> <span class="ent">➊</span>. It sets up the <code>Hal</code> object and establishes its <em>class invariants</em>. Invariants are features of a class that don’t change once they’ve been constructed. With some help from the compiler and the runtime, the programmer decides what the invariants of a class are and ensures that their code enforces them. In this case, the constructor <span epub:type="pagebreak" id="page_lii"/>sets the <code>version</code>, which is an invariant, to <code>9000</code>. The <em>destructor</em> is the second method <span class="ent">➋</span>. Whenever <code>Hal</code> is about to be deallocated, it prints <code>"Stop, Dave."</code> to the console. (Getting <code>Hal</code> to sing “Daisy Bell” is left as an exercise to the reader.)</p>&#13;
<p class="indent">The compiler makes sure the constructor and destructor are invoked automatically for objects with static, local, and thread local storage duration. For objects with dynamic storage duration, you use the keywords <code>new</code> and <code>delete</code> to replace <code>malloc</code> and <code>free</code>, <a href="anoverture.xhtml#anovertureex22">Listing 22</a> illustrates.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Hal {&#13;
<span class="codeitalic1">--snip--</span>&#13;
};&#13;
&#13;
int main() {&#13;
  auto hal = new Hal{};  // Memory is allocated, then constructor is called&#13;
  delete hal;            // Destructor is called, then memory is deallocated&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">I'm completely operational.</span>&#13;
<span class="color1">Stop, Dave.</span></pre>&#13;
<p class="listing"><a id="anovertureex22"/><em>Listing 22: A program that creates and destroys a <code>Hal</code> object</em></p>&#13;
<p class="indent">If (for whatever reason) the constructor is unable to achieve a good state, it typically throws an <em>exception</em>. As a C programmer, you might have dealt with exceptions when programming with some operating system APIs (for example, Windows Structured Exception Handling). When an exception is thrown, the stack unwinds until an exception handler is found, at which point the program recovers. Judicious use of exceptions can clean up code because you only have to check for error conditions where it makes sense to do so. C++ has language-level support for exceptions, as <a href="anoverture.xhtml#anovertureex23">Listing 23</a> illustrates.</p>&#13;
<pre>#include &lt;exception&gt;&#13;
&#13;
try {&#13;
  // Some code that might throw a std::exception <span class="ent">➊</span>&#13;
} catch (const std::exception &amp;e) {&#13;
  // Recover the program here. <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex23"/><em>Listing 23: A <code>try</code>-<code>catch</code> block</em></p>&#13;
<p class="indent">You can put your code that might throw an exception in the block immediately following <code>try</code> <span class="ent">➊</span>. If at any point an exception is thrown, the stack will unwind (graciously destructing any objects that go out of scope) and run any code that you’ve put after the <code>catch</code> expression <span class="ent">➋</span>. If no exception is thrown, this <code>catch</code> code never executes.</p>&#13;
<p class="indent">Constructors, destructors, and exceptions are closely related to another core C++ theme, which is tying an object’s life cycle to the resources it owns. <span epub:type="pagebreak" id="page_liii"/>This is the resource allocation is initialization (RAII) concept (sometimes also called <em>constructor acquires, destructor releases</em>). Consider the C++ class in <a href="anoverture.xhtml#anovertureex24">Listing 24</a>.</p>&#13;
<pre>#include &lt;system_error&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
struct File {&#13;
  File(const char* path, bool write) { <span class="ent">➊</span>&#13;
    auto file_mode = write ? "w" : "r"; <span class="ent">➋</span>&#13;
    file_pointer = fopen(path, file_mode); <span class="ent">➌</span>&#13;
    if (!file_pointer) throw std::system_error(errno, std::system_category()); <span class="ent">➍</span>&#13;
  }&#13;
  ~File() {&#13;
    fclose(file_pointer);&#13;
  }&#13;
  FILE* file_pointer;&#13;
};</pre>&#13;
<p class="listing"><a id="anovertureex24"/><em>Listing 24: A <code>File</code> class</em></p>&#13;
<p class="indent">The constructor of <code>File</code> <span class="ent">➊</span> takes two arguments. The first argument corresponds with the <code>path</code> of the file, and the second is a <code>bool</code> corresponding to whether the file mode should be open for write (<code>true</code>) or read (<code>false</code>). This argument’s value sets <code>file_mode</code> <span class="ent">➋</span> via the <em>ternary operator</em> <code>? :</code>. The ternary operator evaluates a Boolean expression and returns one of two values depending on the Boolean value. For example:</p>&#13;
<pre>x ? val_if_true : val_if_false</pre>&#13;
<p class="indent">If the Boolean expression <code>x</code> is <code>true</code>, the expression’s value is <code>val_if_true</code>. If <code>x</code> is <code>false</code>, the value is <code>val_if_false</code> instead.</p>&#13;
<p class="indent">In the <code>File</code> constructor code snippet in <a href="anoverture.xhtml#anovertureex24">Listing 24</a>, the constructor attempts to open the file at <code>path</code> with read/write access <span class="ent">➌</span>. If anything goes wrong, the call will set <code>file_pointer</code> to <code>nullptr</code>, a special C++ value that’s similar to 0. When this happens, you throw a <code>system_error</code> <span class="ent">➍</span>. A <code>system_error</code> is just an object that encapsulates the details of a system error. If <code>file_pointer</code> isn’t <code>nullptr</code>, it’s valid to use. That’s this class’s invariant.</p>&#13;
<p class="indent">Now consider the program in <a href="anoverture.xhtml#anovertureex25">Listing 25</a>, which employs <code>File</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;system_error&gt;&#13;
#include &lt;cstring&gt;&#13;
&#13;
struct File {&#13;
--<span class="codeitalic1">snip</span>–&#13;
};&#13;
&#13;
int main() {&#13;
  { <span class="ent">➊</span>&#13;
    File file("last_message.txt", true); <span class="ent">➋</span>&#13;
    const auto message = "We apologize for the inconvenience.";&#13;
    fwrite(message, strlen(message), 1, file.file_pointer);&#13;
  } <span class="ent">➌</span>&#13;
  // last_message.txt is closed here!&#13;
  {&#13;
    File file("last_message.txt", false); <span class="ent">➍</span>&#13;
    char read_message[37]{};&#13;
    fread(read_message, sizeof(read_message), 1, file.file_pointer);&#13;
    printf("Read last message: %s\n", read_message);&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">We apologize for the inconvenience.</span></pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_liv"/><a id="anovertureex25"/><em>Listing 25: A program employing the <code>File</code> class</em></p>&#13;
<p class="indent">The braces <span class="ent">➊</span> <span class="ent">➌</span> define a scope. Because the first <code>file</code> resides within this scope, the scope defines the lifetime of <code>file</code>. Once the constructor returns <span class="ent">➋</span>, you know that <code>file.file_pointer</code> is valid thanks to the class invariant; based on the design of the constructor of <code>File</code>, you know <code>file.file_pointer</code> must be valid for the lifetime of the <code>File</code> object. You write a message using <code>fwrite</code>. There’s no need to call <code>fclose</code> explicitly, because <code>file</code> expires and the destructor cleans up <code>file.file_pointer</code> for you <span class="ent">➌</span>. You open <code>File</code> again but this time for read access <span class="ent">➍</span>. As long as the constructor returns, you know that <em>last_message.txt</em> was opened successfully and continue on reading into <code>read_message</code>. After printing the message, the destructor of <code>file</code> is called, and the <code>file.file_pointer</code> is again cleaned up.</p>&#13;
<p class="indent">Sometimes you need the flexibility of dynamic memory allocation, but you still want to lean on the object life cycle of C++ to ensure that you don’t leak memory or accidentally “use after free.” This is exactly the role of <em>smart pointers</em>, which manage the life cycle of dynamic objects through an ownership model. Once no smart pointer owns a dynamic object, the object destructs.</p>&#13;
<p class="indent">One such smart pointer is <code>unique_ptr</code>, which models exclusive ownership. <a href="anoverture.xhtml#anovertureex26">Listing 26</a> illustrates its basic usage.</p>&#13;
<pre>#include &lt;memory&gt;&#13;
&#13;
struct Foundation{&#13;
  const char* founder;&#13;
};&#13;
&#13;
int main() {&#13;
  std::unique_ptr&lt;Foundation&gt; second_foundation{ new Foundation{} }; <span class="ent">➊</span>&#13;
  // Access founder member variable just like a pointer:&#13;
  second_foundation-&gt;founder = "Wanda";&#13;
} <span class="ent">➋</span></pre>&#13;
<p class="listing"><a id="anovertureex26"/><em>Listing 26: A program employing a <code>unique_ptr</code></em></p>&#13;
<p class="indent">You dynamically allocate a <code>Foundation</code>, and the resulting <code>Foundation*</code> pointer is passed into the constructor of <code>second_foundation</code> using the <span epub:type="pagebreak" id="page_lv"/>braced-initialization syntax <span class="ent">➊</span>. The <code>second_foundation</code> has type <code>unique_ptr</code>, which is just an RAII object wrapping the dynamic <code>Foundation</code>. When <code>second_foundation</code> is destructed <span class="ent">➋</span>, the dynamic <code>Foundation</code> destructs appropriately.</p>&#13;
<p class="indent">Smart pointers differ from regular, <em>raw</em> pointers because a raw pointer is simply a memory address. You must orchestrate all the memory management that’s involved with the address manually. On the other hand, smart pointers handle all these messy details. By wrapping a dynamic object with a smart pointer, you can rest assured that memory will be cleaned up appropriately as soon as the object is no longer needed. The compiler knows that the object is no longer needed because the smart pointer’s destructor is called when it falls out of scope.</p>&#13;
<h4 class="h4" id="anoverturelev2sec11"><strong><em>Move Semantics</em></strong></h4>&#13;
<p class="noindent">Sometimes, you want to transfer ownership of an object; this comes up often, for example, with <code>unique_ptr</code>. You can’t copy a <code>unique_ptr</code>, because once one of the copies of the <code>unique_ptr</code> is destructed, the remaining <code>unique_ptr</code> would hold a reference to the deleted object. Rather than copying the object, you use the <code>move</code> semantics of C++ to transfer ownership from one unique pointer to another, as <a href="anoverture.xhtml#anovertureex27">Listing 27</a> illustrates.</p>&#13;
<pre>#include &lt;memory&gt;&#13;
&#13;
struct Foundation{&#13;
  const char* founder;&#13;
};&#13;
&#13;
struct Mutant {&#13;
  // Constructor sets foundation appropriately:&#13;
  Mutant(std::unique_ptr&lt;Foundation&gt; foundation)&#13;
    : foundation(std::move(foundation)) {}&#13;
  std::unique_ptr&lt;Foundation&gt; foundation;&#13;
};&#13;
&#13;
int main() {&#13;
  std::unique_ptr&lt;Foundation&gt; second_foundation{ new Foundation{} }; <span class="ent">➊</span>&#13;
  // ... use second_foundation&#13;
  Mutant the_mule{ std::move(second_foundation) }; <span class="ent">➋</span>&#13;
  // second_foundation is in a 'moved-from' state&#13;
  // the_mule owns the Foundation&#13;
}</pre>&#13;
<p class="listing"><a id="anovertureex27"/><em>Listing 27: A program moving a <code>unique_ptr</code></em></p>&#13;
<p class="indent">As before, you create <code>unique_ptr&lt;Foundation&gt;</code> <span class="ent">➊</span>. You use it for some time and then decide to transfer ownership to a <code>Mutant</code> object. The <code>move</code> function tells the compiler that you want to make the transfer. After constructing <code>the_mule</code> <span class="ent">➋</span>, the lifetime of <code>Foundation</code> is tied to the lifetime of <code>the_mule</code> through its member variable.</p>&#13;
<h3 class="h3" id="anoverturelev1sec3"><span epub:type="pagebreak" id="page_lvi"/><strong>Relax and Enjoy Your Shoes</strong></h3>&#13;
<p class="noindent">C++ is <em>the</em> premier system programming language. Much of your C knowledge will map directly into C++, but you’ll also learn many new concepts. You can start gradually incorporating C++ into your C programs using Super C. As you become competent in some of the deeper themes of C++, you’ll find that writing modern C++ brings with it many substantial advantages over C. You’ll be able to express ideas concisely in code, capitalize on the impressive stdlib to work at a higher level of abstraction, employ templates to improve runtime performance and code reuse, and lean on the C++ object life cycle to manage resources.</p>&#13;
<p class="indent">I expect that the investment you’ll make learning C++ will yield vast dividends. After reading this book, I think you’ll agree.</p>&#13;
</body></html>