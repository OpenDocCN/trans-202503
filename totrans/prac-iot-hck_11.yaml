- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: SPI and I²C
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 和 I²C
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: This chapter introduces you to the *Serial Peripheral Interface (SPI)* and the
    *Inter-Integrated Circuit (I²C)*, two common communication protocols in IoT devices
    that use microcontrollers and peripheral devices. As you learned in Chapter 7,
    sometimes simply connecting to interfaces, such as UART and JTAG, gives us direct
    access to a system shell, maybe one that the manufacturers left purposely. But
    what if the device’s JTAG or UART interfaces require authentication? Or worse,
    what if they’re not implemented? In those cases, you’ll still likely find older
    protocols like SPI and I²C built into the microcontrollers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你介绍了*串行外设接口（SPI）*和*集成电路互联（I²C）*，这两种是物联网设备中常见的通信协议，这些设备使用微控制器和外设。如你在第 7 章中所学，有时仅仅连接像
    UART 和 JTAG 这样的接口就能直接访问系统 shell，也许是制造商故意留下的。但是，如果设备的 JTAG 或 UART 接口需要身份验证呢？或者更糟的是，如果它们没有实现呢？在这些情况下，你仍然可能会找到像
    SPI 和 I²C 这样的旧协议，它们内建于微控制器中。
- en: In this chapter, you’ll use SPI to extract data from EEPROM and other flash
    memory chips, which often contain firmware and other important secrets, such as
    API keys, private passphrases, and service endpoints. You’ll also build your own
    I²C architecture and then practice sniffing and manipulating its serial communications
    to force the peripherals to perform actions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用 SPI 从 EEPROM 和其他闪存芯片中提取数据，这些芯片通常包含固件和其他重要机密信息，如 API 密钥、私密密码短语和服务端点。你还将构建自己的
    I²C 架构，然后练习嗅探并操控其串行通信，迫使外设执行某些操作。
- en: Hardware for Communicating with SPI and I²C
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 SPI 和 I²C 通信的硬件
- en: To communicate with SPI and I²C, you’ll need some specific hardware. You could
    use a breakout board or programmer for EEPROM/flash memory chips if you’re willing
    to desolder the chips (which should be your last resort). But if you prefer to
    not desolder anything from the circuit board, you can use either test hook clips
    or small outline integrated (SOIC) clips, which are cheap and handy.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 SPI 和 I²C 通信，你需要一些特定的硬件。如果你愿意从电路板上拆卸芯片，你可以使用 EEPROM/闪存芯片的分路板或编程器（但这应该是最后的手段）。但如果你不想拆卸电路板上的任何东西，你可以使用测试钩夹或小外形集成电路（SOIC）夹，这些都便宜且方便。
- en: For the SPI project in this chapter, you’ll need an eight-pin SOIC clip cable
    or hook clips to connect to the flash memory chips. SOIC clips ([Figure 8-1](#figure8-1))
    might be tricky to use, because you need to align the pads perfectly when connecting
    the clip to the chip. Hook clips might work better for some people.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 SPI 项目中，你需要一个八针 SOIC 夹线电缆或钩形夹子来连接闪存芯片。SOIC 夹（[图 8-1](#figure8-1)）可能比较难用，因为在将夹子连接到芯片时，你需要完美对齐引脚。对于一些人来说，钩形夹子可能会更合适。
- en: '![f08001](Images/f08001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![f08001](Images/f08001.png)'
- en: 'Figure 8-1: An eight-pin SOIC cable'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：八针 SOIC 电缆
- en: You’ll also need a USB-to-serial interface. Although you could use the adapter
    used in Chapter 7, we recommend the *Bus Pirate* ([http://dangerousprototypes.com/docs/Bus_Pirate](http://dangerousprototypes.com/docs/Bus_Pirate)),
    a robust open source device that supports multiple protocols. It has built-in
    macros for IoT hacking, including scanning and sniffing capabilities for I²C and
    many other protocols. You could also try more expensive tools that can parse I²C
    messages in more formats, like the Beagle ([https://www.totalphase.com/products/beagle-i2cspi/](https://www.totalphase.com/products/beagle-i2cspi/))
    or Aardvark ([https://www.totalphase.com/products/aardvark-i2cspi/](https://www.totalphase.com/products/aardvark-i2cspi/)).
    In this chapter, you’ll learn how to use Bus Pirate’s built-in macros to perform
    common attacks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个 USB 转串行接口。虽然你可以使用第 7 章中使用的适配器，但我们推荐使用*总线海盗*（[http://dangerousprototypes.com/docs/Bus_Pirate](http://dangerousprototypes.com/docs/Bus_Pirate)），这是一款强大的开源设备，支持多种协议。它内置了适用于物联网攻击的宏命令，包括
    I²C 和许多其他协议的扫描和嗅探功能。你还可以尝试一些更昂贵的工具，它们可以解析 I²C 消息的更多格式，比如 Beagle（[https://www.totalphase.com/products/beagle-i2cspi/](https://www.totalphase.com/products/beagle-i2cspi/)）或
    Aardvark（[https://www.totalphase.com/products/aardvark-i2cspi/](https://www.totalphase.com/products/aardvark-i2cspi/)）。在本章中，你将学习如何使用总线海盗的内置宏命令执行常见的攻击。
- en: Additionally, to run the I²C lab exercise later in this chapter, you’ll need
    an Arduino Uno ([https://store.arduino.cc/usa/arduino-uno-rev3/](https://store.arduino.cc/usa/arduino-uno-rev3/)),
    at least one BlinkM LED ([https://www.sparkfun.com/products/8579/](https://www.sparkfun.com/products/8579/)),
    a breadboard, and some jumper cables.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要在本章后续进行 I²C 实验，你将需要一个 Arduino Uno ([https://store.arduino.cc/usa/arduino-uno-rev3/](https://store.arduino.cc/usa/arduino-uno-rev3/))，至少一个
    BlinkM LED ([https://www.sparkfun.com/products/8579/](https://www.sparkfun.com/products/8579/))，一个面包板以及一些跳线。
- en: You might also use Helping Hands, devices that help you hold multiple hardware
    parts. They have a wide range of prices. Refer to “Tools for IoT Hacking” for
    a complete list of tools along with descriptions of some of their strengths and
    weaknesses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用帮助工具（如 Helping Hands）来帮助你固定多个硬件部件。它们的价格范围较广。有关工具的完整清单，以及它们的一些优缺点的描述，请参考《物联网黑客工具》一章。
- en: SPI
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SPI
- en: SPI is a communication protocol that transmits data between peripherals and
    microcontrollers. Found in popular hardware like the Raspberry Pi and Arduino,
    it’s a *synchronous communication protocol*, which means it can transfer data
    faster than I²C and UART. Often, it’s used for short-distance communications in
    places where read and write speeds matter, such as in Ethernet peripherals, LCD
    displays, SD card readers, and the memory chips on almost any IoT device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 是一种在外设和微控制器之间传输数据的通信协议。它广泛应用于 Raspberry Pi 和 Arduino 等流行硬件，是一种 *同步通信协议*，这意味着它比
    I²C 和 UART 传输数据更快。通常，它用于短距离通信场景，在那些读写速度至关重要的地方，比如以太网外设、LCD 显示器、SD 卡读卡器以及几乎所有物联网设备上的存储芯片。
- en: How SPI Works
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SPI 工作原理
- en: 'SPI uses four wires to transmit data. In full duplex mode, when data transmissions
    happen simultaneously in both directions, it relies on a controller-peripheral
    architecture. In such an architecture, the device that serves as the *controller*
    generates and controls a clock that regulates the data transfer, and all devices
    that serve as *peripherals* listen and send messages. SPI uses the following four
    lines (not counting the ground):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 使用四根线路来传输数据。在全双工模式下，当数据在两个方向上同时传输时，它依赖于控制器-外设架构。在这种架构中，作为 *控制器* 的设备生成并控制时钟，调节数据传输，所有作为
    *外设* 的设备则监听并发送消息。SPI 使用以下四条线路（不包括地线）：
- en: '**Controller In, Peripheral Out (CIPO)** For messages sent by peripherals to
    the controller'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**控制器输入，外设输出 (CIPO)** 用于外设向控制器发送的消息'
- en: '**Controller Out, Peripheral In (COPI)** For messages from the controller to
    peripherals'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**控制器输出，外设输入 (COPI)** 用于控制器向外设发送的消息'
- en: '**Serial Clock (SCK)** For an oscillating signal that indicates when devices
    should read lines of data'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**串行时钟 (SCK)** 用于指示设备何时应该读取数据线的振荡信号'
- en: '**Chip Select (CS)** To select the peripheral that should receive a communication'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**芯片选择 (CS)** 用于选择应该接收通信的外设'
- en: Notice that, unlike UART, SPI uses separate lines for sending and receiving
    data (*COPI* and *CIPO*, respectively). Also note that the hardware required to
    implement SPI is cheaper and simpler than UART, and it can achieve higher data
    rates. For these reasons, many microcontrollers used in the IoT world support
    it. You can learn more about SPI implementations at [https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all/.](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all/.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与 UART 不同，SPI 使用独立的线路来发送和接收数据（分别为 *COPI* 和 *CIPO*）。还要注意，实现 SPI 所需的硬件比 UART
    更便宜、更简单，并且能够达到更高的数据传输速率。正因为这些原因，许多物联网领域使用的微控制器都支持 SPI。你可以在 [https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all/.](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all/.)
    上了解更多关于 SPI 实现的信息。
- en: Dumping EEPROM Flash Memory Chips with SPI
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SPI 转储 EEPROM 闪存芯片
- en: Flash memory chips often contain the device’s firmware and other important secrets,
    so extracting data from them can yield interesting security findings, such as
    backdoors, encryption keys, secret accounts, and so on. To locate the memory chips
    in an IoT device, open its external case and remove the PCB.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存芯片通常包含设备的固件以及其他重要的机密信息，因此从中提取数据可能会发现有趣的安全问题，例如后门、加密密钥、秘密账户等。要定位物联网设备中的内存芯片，打开其外壳并取下
    PCB。
- en: Identifying the Chip and Pins
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确定芯片和引脚
- en: Locate your device’s flash memory chip. Products that have been hardened for
    security will usually delete the chip labels on the device, but flash memory chips
    commonly have 8 or 16 pins. You can also find the chip by looking up the microcontroller’s
    datasheet online, as we did in Chapter 7\. The datasheet should contain a diagram
    showing the pins’ configuration and descriptions. The datasheet will likely also
    contain information confirming whether the chip supports SPI. Other information,
    such as protocol version, speeds supported, and memory size, will also prove useful
    when configuring the tools for interacting with SPI.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 找到你设备的闪存芯片。经过安全加固的产品通常会删除设备上的芯片标签，但闪存芯片通常有 8 或 16 个引脚。你也可以通过查找微控制器的数据手册来找到芯片，就像我们在第
    7 章中做的那样。数据手册应包含一张显示引脚配置和描述的图表。数据手册还可能包含确认芯片是否支持 SPI 的信息。其他信息，如协议版本、支持的速度和存储大小，在配置与
    SPI 交互的工具时也非常有用。
- en: 'Once you’ve identified the memory chip, find the small dot at one of the chip’s
    corners that labels pin #1 ([Figure 8-2](#figure8-2)).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦你识别出内存芯片，找到芯片一个角落上的小点，它标示了引脚 #1（见[图 8-2](#figure8-2)）。'
- en: '![f08002](Images/f08002.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f08002](Images/f08002.png)'
- en: 'Figure 8-2: The flash memory chip'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-2: 闪存芯片'
- en: 'Now connect the first pin of an eight-pin SOIC cable to pin #1\. The first
    pin of the SOIC clip often has a different color than the others, making it easier
    to find. Use the pin configuration pulled from the datasheet to align the rest
    of the SOIC pads correctly. [Figure 8-3](#figure8-3) shows a common alignment.
    For example, the WinBond 25Q64 memory chip uses this alignment.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，将八引脚 SOIC 电缆的第一个引脚连接到引脚 #1。SOIC 夹具的第一个引脚通常与其他引脚颜色不同，便于识别。使用从数据手册中获取的引脚配置来正确对齐其余的
    SOIC 垫片。[图 8-3](#figure8-3) 显示了一个常见的对齐方式。例如，WinBond 25Q64 闪存芯片就使用这种对齐方式。'
- en: '![f08003](Images/f08003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![f08003](Images/f08003.png)'
- en: 'Figure 8-3: A memory chip’s pin configuration diagram'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-3: 内存芯片的引脚配置图'
- en: When you’ve connected all parts of the SOIC clip to the memory flash chip, your
    setup should look like the one in [Figure 8-4](#figure8-4). Be careful connecting
    the SOIC clip because you can easily damage the pins.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 SOIC 夹具的所有部分连接到闪存芯片时，设置应该像[图 8-4](#figure8-4)所示。连接 SOIC 夹具时要小心，因为你很容易损坏引脚。
- en: '![f08004](Images/f08004.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![f08004](Images/f08004.png)'
- en: 'Figure 8-4: SOIC clip connected to the flash memory chip'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-4: SOIC 夹具连接到闪存芯片'
- en: If you’re having trouble aligning the pads, test hook clips ([Figure 8-5](#figure8-5))
    work too; you might find them easier to connect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在对齐垫片时遇到困难，测试钩夹（见[图 8-5](#figure8-5)）也能派上用场；你可能会发现它们更容易连接。
- en: '![f08005](Images/f08005.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f08005](Images/f08005.png)'
- en: 'Figure 8-5: Hook clips connect to the SPI pins'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-5: 钩夹连接到 SPI 引脚'
- en: Communicating with the SPI Chip
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与 SPI 芯片通信
- en: You’ll need a USB-to-serial adapter to read the memory chip’s contents. We’ll
    use the Bus Pirate in this example, but you could use any adapter, because most
    support read operations. If you use the Bus Pirate, make sure you upgrade its
    firmware to the latest stable release.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个 USB 到串行适配器来读取内存芯片的内容。我们在这个示例中使用总线海盗，但你也可以使用任何适配器，因为大多数适配器都支持读取操作。如果使用总线海盗，请确保将其固件升级到最新的稳定版本。
- en: Make sure the device whose memory you’re extracting is powered off; then make
    the connections. Connect the Bus Pirate’s pins and the chip’s pins using the SOIC
    clip, as the datasheet indicates. For example, we’d connect the pins for the WinBond
    25Q64 chip as shown in [Table 8-1](#table8-1).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你正在提取内存的设备已关闭电源，然后进行连接。使用 SOIC 夹具连接总线海盗的引脚和芯片的引脚，如数据手册所示。例如，我们将按照[表 8-1](#table8-1)中所示连接
    WinBond 25Q64 芯片的引脚。
- en: 'Table 8-1: Connecting the Pins'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '表 8-1: 引脚连接'
- en: '| **Device/Bus Pirate** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **设备/总线海盗** |'
- en: '| --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Pin #1 (CS) → CS |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 #1 (CS) → CS |'
- en: '| Pin #2 (DO) → CIPO (MISO) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 #2 (DO) → CIPO (MISO) |'
- en: '| Pin #4 (GND) → GND |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 #4 (GND) → GND |'
- en: '| Pin #5 (DI) → COPI (MOSI) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 #5 (DI) → COPI (MOSI) |'
- en: '| Pin #6 (CLK) → CLK |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 #6 (CLK) → CLK |'
- en: '| Pin #8 (VCC) → 3V3 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 #8 (VCC) → 3V3 |'
- en: When you’re done, your connections should look like those in [Figure 8-6](#figure8-6).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成连接时，连接应该像[图 8-6](#figure8-6)中所示。
- en: '![f08006](Images/f08006.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![f08006](Images/f08006.png)'
- en: 'Figure 8-6: The Bus Pirate connected to the SPI chip with hook clips. We used
    Helping Hands to hold the different components.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-6: 总线海盗通过钩夹连接到 SPI 芯片。我们使用了帮助工具来固定不同的组件。'
- en: 'Now, while the device whose memory you’ll read is powered off, connect the
    Bus Pirate’s USB cable to your computer. You can test your communication with
    the SPI chip using the `flashrom` Linux utility, which you can download from[https://flashrom.org/Flashrom](https://flashrom.org/Flashrom)
    (or most package managers). The following command will identify the memory chipset:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您将读取其存储器的设备关闭电源的情况下，将Bus Pirate的USB电缆连接到计算机上。您可以使用`flashrom` Linux实用程序测试与SPI芯片的通信，该实用程序可以从[https://flashrom.org/Flashrom](https://flashrom.org/Flashrom)（或大多数包管理器）下载。以下命令将识别内存芯片组：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure you replace `ttyUSB0` with the device descriptor to which the USB-to-serial
    adapter has been assigned. It will usually be something like `ttyUSB`*<number>*,
    and you can issue the `ls /dev/tty*` command to see the descriptors on your system.
    The utility will either identify the SPI chip or return the message `No EEPROM/flash
    device found`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您用USB到串行适配器分配的设备描述符替换`ttyUSB0`。通常会是类似于`ttyUSB`*<number>*的内容，并且您可以使用`ls /dev/tty*`命令查看系统上的描述符。该实用程序将识别SPI芯片或返回消息`未找到EEPROM/闪存设备`。
- en: Reading the Memory Chip Contents
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取内存芯片内容
- en: 'Once you’ve established communication with the chip, you can perform a read
    operation to obtain its contents. Issue a read operation using the following `flashrom`
    command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦与芯片建立了通信，您就可以执行读操作来获取其内容。使用以下`flashrom`命令发出读操作：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `-r` flag issues a read operation that saves the contents in the specified
    file. The `-p` flag specifies the adapter’s name. The Bus Pirate’s name in this
    context is `buspirate_spi`, but you should change this name if you’re using another
    adapter. You should see output similar to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`-r`标志发出将内容保存在指定文件中的读操作。`-p`标志指定适配器的名称。在此上下文中，Bus Pirate的名称是`buspirate_spi`，但如果您使用其他适配器，则应更改此名称。您应该看到类似以下的输出：'
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the command is done running, the output file should match the chip storage
    size listed in the command output. For this chipset, it was 8MB.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 命令运行完成后，输出文件应与命令输出中列出的芯片存储大小匹配。对于这个芯片组，它是8MB。
- en: 'Alternatively, you can get the chip’s contents using the popular *spiflash.py*
    script from libmpsse. Download the library, created by devttys0, from [https://github.com/devttys0/libmpsse/](https://github.com/devttys0/libmpsse/),
    then compile and install it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用来自libmpsse的流行*spiflash.py*脚本获取芯片的内容。从[https://github.com/devttys0/libmpsse/](https://github.com/devttys0/libmpsse/)下载该库，这是由devttys0创建的，然后编译并安装它：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If everything worked, you should be able to run *spiflash.py*. To make sure
    the tool detects the chip correctly and that all your pin connections are correct,
    execute *spiflash.py* and look for the chipset name in the output. To extract
    the memory stored in the chip, enter the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该能够运行*spiflash.py*。为确保工具正确检测到芯片并且所有引脚连接正确，执行*spiflash.py*并查看输出中的芯片组名称。要提取存储在芯片中的内存，请输入以下命令：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, to read 8MB, run this command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要读取8MB，请运行以下命令：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you don’t know the size of the flash memory to extract, choose a random value
    large enough to hold the entire flash memory’s contents.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道要提取的闪存存储器的大小，请选择一个足够大以容纳整个闪存内容的随机值。
- en: Now that you’ve extracted the flash memory, you could run the `strings` utility
    to begin looking at the information or perform further analysis with tools like
    binwalk. You can learn more about firmware security testing in Chapter 9.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已提取了闪存，可以运行`strings`实用程序开始查看信息，或者使用binwalk等工具进行进一步分析。您可以在第9章了解更多有关固件安全测试的信息。
- en: I²C
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I²C
- en: Pronounced “I squared C,” *I²C* is a serial communication protocol for low-speed
    devices. Phillips Semiconductors developed I²C in the 1980s for communications
    between components on the same circuit board, but you can also use it between
    components connected via cable. In the IoT world, you’ll often find it in microcontrollers,
    I/O interfaces like keyboards and buttons, common household and enterprise devices,
    and sensors of all types. Crucially, even the sensors in many Industrial Control
    Systems (ICS) use I²C, making its exploitation high stakes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 发音为“I squared C”，*I²C*是一种用于低速设备的串行通信协议。菲利浦半导体在1980年代开发了I²C，用于同一电路板上组件之间的通信，但您也可以在通过电缆连接的组件之间使用它。在物联网世界中，您经常会在微控制器、键盘和按钮等I/O接口、常见家庭和企业设备以及各种类型的传感器中找到它。至关重要的是，许多工业控制系统（ICS）中的传感器甚至使用I²C，因此其利用非常重要。
- en: The main advantage of this protocol is its simplicity. Instead of the four wires
    that SPI uses, I²C has a two-wire interface. In addition, the protocol allows
    hardware without built-in I²C support to use I²C through general purpose I/O pins.
    But its simplicity, and the fact that all data travels over the same bus, makes
    it an easy target if you want to sniff or inject your own data. The reason is
    that no authentication occurs between components in IoT devices sharing the same
    I²C bus.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议的主要优点是其简单性。与 SPI 使用的四条线路不同，I²C 具有两线接口。此外，该协议允许没有内置 I²C 支持的硬件通过通用 I/O 引脚使用
    I²C。但由于其简单性，以及所有数据都通过同一总线传输，它也成为了一个容易被窃听或注入数据的目标。原因在于 IoT 设备之间共享同一 I²C 总线时，组件之间没有进行认证。
- en: How I²C Works
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I²C 工作原理
- en: 'I²C’s simplicity allows hardware to exchange data with no strict speed requirements.
    The protocol uses three lines: the serial data line (SDA) for transmitting data,
    the serial clock line (SCL) to determine when the data gets read, and the ground
    line (GND). SDA and SCL lines are connected to the peripherals and they’re *open
    drain drivers*, meaning that both lines need to be connected to resistors. (You’ll
    need only one resistor for each line, not one for every peripheral.) Voltages
    vary from 1.8 V, 3.3 V, and 5.0 V, and transfers can occur at four different speeds:
    100 kHz, or the initial speed according to I²C specifications; 400 kHz, which
    is the fast mode; 1 MHz, called high speed mode; and 3.2 MHz, called ultrafast
    mode.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 的简单性允许硬件交换数据，而无需严格的速度要求。该协议使用三条线路：串行数据线（SDA）用于传输数据，串行时钟线（SCL）用于确定数据何时读取，以及地线（GND）。SDA
    和 SCL 线路连接到外设，它们是 *开漏驱动器*，意味着这两条线路需要连接到电阻器。（每条线路只需要一个电阻器，而不是每个外设一个。）电压从 1.8 V、3.3
    V 和 5.0 V 不等，传输可以以四种不同的速度进行：100 kHz，即 I²C 规范中的初始速度；400 kHz，即快速模式；1 MHz，即高速模式；和
    3.2 MHz，即超高速模式。
- en: Like SPI, I²C uses a controller-peripheral configuration. The components transfer
    data over the SDA line, bit by bit, in eight-bit sequences. The controller, or
    multiple controllers, manages the SCL line. An I²C architecture supports more
    than one controller and one or more peripherals, each with unique addresses used
    for communication. [Table 8-2](#table8-2) shows the structure of a message sent
    from a controller to a peripheral.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 像 SPI 一样，I²C 使用控制器-外设配置。组件通过 SDA 线路逐位传输数据，按八位序列进行传输。控制器或多个控制器管理 SCL 线路。I²C 架构支持多个控制器和一个或多个外设，每个外设都有唯一的地址用于通信。[表
    8-2](#table8-2) 显示了从控制器发送到外设的消息结构。
- en: 'Table 8-2: An I²C Message Sent to a Peripheral over SDA'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2：通过 SDA 发送到外设的 I²C 消息
- en: '| START | I²C address (7 or 10 bits) | Read/Write bit | ACK/NACK bit | Data
    (8 bits) | ACK/NACK bit | Data (8 bits) | STOP |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 启动 | I²C 地址（7 位或 10 位） | 读/写位 | ACK/NACK 位 | 数据（8 位） | ACK/NACK 位 | 数据（8
    位） | 停止 |'
- en: The controller begins each message with a START condition that signals the beginning
    of the message. Then it sends the peripheral’s address, which is usually 7 bits
    long but can be as long as 10 bits. This allows for up to 128 (if using 7-bit
    addresses) or 1024 peripherals (if using 10-bit addresses) on the same bus. The
    controller also appends a Read/Write bit that indicates the kind of operation
    to perform. An ACK/NACK bit indicates what the following data segment will be.
    SPI divides the actual data into eight-bit sequences, each of which ends in another
    ACK/NACK bit. The controller ends the message by sending the STOP condition. For
    more information about the protocol, visit [https://www.i2c-bus.org/.](https://www.i2c-bus.org/)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器以启动条件开始每条消息，表示消息的开始。然后它发送外设的地址，通常为 7 位长，但也可以长达 10 位。这允许最多 128 个（如果使用 7 位地址）或
    1024 个（如果使用 10 位地址）外设在同一总线上。控制器还会附加一个读/写位，指示执行何种操作。一个 ACK/NACK 位指示接下来数据段的类型。SPI
    将实际数据分为八位序列，每个序列后跟一个 ACK/NACK 位。控制器通过发送停止条件来结束消息。有关协议的更多信息，请访问 [https://www.i2c-bus.org/.](https://www.i2c-bus.org/)
- en: As mentioned previously, the I²C protocol supports multiple controllers on the
    same bus. This is important, because by connecting to the bus, we could act as
    another controller, and then read and send data to the peripherals. In the next
    section, we’ll set up our own I²C bus architecture so we can do exactly that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，I²C 协议支持多个控制器在同一总线上。这一点非常重要，因为通过连接到总线，我们可以充当另一个控制器，然后读取和发送数据到外设。在下一节中，我们将设置我们自己的
    I²C 总线架构，以便可以实现这一目标。
- en: Setting Up a Controller-Peripheral I²C Bus Architecture
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置控制器-外设 I²C 总线架构
- en: 'To demonstrate how to sniff I²C communications and write data to peripherals
    on the bus, let’s set up a classic controller-peripheral architecture with some
    help from the following open source hardware:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何嗅探I²C通信并向总线上的外设写入数据，让我们通过以下开源硬件的帮助设置一个经典的控制器-外设架构：
- en: The Arduino Uno microcontroller ([https://store.arduino.cc/usa/arduino-uno-rev3/](https://store.arduino.cc/usa/arduino-uno-rev3/)*)*
    to act as the controller.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Uno微控制器([https://store.arduino.cc/usa/arduino-uno-rev3/](https://store.arduino.cc/usa/arduino-uno-rev3/))*作为控制器。
- en: One or more BlinkM I²C-controlled RGB LEDs ([https://www.sparkfun.com/products/8579/](https://www.sparkfun.com/products/8579/))
    to act as peripherals. You can find the complete BlinkM documentation, including
    examples of other ways to program them, at [https://thingm.com/products/blinkm/](https://thingm.com/products/blinkm/).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个BlinkM I²C控制的RGB LED（[https://www.sparkfun.com/products/8579/](https://www.sparkfun.com/products/8579/)）作为外设。你可以在[https://thingm.com/products/blinkm/](https://thingm.com/products/blinkm/)找到完整的BlinkM文档，包括其他编程方法的示例。
- en: We chose to use the Arduino Uno because the analog pins it uses for SDA and
    SCL have built-in resistors, so we won’t need to add pull-up resistors to the
    circuit. Also, this lets us use Arduino’s official *Wire* libraryto manage the
    I²C bus as the controller and send commands to the I²C peripherals. [Table 8-3](#table8-3)
    lists the Arduino Uno analog pins that support I²C.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用Arduino Uno，因为它用于SDA和SCL的模拟引脚内置了电阻，因此我们不需要在电路中添加上拉电阻。同时，这也使我们能够使用Arduino的官方*Wire*库来管理I²C总线作为控制器，并向I²C外设发送命令。[表8-3](#table8-3)列出了支持I²C的Arduino
    Uno模拟引脚。
- en: 'Table 8-3: Arduino Uno Pins for I²C Communications'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-3：用于I²C通信的Arduino Uno引脚
- en: '| **Arduino analog pin** | **I²C pin** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **Arduino模拟引脚** | **I²C引脚** |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A2 | GND |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| A2 | GND |'
- en: '| A3 | PWR |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| A3 | PWR |'
- en: '| A4 | SDA |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| A4 | SDA |'
- en: '| A5 | SCL |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| A5 | SCL |'
- en: Identify pins A2, A3, A4, and A5 on the Arduino Uno and then connect male-to-male
    Dupont cables to them, as shown in [Figure 8-7](#figure8-7).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 识别Arduino Uno上的A2、A3、A4和A5引脚，然后将公对公的杜邦线连接到它们，如[图8-7](#figure8-7)所示。
- en: '![f08007](Images/f08007.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![f08007](Images/f08007.png)'
- en: 'Figure 8-7: The analog pins are located in the bottom-right corner of the Arduino
    Uno.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-7：Arduino Uno的模拟引脚位于右下角。
- en: Next, identify the GND (-), PWR (+), SDA (d), and SCL (c) pins on the BlinkM
    LED by checking the label at the top of each pin, as shown in [Figure 8-8](#figure8-8).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过检查每个引脚顶部的标签，识别BlinkM LED上的GND（-）、PWR（+）、SDA（d）和SCL（c）引脚，如[图8-8](#figure8-8)所示。
- en: '![f08008](Images/f08008.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![f08008](Images/f08008.png)'
- en: 'Figure 8-8: The BlinkM GND, PWR, data, and clock pins are clearly labeled.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-8：BlinkM的GND、PWR、数据和时钟引脚已清晰标注。
- en: Now, use a breadboard to connect the BlinkM LED and cables to the corresponding
    pins on the Arduino, as described in .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用面包板将BlinkM LED和电缆连接到Arduino上的相应引脚，如所述。
- en: 'Table 8-4: Arduino/BlinkM Connections'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-4：Arduino/BlinkM连接
- en: '| **Arduino Uno/BlinkM RGB LED** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **Arduino Uno/BlinkM RGB LED** |'
- en: '| --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Pin A2 (GND) → PWR - |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 引脚A2（GND）→ PWR - |'
- en: '| Pin A3 (PWR) → PWR + |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 引脚A3（PWR）→ PWR + |'
- en: '| Pin A4 (SDA) → d (for data) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 引脚A4（SDA）→ d（数据） |'
- en: '| Pin A5 (SCL) → c (for clock) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 引脚A5（SCL）→ c（时钟） |'
- en: '[Figure 8-9](#figure8-9) shows these connections.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-9](#figure8-9)展示了这些连接。'
- en: '![f08009](Images/f08009.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f08009](Images/f08009.png)'
- en: 'Figure 8-9: We can connect SDA and SCL without resistors because the Arduino
    pins include built-in resistors.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-9：我们可以在没有电阻的情况下连接SDA和SCL，因为Arduino引脚包括内置电阻。
- en: If you have more than one I²C peripheral, connect them to the same SDA and SCL
    lines. Choose one line of the breadboard for SDA and another one for SCL; then
    connect the devices to those lines. For example, [Figure 8-10](#figure8-10) shows
    two connected BlinkMs. BlinkM LEDs of the same type all come with the same I²C
    address (0x09) by default, which is programmable, as indicated in the product
    datasheet available at [https://www.infinite-electronic.kr/datasheet/e0-COM-09000.pdf](https://www.infinite-electronic.kr/datasheet/e0-COM-09000.pdf).
    (This illustrates why you should always consult the datasheet, if it’s available;
    the information you find could save you reverse engineering efforts. In black
    box assessments, you might not be so lucky.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个I²C外设，将它们连接到相同的SDA和SCL线路上。为SDA选择面包板上的一条线路，为SCL选择另一条线路；然后将设备连接到这些线路。例如，[图8-10](#figure8-10)展示了两个连接的BlinkM。相同类型的BlinkM
    LED默认情况下都配有相同的I²C地址（0x09），该地址是可编程的，如产品数据表中所示，数据表可在[https://www.infinite-electronic.kr/datasheet/e0-COM-09000.pdf](https://www.infinite-electronic.kr/datasheet/e0-COM-09000.pdf)获取。（这说明了为什么你应该始终查阅数据表，如果它可用；你找到的信息可能会帮助你节省反向工程的时间。在黑盒评估中，你可能不会那么幸运。）
- en: '![f08010](Images/f08010.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f08010](Images/f08010.png)'
- en: 'Figure 8-10: An I²C bus supports up to 128 peripherals with 7-bit addresses.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-10：一个I²C总线最多支持128个带有7位地址的外设。
- en: Once you’ve connected the controller (Arduino) and peripheral (BlinkM LED),
    program the Arduino to join the bus and send some commands to the peripherals.
    We’ll use the Arduino IDE to write the program. See Chapter 7 for an introduction
    to the Arduino, as well as installation instructions. In the IDE, select the Arduino
    board you’re using by clicking **Tools**▶**Board**▶**Arduino/Genuino UNO**, and
    then upload the code in [Listing 8-1](#listing8-1).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你连接好控制器（Arduino）和外设（BlinkM LED），就可以编写程序让Arduino加入总线并向外设发送一些命令。我们将使用Arduino
    IDE来编写程序。有关Arduino的介绍以及安装说明，请参见第7章。在IDE中，通过点击**工具**▶**板子**▶**Arduino/Genuino UNO**来选择你使用的Arduino板子，然后上传[清单8-1](#listing8-1)中的代码。
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-1: The I²C controller code that will administer the BlinkM RGB LED'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 清单8-1：将管理BlinkM RGB LED的I²C控制器代码
- en: The code configures the Arduino pins for I²C communication 1, joins the I²C
    bus as the controller 2, and, using a loop, periodically sends a message to the
    peripherals with the address 0x09 3. The message contains commands to light up
    the LEDs 4. You can find lengthier descriptions of these commands in the BlinkM’s
    datasheet. Finally, the code sends a STOP sequence to indicate the end of the
    message 5.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码配置了Arduino引脚以进行I²C通信1，作为控制器加入I²C总线2，并通过循环定期向地址为0x09的外设发送消息3。消息中包含点亮LED的命令4。你可以在BlinkM的数据表中找到这些命令的详细描述。最后，代码发送一个STOP序列，表示消息的结束5。
- en: Now connect the Arduino Uno to the computer to power the circuit and upload
    your code. The BlinkM RGB LEDs should receive the commands and blink accordingly
    ([Figure 8-11](#figure8-11)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将Arduino Uno连接到计算机，以为电路供电并上传你的代码。BlinkM RGB LED应接收命令并相应地闪烁（[图8-11](#figure8-11)）。
- en: '![f08011](Images/f08011.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![f08011](Images/f08011.png)'
- en: 'Figure 8-11: The BlinkM LEDs receiving signals via I²C from the Arduino Uno'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-11：BlinkM LED通过I²C接收来自Arduino Uno的信号
- en: Attacking I²C with the Bus Pirate
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Bus Pirate攻击I²C
- en: Let’s connect the Bus Pirate to our I²C bus and start sniffing communications.
    The Bus Pirate’s firmware has built-in support for I²C. It also has a couple of
    useful macros that we can use to analyze and attack I²C communications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将Bus Pirate连接到I²C总线并开始嗅探通信。Bus Pirate的固件内置了对I²C的支持。它还提供了一些有用的宏，供我们分析和攻击I²C通信。
- en: 'We’ll use the following pins on the Bus Pirate: COPI (MOSI), which corresponds
    to the I²C SDA pin; CLK, which corresponds to the SCL pin; and GND. Connect these
    three lines from the Bus Pirate to the I²C bus ([Table 8-5](#table8-5)) using
    jumper cables.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Bus Pirate上的以下引脚：COPI（MOSI），它对应于I²C的SDA引脚；CLK，它对应于SCL引脚；以及GND。通过跳线将这三条线路从Bus
    Pirate连接到I²C总线（[表8-5](#table8-5)）。
- en: 'Table 8-5: Connections from the Bus Pirate to the I²C Bus'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-5：从Bus Pirate到I²C总线的连接
- en: '| **Bus Pirate/Breadboard** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **Bus Pirate/面包板** |'
- en: '| --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| COPI (MOSI) → SDA |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| COPI (MOSI) → SDA |'
- en: '| CLK → SCL |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| CLK → SCL |'
- en: '| GND → GND |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| GND → GND |'
- en: 'Once the pins are all connected, plug the Bus Pirate into your computer. To
    interact with it, you’ll need to connect it to the serial communication (COM)
    port using the default speed of 115,200 bauds. On Linux, do this using the `screen`
    or `minicom` utilities:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有引脚都连接好，将总线 Pirate 插入计算机。要与其交互，您需要通过默认速度 115,200 波特率将其连接到串行通信（COM）端口。在 Linux
    上，可以使用 `screen` 或 `minicom` 实用工具来完成此操作：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On Windows, open the Device Manager to see the COM port number. Then use PuTTY
    with the configuration shown in [Figure 8-12](#figure8-12).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，打开设备管理器查看 COM 端口号。然后使用 PuTTY，按照[图 8-12](#figure8-12)中的配置进行设置。
- en: '![f08012](Images/f08012.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![f08012](Images/f08012.png)'
- en: 'Figure 8-12: Configuring PuTTY to connect to the Bus Pirate'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-12：配置 PuTTY 以连接到总线 Pirate
- en: Once you’ve set the configuration in PuTTY, click **Open**. You should now have
    an established connection.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完 PuTTY 配置后，点击 **Open**。此时，您应该已经建立了连接。
- en: Detecting I²C Devices
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检测 I²C 设备
- en: 'To enumerate all the I²C devices connected to the bus, use the Bus Pirate’s
    *I*²*C* library to search the entire address space. This yields all I²C chips
    connected, as well as undocumented access addresses. We begin by setting the Bus
    Pirate’s mode using the `m` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要列举所有连接到总线的 I²C 设备，请使用总线 Pirate 的 *I*²*C* 库搜索整个地址空间。这将列出所有连接的 I²C 芯片，以及未记录的访问地址。我们首先使用
    `m` 命令设置总线 Pirate 的模式：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Select `4` to choose the I²C mode, and then set the desired speed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `4` 来选择 I²C 模式，然后设置所需的速度：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We set a speed of `4`**,** which corresponds to approximately 400 kHz, or the
    I²C fast rate, because the controller, the Arduino Uno, operates on that speed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了 `4`**，**对应大约 400 kHz，即 I²C 快速速率，因为控制器 Arduino Uno 以该速度运行。
- en: 'The *I*²*C* library supports two macros. The first is the *address search macro*,
    which will automatically try every I²C address. Then it looks for a response to
    determine how many peripherals are connected and if you can use any other addresses,
    such as broadcast addresses. Execute the macro by entering the `(1)` macro command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*I*²*C* 库支持两个宏。第一个是 *地址搜索宏*，它将自动尝试每个 I²C 地址。然后它会查找响应，以确定连接了多少外设，并检查是否可以使用其他地址，例如广播地址。通过输入
    `(1)` 宏命令执行该宏：'
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This macro displays the addresses, followed by the 7-bit address with a bit
    indicating whether the address is for reading or writing. In this case, we see
    the addresses 0x00(W), the BlinkM broadcast address, and 0x7F, which belongs to
    the BlinkM LED.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏显示地址，后跟 7 位地址以及一个比特位，指示该地址是用于读取还是写入。在这种情况下，我们看到地址 0x00(W)，这是 BlinkM 广播地址，和
    0x7F，属于 BlinkM LED。
- en: Sniffing and Sending Messages
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嗅探和发送消息
- en: 'The second macro built into the Bus Pirate’s *I*²*C* library is the sniffer.
    This macro displays all `START/STOP` sequences, `ACK/NACK` bits, and data shared
    through the I²C bus. Once again, we need to put the Bus Pirate in I²C mode, select
    the speed, and then execute macro number two using the command `(2)`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 内置于总线 Pirate *I*²*C* 库中的第二个宏是嗅探器。此宏显示所有 `START/STOP` 序列、`ACK/NACK` 比特和通过 I²C
    总线共享的数据。同样，我们需要将总线 Pirate 设置为 I²C 模式，选择速度，然后使用命令 `(2)` 执行第二个宏：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The captured data appears on the screen using Bus Pirate’s message format for
    I²C, allowing us to copy and paste the message to replay it, if desired. [Table
    8-6](#table8-6) shows the syntax Bus Pirate uses to represent I²C characters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获的数据以总线 Pirate 用于 I²C 的消息格式显示在屏幕上，允许我们复制并粘贴该消息以进行重播（如果需要）。[表 8-6](#table8-6)
    显示了总线 Pirate 用于表示 I²C 字符的语法。
- en: 'Table 8-6: Bus Pirate Symbols Corresponding to I²C Message Components'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-6：总线 Pirate 符号对应的 I²C 消息组件
- en: '| **I²C characters** | **Bus Pirate symbols** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **I²C 字符** | **总线 Pirate 符号** |'
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| START sequence | [ or { |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| START 序列 | [ 或 { |'
- en: '| STOP sequence | ] or } |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| STOP 序列 | ] 或 } |'
- en: '| ACK | + |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| ACK | + |'
- en: '| NACK | - |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| NACK | - |'
- en: Corroborate that your sniffer is working correctly by matching the sniffer data
    with the data sent by the Arduino Uno.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将嗅探器数据与 Arduino Uno 发送的数据进行对比，验证嗅探器是否工作正常。
- en: 'Now, to send data to any of the peripherals on the bus, enter the message on
    Bus Pirate’s prompt directly or copy any message you want to replay. We can see
    the command structure for changing color in the traffic, and by looking at the
    datasheet, we can deduce its structure. Now we can test it by replaying the command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要向总线上任何外设发送数据，可以直接在总线 Pirate 提示符中输入消息，或复制任何您想要重播的消息。我们可以看到更改颜色的命令结构，通过查看数据表，我们可以推断其结构。现在我们可以通过重播该命令来进行测试：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output shows the sequence bits and data you’ve written on the bus. Analyze
    the bus traffic on your own devices to identify patterns, then try sending your
    own commands. If you used the demo I²C bus shown in this chapter, you can find
    more valid commands on the BlinkM’s datasheet.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了你在总线上写入的序列比特和数据。分析你自己设备上的总线流量，以识别模式，然后尝试发送你自己的命令。如果你使用了本章中展示的I²C总线演示，可以在BlinkM的数据表中找到更多有效的命令。
- en: The stakes of replaying this command are fairly low; we’re only flashing lights
    in patterns. But in real-world attacks, you could use the same technique to write
    MAC addresses, flags, or factory settings, including serial numbers. Using the
    same approach as we used here, you should be able identify I²C buses on any IoT
    device and then analyze the communications between components to read and send
    your own data. In addition, due to this protocol’s simplicity, it’s very likely
    you’ll find it in all kinds of devices.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重放此命令的风险相对较低；我们只是以模式闪烁灯光。但在现实世界的攻击中，你可以使用相同的技术来写入MAC地址、标志或出厂设置，包括序列号。采用与我们在这里使用的相同方法，你应该能够识别任何IoT设备上的I²C总线，然后分析组件之间的通信，以读取和发送你自己的数据。此外，由于该协议的简单性，几乎所有类型的设备都可能会使用它。
- en: Conclusion
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: 'In this chapter, you learned about two of the most common protocols found in
    IoT devices at the hardware level: SPI and I²C. Fast peripherals are likely to
    implement SPI, whereas I²C can be implemented even in microcontrollers that don’t
    have it embedded by design, due its simplicity and cheap hardware requirements.
    The techniques and tools we discussed allow you to take apart devices and analyze
    them to understand their functionality for identifying security weaknesses. Throughout
    the chapter, we used the Bus Pirate, one of the many great tools available for
    interacting with SPI and I²C. This open source board has robust support for most
    communication protocols in IoT, including built-in macros for analyzing and attacking
    a wide variety of IoT devices.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你了解了两种在IoT设备硬件层面上最常见的协议：SPI和I²C。高速外设很可能实现SPI，而I²C甚至可以在那些设计上没有嵌入I²C的微控制器中实现，原因在于它的简单性和低廉的硬件要求。我们讨论的技术和工具可以帮助你拆解设备并分析它们，以了解其功能并识别安全弱点。在本章中，我们使用了Bus
    Pirate，这是许多用于与SPI和I²C交互的优秀工具之一。这个开源板卡对大多数IoT通信协议提供了强大的支持，包括内置宏来分析和攻击各种IoT设备。
