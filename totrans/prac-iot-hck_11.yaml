- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPI and I²C
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces you to the *Serial Peripheral Interface (SPI)* and the
    *Inter-Integrated Circuit (I²C)*, two common communication protocols in IoT devices
    that use microcontrollers and peripheral devices. As you learned in Chapter 7,
    sometimes simply connecting to interfaces, such as UART and JTAG, gives us direct
    access to a system shell, maybe one that the manufacturers left purposely. But
    what if the device’s JTAG or UART interfaces require authentication? Or worse,
    what if they’re not implemented? In those cases, you’ll still likely find older
    protocols like SPI and I²C built into the microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use SPI to extract data from EEPROM and other flash
    memory chips, which often contain firmware and other important secrets, such as
    API keys, private passphrases, and service endpoints. You’ll also build your own
    I²C architecture and then practice sniffing and manipulating its serial communications
    to force the peripherals to perform actions.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware for Communicating with SPI and I²C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To communicate with SPI and I²C, you’ll need some specific hardware. You could
    use a breakout board or programmer for EEPROM/flash memory chips if you’re willing
    to desolder the chips (which should be your last resort). But if you prefer to
    not desolder anything from the circuit board, you can use either test hook clips
    or small outline integrated (SOIC) clips, which are cheap and handy.
  prefs: []
  type: TYPE_NORMAL
- en: For the SPI project in this chapter, you’ll need an eight-pin SOIC clip cable
    or hook clips to connect to the flash memory chips. SOIC clips ([Figure 8-1](#figure8-1))
    might be tricky to use, because you need to align the pads perfectly when connecting
    the clip to the chip. Hook clips might work better for some people.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08001](Images/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: An eight-pin SOIC cable'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need a USB-to-serial interface. Although you could use the adapter
    used in Chapter 7, we recommend the *Bus Pirate* ([http://dangerousprototypes.com/docs/Bus_Pirate](http://dangerousprototypes.com/docs/Bus_Pirate)),
    a robust open source device that supports multiple protocols. It has built-in
    macros for IoT hacking, including scanning and sniffing capabilities for I²C and
    many other protocols. You could also try more expensive tools that can parse I²C
    messages in more formats, like the Beagle ([https://www.totalphase.com/products/beagle-i2cspi/](https://www.totalphase.com/products/beagle-i2cspi/))
    or Aardvark ([https://www.totalphase.com/products/aardvark-i2cspi/](https://www.totalphase.com/products/aardvark-i2cspi/)).
    In this chapter, you’ll learn how to use Bus Pirate’s built-in macros to perform
    common attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, to run the I²C lab exercise later in this chapter, you’ll need
    an Arduino Uno ([https://store.arduino.cc/usa/arduino-uno-rev3/](https://store.arduino.cc/usa/arduino-uno-rev3/)),
    at least one BlinkM LED ([https://www.sparkfun.com/products/8579/](https://www.sparkfun.com/products/8579/)),
    a breadboard, and some jumper cables.
  prefs: []
  type: TYPE_NORMAL
- en: You might also use Helping Hands, devices that help you hold multiple hardware
    parts. They have a wide range of prices. Refer to “Tools for IoT Hacking” for
    a complete list of tools along with descriptions of some of their strengths and
    weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: SPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SPI is a communication protocol that transmits data between peripherals and
    microcontrollers. Found in popular hardware like the Raspberry Pi and Arduino,
    it’s a *synchronous communication protocol*, which means it can transfer data
    faster than I²C and UART. Often, it’s used for short-distance communications in
    places where read and write speeds matter, such as in Ethernet peripherals, LCD
    displays, SD card readers, and the memory chips on almost any IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: How SPI Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SPI uses four wires to transmit data. In full duplex mode, when data transmissions
    happen simultaneously in both directions, it relies on a controller-peripheral
    architecture. In such an architecture, the device that serves as the *controller*
    generates and controls a clock that regulates the data transfer, and all devices
    that serve as *peripherals* listen and send messages. SPI uses the following four
    lines (not counting the ground):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller In, Peripheral Out (CIPO)** For messages sent by peripherals to
    the controller'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Controller Out, Peripheral In (COPI)** For messages from the controller to
    peripherals'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Serial Clock (SCK)** For an oscillating signal that indicates when devices
    should read lines of data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Chip Select (CS)** To select the peripheral that should receive a communication'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that, unlike UART, SPI uses separate lines for sending and receiving
    data (*COPI* and *CIPO*, respectively). Also note that the hardware required to
    implement SPI is cheaper and simpler than UART, and it can achieve higher data
    rates. For these reasons, many microcontrollers used in the IoT world support
    it. You can learn more about SPI implementations at [https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all/.](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all/.)
  prefs: []
  type: TYPE_NORMAL
- en: Dumping EEPROM Flash Memory Chips with SPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flash memory chips often contain the device’s firmware and other important secrets,
    so extracting data from them can yield interesting security findings, such as
    backdoors, encryption keys, secret accounts, and so on. To locate the memory chips
    in an IoT device, open its external case and remove the PCB.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the Chip and Pins
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Locate your device’s flash memory chip. Products that have been hardened for
    security will usually delete the chip labels on the device, but flash memory chips
    commonly have 8 or 16 pins. You can also find the chip by looking up the microcontroller’s
    datasheet online, as we did in Chapter 7\. The datasheet should contain a diagram
    showing the pins’ configuration and descriptions. The datasheet will likely also
    contain information confirming whether the chip supports SPI. Other information,
    such as protocol version, speeds supported, and memory size, will also prove useful
    when configuring the tools for interacting with SPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve identified the memory chip, find the small dot at one of the chip’s
    corners that labels pin #1 ([Figure 8-2](#figure8-2)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f08002](Images/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: The flash memory chip'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now connect the first pin of an eight-pin SOIC cable to pin #1\. The first
    pin of the SOIC clip often has a different color than the others, making it easier
    to find. Use the pin configuration pulled from the datasheet to align the rest
    of the SOIC pads correctly. [Figure 8-3](#figure8-3) shows a common alignment.
    For example, the WinBond 25Q64 memory chip uses this alignment.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f08003](Images/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: A memory chip’s pin configuration diagram'
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve connected all parts of the SOIC clip to the memory flash chip, your
    setup should look like the one in [Figure 8-4](#figure8-4). Be careful connecting
    the SOIC clip because you can easily damage the pins.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08004](Images/f08004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: SOIC clip connected to the flash memory chip'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re having trouble aligning the pads, test hook clips ([Figure 8-5](#figure8-5))
    work too; you might find them easier to connect.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08005](Images/f08005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: Hook clips connect to the SPI pins'
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the SPI Chip
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll need a USB-to-serial adapter to read the memory chip’s contents. We’ll
    use the Bus Pirate in this example, but you could use any adapter, because most
    support read operations. If you use the Bus Pirate, make sure you upgrade its
    firmware to the latest stable release.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the device whose memory you’re extracting is powered off; then make
    the connections. Connect the Bus Pirate’s pins and the chip’s pins using the SOIC
    clip, as the datasheet indicates. For example, we’d connect the pins for the WinBond
    25Q64 chip as shown in [Table 8-1](#table8-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1: Connecting the Pins'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device/Bus Pirate** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Pin #1 (CS) → CS |'
  prefs: []
  type: TYPE_TB
- en: '| Pin #2 (DO) → CIPO (MISO) |'
  prefs: []
  type: TYPE_TB
- en: '| Pin #4 (GND) → GND |'
  prefs: []
  type: TYPE_TB
- en: '| Pin #5 (DI) → COPI (MOSI) |'
  prefs: []
  type: TYPE_TB
- en: '| Pin #6 (CLK) → CLK |'
  prefs: []
  type: TYPE_TB
- en: '| Pin #8 (VCC) → 3V3 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done, your connections should look like those in [Figure 8-6](#figure8-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08006](Images/f08006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: The Bus Pirate connected to the SPI chip with hook clips. We used
    Helping Hands to hold the different components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, while the device whose memory you’ll read is powered off, connect the
    Bus Pirate’s USB cable to your computer. You can test your communication with
    the SPI chip using the `flashrom` Linux utility, which you can download from[https://flashrom.org/Flashrom](https://flashrom.org/Flashrom)
    (or most package managers). The following command will identify the memory chipset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you replace `ttyUSB0` with the device descriptor to which the USB-to-serial
    adapter has been assigned. It will usually be something like `ttyUSB`*<number>*,
    and you can issue the `ls /dev/tty*` command to see the descriptors on your system.
    The utility will either identify the SPI chip or return the message `No EEPROM/flash
    device found`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the Memory Chip Contents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you’ve established communication with the chip, you can perform a read
    operation to obtain its contents. Issue a read operation using the following `flashrom`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-r` flag issues a read operation that saves the contents in the specified
    file. The `-p` flag specifies the adapter’s name. The Bus Pirate’s name in this
    context is `buspirate_spi`, but you should change this name if you’re using another
    adapter. You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the command is done running, the output file should match the chip storage
    size listed in the command output. For this chipset, it was 8MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can get the chip’s contents using the popular *spiflash.py*
    script from libmpsse. Download the library, created by devttys0, from [https://github.com/devttys0/libmpsse/](https://github.com/devttys0/libmpsse/),
    then compile and install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything worked, you should be able to run *spiflash.py*. To make sure
    the tool detects the chip correctly and that all your pin connections are correct,
    execute *spiflash.py* and look for the chipset name in the output. To extract
    the memory stored in the chip, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to read 8MB, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t know the size of the flash memory to extract, choose a random value
    large enough to hold the entire flash memory’s contents.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve extracted the flash memory, you could run the `strings` utility
    to begin looking at the information or perform further analysis with tools like
    binwalk. You can learn more about firmware security testing in Chapter 9.
  prefs: []
  type: TYPE_NORMAL
- en: I²C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pronounced “I squared C,” *I²C* is a serial communication protocol for low-speed
    devices. Phillips Semiconductors developed I²C in the 1980s for communications
    between components on the same circuit board, but you can also use it between
    components connected via cable. In the IoT world, you’ll often find it in microcontrollers,
    I/O interfaces like keyboards and buttons, common household and enterprise devices,
    and sensors of all types. Crucially, even the sensors in many Industrial Control
    Systems (ICS) use I²C, making its exploitation high stakes.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this protocol is its simplicity. Instead of the four wires
    that SPI uses, I²C has a two-wire interface. In addition, the protocol allows
    hardware without built-in I²C support to use I²C through general purpose I/O pins.
    But its simplicity, and the fact that all data travels over the same bus, makes
    it an easy target if you want to sniff or inject your own data. The reason is
    that no authentication occurs between components in IoT devices sharing the same
    I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: How I²C Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I²C’s simplicity allows hardware to exchange data with no strict speed requirements.
    The protocol uses three lines: the serial data line (SDA) for transmitting data,
    the serial clock line (SCL) to determine when the data gets read, and the ground
    line (GND). SDA and SCL lines are connected to the peripherals and they’re *open
    drain drivers*, meaning that both lines need to be connected to resistors. (You’ll
    need only one resistor for each line, not one for every peripheral.) Voltages
    vary from 1.8 V, 3.3 V, and 5.0 V, and transfers can occur at four different speeds:
    100 kHz, or the initial speed according to I²C specifications; 400 kHz, which
    is the fast mode; 1 MHz, called high speed mode; and 3.2 MHz, called ultrafast
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Like SPI, I²C uses a controller-peripheral configuration. The components transfer
    data over the SDA line, bit by bit, in eight-bit sequences. The controller, or
    multiple controllers, manages the SCL line. An I²C architecture supports more
    than one controller and one or more peripherals, each with unique addresses used
    for communication. [Table 8-2](#table8-2) shows the structure of a message sent
    from a controller to a peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-2: An I²C Message Sent to a Peripheral over SDA'
  prefs: []
  type: TYPE_NORMAL
- en: '| START | I²C address (7 or 10 bits) | Read/Write bit | ACK/NACK bit | Data
    (8 bits) | ACK/NACK bit | Data (8 bits) | STOP |'
  prefs: []
  type: TYPE_TB
- en: The controller begins each message with a START condition that signals the beginning
    of the message. Then it sends the peripheral’s address, which is usually 7 bits
    long but can be as long as 10 bits. This allows for up to 128 (if using 7-bit
    addresses) or 1024 peripherals (if using 10-bit addresses) on the same bus. The
    controller also appends a Read/Write bit that indicates the kind of operation
    to perform. An ACK/NACK bit indicates what the following data segment will be.
    SPI divides the actual data into eight-bit sequences, each of which ends in another
    ACK/NACK bit. The controller ends the message by sending the STOP condition. For
    more information about the protocol, visit [https://www.i2c-bus.org/.](https://www.i2c-bus.org/)
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the I²C protocol supports multiple controllers on the
    same bus. This is important, because by connecting to the bus, we could act as
    another controller, and then read and send data to the peripherals. In the next
    section, we’ll set up our own I²C bus architecture so we can do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Controller-Peripheral I²C Bus Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate how to sniff I²C communications and write data to peripherals
    on the bus, let’s set up a classic controller-peripheral architecture with some
    help from the following open source hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino Uno microcontroller ([https://store.arduino.cc/usa/arduino-uno-rev3/](https://store.arduino.cc/usa/arduino-uno-rev3/)*)*
    to act as the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more BlinkM I²C-controlled RGB LEDs ([https://www.sparkfun.com/products/8579/](https://www.sparkfun.com/products/8579/))
    to act as peripherals. You can find the complete BlinkM documentation, including
    examples of other ways to program them, at [https://thingm.com/products/blinkm/](https://thingm.com/products/blinkm/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We chose to use the Arduino Uno because the analog pins it uses for SDA and
    SCL have built-in resistors, so we won’t need to add pull-up resistors to the
    circuit. Also, this lets us use Arduino’s official *Wire* libraryto manage the
    I²C bus as the controller and send commands to the I²C peripherals. [Table 8-3](#table8-3)
    lists the Arduino Uno analog pins that support I²C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-3: Arduino Uno Pins for I²C Communications'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arduino analog pin** | **I²C pin** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A2 | GND |'
  prefs: []
  type: TYPE_TB
- en: '| A3 | PWR |'
  prefs: []
  type: TYPE_TB
- en: '| A4 | SDA |'
  prefs: []
  type: TYPE_TB
- en: '| A5 | SCL |'
  prefs: []
  type: TYPE_TB
- en: Identify pins A2, A3, A4, and A5 on the Arduino Uno and then connect male-to-male
    Dupont cables to them, as shown in [Figure 8-7](#figure8-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08007](Images/f08007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: The analog pins are located in the bottom-right corner of the Arduino
    Uno.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, identify the GND (-), PWR (+), SDA (d), and SCL (c) pins on the BlinkM
    LED by checking the label at the top of each pin, as shown in [Figure 8-8](#figure8-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08008](Images/f08008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: The BlinkM GND, PWR, data, and clock pins are clearly labeled.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, use a breadboard to connect the BlinkM LED and cables to the corresponding
    pins on the Arduino, as described in .
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-4: Arduino/BlinkM Connections'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arduino Uno/BlinkM RGB LED** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Pin A2 (GND) → PWR - |'
  prefs: []
  type: TYPE_TB
- en: '| Pin A3 (PWR) → PWR + |'
  prefs: []
  type: TYPE_TB
- en: '| Pin A4 (SDA) → d (for data) |'
  prefs: []
  type: TYPE_TB
- en: '| Pin A5 (SCL) → c (for clock) |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 8-9](#figure8-9) shows these connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f08009](Images/f08009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: We can connect SDA and SCL without resistors because the Arduino
    pins include built-in resistors.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have more than one I²C peripheral, connect them to the same SDA and SCL
    lines. Choose one line of the breadboard for SDA and another one for SCL; then
    connect the devices to those lines. For example, [Figure 8-10](#figure8-10) shows
    two connected BlinkMs. BlinkM LEDs of the same type all come with the same I²C
    address (0x09) by default, which is programmable, as indicated in the product
    datasheet available at [https://www.infinite-electronic.kr/datasheet/e0-COM-09000.pdf](https://www.infinite-electronic.kr/datasheet/e0-COM-09000.pdf).
    (This illustrates why you should always consult the datasheet, if it’s available;
    the information you find could save you reverse engineering efforts. In black
    box assessments, you might not be so lucky.)
  prefs: []
  type: TYPE_NORMAL
- en: '![f08010](Images/f08010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-10: An I²C bus supports up to 128 peripherals with 7-bit addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve connected the controller (Arduino) and peripheral (BlinkM LED),
    program the Arduino to join the bus and send some commands to the peripherals.
    We’ll use the Arduino IDE to write the program. See Chapter 7 for an introduction
    to the Arduino, as well as installation instructions. In the IDE, select the Arduino
    board you’re using by clicking **Tools**▶**Board**▶**Arduino/Genuino UNO**, and
    then upload the code in [Listing 8-1](#listing8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: The I²C controller code that will administer the BlinkM RGB LED'
  prefs: []
  type: TYPE_NORMAL
- en: The code configures the Arduino pins for I²C communication 1, joins the I²C
    bus as the controller 2, and, using a loop, periodically sends a message to the
    peripherals with the address 0x09 3. The message contains commands to light up
    the LEDs 4. You can find lengthier descriptions of these commands in the BlinkM’s
    datasheet. Finally, the code sends a STOP sequence to indicate the end of the
    message 5.
  prefs: []
  type: TYPE_NORMAL
- en: Now connect the Arduino Uno to the computer to power the circuit and upload
    your code. The BlinkM RGB LEDs should receive the commands and blink accordingly
    ([Figure 8-11](#figure8-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08011](Images/f08011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-11: The BlinkM LEDs receiving signals via I²C from the Arduino Uno'
  prefs: []
  type: TYPE_NORMAL
- en: Attacking I²C with the Bus Pirate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s connect the Bus Pirate to our I²C bus and start sniffing communications.
    The Bus Pirate’s firmware has built-in support for I²C. It also has a couple of
    useful macros that we can use to analyze and attack I²C communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the following pins on the Bus Pirate: COPI (MOSI), which corresponds
    to the I²C SDA pin; CLK, which corresponds to the SCL pin; and GND. Connect these
    three lines from the Bus Pirate to the I²C bus ([Table 8-5](#table8-5)) using
    jumper cables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-5: Connections from the Bus Pirate to the I²C Bus'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bus Pirate/Breadboard** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| COPI (MOSI) → SDA |'
  prefs: []
  type: TYPE_TB
- en: '| CLK → SCL |'
  prefs: []
  type: TYPE_TB
- en: '| GND → GND |'
  prefs: []
  type: TYPE_TB
- en: 'Once the pins are all connected, plug the Bus Pirate into your computer. To
    interact with it, you’ll need to connect it to the serial communication (COM)
    port using the default speed of 115,200 bauds. On Linux, do this using the `screen`
    or `minicom` utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, open the Device Manager to see the COM port number. Then use PuTTY
    with the configuration shown in [Figure 8-12](#figure8-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08012](Images/f08012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-12: Configuring PuTTY to connect to the Bus Pirate'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve set the configuration in PuTTY, click **Open**. You should now have
    an established connection.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting I²C Devices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To enumerate all the I²C devices connected to the bus, use the Bus Pirate’s
    *I*²*C* library to search the entire address space. This yields all I²C chips
    connected, as well as undocumented access addresses. We begin by setting the Bus
    Pirate’s mode using the `m` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Select `4` to choose the I²C mode, and then set the desired speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We set a speed of `4`**,** which corresponds to approximately 400 kHz, or the
    I²C fast rate, because the controller, the Arduino Uno, operates on that speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *I*²*C* library supports two macros. The first is the *address search macro*,
    which will automatically try every I²C address. Then it looks for a response to
    determine how many peripherals are connected and if you can use any other addresses,
    such as broadcast addresses. Execute the macro by entering the `(1)` macro command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This macro displays the addresses, followed by the 7-bit address with a bit
    indicating whether the address is for reading or writing. In this case, we see
    the addresses 0x00(W), the BlinkM broadcast address, and 0x7F, which belongs to
    the BlinkM LED.
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing and Sending Messages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The second macro built into the Bus Pirate’s *I*²*C* library is the sniffer.
    This macro displays all `START/STOP` sequences, `ACK/NACK` bits, and data shared
    through the I²C bus. Once again, we need to put the Bus Pirate in I²C mode, select
    the speed, and then execute macro number two using the command `(2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The captured data appears on the screen using Bus Pirate’s message format for
    I²C, allowing us to copy and paste the message to replay it, if desired. [Table
    8-6](#table8-6) shows the syntax Bus Pirate uses to represent I²C characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-6: Bus Pirate Symbols Corresponding to I²C Message Components'
  prefs: []
  type: TYPE_NORMAL
- en: '| **I²C characters** | **Bus Pirate symbols** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| START sequence | [ or { |'
  prefs: []
  type: TYPE_TB
- en: '| STOP sequence | ] or } |'
  prefs: []
  type: TYPE_TB
- en: '| ACK | + |'
  prefs: []
  type: TYPE_TB
- en: '| NACK | - |'
  prefs: []
  type: TYPE_TB
- en: Corroborate that your sniffer is working correctly by matching the sniffer data
    with the data sent by the Arduino Uno.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to send data to any of the peripherals on the bus, enter the message on
    Bus Pirate’s prompt directly or copy any message you want to replay. We can see
    the command structure for changing color in the traffic, and by looking at the
    datasheet, we can deduce its structure. Now we can test it by replaying the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the sequence bits and data you’ve written on the bus. Analyze
    the bus traffic on your own devices to identify patterns, then try sending your
    own commands. If you used the demo I²C bus shown in this chapter, you can find
    more valid commands on the BlinkM’s datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: The stakes of replaying this command are fairly low; we’re only flashing lights
    in patterns. But in real-world attacks, you could use the same technique to write
    MAC addresses, flags, or factory settings, including serial numbers. Using the
    same approach as we used here, you should be able identify I²C buses on any IoT
    device and then analyze the communications between components to read and send
    your own data. In addition, due to this protocol’s simplicity, it’s very likely
    you’ll find it in all kinds of devices.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about two of the most common protocols found in
    IoT devices at the hardware level: SPI and I²C. Fast peripherals are likely to
    implement SPI, whereas I²C can be implemented even in microcontrollers that don’t
    have it embedded by design, due its simplicity and cheap hardware requirements.
    The techniques and tools we discussed allow you to take apart devices and analyze
    them to understand their functionality for identifying security weaknesses. Throughout
    the chapter, we used the Bus Pirate, one of the many great tools available for
    interacting with SPI and I²C. This open source board has robust support for most
    communication protocols in IoT, including built-in macros for analyzing and attacking
    a wide variety of IoT devices.'
  prefs: []
  type: TYPE_NORMAL
