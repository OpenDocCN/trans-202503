["```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, statement body)\nstatement = Return(exp)\nexp = Constant(int)\n    | Unary(unary_operator, exp)\n    **| Binary(binary_operator, exp, exp)**\nunary_operator = Complement | Negate\n**binary_operator = Add | Subtract | Multiply | Divide | Remainder**\n```", "```\n<exp> ::= <int> | <unop> <exp> | \"(\" <exp> \")\" | **<exp> <binop> <exp>**\n```", "```\n<exp> ::= <term> {(\"+\" | \"-\") <term>}\n<term> ::= <factor> {(\"*\" | \"/\" | \"%\") <factor>}\n<factor> ::= <int> | <unop> <factor> | \"(\" <exp> \")\"\n```", "```\n<program> ::= <function>\n<function> ::= \"int\" <identifier> \"(\" \"void\" \")\" \"{\" <statement> \"}\"\n<statement> ::= \"return\" <exp> \";\"\n**<exp> ::= <factor> | <exp> <binop> <exp>**\n**<factor> ::= <int> | <unop> <factor> | \"(\" <exp> \")\"**\n<unop> ::= \"-\" | \"~\"\n**<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\"**\n<identifier> ::= ? An identifier token ?\n<int> ::= ? A constant token ?\n```", "```\nparse_factor(tokens):\n    next_token = peek(tokens)\n    if next_token is an int:\n        `--snip--`\n    else if next_token is \"~\" or \"-\":\n        operator = parse_unop(tokens)\n      ❶ inner_exp = parse_factor(tokens)\n        return Unary(operator, inner_exp)\nelse if next_token == \"(\":\n        take_token(tokens)\n      ❷ inner_exp = parse_exp(tokens)\n        expect(\")\", tokens)\n        return inner_exp\n    else:\n        fail(\"Malformed factor\")\n```", "```\nparse_exp(tokens):\n  ❶ left = parse_factor(tokens)\n    next_token = peek(tokens)\n  ❷ while next_token is \"+\" or \"-\":\n        operator = parse_binop(tokens)\n      ❸ right = parse_factor(tokens)\n      ❹ left = Binary(operator, left, right)\n        next_token = peek(tokens)\n    return left\n```", "```\nparse_exp(tokens, **min_prec**):\n    left = parse_factor(tokens)\n    next_token = peek(tokens)\n    while next_token is **a binary operator and precedence(next_token) >= min_prec**:\n        operator = parse_binop(tokens)\n        **right = parse_exp(tokens, precedence(next_token) + 1)**\n        left = Binary(operator, left, right)\n        next_token = peek(tokens)\n    return left\n```", "```\n1 * 2 - 3 * (4 + 5)\n```", "```\nparse_exp(\"1 * 2 - 3 * (4 + 5)\", 0):\n```", "```\n left = parse_factor(\"1 * 2 - 3 * (4 + 5)\")\n        = Constant(1)\n    next_token = \"*\"\n```", "```\n // loop iteration #1\n    operator = parse_binop(\"* 2 - 3 * (4 + 5)\")\n             = Multiply\n    right = parse_exp(\"2 - 3 * (4 + 5)\", 51)\n                left = parse_factor(\"2 - 3 * (4 + 5)\")\n                     = Constant(2)\n                next_token = \"-\"\n                // precedence(next_token) < 51\n         = Constant(2)\n    left = Binary(Multiply, Constant(1), Constant(2))\n    next_token = \"-\"\n```", "```\n // loop iteration #2\n    operator = parse_binop(\"- 3 * (4 + 5)\")\n             = Subtract\n    right = parse_exp(\"3 * (4 + 5)\", 46)\n                left = parse_factor(\"3 * (4 + 5)\")\n                     = Constant(3)\n                next_token = \"*\"\n                // loop iteration #1\n                operator = parse_binop(\"* (4 + 5)\")\n                         = Multiply\n                right = parse_exp(\"(4 + 5)\", 51)\n                            left = parse_factor(\"(4 + 5)\")\n                                        parse_exp(\"4 + 5)\", 0)\n                                        `--snip--`\n                                = Binary(Add, Constant(4), Constant(5))\n                      = Binary(Add, Constant(4), Constant(5))\n                left = Binary(\n                           Multiply,\n                           Constant(3),\n                           Binary(Add, Constant(4), Constant(5))\n                        )\n          = Binary(\n                Multiply,\n                Constant(3),\n                Binary(Add, Constant(4), Constant(5))\n            )\n    left = Binary(\n               Subtract,\n               Binary(Multiply, Constant(1), Constant(2)),\n               Binary(\n                   Multiply,\n                   Constant(3),\n                   Binary(Add, Constant(4), Constant(5))\n                )\n            )\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier, instruction* body)\ninstruction = Return(val)\n            | Unary(unary_operator, val src, val dst)\n            **| Binary(binary_operator, val src1, val src2, val dst)**\nval = Constant(int) | Var(identifier)\nunary_operator = Complement | Negate\n**binary_operator = Add | Subtract | Multiply | Divide | Remainder**\n```", "```\nemit_tacky(e, instructions):\n    match e with\n    | `--snip--`\n    | Binary(op, e1, e2) ->\n        v1 = emit_tacky(e1, instructions)\n        v2 = emit_tacky(e2, instructions)\n        dst_name = make_temporary()\n        dst = Var(dst_name)\n        tacky_op = convert_binop(op)\n        instructions.append(Binary(tacky_op, v1, v2, dst))\n        return dst\n```", "```\n#include <stdio.h>\n\nint main(void) {\n    return printf(\"Hello, \") + printf(\"World!\");\n}\n```", "```\nHello, World!\nWorld!Hello,\n```", "```\n00000000000000000000000000000011\n```", "```\n0000000000000000000000000000000000000000000000000000000000000011\n```", "```\n11111111111111111111111111111101\n```", "```\n1111111111111111111111111111111111111111111111111111111111111101\n```", "```\nmovl   $2, -4(%rbp)\nmovl   $9, %eax\ncdq\nidivl  -4(%rbp)\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, instruction* instructions)\ninstruction = Mov(operand src, operand dst)\n            | Unary(unary_operator, operand)\n            **| Binary(binary_operator, operand, operand)**\n            **| Idiv(operand)**\n            **| Cdq**\n            | AllocateStack(int)\n            | Ret\nunary_operator = Neg | Not\n**binary_operator = Add | Sub | Mult**\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int)\nreg = AX | **DX** | R10 | **R11**\n```", "```\nBinary(op, src1, src2, dst)\n```", "```\nMov(src1, dst)\nBinary(op, src2, dst)\n```", "```\nBinary(Divide, src1, src2, dst)\n```", "```\nMov(src1, Reg(AX))\nCdq\nIdiv(src2)\nMov(Reg(AX), dst)\n```", "```\nBinary(Remainder, src1, src2, dst)\n```", "```\nMov(src1, Reg(AX))\nCdq\nIdiv(src2)\nMov(**Reg(DX)**, dst)\n```", "```\nidivl  $3\n```", "```\nmovl   $3, %r10d\nidivl  %r10d\n```", "```\naddl   -4(%rbp), -8(%rbp)\n```", "```\nmovl   -4(%rbp), %r10d\naddl   %r10d, -8(%rbp)\n```", "```\nimull  $3, -4(%rbp)\n```", "```\nmovl   -4(%rbp), %r11d\nimull  $3, %r11d\nmovl   %r11d, -4(%rbp)\n```", "```\n<samp class=\"SANS_Futura_Std_Book_11\">Print out the function definition.\nOn Linux, add at end of file:</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.section .note.GNU-stack,\"\",@progbits</samp>\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.globl</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><name>\n<name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp>\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">pushq    %rbp\n    movq     %rsp, %rbp</samp> \n    <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><instructions></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">movl</samp> <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><dst></samp></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">movq    %rbp, %rsp\npopq    %rbp\nret</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><unary_operator>     <operand></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><binary_operator>    <src></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><dst></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">idivl</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><operand></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">cdq</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">subq    $</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><int></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, %rsp</samp>\n```", "```\n$ **./test_compiler** `**/path/to/your_compiler**` **--chapter 3 --bitwise**\n```"]