["```\ncall stdout.newln;\n```", "```\nprocedure *`ProcName`*;\n          << Local declarations >>\n     begin *`ProcName`*;\n          << Procedure statements >>\n     end *`ProcName`*;\n```", "```\nprocedure zeroBytes;\nbegin zeroBytes;\n\n     mov( 0, eax );\n     mov( 256, ecx );\n     repeat\n          mov( eax, [ebx] );\n          add( 4, ebx );\n          dec( ecx );\n\n     until( @z );  // That is, until ecx=0.\n\nend zeroBytes;\n```", "```\nprogram zeroBytesDemo;\n#include( \"stdlib.hhf\" )\n\n    procedure zeroBytes;\n    begin zeroBytes;\n\n        mov( 0, eax );\n        mov( 256, ecx );\n        repeat\n\n            mov( eax, [ebx] );  // Zero out current dword.\n            add( 4, ebx );      // Point ebx at next dword.\n            dec( ecx );         // Count off 256 dwords.\n\n        until( ecx = 0 );       // Repeat for 256 dwords.\n\n    end zeroBytes;\n\nstatic\n    dwArray: dword[256];\n\nbegin zeroBytesDemo;\n\n    lea( ebx, dwArray );\n    call zeroBytes;\n\nend zeroBytesDemo;\n```", "```\ncall stdout.newln;\nstdout.newln();\n```", "```\ncall zeroBytes;\nzeroBytes();\n```", "```\nprogram nonWorkingProgram;\n#include( \"stdlib.hhf\" );\n\n    procedure PrintSpaces;\n    begin PrintSpaces;\n\n        mov( 40, ecx );\n        repeat\n\n            mov( ' ', al );\n            stdout.putc( al );  // Print 1 of 40 spaces.\n            dec( ecx );         // Count off 40 spaces.\n\n        until( ecx = 0 );\n\n    end PrintSpaces;\n\nbegin nonWorkingProgram;\n\n    mov( 20, ecx );\n    repeat\n\n        PrintSpaces();\n        stdout.put( '*', nl );\n        dec( ecx );\n\n    until( ecx = 0 );\n\nend nonWorkingProgram;\n```", "```\nprocedure PrintSpaces;\n    begin PrintSpaces;\n\n        push( eax );\n        push( ecx );\n        mov( 40, ecx );\n        repeat\n\n            mov( ' ', al );\n            stdout.putc( al );  // Print 1 of 40 spaces.\n            dec( ecx );         // Count off 40 spaces.\n\n        until( ecx = 0 );\n        pop( ecx );\n        pop( eax );\n\n    end PrintSpaces;\n```", "```\nprogram callerPreservation;\n#include( \"stdlib.hhf\" );\n\n    procedure PrintSpaces;\n    begin PrintSpaces;\n\n        mov( 40, ecx );\n        repeat\n\n            mov( ' ', al );\n            stdout.putc( al );  // Print 1 of 40 spaces.\n            dec( ecx );         // Count off 40 spaces.\n\n        until( ecx = 0 );\n\n    end PrintSpaces;\nbegin callerPreservation;\n\n    mov( 20, ecx );\n    repeat\n\n        push( eax );\n        push( ecx );\n        PrintSpaces();\n        pop( ecx );\n        pop( eax );\n        stdout.put( '*', nl );\n        dec( ecx );\n\n    until( ecx = 0 );\n\nend callerPreservation;\n```", "```\nprogram callerPreservation2;\n#include( \"stdlib.hhf\" );\n\n    procedure PrintSpaces;\n    begin PrintSpaces;\n\n        mov( 40, ecx );\n        repeat\n\n            mov( ' ', al );\n            stdout.putc( al );  // Print 1 of 40 spaces.\n            dec( ecx );         // Count off 40 spaces.\n\n        until( ecx = 0 );\n\n    end PrintSpaces;\n\nbegin callerPreservation2;\n\n    mov( 10, ecx );\n    repeat\n\n        push( ecx );\n        PrintSpaces();\n        pop( ecx );\n        stdout.put( '*', nl );\n        dec( ecx );\n\n    until( ecx = 0 );\n\n    mov( 5, ebx );\n    while( ebx > 0 ) do\n\n        PrintSpaces();\n\n        stdout.put( ebx, nl );\n        dec( ebx );\n\n    endwhile;\n\n    mov( 110, ecx );\n    for( mov( 0, eax );  eax < 7; inc( eax )) do\n\n        PrintSpaces();\n\n        stdout.put( eax, \" \", ecx, nl );\n        dec( ecx );\n\n    endfor;\n\nend callerPreservation2;\n```", "```\nexit *`procedurename`*;\nexitif( *`boolean_expression`* ) *`procedurename`*;\n```", "```\nif( *`boolean_expression`* ) then\n\n               exit *`procedurename`*;\n\n          endif;\n```", "```\nprogram demoGlobalScope;\n#include( \"stdlib.hhf\" );\n\nstatic\n    AccessibleInProc: char;\n\n    procedure aProc;\n    begin aProc;\n\n        mov( 'a', AccessibleInProc );\n\n    end aProc;\n\nstatic\n    InaccessibleInProc: char;\n\nbegin demoGlobalScope;\n\n    mov( 'b', InaccessibleInProc );\n    aProc();\n    stdout.put\n    (\n        \"AccessibleInProc   = '\", AccessibleInProc,   \"'\" nl\n        \"InaccessibleInProc = '\", InaccessibleInProc, \"'\" nl\n    );\n\nend demoGlobalScope;\n```", "```\nprogram demoLocalVars;\n#include( \"stdlib.hhf\" );\n\n    // Simple procedure that displays 0..9 using\n    // a local variable as a loop control variable.\n\n    procedure CntTo10;\n    var\n        i: int32;\n\n    begin CntTo10;\n\n        for( mov( 0, i ); i < 10; inc( i )) do\n\n            stdout.put( \"i=\" , i, nl );\n\n        endfor;\n\n    end CntTo10;\n\nbegin demoLocalVars;\n\n    CntTo10();\n\nend demoLocalVars;\n```", "```\nprogram demoLocalVars2;\n#include( \"stdlib.hhf\" );\n\nstatic\n    i:  uns32 := 10;\n    j:  uns32 := 20;\n\n    // The following procedure declares i and j\n    // as local variables, so it does not have access\n    // to the global variables by the same name.\n\n    procedure First;\n    var\n        i:int32;\n        j:uns32;\n\n    begin First;\n\n        mov( 10, j );\n        for( mov( 0, i ); i < 10; inc( i )) do\n\n            stdout.put( \"i=\", i,\" j=\", j, nl );\n            dec( j );\n\n        endfor;\n\n    end First;\n\n    // This procedure declares only an i variable.\n    // It cannot access the value of the global i\n    // variable but it can access the value of the\n    // global j object because it does not provide\n    // a local variant of j.\n\n    procedure Second;\n    var\n        i:uns32;\n\n    begin Second;\n\n        mov( 10, j );\n        for( mov( 0, i ); i < 10; inc( i )) do\n\n            stdout.put( \"i=\", i,\" j=\", j, nl );\n            dec( j );\n\n        endfor;\n\n    end Second;\n\nbegin demoLocalVars2;\n\n    First();\n    Second();\n\n    // Because the calls to First and Second have not\n    // modified variable i, the following statement\n    // should print \"i=10\". However, because the Second\n    // procedure manipulated global variable j, this\n    // code will print \"j=0\" rather than \"j=20\".\n\n    stdout.put(  \"i=\", i, \" j=\", j, nl );\n\nend demoLocalVars2;\n```", "```\nCallProc(I);\n```", "```\nprocedure PrintNSpaces( N:uns32 );\n    begin PrintNSpaces;\n\n        push( ecx );\n        mov( N, ecx );\n        repeat\n\n            stdout.put( ' ' );  // Print 1 of N spaces.\n            dec( ecx );         // Count off N spaces.\n\n        until( ecx = 0 );\n        pop( ecx );\n\n    end PrintNSpaces;\n```", "```\nPrintNSpaces( *`constant`* );\nPrintNSpaces( *`reg32`* );\nPrintNSpaces( *`uns32_variable`* );\n```", "```\nPrintNSpaces( 40 );\nPrintNSpaces( eax );\nPrintNSpaces( SpacesToPrint );\n```", "```\nprocedure PrintNChars( N:uns32; c:char );\n    begin PrintNChars;\n\n        push( ecx );\n        mov( N, ecx );\n        repeat\n\n            stdout.put( c );    // Print 1 of N characters.\n            dec( ecx );         // Count off N characters.\n\n        until( ecx = 0 );\n        pop( ecx );\n\n    end PrintNChars;\n```", "```\nPrintNChars( 20, '*' );\n```", "```\n*`parameter_identifier`* : *`type_identifier`*\n```", "```\nPtrVar: pointer to uns32\nArrayVar: uns32[10]\nrecordVar: record i:int32; u:uns32; endrecord\nDynArray: array.dArray( uns32, 2 )\n```", "```\ntype\n     uPtr:        pointer to uns32;\n     uArray10:    uns32[10];\n     recType:     record i:int32; u:uns32; endrecord\n     dType:       array.dArray( uns32, 2 );\n\n     procedure FancyParms\n     (\n          PtrVar:   uPtr;\n          ArrayVar: uArray10;\n          recordVar:recType;\n          DynArray: dType\n     );\n     begin FancyParms;\n          .\n          .\n          .\n     end FancyParms;\n```", "```\nprocedure PrintNSpaces( val N:uns32 );\n    begin PrintNSpaces;\n\n        push( ecx );\n        mov( N, ecx );\n        repeat\n\n            stdout.put( ' ' );  // Print 1 of N spaces.\n            dec( ecx );         // Count off N spaces.\n\n        until( ecx = 0 );\n        pop( ecx );\n\n    end PrintNSpaces;\n```", "```\nprocedure UsePassByReference( var PBRvar: int32 );\n     begin UsePassByReference;\n          .\n          .\n          .\n     end UsePassByReference;\n```", "```\nUsePassByReference( i32 );\nUsePassByReference( (type int32 [ebx] ) );\n```", "```\nUsePassByReference( 40 );           // Constants are illegal.\nUsePassByReference( EAX );          // Bare registers are illegal.\nUsePassByReference( charVar );      // Actual parameter type must match\n                                    // the formal parameter type.\n```", "```\nprogram PassByRefDemo;\n#include( \"stdlib.hhf\" );\n\nvar\n    i:  int32;\n    j:  int32;\n\n    procedure pbr( var a:int32; var b:int32 );\n    const\n        aa: text := \"(type int32 [ebx])\";\n        bb: text := \"(type int32 [ebx])\";\n\n    begin pbr;\n\n        push( eax );\n        push( ebx );        // Need to use ebx to dereference a and b.\n\n        // a = −1;\n\n        mov( a, ebx );      // Get ptr to the \"a\" variable.\n        mov( −1, aa );      // Store −1 into the \"a\" parameter.\n\n        // b = −2;\n\n        mov( b, ebx );      // Get ptr to the \"b\" variable.\n        mov( −2, bb );      // Store −2 into the \"b\" parameter.\n\n        // Print the sum of a+b.\n        // Note that ebx currently contains a pointer to \"b\".\n\n        mov( bb, eax );\n        mov( a, ebx );      // Get ptr to \"a\" variable.\n        add( aa, eax );\n        stdout.put( \"a+b=\", (type int32 eax), nl );\n\n    end pbr;\n\nbegin PassByRefDemo;\n\n    // Give i and j some initial values so\n    // we can see that pass by reference will\n    // overwrite these values.\n\n    mov( 50, i );\n    mov( 25, j );\n\n    // Call pbr passing i and j by reference\n\n    pbr( i, j );\n\n    // Display the results returned by pbr.\n\n    stdout.put\n    (\n        \"i=  \", i, nl,\n        \"j=  \", j, nl\n    );\n\nend PassByRefDemo;\n```", "```\na+b=−4\ni=  −2;\nj=  25;\n```", "```\nif( cs.member( al, {'a'..'z'}) ) then\n     .\n     .\n     .\nendif;\n```", "```\nmov( mov( 0, eax ), ebx );\n```", "```\nmov( 0, eax );     // HLA compiles interior instructions first.\n     mov( eax, ebx );   // HLA substituted \"eax\" for \"mov( 0, eax )\"\n```", "```\nadd( sub( mov( i, eax ), mov( j, ebx )), mov( k, ecx ));\n```", "```\nsub( mov( i, eax ), mov( j, ebx ))\n```", "```\nsub( eax, mov( j, ebx ))\n```", "```\nsub( eax, ebx )\n```", "```\nadd( ebx, mov( k, ecx ));\n```", "```\nadd( ebx, ecx );\n```", "```\nmov( i, eax );\n     mov( j, ebx );\n     sub( eax, ebx );\n     mov( k, ecx );\n     add( ebx, ecx );\n```", "```\nadd( mov( eax, i ), mov( ebx, j ) );\n```", "```\nmov( eax, i );\n          mov( ebx, j );\n          add( i, j );\n```", "```\nprocedure *`ProcName`* ( *`optional_parameters`* );  @returns( *`string_constant`* );\n      << Local declarations >>\n begin *`ProcName`*;\n      << Procedure statements >>\n end *`ProcName`*;\n```", "```\nprocedure IsAlphabeticChar( c:char ); @returns( \"EAX\" );\nbegin IsAlphabeticChar;\n\n     // Note that cs.member returns true/false in eax.\n\n     cs.member( c, {'a'..'z', 'A'..'Z'} );\n\nend IsAlphabeticChar;\n```", "```\nmov( IsAlphabeticChar( al ), ebx );\n          .\n          .\n          .\n     if( IsAlphabeticChar( ch ) ) then\n          .\n          .\n          .\n     endif;\n```", "```\nIsAlphabeticChar( ch );\n     if( eax ) then\n          .\n          .\n          .\n     endif;\n```", "```\nwhile( IsAlphabeticChar( ch ) ) do\n          .\n          .\n          .\n     endwhile;\n```", "```\nIsAlphabeticChar( ch );\n     while( eax ) do\n          .\n          .\n          .\n     endwhile;\n```", "```\nprocedure Recursive;\nbegin Recursive;\n\n     Recursive();\n\nend Recursive;\n```", "```\nprocedure Recursive;\nbegin Recursive;\n\n     dec( eax );\n     if( @nz ) then\n\n         Recursive();\n\n     endif;\n\nend Recursive;\n```", "```\nprocedure Recursive;\nbegin Recursive;\n\n     repeat\n          dec( eax );\n     until( @z );\n\nend Recursive;\n```", "```\nprogram QSDemo;\n#include( \"stdlib.hhf\" );\n\ntype\n    ArrayType:  uns32[ 10 ];\n\nstatic\n    theArray:   ArrayType := [1,10,2,9,3,8,4,7,5,6];\n\n    procedure quicksort( var a:ArrayType; Low:int32; High:int32 );\n    const\n        i:      text := \"(type int32 edi)\";\n        j:      text := \"(type int32 esi)\";\n        Middle: text := \"(type uns32 edx)\";\n        ary:    text := \"[ebx]\";\n\n    begin quicksort;\n\n        push( eax );\n        push( ebx );\n        push( ecx );\n        push( edx );\n        push( esi );\n        push( edi );\n\n        mov( a, ebx );      // Load BASE address of \"a\" into ebx.\n\n        mov( Low, edi);     // i := Low;\n        mov( High, esi );   // j := High;\n\n        // Compute a pivotal element by selecting the\n        // physical middle element of the array.\n\n        mov( i, eax );\n        add( j, eax );\n        shr( 1, eax );\n        mov( ary[eax*4], Middle );  // Put middle value in edx.\n\n        // Repeat until the edi and esi indexes cross one\n        // another (edi works from the start towards the end\n        // of the array, esi works from the end towards the\n        // start of the array).\n\n        repeat\n\n            // Scan from the start of the array forward\n            // looking for the first element greater or equal\n            // to the middle element).\n\n            while( Middle > ary[i*4] ) do\n\n                inc( i );\n\n            endwhile;\n\n            // Scan from the end of the array backwards looking\n            // for the first element that is less than or equal\n            // to the middle element.\n\n            while( Middle < ary[j*4] ) do\n\n                dec( j );\n\n            endwhile;\n\n            // If we've stopped before the two pointers have\n            // passed over one another, then we've got two\n            // elements that are out of order with respect\n            // to the middle element, so swap these two elements.\n\n            if( i <= j ) then\n\n                mov( ary[i*4], eax );\n                mov( ary[j*4], ecx );\n                mov( eax, ary[j*4] );\n                mov( ecx, ary[i*4] );\n                inc( i );\n                dec( j );\n\n            endif;\n\n        until( i > j );\n\n        // We have just placed all elements in the array in\n        // their correct positions with respect to the middle\n        // element of the array. So all elements at indexes\n        // greater than the middle element are also numerically\n        // greater than this element. Likewise, elements at\n        // indexes less than the middle (pivotal) element are\n        // now less than that element. Unfortunately, the\n        // two halves of the array on either side of the pivotal\n        // element are not yet sorted. Call quicksort recursively\n        // to sort these two halves if they have more than one\n        // element in them (if they have zero or one elements, then\n        // they are already sorted).\n\n        if( Low < j ) then\n\n            quicksort( a, Low, j );\n\n        endif;\n        if( i < High ) then\n\nquicksort( a, i, High );\n\n        endif;\n\n        pop( edi );\n        pop( esi );\n        pop( edx );\n        pop( ecx );\n        pop( ebx );\n        pop( eax );\n\n    end quicksort;\n\nbegin QSDemo;\n\n    stdout.put( \"Data before sorting: \" nl );\n    for( mov( 0, ebx ); ebx < 10; inc( ebx )) do\n\n        stdout.put( theArray[ebx*4]:5 );\n\n    endfor;\n    stdout.newln();\n\n    quicksort( theArray, 0, 9 );\n\n    stdout.put( \"Data after sorting: \" nl );\n    for( mov( 0, ebx ); ebx < 10; inc( ebx )) do\n\n        stdout.put( theArray[ebx*4]:5 );\n\n    endfor;\n    stdout.newln();\n\nend QSDemo;\n```", "```\nprocedure quicksort( var a:ArrayType; Low:int32; High:int32 ); forward;\n```", "```\nprocedure IsItReady( valueToTest: dword ); @returns( \"eax\" ); forward;\n```", "```\n*`procname`*:procedure( *`parameters`* );\nbegin *`procname`*;\n    << body >>\nend *`procname`*;\n*`procname`*:procedure( *`parameters`* ) {*`options`*};\nbegin *`procname`*;\n    << body >>\nend *`procname`*;\n*`procname`*:procedure( *`parameters`* ); *`external`*;\n*`procname`*:procedure( *`parameters`* ) { *`options`* }; *`external`*;\n```", "```\nprocedure *`ProcName`*; @noframe; @nodisplay;\nbegin *`ProcName`*;\n     .\n     .\n     .\nend *`ProcName`*;\n```", "```\nprocedure minimal; @nodisplay; @noframe; @noalignstack;\nbegin minimal;\n\n     ret();\n\nend minimal;\n```", "```\nprogram missingRET;\n#include( \"stdlib.hhf\" );\n\n    // This first procedure has the @noframe\n    // option but does not have a ret instruction.\n\n    procedure firstProc; @noframe; @nodisplay;\n    begin firstProc;\n\n        stdout.put( \"Inside firstProc\" nl );\n\n    end firstProc;\n\n    // Because the procedure above does not have a\n    // ret instruction, it will \"fall through\" to\n    // the following instruction. Note that there\n    // is no call to this procedure anywhere in\n    // this program.\n\n    procedure secondProc; @noframe; @nodisplay;\n    begin secondProc;\n\n        stdout.put( \"Inside secondProc\" nl );\n        ret();\n\nend secondProc;\n\nbegin missingRET;\n\n    // Call the procedure that doesn't have\n    // a ret instruction.\n\n    call firstProc;\n\nend missingRET;\n```", "```\nprocedure MessedUp; @noframe; @nodisplay;\nbegin MessedUp;\n\n     push( eax );\n     ret();\n\nend MessedUp;\n```", "```\nprocedure messedUpToo; @noframe; @nodisplay;\nbegin messedUpToo;\n\n     pop( eax );\n     ret();\n\nend messedUpToo;\n```", "```\nprogram extraPop;\n#include( \"stdlib.hhf\" );\n\n    // Note that the following procedure pops\n    // excess data off the stack (in this case,\n    // it pops messedUpToo's return address).\n\n    procedure messedUpToo; @noframe; @nodisplay;\n    begin messedUpToo;\n\n        stdout.put( \"Entered messedUpToo\" nl );\n        pop( eax );\n        ret();\n\n    end messedUpToo;\n\n    procedure callsMU2; @noframe; @nodisplay;\n    begin callsMU2;\n\n        stdout.put( \"calling messedUpToo\" nl );\n        messedUpToo();\n\n        // Because messedUpToo pops extra data\n        // off the stack, the following code\n        // never executes (because the data popped\n        // off the stack is the return address that\n        // points at the following code).\n\n        stdout.put( \"Returned from messedUpToo\" nl );\n        ret();\n\n    end callsMU2;\n\nbegin extraPop;\n\n    stdout.put( \"Calling callsMU2\" nl );\n    callsMU2();\n    stdout.put( \"Returned from callsMU2\" nl );\n\nend extraPop;\n```", "```\nprocedure ARDemo( i:uns32; j:int32; k:dword ); @nodisplay;\nvar\n     a:int32;\n     r:real32;\n     c:char;\n     b:boolean;\n     w:word;\nbegin ARDemo;\n     .\n     .\n     .\nend ARDemo;\n```", "```\npush( ebp );         // Save a copy of the old ebp value.\n mov( esp, ebp );     // Get pointer to base of activation record into ebp.\n sub( *`NumVars`*, esp ); // Allocate storage for local variables.\n```", "```\npush( ebp );\n          mov( esp, ebp );\n          sub( 12, esp );          // Make room for ARDemo's local variables.\n          and( $FFFF_FFFC, esp );  // Force dword stack alignment.\n```", "```\nprocedure NASDemo( i:uns32; j:int32; k:dword ); @noalignstack;\nvar\n     LocalVar:int32;\nbegin NASDemo;\n     .\n     .\n     .\nend NASDemo;\n```", "```\npush( ebp );\n          mov( esp, ebp );\n          sub( 4, esp );\n```", "```\nmov( ebp, esp );    // Deallocate locals and clean up stack.\npop( ebp );         // Restore pointer to caller's activation record.\nret();              // Return to the caller.\n```", "```\nmov( ebp, esp );    // Deallocate locals and clean up stack.\npop( ebp );         // Restore pointer to caller's activation record.\nret( *`ParmBytes`* );   // Return to the caller and pop the parameters.\n```", "```\nmov( ebp, esp );\npop( ebp );\nret( 12 );\n```", "```\nmov( ebp, esp );\npop( ebp );\nret( _parms_ );\n```", "```\nprocedure LocalVars; @nodisplay;\nvar\n     a:int32;\n     b:int32;\nbegin LocalVars;\n\n     mov( 0, a );\n     mov( a, eax );\n     mov( eax, b );\n\nend LocalVars;\n```", "```\nmov( 0, (type dword [ebp-4]));\n          mov( [ebp-4], eax );\n          mov( eax, [ebp-8] );\n```", "```\npush( ebp );\n          mov( esp, ebp );\n          sub( 8, esp );\n```", "```\npush( ebp );\n          mov( esp, ebp );\n          sub( _vars_, esp );\n```", "```\nProcA();\n          ProcB();\n          ProcC();\n```", "```\nData Size          Pass in this Register\nByte:                     al\nWord:                     ax\nDouble Word:              eax\nQuad Word:                edx:eax\n```", "```\nFirst                                      Last\n          eax, edx, ecx, esi, edi, ebx\n```", "```\n// strfill-  Overwrites the data in a string with a character.\n//\n//     EDI-  Pointer to zero-terminated string (e.g., an HLA string)\n//      AL-  Character to store into the string\n\nprocedure strfill; @nodisplay;\nbegin strfill;\n\n     push( edi );  // Preserve this because it will be modified.\n     while( (type char [edi] ) <> #0 ) do\n\n          mov( al, [edi] );\n          inc( edi );\n\n     endwhile;\n     pop( edi );\n\nend strfill;\n```", "```\nmov( s, edi );  // Get ptr to string data into edi (assumes s:string).\nmov( ' ', al );\nstrfill();\n```", "```\n*`parmName`*: *`parmType`* in *`reg`*\n```", "```\nprocedure HasRegParms( count: uns32 in ecx; charVal:char in al );\n```", "```\nHasRegParms( ecx, bl );\n```", "```\nprocedure HasRefRegParm( var myPtr:uns32 in edi );\n```", "```\nHasRefRegParm( x );\n```", "```\ncall print;\n          byte \"This parameter is in the code stream.\",0;\n```", "```\nprogram printDemo;\n#include( \"stdlib.hhf\" );\n\n    // print-\n    //\n    //  This procedure writes the literal string\n    //  immediately following the call to the\n    //  standard output device. The literal string\n    //  must be a sequence of characters ending with\n    //  a zero byte (i.e., a C string, not an HLA\n    //  string).\n\n    procedure print; @noframe; @nodisplay;\n    const\n\n        // RtnAdrs is the offset of this procedure's\n        // return address in the activation record.\n\n        RtnAdrs:text := \"(type dword [ebp+4])\";\n\n    begin print;\n\n        // Build the activation record (note the\n        // @noframe option above).\n\n        push( ebp );\n        mov( esp, ebp );\n\n        // Preserve the registers this function uses.\n\n        push( eax );\n        push( ebx );\n\n        // Copy the return address into the ebx\n        // register. Because the return address points\n        // at the start of the string to print, this\n        // instruction loads ebx with the address of\n        // the string to print.\n\n        mov( RtnAdrs, ebx );\n\n        // Until we encounter a zero byte, print the\n        // characters in the string.\n\n        forever\n\n            mov( [ebx], al );   // Get the next character.\n            breakif( !al );     // Quit if it's zero.\n            stdout.putc( al );  // Print it.\n            inc( ebx );         // Move on to the next char.\n\n        endfor;\n\n        // Skip past the zero byte and store the resulting\n        // address over the top of the return address so\n        // we'll return to the location that is one byte\n        // beyond the zero-terminating byte of the string.\n\n        inc( ebx );\n        mov( ebx, RtnAdrs );\n\n        // Restore eax and ebx.\n\n        pop( ebx );\n        pop( eax );\n\n        // Clean up the activation record and return.\n\n        pop( ebp );\n        ret();\n\n    end print;\n\nbegin printDemo;\n\n    // Simple test of the print procedure\n\n    call print;\n    byte \"Hello World!\", 13, 10, 0 ;\n\nend printDemo;\n```", "```\nprocedure strfill( s:string; chr:char );\n```", "```\nCallProc(i,j,k);\n```", "```\npush( i );\n          push( j );\n          push( k );\n          call CallProc;\n```", "```\n// Note: To extract parameters off the stack by popping, it is very important\n// to specify both the @nodisplay and @noframe procedure options.\n\nstatic\n     RtnAdrs: dword;\n     p1Parm: dword;\n     p2Parm: dword;\n     p3Parm: dword;\n\nprocedure CallProc( p1:dword; p2:dword; p3:dword ); @nodisplay; @noframe;\nbegin CallProc;\n\n     pop( RtnAdrs );\n     pop( p3Parm );\n     pop( p2Parm );\n     pop( p1Parm );\n     push( RtnAdrs );\n          .\n          .\n          .\n     ret();\n\nend CallProc;\n```", "```\nprocedure CallProc( p1:dword; p2:dword; p3:dword ); @nodisplay; @noframe;\nbegin CallProc;\n\n     push( ebp );     // This is the standard entry sequence.\n     mov( esp, ebp ); // Get base address of A.R. into ebp.\n          .\n          .\n          .\n```", "```\nmov( [ebp+16], eax );   // Accesses the first parameter.\n          mov( [ebp+12], ebx );   // Accesses the second parameter.\n          mov( [ebp+8], ecx );    // Accesses the third parameter.\n```", "```\nprogram AccessingValueParameters;\n#include( \"stdlib.hhf\" )\n\n    procedure ValueParm( theParameter: uns32 ); @nodisplay;\n    begin ValueParm;\n\n        mov( theParameter, eax );\n        add( 2, eax );\n        stdout.put\n        (\n            \"theParameter + 2 = \",\n            (type uns32 eax),\n            nl\n        );\n\n    end ValueParm;\n\nbegin AccessingValueParameters;\n\n    ValueParm( 10 );\n    ValueParm( 135 );\n\nend AccessingValueParameters;\n```", "```\nprogram ManuallyPassingValueParameters;\n#include( \"stdlib.hhf\" )\n\n    procedure ThreeValueParms( p1:uns32; p2:uns32; p3:uns32 ); @nodisplay;\n    begin ThreeValueParms;\n\n        mov( p1, eax );\n        add( p2, eax );\n        add( p3, eax );\n        stdout.put\n        (\n            \"p1 + p2 + p3 = \",\n            (type uns32 eax),\n            nl\n        );\n\n    end ThreeValueParms;\n\nstatic\n    SecondParmValue:uns32 := 25;\n\nbegin ManuallyPassingValueParameters;\n\n    pushd( 10 );                // Value associated with p1\n    pushd( SecondParmValue);    // Value associated with p2\n    pushd( 15 );                // Value associated with p3\n    call ThreeValueParms;\n\nend ManuallyPassingValueParameters;\n```", "```\nprogram PassingExpressions;\n#include( \"stdlib.hhf\" )\n\n    procedure ExprParm( exprValue:uns32 ); @nodisplay;\n    begin ExprParm;\n\n        stdout.put( \"exprValue = \", exprValue, nl );\n\n    end ExprParm;\n\nstatic\n    Operand1: uns32 := 5;\n    Operand2: uns32 := 20;\n\nbegin PassingExpressions;\n\n    // ExprParm( Operand1 + Operand2 );\n    //\n    //  Method one: Compute the sum and manually\n    //  push the sum onto the stack.\n\n    mov( Operand1, eax );\n    add( Operand2, eax );\n    push( eax );\n    call ExprParm;\n\n    //  Method two: Compute the sum in a register and\n    //  pass the register using the HLA high-level\n    //  language syntax.\n\n    mov( Operand1, eax );\n    add( Operand2, eax );\n    ExprParm( eax );\n\nend PassingExpressions;\n```", "```\nprocedure OneByteParm( b:byte );\n```", "```\nsub( 4, esp );    // Make room for the parameter on the stack.\nmov( ah, [esp] ); // Store ah into the L.O. byte of the parameter.\n```", "```\nOneByteParm( *`uns8Var`* );\n```", "```\npush( eax );\npush( eax );\nmov( *`uns8Var`*, al );\nmov( al, [esp+4] );\npop( eax );\n```", "```\nmov( *`uns8Var`*, al );\npush( eax );\ncall OneByteParm;\n```", "```\nmovzx( *`uns8Var`*, esi );\npush( esi );\ncall OneByteParm;\n```", "```\npush( (type dword *`uns8Var`*));\ncall OneByteParm;\n```", "```\nmov( w, ax );\npush( eax );\ncall OneWordParm;\n\npush( (type dword w) );\ncall OneWordParm;\n```", "```\npush( eax );\n          push( eax );\n          mov( *`uns8Var`*, al );\n          mov( al, [esp+4] );\n          pop( eax );\n```", "```\nmov( *`uns8Var`*, al );\n          push( eax );\n```", "```\n@use *`reg32`*;\n```", "```\nprocedure OneByteParm( b:byte ); @nodisplay; @use EAX;\nbegin OneByteParm;\n\n     << Do something with b. >>\n\nend OneByteParm;\n     .\n     .\n     .\nstatic\n     byteVar:byte;\n          .\n          .\n          .\n     OneByteParm( byteVar );\n```", "```\nmov( *`uns8Var`*, al );\npush( eax );\ncall OneByteParm;\n```", "```\nprogram AccessingReferenceParameters;\n#include( \"stdlib.hhf\" )\n\n    procedure RefParm( var theParameter: uns32 ); @nodisplay;\n    begin RefParm;\n\n        // Add 2 directly to the parameter passed by\n        // reference to this procedure.\n\n        mov( theParameter, eax );\n        add( 2, (type uns32 [eax]) );\n\n        // Fetch the value of the reference parameter\n        // and print its value.\n\n        mov( [eax], eax );\n        stdout.put\n        (\n            \"theParameter now equals \",\n            (type uns32 eax),\n            nl\n        );\n\n    end RefParm;\n\nstatic\n    p1: uns32 := 10;\n    p2: uns32 := 15;\n\nbegin AccessingReferenceParameters;\n\n    RefParm( p1 );\n    RefParm( p2 );\n\n    stdout.put( \"On return, p1=\", p1, \" and p2=\", p2, nl );\n\nend AccessingReferenceParameters;\n```", "```\nprogram accessingRefArrayParameters;\n#include( \"stdlib.hhf\" )\n\nconst\n    NumElements := 64;\n\ntype\n    Pt: record\n\n            x:uns8;\n            y:uns8;\n\n        endrecord;\n\n    Pts: Pt[NumElements];\n\n    procedure RefArrayParm( var ptArray: Pts ); @nodisplay;\n    begin RefArrayParm;\n\n        push( eax );\n        push( ecx );\n        push( edx );\n\n        mov( ptArray, edx );    // Get address of parameter into edx.\n\n        for( mov( 0, ecx ); ecx < NumElements; inc( ecx )) do\n\n            // For each element of the array, set the x field\n            // to (ecx div 8) and set the y field to (ecx mod 8).\n\n            mov( cl, al );\n            shr( 3, al );     // ecx div 8.\n            mov( al, (type Pt [edx+ecx*2]).x );\n\n            mov( cl, al );\n            and( %111, al );  // ecx mod 8.\n            mov( al, (type Pt [edx+ecx*2]).y );\n\n        endfor;\n        pop( edx );\n        pop( ecx );\n        pop( eax );\n\n    end RefArrayParm;\n\nstatic\n    MyPts: Pts;\n\nbegin accessingRefArrayParameters;\n\n    // Initialize the elements of the array.\n\n    RefArrayParm( MyPts );\n\n    // Display the elements of the array.\n\n    for( mov( 0, ebx ); ebx < NumElements; inc( ebx )) do\n\n        stdout.put\n        (\n            \"RefArrayParm[\",\n            (type uns32 ebx):2,\n            \"].x=\",\n            MyPts.x[ ebx*2 ],\n\n            \"   RefArrayParm[\",\n            (type uns32 ebx):2,\n            \"].y=\",\n            MyPts.y[ ebx*2 ],\n            nl\n        );\n\n    endfor;\n\nend accessingRefArrayParameters;\n```", "```\nprocedure HasRefParm( var d:dword );\n          .\n          .\n          .\n     static\n          FourBytes:dword;\n\n     var\n          v: dword[2];\n          .\n          .\n          .\n     HasRefParm( FourBytes );\n          .\n          .\n          .\n```", "```\npushd( &FourBytes );\ncall HasRefParm;\n```", "```\n// Call to the HasRefParm procedure:\n\n          HasRefParm( v[ebx*4] );\n\n// HLA actually emits the following code for the above call:\n\n          push( eax );\n          push( eax );\n          lea( eax, v[ebx*4] );\n          mov( eax, [esp+4] );\n          pop( eax );\n          call HasRefParm;\n```", "```\nlea( eax, v[ebx*4] );\n          push( eax );\n          call HasRefParm;\n```", "```\nstatic\n     i:    int32;\n     Ary:  int32[16];\n     iptr: pointer to int32 := &i;\n\nvar\n     v:    int32;\n     AV:   int32[10];\n     vptr: pointer to int32;\n      .\n      .\n      .\n     lea( eax, v );\n     mov( eax, vptr );\n      .\n      .\n      .\n// HasRefParm( i );\n\n     push( &i );               // Simple static object, so just use &.\n     call HasRefParm;\n\n// HasRefParm( Ary[ebx] );     // Pass element of Ary by reference.\n\n     lea( eax, Ary[ ebx*4 ]);  // Must use lea for indexed addresses.\n     push( eax );\n     call HasRefParm;\n\n// HasRefParm( *iptr );  -- Pass object pointed at by iptr\n\n     push( iptr );             // Pass address (iptr's value) on stack.\n     call HasRefParm;\n\n// HasRefParm( v );\n\n     lea( eax, v );            // Must use lea to compute the address\n     push( eax );              // of automatic vars passed on stack.\n     call HasRefParm;\n\n// HasRefParm( AV[ esi ] );  -- Pass element of AV by reference.\n\n     lea( eax, AV[ esi*4] );   // Must use lea to compute address of the\n     push( eax );              // desired element.\n     call HasRefParm;\n\n// HasRefParm( *vptr );  -- Pass address held by vptr...\n\n     push( vptr );             // Just pass vptr's value as the specified\n     call HasRefParm;          // address.\n```", "```\n@use *`reg32`*;\n```", "```\nprocedure p1( val v:dword;  var r:dword );\n     begin p1;\n           .\n           .\n           .\n     end p1;\n\n     procedure p2( val v2:dword; var r2:dword );\n     begin p2;\n\n          p1( v2, r2 );    // (1) First call to p1\n          p1( r2, v2 );    // (2) Second call to p1\n\n     end p2;\n```", "```\npush( v2 );\n     << Code to handle r2 >>\n     call p1;\n```", "```\npush( v2 );   // Pass the value passed in through v2 to p1.\n     push( r2 );   // Pass the address passed in through r2 to p1.\n     call p1;\n```", "```\nsub( 4, esp );      // Make room on stack for parameter.\n     push( eax );        // Preserve eax's value.\n     mov( r2, eax );     // Get address-of object passed in to p2.\n     mov( [eax], eax );  // Dereference to get the value of this object.\n     mov( eax, [esp+4]); // Put value-of parameter into its location on stack.\n     pop( eax );         // Restore original eax value.\n```", "```\nmov( r2, eax );     // Get the pointer to the actual object.\n     pushd( [eax] );     // Push the value of the object onto the stack.\n```", "```\npush( eax );        // Make room for the parameter.\n     push( eax );        // Preserve eax's value.\n     lea( eax, v2 );     // Compute address of v2's value.\n     mov( eax, [esp+4]); // Store away address as parameter value.\n     pop( eax );         // Restore eax's value.\n```", "```\nmov( r2, eax );     // Get the pointer to the actual object.\n     pushd( [eax] );     // Push the value of the object onto the stack.\n     lea( eax, v2 );     // Push the address of v2 onto the stack.\n     push( eax );\n     call p1;\n```", "```\nprocedure HybridCall( i:uns32; j:uns32 );\nbegin HybridCall;\n     .\n     .\n     .\nend HybridCall;\n      .\n      .\n      .\n\n     // Equivalent to HybridCall( 5, i+j );\n\n     HybridCall\n     (\n          5,\n          #{\n               mov( i, eax );\n               add( j, eax );\n               push( eax );\n          }#\n     );\n```", "```\npushd( 5 );\n     mov( i, eax );\n     add( j, eax );\n     push( eax );\n     call HybridCall;\n```", "```\nprocedure p2( val v2:dword; var r2:dword );\n     begin p2;\n\n          p1( v2, r2 );    // (1) First call to p1\n          p1( r2, v2 );    // (2) Second call to p1\n\n     end p2;\n```", "```\nprocedure p2( val v2:dword; var r2:dword );\n     begin p2;\n\n          p1( v2, r2 );    // (1) First call to p1\n          p1               // (2) Second call to p1\n          (                //     This code assumes eax is free.\n               #{\n                    mov( r2, eax );\n                    pushd( [eax] );\n               }#,\n\n               #{\n                    lea( eax, v2 );\n                    push( eax );\n               }#\n          );\n\n     end p2;\n```", "```\nprocedure HasBothRegAndStack( var dest:dword in edi; count:un32 );\n```", "```\ncall Procname;     // Direct call to procedure Procname (or Stmt label).\ncall( Reg32 );     // Indirect call to procedure whose address appears\n                   // in the Reg32 general-purpose 32-bit register.\ncall( dwordVar );  // Indirect call to the procedure whose address\n                   // appears in the dwordVar double word variable.\n```", "```\ncall Procname;\n      .\n      .\n      .\n     mov( &Procname, eax );\n     call( eax );\n      .\n      .\n      .\n     lea( eax, Procname );\n     call( eax );\n```", "```\nprocedure p;\n     begin p;\n     end p;\n      .\n      .\n      .\nstatic\n     ptrToP: dword := &p;\n      .\n      .\n      .\n     call( ptrToP );  // Calls the p procedure if ptrToP has not changed.\n```", "```\nstatic\n     *`procPtr`*: procedure;\n```", "```\ncall( *`procPtr`* );    // Low-level syntax\n     *`procPtr`*();          // High-level language syntax\n```", "```\nstatic\n     ProcPointer: procedure := &p;    // Initialize ProcPointer with\n                                      // the address of p.\n      .\n      .\n      .\n     ProcPointer();            // First invocation calls p.\n\n     mov( &q, ProcPointer );   // Reload ProcPointer with the address of q.\n      .\n      .\n      .\n     ProcPointer();            // This invocation calls the q procedure.\n```", "```\nstatic\n     p:procedure( i:int32; c:char );\n```", "```\nstatic\n     p:procedure( i:int32; c:char ) := &*`SomeProcedure`*;\n```", "```\npush( *`Value_for_i`* );\n     push( *`Value_for_c`* );\n     call( p );\n```", "```\np( *`Value_for_i`*, *`Value_for_c`* );\n```", "```\ntype\n     pptr:     procedure;\n     prec:     record\n                    p:pptr;\n                    << Other fields >>\n               endrecord;\nstatic\n     p1:pptr;\n     p2:pptr[2]\n     p3:prec;\n      .\n      .\n      .\n     p1();\n     p2[ebx*4]();\n     p3.p();\n```", "```\nprocedure p1( procparm: procedure ); forward;\n     procedure p2( procparm: procedure( i:int32 ) ); forward;\n     procedure p3( val procparm: procedure ); forward;\n```", "```\nprocedure p4( var procPtr:procedure ); forward;\n```", "```\nPlot( &sineFunc );\n     Plot( &cosFunc  );\n     Plot( &tanFunc  );\n```", "```\nprocedure ZeroMem( var mem:byte; count:uns32 );\n```", "```\nZeroMem( (type byte MyDataObject), @size( MyDataObject ));\n```", "```\nZeroMem( MyDataObject, @size( MyDataObject ));\n```", "```\nprocedure ZeroMem( var mem:var; count:uns32 );\n```", "```\n#include( \"*`Filename`*\" )\n```", "```\n#include( \"hla.hhf\" )\n#include( \"x86.hhf\" )\n#include( \"misctypes.hhf\" )\n#include( \"hll.hhf\" )\n\n#include( \"excepts.hhf\" )\n#include( \"memory.hhf\" )\n\n#include( \"args.hhf\" )\n#include( \"conv.hhf\" )\n#include( \"strings.hhf\" )\n#include( \"cset.hhf\" )\n#include( \"patterns.hhf\" )\n#include( \"tables.hhf\" )\n#include( \"arrays.hhf\" )\n#include( \"chars.hhf\" )\n\n#include( \"math.hhf\" )\n#include( \"rand.hhf\" )\n\n#include( \"stdio.hhf\" )\n#include( \"stdin.hhf\" )\n#include( \"stdout.hhf\" )\n```", "```\n#include( \"printf.hla\" )\n     #include( \"putc.hla\" )\n```", "```\n#includeonce( \"myHeaderFile.hhf\" )\n```", "```\nunit *`unitname`*;\n\n     << declarations >>\n\nend *`unitname`*;\n```", "```\nunit Number1;\n\nstatic\n    Var1:   uns32;\n    Var2:   uns32;\n\n    procedure Add1and2;\n    begin Add1and2;\n\n        push( eax );\n        mov( Var2, eax );\n        add( eax, Var1 );\n\n    end Add1and2;\n\nend Number1;\n```", "```\nprogram main;\n#include( \"stdlib.hhf\" );\n\nbegin main;\n\n    mov( 2, Var2 );\n    mov( 3, Var1 );\n    Add1and2();\n    stdout.put( \"Var1=\", Var1, nl );\n\nend main;\n```", "```\nprogram main;\n#include( \"stdlib.hhf\" );\n\n    procedure Add1and2; external;\n\nstatic\n    Var1: uns32; external;\n    Var2: uns32; external;\n\nbegin main;\n\n    mov( 2, Var2 );\n    mov( 3, Var1 );\n    Add1and2();\n    stdout.put( \"Var1=\", Var1, nl );\n\nend main;\n```", "```\nunit Number1;\n\nstatic\n    Var1:   uns32; external;\n    Var2:   uns32; external;\n\n    procedure Add1and2; external;\n\nstatic\n    Var1:   uns32;\n    Var2:   uns32;\n\n    procedure Add1and2;\n    begin Add1and2;\n\n        push( eax );\n        mov( Var2, eax );\n        add( eax, Var1 );\n\n    end Add1and2;\n\nend Number1;\n```", "```\nHLA main2.hla\nHLA unit2.hla\n```", "```\nHLA main2.hla unit2.hla\n```", "```\nHLA -c main2.hla\nHLA -c unit2.hla\n```", "```\nHLA main2.obj unit2.obj\n```", "```\nHLA main2.hla unit2.obj\n```", "```\nstatic\n          extObj:          uns32; external;\n          extObj:          uns32;\n          localObject:     uns32;\n```", "```\nstatic\n     c: char; external( \"var_c\" );\n     c: char;\n```", "```\nstatic\n     StudentCount: uns32; external( \"PersonCount\" );\n```", "```\n// myHeader.hhf -\n//\n// Routines supported in the myLibrary.lib file\n\nnamespace myLib;\n\n     procedure func1; external;\n     procedure func2; external;\n     procedure func3; external;\n\nend myLib;\n```", "```\nunit func1Unit;\n#includeonce( \"myHeader.hhf\" )\n\nprocedure myLib.func1;\nbegin func1;\n\n     << Code for func1 >>\n\nend func1;\n\nend func1Unit;\n```", "```\n// myHeader.hhf -\n//\n// Routines supported in the myLibrary.lib file\n\nnamespace myLib;\n\n     procedure func1; external( \"myLib_func1\" );\n     procedure func2; external( \"myLib_func2\" );\n     procedure func3; external( \"myLib_func3\" );\n\nend myLib;\n```"]