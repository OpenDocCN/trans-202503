- en: '**Introduction**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Howdy y’all,
  prefs: []
  type: TYPE_NORMAL
- en: Microcontrollers are single-chip computers. There’s one in your credit card
    and dozens in your laptop and car. Medical devices, video games, electric power
    meters, and two-way radios use them. Inside each there is some non-volatile memory
    for a computer program, the barest minimum of a CPU to run that program, and enough
    RAM to store global variables, and maybe also a heap and a call stack.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve long been fascinated with the readout protection features of microcontrollers,
    which protect a chip’s firmware from being extracted and reverse engineered. In
    that time, many clever neighbors have come up with many clever ways to extract
    this firmware, but when I wanted to share them, I’d often find myself sketching
    the broad details on a beer-stained napkin, for lack of any centralized collection.
  prefs: []
  type: TYPE_NORMAL
- en: So I began this book as a way to document as many of those tricks as I might
    find, organized by technique and by explicit model numbers, with citations back
    to the original publications. These are real exploits, extracting code from real
    chips.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how the nRF51’s protection mode allows debugging that can disable
    its protection over JTAG, and how the protection of the nRF52 series is a little
    better but vulnerable to voltage glitching attacks. You’ll explore how the STM32F0
    allows for one word to be dumped after every reset, how the STM32F1’s exception
    handling can slowly leak the firmware out over an hour, and how the USB bootloaders
    of the STM32F2 and STM32F4 are vulnerable to arbitrary code execution. You’ll
    also learn how the Texas Instruments MSP430 firmware can be extracted by a camera
    flash, and how grounding one pin on the Freescale MC13224 will disable all protections
    to allow an external debugger.
  prefs: []
  type: TYPE_NORMAL
- en: For each of these exploits, you’ll learn how to reproduce the results, dumping
    a chip in your own lab. Side commentary will refer you to related chips, and how
    one attack might’ve predicted another, which will be handy when you try to dump
    the firmware from something new. And wherever possible, you will be referred to
    both source code and the first publication of the technique.
  prefs: []
  type: TYPE_NORMAL
- en: Numbered chapters provide in-depth explanations of either techniques or how
    to hack a specific chip. These are roughly grouped together with chapters that
    introduce a type of technique. Lettered chapters attempt to quickly group targets,
    describing prior research succinctly. Memory maps are provided to help you think
    of memory addresses as specific places, and wherever possible I’ve included X-ray
    and die photographs from my own lab.
  prefs: []
  type: TYPE_NORMAL
- en: To use this book, I’d suggest first reading through quickly to get an overview
    of how to extract chip firmware, then using the index in the back to find techniques
    for specific part numbers when you need them. You won’t get anywhere without practice,
    so be sure to implement some of these attacks yourself even if your intent is
    to defend against them.
  prefs: []
  type: TYPE_NORMAL
- en: Your school librarian would be right to remind you to chase down some of the
    citations from the bibliography, and that same librarian would be wrong to tell
    you not to write in the margins. I made them wide to hold notes where you find
    them handy.
  prefs: []
  type: TYPE_NORMAL
- en: 73 from EM85AX,
  prefs: []
  type: TYPE_NORMAL
- en: Travis Goodspeed
  prefs: []
  type: TYPE_NORMAL
