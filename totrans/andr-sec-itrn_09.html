<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Enterprise Security"><div class="titlepage"><div><div><h1 class="title"><a id="enterprise_security"/>Chapter 9. Enterprise Security</h1></div></div></div><p><a id="iddle1738" class="indexterm"/>Initial Android versions were mostly consumer-oriented, with limited enterprise features. However, as the platform has grown in popularity, Android devices have entered the workplace and are increasingly used to access corporate email, customer information, and other company data. As a result of this trend, the need for increased platform security and tools that allow effective management of employee devices has steadily grown. While Android’s primary focus remains general-purpose consumer devices, recent versions have introduced numerous enterprise features and Android will likely become even more enterprise-friendly as it develops.</p><p>In this chapter, we discuss Android’s major enterprise-oriented features and demonstrate how they can be used to both increase device security and provide centralized device policy management. We’ll begin with device administration, and show how it can be integrated into third-party applications. We then look into Android’s VPN support and describe the APIs that allow new VPN solutions to be developed as third-party, user-installed applications. Next we show how Android implements different authentication <a id="iddle1545" class="indexterm"/><a id="iddle1546" class="indexterm"/><a id="iddle1557" class="indexterm"/><a id="iddle1739" class="indexterm"/><a id="iddle1825" class="indexterm"/><a id="iddle2139" class="indexterm"/><a id="iddle2602" class="indexterm"/><a id="iddle2776" class="indexterm"/><a id="iddle3039" class="indexterm"/><a id="iddle3041" class="indexterm"/><a id="iddle3043" class="indexterm"/><a id="iddle3046" class="indexterm"/><a id="iddle3048" class="indexterm"/><a id="iddle3051" class="indexterm"/><a id="iddle3101" class="indexterm"/><a id="iddle3125" class="indexterm"/>methods supported by the EAP authentication framework and describe how it manages credentials. Finally, we demonstrate how to add an EAP profile programmatically using the extended Wi-Fi management APIs added in Android 4.3.</p><div class="sect1" title="Device Administration"><div class="titlepage"><div><div><h1 class="title"><a id="device_administration"/>Device Administration</h1></div></div></div><p>Android 2.2 introduced support for a Device Administration API, which makes it possible to develop applications that can both enforce a systemwide security policy and dynamically adapt their features based on the device’s current security level. Such applications are called <span class="emphasis"><em>device administrators</em></span>. Device administrators must be explicitly enabled in the device’s security settings and cannot be uninstalled if they are active. When enabled, they’re granted special privileges that allow them to lock the device, change the lockscreen password, and even wipe the device (delete all user data). Device administrators are often coupled with a specific type of enterprise account (such as a Microsoft Exchange or Google Apps account), which allows enterprise administrators to control access to corporate data by allowing access only to devices that conform to the required security policy. Security policies can be static and built into the device administrator application, or they can be configured on the server side and sent to the device as part of a provisioning or synchronization protocol.</p><p>As of version 4.4, Android supports the policy types listed in <a class="xref" href="ch09.html#supported_device_administration_policies" title="Table 9-1. Supported Device Administration Policies">Table 9-1</a>. The policy constants are defined in the <code class="literal">DeviceAdminInfo</code> class.<sup>[<a id="ch09fn01" href="#ftn.ch09fn01" class="footnote">87</a>]</sup></p><div class="table"><a id="supported_device_administration_policies"/><p class="title">Table 9-1. Supported Device Administration Policies</p><div class="table-contents"><table summary="Supported Device Administration Policies" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Policy Constant/XML Tag</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Value (bit to set)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>API Level</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">USES_POLICY_LIMIT_PASSWORD &lt;limit-password&gt;</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Limit the passwords that the user can select by setting a minimum length or complexity.</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">USES_POLICY_WATCH_LOGIN &lt;watch-login&gt;</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Watch login attempts by a user.</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">USES_POLICY_RESET_PASSWORD &lt;reset-password&gt;</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Reset a user’s password.</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">USES_POLICY_FORCE_LOCK &lt;force-lock&gt;</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Force the device to lock, or limit the maximum lock timeout.</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">USES_POLICY_WIPE_DATA &lt;wipe-data&gt;</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Factory reset the device, erasing all user data.</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">USES_POLICY_SETS_GLOBAL_PROXY &lt;set-global-proxy&gt;</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Specify the device global proxy. (This is hidden from SDK applications.)</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>9</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">USES_POLICY_EXPIRE_PASSWORD &lt;expire-password&gt;</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Force the user to change their password after an administrator-defined time limit.</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>11</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">USES_ENCRYPTED_STORAGE &lt;encrypted-storage&gt;</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Require stored data to be encrypted.</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>11</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">USES_POLICY_DISABLE_CAMERA &lt;disable-camera&gt;</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Disable the use of all device cameras.</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>14</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">USES_POLICY_DISABLE_KEYGUARD_FEATURES &lt;disable-keyguard-features&gt;</code></p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>9</p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>Disable the use of keyguard features such as lockscreen widgets or camera support.</p></td><td style="" valign="top"><p>17</p></td></tr></tbody></table></div></div><p><a id="iddle1567" class="indexterm"/><a id="iddle1571" class="indexterm"/><a id="iddle1617" class="indexterm"/><a id="iddle1618" class="indexterm"/><a id="iddle1721" class="indexterm"/><a id="iddle1766" class="indexterm"/><a id="iddle3030" class="indexterm"/><a id="iddle3033" class="indexterm"/><a id="iddle3035" class="indexterm"/><a id="iddle3037" class="indexterm"/>Each device administration application must list the policies it intends to use in a metadata file (see “<a class="xref" href="ch09.html#privilege_management" title="Privilege Management">Privilege Management</a>” for details). The list of supported policies is displayed to the user when they activate the administrator app, as shown in <a class="xref" href="ch09.html#device_administrator_activation_screen" title="Figure 9-1. Device administrator activation screen">Figure 9-1</a>.</p><div class="sect2" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="implementation-id00017"/>Implementation</h2></div></div></div><p>Now that we know which policies can be enforced with the Device Administration API, let’s look at the internal implementation. Like most public Android APIs, a manager class called <code class="literal">DevicePolicyManager</code><sup>[<a id="ch09fn02" href="#ftn.ch09fn02" class="footnote">88</a>]</sup> exposes part of the functionality of the underlying system service, <code class="literal">DevicePolicyManagerService</code>. However, because the <code class="literal">DevicePolicyManager</code> facade class defines constants and translates service exceptions to return codes but otherwise adds little functionality, we’ll focus on the <code class="literal">DevicePolicyManagerService</code> class.</p><div class="figure"><a id="device_administrator_activation_screen"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00038"/><img src="figs/web/09fig01.png.jpg" alt="Device administrator activation screen"/></div></div><p class="title">Figure 9-1. Device administrator activation screen</p></div><p>Like most system services, <code class="literal">DevicePolicyManagerService</code> is started by and runs within the <span class="emphasis"><em>system_server</em></span> process as the <span class="emphasis"><em>system</em></span> user, and thus can execute almost all Android privileged actions. Unlike most system services, <a id="iddle1556" class="indexterm"/><a id="iddle1744" class="indexterm"/><a id="iddle3032" class="indexterm"/><a id="iddle3044" class="indexterm"/>it can grant access to certain privileged actions (such as changing the lockscreen password) to third-party applications, which do not need to hold any special system permissions. This makes it possible for users to enable and disable device administrators on demand, and guarantees that device administrators can only enforce policies that they have explicitly declared. However, this level of flexibility cannot be easily implemented with standard Android permissions that are only granted at install time and cannot be revoked (with some exceptions, as discussed in <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>). Therefore, <code class="literal">DevicePolicyManagerService</code> employs a different method for privilege management.</p><p>Another interesting aspect of Android’s device administration implementation relates to how policies are managed and enforced. We describe device administrator privilege management and policy enforcement in detail next.</p><div class="sect3" title="Privilege Management"><div class="titlepage"><div><div><h3 class="title"><a id="privilege_management"/>Privilege Management</h3></div></div></div><p>At runtime, the <code class="literal">DevicePolicyManagerService</code> keeps an internal, on-memory list of policy structures for each device user. (Policies are also persisted on disk in an XML file, as described in the next section.)</p><p>Each policy structure contains the currently effective policy for a certain user and a list of metadata about each active device administrator. Because each user can enable more than one application with device administrator functionality, the currently active policy is calculated by selecting the strictest defined policy among all administrators. The metadata about each active device administrator contains information about the declaring application, and a list of declared policies (represented by a bitmask).</p><p>The <code class="literal">DevicePolicyManagerService</code> decides whether to grant access to privileged operations to a calling application based on its internal list of active policies: if the calling application is currently an active device administrator, and it has requested the policy that corresponds to the current request (API call), only then is the request granted and the operation executed. In order to confirm that an active administrator component really belongs to the calling application, <code class="literal">DevicePolicyManagerService</code> compares the UID of the calling process (returned by <code class="literal">Binder.getCallingUid()</code>) with the UID associated with the target administrator component. For example, an application that calls the <code class="literal">resetPassword()</code> needs to be an active device administrator, have the same UID as the registered administrator component, and have requested the <code class="literal">USES_POLICY_RESET_PASSWORD</code> policy in order for the call to succeed.</p><p>Policies are requested by adding an XML resource file that lists all policies that a device administrator application wants to use as children of the <code class="literal">&lt;uses-policies&gt;</code> tag. Before a device administrator is activated, the system parses the XML file and displays a dialog similar to the one in <a class="xref" href="ch09.html#device_administrator_activation_screen" title="Figure 9-1. Device administrator activation screen">Figure 9-1</a>, allowing the user to review the requested policies before enabling the administrator. Much like Android permissions, administrator policies are granted on an all-or-nothing basis, and there is no way to selectively enable <a id="iddle1058" class="indexterm"/><a id="iddle2184" class="indexterm"/><a id="iddle2769" class="indexterm"/>only certain policies. A resource file that requests all policies might look like <a class="xref" href="ch09.html#declaring_policies_in_a_device_administr" title="Example 9-1. Declaring policies in a device administrator application">Example 9-1</a> (for the policy corresponding to each tag, see the first column of <a class="xref" href="ch09.html#supported_device_administration_policies" title="Table 9-1. Supported Device Administration Policies">Table 9-1</a>). You can find more details about adding this file to a device administrator application in “<a class="xref" href="ch09.html#adding_a_device_administrator" title="Adding a Device Administrator">Adding a Device Administrator</a>”.</p><div class="example"><a id="declaring_policies_in_a_device_administr"/><p class="title">Example 9-1. Declaring policies in a device administrator application</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;device-admin &gt;
    &lt;uses-policies&gt;
        &lt;limit-password /&gt;
        &lt;watch-login /&gt;
        &lt;reset-password /&gt;
        &lt;force-lock /&gt;
        &lt;wipe-data /&gt;
        &lt;expire-password /&gt;
        &lt;encrypted-storage /&gt;
        &lt;disable-camera /&gt;
        &lt;disable-keyguard-features /&gt;
        &lt;set-global-proxy /&gt;
    &lt;/uses-policies&gt;
&lt;/device-admin&gt;</pre></div></div><p>In order to be notified about policy-related system events and to be allowed access to the Device Administration API, device administrators must be activated first. This is achieved by calling the <code class="literal">setActiveAdmin()</code> method of the <code class="literal">DevicePolicyManagerService</code>. Because this method requires the <code class="literal">MANAGE_DEVICE_ADMINS</code> permission, which is a system signature permission, only system applications can add a device administrator without user interaction.</p><p>User-installed device administrator applications can only request to be activated by starting the <code class="literal">ACTION_ADD_DEVICE_ADMIN</code> implicit intent with code similar to <a class="xref" href="ch09.html#requesting_device_administrator_activati" title="Example 9-2. Requesting device administrator activation">Example 9-2</a>. The only handler for this intent is the system Settings application, which holds the <code class="literal">MANAGE_DEVICE_ADMINS</code> permission. Upon receiving the intent, the Settings applications checks whether the requesting application is a valid device administrator, extracts the requested policies, and builds the confirmation dialog shown in <a class="xref" href="ch09.html#device_administrator_activation_screen" title="Figure 9-1. Device administrator activation screen">Figure 9-1</a>. The user pressing the Activate button calls the <code class="literal">setActiveAdmin()</code> method, which adds the application to the list of active administrators for the current device user.</p><div class="example"><a id="requesting_device_administrator_activati"/><p class="title">Example 9-2. Requesting device administrator activation</p><div class="example-contents"><pre class="programlisting">Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
ComponentName admin = new ComponentName(this, MyDeviceAdminReceiver.class);
intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, admin);
intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,
                "Required for corporate email access.");
startActivityForResult(intent, REQUEST_CODE_ENABLE_ADMIN);</pre></div></div></div><div class="sect3" title="Policy Persistence"><div class="titlepage"><div><div><h3 class="title"><a id="policy_persistence"/>Policy Persistence</h3></div></div></div><p><a id="iddle1555" class="indexterm"/><a id="iddle1565" class="indexterm"/><a id="iddle1568" class="indexterm"/><a id="iddle1743" class="indexterm"/><a id="iddle1822" class="indexterm"/><a id="iddle2422" class="indexterm"/><a id="iddle2506" class="indexterm"/>When a device administrator is activated, deactivated, or its policies are updated, changes are written to the <span class="emphasis"><em>device_policies.xml</em></span> file for the target user. For the owner user, that file is stored under <span class="emphasis"><em>/data/system/</em></span>, and for all other users it’s written to the user’s system directory (<span class="emphasis"><em>/data/users/&lt;user-ID&gt;/</em></span>). The file is owned by and only modifiable by the <span class="emphasis"><em>system</em></span> user (file permissions 0600).</p><p>The <span class="emphasis"><em>device_policies.xml</em></span> file contains information about each active administrator and its policies, as well some global information about the current lockscreen password. The file might look like <a class="xref" href="ch09.html#contents_of_the_devicesunderscorepolicie" title="Example 9-3. Contents of the devices_policies.xml file">Example 9-3</a>.</p><div class="example"><a id="contents_of_the_devicesunderscorepolicie"/><p class="title">Example 9-3. Contents of the <span class="roman">devices_policies.xml</span> file</p><div class="example-contents"><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;
&lt;policies&gt;
  &lt;admin name="com.google.android.gms/com.google.android.gms.mdm.receivers.MdmDeviceAdminReceiver"&gt;➊
    &lt;policies flags="28" /&gt;
  &lt;/admin&gt;
  &lt;admin name="com.example.android.apis/com.example.android.apis.app.DeviceAdminSampleReceiver"&gt;➋
    &lt;policies flags="1023" /&gt;➌
    &lt;password-quality value="327680" /&gt;➍
    &lt;min-password-length value="6" /&gt;
    &lt;min-password-letters value="2" /&gt;
    &lt;min-password-numeric value="2" /&gt;
    &lt;max-time-to-unlock value="300000" /&gt;
    &lt;max-failed-password-wipe value="100" /&gt;
    &lt;encryption-requested value="true" /&gt;
    &lt;disable-camera value="true" /&gt;
    &lt;disable-keyguard-features value="1" /&gt;
&lt;/admin&gt;
&lt;admin name="com.android.email/com.android.email.SecurityPolicy$PolicyAdmin"&gt;➎
  &lt;policies flags="475" /&gt;
&lt;/admin&gt;
&lt;password-owner value="10076" /&gt;➏
&lt;active-password quality="327680" length="6"
                 uppercase="0" lowercase="3"
                 letters="3" numeric="3" symbols="0" nonletter="3" /&gt;➐
&lt;/policies&gt;</pre></div></div><p>This example has three active device administrators, each represented by an <code class="literal">&lt;admin&gt;</code> element (➊, ➋, and ➎). The policies of each administrator app are stored in the <code class="literal">flags</code> attribute of the <code class="literal">&lt;policies&gt;</code> tag ➌.</p><p>A policy is considered enabled if its corresponding bit is set (see the Value column of <a class="xref" href="ch09.html#supported_device_administration_policies" title="Table 9-1. Supported Device Administration Policies">Table 9-1</a>). For example, because the <span class="emphasis"><em>DeviceAdminSample</em></span> application has requested all currently available policies, its <code class="literal">flags</code> attribute has the value 1023 (0x3FF, or 1111111111 in binary).</p><p>If the administrator defines password quality restrictions (for example, alphanumeric or complex), they are persisted as the <code class="literal">value</code> attribute of the <code class="literal">&lt;password-quality&gt;</code> tag ➍. In this example, the value 327680 (0x50000) corresponds to <code class="literal">PASSWORD_QUALITY_ALPHANUMERIC</code>. (Password quality constants are defined in the <code class="literal">DevicePolicyManager</code> class.)</p><p><a id="iddle1063" class="indexterm"/><a id="iddle1064" class="indexterm"/><a id="iddle1065" class="indexterm"/><a id="iddle1069" class="indexterm"/><a id="iddle1554" class="indexterm"/><a id="iddle1566" class="indexterm"/><a id="iddle1742" class="indexterm"/><a id="iddle2160" class="indexterm"/><a id="iddle2421" class="indexterm"/><a id="iddle2423" class="indexterm"/><a id="iddle2600" class="indexterm"/><a id="iddle3042" class="indexterm"/><a id="iddle3049" class="indexterm"/>The values of other policy requirements, such as password length and device encryption, are also stored as children of each <code class="literal">&lt;admin&gt;</code> element. If the password has been set programmatically by using the <code class="literal">resetPassword()</code> method, <span class="emphasis"><em>device_policies.xml</em></span> contains a <code class="literal">&lt;password-owner&gt;</code> tag that stores the UID of the application that sets the password in its <code class="literal">value</code> attribute ➏. Finally, the <code class="literal">&lt;active-password&gt;</code> tag contains details about the complexity of the current password ➐.</p></div><div class="sect3" title="Policy Enforcement"><div class="titlepage"><div><div><h3 class="title"><a id="policy_enforcement"/>Policy Enforcement</h3></div></div></div><p>Device administrator policies have different granularity and can be enforced either for the current user or for all users on a device. Some policies are not enforced by the system at all—the system only notifies the declaring administration application, which is then responsible for taking an appropriate action. In this section, we describe how each type of policy is implemented and enforced.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong><code class="literal">USES_POLICY_LIMIT_PASSWORD</code></strong></span></span></dt><dd><p>After one or more password restrictions have been set, users cannot enter a password that does not fulfill the current policy. However, the system does not require passwords to be changed immediately, so the current password remains in effect until changed. Administrator applications can prompt the user for a new password by starting an implicit intent with the <code class="literal">DevicePolicyManager.ACTION_SET_NEW_PASSWORD</code> action.</p><p>Because each device user has a separate unlock password, password quality policies are applied per-user. When password quality is set, unlock methods that do not allow for a password of the desired quality are disabled. For example, setting password quality to <code class="literal">PASSWORD_ QUALITY_ALPHANUMERIC</code> disables the Pattern and PIN unlock methods, as shown in <a class="xref" href="ch09.html#setting_a_password_quality_policy_disabl" title="Figure 9-2. Setting a password quality policy disables incompatible unlock methods">Figure 9-2</a>.</p><div class="figure"><a id="setting_a_password_quality_policy_disabl"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00039"/><img src="figs/web/09fig02.png.jpg" alt="Setting a password quality policy disables incompatible unlock methods"/></div></div><p class="title">Figure 9-2. Setting a password quality policy disables incompatible unlock methods</p></div></dd><dt><span class="term"><span class="strong"><strong><code class="literal">USES_POLICY_WATCH_LOGIN</code></strong></span></span></dt><dd><p>This policy enables device administrators to receive notifications about the outcome of login attempts. Notifications are sent with the <code class="literal">ACTION_PASSWORD_FAILED</code> and <code class="literal">ACTION_PASSWORD_SUCCEEDED</code> broadcasts. Broadcast receivers that derive from <code class="literal">DeviceAdminReceiver</code> are automatically notified via the <code class="literal">onPasswordFailed()</code> and <code class="literal">onPasswordSucceeded()</code> methods.</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">USES_POLICY_RESET_PASSWORD</code></strong></span></span></dt><dd><p><a id="iddle1892" class="indexterm"/><a id="iddle2150" class="indexterm"/><a id="iddle2153" class="indexterm"/><a id="iddle2601" class="indexterm"/><a id="iddle2780" class="indexterm"/><a id="iddle2781" class="indexterm"/><a id="iddle3040" class="indexterm"/><a id="iddle3045" class="indexterm"/><a id="iddle3047" class="indexterm"/><a id="iddle3050" class="indexterm"/><a id="iddle3052" class="indexterm"/><a id="iddle3126" class="indexterm"/><a id="iddle3128" class="indexterm"/>This policy enables administrator applications to set the current user’s password via the <code class="literal">resetPassword()</code> API. The specified password must satisfy the current password quality requirements and takes effect immediately. Note that if the device is encrypted, setting the lockscreen password for the owner user also changes the device encryption password. (<a class="xref" href="ch10.html" title="Chapter 10. Device Security">Chapter 10</a> provides more detail on device encryption.)</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">USES_POLICY_FORCE_LOCK</code></strong></span></span></dt><dd><p>This policy allows administrators to lock the device immediately by calling the <code class="literal">lockNow()</code> method, or to specify the maximum time for user inactivity until the device locks automatically via <code class="literal">setMaximumTimeToLock()</code>. Setting the maximum time to lock takes effect immediately and limits the inactivity sleep time that users can set via the system Display settings.</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">USES_POLICY_WIPE_DATA</code></strong></span></span></dt><dd><p>This policy allows device administrators to wipe user data by calling the <code class="literal">wipeData()</code> API. Applications that also request the <code class="literal">USES_POLICY_WATCH_LOGIN</code> policy can set the number of failed login attempts before the device is wiped automatically via the <code class="literal">setMaximumFailedPasswordsForWipe()</code> API. When the number of failed passwords is set to a value greater than zero, the lockscreen implementation notifies the <code class="literal">DevicePolicyManagerService</code> and displays a warning dialog after each failed attempt, and triggers a data wipe once the threshold is reached. If the wipe is triggered by an unsuccessful login attempt by the owner user, a full device wipe is performed. If, on the other hand, the wipe is triggered by a secondary user, only that user (and any associated data) is deleted and the device switches to the owner user.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note01"/>Note</h3><p><span class="emphasis"><em>Full device wipe is not immediate, but is implemented by writing a <code class="literal">wipe_data</code> command in the</em></span> cache <span class="emphasis"><em>partition and rebooting into recovery mode. The recovery OS is responsible for executing the actual device wipe. Therefore, if the device has a custom recovery image that ignores the wipe command, or if the user manages to boot into a custom recovery and delete or modify the command file, the device wipe might not be executed. (<a class="xref" href="ch10.html" title="Chapter 10. Device Security">Chapter 10</a> and <a class="xref" href="ch13.html" title="Chapter 13. System Updates and Root Access">Chapter 13</a> discuss recovery images in more detail.)</em></span></p></div></dd><dt><span class="term"><span class="strong"><strong><code class="literal">USES_POLICY_SETS_GLOBAL_PROXY</code></strong></span></span></dt><dd><p>As of Android 4.4, this policy is not available to third-party applications. It allows device administrators to set the global proxy server host (<code class="literal">Settings.Global.GLOBAL_HTTP_PROXY_HOST</code>), port (<code class="literal">GLOBAL_HTTP_PROXY_PORT</code>), and the list of excluded hosts (<code class="literal">GLOBAL_HTTP_PROXY_EXCLUSION_LIST</code>) by writing to the global system settings provider. Only the device owner is allowed to set global proxy settings.</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">USES_POLICY_EXPIRE_PASSWORD</code></strong></span></span></dt><dd><p><a id="iddle1066" class="indexterm"/><a id="iddle1310" class="indexterm"/><a id="iddle1312" class="indexterm"/><a id="iddle1550" class="indexterm"/><a id="iddle1558" class="indexterm"/><a id="iddle1604" class="indexterm"/><a id="iddle1724" class="indexterm"/><a id="iddle1741" class="indexterm"/><a id="iddle1866" class="indexterm"/><a id="iddle2092" class="indexterm"/><a id="iddle2344" class="indexterm"/><a id="iddle2420" class="indexterm"/><a id="iddle2771" class="indexterm"/><a id="iddle2779" class="indexterm"/><a id="iddle2787" class="indexterm"/><a id="iddle2793" class="indexterm"/><a id="iddle3031" class="indexterm"/><a id="iddle3034" class="indexterm"/><a id="iddle3036" class="indexterm"/><a id="iddle3038" class="indexterm"/>This policy allows administrators to set the password expiration timeout via the <code class="literal">setPasswordExpirationTimeout()</code> API. If an expiration timeout is set, the system registers a daily alarm that checks for password expiration. If the password has already expired, <code class="literal">DevicePolicyManagerService</code> posts daily password change notifications until it is changed. Device administrators are notified about password expiration status via the <code class="literal">Dev iceAdminReceiver.onPasswordExpiring()</code> method.</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">USES_ENCRYPTED_STORAGE</code></strong></span></span></dt><dd><p>This policy allows administrators to request that device storage be encrypted via the <code class="literal">setStorageEncryption()</code> API. Only the owner user can request storage encryption. Requesting storage encryption does not automatically start the device encryption process if the device is not encrypted; device administrators must check the current storage status by using the <code class="literal">getStorageEncryptionStatus()</code> API (which checks the <span class="emphasis"><em>ro.crypto.state</em></span> read-only system property), and start the encryption process. Device encryption can be kicked off by starting the associated system activity with the <code class="literal">ACTION_START_ENCRYPTION</code> implicit intent.</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">USES_POLICY_DISABLE_CAMERA</code></strong></span></span></dt><dd><p>This policy allows device administrators to disable all cameras on the device via the <code class="literal">setCameraDisabled()</code> API. Camera is disabled by setting the <span class="emphasis"><em>sys.secpolicy.camera.disabled</em></span> system property to 1. The native system <code class="literal">CameraService</code> checks this property and disallows all connections if it is set to 1, effectively disabling the camera for all users of the device.</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">USES_POLICY_DISABLE_KEYGUARD_FEATURES</code></strong></span></span></dt><dd><p>This policy allows administrators to disable keyguard customizations such as lockscreen widgets by calling the <code class="literal">setKeyguardDisabledFeatures()</code> method. The system keyguard implementation checks if this policy is in effect and disables the corresponding features for the target user.</p></dd></dl></div></div></div><div class="sect2" title="Adding a Device Administrator"><div class="titlepage"><div><div><h2 class="title"><a id="adding_a_device_administrator"/>Adding a Device Administrator</h2></div></div></div><p>As with other applications, device administrators can either be included in the system image or they can be installed by users. If an administrator is part of the system image, it can be set as the <span class="emphasis"><em>device owner app</em></span> in Android 4.4 and later, which is a special kind of device admin that cannot be disabled by the user and cannot be uninstalled. In this section, we’ll show how to implement a device admin app and then demonstrate how a system app can be set as the device owner.</p><div class="sect3" title="Implementing a Device Administrator"><div class="titlepage"><div><div><h3 class="title"><a id="implementing_a_device_administrator"/>Implementing a Device Administrator</h3></div></div></div><p><a id="iddle1059" class="indexterm"/><a id="iddle1263" class="indexterm"/><a id="iddle1551" class="indexterm"/><a id="iddle1553" class="indexterm"/><a id="iddle1559" class="indexterm"/><a id="iddle1561" class="indexterm"/><a id="iddle1562" class="indexterm"/><a id="iddle1989" class="indexterm"/><a id="iddle2339" class="indexterm"/><a id="iddle2340" class="indexterm"/><a id="iddle2595" class="indexterm"/>A device administrator application needs to declare a broadcast receiver that requires the <code class="literal">BIND_DEVICE_ADMIN</code> permission (➊ in <a class="xref" href="ch09.html#device_administrator_broadcast_receiver" title="Example 9-4. Device administrator broadcast receiver declaration">Example 9-4</a>), declares an XML resource file that lists the policies it uses ➋, and responds to the <code class="literal">ACTION_DEVICE_ADMIN_ENABLED</code> intent ➌. <a class="xref" href="ch09.html#declaring_policies_in_a_device_administr" title="Example 9-1. Declaring policies in a device administrator application">Example 9-1</a> shows a sample policy declaration.</p><div class="example"><a id="device_administrator_broadcast_receiver"/><p class="title">Example 9-4. Device administrator broadcast receiver declaration</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.example.deviceadmin"&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;receiver android:name=".MyDeviceAdminReceiver"
        android:label="@string/device_admin"
        android:description="@string/device_admin_description"
        android:permission="android.permission.BIND_DEVICE_ADMIN"&gt;➊
        &lt;meta-data android:name="android.app.device_admin"
                   android:resource="@xml/device_admin_policy" /&gt;➋
        &lt;intent-filter&gt;
           &lt;action android:name="android.app.action.DEVICE_ADMIN_ENABLED" /&gt;➌
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
    --<span class="emphasis"><em>snip</em></span>--
&lt;/manifest&gt;</pre></div></div><p>The Android SDK provides a base class that you can derive your receiver from, namely <code class="literal">android.app.admin.DeviceAdminReceiver</code>. This class defines a number of callback methods that you can override in order to handle the device policy-related broadcasts sent by the system. The default implementations are empty, but at a minimum you should override the <code class="literal">onEnabled()</code> and <code class="literal">onDisabled()</code> methods in order to be notified when the administrator is enabled or disabled. Device administrators cannot use any privileged APIs before <code class="literal">onEnabled()</code> is called or after <code class="literal">onDisabled()</code> is called.</p><p>You can use the <code class="literal">isAdminActive()</code> API at any time to see if an application is currently an active device administrator. As mentioned in “<a class="xref" href="ch09.html#privilege_management" title="Privilege Management">Privilege Management</a>”, an administrator cannot activate itself automatically, but must start a system activity to prompt for user confirmation with code similar to <a class="xref" href="ch09.html#requesting_device_administrator_activati" title="Example 9-2. Requesting device administrator activation">Example 9-2</a>. However, when already active, an administrator can deactivate itself by calling the <code class="literal">removeActiveAdmin()</code> method.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note02"/>Note</h3><p><span class="emphasis"><em>See the official Device Administration API guide</em></span><sup>[<a id="ch09fn03" href="#ftn.ch09fn03" class="footnote">89</a>]</sup> <span class="emphasis"><em>for more details and a full working example application.</em></span></p></div></div><div class="sect3" title="Setting the Device Owner"><div class="titlepage"><div><div><h3 class="title"><a id="setting_the_device_owner"/>Setting the Device Owner</h3></div></div></div><p>A device administrator application that’s part of the system image (that is, its APK file is installed on the <span class="emphasis"><em>system</em></span> partition) can be set as the device owner by <a id="iddle1861" class="indexterm"/><a id="iddle1862" class="indexterm"/><a id="iddle1993" class="indexterm"/><a id="iddle1994" class="indexterm"/><a id="iddle2774" class="indexterm"/>calling the <code class="literal">setDeviceOwner(String packageName, String ownerName)</code> method (not visible in the public SDK API). The first parameter in this method specifies the package name of the target application, and the second specifies the name of the owner to be displayed in the UI. While this method requires no special permissions, it can only be called before a device is provisioned (that is, if the global setting <code class="literal">Settings.Global.DEVICE_PROVISIONED</code> is set to 0), which means that it can only be called by system applications that execute as part of device initialization.</p><p>A successful call to this method writes a <span class="emphasis"><em>device_owner.xml</em></span> file (like the one in <a class="xref" href="ch09.html#contents_of_the_deviceunderscoreownerdot" title="Example 9-5. Contents of the device_owner.xml file">Example 9-5</a>) to <span class="emphasis"><em>/data/system/</em></span>. Information about the current device owner can be obtained using the <code class="literal">getDeviceOwner()</code>, <code class="literal">isDeviceOwner()</code> (which is exposed as <code class="literal">isDeviceOwnerApp()</code> in the Android SDK API) and <code class="literal">getDeviceOwnerName()</code> methods.</p><div class="example"><a id="contents_of_the_deviceunderscoreownerdot"/><p class="title">Example 9-5. Contents of the <span class="roman">device_owner.xml</span> file</p><div class="example-contents"><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;
&lt;device-owner package="com.example.deviceadmin" name="Device Owner" /&gt;</pre></div></div><p>When a device owner is activated, either as part of the provisioning process or by the user, it cannot be disabled and uninstalled, as shown in <a class="xref" href="ch09.html#device_owner_administrator_cannot_be_dis" title="Figure 9-3. A device owner administrator cannot be disabled.">Figure 9-3</a>.</p><div class="figure"><a id="device_owner_administrator_cannot_be_dis"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00040"/><img src="figs/web/09fig03.png.jpg" alt="A device owner administrator cannot be disabled."/></div></div><p class="title">Figure 9-3. A device owner administrator cannot be disabled.</p></div></div><div class="sect3" title="Managed Devices"><div class="titlepage"><div><div><h3 class="title"><a id="managed_devices"/>Managed Devices</h3></div></div></div><p><a id="iddle1547" class="indexterm"/><a id="iddle1549" class="indexterm"/><a id="iddle1552" class="indexterm"/><a id="iddle1560" class="indexterm"/><a id="iddle1569" class="indexterm"/><a id="iddle1693" class="indexterm"/><a id="iddle1740" class="indexterm"/><a id="iddle1765" class="indexterm"/><a id="iddle1960" class="indexterm"/><a id="iddle2068" class="indexterm"/><a id="iddle2183" class="indexterm"/><a id="iddle2210" class="indexterm"/><a id="iddle2971" class="indexterm"/>A device with an owner administrator installed is called a <span class="emphasis"><em>managed device</em></span>, and it reacts differently to configuration changes that affect device security than unmanaged devices. As discussed in <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a> and <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a>, Android allows users to install certificates in the system trust store either via the system Settings application, or by using third-party applications that call the <code class="literal">KeyChain</code> API. If there are user-installed certificates in the system trust store, as of version 4.4 Android shows a warning (see <a class="xref" href="ch06.html#network_monitoring_warning_in_android_4d" title="Figure 6-6. Network monitoring warning in Android 4.4">Figure 6-6</a>) notifying users that their communications can be monitored.</p><p>Enterprise networks often require trusted certificates (for example, the root certificate of a corporate PKI) to be installed in order to access enterprise services. Such certificates can be silently installed or removed by device administrators that hold the <code class="literal">MANAGE_CA_ CERTIFICATES</code> system permissions via the <code class="literal">installCaCert()</code> and <code class="literal">uninstallCaCert()</code> methods of the <code class="literal">DevicePolicyManager</code> class (these methods are reserved for system applications and aren’t visible in the public SDK API). If an additional trusted certificate is installed on a managed device, the network monitoring warning changes to a less scary information message, as shown in <a class="xref" href="ch09.html#network_monitoring_information_message_s" title="Figure 9-4. Network monitoring information message shown on managed devices">Figure 9-4</a>.</p></div></div><div class="sect2" title="Enterprise Account Integration"><div class="titlepage"><div><div><h2 class="title"><a id="enterprise_account_integration"/>Enterprise Account Integration</h2></div></div></div><p>As mentioned in “<a class="xref" href="ch09.html#device_administration" title="Device Administration">Device Administration</a>”, device administrator applications are often coupled with enterprise accounts, in order to allow some control over devices that access company data. In this section, we’ll discuss two such implementations: one in the stock Email application, which works with Microsoft Exchange ActiveSync accounts, and the other in the dedicated Google Apps Device Policy application, which works with corporate Google accounts.</p><div class="figure"><a id="network_monitoring_information_message_s"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00041"/><img src="figs/web/09fig04.png.jpg" alt="Network monitoring information message shown on managed devices"/></div></div><p class="title">Figure 9-4. Network monitoring information message shown on managed devices</p></div><div class="sect3" title="Microsoft Exchange ActiveSync"><div class="titlepage"><div><div><h3 class="title"><a id="microsoft_exchange_activesync"/>Microsoft Exchange ActiveSync</h3></div></div></div><p><span class="emphasis"><em>Microsoft Exchange ActiveSync</em></span> (usually abbreviated as <span class="emphasis"><em>EAS</em></span>) is a protocol that supports email, contacts, calendar, and task synchronization from a <a id="iddle1548" class="indexterm"/><a id="iddle1750" class="indexterm"/><a id="iddle1902" class="indexterm"/><a id="iddle3072" class="indexterm"/><a id="iddle3077" class="indexterm"/>groupware server to a mobile device. It’s supported both by Microsoft’s own Exchange Server, and by most competing products, including Google Apps.</p><p>The Email application included in Android supports ActiveSync accounts and data synchronization via dedicated account authenticators (see <a class="xref" href="ch08.html" title="Chapter 8. Online Account Management">Chapter 8</a>) and sync adapters. In order to allow enterprise administrators to enforce a security policy on devices that access email and other corporate data, the Email application doesn’t allow synchronization until the built-in device administrator is enabled by the user. The administrator can set lockscreen password rules, erase all data, require storage encryption, and disable device cameras, as shown in <a class="xref" href="ch09.html#device_administrator_policies_required_f" title="Figure 9-5. Device administrator policies required for using an EAS account">Figure 9-5</a>. However, the policies are not built into the app but fetched from the service using the EAS Provision protocol.</p><div class="figure"><a id="device_administrator_policies_required_f"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00042"/><img src="figs/web/09fig05.png.jpg" alt="Device administrator policies required for using an EAS account"/></div></div><p class="title">Figure 9-5. Device administrator policies required for using an EAS account</p></div></div><div class="sect3" title="Google Apps"><div class="titlepage"><div><div><h3 class="title"><a id="google_apps"/>Google Apps</h3></div></div></div><p>The corporate version of Google’s Gmail service, Google Apps, also supports setting mobile device security policies. If the feature is enabled by the domain administrator, Google Apps account holders can also remotely locate, ring, lock, or wipe their Android devices. Domain administrators can also selectively delete a Google Apps account and all of its associated content from a managed device, without performing a full wipe. Both security policy enforcement and remote device management are implemented in the dedicated Google Apps Device Policy application (see ➎ in <a class="xref" href="ch09.html#contents_of_the_devicesunderscorepolicie" title="Example 9-3. Contents of the devices_policies.xml file">Example 9-3</a>).</p><p>When first started, the application requests that the user enable the built-in device administrator and displays the current domain policy settings as shown in <a class="xref" href="ch09.html#policy_enforcement_confirmation_in_the_g" title="Figure 9-6. Policy enforcement confirmation in the Google Apps Device Policy application">Figure 9-6</a>.</p><p>Domain administrators define policies in the Google Apps admin console (see <a class="xref" href="ch09.html#google_apps_device_policy_management_ui" title="Figure 9-7. Google Apps device policy management UI">Figure 9-7</a>), and policy settings are pushed to devices using Google’s proprietary sync protocol.</p><p>While free Google accounts do not support setting a device policy, Google experience devices can use the basic device administrator built into Google Play Services (see ➊ in <a class="xref" href="ch09.html#contents_of_the_devicesunderscorepolicie" title="Example 9-3. Contents of the devices_policies.xml file">Example 9-3</a>). This administrator allows Google account holders to remotely locate or wipe their devices using the Android Device Manager website or the associated Android application.</p><div class="figure"><a id="policy_enforcement_confirmation_in_the_g"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00043"/><img src="figs/web/09fig06.png.jpg" alt="Policy enforcement confirmation in the Google Apps Device Policy application"/></div></div><p class="title">Figure 9-6. Policy enforcement confirmation in the Google Apps Device Policy application</p></div><div class="figure"><a id="google_apps_device_policy_management_ui"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00044"/><img src="figs/web/09fig07.png.jpg" alt="Google Apps device policy management UI"/></div></div><p class="title">Figure 9-7. Google Apps device policy management UI</p></div></div></div></div><div class="sect1" title="VPN Support"><div class="titlepage"><div><div><h1 class="title"><a id="vpn_support"/>VPN Support</h1></div></div></div><p><a id="iddle1198" class="indexterm"/><a id="iddle1363" class="indexterm"/><a id="iddle1367" class="indexterm"/><a id="iddle1752" class="indexterm"/><a id="iddle1755" class="indexterm"/><a id="iddle1850" class="indexterm"/><a id="iddle1914" class="indexterm"/><a id="iddle1982" class="indexterm"/><a id="iddle1988" class="indexterm"/><a id="iddle2129" class="indexterm"/><a id="iddle2211" class="indexterm"/><a id="iddle2231" class="indexterm"/><a id="iddle2418" class="indexterm"/><a id="iddle2508" class="indexterm"/><a id="iddle2509" class="indexterm"/><a id="iddle2560" class="indexterm"/><a id="iddle3087" class="indexterm"/><a id="iddle3096" class="indexterm"/>A <span class="emphasis"><em>Virtual Private Network (VPN)</em></span> allows a private network to be extended across a public network without requiring a dedicated physical connection, thus enabling all connected devices to send and receive data as if colocated and physically connected to the same private network. When a VPN is used to allow individual devices to connect to a target private network, it’s referred to as a <span class="emphasis"><em>remote access VPN</em></span>, and when used to connect two remote networks, as a <span class="emphasis"><em>site-to-site VPN</em></span>.</p><p>Remote-access VPNs can connect fixed devices with a static IP address, such as a computer in a remote office, but configurations where mobile clients use variable network connections and dynamic addresses are much more common. Such a configuration is often called a <span class="emphasis"><em>road warrior</em></span> configuration and is the configuration most commonly used with Android VPN clients.</p><p>In order to ensure that data transmitted over a VPN remains private, VPNs typically authenticate remote clients and provide data confidentiality and integrity by using a secure tunneling protocol. VPN protocols are complex because they work at multiple network layers simultaneously and often involve multiple levels of encapsulation in order to be compatible with various network configurations. A thorough discussion of them is beyond the scope of his book, but in the following sections you’ll find a brief overview of the major types of VPN protocols, with a focus on the ones available on Android.</p><div class="sect2" title="PPTP"><div class="titlepage"><div><div><h2 class="title"><a id="pptp"/>PPTP</h2></div></div></div><p>The <span class="emphasis"><em>Point-to-Point Tunneling Protocol (PPTP)</em></span> uses a TCP control channel to establish connections and the Generic Routing Encapsulation (GRE) tunneling protocol to encapsulate Point-to-Point Protocol (PPP) packets. Several authentication methods such as Password Authentication Protocol (PAP), Challenge-Handshake Authentication Protocol (CHAP), and its Microsoft extension MS-CHAP v1/v2, as well as EAP-TLS, are supported, but only EAP-TLS is currently considered secure.</p><p>The PPP payload can be encrypted using the Microsoft Point-to-Point Encryption (MPPE) protocol, which uses the RC4 stream cipher. Because MPPE does not employ any form of ciphertext authentication, it is vulnerable to bit-flipping attacks. In addition, multiple problems with the RC4 cipher have been uncovered in recent years, which further reduces the security of MMPE and PPTP.</p></div><div class="sect2" title="L2TP/IPSec"><div class="titlepage"><div><div><h2 class="title"><a id="l2tpsolidusipsec"/>L2TP/IPSec</h2></div></div></div><p>The <span class="emphasis"><em>Layer 2 Tunneling Protocol (L2TP)</em></span> is similar to PPTP and exists at the data link layer (Layer 2 in the OSI model). Because L2TP provides no encryption or confidentiality of its own (it relies on the tunneled protocol to implement these features), an L2TP VPN is typically implemented using a combination of L2TP and the Internet Protocol Security (IPSec) protocol suite, which adds authentication, confidentiality, and integrity.</p><p><a id="iddle1756" class="indexterm"/><a id="iddle1757" class="indexterm"/><a id="iddle1947" class="indexterm"/><a id="iddle1980" class="indexterm"/><a id="iddle1983" class="indexterm"/><a id="iddle1987" class="indexterm"/><a id="iddle1990" class="indexterm"/><a id="iddle2221" class="indexterm"/><a id="iddle2356" class="indexterm"/><a id="iddle2650" class="indexterm"/><a id="iddle2700" class="indexterm"/><a id="iddle2864" class="indexterm"/><a id="iddle3097" class="indexterm"/><a id="iddle3098" class="indexterm"/><a id="iddle3157" class="indexterm"/>In an L2TP/IPSec configuration, a secure channel is first established using IPSec, and an L2TP tunnel is then established over the secure channel. L2TP packets are always wrapped inside IPSec packets and are therefore secure. An IPSec connection requires establishing a <span class="emphasis"><em>Security Association (SA)</em></span>, which is a combination of cryptographic algorithm and mode, encryption key, and other parameters required to establish a secure channel.</p><p>SAs are established using the Internet Security Association and Key Management Protocol (ISAKMP). ISAKMP does not define a particular key exchange method and is typically implemented either by manual configuration of pre-shared secrets, or by using the Internet Key Exchange (IKE and IKEv2) protocol. IKE uses X.509 certificates for peer authentication (much like SSL), and a Diffie-Hellman key exchange in order to establish a shared secret, which is used to derive the actual session encryption keys.</p></div><div class="sect2" title="IPSec Xauth"><div class="titlepage"><div><div><h2 class="title"><a id="ipsec_xauth"/>IPSec Xauth</h2></div></div></div><p><span class="emphasis"><em>IPSec Extended Authentication (Xauth)</em></span> extends IKE to include additional user authentication exchanges. This allows an existing user database or a RADIUS infrastructure to be used to authenticate remote access clients, and makes it possible to integrate two-factor authentication.</p><p><span class="emphasis"><em>Mode-configuration (Modecfg)</em></span> is another IPSec extension that is often used in a remote access scenario. Modecfg allows VPN servers to push network configuration information such as the private IP address and DNS server addresses to clients. When used in combination, Xauth and Modecfg make it possible to create a pure-IPSec VPN solution, which doesn’t rely on additional protocols for authentication and tunneling.</p></div><div class="sect2" title="SSL-Based VPNs"><div class="titlepage"><div><div><h2 class="title"><a id="ssl-based_vpns"/>SSL-Based VPNs</h2></div></div></div><p>SSL-based VPNs use SSL or TLS (see <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a>) to establish a secure connection and tunnel network traffic. No single standard defines SSL-based VPNs, and different implementations use different strategies in order to establish a secure channel and encapsulate packets.</p><p>OpenVPN is a popular open source application that uses SSL for authentication and key exchange (preconfigured shared static keys are also supported), and a custom encryption protocol<sup>[<a id="ch09fn04" href="#ftn.ch09fn04" class="footnote">90</a>]</sup> to encrypt and authenticate packets. OpenVPN multiplexes the SSL session used for authentication and key exchange, and the encrypted packets stream over a single UDP (or TCP) port. The multiplexing protocol provides a reliable transport layer for SSL on top of UDP, but it tunnels encrypted IP packets over UDP without adding reliability. Reliability is provided by the tunneled protocol itself, which is usually TCP.</p><p>The main advantages of OpenVPN over IPSec are that it is much simpler and can be implemented entirely in userspace. IPSec, on the other hand, requires kernel-level support and implementation of multiple interoperating <a id="iddle1753" class="indexterm"/><a id="iddle2134" class="indexterm"/><a id="iddle2137" class="indexterm"/><a id="iddle2236" class="indexterm"/><a id="iddle2552" class="indexterm"/><a id="iddle3088" class="indexterm"/><a id="iddle3091" class="indexterm"/>protocols. Additionally, it’s easier to get OpenVPN traffic through firewalls, NAT, and proxies because it uses the common network protocols TCP and UDP and can multiplex tunneled traffic over a single port.</p><p>The following sections examine Android’s built-in VPN support and the APIs it provides for applications that want to implement additional VPN solutions. We’ll also review the components that make up Android’s VPN infrastructure and show how it protects VPN credentials.</p></div><div class="sect2" title="Legacy VPN"><div class="titlepage"><div><div><h2 class="title"><a id="legacy_vpn"/>Legacy VPN</h2></div></div></div><p>Prior to Android 4.0, VPN support was entirely built into the platform and wasn’t extensible. Support for new VPN types could only be added as part of platform updates. To distinguish it from application-based implementations, built-in VPN support is referred to as <span class="emphasis"><em>legacy VPN</em></span>.</p><p>Early Android versions supported different VPN configurations based on PPTP and L2TP/IPsec, with support for “pure-IPSec” VPNs using IPSec Xauth added in version 4.0. In addition to new built-in VPN configurations, Android 4.0 also introduced application-based VPNs by supplying the base platform class <code class="literal">VpnService</code>, which applications could extend in order to implement a new VPN solution.</p><p>Legacy VPN is controlled via the system Settings application and is only available to the owner (also called the primary user) on multi-user devices. <a class="xref" href="ch09.html#legacy_vpn_profile_definition_dialog" title="Figure 9-8. Legacy VPN profile definition dialog">Figure 9-8</a> shows the dialog for adding a new IPSec legacy VPN profile.</p><div class="sect3" title="Implementation"><div class="titlepage"><div><div><h3 class="title"><a id="implementation-id00018"/>Implementation</h3></div></div></div><div class="figure"><a id="legacy_vpn_profile_definition_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00045"/><img src="figs/web/09fig08.png.jpg" alt="Legacy VPN profile definition dialog"/></div></div><p class="title">Figure 9-8. Legacy VPN profile definition dialog</p></div><p>Legacy VPNs are implemented using a combination of kernel drivers as well as native daemons, commands, and system services. The lower-level implementation of PPTP and L2TP tunneling uses an Android-specific PPP daemon called <span class="emphasis"><em>mtpd</em></span> and the PPPoPNS and PPPoLAC (only available in Android kernels) kernel drivers.</p><p>Because legacy VPNs support only a single VPN connection per device, <span class="emphasis"><em>mtpd</em></span> can create only a single session. IPSec VPNs leverage the built-in kernel support for IPSec and a modified <span class="emphasis"><em>racoon</em></span> IKE key management daemon (part of the IPSec-Tools<sup>[<a id="ch09fn05" href="#ftn.ch09fn05" class="footnote">91</a>]</sup> utilities package that complements the Linux kernel IPSec implementation; <span class="emphasis"><em>racoon</em></span> supports only IKEv1). <a class="xref" href="ch09.html#racoon_and_mtpd_definition_in_initdotrc" title="Example 9-6. racoon and mtpd definition in init.rc">Example 9-6</a> shows how these two daemons are defined in <span class="emphasis"><em>init.rc</em></span>.</p><div class="example"><a id="racoon_and_mtpd_definition_in_initdotrc"/><p class="title">Example 9-6. <span class="roman">racoon</span> and <span class="roman">mtpd</span> definition in <span class="roman">init.rc</span></p><div class="example-contents"><pre class="programlisting">service racoon /system/bin/racoon➊
    class main
    socket racoon stream 600 system system➋
    # IKE uses UDP port 500. Racoon will setuid to vpn after binding the port.
    group vpn net_admin inet➌
    disabled
    oneshot

service mtpd /system/bin/mtpd➍
    class main
    socket mtpd stream 600 system system➎
    user vpn
    group vpn net_admin inet net_raw➏
    disabled
    oneshot</pre></div></div><p>Both <span class="emphasis"><em>racoon</em></span> ➊ and <span class="emphasis"><em>mtpd</em></span> ➍ create control sockets (➋ and ➎), which are only accessible by the <span class="emphasis"><em>system</em></span> user and are not started by default. Both daemons have <span class="emphasis"><em>vpn</em></span>, <span class="emphasis"><em>net_admin</em></span> (mapped by the kernel to the <code class="literal">CAP_NET_ADMIN</code> Linux capability), and <span class="emphasis"><em>inet</em></span> added to their supplementary groups (➌ and ➏), which allow them to create sockets and control network interface devices. The <span class="emphasis"><em>mtpd</em></span> daemon also receives the <span class="emphasis"><em>net_raw</em></span> group (mapped to the <code class="literal">CAP_NET_RAW</code> Linux capability), which allows it to create GRE sockets (used by PPTP).</p><p>When a VPN is started via the system Settings app, Android starts the <span class="emphasis"><em>racoon</em></span> and <span class="emphasis"><em>mtpd</em></span> daemons and sends them control commands via their local sockets in order to establish the configured connection. The daemons create the requested VPN tunnel, and then create and configure a tunnel network interface with the received IP address and network mask. While <span class="emphasis"><em>mtpd</em></span> performs interface configuration internally, <span class="emphasis"><em>racoon</em></span> uses the helper command <code class="literal">ip-up-vpn</code> to bring up the tunnel interface, which is usually <span class="emphasis"><em>tun0</em></span>.</p><p>In order to communicate connection parameters back to the framework, VPN daemons write a <span class="emphasis"><em>state</em></span> file in <span class="emphasis"><em>/data/misc/vpn/</em></span> as shown in <a class="xref" href="ch09.html#contents_of_the_vpn_state_file" title="Example 9-7. Contents of the VPN state file">Example 9-7</a>.</p><div class="example"><a id="contents_of_the_vpn_state_file"/><p class="title">Example 9-7. Contents of the VPN <span class="roman">state</span> file</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>cat /data/misc/vpn/state</strong></span>
tun0➊
10.8.0.1/24➋
192.168.1.0/24➌
192.168.1.1➍
example.com➎</pre></div></div><p><a id="iddle2138" class="indexterm"/><a id="iddle2270" class="indexterm"/><a id="iddle3092" class="indexterm"/>The file contains the tunnel interface name ➊, its IP address and mask ➋, configured routes ➌, DNS servers ➍, and search domains ➎, with each on a new line.</p><p>After the VPN daemons start running, the framework parses the <span class="emphasis"><em>state</em></span> file and calls the system <code class="literal">ConnectivityService</code> in order to configure routing, DNS servers, and search domains for the newly established VPN connection. In turn, <code class="literal">ConnectivityService</code> sends control commands via the local control socket of the <span class="emphasis"><em>netd</em></span> daemon, which can modify the kernel’s packet filtering and routing tables because it runs as root. Traffic from all applications started by the owner user and restricted profiles is routed through the VPN interface by adding a firewall rule that matches the application UID and corresponding routing rules. (We discuss per-application traffic routing and multi-user support in detail in “<a class="xref" href="ch09.html#multi-user_support-id00019" title="Multi-User Support">Multi-User Support</a>”).</p></div><div class="sect3" title="Profile and Credential Storage"><div class="titlepage"><div><div><h3 class="title"><a id="profile_and_credential_storage"/>Profile and Credential Storage</h3></div></div></div><p>Each VPN configuration created via the Settings app is called a <span class="emphasis"><em>VPN profile</em></span> and is saved on disk in encrypted form. Encryption is performed by the Android credential storage daemon <span class="emphasis"><em>keystore</em></span>, with a device-specific key. (See <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a> for more on credential storage implementation.)</p><p>VPN profiles are serialized by concatenating all configured properties, which are delimited by a <span class="emphasis"><em>NUL</em></span> character (<span class="emphasis"><em>\0</em></span>) in a single profile string that is saved to the system keystore as a binary blob. VPN profile filenames are generated by appending the current time in milliseconds (in hexadecimal format) to the <span class="emphasis"><em>VPN_</em></span> prefix. For example, <a class="xref" href="ch09.html#contents_of_the_keystore_directory_when" title="Example 9-8. Contents of the keystore directory when VPN profiles are configured">Example 9-8</a> shows the <span class="emphasis"><em>keystore</em></span> directory of a user with three configured VPN profiles (file timestamps omitted):</p><div class="example"><a id="contents_of_the_keystore_directory_when"/><p class="title">Example 9-8. Contents of the <code class="literal">keystore</code> directory when VPN profiles are configured</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /data/misc/keystore/user_0</strong></span>
-rw------- keystore keystore      980 1000_CACERT_cacert➊
-rw------- keystore keystore       52 1000_LOCKDOWN_VPN➋
-rw------- keystore keystore      932 1000_USRCERT_vpnclient➌
-rw------- keystore keystore     1652 1000_USRPKEY_vpnclient➍
-rw------- keystore keystore      116 1000_VPN_144965b85a6➎
-rw------- keystore keystore       84 1000_VPN_145635c88c8➏
-rw------- keystore keystore      116 1000_VPN_14569512c80➐</pre></div></div><p>The three VPN profiles are stored in the <span class="emphasis"><em>1000_VPN_144965b85a6</em></span> ➎, <span class="emphasis"><em>1000_VPN_145635c88c8</em></span> ➏, and <span class="emphasis"><em>1000_VPN_14569512c80</em></span> ➐ files. The <span class="emphasis"><em>1000_</em></span> prefix represents the owner user, which is <span class="emphasis"><em>system</em></span> (UID 1000). Because VPN profiles are owned by the <span class="emphasis"><em>system</em></span> user, only system applications can retrieve and decrypt profile contents.</p><p><a class="xref" href="ch09.html#contents_of_vpn_profile_files" title="Example 9-9. Contents of VPN profile files">Example 9-9</a> shows the decrypted contents of the three VPN profile files. (The <span class="emphasis"><em>NUL</em></span> character has been replaced with vertical bar [<code class="literal">|</code>] for readability.)</p><div class="example"><a id="contents_of_vpn_profile_files"/><p class="title">Example 9-9. Contents of VPN profile files</p><div class="example-contents"><pre class="programlisting">psk-vpn|1|vpn1.example.com|test1|pass1234||||true|l2tpsecret|l2tpid|PSK|||➊
pptpvpn|0|vpn2.example.com|user1|password||||true||||||➋
certvpn|4|vpn3.example.com|user3|password||||true||||vpnclient|cacert|➌</pre></div></div><p><a id="iddle2135" class="indexterm"/><a id="iddle2553" class="indexterm"/><a id="iddle3089" class="indexterm"/>The profile files contain all fields shown in the VPN profile edit dialog (see <a class="xref" href="ch09.html#legacy_vpn_profile_definition_dialog" title="Figure 9-8. Legacy VPN profile definition dialog">Figure 9-8</a>), with missing properties represented by an empty string. The first five fields represent the name of the VPN, the type of VPN, the VPN gateway host, the username, and the password, respectively. In <a class="xref" href="ch09.html#contents_of_vpn_profile_files" title="Example 9-9. Contents of VPN profile files">Example 9-9</a>, the first VPN profile ➊ is for an L2TP/IPsec VPN with pre-shared key (type 1); the second profile ➋ is for a PPTP VPN (type 0), and the last one ➌ is for a IPSec VPN that uses certificates and Xauth authentication (type 4).</p><p>In addition to the username and password, VPN profile files also contain all other credentials required to connect to the VPN. In the case of the first VPN profile ➊ in <a class="xref" href="ch09.html#contents_of_vpn_profile_files" title="Example 9-9. Contents of VPN profile files">Example 9-9</a>, the additional credential is the pre-shared key required to establish an IPSec secure connection (represented by the <span class="emphasis"><em>PSK</em></span> string in this example). In the case of the third profile ➌, the additional credentials are the user’s private key and certificate. However, as you can see in the listing, the full key and certificate are not included; instead, the profile contains only the alias (<span class="emphasis"><em>vpnclient</em></span>) of the key and certificate (both share a common alias). The private key and certificate are stored in the system credential store, and the alias included in the VPN profile serves only as an identifier, which is used to access or retrieve the key and certificate.</p></div><div class="sect3" title="Accessing Credentials"><div class="titlepage"><div><div><h3 class="title"><a id="accessing_credentials"/>Accessing Credentials</h3></div></div></div><p>The <span class="emphasis"><em>racoon</em></span> daemon, which originally used keys and certificates stored in PEM files, was modified to use Android’s <span class="emphasis"><em>keystore</em></span> OpenSSL engine. As discussed in <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a>, the <span class="emphasis"><em>keystore</em></span> engine is a gateway to the system credential store, which can take advantage of hardware-backed credential store implementations when available. When passed a key alias, it uses the corresponding private key to sign authentication packets, without extracting the key from the keystore.</p><p>The VPN profile ➌ in <a class="xref" href="ch09.html#contents_of_vpn_profile_files" title="Example 9-9. Contents of VPN profile files">Example 9-9</a> also contains the alias of the CA certificate (<span class="emphasis"><em>cacert</em></span>), which is used as a trust anchor when validating the server’s certificate. At runtime, the framework retrieves the client certificate (➌ in <a class="xref" href="ch09.html#contents_of_the_keystore_directory_when" title="Example 9-8. Contents of the keystore directory when VPN profiles are configured">Example 9-8</a>) and the CA certificate (➊ in <a class="xref" href="ch09.html#contents_of_the_keystore_directory_when" title="Example 9-8. Contents of the keystore directory when VPN profiles are configured">Example 9-8</a>) from the system keystore and passes them to <span class="emphasis"><em>racoon</em></span> via the control socket, along with other connection parameters. The private key blob (➍ in <a class="xref" href="ch09.html#contents_of_the_keystore_directory_when" title="Example 9-8. Contents of the keystore directory when VPN profiles are configured">Example 9-8</a>) is never directly passed to the <span class="emphasis"><em>racoon</em></span> daemon, only its alias (<span class="emphasis"><em>vpnclient</em></span>).</p><div class="note" title="Note"><h3 class="title"><a id="ch09note03"/>Note</h3><p><span class="emphasis"><em>While private keys are protected by hardware on devices with a hardware-backed keystore, pre-shared keys or passwords stored in a VPN profile content are not. The reason for this is that as of this writing, Android doesn’t support importing symmetric keys in the hardware-backed keystore; it only supports asymmetric keys (RSA, DSA, and EC). As a result, credentials for VPNs that use pre-shared keys are stored in the VPN profile in plaintext form and can be extracted from devices that allow root access after the profile is decrypted on memory.</em></span></p></div></div><div class="sect3" title="Always-On VPN"><div class="titlepage"><div><div><h3 class="title"><a id="always-on_vpn"/>Always-On VPN</h3></div></div></div><p><a id="iddle1133" class="indexterm"/><a id="iddle2136" class="indexterm"/><a id="iddle2151" class="indexterm"/><a id="iddle2152" class="indexterm"/><a id="iddle2271" class="indexterm"/><a id="iddle3090" class="indexterm"/>Android 4.2 and later supports an <span class="emphasis"><em>always-on</em></span> VPN configuration, which blocks all network connections from applications until a connection to the specified VPN profile is established. This prevents applications from sending data across insecure channels, such as public Wi-Fi networks.</p><p>Setting up an always-on VPN requires setting up a VPN profile that specifies the VPN gateway as an IP address, and specifies an explicit DNS server IP address. This explicit configuration is required in order to make sure that DNS traffic isn’t sent to the locally configured DNS server, which is blocked when an always-on VPN is in effect. The VPN profile selection dialog is shown in <a class="xref" href="ch09.html#always-on_vpn_profile_selection_dialog" title="Figure 9-9. Always-on VPN profile selection dialog">Figure 9-9</a>.</p><p>The profile selection is saved with other VPN profiles in the encrypted file <span class="emphasis"><em>LOCKDOWN_VPN</em></span> (➋ in <a class="xref" href="ch09.html#contents_of_the_keystore_directory_when" title="Example 9-8. Contents of the keystore directory when VPN profiles are configured">Example 9-8</a>) which contains only the name of the selected profile; in our example, <span class="emphasis"><em>144965b85a6</em></span>. If the <span class="emphasis"><em>LOCKDOWN_VPN</em></span> file is present, the system automatically connects to the specified VPN when the device boots. If the underlying network connection reconnects or changes (for example, when switching Wi-Fi hotspots), the VPN is automatically restarted.</p><div class="figure"><a id="always-on_vpn_profile_selection_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00046"/><img src="figs/web/09fig09.png.jpg" alt="Always-on VPN profile selection dialog"/></div></div><p class="title">Figure 9-9. Always-on VPN profile selection dialog</p></div><p>An always-on VPN guarantees that all traffic goes through the VPN by installing firewall rules that block all packets except those which go through the VPN interface. The rules are installed by the <code class="literal">LockdownVpnTracker</code> class (always-on VPN is referred to as <span class="emphasis"><em>lockdown VPN</em></span> in Android source code), which monitors VPN state and adjusts the current firewall state by sending commands to the <span class="emphasis"><em>netd</em></span> daemon, which in turn executes the <code class="literal">iptables</code> utility in order to modify the kernels packet filtering tables. For example, when an always-on L2TP/IPSec VPN has connected to a VPN server with IP address 11.22.33.44 and has created a tunnel interface <span class="emphasis"><em>tun0</em></span> with IP address 10.1.1.1, the installed firewall rules (as reported by <code class="literal">iptables</code>; some columns have been omitted for brevity) might look like <a class="xref" href="ch09.html#always-on_vpn_firewall_rules" title="Example 9-10. Always-on VPN firewall rules">Example 9-10</a>.</p><div class="example"><a id="always-on_vpn_firewall_rules"/><p class="title">Example 9-10. Always-on VPN firewall rules</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>iptables -v -L n</strong></span>
--<span class="emphasis"><em>snip</em></span>--
Chain fw_INPUT (1 references)
 target     prot opt in     out    source      destination
 RETURN     all  --  *      *      0.0.0.0/0   10.1.1.0/24➊
 RETURN     all  --  tun0   *      0.0.0.0/0   0.0.0.0/0➋
 RETURN     udp  --  *      *      11.22.33.44 0.0.0.0/0    udp spt:1701➌
 RETURN     tcp  --  *      *      11.22.33.44 0.0.0.0/0    tcp spt:1701
 RETURN     udp  --  *      *      11.22.33.44 0.0.0.0/0    udp spt:4500
 RETURN     tcp  --  *      *      11.22.33.44 0.0.0.0/0    tcp spt:4500
 RETURN     udp  --  *      *      11.22.33.44 0.0.0.0/0    udp spt:500
 RETURN     tcp  --  *      *      11.22.33.44 0.0.0.0/0    tcp spt:500
 RETURN     all  --  lo     *      0.0.0.0/0   0.0.0.0/0
 DROP       all  --  *      *      0.0.0.0/0   0.0.0.0/0➍

Chain fw_OUTPUT (1 references)
 target     prot opt in     out    source      destination
 RETURN     all  --  *      *      10.1.1.0/24 0.0.0.0/0➎
 RETURN     all  --  *      tun0   0.0.0.0/0   0.0.0.0/0➏
 RETURN     udp  --  *      *      0.0.0.0/0   11.22.33.44  udp dpt:1701➐
 RETURN     tcp  --  *      *      0.0.0.0/0   11.22.33.44  tcp dpt:1701
 RETURN     udp  --  *      *      0.0.0.0/0   11.22.33.44  udp dpt:4500
 RETURN     tcp  --  *      *      0.0.0.0/0   11.22.33.44  tcp dpt:4500
 RETURN     udp  --  *      *      0.0.0.0/0   11.22.33.44  udp dpt:500
 RETURN     tcp  --  *      *      0.0.0.0/0   11.22.33.44  tcp dpt:500
 RETURN     all  --  *      lo     0.0.0.0/0   0.0.0.0/0
 REJECT     all  --  *      *      0.0.0.0/0   0.0.0.0/0   reject-with icmp-port-unreachable➑
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a id="iddle1168" class="indexterm"/><a id="iddle1751" class="indexterm"/><a id="iddle3078" class="indexterm"/><a id="iddle3099" class="indexterm"/>As you can see in the listing, all traffic to and from the VPN network is allowed (➊ and ➎), as is all traffic on the tunnel interface (➋ and ➏). Traffic to and from the VPN server (➌ and ➐) is allowed only on the ports used by IPSec (500 and 4500) and L2TP (1701). All other incoming traffic is dropped ➍, and all other outgoing traffic is rejected ➑.</p></div></div><div class="sect2" title="Application-Based VPNs"><div class="titlepage"><div><div><h2 class="title"><a id="application-based_vpns"/>Application-Based VPNs</h2></div></div></div><p>Android 4.0 added a <code class="literal">VpnService</code> public API<sup>[<a id="ch09fn06" href="#ftn.ch09fn06" class="footnote">92</a>]</sup> that third-party applications can use to build VPN solutions that are neither built into the OS nor require system-level permissions. The <code class="literal">VpnService</code> and associated <code class="literal">Builder</code> class let applications specify network parameters such as interface IP address and routes, which the system uses to create and configure a virtual network interface. Applications receive a file descriptor associated with that network interface and can tunnel network traffic by reading from or writing to the file descriptor of the interface.</p><p>Each read retrieves an outgoing IP packet, and each write injects an incoming IP packet. Because raw access to network packets effectively lets applications intercept and modify network traffic, application-based VPNs cannot be started automatically and always require user interaction. Additionally, an ongoing notification is shown while a VPN is connected. The connection warning dialog for an application-based VPN might look like <a class="xref" href="ch09.html#application-based_vpn_connection_warning" title="Figure 9-10. Application-based VPN connection warning dialog">Figure 9-10</a>.</p><div class="figure"><a id="application-based_vpn_connection_warning"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00047"/><img src="figs/web/09fig10.png.jpg" alt="Application-based VPN connection warning dialog"/></div></div><p class="title">Figure 9-10. Application-based VPN connection warning dialog</p></div><div class="sect3" title="Declaring a VPN"><div class="titlepage"><div><div><h3 class="title"><a id="declaring_a_vpn"/>Declaring a VPN</h3></div></div></div><p><a id="iddle1169" class="indexterm"/><a id="iddle3079" class="indexterm"/>An application-based VPN is implemented by creating a service component that extends the <code class="literal">VpnService</code> base class and registering it in the application manifest, as shown in <a class="xref" href="ch09.html#registering_a_vpn_service_in_the_applica" title="Example 9-11. Registering a VPN service in the application manifest">Example 9-11</a>.</p><div class="example"><a id="registering_a_vpn_service_in_the_applica"/><p class="title">Example 9-11. Registering a VPN service in the application manifest</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.example.vpn"&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;application android:label="@string/app"&gt;
         --<span class="emphasis"><em>snip</em></span>--
         &lt;service android:name=".MyVpnService"
                  android:permission="android.permission.BIND_VPN_SERVICE"&gt;➊
            &lt;intent-filter&gt;
                &lt;action android:name="android.net.VpnService"/&gt;➋
            &lt;/intent-filter&gt;
        &lt;/service&gt;
    &lt;/application&gt;
&lt;/manifest&gt;:</pre></div></div><p>The service must have an intent filter that matches the <span class="emphasis"><em>android.net.VpnService</em></span> intent action ➋ so that the system can bind to the service and <a id="iddle1170" class="indexterm"/><a id="iddle1171" class="indexterm"/><a id="iddle1172" class="indexterm"/><a id="iddle1762" class="indexterm"/><a id="iddle2357" class="indexterm"/><a id="iddle2510" class="indexterm"/><a id="iddle3080" class="indexterm"/><a id="iddle3081" class="indexterm"/><a id="iddle3082" class="indexterm"/>control it. In addition, the service must require the <code class="literal">BIND_VPN_SERVICE</code> system signature permission ➊, which guarantees that only system applications can bind to it.</p></div><div class="sect3" title="Preparing the VPN"><div class="titlepage"><div><div><h3 class="title"><a id="preparing_the_vpn"/>Preparing the VPN</h3></div></div></div><p>To register a new VPN connection with the system, the application first calls <code class="literal">VpnService.prepare()</code> in order to be granted permission to run, and then calls the <code class="literal">establish()</code> method in order to create a network tunnel (discussed in the next section). The <code class="literal">prepare()</code> method returns an intent that’s used to start the warning dialog shown in <a class="xref" href="ch09.html#application-based_vpn_connection_warning" title="Figure 9-10. Application-based VPN connection warning dialog">Figure 9-10</a>. The dialog serves to obtain the user’s permission and ensure that only one VPN connection per user is running at any time. If <code class="literal">prepare()</code> is called while a VPN connection created by another application is running, that connection is terminated. The <code class="literal">prepare()</code> method saves the package name of the calling application, and only that application is allowed to start a VPN connection until the method is called again, or the system tears down the VPN connection (for example, if the VPN app’s process crashes). When a VPN connection is deactivated for any reason, the system calls the <code class="literal">onRevoke()</code> method of the current VPN application’s <code class="literal">VpnService</code> implementation.</p></div><div class="sect3" title="Establishing a VPN Connection"><div class="titlepage"><div><div><h3 class="title"><a id="establishing_a_vpn_connection"/>Establishing a VPN Connection</h3></div></div></div><p>After a VPN application has been prepared and granted permission to run, it can start its <code class="literal">VpnService</code> component, which would then typically create a tunnel to the VPN gateway and negotiate the network parameters for the VPN connection. Next, it sets up the <code class="literal">VpnService.Builder</code> class using those parameters and calls <code class="literal">VpnService.establish()</code> in order to receive a file descriptor to read and write packets. The <code class="literal">establish()</code> method first ensures that it’s being called by the application currently granted permission to establish a VPN connection by comparing the UID of the caller to the granted application’s UID. <code class="literal">establish()</code> then checks whether the current Android user is allowed to create VPN connections, and verifies that the service requires the <code class="literal">BIND_VPN_SERVICE</code> permission; if the service doesn’t require that permission, it’s considered insecure and a <code class="literal">SecurityException</code> is thrown. Next, the <code class="literal">establish()</code> method creates and configures a tunnel interface using native code, and sets up routing and DNS servers.</p></div><div class="sect3" title="Notifying the User About the VPN Connection"><div class="titlepage"><div><div><h3 class="title"><a id="notifying_the_user_about_the_vpn_connect"/>Notifying the User About the VPN Connection</h3></div></div></div><p>The last step in establishing a VPN connection is to show an ongoing notification that tells the user that network traffic is been tunneled through a VPN, which allows them to monitor and control the connection via the associated control dialog. The dialog for the OpenVPN for Android application is shown in <a class="xref" href="ch09.html#application-based_vpn_management_dialog" title="Figure 9-11. Application-based VPN management dialog">Figure 9-11</a>.</p><p><a id="iddle1754" class="indexterm"/><a id="iddle2142" class="indexterm"/><a id="iddle2260" class="indexterm"/><a id="iddle2262" class="indexterm"/><a id="iddle2273" class="indexterm"/><a id="iddle3093" class="indexterm"/><a id="iddle3095" class="indexterm"/>This dialog is part of the dedicated package <code class="literal">com.android.vpndialogs</code>, which is the only package explicitly allowed to manage application-based VPN connections, other than the <span class="emphasis"><em>system</em></span> user. This ensures that a VPN connection can only be started and managed via the system-mandated UI.</p><p>Using the application-based VPN framework, applications are free to implement network tunneling, with any required authentication and encryption methods. Because all packets the device sends or receives pass through the VPN application, it can be used not only for tunneling but also for traffic logging, filtering, or modification (such as removing advertisements).</p><div class="note" title="Note"><h3 class="title"><a id="ch09note04"/>Note</h3><p><span class="emphasis"><em>For a full-featured implementation of an application-based VPN that takes advantage of Android’s credential store to manage authentication keys and certificates, see the source code for OpenVPN for Android.</em></span><sup>[<a id="ch09fn07" href="#ftn.ch09fn07" class="footnote">93</a>]</sup> <span class="emphasis"><em>This application implements an SSL VPN client that is fully compatible with the OpenVPN server.</em></span></p></div></div></div><div class="sect2" title="Multi-User Support"><div class="titlepage"><div><div><h2 class="title"><a id="multi-user_support-id00019"/>Multi-User Support</h2></div></div></div><p>As mentioned earlier, on multi-user devices, legacy VPNs can be controlled only by the owner user. However, with its introduction of multi-user support, Android 4.2 and higher allows all secondary users (with the exception of restricted profiles, which must share the primary user’s VPN connection) to start application-based VPNs. While this change technically allowed each user to start their own VPN, because only one application-based VPN could be activated at a time, traffic for all device users was routed through the currently active VPN regardless of who started it. Android 4.4 finally brought full multi-user VPN support by introducing <span class="emphasis"><em>per-user VPN</em></span>, which allows traffic from any user to be routed through their VPN, thus isolating it from other users’ traffic.</p><div class="sect3" title="Linux Advanced Routing"><div class="titlepage"><div><div><h3 class="title"><a id="linux_advanced_routing"/>Linux Advanced Routing</h3></div></div></div><div class="figure"><a id="application-based_vpn_management_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00048"/><img src="figs/web/09fig11.png.jpg" alt="Application-based VPN management dialog"/></div></div><p class="title">Figure 9-11. Application-based VPN management dialog</p></div><p>Android uses several advanced packet filtering and routing features of the Linux kernel in order to implement per-user VPNs. These features (implemented by the <span class="emphasis"><em>netfilter</em></span> kernel framework) include the <span class="emphasis"><em>owner</em></span> module <a id="iddle2193" class="indexterm"/><a id="iddle2261" class="indexterm"/><a id="iddle2274" class="indexterm"/><a id="iddle3094" class="indexterm"/>of the Linux <span class="emphasis"><em>iptables</em></span> tool, which allows matching of locally generated packets based on the UID, GID, or PID of the process that created them. For example, the command shown at ➊ in <a class="xref" href="ch09.html#using_owner_matching_and_packet_marking" title="Example 9-12. Using owner matching and packet marking with iptables">Example 9-12</a> creates a packet-filtering rule that drops all outgoing packets generated by the user with UID 1234.</p><div class="example"><a id="using_owner_matching_and_packet_marking"/><p class="title">Example 9-12. Using owner matching and packet marking with <span class="roman">iptables</span></p><div class="example-contents"><pre class="programlisting"># iptables -A OUTPUT -m owner --uid-owner 1234 -j DROP➊
# iptables -A PREROUTING -t mangle -p tcp --dport 80 -j MARK --set-mark 0x1➋
# ip rule add fwmark 0x1 table web➌
# ip route add default via 1.2.3.4 dev em3 table web➍</pre></div></div><p>Another important netfilter feature is the ability to mark packets that match a certain selector with a specified number (called a <span class="emphasis"><em>mark</em></span>). For example, the rule at ➋ marks all packets destined for port 80 (which is typically used by a web server) with the mark 0x1. This mark can then be matched in later filtering or routing rules in order to, for example, send marked packets through a particular interface by adding a routing rule that sends marked packets to a predefined routing table, which is <span class="emphasis"><em>web</em></span> in our example ➌. Finally, a route that sends packets matching the <span class="emphasis"><em>web</em></span> table to the <span class="emphasis"><em>em3</em></span> interface can be added with the command shown at ➍.</p></div><div class="sect3" title="Multi-User VPN Implementation"><div class="titlepage"><div><div><h3 class="title"><a id="multi-user_vpn_implementation"/>Multi-User VPN Implementation</h3></div></div></div><p>Android uses these packet filtering and routing features to mark packets originating from all apps of a particular Android user and send them through the tunneling interface created by the VPN app started by that user. When the owner user starts a VPN, that VPN is shared with any restricted profiles on the device that cannot start their own VPNs by matching all packets originating from restricted profiles and routing them through the owner’s VPN tunnel.</p><p>This split-routing is implemented at the framework level by the <code class="literal">NetworkManagementService</code>, which provides APIs to manage package matching and routing by UID or UID range. <code class="literal">NetworkManagementService</code> implements those APIs by sending commands to the native <span class="emphasis"><em>netd</em></span> daemon which runs as root, and thus can modify the kernel’s packet filtering and routing tables. <span class="emphasis"><em>netd</em></span> manipulates the kernel’s filtering and routing configuration by calling the <span class="emphasis"><em>iptables</em></span> and <span class="emphasis"><em>ip</em></span> userland utilities.</p><p>Let’s illustrate Android’s per-user VPN routing with an example as shown in <a class="xref" href="ch09.html#packet_matching_rules_for_vpns_started_b" title="Example 9-13. Packet matching rules for VPNs started by two different device users">Example 9-13</a>. The primary user (user ID 0) and the first secondary user (user ID 10) have each started an application-based VPN. The owner user’s VPN is assigned the <span class="emphasis"><em>tun0</em></span> tunneling interface, and the secondary user’s VPN is assigned the <span class="emphasis"><em>tun1</em></span> interface. The device also has a restricted profile with user ID 13. <a class="xref" href="ch09.html#packet_matching_rules_for_vpns_started_b" title="Example 9-13. Packet matching rules for VPNs started by two different device users">Example 9-13</a> shows the state of the kernel’s packet filtering tables when both VPNs are connected (with some details omitted).</p><div class="example"><a id="packet_matching_rules_for_vpns_started_b"/><p class="title">Example 9-13. Packet matching rules for VPNs started by two different device users</p><div class="example-contents"><pre class="programlisting"><span class="strong"><strong># iptables -t mangle -L –n</strong></span>
--<span class="emphasis"><em>snip</em></span>--
Chain st_mangle_OUTPUT (1 references)
target     prot opt source               destination
RETURN     all  --  0.0.0.0/0            0.0.0.0/0           mark match 0x1➊
RETURN     all  --  0.0.0.0/0            0.0.0.0/0           owner UID match 1016➋
--<span class="emphasis"><em>snip</em></span>--
st_mangle_tun0_OUTPUT  all  --  0.0.0.0/0           0.0.0.0/0           [goto] owner UID match
0-99999➌
st_mangle_tun0_OUTPUT  all  --  0.0.0.0/0           0.0.0.0/0           [goto] owner UID match
1300000-1399999➍
st_mangle_tun1_OUTPUT  all  --  0.0.0.0/0           0.0.0.0/0           [goto] owner UID match
1000000-1099999➎

Chain st_mangle_tun0_OUTPUT (3 references)
target     prot opt source               destination
MARK       all  --  0.0.0.0/0            0.0.0.0/0           MARK and 0x0
MARK       all  --  0.0.0.0/0            0.0.0.0/0           MARK set 0x3c➏

Chain st_mangle_tun1_OUTPUT (2 references)
target     prot opt source               destination
MARK       all  --  0.0.0.0/0            0.0.0.0/0           MARK and 0x0
MARK       all  --  0.0.0.0/0            0.0.0.0/0           MARK set 0x3d➐</pre></div></div><p>Outgoing packets are first sent to the <span class="emphasis"><em>st_mangle_OUTPUT</em></span> chain, which is responsible for matching and marking packets. Packets exempt from peruser routing (those already marked with 0x1 ➊), and packets originating from legacy VPNs (UID 1016 ➋, assigned to the built-in <span class="emphasis"><em>vpn</em></span> user, which both <span class="emphasis"><em>mtd</em></span> and <span class="emphasis"><em>racoon</em></span> run as) pass without modification.</p><p>Next, packets created by processes running with UIDs between 0 and 99999 (the range of UIDs assigned to apps started by the primary user, as discussed in <a class="xref" href="ch04.html" title="Chapter 4. User Management">Chapter 4</a>) are matched and sent to the <span class="emphasis"><em>st_mangle_tun0_ OUTPUT</em></span> chain ➌. Packets originating from UIDs 1300000–1399999, the range assigned to our restricted profile (user ID 13), are sent to the same chain ➍. Thus, traffic originating from the owner user and the restricted profile is treated the same way. Packets originating from the first secondary user (user ID 10, UID range 1000000-1099999) are, however, sent to a different chain, <span class="emphasis"><em>st_mangle_tun1_OUTPUT</em></span> ➎. The target chains themselves are simple: <span class="emphasis"><em>st_mangle_tun0_OUTPUT</em></span> first clears the packet mark and then marks them with <span class="emphasis"><em>0x3c</em></span> ➏; <span class="emphasis"><em>st_mangle_tun1_OUTPUT</em></span> does the same but uses the mark <span class="emphasis"><em>0x3d</em></span> ➐. After packets have been marked, the marks are used to implement and match different routing rules, as shown in <a class="xref" href="ch09.html#routing_rules_for_vpns_started_by_two_di" title="Example 9-14. Routing rules for VPNs started by two different device users">Example 9-14</a>.</p><div class="example"><a id="routing_rules_for_vpns_started_by_two_di"/><p class="title">Example 9-14. Routing rules for VPNs started by two different device users</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ip rule ls</strong></span>
0:      from all lookup local
100:    from all fwmark 0x3c lookup 60➊
100:    from all fwmark 0x3d lookup 61➋
--<span class="emphasis"><em>snip</em></span>--
# <span class="strong"><strong>ip route list table 60</strong></span>
default dev tun0 scope link➌
# <span class="strong"><strong>ip route list table 61</strong></span>
default dev tun1 scope link➍</pre></div></div><p><a id="iddle1672" class="indexterm"/><a id="iddle1745" class="indexterm"/><a id="iddle1770" class="indexterm"/><a id="iddle2194" class="indexterm"/><a id="iddle3106" class="indexterm"/><a id="iddle3118" class="indexterm"/><a id="iddle3119" class="indexterm"/><a id="iddle3130" class="indexterm"/><a id="iddle3134" class="indexterm"/>Notice that two rules that match each mark have been created, and that they’re associated with different routing tables. Packets marked with <span class="emphasis"><em>0x3c</em></span> go to routing table 60 (0x3c in hexadecimal ➊), while those marked with <span class="emphasis"><em>0x3d</em></span> go to table 61 (0x3d in hexadecimal ➋). Table 60 routes everything through the <span class="emphasis"><em>tun0</em></span> tunneling interface ➌, which was created by the owner user, and table 61 routes everything through the <span class="emphasis"><em>tun1</em></span> interface ➍, created by the secondary user.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note05"/>Note</h3><p><span class="emphasis"><em>While the VPN traffic routing method introduced in Android 4.4 offers greater flexibility and allows user VPN traffic to be isolated, as of this writing the implementation appears to have some problems, especially related to switching between different physical networks (for example, mobile to Wi-Fi or vice versa). Those problems should be addressed in future versions, possibly by modifying how packet filtering chains are associated with interfaces, but the basic implementation strategy is likely to remain the same.</em></span></p></div></div></div></div><div class="sect1" title="Wi-Fi EAP"><div class="titlepage"><div><div><h1 class="title"><a id="wi-fi_eap"/>Wi-Fi EAP</h1></div></div></div><p>Android supports different wireless network protocols, including Wi-Fi Protected Access (WPA) and Wi-Fi Protected Access II (WPA2), which are currently deployed on most wireless devices. Both protocols support a simple <span class="emphasis"><em>pre-shared key (PSK)</em></span> mode, also referred to as <span class="emphasis"><em>Personal mode</em></span>, in which all devices that access the network must be configured with the same 256-bit authentication key.</p><p>Devices can be configured either with the raw key bytes or with an ASCII passphrase that’s used to derive the authentication key using the PBKDF2 key derivation algorithm. While the PSK mode is simple, it doesn’t scale as the number of network users increases. If access for a certain user needs to be revoked, for example, the only way to cancel their network credentials is to change the shared passphrase, which would force all other users to reconfigure their devices. Additionally, as there is no practical way to distinguish users and devices, it is difficult to implement flexible access rules or accounting.</p><p>To address this problem, both WPA and WPA2 support the IEEE 802.1X network access control standard, which offers an encapsulation of the Extensible Authentication Protocol (EAP). Authentication in a wireless network that uses 802.1X and involves a supplicant, an authenticator, and an authentication server is shown in <a class="xref" href="ch09.html#eight02dot1x_authentication_participants" title="Figure 9-12. 802.1X authentication participants">Figure 9-12</a>.</p><div class="figure"><a id="eight02dot1x_authentication_participants"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00049"/><img src="figs/web/09fig12.png.jpg" alt="802.1X authentication participants"/></div></div><p class="title">Figure 9-12. 802.1X authentication participants</p></div><p><a id="iddle1676" class="indexterm"/><a id="iddle1680" class="indexterm"/><a id="iddle1748" class="indexterm"/><a id="iddle2434" class="indexterm"/><a id="iddle2521" class="indexterm"/><a id="iddle3109" class="indexterm"/>The <span class="emphasis"><em>supplicant</em></span> is a wireless device such as an Android phone that wants to connect to the network, and the <span class="emphasis"><em>authenticator</em></span> is the gateway to the network that validates the supplicant’s identity and provides authorization. In a typical Wi-Fi configuration, the authenticator is the wireless access point (AP). The <span class="emphasis"><em>authentication server</em></span>, typically a RADIUS server, verifies client credentials and decides whether they should be granted access based on a preconfigured access policy.</p><p>Authentication is implemented by exchanging EAP messages between the three nodes. These are encapsulated in a format suitable for the medium connecting each two nodes: EAP over LAN (EAPOL) between the supplicant and the authenticator, and RADIUS between the authenticator and the authentication server.</p><p>Because EAP is an authentication framework that supports different concrete authentication types and not a concrete authentication mechanism, the supplicant and authentication server (with the help of the authenticator) need to negotiate a commonly supported authentication method before authentication can be performed. There are various standard and proprietary EAP authentication methods, and current Android versions support most of the methods used in wireless networks.</p><p>The sections below offer a brief overview of the EAP authentication methods that Android supports, and show how it protects credentials for each method. We’ll also demonstrate how to configure access to a Wi-Fi network that uses EAP for authentication using Android’s wireless network management APIs.</p><div class="sect2" title="EAP Authentication Methods"><div class="titlepage"><div><div><h2 class="title"><a id="eap_authentication_methods"/>EAP Authentication Methods</h2></div></div></div><p>As of version 4.4, Android supports the PEAP, EAP-TLS, EAP-TTLS, and EAP-PWD authentication methods. Before exploring how Android stores credentials for each authentication method, let’s briefly discuss how each one works.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>PEAP</strong></span></span></dt><dd><p>The Protected Extensible Authentication Protocol (PEAP) transmits EAP messages through an SSL connection in order to provide confidentiality and integrity. It uses PKI and a server certificate to authenticate the server and establish an SSL connection (Phase 1), but does not mandate how clients are authenticated. Clients are authenticated using a second, inner (Phase 2) authentication method, which is transmitted inside the SSL tunnel. Android supports the MSCHAPv2 (specified in PEAPv0<sup>[<a id="ch09fn08" href="#ftn.ch09fn08" class="footnote">94</a>]</sup>) and Generic Token Card (GTC, specified in PEAPv2<sup>[<a id="ch09fn09" href="#ftn.ch09fn09" class="footnote">95</a>]</sup>) methods for Phase 2 authentication.</p></dd><dt><span class="term"><span class="strong"><strong>EAP-TLS</strong></span></span></dt><dd><p><a id="iddle1674" class="indexterm"/><a id="iddle1677" class="indexterm"/><a id="iddle1678" class="indexterm"/><a id="iddle1679" class="indexterm"/><a id="iddle1684" class="indexterm"/><a id="iddle1687" class="indexterm"/><a id="iddle1691" class="indexterm"/><a id="iddle1747" class="indexterm"/><a id="iddle1772" class="indexterm"/><a id="iddle1776" class="indexterm"/><a id="iddle1778" class="indexterm"/><a id="iddle1918" class="indexterm"/><a id="iddle3108" class="indexterm"/><a id="iddle3132" class="indexterm"/>The EAP-Transport Layer Security (EAP-TLS) method<sup>[<a id="ch09fn10" href="#ftn.ch09fn10" class="footnote">96</a>]</sup> uses TLS for mutual authentication and was formerly the only EAP method certified for use with WPA Enterprise. EAP-TLS uses both a server certificate to authenticate the server to supplicants, and a client certificate that the authentication server verifies in order to establish supplicant identity. Granting network access requires issuing and distributing X.509 client certificates, and thus maintaining a public key infrastructure. Existing clients can be blocked from accessing the network by revoking their supplicant certificates. Android supports EAP-TLS and manages client keys and certificates using the system credential store.</p></dd><dt><span class="term"><span class="strong"><strong>EAP-TTLS</strong></span></span></dt><dd><p>Like EAP-TLS, the EAP-Tunneled Transport Layer Security (EAP-TTLS) protocol<sup>[<a id="ch09fn11" href="#ftn.ch09fn11" class="footnote">97</a>]</sup> is based on TLS. However, EAP-TTLS does not require client authentication using X.509 certificates. Clients can be authenticated either using a certificate during the handshake phase (Phase 1), or with another protocol during the tunnel phase (Phase 2). Android does not support authentication during Phase 1, but supports the PAP, MSCHAP, MSCHAPv2, and GTC protocols for Phase 2.</p></dd><dt><span class="term"><span class="strong"><strong>EAP-PWD</strong></span></span></dt><dd><p>The EAP-PWD authentication method<sup>[<a id="ch09fn12" href="#ftn.ch09fn12" class="footnote">98</a>]</sup> uses a shared password for authentication. Unlike legacy schemes that rely on a simple challenge-response mechanism, EAP-PWD is designed to be resistant to passive attacks, active attacks, and dictionary attacks. The protocol also provides forward secrecy and guarantees that even if a password is compromised, earlier sessions cannot be decrypted. EAP-PWD is based on discrete logarithm cryptography and can be implemented using either finite fields or elliptic curves.</p></dd></dl></div></div><div class="sect2" title="Android Wi-Fi Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="android_wi-fi_architecture"/>Android Wi-Fi Architecture</h2></div></div></div><p>Like most hardware support in Android, Android’s Wi-Fi architecture consists of a kernel layer (WLAN adapter driver modules), native daemon (<span class="emphasis"><em>wpa_supplicant</em></span>), a Hardware Abstraction Layer (HAL), system services, and a system UI. Wi-Fi adapter kernel drivers are usually specific to the system on a chip (SoC) that an Android device is built upon, and are typically closed source and loaded as kernel modules. The <span class="emphasis"><em>wpa_supplicant</em></span><sup>[<a id="ch09fn13" href="#ftn.ch09fn13" class="footnote">99</a>]</sup> is a WPA supplicant daemon that implements key negotiation with a WPA authenticator and <a id="iddle1681" class="indexterm"/><a id="iddle1749" class="indexterm"/><a id="iddle3110" class="indexterm"/><a id="iddle3117" class="indexterm"/><a id="iddle3120" class="indexterm"/><a id="iddle3121" class="indexterm"/>controls 802.1X association of the WLAN driver. However, Android devices rarely include the original <span class="emphasis"><em>wpa_supplicant</em></span> code; the included implementation is often modified for better compatibility with the underlying SoC.</p><p>The HAL is implemented in the <span class="emphasis"><em>libharware_legacy</em></span> native library and is responsible for relaying commands from the framework to <span class="emphasis"><em>wpa_supplicant</em></span> via its control socket. The system service that controls Wi-Fi connectivity is <code class="literal">WifiService</code>, which offers a public interface via the <code class="literal">WifiManager</code> facade class. The <code class="literal">WifiService</code> delegates Wi-Fi state management to a rather complex <code class="literal">WifiStateMachine</code> class, which can go through more than a dozen states while connecting to a wireless network.</p><p>WLAN connectivity is controlled via the Wi-Fi screen of the system Settings app, and connectivity status is displayed in the status bar and Quick Settings, both of which are part of the SystemUI package.</p><p>Android stores Wi-Fi-related configuration files in the <span class="emphasis"><em>/data/misc/wifi/</em></span> directory because wireless connectivity daemons persist configuration changes directly to disk and thus need a writable directory. The directory is owned by the <span class="emphasis"><em>wifi</em></span> user (UID 1010), which is also the user that the <span class="emphasis"><em>wpa_supplicant</em></span> runs as. Configurations files, including <span class="emphasis"><em>wpa_supplicant.conf</em></span>, have permissions set to 0660 and are owned by the <span class="emphasis"><em>system</em></span> user, and their group is set to <span class="emphasis"><em>wifi</em></span>. This ensures that both system applications and the supplicant daemon can read and modify configurations files, but they are not accessible to other applications. The <span class="emphasis"><em>wpa_supplicant.conf</em></span> file contains configuration parameters formatted as key-value pairs, both global and specific to a particular network. Network-specific parameters are enclosed in network blocks, which may look like <a class="xref" href="ch09.html#psk_network_configuration_block_in_wpaun" title="Example 9-15. PSK network configuration block in wpa_supplicant.conf">Example 9-15</a> for a PSK configuration.</p><div class="example"><a id="psk_network_configuration_block_in_wpaun"/><p class="title">Example 9-15. PSK network configuration block in <span class="roman">wpa_supplicant.conf</span></p><div class="example-contents"><pre class="programlisting">network={
    ssid="psk-ap"➊
    key_mgmt=WPA-PSK➋
    psk="password"➌
    priority=805➍
}</pre></div></div><p>As you can see, the <code class="literal">network</code> block specifies the network SSID ➊, authentication key management protocol ➋, the pre-shared key itself ➌, and a priority value ➍. The PSK is saved in plaintext, and while the <span class="emphasis"><em>wpa_supplicant.conf</em></span> access bits disallow non-system applications from accessing it, it can be easily extracted from devices that allow root access.</p></div><div class="sect2" title="EAP Credentials Management"><div class="titlepage"><div><div><h2 class="title"><a id="eap_credentials_management"/>EAP Credentials Management</h2></div></div></div><p>In this section, we’ll examine how Android manages Wi-Fi credentials for each of the supported EAP authentication methods and discuss the Android-specific <span class="emphasis"><em>wpa_supplicant</em></span> changes that allow the supplicant daemon to take advantage of Android’s system credential store.</p><p><a class="xref" href="ch09.html#peap_network_configuration_block_in_wpau" title="Example 9-16. PEAP network configuration block in wpa_supplicant.conf">Example 9-16</a> shows the network block in <span class="emphasis"><em>wpa_supplicant.conf</em></span> for a network configured to use PEAP.</p><div class="example"><a id="peap_network_configuration_block_in_wpau"/><p class="title">Example 9-16. PEAP network configuration block in <span class="roman">wpa_supplicant.conf</span></p><div class="example-contents"><pre class="programlisting">network={
    ssid="eap-ap"
    key_mgmt=WPA-EAP IEEE8021X➊
    eap=PEAP➋
    identity="android1"➌
    anonymous_identity="anon"
    password="password"➍
    ca_cert="keystore://CACERT_eapclient"➎
    phase2="auth=MSCHAPV2"➏
    proactive_key_caching=1
}</pre></div></div><p><a id="iddle1688" class="indexterm"/><a id="iddle1773" class="indexterm"/><a id="iddle2435" class="indexterm"/><a id="iddle2522" class="indexterm"/>Here, the key management mode is set to <span class="emphasis"><em>WPA-EAP IEEE8021X</em></span> ➊, the EAP method to <span class="emphasis"><em>PEAP</em></span> ➋, and Phase 2 authentication to MSCHAPv2 ➏. Credentials, namely the identity ➌ and password ➍, are stored in plaintext in the configuration file, as they are in PSK mode.</p><p>One notable difference from a general-purpose <span class="emphasis"><em>wpa_supplicant.conf</em></span> is the format of the CA certificate path ➎. The CA certificate path (<span class="emphasis"><em>ca_cert</em></span>) is used when validating the server certificate, and in Android <span class="emphasis"><em>ca_cert</em></span> is in a URI-like format with the <span class="emphasis"><em>keystore</em></span> scheme. This Android-specific extension allows the <span class="emphasis"><em>wpa_supplicant</em></span> daemon to retrieve certificates from the system credential store. When the daemon encounters a certificate path that starts with <span class="emphasis"><em>keystore://</em></span>, it connects to the <code class="literal">IKeystoreService</code> remote interface of the native <span class="emphasis"><em>keystore</em></span> service and retrieves the certificate bytes using the URI path as the key.</p><p>EAP-TLS configuration is similar to the PEAP one, as shown in <a class="xref" href="ch09.html#eap-tls_network_configuration_block_in_w" title="Example 9-17. EAP-TLS network configuration block in wpa_supplicant.conf">Example 9-17</a>.</p><div class="example"><a id="eap-tls_network_configuration_block_in_w"/><p class="title">Example 9-17. EAP-TLS network configuration block in <span class="roman">wpa_supplicant.conf</span></p><div class="example-contents"><pre class="programlisting">network={
    ssid="eap-ap"
    key_mgmt=WPA-EAP IEEE8021X
    eap=TLS
    identity="android1"
    ca_cert="keystore://CACERT_eapclient"
    client_cert="keystore://USRCERT_eapclient"➊
    engine_id="keystore"➋
    key_id="USRPKEY_eapclient"➌
    engine=1
    priority=803
    proactive_key_caching=1
}</pre></div></div><p>New here is the addition of a client certificate URI ➊, an engine ID ➋, and a key ID ➌. The client certificate is retrieved from the system credential store, just like the CA certificate. The engine ID refers to the OpenSSL engine that should be used for cryptographic operations when connecting to the SSID configured in the <code class="literal">network</code> block. The <span class="emphasis"><em>wpa_supplicant</em></span> has native <a id="iddle1685" class="indexterm"/><a id="iddle1692" class="indexterm"/><a id="iddle1777" class="indexterm"/><a id="iddle1779" class="indexterm"/>support for configurable OpenSSL engines, and is often used with an PKCS#11 engine in order to use keys stored in a smart card or other hardware device.</p><p>As discussed in <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a>, Android’s <span class="emphasis"><em>keystore</em></span> engine uses keys stored in the system credential store. If a device supports hardware-backed credential storage, the <span class="emphasis"><em>keystore</em></span> engine can transparently take advantage of it by virtue of the intermediate <span class="emphasis"><em>keymaster</em></span> HAL module. The key ID in <a class="xref" href="ch09.html#eap-tls_network_configuration_block_in_w" title="Example 9-17. EAP-TLS network configuration block in wpa_supplicant.conf">Example 9-17</a> references the alias of the private key to use for authentication.</p><p>As of version 4.3, Android allows you to select the owner of private keys and certificates when importing them. Previously, all imported keys were owned by the <span class="emphasis"><em>system</em></span> user, but if you set the Credential use parameter to Wi-Fi in the import dialog (see <a class="xref" href="ch09.html#setting_the_credential_owner_to_wi-fi_in" title="Figure 9-13. Setting the credential owner to Wi-Fi in the PKCS#12 import dialog">Figure 9-13</a>), the key owner is set to the <span class="emphasis"><em>wifi</em></span> user (UID 1010), and the key can only be accessed by system components that run as the <span class="emphasis"><em>wifi</em></span> user, like <span class="emphasis"><em>wpa_supplicant</em></span>.</p><div class="figure"><a id="setting_the_credential_owner_to_wi-fi_in"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00050"/><img src="figs/web/09fig13.png.jpg" alt="Setting the credential owner to Wi-Fi in the PKCS#12 import dialog"/></div></div><p class="title">Figure 9-13. Setting the credential owner to Wi-Fi in the PKCS#12 import dialog</p></div><p>Because Android does not support client authentication when using the EAP-TTLS authentication method, the configuration only contains a CA certificate reference ➋, as shown in <a class="xref" href="ch09.html#eap-ttls_network_configuration_block_in" title="Example 9-18. EAP-TTLS network configuration block in wpa_supplicant.conf">Example 9-18</a>. The password ➊ is stored in plaintext.</p><div class="example"><a id="eap-ttls_network_configuration_block_in"/><p class="title">Example 9-18. EAP-TTLS network configuration block in <span class="roman">wpa_supplicant.conf</span></p><div class="example-contents"><pre class="programlisting">network={
    ssid="eap-ap"
    key_mgmt=WPA-EAP IEEE8021X
    eap=TTLS
    identity="android1"
    anonymous_identity="anon"
    password="pasword"➊
    ca_cert="keystore://CACERT_eapclient"➋
    phase2="auth=GTC"
    proactive_key_caching=1
}</pre></div></div><p>The EAP-PWD method does not depend on TLS to establish a secure channel and thus requires no certificate configuration, as shown in <a class="xref" href="ch09.html#eap-pwd_network_configuration_block_in_w" title="Example 9-19. EAP-PWD network configuration block in wpa_supplicant.conf">Example 9-19</a>. Credentials are stored in plaintext (➊ and ➋), as with other configurations that use passwords.</p><div class="example"><a id="eap-pwd_network_configuration_block_in_w"/><p class="title">Example 9-19. EAP-PWD network configuration block in <span class="roman">wpa_supplicant.conf</span></p><div class="example-contents"><pre class="programlisting">network={
    ssid="eap-ap"
    key_mgmt=WPA-EAP IEEE8021X
    eap=PWD
    identity="android1"➊
    password="password"➋
    proactive_key_caching=1
}</pre></div></div><p><a id="iddle1104" class="indexterm"/><a id="iddle1365" class="indexterm"/><a id="iddle1673" class="indexterm"/><a id="iddle1689" class="indexterm"/><a id="iddle1746" class="indexterm"/><a id="iddle1774" class="indexterm"/><a id="iddle3107" class="indexterm"/><a id="iddle3113" class="indexterm"/><a id="iddle3116" class="indexterm"/>To sum up, configurations for all EAP methods that use a password for authentication store credential information in plaintext in the <span class="emphasis"><em>wpa_supplicant.conf</em></span> file. When using EAP-TLS, which relies on client authentication, the client key is stored in the system keystore, and thus offers the highest level of credential protection.</p></div><div class="sect2" title="Adding an EAP Network with WifiManager"><div class="titlepage"><div><div><h2 class="title"><a id="adding_an_eap_network_with_wifimanager"/>Adding an EAP Network with WifiManager</h2></div></div></div><p>While Android supports a number of WPA Enterprise authentication methods, setting them up properly might challenge some users because of the number of parameters that need to be configured and the need to install and select authentication certificates. Because Android’s official API for managing Wi-Fi networks, called <code class="literal">WifiManager</code>, did not support EAP configurations prior to Android 4.3, the only way to set up an EAP network was to add it via the system Settings app and configure it manually. Android 4.3 (API level 18) extended the <code class="literal">WifiManager</code> API to allow for programmatic EAP configuration, thus enabling automatic network provisioning in enterprise environments. In this section, we’ll show how to use <code class="literal">WifiManager</code> to add an EAP-TLS network and discuss the underlying implementation.</p><p><code class="literal">WifiManager</code> allows an app that holds the <code class="literal">CHANGE_WIFI_STATE</code> permission (protection level <span class="emphasis"><em>dangerous</em></span>) to add a Wi-Fi network by initializing a <code class="literal">WifiConfiguration</code> instance with the network’s SSID, authentication algorithms, and credentials, and pass it to the <code class="literal">addNetwork()</code> method of <code class="literal">WifiManager</code>. Android 4.3 extends this API by adding an <code class="literal">enterpriseConfig</code> field of type <code class="literal">WifiEnterpriseConfig</code> to the <code class="literal">WifiConfiguration</code> class, which allows you to configure the EAP authentication method to use, client and CA certificates, the Phase 2 authentication method (if any), and additional credentials such as username and password. <a class="xref" href="ch09.html#adding_an_eap-tls_network_using_wifimana" title="Example 9-20. Adding an EAP-TLS network using WifiManager">Example 9-20</a> shows how to use this API to add a network that uses EAP-TLS for authentication.</p><div class="example"><a id="adding_an_eap-tls_network_using_wifimana"/><p class="title">Example 9-20. Adding an EAP-TLS network using <code class="literal">WifiManager</code></p><div class="example-contents"><pre class="programlisting">X509Certificate caCert = getCaCert();
PrivateKey clientKey = getClientKey();
X509Certificate clientCert = getClientCert();

WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
enterpriseConfig.setCaCertificate(caCert);➊
enterpriseConfig.setClientKeyEntry(clientKey, clientCert);➋
enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);➌
enterpriseConfig.setPhase2Method(WifiEnterpriseConfig.Phase2.NONE);➍
enterpriseConfig.setIdentity("android1");➎
WifiConfiguration config = new WifiConfiguration();
config.enterpriseConfig = enterpriseConfig;➏
config.SSID = "\"eap-ap\"";
config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.IEEE8021X);➐
config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_EAP);➑

int netId = wm.addNetwork(config);➒
if (netId != -1) {
    boolean success = wm.saveConfiguration();➓
}</pre></div></div><p><a id="iddle1690" class="indexterm"/><a id="iddle1775" class="indexterm"/><a id="iddle3115" class="indexterm"/>In order to set up EAP-TLS authentication, we first need to obtain the CA certificate used to verify the server’s identity, and the client’s private key and certificate. Because these are typically distributed as a PKCS#12 file, we can use a <code class="literal">KeyStore</code> of type <span class="emphasis"><em>PKCS12</em></span> to extract them (not shown). (Android will automatically import the specified keys and certificates into the system keystore when you add an EAP profile that uses them, so you don’t need to import the PKCS#12 file.) After we have the CA certificate and client credentials, we set them to our <code class="literal">WifiEnterpriseConfig</code> instance using the <code class="literal">setCaCertificate()</code> ➊ and <code class="literal">setClientKeyEntry()</code> ➋ methods. We then set the EAP method to <code class="literal">Eap.TLS</code> ➌ and the Phase 2 method to <code class="literal">NONE</code> ➍, as EAP-TLS authenticates users as part of establishing an SSL connection (Phase 1). Android also requires us to set the identity ➎ even though it might not be used by the authentication server. After we’ve configured the <code class="literal">WifiEnterpriseConfig</code> object, we can add it to the main <code class="literal">WifiConfiguration</code> instance ➏. The set of key management protocols also needs to be configured (➐ and ➑) because it defaults to WPA PSK. Finally, we can add the network ➒ and save the configuration ➓, which updates the <span class="emphasis"><em>wpa_supplicant.conf</em></span> file to include the newly configured network.</p><p>Android automatically generates aliases for the configured private key and certificates, and then imports the PKI credentials into the system keystore. The aliases are based on the AP name, key management scheme, and EAP authentication method. A programmatically configured network is automatically shown in the Wi-Fi screen of the system Settings application, and might look like <a class="xref" href="ch09.html#eap-tls_network_added_using_wifimanager" title="Figure 9-14. An EAP-TLS network added using WifiManager">Figure 9-14</a> for the example shown in <a class="xref" href="ch09.html#adding_an_eap-tls_network_using_wifimana" title="Example 9-20. Adding an EAP-TLS network using WifiManager">Example 9-20</a>.</p><div class="figure"><a id="eap-tls_network_added_using_wifimanager"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00051"/><img src="figs/web/09fig14.png.jpg" alt="An EAP-TLS network added using WifiManager"/></div></div><p class="title">Figure 9-14. An EAP-TLS network added using <code class="literal">WifiManager</code></p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00020"/>Summary</h1></div></div></div><p>Android supports a Device Administration API that allows device administration apps to configure a security policy, which can include requirements for lockscreen password complexity, device encryption, and camera usage. Device administrators are often used with corporate accounts, such as those for Microsoft Exchange and Google Apps, in order to limit access to corporate data based on the policy and device settings. The Device Administration API also provides features that enable remote device locking and data wipe.</p><p>Android devices can connect to various types of VPNs, including PPTP, L2TP/IPSec, and SSL-based VPNs. Support for PPTP and L2TP/IPSec is built into the platform and can only be extended through OS updates. Android 4.0 adds support for application-based VPNs, which allows third-party applications to implement custom VPN solutions.</p><p>In addition to the widely used pre-shared key Wi-Fi authentication mode, Android supports various WPA Enterprise configurations, namely PEAP, EAP-TLS, EAP-TTLS, and EAP-PWD. Certificates and private keys for EAP authentication methods that use SSL to establish a secure channel or authenticate users are stored in the system keystore and can use hardware protection when available. Wi-Fi networks that use EAP for authentication can be automatically provisioned using the <code class="literal">WifiManager</code> API in recent Android versions, beginning with Android 4.3.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch09fn01" href="#ch09fn01" class="para">87</a>] </sup>Google, <span class="emphasis"><em>Android APIs Reference</em></span>, “DeviceAdminInfo,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/reference/android/app/admin/DeviceAdminInfo.html">https://developer.android.com/reference/android/app/admin/DeviceAdminInfo.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn02" href="#ch09fn02" class="para">88</a>] </sup>Google, <span class="emphasis"><em>Android APIs Reference</em></span>, “DevicePolicyManager,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/reference/android/app/admin/DevicePolicyManager.html">https://developer.android.com/reference/android/app/admin/DevicePolicyManager.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn03" href="#ch09fn03" class="para">89</a>] </sup>Google, <span class="emphasis"><em>API Guides</em></span>, “Device Administration,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/guide/topics/admin/device-admin.html">https://developer.android.com/guide/topics/admin/device-admin.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn04" href="#ch09fn04" class="para">90</a>] </sup>OpenVPN Technologies, Inc, “OpenVPN Security Overview,” <span class="emphasis"><em><a class="ulink" href="http://openvpn.net/index.php/open-source/documentation/security-overview.html">http://openvpn.net/index.php/open-source/documentation/security-overview.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn05" href="#ch09fn05" class="para">91</a>] </sup>IPSec-Tools, <span class="emphasis"><em><a class="ulink" href="http://ipsec-tools.sourceforge.net/">http://ipsec-tools.sourceforge.net/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn06" href="#ch09fn06" class="para">92</a>] </sup>Google, <span class="emphasis"><em>Android APIs Reference</em></span>, “VpnService,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/reference/android/net/VpnService.html">https://developer.android.com/reference/android/net/VpnService.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn07" href="#ch09fn07" class="para">93</a>] </sup>Arne Schwabe, “Openvpn for Android 4.0+,” <span class="emphasis"><em><a class="ulink" href="https://code.google.com/p/ics-openvpn/">https://code.google.com/p/ics-openvpn/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn08" href="#ch09fn08" class="para">94</a>] </sup>Vivek Kamath, Ashwin Palekar, and Mark Woodrich, <span class="emphasis"><em>Microsoft’s PEAP version 0 (Implementation in Windows XP SP1)</em></span>, <span class="emphasis"><em><a class="ulink" href="https://tools.ietf.org/html/draft-kamath-pppext-peapv0-00/">https://tools.ietf.org/html/draft-kamath-pppext-peapv0-00/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn09" href="#ch09fn09" class="para">95</a>] </sup>Ashwin Palekar et al., <span class="emphasis"><em>Protected EAP Protocol (PEAP) Version 2</em></span>, <span class="emphasis"><em><a class="ulink" href="https://tools.ietf.org/html/draft-josefsson-pppext-eap-tls-eap-10/">https://tools.ietf.org/html/draft-josefsson-pppext-eap-tls-eap-10/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn10" href="#ch09fn10" class="para">96</a>] </sup>D. Simon, B. Aboba, and R. Hurst, <span class="emphasis"><em>The EAP-TLS Authentication Protocol, <a class="ulink" href="http://tools.ietf.org/html/rfc5216/">http://tools.ietf.org/html/rfc5216/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn11" href="#ch09fn11" class="para">97</a>] </sup>P. Funk and S. Blake-Wilson, <span class="emphasis"><em>Extensible Authentication Protocol Tunneled Transport Layer Security Authenticated Protocol Version 0 (EAP-TTLSv0)</em></span>, <span class="emphasis"><em><a class="ulink" href="https://tools.ietf.org/html/rfc5281/">https://tools.ietf.org/html/rfc5281/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn12" href="#ch09fn12" class="para">98</a>] </sup>D. Harkins and G. Zorn, <span class="emphasis"><em>Extensible Authentication Protocol (EAP) Authentication Using Only a Password</em></span>, <span class="emphasis"><em><a class="ulink" href="https://tools.ietf.org/html/rfc5931/">https://tools.ietf.org/html/rfc5931/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch09fn13" href="#ch09fn13" class="para">99</a>] </sup>Jouni Malinen, <span class="emphasis"><em>Linux WPA/WPA2/IEEE 802.1X Supplicant</em></span>, <span class="emphasis"><em><a class="ulink" href="http://hostap.epitest.fi/wpa_supplicant/">http://hostap.epitest.fi/wpa_supplicant/</a></em></span></p></div></div></div></body></html>