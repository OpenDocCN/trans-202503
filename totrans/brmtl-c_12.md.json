["```\n**#0  0x0000000000001136 in ?? ()**\n**#1  0x0000000000001150 in ?? ()**\n#2  0x0000000000001165 in ?? ()\n#3  0x000000000000117a in ?? ()\n#4  0x00007ffff7de50b3 in __libc_main (main=0x555555555168) at ../csu/libc-start.c:308\n#5  0x000000000000106e in ?? ()\n```", "```\n.text          0x0000000000001129       0x58 /tmp/cctwz0VM.o\n               **0x0000000000001129                three**\n **0x000000000000113e                two**\n               0x0000000000001153                one\n               0x0000000000001168                main\n```", "```\nint main() {\n   doIt(\"this goes in text too\");\n   return();\n}\n```", "```\nint anExample = 5;\n```", "```\nint uninitialized;\n```", "```\n$ **size example.o**\n   text   data    bss    dec    hex    filename\n    481      4      4    489    1e9    example.o\n```", "```\n/**\n * A program to demonstrate various types of variable\n * storage, so we can see what the linker does with them\n */\nint uninitializedGlobal;   // An uninitialized global (section bss)\nint initializedGlobal = 1; // An initialized global (section data)\nint initializedToZero = 0; // An initialized global (section bss)\n\n// aString -- initialized variable (section bss)\n// \"A string.\" -- constant (section text)\nconst char* aString = \"A string.\"; // String (pointing to ready-only data)\nstatic int uninitializedModule;    // An uninitialized module-only symbol\n                                   // (section bss)\nstatic int initializedModule = 2;  // An initialized module-only symbol\n                                   // (section data)\n\nint main()\n{\n    int uninitializedLocal;      // A local variable (section stack)\n    int initializedLocal = 1234; // An initialized local (section stack)\n\n static int uninitializedStatic;      // \"Uninitialized\" static (section bss)\n    static int initializedStatic = 5678; // Initialized static (section data)\n\n    while (1)\n        continue; // Not much logic here\n}\n```", "```\nint initializedGlobal = 1; // An initialized global (section data)\n\n  16                            .global initializedGlobal\n  17                            .data\n  18                            .align  2\n  21                    initializedGlobal:\n  22 0000 01000000              .word   1\n```", "```\nint initializedToZero = 0; // An initialized global (section bss)\n\n  23                            .global initializedToZero\n  24                            .bss\n  25                            .align  2\n  28                    initializedToZero:\n  29 0000 00000000              .space  4\n```", "```\nint uninitializedGlobal; // An uninitialized global (section bss)\n\n  15                            .comm   uninitializedGlobal,4,4\n```", "```\nconst char* aString = \"A string.\"; // String (pointing to read-only data)\n\n  30                            .global aString\n  31                            .section        .rodata\n  32                            .align  2\n  33                    .LC0:\n  34 0000 41207374              .ascii  \"A string.\\000\"\n  34      72696E67\n  34      2E00\n  35                            .data\n  36                            .align  2\n  39                    aString:\n  40 0004 00000000              .word   .LC0\n```", "```\nint main()\n\n  52                            .section        .text.main,\"ax\",%progbits\n  53                            .align  1\n  54                            .global main\n  60                    main:\n  67 0000 80B5                  push    {r7, lr}\n```", "```\nstatic int initializedModule = 2; // An initialized module-only symbol\n                                  // (section data)\n\n  46                            .data\n  47                            .align  2\n  50                    initializedModule:\n  51 0008 02000000              .word  2\n```", "```\nstatic int uninitializedModule; // An uninitialized module-only symbol\n                                // (section bss)\n\n  41                            .bss\n  42                            .align  2\n  43                    uninitializedModule:\n  44 0004 00000000              .space  4\n```", "```\nstatic int uninitializedStatic; // \"Uninitialized\" static (section bss)\n\n  94                            .bss\n  95                            .align  2\n  96                    uninitializedStatic.4108:\n  97 0008 00000000              .space  4\n```", "```\nstatic int initializedStatic = 5678; // Initialized static (section data)\n\n  88                            .data\n  89                            .align  2\n  92                    initializedStatic.4109:\n  93 000c 2E160000              .word  5678\n```", "```\n131                       .section .isr_vector,\"a\",%progbits\n134                    \n135                    \n136                    g_pfnVectors:\n137 0000 00000000        .word  _estack\n138 0004 00000000        .word  Reset_Handler\n139 0008 00000000        .word  NMI_Handler\n140 000c 00000000        .word  HardFault_Handler\n```", "```\nint initializedGlobal = 1234;\n```", "```\n52                  .section    .text.main,\"ax\",%progbits\n`--snip--`\n60                  main:\n61                  .LFB0:\n`--snip--`\n67 0000 80B5            push    {r7, lr}\n```", "```\ns_sin.o\ns_tan.o\ns_tanh.o\ns_fpclassify.o\ns_trunc.o\ns_remquo.o\n`--snip--`\n```", "```\nMemory Configuration\n\nName             Origin             Length             Attributes\nFLASH            0x0000000008000000 0x0000000000010000 xr\nRAM              0x0000000020000000 0x0000000000002000 xrw\n*default*        0x0000000000000000 0xffffffffffffffff\n```", "```\n.isr_vector     0x0000000008000000       0xc0\n```", "```\n.text.main     0x0000000008000138       0x60 src/main.o\n                0x0000000008000138                main\n```", "```\n COMMON         0x0000000020000464        0x4 src/main.o\n                0x0000000020000464        uninitializedGlobal\n```", "```\nFATAL ERROR: Address  0x0000000008000158\n```", "```\nD> x/4 20000464\n0x20000464:   1234    0x4D2\n```", "```\nstatic uint32_t resetCount __attribute__((section(.config)) = 0;\n```", "```\nMEMORY\n{\n    FLASH (rx)     : ORIGIN = 0x8000000, LENGTH = 64K\n    RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 8K\n}\n```", "```\nMEMORY\n{\n    FLASH (rx)     : ORIGIN = 0x8000000,       LENGTH = 60K\n    CONFIG (rw)    : ORIGIN = 0x8000000 + 60K, LENGTH = 4K\n    RAM (xrw)      : ORIGIN = 0x20000000,      LENGTH = 8K\n}\n```", "```\n{\n   . = ALIGN(4);\n   *(.config*)\n} >CONFIG\n```", "```\n++resetCount;\n```", "```\n/**\n * Update the resetCounter.\n *\n * In C this would be ++resetCount. Because we are dealing\n * with flash, this is a much more difficult operation.\n */\nstatic HAL_StatusTypeDef updateCounter(void) {\n  1 HAL_FLASH_Unlock(); // Allow flash to be modified.\n 2 uint32_t newResetCount = resetCount + 1;  // Next value for reset count\n\n    uint32_t pageError = 0;     // Error indication from the erase operation\n\n    // Tell the flash system to erase resetCounter (and the rest of the page).\n  3 FLASH_EraseInitTypeDef eraseInfo = {  \n        .TypeErase = FLASH_TYPEERASE_PAGES,     // Going to erase one page\n        .PageAddress = (uint32_t)&resetCount,   // The start of the page\n        .NbPages = 1                            // One page to erase\n    };\n\n    // Erase the page and get the result.\n  4 HAL_StatusTypeDef result = HAL_FLASHEx_Erase(&eraseInfo, &pageError);\n    if (result != HAL_OK) {\n        HAL_FLASH_Lock();\n        return (result);\n    }\n\n    // Program the new reset counter into flash.\n    result = 5 HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,\n            (uint32_t)&resetCount, newResetCount);\n\n    HAL_FLASH_Lock();\n    return (result);\n}\n```", "```\n/**\n * @brief Write the number of times the system reset to the serial device.\n */\n#include <stdbool.h>\n#include \"stm32f0xx_nucleo.h\"\n#include \"stm32f0xx.h\"\n\nconst char message1[] = \"This system has been reset \";   // Part 1 of message\nconst char message2[] = \" times\\r\\n\";                    // Part 2 of message\nconst char many[] = \"many\";         // The word many\n// Number of times reset has been performed\nuint32_t resetCount __attribute__((section(\".config.keep\"))) = 0;\nint current; // The character in the message we are sending\n\nUART_HandleTypeDef uartHandle;      // UART initialization\n\n/**\n  * @brief This function is executed in case of error occurrence.\n  *\n  * All it does is blink the LED.\n  */\nvoid Error_Handler(void)\n{\n    /* Turn ED3 on. */\n    HAL_GPIO_WritePin(LED2_GPIO_PORT, LED2_PIN, GPIO_PIN_SET);\n\n    while (true)\n    {\n    // Toggle the state of LED2.\n        HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN);\n        HAL_Delay(1000);        // Wait one second.\n    }\n}\n/**\n * Send character to the UART.\n *\n * @param ch The character to send\n */\nvoid myPutchar(const char ch)\n{\n    // This line gets and saves the value of UART_FLAG_TXE at call\n    // time. This value changes, so if you stop the program on the \"if\"\n    // line below, the value will be set to zero because it goes away\n    // faster than you can look at it.\n    int result __attribute__((unused)) =\n        (uartHandle.Instance->ISR & UART_FLAG_TXE);\n\n    // Block until the transmit empty (TXE) flag is set.\n    while ((uartHandle.Instance->ISR & UART_FLAG_TXE) == 0)\n        continue;\n\n    uartHandle.Instance->TDR = ch;     // Send character to the UART.\n}\n\n/**\n * Send string to the UART.\n *\n * @param msg Message to send\n */\nstatic void myPuts(const char* const msg)\n{\n    for (unsigned int i = 0; msg[i] != '\\0'; ++i) {\n        myPutchar(msg[i]);\n    }\n}\n\n/**\n * Initialize LED2 (so we can blink red for error).\n */\nvoid led2_Init(void)\n{\n    // LED clock initialization\n    LED2_GPIO_CLK_ENABLE();\n\n    GPIO_InitTypeDef GPIO_LedInit;      // Initialization for the LED\n    // Initialize LED.\n    GPIO_LedInit.Pin = LED2_PIN;\n    GPIO_LedInit.Mode = GPIO_MODE_OUTPUT_PP;\n    GPIO_LedInit.Pull = GPIO_PULLUP;\n    GPIO_LedInit.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(LED2_GPIO_PORT, &GPIO_LedInit);\n}\n\n/**\n * Initialize UART2 for output.\n */\nvoid uart2_Init(void)\n{\n    // UART initialization\n    // UART2 -- one connected to ST-LINK USB\n    uartHandle.Instance = USART2;\n    uartHandle.Init.BaudRate = 9600;                    // Speed 9600\n    uartHandle.Init.WordLength = UART_WORDLENGTH_8B;    // 8 bits/character\n    uartHandle.Init.StopBits = UART_STOPBITS_1;         // One stop bit\n    uartHandle.Init.Parity = UART_PARITY_NONE;          // No parity\n    uartHandle.Init.Mode = UART_MODE_TX_RX;             // Transmit & receive\n    uartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;    // No hw control\n\n    // Oversample the incoming stream.\n    uartHandle.Init.OverSampling = UART_OVERSAMPLING_16;\n\n    // Do not use one-bit sampling.\n    uartHandle.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;\n\n    // Nothing advanced\n    uartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;\n    /*\n     * For those of you connecting a terminal emulator, the above parameters\n     * translate to 9600,8,N,1.\n     */\n\n    if (HAL_UART_Init(&uartHandle) != HAL_OK)\n    {\n        Error_Handler();\n    }\n}\n/**\n * Update the resetCounter.\n *\n * In C, this would be ++resetCounter. Because we are dealing\n * with flash, this is a much more difficult operation.\n */\nstatic HAL_StatusTypeDef updateCounter(void) {\n    HAL_FLASH_Unlock(); // Allow flash to be modified.\n    uint32_t newResetCount = resetCount + 1;    // Next value for reset count\n\n    uint32_t pageError = 0;     // Error indication from the erase operation\n    // Tell the flash system to erase resetCounter (and the rest of the page).\n    FLASH_EraseInitTypeDef eraseInfo = {\n        .TypeErase = FLASH_TYPEERASE_PAGES,     // Going to erase 1 page\n        .PageAddress = (uint32_t)&resetCount,   // The start of the page\n        .NbPages = 1                            // One page to erase\n    };\n\n    // Erase the page and get the result.\n    HAL_StatusTypeDef result = HAL_FLASHEx_Erase(&eraseInfo, &pageError);\n    if (result != HAL_OK) {\n        HAL_FLASH_Lock();\n        return (result);\n    }\n\n    // Program the new reset counter into flash.\n    result = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,\n            (uint32_t)&resetCount, newResetCount);\n\n    HAL_FLASH_Lock();\n    return (result);\n}\n\nint main(void)\n{\n    HAL_Init(); // Initialize hardware.\n    led2_Init();\n    uart2_Init();\n\n    myPuts(message1);\n\n    HAL_StatusTypeDef status = updateCounter();\n\n    switch (status) {\n        case HAL_FLASH_ERROR_NONE:\n            // Nothing, this is correct.\n            break;\n        case HAL_FLASH_ERROR_PROG:\n            myPuts(\"HAL_FLASH_ERROR_PROG\");\n            break;\n        case HAL_FLASH_ERROR_WRP:\n            myPuts(\"HAL_FLASH_ERROR_WRP\");\n            break;\n        default:\n            myPuts(\"**unknown error code**\");\n            break;\n    }\n    // A copout to avoid writing an integer to an ASCII function\n if (resetCount < 10)\n        myPutchar('0'+ resetCount);\n    else\n        myPuts(\"many\");\n\n    myPuts(message2);\n\n    for (;;) {\n        continue;       // Do nothing.\n    }\n}\n\n/**\n * Magic function that's called by the HAL layer to actually\n * initialize the UART. In this case, we need to put the UART pins in\n * alternate mode so they act as UART pins and not like GPIO pins.\n *\n * @note: Only works for UART2, the one connected to the USB serial\n * converter\n *\n * @param uart The UART information\n */\nvoid HAL_UART_MspInit(UART_HandleTypeDef* uart)\n{\n    GPIO_InitTypeDef GPIO_InitStruct;\n    if(uart->Instance == USART2)\n    {\n        /* Peripheral clock enable */\n        __HAL_RCC_USART2_CLK_ENABLE();\n\n        /*\n         * USART2 GPIO Configuration\n         * PA2     ------> USART2_TX\n         * PA3     ------> USART2_RX\n         */\n        GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;\n        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n        GPIO_InitStruct.Pull = GPIO_NOPULL;\n        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n        // Alternate function -- that of UART\n        GPIO_InitStruct.Alternate = GPIO_AF1_USART2;\n        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n    }\n\n}\n\n/**\n * Magic function called by HAL layer to de-initialize the\n * UART hardware. Something we never do, but we put this\n * in here for the sake of completeness.\n *\n * @note: Only works for UART2, the one connected to the USB serial\n * converter\n *\n * @param uart The UART information\n */\nvoid HAL_UART_MspDeInit(UART_HandleTypeDef* uart)\n{\n    if(uart->Instance == USART2)\n    {\n        /* Peripheral clock disable */\n        __HAL_RCC_USART2_CLK_DISABLE();\n\n        /*\n         * USART2 GPIO Configuration\n         * PA2     ------> USART2_TX\n         * PA3     ------> USART2_RX\n         */\n        HAL_GPIO_DeInit(GPIOA, GPIO_PIN_2|GPIO_PIN_3);\n    }\n}\n```", "```\nstruct config {\n    char name[16];    // Name of the unit\n    uint16_t sensors[10]; // The type of sensor connected to each input\n    uint32_t reportTime;  // Seconds between reports\n    // ... Lots of other stuff\n};\nstruct config theConfig __attribute__((section \".config\")); // The configuration\n\nstatic void updateReportTime(const uint32_t newReportTime) {\n\n    // <Prepare flash>\n\n    struct config currentConfig = config;\n    currentConfig.reportTime = newReportTime;\n\n // <Erase flash>\n    writeFlash(&config, &currentConfig, sizeof(currentConfig));\n\n    // <Lock flash>\n}\n```", "```\nMEMORY\n{\n    FLASH (rx)     : ORIGIN = 0x8000000,       LENGTH = 52K\n    LOGO (r)       : ORIGIN = 0x8000000 + 52K, LENGTH = 8K\n    CONFIG (rw)    : ORIGIN = 0x8000000 + 60K, LENGTH = 4K\n    RAM (xrw)      : ORIGIN = 0x20000000,      LENGTH = 8K\n}\n```", "```\nif ((bad checksum1) and (good checksum2)) use section2\nif ((good checksum1) and (bad checksum2)) use section1\nif (both good) use the section with the highest version number\nif (both bad) blink the emergency light; we're bricked\n```"]