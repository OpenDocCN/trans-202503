- en: '![](../images/pg272.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg272.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-27.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-27.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">UNSIGNED
    INTEGERS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">无符号整数</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'In this chapter, you’ll implement the unsigned counterparts to our two signed
    integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. You’ll
    extend the usual arithmetic conversions to handle unsigned integers and implement
    casts between signed and unsigned types. On the backend, you’ll use a few new
    assembly instructions to do unsigned integer arithmetic.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将实现我们两个有符号整数类型的无符号对等类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>。您将扩展通常的算术转换以处理无符号整数，并实现有符号和无符号类型之间的强制转换。在后端，您将使用一些新的汇编指令来进行无符号整数算术运算。
- en: In [Chapter 11](chapter11.xhtml), we focused on inferring and tracking type
    information in general; now we’ll be able to build on that work to add new types
    with relatively little effort. Before we modify the compiler, let’s start with
    a quick overview of conversions between signed and unsigned types.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 11 章](chapter11.xhtml) 中，我们集中讨论了推断和追踪类型信息；现在我们将能够在此基础上，利用相对较少的工作来添加新类型。在修改编译器之前，让我们先快速概述一下有符号和无符号类型之间的转换。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Type Conversions, Again</samp>'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">类型转换，再次说明</samp>'
- en: 'Every integer type conversion has two aspects we need to consider: how the
    integer’s value changes and how its binary representation changes. We saw this
    in the conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> in the previous
    chapter. Sign extension changes a signed integer’s representation from 32 to 64
    bits without changing its value. Truncating a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> also changes its
    representation, and it changes its value too if the original value can’t fit in
    the new type.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每种整数类型的转换都有两个方面需要考虑：整数值的变化以及其二进制表示的变化。我们在上一章中看到过 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 之间的转换。符号扩展将有符号整数的表示从
    32 位扩展到 64 位，而不改变其值。将 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    截断为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 也会改变其表示，如果原始值无法适应新类型，还会改变其值。
- en: With that distinction in mind, I’ll break our type conversions down into four
    cases. In each case, I’ll describe how the integer’s representation will change.
    Then, I’ll explain how that corresponds with the rules in the C standard about
    how its value should change.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个区分，我将把我们的类型转换分为四种情况。在每种情况下，我会描述整数的表示如何变化。然后，我会解释这些变化如何与 C 标准中有关其值变化的规则相对应。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    Signed and Unsigned Types of the Same Size</samp>
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在相同大小的有符号和无符号类型之间转换</samp>
- en: 'The first case is when we convert between signed and unsigned types of the
    same size: that is, between <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> or between
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. These conversions don’t change the binary representation of the integer.
    The only thing that changes is whether we use two’s complement to interpret its
    value. Let’s consider the effect of that change in interpretation.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个情况是当我们在相同大小的有符号和无符号类型之间转换时：即，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> 之间，或在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> 之间。这些转换不会改变整数的二进制表示。唯一改变的是我们是否使用二进制补码来解释其值。让我们考虑这种解释变化的影响。
- en: 'If a signed integer is positive, its upper bit will be 0, so interpreting it
    as an unsigned integer won’t change its value. The reverse is also true: if an
    unsigned integer is smaller than the maximum value the signed type can represent,
    its upper bit must be 0\. Therefore, if we reinterpret it using two’s complement,
    its value won’t change. As you learned in the previous chapter, when we convert
    an integer to a new type, the standard requires us to preserve its value if we
    can. We’re satisfying that requirement here.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个有符号整数为正数，则其最高位将为0，因此将其解释为无符号整数不会改变其值。反之亦然：如果一个无符号整数小于有符号类型能表示的最大值，则其最高位必定为0。因此，如果我们使用二进制补码重新解释它，其值将不会发生变化。正如你在上一章中学到的，当我们将整数转换为新类型时，标准要求我们尽可能保留其值。我们在这里满足了这一要求。
- en: That leaves integers whose upper bit is 1\. When we reinterpret a signed negative
    integer as unsigned, we change the upper bit’s value from negative to positive.
    If the upper bit is 1, this has the effect of adding 2*^N* to the value, where
    *N* is the number of bits in the type. This is exactly the behavior the standard
    requires; section 6.3.1.3, paragraph 2, states that if the value can’t be represented
    by the new type and the new type is unsigned, “the value is converted by repeatedly
    adding or subtracting one more than the maximum value that can be represented
    in the new type until the value is in the range of the new type.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了最高位为1的整数。当我们将一个有符号的负整数重新解释为无符号整数时，我们将最高位的值从负数变为正数。如果最高位是1，这会导致值增加2*^N*，其中*N*是该类型的位数。这正是标准所要求的行为；第6.3.1.3节第2段指出，如果新类型无法表示该值，并且新类型是无符号的，“则通过反复加或减去新类型能够表示的最大值加1，直到该值落入新类型的范围。”
- en: 'Conversely, converting an unsigned type with a leading 1 to the corresponding
    signed type will subtract 2*^N* from its value. This matches the implementation-defined
    behavior we chose in the last chapter for conversions to signed integers, following
    GCC: “The value is reduced modulo 2*^N* to be within range of the type.”'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，将一个带有前导1的无符号类型转换为相应的有符号类型将会从其值中减去2*^N*。这与我们在上一章中为有符号整数转换所选择的实现定义行为相符，遵循GCC：“该值会按2*^N*取模，以保持在类型范围内。”
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting unsigned
    int to a Larger Type</samp>
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将无符号整数转换为更大类型</samp>
- en: The second case is when we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> to a larger type, either <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. To handle
    this case, we’ll *zero extend* the integer by filling the upper bits of the new
    representation with zeros. This conversion always preserves the original value,
    since we’re just adding leading zeros to a positive number.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是当我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">无符号整数</samp>转换为更大类型时，可能是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">无符号长整数</samp>。处理这种情况时，我们会通过将新表示的高位填充为零来*零扩展*该整数。这种转换始终保留原始值，因为我们只是给正数添加了前导零。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting
    signed int to a Larger Type</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将有符号整数转换为更大类型</samp>'
- en: The third case is when we convert a signed <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. We already convert <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> using sign extension.
    We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> the same way. If
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is positive, sign
    extension will just add leading zeros, which preserves its value whether you interpret
    the result as signed or unsigned. If the value is negative, sign extending and
    then interpreting the result as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> will add 2^(64) to its value, as the standard requires.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个情况是我们将有符号的 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 转换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>。我们已经使用符号扩展将 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>。我们将以相同的方式将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 是正数，符号扩展将只会添加前导零，无论你将结果解释为有符号还是无符号，它的值都将保持不变。如果值是负数，符号扩展后再将结果解释为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> 将会向它的值添加 2^(64)，这是标准要求的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting from Larger
    to Smaller Types</samp>
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从较大类型转换到较小类型</samp>
- en: In the final case, we convert a larger type (<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>) to a smaller
    one (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>). We always handle this case by truncating the value. This has the
    effect of adding or subtracting 2^(32) until the value is in the range of the
    new type—or, equivalently, reducing the value modulo 2^(32)—which is the behavior
    we want. I won’t walk you through why truncating the integer produces the correct
    value in every case; you can work through some examples on your own, or just take
    my word for it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况中，我们将较大的类型（<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>）转换为较小的类型（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>）。我们总是通过截断值来处理这种情况。这样会添加或减去 2^(32)，直到值落入新类型的范围——或者等效地，减少值对 2^(32) 取模——这就是我们想要的行为。我不会详细讲解为什么在每种情况下截断整数会产生正确的值；你可以自己做一些例子，或者相信我的话。
- en: Now that you know what to expect from type conversions, let’s get to work on
    the compiler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了类型转换的预期效果，让我们开始编写编译器吧。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add four new tokens in this chapter:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将添加四个新令牌：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">signed</samp>  A keyword used to
    specify a signed integer type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">signed</samp> 一个关键字，用于指定有符号整数类型。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned</samp> A keyword used
    to specify an unsigned integer type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned</samp> 一个关键字，用于指定无符号整数类型。
- en: '**Unsigned integer constants**  Integer constants with a <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> suffix. An unsigned
    constant token matches the regex <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+[uU]\b</samp>.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**无符号整数常量** 具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">U</samp> 后缀的整数常量。无符号常量令牌匹配正则表达式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+[uU]\b</samp>。'
- en: '**Unsigned long integer constants** Integer constants with a case- insensitive
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ul</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">lu</samp>
    suffix. An unsigned long constant token matches the regex <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+([lL][uU]|[uU][lL])\b</samp>.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**无符号长整型常量** 具有不区分大小写的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ul</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">lu</samp> 后缀的整数常量。无符号长整型常量的令牌匹配正则表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+([lL][uU]|[uU][lL])\b</samp>。'
- en: Update your lexer to support these tokens, then test it out.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的词法分析器以支持这些令牌，然后进行测试。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">语法分析器</samp>'
- en: Next, we’ll update the AST to support the two new unsigned types and their corresponding
    constants. These updates are bolded in [Listing 12-1](chapter12.xhtml#list12-1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新AST以支持这两种新的无符号类型及其对应的常量。这些更新在[清单 12-1](chapter12.xhtml#list12-1)中已加粗。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: The abstract
    syntax tree with unsigned types and unsigned constants</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-1：包含无符号类型和无符号常量的抽象语法树</samp>
- en: Just like when you added <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>
    in the previous chapter, you need to make sure <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUInt</samp>
    can represent the full range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>
    can represent the full range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. If your implementation language has unsigned 32-bit and 64-bit integer
    types, use them here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一章中你添加了<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>一样，你需要确保<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstUInt</samp>可以表示完整的<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>范围，而<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>可以表示完整的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>范围。如果你的实现语言中有无符号的32位和64位整数类型，可以在这里使用它们。
- en: '[Listing 12-2](chapter12.xhtml#list12-2) shows the updated grammar, with the
    changes bolded.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-2](chapter12.xhtml#list12-2)展示了更新后的语法，修改部分已加粗。'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: The grammar with
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">signed</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">type specifiers and unsigned constants</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-2：包含</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">signed</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">类型说明符和无符号常量的语法</samp>
- en: 'Parsing type specifiers is more complicated than in the previous chapter because
    there are so many different ways to refer to the same type. For example, these
    are all valid ways to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    type:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解析类型说明符比上一章更复杂，因为有许多不同的方式可以引用同一类型。例如，下面这些都是指定<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>类型的有效方式：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long int</samp>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long int</samp>
- en: The order of type specifiers doesn’t matter, so <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    signed</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long int signed</samp>,
    and so on all specify the same type. The pseudocode in [Listing 12-3](chapter12.xhtml#list12-3)
    provides one way to impose order on this chaos.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类型说明符的顺序并不重要，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">long signed</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long int signed</samp>等都指定相同的类型。[清单 12-3](chapter12.xhtml#list12-3)中的伪代码提供了一种方式来规范这些混乱。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Determining a
    type from a list of type specifiers</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-3：从类型说明符列表中确定类型</samp>
- en: We start by checking for error cases. You need at least one specifier to indicate
    a type, and you can’t include the same specifier twice. You can’t specify a type
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">int long int</samp>, for example.
    (The <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> type specifier
    would complicate this validation check, but we’re not implementing it.) You also
    can’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> specifiers in
    the same type specification, since they contradict each other.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查错误情况。你至少需要一个说明符来指示类型，并且不能包含相同的说明符两次。例如，你不能指定类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    long int</samp>。（<samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp>类型说明符会使这个验证检查更复杂，但我们不打算实现它。）你也不能在同一类型说明中同时包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>说明符，因为它们是互相矛盾的。
- en: Once we know our input specifies a valid type, we check for the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> specifiers. If both
    are present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. Otherwise, if <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    is present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>; if <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is present,
    the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>; if neither
    is present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Basically, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is the default
    type, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> specifiers can indicate
    a type other than the default. Section 6.7.2, paragraph 2, of the C standard enumerates
    all the ways you can specify each type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认输入指定了有效的类型，我们会检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 修饰符。如果两者都存在，那么类型就是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>。否则，如果存在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>，类型就是 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>；如果存在 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，类型就是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>；如果两者都不存在，类型就是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。基本上，<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    是默认类型，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 修饰符可以指示除默认类型以外的其他类型。C标准第6.7.2节，第2段列出了所有指定每种类型的方法。
- en: We also need to deal with constant tokens. In the previous chapter, [Listing
    11-6](chapter11.xhtml#list11-6) demonstrated how to parse signed constant tokens.
    I won’t include the corresponding pseudocode for unsigned constant tokens here,
    but the logic is the same. We parse an unsigned integer constant token as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstUInt</samp> if it’s within the range
    of values an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    can hold; that is, between 0 and 2^(32) – 1, inclusive. Otherwise, we parse it
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要处理常量标记。在上一章中，[列表11-6](chapter11.xhtml#list11-6)演示了如何解析有符号常量标记。我这里不再包括无符号常量标记的伪代码，但逻辑是一样的。如果无符号整数常量标记在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> 能表示的范围内（即在 0
    和 2^(32) – 1 之间，包括0和最大值），我们将其解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUInt</samp>。否则，我们将其解析为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>。
- en: 'An unsigned long constant token will always be parsed to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>.
    If either kind of unsigned constant token isn’t in the range for <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> (between 0 and 2^(64) – 1), we’ll throw an error. If you’re curious,
    section 6.4.4.1 of the C standard has the full rules for determining the types
    of integer constants.  ### <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '一个无符号长整型常量标记将始终解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>。如果任何类型的无符号常量标记不在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> 的范围内（介于 0 和
    2^(64) – 1 之间），我们会抛出一个错误。如果你感兴趣，C标准第6.4.4.1节有关于如何确定整数常量类型的完整规则。 ### <samp class="SANS_Futura_Std_Bold_B_11">类型检查器</samp>'
- en: We don’t need to change the loop labeling or identifier resolution passes in
    this chapter. We just need to handle unsigned integers in the type checker.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们不需要修改循环标记或标识符解析阶段。我们只需要在类型检查器中处理无符号整数。
- en: 'First, we’ll update our implementation of the usual arithmetic conversions,
    which implicitly convert the operands in a binary expression to a common type.
    Let’s walk through the usual arithmetic conversion rules for integer types, which
    are defined in section 6.3.1.8, paragraph 1, of the C standard. The first rule
    is pretty self-explanatory:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新通常算术转换的实现，这会隐式地将二元表达式中的操作数转换为通用类型。我们来了解一下整数类型的通常算术转换规则，这些规则在C标准第6.3.1.8节第1段中有定义。第一个规则非常直观：
- en: If both operands have the same type, then no further conversion is needed.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果两个操作数具有相同的类型，则不需要进一步的转换。
- en: 'The second one is a little harder to follow:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个稍微难理解一点：
- en: Otherwise, if both operands have signed integer types or both have unsigned
    integer types, the operand with the type of the lesser integer conversion rank
    is converted to the type of the operand with greater rank.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 否则，如果两个操作数都是有符号整数类型或都是无符号整数类型，则将具有较小整数转换等级的操作数转换为具有较大等级的操作数的类型。
- en: This just means “if both integers have the same signedness, convert the smaller
    type to the bigger one.” We already do this when we implicitly convert values
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
    Section 6.3.1.1, paragraph 1, specifies the *integer conversion rank* of every
    integer type, which provides a relative order on their sizes without nailing down
    those sizes exactly. Of the types we have so far, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> have the
    highest rank, then <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. The signed
    and unsigned versions of the same type always have the same rank. Because of their
    relative conversion ranks, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    is guaranteed to be at least as large as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    but not necessarily larger. (In fact, the two types are the same size on most
    32-bit systems.) Regardless of their exact sizes, the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    and the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. No big
    surprises here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是意味着“如果两个整数有相同的符号性，转换较小的类型为较大的类型。”我们在将值从<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>隐式转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>时已经做到了这一点。第6.3.1.1节，第1段，规定了*整数转换等级*，它提供了每种整数类型的相对顺序，而不是精确地规定这些类型的大小。在我们目前为止使用的类型中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>具有最高的等级，然后是<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>。相同类型的有符号和无符号版本始终具有相同的等级。由于它们的相对转换等级，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>保证至少和<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>一样大，但不一定更大。（事实上，在大多数32位系统上，这两种类型的大小是相同的。）无论它们的确切大小如何，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的共同类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，而<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>的共同类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>。这里没有什么大惊小怪的。
- en: 'The third rule talks about cases with one signed operand and one unsigned operand:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条规则讨论的是有一个有符号操作数和一个无符号操作数的情况：
- en: Otherwise, if the operand that has unsigned integer type has rank greater or
    equal to the rank of the type of the other operand, then the operand with signed
    integer type is converted to the type of the operand with unsigned integer type.
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 否则，如果具有无符号整数类型的操作数的等级大于或等于另一个操作数类型的等级，则具有有符号整数类型的操作数会转换为具有无符号整数类型的操作数的类型。
- en: 'So, if the two types are the same size, or if the unsigned type is bigger,
    we go with the unsigned type. For example, the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, and the common type
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>.
    That leaves the case where the signed type is bigger, which is covered by the
    fourth rule:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果两种类型的大小相同，或者无符号类型更大，我们选择无符号类型。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>的共同类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>，而<int</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>的共同类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>。剩下的情况是有符号类型更大，这由第四条规则来处理：
- en: Otherwise, if the type of the operand with signed integer type can represent
    all of the values of the type of the operand with unsigned integer type, then
    the operand with unsigned integer type is converted to the type of the operand
    with signed integer type.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 否则，如果带符号整数类型的操作数能够表示无符号整数类型操作数的所有值，那么无符号整数类型的操作数将转换为带符号整数类型操作数的类型。
- en: 'Under the System V x64 ABI, a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    can represent every value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>, so the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. This isn’t true in implementations
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    are the same size. In these implementations, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    has a higher rank than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    but can’t represent every value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. The fifth and final rule covers these implementations. Even though
    this rule doesn’t apply to us, I’ll include it for the sake of completeness:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 System V x64 ABI 下，<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    可以表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> 类型的所有值，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    的公共类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 相同大小的实现中，情况则不同。在这些实现中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 的等级高于 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，但无法表示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> 类型的所有值。第五条规则涵盖了这些实现。尽管此规则不适用于我们，但我会为了完整性而包含它：
- en: Otherwise, both operands are converted to the unsigned integer type corresponding
    to the type of the operand with signed integer type.
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 否则，两个操作数都将转换为与带符号整数类型操作数相对应的无符号整数类型。
- en: So, on systems where <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> are the same size,
    the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    大小相同的系统上，<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> 的公共类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>。
- en: This all boils down to three rules for finding the common type, which [Listing
    12-4](chapter12.xhtml#list12-4) describes in pseudocode.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这归结为查找公共类型的三条规则，[清单 12-4](chapter12.xhtml#list12-4) 在伪代码中描述了这些规则。
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Finding the common
    type of two integers</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-4：查找两个整数的公共类型</samp>
- en: 'First, if the types are the same, pick either one ❶. Otherwise, if they’re
    the same size, choose the unsigned one ❷. If they’re not the same size, choose
    the bigger one ❸. Apart from the usual arithmetic conversions, we’ll make one
    tiny update to the logic for type checking expressions: we’ll annotate unsigned
    constants with the correct type, in the same way that we already annotate signed
    constants.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果类型相同，选择任意一个 ❶。否则，如果它们大小相同，选择无符号类型 ❷。如果它们大小不同，选择较大的类型 ❸。除了常规的算术转换，我们将对类型检查表达式的逻辑进行一次小更新：我们将使用正确的类型标注无符号常量，方式与我们已经标注带符号常量相同。
- en: 'Next, let’s look at how we record the initial values of static variables in
    the symbol table. We’ll add two new kinds of static initializers, just like we
    added two new kinds of constants:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在符号表中记录静态变量的初始值。我们将添加两种新的静态初始化器，就像我们添加了两种新的常量一样：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to convert each initializer to the type of the variable it’s initializing,
    according to the type conversion rules presented at the beginning of this chapter.
    Consider the following declaration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要根据本章开始时介绍的类型转换规则，将每个初始化器转换为它所初始化的变量的类型。考虑以下声明：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The value 4,294,967,299 is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. When adding <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    to the symbol table, we’ll convert this value to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> by subtracting 2^(32) from it. (In practice, you can probably just
    use the equivalent integer type conversion in your implementation language.) The
    resulting initializer will be <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(3)</samp>.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 值 4,294,967,299 超出了<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>的范围。当将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">u</samp>添加到符号表时，我们将通过从该值中减去 2^(32) 来将其转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>。（实际上，你可能只需要在实现语言中使用等效的整数类型转换。）结果初始化器将是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(3)</samp>。
- en: 'Along the same lines, this declaration initializes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with a value outside of its range:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，以下声明将一个超出其范围的 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 进行初始化：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we reduce this value modulo 2^(32), the resulting initializer will be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IntInit(-50)</samp>.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对该值进行 2^(32) 取模，结果初始化器将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(-50)</samp>。
- en: 'It isn’t strictly necessary to have different static initializers for signed
    and unsigned variables. Instead, you could use <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit</samp>
    to represent both <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> initializers
    and use <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp> to represent
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> initializers. Ultimately, the assembler will write out the same bytes
    for an initializer whether you represent it as a signed or unsigned value: the
    directives <samp class="SANS_TheSansMonoCd_W5Regular_11">.long -50</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.long 4294967246</samp> mean exactly
    the same thing. Having separate <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit</samp> initializers
    just makes our type conversions easier to keep track of.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号和无符号变量，严格来说不需要使用不同的静态初始化器。相反，你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit</samp>
    来表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> 的初始化器，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp>
    来表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> 的初始化器。最终，汇编器将为初始化器写出相同的字节，无论你将其表示为有符号还是无符号值：指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">.long
    -50</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">.long 4294967246</samp>
    完全相同。将 <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit</samp>
    初始化器分开，只是让我们的类型转换更容易追踪。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: 'We’ll make one addition to TACKY in this chapter: a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>
    instruction. [Listing 12-5](chapter12.xhtml#list12-5) defines the whole TACKY
    IR.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向 TACKY 添加一项：<samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>
    指令。[列表 12-5](chapter12.xhtml#list12-5) 定义了整个 TACKY IR。
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-5: Adding the</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">ZeroExtend</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction
    to TACKY</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 12-5：将</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ZeroExtend</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">指令添加到 TACKY</samp>
- en: Now we have to generate the right TACKY for cast expressions that convert to
    and from unsigned types. At the beginning of this chapter, we discussed how converting
    an integer to a new type affected its binary representation in four different
    cases. [Listing 12-6](chapter12.xhtml#list12-6) demonstrates what TACKY instructions
    to emit in each of those cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须为将转换为和从无符号类型转换的类型转换表达式生成正确的 TACKY。在本章开始时，我们讨论了将整数转换为新类型如何影响其二进制表示的四种不同情况。[列表
    12-6](chapter12.xhtml#list12-6) 展示了在每种情况下应该发出什么样的 TACKY 指令。
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-6: Converting a
    cast expression to TACKY</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 12-6：将类型转换表达式转换为 TACKY</samp>
- en: As in the previous chapter, the cast expression does nothing if the inner expression
    already has the correct type. Otherwise, we check if the original type and the
    target type are the same size ❶. If they are, we don’t need to extend, truncate,
    or otherwise change the inner value, because its representation in assembly won’t
    change. We just copy it into a temporary variable with the correct type. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction here may seem
    redundant, but we need it to help us track type information during assembly generation.
    We’ll generate different assembly for certain TACKY instructions depending on
    whether their operands are signed or unsigned. If we don’t store the result of
    each expression in a variable of the correct type, we’ll generate incorrect assembly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章一样，如果内部表达式已经具有正确的类型，则类型转换表达式不做任何操作。否则，我们检查原始类型和目标类型的大小是否相同❶。如果相同，我们不需要扩展、截断或以其他方式更改内部值，因为其在汇编中的表示不会改变。我们只是将其复制到一个具有正确类型的临时变量中。这里的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令可能看起来多余，但我们需要它来帮助我们在汇编生成过程中跟踪类型信息。根据操作数是有符号还是无符号，我们将为某些TACKY指令生成不同的汇编。如果我们不将每个表达式的结果存储在正确类型的变量中，我们将生成不正确的汇编。
- en: Next, we check whether the target type is smaller than the original type ❷.
    In that case, we’ll issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>
    instruction. If that check also fails, this cast expression converts a smaller
    type to a larger one. We issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>
    instruction if the original type is signed ❸ and a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>
    instruction if it’s unsigned ❹.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查目标类型是否小于原始类型❷。如果是这种情况，我们会发出<samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>指令。如果该检查也失败，则该类型转换表达式将较小的类型转换为较大的类型。如果原始类型是有符号的❸，我们发出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>指令；如果是无符号的❹，我们发出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>指令。
- en: Once your compiler generates the correct TACKY for unsigned constants and cast
    expressions, you can test it out.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的编译器为无符号常量和类型转换表达式生成了正确的TACKY指令，你就可以进行测试。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Unsigned Integer Operations in Assembly</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编中的无符号整数操作</samp>
- en: 'In most cases, we can use exactly the same assembly instructions to operate
    on signed and unsigned values. However, there are two cases where we handle unsigned
    values differently: comparisons and division. We’ll need to translate the new
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp> instruction to
    assembly too. Before we update the assembly generation stage, let’s look at how
    unsigned comparisons, unsigned division, and zero extension work in assembly.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们可以使用完全相同的汇编指令来操作有符号和无符号值。然而，在两个情况下，我们需要不同地处理无符号值：比较和除法。我们还需要将新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>指令转换为汇编指令。在更新汇编生成阶段之前，让我们先看看在汇编中无符号比较、无符号除法和零扩展是如何工作的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsigned Comparisons</samp>
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">无符号比较</samp>
- en: 'In [Chapter 4](chapter4.xhtml), you learned how to compare two integers: issue
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction to set
    the RFLAGS register, then issue a conditional instruction whose behavior depends
    on the state of that register. We’ll use the same approach to compare unsigned
    integers, but we need different condition codes that rely on different flags.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](chapter4.xhtml)中，你学会了如何比较两个整数：发出<samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>指令以设置RFLAGS寄存器，然后发出一个条件指令，其行为取决于该寄存器的状态。我们将采用相同的方法来比较无符号整数，但我们需要依赖不同的标志来使用不同的条件码。
- en: Several instructions that perform arithmetic, including <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>,
    don’t distinguish between signed and unsigned values. [Listing 12-7](chapter12.xhtml#list12-7)
    demonstrates how a single operation can implement both signed and unsigned addition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 执行算术运算的几条指令，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>，不区分有符号和无符号值。[列表
    12-7](chapter12.xhtml#list12-7)演示了如何使用一个操作同时实现有符号和无符号加法。
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-7: Adding binary
    integers</samp>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 12-7：二进制整数加法</samp>
- en: If we interpret the operands and the result as unsigned 4-bit integers, [Listing
    12-7](chapter12.xhtml#list12-7) calculates 8 + 2 = 10\. If we interpret them as
    signed 4-bit integers, it calculates −8 + 2 = −6\. As long as we interpret both
    operands and the result consistently, we get the right answer either way. You
    can think of the results of <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and most other arithmetic
    assembly instructions as sequences of bits with two possible values, one signed
    and one unsigned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将操作数和结果解释为无符号的 4 位整数，[清单 12-7](chapter12.xhtml#list12-7) 计算的是 8 + 2 = 10。如果我们将它们解释为有符号的
    4 位整数，则计算的是 −8 + 2 = −6。只要我们一致地解释两个操作数和结果，无论哪种方式都能得到正确的答案。你可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> 和大多数其他算术汇编指令的结果视为具有两种可能值的比特序列，一种是有符号的，一种是无符号的。
- en: 'After the processor executes one of these instructions, some flags in RFLAGS
    tell us about the signed value of the result, others tell us about its unsigned
    value, and still others apply to both values. (Some flags have nothing to do with
    the results of these instructions, but we don’t care about them.) We discussed
    three flags in [Chapter 4](chapter4.xhtml): ZF, the zero flag; SF, the sign flag;
    and OF, the overflow flag. ZF applies whether we interpret the result as signed
    or unsigned, since zero is represented the same way in either case. The SF and
    OF flags, however, give us meaningful information only about the result’s signed
    value.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器执行这些指令之一之后，RFLAGS 中的某些标志会告诉我们结果的有符号值，其他一些标志则告诉我们其无符号值，还有一些标志适用于这两种值。（有些标志与这些指令的结果无关，但我们不关心它们。）我们在[第4章](chapter4.xhtml)中讨论了三个标志：ZF，零标志；SF，符号标志；和
    OF，溢出标志。无论我们将结果解释为有符号还是无符号，ZF 都适用，因为零在这两种情况下的表示方式是相同的。然而，SF 和 OF 标志仅在结果的有符号值上提供有意义的信息。
- en: SF, for example, indicates that the result is negative. In [Chapter 4](chapter4.xhtml),
    we used this flag to conclude that <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> was negative. In that case, assuming there was no overflow, we knew
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> was less than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. That won’t work for unsigned
    values, which are positive by definition. Consider [Listing 12-8](chapter12.xhtml#list12-8),
    which uses unsigned 4-bit integers to calculate 15 – 3.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，SF 表示结果为负数。在[第4章](chapter4.xhtml)中，我们使用这个标志得出结论，<samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> 是负数。在那种情况下，假设没有溢出，我们知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    小于 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>。对于无符号值，这种方法不起作用，因为无符号值按定义是正数。考虑[清单
    12-8](chapter12.xhtml#list12-8)，它使用无符号的 4 位整数来计算 15 – 3。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-8: Subtracting binary
    integers</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-8：减法二进制整数</samp>
- en: Since 15 is greater than 3, the result of this operation is a positive number,
    12\. The fact that the result has a leading 1 doesn’t tell us anything about which
    operand is larger. Similarly, OF tells us that the signed value of some instruction’s
    result wrapped around from positive to negative, or vice versa, which doesn’t
    tell us anything useful about its unsigned value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 15 大于 3，因此此操作的结果是一个正数，12。结果具有前导 1 并没有告诉我们哪个操作数更大。类似地，OF 告诉我们某个指令结果的有符号值从正数环绕到负数，或反之，这并没有告诉我们任何关于其无符号值的有用信息。
- en: 'To compare unsigned integers, we’ll use CF, the *carry flag*. This flag indicates
    that the unsigned value of a result wrapped around because the correct value was
    less than zero or greater than the maximum value the type could hold. For example,
    suppose we want to compute 15 + 1 with unsigned 4-bit integers. The 4-bit unsigned
    representation of 15 is <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>;
    when we increment it, it wraps around to <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>.
    This computation will set the carry flag to 1\. The carry flag will also be set
    if we try to calculate 0 – 1 and the result wraps around in the other direction
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>, or 15\. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> will always wrap around and set the carry flag. If <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    > b</samp>, the result will always be representable as an unsigned integer, so
    it won’t have to wrap around. Let’s walk through how <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp
    b, a</samp> will impact CF and ZF when we interpret <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> as unsigned integers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较无符号整数，我们将使用 CF，即*进位标志*。该标志指示结果的无符号值发生了溢出，因为正确的值小于零或大于该类型能够表示的最大值。例如，假设我们要用无符号
    4 位整数计算 15 + 1。15 的无符号 4 位表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>；当我们将其加
    1 时，它会回绕到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>。这个计算将使进位标志被设置为
    1。如果我们尝试计算 0 - 1，且结果在相反方向回绕到 <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>，即
    15，那么进位标志也会被设置为 1。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>，则
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> 的结果总是回绕并设置进位标志。如果 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>，则结果总是可以表示为无符号整数，因此不会发生回绕。让我们看看当我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    作为无符号整数时，<samp class="SANS_TheSansMonoCd_W5Regular_11">cmp b, a</samp> 会如何影响 CF
    和 ZF：
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> will be 0, so ZF will be 1 and CF will be 0.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> 将为 0，因此 ZF 将为 1，CF 将为 0。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> will be a positive number. It will be greater than 0 but less than
    or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, so it won’t
    wrap around. ZF and CF will both be 0.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> 将是一个正数。它将大于 0，但小于或等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>，因此不会回绕。ZF
    和 CF 都将为 0。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> will be negative, so it will have to wrap around. ZF will be 0 and
    CF will be 1.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> 将为负数，因此它必须回绕。ZF 将为 0，CF 将为 1。
- en: Note that ZF and CF are mutually exclusive; one operation will never set both
    of them. All the condition codes we need in this chapter depend on one or both
    of these flags. [Table 12-1](chapter12.xhtml#tab12-1) lists these condition codes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ZF 和 CF 是互斥的；一个操作永远不会同时设置这两个标志。本章中所需的所有条件码都依赖于这两个标志之一或两者。[表 12-1](chapter12.xhtml#tab12-1)
    列出了这些条件码。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-1:</samp> <samp class="SANS_Futura_Std_Book_11">Condition
    Codes for Unsigned Comparisons</samp>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-1：</samp> <samp class="SANS_Futura_Std_Book_11">无符号比较的条件码</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Condition code</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Flags</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">条件码</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">含义</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">标志</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    == b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF set</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    == b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF 被设置</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    != b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF not set</samp> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    != b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF未设置</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    > b</samp> | <samp class="SANS_Futura_Std_Book_11">CF not set and ZF not set</samp>
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    > b</samp> | <samp class="SANS_Futura_Std_Book_11">CF未设置且ZF未设置</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    >= b</samp> | <samp class="SANS_Futura_Std_Book_11">CF not set</samp> |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    >= b</samp> | <samp class="SANS_Futura_Std_Book_11">CF未设置</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    < b</samp> | <samp class="SANS_Futura_Std_Book_11">CF set</samp> |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    < b</samp> | <samp class="SANS_Futura_Std_Book_11">CF设置</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    <= b</samp> | <samp class="SANS_Futura_Std_Book_11">CF set or ZF set</samp> |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    <= b</samp> | <samp class="SANS_Futura_Std_Book_11">CF设置或ZF设置</samp> |'
- en: We use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp> condition codes to test
    for equality and inequality, but we’ll use new codes to determine which of two
    operands is larger. The <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> in the new codes are
    mnemonics for “above” and “below.” The new condition codes can appear in conditional
    jump and set instructions, just like the old ones. [Listing 12-9](chapter12.xhtml#list12-9)
    demonstrates how to set EAX to 1 if the unsigned value in EDX is greater than
    10.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用现有的 <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp>
    条件码来测试相等和不等，但我们将使用新的代码来确定两个操作数中哪个更大。新代码中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> 是“above”（上面）和“below”（下面）的助记符。新的条件码可以出现在条件跳转和设置指令中，就像旧的条件码一样。[列表12-9](chapter12.xhtml#list12-9)
    演示了如何在 EAX 中设置 1，如果 EDX 中的无符号值大于 10。
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-9: Performing an
    unsigned comparison in assembly</samp>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表12-9：在汇编中执行无符号比较</samp>
- en: 'This follows exactly the same pattern as signed comparisons: we issue the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction, then zero out
    the destination, and finally issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    instruction with a suffix for the appropriate condition code.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这与有符号比较的模式完全相同：我们发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    指令，然后清除目标值，最后发出带有适当条件码后缀的 <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsigned Division</samp>
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">无符号除法</samp>
- en: For most arithmetic operations, the same instruction can operate correctly on
    both signed and unsigned integers. But for division, this doesn’t work. Suppose
    we want to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">1000 / 0010</samp>.
    If we interpret these values as signed 4-bit integers, this is −8 / 2 and the
    result is −4, represented as <samp class="SANS_TheSansMonoCd_W5Regular_11">1100</samp>.
    If they’re unsigned 4-bit integers, this is 8 / 2 and the result is 4, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0100</samp>. There’s no way a single instruction
    can produce the correct result in both cases.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数算术操作，相同的指令可以在有符号和无符号整数上正确操作。但对于除法，这种方式不适用。假设我们想要计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">1000
    / 0010</samp>。如果将这些值解释为有符号4位整数，则为 −8 / 2，结果是 −4，表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1100</samp>。如果它们是无符号4位整数，则为
    8 / 2，结果是 4，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">0100</samp>。单条指令无法在两种情况下都产生正确的结果。
- en: So, we’ll need a new instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>,
    to perform unsigned division. This instruction works just like <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>.
    It takes one operand, which is its divisor. Its dividend is the value stored in
    EDX and EAX, or RDX and RAX if we’re working with quadwords. It stores the quotient
    in EAX or RAX, and it stores the remainder in EDX or RDX.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一个新的指令<samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>来执行无符号除法。这个指令与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>一样。它需要一个操作数，即除数。被除数是存储在EDX和EAX中的值，或者在处理四字时是存储在RDX和RAX中的值。它将商存储在EAX或RAX中，将余数存储在EDX或RDX中。
- en: Since the dividend is unsigned, we zero extend it from EAX into EDX (or from
    RAX into RDX) instead of sign extending it. We accomplish this by zeroing out
    RDX instead of emitting a <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>
    instruction.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被除数是无符号的，我们将其从EAX扩展到EDX（或从RAX扩展到RDX），而不是进行符号扩展。我们通过将RDX清零，而不是发出<samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>指令来实现这一点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Zero Extension</samp>
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">零扩展</samp>
- en: 'The last operation we need to implement is zero extension. We can zero extend
    a longword to a quadword by moving it into a register; this zeroes out the register’s
    upper 4 bytes. Then, if we need to store the value in memory, we can move the
    whole 8-byte value to its final destination. The following code zero extends the
    value at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp> and then
    saves the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个操作是零扩展。我们可以通过将一个长字移动到寄存器中来将其零扩展为四字；这将清除寄存器的上4个字节。然后，如果需要将值存储到内存中，我们可以将整个8字节的值移动到最终位置。以下代码将位于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>的值零扩展，然后将结果保存到<samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use the 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction to copy the value into the register and the 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp>
    instruction to copy it back out. If the final destination of the zero extension
    operation is a register instead of a location in memory, we need only the first
    4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用4字节的<samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>指令将值复制到寄存器中，使用8字节的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movq</samp>指令将其复制出来。如果零扩展操作的最终目标是寄存器而不是内存位置，我们只需要第一个4字节的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>指令。
- en: There’s also a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction, which zero extends source values that are smaller than 4 bytes. We
    don’t need this instruction yet, but we’ll use it when we implement character
    types in [Chapter 16](chapter16.xhtml).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个独立的<samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>指令，它用于零扩展小于4字节的源值。我们暂时不需要这个指令，但在[第16章](chapter16.xhtml)中实现字符类型时会用到它。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>'
- en: Now that you know how to work with unsigned integers in assembly, you’re ready
    to extend the assembly generation stage. [Listing 12-10](chapter12.xhtml#list12-10)
    defines the latest assembly AST, with this chapter’s additions bolded.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何在汇编中处理无符号整数，你可以开始扩展汇编生成阶段。[清单12-10](chapter12.xhtml#list12-10)定义了最新的汇编AST，本文中新增的部分已加粗。
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-10: The assembly
    AST with unsigned operations</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单12-10：带有无符号操作的汇编AST</samp>
- en: We’ve added the new condition codes and unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    instruction we discussed in the previous section. We’ve also added a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instruction to handle zero extension. For now, this instruction is only a placeholder.
    During the instruction fix-up pass, we’ll replace it with either one or two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions, depending on
    whether its destination is in memory or a register. (At the moment, the destination
    will always be in memory, so we’ll always need two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions; this will change once we implement register allocation in [Part
    III](part3.xhtml).) When we add character types, <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    will also represent the real <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction to zero extend 1-byte values.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了上一节中讨论的新条件码和无符号<samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>指令。我们还添加了一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>指令来处理零扩展。目前，这个指令只是一个占位符。在指令修复阶段，我们会将其替换为一个或两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令，具体取决于其目标是内存还是寄存器。（目前，目标总是内存，因此我们始终需要两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令；一旦我们在[第三部分](part3.xhtml)中实现寄存器分配，这一点将发生变化。）当我们添加字符类型时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>还将表示真正的<samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>指令，用于将1字节的值零扩展。
- en: Let’s recap the changes we’ll need to make to the assembly generation pass.
    First, when we convert source-level types to assembly types, we lose the distinction
    between signed and unsigned integers. Both <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> values
    in TACKY become quadwords in assembly, and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> values become
    longwords.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在汇编生成阶段需要做的更改。首先，当我们将源级类型转换为汇编类型时，我们失去了带符号和无符号整数之间的区别。在TACKY中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>值在汇编中都变成了四字长，而<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>值则变成了长字。
- en: When we convert a comparison instruction from TACKY to assembly, we start by
    looking up the type of either operand (both operands are guaranteed to have the
    same type). We then choose the appropriate condition code, depending on whether
    that type is signed. For example, to handle
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将比较指令从TACKY转换为汇编时，我们首先查找任一操作数的类型（两个操作数的类型保证相同）。然后，根据该类型是否带符号，我们选择适当的条件码。例如，处理
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'we start by looking up the type of either <samp class="SANS_TheSansMonoCd_W5Regular_11">src1</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp> in the symbol table.
    Let’s say the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt</samp>.
    In this case, we’ll generate the following assembly instructions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从符号表中查找<samp class="SANS_TheSansMonoCd_W5Regular_11">src1</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp>的类型。假设类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UInt</samp>。在这种情况下，我们将生成以下汇编指令：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These are exactly the same instructions we’d generate for a signed comparison,
    except that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    condition code instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令与我们为带符号比较生成的指令完全相同，唯一的区别是我们使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>条件码，而不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">L</samp>。
- en: To handle a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Remainder</samp> operation, we
    copy the first operand into EAX, as before. Then, if the operands are signed,
    we sign extend EAX into EDX and issue an <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instruction. If they’re unsigned, we zero out EDX and issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    instruction. (Naturally, we’ll use RAX and RDX instead of EAX and EDX if the operands
    are quadwords.) For example, we’ll translate
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理TACKY的<samp class="SANS_TheSansMonoCd_W5Regular_11">除法</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">余数</samp>操作，我们将第一个操作数复制到EAX寄存器中，如之前所做的那样。然后，如果操作数是带符号的，我们将EAX符号扩展到EDX并发出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>指令。如果操作数是无符号的，我们将EDX清零并发出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">div</samp>指令。（自然地，如果操作数是四字长，我们将使用RAX和RDX代替EAX和EDX。）例如，我们将转换为
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'into:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, we’ll convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>
    TACKY instruction into a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    assembly instruction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp> TACKY
    指令转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> 汇编指令。
- en: '[Tables 12-2](chapter12.xhtml#tab12-2) through [12-5](chapter12.xhtml#tab12-5)
    summarize the latest updates to the conversion from TACKY to assembly. New constructs
    and changes to the way we convert existing constructs are bolded.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-2](chapter12.xhtml#tab12-2) 到 [12-5](chapter12.xhtml#tab12-5) 总结了从 TACKY
    到汇编的最新转换更新。新增的构造和我们转换现有构造的方式的更改已加粗显示。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-2：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 指令转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 指令</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Divide, src1, src2,
    dst)</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp> |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Divide, src1, src2,
    dst)</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp> |'
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">无符号</samp> |'
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Remainder, src1, src2,
    dst)</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp> |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Remainder, src1, src2,
    dst)</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp> |'
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">无符号</samp> |'
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ZeroExtend(src, dst)</samp>
    |  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">MovZeroExtend(src, dst)</samp>
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ZeroExtend(src, dst)</samp>
    |  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">MovZeroExtend(src, dst)</samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Comparisons to Assembly</samp>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-3：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 比较转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp> |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 比较</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">汇编条件码</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">B</samp>
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">无符号</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">B</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">有符号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">BE</samp>
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">无符号</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">BE</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">有符号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">A</samp>
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">无符号</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">A</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">有符号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AE</samp>
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">无符号</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AE</samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-4：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 操作数转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">粘性操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp>
    |'
- en: '| --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstUInt(int))</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp> |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">常量(ConstUInt(int))</samp> |
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstULong(int))</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp> |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">常量(ConstULong(int))</samp> |
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp> |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表12-5：</samp> <samp class="SANS_Futura_Std_Book_11">类型转换为汇编类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">源类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编类型</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">对齐</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">UInt</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4</samp> |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">UInt</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ULong</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ULong</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp> |'
- en: Next, we’ll update the pseudoregister replacement and instruction fix-up passes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新伪寄存器替换和指令修正的处理过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">替换伪寄存器</samp>
- en: We’ll extend this pass to handle the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> instructions.
    Otherwise, there’s nothing to change here. This pass looks at each operand’s assembly
    type rather than its source-level type, so it doesn’t distinguish between signed
    and unsigned operands.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展这个过程，以处理新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> 指令。否则，这里没有什么需要更改的。这个过程查看的是每个操作数的汇编类型，而不是其源级类型，因此它不会区分有符号和无符号操作数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the Div
    and MovZeroExtend Instructions</samp>
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修正 Div 和 MovZeroExtend
    指令</samp>
- en: Next, we’ll rewrite both <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>. Like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>, the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    instruction can’t use a constant operand. We’ll rewrite it the same way as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>, copying its operand into
    R10 if we need to.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>。与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> 类似，新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    指令不能使用常量操作数。我们将像重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> 一样重写它，必要时将操作数复制到
    R10。
- en: We’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    with one or two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions.
    If its destination is a register, we’ll issue a single <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction. For example, we’ll rewrite
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一条或两条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令替换 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>。如果目标是寄存器，我们将发出一条
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> 指令。例如，我们将重写
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'as:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If its destination is in memory, we’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction to zero extend into R11, then move it from there to the destination.
    So, we’ll rewrite
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标在内存中，我们将使用一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> 指令将其零扩展到
    R11 中，然后再从那里移动到目标。因此，我们将重写
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'as:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We won’t make any other changes to this pass.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会对这个过程做其他更改。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码生成</samp>
- en: We’ll make a few changes to the code emission stage in this chapter. First,
    we’ll add the <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> instruction
    and the new condition codes. We’ll also add our two new static initializers, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UIntInit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit</samp>,
    which we’ll emit exactly like their signed counterparts, <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp>. [Tables 12-6](chapter12.xhtml#tab12-6)
    through [12-8](chapter12.xhtml#tab12-8) demonstrate how to emit these new constructs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中对代码发射阶段进行一些更改。首先，我们将添加`div`指令和新的条件码。我们还将添加两个新的静态初始化器，<samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ULongInit</samp>，它们的发射方式将与其有符号对应物<code>IntInit</code>和<code>LongInit</code>完全相同。[表
    12-6](chapter12.xhtml#tab12-6)至[12-8](chapter12.xhtml#tab12-8)展示了如何发射这些新结构。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-6：</samp> <samp class="SANS_Futura_Std_Book_11">格式化静态初始化器</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">静态初始化器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(0)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.zero 4</samp> |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(0)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.zero 4</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(i)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp>
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(i)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(0)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.zero 8</samp> |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(0)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.zero 8</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(i)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp>
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(i)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-7：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Div(t, operand)</samp> |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Div(t, operand)</samp> |'
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-8:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Suffixes for Condition Codes</samp>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-8：</samp> <samp class="SANS_Futura_Std_Book_11">条件码的指令后缀</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Condition code</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Instruction
    suffix</samp> |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">条件码</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">指令后缀</samp>
    |'
- en: '| --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ae</samp>
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ae</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">be</samp>
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">be</samp>
    |'
- en: I haven’t bolded the new constructs and changes in these tables like I normally
    do, because all of these assembly constructs are new.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有像往常一样加粗这些表格中的新结构和更改，因为所有这些汇编结构都是新的。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">概述</samp>'
- en: In this chapter, you built on the foundations you laid in [Chapter 11](chapter11.xhtml)
    to implement two unsigned integer types. You waded through the C standard’s rules
    for type conversions and explored how those conversions impact both an integer’s
    representation and its value. In the type checker, you learned how signed and
    unsigned integers are converted to a common type. During assembly generation,
    you implemented zero extension and unsigned division and comparisons.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你在[第11章](chapter11.xhtml)中打下的基础上，实现了两个无符号整数类型。你深入研究了C标准中关于类型转换的规则，并探索了这些转换如何影响整数的表示和数值。在类型检查器中，你了解了有符号和无符号整数是如何转换为共同类型的。在汇编生成过程中，你实现了零扩展、无符号除法和比较操作。
- en: In [Chapter 13](chapter13.xhtml), you’ll add a floating-point type, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Floating-point numbers are processed very differently from integers in hardware;
    they even get their own set of registers! As you’ll see, those hardware differences
    impact everything from type conversions to function calling conventions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](chapter13.xhtml)中，你将添加一个浮点类型，<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。浮点数在硬件中的处理方式与整数有很大不同；它们甚至有自己的寄存器！正如你将看到的那样，这些硬件差异影响了从类型转换到函数调用约定的方方面面。
