- en: '![](../images/pg272.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-27.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">UNSIGNED
    INTEGERS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll implement the unsigned counterparts to our two signed
    integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. You’ll
    extend the usual arithmetic conversions to handle unsigned integers and implement
    casts between signed and unsigned types. On the backend, you’ll use a few new
    assembly instructions to do unsigned integer arithmetic.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](chapter11.xhtml), we focused on inferring and tracking type
    information in general; now we’ll be able to build on that work to add new types
    with relatively little effort. Before we modify the compiler, let’s start with
    a quick overview of conversions between signed and unsigned types.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Type Conversions, Again</samp>'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Every integer type conversion has two aspects we need to consider: how the
    integer’s value changes and how its binary representation changes. We saw this
    in the conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> in the previous
    chapter. Sign extension changes a signed integer’s representation from 32 to 64
    bits without changing its value. Truncating a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> also changes its
    representation, and it changes its value too if the original value can’t fit in
    the new type.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: With that distinction in mind, I’ll break our type conversions down into four
    cases. In each case, I’ll describe how the integer’s representation will change.
    Then, I’ll explain how that corresponds with the rules in the C standard about
    how its value should change.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    Signed and Unsigned Types of the Same Size</samp>
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first case is when we convert between signed and unsigned types of the
    same size: that is, between <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> or between
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. These conversions don’t change the binary representation of the integer.
    The only thing that changes is whether we use two’s complement to interpret its
    value. Let’s consider the effect of that change in interpretation.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'If a signed integer is positive, its upper bit will be 0, so interpreting it
    as an unsigned integer won’t change its value. The reverse is also true: if an
    unsigned integer is smaller than the maximum value the signed type can represent,
    its upper bit must be 0\. Therefore, if we reinterpret it using two’s complement,
    its value won’t change. As you learned in the previous chapter, when we convert
    an integer to a new type, the standard requires us to preserve its value if we
    can. We’re satisfying that requirement here.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: That leaves integers whose upper bit is 1\. When we reinterpret a signed negative
    integer as unsigned, we change the upper bit’s value from negative to positive.
    If the upper bit is 1, this has the effect of adding 2*^N* to the value, where
    *N* is the number of bits in the type. This is exactly the behavior the standard
    requires; section 6.3.1.3, paragraph 2, states that if the value can’t be represented
    by the new type and the new type is unsigned, “the value is converted by repeatedly
    adding or subtracting one more than the maximum value that can be represented
    in the new type until the value is in the range of the new type.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, converting an unsigned type with a leading 1 to the corresponding
    signed type will subtract 2*^N* from its value. This matches the implementation-defined
    behavior we chose in the last chapter for conversions to signed integers, following
    GCC: “The value is reduced modulo 2*^N* to be within range of the type.”'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting unsigned
    int to a Larger Type</samp>
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second case is when we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> to a larger type, either <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. To handle
    this case, we’ll *zero extend* the integer by filling the upper bits of the new
    representation with zeros. This conversion always preserves the original value,
    since we’re just adding leading zeros to a positive number.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting
    signed int to a Larger Type</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The third case is when we convert a signed <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. We already convert <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> using sign extension.
    We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> the same way. If
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is positive, sign
    extension will just add leading zeros, which preserves its value whether you interpret
    the result as signed or unsigned. If the value is negative, sign extending and
    then interpreting the result as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> will add 2^(64) to its value, as the standard requires.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting from Larger
    to Smaller Types</samp>
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the final case, we convert a larger type (<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>) to a smaller
    one (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>). We always handle this case by truncating the value. This has the
    effect of adding or subtracting 2^(32) until the value is in the range of the
    new type—or, equivalently, reducing the value modulo 2^(32)—which is the behavior
    we want. I won’t walk you through why truncating the integer produces the correct
    value in every case; you can work through some examples on your own, or just take
    my word for it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what to expect from type conversions, let’s get to work on
    the compiler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add four new tokens in this chapter:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">signed</samp>  A keyword used to
    specify a signed integer type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned</samp> A keyword used
    to specify an unsigned integer type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**Unsigned integer constants**  Integer constants with a <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> suffix. An unsigned
    constant token matches the regex <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+[uU]\b</samp>.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Unsigned long integer constants** Integer constants with a case- insensitive
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ul</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">lu</samp>
    suffix. An unsigned long constant token matches the regex <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+([lL][uU]|[uU][lL])\b</samp>.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Update your lexer to support these tokens, then test it out.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll update the AST to support the two new unsigned types and their corresponding
    constants. These updates are bolded in [Listing 12-1](chapter12.xhtml#list12-1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新AST以支持这两种新的无符号类型及其对应的常量。这些更新在[清单 12-1](chapter12.xhtml#list12-1)中已加粗。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: The abstract
    syntax tree with unsigned types and unsigned constants</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-1：包含无符号类型和无符号常量的抽象语法树</samp>
- en: Just like when you added <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>
    in the previous chapter, you need to make sure <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUInt</samp>
    can represent the full range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>
    can represent the full range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. If your implementation language has unsigned 32-bit and 64-bit integer
    types, use them here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一章中你添加了<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>一样，你需要确保<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstUInt</samp>可以表示完整的<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>范围，而<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>可以表示完整的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>范围。如果你的实现语言中有无符号的32位和64位整数类型，可以在这里使用它们。
- en: '[Listing 12-2](chapter12.xhtml#list12-2) shows the updated grammar, with the
    changes bolded.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-2](chapter12.xhtml#list12-2)展示了更新后的语法，修改部分已加粗。'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: The grammar with
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">signed</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">type specifiers and unsigned constants</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-2：包含</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">signed</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">类型说明符和无符号常量的语法</samp>
- en: 'Parsing type specifiers is more complicated than in the previous chapter because
    there are so many different ways to refer to the same type. For example, these
    are all valid ways to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    type:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解析类型说明符比上一章更复杂，因为有许多不同的方式可以引用同一类型。例如，下面这些都是指定<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>类型的有效方式：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long int</samp>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long int</samp>
- en: The order of type specifiers doesn’t matter, so <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    signed</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long int signed</samp>,
    and so on all specify the same type. The pseudocode in [Listing 12-3](chapter12.xhtml#list12-3)
    provides one way to impose order on this chaos.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类型说明符的顺序并不重要，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">long signed</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long int signed</samp>等都指定相同的类型。[清单 12-3](chapter12.xhtml#list12-3)中的伪代码提供了一种方式来规范这些混乱。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Determining a
    type from a list of type specifiers</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-3：从类型说明符列表中确定类型</samp>
- en: We start by checking for error cases. You need at least one specifier to indicate
    a type, and you can’t include the same specifier twice. You can’t specify a type
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">int long int</samp>, for example.
    (The <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> type specifier
    would complicate this validation check, but we’re not implementing it.) You also
    can’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> specifiers in
    the same type specification, since they contradict each other.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查错误情况。你至少需要一个说明符来指示类型，并且不能包含相同的说明符两次。例如，你不能指定类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    long int</samp>。（<samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp>类型说明符会使这个验证检查更复杂，但我们不打算实现它。）你也不能在同一类型说明中同时包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>说明符，因为它们是互相矛盾的。
- en: Once we know our input specifies a valid type, we check for the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> specifiers. If both
    are present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. Otherwise, if <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    is present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>; if <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is present,
    the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>; if neither
    is present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Basically, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is the default
    type, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> specifiers can indicate
    a type other than the default. Section 6.7.2, paragraph 2, of the C standard enumerates
    all the ways you can specify each type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We also need to deal with constant tokens. In the previous chapter, [Listing
    11-6](chapter11.xhtml#list11-6) demonstrated how to parse signed constant tokens.
    I won’t include the corresponding pseudocode for unsigned constant tokens here,
    but the logic is the same. We parse an unsigned integer constant token as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstUInt</samp> if it’s within the range
    of values an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    can hold; that is, between 0 and 2^(32) – 1, inclusive. Otherwise, we parse it
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'An unsigned long constant token will always be parsed to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>.
    If either kind of unsigned constant token isn’t in the range for <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> (between 0 and 2^(64) – 1), we’ll throw an error. If you’re curious,
    section 6.4.4.1 of the C standard has the full rules for determining the types
    of integer constants.  ### <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to change the loop labeling or identifier resolution passes in
    this chapter. We just need to handle unsigned integers in the type checker.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll update our implementation of the usual arithmetic conversions,
    which implicitly convert the operands in a binary expression to a common type.
    Let’s walk through the usual arithmetic conversion rules for integer types, which
    are defined in section 6.3.1.8, paragraph 1, of the C standard. The first rule
    is pretty self-explanatory:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: If both operands have the same type, then no further conversion is needed.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The second one is a little harder to follow:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if both operands have signed integer types or both have unsigned
    integer types, the operand with the type of the lesser integer conversion rank
    is converted to the type of the operand with greater rank.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This just means “if both integers have the same signedness, convert the smaller
    type to the bigger one.” We already do this when we implicitly convert values
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
    Section 6.3.1.1, paragraph 1, specifies the *integer conversion rank* of every
    integer type, which provides a relative order on their sizes without nailing down
    those sizes exactly. Of the types we have so far, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> have the
    highest rank, then <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. The signed
    and unsigned versions of the same type always have the same rank. Because of their
    relative conversion ranks, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    is guaranteed to be at least as large as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    but not necessarily larger. (In fact, the two types are the same size on most
    32-bit systems.) Regardless of their exact sizes, the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    and the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. No big
    surprises here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The third rule talks about cases with one signed operand and one unsigned operand:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if the operand that has unsigned integer type has rank greater or
    equal to the rank of the type of the other operand, then the operand with signed
    integer type is converted to the type of the operand with unsigned integer type.
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, if the two types are the same size, or if the unsigned type is bigger,
    we go with the unsigned type. For example, the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, and the common type
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>.
    That leaves the case where the signed type is bigger, which is covered by the
    fourth rule:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if the type of the operand with signed integer type can represent
    all of the values of the type of the operand with unsigned integer type, then
    the operand with unsigned integer type is converted to the type of the operand
    with signed integer type.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Under the System V x64 ABI, a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    can represent every value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>, so the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. This isn’t true in implementations
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    are the same size. In these implementations, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    has a higher rank than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    but can’t represent every value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. The fifth and final rule covers these implementations. Even though
    this rule doesn’t apply to us, I’ll include it for the sake of completeness:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, both operands are converted to the unsigned integer type corresponding
    to the type of the operand with signed integer type.
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, on systems where <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> are the same size,
    the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: This all boils down to three rules for finding the common type, which [Listing
    12-4](chapter12.xhtml#list12-4) describes in pseudocode.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Finding the common
    type of two integers</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if the types are the same, pick either one ❶. Otherwise, if they’re
    the same size, choose the unsigned one ❷. If they’re not the same size, choose
    the bigger one ❸. Apart from the usual arithmetic conversions, we’ll make one
    tiny update to the logic for type checking expressions: we’ll annotate unsigned
    constants with the correct type, in the same way that we already annotate signed
    constants.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at how we record the initial values of static variables in
    the symbol table. We’ll add two new kinds of static initializers, just like we
    added two new kinds of constants:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to convert each initializer to the type of the variable it’s initializing,
    according to the type conversion rules presented at the beginning of this chapter.
    Consider the following declaration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The value 4,294,967,299 is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. When adding <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    to the symbol table, we’ll convert this value to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> by subtracting 2^(32) from it. (In practice, you can probably just
    use the equivalent integer type conversion in your implementation language.) The
    resulting initializer will be <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(3)</samp>.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the same lines, this declaration initializes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with a value outside of its range:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we reduce this value modulo 2^(32), the resulting initializer will be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IntInit(-50)</samp>.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'It isn’t strictly necessary to have different static initializers for signed
    and unsigned variables. Instead, you could use <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit</samp>
    to represent both <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> initializers
    and use <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp> to represent
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> initializers. Ultimately, the assembler will write out the same bytes
    for an initializer whether you represent it as a signed or unsigned value: the
    directives <samp class="SANS_TheSansMonoCd_W5Regular_11">.long -50</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.long 4294967246</samp> mean exactly
    the same thing. Having separate <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit</samp> initializers
    just makes our type conversions easier to keep track of.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll make one addition to TACKY in this chapter: a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>
    instruction. [Listing 12-5](chapter12.xhtml#list12-5) defines the whole TACKY
    IR.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-5: Adding the</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">ZeroExtend</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction
    to TACKY</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Now we have to generate the right TACKY for cast expressions that convert to
    and from unsigned types. At the beginning of this chapter, we discussed how converting
    an integer to a new type affected its binary representation in four different
    cases. [Listing 12-6](chapter12.xhtml#list12-6) demonstrates what TACKY instructions
    to emit in each of those cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-6: Converting a
    cast expression to TACKY</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous chapter, the cast expression does nothing if the inner expression
    already has the correct type. Otherwise, we check if the original type and the
    target type are the same size ❶. If they are, we don’t need to extend, truncate,
    or otherwise change the inner value, because its representation in assembly won’t
    change. We just copy it into a temporary variable with the correct type. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction here may seem
    redundant, but we need it to help us track type information during assembly generation.
    We’ll generate different assembly for certain TACKY instructions depending on
    whether their operands are signed or unsigned. If we don’t store the result of
    each expression in a variable of the correct type, we’ll generate incorrect assembly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the target type is smaller than the original type ❷.
    In that case, we’ll issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>
    instruction. If that check also fails, this cast expression converts a smaller
    type to a larger one. We issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>
    instruction if the original type is signed ❸ and a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>
    instruction if it’s unsigned ❹.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Once your compiler generates the correct TACKY for unsigned constants and cast
    expressions, you can test it out.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Unsigned Integer Operations in Assembly</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In most cases, we can use exactly the same assembly instructions to operate
    on signed and unsigned values. However, there are two cases where we handle unsigned
    values differently: comparisons and division. We’ll need to translate the new
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp> instruction to
    assembly too. Before we update the assembly generation stage, let’s look at how
    unsigned comparisons, unsigned division, and zero extension work in assembly.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsigned Comparisons</samp>
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 4](chapter4.xhtml), you learned how to compare two integers: issue
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction to set
    the RFLAGS register, then issue a conditional instruction whose behavior depends
    on the state of that register. We’ll use the same approach to compare unsigned
    integers, but we need different condition codes that rely on different flags.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Several instructions that perform arithmetic, including <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>,
    don’t distinguish between signed and unsigned values. [Listing 12-7](chapter12.xhtml#list12-7)
    demonstrates how a single operation can implement both signed and unsigned addition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-7: Adding binary
    integers</samp>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: If we interpret the operands and the result as unsigned 4-bit integers, [Listing
    12-7](chapter12.xhtml#list12-7) calculates 8 + 2 = 10\. If we interpret them as
    signed 4-bit integers, it calculates −8 + 2 = −6\. As long as we interpret both
    operands and the result consistently, we get the right answer either way. You
    can think of the results of <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and most other arithmetic
    assembly instructions as sequences of bits with two possible values, one signed
    and one unsigned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'After the processor executes one of these instructions, some flags in RFLAGS
    tell us about the signed value of the result, others tell us about its unsigned
    value, and still others apply to both values. (Some flags have nothing to do with
    the results of these instructions, but we don’t care about them.) We discussed
    three flags in [Chapter 4](chapter4.xhtml): ZF, the zero flag; SF, the sign flag;
    and OF, the overflow flag. ZF applies whether we interpret the result as signed
    or unsigned, since zero is represented the same way in either case. The SF and
    OF flags, however, give us meaningful information only about the result’s signed
    value.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: SF, for example, indicates that the result is negative. In [Chapter 4](chapter4.xhtml),
    we used this flag to conclude that <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> was negative. In that case, assuming there was no overflow, we knew
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> was less than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. That won’t work for unsigned
    values, which are positive by definition. Consider [Listing 12-8](chapter12.xhtml#list12-8),
    which uses unsigned 4-bit integers to calculate 15 – 3.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-8: Subtracting binary
    integers</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Since 15 is greater than 3, the result of this operation is a positive number,
    12\. The fact that the result has a leading 1 doesn’t tell us anything about which
    operand is larger. Similarly, OF tells us that the signed value of some instruction’s
    result wrapped around from positive to negative, or vice versa, which doesn’t
    tell us anything useful about its unsigned value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare unsigned integers, we’ll use CF, the *carry flag*. This flag indicates
    that the unsigned value of a result wrapped around because the correct value was
    less than zero or greater than the maximum value the type could hold. For example,
    suppose we want to compute 15 + 1 with unsigned 4-bit integers. The 4-bit unsigned
    representation of 15 is <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>;
    when we increment it, it wraps around to <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>.
    This computation will set the carry flag to 1\. The carry flag will also be set
    if we try to calculate 0 – 1 and the result wraps around in the other direction
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>, or 15\. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> will always wrap around and set the carry flag. If <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    > b</samp>, the result will always be representable as an unsigned integer, so
    it won’t have to wrap around. Let’s walk through how <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp
    b, a</samp> will impact CF and ZF when we interpret <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> as unsigned integers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> will be 0, so ZF will be 1 and CF will be 0.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a > b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> will be a positive number. It will be greater than 0 but less than
    or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, so it won’t
    wrap around. ZF and CF will both be 0.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    - b</samp> will be negative, so it will have to wrap around. ZF will be 0 and
    CF will be 1.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that ZF and CF are mutually exclusive; one operation will never set both
    of them. All the condition codes we need in this chapter depend on one or both
    of these flags. [Table 12-1](chapter12.xhtml#tab12-1) lists these condition codes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-1:</samp> <samp class="SANS_Futura_Std_Book_11">Condition
    Codes for Unsigned Comparisons</samp>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Condition code</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Flags</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    == b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF set</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    != b</samp> | <samp class="SANS_Futura_Std_Book_11">ZF not set</samp> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    > b</samp> | <samp class="SANS_Futura_Std_Book_11">CF not set and ZF not set</samp>
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    >= b</samp> | <samp class="SANS_Futura_Std_Book_11">CF not set</samp> |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    < b</samp> | <samp class="SANS_Futura_Std_Book_11">CF set</samp> |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    <= b</samp> | <samp class="SANS_Futura_Std_Book_11">CF set or ZF set</samp> |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: We use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp> condition codes to test
    for equality and inequality, but we’ll use new codes to determine which of two
    operands is larger. The <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> in the new codes are
    mnemonics for “above” and “below.” The new condition codes can appear in conditional
    jump and set instructions, just like the old ones. [Listing 12-9](chapter12.xhtml#list12-9)
    demonstrates how to set EAX to 1 if the unsigned value in EDX is greater than
    10.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-9: Performing an
    unsigned comparison in assembly</samp>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'This follows exactly the same pattern as signed comparisons: we issue the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction, then zero out
    the destination, and finally issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    instruction with a suffix for the appropriate condition code.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsigned Division</samp>
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For most arithmetic operations, the same instruction can operate correctly on
    both signed and unsigned integers. But for division, this doesn’t work. Suppose
    we want to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">1000 / 0010</samp>.
    If we interpret these values as signed 4-bit integers, this is −8 / 2 and the
    result is −4, represented as <samp class="SANS_TheSansMonoCd_W5Regular_11">1100</samp>.
    If they’re unsigned 4-bit integers, this is 8 / 2 and the result is 4, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0100</samp>. There’s no way a single instruction
    can produce the correct result in both cases.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: So, we’ll need a new instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>,
    to perform unsigned division. This instruction works just like <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>.
    It takes one operand, which is its divisor. Its dividend is the value stored in
    EDX and EAX, or RDX and RAX if we’re working with quadwords. It stores the quotient
    in EAX or RAX, and it stores the remainder in EDX or RDX.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Since the dividend is unsigned, we zero extend it from EAX into EDX (or from
    RAX into RDX) instead of sign extending it. We accomplish this by zeroing out
    RDX instead of emitting a <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>
    instruction.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Zero Extension</samp>
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last operation we need to implement is zero extension. We can zero extend
    a longword to a quadword by moving it into a register; this zeroes out the register’s
    upper 4 bytes. Then, if we need to store the value in memory, we can move the
    whole 8-byte value to its final destination. The following code zero extends the
    value at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp> and then
    saves the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use the 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction to copy the value into the register and the 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp>
    instruction to copy it back out. If the final destination of the zero extension
    operation is a register instead of a location in memory, we need only the first
    4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction, which zero extends source values that are smaller than 4 bytes. We
    don’t need this instruction yet, but we’ll use it when we implement character
    types in [Chapter 16](chapter16.xhtml).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to work with unsigned integers in assembly, you’re ready
    to extend the assembly generation stage. [Listing 12-10](chapter12.xhtml#list12-10)
    defines the latest assembly AST, with this chapter’s additions bolded.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-10: The assembly
    AST with unsigned operations</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added the new condition codes and unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    instruction we discussed in the previous section. We’ve also added a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instruction to handle zero extension. For now, this instruction is only a placeholder.
    During the instruction fix-up pass, we’ll replace it with either one or two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions, depending on
    whether its destination is in memory or a register. (At the moment, the destination
    will always be in memory, so we’ll always need two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions; this will change once we implement register allocation in [Part
    III](part3.xhtml).) When we add character types, <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    will also represent the real <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction to zero extend 1-byte values.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Let’s recap the changes we’ll need to make to the assembly generation pass.
    First, when we convert source-level types to assembly types, we lose the distinction
    between signed and unsigned integers. Both <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> values
    in TACKY become quadwords in assembly, and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> values become
    longwords.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: When we convert a comparison instruction from TACKY to assembly, we start by
    looking up the type of either operand (both operands are guaranteed to have the
    same type). We then choose the appropriate condition code, depending on whether
    that type is signed. For example, to handle
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'we start by looking up the type of either <samp class="SANS_TheSansMonoCd_W5Regular_11">src1</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp> in the symbol table.
    Let’s say the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt</samp>.
    In this case, we’ll generate the following assembly instructions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These are exactly the same instructions we’d generate for a signed comparison,
    except that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    condition code instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: To handle a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Remainder</samp> operation, we
    copy the first operand into EAX, as before. Then, if the operands are signed,
    we sign extend EAX into EDX and issue an <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instruction. If they’re unsigned, we zero out EDX and issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    instruction. (Naturally, we’ll use RAX and RDX instead of EAX and EDX if the operands
    are quadwords.) For example, we’ll translate
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'into:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, we’ll convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>
    TACKY instruction into a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    assembly instruction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 12-2](chapter12.xhtml#tab12-2) through [12-5](chapter12.xhtml#tab12-5)
    summarize the latest updates to the conversion from TACKY to assembly. New constructs
    and changes to the way we convert existing constructs are bolded.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Divide, src1, src2,
    dst)</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp> |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Remainder, src1, src2,
    dst)</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp> |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ZeroExtend(src, dst)</samp>
    |  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">MovZeroExtend(src, dst)</samp>
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Comparisons to Assembly</samp>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp> |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">B</samp>
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">BE</samp>
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">A</samp>
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AE</samp>
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstUInt(int))</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp> |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstULong(int))</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp> |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">UInt</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4</samp> |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ULong</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: Next, we’ll update the pseudoregister replacement and instruction fix-up passes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll extend this pass to handle the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> instructions.
    Otherwise, there’s nothing to change here. This pass looks at each operand’s assembly
    type rather than its source-level type, so it doesn’t distinguish between signed
    and unsigned operands.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the Div
    and MovZeroExtend Instructions</samp>
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll rewrite both <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>. Like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>, the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    instruction can’t use a constant operand. We’ll rewrite it the same way as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>, copying its operand into
    R10 if we need to.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: We’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    with one or two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions.
    If its destination is a register, we’ll issue a single <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction. For example, we’ll rewrite
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'as:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If its destination is in memory, we’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction to zero extend into R11, then move it from there to the destination.
    So, we’ll rewrite
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'as:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We won’t make any other changes to this pass.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll make a few changes to the code emission stage in this chapter. First,
    we’ll add the <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> instruction
    and the new condition codes. We’ll also add our two new static initializers, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UIntInit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit</samp>,
    which we’ll emit exactly like their signed counterparts, <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp>. [Tables 12-6](chapter12.xhtml#tab12-6)
    through [12-8](chapter12.xhtml#tab12-8) demonstrate how to emit these new constructs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(0)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.zero 4</samp> |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(i)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp>
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(0)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.zero 8</samp> |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(i)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><i></samp>
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Div(t, operand)</samp> |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-8:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Suffixes for Condition Codes</samp>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Condition code</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Instruction
    suffix</samp> |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ae</samp>
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">be</samp>
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: I haven’t bolded the new constructs and changes in these tables like I normally
    do, because all of these assembly constructs are new.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you built on the foundations you laid in [Chapter 11](chapter11.xhtml)
    to implement two unsigned integer types. You waded through the C standard’s rules
    for type conversions and explored how those conversions impact both an integer’s
    representation and its value. In the type checker, you learned how signed and
    unsigned integers are converted to a common type. During assembly generation,
    you implemented zero extension and unsigned division and comparisons.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](chapter13.xhtml), you’ll add a floating-point type, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Floating-point numbers are processed very differently from integers in hardware;
    they even get their own set of registers! As you’ll see, those hardware differences
    impact everything from type conversions to function calling conventions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
