["```\nmul( *`reg8`* );        // returns \"ax\"\n          mul( *`reg16`* );       // returns \"dx:ax\"\n          mul( *`reg32`* );       // returns \"edx:eax\"\n\n          mul( *`mem8`* );        // returns \"ax\"\n          mul( *`mem16`* );       // returns \"dx:ax\"\n\n          mul( *`mem32`* );       // returns \"edx:eax\"\n```", "```\nimul( *`reg8`* );       // returns \"ax\"\n          imul( *`reg16`* );      // returns \"dx:ax\"\n          imul( *`reg32`* );      // returns \"edx:eax\"\n\n          imul( *`mem8`* );       // returns \"ax\"\n          imul( *`mem16`* );      // returns \"dx:ax\"\n\n          imul( *`mem32`* );      // returns \"edx:eax\"\n```", "```\nmul( *`operand8`* );\n```", "```\nimul( *`operand8`* );\n```", "```\nax := al * *`operand8`*\n```", "```\ndx:ax := ax * *`operand16`*\n```", "```\nedx:eax := eax * *`operand32`*\n```", "```\nmul( *`reg8`*, al );\n          mul( *`reg16`*, ax );\n          mul( *`reg32`*, eax );\n\n          mul( *`mem8`*, al );\n          mul( *`mem16`*, ax );\n          mul( *`mem32`*, eax );\n\n          mul( *`constant8`*, al );\n          mul( *`constant16`*, ax );\n\n          mul( *`constant32`*, eax );\n```", "```\nimul( *`reg8`*, al );\n          imul( *`reg16`*, ax );\n          imul( *`reg32`*, eax );\n\n          imul( *`mem8`*, al );\n          imul( *`mem16`*, ax );\n          imul( *`mem32`*, eax );\n\n          imul( *`constant8`*, al );\n          imul( *`constant16`*, ax );\n\n          imul( *`constant32`*, eax );\n```", "```\ndiv( *`reg8`* );                  // returns \"al\"\n          div( *`reg16`* );                 // returns \"ax\"\n          div( *`reg32`* );                 // returns \"eax\"\n\n          div( *`reg8`*, ax );              // returns \"al\"\n          div( *`reg16`*, dx:ax );          // returns \"ax\"\n          div( *`reg32`*, edx:eax );        // returns \"eax\"\n\n          div( *`mem8`* );                  // returns \"al\"\n          div( *`mem16`* );                 // returns \"ax\"\n          div( *`mem32`* );                 // returns \"eax\"\n\n          div( *`mem8`*, ax );              // returns \"al\"\n          div( *`mem16`*, dx:ax );          // returns \"ax\"\n          div( *`mem32`*, edx:eax );        // returns \"eax\"\n\n          div( *`constant8`*, ax );         // returns \"al\"\n          div( *`constant16`*, dx:ax );     // returns \"ax\"\n          div( *`constant32`*, edx:eax );   // returns \"eax\"\n\n          idiv( *`reg8`* );                 // returns \"al\"\n          idiv( *`reg16`* );                // returns \"ax\"\n          idiv( *`reg32`* );                // returns \"eax\"\n\n          idiv( *`reg8`*, ax );             // returns \"al\"\n          idiv( *`reg16`*, dx:ax );         // returns \"ax\"\n          idiv( *`reg32`*, edx:eax );       // returns \"eax\"\n\n          idiv( *`mem8`* );                 // returns \"al\"\n          idiv( *`mem16`* );                // returns \"ax\"\n          idiv( *`mem32`* );                // returns \"eax\"\n\n          idiv( *`mem8`*, ax );             // returns \"al\"\n          idiv( *`mem16`*, dx:ax );         // returns \"ax\"\n          idiv( *`mem32`*, edx:eax );       // returns \"eax\"\n\n          idiv( *`constant8`*, ax );        // returns \"al\"\n          idiv( *`constant16`*, dx:ax );    // returns \"ax\"\n          idiv( *`constant32`*, edx:eax );  // returns \"eax\"\n```", "```\nmod( *`reg8`* );                  // returns \"ah\"\n          mod( *`reg16`* );                 // returns \"dx\"\n          mod( *`reg32`* );                 // returns \"edx\"\n\n          mod( *`reg8`*, ax );              // returns \"ah\"\n          mod( *`reg16`*, dx:ax );          // returns \"dx\"\n          mod( *`reg32`*, edx:eax );        // returns \"edx\"\n\n          mod( *`mem8`* );                  // returns \"ah\"\n          mod( *`mem16`* );                 // returns \"dx\"\n          mod( *`mem32`* );                 // returns \"edx\"\n\n          mod( *`mem8`*, ax );              // returns \"ah\"\n          mod( *`mem16`*, dx:ax );          // returns \"dx\"\n          mod( *`mem32`*, edx:eax );        // returns \"edx\"\n\n          mod( *`constant8`*, ax );         // returns \"ah\"\n          mod( *`constant16`*, dx:ax );     // returns \"dx\"\n          mod( *`constant32`*, edx:eax );   // returns \"edx\"\n\n          imod( *`reg8`* );                 // returns \"ah\"\n          imod( *`reg16`* );                // returns \"dx\"\n          imod( *`reg32`* );                // returns \"edx\"\n\n          imod( *`reg8`*, ax );             // returns \"ah\"\n          imod( *`reg16`*, dx:ax );         // returns \"dx\"\n          imod( *`reg32`*, edx:eax );       // returns \"edx\"\n\n          imod( *`mem8`* );                 // returns \"ah\"\n          imod( *`mem16`* );                // returns \"dx\"\n          imod( *`mem32`* );                // returns \"edx\"\n\n          imod( *`mem8`*, ax );             // returns \"ah\"\n          imod( *`mem16`*, dx:ax );         // returns \"dx\"\n          imod( *`mem32`*, edx:eax );       // returns \"edx\"\n\n          imod( *`constant8`*, ax );        // returns \"ah\"\n          imod( *`constant16`*, dx:ax );    // returns \"dx\"\n          imod( *`constant32`*, edx:eax );  // returns \"edx\"\n```", "```\ncmp( *`LeftOperand`*, *`RightOperand`* );\n```", "```\ncmp( *`reg`*, *`reg`* );       // Registers must be the same size.\n          cmp( *`reg`*, *`mem`* );       // Sizes must match.\n          cmp( *`reg`*, *`constant`* );\n          cmp( *`mem`*, *`constant`* );\n```", "```\ncmp( ax, bx );\n```", "```\ncmp( *`Left`*, *`Right`* );\n```", "```\nLeft          minus     Right           S    O\n     ------                  ------          -    -\n\n     $FFFF (-1)      -       $FFFE (-2)      0    0\n     $8000           -       $0001           0    1\n     $FFFE (-2)      -       $FFFF (-1)      1    0\n     $7FFF (32767)   -       $FFFF (-1)      1    1\n```", "```\ncmp( eax, ebx );\n          if( @e ) then\n\n              << Do something if eax = ebx. >>\n\n          endif;\n```", "```\nif( eax = ebx ) then\n\n              << Do something if eax = ebx. >>\n\n          endif;\n```", "```\nset*`cc`*( *`reg8`* );\n          set*`cc`*( *`mem8`* );\n```", "```\n// bool := a <= b\n\n          mov( a, eax );\n          cmp( eax, b );\n          setle( bool );            // bool is a boolean or byte variable.\n```", "```\n// bool := ((a <= b) and (d = e))\n\n          mov( a, eax );\n          cmp( eax, b );\n          setle( bl );\n          mov( d, eax );\n          cmp( eax, e );\n          sete( bh );\n          and( bl, bh );\n          mov( bh, bool );\n```", "```\ntest( *`operand1`*, *`operand2`* );\n```", "```\ntest( eax, eax );\n          setz( bl );          // bl is set to 1 if eax contains 0.\n               .\n               .\n               .\n          test( bx, bx );\n          if( @nz ) then\n\n               << Do something if bx <> 0\\. >>\n\n          endif;\n```", "```\nx := y * z;\n```", "```\nmov( y, eax );\n          intmul( z, eax );\n          mov( eax, x );\n```", "```\n*`variable`* := *`constant`*\n```", "```\n*`var1`* := *`var2`*\n```", "```\nmov( *`constant`*, *`variable`* );\n```", "```\n*`var1`* := *`var2`*;\n```", "```\nmov( *`var2`*, eax );\n          mov( eax, *`var1`* );\n```", "```\n*`var1`* := *`term1 op term2`*;\n```", "```\nmov( *`term1`*, eax );\n          *`op`*( *`term2`*, eax );\n          mov( eax, *`var1`* )\n```", "```\nx := y + z;\n\n          mov( y, eax );\n          add( z, eax );\n          mov( eax, x );\n\nx := y - z;\n\n          mov( y, eax );\n          sub( z, eax );\n          mov( eax, x );\n\nx := y * z; {unsigned}\n\n          mov( y, eax );\n          mul( z, eax );     // Don't forget this wipes out edx.\n          mov( eax, x );\n\nx := y * z; {signed}\n\n          mov( y, eax );\n          intmul( z, eax );  // Does not affect edx!\n          mov( eax, x );\n\nx := y div z; {unsigned div}\n\n          mov( y, eax );\n          mov( 0, edx );       // Zero extend eax into edx.\n          div( z, edx:eax );\n          mov( eax, x );\n\nx := y idiv z; {signed div}\n\n          mov( y, eax );\n          cdq();               // Sign extend eax into edx.\n          idiv( z, edx:eax );\n          mov( eax, z );\n\nx := y mod z; {unsigned remainder}\n\n          mov( y, eax );\n          mov( 0, edx );       // Zero extend eax into edx.\n          mod( z, edx:eax );\n          mov( edx, x );       // Note that remainder is in edx.\n\nx := y imod z; {signed remainder}\n\n          mov( y, eax );\n          cdq();               // Sign extend eax into edx.\n          imod( z, edx:eax );\n          mov( edx, x );       // Remainder is in edx.\n```", "```\n*`var`* := -*`var`*\n```", "```\n*`var1`* := -*`var2`*\n```", "```\nmov( −14, *`var`* );\n```", "```\n// *`var1`* = -*`var1`*;\n\n          neg( *`var1`* );\n```", "```\n// *`var1`* = -*`var2`*;\n\n          mov( *`var2`*, eax );\n          neg( eax );\n          mov( eax, *`var1`* );\n```", "```\nw := w - y - z;\n```", "```\nmov( w, eax );\n          sub( y, eax );\n          sub( z, eax );\n          mov( eax, w );\n```", "```\nmov( y, eax );\n          sub( z, eax );\n          sub( eax, w );\n```", "```\nmov( y, eax );\n          add( z, eax );\n          sub( eax, w );\n```", "```\nx := w * y + z;\n```", "```\nx := (w * y) + z;\n```", "```\nx := w * (y + z);\n```", "```\nx *`op1`* y *`op2`* z\n```", "```\n// w := x + y * z;\n\n          mov( x, ebx );\n          mov( y, eax );      // Must compute y * z first because \"*\"\n          intmul( z, eax );   // has higher precedence than \"+\".\n          add( ebx, eax );\n          mov( eax, w );\n```", "```\n2^2^3 is equal to 2^(2^3) *`not`* (2^2)^3\n```", "```\n// w := x - y - z\n\n          mov( x, eax );      // All the same operator, so we need\n          sub( y, eax );      // to evaluate from left to right\n          sub( z, eax );      // because they all have the same\n          mov( eax, w );      // precedence and are left associative.\n\n// w := x + y * z\n\n          mov( y, eax );      // Must compute y * z first because\n          intmul( z, eax );   // multiplication has a higher\n          add( x, eax );      // precedence than addition.\n          mov( eax, w );\n\n// w := x / y - z\n\n          mov( x, eax );      // Here we need to compute division\n          cdq();              // first because it has the highest\n          idiv( y, edx:eax ); // precedence.\n          sub( z, eax );\n          mov( eax, w );\n\n// w := x * y * z\n\n          mov( y, eax );      // Addition and multiplication are\n          intmul( z, eax );   // commutative; therefore the order\n          intmul( x, eax );   // of evaluation does not matter.\n          mov( eax, w );\n```", "```\nw := x / y * z      // Note: This is (x * z) / y, not x / (y * z).\n```", "```\nw := x / y * z;\n```", "```\nmov( x, eax );\n          imul( z, eax );          // Note the use of imul, not intmul!\n          idiv( y, edx:eax );\n          mov( eax, w );\n```", "```\nw := x - y * x;\n```", "```\nmov( x, ebx );\n          mov( y, eax );\n          intmul( x, eax );\n          sub( eax, ebx );\n          mov( ebx, w );\n```", "```\nw := (a + b) * (y + z);\n```", "```\n*`temp1`* := a + b;\n          *`temp2`* := y + z;\n          w := *`temp1`* * *`temp2`*;\n```", "```\nmov( a, eax );\n          add( b, eax );\n          mov( eax, *`temp1`* );\n          mov( y, eax );\n          add( z, eax );\n          mov( eax, *`temp2`* );\n          mov( *`temp1`*, eax );\n          intmul( *`temp2`*, eax );\n          mov( eax, w );\n```", "```\nmov( a, eax );\n          add( b, eax );\n          mov( y, ebx );\n          add( z, ebx );\n          intmul( ebx, eax );\n          mov( eax, w );\n```", "```\nx := (y + z) * (a - b) / 10;\n```", "```\n*`temp1`* := (y + z)\n          *`temp2`* := (a - b)\n          *`temp1`* := *`temp1`* * *`temp2`*\n          X := *`temp1`* / 10\n```", "```\nmov( y, eax );            // Compute eax = y + z\n          add( z, eax );\n          mov( a, ebx );            // Compute ebx = a - b\n          sub( b, ebx );\n          imul( ebx, eax );         // This also sign extends eax into edx.\n          idiv( 10, edx:eax );\n          mov( eax, x );\n```", "```\n(A *`op`* B) = (B *`op`* A)\n```", "```\nb := ((x = y) and (a <= c)) or ((z - a) <> 5);\n```", "```\n// c = a AND b;\n\n     mov( a, al );\n     and( b, al );\n     mov( al, c );\n\n// c = a OR b;\n\n     mov( a, al );\n     or( b, al );\n     mov( al, c );\n\n// c = a XOR b;\n\n     mov( a, al );\n     xor( b, al );\n     mov( al, c );\n\n// b = NOT a;\n\n     mov( a, al );     // Note that the NOT instruction does not\n     not( al );        // properly compute al = NOT al by itself.\n     and( 1, al );     // I.e., (NOT 0) does not equal one. The AND\n     mov( al, b );     // instruction corrects this problem.\n\n     mov( a, al );     // Another way to do b = NOT a;\n     xor( 1, al );     // Inverts bit 0.\n     mov( al, b );\n```", "```\nb := ((x = y) and (a <= d)) or ((z - a) <> 5);\n```", "```\nmov( x, eax );\n          cmp( y, eax );\n          sete( al );       // al := x = y;\n\n          mov( a, ebx );\n          cmp( ebx, d );\n          setle( bl );     // bl := a <= d;\n          and( al, bl );   // bl := (x = y) and (a <= d);\n\n          mov( z, eax );\n          sub( a, eax );\n          cmp( eax, 5 );\n          setne( al );\n          or( bl, al );     // al := ((x = y) and (a <= d)) or ((z - a) <> 5);\n          mov( al, b );\n```", "```\nshl( 1, ax );          // Multiply ax by two.\n          mov( ax, bx);          // Save 2*ax for later.\n          shl( 2, ax );          // Multiply ax by eight (*4 really,\n                                 // but ax contains *2).\n          add( bx, ax );         // Add in ax*2 to ax*8 to get ax*10.\n```", "```\nintmul( 10, ax );\n```", "```\nmov( eax, ebx );             // Save eax * 1\n          shl( 3, eax );               // eax = eax * 8\n          sub( ebx, eax );             // eax * 8 - eax * 1 is eax * 7\n```", "```\nshl( 3, eax );\n          sub( 1, eax );\n```", "```\nlea( eax, [ecx][ecx] );       // eax := ecx * 2\n          lea( eax, [eax][eax*2] );     // eax := eax * 3\n          lea( eax, [eax*4] );          // eax := eax * 4\n          lea( eax, [ebx][ebx*4] );     // eax := ebx * 5\n          lea( eax, [eax*8] );          // eax := eax * 8\n          lea( eax, [edx][edx*8] );     // eax := edx * 9\n```", "```\nmov( 6554, dx );          // 6,554 = round( 65,536/10 )\n          mul( dx, ax );\n```", "```\ninc( CounterVar );\n          and( nBits, CounterVar );\n```", "```\ninc( CounterVar );\n          and( %00001111, CounterVar );\n```", "```\nfldcw( *`mem16`* );\nfstcw( *`mem16`* );\n```", "```\nstatic\n     fcw16: word;\n          .\n          .\n          .\n          fstcw( fcw16 );\n          mov( fcw16, ax );\n          and( $f0ff, ax );      // Clears bits 8-11.\n          or( $0c00, ax );       // Rounding control=%11, Precision = %00.\n          mov( ax, fcw16 );\n          fldcw( fcw16 );\n```", "```\nfld( st1 );\n          fld( *`real32_variable`* );\n          fld( *`real64_variable`* );\n          fld( *`real80_variable`* );\n          fld( (type real64 [ebx]) );\n          fld( *`real_constant`* );\n```", "```\nmov( eax, *`tempReal32`* );    // Save real32 value in eax to memory.\n    fld( *`tempReal32`* );         // Push that real value onto the FPU stack.\n```", "```\nfst( *`real32_variable`* );\n          fst( *`real64_variable`* );\n          fst( *`realArray`*[ ebx*8 ] );\n          fst( st2 );\n          fstp( st1 );\n```", "```\nfxch( st2 );\n          fsqrt();\n          fxch( st2 );\n```", "```\nfild( *`word_variable`* );\n          fild( *`dword_val`*[ ecx*4 ] );\n          fild( *`qword_variable`* );\n          fild( (type int64 [ebx]) );\n```", "```\nfist( *`word_var`*[ ebx*2 ] );\n          fist( *`qword_var`* );\n          fisttp( *`dword_var`* );\n          fistp( *`dword_var`* );\n```", "```\nstatic\n     fcw16:         word;\n     fcw16_2:       word;\n     IntResult:     int32;\n          .\n          .\n          .\n          fstcw( fcw16 );\n          mov( fcw16, ax );\n          or( $0c00, ax );        // Rounding control=%11 (truncate).\n          mov( ax, fcw16_2 );     // Store into memory and reload the ctrl word.\n          fldcw( fcw16_2 );\n\n          fistp( IntResult );     // Truncate ST0 and store as int32 object.\n\n          fldcw( fcw16 );         // Restore original rounding control.\n```", "```\n// Assuming fewer than 8 items on the stack, the following\n// code sequence is equivalent to an fbst instruction:\n\n          fld( st0 );\n          fbstp( *`tbyte_var`* );\n\n// The following example easily converts an 80-bit BCD value to\n// a 64-bit integer:\n\n          fbld( *`tbyte_var`* );\n          fist( *`qword_var`* );\n```", "```\nfadd()\n          faddp()\n          fadd( st0, st*`i`* );\n          fadd( st*`i`*, st0 );\n          faddp( st0, st*`i`* );\n          fadd( *`mem_32_64`* );\n          fadd( *`real_constant`* );\n```", "```\nfsub()\n          fsubp()\n          fsubr()\n          fsubrp()\n\n          fsub( st0, st*`i`* )\n          fsub( st*`i`*, st0 );\n          fsubp( st0, st*`i`* );\n          fsub( *`mem_32_64`* );\n          fsub( *`real_constant`* );\n\n          fsubr( st0, st*`i`* )\n          fsubr( st*`i`*, st0 );\n          fsubrp( st0, st*`i`* );\n          fsubr( *`mem_32_64`* );\n          fsubr( *`real_constant`* );\n```", "```\nfmul()\n          fmulp()\n\n          fmul( st*`i`*, st0 );\n          fmul( st0, st*`i`* );\n          fmul( *`mem_32_64`* );\n          fmul( *`real_constant`* );\n\n          fmulp( st0, st*`i`* );\n```", "```\nfdiv()\n          fdivp()\n          fdivr()\n          fdivrp()\n\n          fdiv( st*`i`*, st0 );\n          fdiv( st0, st*`i`* );\n          fdivp( st0, st*`i`* );\n\n          fdivr( st*`i`*, st0 );\n          fdivr( st0, st*`i`* );\n          fdivrp( st0, st*`i`* );\n\n          fdiv( *`mem_32_64`* );\n          fdivr( *`mem_32_64`* );\n          fdiv( *`real_constant`* );\n          fdivr( *`real_constant`* );\n```", "```\nfdiv( st*`i`*, st0 );          // st0 := st0/st*`i`*\n          fdiv( st0, st*`i`* );          // st*`i`* := st*`i`*/st0\n          fdivp( st0, st*`i`* );         // st*`i`* := st*`i`*/st0 then pop st0\n          fdivr( st0, st*`i`* );         // st0 := st0/st*`i`*\n          fdivrp( st0, st*`i`* );        // st*`i`* := st0/st*`i`* then pop st0\n```", "```\n// Compute z := sqrt(x**2 + y**2);\n\n          fld( x );                  // Load x.\n          fld( st0 );                // Duplicate x on TOS.\n          fmulp();                   // Compute x**2.\n\n          fld( y );                  // Load y.\n          fld( st0 );                // Duplicate y.\n          fmul();                    // Compute y**2.\n\n          faddp();                   // Compute x**2 + y**2.\n          fsqrt();                   // Compute sqrt( x**2 + y**2 ).\n          fstp( z );                 // Store result away into z.\n```", "```\n// Compute z := x mod y\n\n          fld( y );\n          fld( x );\n          repeat\n\n               fprem1();\n               fstsw( ax );   // Get condition code bits into ax.\n               and( 1, ah );  // See if C2 is set.\n\n          until( @z );        // Repeat until C2 is clear.\n          fstp( z );          // Store away the remainder.\n          fstp( st0 );        // Pop old y value.\n```", "```\n// Compute x := sqrt(abs(x));\n\n          fld( x );\n          fabs();\n          fsqrt();\n          fstp( x );\n```", "```\n// Compute x := -x if x is positive, x := x if x is negative.\n// That is, force x to be a negative value.\n\n          fld( x );\n          fabs();\n          fchs();\n          fstp( x );\n```", "```\nfcom()\n          fcomp()\n          fcompp()\n\n          fcom( st*`i`* )\n          fcomp( st*`i`* )\n\n          fcom( *`mem_32_64`* )\n          fcomp( *`mem_32_64`* )\n          fcom( *`real_constant`* )\n          fcomp( *`real_constant`* )\n```", "```\nfcompp();\n          fstsw( ax );\n          sahf();\n          setb( al );   // al = true if st1 < st0.\n               .\n               .\n               .\n```", "```\nfcompp();\n          fstsw( ax );\n          sahf();\n          if( @b ) then\n\n               << Code that executes if st1 < st0 >>\n\n          endif;\n```", "```\nfcomi()\n          fcomip()\n          fcomi( st*`i`* )\n          fcomip( st*`i`* )\n\n          fcomi( *`mem_32_64`* )\n          fcomip( *`mem_32_64`* )\n          fcomi( *`real_constant`* )\n          fcomip( *`real_constant`* )\n```", "```\nftst();\n          fstsw( ax );\n          sahf();\n          sete( al );                         // Set al to 1 if TOS = 0.0\n```", "```\nfldz()               // Pushes +0.0.\n          fld1()               // Pushes +1.0.\n          fldpi()              // Pushes pi.\n          fldl2t()             // Pushes log2(10).\n          fldl2e()             // Pushes log2(e).\n          fldlg2()             // Pushes log10(2).\n          fldln2()             // Pushes ln(2).\n```", "```\nfld( x );\n          fldl2t();\n          fmul();\n          f2xm1();\n          fld1();\n          fadd();\n```", "```\nfyl2x();\n```", "```\nfyl2xp1();\n```", "```\nfinit();\n         fninit();\n```", "```\nfldcw( *`mem16`* );\n          fstcw( *`mem16`* );\n```", "```\nfclex();\n     fnclex();\n```", "```\nfstsw( ax );\n          fnstsw( ax );\n          fstsw( *`mem16`* );\n          fnstsw( *`mem16`* );\n```", "```\nfiadd( *`int_16_32`* );\n          fisub( *`int_16_32`* );\n          fisubr( *`int_16_32`* );\n          fimul( *`int_16_32`* );\n          fidiv( *`int_16_32`* );\n          fidivr( *`int_16_32`* );\n\n          ficom( *`int_16_32`* );\n          ficomp( *`int_16_32`* );\n```", "```\ninfix notation                     postfix notation\n          5 + 6                              5  6  +\n          7 − 2                              7  2  −\n          x * y                              x  y  *\n          a / b                              a  b  /\n```", "```\nfld( 5.0 );\n          fld( 6.0 );\n          fadd();                    // 11.0 is now on the top of the FPU stack.\n```", "```\ninfix notation                    postfix notation\n          (x + y) * 2                       x  y + 2 *\n          x * 2 − (a + b)                   x 2 * a b + −\n          (a + b) * (c + d)                 a b + c d + *\n```", "```\n//          x y + 2 *\n\n          fld( x );\n          fld( y );\n          fadd();\n          fld( 2.0 );\n          fmul();\n\n//          x 2 * a b + −\n\n          fld( x );\n          fld( 2.0 );\n          fmul();\n          fld( a );\n          fld( b );\n          fadd();\n          fsub();\n\n//          a b + c d + *\n\n          fld( a );\n          fld( b );\n          fadd();\n          fld( c );\n          fld( d );\n          fadd();\n          fmul();\n```", "```\nx = ((y - z) * a) - ( a + b * c ) / 3.14159\n```", "```\nx = ([y z -] * a) - ( a + b * c ) / 3.14159\n```", "```\nx = [y z - a *] - ( a + b * c ) / 3.14159\n```", "```\nx = [y z - a *] - ( a + [b c *]) / 3.14159\n```", "```\nx = [y z - a *] - [a b c * +] / 3.14159\n```", "```\nx = [y z - a *] - [a b c * + 3.14159 /]\n```", "```\nx = [y z - a *] [a b c * + 3.14159 /] -\n```", "```\nx = y z - a * a b c * + 3.14159 / -\n```", "```\na = (x * y - z + t) / 2.0\n```", "```\n    a = ( [x y *] - z + t) / 2.0\n    ```", "```\n    a = ( [x y * z -] + t) / 2.0\n    ```", "```\n    a = [x y * z - t +] / 2.0\n    ```", "```\n    a = [x y * z - t + 2.0 / ]\n    ```", "```\n    a = x y * z - t + 2.0 /\n    ```", "```\nx = y z - a * a b c * + 3.14159 / -\n```", "```\n    fld( y );\n              fld( z );\n              fsub();\n              fld( a );\n              fmul();\n              fld( a );\n              fld( b );\n              fld( c );\n              fmul();\n              fadd();\n              fldpi();       // Loads pi (3.14159)\n              fdiv();\n              fsub();\n\n              fstp( x );     // Store result away into x.\n    ```", "```\n    a = x y * z - t + 2.0 /\n              fld( x );\n              fld( y );\n              fmul();\n              fld( z );\n              fsub();\n              fld( t );\n              fadd();\n              fld( 2.0 );\n              fdiv();\n\n              fstp( a );     // Store result away into a.\n    ```"]