- en: Chapter 12. Bypassing Antivirus Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your pentesting clients will most likely be running some sort of antivirus solution.
    So far in this book we’ve avoided having any of our malicious executables deleted
    by antivirus applications, but antivirus program avoidance is a constantly changing
    field. Typically you will be more likely to avoid detection by using a memory-corruption
    exploit and loading your payload directly into memory—that is, by never touching
    the disk. That said, with the attack landscape shifting to emphasize client-side
    and social-engineering attacks, it may not always be possible to avoid writing
    your payload to disk. In this chapter we’ll look at a few techniques for obscuring
    our malware to try to avoid detection when the payload is written to the disk.
  prefs: []
  type: TYPE_NORMAL
- en: Trojans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit Framework"), we created
    a standalone malicious executable that runs a Metasploit payload. Though we may
    be able to use social engineering to trick a user into downloading and running
    our malicious file, the lack of any functionality other than our executable’s
    payload could tip off users that something is amiss. We’d be much more likely
    to evade detection if we could hide our payload inside of some legitimate program
    that would run normally, with our payload running in the background. Such a program
    is called a *trojan*, after the legendary wooden horse that ended the Trojan War.
    The horse appeared to be an innocuous offering to the gods and was brought inside
    the previously impenetrable walled city of Troy, with enemy soldiers hiding inside,
    ready to attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'We encountered a trojan in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation"):
    The Vsftpd server on our Ubuntu target had a backdoor that could be triggered
    at login by entering a smiley face as part of the username. Attackers compromised
    the source code repositories for Vsftpd and added additional trojan functionality
    to the program. Anyone who downloaded Vsftpd from the official repositories between
    the initial compromise and detection ended up with a trojaned version.'
  prefs: []
  type: TYPE_NORMAL
- en: Msfvenom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although reverse-engineering binaries or gaining access to source code and manually
    adding trojan code is beyond the scope of this book, the Msfvenom tool has some
    options we can use to embed a Metasploit payload inside a legitimate binary. [Example 12-1](ch12.xhtml#msfvenom_help_page
    "Example 12-1. Msfvenom help page") shows some important options we have not encountered
    previously in the text.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1. Msfvenom help page
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the `-x` flag ❶ allows us to use an executable file as a template
    in which to embed our chosen payload. However, though the resulting executable
    will look like the original one, the added payload will pause the execution of
    the original, and we shouldn’t expect a user to run an executable that appears
    to hang at startup very many times. Luckily, Msfvenom’s `-k` flag ❷ will keep
    the executable template intact and run our payload in a new thread, allowing the
    original executable to run normally.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the `-x` and `-k` flags to build a trojaned Windows executable that
    will appear normal to a user but which will send us a Meterpreter session in the
    background. To do so, we choose the payload with the `-p` flag and set the relevant
    payload options as in [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit
    Framework"). Any legitimate executable will do; you’ll find some useful Windows
    binaries for pentesting in Kali Linux at */usr/share/windows-binaries*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed our payload inside the *radmin.exe* binary enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our Msfvenom command specifies the payload to generate with the `-p` option.
    We set the `LHOST` option to the IP address of Kali, the system to call back to
    when the payload runs. We can also set the `LPORT` option. As discussed in this
    section, the `-x` option selects an executable in which to embed our payload.
    The `-k` option runs the payload in a separate thread. The `-f` flag tells Msfvenom
    to build the payload in the executable format. Once created, run the trojaned
    binary on either the Windows XP or Windows 7 target. The Radmin Viewer program
    should appear to run normally ([Figure 12-1](ch12.xhtml#trojaned_radmin_viewer_executable
    "Figure 12-1. Trojaned Radmin Viewer executable")), but the embedded payload should
    give us a Meterpreter session if we set up a handler using the *multi/handler*
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '![Trojaned Radmin Viewer executable](httpatomoreillycomsourcenostarchimages2030404.png.jpg)Figure 12-1. Trojaned
    Radmin Viewer executableChecking for Trojans with the MD5 Hash'
  prefs: []
  type: TYPE_NORMAL
- en: Our trojaned binary should convince the average user that the program is legitimate.
    Security-savvy users should verify the integrity of a downloaded file before running
    it by checking its MD5 hash against the value published by the vendor, where available.
    An MD5 hash is a kind of file fingerprint; if changes are made to the file, the
    MD5 hash will change.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s compare the MD5 hashes of the original *radmin.exe* with our trojaned
    version. In Kali Linux, the `md5sum` program will calculate a file’s MD5 hash.
    Run `md5sum` on both binaries, and you’ll find that the hash values are dramatically
    different, as you can see here at ❶ and ❷.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, the MD5 hashing algorithm is not perfect, and a tampered binary could
    have the same MD5 hash as the original file, which is known as an *MD5 collision
    attack*. For this reason, many vendors publish a Secure Hash Algorithm (SHA) hash
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, checking two separate hash values is better than checking one. The
    SHA family contains multiple hashing algorithms, and the version used will vary
    among vendors. Kali comes with programs for various SHA hashes. For example, `sha512sum`
    calculates the 64-bit block size SHA-2 hash, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When installing software, be sure to calculate the hash(es) of your downloaded
    version, and compare it to the value(s) published by the vendor.
  prefs: []
  type: TYPE_NORMAL
- en: How Antivirus Applications Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we try different techniques to get our Metasploit payloads past an antivirus
    program, let’s discuss how these programs work. Most antivirus solutions start
    by comparing potentially dangerous code to a set of patterns and rules that make
    up the *antivirus definitions*, which match known malicious code. Antivirus definitions
    are updated regularly as new malware is identified by each vendor. This sort of
    identification is called *static analysis*.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to static analysis against a set of signatures, more advanced antivirus
    solutions also test for malicious activity, called *dynamic analysis*. For example,
    a program that tries to replace every file on the hard drive or connects to a
    known botnet command and control server every 30 seconds is exhibiting potentially
    malicious activity and may be flagged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some antivirus products, such as Google’s Bouncer, run new apps that are uploaded
    to the Google Play store and pass static analysis in an isolated sandbox to try
    to detect malicious activity that doesn’t have a known malicious signature.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Security Essentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we use different methods in this section to bring down our detection rate,
    keep in mind that even if you not able to get a 0 percent detection rate among
    all antivirus vendors, if you know which antivirus solution is deployed in your
    client’s environment, you can focus your efforts on clearing just that antivirus
    program. In this chapter, we will try to bypass Microsoft Security Essentials
    using various methods.
  prefs: []
  type: TYPE_NORMAL
- en: When we created our Windows 7 target in [Chapter 1](ch01.xhtml "Chapter 1. Setting
    Up Your Virtual Lab"), we installed Microsoft Security Essentials, but we didn’t
    turn on real-time protection to scan files as they are downloaded or installed.
    Now let’s turn on this protection to see if we can create an undetectable trojan.
    Open Microsoft Security Essentials, select the **Settings** tab, choose **Real-time
    protection**, and check the box to turn on the service, as shown in [Figure 12-2](ch12.xhtml#microsoft_security_essentials_real-time
    "Figure 12-2. Microsoft Security Essentials real-time protection"). Click **Save
    changes**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft Security Essentials real-time protection](httpatomoreillycomsourcenostarchimages2030406.png.jpg)Figure 12-2. Microsoft
    Security Essentials real-time protection'
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, even free antivirus solutions like Microsoft Security Essentials
    do a good job of catching Metasploit payloads. For a real test, try installing
    the trojaned *radmin.exe* with real-time protection turned on. You should see
    a pop-up at the bottom-right corner of the screen, like the one shown in [Figure 12-3](ch12.xhtml#malicious_software_detected
    "Figure 12-3. Malicious software detected"). The file is automatically deleted
    before the user can run it—that certainly puts a damper on things.
  prefs: []
  type: TYPE_NORMAL
- en: '![Malicious software detected](httpatomoreillycomsourcenostarchimages2030408.png.jpg)Figure 12-3. Malicious
    software detected'
  prefs: []
  type: TYPE_NORMAL
- en: VirusTotal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to see which antivirus solutions will flag a program as malicious is
    to upload the file in question to the VirusTotal website (*[https://www.virustotal.com/](https://www.virustotal.com/)*).
    As of this writing, VirusTotal scans uploaded files with 51 antivirus programs
    and reports which ones detect malware. VirusTotal is shown in [Figure 12-4](ch12.xhtml#virustotal-id00034
    "Figure 12-4. VirusTotal").
  prefs: []
  type: TYPE_NORMAL
- en: '![VirusTotal](httpatomoreillycomsourcenostarchimages2030410.png.jpg)Figure 12-4. VirusTotal'
  prefs: []
  type: TYPE_NORMAL
- en: To see which antivirus programs detect our trojaned *radmin.exe* as currently
    written, upload the file to VirusTotal and click **Scan it!**. Because antivirus
    definitions are constantly updated, your results will differ, but as you can see
    in [Figure 12-5](ch12.xhtml#trojaned_binary_antivirus_detection "Figure 12-5. Trojaned
    binary antivirus detection"), 25 of 51 scanners detected our file as malicious.
    (The bottom of the page shows which scanners detected the malware.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Trojaned binary antivirus detection](httpatomoreillycomsourcenostarchimages2030412.png.jpg)Figure 12-5. Trojaned
    binary antivirus detection'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VirusTotal shares uploaded binaries with antivirus vendors so they can write
    signatures to match. Antivirus companies use VirusTotal signatures to improve
    their detection engines, so anything you upload to the site may be caught by antivirus
    software just because you uploaded it. To avoid that risk, you can install the
    antivirus product on a virtual machine and test your trojans manually against
    it, as we did in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Past an Antivirus Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clearly if we want to get past antivirus solutions, we need to try harder to
    hide. Let’s look at some other useful ways to hide our Metasploit payloads besides
    simply placing them inside of an executable.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Encoders are tools that allow you to avoid characters in an exploit that would
    break it. (You’ll learn more about these requirements when we write our own exploits
    in [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer Overflow in Linux")
    through [Chapter 19](ch19.xhtml "Chapter 19. Fuzzing, Porting Exploits, and Metasploit
    Modules").) At the time of this writing, Metasploit supports 32 encoders. Encoders
    mangle the payload and prepend decoding instructions to be executed in order to
    decode the payload before it is run. It is a common misperception that Metasploit’s
    encoders were designed to help bypass antivirus programs. Some Metasploit encoders
    create polymorphic code, or mutating code, which ensures that the encoded payload
    looks different each time the payload is generated. This process makes it more
    difficult for antivirus vendors to create signatures for the payload, but as we
    will see, it is not enough to bypass most antivirus solutions.
  prefs: []
  type: TYPE_NORMAL
- en: To list all of the encoders available in Msfvenom, use the **`-l encoders`**
    option, as shown in [Example 12-2](ch12.xhtml#msfvenom_encoders "Example 12-2. Msfvenom
    encoders").
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-2. Msfvenom encoders
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The only encoder with an excellent rank is *x86/shikata_ga_nai* ❶. *Shikata
    Ga Nai* is Japanese for “It can’t be helped.” Encoder rankings are based on the
    entropy level of the output. With *shikata_ga_nai*, even the decoder stub is polymorphic.
    The nitty-gritty details of how this encoder works are beyond the scope of this
    book, but suffice it to say that it mangles payloads beyond easy recognition.
  prefs: []
  type: TYPE_NORMAL
- en: Tell Msfvenom to use the *shikata_ga_nai* encoder with the `-e` flag, as shown
    in [Example 12-3](ch12.xhtml#creating_an_encoded_executable_with_msfv "Example 12-3. Creating
    an encoded executable with Msfvenom"). Additionally, for further obfuscation,
    we’ll run our payload through an encoder multiple times, encoding the output from
    the previous round with the `-i` flag and specifying the number of encoding rounds
    (10 in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-3. Creating an encoded executable with Msfvenom
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now upload the resulting binary to VirusTotal. As you can see in [Figure 12-6](ch12.xhtml#virustotal_results_for_an_encoded_binary
    "Figure 12-6. VirusTotal results for an encoded binary"), 35 of the tested antivirus
    products detected our payload, even with the encoding. That’s a higher detection
    rate than we found when embedding our payload inside a prebuilt executable. In
    other words, *shikata_ga_nai* alone doesn’t do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: '![VirusTotal results for an encoded binary](httpatomoreillycomsourcenostarchimages2030414.png.jpg)Figure 12-6. VirusTotal
    results for an encoded binary'
  prefs: []
  type: TYPE_NORMAL
- en: To see if we can improve our results, we can try experimenting with using multiple
    Metasploit encoders on our payload. For example, we can combine multiple rounds
    of *shikata_ga_nai* with another Metasploit encoder, *x86/bloxor*, as shown in
    [Example 12-4](ch12.xhtml#multiencoding_with_msfvenom "Example 12-4. Multiencoding
    with Msfvenom").
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-4. Multiencoding with Msfvenom
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This time, we start out with Msfvenom using the *windows/meterpreter/reverse_tcp*
    payload as usual and encode it with *shikata_ga_nai*, as in the previous example.
    However, instead of setting the format to *.exe*, we output in raw format ❶. Also,
    instead of outputting the results to an *.exe* file as we did previously, this
    time we output the raw bytes into a *.bin* file ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we take the results of the *shikata_ga_nai* encoding and encode it with
    the *x86/bloxor* encoder. Our syntax for Msfvenom will differ from what we are
    used to. First, we set the payload to null with the option `-p -` ❸. And, because
    we are not setting a payload, we need to tack on two new options to tell Msfvenom
    how to encode our input: `-a x86` ❹ to specify the architecture as 32 bit, and
    `--platform windows` ❺ to specify the Windows platform. Finally, at the end of
    the Msfvenom command, we use the `<` symbol to pipe the *.bin* file from the previous
    command as input into Msfvenom ❻. The resulting executable will be encoded with
    *shikata_ga_nai* and *x86/bloxor*.'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting executable is detected by 33 antivirus programs on VirusTotal
    as of this writing—slightly better than *shikata_ga_nai* by itself. You may be
    able to improve your results by experimenting with different sets of encoders
    and chaining more than two encoders together, or by combining techniques. For
    example, what if we both embed our payload in a binary and encode it with *shikata_ga_nai*
    as shown here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This gave only a slight improvement: The payload was detected by 21 antivirus
    programs. And, unfortunately, Microsoft Security Essentials flagged both executables
    as malicious, as shown in [Figure 12-7](ch12.xhtml#microsoft_is_still_flagging_this_binary
    "Figure 12-7. Microsoft is still flagging this binary as malicious."). We need
    to look beyond Metasploit encoders if we’re going to get past antivirus detection
    on our Windows 7 target.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft is still flagging this binary as malicious.](httpatomoreillycomsourcenostarchimages2030416.png.jpg)Figure 12-7. Microsoft
    is still flagging this binary as malicious.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom Cross Compiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the de facto standard for penetration testing, Metasploit gets a fair amount
    of attention from antivirus vendors who make detecting the signatures for payloads
    generated by Msfvenom a priority. When Msfvenom creates an executable, it uses
    prebuilt templates that antivirus vendors can use to build detection signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps we can improve our ability to bypass antivirus solutions by compiling
    an executable ourselves using raw shellcode. Let’s start with a simple C template,
    as shown in [Example 12-5](ch12.xhtml#custom_executable_template "Example 12-5. Custom
    executable template"). (We discussed the basics of C programming in [Chapter 3](ch03.xhtml
    "Chapter 3. Programming"). Review that section if this program doesn’t make sense
    to you.) Save this code to a file called *custommeterpreter.c*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-5. Custom executable template
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We need to fill in data for the variables `random` ❶ and `shellcode` ❷, which
    are both unsigned character arrays. Our hope is that adding some randomness and
    compiling our own C code will be enough to trick antivirus programs. The `random`
    variable will introduce some randomness to the template. The `shellcode` variable
    will hold the raw hexadecimal bytes of the payload we create with Msfvenom. The
    `main` function ❸ runs when our compiled C program starts and executes our shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: Create your payload in Msfvenom as usual, except this time set the format with
    the `-f` flag to `c`, as shown in [Example 12-6](ch12.xhtml#creating_a_raw_payload_in_c_format
    "Example 12-6. Creating a raw payload in C format"). This will create hex bytes
    that we can drop into our C file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-6. Creating a raw payload in C format
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to add some randomness. A good place to find randomness on
    a Linux system is in the */dev/urandom* file. This file is specifically designed
    as a pseudorandom number generator; it generates data using entropy in the Linux
    system.
  prefs: []
  type: TYPE_NORMAL
- en: But if we just `cat` out data from */dev/urandom*, we’ll get a lot of unprintable
    characters. To get the proper data for a character array, we’ll use the `tr` Linux
    utility to translate the */dev/urandom* data to printable characters. Use `tr
    -dc A-Z-a-z-0-9`, and then pipe the commands into the `head` command to output
    only the first 512 characters from */dev/urandom*, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now drop the data from */dev/urandom* into the `random` variable in the C file.
    The finished file is shown in [Example 12-7](ch12.xhtml#finished_custom_c_file
    "Example 12-7. Finished custom C file"). (Of course, your randomness and encoded
    payload will differ.) Be sure to surround the string with quotes and use a semicolon
    (`;`) at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-7. Finished custom C file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to compile the C program. We can’t use the built-in GCC program
    because it would compile our program to run on Linux systems, and we want to run
    it on a 32-bit Windows system. Instead, we’ll use the Mingw32 cross compiler from
    the Kali Linux repositories, which we installed in [Chapter 1](ch01.xhtml "Chapter 1. Setting
    Up Your Virtual Lab"). If you haven’t already installed it, install it with **`apt-get
    install mingw32`**, and then compile your custom C file with **`i586-mingw32msvc-gcc`**.
    (Other than the program name, the syntax for using the cross compiler is the same
    as for Linux’s built-in GCC, discussed in [Chapter 3](ch03.xhtml "Chapter 3. Programming").)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now upload the resulting executable to VirusTotal. As of this writing, 18 antivirus
    products detected the malicious file. That’s an improvement, but Microsoft Security
    Essentials is still catching our file.
  prefs: []
  type: TYPE_NORMAL
- en: We still need to work a little harder to get a malicious executable onto our
    Windows 7 system. (You could have better success with this technique with another
    cross compiler from another repository.)
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting Executables with Hyperion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to obfuscate our payload is to encrypt it. One executable encrypter
    is Hyperion, which uses Advanced Execution Standard (AES) encryption, a current
    industry standard. After encrypting the executable, Hyperion throws away the encryption
    keys. When the executable runs, it brute-forces the encryption key to decrypt
    itself back to the original executable.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any background in cryptography, this process should raise a lot
    of red flags. AES is currently considered a secure encryption standard. If the
    executable doesn’t have access to the encryption key, it should not be able to
    brute-force the key in any reasonable amount of time, certainly not fast enough
    for our program to run in the time window of our pentest. What’s going on?
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, Hyperion greatly reduces the possible keyspace for the encryption
    key, which means that binaries encrypted with it shouldn’t be considered cryptographically
    secure. However, because our goal and the goal of the Hyperion authors is to obfuscate
    the code to bypass antivirus detection, the fact that the key can be brute-forced
    is not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by using Hyperion to encrypt at simple Meterpreter executable with
    no additional antivirus avoidance techniques, as shown in [Example 12-8](ch12.xhtml#running_hyperion
    "Example 12-8. Running Hyperion"). (We installed Hyperion in [Chapter 1](ch01.xhtml
    "Chapter 1. Setting Up Your Virtual Lab")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-8. Running Hyperion
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Hyperion was written to run on Windows systems, but we can run it on Kali Linux
    with the Wine program, as you can see in [Example 12-8](ch12.xhtml#running_hyperion
    "Example 12-8. Running Hyperion"). Be sure to change into the Hyperion directory
    created when you unzipped the source before running *hyperion.exe* with Wine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyperion takes two arguments: the name of the file to encrypt and the name
    of the encrypted output file. Run Hyperion to encrypt the simple Meterpreter executable
    as shown at ❶. The resulting file is in the Hyperion 1.0 directory, so upload
    it to VirusTotal from there.'
  prefs: []
  type: TYPE_NORMAL
- en: Using just a Meterpreter executable generated with Msfvenom (with no encoding,
    custom templates, or anything else) and encrypting it with Hyperion resulted in
    27 antivirus programs in VirusTotal detecting the malicious behavior. That’s not
    our lowest detection rate yet, but we have finally achieved our goal. As shown
    in [Figure 12-8](ch12.xhtml#microsoft_security_essentials_does_not_d "Figure 12-8. Microsoft
    Security Essentials does not detect malware."), Microsoft Security Essentials
    did not detect any malicious activity!
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft Security Essentials does not detect malware.](httpatomoreillycomsourcenostarchimages2030418.png.jpg)Figure 12-8. Microsoft
    Security Essentials does not detect malware.'
  prefs: []
  type: TYPE_NORMAL
- en: Sure enough, we can download and run the Hyperion-encrypted executable on the
    Windows 7 system with antivirus protection and get a Meterpreter session. We haven’t
    achieved a 0 percent detection rate—the holy grail for antivirus bypass researchers—but
    we have been able to meet our pentest goals.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To lower our detection rate even more, try combining Hyperion encryption with
    other techniques from this section. For example, using Hyperion with a custom
    template dropped my detection number down to 14.
  prefs: []
  type: TYPE_NORMAL
- en: Evading Antivirus with Veil-Evasion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we have successfully reached our goal of bypassing Microsoft Security
    Essentials on Windows 7, the antivirus landscape changes rapidly, so it is worthwhile
    to keep abreast of the latest tools and techniques. Veil-Evasion is a Python framework
    that automates creating antivirus-evading payloads, giving users the choice of
    multiple techniques. We covered installing Veil-Evasion on Kali Linux in [Chapter 1](ch01.xhtml
    "Chapter 1. Setting Up Your Virtual Lab"); refer back if you need a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As updates are made to Veil-Evasion, your version may be different from what
    is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Python Shellcode Injection with Windows APIs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Previously we looked at using a custom C template to compile and execute shellcode.
    We can do something similar with Python’s Ctypes library, which gives us access
    to Windows API function calls and can create C-compatible data types. We can use
    Ctypes to access the Windows API VirtualAlloc, which creates a new executable
    memory region for the shellcode and locks the memory region in physical memory,
    to avoid a page fault as shellcode is copied in and executed. `RtlMoveMemory`
    is used to copy the shellcode bytes into the memory region created by VirtualAlloc.
    The `CreateThread` API creates a new thread to run the shellcode, and finally,
    `WaitForSingleObject` waits until the created thread is finished and our shellcode
    has finished running.
  prefs: []
  type: TYPE_NORMAL
- en: These steps collectively are referred to as the *VirtualAlloc injection method*.
    This method, of course, would give us a Python script rather than a Windows executable,
    but you can use multiple tools to convert a Python script into a stand-alone executable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Encrypted Python-Generated Executables with Veil-Evasion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the methods implemented in Veil-Evasion uses the Python injection technique
    described earlier. To provide further antivirus protection, Veil-Evasion can use
    encryption. For our example, we will use Python VirtualAlloc injection combined
    with AES encryption, as we did in the Hyperion example earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To start Veil-Evasion, change directories to *Veil-Evasion-master* and run *./Veil-Evasion.py*.
    You should be presented with a menu-based prompt similar to those we saw in SET
    in the previous chapter, as shown in [Example 12-9](ch12.xhtml#running_veil "Example 12-9. Running
    Veil").
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-9. Running Veil
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To see all the available payloads in Veil-Evasion, enter **`list`** at the prompt,
    as shown in [Example 12-10](ch12.xhtml#veil-evasion_payloads "Example 12-10. Veil-Evasion
    payloads").
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-10. Veil-Evasion payloads
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As of this writing, there are 28 ways to create executables implemented in Veil-Evasion.
    For this example, choose option 23 ❶ to use the VirtualAlloc injection method
    and encrypt it with AES encryption. Once you choose a method, Veil-Evasion will
    prompt you to change the method options from the default, if desired, as shown
    in [Example 12-11](ch12.xhtml#using_python_virtualalloc_in_veil-evasio "Example 12-11. Using
    Python VirtualAlloc in Veil-Evasion").
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-11. Using Python VirtualAlloc in Veil-Evasion
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By default, this payload will compile the Python script into an executable ❶
    using `VirtualAlloc()` as the injection method ❷. These options are correct for
    our example, so enter **`generate`** at the prompt. You are then prompted for
    details about the shellcode, as shown in [Example 12-12](ch12.xhtml#generating_the_executable_in_veil-evasio
    "Example 12-12. Generating the executable in Veil-Evasion").
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-12. Generating the executable in Veil-Evasion
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Veil-Evasion prompts you to select either Msfvenom to generate the shellcode
    or to provide custom shellcode. For our purposes, choose Msfvenom. The default
    payload is *windows/meterpreter/reverse_tcp*, so press enter to select it. You
    should be prompted for the usual options, `LHOST` and `LPORT`, and for a filename
    for the generated executable. Finally, Veil-Evasion offers two Python to executable
    methods. Choose the default, `Pyinstaller`, to have Veil-Evasion generate the
    malicious executable and save it to the *veil-output/compiled* directory.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, the resulting executable sails right past Microsoft Security
    Essentials on our Windows 7 box. Veil-Evasion notes that you shouldn’t upload
    the resulting executable to online scanners, so at the author’s request we’ll
    forgo checking this example with VirusTotal. However, we can install other antivirus
    solutions besides Microsoft Security Essentials to see if the executable is flagged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you find the Veil-Evasion executables aren’t working, you might need to update
    Metasploit with Msfupdate. Since Veil-Evasion is not currently in the Kali Linux
    repos, the latest version you pull down when you set up may not match up with
    how Msfvenom works in the default Kali 1.0.6 install. Of course, if you update
    Metasploit with Msfupdate, other exercises in this book may change, as Metasploit’s
    functionality changes frequently. Therefore, you may want to save this exercise
    for a second pass through the book or use a second Kali Linux image if you don’t
    want the update to affect later exercises in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding in Plain Sight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the best way to avoid antivirus programs is to avoid traditional payloads
    altogether. If you are familiar with coding for Windows, you can use Windows APIs
    to mimic the functionality of a payload. There is, of course, no rule that legitimate
    applications cannot open a TCP connection to another system and send data—essentially
    what our *windows/meterpreter/reverse_tcp* payload is doing.
  prefs: []
  type: TYPE_NORMAL
- en: You may find that instead of generating the payload with Msfvenom and attempting
    to hide it with the methods covered in this chapter, you get even better results
    just writing a C program that performs the payload functionality you want. You
    can even invest in a code-signing certificate to sign your binary executable,
    to make it look even more legitimate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Turn Real-time protection in Microsoft Security Essentials back off before moving
    on to post exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve looked at only a few techniques for bypassing antivirus detection in this
    chapter. The topic of bypassing antivirus solutions could take up an entire book,
    and by the time it was published, the book would already be wildly out of date.
    Pentesters and researchers are constantly coming up with new techniques to sneak
    past antivirus detection, and antivirus vendors are always adding new signatures
    and heuristics to catch them.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at ways to use Metasploit to encode and embed payloads in legitimate
    executables. When we found that these techniques weren’t enough to evade Microsoft
    Security Essentials, we turned to techniques beyond Metasploit. We built a custom
    executable template and found that we were able to improve our results by combining
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We were finally able to reach our goal of bypassing Microsoft Security Essentials
    using Hyperion. Though we never reached a 0 percent detection rate, we were able
    to bypass Microsoft Security Essentials as well as several other top antivirus
    solutions. We also looked at another tool, Veil-Evasion, which uses VirtualAlloc
    injection combined with encryption for even better evasion.
  prefs: []
  type: TYPE_NORMAL
- en: Having looked at a lot of ways to get onto systems, even ones without readily
    apparent vulnerabilities, we’ll now turn our attention to what we can do once
    we penetrate a system, as we enter the post-exploitation stage of pentesting.
  prefs: []
  type: TYPE_NORMAL
