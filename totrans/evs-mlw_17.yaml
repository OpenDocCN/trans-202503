- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVADING
    ENDPOINT AND NETWORK DEFENSES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">规避端点和网络防御</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: To successfully infiltrate and operate in its target environment, modern malware
    must survive that environment’s defenses. Many targets, especially those in an
    enterprise environment, are behind multiple defensive applications and products
    that work tirelessly to protect the systems and networks that make up the organization’s
    infrastructure. Malware can take active measures to evade these defenses (for
    example, by tampering with host defense applications) or take a passive approach
    to try to slip by them undetected.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功渗透并在目标环境中运行，现代恶意软件必须能够生存并突破该环境的防御。许多目标，特别是在企业环境中的目标，背后都有多个防御应用程序和产品，它们不知疲倦地工作，保护着构成组织基础设施的系统和网络。恶意软件可以采取主动措施来规避这些防御（例如，通过篡改主机防御应用程序），也可以采取被动方式试图悄无声息地绕过这些防御。
- en: In this chapter, I’ll outline different types of defenses that malware could
    encounter on victim hosts and networks, and then I’ll explain some techniques
    it might employ to get around those defenses. Defense evasion is a huge topic,
    so this chapter will focus primarily on the most common tactics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将概述恶意软件可能在受害主机和网络中遇到的不同防御类型，然后我会解释它可能采用的一些技术，以绕过这些防御。防御规避是一个庞大的话题，因此本章将主要关注最常见的战术。
- en: <samp class="SANS_Futura_Std_Bold_B_11">An Endpoint Defense Primer</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">端点防御基础</samp>
- en: The endpoint defense market is flooded with overloaded terms and fancy product
    names. It can be difficult to keep track of it all and understand at a fundamental
    level what each tool actually does. In this section, I’ll try to establish a common
    vocabulary for endpoint defense tools. First, though, we’ll go over a brief history
    of endpoint defenses to establish a baseline level of knowledge on which we can
    build.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 端点防御市场充斥着过载的术语和花哨的产品名称。要跟上这一切并从根本上理解每个工具的实际功能可能会很困难。在这一节中，我将尝试为端点防御工具建立一个通用词汇表。然而，首先我们将简要回顾端点防御的历史，为我们建立一个基础知识水平，进而进行更深的理解。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">A Brief History of
    Endpoint Defense Technology</samp>
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">端点防御技术简史</samp>
- en: Endpoint defense software goes back to the early days of malware, the 1970s
    and 1980s. At that time, endpoint defenses were appropriately called *antivirus
    (AV)* products, as most types of malicious software were widely known as *viruses*.
    In those early days, malware was relatively simple and AV software simply searched
    files for specific malicious patterns. Those AV programs were typically developed
    by hobbyists.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 端点防御软件可以追溯到恶意软件的早期，即1970年代和1980年代。当时，端点防御被恰当地称为*杀毒软件（AV）*产品，因为大多数类型的恶意软件普遍被称为*病毒*。在那些早期阶段，恶意软件相对简单，AV软件仅仅是通过搜索文件来查找特定的恶意模式。这些AV程序通常是由业余爱好者开发的。
- en: In the late 1980s and early 1990s, malware started to become more sophisticated,
    and commercial AV software companies (including Norton, Kaspersky, and McAfee)
    emerged to address the growing threat. The software these companies developed
    provided more advanced features than the hobbyist AV programs, such as real-time
    scanning, heuristics-based detection, and automatic signature updates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代末和1990年代初，恶意软件开始变得更加复杂，商业AV软件公司（包括诺顿、卡巴斯基和迈克菲）应运而生，解决日益严重的威胁。这些公司开发的软件比业余爱好者的AV程序提供了更多高级功能，如实时扫描、基于启发式的检测和自动签名更新。
- en: As malware authors were forced to adapt to technological advances, they created
    even more complex and covert malware capable of evading traditional AV software.
    In response, AV vendors started to develop much more robust software (which I’ll
    refer to as *anti-malware software* going forward), as well as products called
    *endpoint protection platforms (EPPs)*. EPPs are a more complete host protection
    solution that includes features not found in traditional anti-malware, such as
    built-in software firewalls and host intrusion prevention. More recently, *endpoint
    detection and response (EDR)* solutions have emerged as a more advanced endpoint
    security solution that provides real-time visibility into endpoint activity and
    enables security teams to quickly detect and respond to security threats.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着恶意软件作者被迫适应技术进步，他们创造了更加复杂和隐蔽的恶意软件，能够躲避传统的AV软件。作为回应，AV供应商开始开发更强大的软件（我将称之为*反恶意软件*），以及被称为*端点保护平台（EPP）*的产品。EPP是一种更完整的主机保护解决方案，包含了传统反恶意软件所没有的功能，例如内置软件防火墙和主机入侵防御。最近，*端点检测与响应（EDR）*解决方案作为一种更先进的端点安全解决方案出现，提供对端点活动的实时可视化，帮助安全团队快速检测和应对安全威胁。
- en: There’s a significant amount of overlap among host defense technologies. Many
    modern anti-malware products, for example, incorporate aspects of EPPs and even
    EDR solutions. EPPs include all of the functionalities of traditional and modern
    anti-malware and may overlap with some EDR solutions. EDR typically includes all
    of the functionalities of anti-malware and EPPs, as well as others. Thus, for
    the sake of simplicity, I’ll categorize endpoint defenses as either anti-malware
    or EDR in this book. Note, however, that each product vendor has its own “secret
    sauce,” so these categories are meant to reflect how the defenses work in general,
    not the specific details of how they operate in practice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 主机防御技术之间有相当大的重叠。例如，许多现代反恶意软件产品结合了EPP和甚至EDR解决方案的某些方面。EPP包括传统和现代反恶意软件的所有功能，并且可能与某些EDR解决方案有所重叠。EDR通常包括反恶意软件和EPP的所有功能，以及其他一些功能。因此，为了简化起见，我将在本书中将端点防御归类为反恶意软件或EDR。然而，请注意，每个产品供应商都有自己独特的“秘密配方”，因此这些类别旨在反映防御技术的工作原理，而不是它们在实践中的具体操作细节。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anti-malware</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">反恶意软件</samp>'
- en: Perhaps the most common and well-known host defense technology is *anti-malware*,
    or what was formerly called *antivirus*. It specializes in detecting and identifying
    malware threats on the system, both on the hard disk (before malware executes
    itself) and in memory (after the malware is running on the system). To accomplish
    this, anti-malware software uses a range of techniques, including hash-based and
    signature-based detection as well as heuristic and behavioral analysis.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最常见和最著名的主机防御技术是*反恶意软件*，或者以前被称为*杀毒软件*。它专门用于检测和识别系统上的恶意软件威胁，既包括硬盘上的恶意软件（在恶意软件执行之前），也包括内存中的恶意软件（在恶意软件已经在系统上运行之后）。为了实现这一点，反恶意软件使用一系列技术，包括基于哈希和基于特征的检测，以及启发式和行为分析。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hash-Based Detection</samp>
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于哈希的检测</samp>
- en: '*Hash-based detection* is a primitive method used in early anti-malware scanners,
    and it’s still used today to some extent. Anti-malware vendors maintain a database
    of file hashes known to be either benign or malicious. When a file is written
    to disk, the anti-malware software scans the file and compares its hash to the
    database. If the file is known to be benign, the anti-malware software leaves
    it alone. If the file is known to be malicious, the anti-malware software automatically
    removes it from the system and places it into a special quarantine where it can
    do no harm.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于哈希的检测*是一种早期反恶意软件扫描程序使用的原始方法，并且今天仍在一定程度上被使用。反恶意软件供应商维护一个已知为良性或恶意的文件哈希数据库。当文件写入磁盘时，反恶意软件会扫描该文件并将其哈希与数据库进行比较。如果该文件已知为良性，反恶意软件将不做任何处理。如果该文件已知为恶意，反恶意软件会自动将其从系统中移除，并将其放入一个特殊的隔离区，确保其不会造成任何危害。'
- en: The primary problem with this hash-based method is that the files must already
    be known to the anti-malware software. If the file is new and not in the database,
    the anti-malware can’t detect it (at least, not using hash analysis alone). According
    to a December 15, 2020, press release from Kaspersky, about 360,000 new malicious
    files were created every day that year. This obviously poses a problem for hash-based
    detection methods, since anti-malware software can’t possibly keep up.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于哈希值的方法的主要问题在于，文件必须已经被反恶意软件程序识别。如果文件是新的，并且不在数据库中，反恶意软件就无法检测到它（至少，单靠哈希分析无法检测）。根据卡巴斯基2020年12月15日的新闻稿，2020年每天约有36万个新的恶意文件被创建。这显然给基于哈希值的检测方法带来了问题，因为反恶意软件程序无法跟上如此庞大的文件量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Signature-Based Detection</samp>
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于特征的检测</samp>
- en: '*Signature-based detection*, an upgrade to the older hash-based detection methods,
    uses *signatures*, or known patterns, to identify malicious code in files or process
    memory. These patterns can be strings, byte sequences, metadata, or anything else
    that indicates that the file or memory segment could be related to malware. Anti-malware
    software maintains a large database of signatures, and when it identifies a match
    on one, it raises an alert and quarantines the respective file or terminates the
    suspect process. Signature-based detection functions similarly to the Yara rules
    discussed in [Chapter 2](chapter2.xhtml).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于特征的检测*，是对旧有哈希值检测方法的升级，使用*特征*或已知模式来识别文件或进程内存中的恶意代码。这些模式可以是字符串、字节序列、元数据或其他任何能表明文件或内存段可能与恶意软件相关的内容。反恶意软件程序会维护一个庞大的特征库，当它发现匹配时，便会发出警报并将相关文件隔离或终止可疑进程。基于特征的检测与在[第二章](chapter2.xhtml)中讨论的Yara规则类似。'
- en: Over time, malware authors have caught on to these detection techniques. For
    example, since signature-based detection is looking for malicious patterns, malware
    authors can simply encrypt or obfuscate their malware on disk or in memory to
    hide or change these patterns. Worse, they can generate countless variations of
    their malware so that, once again, the detection mechanisms can’t keep pace. It’s
    clear that anti-malware software has had to evolve.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，恶意软件作者已经意识到这些检测技术。例如，由于基于特征的检测是通过寻找恶意模式，恶意软件作者可以简单地加密或混淆他们的恶意软件，无论是在磁盘上还是在内存中，以隐藏或改变这些模式。更糟糕的是，他们可以生成无数种恶意软件的变种，以至于检测机制再也无法跟上其变化。显然，反恶意软件程序必须不断进化。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Heuristic-Based Detection</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于启发式的检测</samp>'
- en: Instead of matching file hashes or looking for specific patterns in a piece
    of software, *heuristic-based detection* looks at a file’s behavior. It does this
    by using a few different sub-techniques. First, it inspects the file for signs
    of malicious code. This goes beyond simple string and byte-sequence pattern matching,
    however; it’s looking for indicators such as suspicious blocks of assembly instructions
    or atypical uses of API calls. This process may also involve a weighting or scoring
    system. When the anti-malware software discovers a suspicious sequence of code,
    the file’s score increases. Once this score hits a predefined threshold, the anti-malware
    engine rates the file as malicious.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与其匹配文件哈希值或寻找软件中特定的模式，*基于启发式的检测*则关注文件的行为。它通过几种不同的子技术来实现这一目标。首先，它会检查文件是否有恶意代码的迹象。这个过程不仅仅是简单的字符串和字节序列模式匹配；它还会寻找一些指示，如可疑的汇编指令块或API调用的异常使用。这个过程还可能涉及加权或评分系统。当反恶意软件软件发现可疑的代码序列时，文件的分数会增加。一旦分数达到预定的阈值，反恶意软件引擎便会将文件判定为恶意文件。
- en: More modern heuristic-based methods can also employ file emulation techniques
    to better understand the file. *File emulation* involves executing the file in
    an *emulation engine*, which is a very lightweight virtual machine that can dynamically
    assess the file before it actually executes on the system. As CPU instructions
    are executed in the emulator, the anti-malware software monitors the file’s behaviors,
    and if any are suspicious or raise the file’s score high enough, the anti-malware
    takes further action.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更现代的基于启发式的方法还可以使用文件仿真技术来更好地理解文件。*文件仿真*涉及在*仿真引擎*中执行文件，这是一种非常轻量级的虚拟机，可以在文件真正执行之前动态地评估它。随着CPU指令在仿真器中执行，反恶意软件会监控文件的行为，如果有任何行为可疑或使文件的分数足够高，反恶意软件将采取进一步行动。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Cloud-Based Analysis Sandboxes</samp>
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于云的分析沙箱</samp>
- en: Running each file on a system through an emulation engine would be very taxing,
    so some modern anti-malware vendors instead use cloud-based analysis sandboxes.
    If a file is still unclassified even after it’s been subjected to hash-based,
    signature-based, and heuristic-based detection mechanisms, the file will be sent
    to the anti-malware vendor’s cloud environment for sandboxing and further analysis.
    *Cloud-based sandboxing* is a form of crowdsourced security in that all customers
    who use such anti-malware software will be notified if a particular file is malicious,
    even if they’ve never seen it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统上运行每个文件通过仿真引擎将非常繁重，因此一些现代反恶意软件供应商改为使用基于云的分析沙箱。如果一个文件在经历了基于哈希、基于特征码和基于启发式的检测机制后仍未分类，该文件将被发送到反恶意软件供应商的云环境中进行沙箱化和进一步分析。*基于云的沙箱化*是一种众包安全方式，使用这种反恶意软件的所有客户都会收到通知，如果某个文件被确认恶意，即使他们之前从未见过该文件。
- en: '[Figure 13-1](chapter13.xhtml#fig13-1) summarizes the detection mechanisms
    we’ve covered so far.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](chapter13.xhtml#fig13-1)总结了我们迄今为止讨论的检测机制。'
- en: '![](../images/fig13-1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: Typical detection
    mechanisms in anti-malware software</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-1：反恶意软件中的典型检测机制</samp>
- en: Note that many modern anti-malware solutions use a combination of some or all
    of these techniques.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，许多现代反恶意软件解决方案使用了上述一些或全部技术的组合。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Limitations and Challenges</samp>
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">局限性与挑战</samp>
- en: Even though anti-malware software has progressed and improved substantially
    over time, it still has some limitations. As a whole, it’s effective at identifying
    and eliminating threats from files that are known to be malicious; those that
    share similarities with files that are known to be malicious; and those that aren’t
    especially advanced, targeted, or bespoke. More advanced and specific threats
    can sneak past anti-malware software (as we’ll see later in this chapter).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管反恶意软件已经随着时间的推移取得了显著进步和改进，但它仍然存在一些局限性。总体而言，它能够有效地识别和消除已知恶意的文件、与已知恶意文件相似的文件，以及那些不特别先进、针对性不强或定制化不高的文件。然而，更多先进和特定的威胁可能会悄悄绕过反恶意软件（我们将在本章后面看到）。
- en: 'Another limitation of anti-malware software is that it must be mindful of system
    resources. Anti-malware software has a very difficult job: it must scan potentially
    thousands of files and memory regions at a time while keeping the lowest system
    resource footprint possible to avoid disrupting the end-user experience. This
    means that it can’t run every file through the emulation or sandboxing process;
    it must reserve those more time- and resource-intensive techniques for suspicious
    files that require deeper investigation.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 反恶意软件的另一个限制是必须考虑系统资源。反恶意软件面临着一项非常困难的任务：它必须同时扫描潜在的成千上万个文件和内存区域，同时保持尽可能低的系统资源占用，以避免干扰最终用户体验。这意味着它不能将每个文件都经过仿真或沙箱处理；它必须将这些更耗时和资源的技术保留给那些需要深入调查的可疑文件。
- en: Even among the files it deems malicious, anti-malware software must be selective.
    For example, anti-malware software has been known to flag critical system files
    as malicious, an action that cannot be tolerated. As a result, anti-malware products
    may lean toward giving a file a pass rather than flagging it as malicious.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在它认为是恶意的文件中，反恶意软件也必须具有选择性。例如，反恶意软件已知会将关键系统文件标记为恶意，这种行为是无法容忍的。因此，反恶意软件产品可能倾向于让文件通过而不是将其标记为恶意。
- en: One final limitation of anti-malware software is that while it’s intended to
    detect and eradicate threats on the endpoint, it wasn’t designed with post-compromise
    investigations or context in mind. Modern and advanced attacks often involve a
    number of steps in the attack chain that use multiple techniques and components,
    and anti-malware alone can leave blind spots, especially in complex corporate
    environments. This is where EDR comes into play.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 反恶意软件的一个最终限制是，虽然它旨在检测并消除端点的威胁，但它并不是为了事后入侵调查或上下文分析而设计的。现代和高级攻击通常涉及攻击链中的多个步骤，这些步骤使用了多种技术和组件，单靠反恶意软件可能会留下盲点，特别是在复杂的企业环境中。这时，EDR（端点检测与响应）就发挥了作用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Endpoint Detection
    and Response</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">端点检测与响应</samp>
- en: '*Endpoint detection and response (EDR)* solutions provide more advanced threat
    detection and response features than traditional anti-malware solutions provide.
    While anti-malware solutions are focused primarily on detecting and defending
    against known malware threats, EDR solutions are able to detect and act upon a
    broader range of advanced threats.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*端点检测与响应（EDR）*解决方案提供比传统反恶意软件解决方案更先进的威胁检测和响应功能。传统的反恶意软件解决方案主要集中在检测和防御已知的恶意软件威胁，而EDR解决方案能够检测并应对更广泛的高级威胁。'
- en: One of EDR’s primary benefits is its ability to establish context around an
    attack. It creates this context, often referred to as *telemetry*, by collecting
    data from multiple endpoints, enabling investigators to perform deeper analysis
    and to identify similar patterns of malicious activity across the enterprise.
    EDR can even help investigation teams identify the “patient zero” of an attack.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: EDR的主要优点之一是能够建立攻击的上下文。它通过收集来自多个端点的数据来创建这种上下文，通常被称为*遥测*，从而使调查人员能够进行更深入的分析，并识别整个企业中类似的恶意活动模式。EDR甚至可以帮助调查小组识别攻击的“零号病人”。
- en: Let’s take a quick look under the hood to see how EDR works. Typically, EDR
    consists of multiple components in both user space and kernel space, plus a log
    aggregator and analysis engine. We’ll start with the user-space components.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看EDR的工作原理。通常，EDR由多个组件组成，包括用户空间和内核空间的组件，以及日志聚合器和分析引擎。我们将从用户空间组件开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">User-Space Components</samp>
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">用户空间组件</samp>
- en: EDR solutions always have at least one executable running as a process in user
    space. This process, often called an *agent*, runs in a high-privilege context
    and monitors other processes on the host for suspicious behaviors, intervening
    when necessary. To do this, the EDR agent collects and analyzes system events,
    then forwards this information to a log aggregator, which we’ll discuss shortly.
    When a new process is created on the host, the EDR process can inject a hooking
    module into it using various methods such as the ones discussed in [Chapter 12](chapter12.xhtml).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: EDR解决方案始终至少有一个可执行文件作为用户空间中的进程运行。这个进程通常被称为*代理*，它以高权限上下文运行，并监视主机上其他进程的可疑行为，必要时进行干预。为了实现这一点，EDR代理收集并分析系统事件，然后将这些信息转发给日志聚合器，我们稍后会讨论。当主机上创建一个新进程时，EDR进程可以通过各种方法注入钩子模块到该进程中，方法包括在[第12章](chapter12.xhtml)中讨论的那些。
- en: '[Figure 13-2](chapter13.xhtml#fig13-2) illustrates malware being hooked by
    EDR.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-2](chapter13.xhtml#fig13-2) 展示了恶意软件被EDR钩住的过程。'
- en: '![](../images/fig13-2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: The EDR process
    using a module to hook malware</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-2：EDR过程使用模块钩住恶意软件</samp>
- en: The malware executable (*malware.exe*) is calling a WinAPI function residing
    in *kernel32.dll*, which subsequently invokes *ntdll.dll*. Instead of *ntdll.dll*
    making a syscall into kernel space (which is what would happen under normal circumstances),
    the installed EDR software is hooking *ntdll.dll* via a previously injected DLL
    (*edr_hook.dll*). This allows the EDR software to decide whether to permit the
    API call or to block or even terminate it. If the EDR software deems the API activity
    benign, it allows the API call to continue to the kernel as normal.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可执行文件（*malware.exe*）调用位于*kernel32.dll*中的WinAPI函数，进而调用*ntdll.dll*。与正常情况下*ntdll.dll*通过系统调用进入内核空间不同，已安装的EDR软件通过先前注入的DLL（*edr_hook.dll*）钩住*ntdll.dll*。这样，EDR软件就可以决定是否允许API调用，或者阻止甚至终止它。如果EDR软件认为该API活动无害，它将允许API调用正常地传递到内核。
- en: 'Some common functions that may be hooked by modern anti-malware and EDR software
    include the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现代反恶意软件和EDR软件可能会钩住的一些常见功能包括：
- en: Memory operations (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp>)
    that monitor memory commits and protection changes, such as when the EDR software
    wishes to know whether a region of memory is changed to *read-write-executable
    (RWX)*, indicating that there’s potentially code in this region about to be executed
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存操作（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp>）监视内存提交和保护变化，比如当EDR软件希望知道内存区域是否已更改为*可读写可执行（RWX）*时，表示该区域可能有代码即将被执行。
- en: Functions that create and terminate processes (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtTerminateProcess</samp>) so that
    the EDR software can watch over and hook into newly created processes
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和终止进程的函数（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>，
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>，和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtTerminateProcess</samp>），以便EDR软件可以监控和挂钩新创建的进程
- en: Functions that load libraries (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LdrLoadDll</samp>)
    so that the EDR software can monitor suspicious processes as they load new libraries
    and modules
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载库的函数（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">LdrLoadDll</samp>），以便EDR软件可以在加载新库和模块时监控可疑进程
- en: Functions commonly used for process injection (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThread</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>) so that
    the EDR software can monitor for code- and hook- injection attempts
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用于进程注入的函数（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>，
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThread</samp>， <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>，
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>，和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>），以便EDR软件可以监控代码注入和挂钩注入尝试
- en: File writes (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteFile</samp>),
    which are often used by ransomware and other destructive malware
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件写入（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteFile</samp>），常被勒索软件和其他破坏性恶意软件使用
- en: Functions that attempt to create network connections, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpen</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnect</samp>, which
    EDR can monitor for suspicious network communication
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建网络连接的函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpen</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnect</samp>，这些函数可以被EDR监控以检测可疑的网络通信
- en: Hooking API function calls is only one way of monitoring the system. Some EDR
    products also collect system data using other sources, such as *Event Tracing
    for Windows (ETW)*, a mechanism designed for logging and diagnostics that’s been
    a part of Windows since 2007\. ETW is able to collect and log data from many sources,
    including user-space processes and kernel drivers, which makes it quite useful
    for EDR ingestion as well. You can read more about it in the Microsoft documentation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 挂钩API函数调用只是监控系统的一种方式。一些EDR产品还使用其他来源收集系统数据，例如*Windows事件追踪（ETW）*，这是一个用于日志记录和诊断的机制，自2007年以来就已成为Windows的一部分。ETW能够从多个来源收集和记录数据，包括用户空间进程和内核驱动程序，这使得它在EDR数据采集中也非常有用。你可以在微软文档中了解更多信息。
- en: To identify suspicious activity, EDR agents might rely upon a threat-scoring
    system. To illustrate this, consider the attack scenario shown in [Figure 13-3](chapter13.xhtml#fig13-3).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别可疑活动，EDR代理可能依赖于威胁评分系统。为了说明这一点，请参考[图13-3](chapter13.xhtml#fig13-3)中的攻击场景。
- en: '![](../images/fig13-3.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: A multistage attack</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-3：多阶段攻击</samp>
- en: First, the attacker sends a target user a specially crafted phishing email containing
    a malicious Microsoft Office document attachment. The Office document’s malicious
    code executes PowerShell to contact a staging server where the attacker’s malware
    payload (*ransomware.exe*) is hosted, then downloads and executes the payload
    in memory. The ransomware payload subsequently begins encrypting files on the
    victim’s hard disk.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，攻击者向目标用户发送一封精心制作的钓鱼电子邮件，附件包含一个恶意的Microsoft Office文档。Office文档中的恶意代码执行PowerShell来联系一个临时服务器，在那里攻击者的恶意软件载荷（*ransomware.exe*）被托管，然后在内存中下载并执行该载荷。之后，勒索软件载荷开始加密受害者硬盘上的文件。
- en: The EDR product assigns a score to each event that makes up this attack. Say
    it assigns a threat value of 35 to the Office document that launched a PowerShell
    command, a value of 20 to the connection to the suspicious server, and a value
    of 30 to the download and execution of an unknown executable file. If the maximum
    threat score is a hypothetical 100, and if any value over 75 is considered malicious,
    then this series of events totaling 85 would trigger the EDR solution to perform
    actions such as killing the Office and PowerShell processes or terminating the
    network connections to the remote server. The ransomware execution itself would
    likely have a high threat score, as ransomware creates multitudes of file write
    actions. Furthermore, metadata related to these events would be forwarded to a
    central log storage and processor, allowing the EDR product to analyze this attack
    in the context of the entire enterprise infrastructure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: EDR产品会为构成此次攻击的每个事件分配一个分数。例如，它为启动PowerShell命令的Office文档分配35的威胁值，为连接到可疑服务器的操作分配20的威胁值，为下载并执行未知可执行文件分配30的威胁值。如果假设最大威胁分数为100，并且任何超过75的值都被认为是恶意的，那么这个总计85的事件序列将触发EDR解决方案执行一些操作，比如终止Office和PowerShell进程，或断开与远程服务器的网络连接。勒索软件本身的执行可能会有很高的威胁评分，因为勒索软件会创建大量的文件写入操作。此外，与这些事件相关的元数据将被转发到一个中央日志存储和处理器，允许EDR产品在整个企业基础设施的上下文中分析这次攻击。
- en: 'Keep in mind that this threat-scoring system example is intentionally simplified
    and merely intended to demonstrate how EDR is better equipped than traditional
    endpoint defenses to “connect the dots” during an advanced attack. Let’s move
    on to another important part of EDR solutions: kernel-space components.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个威胁评分系统示例是故意简化的，旨在演示EDR如何比传统的端点防御更能在高级攻击中“串联”事件。接下来，我们将讨论EDR解决方案中的另一个重要部分：内核空间组件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Kernel-Space Components</samp>
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">内核空间组件</samp>
- en: In kernel space, EDR solutions primarily take the form of kernel drivers or
    modules, which are pieces of compiled code that execute in kernel address space.
    EDR kernel drivers rely on *callbacks*, functions registered by kernel components
    to receive notifications in response to specific events. To monitor the system
    for new processes, for example, the EDR kernel driver registers a callback routine
    by invoking the kernel function <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>.
    When a process is created or terminated, the EDR kernel driver will be notified
    so that it can respond to that event accordingly, likely by engaging its user-space
    component to inject hooks into the newly created process to begin monitoring.
    [Figure 13-4](chapter13.xhtml#fig13-4) illustrates how this works.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核空间，EDR解决方案主要以内核驱动程序或模块的形式存在，这些模块是执行在内核地址空间中的已编译代码。EDR内核驱动程序依赖于*回调*，即内核组件注册的函数，用于接收特定事件的通知。例如，为了监控系统中的新进程，EDR内核驱动程序通过调用内核函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>
    注册一个回调例程。当进程被创建或终止时，EDR内核驱动程序会收到通知，以便相应地作出响应，通常是通过调用其用户空间组件，将钩子注入新创建的进程中开始监控。[图
    13-4](chapter13.xhtml#fig13-4)展示了这一过程是如何工作的。
- en: '![](../images/fig13-4.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: EDR hook injection</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-4: EDR钩子注入</samp>'
- en: In this example, the EDR kernel driver is notified via <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>
    (not shown) that a new process, *malware.exe*, is being created ❶. The EDR driver
    instructs the EDR agent in user space (*edr_agent.exe*) ❷ to inject a hook into
    the new process ❸. Now *malware.exe* is being monitored by the EDR.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，EDR内核驱动程序通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>（未显示）被通知到一个新的进程，*malware.exe*，正在被创建❶。EDR驱动程序指示用户空间中的EDR代理（*edr_agent.exe*）❷将钩子注入到新创建的进程中❸。现在，*malware.exe*
    正在被EDR监控。
- en: 'Here are a few other callbacks that EDR software might use, plus the circumstances
    in which they’re triggered:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些EDR软件可能使用的其他回调，以及触发它们的情况：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetCreateThreadNotifyRoutine </samp>This
    is triggered when any new thread is created or deleted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetCreateThreadNotifyRoutine</samp> 当创建或删除任何新线程时，都会触发该回调。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetLoadImageNotifyRoutine(Ex) </samp>This
    is triggered when a process loads an image (such as a DLL module) into memory,
    or when a new driver is loaded.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetLoadImageNotifyRoutine(Ex) </samp>当进程将一个镜像（如DLL模块）加载到内存中，或者加载一个新驱动程序时，会触发该事件。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoWMISetNotificationCallback </samp>This
    is triggered by Windows Management Instrumentation (WMI) events.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoWMISetNotificationCallback </samp>此事件由Windows管理工具（WMI）事件触发。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CmRegisterCallback(Ex) </samp>This
    is triggered when any running thread modifies the Windows registry.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CmRegisterCallback(Ex) </samp>当任何正在运行的线程修改Windows注册表时，会触发该事件。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FsRtlRegisterFileSystemFilterCallbacks </samp>This
    is triggered when certain filesystem operations occur.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FsRtlRegisterFileSystemFilterCallbacks </samp>当某些文件系统操作发生时，会触发此事件。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoRegisterBootDriverCallback </samp>This
    is triggered when a new boot-start driver is initialized. Boot-start drivers start
    on system boot-up, so this callback can be used by anti-malware and EDR to detect
    rootkits and bootkits that use a boot-up driver (more on rootkits in [Chapter
    14](chapter14.xhtml)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoRegisterBootDriverCallback </samp>当一个新的启动驱动程序初始化时，会触发此事件。启动驱动程序在系统启动时启动，因此反恶意软件和EDR可以利用此回调检测使用启动驱动程序的根套件和启动套件（有关根套件的更多信息，请参见[第14章](chapter14.xhtml)）。
- en: EDR can also take advantage of minifilter drivers. *Minifilters* are used to
    monitor requests to the filesystem from user-space processes, so EDR can use them
    to intercept and block malicious filesystem actions that malware is trying to
    execute (for example, ransomware opening and writing to files at a rapid rate).
    Another reason EDR uses minifilters is to monitor and protect its own files from
    tampering or deletion. In the event that a malware sample is able to establish
    low-level privileges and attempt to remove or modify EDR components, the minifilter
    drivers will notify the EDR product about this activity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: EDR还可以利用迷你过滤驱动。*迷你过滤器*用于监视来自用户空间进程的文件系统请求，因此EDR可以使用它们来拦截和阻止恶意文件系统操作（例如勒索软件以极快的速度打开和写入文件）。EDR使用迷你过滤器的另一个原因是监视和保护其自身文件免受篡改或删除。如果恶意软件能够获得低级权限并尝试删除或修改EDR组件，迷你过滤驱动将会通知EDR产品此活动。
- en: Other kernel components that EDR may use are network filter drivers and *early-launch
    anti-malware (ELAM)* drivers. Network filter drivers can be used to monitor, intercept,
    and modify network communication, which can be useful in detecting anomalous network
    traffic such as command and control (C2) traffic. ELAM drivers load before the
    operating system boots and help protect against malware that could tamper with
    the boot process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: EDR可能使用的其他内核组件包括网络过滤驱动和*早期启动反恶意软件（ELAM）*驱动。网络过滤驱动可用于监视、拦截和修改网络通信，这对于检测异常网络流量（如命令与控制（C2）流量）非常有用。ELAM驱动在操作系统启动之前加载，有助于防止恶意软件篡改启动过程。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*You may have noticed that EDR injects modules into other processes, installs
    hooks to intercept API calls, and installs drivers into kernel space, which is
    eerily similar to malware! EDR does indeed look suspiciously similar to a variant
    of malware called rootkits. We’ll talk about rootkit techniques and components
    in more detail in [Chapter 14](chapter14.xhtml).*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能已经注意到，EDR将模块注入到其他进程中，安装钩子以拦截API调用，并将驱动程序安装到内核空间，这和恶意软件非常相似！EDR确实看起来和一种名为根套件的恶意软件变种非常相似。我们将在[第14章](chapter14.xhtml)中更详细地讨论根套件技术和组件。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Logging and Analysis</samp>
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">日志记录与分析</samp>
- en: I mentioned previously that one of the EDR agent’s responsibilities is to forward
    events and associated data to a central logging server, where they can be further
    analyzed and stored for future investigations. [Figure 13-5](chapter13.xhtml#fig13-5)
    illustrates this process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，EDR代理的一个职责是将事件及相关数据转发到中央日志服务器，在那里它们可以被进一步分析并存储以备将来调查。[图 13-5](chapter13.xhtml#fig13-5)展示了这一过程。
- en: '![](../images/fig13-5.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: An EDR agent gathering
    data from multiple endpoints for analysis</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-5：EDR代理收集来自多个端点的数据进行分析</samp>
- en: As you can see here, EDR agents running on disparate endpoints in the enterprise
    infrastructure forward data to the EDR log aggregator. Using various vendor-specific
    techniques, the data is processed and analyzed, enabling the EDR product to detect
    larger-scale attacks, for example. Using this telemetry, some EDR products can
    even “learn” what’s normal for this specific enterprise environment, helping them
    further differentiate between typical end-user behaviors and malicious activity.
    Many modern EDR solutions can also collect logs from many different sources to
    monitor an organization’s entire IT infrastructure. These EDR solutions are sometimes
    referred to as *extended detection and response* (*XDR)* platforms. XDRs are able
    to collect and analyze data from sources such as client endpoints, servers, network
    devices, applications, and cloud computing environments. For the remainder of
    this book, I’ll use the term *EDR* to also refer to XDR.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，运行在企业基础设施中不同端点上的EDR代理将数据转发到EDR日志聚合器。通过使用各种供应商特定的技术，数据被处理和分析，使EDR产品能够检测到更大规模的攻击。例如，使用这些遥测数据，一些EDR产品甚至能够“学习”特定企业环境中的正常情况，帮助它们进一步区分典型的终端用户行为和恶意活动。许多现代EDR解决方案还可以从许多不同的来源收集日志，以监控整个组织的IT基础设施。这些EDR解决方案有时被称为*扩展检测与响应*（*XDR*）平台。XDR能够从客户端终端、服务器、网络设备、应用程序和云计算环境等来源收集并分析数据。在本书的其余部分，我将使用*EDR*一词，也包括XDR。
- en: Even with all its benefits and capabilities, EDR can be (and sometimes is) bypassed
    by advanced malware. Now that you have a basic understanding of how EDR and anti-malware
    software work, let’s look at how malware can tamper with and circumvent these
    defenses. Advanced malware will often first attempt to understand the environment
    in which it is operating; this involves the malware scouting the target system
    and network and attempting to identify the endpoint defenses standing in its path.
    We’ll start there.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管EDR具有所有的优势和功能，但它仍然可能被高级恶意软件绕过（有时确实如此）。现在你已经基本了解了EDR和反恶意软件的工作原理，让我们来看看恶意软件如何篡改并规避这些防御。高级恶意软件通常会首先尝试了解其运行的环境；这涉及到恶意软件侦察目标系统和网络，并试图识别挡在其面前的终端防御。我们从这里开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Identifying Endpoint Defenses</samp>
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">识别终端防御</samp>
- en: 'Since many anti-malware and EDR products behave and monitor the system a bit
    differently, an advanced attacker will conduct at least basic reconnaissance on
    the target prior to executing a malware payload. There are a number of techniques
    an attacker might employ to enumerate the target’s defenses. For example, the
    following PowerShell command will retrieve a list of installed anti-malware software
    on the host:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多反恶意软件和EDR产品在行为和监控系统的方式上有所不同，一个高级攻击者会在执行恶意软件载荷之前，至少对目标进行基本的侦察。攻击者可能会采用多种技术来枚举目标的防御。例如，以下PowerShell命令将检索主机上安装的反恶意软件列表：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s some example output for this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该命令的一些示例输出：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On my system, Microsoft Defender was identified as the active anti-malware product.
    (This output uses the outdated name *Windows Defender*; the product has since
    been renamed Microsoft Defender.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，Microsoft Defender被识别为活动的反恶意软件产品。（此输出使用的是过时的名称*Windows Defender*；该产品已更名为Microsoft
    Defender。）
- en: Although this command will retrieve only anti-malware software that has registered
    itself within the Microsoft Security Center, most anti-malware vendors do this.
    A more robust solution is to enumerate artifacts on the host, searching for signs
    of endpoint defense products.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该命令只会检索已在Microsoft安全中心注册的反恶意软件，大多数反恶意软件供应商都会这样做。一个更强大的解决方案是枚举主机上的工件，寻找终端防御产品的迹象。
- en: In [Chapter 4](chapter4.xhtml), we discussed how malware enumerates and lists
    processes running on the host for sandbox and VM detection. It can do the same
    for enumerating defenses. For example, it can call the Windows API functions <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp> to create
    a “snapshot” of all processes running on the victim host, then iterate through
    these processes using <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>. It can
    then search for suspect process names such as *MsMpEng.exe* (the default Windows
    10 and 11 anti-malware process), *AvastSvc.exe* (the executable process for the
    anti-malware product from Avast), or any process with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">falcon</samp>
    in its name (which could be related to the CrowdStrike Falcon EDR product) in
    order to determine what kinds of defenses are on the host.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](chapter4.xhtml)中，我们讨论了恶意软件如何列举并列出主机上运行的进程以进行沙箱和虚拟机检测。它也可以对防御进行同样的操作。例如，它可以调用
    Windows API 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>
    创建受害主机上所有进程的“快照”，然后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp> 遍历这些进程。接着，它可以搜索可疑的进程名称，例如
    *MsMpEng.exe*（Windows 10 和 11 的默认反恶意软件进程）、*AvastSvc.exe*（Avast 反恶意软件产品的可执行进程），或者任何名称中包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">falcon</samp> 字符串的进程（可能与 CrowdStrike
    Falcon EDR 产品相关），以确定主机上有哪些防御措施。
- en: 'Some of the most popular anti-malware and EDR vendors and products include
    the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最流行的反恶意软件和 EDR 厂商及产品包括以下内容：
- en: 'CrowdStrike Falcon EDR: *CSFalcon*.exe*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CrowdStrike Falcon EDR: *CSFalcon*.exe*'
- en: 'ESET Smart Security: *Ekrn.exe*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ESET Smart Security: *Ekrn.exe*'
- en: 'Kaspersky: *Avp.exe*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kaspersky: *Avp.exe*'
- en: 'Malwarebytes: *Mbam.exe*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Malwarebytes: *Mbam.exe*'
- en: 'McAfee Endpoint Security: *masvc.exe*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'McAfee Endpoint Security: *masvc.exe*'
- en: 'Sophos: *SavService.exe*'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sophos: *SavService.exe*'
- en: 'Symantec Endpoint Protection: *ccSvcHst.exe*'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Symantec Endpoint Protection: *ccSvcHst.exe*'
- en: 'VMware Carbon Black: *cb.exe*'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'VMware Carbon Black: *cb.exe*'
- en: 'Microsoft Defender for Endpoint (formerly Windows Defender): *MsMpEng.exe*'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Defender for Endpoint（前身为 Windows Defender）：*MsMpEng.exe*
- en: These processes often have associated services, which are named similarly and
    can be enumerated by malware. Also keep in mind that the list is not exhaustive
    and is subject to change between software versions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些进程通常会有相关的服务，它们的命名方式相似，恶意软件可以枚举它们。还需记住，列表并不全面，并且在软件版本之间可能会有所变化。
- en: Alternatively, scanning the host for anti-malware and EDR-related files, drivers,
    and registry keys can be effective. [Figure 13-6](chapter13.xhtml#fig13-6) shows
    the Procmon output of a malware sample that queries the registry for keys that
    match common anti-malware vendors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，扫描主机以查找与反恶意软件和 EDR 相关的文件、驱动程序和注册表项也很有效。[图 13-6](chapter13.xhtml#fig13-6)
    显示了恶意软件样本查询注册表以匹配常见反恶意软件厂商的键值的 Procmon 输出。
- en: '![](../images/fig13-6.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: Malware querying
    the registry for names of anti-malware and EDR products</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-6：恶意软件查询注册表以获取反恶意软件和 EDR
    产品的名称</samp>
- en: Similarly, the anti-malware product from Kaspersky, for example, installs itself
    to a directory such as *C:\Program Files (x86)\Kaspersky Lab\Kaspersky Total Security*
    and installs several drivers on the host that are visible in the *C:\System32\drivers*
    directory, which could alert malware to its presence (see [Figure 13-7](chapter13.xhtml#fig13-7)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，卡巴斯基的反恶意软件产品，例如，安装在类似于 *C:\Program Files (x86)\Kaspersky Lab\Kaspersky Total
    Security* 的目录中，并且在 *C:\System32\drivers* 目录下安装了多个驱动程序，这些驱动程序可能会让恶意软件注意到它的存在（参见[图
    13-7](chapter13.xhtml#fig13-7)）。
- en: '![](../images/fig13-7.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-7: Kaspersky’s installed
    drivers</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-7：卡巴斯基安装的驱动程序</samp>
- en: There are a number of research projects, such as at [*https://<wbr>github<wbr>.com<wbr>/ethereal<wbr>-vx<wbr>/Antivirus<wbr>-Artifacts*](https://github.com/ethereal-vx/Antivirus-Artifacts),
    that catalog the different artifacts that endpoint defense products create on
    the host. These resources can be useful to both malware researchers and malware
    authors.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些研究项目，如 [*https://<wbr>github<wbr>.com<wbr>/ethereal<wbr>-vx<wbr>/Antivirus<wbr>-Artifacts*](https://github.com/ethereal-vx/Antivirus-Artifacts)，它们记录了端点防御产品在主机上创建的不同工件。这些资源对恶意软件研究人员和恶意软件作者都很有帮助。
- en: Finally, malware already running on the host may attempt to look for signs that
    it is being hooked by anti-malware or EDR. For instance, the malware might enumerate
    its loaded modules using <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> (as described
    in [Chapter 7](chapter7.xhtml)) or search its process memory for signs of hooking,
    as it does to circumvent sandbox hooking (described in [Chapter 8](chapter8.xhtml)).
    These hooks may reveal a specific defense product.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，已经在主机上运行的恶意软件可能会尝试查找其是否被反恶意软件或 EDR 勾取的迹象。例如，恶意软件可能会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> 枚举其加载的模块（如
    [第 7 章](chapter7.xhtml) 所描述），或者搜索其进程内存中的勾取迹象，正如它绕过沙箱勾取时所做的那样（如 [第 8 章](chapter8.xhtml)
    所描述）。这些勾取可能暴露出特定的防御产品。
- en: Once an endpoint security product has been detected and identified, the malware
    can take one of several active or passive approaches to circumvent it. First,
    we’ll discuss some active measures.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到并识别出端点安全产品，恶意软件可以采取几种主动或被动的方式绕过它。首先，我们将讨论一些主动措施。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Actively Circumventing Endpoint Defenses</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">主动绕过端点防御</samp>
- en: '*Active circumvention* is directly bypassing defenses by disabling them completely,
    modifying policies to weaken them, or tampering with them to blind them. There
    are many ways to accomplish this, so let’s look at some examples.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*主动规避*是通过完全禁用防御、修改策略使其变弱，或篡改它们以让其失效来直接绕过防御。这有许多种实现方式，让我们来看一些示例。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Disabling Host Defenses</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">禁用主机防御</samp>
- en: A crude but effective method for malware to evade and bypass endpoint security
    is simply to disable it. After enumerating the security products running on the
    endpoint, malware can disable them in several ways. First, it can attempt to kill
    the application’s processes (examples include anti-malware and EDR-related processes,
    Windows Security Center processes and services, and any firewall products such
    as the Windows built-in host firewall) by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>
    function or invoking tools such as PowerShell or the Windows command line.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件规避和绕过端点安全的一种粗糙但有效的方法就是直接禁用它。恶意软件在枚举了端点上运行的安全产品后，可以通过几种方式禁用它们。首先，它可以尝试通过调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp> 函数，或使用 PowerShell
    或 Windows 命令行等工具终止应用程序的进程（例如反恶意软件和 EDR 相关进程、Windows 安全中心进程和服务，以及任何防火墙产品，如 Windows
    内置的主机防火墙）。
- en: 'Some anti-malware solutions store parts of their configurations in the registry;
    tampering with these can also produce unwanted results. The malware family KillAV
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 659ce17fd9d4c6aad952bc5c0ae93a748178e53f8d60e45ba1d0c15632fd3e3f</samp>),
    which specializes in doing what its name suggests, attempts to disable the default
    Windows anti-malware and threat protection services by stopping processes and
    tampering with the registry. Here are some of the commands that this malware executes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '一些反恶意软件解决方案将其配置的部分存储在注册表中；篡改这些配置也可能导致不必要的结果。专门从事其名字所暗示的操作的恶意软件家族 KillAV (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 659ce17fd9d4c6aad952bc5c0ae93a748178e53f8d60e45ba1d0c15632fd3e3f</samp>)，尝试通过停止进程和篡改注册表来禁用默认的
    Windows 反恶意软件和威胁保护服务。以下是该恶意软件执行的一些命令：'
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">net stop WinDefend</samp>
    command terminates the Microsoft Defender process, while the various <samp class="SANS_TheSansMonoCd_W5Regular_11">REG
    ADD</samp> commands tamper with the registry to switch off the Microsoft Defender
    real-time monitoring service, the AntiSpyware service, and the AV boot driver
    (WdBoot), all of which are critical components of the Windows default anti-malware
    services.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">net stop WinDefend</samp> 命令终止
    Microsoft Defender 进程，而各种 <samp class="SANS_TheSansMonoCd_W5Regular_11">REG ADD</samp>
    命令则篡改注册表以关闭 Microsoft Defender 实时监控服务、反间谍软件服务和 AV 启动驱动程序 (WdBoot)，这些都是 Windows
    默认反恶意软件服务的关键组成部分。
- en: 'Some malware simply attempts to uninstall defense software from the host, using
    PowerShell commands like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件通过使用如下的 PowerShell 命令，简单地尝试卸载主机上的防御软件：
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first PowerShell command leverages WMI to enumerate installed software on
    the host, looking specifically for ESET anti-malware software; the second command
    uninstalls it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 PowerShell 命令利用 WMI 枚举主机上安装的软件，特别查找 ESET 反恶意软件；第二个命令卸载该软件。
- en: 'A possibly less noisy approach is lowering an endpoint defense process’s *priority*:
    that is, reducing how important the process is to the operating system. Higher-priority
    processes (typically, critical processes such as system processes) are allotted
    more CPU time. By lowering an endpoint defense process’s priority using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetPriorityClass</samp>, the malware can
    diminish its effectiveness. The following pseudocode demonstrates this approach:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能噪音较小的方法是降低端点防御进程的 *优先级*：即减少进程对操作系统的重要性。优先级较高的进程（通常是系统进程等关键进程）会分配更多的 CPU
    时间。通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SetPriorityClass</samp>
    降低端点防御进程的优先级，恶意软件可以减少其效果。以下伪代码展示了这种方法：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is a catch with these techniques, however: depending on the operating
    environment, the malware may require high-level privileges to terminate anti-malware
    processes and services, tamper with registry configurations and process priorities,
    and uninstall software. In this case, the malware must elevate its privileges
    before trying to disable endpoint defenses. We’ll look at how it does so in the
    “Privilege Elevation for Defense Evasion” section on [page 248](chapter13.xhtml#pg_248).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些技术有一个陷阱：根据操作环境的不同，恶意软件可能需要高权限才能终止反恶意软件进程和服务、篡改注册表配置和进程优先级，并卸载软件。在这种情况下，恶意软件必须提升其权限，然后才能尝试禁用端点防御。我们将在
    [第248页](chapter13.xhtml#pg_248) 的“防御规避的权限提升”部分中查看它是如何做到的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Adding Anti-malware
    Exclusions</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">添加反恶意软件排除项</samp>
- en: Another way to impair defenses is by tampering with the anti-malware exclusion
    list. Anti-malware software regularly scans specific filesystem directories on
    the endpoint, which are determined by how the user or organization configures
    the software. Most anti-malware software allows users to add exclusions, in the
    form of directory paths, to its configuration settings. Any files or directories
    in this exclusion list won’t be monitored or scanned.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种削弱防御的方法是篡改反恶意软件的排除列表。反恶意软件会定期扫描端点上的特定文件系统目录，这些目录由用户或组织配置软件时决定。大多数反恶意软件允许用户在其配置设置中添加排除项，通常以目录路径的形式。这些排除列表中的任何文件或目录都不会被监控或扫描。
- en: 'To employ this technique, an initial dropper or loader malware creates an exclusion
    on the victim host, and once that exclusion is enabled, it deploys the payload
    into the excluded directory. Here’s how malware could use PowerShell to create
    an exclusion in the Microsoft Defender anti-malware solution:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这种技术，初始的投放者或加载器恶意软件会在受害主机上创建一个排除项，一旦该排除项启用，它会将有效载荷部署到排除的目录中。以下是恶意软件如何使用
    PowerShell 在 Microsoft Defender 反恶意软件解决方案中创建排除项的示例：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command adds an anti-malware exclusion for the path *C:\Malware\DoNotScanThisDirectory\*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令为路径 *C:\Malware\DoNotScanThisDirectory\* 添加反恶意软件排除项。
- en: Note that the malware must have high-level privileges on the victim host to
    create exclusions in later versions of Windows, making the barrier to entry for
    this kind of attack more difficult than in older versions of the operating system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 Windows 的后续版本中，恶意软件必须具有高权限才能在受害主机上创建排除项，这使得这种攻击的入侵门槛比旧版本操作系统更高。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Disabling Other Security
    Controls</samp>
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">禁用其他安全控制</samp>
- en: In addition to disabling anti-malware, EDR, and other defenses, malware can
    disable other security features of the system. While such security features may
    not directly prevent attacks, disabling them can degrade the overall security
    of the host, making it more susceptible to further attacks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了禁用反恶意软件、EDR 和其他防御措施外，恶意软件还可以禁用系统的其他安全功能。虽然这些安全功能可能不会直接防止攻击，但禁用它们会降低主机的整体安全性，使其更容易受到进一步攻击。
- en: 'For example, malware may disable the Windows Update service, which is responsible
    for periodically updating Windows to patch bugs and vulnerabilities. If a threat
    actor disabled this service under the radar, it could ultimately degrade the overall
    security of the host over a longer period of time, leaving the system open to
    follow-up attacks. To disable a service with PowerShell, the malware could execute
    the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，恶意软件可能禁用 Windows 更新服务，该服务负责定期更新 Windows，以修补漏洞和漏洞。如果威胁行为者在不引人注意的情况下禁用了此服务，最终可能会在较长时间内削弱主机的整体安全性，使系统容易受到后续攻击。要使用
    PowerShell 禁用服务，恶意软件可以执行以下命令：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The malware could also disable PowerShell security. Some Windows environments
    prohibit the execution of unauthorized PowerShell scripts, so switching off script
    execution controls could help an attacker execute PowerShell scripts they otherwise
    couldn’t. To enable PowerShell script execution, an attacker can issue the following
    command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可能禁用 PowerShell 安全性。一些 Windows 环境禁止执行未经授权的 PowerShell 脚本，因此关闭脚本执行控制可能有助于攻击者执行他们原本无法执行的
    PowerShell 脚本。要启用 PowerShell 脚本执行，攻击者可以执行以下命令：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To prevent unauthorized outbound traffic from an endpoint, it’s common to configure
    a host-based firewall solution. Host-based firewalls can be used to allow outbound
    traffic from specific processes, such as web browsers, while preventing outbound
    traffic from processes that shouldn’t be communicating with any other hosts on
    the network or the internet. To get around this limitation, an attacker can directly
    modify firewall configurations on the host. This configuration differs depending
    on the firewall software being used, but for the standard Windows firewall, a
    rule can be added or modified with PowerShell. For example, malware could use
    the following command to change the default firewall policy to permit all outbound
    traffic from all processes on the host:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止未经授权的出站流量从端点传出，通常会配置基于主机的防火墙解决方案。基于主机的防火墙可以用于允许特定进程（如 web 浏览器）的出站流量，同时防止不应与任何其他主机或互联网通信的进程的出站流量。为了绕过这个限制，攻击者可以直接修改主机上的防火墙配置。根据使用的防火墙软件不同，这种配置有所不同，但对于标准的
    Windows 防火墙，可以通过 PowerShell 添加或修改规则。例如，恶意软件可以使用以下命令将默认的防火墙策略更改为允许所有进程的所有出站流量：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Malware can also disable non-security-related tools that could be used to expose
    it. Examples include terminating and disabling the Windows Task Manager to prevent
    cautious users from spotting suspicious running processes or disabling the Registry
    Editor to prevent a knowledgeable system administrator from identifying malicious
    artifacts in the registry.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以禁用与安全性无关的工具，这些工具可能被用来暴露它。例如，终止和禁用 Windows 任务管理器，以防止谨慎的用户发现可疑的正在运行的进程，或者禁用注册表编辑器，以防止有经验的系统管理员在注册表中识别恶意遗留物。
- en: There are many policies and configurations on a Windows system that an attacker
    could alter to degrade security; these are just a few examples. The key takeaway
    is that a threat actor may not attempt to completely disable endpoint defenses
    like anti-malware and EDR but may instead go for a less direct approach, making
    slight tweaks to the system to achieve its goals. This is a double-edged sword,
    however; the more the malware alters a system, the higher the chances it will
    be detected.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，攻击者可以更改许多策略和配置来削弱安全性；这些仅是一些例子。关键要点是，威胁行为者可能不会尝试完全禁用终端防御，如反恶意软件和
    EDR，而是可能采取一种较间接的方法，通过对系统进行轻微调整来实现其目标。然而，这是一把双刃剑；恶意软件对系统的修改越多，它被检测到的机会就越高。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Blinding Defenses
    by Unhooking</samp>
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">通过解除挂钩来致盲防御</samp>
- en: Since EDR and modern anti-malware heavily rely on hooks to monitor suspicious
    processes and detect and prevent threats, unhooking techniques can create blind
    spots for them. The unhooking approaches outlined in the “Anti-hooking” section
    on [page 137](chapter8.xhtml#pg_137) can be effective for some EDR and anti-malware
    software, but advanced host defenses are expecting them. These defenses may monitor
    their own hooks at the kernel level using their installed kernel components, and
    malware in turn could tamper with and unhook endpoint defenses at the kernel level.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于EDR和现代反恶意软件严重依赖钩子来监控可疑进程以及检测和防止威胁，解除钩取技术可能会为它们创造盲点。在[第137页](chapter8.xhtml#pg_137)“反钩取”部分中概述的解除钩取方法对于某些EDR和反恶意软件软件可能有效，但高级主机防御已经在期待这些方法。这些防御可能会使用它们安装的内核组件在内核级别监控自己的钩子，而恶意软件则可能篡改并解除终端防御的钩取。
- en: The cat-and-mouse game that malware authors and host defenses play is evident
    here. Endpoint protection software monitors and hooks into malware. The malware
    scans for these hooks and unhooks them or tries to circumvent them in other ways.
    In response, the endpoint protection products check whether they’ve been unhooked,
    and the cycle continues. Endpoint defenses have some advantage here, however.
    If a program tries to remove hooks, the EDR or anti-malware software can assume
    that the process is malicious with some level of confidence, as there’s virtually
    no legitimate reason for unhooking.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者与主机防御之间的猫鼠游戏在这里表现得非常明显。终端保护软件监控并钩取恶意软件。恶意软件扫描这些钩子，并解除钩取，或尝试通过其他方式绕过它们。作为回应，终端保护产品会检查它们是否已被解除钩取，循环继续。尽管如此，终端防御在此处还是有一定优势的。如果程序试图移除钩子，EDR或反恶意软件软件可以在一定程度上推测该进程是恶意的，因为几乎没有正当理由去解除钩取。
- en: As mentioned earlier in this chapter, endpoint defenses might use other sources
    of system monitoring, such as ETW, to supplement traditional hook-based monitoring.
    These data sources could also be blinded in various ways; in fact, there’s already
    a considerable amount of research on blinding ETW. This can be accomplished in
    multiple ways, one of which is to hook or patch <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwEventWrite</samp>,
    a function critical to ETW’s operation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所提到的，终端防御可能会使用其他系统监控源，如ETW，来补充传统的基于钩取的监控。这些数据源也可能以各种方式被盲化；事实上，已经有相当多的研究针对ETW盲化。这可以通过多种方式实现，其中一种方法是钩取或修补<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EtwEventWrite</samp>，该函数对ETW的操作至关重要。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Exploiting Vulnerabilities
    in Host Defense Tooling</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">利用主机防御工具中的漏洞</samp>
- en: Anti-malware, EDR, and other defenses are developed by humans, and humans make
    mistakes, so inevitably there will be bugs in the product code that could lead
    to vulnerabilities threat actors can exploit. There haven’t been many publicly
    reported attempts to exploit defense tooling during attacks, but it’s always a
    possibility, especially for threat actors that have the means and ability to discover
    these bugs. A quick search in the MITRE CVE vulnerability database ([*https://<wbr>cve<wbr>.mitre<wbr>.org*](https://cve.mitre.org))
    reveals some public vulnerabilities in anti-malware products, as shown in [Figure
    13-8](chapter13.xhtml#fig13-8).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 反恶意软件、EDR和其他防御系统是由人类开发的，而人类会犯错，因此，产品代码中不可避免地会存在漏洞，威胁行为者可以利用这些漏洞。尽管公开报告的利用防御工具的攻击尝试并不多，但这始终是一种可能性，特别是对于那些具备发现这些漏洞的手段和能力的威胁行为者。快速搜索MITRE
    CVE漏洞数据库（[*https://<wbr>cve<wbr>.mitre<wbr>.org*](https://cve.mitre.org)）可以找到一些反恶意软件产品中的公开漏洞，如[图13-8](chapter13.xhtml#fig13-8)所示。
- en: '![](../images/fig13-8.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-8: Vulnerabilities
    in anti-malware products, as reported by MITRE</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-8：MITRE报告的反恶意软件产品中的漏洞</samp>
- en: This list includes vulnerabilities discovered in the anti-malware engines of
    Watchdog, Kaspersky, and F-Secure products. Most of the vulnerabilities listed
    are *denial-of-service (DoS)* bugs that could allow specially crafted code to
    crash the anti-malware engine or otherwise hamper its effectiveness.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表包括在Watchdog、Kaspersky和F-Secure产品的反恶意软件引擎中发现的漏洞。列出的漏洞大多数是*拒绝服务（DoS）*漏洞，可能允许特制的代码使反恶意软件引擎崩溃或以其他方式妨碍其有效性。
- en: That sums up our tour of active circumvention techniques. Now we’ll turn to
    passive circumvention, which can be a stealthier and equally effective approach.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了我们对主动规避技术的探讨。接下来，我们将讨论被动规避，它可以是一种更加隐蔽且同样有效的方法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Passively Circumventing Endpoint Defenses</samp>
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">被动规避端点防御</samp>
- en: Passive circumvention techniques involve slipping past host defenses without
    directly tampering with them. As you’ll see, these methods can be just as fruitful
    as active techniques without raising as many alarms.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 被动规避技术通过不直接篡改防御措施来悄悄绕过宿主防御。如你所见，这些方法与主动技术一样有效，却不会引发太多警报。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Circumventing Monitoring</samp>
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">规避监控</samp>
- en: '[Chapter 8](chapter8.xhtml) discussed how malware can circumvent API hooking
    and monitoring in an attempt to evade sandboxes. Malware can use similar techniques
    to circumvent endpoint defenses. Because endpoint defenses also rely on function
    hooking to intercept and monitor suspicious activities, circumventing and bypassing
    these hooks is often an effective way to blind them.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](chapter8.xhtml)讨论了恶意软件如何规避API钩子和监控，从而试图逃避沙盒。恶意软件可以使用类似的技术来规避端点防御。由于端点防御也依赖于函数钩子来拦截和监控可疑活动，规避和绕过这些钩子通常是让它们失效的有效方式。'
- en: Since anti-malware and EDR monitor various Windows API calls to detect malicious
    activities, one circumvention measure is to implement *direct syscalls*, or calls
    into kernel address space from user mode that circumvent the typical syscall procedure.
    Specifically, when a program invokes an API function in user mode, the operating
    system makes a syscall into *ntosknrl.exe* to access the function’s code (see
    [Figure 13-9](chapter13.xhtml#fig13-9)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反恶意软件和EDR监控各种Windows API调用以检测恶意活动，一种规避措施是实现*直接系统调用*，即从用户模式直接调用内核地址空间，绕过典型的系统调用程序。具体来说，当程序在用户模式下调用API函数时，操作系统会发起一个系统调用进入*ntosknrl.exe*以访问该函数的代码（见[图13-9](chapter13.xhtml#fig13-9)）。
- en: '![](../images/fig13-9.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-9.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-9: Normal syscall
    behavior</samp>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-9：正常的系统调用行为</samp>
- en: Instead of relying on the normal Windows and NT API calling process, though,
    malware can directly make the syscall (see [Figure 13-10](chapter13.xhtml#fig13-10)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，恶意软件并不依赖于常规的Windows和NT API调用过程，而是可以直接发起系统调用（见[图13-10](chapter13.xhtml#fig13-10)）。
- en: '![](../images/fig13-10.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-10.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-10: A direct syscall</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-10：直接系统调用</samp>
- en: 'Syscalls follow a basic pattern called a *syscall stub.* The purpose of the
    stub is to transfer execution flow from user mode to kernel mode, where the code
    of the function being invoked actually resides. The following code shows a syscall
    stub for the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用遵循一种基本模式，称为*系统调用存根*。存根的目的是将执行流从用户模式转移到内核模式，在内核模式下被调用的函数的代码实际上驻留在其中。以下代码展示了一个针对<sup
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</sup>函数的系统调用存根：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The most important part of the stub is the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    eax, 18</samp> line, in which <samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp>
    represents the *system service number (SSN)*, sometimes referred to as the *syscall
    number* or *syscall ID*. This number maps to the function code (in this case,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>)
    that will be called in kernel mode. The next most important part of the stub is
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">syscall</samp> instruction (in
    hex, <samp class="SANS_TheSansMonoCd_W5Regular_11">0F 05</samp>), which uses the
    SSN in the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register to
    direct execution flow to the corresponding kernel function. The return (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>) instruction transfers execution
    flow back to the main program code once the syscall returns and has completed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 存根中最重要的部分是 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov eax, 18</samp>
    这一行，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp> 代表 *系统服务号（SSN）*，有时也称为
    *系统调用号* 或 *系统调用 ID*。这个数字映射到将以内核模式调用的函数代码（在本例中为 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>）。存根中下一个最重要的部分是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">syscall</samp> 指令（十六进制，<samp class="SANS_TheSansMonoCd_W5Regular_11">0F
    05</samp>），它使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> 寄存器中的
    SSN 将执行流指向相应的内核函数。返回（<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>）指令会将执行流转回主程序代码，一旦系统调用返回并完成。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The syscall stubs we’ve discussed thus far are specific to the x64 architecture.
    The x86 programs often use a different call:* sysenter*. Sysenter stubs are very
    similar:*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们目前讨论的系统调用存根特定于 x64 架构。x86 程序通常使用不同的调用：* sysenter*。sysenter 存根非常相似：*'
- en: mov edx, esp
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mov edx, esp
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sysenter
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sysenter
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ret
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ret
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov edx, esp</samp>
    instruction moves the SSN (stored in <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ESP</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EDX</samp> and passes
    it to the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sysenter</samp>
    instruction (hex <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">0F</samp>*
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">34</samp>*). Note that
    some x64 programs also use sysenter calls.*'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov edx, esp</samp>
    指令将 SSN（存储在 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ESP</samp>
    中）移动到 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EDX</samp> 中，并将其传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sysenter</samp> 指令（十六进制
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">0F</samp>* <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">34</samp>*）。请注意，一些
    x64 程序也使用 sysenter 调用。*'
- en: If malware wants to make a direct syscall (to avoid EDR or anti-malware hooks),
    it just needs to know the SSN of the function to call and then directly invoke
    the syscall. Sounds simple enough, but there are a few hurdles malware authors
    may face; most notably, function SSNs change depending on the Windows version
    and patch level of the target host. To get around this problem, malware authors
    have a few options. One option is to extract the SSNs from the *ntdll.dll* loaded
    in memory (see [Figure 13-11](chapter13.xhtml#fig13-11)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意软件想要直接发起系统调用（以避免 EDR 或反恶意软件钩子），它只需要知道要调用的函数的 SSN（系统服务号），然后直接调用该系统调用。听起来很简单，但恶意软件作者可能会面临一些障碍；最明显的是，函数的
    SSN 会根据目标主机的 Windows 版本和补丁级别而变化。为了解决这个问题，恶意软件作者有几个选择。一个选择是从内存中加载的 *ntdll.dll*
    中提取 SSN（请参见 [图 13-11](chapter13.xhtml#fig13-11)）。
- en: '![](../images/fig13-11.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-11: Syscall stubs
    in the loaded</samp> <samp class="SANS_Futura_Std_Book_11">ntdll.dll</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">module</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-11：已加载的</samp> <samp class="SANS_Futura_Std_Book_11">ntdll.dll</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">模块中的系统调用存根</samp>
- en: '[Figure 13-11](chapter13.xhtml#fig13-11) illustrates what *ntdll.dll* syscall
    stubs look like loaded in memory. Notice the highlighted SSNs for some of the
    exported *ntdll.dll* functions. Malware can inspect its loaded modules in memory,
    locate the relevant syscall stubs, and identify the SSN it requires. Once it obtains
    the SSN for the function it wants to call, it can craft its own syscall stubs,
    bypassing the standard syscall invocation from *ntdll.dll*. The following code
    illustrates the use of syscalls (more accurately, sysenters) in a variant of Remcos
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 45cd8dd797af4fd769eef00243134c46c38bd9e65e15d7bd2e9b834d5e8b3095</samp>):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-11](chapter13.xhtml#fig13-11) 展示了加载到内存中的 *ntdll.dll* 系统调用存根的样子。注意一些导出
    *ntdll.dll* 函数的 SSN 被高亮显示。恶意软件可以检查其加载的模块，定位相关的系统调用存根，并识别它所需的 SSN。一旦获取到它想要调用的函数的
    SSN，恶意软件就可以自定义系统调用存根，从而绕过 *ntdll.dll* 的标准系统调用调用。以下代码展示了在 Remcos 的一个变种中使用系统调用（更准确地说，是
    sysenter）的方式（<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 45cd8dd797af4fd769eef00243134c46c38bd9e65e15d7bd2e9b834d5e8b3095</samp>）：'
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This Remcos sample resolves the SSNs of the functions it wishes to call by enumerating
    the *ntdll.dll* file on disk (not shown here). It subsequently calls a function
    that contains the standard sysenter stub. Specifically, this Remcos sample is
    attempting to covertly inject code into another process by making direct sysenter
    calls to invoke the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>, and others.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Remcos 示例通过枚举磁盘上的 *ntdll.dll* 文件（此处未展示）来解析它希望调用的函数的 SSN。然后，它调用包含标准 sysenter
    存根的函数。具体来说，这个 Remcos 示例试图通过直接发起 sysenter 调用来隐秘地将代码注入到另一个进程中，从而调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>
    等函数。
- en: One problem with this approach is that these syscalls aren’t originating from
    their intended module, *ntdll.dll*. This can be a dead giveaway for endpoint defenses
    looking for this type of anomaly. A stealthier option, sometimes called an *indirect*
    syscall, is for malware authors to simply reuse the syscalls in *ntdll.dll* rather
    than crafting their own syscall stubs. To accomplish this, the malware identifies
    the syscall stub address in *ntdll.dll* for the function it wishes to call. Then,
    rather than including a call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>
    function, for example, the malware implements a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    instruction to jump directly to that syscall stub inside *ntdll.dll*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是，这些系统调用并不是来自它们预定的模块 *ntdll.dll*。对于寻找此类异常的端点防御系统来说，这可能是一个显而易见的提示。一个更为隐蔽的选项，有时被称为
    *间接* 系统调用，是恶意软件作者直接重用 *ntdll.dll* 中的系统调用，而不是自定义自己的系统调用存根。为了实现这一点，恶意软件识别出它希望调用的函数在
    *ntdll.dll* 中的系统调用存根地址。然后，恶意软件不再调用例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>
    函数，而是实现一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> 指令，直接跳转到 *ntdll.dll*
    中的该系统调用存根。
- en: These are just a few of the tricks malware authors might use to bypass hooks
    installed by endpoint defenses. However, these techniques are not foolproof. As
    you’ve seen, many can produce suspicious indicators (enumerating *ntdll.dll* memory,
    invoking syscalls directly from the malware’s code, making direct jumps into *ntdll.dll*,
    and so on). Not only that, but also many modern endpoint defenses hook into the
    kernel to attempt to spot this sort of activity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是恶意软件作者可能用来绕过端点防御系统所安装的钩子的几种技巧。然而，这些技巧并非万无一失。如你所见，许多方法会产生可疑的迹象（枚举 *ntdll.dll*
    内存、直接从恶意软件代码中调用系统调用、直接跳转到 *ntdll.dll* 等）。不仅如此，许多现代端点防御还会钩住内核，试图检测这种类型的活动。
- en: 'Evasion using syscall invocation is a fascinating topic, so if you’re interested
    in learning more, I recommend the following references:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用系统调用调用进行规避是一个有趣的话题，因此，如果你有兴趣了解更多，建议参考以下文献：
- en: Usman Sikander, “AV/EDR Evasion Using Direct System Calls (User-Mode vs. Kernel-Mode),”
    *Medium*, March 11, 2022, [*https://<wbr>medium<wbr>.com<wbr>/@merasor07<wbr>/av<wbr>-edr<wbr>-evasion<wbr>-using<wbr>-direct<wbr>-system<wbr>-calls<wbr>-user<wbr>-mode<wbr>-vs<wbr>-kernel<wbr>-mode<wbr>-fad2fdfed01a*](https://medium.com/@merasor07/av-edr-evasion-using-direct-system-calls-user-mode-vs-kernel-mode-fad2fdfed01a).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Usman Sikander，“使用直接系统调用绕过 AV/EDR（用户模式与内核模式），” *Medium*，2022年3月11日，[*https://<wbr>medium<wbr>.com<wbr>/@merasor07<wbr>/av<wbr>-edr<wbr>-evasion<wbr>-using<wbr>-direct<wbr>-system<wbr>-calls<wbr>-user<wbr>-mode<wbr>-vs<wbr>-kernel<wbr>-mode<wbr>-fad2fdfed01a*](https://medium.com/@merasor07/av-edr-evasion-using-direct-system-calls-user-mode-vs-kernel-mode-fad2fdfed01a)。
- en: 'Cornelis, “Red Team Tactics: Combining Direct System Calls and sRDI to bypass
    AV/EDR,” *Outflank*, June 19, 2019, [*https://<wbr>www<wbr>.outflank<wbr>.nl<wbr>/blog<wbr>/2019<wbr>/06<wbr>/19<wbr>/red<wbr>-team<wbr>-tactics<wbr>-combining<wbr>-direct<wbr>-system<wbr>-calls<wbr>-and<wbr>-srdi<wbr>-to<wbr>-bypass<wbr>-av<wbr>-edr<wbr>/*](https://www.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cornelis，“红队战术：结合直接系统调用和 sRDI 绕过 AV/EDR，” *Outflank*，2019年6月19日，[*https://<wbr>www<wbr>.outflank<wbr>.nl<wbr>/blog<wbr>/2019<wbr>/06<wbr>/19<wbr>/red<wbr>-team<wbr>-tactics<wbr>-combining<wbr>-direct<wbr>-system<wbr>-calls<wbr>-and<wbr>-srdi<wbr>-to<wbr>-bypass<wbr>-av<wbr>-edr<wbr>/*](https://www.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/)。
- en: Red Team Notes, “Calling Syscalls Directly from Visual Studio to Bypass AVs/EDRs,”
    *Red Team Notes*, n.d., [*https://<wbr>www<wbr>.ired<wbr>.team<wbr>/offensive<wbr>-security<wbr>/defense<wbr>-evasion<wbr>/using<wbr>-syscalls<wbr>-directly<wbr>-from<wbr>-visual<wbr>-studio<wbr>-to<wbr>-bypass<wbr>-avs<wbr>-edrs*](https://www.ired.team/offensive-security/defense-evasion/using-syscalls-directly-from-visual-studio-to-bypass-avs-edrs).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红队笔记，“直接从 Visual Studio 调用系统调用以绕过 AVs/EDRs，” *红队笔记*，无日期，[*https://<wbr>www<wbr>.ired<wbr>.team<wbr>/offensive<wbr>-security<wbr>/defense<wbr>-evasion<wbr>/using<wbr>-syscalls<wbr>-directly<wbr>-from<wbr>-visual<wbr>-studio<wbr>-to<wbr>-bypass<wbr>-avs<wbr>-edrs*](https://www.ired.team/offensive-security/defense-evasion/using-syscalls-directly-from-visual-studio-to-bypass-avs-edrs)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Circumventing Signature-Based
    Detection</samp>
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">规避基于签名的检测</samp>
- en: As we’ve discussed, anti-malware uses signature-based detection mechanisms,
    meaning that it looks for common patterns to identify malicious code in files
    and in memory. Malware often contains strings, function names, or DLL and module
    names that are hardcoded in its executable or that reside in memory and can be
    used to expose it. Thus, simply modifying these strings, functions, and module
    names can often lead to lower rates of detection, at least by more traditional
    anti-malware solutions. This is one of the most basic ways to abuse signature-based
    anti-malware detections, but modern malware requires more sophisticated evasion
    techniques to deal with more sophisticated anti-malware solutions. This is where
    mutation comes in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，反恶意软件使用基于签名的检测机制，这意味着它会寻找常见的模式来识别文件和内存中的恶意代码。恶意软件通常包含硬编码在其可执行文件中的字符串、函数名称，或者驻留在内存中的
    DLL 和模块名称，这些都可能暴露其存在。因此，简单地修改这些字符串、函数和模块名称，通常可以显著降低被检测的概率，至少是针对传统的反恶意软件解决方案来说。这是滥用基于签名的反恶意软件检测的最基本方法之一，但现代恶意软件需要更复杂的规避技术来应对更先进的反恶意软件解决方案。这就是变异技术的作用所在。
- en: '*Mutation* is malware’s ability to change its features and code in order to
    evade detection or adapt to its environment. With mutation, the malware’s goal
    is to change its code just enough to fly under the radar while retaining its basic
    functionalities. To help you better understand mutation, let’s look at the life
    cycle of a typical malware sample.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*变异*是恶意软件为了规避检测或适应其环境而改变其特征和代码的能力。通过变异，恶意软件的目标是对代码进行足够的修改，以避开雷达监控，同时保留其基本功能。为了帮助你更好地理解变异，我们来看看一个典型恶意软件样本的生命周期。'
- en: Some malware authors, notably cybercrime groups, “spam” malware to hundreds
    or thousands of potential victims, expecting to trick a few unsuspecting people
    into executing it. Once enough victims have been infected by a strain of malware,
    investigators will inevitably get their hands on the sample and develop detection
    rules for it, which will then be implemented in anti-malware engines and other
    defense technologies. This can quickly reduce the lifespan of any given piece
    of malware. This doesn’t apply just to mass spam malware, however; it can also
    be true of more targeted malware. If the malware is able to mutate on the victim
    host, it may be able to similarly evade detection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件作者，尤其是网络犯罪团伙，会将恶意软件“垃圾邮件”发送给数百或数千个潜在受害者，期望能诱使一些毫无防备的人执行它。一旦足够多的受害者被某种恶意软件感染，调查人员不可避免地会获得该样本并为其开发检测规则，这些规则随后会被实施到反恶意软件引擎和其他防御技术中。这将迅速减少任何恶意软件的生命周期。然而，这不仅适用于大规模垃圾邮件恶意软件；它同样适用于更有针对性的恶意软件。如果恶意软件能够在受害者主机上变异，它也可能像这样逃避检测。
- en: 'There are different forms of mutation, such as *code block reordering*, in
    which code is shifted around and reordered to create new “variants” of the malware,
    and *register reassignment*, in which CPU registers are changed (for example,
    all ECX register references are changed to EDX). These mutations of the malware’s
    code, implemented by a *mutation engine*, can significantly change the code’s
    structure and signature. The following is a very simple example of a mutation
    that shows how assembly code may be functionally identical but appears different:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同形式的变异，比如 *代码块重排*，在这种方式中，代码被移位并重新排序，以创建恶意软件的新“变体”；还有 *寄存器重新分配*，即更改CPU寄存器（例如，将所有
    ECX 寄存器引用改为 EDX）。这些由 *变异引擎* 实现的恶意软件代码变异，能够显著改变代码的结构和特征。下面是一个非常简单的变异示例，展示了汇编代码如何在功能上相同但外观不同：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example code block simply sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    register to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and then sets
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Compare this to the following
    code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码块简单地将 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> 寄存器设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，然后将 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。将其与下面的代码进行比较：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code also sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (but using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> instruction rather than the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction) and then
    sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    (using the <samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp> instruction
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>). If this
    were actual malicious code, anti-malware software might have a detection signature
    for one of these code blocks, but perhaps not the other. In the real world, of
    course, this code would be a lot more complex.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也将 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>（但使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> 指令，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令），然后将 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>（使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp> 指令，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>）。如果这段代码是实际的恶意代码，反恶意软件软件可能已经为其中一个代码块建立了检测特征，但可能没有对另一个代码块进行检测。当然，在现实世界中，这段代码会复杂得多。
- en: Mutation can occur either dynamically during runtime or on the malware file
    itself. Mutation during runtime occurs once the malware executes on the victim
    system. The malware may dynamically alter its code in memory to evade defenses
    that scan for malicious code patterns in memory. Mutation on the malware file
    itself occurs before the malware is delivered to the victim. The malware author
    may run their code through a mutation engine that spits out unique variants of
    the same malware that can all be delivered to different victims. Packers, which
    I’ll discuss in detail in [Chapter 17](chapter17.xhtml), can be a form of both
    runtime and static file mutation. When malware is run through a packing engine,
    it is obfuscated so that it will appear unique to all other variants of the same
    malware family.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 变异可以在运行时动态发生，也可以在恶意软件文件本身发生。运行时变异发生在恶意软件在受害者系统上执行时。恶意软件可能会在内存中动态修改其代码，以规避扫描内存中恶意代码模式的防御机制。恶意软件文件本身的变异发生在恶意软件被传递给受害者之前。恶意软件作者可能会通过变异引擎运行其代码，生成相同恶意软件的不同变种，并将这些变种传递给不同的受害者。打包器（packers），我将在[第17章](chapter17.xhtml)中详细讨论，既可以是运行时变异，也可以是静态文件变异。当恶意软件通过打包引擎运行时，它会被混淆，使其看起来与该恶意软件家族的所有其他变种都不同。
- en: 'The virus-like ransomware malware family Virlock provides a good example of
    mutation. When Virlock (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    7a92e23a6842cb51c9959892b83aa3be633d56ff50994e251b4fe82be1f2354c</samp>) executes
    on a victim system, it decrypts three instances of itself in memory and drops
    them to the disk as files. All three instances differ from all other Virlock malware
    samples and have a different signature. This ensures the malware will remain undetected,
    at least by anti-malware engines that rely on hashes and basic file signatures
    for detection.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '类似病毒的勒索软件家族Virlock是变异的一个很好的例子。当Virlock（<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    7a92e23a6842cb51c9959892b83aa3be633d56ff50994e251b4fe82be1f2354c</samp>）在受害者系统上执行时，它会在内存中解密三个自己的实例，并将它们作为文件丢到磁盘上。这三个实例与其他所有Virlock恶意软件样本不同，并且具有不同的签名。这确保了恶意软件能够保持未被检测到，至少对于依赖哈希值和基本文件签名进行检测的反恶意软件引擎来说是如此。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Uncommon Programming
    Languages</samp>
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">使用不常见的编程语言</samp>
- en: In an attempt to circumvent endpoint defenses, malware authors may use obscure
    or uncommon programming languages to develop their malware. Anti-malware software
    may be unfamiliar with the code and data structure in these languages, and it
    takes time for its signature and heuristic detections to catch up. Uncommon or
    new programming languages can also create a challenge for malware analysts and
    reverse engineers who are expecting more typical malware code, such as C or C++.
    Furthermore, many of these uncommon languages can be used across different operating
    systems. For instance, a program written for Windows can also run on macOS or
    Linux as long as the victim system has the required libraries installed. This
    can make the malware more resilient to different operating systems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了规避终端防御，恶意软件作者可能会使用不常见或罕见的编程语言来开发恶意软件。反恶意软件程序可能不熟悉这些语言中的代码和数据结构，因此它需要时间才能跟上其特征码和启发式检测。不常见或新的编程语言也可能对恶意软件分析师和逆向工程师造成挑战，因为他们期望看到的是更典型的恶意软件代码，如C或C++。此外，许多这些不常见的语言可以跨不同操作系统使用。例如，为Windows编写的程序只要受害者系统安装了所需的库，也可以在macOS或Linux上运行。这使得恶意软件在不同操作系统之间更具抗性。
- en: Using uncommon languages isn’t a new technique. Early malware was often written
    in C, but malware authors began using the .NET framework (such as C#), which is
    still very popular. However, anti-malware and other defenses have caught up, so
    malware authors are adapting and now increasingly using other languages. Python,
    a very common scripting language, has seen more use in malware in both scripts
    and executable format. Malware authors simply code a malicious Python script (*.py*),
    which can be executed on any system that has the right Python libraries installed.
    Tools such as Py2Exe and PyInstaller can even convert a Python script into an
    executable, which the attacker can deploy on a victim machine similar to a standard
    PE file. Since it’s fairly trivial to code a malicious Python script and then
    convert it into an executable, this approach has a lower barrier to entry for
    malware authors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不常见的编程语言并不是一种新技术。早期的恶意软件通常是用C语言编写的，但恶意软件作者开始使用.NET框架（如C#），该框架至今仍非常流行。然而，反恶意软件和其他防御措施已经迎头赶上，因此恶意软件作者正在适应并且越来越多地使用其他编程语言。Python作为一种非常常见的脚本语言，在恶意软件中得到了更多的应用，既可以用于脚本也可以用于可执行文件。恶意软件作者只需编写一个恶意的Python脚本（*.py*），该脚本可以在任何安装了正确Python库的系统上执行。工具如Py2Exe和PyInstaller甚至可以将Python脚本转换成可执行文件，攻击者可以像处理标准PE文件一样将其部署到受害者的机器上。由于编写一个恶意的Python脚本并将其转换为可执行文件相对简单，这种方法降低了恶意软件作者的门槛。
- en: Nim ([*https://<wbr>nim<wbr>-lang<wbr>.org*](https://nim-lang.org)), a self-proclaimed
    “statically typed compiled systems programming language,” has also seen growing
    use with malware authors. Notably, Nim was used by the threat group behind the
    infamous Trickbot banking trojan (see Lawrence Abrams’s article “TrickBot’s BazarBackdoor
    Malware is Now Coded in Nim to Evade Antivirus” at [*https://<wbr>www<wbr>.bleepingcomputer<wbr>.com<wbr>/news<wbr>/security<wbr>/trickbots<wbr>-bazarbackdoor<wbr>-malware<wbr>-is<wbr>-now<wbr>-coded<wbr>-in<wbr>-nim<wbr>-to<wbr>-evade<wbr>-antivirus<wbr>/*](https://www.bleepingcomputer.com/news/security/trickbots-bazarbackdoor-malware-is-now-coded-in-nim-to-evade-antivirus/)).
    Using Nim potentially helped the malware evade AV defenses.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Nim（[*https://<wbr>nim<wbr>-lang<wbr>.org*](https://nim-lang.org)），一个自称为“静态类型编译系统编程语言”的语言，恶意软件作者也开始越来越多地使用。特别是，Nim曾被背后威胁组使用，该组以臭名昭著的Trickbot银行木马而闻名（请参见Lawrence
    Abrams的文章《TrickBot的BazarBackdoor恶意软件现在使用Nim编码以规避杀毒软件》，链接为[*https://<wbr>www<wbr>.bleepingcomputer<wbr>.com<wbr>/news<wbr>/security<wbr>/trickbots<wbr>-bazarbackdoor<wbr>-malware<wbr>-is<wbr>-now<wbr>-coded<wbr>-in<wbr>-nim<wbr>-to<wbr>-evade<wbr>-antivirus<wbr>/*](https://www.bleepingcomputer.com/news/security/trickbots-bazarbackdoor-malware-is-now-coded-in-nim-to-evade-antivirus/))。使用Nim可能帮助恶意软件逃避了杀毒软件的防御。
- en: Go (sometimes called Golang) is an open source language from Google. It’s simple
    to program in (compared with other compiled languages such as C), so it’s no surprise
    that it has also seen increased use in malware. Rust ([*https://<wbr>www<wbr>.rust<wbr>-lang<wbr>.org*](https://www.rust-lang.org))
    is another language seeing more use in malware development. Indeed, nearly any
    programming or scripting language can be used for nefarious purposes, so this
    section could get very long. Even PowerShell is being used more often by malware
    authors. Malware analysts and defenders would be wise to stay abreast of the different
    languages being used in modern malware.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Go（有时称为Golang）是Google推出的一种开源语言。它比其他编译语言（如C语言）更易于编程，因此它在恶意软件中的使用增加也就不足为奇了。Rust（[*https://<wbr>www<wbr>.rust<wbr>-lang<wbr>.org*](https://www.rust-lang.org)）是另一种在恶意软件开发中得到更多使用的语言。实际上，几乎任何编程或脚本语言都可以用于不法目的，因此这一部分可能会非常长。即便是PowerShell也正被恶意软件作者越来越多地使用。恶意软件分析师和防御者应该密切关注现代恶意软件中使用的各种编程语言。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Abusing Certificate
    Trust and Signing</samp>
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">滥用证书信任和签名</samp>
- en: A *digital signature* is a trusted certificate that functions as a mark of approval
    for a file, informing the operating system and other applications that the file
    is legitimate and safe to execute. Many anti-malware solutions put less scrutiny
    on files that are digitally signed by a known and trusted authority. As a result,
    malware can abuse certificate trust chains to evade endpoint defenses.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字签名*是一种受信任的证书，作为文件的批准标志，通知操作系统和其他应用程序该文件是合法且可以安全执行的。许多反恶意软件解决方案对由已知且受信任的机构数字签名的文件审查较少。因此，恶意软件可以滥用证书信任链来绕过端点防御。'
- en: The *certificate trust store* is the repository where Windows stores the signer
    certificates that it trusts. You can view the trust store on Windows with the
    certmgr application (which you can find in *C:\Windows\System32*), as shown in
    [Figure 13-12](chapter13.xhtml#fig13-12).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*证书信任存储*是Windows存储其信任的签名者证书的库。您可以使用certmgr应用程序查看Windows中的信任存储（该应用程序可以在*C:\Windows\System32*中找到），如[图13-12](chapter13.xhtml#fig13-12)所示。'
- en: '![](../images/fig13-12.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-12.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-12: Viewing the trust
    store in Windows with certmgr</samp>'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-12：使用certmgr查看Windows中的信任存储</samp>
- en: Malware authors can digitally sign their code with a trusted certificate in
    a few ways. First, if a threat actor were to infiltrate the network of a trusted
    company, it could generate valid certificates and sign its own malware with them,
    or it could steal certificates and digitally sign its malicious code with those.
    In fact, this has happened on more than one occasion, such as when code-signing
    certificates were stolen from Nvidia in 2022 (see Pieter Arntz’s article “Stolen
    Nvidia Certificates Used to Sign Malware—Here’s What to Do” at [*https://<wbr>www<wbr>.malwarebytes<wbr>.com<wbr>/blog<wbr>/news<wbr>/2022<wbr>/03<wbr>/stolen<wbr>-nvidia<wbr>-certificates<wbr>-used<wbr>-to<wbr>-sign<wbr>-malware<wbr>-heres<wbr>-what<wbr>-to<wbr>-do*](https://www.malwarebytes.com/blog/news/2022/03/stolen-nvidia-certificates-used-to-sign-malware-heres-what-to-do)).
    Code-signing certificates are sometimes even sold on the dark web!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者可以通过几种方式使用受信证书对其代码进行数字签名。首先，如果攻击者渗透了受信任公司网络，它可以生成有效的证书并用这些证书签名自己的恶意软件，或者它可以窃取证书并用这些证书对其恶意代码进行数字签名。事实上，这种情况曾多次发生，例如2022年从Nvidia盗取代码签名证书时（请参见Pieter
    Arntz的文章《盗用Nvidia证书用于签名恶意软件——该如何应对》：[*https://<wbr>www<wbr>.malwarebytes<wbr>.com<wbr>/blog<wbr>/news<wbr>/2022<wbr>/03<wbr>/stolen<wbr>-nvidia<wbr>-certificates<wbr>-used<wbr>-to<wbr>-sign<wbr>-malware<wbr>-heres<wbr>-what<wbr>-to<wbr>-do*](https://www.malwarebytes.com/blog/news/2022/03/stolen-nvidia-certificates-used-to-sign-malware-heres-what-to-do))。代码签名证书有时甚至会在暗网出售！
- en: 'Second, in certain circumstances it’s possible to insert malicious code into
    a previously signed executable file, all without invalidating the certificate.
    This was presented by researchers at the Black Hat conference in 2016 (see the
    report “Certificate Bypass: Hiding and Executing Malware from a Digitally Signed
    Executable,” from the Deep Instinct Research Team, at [*https://<wbr>www<wbr>.blackhat<wbr>.com<wbr>/us<wbr>-16<wbr>/briefings<wbr>/schedule<wbr>/#certificate<wbr>-bypass<wbr>-hiding<wbr>-and<wbr>-executing<wbr>-malware<wbr>-from<wbr>-a<wbr>-digitally<wbr>-signed<wbr>-executable<wbr>-3984*](https://www.blackhat.com/us-16/briefings/schedule/#certificate-bypass-hiding-and-executing-malware-from-a-digitally-signed-executable-3984)).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在某些情况下，可以将恶意代码插入到一个已经签名的可执行文件中，而不会使证书失效。这在2016年Black Hat大会上由研究人员展示（请参见Deep
    Instinct研究团队的报告《证书绕过：隐藏和执行来自数字签名可执行文件的恶意软件》：[*https://<wbr>www<wbr>.blackhat<wbr>.com<wbr>/us<wbr>-16<wbr>/briefings<wbr>/schedule<wbr>/#certificate<wbr>-bypass<wbr>-hiding<wbr>-and<wbr>-executing<wbr>-malware<wbr>-from<wbr>-a<wbr>-digitally<wbr>-signed<wbr>-executable<wbr>-3984*](https://www.blackhat.com/us-16/briefings/schedule/#certificate-bypass-hiding-and-executing-malware-from-a-digitally-signed-executable-3984))。
- en: 'Finally, malware can simply add a certificate to the list of trusted certificates
    on the operating system. This is easier said than done: the malware must already
    be executing on the host with a high level of privileges. But if it succeeds,
    the malware author may be able to run any additional malware they wish to on the
    host.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件可以简单地将证书添加到操作系统的受信证书列表中。这说起来容易做起来难：恶意软件必须已经在具有高权限的主机上运行。但如果成功，恶意软件的作者可能能够在主机上运行他们希望运行的任何额外恶意软件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Abusing Engine Limitations</samp>
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">滥用引擎限制</samp>
- en: As mentioned earlier, anti-malware software (as well as EDR software that has
    built-in anti-malware capabilities) has the difficult task of balancing high rates
    of detection with the end-user experience. This means, first and foremost, that
    it must have a high success rate when detecting malicious code, while also limiting
    false positives. Additionally, the anti-malware scanning and monitoring activity
    must be transparent to the end user. These scans shouldn’t impact the user experience
    at a level where the system becomes unusable or unstable. Cunning malware authors
    can take advantage of these restrictions using various techniques, two examples
    being delayed execution and memory bombing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，反恶意软件（以及具有内建反恶意软件功能的EDR软件）面临着平衡高检测率与终端用户体验的艰巨任务。这意味着，首先，它必须在检测恶意代码时具有高成功率，同时还要限制误报。此外，反恶意软件的扫描和监控活动必须对终端用户透明。这些扫描不应影响用户体验到使系统无法使用或不稳定的程度。狡猾的恶意软件作者可以利用这些限制，采用各种技术，其中两个例子就是延迟执行和内存炸弹。
- en: In the same way that some malware uses delayed execution to evade detection
    inside a sandbox (as discussed in [Chapter 8](chapter8.xhtml)), it may be able
    to “outsleep” an anti-malware scanning engine. One way it can do this is by waiting
    until a specific number of milliseconds have passed. Once, say, 600,000 milliseconds
    (10 minutes) have elapsed, the sample executes its malicious code. Because the
    anti-malware engine might have a time limit on its emulation or sandboxing engine
    (to prevent the anti-malware engine from indefinitely analyzing a large file and
    consuming valuable system resources), this technique sometimes allows malware
    to slip through undetected.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些恶意软件通过延迟执行来规避沙盒内的检测（如[第8章](chapter8.xhtml)所讨论的）类似，它可能也能够“延迟”反恶意软件扫描引擎的检测。它可能通过等待特定的毫秒数过去来实现这一点。例如，当600,000毫秒（即10分钟）过去后，样本执行其恶意代码。由于反恶意软件引擎可能对其仿真或沙盒引擎设置了时间限制（以防止反恶意软件引擎无休止地分析大文件并消耗宝贵的系统资源），这种技术有时能够让恶意软件未被检测到地悄然通过。
- en: '*Memory bombing*, a term coined in the book *Antivirus Bypass Techniques* by
    Uriel Kosayev and Nir Yehoshua (Packt, 2021), involves malware allocating excessively
    large regions of memory inside its process address space. Because anti-malware
    software must take into account its system resources consumption (CPU, memory,
    and so on), it might only quickly scan this large region of memory or even ignore
    it altogether, allowing the malicious code to go unnoticed. Note that this technique
    can also be effective against sandboxes.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存炸弹*，这一术语由Uriel Kosayev和Nir Yehoshua在其著作《病毒防护绕过技术》（Packt，2021）中提出，指的是恶意软件在其进程地址空间内分配过大的内存区域。由于反恶意软件必须考虑系统资源的消耗（如CPU、内存等），它可能仅快速扫描这块大内存区域，甚至完全忽略它，从而使恶意代码未被发现。请注意，这一技术对于沙盒环境也可能有效。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Masquerading as a
    Safe File</samp>
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">伪装成一个安全文件</samp>
- en: '*Masquerading* is used by malware authors to disguise malware as legitimate
    files. This technique is used primarily as a method of deceiving a victim rather
    than as a means of directly circumventing endpoint defenses. Masquerading can
    take many forms, including the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*伪装*是恶意软件作者用来将恶意软件伪装成合法文件的技术。这一技术主要作为欺骗受害者的手段，而不是直接绕过终端防御。伪装有多种形式，包括以下几种：'
- en: '**Spoofing a filename**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪造文件名**'
- en: The malware author simply names a malicious file after a common system file
    or legitimate application file (such as *explorer.exe* or *PowerPoint.exe*) or
    slightly modifies a filename (such as *expl0rer.exe*). Malware authors could also
    change the file extension of malicious files to something more unassuming, such
    as renaming an *.exe* file to a *.jpg* file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者仅仅将恶意文件命名为常见的系统文件或合法应用程序文件的名字（例如*explorer.exe*或*PowerPoint.exe*），或者稍微修改文件名（如*expl0rer.exe*）。恶意软件作者还可能将恶意文件的扩展名更改为更不起眼的类型，比如将*.exe*文件重命名为*.jpg*文件。
- en: '**Spoofing file metadata**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪造文件元数据**'
- en: The malware author spoofs the metadata of a malicious file, such as by using
    “Microsoft” as the file’s publisher or company name. A similar technique is reusing
    legitimate program icons. For example, malware might use the Microsoft Word logo
    to make its malicious file appear genuine.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者伪造恶意文件的元数据，例如使用“Microsoft”作为文件的发布者或公司名称。类似的技术还包括重用合法程序的图标。例如，恶意软件可能使用Microsoft
    Word的图标，使其恶意文件看起来像合法文件。
- en: '**Executing social engineering attacks**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行社交工程攻击**'
- en: The malware author tricks the user into executing the malware, for example,
    by sending an email to a target user with a malicious file called *important_invoice.pdf*.
    A similar technique is the use of double extensions. By default, Windows doesn’t
    display file extensions, so the file *financials.xls.exe* would display in Windows
    as simply *financials.xls*. This may mislead an unsuspecting person into launching
    a malicious executable file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者通过欺骗用户执行恶意软件，例如，向目标用户发送一封带有名为*important_invoice.pdf*的恶意文件的电子邮件。类似的技巧是使用双扩展名。默认情况下，Windows
    不显示文件扩展名，因此文件*financials.xls.exe*在 Windows 中会显示为 *financials.xls*。这可能会误导毫无戒心的人启动一个恶意的可执行文件。
- en: Even though masquerading is a relatively simple and inexpensive technique to
    implement, it can be quite effective. Notably, researchers from ESET reported
    that the threat group Sandworm delivered to victims in Ukraine malware disguised
    as a component of the IDA Pro disassembly tool and ESET’s own security software
    (see Kelly Jackson Higgins’s article “Sandworm APT Trolls Researchers on its Trail
    as it Targets Ukraine” at [*https://<wbr>www<wbr>.darkreading<wbr>.com<wbr>/threat<wbr>-intelligence<wbr>/sandworm<wbr>-apt<wbr>-trolls<wbr>-researchers<wbr>-on<wbr>-its<wbr>-trail<wbr>-while<wbr>-it<wbr>-targets<wbr>-ukraine*](https://www.darkreading.com/threat-intelligence/sandworm-apt-trolls-researchers-on-its-trail-while-it-targets-ukraine)).
    Another notable example of masquerading is malware imitating documents authored
    by reputable organizations, such as COVID-19–related information from the World
    Health Organization, as reported by Proofpoint in 2022 (see “Nerbian RAT Using
    COVID-19 Themes Features Sophisticated Evasion Techniques” from Andrew Northern
    and colleagues at [*https://<wbr>www<wbr>.proofpoint<wbr>.com<wbr>/us<wbr>/blog<wbr>/threat<wbr>-insight<wbr>/nerbian<wbr>-rat<wbr>-using<wbr>-covid<wbr>-19<wbr>-themes<wbr>-features<wbr>-sophisticated<wbr>-evasion<wbr>-techniques*](https://www.proofpoint.com/us/blog/threat-insight/nerbian-rat-using-covid-19-themes-features-sophisticated-evasion-techniques)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管伪装是一种相对简单且成本低廉的技术，但它可以非常有效。特别是，ESET 的研究人员报告称，沙虫（Sandworm）威胁组织向乌克兰的受害者发送了伪装成
    IDA Pro 反汇编工具组件和 ESET 自家安全软件的恶意软件（见 Kelly Jackson Higgins 文章《沙虫 APT 在追踪其痕迹时戏弄研究人员，目标锁定乌克兰》，网址为
    [*https://www.darkreading.com/threat-intelligence/sandworm-apt-trolls-researchers-on-its-trail-while-it-targets-ukraine*](https://www.darkreading.com/threat-intelligence/sandworm-apt-trolls-researchers-on-its-trail-while-it-targets-ukraine)）。另一个显著的伪装案例是恶意软件模仿知名组织撰写的文档，如
    2022 年 Proofpoint 报告的世界卫生组织发布的关于 COVID-19 的信息（见 Andrew Northern 等人的文章《Nerbian
    RAT 使用 COVID-19 主题，具备复杂的规避技术》，网址为 [*https://www.proofpoint.com/us/blog/threat-insight/nerbian-rat-using-covid-19-themes-features-sophisticated-evasion-techniques*](https://www.proofpoint.com/us/blog/threat-insight/nerbian-rat-using-covid-19-themes-features-sophisticated-evasion-techniques)）。
- en: So far, we’ve explored different techniques malware uses to circumvent host
    defenses by actively tampering with them or passively slipping by them. Now let’s
    shift gears a bit and explore privilege elevation and how it can be used by malware
    to carry out operations that may otherwise be detected and blocked by endpoint
    defenses.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了恶意软件如何通过积极篡改或被动绕过主机防御来规避它们。现在，让我们稍微转变一下思路，探讨权限提升及其如何被恶意软件用来执行那些可能会被终端防御检测并阻止的操作。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Privilege Elevation for Defense Evasion</samp>
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">用于防御规避的权限提升</samp>
- en: '*Privilege elevation*, or obtaining a higher level of privileges than one currently
    holds, can be a potent evasion tactic. After obtaining a high privilege level
    on the host, an attacker has a lot more freedom to execute further attacks that
    bypass endpoint defenses. As you’ve seen, high privilege levels are required for
    actions such as disabling anti-malware or modifying firewall configurations. While
    there are many ways to elevate privileges, this section will focus on four of
    the most common techniques in modern malware: UAC bypasses, access token impersonation
    and manipulation, credential reuse, and direct exploitation.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*权限提升*，即获得比当前更高的权限级别，是一种强大的规避策略。在主机上获得高权限级别后，攻击者将拥有更多自由，能够执行绕过终端防御的进一步攻击。正如你所看到的，执行某些操作（如禁用反恶意软件或修改防火墙配置）需要高权限级别。虽然有很多方式可以提升权限，本节将重点介绍现代恶意软件中四种最常见的技巧：UAC
    绕过、访问令牌伪装和操控、凭据重用和直接利用。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Bypassing User Account
    Control</samp>
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">绕过用户帐户控制</samp>
- en: '*User Account Control (UAC)* is a protection control in Windows designed to
    prevent unauthorized applications from executing code at high privilege levels.
    When an application requests administrator access, an administrator on the system
    must consent to the request (see [Figure 13-13](chapter13.xhtml#fig13-13)).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户帐户控制（UAC）*是Windows中的一种保护控制，旨在防止未经授权的应用程序以高权限级别执行代码。当应用程序请求管理员访问权限时，系统中的管理员必须同意此请求（参见[图13-13](chapter13.xhtml#fig13-13)）。'
- en: '![](../images/fig13-13.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-13.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-13: A typical UAC
    pop-up</samp>'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-13：典型的UAC弹出窗口</samp>
- en: When an administrator consents, the application’s process integrity level increases
    to “high.” The most common integrity levels (high, medium, low, and system) help
    dictate what a process can and cannot do on a system. High-integrity processes
    run in an elevated mode and have access to objects assigned to lower integrity
    levels. Medium-integrity processes run with standard user rights; this is the
    default setting for most processes. Low-integrity processes have the lowest privilege
    level and are usually reserved for applications such as web browsers that should
    run in a container-like environment for security reasons. System integrity processes
    are those that are integral to the stability of the operating system; these include
    the Service Control Manager (*services.exe*) and the Windows subsystem process
    (*csrss.exe*). By design, processes with lower integrity levels cannot modify
    data in processes with higher integrity levels.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理员同意时，应用程序的进程完整性级别会提高到“高”。最常见的完整性级别（高、中、低和系统）帮助决定一个进程能做什么以及不能做什么。高完整性进程在提升模式下运行，并可以访问分配给较低完整性级别的对象。中完整性进程以标准用户权限运行；这是大多数进程的默认设置。低完整性进程具有最低权限级别，通常用于诸如Web浏览器等应用程序，这些程序应出于安全原因在类似容器的环境中运行。系统完整性进程是对操作系统稳定性至关重要的进程；这些包括服务控制管理器（*services.exe*）和Windows子系统进程（*csrss.exe*）。按照设计，较低完整性级别的进程无法修改具有更高完整性级别进程中的数据。
- en: '[Figure 13-14](chapter13.xhtml#fig13-14) shows an excerpt from Process Hacker,
    which conveniently highlights processes based on their elevation and integrity
    levels.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-14](chapter13.xhtml#fig13-14)显示了Process Hacker中的一个摘录，它方便地根据进程的提升和完整性级别对进程进行高亮显示。'
- en: '![](../images/fig13-14.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-14.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-14: Process integrity
    viewed in Process Hacker</samp>'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-14：在Process Hacker中查看进程完整性</samp>
- en: Process Hacker itself (*ProcessHacker.exe*) is highlighted in orange (or dark
    gray in this book), meaning that it’s elevated and running in a high-integrity
    mode. *Explorer.exe* is highlighted in pink (medium gray), demarcating it as a
    system process. The other, more mundane processes, such as Excel and Notepad,
    are yellow (light gray), meaning that they’re medium-integrity processes running
    with standard user privileges.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Process Hacker本身（*ProcessHacker.exe*）以橙色（或本书中的深灰色）突出显示，表示它是提升过的并以高完整性模式运行。*Explorer.exe*以粉红色（中灰色）突出显示，标明它是一个系统进程。其他一些更为平凡的进程，如Excel和Notepad，则以黄色（浅灰色）显示，表示它们是中等完整性进程，以标准用户权限运行。
- en: UAC works to protect systems against malicious privilege elevation attempts
    by explicitly requesting permission from a higher-level account. UAC bypass attacks
    rely on tricking a user, an application, or the operating system itself into executing
    potentially dangerous actions in an elevated context. Let’s take a look at how
    UAC bypasses work in practice with a simple example.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: UAC旨在通过明确请求更高权限账户的许可来保护系统免受恶意权限提升的攻击。UAC绕过攻击依赖于欺骗用户、应用程序或操作系统本身，使其在提升的上下文中执行潜在的危险操作。让我们通过一个简单的例子来看看UAC绕过是如何在实践中工作的。
- en: A number of built-in Windows utilities are designed to be run with elevated
    permissions. One of these utilities is *msconfig.exe*, a simple Windows configuration
    tool that allows system administrators to change Windows boot options and modify
    services and startup tasks, among other things. Normally, applications requesting
    elevated permissions produce a UAC prompt; by default, even users with administrator
    privileges must consent to this prompt. If executed from an administrator account,
    however, *msconfig.exe* automatically elevates itself to a high-integrity process
    without prompting for UAC. Furthermore, it allows for the execution of other tools
    that will subsequently run in a high-integrity context, also without a UAC prompt.
    Unfortunately for *msconfig.exe*, an actor can abuse this behavior, resulting
    in a simple UAC bypass. From the Tools menu in *msconfig.exe*, a user can select
    the Command Prompt tool and click Launch (see [Figure 13-15](chapter13.xhtml#fig13-15)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内置的Windows工具被设计为以提升权限运行。其中一个工具是*msconfig.exe*，这是一个简单的Windows配置工具，允许系统管理员更改Windows启动选项、修改服务和启动任务等。通常，请求提升权限的应用程序会弹出UAC提示；默认情况下，即使是拥有管理员权限的用户也必须同意该提示。然而，如果从管理员账户执行，*msconfig.exe*会自动将自身提升为高完整性进程，而无需弹出UAC提示。此外，它还允许执行其他工具，这些工具也会在高完整性上下文中运行，同样不会出现UAC提示。不幸的是，*msconfig.exe*的这一行为可以被恶意利用，导致简单的UAC绕过。从*msconfig.exe*的工具菜单中，用户可以选择命令提示符工具并点击启动（参见[图13-15](chapter13.xhtml#fig13-15)）。
- en: '![](../images/fig13-15.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-15.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-15: Launching a command
    prompt from</samp> <samp class="SANS_Futura_Std_Book_11">msconfig.exe</samp>'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-15：从</samp> <samp class="SANS_Futura_Std_Book_11">msconfig.exe</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">启动命令提示符</samp>
- en: Next, a new command prompt with the integrity level of its parent process (*msconfig.exe*)
    will launch, without prompting for UAC permission. [Figure 13-16](chapter13.xhtml#fig13-16)
    shows this new *cmd.exe* process in Process Hacker.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将启动一个具有其父进程（*msconfig.exe*）完整性级别的新命令提示符，而不会提示UAC权限。[图13-16](chapter13.xhtml#fig13-16)显示了在Process
    Hacker中该新的*cmd.exe*进程。
- en: '![](../images/fig13-16.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-16.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-16: The</samp> <samp
    class="SANS_Futura_Std_Book_11">cmd.exe</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">process
    spawned with high integrity</samp>'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-16：具有高完整性级别的</samp> <samp
    class="SANS_Futura_Std_Book_11">cmd.exe</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">进程</samp>
- en: 'Notice that the process’s privileges are elevated (“Elevated: Yes”) and its
    integrity is high. The user bypassed UAC by executing a process that must be run
    in a high-integrity context (which doesn’t prompt for UAC permission on the default
    Windows configuration) and by spawning a command prompt that inherits that process’s
    high integrity level. This command prompt is now running as administrator and
    can be used to execute high-privilege commands. A similar real-world example of
    this comes from the malware family Trickbot, which abuses the auto-elevation property
    of the *WSReset.exe* Windows tool; see the article “Trickbot Trojan Leveraging
    a New Windows 10 UAC Bypass,” by Arnold Osipov at [*https://<wbr>blog<wbr>.morphisec<wbr>.com<wbr>/trickbot<wbr>-uses<wbr>-a<wbr>-new<wbr>-windows<wbr>-10<wbr>-uac<wbr>-bypass*](https://blog.morphisec.com/trickbot-uses-a-new-windows-10-uac-bypass).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，该进程的权限已被提升（“Elevated: Yes”），且其完整性级别为高。用户通过执行必须在高完整性上下文中运行的进程（该进程在默认的Windows配置下不会提示UAC权限）来绕过了UAC，并通过启动一个继承该进程高完整性级别的命令提示符。这个命令提示符现在以管理员身份运行，可以用来执行高权限命令。一个类似的真实案例来自恶意软件家族Trickbot，它利用了*WSReset.exe*
    Windows工具的自动提升特性；详情见Arnold Osipov的文章“Trickbot木马利用新的Windows 10 UAC绕过”[在此阅读](https://blog.morphisec.com/trickbot-uses-a-new-windows-10-uac-bypass)。'
- en: The problem with this particular UAC bypass is that it requires GUI access to
    the system, so malware would have to jump through quite a few hoops to execute
    this attack without the victim noticing what’s going on. Malware authors have
    discovered a few ways to get around this limitation, however.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的UAC绕过问题在于它需要访问系统的GUI界面，因此恶意软件必须经过多个步骤才能在不让受害者察觉的情况下执行这一攻击。然而，恶意软件作者已经发现了一些方法来绕过这一限制。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">DLL Hijacking</samp>
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">DLL劫持</samp>
- en: In [Chapter 12](chapter12.xhtml), you learned that malware can abuse hijacking
    vulnerabilities in legitimate applications to inject a malicious DLL and stealthily
    run code. This type of attack is also an effective way to bypass UAC. Revisiting
    the *msconfig.exe* example used earlier, if it fell prey to DLL hijacking and
    allowed a malicious DLL to be loaded in place of a legitimate one, the malicious
    DLL could then execute under the context of the high-privileged *msconfig.exe*
    application. Any UAC pop-ups will be under the guise of *msconfig.exe*, possibly
    tricking the user into consenting and allowing the malicious code to run at a
    higher privilege level than would otherwise be possible.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 12 章](chapter12.xhtml)中，您学到了恶意软件如何利用合法应用中的劫持漏洞来注入恶意 DLL 并隐秘地执行代码。这种攻击方式也是绕过
    UAC 的有效手段。回顾之前使用的 *msconfig.exe* 示例，如果它成为 DLL 劫持的受害者，并允许恶意 DLL 替换合法 DLL 加载，那么该恶意
    DLL 就可以在高权限的 *msconfig.exe* 应用程序上下文中执行。任何 UAC 弹窗将以 *msconfig.exe* 的名义出现，可能会欺骗用户同意并允许恶意代码以比正常情况下更高的权限级别运行。
- en: 'In a 2016 report from Fox-IT and NCC Group called “Mofang: A Politically Motivated
    Information Stealing Adversary” (which you can download at [*https://<wbr>blog<wbr>.fox<wbr>-it<wbr>.com<wbr>/2016<wbr>/06<wbr>/15<wbr>/mofang<wbr>-a<wbr>-politically<wbr>-motivated<wbr>-information<wbr>-stealing<wbr>-adversary<wbr>/*](https://blog.fox-it.com/2016/06/15/mofang-a-politically-motivated-information-stealing-adversary/)),
    researchers highlighted such an attack by the threat group Mofang, which abused
    the legitimate *migwiz.exe* Windows application to load a DLL called *cryptbase.dll*.
    This DLL was hijacked by the attackers, causing *migwiz.exe* (which runs in an
    elevated state by default) to load the malicious version of *cryptbase.dll*, effectively
    bypassing certain UAC controls.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2016 年 Fox-IT 和 NCC Group 发布的报告《Mofang：一场政治动机的信息窃取对抗者》（您可以在 [*https://<wbr>blog<wbr>.fox<wbr>-it<wbr>.com<wbr>/2016<wbr>/06<wbr>/15<wbr>/mofang<wbr>-a<wbr>-politically<wbr>-motivated<wbr>-information<wbr>-stealing<wbr>-adversary<wbr>/*](https://blog.fox-it.com/2016/06/15/mofang-a-politically-motivated-information-stealing-adversary/)
    下载）中，研究人员突出展示了 Mofang 威胁组的这种攻击，该组滥用了合法的 *migwiz.exe* Windows 应用程序来加载一个名为 *cryptbase.dll*
    的 DLL。这个 DLL 被攻击者劫持，导致 *migwiz.exe*（默认以提升状态运行）加载了恶意版本的 *cryptbase.dll*，有效地绕过了某些
    UAC 控制。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">COM Abuse</samp>
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">COM 滥用</samp>
- en: 'The *Component Object Model (COM)* is a part of the Windows API that allows
    for interprocess communication. The basic building block of COM is a *COM object*,
    which is composed of data and the functions that control access to it, known as
    *interfaces*. A COM object server exposes interfaces to COM clients, and clients
    access the COM server via these interfaces. COM server objects are often *.dll*
    or *.exe* files. Each COM server object has a unique ID, called a class ID (CLSID),
    which is a 128-bit string that takes the form of a series of numbers and characters.
    These strings are often displayed in brackets, as in this example: <samp class="SANS_TheSansMonoCd_W5Regular_11">{4E5FC2F8-8C44-6776-0912-CB15617EBC13}</samp>.
    This will be important in a moment.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件对象模型 (COM)* 是 Windows API 的一部分，允许进程间通信。COM 的基本构建块是 *COM 对象*，它由数据和控制访问的函数组成，这些函数被称为
    *接口*。COM 对象服务器向 COM 客户端暴露接口，客户端通过这些接口访问 COM 服务器。COM 服务器对象通常是 *.dll* 或 *.exe* 文件。每个
    COM 服务器对象都有一个唯一的 ID，称为类 ID (CLSID)，它是一个 128 位的字符串，形式是由一系列数字和字符组成。这些字符串通常显示在括号中，例如：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{4E5FC2F8-8C44-6776-0912-CB15617EBC13}</samp>。这一点稍后会很重要。'
- en: A number of COM objects have a property called <samp class="SANS_TheSansMonoCd_W5Regular_11">COMAutoApproval</samp>,
    which indicates that the particular COM object doesn’t require a user to explicitly
    permit the privilege elevation functions that are part of the object. On a Windows
    system, you can view the list of COM objects that have this property in the registry
    key *HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\UAC\COMAutoApprovalList*.
    [Figure 13-17](chapter13.xhtml#fig13-17) shows this list on my system.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 COM 对象都有一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">COMAutoApproval</samp>
    的属性，表示该 COM 对象不需要用户明确允许与对象相关的权限提升功能。在 Windows 系统中，您可以在注册表项 *HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows
    NT\CurrentVersion\UAC\COMAutoApprovalList* 中查看具有此属性的 COM 对象列表。[图 13-17](chapter13.xhtml#fig13-17)
    显示了我系统上的这个列表。
- en: '![](../images/fig13-17.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-17.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-17: Viewing COM objects
    with COMAutoApproval enabled</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-17：启用 COMAutoApproval 的情况下查看
    COM 对象</samp>
- en: 'On a typical Windows 10 system, there are over 100 objects in this list! As
    you might imagine, some of these objects can be abused by malware to bypass UAC.
    For example, some COM object interfaces contain functions that can execute arbitrary
    code. A COM interface may expose a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteCommand</samp>,
    for instance, that takes an arbitrary command as input. The following pseudocode
    illustrates this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Windows 10系统中，这个列表中有超过100个对象！正如你可以想象的那样，其中一些对象可能会被恶意软件滥用，以绕过UAC。例如，一些COM对象接口包含可以执行任意代码的函数。例如，一个COM接口可能暴露一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ExecuteCommand</samp>的函数，该函数接受任意命令作为输入。以下伪代码展示了这一点：
- en: '[PRE13]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This malware initializes COM (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoInitialize</samp>)
    and creates a COM instance (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoCreateInstance</samp>)
    of the COM object <samp class="SANS_TheSansMonoCd_W5Regular_11">VulnerableComObject</samp>.
    Once the COM object is initialized, the malware invokes the vulnerable <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteCommand</samp>
    method (which is exposed and exported via the COM object), passing <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp>
    as a parameter. Because the COM object is running with high privileges, the subsequent
    command will also be executed with high privileges. This specific command copies
    the malware executable into the *System32* directory, an action that would normally
    display a UAC prompt.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件初始化COM（<samp class="SANS_TheSansMonoCd_W5Regular_11">CoInitialize</samp>），并创建COM对象<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VulnerableComObject</samp>的COM实例（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CoCreateInstance</samp>）。一旦COM对象初始化，恶意软件就会调用脆弱的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ExecuteCommand</samp>方法（该方法通过COM对象暴露并导出），并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">command</samp>作为参数传入。由于COM对象以高权限运行，随后的命令也将以高权限执行。这个特定的命令将恶意软件可执行文件复制到*System32*目录，这个操作通常会显示UAC提示。
- en: This is a simplified version of this technique, but similar techniques have
    been used in real-world attacks. A well-researched project called UACME details
    a variation of this technique and many more at [*https://<wbr>github<wbr>.com<wbr>/hfiref0x<wbr>/UACME*](https://github.com/hfiref0x/UACME).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该技术的简化版，但类似的技术已经在现实攻击中被使用过。一个经过深入研究的项目UACME详细介绍了该技术的变种及更多内容，网址是[*https://<wbr>github<wbr>.com<wbr>/hfiref0x<wbr>/UACME*](https://github.com/hfiref0x/UACME)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registry Tampering</samp>
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">注册表篡改</samp>
- en: Although modifying the registry often requires high-level privileges on the
    victim system in the first place, malware can use the registry to sidestep the
    UAC prompt itself. Consider a scenario in which an attacker has control over the
    infected host and can execute commands on it but doesn’t have a GUI to the host.
    The attacker might still be required to click on UAC prompts to execute certain
    actions, and this can be problematic without a graphical interface to the victim
    system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管修改注册表通常需要对受害者系统拥有高权限，但恶意软件可以利用注册表绕过UAC提示本身。考虑一种情境，攻击者控制了受感染的主机并能够执行命令，但没有图形界面。攻击者可能仍然需要点击UAC提示才能执行某些操作，而没有图形界面的情况下，这会造成问题。
- en: In this case, the malware can try to modify the registry key *HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\EnableLUA*
    from the default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which will effectively
    disable UAC prompts on the host. Setting the key *HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ConsentPromptBehaviorAdmin*
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> will also disable UAC
    prompts for administrator actions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，恶意软件可以尝试修改注册表项*HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\EnableLUA*，将其从默认值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>修改为<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，这将有效地禁用主机上的UAC提示。将键值*HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ConsentPromptBehaviorAdmin*设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，也将禁用管理员操作的UAC提示。
- en: Note that the machine may need to be rebooted in order for these changes to
    take effect, which could be problematic for the attacker and provoke unwanted
    attention.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，机器可能需要重新启动才能使这些更改生效，这可能对攻击者造成问题并引起不必要的关注。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Impersonating and
    Manipulating Access Tokens</samp>
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">模拟和操控访问令牌</samp>
- en: 'Each process running on a system has an assigned access token inherited from
    its parent process, whose access token is in turn inherited from the user account
    that spawned it. This user account access token represents the rights and privileges
    of the user account. Process access tokens can be assigned different privileges:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>, for example,
    grants a user or process the ability to back up files and directories; <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>
    grants the process the ability to load a kernel driver; and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeShutdownPrivilege</samp>
    permits a process to shut down the system.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上运行的每个进程都有一个从其父进程继承的访问令牌，而父进程的访问令牌又是从启动它的用户帐户继承的。这个用户帐户访问令牌代表了用户帐户的权利和权限。进程访问令牌可以分配不同的权限：例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp> 赋予用户或进程备份文件和目录的能力；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp> 赋予进程加载内核驱动程序的能力；而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeShutdownPrivilege</samp> 允许进程关闭系统。
- en: To gain additional privileges, malware can duplicate a token from another process,
    a technique often known as *token theft* or *token impersonation*. The malware
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">DuplicateToken</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DuplicateTokenEx</samp> to create a copy
    of a token assigned to another process, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateLoggedOnUser</samp>,
    passing the duplicated token as a parameter. This assigns the permissions of the
    original token to the malware. The malware can also call <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp>
    to spawn a brand-new process and assign it the permissions of the duplicated token.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得额外的权限，恶意软件可以复制另一个进程的令牌，这种技术通常被称为 *令牌窃取* 或 *令牌冒充*。恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DuplicateToken</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">DuplicateTokenEx</samp> 来创建一个从另一个进程分配来的令牌副本，然后调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateLoggedOnUser</samp>，将复制的令牌作为参数传递。这将把原始令牌的权限赋给恶意软件。恶意软件还可以调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp> 来生成一个全新的进程，并赋予它复制令牌的权限。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Alternatively, malware can manipulate its own token and assign it new privileges.
    One such coveted privilege that malware may attempt to obtain is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeDebugPrivilege</samp>,
    which permits a process to inspect and manipulate other processes owned by other
    user accounts, up to and including the System account. If a lower-privileged process
    is allowed to manipulate System processes, it can potentially inject and execute
    code in the context of these processes, completely bypassing UAC controls or,
    at the very least, tricking users into permitting elevated actions via UAC.*'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*或者，恶意软件可以操控其自身的令牌并赋予它新的权限。恶意软件可能试图获得的一个重要权限是 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeDebugPrivilege</samp>，该权限允许进程检查和操控其他用户帐户拥有的进程，包括系统帐户。如果一个低权限进程被允许操控系统进程，它可能会在这些进程的上下文中注入并执行代码，从而完全绕过UAC控制，或者至少通过UAC欺骗用户允许提升的操作。*'
- en: To gain the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    privilege, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcessToken</samp>
    function to open the access token of its process, then invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp>,
    passing <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    as a parameter. However, just because a process requests this privilege doesn’t
    mean the operating system will grant it. Only previously elevated processes can
    request and be granted this permission, so the malware must already be running
    in an elevated state. Malware usually will use one of the UAC bypass techniques
    mentioned earlier in this chapter to elevate its privileges and then grant itself
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> to gain
    further access to other system processes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> 权限，恶意软件调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcessToken</samp> 函数来打开其进程的访问令牌，然后调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp>，将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> 作为参数传递。然而，仅仅因为一个进程请求了这个特权并不意味着操作系统会授予它。只有之前已经提升权限的进程才能请求并被授予该权限，因此恶意软件必须已经在提升状态下运行。恶意软件通常会使用本章前面提到的
    UAC 绕过技术之一来提升自己的权限，然后授予自己 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>，以进一步访问其他系统进程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Extracting and Reusing
    Credentials</samp>
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">提取并重用凭证</samp>
- en: Locating and extracting account credentials can be a potent privilege elevation
    method. If malware can locate an administrator’s credentials, for example, it
    may be able to reuse them to create a process with elevated permissions, or even
    to move laterally to other hosts on the network and gain elevated privileges on
    those systems. There are many ways malware can do this.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 定位和提取账户凭证可以是一种强有力的特权提升方法。例如，如果恶意软件能够找到管理员的凭证，它可能会重新使用这些凭证创建一个具有提升权限的进程，甚至可以横向移动到网络中的其他主机并在这些系统上获得提升的权限。恶意软件有许多方法可以做到这一点。
- en: One method of extracting credentials is to inspect the memory of the *Local
    Security Authority Subsystem Service (LSASS)* process, which oversees security
    policies and authentication. By nature, its process (*lsass.exe*) contains sensitive
    data in its memory address space—namely, login credentials and security tokens.
    On modern versions of Windows, this sensitive data is obfuscated (for example,
    via hashing), but in special circumstances it may be in cleartext. By inspecting
    the process memory of *lsass.exe*, malware may be able to locate and extract privileged
    credentials and tokens, then attempt to reuse them to elevate its own privileges.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 提取凭证的一种方法是检查 *本地安全授权子系统服务（LSASS）* 进程的内存，该进程负责安全策略和身份验证。从本质上讲，它的进程 (*lsass.exe*)
    在其内存地址空间中包含敏感数据——即登录凭证和安全令牌。在现代版本的 Windows 中，这些敏感数据会被混淆（例如，通过哈希处理），但在特殊情况下，数据可能是明文的。通过检查
    *lsass.exe* 的进程内存，恶意软件可能能够定位并提取特权凭证和令牌，然后尝试重用它们来提升自身权限。
- en: There are some tools that can automate this process. One well-known example,
    Mimikatz ([*https://<wbr>github<wbr>.com<wbr>/gentilkiwi<wbr>/mimikatz*](https://github.com/gentilkiwi/mimikatz)),
    can extract credentials (and other sensitive data) from the victim system’s memory.
    Even though Mimikatz has existed since 2011, it is still actively updated and
    often used in real-world attacks. Some attack frameworks, such as Cobalt Strike,
    even have tools like Mimikatz built in.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以自动化这个过程。一个众所周知的例子是 Mimikatz（[*https://<wbr>github<wbr>.com<wbr>/gentilkiwi<wbr>/mimikatz*](https://github.com/gentilkiwi/mimikatz)），它可以从受害系统的内存中提取凭证（以及其他敏感数据）。尽管
    Mimikatz 自2011年就已存在，但它仍然在积极更新，并且常常在真实世界的攻击中使用。一些攻击框架，如 Cobalt Strike，甚至内置了像 Mimikatz
    这样的工具。
- en: Another method of credential extraction is *keylogging*, an effort to capture
    the victim’s keystrokes to obtain login credentials for various accounts and services.
    Keylogging is often implemented with different forms of hooking, as described
    in [Chapter 12](chapter12.xhtml).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种提取凭证的方法是 *键盘记录*，即通过捕获受害者的按键来获得各种账户和服务的登录凭证。键盘记录通常通过不同形式的钩子实现，如 [第12章](chapter12.xhtml)所述。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Exploiting Vulnerabilities
    for Privilege Elevation</samp>
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">利用漏洞提升特权</samp>
- en: Finally, some malware may attempt to exploit vulnerabilities in order to elevate
    its privileges. *Local privilege elevation* (*LPE*) vulnerabilities, which allow
    a malware to elevate its privileges on a system it already has lower-level access
    to, are especially popular among threat actors. One notable, relatively recent
    example of exploitation for privilege escalation is the CVE-2021-36934 vulnerability
    (see [*https://<wbr>cve<wbr>.mitre<wbr>.org*](https://cve.mitre.org)), nicknamed
    “HiveNightmare,” which affected Windows 10 and some versions of Windows 11\. HiveNightmare
    takes advantage of an access control issue in certain Windows directories. Inside
    these directories lie registry hives containing sensitive data, such as stored
    credentials, that’s not normally accessible to underprivileged users. However,
    by exploiting this vulnerability, an attacker could access backups of this sensitive
    data inside the Windows *Volume Shadow Copy Service (VSS)*, a Windows backup mechanism
    that stores copies of files and other data. In vulnerable versions of Windows,
    the attacker could craft a special payload that exploits this access control flaw,
    allowing the attacker to access unlocked copies of the sensitive registry hive
    data and use the stored credentials to elevate their privileges on the system.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些恶意软件可能会尝试利用漏洞来提升其权限。*本地权限提升*（*LPE*）漏洞允许恶意软件在已获得低权限访问的系统上提升其权限，这在威胁行为者中尤其受欢迎。一个较为近期的典型漏洞是CVE-2021-36934（见
    [*https://<wbr>cve<wbr>.mitre<wbr>.org*](https://cve.mitre.org)），被称为“HiveNightmare”，该漏洞影响了Windows
    10及某些版本的Windows 11。HiveNightmare利用了某些Windows目录中的访问控制问题。在这些目录内，存储着包含敏感数据的注册表配置单元，如存储的凭据，这些数据通常是非特权用户无法访问的。然而，通过利用这个漏洞，攻击者可以访问Windows
    *卷影复制服务（VSS）*中的这些敏感数据的备份，VSS是一个Windows备份机制，用于存储文件和其他数据的副本。在受影响版本的Windows中，攻击者可以制作一个特定的有效载荷，利用该访问控制缺陷，使攻击者能够访问解锁的敏感注册表配置单元数据副本，并利用存储的凭据提升其在系统上的权限。
- en: '[Figure 13-18](chapter13.xhtml#fig13-18) illustrates this exploit in action.
    (The exploit code can be obtained at [*https://<wbr>github<wbr>.com<wbr>/GossiTheDog<wbr>/HiveNightmare<wbr>*](https://github.com/GossiTheDog/HiveNightmare).)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-18](chapter13.xhtml#fig13-18)展示了这个漏洞攻击的实例。（漏洞代码可以在 [*https://<wbr>github<wbr>.com<wbr>/GossiTheDog<wbr>/HiveNightmare<wbr>*](https://github.com/GossiTheDog/HiveNightmare)
    获取。）'
- en: '![](../images/fig13-18.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-18.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-18: The HiveNightmare
    exploit in action</samp>'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-18：HiveNightmare漏洞攻击实例</samp>
- en: This exploit code dumps the extracted registry hive files into the current working
    directory. A quick directory listing reveals that the exploit was successful (see
    [Figure 13-19](chapter13.xhtml#fig13-19)).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞代码将提取的注册表配置单元文件转储到当前工作目录。通过快速列出目录内容，可以看到漏洞攻击已经成功（见 [图13-19](chapter13.xhtml#fig13-19)）。
- en: '![](../images/fig13-19.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-19.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-19: The HiveNightmare
    exploitation was successful!</samp>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-19：HiveNightmare漏洞攻击成功！</samp>
- en: This attack may not look like much from the captured screenshots, but it’s powerful.
    As a nonprivileged user, I was able to extract sensitive registry hives directly
    from VSS that otherwise would not be available to me; had I wanted to, I could
    have queried them for stored credentials that I could then have used to execute
    code at a high privilege level. This is just one example of a vulnerability (and
    also a good example of credential extraction), but numerous privilege elevation
    vulnerabilities have been released over the past five years; some are high profile,
    and some are actively being abused by malware in the wild. Unfortunately, there
    are likely more similar vulnerabilities that are still unknown to the public.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个攻击从捕获的截图来看可能并不起眼，但它非常强大。作为一个非特权用户，我能够直接从VSS中提取敏感的注册表配置单元，这些配置单元通常对我不可用；如果我愿意，我还可以查询它们，提取存储的凭据，然后利用这些凭据在更高权限级别执行代码。这只是一个漏洞的例子（也是一个凭据提取的好例子），但过去五年里，已经发布了许多特权提升漏洞；其中一些漏洞引起了广泛关注，还有一些正被恶意软件在实际环境中滥用。不幸的是，可能还有更多类似的漏洞目前尚未为公众所知。
- en: Now that we’ve looked at some ways in which malware might circumvent endpoint
    defenses, let’s shift our focus to how it could circumvent network defense controls.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看过了一些恶意软件可能绕过终端防御的方法，让我们将注意力转向它如何绕过网络防御控制。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Circumventing Network Defenses</samp>
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">绕过网络防御</samp>
- en: '*Network controls* are another layer of defense that malware must bypass in
    order to be successful. Circumventing network defenses relies on many of the tactics
    you’ve already seen in previous chapters. For example, malware can take advantage
    of obfuscation techniques such as encryption to conceal its C2 traffic. It can
    also leverage sandbox evasion techniques to circumvent network defenses that rely
    on sandboxing of suspicious files traversing the network. In this section, I’ll
    focus on circumvention techniques that haven’t yet been covered in the book. Before
    we start, however, I’ll briefly introduce some of the various network defenses
    available.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络控制*是恶意软件必须绕过的另一个防御层，才能成功实现其目的。绕过网络防御依赖于你在前几章中已经见过的许多战术。例如，恶意软件可以利用加密等混淆技术来掩盖其C2流量。它还可以利用沙箱规避技术，绕过依赖沙箱化可疑文件的网络防御。在本节中，我将重点介绍书中尚未涵盖的绕过技术。不过，在我们开始之前，我会简要介绍一些可用的各种网络防御措施。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Introducing Modern
    Network Defenses</samp>
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">引入现代网络防御</samp>
- en: 'As with host defenses, the network defense market is flooded with product names
    and acronyms. At a fundamental level, there are only a few different types of
    modern network defenses. The ones I’ll focus on in this chapter are NIDS, NDR,
    and email protection:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与主机防御类似，网络防御市场充斥着各种产品名称和缩写。从根本上说，现代网络防御只有几种不同的类型。我将在本章重点介绍NIDS、NDR和电子邮件保护：
- en: '**Network intrusion detection systems (NIDS)**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络入侵检测系统（NIDS）**'
- en: These products monitor incoming and outgoing network traffic, searching for
    signs of malicious activity. Much like anti-malware, NIDS can be signature based,
    anomaly based, or a combination of the two. Signature-based NIDS techniques search
    for suspicious signature patterns in network traffic such as sequences of data,
    code, or strings. Anomaly-based techniques look more into behavioral patterns
    of network traffic and may leverage machine learning techniques. NIDS can also
    be *intrusion prevention systems (IPS)*, which not only detect attacks but also
    respond to and prevent them. Both NIDS and IPS are often included in modern implementations
    of more traditional network defenses like firewalls.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些产品监控进出站的网络流量，寻找恶意活动的迹象。与反恶意软件类似，NIDS可以是基于签名的、基于异常的，或两者的结合。基于签名的NIDS技术会在网络流量中搜索可疑的签名模式，例如数据、代码或字符串的序列。基于异常的技术则更多地关注网络流量的行为模式，并可能利用机器学习技术。NIDS也可以是*入侵预防系统（IPS）*，不仅能检测攻击，还能响应并阻止攻击。NIDS和IPS通常包含在现代实施的传统网络防御中，如防火墙。
- en: '**Network detection and response (NDR)**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络检测与响应（NDR）**'
- en: This is the network equivalent of EDR. NDR is a more modern solution than NIDS
    and in some ways seeks to replace it. NDR uses real-time network traffic analysis
    to identify potential attacks, detect threats (such as malware) traversing the
    network, and be triggered by suspicious behaviors. The telemetry of NDR and host-based
    EDR can be combined to create extended detection and response (XDR), which allows
    analysts and investigators to track attacks across both the network and endpoint
    layers.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网络版的EDR。NDR比NIDS更现代，是在某些方面试图取代NIDS的解决方案。NDR通过实时的网络流量分析来识别潜在攻击，检测通过网络传播的威胁（例如恶意软件），并能因可疑行为而触发警报。NDR与基于主机的EDR的遥测数据可以结合，形成扩展检测与响应（XDR），使分析人员和调查员能够跨网络和端点层追踪攻击。
- en: '**Email protection technologies**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子邮件保护技术**'
- en: These solutions, which are becoming more widely used and necessary, sit at the
    email gateway of an organization and monitor and inspect inbound and outbound
    email traffic. This is a crucial control, as many inbound emails are laced with
    malicious attachments or URLs. Email protection suites scan and sandbox inbound
    and (sometimes) outbound emails, then raise alerts on (or simply delete) malicious
    ones. Since this technology partly relies on sandboxing, it can potentially be
    thwarted by the previously discussed anti-sandbox techniques.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案正在变得越来越广泛使用和必要，它们位于组织的电子邮件网关，监控和检查进出站的电子邮件流量。这是一个至关重要的控制措施，因为许多进入的电子邮件都携带恶意附件或URL。电子邮件保护套件扫描并沙箱化进站（有时也包括出站）邮件，然后对恶意邮件发出警报（或直接删除）。由于这项技术部分依赖于沙箱化，它可能会受到之前讨论的反沙箱技术的阻碍。
- en: Now we’ll start looking at the ways in which malware might try to circumvent
    these controls.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始探讨恶意软件可能尝试绕过这些控制措施的方式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Obfuscating and Obscuring
    Network Traffic</samp>
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">混淆和掩盖网络流量</samp>
- en: To bypass NIDS and NDR, modern malware must employ obfuscation or encryption
    techniques to mask its network traffic. Some malware may attempt to hide from
    network defenses while downloading additional payloads or modules using encrypted
    network protocols such as HTTPS, Secure File Transfer Protocol (SFTP), or Secure
    Shell (SSH). Malware has even been known to make use of the encrypted surveillance
    protection software Tor to obscure its network activities. The malware family
    Bashlite (also known as Gafgyt) has been observed using this technique when communicating
    with its C2 infrastructure. Keep in mind that the very act of using Tor and other
    lesser-used protocols and services can itself be a telltale sign of malicious
    activity. While this technique may indeed prevent network defenses and investigators
    from inspecting the suspicious traffic, it doesn’t mean the malware will go completely
    undetected.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过NIDS和NDR，现代恶意软件必须采用混淆或加密技术来掩盖其网络流量。有些恶意软件可能会尝试在下载附加负载或模块时，通过使用加密网络协议（如HTTPS、安全文件传输协议（SFTP）或安全外壳（SSH））来隐藏自己免受网络防御的监控。恶意软件甚至已经被发现利用加密的监控保护软件Tor来掩盖其网络活动。恶意软件家族Bashlite（也称为Gafgyt）在与其C2基础设施通信时曾使用过这种技术。请记住，使用Tor和其他不常用协议和服务的行为本身就可能成为恶意活动的迹象。尽管这种技术可能确实可以阻止网络防御和调查人员检查可疑的流量，但这并不意味着恶意软件会完全不被发现。
- en: Another example of this tactic is *DNS tunneling*, which abuses the Domain Name
    System (DNS) protocol to hide traffic such as file downloads, exfiltration of
    data from the network, or C2 communication. Since DNS is a fundamental protocol
    that the internet runs on, DNS tunneling may go completely unnoticed by network
    monitoring and defenses. [Figure 13-20](chapter13.xhtml#fig13-20) illustrates
    what DNS tunneling looks like.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略的另一个例子是*DNS隧道*，它利用域名系统（DNS）协议来隐藏流量，比如文件下载、数据从网络中泄漏或C2通信。由于DNS是互联网运行的基础协议，DNS隧道可能完全不会被网络监控和防御发现。[图13-20](chapter13.xhtml#fig13-20)展示了DNS隧道的表现形式。
- en: '![](../images/fig13-20.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-20.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-20: DNS tunneling</samp>'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-20：DNS隧道</samp>
- en: Let’s start with the infected host, which has a remote access trojan (RAT) hiding
    on it. This RAT communicates with its C2 server (*evil.com*) and requires special
    instructions that it will receive via DNS tunneling. It sends a DNS query to its
    C2 server (*36128.evil.com*). The *36128* subdomain is a randomized numerical
    string. Next, the DNS request is sent to a recursive DNS server, a local server
    that services DNS requests. This recursive DNS server may be an internet service
    provider (for home users and small businesses) or a server inside an organization
    that the host is part of.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从感染的主机开始，这台主机上隐藏着一个远程访问木马（RAT）。这个RAT与其C2服务器（*evil.com*）进行通信，并需要通过DNS隧道接收特定的指令。它向其C2服务器（*36128.evil.com*）发送一个DNS查询。*36128*子域是一个随机生成的数字字符串。接下来，DNS请求被发送到一个递归DNS服务器，这是一个提供DNS请求服务的本地服务器。这个递归DNS服务器可能是一个互联网服务提供商（适用于家庭用户和小型企业），或者是感染主机所在组织内部的服务器。
- en: Recursive DNS servers subsequently contact an *authoritative DNS server*, the
    source of authority for a domain. When a new website is provisioned from a hosting
    provider, the provider acts as the authoritative DNS server for that domain. Alternatively,
    anyone can establish their own authoritative DNS server for a domain name they
    have purchased. In this case, the RAT on the infected host is ultimately contacting
    the authoritative DNS server for the domain *evil.com*, and the malware author
    owns the authoritative DNS server for this domain.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 递归DNS服务器随后会联系一个*权威DNS服务器*，它是域名的权威源。当一个新网站从托管服务商处获得时，提供商会作为该域名的权威DNS服务器。或者，任何人都可以为他们购买的域名建立自己的权威DNS服务器。在这种情况下，感染主机上的RAT最终联系的是*evil.com*域名的权威DNS服务器，而恶意软件作者拥有该域名的权威DNS服务器。
- en: Once the C2 server receives the DNS request, it responds with a reply to the
    sender. In this case, however, the reply includes an encoded command, the simple
    string <samp class="SANS_TheSansMonoCd_W5Regular_11">execute</samp>. This command,
    which could be obfuscated with a simple algorithm such as Base64 or even encrypted,
    can be hidden away in one of the records inside a DNS response. Record types that
    are often abused for DNS tunneling are TXT, CNAME, Resource Records (RR), and
    NULL records. (These are outside the scope of this book and won’t be discussed
    further.)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦C2服务器收到DNS请求，它会向发送者返回响应。然而，在这种情况下，响应中包含了一个编码的命令——简单字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">execute</samp>。这个命令可以通过简单的算法（如Base64编码）或甚至加密进行混淆，可以隐藏在DNS响应中的某个记录里。常被滥用进行DNS隧道的记录类型包括TXT、CNAME、资源记录（RR）和NULL记录。（这些超出了本书的范围，不会进一步讨论。）
- en: Once the infected host receives the DNS response, the RAT decodes the embedded
    string and processes the command <samp class="SANS_TheSansMonoCd_W5Regular_11">execute</samp>.
    Presumably, this means the RAT will then execute a malicious command. DNS by default
    is not encrypted, but again, since it’s so widely used and may be difficult to
    fully monitor, this type of attack may slip past network defenses.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦感染的主机接收到DNS响应，RAT解码嵌入的字符串并处理命令<samp class="SANS_TheSansMonoCd_W5Regular_11">execute</samp>。可以推测，这意味着RAT将执行一个恶意命令。DNS默认情况下是不加密的，但由于它的广泛使用，而且可能难以完全监控，这种类型的攻击可能会避开网络防御系统。
- en: 'Malware has also been known to use custom C2 frameworks that employ novel methods
    of network communication. These frameworks may leverage publicly accessible services
    such as GitHub, Pastebin, Telegram, or even X to conceal traffic and commands.
    Not only is this traffic usually encrypted, but it also can go completely unnoticed
    since it appears normal. One example of this arose when researchers at ESET discovered
    that the threat group Turla abused Britney Spears’s Instagram account to conceal
    its C2 servers (see the article “Carbon Paper: Peering into Turla’s Second Stage
    Backdoor” at [*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2017<wbr>/03<wbr>/30<wbr>/carbon<wbr>-paper<wbr>-peering<wbr>-turlas<wbr>-second<wbr>-stage<wbr>-backdoor<wbr>/*](https://www.welivesecurity.com/2017/03/30/carbon-paper-peering-turlas-second-stage-backdoor/)).
    The Turla group pasted to Spears’s Instagram page encoded text representing a
    URL that contained the address of its C2 server. Malware on systems previously
    infected by the Turla group then monitored her Instagram profile for these specific
    patterns to retrieve the address information of the C2 servers. The address was
    then decoded by the malware and used to retrieve additional commands from the
    attacker’s infrastructure.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '恶意软件还已知使用自定义的C2框架，采用新颖的网络通信方式。这些框架可能利用公开访问的服务，如GitHub、Pastebin、Telegram，甚至X，来隐藏流量和命令。这些流量不仅通常是加密的，而且由于看起来正常，可能完全未被察觉。一个例子是，ESET的研究人员发现威胁组织Turla滥用了布兰妮·斯皮尔斯的Instagram账户来隐藏其C2服务器（参见文章“Carbon
    Paper: Peering into Turla’s Second Stage Backdoor”在[*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2017<wbr>/03<wbr>/30<wbr>/carbon<wbr>-paper<wbr>-peering<wbr>-turlas<wbr>-second<wbr>-stage<wbr>-backdoor<wbr>/*](https://www.welivesecurity.com/2017/03/30/carbon-paper-peering-turlas-second-stage-backdoor/)）。Turla组织将编码文本粘贴到斯皮尔斯的Instagram页面上，这些文本代表了一个包含其C2服务器地址的URL。之前被Turla组织感染的系统中的恶意软件会监控她的Instagram个人资料，寻找这些特定的模式来获取C2服务器的地址信息。然后，恶意软件解码该地址，并用它来从攻击者的基础设施中获取更多命令。'
- en: Attackers may also host their malware payloads on well-known file-sharing sites
    like Google Drive and Dropbox. Since these services are widely used for legitimate
    purposes, malware that’s downloading a payload or additional modules from Google
    Drive, for example, may look completely normal to a casual observer and to network
    defenses.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者也可能将其恶意软件载荷托管在知名的文件共享网站上，如Google Drive和Dropbox。由于这些服务广泛用于合法目的，恶意软件从Google
    Drive等站点下载载荷或附加模块时，可能对普通观察者和网络防御系统看起来完全正常。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Concealing Infrastructure
    Using Geofencing</samp>
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">通过地理围栏隐藏基础设施</samp>
- en: '*Geofencing* refers to the use of geographical locations as a factor that determines
    the malware’s behavior. In essence, the malware is designed to execute its payload
    only when the target host is located within a specific geographical boundary,
    such as a specific country. Geofencing can also be used to deter and prevent malware-scanning
    engines and analysts from identifying and investigating a malicious server. In
    the case of email protection solutions, for example, as malicious attachments
    are detonated in a sandbox, the sandbox may identify that the malware is attempting
    to communicate with an unknown domain on the internet. The sandbox may then try
    to “scan” or probe the server in an effort to identify its true nature and classify
    it as either legitimate or malicious.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*地理围栏*（Geofencing）指的是利用地理位置作为确定恶意软件行为的因素。实际上，恶意软件被设计为仅在目标主机位于特定地理边界内时才执行其有效负载，例如某个特定国家。地理围栏还可以用于阻止和防止恶意软件扫描引擎和分析人员识别和调查恶意服务器。例如，在电子邮件保护解决方案中，当恶意附件在沙箱中被引爆时，沙箱可能会识别出恶意软件正在尝试与互联网上的未知域名进行通信。沙箱随后可能会尝试“扫描”或探测该服务器，以试图识别其真实性质，并将其分类为合法或恶意。'
- en: 'Geofencing techniques can be used by a malicious server to prevent this behavior.
    By querying the location of the system or investigator probing its infrastructure,
    the server can hide itself from uninvited guests. A malware author in China, for
    example, may be specifically targeting victims in Germany. Any traffic to the
    malware’s C2 server not originating from an IP address in Germany can be blocked,
    preventing automated scanning engines or investigators without a German IP address
    from inspecting it more closely. Alternatively, the server could even display
    misleading information to systems not originating from Germany. For instance,
    any traffic from non-German IPs may be rerouted to a completely different, benign
    website. A similar technique was identified by researchers at Proofpoint, who
    revealed that the threat group TA547 leveraged geofencing to serve malware payloads
    to only certain targets (see the article “The First Step: Initial Access Leads
    to Ransomware” at [*https://<wbr>www<wbr>.proofpoint<wbr>.com<wbr>/us<wbr>/blog<wbr>/threat<wbr>-insight<wbr>/first<wbr>-step<wbr>-initial<wbr>-access<wbr>-leads<wbr>-ransomware*](https://www.proofpoint.com/us/blog/threat-insight/first-step-initial-access-leads-ransomware)).
    Payloads were hosted on servers, and only victims originating from specific countries
    were allowed to access and download the malware payloads.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意服务器可以使用地理围栏技术来防止这种行为。通过查询系统或调查员探测其基础设施的位置，服务器可以将自己隐藏起来，避免被不请自来的访客发现。例如，一位位于中国的恶意软件作者可能专门针对德国的受害者。任何不是来自德国IP地址的流量都可以被阻止，从而防止没有德国IP地址的自动扫描引擎或调查人员进一步检查它。或者，服务器甚至可以向非德国IP地址的系统显示误导性信息。例如，来自非德国IP的任何流量可能会被重定向到一个完全不同的、无害的网站。类似的技术被Proofpoint的研究人员发现，他们揭示了威胁团体TA547利用地理围栏技术仅向特定目标提供恶意软件有效负载（请参见文章“第一步：初步访问导致勒索软件”
    [*https://www.proofpoint.com/us/blog/threat-insight/first-step-initial-access-leads-ransomware*](https://www.proofpoint.com/us/blog/threat-insight/first-step-initial-access-leads-ransomware)）。有效负载被托管在服务器上，只有来自特定国家的受害者才能访问并下载恶意软件有效负载。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Generating New Infrastructure
    Using DGAs</samp>
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">使用DGA生成新基础设施</samp>
- en: One major problem that malware authors face is the fact that once a C2 server
    is identified by a sandbox, investigator, or defense software, it is effectively
    “burned,” meaning it will soon be blocklisted by most security products. This
    renders the malware that communicates with this server ineffective.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者面临的一个主要问题是，一旦C2服务器被沙箱、调查员或防御软件识别出来，它就会被“烧掉”，意味着它很快会被大多数安全产品列入黑名单。这使得与该服务器通信的恶意软件变得无效。
- en: Malware can get around this problem by dynamically generating new C2 server
    addresses using *domain generation algorithms (DGAs)*, which consist of client-
    and server-side components. The malware (the client, in this case) uses embedded
    DGA code to create new domain names. The malware’s C2 server uses the same algorithm
    to produce a new domain name identical to the one created by the malware client.
    DGA operates on the principle that both the client and server sides of the algorithm
    generate predictable domain names. This algorithm must generate the same domain
    name on both the client and server sides, but it must be unpredictable enough
    that security researchers and analysis tools can’t guess the next domain names
    that will be generated.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过动态生成新的C2服务器地址来绕过这个问题，这一过程使用*域名生成算法（DGA）*，该算法包含客户端和服务器端组件。在这个例子中，恶意软件（客户端）使用内嵌的DGA代码生成新的域名。恶意软件的C2服务器使用相同的算法生成与恶意软件客户端生成的域名相同的新域名。DGA的工作原理是，客户端和服务器端的算法都生成可预测的域名。该算法必须确保客户端和服务器端生成相同的域名，但同时必须足够不可预测，以至于安全研究人员和分析工具无法猜测将生成的下一个域名。
- en: '[Figure 13-21](chapter13.xhtml#fig13-21) illustrates how DGAs are used by malware.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-21](chapter13.xhtml#fig13-21)展示了恶意软件如何使用DGA。'
- en: '![](../images/fig13-21.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-21.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-21: How DGAs work</samp>'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-21：DGA的工作原理</samp>
- en: The malware first generates a new domain name using DGA code embedded in its
    executable file. After executing the algorithm, the malware produces the domain
    *evil-01.tk*, and on the malware’s C2 infrastructure, the same algorithm runs
    and also produces *evil-01.tk* ❶. Then the malware author provisions a new server
    with the address *evil-01.tk* ❷. The malware then connects to the C2 server using
    this domain name, which is now online ❸.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先通过其可执行文件中嵌入的DGA代码生成一个新的域名。执行算法后，恶意软件生成域名*evil-01.tk*，在恶意软件的C2基础设施上，同样的算法运行并生成相同的*evil-01.tk*
    ❶。然后，恶意软件作者配置一个新服务器，使用地址*evil-01.tk* ❷。接着，恶意软件使用这个现在已上线的域名连接到C2服务器 ❸。
- en: After a predetermined period of time, such as eight hours, the malware generates
    a new domain, *evil-02.cn* ❹. In turn, the server generates the same domain name,
    which is then provisioned ❺. Finally, the malware connects to it ❻. By this time,
    the first server (*evil-01.tk*) is likely offline. This cycle repeats until the
    algorithm runs out of available domains. This powerful DGA technique allows malware
    authors to generate hundreds or thousands of new domain names to use as C2 servers,
    making it a game of “whack-a-mole” for security products and investigators to
    identify and add these domains to a blocklist.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在预定的时间段后，例如八小时，恶意软件会生成一个新的域名，*evil-02.cn* ❹。接着，服务器生成相同的域名，并进行配置 ❺。最后，恶意软件连接到该域名
    ❻。此时，第一个服务器（*evil-01.tk*）可能已经下线。这个循环会不断重复，直到算法用尽可用的域名。这种强大的DGA技术使得恶意软件作者可以生成数百或数千个新的域名作为C2服务器，使得安全产品和调查人员在识别并将这些域名加入黑名单时，像玩“打地鼠”一样充满挑战。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Executing the Fast-Flux
    Technique</samp>
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">执行快速变换技术</samp>
- en: '*Fast flux* is a type of evasion technique used in large part by *botnets*,
    networks of infected systems that an attacker controls. As victims are infected
    by a particular malware variant, the infected hosts (the *bots*) are added to
    the botnet. Botnets are used by threat actors for various purposes, such as to
    send spam, conduct phishing and *distributed denial-of-service (DDoS)* attacks,
    and facilitate various types of fraud. The fast-flux technique allows threat actors
    to use their bots as proxies for concealing and protecting C2 servers and other
    infrastructure.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速变换*是一种主要由*僵尸网络*使用的规避技术，僵尸网络是由攻击者控制的感染系统网络。当受害者被某种特定的恶意软件变种感染时，感染的主机（即*机器人*）会被加入到僵尸网络中。攻击者利用僵尸网络进行各种目的，例如发送垃圾邮件、进行钓鱼和*分布式拒绝服务（DDoS）*攻击，以及实施各种类型的欺诈行为。快速变换技术使得攻击者能够利用其机器人作为代理，隐藏和保护C2服务器及其他基础设施。'
- en: To execute this technique, threat actors purchase a domain name and then rapidly
    change the IP address associated with the domain so that each time a victim visits
    it, they are directed to a different hosting IP address. This rapid changing of
    IP addresses is configured *round-robin* style, a legitimate technique for balancing
    client requests to a web server. By shortening the time-to-live (TTL) values of
    the IP addresses to several minutes or even less, the threat actor creates a more
    elusive infrastructure, making it more difficult for network defenses to identify
    and block malicious traffic, and for law enforcement and other investigators to
    identify its full infrastructure. [Figure 13-22](chapter13.xhtml#fig13-22) breaks
    down what fast flux looks like in practice.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这一技术，威胁行为者购买一个域名，然后迅速更改与该域名关联的 IP 地址，这样每次受害者访问时，他们会被引导到不同的托管 IP 地址。IP 地址的快速变化是采用*轮询*方式配置的，这是一种平衡客户端请求到
    Web 服务器的合法技术。通过将 IP 地址的生存时间（TTL）值缩短到几分钟甚至更少，威胁行为者创造了一个更加难以捉摸的基础设施，使得网络防御更难识别和阻止恶意流量，也使得执法机构和其他调查人员更难识别其完整的基础设施。[图
    13-22](chapter13.xhtml#fig13-22)展示了快速变换技术在实践中的表现。
- en: '![](../images/fig13-22.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-22.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-22: The fast-flux
    technique implemented in a botnet</samp>'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-22：在僵尸网络中实施的快速变换技术</samp>
- en: First, a victim executes malware on their computer, and the malware wants to
    make an HTTP connection to the threat actor’s domain, *evil.com*. Before this
    can happen, however, *evil.com* must be resolved to an IP address. The victim
    makes a DNS request ❶, and *evil.com* is resolved (by an authoritative DNS server
    that the malware author controls) to the IP address 59.111.180.193 ❷. Next, the
    malware makes an HTTP request to the IP address 59.111.180.193 ❸, which is part
    of a botnet and assigned to Bot 1\. Acting as a proxy, Bot 1 redirects the HTTP
    request to the threat actor’s malware delivery server ❹, which subsequently delivers
    the malware payload to the victim ❺.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，受害者在其计算机上执行恶意软件，恶意软件想要与威胁行为者的域名 *evil.com* 建立 HTTP 连接。然而，在此之前，*evil.com*
    必须解析为一个 IP 地址。受害者发起一个 DNS 请求 ❶，*evil.com* 被解析（通过恶意软件作者控制的权威 DNS 服务器）为 IP 地址 59.111.180.193
    ❷。接下来，恶意软件向 IP 地址 59.111.180.193 发起 HTTP 请求 ❸，该地址属于一个僵尸网络并分配给 Bot 1。作为代理，Bot 1
    将 HTTP 请求重定向到威胁行为者的恶意软件传输服务器 ❹，该服务器随后向受害者发送恶意软件负载 ❺。
- en: Minutes later, a new victim (infected with the same malware) makes a DNS and
    HTTP request for *evil.com*, just like the first victim. This time, however, the
    DNS server returns 97.66.36.178 as the IP (since the threat actor has already
    changed the IP address associated with this domain). This IP is mapped to Bot
    2, which similarly proxies and redirects the HTTP request to the malware staging
    server and delivers a payload to the second victim. Because the IP address changes
    very frequently and is spread across the botnet (which could be a spiderweb of
    many thousands of systems), it is difficult to pin down the attacker’s infrastructure
    in order to identify the other systems in the botnet and the attacker’s malware
    distribution and C2 servers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，一个新的受害者（感染了相同的恶意软件）像第一个受害者一样，向 *evil.com* 发起 DNS 和 HTTP 请求。然而，这一次，DNS 服务器返回了
    97.66.36.178 作为 IP 地址（因为威胁行为者已经更改了该域名关联的 IP 地址）。这个 IP 映射到 Bot 2，Bot 2 同样充当代理，将
    HTTP 请求重定向到恶意软件临时服务器，并向第二个受害者发送负载。由于 IP 地址变化非常频繁并且分布在僵尸网络中（这可能是由成千上万的系统组成的蜘蛛网），因此很难追踪攻击者的基础设施，以便识别僵尸网络中的其他系统以及攻击者的恶意软件分发和
    C2 服务器。
- en: Fast flux is not only used in botnets; it’s also used by *bulletproof hosters
    (BPHs)*, which are web hosting providers that cater to less scrupulous web activities
    such as online gambling and spam or illegal activities such as organized crime.
    Normally, BPHs are housed in countries where this type of activity is not heavily
    scrutinized (and so goes unnoticed or is otherwise tolerated) and requests for
    takedown of malicious infrastructure from law enforcement agencies are not honored.
    BPHs may offer fast-flux services to cybercrime groups and others.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 快速变换不仅仅用于僵尸网络；它还被*防御力强的主机商（BPHs）*使用，这些是专门为不太讲究的网络活动（如在线赌博和垃圾邮件）或非法活动（如有组织犯罪）提供服务的
    Web 主机提供商。通常，BPHs 位于那些这类活动不受到严格审查的国家（因此不会被注意到或被容忍），并且执法机构的恶意基础设施删除请求不被接受。BPHs
    可能为网络犯罪团伙和其他人提供快速变换服务。
- en: There’s a related technique, called *double fast flux*, where not only is the
    IP address of the malicious domain rapidly changed, but so is the IP address of
    the attacker’s authoritative DNS server(s). This adds an extra layer of defense
    and complexity for researchers and network defenses.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种相关技术，叫做*双重快速变更*，不仅恶意域名的IP地址会迅速变化，攻击者的授权DNS服务器的IP地址也会发生变化。这为研究人员和网络防御增加了额外的防护层和复杂性。
- en: Very few of the techniques we have discussed throughout this chapter are effective
    on their own. Modern malware-based attacks often use a combination of these techniques
    to infiltrate their targets, as you’ll see next.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论的技术很少能够单独有效。现代基于恶意软件的攻击通常会结合多种技术来渗透目标，接下来你将看到这一点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Multistage and Complex Attacks</samp>
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">多阶段和复杂攻击</samp>
- en: As mentioned earlier in this chapter, some modern defenses like EDR use a threat-scoring
    system or other analytical techniques to identify suspicious behaviors. In the
    early days of malware, it was common for malware to be delivered as a single malicious
    file. This file contained all the functionality required to infect the victim
    and take the further actions that the malware author intended. To successfully
    bypass modern endpoint and network defenses, however, malware authors must take
    a more complex, multistage approach. Crafting multistep, complex attack chains
    makes it more difficult for defenses to identify what’s occurring and take appropriate
    action. [Figure 13-23](chapter13.xhtml#fig13-23) illustrates such an attack.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面提到的，一些现代防御措施，如EDR，使用威胁评分系统或其他分析技术来识别可疑行为。在恶意软件的早期阶段，恶意软件通常以单个恶意文件的形式交付。这个文件包含了感染受害者所需的所有功能，并执行恶意软件作者计划的进一步动作。然而，要成功绕过现代的端点和网络防御，恶意软件作者必须采取更复杂的多阶段方法。精心设计的多步骤复杂攻击链使防御更难识别正在发生的事情并采取适当的行动。[图
    13-23](chapter13.xhtml#fig13-23)展示了这样的攻击。
- en: '![](../images/fig13-23.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-23.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-23: A complex, multistage
    attack</samp>'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-23：复杂的多阶段攻击</samp>
- en: First, the malware author delivers a malicious document file to the victim.
    Once opened, the file executes embedded JavaScript code, which in turn executes
    obfuscated PowerShell code. The PowerShell code contacts the attacker’s malware
    staging server to download a loader (*Loader.exe*), which is responsible for contacting
    another remote server to download the malware payload (*Payload.exe*).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，恶意软件作者将恶意文档文件交给受害者。一旦打开，文件执行嵌入的JavaScript代码，进而执行混淆的PowerShell代码。PowerShell代码联系攻击者的恶意软件暂存服务器下载一个加载程序（*Loader.exe*），该程序负责联系另一个远程服务器下载恶意软件负载（*Payload.exe*）。
- en: Tracing these disparate events is more challenging for defenses. Rather than
    evaluating the behaviors of a single executable file, an EDR’s event-tracing engine
    and analyzer will have to assess many different events from multiple sources before
    making a determination that this is malicious activity. To further complicate
    this attack, the malware author could spice it up with *sleep routines*. For example,
    the PowerShell command could wait two hours before downloading the loader executable,
    the loader could sleep for four hours before downloading the payload file, and
    then the payload could sleep for another eight hours before contacting its C2
    server. The event-tracing engine would then have to account for many hours of
    time variance between events.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪这些分散的事件对于防御来说更具挑战性。EDR的事件追踪引擎和分析器必须评估来自多个来源的许多不同事件，而不是仅评估单个可执行文件的行为，才能判断这是否是恶意活动。为了进一步复杂化这个攻击，恶意软件作者可能会通过*睡眠例程*来增加难度。例如，PowerShell命令可能在下载加载程序可执行文件之前等待两个小时，加载程序可能在下载负载文件之前等待四小时，然后负载文件可能在联系C2服务器之前等待另一个八小时。事件追踪引擎必须考虑事件之间多个小时的时间差异。
- en: 'From the attacker’s perspective, however, there’s a downside to these multistage
    attacks: if even one stage of the attack fails, the entire attack chain fails.
    For example, if anti-malware is able to detect and quarantine the initial malicious
    Office document, the rest of the attack chain will fail. The same will happen
    if network defenses are able to identify and block the connections to the attacker’s
    malware-staging servers. This is a gamble malware authors must take, however.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从攻击者的角度来看，这些多阶段攻击存在一个缺点：如果攻击的任何一个阶段失败，整个攻击链就会失败。例如，如果反恶意软件能够检测并隔离最初的恶意Office文档，那么攻击链的其余部分将会失败。如果网络防御能够识别并阻止与攻击者的恶意软件部署服务器的连接，也会发生同样的情况。然而，这是恶意软件作者必须冒的风险。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter discussed many of the common techniques malware uses to actively
    and passively circumvent host defense controls such as anti-malware and EDR, as
    well as network-based controls such as NIDS. We looked in detail at how malware
    can enumerate a victim host to identify host defenses and how it might actively
    thwart those defenses. We also covered how malware can elevate its privileges,
    enabling it to slip past defenses more discreetly. In the next chapter, you’ll
    learn about rootkits, a type of low-level malware that uses techniques that might
    be considered the ultimate form of defense evasion.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了恶意软件常用的多种技术，如何主动和被动地绕过主机防御控制，例如反恶意软件和EDR，以及基于网络的控制，如NIDS。我们详细分析了恶意软件如何枚举受害主机以识别主机防御，并如何主动破坏这些防御。我们还介绍了恶意软件如何提升其权限，使其能更隐秘地绕过防御。在下一章中，你将学习关于Rootkit的内容，这是一种低级别的恶意软件，它使用的技术可能被视为防御规避的终极形式。
