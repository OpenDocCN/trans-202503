- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVADING
    ENDPOINT AND NETWORK DEFENSES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">规避端点和网络防御</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: To successfully infiltrate and operate in its target environment, modern malware
    must survive that environment’s defenses. Many targets, especially those in an
    enterprise environment, are behind multiple defensive applications and products
    that work tirelessly to protect the systems and networks that make up the organization’s
    infrastructure. Malware can take active measures to evade these defenses (for
    example, by tampering with host defense applications) or take a passive approach
    to try to slip by them undetected.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功渗透并在目标环境中运行，现代恶意软件必须能够生存并突破该环境的防御。许多目标，特别是在企业环境中的目标，背后都有多个防御应用程序和产品，它们不知疲倦地工作，保护着构成组织基础设施的系统和网络。恶意软件可以采取主动措施来规避这些防御（例如，通过篡改主机防御应用程序），也可以采取被动方式试图悄无声息地绕过这些防御。
- en: In this chapter, I’ll outline different types of defenses that malware could
    encounter on victim hosts and networks, and then I’ll explain some techniques
    it might employ to get around those defenses. Defense evasion is a huge topic,
    so this chapter will focus primarily on the most common tactics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将概述恶意软件可能在受害主机和网络中遇到的不同防御类型，然后我会解释它可能采用的一些技术，以绕过这些防御。防御规避是一个庞大的话题，因此本章将主要关注最常见的战术。
- en: <samp class="SANS_Futura_Std_Bold_B_11">An Endpoint Defense Primer</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">端点防御基础</samp>
- en: The endpoint defense market is flooded with overloaded terms and fancy product
    names. It can be difficult to keep track of it all and understand at a fundamental
    level what each tool actually does. In this section, I’ll try to establish a common
    vocabulary for endpoint defense tools. First, though, we’ll go over a brief history
    of endpoint defenses to establish a baseline level of knowledge on which we can
    build.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 端点防御市场充斥着过载的术语和花哨的产品名称。要跟上这一切并从根本上理解每个工具的实际功能可能会很困难。在这一节中，我将尝试为端点防御工具建立一个通用词汇表。然而，首先我们将简要回顾端点防御的历史，为我们建立一个基础知识水平，进而进行更深的理解。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">A Brief History of
    Endpoint Defense Technology</samp>
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">端点防御技术简史</samp>
- en: Endpoint defense software goes back to the early days of malware, the 1970s
    and 1980s. At that time, endpoint defenses were appropriately called *antivirus
    (AV)* products, as most types of malicious software were widely known as *viruses*.
    In those early days, malware was relatively simple and AV software simply searched
    files for specific malicious patterns. Those AV programs were typically developed
    by hobbyists.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 端点防御软件可以追溯到恶意软件的早期，即1970年代和1980年代。当时，端点防御被恰当地称为*杀毒软件（AV）*产品，因为大多数类型的恶意软件普遍被称为*病毒*。在那些早期阶段，恶意软件相对简单，AV软件仅仅是通过搜索文件来查找特定的恶意模式。这些AV程序通常是由业余爱好者开发的。
- en: In the late 1980s and early 1990s, malware started to become more sophisticated,
    and commercial AV software companies (including Norton, Kaspersky, and McAfee)
    emerged to address the growing threat. The software these companies developed
    provided more advanced features than the hobbyist AV programs, such as real-time
    scanning, heuristics-based detection, and automatic signature updates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代末和1990年代初，恶意软件开始变得更加复杂，商业AV软件公司（包括诺顿、卡巴斯基和迈克菲）应运而生，解决日益严重的威胁。这些公司开发的软件比业余爱好者的AV程序提供了更多高级功能，如实时扫描、基于启发式的检测和自动签名更新。
- en: As malware authors were forced to adapt to technological advances, they created
    even more complex and covert malware capable of evading traditional AV software.
    In response, AV vendors started to develop much more robust software (which I’ll
    refer to as *anti-malware software* going forward), as well as products called
    *endpoint protection platforms (EPPs)*. EPPs are a more complete host protection
    solution that includes features not found in traditional anti-malware, such as
    built-in software firewalls and host intrusion prevention. More recently, *endpoint
    detection and response (EDR)* solutions have emerged as a more advanced endpoint
    security solution that provides real-time visibility into endpoint activity and
    enables security teams to quickly detect and respond to security threats.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着恶意软件作者被迫适应技术进步，他们创造了更加复杂和隐蔽的恶意软件，能够躲避传统的AV软件。作为回应，AV供应商开始开发更强大的软件（我将称之为*反恶意软件*），以及被称为*端点保护平台（EPP）*的产品。EPP是一种更完整的主机保护解决方案，包含了传统反恶意软件所没有的功能，例如内置软件防火墙和主机入侵防御。最近，*端点检测与响应（EDR）*解决方案作为一种更先进的端点安全解决方案出现，提供对端点活动的实时可视化，帮助安全团队快速检测和应对安全威胁。
- en: There’s a significant amount of overlap among host defense technologies. Many
    modern anti-malware products, for example, incorporate aspects of EPPs and even
    EDR solutions. EPPs include all of the functionalities of traditional and modern
    anti-malware and may overlap with some EDR solutions. EDR typically includes all
    of the functionalities of anti-malware and EPPs, as well as others. Thus, for
    the sake of simplicity, I’ll categorize endpoint defenses as either anti-malware
    or EDR in this book. Note, however, that each product vendor has its own “secret
    sauce,” so these categories are meant to reflect how the defenses work in general,
    not the specific details of how they operate in practice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 主机防御技术之间有相当大的重叠。例如，许多现代反恶意软件产品结合了EPP和甚至EDR解决方案的某些方面。EPP包括传统和现代反恶意软件的所有功能，并且可能与某些EDR解决方案有所重叠。EDR通常包括反恶意软件和EPP的所有功能，以及其他一些功能。因此，为了简化起见，我将在本书中将端点防御归类为反恶意软件或EDR。然而，请注意，每个产品供应商都有自己独特的“秘密配方”，因此这些类别旨在反映防御技术的工作原理，而不是它们在实践中的具体操作细节。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anti-malware</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">反恶意软件</samp>'
- en: Perhaps the most common and well-known host defense technology is *anti-malware*,
    or what was formerly called *antivirus*. It specializes in detecting and identifying
    malware threats on the system, both on the hard disk (before malware executes
    itself) and in memory (after the malware is running on the system). To accomplish
    this, anti-malware software uses a range of techniques, including hash-based and
    signature-based detection as well as heuristic and behavioral analysis.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最常见和最著名的主机防御技术是*反恶意软件*，或者以前被称为*杀毒软件*。它专门用于检测和识别系统上的恶意软件威胁，既包括硬盘上的恶意软件（在恶意软件执行之前），也包括内存中的恶意软件（在恶意软件已经在系统上运行之后）。为了实现这一点，反恶意软件使用一系列技术，包括基于哈希和基于特征的检测，以及启发式和行为分析。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hash-Based Detection</samp>
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于哈希的检测</samp>
- en: '*Hash-based detection* is a primitive method used in early anti-malware scanners,
    and it’s still used today to some extent. Anti-malware vendors maintain a database
    of file hashes known to be either benign or malicious. When a file is written
    to disk, the anti-malware software scans the file and compares its hash to the
    database. If the file is known to be benign, the anti-malware software leaves
    it alone. If the file is known to be malicious, the anti-malware software automatically
    removes it from the system and places it into a special quarantine where it can
    do no harm.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于哈希的检测*是一种早期反恶意软件扫描程序使用的原始方法，并且今天仍在一定程度上被使用。反恶意软件供应商维护一个已知为良性或恶意的文件哈希数据库。当文件写入磁盘时，反恶意软件会扫描该文件并将其哈希与数据库进行比较。如果该文件已知为良性，反恶意软件将不做任何处理。如果该文件已知为恶意，反恶意软件会自动将其从系统中移除，并将其放入一个特殊的隔离区，确保其不会造成任何危害。'
- en: The primary problem with this hash-based method is that the files must already
    be known to the anti-malware software. If the file is new and not in the database,
    the anti-malware can’t detect it (at least, not using hash analysis alone). According
    to a December 15, 2020, press release from Kaspersky, about 360,000 new malicious
    files were created every day that year. This obviously poses a problem for hash-based
    detection methods, since anti-malware software can’t possibly keep up.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于哈希值的方法的主要问题在于，文件必须已经被反恶意软件程序识别。如果文件是新的，并且不在数据库中，反恶意软件就无法检测到它（至少，单靠哈希分析无法检测）。根据卡巴斯基2020年12月15日的新闻稿，2020年每天约有36万个新的恶意文件被创建。这显然给基于哈希值的检测方法带来了问题，因为反恶意软件程序无法跟上如此庞大的文件量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Signature-Based Detection</samp>
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于特征的检测</samp>
- en: '*Signature-based detection*, an upgrade to the older hash-based detection methods,
    uses *signatures*, or known patterns, to identify malicious code in files or process
    memory. These patterns can be strings, byte sequences, metadata, or anything else
    that indicates that the file or memory segment could be related to malware. Anti-malware
    software maintains a large database of signatures, and when it identifies a match
    on one, it raises an alert and quarantines the respective file or terminates the
    suspect process. Signature-based detection functions similarly to the Yara rules
    discussed in [Chapter 2](chapter2.xhtml).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于特征的检测*，是对旧有哈希值检测方法的升级，使用*特征*或已知模式来识别文件或进程内存中的恶意代码。这些模式可以是字符串、字节序列、元数据或其他任何能表明文件或内存段可能与恶意软件相关的内容。反恶意软件程序会维护一个庞大的特征库，当它发现匹配时，便会发出警报并将相关文件隔离或终止可疑进程。基于特征的检测与在[第二章](chapter2.xhtml)中讨论的Yara规则类似。'
- en: Over time, malware authors have caught on to these detection techniques. For
    example, since signature-based detection is looking for malicious patterns, malware
    authors can simply encrypt or obfuscate their malware on disk or in memory to
    hide or change these patterns. Worse, they can generate countless variations of
    their malware so that, once again, the detection mechanisms can’t keep pace. It’s
    clear that anti-malware software has had to evolve.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，恶意软件作者已经意识到这些检测技术。例如，由于基于特征的检测是通过寻找恶意模式，恶意软件作者可以简单地加密或混淆他们的恶意软件，无论是在磁盘上还是在内存中，以隐藏或改变这些模式。更糟糕的是，他们可以生成无数种恶意软件的变种，以至于检测机制再也无法跟上其变化。显然，反恶意软件程序必须不断进化。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Heuristic-Based Detection</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于启发式的检测</samp>'
- en: Instead of matching file hashes or looking for specific patterns in a piece
    of software, *heuristic-based detection* looks at a file’s behavior. It does this
    by using a few different sub-techniques. First, it inspects the file for signs
    of malicious code. This goes beyond simple string and byte-sequence pattern matching,
    however; it’s looking for indicators such as suspicious blocks of assembly instructions
    or atypical uses of API calls. This process may also involve a weighting or scoring
    system. When the anti-malware software discovers a suspicious sequence of code,
    the file’s score increases. Once this score hits a predefined threshold, the anti-malware
    engine rates the file as malicious.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与其匹配文件哈希值或寻找软件中特定的模式，*基于启发式的检测*则关注文件的行为。它通过几种不同的子技术来实现这一目标。首先，它会检查文件是否有恶意代码的迹象。这个过程不仅仅是简单的字符串和字节序列模式匹配；它还会寻找一些指示，如可疑的汇编指令块或API调用的异常使用。这个过程还可能涉及加权或评分系统。当反恶意软件软件发现可疑的代码序列时，文件的分数会增加。一旦分数达到预定的阈值，反恶意软件引擎便会将文件判定为恶意文件。
- en: More modern heuristic-based methods can also employ file emulation techniques
    to better understand the file. *File emulation* involves executing the file in
    an *emulation engine*, which is a very lightweight virtual machine that can dynamically
    assess the file before it actually executes on the system. As CPU instructions
    are executed in the emulator, the anti-malware software monitors the file’s behaviors,
    and if any are suspicious or raise the file’s score high enough, the anti-malware
    takes further action.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更现代的基于启发式的方法还可以使用文件仿真技术来更好地理解文件。*文件仿真*涉及在*仿真引擎*中执行文件，这是一种非常轻量级的虚拟机，可以在文件真正执行之前动态地评估它。随着CPU指令在仿真器中执行，反恶意软件会监控文件的行为，如果有任何行为可疑或使文件的分数足够高，反恶意软件将采取进一步行动。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Cloud-Based Analysis Sandboxes</samp>
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于云的分析沙箱</samp>
- en: Running each file on a system through an emulation engine would be very taxing,
    so some modern anti-malware vendors instead use cloud-based analysis sandboxes.
    If a file is still unclassified even after it’s been subjected to hash-based,
    signature-based, and heuristic-based detection mechanisms, the file will be sent
    to the anti-malware vendor’s cloud environment for sandboxing and further analysis.
    *Cloud-based sandboxing* is a form of crowdsourced security in that all customers
    who use such anti-malware software will be notified if a particular file is malicious,
    even if they’ve never seen it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统上运行每个文件通过仿真引擎将非常繁重，因此一些现代反恶意软件供应商改为使用基于云的分析沙箱。如果一个文件在经历了基于哈希、基于特征码和基于启发式的检测机制后仍未分类，该文件将被发送到反恶意软件供应商的云环境中进行沙箱化和进一步分析。*基于云的沙箱化*是一种众包安全方式，使用这种反恶意软件的所有客户都会收到通知，如果某个文件被确认恶意，即使他们之前从未见过该文件。
- en: '[Figure 13-1](chapter13.xhtml#fig13-1) summarizes the detection mechanisms
    we’ve covered so far.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](chapter13.xhtml#fig13-1)总结了我们迄今为止讨论的检测机制。'
- en: '![](../images/fig13-1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: Typical detection
    mechanisms in anti-malware software</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-1：反恶意软件中的典型检测机制</samp>
- en: Note that many modern anti-malware solutions use a combination of some or all
    of these techniques.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，许多现代反恶意软件解决方案使用了上述一些或全部技术的组合。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Limitations and Challenges</samp>
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">局限性与挑战</samp>
- en: Even though anti-malware software has progressed and improved substantially
    over time, it still has some limitations. As a whole, it’s effective at identifying
    and eliminating threats from files that are known to be malicious; those that
    share similarities with files that are known to be malicious; and those that aren’t
    especially advanced, targeted, or bespoke. More advanced and specific threats
    can sneak past anti-malware software (as we’ll see later in this chapter).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管反恶意软件已经随着时间的推移取得了显著进步和改进，但它仍然存在一些局限性。总体而言，它能够有效地识别和消除已知恶意的文件、与已知恶意文件相似的文件，以及那些不特别先进、针对性不强或定制化不高的文件。然而，更多先进和特定的威胁可能会悄悄绕过反恶意软件（我们将在本章后面看到）。
- en: 'Another limitation of anti-malware software is that it must be mindful of system
    resources. Anti-malware software has a very difficult job: it must scan potentially
    thousands of files and memory regions at a time while keeping the lowest system
    resource footprint possible to avoid disrupting the end-user experience. This
    means that it can’t run every file through the emulation or sandboxing process;
    it must reserve those more time- and resource-intensive techniques for suspicious
    files that require deeper investigation.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 反恶意软件的另一个限制是必须考虑系统资源。反恶意软件面临着一项非常困难的任务：它必须同时扫描潜在的成千上万个文件和内存区域，同时保持尽可能低的系统资源占用，以避免干扰最终用户体验。这意味着它不能将每个文件都经过仿真或沙箱处理；它必须将这些更耗时和资源的技术保留给那些需要深入调查的可疑文件。
- en: Even among the files it deems malicious, anti-malware software must be selective.
    For example, anti-malware software has been known to flag critical system files
    as malicious, an action that cannot be tolerated. As a result, anti-malware products
    may lean toward giving a file a pass rather than flagging it as malicious.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在它认为是恶意的文件中，反恶意软件也必须具有选择性。例如，反恶意软件已知会将关键系统文件标记为恶意，这种行为是无法容忍的。因此，反恶意软件产品可能倾向于让文件通过而不是将其标记为恶意。
- en: One final limitation of anti-malware software is that while it’s intended to
    detect and eradicate threats on the endpoint, it wasn’t designed with post-compromise
    investigations or context in mind. Modern and advanced attacks often involve a
    number of steps in the attack chain that use multiple techniques and components,
    and anti-malware alone can leave blind spots, especially in complex corporate
    environments. This is where EDR comes into play.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 反恶意软件的一个最终限制是，虽然它旨在检测并消除端点的威胁，但它并不是为了事后入侵调查或上下文分析而设计的。现代和高级攻击通常涉及攻击链中的多个步骤，这些步骤使用了多种技术和组件，单靠反恶意软件可能会留下盲点，特别是在复杂的企业环境中。这时，EDR（端点检测与响应）就发挥了作用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Endpoint Detection
    and Response</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">端点检测与响应</samp>
- en: '*Endpoint detection and response (EDR)* solutions provide more advanced threat
    detection and response features than traditional anti-malware solutions provide.
    While anti-malware solutions are focused primarily on detecting and defending
    against known malware threats, EDR solutions are able to detect and act upon a
    broader range of advanced threats.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*端点检测与响应（EDR）*解决方案提供比传统反恶意软件解决方案更先进的威胁检测和响应功能。传统的反恶意软件解决方案主要集中在检测和防御已知的恶意软件威胁，而EDR解决方案能够检测并应对更广泛的高级威胁。'
- en: One of EDR’s primary benefits is its ability to establish context around an
    attack. It creates this context, often referred to as *telemetry*, by collecting
    data from multiple endpoints, enabling investigators to perform deeper analysis
    and to identify similar patterns of malicious activity across the enterprise.
    EDR can even help investigation teams identify the “patient zero” of an attack.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: EDR的主要优点之一是能够建立攻击的上下文。它通过收集来自多个端点的数据来创建这种上下文，通常被称为*遥测*，从而使调查人员能够进行更深入的分析，并识别整个企业中类似的恶意活动模式。EDR甚至可以帮助调查小组识别攻击的“零号病人”。
- en: Let’s take a quick look under the hood to see how EDR works. Typically, EDR
    consists of multiple components in both user space and kernel space, plus a log
    aggregator and analysis engine. We’ll start with the user-space components.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看EDR的工作原理。通常，EDR由多个组件组成，包括用户空间和内核空间的组件，以及日志聚合器和分析引擎。我们将从用户空间组件开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">User-Space Components</samp>
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">用户空间组件</samp>
- en: EDR solutions always have at least one executable running as a process in user
    space. This process, often called an *agent*, runs in a high-privilege context
    and monitors other processes on the host for suspicious behaviors, intervening
    when necessary. To do this, the EDR agent collects and analyzes system events,
    then forwards this information to a log aggregator, which we’ll discuss shortly.
    When a new process is created on the host, the EDR process can inject a hooking
    module into it using various methods such as the ones discussed in [Chapter 12](chapter12.xhtml).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: EDR解决方案始终至少有一个可执行文件作为用户空间中的进程运行。这个进程通常被称为*代理*，它以高权限上下文运行，并监视主机上其他进程的可疑行为，必要时进行干预。为了实现这一点，EDR代理收集并分析系统事件，然后将这些信息转发给日志聚合器，我们稍后会讨论。当主机上创建一个新进程时，EDR进程可以通过各种方法注入钩子模块到该进程中，方法包括在[第12章](chapter12.xhtml)中讨论的那些。
- en: '[Figure 13-2](chapter13.xhtml#fig13-2) illustrates malware being hooked by
    EDR.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-2](chapter13.xhtml#fig13-2) 展示了恶意软件被EDR钩住的过程。'
- en: '![](../images/fig13-2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: The EDR process
    using a module to hook malware</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-2：EDR过程使用模块钩住恶意软件</samp>
- en: The malware executable (*malware.exe*) is calling a WinAPI function residing
    in *kernel32.dll*, which subsequently invokes *ntdll.dll*. Instead of *ntdll.dll*
    making a syscall into kernel space (which is what would happen under normal circumstances),
    the installed EDR software is hooking *ntdll.dll* via a previously injected DLL
    (*edr_hook.dll*). This allows the EDR software to decide whether to permit the
    API call or to block or even terminate it. If the EDR software deems the API activity
    benign, it allows the API call to continue to the kernel as normal.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可执行文件（*malware.exe*）调用位于*kernel32.dll*中的WinAPI函数，进而调用*ntdll.dll*。与正常情况下*ntdll.dll*通过系统调用进入内核空间不同，已安装的EDR软件通过先前注入的DLL（*edr_hook.dll*）钩住*ntdll.dll*。这样，EDR软件就可以决定是否允许API调用，或者阻止甚至终止它。如果EDR软件认为该API活动无害，它将允许API调用正常地传递到内核。
- en: 'Some common functions that may be hooked by modern anti-malware and EDR software
    include the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现代反恶意软件和EDR软件可能会钩住的一些常见功能包括：
- en: Memory operations (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp>)
    that monitor memory commits and protection changes, such as when the EDR software
    wishes to know whether a region of memory is changed to *read-write-executable
    (RWX)*, indicating that there’s potentially code in this region about to be executed
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存操作（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp>）监视内存提交和保护变化，比如当EDR软件希望知道内存区域是否已更改为*可读写可执行（RWX）*时，表示该区域可能有代码即将被执行。
- en: Functions that create and terminate processes (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtTerminateProcess</samp>) so that
    the EDR software can watch over and hook into newly created processes
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和终止进程的函数（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcessEx</samp>，
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateUserProcess</samp>，和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtTerminateProcess</samp>），以便EDR软件可以监控和挂钩新创建的进程
- en: Functions that load libraries (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LdrLoadDll</samp>)
    so that the EDR software can monitor suspicious processes as they load new libraries
    and modules
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载库的函数（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">LdrLoadDll</samp>），以便EDR软件可以在加载新库和模块时监控可疑进程
- en: Functions commonly used for process injection (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThread</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>) so that
    the EDR software can monitor for code- and hook- injection attempts
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用于进程注入的函数（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess</samp>，
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThread</samp>， <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>，
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp>，和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>），以便EDR软件可以监控代码注入和挂钩注入尝试
- en: File writes (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteFile</samp>),
    which are often used by ransomware and other destructive malware
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件写入（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteFile</samp>），常被勒索软件和其他破坏性恶意软件使用
- en: Functions that attempt to create network connections, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpen</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnect</samp>, which
    EDR can monitor for suspicious network communication
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建网络连接的函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpen</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnect</samp>，这些函数可以被EDR监控以检测可疑的网络通信
- en: Hooking API function calls is only one way of monitoring the system. Some EDR
    products also collect system data using other sources, such as *Event Tracing
    for Windows (ETW)*, a mechanism designed for logging and diagnostics that’s been
    a part of Windows since 2007\. ETW is able to collect and log data from many sources,
    including user-space processes and kernel drivers, which makes it quite useful
    for EDR ingestion as well. You can read more about it in the Microsoft documentation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 挂钩API函数调用只是监控系统的一种方式。一些EDR产品还使用其他来源收集系统数据，例如*Windows事件追踪（ETW）*，这是一个用于日志记录和诊断的机制，自2007年以来就已成为Windows的一部分。ETW能够从多个来源收集和记录数据，包括用户空间进程和内核驱动程序，这使得它在EDR数据采集中也非常有用。你可以在微软文档中了解更多信息。
- en: To identify suspicious activity, EDR agents might rely upon a threat-scoring
    system. To illustrate this, consider the attack scenario shown in [Figure 13-3](chapter13.xhtml#fig13-3).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别可疑活动，EDR代理可能依赖于威胁评分系统。为了说明这一点，请参考[图13-3](chapter13.xhtml#fig13-3)中的攻击场景。
- en: '![](../images/fig13-3.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: A multistage attack</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-3：多阶段攻击</samp>
- en: First, the attacker sends a target user a specially crafted phishing email containing
    a malicious Microsoft Office document attachment. The Office document’s malicious
    code executes PowerShell to contact a staging server where the attacker’s malware
    payload (*ransomware.exe*) is hosted, then downloads and executes the payload
    in memory. The ransomware payload subsequently begins encrypting files on the
    victim’s hard disk.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，攻击者向目标用户发送一封精心制作的钓鱼电子邮件，附件包含一个恶意的Microsoft Office文档。Office文档中的恶意代码执行PowerShell来联系一个临时服务器，在那里攻击者的恶意软件载荷（*ransomware.exe*）被托管，然后在内存中下载并执行该载荷。之后，勒索软件载荷开始加密受害者硬盘上的文件。
- en: The EDR product assigns a score to each event that makes up this attack. Say
    it assigns a threat value of 35 to the Office document that launched a PowerShell
    command, a value of 20 to the connection to the suspicious server, and a value
    of 30 to the download and execution of an unknown executable file. If the maximum
    threat score is a hypothetical 100, and if any value over 75 is considered malicious,
    then this series of events totaling 85 would trigger the EDR solution to perform
    actions such as killing the Office and PowerShell processes or terminating the
    network connections to the remote server. The ransomware execution itself would
    likely have a high threat score, as ransomware creates multitudes of file write
    actions. Furthermore, metadata related to these events would be forwarded to a
    central log storage and processor, allowing the EDR product to analyze this attack
    in the context of the entire enterprise infrastructure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: EDR产品会为构成此次攻击的每个事件分配一个分数。例如，它为启动PowerShell命令的Office文档分配35的威胁值，为连接到可疑服务器的操作分配20的威胁值，为下载并执行未知可执行文件分配30的威胁值。如果假设最大威胁分数为100，并且任何超过75的值都被认为是恶意的，那么这个总计85的事件序列将触发EDR解决方案执行一些操作，比如终止Office和PowerShell进程，或断开与远程服务器的网络连接。勒索软件本身的执行可能会有很高的威胁评分，因为勒索软件会创建大量的文件写入操作。此外，与这些事件相关的元数据将被转发到一个中央日志存储和处理器，允许EDR产品在整个企业基础设施的上下文中分析这次攻击。
- en: 'Keep in mind that this threat-scoring system example is intentionally simplified
    and merely intended to demonstrate how EDR is better equipped than traditional
    endpoint defenses to “connect the dots” during an advanced attack. Let’s move
    on to another important part of EDR solutions: kernel-space components.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个威胁评分系统示例是故意简化的，旨在演示EDR如何比传统的端点防御更能在高级攻击中“串联”事件。接下来，我们将讨论EDR解决方案中的另一个重要部分：内核空间组件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Kernel-Space Components</samp>
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">内核空间组件</samp>
- en: In kernel space, EDR solutions primarily take the form of kernel drivers or
    modules, which are pieces of compiled code that execute in kernel address space.
    EDR kernel drivers rely on *callbacks*, functions registered by kernel components
    to receive notifications in response to specific events. To monitor the system
    for new processes, for example, the EDR kernel driver registers a callback routine
    by invoking the kernel function <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>.
    When a process is created or terminated, the EDR kernel driver will be notified
    so that it can respond to that event accordingly, likely by engaging its user-space
    component to inject hooks into the newly created process to begin monitoring.
    [Figure 13-4](chapter13.xhtml#fig13-4) illustrates how this works.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核空间，EDR解决方案主要以内核驱动程序或模块的形式存在，这些模块是执行在内核地址空间中的已编译代码。EDR内核驱动程序依赖于*回调*，即内核组件注册的函数，用于接收特定事件的通知。例如，为了监控系统中的新进程，EDR内核驱动程序通过调用内核函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>
    注册一个回调例程。当进程被创建或终止时，EDR内核驱动程序会收到通知，以便相应地作出响应，通常是通过调用其用户空间组件，将钩子注入新创建的进程中开始监控。[图
    13-4](chapter13.xhtml#fig13-4)展示了这一过程是如何工作的。
- en: '![](../images/fig13-4.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: EDR hook injection</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-4: EDR钩子注入</samp>'
- en: In this example, the EDR kernel driver is notified via <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>
    (not shown) that a new process, *malware.exe*, is being created ❶. The EDR driver
    instructs the EDR agent in user space (*edr_agent.exe*) ❷ to inject a hook into
    the new process ❸. Now *malware.exe* is being monitored by the EDR.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，EDR内核驱动程序通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSetCreateProcessNotifyRoutine</samp>（未显示）被通知到一个新的进程，*malware.exe*，正在被创建❶。EDR驱动程序指示用户空间中的EDR代理（*edr_agent.exe*）❷将钩子注入到新创建的进程中❸。现在，*malware.exe*
    正在被EDR监控。
- en: 'Here are a few other callbacks that EDR software might use, plus the circumstances
    in which they’re triggered:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些EDR软件可能使用的其他回调，以及触发它们的情况：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetCreateThreadNotifyRoutine </samp>This
    is triggered when any new thread is created or deleted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetCreateThreadNotifyRoutine</samp> 当创建或删除任何新线程时，都会触发该回调。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetLoadImageNotifyRoutine(Ex) </samp>This
    is triggered when a process loads an image (such as a DLL module) into memory,
    or when a new driver is loaded.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PsSetLoadImageNotifyRoutine(Ex) </samp>当进程将一个镜像（如DLL模块）加载到内存中，或者加载一个新驱动程序时，会触发该事件。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoWMISetNotificationCallback </samp>This
    is triggered by Windows Management Instrumentation (WMI) events.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoWMISetNotificationCallback </samp>此事件由Windows管理工具（WMI）事件触发。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CmRegisterCallback(Ex) </samp>This
    is triggered when any running thread modifies the Windows registry.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CmRegisterCallback(Ex) </samp>当任何正在运行的线程修改Windows注册表时，会触发该事件。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FsRtlRegisterFileSystemFilterCallbacks </samp>This
    is triggered when certain filesystem operations occur.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FsRtlRegisterFileSystemFilterCallbacks </samp>当某些文件系统操作发生时，会触发此事件。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoRegisterBootDriverCallback </samp>This
    is triggered when a new boot-start driver is initialized. Boot-start drivers start
    on system boot-up, so this callback can be used by anti-malware and EDR to detect
    rootkits and bootkits that use a boot-up driver (more on rootkits in [Chapter
    14](chapter14.xhtml)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoRegisterBootDriverCallback </samp>当一个新的启动驱动程序初始化时，会触发此事件。启动驱动程序在系统启动时启动，因此反恶意软件和EDR可以利用此回调检测使用启动驱动程序的根套件和启动套件（有关根套件的更多信息，请参见[第14章](chapter14.xhtml)）。
- en: EDR can also take advantage of minifilter drivers. *Minifilters* are used to
    monitor requests to the filesystem from user-space processes, so EDR can use them
    to intercept and block malicious filesystem actions that malware is trying to
    execute (for example, ransomware opening and writing to files at a rapid rate).
    Another reason EDR uses minifilters is to monitor and protect its own files from
    tampering or deletion. In the event that a malware sample is able to establish
    low-level privileges and attempt to remove or modify EDR components, the minifilter
    drivers will notify the EDR product about this activity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: EDR还可以利用迷你过滤驱动。*迷你过滤器*用于监视来自用户空间进程的文件系统请求，因此EDR可以使用它们来拦截和阻止恶意文件系统操作（例如勒索软件以极快的速度打开和写入文件）。EDR使用迷你过滤器的另一个原因是监视和保护其自身文件免受篡改或删除。如果恶意软件能够获得低级权限并尝试删除或修改EDR组件，迷你过滤驱动将会通知EDR产品此活动。
- en: Other kernel components that EDR may use are network filter drivers and *early-launch
    anti-malware (ELAM)* drivers. Network filter drivers can be used to monitor, intercept,
    and modify network communication, which can be useful in detecting anomalous network
    traffic such as command and control (C2) traffic. ELAM drivers load before the
    operating system boots and help protect against malware that could tamper with
    the boot process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: EDR可能使用的其他内核组件包括网络过滤驱动和*早期启动反恶意软件（ELAM）*驱动。网络过滤驱动可用于监视、拦截和修改网络通信，这对于检测异常网络流量（如命令与控制（C2）流量）非常有用。ELAM驱动在操作系统启动之前加载，有助于防止恶意软件篡改启动过程。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*You may have noticed that EDR injects modules into other processes, installs
    hooks to intercept API calls, and installs drivers into kernel space, which is
    eerily similar to malware! EDR does indeed look suspiciously similar to a variant
    of malware called rootkits. We’ll talk about rootkit techniques and components
    in more detail in [Chapter 14](chapter14.xhtml).*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能已经注意到，EDR将模块注入到其他进程中，安装钩子以拦截API调用，并将驱动程序安装到内核空间，这和恶意软件非常相似！EDR确实看起来和一种名为根套件的恶意软件变种非常相似。我们将在[第14章](chapter14.xhtml)中更详细地讨论根套件技术和组件。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Logging and Analysis</samp>
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">日志记录与分析</samp>
- en: I mentioned previously that one of the EDR agent’s responsibilities is to forward
    events and associated data to a central logging server, where they can be further
    analyzed and stored for future investigations. [Figure 13-5](chapter13.xhtml#fig13-5)
    illustrates this process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，EDR代理的一个职责是将事件及相关数据转发到中央日志服务器，在那里它们可以被进一步分析并存储以备将来调查。[图 13-5](chapter13.xhtml#fig13-5)展示了这一过程。
- en: '![](../images/fig13-5.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: An EDR agent gathering
    data from multiple endpoints for analysis</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-5：EDR代理收集来自多个端点的数据进行分析</samp>
- en: As you can see here, EDR agents running on disparate endpoints in the enterprise
    infrastructure forward data to the EDR log aggregator. Using various vendor-specific
    techniques, the data is processed and analyzed, enabling the EDR product to detect
    larger-scale attacks, for example. Using this telemetry, some EDR products can
    even “learn” what’s normal for this specific enterprise environment, helping them
    further differentiate between typical end-user behaviors and malicious activity.
    Many modern EDR solutions can also collect logs from many different sources to
    monitor an organization’s entire IT infrastructure. These EDR solutions are sometimes
    referred to as *extended detection and response* (*XDR)* platforms. XDRs are able
    to collect and analyze data from sources such as client endpoints, servers, network
    devices, applications, and cloud computing environments. For the remainder of
    this book, I’ll use the term *EDR* to also refer to XDR.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Even with all its benefits and capabilities, EDR can be (and sometimes is) bypassed
    by advanced malware. Now that you have a basic understanding of how EDR and anti-malware
    software work, let’s look at how malware can tamper with and circumvent these
    defenses. Advanced malware will often first attempt to understand the environment
    in which it is operating; this involves the malware scouting the target system
    and network and attempting to identify the endpoint defenses standing in its path.
    We’ll start there.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Identifying Endpoint Defenses</samp>
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since many anti-malware and EDR products behave and monitor the system a bit
    differently, an advanced attacker will conduct at least basic reconnaissance on
    the target prior to executing a malware payload. There are a number of techniques
    an attacker might employ to enumerate the target’s defenses. For example, the
    following PowerShell command will retrieve a list of installed anti-malware software
    on the host:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s some example output for this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On my system, Microsoft Defender was identified as the active anti-malware product.
    (This output uses the outdated name *Windows Defender*; the product has since
    been renamed Microsoft Defender.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Although this command will retrieve only anti-malware software that has registered
    itself within the Microsoft Security Center, most anti-malware vendors do this.
    A more robust solution is to enumerate artifacts on the host, searching for signs
    of endpoint defense products.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](chapter4.xhtml), we discussed how malware enumerates and lists
    processes running on the host for sandbox and VM detection. It can do the same
    for enumerating defenses. For example, it can call the Windows API functions <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp> to create
    a “snapshot” of all processes running on the victim host, then iterate through
    these processes using <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>. It can
    then search for suspect process names such as *MsMpEng.exe* (the default Windows
    10 and 11 anti-malware process), *AvastSvc.exe* (the executable process for the
    anti-malware product from Avast), or any process with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">falcon</samp>
    in its name (which could be related to the CrowdStrike Falcon EDR product) in
    order to determine what kinds of defenses are on the host.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most popular anti-malware and EDR vendors and products include
    the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'CrowdStrike Falcon EDR: *CSFalcon*.exe*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ESET Smart Security: *Ekrn.exe*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kaspersky: *Avp.exe*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Malwarebytes: *Mbam.exe*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'McAfee Endpoint Security: *masvc.exe*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sophos: *SavService.exe*'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Symantec Endpoint Protection: *ccSvcHst.exe*'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VMware Carbon Black: *cb.exe*'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Defender for Endpoint (formerly Windows Defender): *MsMpEng.exe*'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These processes often have associated services, which are named similarly and
    can be enumerated by malware. Also keep in mind that the list is not exhaustive
    and is subject to change between software versions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, scanning the host for anti-malware and EDR-related files, drivers,
    and registry keys can be effective. [Figure 13-6](chapter13.xhtml#fig13-6) shows
    the Procmon output of a malware sample that queries the registry for keys that
    match common anti-malware vendors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-6.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: Malware querying
    the registry for names of anti-malware and EDR products</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the anti-malware product from Kaspersky, for example, installs itself
    to a directory such as *C:\Program Files (x86)\Kaspersky Lab\Kaspersky Total Security*
    and installs several drivers on the host that are visible in the *C:\System32\drivers*
    directory, which could alert malware to its presence (see [Figure 13-7](chapter13.xhtml#fig13-7)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-7.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-7: Kaspersky’s installed
    drivers</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of research projects, such as at [*https://<wbr>github<wbr>.com<wbr>/ethereal<wbr>-vx<wbr>/Antivirus<wbr>-Artifacts*](https://github.com/ethereal-vx/Antivirus-Artifacts),
    that catalog the different artifacts that endpoint defense products create on
    the host. These resources can be useful to both malware researchers and malware
    authors.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Finally, malware already running on the host may attempt to look for signs that
    it is being hooked by anti-malware or EDR. For instance, the malware might enumerate
    its loaded modules using <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> (as described
    in [Chapter 7](chapter7.xhtml)) or search its process memory for signs of hooking,
    as it does to circumvent sandbox hooking (described in [Chapter 8](chapter8.xhtml)).
    These hooks may reveal a specific defense product.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Once an endpoint security product has been detected and identified, the malware
    can take one of several active or passive approaches to circumvent it. First,
    we’ll discuss some active measures.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Actively Circumventing Endpoint Defenses</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Active circumvention* is directly bypassing defenses by disabling them completely,
    modifying policies to weaken them, or tampering with them to blind them. There
    are many ways to accomplish this, so let’s look at some examples.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Disabling Host Defenses</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A crude but effective method for malware to evade and bypass endpoint security
    is simply to disable it. After enumerating the security products running on the
    endpoint, malware can disable them in several ways. First, it can attempt to kill
    the application’s processes (examples include anti-malware and EDR-related processes,
    Windows Security Center processes and services, and any firewall products such
    as the Windows built-in host firewall) by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>
    function or invoking tools such as PowerShell or the Windows command line.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Some anti-malware solutions store parts of their configurations in the registry;
    tampering with these can also produce unwanted results. The malware family KillAV
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 659ce17fd9d4c6aad952bc5c0ae93a748178e53f8d60e45ba1d0c15632fd3e3f</samp>),
    which specializes in doing what its name suggests, attempts to disable the default
    Windows anti-malware and threat protection services by stopping processes and
    tampering with the registry. Here are some of the commands that this malware executes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">net stop WinDefend</samp>
    command terminates the Microsoft Defender process, while the various <samp class="SANS_TheSansMonoCd_W5Regular_11">REG
    ADD</samp> commands tamper with the registry to switch off the Microsoft Defender
    real-time monitoring service, the AntiSpyware service, and the AV boot driver
    (WdBoot), all of which are critical components of the Windows default anti-malware
    services.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Some malware simply attempts to uninstall defense software from the host, using
    PowerShell commands like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first PowerShell command leverages WMI to enumerate installed software on
    the host, looking specifically for ESET anti-malware software; the second command
    uninstalls it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'A possibly less noisy approach is lowering an endpoint defense process’s *priority*:
    that is, reducing how important the process is to the operating system. Higher-priority
    processes (typically, critical processes such as system processes) are allotted
    more CPU time. By lowering an endpoint defense process’s priority using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetPriorityClass</samp>, the malware can
    diminish its effectiveness. The following pseudocode demonstrates this approach:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is a catch with these techniques, however: depending on the operating
    environment, the malware may require high-level privileges to terminate anti-malware
    processes and services, tamper with registry configurations and process priorities,
    and uninstall software. In this case, the malware must elevate its privileges
    before trying to disable endpoint defenses. We’ll look at how it does so in the
    “Privilege Elevation for Defense Evasion” section on [page 248](chapter13.xhtml#pg_248).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Adding Anti-malware
    Exclusions</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to impair defenses is by tampering with the anti-malware exclusion
    list. Anti-malware software regularly scans specific filesystem directories on
    the endpoint, which are determined by how the user or organization configures
    the software. Most anti-malware software allows users to add exclusions, in the
    form of directory paths, to its configuration settings. Any files or directories
    in this exclusion list won’t be monitored or scanned.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'To employ this technique, an initial dropper or loader malware creates an exclusion
    on the victim host, and once that exclusion is enabled, it deploys the payload
    into the excluded directory. Here’s how malware could use PowerShell to create
    an exclusion in the Microsoft Defender anti-malware solution:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command adds an anti-malware exclusion for the path *C:\Malware\DoNotScanThisDirectory\*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Note that the malware must have high-level privileges on the victim host to
    create exclusions in later versions of Windows, making the barrier to entry for
    this kind of attack more difficult than in older versions of the operating system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Disabling Other Security
    Controls</samp>
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to disabling anti-malware, EDR, and other defenses, malware can
    disable other security features of the system. While such security features may
    not directly prevent attacks, disabling them can degrade the overall security
    of the host, making it more susceptible to further attacks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, malware may disable the Windows Update service, which is responsible
    for periodically updating Windows to patch bugs and vulnerabilities. If a threat
    actor disabled this service under the radar, it could ultimately degrade the overall
    security of the host over a longer period of time, leaving the system open to
    follow-up attacks. To disable a service with PowerShell, the malware could execute
    the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The malware could also disable PowerShell security. Some Windows environments
    prohibit the execution of unauthorized PowerShell scripts, so switching off script
    execution controls could help an attacker execute PowerShell scripts they otherwise
    couldn’t. To enable PowerShell script execution, an attacker can issue the following
    command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To prevent unauthorized outbound traffic from an endpoint, it’s common to configure
    a host-based firewall solution. Host-based firewalls can be used to allow outbound
    traffic from specific processes, such as web browsers, while preventing outbound
    traffic from processes that shouldn’t be communicating with any other hosts on
    the network or the internet. To get around this limitation, an attacker can directly
    modify firewall configurations on the host. This configuration differs depending
    on the firewall software being used, but for the standard Windows firewall, a
    rule can be added or modified with PowerShell. For example, malware could use
    the following command to change the default firewall policy to permit all outbound
    traffic from all processes on the host:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Malware can also disable non-security-related tools that could be used to expose
    it. Examples include terminating and disabling the Windows Task Manager to prevent
    cautious users from spotting suspicious running processes or disabling the Registry
    Editor to prevent a knowledgeable system administrator from identifying malicious
    artifacts in the registry.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: There are many policies and configurations on a Windows system that an attacker
    could alter to degrade security; these are just a few examples. The key takeaway
    is that a threat actor may not attempt to completely disable endpoint defenses
    like anti-malware and EDR but may instead go for a less direct approach, making
    slight tweaks to the system to achieve its goals. This is a double-edged sword,
    however; the more the malware alters a system, the higher the chances it will
    be detected.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Blinding Defenses
    by Unhooking</samp>
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since EDR and modern anti-malware heavily rely on hooks to monitor suspicious
    processes and detect and prevent threats, unhooking techniques can create blind
    spots for them. The unhooking approaches outlined in the “Anti-hooking” section
    on [page 137](chapter8.xhtml#pg_137) can be effective for some EDR and anti-malware
    software, but advanced host defenses are expecting them. These defenses may monitor
    their own hooks at the kernel level using their installed kernel components, and
    malware in turn could tamper with and unhook endpoint defenses at the kernel level.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The cat-and-mouse game that malware authors and host defenses play is evident
    here. Endpoint protection software monitors and hooks into malware. The malware
    scans for these hooks and unhooks them or tries to circumvent them in other ways.
    In response, the endpoint protection products check whether they’ve been unhooked,
    and the cycle continues. Endpoint defenses have some advantage here, however.
    If a program tries to remove hooks, the EDR or anti-malware software can assume
    that the process is malicious with some level of confidence, as there’s virtually
    no legitimate reason for unhooking.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, endpoint defenses might use other sources
    of system monitoring, such as ETW, to supplement traditional hook-based monitoring.
    These data sources could also be blinded in various ways; in fact, there’s already
    a considerable amount of research on blinding ETW. This can be accomplished in
    multiple ways, one of which is to hook or patch <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwEventWrite</samp>,
    a function critical to ETW’s operation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Exploiting Vulnerabilities
    in Host Defense Tooling</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Anti-malware, EDR, and other defenses are developed by humans, and humans make
    mistakes, so inevitably there will be bugs in the product code that could lead
    to vulnerabilities threat actors can exploit. There haven’t been many publicly
    reported attempts to exploit defense tooling during attacks, but it’s always a
    possibility, especially for threat actors that have the means and ability to discover
    these bugs. A quick search in the MITRE CVE vulnerability database ([*https://<wbr>cve<wbr>.mitre<wbr>.org*](https://cve.mitre.org))
    reveals some public vulnerabilities in anti-malware products, as shown in [Figure
    13-8](chapter13.xhtml#fig13-8).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-8.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-8: Vulnerabilities
    in anti-malware products, as reported by MITRE</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: This list includes vulnerabilities discovered in the anti-malware engines of
    Watchdog, Kaspersky, and F-Secure products. Most of the vulnerabilities listed
    are *denial-of-service (DoS)* bugs that could allow specially crafted code to
    crash the anti-malware engine or otherwise hamper its effectiveness.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: That sums up our tour of active circumvention techniques. Now we’ll turn to
    passive circumvention, which can be a stealthier and equally effective approach.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Passively Circumventing Endpoint Defenses</samp>
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Passive circumvention techniques involve slipping past host defenses without
    directly tampering with them. As you’ll see, these methods can be just as fruitful
    as active techniques without raising as many alarms.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Circumventing Monitoring</samp>
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Chapter 8](chapter8.xhtml) discussed how malware can circumvent API hooking
    and monitoring in an attempt to evade sandboxes. Malware can use similar techniques
    to circumvent endpoint defenses. Because endpoint defenses also rely on function
    hooking to intercept and monitor suspicious activities, circumventing and bypassing
    these hooks is often an effective way to blind them.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Since anti-malware and EDR monitor various Windows API calls to detect malicious
    activities, one circumvention measure is to implement *direct syscalls*, or calls
    into kernel address space from user mode that circumvent the typical syscall procedure.
    Specifically, when a program invokes an API function in user mode, the operating
    system makes a syscall into *ntosknrl.exe* to access the function’s code (see
    [Figure 13-9](chapter13.xhtml#fig13-9)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-9.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-9: Normal syscall
    behavior</samp>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Instead of relying on the normal Windows and NT API calling process, though,
    malware can directly make the syscall (see [Figure 13-10](chapter13.xhtml#fig13-10)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-10.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-10: A direct syscall</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Syscalls follow a basic pattern called a *syscall stub.* The purpose of the
    stub is to transfer execution flow from user mode to kernel mode, where the code
    of the function being invoked actually resides. The following code shows a syscall
    stub for the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The most important part of the stub is the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    eax, 18</samp> line, in which <samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp>
    represents the *system service number (SSN)*, sometimes referred to as the *syscall
    number* or *syscall ID*. This number maps to the function code (in this case,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>)
    that will be called in kernel mode. The next most important part of the stub is
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">syscall</samp> instruction (in
    hex, <samp class="SANS_TheSansMonoCd_W5Regular_11">0F 05</samp>), which uses the
    SSN in the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register to
    direct execution flow to the corresponding kernel function. The return (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>) instruction transfers execution
    flow back to the main program code once the syscall returns and has completed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The syscall stubs we’ve discussed thus far are specific to the x64 architecture.
    The x86 programs often use a different call:* sysenter*. Sysenter stubs are very
    similar:*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: mov edx, esp
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sysenter
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ret
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mov edx, esp</samp>
    instruction moves the SSN (stored in <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ESP</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EDX</samp> and passes
    it to the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sysenter</samp>
    instruction (hex <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">0F</samp>*
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">34</samp>*). Note that
    some x64 programs also use sysenter calls.*'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If malware wants to make a direct syscall (to avoid EDR or anti-malware hooks),
    it just needs to know the SSN of the function to call and then directly invoke
    the syscall. Sounds simple enough, but there are a few hurdles malware authors
    may face; most notably, function SSNs change depending on the Windows version
    and patch level of the target host. To get around this problem, malware authors
    have a few options. One option is to extract the SSNs from the *ntdll.dll* loaded
    in memory (see [Figure 13-11](chapter13.xhtml#fig13-11)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-11.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-11: Syscall stubs
    in the loaded</samp> <samp class="SANS_Futura_Std_Book_11">ntdll.dll</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">module</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-11](chapter13.xhtml#fig13-11) illustrates what *ntdll.dll* syscall
    stubs look like loaded in memory. Notice the highlighted SSNs for some of the
    exported *ntdll.dll* functions. Malware can inspect its loaded modules in memory,
    locate the relevant syscall stubs, and identify the SSN it requires. Once it obtains
    the SSN for the function it wants to call, it can craft its own syscall stubs,
    bypassing the standard syscall invocation from *ntdll.dll*. The following code
    illustrates the use of syscalls (more accurately, sysenters) in a variant of Remcos
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 45cd8dd797af4fd769eef00243134c46c38bd9e65e15d7bd2e9b834d5e8b3095</samp>):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This Remcos sample resolves the SSNs of the functions it wishes to call by enumerating
    the *ntdll.dll* file on disk (not shown here). It subsequently calls a function
    that contains the standard sysenter stub. Specifically, this Remcos sample is
    attempting to covertly inject code into another process by making direct sysenter
    calls to invoke the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp>, and others.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: One problem with this approach is that these syscalls aren’t originating from
    their intended module, *ntdll.dll*. This can be a dead giveaway for endpoint defenses
    looking for this type of anomaly. A stealthier option, sometimes called an *indirect*
    syscall, is for malware authors to simply reuse the syscalls in *ntdll.dll* rather
    than crafting their own syscall stubs. To accomplish this, the malware identifies
    the syscall stub address in *ntdll.dll* for the function it wishes to call. Then,
    rather than including a call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>
    function, for example, the malware implements a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    instruction to jump directly to that syscall stub inside *ntdll.dll*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few of the tricks malware authors might use to bypass hooks
    installed by endpoint defenses. However, these techniques are not foolproof. As
    you’ve seen, many can produce suspicious indicators (enumerating *ntdll.dll* memory,
    invoking syscalls directly from the malware’s code, making direct jumps into *ntdll.dll*,
    and so on). Not only that, but also many modern endpoint defenses hook into the
    kernel to attempt to spot this sort of activity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Evasion using syscall invocation is a fascinating topic, so if you’re interested
    in learning more, I recommend the following references:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Usman Sikander, “AV/EDR Evasion Using Direct System Calls (User-Mode vs. Kernel-Mode),”
    *Medium*, March 11, 2022, [*https://<wbr>medium<wbr>.com<wbr>/@merasor07<wbr>/av<wbr>-edr<wbr>-evasion<wbr>-using<wbr>-direct<wbr>-system<wbr>-calls<wbr>-user<wbr>-mode<wbr>-vs<wbr>-kernel<wbr>-mode<wbr>-fad2fdfed01a*](https://medium.com/@merasor07/av-edr-evasion-using-direct-system-calls-user-mode-vs-kernel-mode-fad2fdfed01a).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cornelis, “Red Team Tactics: Combining Direct System Calls and sRDI to bypass
    AV/EDR,” *Outflank*, June 19, 2019, [*https://<wbr>www<wbr>.outflank<wbr>.nl<wbr>/blog<wbr>/2019<wbr>/06<wbr>/19<wbr>/red<wbr>-team<wbr>-tactics<wbr>-combining<wbr>-direct<wbr>-system<wbr>-calls<wbr>-and<wbr>-srdi<wbr>-to<wbr>-bypass<wbr>-av<wbr>-edr<wbr>/*](https://www.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Team Notes, “Calling Syscalls Directly from Visual Studio to Bypass AVs/EDRs,”
    *Red Team Notes*, n.d., [*https://<wbr>www<wbr>.ired<wbr>.team<wbr>/offensive<wbr>-security<wbr>/defense<wbr>-evasion<wbr>/using<wbr>-syscalls<wbr>-directly<wbr>-from<wbr>-visual<wbr>-studio<wbr>-to<wbr>-bypass<wbr>-avs<wbr>-edrs*](https://www.ired.team/offensive-security/defense-evasion/using-syscalls-directly-from-visual-studio-to-bypass-avs-edrs).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Circumventing Signature-Based
    Detection</samp>
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we’ve discussed, anti-malware uses signature-based detection mechanisms,
    meaning that it looks for common patterns to identify malicious code in files
    and in memory. Malware often contains strings, function names, or DLL and module
    names that are hardcoded in its executable or that reside in memory and can be
    used to expose it. Thus, simply modifying these strings, functions, and module
    names can often lead to lower rates of detection, at least by more traditional
    anti-malware solutions. This is one of the most basic ways to abuse signature-based
    anti-malware detections, but modern malware requires more sophisticated evasion
    techniques to deal with more sophisticated anti-malware solutions. This is where
    mutation comes in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*Mutation* is malware’s ability to change its features and code in order to
    evade detection or adapt to its environment. With mutation, the malware’s goal
    is to change its code just enough to fly under the radar while retaining its basic
    functionalities. To help you better understand mutation, let’s look at the life
    cycle of a typical malware sample.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Some malware authors, notably cybercrime groups, “spam” malware to hundreds
    or thousands of potential victims, expecting to trick a few unsuspecting people
    into executing it. Once enough victims have been infected by a strain of malware,
    investigators will inevitably get their hands on the sample and develop detection
    rules for it, which will then be implemented in anti-malware engines and other
    defense technologies. This can quickly reduce the lifespan of any given piece
    of malware. This doesn’t apply just to mass spam malware, however; it can also
    be true of more targeted malware. If the malware is able to mutate on the victim
    host, it may be able to similarly evade detection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different forms of mutation, such as *code block reordering*, in
    which code is shifted around and reordered to create new “variants” of the malware,
    and *register reassignment*, in which CPU registers are changed (for example,
    all ECX register references are changed to EDX). These mutations of the malware’s
    code, implemented by a *mutation engine*, can significantly change the code’s
    structure and signature. The following is a very simple example of a mutation
    that shows how assembly code may be functionally identical but appears different:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example code block simply sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    register to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and then sets
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Compare this to the following
    code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code also sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (but using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> instruction rather than the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction) and then
    sets <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    (using the <samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp> instruction
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>). If this
    were actual malicious code, anti-malware software might have a detection signature
    for one of these code blocks, but perhaps not the other. In the real world, of
    course, this code would be a lot more complex.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Mutation can occur either dynamically during runtime or on the malware file
    itself. Mutation during runtime occurs once the malware executes on the victim
    system. The malware may dynamically alter its code in memory to evade defenses
    that scan for malicious code patterns in memory. Mutation on the malware file
    itself occurs before the malware is delivered to the victim. The malware author
    may run their code through a mutation engine that spits out unique variants of
    the same malware that can all be delivered to different victims. Packers, which
    I’ll discuss in detail in [Chapter 17](chapter17.xhtml), can be a form of both
    runtime and static file mutation. When malware is run through a packing engine,
    it is obfuscated so that it will appear unique to all other variants of the same
    malware family.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The virus-like ransomware malware family Virlock provides a good example of
    mutation. When Virlock (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:
    7a92e23a6842cb51c9959892b83aa3be633d56ff50994e251b4fe82be1f2354c</samp>) executes
    on a victim system, it decrypts three instances of itself in memory and drops
    them to the disk as files. All three instances differ from all other Virlock malware
    samples and have a different signature. This ensures the malware will remain undetected,
    at least by anti-malware engines that rely on hashes and basic file signatures
    for detection.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Uncommon Programming
    Languages</samp>
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In an attempt to circumvent endpoint defenses, malware authors may use obscure
    or uncommon programming languages to develop their malware. Anti-malware software
    may be unfamiliar with the code and data structure in these languages, and it
    takes time for its signature and heuristic detections to catch up. Uncommon or
    new programming languages can also create a challenge for malware analysts and
    reverse engineers who are expecting more typical malware code, such as C or C++.
    Furthermore, many of these uncommon languages can be used across different operating
    systems. For instance, a program written for Windows can also run on macOS or
    Linux as long as the victim system has the required libraries installed. This
    can make the malware more resilient to different operating systems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Using uncommon languages isn’t a new technique. Early malware was often written
    in C, but malware authors began using the .NET framework (such as C#), which is
    still very popular. However, anti-malware and other defenses have caught up, so
    malware authors are adapting and now increasingly using other languages. Python,
    a very common scripting language, has seen more use in malware in both scripts
    and executable format. Malware authors simply code a malicious Python script (*.py*),
    which can be executed on any system that has the right Python libraries installed.
    Tools such as Py2Exe and PyInstaller can even convert a Python script into an
    executable, which the attacker can deploy on a victim machine similar to a standard
    PE file. Since it’s fairly trivial to code a malicious Python script and then
    convert it into an executable, this approach has a lower barrier to entry for
    malware authors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Nim ([*https://<wbr>nim<wbr>-lang<wbr>.org*](https://nim-lang.org)), a self-proclaimed
    “statically typed compiled systems programming language,” has also seen growing
    use with malware authors. Notably, Nim was used by the threat group behind the
    infamous Trickbot banking trojan (see Lawrence Abrams’s article “TrickBot’s BazarBackdoor
    Malware is Now Coded in Nim to Evade Antivirus” at [*https://<wbr>www<wbr>.bleepingcomputer<wbr>.com<wbr>/news<wbr>/security<wbr>/trickbots<wbr>-bazarbackdoor<wbr>-malware<wbr>-is<wbr>-now<wbr>-coded<wbr>-in<wbr>-nim<wbr>-to<wbr>-evade<wbr>-antivirus<wbr>/*](https://www.bleepingcomputer.com/news/security/trickbots-bazarbackdoor-malware-is-now-coded-in-nim-to-evade-antivirus/)).
    Using Nim potentially helped the malware evade AV defenses.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Go (sometimes called Golang) is an open source language from Google. It’s simple
    to program in (compared with other compiled languages such as C), so it’s no surprise
    that it has also seen increased use in malware. Rust ([*https://<wbr>www<wbr>.rust<wbr>-lang<wbr>.org*](https://www.rust-lang.org))
    is another language seeing more use in malware development. Indeed, nearly any
    programming or scripting language can be used for nefarious purposes, so this
    section could get very long. Even PowerShell is being used more often by malware
    authors. Malware analysts and defenders would be wise to stay abreast of the different
    languages being used in modern malware.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Abusing Certificate
    Trust and Signing</samp>
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *digital signature* is a trusted certificate that functions as a mark of approval
    for a file, informing the operating system and other applications that the file
    is legitimate and safe to execute. Many anti-malware solutions put less scrutiny
    on files that are digitally signed by a known and trusted authority. As a result,
    malware can abuse certificate trust chains to evade endpoint defenses.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The *certificate trust store* is the repository where Windows stores the signer
    certificates that it trusts. You can view the trust store on Windows with the
    certmgr application (which you can find in *C:\Windows\System32*), as shown in
    [Figure 13-12](chapter13.xhtml#fig13-12).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-12.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-12: Viewing the trust
    store in Windows with certmgr</samp>'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Malware authors can digitally sign their code with a trusted certificate in
    a few ways. First, if a threat actor were to infiltrate the network of a trusted
    company, it could generate valid certificates and sign its own malware with them,
    or it could steal certificates and digitally sign its malicious code with those.
    In fact, this has happened on more than one occasion, such as when code-signing
    certificates were stolen from Nvidia in 2022 (see Pieter Arntz’s article “Stolen
    Nvidia Certificates Used to Sign Malware—Here’s What to Do” at [*https://<wbr>www<wbr>.malwarebytes<wbr>.com<wbr>/blog<wbr>/news<wbr>/2022<wbr>/03<wbr>/stolen<wbr>-nvidia<wbr>-certificates<wbr>-used<wbr>-to<wbr>-sign<wbr>-malware<wbr>-heres<wbr>-what<wbr>-to<wbr>-do*](https://www.malwarebytes.com/blog/news/2022/03/stolen-nvidia-certificates-used-to-sign-malware-heres-what-to-do)).
    Code-signing certificates are sometimes even sold on the dark web!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, in certain circumstances it’s possible to insert malicious code into
    a previously signed executable file, all without invalidating the certificate.
    This was presented by researchers at the Black Hat conference in 2016 (see the
    report “Certificate Bypass: Hiding and Executing Malware from a Digitally Signed
    Executable,” from the Deep Instinct Research Team, at [*https://<wbr>www<wbr>.blackhat<wbr>.com<wbr>/us<wbr>-16<wbr>/briefings<wbr>/schedule<wbr>/#certificate<wbr>-bypass<wbr>-hiding<wbr>-and<wbr>-executing<wbr>-malware<wbr>-from<wbr>-a<wbr>-digitally<wbr>-signed<wbr>-executable<wbr>-3984*](https://www.blackhat.com/us-16/briefings/schedule/#certificate-bypass-hiding-and-executing-malware-from-a-digitally-signed-executable-3984)).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, malware can simply add a certificate to the list of trusted certificates
    on the operating system. This is easier said than done: the malware must already
    be executing on the host with a high level of privileges. But if it succeeds,
    the malware author may be able to run any additional malware they wish to on the
    host.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Abusing Engine Limitations</samp>
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned earlier, anti-malware software (as well as EDR software that has
    built-in anti-malware capabilities) has the difficult task of balancing high rates
    of detection with the end-user experience. This means, first and foremost, that
    it must have a high success rate when detecting malicious code, while also limiting
    false positives. Additionally, the anti-malware scanning and monitoring activity
    must be transparent to the end user. These scans shouldn’t impact the user experience
    at a level where the system becomes unusable or unstable. Cunning malware authors
    can take advantage of these restrictions using various techniques, two examples
    being delayed execution and memory bombing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that some malware uses delayed execution to evade detection
    inside a sandbox (as discussed in [Chapter 8](chapter8.xhtml)), it may be able
    to “outsleep” an anti-malware scanning engine. One way it can do this is by waiting
    until a specific number of milliseconds have passed. Once, say, 600,000 milliseconds
    (10 minutes) have elapsed, the sample executes its malicious code. Because the
    anti-malware engine might have a time limit on its emulation or sandboxing engine
    (to prevent the anti-malware engine from indefinitely analyzing a large file and
    consuming valuable system resources), this technique sometimes allows malware
    to slip through undetected.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '*Memory bombing*, a term coined in the book *Antivirus Bypass Techniques* by
    Uriel Kosayev and Nir Yehoshua (Packt, 2021), involves malware allocating excessively
    large regions of memory inside its process address space. Because anti-malware
    software must take into account its system resources consumption (CPU, memory,
    and so on), it might only quickly scan this large region of memory or even ignore
    it altogether, allowing the malicious code to go unnoticed. Note that this technique
    can also be effective against sandboxes.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Masquerading as a
    Safe File</samp>
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Masquerading* is used by malware authors to disguise malware as legitimate
    files. This technique is used primarily as a method of deceiving a victim rather
    than as a means of directly circumventing endpoint defenses. Masquerading can
    take many forms, including the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Spoofing a filename**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The malware author simply names a malicious file after a common system file
    or legitimate application file (such as *explorer.exe* or *PowerPoint.exe*) or
    slightly modifies a filename (such as *expl0rer.exe*). Malware authors could also
    change the file extension of malicious files to something more unassuming, such
    as renaming an *.exe* file to a *.jpg* file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Spoofing file metadata**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The malware author spoofs the metadata of a malicious file, such as by using
    “Microsoft” as the file’s publisher or company name. A similar technique is reusing
    legitimate program icons. For example, malware might use the Microsoft Word logo
    to make its malicious file appear genuine.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing social engineering attacks**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The malware author tricks the user into executing the malware, for example,
    by sending an email to a target user with a malicious file called *important_invoice.pdf*.
    A similar technique is the use of double extensions. By default, Windows doesn’t
    display file extensions, so the file *financials.xls.exe* would display in Windows
    as simply *financials.xls*. This may mislead an unsuspecting person into launching
    a malicious executable file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Even though masquerading is a relatively simple and inexpensive technique to
    implement, it can be quite effective. Notably, researchers from ESET reported
    that the threat group Sandworm delivered to victims in Ukraine malware disguised
    as a component of the IDA Pro disassembly tool and ESET’s own security software
    (see Kelly Jackson Higgins’s article “Sandworm APT Trolls Researchers on its Trail
    as it Targets Ukraine” at [*https://<wbr>www<wbr>.darkreading<wbr>.com<wbr>/threat<wbr>-intelligence<wbr>/sandworm<wbr>-apt<wbr>-trolls<wbr>-researchers<wbr>-on<wbr>-its<wbr>-trail<wbr>-while<wbr>-it<wbr>-targets<wbr>-ukraine*](https://www.darkreading.com/threat-intelligence/sandworm-apt-trolls-researchers-on-its-trail-while-it-targets-ukraine)).
    Another notable example of masquerading is malware imitating documents authored
    by reputable organizations, such as COVID-19–related information from the World
    Health Organization, as reported by Proofpoint in 2022 (see “Nerbian RAT Using
    COVID-19 Themes Features Sophisticated Evasion Techniques” from Andrew Northern
    and colleagues at [*https://<wbr>www<wbr>.proofpoint<wbr>.com<wbr>/us<wbr>/blog<wbr>/threat<wbr>-insight<wbr>/nerbian<wbr>-rat<wbr>-using<wbr>-covid<wbr>-19<wbr>-themes<wbr>-features<wbr>-sophisticated<wbr>-evasion<wbr>-techniques*](https://www.proofpoint.com/us/blog/threat-insight/nerbian-rat-using-covid-19-themes-features-sophisticated-evasion-techniques)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve explored different techniques malware uses to circumvent host
    defenses by actively tampering with them or passively slipping by them. Now let’s
    shift gears a bit and explore privilege elevation and how it can be used by malware
    to carry out operations that may otherwise be detected and blocked by endpoint
    defenses.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Privilege Elevation for Defense Evasion</samp>
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Privilege elevation*, or obtaining a higher level of privileges than one currently
    holds, can be a potent evasion tactic. After obtaining a high privilege level
    on the host, an attacker has a lot more freedom to execute further attacks that
    bypass endpoint defenses. As you’ve seen, high privilege levels are required for
    actions such as disabling anti-malware or modifying firewall configurations. While
    there are many ways to elevate privileges, this section will focus on four of
    the most common techniques in modern malware: UAC bypasses, access token impersonation
    and manipulation, credential reuse, and direct exploitation.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Bypassing User Account
    Control</samp>
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*User Account Control (UAC)* is a protection control in Windows designed to
    prevent unauthorized applications from executing code at high privilege levels.
    When an application requests administrator access, an administrator on the system
    must consent to the request (see [Figure 13-13](chapter13.xhtml#fig13-13)).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-13.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-13: A typical UAC
    pop-up</samp>'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: When an administrator consents, the application’s process integrity level increases
    to “high.” The most common integrity levels (high, medium, low, and system) help
    dictate what a process can and cannot do on a system. High-integrity processes
    run in an elevated mode and have access to objects assigned to lower integrity
    levels. Medium-integrity processes run with standard user rights; this is the
    default setting for most processes. Low-integrity processes have the lowest privilege
    level and are usually reserved for applications such as web browsers that should
    run in a container-like environment for security reasons. System integrity processes
    are those that are integral to the stability of the operating system; these include
    the Service Control Manager (*services.exe*) and the Windows subsystem process
    (*csrss.exe*). By design, processes with lower integrity levels cannot modify
    data in processes with higher integrity levels.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-14](chapter13.xhtml#fig13-14) shows an excerpt from Process Hacker,
    which conveniently highlights processes based on their elevation and integrity
    levels.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-14.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-14: Process integrity
    viewed in Process Hacker</samp>'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Process Hacker itself (*ProcessHacker.exe*) is highlighted in orange (or dark
    gray in this book), meaning that it’s elevated and running in a high-integrity
    mode. *Explorer.exe* is highlighted in pink (medium gray), demarcating it as a
    system process. The other, more mundane processes, such as Excel and Notepad,
    are yellow (light gray), meaning that they’re medium-integrity processes running
    with standard user privileges.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: UAC works to protect systems against malicious privilege elevation attempts
    by explicitly requesting permission from a higher-level account. UAC bypass attacks
    rely on tricking a user, an application, or the operating system itself into executing
    potentially dangerous actions in an elevated context. Let’s take a look at how
    UAC bypasses work in practice with a simple example.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: A number of built-in Windows utilities are designed to be run with elevated
    permissions. One of these utilities is *msconfig.exe*, a simple Windows configuration
    tool that allows system administrators to change Windows boot options and modify
    services and startup tasks, among other things. Normally, applications requesting
    elevated permissions produce a UAC prompt; by default, even users with administrator
    privileges must consent to this prompt. If executed from an administrator account,
    however, *msconfig.exe* automatically elevates itself to a high-integrity process
    without prompting for UAC. Furthermore, it allows for the execution of other tools
    that will subsequently run in a high-integrity context, also without a UAC prompt.
    Unfortunately for *msconfig.exe*, an actor can abuse this behavior, resulting
    in a simple UAC bypass. From the Tools menu in *msconfig.exe*, a user can select
    the Command Prompt tool and click Launch (see [Figure 13-15](chapter13.xhtml#fig13-15)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-15.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-15: Launching a command
    prompt from</samp> <samp class="SANS_Futura_Std_Book_11">msconfig.exe</samp>'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Next, a new command prompt with the integrity level of its parent process (*msconfig.exe*)
    will launch, without prompting for UAC permission. [Figure 13-16](chapter13.xhtml#fig13-16)
    shows this new *cmd.exe* process in Process Hacker.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-16.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-16: The</samp> <samp
    class="SANS_Futura_Std_Book_11">cmd.exe</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">process
    spawned with high integrity</samp>'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the process’s privileges are elevated (“Elevated: Yes”) and its
    integrity is high. The user bypassed UAC by executing a process that must be run
    in a high-integrity context (which doesn’t prompt for UAC permission on the default
    Windows configuration) and by spawning a command prompt that inherits that process’s
    high integrity level. This command prompt is now running as administrator and
    can be used to execute high-privilege commands. A similar real-world example of
    this comes from the malware family Trickbot, which abuses the auto-elevation property
    of the *WSReset.exe* Windows tool; see the article “Trickbot Trojan Leveraging
    a New Windows 10 UAC Bypass,” by Arnold Osipov at [*https://<wbr>blog<wbr>.morphisec<wbr>.com<wbr>/trickbot<wbr>-uses<wbr>-a<wbr>-new<wbr>-windows<wbr>-10<wbr>-uac<wbr>-bypass*](https://blog.morphisec.com/trickbot-uses-a-new-windows-10-uac-bypass).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this particular UAC bypass is that it requires GUI access to
    the system, so malware would have to jump through quite a few hoops to execute
    this attack without the victim noticing what’s going on. Malware authors have
    discovered a few ways to get around this limitation, however.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">DLL Hijacking</samp>
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In [Chapter 12](chapter12.xhtml), you learned that malware can abuse hijacking
    vulnerabilities in legitimate applications to inject a malicious DLL and stealthily
    run code. This type of attack is also an effective way to bypass UAC. Revisiting
    the *msconfig.exe* example used earlier, if it fell prey to DLL hijacking and
    allowed a malicious DLL to be loaded in place of a legitimate one, the malicious
    DLL could then execute under the context of the high-privileged *msconfig.exe*
    application. Any UAC pop-ups will be under the guise of *msconfig.exe*, possibly
    tricking the user into consenting and allowing the malicious code to run at a
    higher privilege level than would otherwise be possible.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'In a 2016 report from Fox-IT and NCC Group called “Mofang: A Politically Motivated
    Information Stealing Adversary” (which you can download at [*https://<wbr>blog<wbr>.fox<wbr>-it<wbr>.com<wbr>/2016<wbr>/06<wbr>/15<wbr>/mofang<wbr>-a<wbr>-politically<wbr>-motivated<wbr>-information<wbr>-stealing<wbr>-adversary<wbr>/*](https://blog.fox-it.com/2016/06/15/mofang-a-politically-motivated-information-stealing-adversary/)),
    researchers highlighted such an attack by the threat group Mofang, which abused
    the legitimate *migwiz.exe* Windows application to load a DLL called *cryptbase.dll*.
    This DLL was hijacked by the attackers, causing *migwiz.exe* (which runs in an
    elevated state by default) to load the malicious version of *cryptbase.dll*, effectively
    bypassing certain UAC controls.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">COM Abuse</samp>
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *Component Object Model (COM)* is a part of the Windows API that allows
    for interprocess communication. The basic building block of COM is a *COM object*,
    which is composed of data and the functions that control access to it, known as
    *interfaces*. A COM object server exposes interfaces to COM clients, and clients
    access the COM server via these interfaces. COM server objects are often *.dll*
    or *.exe* files. Each COM server object has a unique ID, called a class ID (CLSID),
    which is a 128-bit string that takes the form of a series of numbers and characters.
    These strings are often displayed in brackets, as in this example: <samp class="SANS_TheSansMonoCd_W5Regular_11">{4E5FC2F8-8C44-6776-0912-CB15617EBC13}</samp>.
    This will be important in a moment.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: A number of COM objects have a property called <samp class="SANS_TheSansMonoCd_W5Regular_11">COMAutoApproval</samp>,
    which indicates that the particular COM object doesn’t require a user to explicitly
    permit the privilege elevation functions that are part of the object. On a Windows
    system, you can view the list of COM objects that have this property in the registry
    key *HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\UAC\COMAutoApprovalList*.
    [Figure 13-17](chapter13.xhtml#fig13-17) shows this list on my system.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-17.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-17: Viewing COM objects
    with COMAutoApproval enabled</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'On a typical Windows 10 system, there are over 100 objects in this list! As
    you might imagine, some of these objects can be abused by malware to bypass UAC.
    For example, some COM object interfaces contain functions that can execute arbitrary
    code. A COM interface may expose a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteCommand</samp>,
    for instance, that takes an arbitrary command as input. The following pseudocode
    illustrates this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This malware initializes COM (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoInitialize</samp>)
    and creates a COM instance (<samp class="SANS_TheSansMonoCd_W5Regular_11">CoCreateInstance</samp>)
    of the COM object <samp class="SANS_TheSansMonoCd_W5Regular_11">VulnerableComObject</samp>.
    Once the COM object is initialized, the malware invokes the vulnerable <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteCommand</samp>
    method (which is exposed and exported via the COM object), passing <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp>
    as a parameter. Because the COM object is running with high privileges, the subsequent
    command will also be executed with high privileges. This specific command copies
    the malware executable into the *System32* directory, an action that would normally
    display a UAC prompt.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: This is a simplified version of this technique, but similar techniques have
    been used in real-world attacks. A well-researched project called UACME details
    a variation of this technique and many more at [*https://<wbr>github<wbr>.com<wbr>/hfiref0x<wbr>/UACME*](https://github.com/hfiref0x/UACME).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registry Tampering</samp>
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although modifying the registry often requires high-level privileges on the
    victim system in the first place, malware can use the registry to sidestep the
    UAC prompt itself. Consider a scenario in which an attacker has control over the
    infected host and can execute commands on it but doesn’t have a GUI to the host.
    The attacker might still be required to click on UAC prompts to execute certain
    actions, and this can be problematic without a graphical interface to the victim
    system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the malware can try to modify the registry key *HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\EnableLUA*
    from the default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which will effectively
    disable UAC prompts on the host. Setting the key *HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ConsentPromptBehaviorAdmin*
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> will also disable UAC
    prompts for administrator actions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Note that the machine may need to be rebooted in order for these changes to
    take effect, which could be problematic for the attacker and provoke unwanted
    attention.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Impersonating and
    Manipulating Access Tokens</samp>
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each process running on a system has an assigned access token inherited from
    its parent process, whose access token is in turn inherited from the user account
    that spawned it. This user account access token represents the rights and privileges
    of the user account. Process access tokens can be assigned different privileges:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>, for example,
    grants a user or process the ability to back up files and directories; <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>
    grants the process the ability to load a kernel driver; and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeShutdownPrivilege</samp>
    permits a process to shut down the system.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: To gain additional privileges, malware can duplicate a token from another process,
    a technique often known as *token theft* or *token impersonation*. The malware
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">DuplicateToken</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DuplicateTokenEx</samp> to create a copy
    of a token assigned to another process, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateLoggedOnUser</samp>,
    passing the duplicated token as a parameter. This assigns the permissions of the
    original token to the malware. The malware can also call <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp>
    to spawn a brand-new process and assign it the permissions of the duplicated token.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Alternatively, malware can manipulate its own token and assign it new privileges.
    One such coveted privilege that malware may attempt to obtain is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeDebugPrivilege</samp>,
    which permits a process to inspect and manipulate other processes owned by other
    user accounts, up to and including the System account. If a lower-privileged process
    is allowed to manipulate System processes, it can potentially inject and execute
    code in the context of these processes, completely bypassing UAC controls or,
    at the very least, tricking users into permitting elevated actions via UAC.*'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To gain the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    privilege, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcessToken</samp>
    function to open the access token of its process, then invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustTokenPrivileges</samp>,
    passing <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    as a parameter. However, just because a process requests this privilege doesn’t
    mean the operating system will grant it. Only previously elevated processes can
    request and be granted this permission, so the malware must already be running
    in an elevated state. Malware usually will use one of the UAC bypass techniques
    mentioned earlier in this chapter to elevate its privileges and then grant itself
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> to gain
    further access to other system processes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Extracting and Reusing
    Credentials</samp>
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Locating and extracting account credentials can be a potent privilege elevation
    method. If malware can locate an administrator’s credentials, for example, it
    may be able to reuse them to create a process with elevated permissions, or even
    to move laterally to other hosts on the network and gain elevated privileges on
    those systems. There are many ways malware can do this.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: One method of extracting credentials is to inspect the memory of the *Local
    Security Authority Subsystem Service (LSASS)* process, which oversees security
    policies and authentication. By nature, its process (*lsass.exe*) contains sensitive
    data in its memory address space—namely, login credentials and security tokens.
    On modern versions of Windows, this sensitive data is obfuscated (for example,
    via hashing), but in special circumstances it may be in cleartext. By inspecting
    the process memory of *lsass.exe*, malware may be able to locate and extract privileged
    credentials and tokens, then attempt to reuse them to elevate its own privileges.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: There are some tools that can automate this process. One well-known example,
    Mimikatz ([*https://<wbr>github<wbr>.com<wbr>/gentilkiwi<wbr>/mimikatz*](https://github.com/gentilkiwi/mimikatz)),
    can extract credentials (and other sensitive data) from the victim system’s memory.
    Even though Mimikatz has existed since 2011, it is still actively updated and
    often used in real-world attacks. Some attack frameworks, such as Cobalt Strike,
    even have tools like Mimikatz built in.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Another method of credential extraction is *keylogging*, an effort to capture
    the victim’s keystrokes to obtain login credentials for various accounts and services.
    Keylogging is often implemented with different forms of hooking, as described
    in [Chapter 12](chapter12.xhtml).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Exploiting Vulnerabilities
    for Privilege Elevation</samp>
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, some malware may attempt to exploit vulnerabilities in order to elevate
    its privileges. *Local privilege elevation* (*LPE*) vulnerabilities, which allow
    a malware to elevate its privileges on a system it already has lower-level access
    to, are especially popular among threat actors. One notable, relatively recent
    example of exploitation for privilege escalation is the CVE-2021-36934 vulnerability
    (see [*https://<wbr>cve<wbr>.mitre<wbr>.org*](https://cve.mitre.org)), nicknamed
    “HiveNightmare,” which affected Windows 10 and some versions of Windows 11\. HiveNightmare
    takes advantage of an access control issue in certain Windows directories. Inside
    these directories lie registry hives containing sensitive data, such as stored
    credentials, that’s not normally accessible to underprivileged users. However,
    by exploiting this vulnerability, an attacker could access backups of this sensitive
    data inside the Windows *Volume Shadow Copy Service (VSS)*, a Windows backup mechanism
    that stores copies of files and other data. In vulnerable versions of Windows,
    the attacker could craft a special payload that exploits this access control flaw,
    allowing the attacker to access unlocked copies of the sensitive registry hive
    data and use the stored credentials to elevate their privileges on the system.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-18](chapter13.xhtml#fig13-18) illustrates this exploit in action.
    (The exploit code can be obtained at [*https://<wbr>github<wbr>.com<wbr>/GossiTheDog<wbr>/HiveNightmare<wbr>*](https://github.com/GossiTheDog/HiveNightmare).)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-18.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-18: The HiveNightmare
    exploit in action</samp>'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: This exploit code dumps the extracted registry hive files into the current working
    directory. A quick directory listing reveals that the exploit was successful (see
    [Figure 13-19](chapter13.xhtml#fig13-19)).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-19.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-19: The HiveNightmare
    exploitation was successful!</samp>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: This attack may not look like much from the captured screenshots, but it’s powerful.
    As a nonprivileged user, I was able to extract sensitive registry hives directly
    from VSS that otherwise would not be available to me; had I wanted to, I could
    have queried them for stored credentials that I could then have used to execute
    code at a high privilege level. This is just one example of a vulnerability (and
    also a good example of credential extraction), but numerous privilege elevation
    vulnerabilities have been released over the past five years; some are high profile,
    and some are actively being abused by malware in the wild. Unfortunately, there
    are likely more similar vulnerabilities that are still unknown to the public.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at some ways in which malware might circumvent endpoint
    defenses, let’s shift our focus to how it could circumvent network defense controls.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Circumventing Network Defenses</samp>
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Network controls* are another layer of defense that malware must bypass in
    order to be successful. Circumventing network defenses relies on many of the tactics
    you’ve already seen in previous chapters. For example, malware can take advantage
    of obfuscation techniques such as encryption to conceal its C2 traffic. It can
    also leverage sandbox evasion techniques to circumvent network defenses that rely
    on sandboxing of suspicious files traversing the network. In this section, I’ll
    focus on circumvention techniques that haven’t yet been covered in the book. Before
    we start, however, I’ll briefly introduce some of the various network defenses
    available.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Introducing Modern
    Network Defenses</samp>
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with host defenses, the network defense market is flooded with product names
    and acronyms. At a fundamental level, there are only a few different types of
    modern network defenses. The ones I’ll focus on in this chapter are NIDS, NDR,
    and email protection:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**Network intrusion detection systems (NIDS)**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: These products monitor incoming and outgoing network traffic, searching for
    signs of malicious activity. Much like anti-malware, NIDS can be signature based,
    anomaly based, or a combination of the two. Signature-based NIDS techniques search
    for suspicious signature patterns in network traffic such as sequences of data,
    code, or strings. Anomaly-based techniques look more into behavioral patterns
    of network traffic and may leverage machine learning techniques. NIDS can also
    be *intrusion prevention systems (IPS)*, which not only detect attacks but also
    respond to and prevent them. Both NIDS and IPS are often included in modern implementations
    of more traditional network defenses like firewalls.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**Network detection and response (NDR)**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: This is the network equivalent of EDR. NDR is a more modern solution than NIDS
    and in some ways seeks to replace it. NDR uses real-time network traffic analysis
    to identify potential attacks, detect threats (such as malware) traversing the
    network, and be triggered by suspicious behaviors. The telemetry of NDR and host-based
    EDR can be combined to create extended detection and response (XDR), which allows
    analysts and investigators to track attacks across both the network and endpoint
    layers.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Email protection technologies**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: These solutions, which are becoming more widely used and necessary, sit at the
    email gateway of an organization and monitor and inspect inbound and outbound
    email traffic. This is a crucial control, as many inbound emails are laced with
    malicious attachments or URLs. Email protection suites scan and sandbox inbound
    and (sometimes) outbound emails, then raise alerts on (or simply delete) malicious
    ones. Since this technology partly relies on sandboxing, it can potentially be
    thwarted by the previously discussed anti-sandbox techniques.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll start looking at the ways in which malware might try to circumvent
    these controls.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Obfuscating and Obscuring
    Network Traffic</samp>
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To bypass NIDS and NDR, modern malware must employ obfuscation or encryption
    techniques to mask its network traffic. Some malware may attempt to hide from
    network defenses while downloading additional payloads or modules using encrypted
    network protocols such as HTTPS, Secure File Transfer Protocol (SFTP), or Secure
    Shell (SSH). Malware has even been known to make use of the encrypted surveillance
    protection software Tor to obscure its network activities. The malware family
    Bashlite (also known as Gafgyt) has been observed using this technique when communicating
    with its C2 infrastructure. Keep in mind that the very act of using Tor and other
    lesser-used protocols and services can itself be a telltale sign of malicious
    activity. While this technique may indeed prevent network defenses and investigators
    from inspecting the suspicious traffic, it doesn’t mean the malware will go completely
    undetected.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Another example of this tactic is *DNS tunneling*, which abuses the Domain Name
    System (DNS) protocol to hide traffic such as file downloads, exfiltration of
    data from the network, or C2 communication. Since DNS is a fundamental protocol
    that the internet runs on, DNS tunneling may go completely unnoticed by network
    monitoring and defenses. [Figure 13-20](chapter13.xhtml#fig13-20) illustrates
    what DNS tunneling looks like.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-20.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-20: DNS tunneling</samp>'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the infected host, which has a remote access trojan (RAT) hiding
    on it. This RAT communicates with its C2 server (*evil.com*) and requires special
    instructions that it will receive via DNS tunneling. It sends a DNS query to its
    C2 server (*36128.evil.com*). The *36128* subdomain is a randomized numerical
    string. Next, the DNS request is sent to a recursive DNS server, a local server
    that services DNS requests. This recursive DNS server may be an internet service
    provider (for home users and small businesses) or a server inside an organization
    that the host is part of.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Recursive DNS servers subsequently contact an *authoritative DNS server*, the
    source of authority for a domain. When a new website is provisioned from a hosting
    provider, the provider acts as the authoritative DNS server for that domain. Alternatively,
    anyone can establish their own authoritative DNS server for a domain name they
    have purchased. In this case, the RAT on the infected host is ultimately contacting
    the authoritative DNS server for the domain *evil.com*, and the malware author
    owns the authoritative DNS server for this domain.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Once the C2 server receives the DNS request, it responds with a reply to the
    sender. In this case, however, the reply includes an encoded command, the simple
    string <samp class="SANS_TheSansMonoCd_W5Regular_11">execute</samp>. This command,
    which could be obfuscated with a simple algorithm such as Base64 or even encrypted,
    can be hidden away in one of the records inside a DNS response. Record types that
    are often abused for DNS tunneling are TXT, CNAME, Resource Records (RR), and
    NULL records. (These are outside the scope of this book and won’t be discussed
    further.)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Once the infected host receives the DNS response, the RAT decodes the embedded
    string and processes the command <samp class="SANS_TheSansMonoCd_W5Regular_11">execute</samp>.
    Presumably, this means the RAT will then execute a malicious command. DNS by default
    is not encrypted, but again, since it’s so widely used and may be difficult to
    fully monitor, this type of attack may slip past network defenses.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware has also been known to use custom C2 frameworks that employ novel methods
    of network communication. These frameworks may leverage publicly accessible services
    such as GitHub, Pastebin, Telegram, or even X to conceal traffic and commands.
    Not only is this traffic usually encrypted, but it also can go completely unnoticed
    since it appears normal. One example of this arose when researchers at ESET discovered
    that the threat group Turla abused Britney Spears’s Instagram account to conceal
    its C2 servers (see the article “Carbon Paper: Peering into Turla’s Second Stage
    Backdoor” at [*https://<wbr>www<wbr>.welivesecurity<wbr>.com<wbr>/2017<wbr>/03<wbr>/30<wbr>/carbon<wbr>-paper<wbr>-peering<wbr>-turlas<wbr>-second<wbr>-stage<wbr>-backdoor<wbr>/*](https://www.welivesecurity.com/2017/03/30/carbon-paper-peering-turlas-second-stage-backdoor/)).
    The Turla group pasted to Spears’s Instagram page encoded text representing a
    URL that contained the address of its C2 server. Malware on systems previously
    infected by the Turla group then monitored her Instagram profile for these specific
    patterns to retrieve the address information of the C2 servers. The address was
    then decoded by the malware and used to retrieve additional commands from the
    attacker’s infrastructure.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Attackers may also host their malware payloads on well-known file-sharing sites
    like Google Drive and Dropbox. Since these services are widely used for legitimate
    purposes, malware that’s downloading a payload or additional modules from Google
    Drive, for example, may look completely normal to a casual observer and to network
    defenses.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Concealing Infrastructure
    Using Geofencing</samp>
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Geofencing* refers to the use of geographical locations as a factor that determines
    the malware’s behavior. In essence, the malware is designed to execute its payload
    only when the target host is located within a specific geographical boundary,
    such as a specific country. Geofencing can also be used to deter and prevent malware-scanning
    engines and analysts from identifying and investigating a malicious server. In
    the case of email protection solutions, for example, as malicious attachments
    are detonated in a sandbox, the sandbox may identify that the malware is attempting
    to communicate with an unknown domain on the internet. The sandbox may then try
    to “scan” or probe the server in an effort to identify its true nature and classify
    it as either legitimate or malicious.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Geofencing techniques can be used by a malicious server to prevent this behavior.
    By querying the location of the system or investigator probing its infrastructure,
    the server can hide itself from uninvited guests. A malware author in China, for
    example, may be specifically targeting victims in Germany. Any traffic to the
    malware’s C2 server not originating from an IP address in Germany can be blocked,
    preventing automated scanning engines or investigators without a German IP address
    from inspecting it more closely. Alternatively, the server could even display
    misleading information to systems not originating from Germany. For instance,
    any traffic from non-German IPs may be rerouted to a completely different, benign
    website. A similar technique was identified by researchers at Proofpoint, who
    revealed that the threat group TA547 leveraged geofencing to serve malware payloads
    to only certain targets (see the article “The First Step: Initial Access Leads
    to Ransomware” at [*https://<wbr>www<wbr>.proofpoint<wbr>.com<wbr>/us<wbr>/blog<wbr>/threat<wbr>-insight<wbr>/first<wbr>-step<wbr>-initial<wbr>-access<wbr>-leads<wbr>-ransomware*](https://www.proofpoint.com/us/blog/threat-insight/first-step-initial-access-leads-ransomware)).
    Payloads were hosted on servers, and only victims originating from specific countries
    were allowed to access and download the malware payloads.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Generating New Infrastructure
    Using DGAs</samp>
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One major problem that malware authors face is the fact that once a C2 server
    is identified by a sandbox, investigator, or defense software, it is effectively
    “burned,” meaning it will soon be blocklisted by most security products. This
    renders the malware that communicates with this server ineffective.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Malware can get around this problem by dynamically generating new C2 server
    addresses using *domain generation algorithms (DGAs)*, which consist of client-
    and server-side components. The malware (the client, in this case) uses embedded
    DGA code to create new domain names. The malware’s C2 server uses the same algorithm
    to produce a new domain name identical to the one created by the malware client.
    DGA operates on the principle that both the client and server sides of the algorithm
    generate predictable domain names. This algorithm must generate the same domain
    name on both the client and server sides, but it must be unpredictable enough
    that security researchers and analysis tools can’t guess the next domain names
    that will be generated.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-21](chapter13.xhtml#fig13-21) illustrates how DGAs are used by malware.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-21.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-21: How DGAs work</samp>'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The malware first generates a new domain name using DGA code embedded in its
    executable file. After executing the algorithm, the malware produces the domain
    *evil-01.tk*, and on the malware’s C2 infrastructure, the same algorithm runs
    and also produces *evil-01.tk* ❶. Then the malware author provisions a new server
    with the address *evil-01.tk* ❷. The malware then connects to the C2 server using
    this domain name, which is now online ❸.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: After a predetermined period of time, such as eight hours, the malware generates
    a new domain, *evil-02.cn* ❹. In turn, the server generates the same domain name,
    which is then provisioned ❺. Finally, the malware connects to it ❻. By this time,
    the first server (*evil-01.tk*) is likely offline. This cycle repeats until the
    algorithm runs out of available domains. This powerful DGA technique allows malware
    authors to generate hundreds or thousands of new domain names to use as C2 servers,
    making it a game of “whack-a-mole” for security products and investigators to
    identify and add these domains to a blocklist.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Executing the Fast-Flux
    Technique</samp>
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Fast flux* is a type of evasion technique used in large part by *botnets*,
    networks of infected systems that an attacker controls. As victims are infected
    by a particular malware variant, the infected hosts (the *bots*) are added to
    the botnet. Botnets are used by threat actors for various purposes, such as to
    send spam, conduct phishing and *distributed denial-of-service (DDoS)* attacks,
    and facilitate various types of fraud. The fast-flux technique allows threat actors
    to use their bots as proxies for concealing and protecting C2 servers and other
    infrastructure.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: To execute this technique, threat actors purchase a domain name and then rapidly
    change the IP address associated with the domain so that each time a victim visits
    it, they are directed to a different hosting IP address. This rapid changing of
    IP addresses is configured *round-robin* style, a legitimate technique for balancing
    client requests to a web server. By shortening the time-to-live (TTL) values of
    the IP addresses to several minutes or even less, the threat actor creates a more
    elusive infrastructure, making it more difficult for network defenses to identify
    and block malicious traffic, and for law enforcement and other investigators to
    identify its full infrastructure. [Figure 13-22](chapter13.xhtml#fig13-22) breaks
    down what fast flux looks like in practice.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-22.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-22: The fast-flux
    technique implemented in a botnet</samp>'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: First, a victim executes malware on their computer, and the malware wants to
    make an HTTP connection to the threat actor’s domain, *evil.com*. Before this
    can happen, however, *evil.com* must be resolved to an IP address. The victim
    makes a DNS request ❶, and *evil.com* is resolved (by an authoritative DNS server
    that the malware author controls) to the IP address 59.111.180.193 ❷. Next, the
    malware makes an HTTP request to the IP address 59.111.180.193 ❸, which is part
    of a botnet and assigned to Bot 1\. Acting as a proxy, Bot 1 redirects the HTTP
    request to the threat actor’s malware delivery server ❹, which subsequently delivers
    the malware payload to the victim ❺.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Minutes later, a new victim (infected with the same malware) makes a DNS and
    HTTP request for *evil.com*, just like the first victim. This time, however, the
    DNS server returns 97.66.36.178 as the IP (since the threat actor has already
    changed the IP address associated with this domain). This IP is mapped to Bot
    2, which similarly proxies and redirects the HTTP request to the malware staging
    server and delivers a payload to the second victim. Because the IP address changes
    very frequently and is spread across the botnet (which could be a spiderweb of
    many thousands of systems), it is difficult to pin down the attacker’s infrastructure
    in order to identify the other systems in the botnet and the attacker’s malware
    distribution and C2 servers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Fast flux is not only used in botnets; it’s also used by *bulletproof hosters
    (BPHs)*, which are web hosting providers that cater to less scrupulous web activities
    such as online gambling and spam or illegal activities such as organized crime.
    Normally, BPHs are housed in countries where this type of activity is not heavily
    scrutinized (and so goes unnoticed or is otherwise tolerated) and requests for
    takedown of malicious infrastructure from law enforcement agencies are not honored.
    BPHs may offer fast-flux services to cybercrime groups and others.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: There’s a related technique, called *double fast flux*, where not only is the
    IP address of the malicious domain rapidly changed, but so is the IP address of
    the attacker’s authoritative DNS server(s). This adds an extra layer of defense
    and complexity for researchers and network defenses.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Very few of the techniques we have discussed throughout this chapter are effective
    on their own. Modern malware-based attacks often use a combination of these techniques
    to infiltrate their targets, as you’ll see next.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Multistage and Complex Attacks</samp>
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, some modern defenses like EDR use a threat-scoring
    system or other analytical techniques to identify suspicious behaviors. In the
    early days of malware, it was common for malware to be delivered as a single malicious
    file. This file contained all the functionality required to infect the victim
    and take the further actions that the malware author intended. To successfully
    bypass modern endpoint and network defenses, however, malware authors must take
    a more complex, multistage approach. Crafting multistep, complex attack chains
    makes it more difficult for defenses to identify what’s occurring and take appropriate
    action. [Figure 13-23](chapter13.xhtml#fig13-23) illustrates such an attack.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-23.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-23: A complex, multistage
    attack</samp>'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: First, the malware author delivers a malicious document file to the victim.
    Once opened, the file executes embedded JavaScript code, which in turn executes
    obfuscated PowerShell code. The PowerShell code contacts the attacker’s malware
    staging server to download a loader (*Loader.exe*), which is responsible for contacting
    another remote server to download the malware payload (*Payload.exe*).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Tracing these disparate events is more challenging for defenses. Rather than
    evaluating the behaviors of a single executable file, an EDR’s event-tracing engine
    and analyzer will have to assess many different events from multiple sources before
    making a determination that this is malicious activity. To further complicate
    this attack, the malware author could spice it up with *sleep routines*. For example,
    the PowerShell command could wait two hours before downloading the loader executable,
    the loader could sleep for four hours before downloading the payload file, and
    then the payload could sleep for another eight hours before contacting its C2
    server. The event-tracing engine would then have to account for many hours of
    time variance between events.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'From the attacker’s perspective, however, there’s a downside to these multistage
    attacks: if even one stage of the attack fails, the entire attack chain fails.
    For example, if anti-malware is able to detect and quarantine the initial malicious
    Office document, the rest of the attack chain will fail. The same will happen
    if network defenses are able to identify and block the connections to the attacker’s
    malware-staging servers. This is a gamble malware authors must take, however.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter discussed many of the common techniques malware uses to actively
    and passively circumvent host defense controls such as anti-malware and EDR, as
    well as network-based controls such as NIDS. We looked in detail at how malware
    can enumerate a victim host to identify host defenses and how it might actively
    thwart those defenses. We also covered how malware can elevate its privileges,
    enabling it to slip past defenses more discreetly. In the next chapter, you’ll
    learn about rootkits, a type of low-level malware that uses techniques that might
    be considered the ultimate form of defense evasion.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
