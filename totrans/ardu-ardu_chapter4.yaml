- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BUILDING
    WATCHDOG TIMERS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Projects that sit unattended for some time may lock up or stop working because
    of accidents, suboptimal design, or power issues. To solve these problems, you
    can use a *watchdog timer*, a small circuit that sits dormant while the project
    is operating normally but hard resets the microcontroller to a restart operation
    if it doesn’t receive a normal signal. These timers can help you build more advanced,
    professional, and reliable projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the 555 timer IC as an astable timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the formulas to calculate 555 timer IC delay periods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build your own watchdog timer using a PCB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Ensuring Constant and Reliable Operation</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you gain microcontroller expertise, you may find yourself building projects
    or products operating without your constant attention over long periods of time.
    This could be a weather-monitoring system, a data-logging device, a hardware web
    host that allows remote reviews of current data, or some other device whose physical
    location is hard to access (buried in a basement or an attic).
  prefs: []
  type: TYPE_NORMAL
- en: When the final project is out of your hands, how can you ensure constant and
    reliable operation? Even when your hardware and sketch or code seems foolproof,
    unexpected situations can cause your Arduino to stop operating. A temporary power
    brownout could freeze the microcontroller (that is, halt the sketch). An unexpected
    temperature extreme could also cause issues. Or your sketch may have unanticipated
    bugs. For these reasons and more, you’ll need a watchdog.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll explain the theory behind watchdog timers and then show
    you how to build your own watchdog timer circuit.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Watchdog Timer Theory</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A watchdog timer circuit is an external timer connected to the RESET pin on
    the Arduino board. The watchdog circuit begins with a HIGH signal set to change
    to LOW after a predetermined length of time, which will cause the Arduino to reset
    and start again. However, the Arduino can prevent this reset by sending a regular
    signal, or *heartbeat*, via a digital output pin connected to the watchdog circuit.
    The heartbeat resets the timer circuit before the watchdog timer can reset the
    Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the timing diagram in [Figure 4-1](chapter4.xhtml#fig4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![A TIMING DIAGRAM EXPLAINING THE ARDUINO HEARTBEAT CAUSING RESET BY THE WATCHDOG
    TIMER CIRCUIT](../images/fig4-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A timing diagram
    of a watchdog timer output and Arduino heartbeat output</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The top signal is the output from a watchdog timer, continually oscillating
    between HIGH and LOW. The period for the HIGH signal is much longer than that
    for LOW. The watchdog output is connected to the Arduino’s RESET pin. When the
    watchdog timer resets, the output starts at HIGH, meaning the Arduino must keep
    resetting the watchdog timer to stop the watchdog timer resetting the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: To enable this, an Arduino digital output pin connected to the watchdog timer
    sends a quick pulse (HIGH and then LOW) to the timer ❶, resetting the timer and
    stopping the timer output from going LOW. If the Arduino has a problem and stops
    pulsing the heartbeat signal to the watchdog timer ❷, the watchdog timer oscillations
    continue and its signal will go LOW ❸, resetting the Arduino. After this reset,
    the Arduino should recover and begin sending out the heartbeat signal again ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The watchdog timer is a hardware-based solution, making it less error-prone
    than a software-based function. If the reset doesn’t get the Arduino going again,
    there’s a major fault in the project that will require you to physically examine
    the hardware or code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Watchdog Timer Circuit
    Configuration</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heart of the watchdog timer circuit is the 555 timer IC shown in [Figure
    4-2](chapter4.xhtml#fig4-2). This compact part contains a customizable timing
    circuit you can use in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A TEXAS INSTRUMENTS 555 TIMER IC](../images/fig4-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: A 555 timer IC</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To use the 555 as a watchdog timer, you’ll configure it as an *astable timer*,
    one that generates a continuous signal output with a longer HIGH than LOW, as
    shown in [Figure 4-3](chapter4.xhtml#fig4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![A BASIC SCHEMATIC FOR A555 ASTABLE TIMER CIRCUIT](../images/fig4-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: A basic astable
    timer circuit</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The astable timer circuit is fairly simple. Inside the 555 are a voltage comparator
    circuit and a flip-flop, which changes state between LOW and HIGH to drive the
    output pin. When power is applied, the voltage at pin 2 (the trigger pin) is less
    than one-third V[CC], meaning the flip-flop switches to set the 555 output to
    HIGH. C then charges via R[A] and R[B].
  prefs: []
  type: TYPE_NORMAL
- en: After a period with output at HIGH, the voltage at pin 6 (the threshold pin)
    goes above two-thirds V[CC]. The flip-flop switches to set the 555 output to LOW.
    This also enables the discharge function so that C discharges via R[B].
  prefs: []
  type: TYPE_NORMAL
- en: After a period with the output at LOW, the voltage at pin 2 is less than one-third
    V[CC], so the flip-flop switches to set the 555 output to HIGH … and the cycle
    repeats. The output is sourced from pin 3, which operates as an open collector—that
    is, when LOW, it can sink current to GND.
  prefs: []
  type: TYPE_NORMAL
- en: The duty cycle of the output signal and the HIGH and LOW periods are determined
    by the values of resistors R[1] and R[2] and the capacitor C. The R[L] parts are
    the loads, or the circuitry controlled by the output. Current can flow from V[CC]
    through the higher R[L] when the output is off, and from the output through the
    lower R[L] to GND when the output is on. Up to 200 mA of current can flow in or
    out of the 555’s output pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the HIGH and LOW period times for the output—and if you are curious,
    the frequency of the output signal (which we don’t use but might as well set!)—we
    use the following three formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg50-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'T[low] is the length of time the astable output from the 555 timer is LOW,
    and T[high] is the length of time the output is HIGH. For example, with a value
    of 100 kΩ for R[1], a value of 4.7 kΩ for R[2], and a capacitor C of 100 uF, the
    calculations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: T[high] = 0.693 (4,700) 0.0001 = 7.255 s
  prefs: []
  type: TYPE_NORMAL
- en: T[low] = 0.693 (100,000 + 4,700) 0.0001 = 0.3257 s
  prefs: []
  type: TYPE_NORMAL
- en: A spreadsheet with these formulas is available in the sketch download from [*https://<wbr>nostarch<wbr>.com<wbr>/arduino<wbr>-arduinians*](https://nostarch.com/arduino-arduinians).
    Use these formulas to easily calculate the values of resistors and the capacitor
    needed for your required HIGH and LOW times. The value of R[2] generally remains
    constant, as R[1] has more effect on the final values.
  prefs: []
  type: TYPE_NORMAL
- en: When building a 555 timer circuit, use 1 percent tolerance resistors. Larger
    capacitors can have a very large tolerance, especially during temperature fluctuations—sometimes
    up to +/−20 percent—so try to keep the capacitor value as small as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to operate a 555 timer, let’s build a watchdog timer circuit
    for our Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #14: Building a Watchdog Timer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll build a convenient and adjustable watchdog timer for
    your Arduino Uno or other microcontroller that utilizes the type of reset circuit
    discussed. You can build the circuit on a solderless breadboard for a more temporary
    setup or download the PCB files for this project and have your own PCB manufactured
    to create a permanent watchdog timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Project #14 PCB or solderless breadboard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An NE555 timer IC (not the CMOS 7555 version!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An eight-pin IC socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 1N4001 diode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 5 mm LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 × 40 2.54 mm inline header pins (if using PCB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 2N7000 N-MOSFET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 1 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 10 kΩ, 0.25 W, 1 percent resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 100 Ω, 0.25 W, 1 percent resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other resistors (see the following section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 0.01 µF ceramic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 0.1 µF ceramic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 100 µF, 16 V electrolytic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 4-4](chapter4.xhtml#fig4-4) shows the schematic for this project.'
  prefs: []
  type: TYPE_NORMAL
- en: '![SCHEMATIC FOR PROJECT #14](../images/fig4-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The schematic for
    Project #14</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Before assembling the circuit, determine which values to use for R[1] and R[2]
    to control the length of the HIGH and LOW periods of the output, using the formulas
    provided in the previous section. The results will differ depending on whether
    you’re using a PCB or solderless breadboard, as the contacts inside a breadboard
    also have their own resistance value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those of you building with a PCB, the schematic shows three resistors for
    R[e]: R[1A], R[1B], and R[1C]. I have left space for up to three resistors to
    be used as a combined value for R[1] so that you can change resistor values if
    required by adding new resistors in the R[1B] or R[1C] spaces and cutting out
    the unwanted values. Alternately, you may need to use two or three resistors in
    parallel to get your exact required value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the value of resistors in parallel, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: R[T] = 1 / (1 / R[1A] + 1 / R[1B] + 1 / R[1C] + …)
  prefs: []
  type: TYPE_NORMAL
- en: If you just need to use one resistor for R[1], insert it into the R[1A] space
    on the PCB.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not sure what values to use for this project, a good default option
    is to use around 100 kΩ for R[1] and 4.7 kΩ for R[2]. This will create a HIGH
    delay of just over 57 seconds, close to a minute. With this delay, your Arduino
    must reset the timer more often than once every 7 seconds to avoid being reset
    by the timer itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The 555 Circuit’s
    Inner Workings</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a closer look at the 555 circuit’s inner workings. When you apply
    power to the circuit, the 555 should start operating as described earlier, with
    the output signal connected to the Arduino’s RESET pin and starting as HIGH. The
    Arduino should operate as normal. Diode D[1], connected between the 555’s output
    pin and the Arduino RESET pin, ensures no stray signals can reset the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, as determined by your R[1] values, capacitor C[1] should start charging
    via the 555’s trigger pin. When the Arduino sends a HIGH signal via the heartbeat
    pin, it should turn on the N-MOSFET Q[1]. Doing so not only blinks LED D[3] (a
    visual indication of the Arduino heartbeat signal) but also shorts the capacitor
    C[1] to GND via R[6], emptying the capacitor. The capacitor C[1] then starts charging
    again, resetting the amount of time before the 555 can reset the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: If the Arduino keeps sending heartbeat pulses, the 555 timer never has a chance
    to change the output state to LOW and reset the Arduino, as discussed. However,
    if the Arduino stops sending heartbeat signals, capacitor C[1] will continue to
    charge until the 555’s threshold pin voltage reaches two-thirds of 5 V. At that
    point, the 555’s output changes state to LOW for a short period (determined by
    R[2]). This resets the Arduino and blinks LED D[2] (a visual indication that the
    reset circuit has been activated). When the 555’s output pin is LOW, current can
    flow from 5V, through R[3] and the LED, and into the 555 output pin. When the
    output pin is LOW, current can flow into the pin, as opposed to current flowing
    out from the output pin when it is HIGH. The output then changes back to HIGH,
    and the process starts again.
  prefs: []
  type: TYPE_NORMAL
- en: Resistors R[3] and R[4] limit current to the LEDs, while resistor R[5] pulls
    down the N-MOSFET until activated, avoiding unplanned activation. Resistor R[6]
    protects C[1] while the capacitor is discharging, avoiding a dead short when a
    heartbeat signal is received. C[2] smooths the power supply over the circuit.
    Finally, the 555 requires C[3] for normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Circuit Assembly</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assemble the project using the PCB shown in [Figure 4-5](chapter4.xhtml#fig4-5)
    as usual: start with the lowest-profile parts, such as the resistors, and then
    work your way to the tallest parts (the capacitors and inline header pins).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF AN UNPOPULATED PRINTER CIRCUIT BOARD FOR PROJECT #14](../images/fig4-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: The PCB for Project
    #14</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to use an IC socket for the 555 and match the notch at the end
    of the IC with the notch on the PCB. You may need to trim your inline header pins
    to get one strip of four pins.
  prefs: []
  type: TYPE_NORMAL
- en: Once assembled, your watchdog timer should resemble the one shown in [Figure
    4-6](chapter4.xhtml#fig4-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE COMPLETED PRINTED CIRCUIT BOARD FOR PROJECT #14](../images/fig4-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: The completed watchdog
    timer board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the 5V, RESET, and GND pins to the matching Arduino pins and connect
    the heartbeat pin to an unused digital pin on your Arduino. To make your sketch
    send a pulse at a frequency faster than the operation of the watchdog timer, consider
    the following example of using the watchdog timer. Upload the sketch after connecting
    the watchdog timer to your Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This sketch defines digital pin 5 as the heartbeat connection to the watchdog
    timer circuit ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">heartBeat()</samp>
    function generates the heartbeat pulse ❷, which simply flips the pin on and off
    for a moment—long enough to reset the watchdog timer circuit. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> function ❸ sends the heartbeat to reset the watchdog as soon as
    possible after the Arduino is reset or powered up. Finally, the main loop ❹ sends
    the heartbeat regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Placing the <samp class="SANS_TheSansMonoCd_W5Regular_11">heartbeat()</samp>
    function in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> is
    an ideal spot, assuming the time taken by a single run of the code in the loop
    is less than the timeout period of the watchdog. You can always insert more calls
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">heartBeat()</samp> in your other
    functions as well if you want to increase the number of watchdog-initiated resets
    of your project.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covered why you’d want to use a watchdog timer, along with the
    theory of operating and building your own circuit. You learned how to use the
    watchdog timer method in order to maintain the reliability of future Arduino-based
    projects, as well as how to use other microcontrollers such as the ATtiny or with
    other electronic devices that have an output and reset on LOW input.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn to control multiple LEDs with a minimal number
    of digital output pins.
  prefs: []
  type: TYPE_NORMAL
