<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_115"/><strong><span class="big">9</span><br/>BOOTKIT DYNAMIC ANALYSIS: EMULATION AND VIRTUALIZATION</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">You saw in <a href="ch08.xhtml#ch08">Chapter 8</a> that static analysis is a powerful tool for bootkit reverse engineering. In some situations, however, it can’t give you the information you’re looking for, so you’ll need to use <em>dynamic analysis</em> techniques instead. This is often true for bootkits that contain encrypted components for which decryption is problematic or for bootkits like Rovnix—covered in <a href="ch11.xhtml#ch11">Chapter 11</a>—that employ multiple hooks during execution to disable OS protection mechanisms. Static analysis tools can’t always tell which modules the bootkit tampers with, so dynamic analysis is more effective in these cases.</p>
<p class="indent">Dynamic analysis generally relies on the debugging facilities of the platform being analyzed, but the preboot environment doesn’t provide conventional debugging facilities. Debugging in a preboot environment usually requires special equipment, software, and knowledge, making it a challenging task.</p>
<p class="indent"><span epub:type="pagebreak" id="page_116"/>To overcome this hurdle, we need an additional layer of software—either an emulator or a virtual machine (VM). Emulation and virtualization tools enable us to run boot code in the controlled preboot environment with conventional debugging interfaces.</p>
<p class="indent">In this chapter, we’ll explore both approaches to dynamic bootkit analysis—specifically, emulation with Bochs and virtualization with VMware Workstation. The two types of approaches are similar, and both allow researchers to observe the boot code’s behavior at the moment of execution, provide the same level of insight into the code being debugged, and permit the same access to the CPU registers and memory.</p>
<p class="indent">The difference between the two methods lies in their implementation. The Bochs emulator interprets the code to emulate entirely on a virtual CPU, whereas VMware Workstation uses the real, physical CPU to execute most instructions of a guest OS.</p>
<p class="indent">The bootkit components we’ll be using for the analysis in this chapter are available in the book’s resources at <em><a href="https://nostarch.com/rootkits/">https://nostarch.com/rootkits/</a></em>. You’ll need the MBR in the file <em>mbr.mbr</em> and the VBR and IPL in the file <em>partition0.data</em>.</p>
<h3 class="h3" id="ch09lev1sec1"><strong>Emulation with Bochs</strong></h3>
<p class="noindent">Bochs (<em><a href="http://bochs.sourceforge.net/">http://bochs.sourceforge.net/</a></em>), pronounced “box,” is an open source emulator for the Intel x86-64 platform capable of emulating an entire computer. Our primary interest in this tool is that it provides a debugging interface that can trace the code it emulates, so we can use it to debug modules executed in the preboot environment, such as the MBR and VBR/IPL. Bochs also runs as a single user-mode process, so there’s no need to install kernel-mode drivers or any special system services to support the emulated environment.</p>
<p class="indent">Other tools, like the open source emulator QEMU (<em><a href="http://wiki.qemu.org/Main_Page">http://wiki.qemu.org/Main_Page</a></em>), provide the same functionality as Bochs and can also be used for bootkit analysis. But we chose Bochs over QEMU because in our extensive experience, Bochs has shown better integration with Hex-Rays IDA Pro for Microsoft Windows platforms. Bochs also has a more compact architecture that focuses on emulating only x86/x64 platforms, and it has an embedded debugging interface that we can use for boot code debugging without having to use IDA Pro—although its performance is enhanced when paired with IDA Pro, as we’ll demonstrate later in “<a href="ch09.xhtml#ch09lev2sec5">Combining Bochs with IDA</a>” on <a href="ch09.xhtml#page_123">page 123</a>.</p>
<p class="indent">It’s worth noting that QEMU is more efficient and supports more architectures, including the Advanced RISC Machine (ARM) architecture. QEMU’s use of an internal GNU Debugger (GDB) interface also provides opportunities for debugging from early on in the VM booting process. So, if you want to explore debugging more after this chapter, QEMU may be worth trying out.</p>
<h4 class="h4" id="ch09lev2sec1"><span epub:type="pagebreak" id="page_117"/><strong><em>Installing Bochs</em></strong></h4>
<p class="noindent">You can download the latest version of Bochs from <em><a href="https://sourceforge.net/projects/bochs/files/bochs/">https://sourceforge.net/projects/bochs/files/bochs/</a></em>. You have two download options: the Bochs installer and a ZIP archive with Bochs components. The installer includes more components and tools—including the <code>bximage</code> tool we’ll discuss later—so we recommend downloading it instead of the ZIP archive. The installation is straightforward: just click through the steps and leave the default values for the parameters. Throughout the chapter, we’ll refer to the directory where Bochs has been installed as the <em>Bochs working directory</em>.</p>
<h4 class="h4" id="ch09lev2sec2"><strong><em>Creating a Bochs Environment</em></strong></h4>
<p class="noindent">To use the Bochs emulator, we first need to create an environment for it, consisting of a Bochs configuration file and a disk image. The configuration file is a text file that contains all the essential information the emulator needs to execute the code (which disk image to use, the CPU parameters, and so forth), and the disk image contains the guest OS and boot modules to emulate.</p>
<h5 class="h5" id="ch09lev3sec1"><strong>Creating the Configuration File</strong></h5>
<p class="noindent"><a href="ch09.xhtml#ch09list01">Listing 9-1</a> demonstrates the most frequently used parameters for bootkit debugging, and we’ll use this as our Bochs configuration file throughout this chapter. Open a new text file and enter the contents of <a href="ch09.xhtml#ch09list01">Listing 9-1</a>. Or, if you prefer, you can use the <em>bochsrc.bxrc</em> file provided in the book’s resources. You’ll need to save this file in the Bochs working directory and name it <em>bochsrc.bxrc</em>. The <em>.bxrc</em> extension means that the file contains configuration parameters for Bochs.</p>
<pre>megs: 512<br/>
romimage: file="../BIOS-bochs-latest" <span class="ent">➊</span><br/>
vgaromimage: file="../VGABIOS-lgpl-latest" <span class="ent">➋</span><br/>
boot: cdrom, disk <span class="ent">➌</span><br/>
ata0-master: type=disk, path="win_os.img", mode=flat, cylinders=6192, heads=16, spt=63 <span class="ent">➍</span><br/>
mouse: enabled=0 <span class="ent">➎</span><br/>
cpu: ips=90000000 <span class="ent">➏</span></pre>
<p class="listing" id="ch09list01"><em>Listing 9-1: Sample Bochs configuration file</em></p>
<p class="indent">The first parameter, <code>megs</code>, sets a RAM limit for the emulated environment in megabytes. For our boot code–debugging needs, 512MB is more than sufficient. The <code>romimage</code> parameter <span class="ent">➊</span> and <code>vgaromimage</code> parameter <span class="ent">➋</span> specify the paths to the BIOS and VGA-BIOS modules to be used in the emulated environment. Bochs comes with default BIOS modules, but you can use custom modules if necessary (for example, in the case of firmware development). Because our goal is to debug MBR and VBR code, we’ll use the default BIOS module. The <code>boot</code> option specifies the boot device <span epub:type="pagebreak" id="page_118"/>sequence <span class="ent">➌</span>. With the settings shown, Bochs will first attempt to boot from the CD-ROM device, and if that fails, it will proceed to the hard drive. The next option, <code>ata0-master</code>, specifies the type and characteristics of the hard drive to be emulated by Bochs <span class="ent">➍</span>. It has several parameters:</p>
<p class="hangt"><span class="codestrong">type</span> The type of device, either <code>disk</code> or <code>cdrom</code>.</p>
<p class="hang"><span class="codestrong">path</span> The path to a file on the host filesystem with the disk image.</p>
<p class="hang"><span class="codestrong">mode</span> The type of image. This option is valid only for disk devices; we’ll discuss it in more detail in “<a href="ch09.xhtml#ch09lev2sec5">Combining Bochs with IDA</a>” on <a href="ch09.xhtml#page_123">page 123</a>.</p>
<p class="hang"><span class="codestrong">cylinders</span> The number of cylinders for the disk; this option defines the size of the disk.</p>
<p class="hang"><span class="codestrong">heads</span> The number of heads for the disk; this option defines the size of the disk.</p>
<p class="hangb"><span class="codestrong">spt</span> The number of sectors per track; this option defines the size of the disk.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In the following section, you’ll see how to create a disk image using the <span class="codeitalic">bximage</span> tool included with Bochs. Once it has created a new disk image, <span class="codeitalic">bximage</span> outputs the parameters for you to provide in the <span class="codeitalic">ata0-master</span> option.</em></p>
</div>
<p class="indent">The <code>mouse</code> parameter enables the use of a mouse in the guest OS <span class="ent">➎</span>. The <code>cpu</code> option defines the parameters of the virtual CPU inside the Bochs emulator <span class="ent">➏</span>. In our example, we use <code>ips</code> to specify the number of instructions to emulate per second. You can tweak this option to change performance characteristics; for example, for Bochs version 2.6.8 and a CPU with Intel Core i7, the typical <code>ips</code> value would be between 85 and 95 MIPS (millions of instructions per second), which is the case with the value we’re using here.</p>
<h5 class="h5" id="ch09lev3sec2"><strong>Creating the Disk Image</strong></h5>
<p class="noindent">To create a disk image for Bochs, you can use either the <code>dd</code> utility in Unix or the <code>bximage</code> tool provided with the Bochs emulator. We’ll choose <code>bximage</code> because we can use it on both Linux and Windows machines.</p>
<p class="indent">Open the <code>bximage</code> disk image creation tool. When it starts, <code>bximage</code> provides a list of options, as shown in <a href="ch09.xhtml#ch09fig01">Figure 9-1</a>. Enter <span class="codestrong">1</span> to create a new image <span class="ent">➊</span>.</p>
<p class="indent">The tool then asks whether you want to make a floppy or hard disk image. In our case, we specify <code>hd</code> <span class="ent">➋</span> to create a hard disk image. Next, it asks what type of image to create. Generally, the type of disk image determines the layout of the disk image in the file. The tool can create multiple types of disk images; for a full list of supported types, refer to the Bochs documentation. We choose <code>flat</code> <span class="ent">➌</span> to produce a disk image in a single file with flat layout. This means the offset within the file disk image corresponds to the offset on the disk, which allows us to easily edit and modify the image.</p>
<div class="image"><span epub:type="pagebreak" id="page_119"/><a id="ch09fig01"/><img src="../images/09fig01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-1: Creating a Bochs disk image with the <code>bximage</code> tool</em></p>
<p class="indent">Next, we need to specify the disk size in megabytes. The value you provide depends on what you’re using Bochs for. If you want to install an OS onto the disk image, the disk size needs to be large enough to store all the OS files. On the other hand, if you want to use the disk image only for debugging boot code, a disk size of 10MB <span class="ent">➍</span> is sufficient.</p>
<p class="indent">Finally, <code>bximage</code> prompts for an image name—this is the path to the file on the host filesystem in which the image will be stored <span class="ent">➎</span>. If you provide only the filename without the full path, the file will be stored in the same directory as Bochs. Once you enter the filename, Bochs creates the disk image and outputs a configuration string <span class="ent">➏</span> for you to enter in the <code>ata0-master</code> line of the Bochs configuration file (<a href="ch09.xhtml#ch09list01">Listing 9-1</a>). To avoid confusion, either provide a full path to the image file in <code>bximage</code> or copy the newly created image file into the same directory as the configuration file. This ensures that Bochs can find and load the image file.</p>
<h4 class="h4" id="ch09lev2sec3"><strong><em>Infecting the Disk Image</em></strong></h4>
<p class="noindent">Once you’ve created the disk image, we can proceed with infecting the disk with a bootkit. We can do so in one of two ways. The first option is to install a guest OS onto the Bochs disk image and then execute the bootkit infector into the guest environment. At execution, the malware will infect the disk image with the bootkit. This approach allows you to perform deeper <span epub:type="pagebreak" id="page_120"/>malware analysis because the malware installs all the components onto the guest system, including the bootkit and the kernel-mode drivers. But it also has some drawbacks:</p>
<ul>
<li class="noindent">The disk image we created earlier must be large enough to accommodate the OS.</li>
<li class="noindent">The emulation of the instructions during the OS installation and malware execution increases the execution time significantly.</li>
<li class="noindent">Some modern malware implements antiemulation functionality, meaning the malware detects when it is running in the emulator and exits without infecting the system.</li>
</ul>
<p class="indent">For these reasons, we’ll use the second option: infecting the disk image by extracting the bootkit components (the MBR, VBR, and IPL) from the malware and writing them directly to the disk image. This approach requires a substantially smaller disk size, and it is usually much faster. But it also means we can’t observe and analyze other components of the malware, like kernel-mode drivers. This approach also requires some prior understanding of the malware and its architecture. So another reason we’re choosing it is that it gives us more insight into using Bochs in the context of dynamic analysis.</p>
<h5 class="h5" id="ch09lev3sec3"><strong>Writing the MBR to the Disk Image</strong></h5>
<p class="noindent">Make sure you’ve downloaded and saved the <em>mbr.mbr</em> code from the resources at <em><a href="https://nostarch.com/rootkits/">https://nostarch.com/rootkits/</a></em>. <a href="ch09.xhtml#ch09list02">Listing 9-2</a> shows the Python code that writes the malicious MBR onto the disk image. Copy it into a text editor and save it as an external Python file.</p>
<pre># read MBR from file<br/>
mbr_file = open("<span class="codeitalic1">path_to_mbr_file</span>", "rb") <span class="ent">➊</span><br/>
mbr = mbr_file.read()<br/>
mbr_file.close()<br/>
# write MBR to the very beginning of the disk image<br/>
disk_image_file = open("<span class="codeitalic1">path_to_disk_image</span>", "r+b") <span class="ent">➋</span><br/>
disk_image_file.seek(0)<br/>
disk_image_file.write(mbr) <span class="ent">➌</span><br/>
disk_image_file.close()</pre>
<p class="listing" id="ch09list02"><em>Listing 9-2: Writing the MBR code onto the disk image</em></p>
<p class="indent">In this example, enter the file location for the MBR in place of <span class="codeitalic">path_to_mbr_file</span> <span class="ent">➊</span>, enter the disk image location in place of <span class="codeitalic">path_to_disk_image</span> <span class="ent">➋</span>, and then save the code into a file with the extension <em>.py</em>. Now, execute <code>python</code> <span class="codeitalic">path_to_the_script_file</span><code>.py</code>, and the Python interpreter will execute the code in Bochs. The MBR we’ve written <span class="ent">➌</span> onto the disk image contains only one active partition (0) in the partition table, as shown in <a href="ch09.xhtml#ch09tab01">Table 9-1</a>.</p>
<p class="tabcap" id="ch09tab01"><span epub:type="pagebreak" id="page_121"/><strong>Table 9-1:</strong> MBR Partition Table</p>
<table class="topbot-d">
<colgroup>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
<col style="width:25%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Partition number</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Type</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Starting sector</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Partition size in sectors</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">0</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x80 (bootable)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x10 <span class="ent">➊</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0x200</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">1</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0 (no partition)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">2</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0 (no partition)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba">3</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">0 (no partition)</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">0</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">0</p></td>
</tr>
</tbody>
</table>
<p class="indent">Next, we need to write the VBR and IPL onto the disk image. Make sure you download and save the <em>partition0.data</em> code from the resources at <em><a href="https://nostarch.com/rootkits/">https://nostarch.com/rootkits/</a></em>. We need to write these modules at the offset <span class="ent">➊</span> specified in <a href="ch09.xhtml#ch09tab01">Table 9-1</a>, which corresponds to the starting offset of the active partition.</p>
<h5 class="h5" id="ch09lev3sec4"><strong>Writing the VBR and IPL to the Disk Image</strong></h5>
<p class="noindent">To write the VBR and IPL onto the disk image, enter the code presented in <a href="ch09.xhtml#ch09list03">Listing 9-3</a> in a text editor and save it as a Python script.</p>
<pre># read VBR and IPL from file<br/>
vbr_file = open("<span class="codeitalic1">path_to_vbr_file</span>", "rb") <span class="ent">➊</span><br/>
vbr = vbr_file.read()<br/>
vbr_file.close()<br/>
# write VBR and IPL at the offset 0x2000<br/>
disk_image_file = open("<span class="codeitalic1">path_to_disk_image</span>", "r+b") <span class="ent">➋</span><br/>
disk_image_file.seek(0x10 * 0x200)<br/>
disk_image_file.write(vbr)<br/>
disk_image_file.close()</pre>
<p class="listing" id="ch09list03"><em>Listing 9-3: Writing the VBR and IPL onto the disk image</em></p>
<p class="indent">Again, as with <a href="ch09.xhtml#ch09list02">Listing 9-2</a>, replace <span class="codeitalic">path_to_vbr_file</span> <span class="ent">➊</span> with the path to the file containing the VBR and replace <span class="codeitalic">path_to_disk_image</span> <span class="ent">➋</span> with the image location before running the script.</p>
<p class="indent">After executing the script, we have a disk image ready for debugging in Bochs. We’ve successfully written the malicious MBR and VBR/IPL onto the image, and we can analyze them in the Bochs debugger.</p>
<h4 class="h4" id="ch09lev2sec4"><strong><em>Using the Bochs Internal Debugger</em></strong></h4>
<p class="noindent">The Bochs debugger is a stand-alone application, <em>bochsdbg.exe</em>, with a command line interface. We can use the functions supported by the Bochs debugger—such as breakpoint, memory manipulation, tracing, and code disassembly—to examine boot code for malicious activity or decrypt polymorphic MBR code. To start a debugging session, call the <em>bochsdbg.exe</em> application from the command line with a path to the Bochs configuration file <em>bochsrc.bxrc</em>, like so:</p>
<pre>bochsdbg.exe -q -f bochsrc.bxrc</pre>
<p class="indent"><span epub:type="pagebreak" id="page_122"/>This command starts a virtual machine and opens a debugging console. First, set a breakpoint at the beginning of the boot code so that the debugger stops the execution of the MBR code at the beginning, giving us an opportunity to analyze the code. The first MBR instruction is placed at address 0x7c00, so enter the command <span class="codestrong">lb 0x7c00</span> to set the breakpoint at the beginning of the instructions. To commence execution, we apply the <code>c</code> command, as shown in <a href="ch09.xhtml#ch09fig02">Figure 9-2</a>. To see the disassembled instructions from the current address, we use the <code>u</code> debugger command; for example, <a href="ch09.xhtml#ch09fig02">Figure 9-2</a> shows the first 10 disassembled instructions with the command <code>u /10</code>.</p>
<div class="image"><a id="ch09fig02"/><img src="../images/09fig02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-2: The command line Bochs debugger interface</em></p>
<p class="indent">You can get a full list of the debugger commands by entering <code>help</code> or visiting the documentation at <em><a href="http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html">http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html</a></em>. Here are a few of the more useful ones:</p>
<p class="hangt"><span class="codestrong">c</span> Continue executing.</p>
<p class="hang"><span class="codestrong">s [</span><span class="codestrongitalic">count</span><span class="codestrong">]</span> Execute count instructions (step); the default value is <code>1</code>.</p>
<p class="hang"><span class="codestrong">q</span> Quit the debugger and execution.</p>
<p class="hang"><strong><small>CTRL</small>-C</strong> Stop execution and return to the command line prompt.</p>
<p class="hang"><span class="codestrong">lb addr</span> Set a linear address instruction breakpoint.</p>
<p class="hang"><span class="codestrong">info break</span> Display the state of all current breakpoints.</p>
<p class="hang"><span class="codestrong">bpe</span> <span class="codestrongitalic">n</span> Enable a breakpoint.</p>
<p class="hang"><span class="codestrong">bpd</span> <span class="codestrongitalic">n</span> Disable a breakpoint.</p>
<p class="hangb"><span class="codestrong">del</span> <span class="codestrongitalic">n</span> Delete a breakpoint.</p>
<p class="indent">Although we can use the Bochs debugger on its own for basic dynamic analysis, we can do more when it’s bound with IDA, mainly because the code navigation in IDA is much more powerful than batch-mode debugging. In an IDA session, we can also continue with a static analysis of the created IDA Pro database file and use features like the decompiler.</p>
<h4 class="h4" id="ch09lev2sec5"><span epub:type="pagebreak" id="page_123"/><strong><em>Combining Bochs with IDA</em></strong></h4>
<p class="noindent">Now that we have an infected disk image prepared, we’ll launch Bochs and start the emulation. Starting with version 5.4, IDA Pro provides a frontend for the DBG debugger, which we can use with Bochs to debug guest operating systems. To launch the Bochs debugger in IDA Pro, open IDA Pro and then go to <strong>Debugger</strong>▸<strong>Run</strong>▸<strong>Local Bochs debugger</strong>.</p>
<p class="indent">A dialog will open, asking for some options, as shown in <a href="ch09.xhtml#ch09fig03">Figure 9-3</a>. In the Application field, specify the path to the Bochs configuration file you created earlier.</p>
<div class="image"><a id="ch09fig03"/><img src="../images/09fig03.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-3: Specifying the path to the Bochs configuration file</em></p>
<p class="indent">Next, we need to set some options. Click <strong>Debug options</strong> and then go to <strong>Set specific options</strong>. You’ll see a dialog like the one in <a href="ch09.xhtml#ch09fig04">Figure 9-4</a>, offering three options for the Bochs operation mode:</p>
<p class="hangt"><strong>Disk image</strong> Launch Bochs and execute the disk image.</p>
<p class="hang"><strong>IDB</strong> Emulate a selected part of the code inside Bochs.</p>
<p class="hangb"><strong>PE</strong> Load and emulate the PE image inside Bochs.</p>
<div class="image"><a id="ch09fig04"/><img src="../images/09fig04.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-4: Choosing the operation mode for Bochs</em></p>
<p class="indent">For our case, we select <strong>Disk image</strong> <span class="ent">➊</span> to make Bochs load and execute the disk image we created and infected earlier.</p>
<p class="indent">Next, IDA Pro launches Bochs with our specified parameters, and because we set the breakpoint earlier, it will break upon execution of the <span epub:type="pagebreak" id="page_124"/>first instruction of the MBR at address 0000:7c00h. We can then use the standard IDA Pro debugger interface to debug the boot components (see <a href="ch09.xhtml#ch09fig05">Figure 9-5</a>).</p>
<div class="image"><a id="ch09fig05"/><img src="../images/09fig05.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-5: Debugging MBR from IDA interface on a Bochs VM</em></p>
<p class="indent">The interface presented in <a href="ch09.xhtml#ch09fig05">Figure 9-5</a> is considerably more user-friendly than the command line interface the Bochs debugger provides (shown previously in <a href="ch09.xhtml#ch09fig02">Figure 9-2</a>). You can see the disassembly of the boot code <span class="ent">➊</span>, the contents of the CPU’s registers <span class="ent">➋</span>, a memory dump <span class="ent">➌</span>, and the CPU’s stack <span class="ent">➍</span> in a single window. This significantly simplifies the process of boot code debugging.</p>
<h3 class="h3" id="ch09lev1sec2"><strong>Virtualization with VMware Workstation</strong></h3>
<p class="noindent">IDA Pro and Bochs are a powerful combination for boot code analysis. But debugging OS boot processes is sometimes unstable with Bochs, and there are some performance limitations to the emulation technique. For instance, performing an in-depth analysis of malware requires you to create a disk image with a preinstalled OS. This step can be time-consuming due to the nature of emulation. Bochs also lacks a convenient system for managing snapshots of an emulated environment—an indispensable feature in malware analysis.</p>
<p class="indent">For something more stable and efficient, we can use VMware’s internal GDB debugging interface with IDA. In this section, we introduce the VMware GDB debugger and demonstrate how to set up a debugging <span epub:type="pagebreak" id="page_125"/>session. We’ll discuss the specifics of debugging Microsoft Windows bootloaders over the next few chapters, which focus on MBR and VBR bootkits. We’ll also look at switching from real mode to protected mode from a debugging perspective.</p>
<p class="indent">VMware Workstation is a powerful tool for replicating operating systems and environments. It allows us to create virtual machines with guest operating systems and run them on the same machine as the host operating system. The guest and host operating systems will work without interfering with each other, as if they were running on two different physical machines. This is very useful for debugging because it makes it easy to run two programs—the debugger and the application being debugged—on the same host. In this regard, the VMware Workstation is quite similar to Bochs, except that the latter emulates CPU instructions, whereas VMware Workstation executes them on the physical CPU. As a result, the code executed in the VM runs faster than in Bochs.</p>
<p class="indent">The recent versions of VMware Workstation (version 6.5 onward) include a GDB stub for debugging VMs running inside VMware. This allows us to debug the VM from the very beginning of its execution, even before BIOS executes the MBR code. Starting from version 5.4, IDA Pro includes a debugger module that supports the GDB debug protocol, which we can use in conjunction with VMware.</p>
<p class="indent">At the time of writing this chapter, VMware Workstation is available in two versions: Professional (the commercial version) and Workstation Player (the free version). The Professional version offers extended functionality, including the ability to create and edit VMs, whereas Workstation Player allows users only to run VMs or to modify their configurations. But both versions include the GDB debugger, and we can use both for bootkit analysis. In this chapter, we’ll use the Professional version so we can create a VM.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Before you can start using the VMware GBD debugger, you need to create a virtual machine instance using VMware Workstation and preinstall an operating system on it. The process of creating a VM is beyond the scope of this chapter, but you can find all the necessary information in the documentation at</em> <a href="https://www.vmware.com/pdf/desktop/ws90-using.pdf">https://www.vmware.com/pdf/desktop/ws90-using.pdf</a>.</p>
</div>
<h4 class="h4" id="ch09lev2sec6"><strong><em>Configuring the VMware Workstation</em></strong></h4>
<p class="noindent">Once you’ve created a virtual machine, VMware Workstation places the VM image and a configuration file in a user-specified directory, which we will refer to as the virtual machine’s directory.</p>
<p class="indent">To enable VMware to work with GDB, you first need to specify certain configuration options in the virtual machine configuration file, shown in <a href="ch09.xhtml#ch09list04">Listing 9-4</a>. The virtual machine configuration file is a text file that should have the extension <em>.vmx</em>, and it is located in the virtual machine’s directory. Open it in the text editor of your choice and copy the parameters in <a href="ch09.xhtml#ch09list04">Listing 9-4</a>.</p>
<pre><span epub:type="pagebreak" id="page_126"/><span class="ent">➊</span> debugStub.listen.guest32 = "TRUE"<br/>
<span class="ent">➋</span> debugStub.hideBreakpoints= "TRUE"<br/>
<span class="ent">➌</span> monitor.debugOnStartGuest32 = "TRUE"</pre>
<p class="listing" id="ch09list04"><em>Listing 9-4: Enabling a GDB stub in the VM</em></p>
<p class="indent">The first option <span class="ent">➊</span> allows guest debugging from the local host. It enables the VMware GDB stub, which allows us to attach a debugger supporting the GDB protocol to the debugged VM. If our debugger and VM were running on different machines, we would instead need to enable remote debugging with the command <code>debugStub.listen.guest32.remote</code>.</p>
<p class="indent">The second option <span class="ent">➋</span> enables the use of hardware breakpoints rather than software breakpoints. The hardware breakpoints employ CPU debugging facilities—namely, debugging registers <code>dr0</code> through <code>dr7</code>—whereas implementing software breakpoints usually involves executing the <code>int 3</code> instruction. In the context of malware debugging, this means hardware breakpoints are more resilient and more difficult to detect.</p>
<p class="indent">The last option <span class="ent">➌</span> instructs GDB to break the debugger upon executing the very first instruction from the CPU—that is, right after the VM is launched. If we skip this configuration option, VMware Workstation will start executing the boot code without breaking on it, and as a result, we won’t be able to debug it.</p>
<div class="sidebar">
<p class="sidebart"><strong>DEBUGGING FOR 32-BIT OR 64-BIT</strong></p>
<p class="spara">The suffix 32 in the options <code>debugStub.listen.guest32</code> and <code>debugStub.debugOnStartGuest32</code> indicates that 32-bit code is being debugged. If you need to debug a 64-bit OS, you can use the options <code>debugStub.listen.guest64</code> and <code>debugStub.debugOnStartGuest64</code> instead. However, for preboot code (MBR/VBR) running in 16-bit real mode, either of the 32-bit or 64-bit options would work.</p>
</div>
<h4 class="h4" id="ch09lev2sec7"><strong><em>Combining VMware GDB with IDA</em></strong></h4>
<p class="noindent">After configuring the VM, we can proceed with launching the debugging session. First, to start the VM in VMware Workstation, go to the menu and choose <strong>VM</strong>▸<strong>Power</strong>▸<strong>Power On</strong>.</p>
<p class="indent">Next, we’ll run the IDA Pro debugger to attach to the VM. Select <strong>Debugger</strong> and go to <strong>Attach</strong>▸<strong>Remote GDB debugger</strong>.</p>
<p class="indent">Now we need to configure the debugging options. First, we specify the hostname and the port of the target it should attach to. We’re running the VM on the same host, so we specify <span class="codestrong">localhost</span> as the hostname (as shown in <a href="ch09.xhtml#ch09fig06">Figure 9-6</a>) and <span class="codestrong">8832</span> as the port. This is the port the GDB stub will listen to for incoming connections when we’re using <code>debugStub.listen.guest32</code> in <span epub:type="pagebreak" id="page_127"/>the VM configuration file (when we’re using <code>debugStub.listen.guest64</code> in the configuration file, the port number is <code>8864</code>). We can leave the rest of debug parameters at their default values.</p>
<div class="image"><a id="ch09fig06"/><img src="../images/09fig06.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-6: Specifying GDB parameters</em></p>
<p class="indent">Once all the options are set, IDA Pro attempts to attach to the target and suggests a list of processes it can attach to. Since we have already started debugging the preboot components, we should choose <strong>&lt;attach to the process started on target&gt;</strong>, as shown in <a href="ch09.xhtml#ch09fig07">Figure 9-7</a>.</p>
<div class="image"><a id="ch09fig07"/><img src="../images/09fig07.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-7: Selecting the target process</em></p>
<p class="indent">At this point, IDA Pro attaches to the VM and breaks upon execution of the very first instruction.</p>
<h5 class="h5" id="ch09lev3sec5"><strong>Configuring the Memory Segment</strong></h5>
<p class="noindent">Before going any further, we need to change the type of the memory segment the debugger has created for us. When we started the debugging session, IDA Pro created a 32-bit memory segment, something like <a href="ch09.xhtml#ch09fig08">Figure 9-8</a>.</p>
<div class="image"><a id="ch09fig08"/><img src="../images/09fig08.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-8: Parameters of the memory segment in IDA Pro</em></p>
<p class="indent">In the preboot environment, the CPU operates in real mode, so in order to correctly disassemble the code, we need to change this segment from 32-bit to 16-bit. To do this, right-click the target segment and choose <strong>Change segment attributes</strong>. In the dialog that appears, select <strong>16-bit</strong> <span class="ent">➊</span> in the Segment bitness pane, as shown in <a href="ch09.xhtml#ch09fig09">Figure 9-9</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_128"/><a id="ch09fig09"/><img src="../images/09fig09.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-9: Changing the bitness of the memory segment</em></p>
<p class="indent">This will make the segment 16-bit, and all the instructions in the boot components will be correctly disassembled.</p>
<h5 class="h5" id="ch09lev3sec6"><strong>Running the Debugger</strong></h5>
<p class="noindent">With all the correct options set, we can proceed with the MBR loading. Since the debugger was attached to the VM at the very beginning of the execution, the MBR code hasn’t yet been loaded. To load the MBR code, we set a breakpoint at the very start of the code at the address 0000:7c00h and then continue the execution. To set the breakpoint, go to address 0000:7c00h in the disassembly window and press F2. This will display a dialog with the breakpoint parameters (see <a href="ch09.xhtml#ch09fig10">Figure 9-10</a>).</p>
<p class="indent">The Location text box <span class="ent">➊</span> specifies the address at which the breakpoint will be set: 0x7c00, which corresponds to virtual address 0000:7c00h. In the Settings area <span class="ent">➋</span>, we select the Enabled and Hardware checkbox options. Checking the Enabled box means that the breakpoint is active, and once the execution flow reaches the address specified in the Location text box, the breakpoint is triggered. Checking the Hardware box means that the debugger will use the CPU’s debugging registers to set up the breakpoint, and it also activates the Hardware breakpoint mode options <span class="ent">➌</span>, which specify the type of the breakpoint. In our case, we specify Execute to set up the breakpoint for executing an instruction at address 0000:7c00h. The other types of hardware breakpoints are for reading and writing memory at the specified location, which we don’t need here. The Size drop-down menu <span class="ent">➍</span> specifies the size of the controlled memory. We can leave the default value, 1, meaning that the breakpoint will control only 1 byte at address 0000:7c00h. Once these parameters are set, click <strong>OK</strong> and then resume execution by pressing F9.</p>
<div class="image"><span epub:type="pagebreak" id="page_129"/><a id="ch09fig10"/><img src="../images/09fig10.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-10: The Breakpoint settings dialog</em></p>
<p class="indent">Once the MBR is loaded and executed, the debugger breaks. The debugger window is shown in <a href="ch09.xhtml#ch09fig11">Figure 9-11</a>.</p>
<div class="image"><a id="ch09fig11"/><img src="../images/09fig11.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-11: The IDA Pro debugger interface</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_130"/>At this point, we are at the very first instruction of the MBR code, as the instruction pointer register <span class="ent">➊</span> points to 0000:7c00h. We can see in the memory dump window and in the disassembly that the MBR has been successfully loaded. From here, we can continue the debugging process of the MBR code and execute each instruction, step by step.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The purpose of this section was simply to introduce you to the possibility of using the VMware Workstation GDB debugger with IDA Pro, so we aren’t going any deeper into using the GDB debugger in this chapter. You’ll find more information on its usage over the next few chapters, however, as we analyze the Rovnix bootkit.</em></p>
</div>
<h3 class="h3" id="ch09lev1sec3"><strong>Microsoft Hyper-V and Oracle VirtualBox</strong></h3>
<p class="noindent">This chapter doesn’t cover the Hyper-V virtual machine manager, which is a component of Microsoft’s client operating systems since Windows 8, nor does it cover the VirtualBox open source virtual machine manager (VMM). This is because, at the time of this writing, neither program has a documented interface for debugging early enough in the VM boot process for the requirements of boot code malware analysis.</p>
<p class="indent">At the time of publication, Microsoft Hyper-V is the only virtualization software that can support VMs with Secure Boot enabled, which may be one reason no debugging interface is provided for the early stages of the boot process. We’ll look more deeply at Secure Boot technology and its vulnerabilities in <a href="ch17.xhtml#ch17">Chapter 17</a>. We mention these two programs here because they are used extensively in malware analysis, but their lack of early boot process debugging interfaces is the main reason we prefer the VMware Workstation for debugging malicious bootstrap code.</p>
<h3 class="h3" id="ch09lev1sec4"><strong>Conclusion</strong></h3>
<p class="noindent">In this chapter, we demonstrated how to debug bootkit MBR and VBR code using the Bochs emulator and VMware Workstation. These techniques for dynamic analysis are useful to have in your arsenal when you need to take a deeper look inside malicious bootstrap code. They complement methods you might use in static analysis and help answer questions that static analysis can’t.</p>
<p class="indent">We’ll use these tools and methods again in <a href="ch11.xhtml#ch11">Chapter 11</a> to analyze the Rovnix bootkit, whose architecture and functionality is too elaborate for static analysis methods to be effective.</p>
<h3 class="h3" id="ch09lev1sec5"><strong>Exercises</strong></h3>
<p class="noindent">We’ve provided a series of exercises for you to test out the skills you learned in this chapter. You’ll construct a Bochs image of a PC from an MBR, a VBR/IPL, and a New Technology File System (NTFS) partition <span epub:type="pagebreak" id="page_131"/>and then perform dynamic analysis using the IDA Pro frontend for Bochs. First, you need to download the following resources at <em><a href="https://nostarch.com/rootkits/">https://nostarch.com/rootkits/</a></em>.</p>
<p class="hangt"><strong><em>mbr.mbr</em></strong> A binary file containing an MBR</p>
<p class="hang"><strong><em>partition0.data</em></strong> An NTFS partition image, containing a VBR and an IPL</p>
<p class="hangb"><strong><em>bochs.bochsrc</em></strong> The Bochs configuration file</p>
<p class="indent">You’ll also need the IDA Pro disassembler, a Python interpreter, and the Bochs emulator. Using these tools and the information covered in this chapter, you should be able to complete the following exercises:</p>
<ol>
<li class="noindent">Create a Bochs image and adjust the values in the provided template configuration file <em>bochs.bochsrc</em> so it matches <a href="ch09.xhtml#ch09list01">Listing 9-1</a>. Use the <code>bximage</code> tool as described in “<a href="ch09.xhtml#ch09lev3sec2">Creating the Disk Image</a>” on <a href="ch09.xhtml#page_118">page 118</a> to create a 10MB flat image. Then store the image in a file.</li>
<li class="noindent">Edit the <code>ata0-master</code> option in the template configuration file to use the image in exercise 1. Use the parameters provided in <a href="ch09.xhtml#ch09list01">Listing 9-1</a>.</li>
<li class="noindent">With your Bochs image ready, write the MBR and VBR bootkit components onto it. First, open the <em>mbr.mbr</em> file in IDA Pro and analyze it. Observe that the code of the MBR is encrypted. Locate the decryption routine and describe its algorithm.</li>
<li class="noindent">Analyze the MBR’s partition table and try to answer the following questions: How many partitions are there? Which one is the active partition? Where is this active partition located on the hard drive? What is its offset from the beginning of the hard drive and its size in sectors?</li>
<li class="noindent">After locating the active partition, write the <em>mbr.mbr</em> file onto the Bochs image using the Python script in <a href="ch09.xhtml#ch09list02">Listing 9-2</a>. Write the <em>partition0.data</em> file onto the Bochs image at the offset found at the previous exercise using the Python script in <a href="ch09.xhtml#ch09list03">Listing 9-3</a>. After completing this task, you’ll have an infected Bochs image that is ready to be emulated.</li>
<li class="noindent">Launch the Bochs emulator with the newly edited <em>bochs.bochsrc</em> configuration, using the IDA Pro frontend described in “<a href="ch09.xhtml#ch09lev2sec5">Combining Bochs with IDA</a>” on <a href="ch09.xhtml#page_123">page 123</a>. The IDA Pro debugger should break at execution. Set a breakpoint at the address 0000:7c00h, which corresponds to the address where the MBR code will be loaded.</li>
<li class="noindent">When the breakpoint at address 0000:7c00h is hit, check that the MBR’s code is still encrypted. Set the breakpoint on the decryption routine identified earlier and resume execution. When the decryption routine breakpoint is hit, trace it until all the MBR’s code is completely decrypted. Dump the decrypted MBR into a file for further static analysis. (Refer to <a href="ch08.xhtml#ch08">Chapter 8</a> for MBR static analysis techniques.)<span epub:type="pagebreak" id="page_132"/></li>
</ol>
</body></html>