- en: '6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DATA
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter is all about data: reading it, writing it, visualizing it, and
    analyzing it. We’ll begin with a discussion of input and output using Racket ports
    (an essential tool we’ll use throughout this chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: I/O, I/O, It’s Off to Work We Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Data is transferred in Racket via ports: data flows into an input port and
    out of output ports. The general process of transferring data to or from an external
    source (such a text file or database server) is referred to as *I/O*. Let’s look
    at some examples of ports.'
  prefs: []
  type: TYPE_NORMAL
- en: '***File I/O Ports***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ports can be used for writing and reading data to a file, as the following dialog
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we attempt to open a port to a file that already exists, we get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The default mode of operation for `open-output-file` is to create a new file.
    Since we can’t create a new file twice, we need to declare how we intend to handle
    an existing file. This is managed via the `#:exists` keyword: we can append to
    the existing file by specifying ’`append` as its value, blow away the file and
    create a new file with ’`replace`, or keep the file but delete the contents with
    ’`truncate` (the default for value for `#:exists` is ’`error`, which means to
    generate an error if the file exists). We exercise a few of these options below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the end of the file is reached, `read-line` returns an end of file object;
    this prints as `#<eof>` but is defined as `eof` in Racket. This value can be tested
    for with the `eof-object?` predicate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every time a port is opened, you must remember to close it when the data transfer
    is complete. The closing can be performed automatically by using either `call-with-output-file`
    or `call-with-input-file` (depending on which way the data is flowing). These
    procedures work by supplying them with a function that does the actual data transfer.
    Here are some examples using this approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ll explore file ports in greater detail a bit later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '***String Ports***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ports can be opened against strings. This can be handy when trying to build
    a string where different components of the string will be appended at various
    times within a procedure. We’ll put string ports to good use in [Chapter 10](ch10.xhtml)
    when we build string representations of algebraic expressions. Some simple examples
    are provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unlike file ports, string ports don’t have to be explicitly closed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Computer-to-Computer Ports***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ports can be set up to allow two computers to communicate with each other. This
    type of communication uses the TCP/IP protocol. To establish the connections,
    the first computer (called the *server*) establishes itself as a listener with
    the `tcp-listen` command. This command accepts an unsigned integer as a port number
    (this is a TCP/IP port number). Note that a Racket port is a different entity
    from the TCP port specified by the port number. The server then calls `tcp-accept`,
    which returns two values—an input port and an output port—to permit two-way communication
    between the computers. The following session illustrates setting up a server and
    the server waiting for a query from a client computer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Computer 1** – The Server'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The string `"Hello there!"` is sent from the client. This is the result of executing
    the line `(read-line comp1-in)`, after which the server responds with `"Got it,
    bro!"`.
  prefs: []
  type: TYPE_NORMAL
- en: The client establishes its communication link by a using `tcp-connect`. The
    `tcp-connect` command takes the server computer name and the port number established
    by the server as arguments. It then initiates the dialog by sending `(displayln
    "Hello there!\n" comp2-out)` over the output port and waiting for a response from
    the server with `(read-line comp2-in)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Computer 2** – The Client'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is just a simple example; there are of course a number of nuances to setting
    up successful communication channels between computers. Consult the Racket Documentation
    for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve explored ports, let’s see how we can use them to enhance our
    security. No, not computer security. In this section, we’ll take a look at a type
    of security that virtually everyone is interested in: money. In particular we’ll
    be exploring securities such as stocks and bonds. The specific data we’re going
    to look at is price over time. There are a number of ways to look at prices: stock
    prices of individual corporations, average prices over an industry or group of
    institutions, or prices of index funds.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-1](ch06.xhtml#ch6tab1) lists the various entities we’ll be investigating.
    In the remainder of the chapter, we’ll refer to these entities as *assets*. The
    Symbol column indicates the stock market symbol that’s used to look up price information.
    Definitions for entries in the Type column are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Corp** An individual corporation. Most of these should be reasonably familiar.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index** A market index—just an indicator and not something you actually invest
    in. The Dow Jones Industrial Average is the weighted average consisting of 30
    large publicly traded institutions. The S&P 500 (Standard and Poor’s 500) is similar
    but consists of 500 large publicly traded institutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index Fund** An index fund, unlike an index, *can* be invested in. An index
    fund is typically composed of some mix of stocks or bonds. The Vanguard Total
    Bond Market fund is composed of a mix of long-term and short-term and both corporate
    and government bonds. The idea of index funds is that investing in a range of
    institutions minimized risk since the poor performance of one investment will
    be mitigated when averaged in with the remaining investments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1**: A Selection of Securities'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Symbol** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Amazon | AMZN | Corp |'
  prefs: []
  type: TYPE_TB
- en: '| Apple | AAPL | Corp |'
  prefs: []
  type: TYPE_TB
- en: '| Bank of America | BAC | Corp |'
  prefs: []
  type: TYPE_TB
- en: '| Dow Jones | ^DJI | Index |'
  prefs: []
  type: TYPE_TB
- en: '| ExxonMobil | XOM | Corp |'
  prefs: []
  type: TYPE_TB
- en: '| Ford | F | Corp |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft | MSFT | Corp |'
  prefs: []
  type: TYPE_TB
- en: '| S&P 500 | ^GSPC | Index |'
  prefs: []
  type: TYPE_TB
- en: '| Vanguard Total Bond Market | VBMFX | Index Fund |'
  prefs: []
  type: TYPE_TB
- en: The data we’re going to examine was downloaded from the Yahoo! Finance website.
    This data is in the form of *comma-separated value (CSV)* files. What this means
    is that each value in the file is separated by a comma, and each record occupies
    a single line. Here’s an example from a file containing the Dow Jones Industrial
    Average for the first few days of the year 2007 (we’ve lopped off a few decimal
    places from the prices to keep the listing from extending off the page).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first row gives a short description of each data value in the succeeding
    rows. [Table 6-2](ch06.xhtml#ch6tab2) gives a more detailed description.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-2**: CSV File Format'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Date | Date of transactions (year-month-day) |'
  prefs: []
  type: TYPE_TB
- en: '| Open | Price when market opened |'
  prefs: []
  type: TYPE_TB
- en: '| High | Highest traded price for the day |'
  prefs: []
  type: TYPE_TB
- en: '| Low | Lowest traded price for the day |'
  prefs: []
  type: TYPE_TB
- en: '| Close | Price when the market closed |'
  prefs: []
  type: TYPE_TB
- en: '| Adj Close | Adjusted closing price |'
  prefs: []
  type: TYPE_TB
- en: '| Volume | Number of trades for the day |'
  prefs: []
  type: TYPE_TB
- en: The adjusted close reflects any adjustments based on dividends or stock splits
    (the term *split* means if you owned a single stock share selling for $100, you’d
    own two shares at $50 after the split).
  prefs: []
  type: TYPE_NORMAL
- en: Getting Data into Racket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first order of business is to get the CSV data into a form that will be
    useful within Racket. We’ll use a `hist` structure to contain the data for a single
    record from the CSV file. This struct has the following form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The field names should need no explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The following function will take a file port and return a `hist` structure populated
    with the data values from the current import record (the next unread line in the
    file) with each price entry converted to a numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve taken the opportunity to exercise another of Racket’s hidden treasures,
    pattern matching. *Pattern matching* uses the `match` form ➊ included in the *racket/match*
    library (not to worry; this library is automatically included with the *racket*
    library).
  prefs: []
  type: TYPE_NORMAL
- en: 'A `match` expression looks a bit like a `cond` expression, but instead of having
    to use a complex Boolean expression, we simply provide the data structure we want
    to match against. It’s possible to use a number of different structures as patterns
    to match against, including literal values, but we’ll simply use a list for this
    exercise ➋. The split `rec` values are bound to the identifiers `date`, `open`,
    and so on. If a match is found, then a `hist` structure is returned ➌. A single
    underscore (`_`) serves as a wildcard that matches anything ➍ (for example if
    the number of values in the split list did not match the number of items in the
    binding list, an `error` exception would be raised). With this in place, the following
    code reads in a few values (in the following code segments, the reader should
    substitute their own data path where paths starting with `StockHistory/` are used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first `hist` structure produced contains false values because the header
    strings in the first line of the CSV file couldn’t be converted to numbers by
    `import-record`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For display purposes, we often want to uniformly format the history records
    to display each value as a string right-aligned and with a certain precision.
    The following function performs this service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `width` parameter specifies the overall width of each value, and the `prec`
    parameter specifies the precision. Applying this function to the first few rows
    of the ExxonMobil data results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that some of the output values are padded with spaces because the numbers
    are less than six characters wide when formatted with two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll sometimes want to display the data in tabular form, we’ll take
    advantage of the `text-table` package. Unfortunately, this package isn’t included
    with the default Racket install, so it’ll need to be installed via either Racket’s
    package manager or the `raco` command line tool (see [Chapter 2](ch02.xhtml) on
    `infix` for an example of how to install packages). Once the `text-table` package
    is installed, the following command must be included in your definition file or
    executed in the interactive window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `text-table` package defines the `table->string` function, which takes a
    list of lists, where each sublist represents a row in the table. Here’s a simple
    example of how it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The data that we’re going to be querying against has a file structure similar
    to the one shown in [Figure 6-1](ch06.xhtml#ch6fig1). The files have records (one
    record for each day, month, or week) for years 1980 through the end of 2016 (where
    available).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: Stock history file structure*'
  prefs: []
  type: TYPE_NORMAL
- en: The following code will display rows of stock history when given the stock symbol
    and time period (either `"Daily"`, `"Monthly"`, or `"Weekly"`—files for each period
    are stored in a corresponding folder). In addition, a filter must be specified.
    The filter is a function that accepts a `hist` structure and returns `#t` or `#f`
    depending on what’s being searched for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the input file is opened and we’ve skipped past the header line, the code
    line `(let* ([recs` ➊ binds two variables: `recs` and `tbl-list` ➑. Note that
    `recs` is used to initialize `tbl-list` ➑, which simply adds a header for the
    data contained in `recs`. Then the final output is generated ➒.'
  prefs: []
  type: TYPE_NORMAL
- en: In the main body of code, we set up a function called `loop` ➋ to recursively
    extract the data from the input file (the `reverse` just prior to this is needed
    since the recursive call builds up the data in the reverse order). Note that `rec-list`
    is initialized with an empty list. The identifier `rec` ➌ is populated with a
    single row from the input file. Once the end of the file is reached, we output
    the compiled `rec-list`, but until then we use the filter to search for records
    that meet our criteria ➍. When such a record is found, we bind a local version
    of `rec` using our previously defined `format-rec` code ➎. Since we’re in a `let*`
    form, we bind a new local version of `rec` on the next line with data extracted
    from the imported record. Having done this, we add this to the previously imported
    data ➏ and recursively call `loop`. If the filter’s criteria are not met, we simply
    trigger the reading of the next row of data from the import file with the existing
    data ➐.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the year 2008 when things started to go horribly wrong
    in the financial sector. (The `substring` function is used to pull the year out
    of the date field and display only records where the year is equal to 2008.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: During that year, the Dow swung from a high of 13,279.54 in January to a low
    of 7,449.38 in November. A swing of 5,380 points, or a 44 percent drop!
  prefs: []
  type: TYPE_NORMAL
- en: A year earlier, Microsoft had been averaging around $30 a share, but it dropped
    below $19 a few times in 2008\. Let’s see when that happened.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A Database Detour
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section is entirely optional since the rest of the chapter isn’t dependent
    on the ideas presented here. But we do want to present some information on random
    file access that could be useful in various scenarios. *Random file access* is
    a key component for efficient data queries. In particular, random file access
    is a critical component in any database. A database is mainly just a predefined
    collection of tables, with each table potentially containing multiple records.
    So far, to locate a particular record in a table, we’ve scanned a file, record
    by record, until the desired entry was located. On average half the records have
    to be checked, and in the worst case, all the records are checked. This is clearly
    not very efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, we’re looking for a particular date, and the fact that the records
    are in date order suggests that a binary search might be applicable (if you don’t
    know what a binary search is, we’ll delve into the details shortly); but there
    is a problem. In CSV files, the records are packed together with a variable number
    of characters in each record, so there is no way to accurately get positioned
    on a particular record without reading through the file starting from the beginning.
    The key is to allocate slots for each record where each slot is a fixed size,
    but large enough to hold the largest record. To facilitate this, we’ll define
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This function scans the input file to determine the number of records in the
    file and the maximum record size.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the information returned from `file-info`, we can construct an appropriately
    formatted data file. This file reserves the first slot to hold the information
    returned from `file-info` since this will be useful when we get around to actually
    searching the file. The remaining slots are populated with values from the source
    file by using the `file-position` function to set the location the values are
    written to (by calling `display`). Unused space at the end of a record is filled
    with zero (0) bytes. To actually create the file, we define a function called
    `csv->db`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a data file in the same folder as the source file, with
    the same name, except that the output file ➊ has *.db* as a file extension instead
    of *.csv*. Next, we set the file position to the end of the file ➋ and write a
    dummy record ➌. This is an efficiency step to keep the operating system from constantly
    enlarging the file every time a record is written. We write the number of records
    and slot size to the first record in the file ➍ ➎. For each record in the input
    file, we then position the output file pointer ➏ and write out the record ➐.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having thus created a searchable data file, we can now create a routine to
    perform a binary search to efficiently find a record for a particular date. (For
    more detailed information on binary searches in general, see the Wikipedia article:
    [*http://en.wikipedia.org/wiki/Binary_search_algorithm*](http://en.wikipedia.org/wiki/Binary_search_algorithm).)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we perform some basic initialization ➊ ➋. After opening the input file,
    we read the first record (which contains the number of records and slot size)
    and bind `recs` and `slot-size` to the appropriate values. Next, we define a couple
    of helper functions to simplify retrieving data for the current record ➌ ➍. The
    remainder of the code is a straightforward implementation of a binary search routine,
    the main body consisting of a loop (via recursive function `loop`). The search
    begins by testing whether any records remain to be checked ➎. If `(> min max)`
    is true, all records have been checked and no match has been found, so the function
    returns `#f`. Next, we compare the date of the middle element of the file with
    the target date ➏. If the target date matches the middle element, the current
    record is returned ➑. If the target date is less than or greater than the date
    of the current element, the search continues by narrowing down the range of the
    file by resetting `min` ➏ and `max` ➐ as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We test our creation by first forming a searchable data file for Microsoft
    stock prices with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we’re then interested in retrieving the stock price record for March 13,
    1992, we do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The Microsoft file has 7,768 records. On average, a linear search would have
    to examine 3,884 records. The worst-case performance of a binary search is given
    by the following expression, where *t* is the number of checks that need to be
    performed and *n* is the number of records:'
  prefs: []
  type: TYPE_NORMAL
- en: '*t* = ⌊log[2](n + 1)⌋'
  prefs: []
  type: TYPE_NORMAL
- en: This means that searching the Microsoft data would only require the following
    checks. Examining 12 records is a lot better than examining 3,884.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0158-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data Visualization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A picture is worth a thousand dollars, er . . . a thousand words. So far we’ve
    been looking at data. Now we want to look at information. The difference is this:
    data is just a raw assemblage of numbers, dates, and strings; information says
    how these things are related. Just perusing a list of numbers doesn’t provide
    much insight into their meaning, but often a visual representation invokes an
    epiphany. In light of this, we turn to the topic of data visualization. In this
    section we’ll look at financial data in two different ways: value over time and
    frequency analysis via histograms.'
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that we have everything we need, we start from scratch with the following
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Most of this should be self-explanatory. As a reminder, the `text-table` package
    isn’t part of the default Racket setup (see [“Getting Data into Racket” on page
    150](ch06.xhtml#ch00lev1sec_36) for more info). We use `data-path` to keep from
    hardcoding the file paths in the body of various functions. To differentiate multiple
    assets on plots, they’re assigned unique colors in `symbol-color` and line styles
    in `symbol-style`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll again make use of `import-record`, which is reproduced here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: While this function extracts everything in the record, for the remainder of
    the chapter we’ll primarily be interested in the date and closing price.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll be plotting time-varying values, we need to convert the date string
    from each record into a numeric value. We can do this with the following vector
    and function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `month-days` vector provides the number of elapsed days in the year for
    the first day of any given month (the month number is the index; for example,
    February is represented by index 2). For example the entry with index 2 is 31,
    indicating that on February 1, 31 days have elapsed. Months after February have
    an extra quarter-day to account for leap years. The date conversion happens in
    `date->number` where the year forms the integer portion of the date, and the month
    and day provide the fractional portion. The fact that February can have 28 or
    29 days is handled by an approximation that should be sufficient for our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '***Plotting for Success***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you saw in the [Chapter 4](ch04.xhtml), Racket plots a sequence of line
    segments by using a `lines` form that takes a list of vectors as its argument.
    Each vector specifies the *x* (date) and *y* (close price) coordinates of a segment
    end point. To construct this list, we use the `get-coords` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As with other examples, this function takes the stock symbol, time period type,
    and a filter function as arguments. Since the assets we’re examining can have
    widely differing values, to enable showing them on the same plot we provide the
    ability to normalize the values with an extra parameter. What this means is that
    instead of plotting the actual value, we plot the ratio of the first value in
    the time period to the actual value ➊. This way all the assets start out with
    a value of 1, but we still see how the relative values vary over time. A few examples
    will make this clear shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The routine that does the plotting is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This time we provide it with a list of stock symbols (to allow multiple assets
    to be plotted at the same time), a time period type, and a filter function as
    arguments. We also have the option to specify whether or not the plot normalizes
    the data with the optional `normalize` parameter, which defaults to `#f`. Since
    plotted values can occur on just about any portion of the plot, we allow the user
    to specify where the legend is positioned with the optional `anchor` parameter.
    In addition we allow the user to override the default range of *y* values.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re primarily going to be plotting data for some range of years or dates,
    we’ll define a couple of function factories that create query functions by specifying
    the range of dates we’re interested in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Having established the prerequisites, we’re ready to generate some plots. Let’s
    begin by plotting Dow Jones data for 2007 and 2008 (see [Figure 6-2](ch06.xhtml#ch6fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/06fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: Dow Jones daily close price 2007–2008*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can actually *see* the precipitous drop that occurred in October of 2008\.
    Next, let’s look at a few other institutions to see how they fared (see [Figure
    6-3](ch06.xhtml#ch6fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/06fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: Multiple daily close prices*'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the Dow numbers are so large, they’ve swamped everybody else.
    Now let’s see what happens when we normalize the numbers (see [Figure 6-4](ch06.xhtml#ch6fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/06fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: Normalized daily close prices*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s clear that the Dow and S&P 500 general market indices track fairly close
    to each other. Apple is all over the map. The bond fund stayed steady throughout
    the mayhem.
  prefs: []
  type: TYPE_NORMAL
- en: What have we learned? Well, it would be foolish to make too many assumptions
    based on a few plots. It’s fairly clear, though, that at least for this time period,
    bonds barely wiggled, the market as a whole (represented by the index indicators
    S&P 500 and the Dow) had some turbulence, but not as much as Apple.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a longer view and see what comes up in [Figure 6-5](ch06.xhtml#ch6fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/p0165-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: Monthly close prices 1981–2016*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So around 2005-ish, Apple went off the chart (more about that a bit latter).
    Let’s examine ExxonMobil in a bit more detail. Since this is a normalized chart,
    we’re seeing the relative difference in the prices; this means that at the end
    of 2016, ExxonMobil stock was worth roughly 18 times what it was worth at the
    beginning of 1981\. Sounds like a lot, but is it really? We can get some idea
    of the average annual return this represents by using the compound interest formula
    given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0165-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this formula, *V* is the current value, *P* is the initial principal, *i*
    is the annual interest rate, *n* is the number of compounding periods per year
    (we’re going to assume monthly compounding, so this will be 12), and *t* is the
    number of periods (so *nt* is 12 times the number of years). We want to know the
    annual interest *i*, so after a bit of algebra (we won’t bore you with the details),
    we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0165-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following function will calculate this value for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So over 35 years, $1 invested in ExxonMobil stock would yield an interest rate
    of . . .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Or around 8 percent, which is quite respectable given that ExxonMobil also pays
    quarterly dividends, which sweetens the pot even more.
  prefs: []
  type: TYPE_NORMAL
- en: But what about that wild stallion, Apple? Well, let’s adjust our range a bit
    and see what develops.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/06fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: Monthly close prices up to $300*'
  prefs: []
  type: TYPE_NORMAL
- en: Wow, a dollar invested in 1981 (after a long dry spell) would be worth about
    $225 at the end of 2016\. Who knew? Let’s see what the effective interest rate
    is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost 16 percent—not too shabby. Is Apple a good investment? Well, any (honest)
    financial advisor will tell you this repeatedly: past performance is not a guarantee
    of future results.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Lumping Things Together***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One thing besides the outrageous return on investment (ROI) of Apple stands
    out: its value is very erratic. Let’s look at ExxonMobil and Apple during the
    period of time before things got really crazy in 2008 (see [Figure 6-7](ch06.xhtml#ch6fig7)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/06fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: Apple and ExxonMobil before the crash*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s clear that even over this short interval of time, the value of Apple from
    one day to the next would not be easy to predict. If someone isn’t interested
    in the specific value of a stock, but rather how variable it is, one way to visualize
    the variability is with a histogram. A *histogram* represents data by showing
    how often values fall into certain ranges. We call these ranges *bins*. To aid
    in our analysis, we’ll supplement each histogram with a table that gives the range
    of values and counts for each bin.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we define a function that extracts a particular data field for an
    investment given the stock symbol, period, filter function, and the corresponding
    `hist` structure field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For example if we wanted the maximum stock cost for Microsoft in 1999 (a pretty
    good year for Microsoft) in the monthly data, we could get it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The following function compiles the data (a list of values) and populates bins
    with the proper count of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This function first sets an overall range of values that are 60 percent below
    and 60 percent above the average value. Within this range, data values will be
    compiled into the `bin` vector. At the end of the process, the function returns
    the overall minimum and maximum range of the bins as well as categorized values
    contained in `bin`. Each vector in `bin` contains the bin index and the number
    of values in the bin (it has to be formatted this way to work with Racket’s `discrete-histogram`
    function).
  prefs: []
  type: TYPE_NORMAL
- en: To display the data in tabular form, we define `bin-table`, which will display
    the bin index along with the range of values for the bin and the number of values
    in each bin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: After we’ve laid the groundwork, creating a function to generate the output
    is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see what this tells us about Apple and ExxonMobil (see [Figures 6-8](ch06.xhtml#ch6fig8)
    and [6-9](ch06.xhtml#ch6fig9)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/06fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: Apple histogram*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/06fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: ExxonMobil histogram*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s clear from the histograms that values for Apple are dispersed over a wider
    range of values than the data for ExxonMobil for the same time period. This higher
    volatility is the price Apple investors pay for the possibility of getting larger
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: A Bit of Statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We demonstrated in the previous section that the old truism that a picture is
    worth a thousand words makes a bit of sense, at least in terms of analyzing investment
    data. But it’s also true that a single number is worth, well, at least one picture.
    So far our analysis has primarily been qualitative, where we used a number of
    techniques to visualize our data. We now turn to a couple of standard statistical
    tools that are widely used for quantitative analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '***Standard Deviation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the last section, we looked at using histograms to get some idea of how
    widely dispersed stock values were over some period of time. This type of information
    can be summed up in a single number called the *standard deviation*. For a given
    set of numbers, the standard deviation indicates how much individual numbers deviate
    from the overall average of the set. You might think of it as the average amount
    of deviation. Standard deviation is defined by the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0172-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this equation, *n* is the number of values, the Greek letter mu (*μ*) represents
    the mean or average of all the data values, and the *x*[*i*] represents the individual
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closely related to standard deviation is the statistical concept of *variance*,
    which is simply the square of the standard deviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0173-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We shall see a bit later that variance is useful in regression analysis where
    we attempt to determine how data is trending.
  prefs: []
  type: TYPE_NORMAL
- en: 'We wrap the standard deviation formula in a Racket function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can now compute numerical values with which we can analyze the deviation
    of different assets. Let’s take a look at the data we generated histograms for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This *seems* to indicate that Apple actually had less deviation than ExxonMobil.
    This is where the proper interpretation of data is crucial. The histogram data
    showed us the spread of data within ± 60% of the *average* value. To make sense
    of the deviation data, let’s get the average value of these stocks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: From this we can now see that Apple typically deviated almost 24 percent from
    its average price during that period whereas ExxonMobil only deviated about 7.5
    percent.
  prefs: []
  type: TYPE_NORMAL
- en: While here we’re strictly looking at the standard deviation of the close price,
    this is *not* how deviation is normally evaluated in a financial sense. What is
    of most interest in that regard is deviation of *returns*. A stock that has a
    steady 10 percent annual return would clearly have some price deviation, but it
    would have almost no deviation based on returns. Another consideration is that
    change in stock price alone is not necessarily an indication of returns since
    dividends (for those stocks that pay dividends) come into play as well.
  prefs: []
  type: TYPE_NORMAL
- en: '***Regression***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In our analysis of various financial assets, we’ve mentioned the adage that
    past performance is not a guarantee of future results, which is true, but past
    performance might suggest future results. Given a disparate set of data points,
    it’s often of interest to determine whether or not they suggest a trend. The statistical
    tool called *regression analysis* attempts to make just such a determination.
    Regression analysis fits a straight line to a set of data points (since we’re
    only fitting our data to a straight line, this is technically called *linear regression*)
    where *x* is called the *independent predictor* or *predictor variable*, and *y*
    is called the *dependent response*. The desired outcome is this *regression* or
    *prediction* line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *a + bx*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that given this line and some *x*-value, we can compute an estimated
    value for *y*. The parameters *a* and *b* are defined in such a way as to minimize
    the total distance of the *y* data values from the line. Specifically, if (*x*[*i*],
    *y*[*i*]) are the actual data points, we let *ŷ*[*i*] = *a* + *bx*[*i*] (this
    is the estimated value of *y* at *x*[*i*]), in which case regression analysis
    seeks to minimize the *sum of squares errors* given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06eqa01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If ![Image](../images/x-bar.jpg) is the mean, or average, of all the *x* values
    and ![Image](../images/y-bar.jpg) is the mean of all the *y* values, it can be
    shown that the *a* and *b* parameters of the regression line are given by the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0174-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The formidable-looking Equation (6.1) is actually the ratio of two simpler
    formulas: the *covariance* of *x* and *y* and the variance of *x*. We’ve already
    seen that the variance of *x* is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0174-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The covariance of *x* and *y* is defined by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0174-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Covariance is a measure of the joint variability of two random variables (in
    our case the *x*[*i*] and *y*[*i*]). We make use of the following slightly altered
    form of these last two equations, along with a couple of others, to develop a
    method to determine how well our regression line actually fits the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0174-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We see that SS[*xx*] is just a slightly tweaked version of ![Image](../images/p174.jpg)
    and SS[*xy*] is likewise a tweaked version of Cov(*x*, *y*). The last equation,
    sum of squares regression, represents the sum of the squares of the distance of
    the estimated *ŷ*’s from the mean of the *y*-values to the regression line (the
    line that minimizes this distance will give us the best fit to the data). We saw
    in Equation (6.1) that the slope of the regression line is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06eqa03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But the following can also be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0175-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last equation is called the *squared correlation* or *coefficient of determination*.
    This number can vary between 0 and 1\. A value of 1 indicates the data points
    perfectly fit the regression line, and a value of 0 indicates there’s no correlation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The regression line parameters can be computed with the following Racket function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is a straightforward adaption of Equations (6.1) and (6.2). Let’s see what
    this tells us about Bank of America when it was in its downward spiral during
    the 2008 financial crisis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The second value is the slope of the regression line, which indicates that during
    that period, it was losing an average of $27 per year (over half its value in
    July of 2007). Ouch.
  prefs: []
  type: TYPE_NORMAL
- en: We now define a plot routine that accepts a single asset symbol, but that plots
    the data points instead of lines and includes the corresponding regression line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can see Bank of America’s distress in graphic detail in [Figure 6-10](ch06.xhtml#ch6fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/06fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: Regression line plotted on Bank of America data*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine how well the regression line fits the data, we define a `correlation`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is also just a direct implementation of the definition of *R*² given above.
    With this we can test the fit of the Bank of America least squares line to the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This indicates a fairly good fit. But in many cases the data doesn’t provide
    a good fit with a straight line. For instance if we include the start of the recovery
    phase, we wind up with a plot such as the following in [Figure 6-11](ch06.xhtml#ch6fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](../images/06fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: Poorly fitting regression line*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And this indicates some degree of correlation, but not as good as what we had
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we looked at various ways of accessing and analyzing data using
    Racket and DrRacket. We began by introducing the mechanics of how to import and
    export data to and from Racket ports. Once we had mastered this bit of technology,
    we leveraged it to look at securities in the form of raw historical stock market
    values. We then took a slight detour and explored binary search using random file
    access. Having defined a mechanism to access and parse our stock market data,
    we then looked at qualitative methods to analyze our data using various visualization
    techniques. Finally, we bit the bullet and introduced a bit of mathematics, which
    allowed us to do some statistical quantitative analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we see how we can use some sophisticated search algorithms to solve
    some classical problems in recreational mathematics.
  prefs: []
  type: TYPE_NORMAL
