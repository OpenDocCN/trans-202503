- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FIRST
    DASH APP</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter you’ll build your first Dash app. We’ll analyze the number of
    Twitter likes received by 16 chosen celebrities since 2011\. You can download
    the data with the book’s resources at [*https://<wbr>nostarch<wbr>.com<wbr>/python<wbr>-dash*](https://nostarch.com/python-dash).
    The type of analysis we’ll do is common in the field of social media analytics,
    typically used to better understand audience behavior, the effectiveness of posts,
    and the overall performance of an account.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first dashboard will plot the number of likes per tweet. Once you master
    this simple plotting process with Dash, you’ll be able to scale your skills to
    plot bigger and more complex data in other areas: Instagram post views, Facebook
    profile visits, LinkedIn post click-through rates, and YouTube video performance.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter should give you sufficient knowledge of Dash to create your own
    dashboard app. You’ll learn how to incorporate data into your app, manage numerous
    dashboard app components, build basic charts such as line charts, and add interactive
    capabilities to your dashboard through the callback decorator. First, let’s download
    the code and run the app to see what it does.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up the Project</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open PyCharm, create a new project, and call it *my-first-app* (the project
    name should be the suffix text after the last backslash in the Location field
    of the New Project dialog). Set up your virtual environment using the standard
    Virtualenv.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*The code in this chapter assumes you’re using a Python IDE, such as PyCharm.
    If you don’t have an IDE installed and a virtual environment set, refer back to
    [Chapter 2](chapter2.xhtml) and complete your Python setup. If you’re using a
    different coding environment, just adapt the instructions here to your environment.
    The code in this chapter also requires Python 3.6 or higher.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to download this chapter’s dashboard app files into your project
    folder. Instead of cloning the repository as we did in [Chapter 2](chapter2.xhtml),
    we’ll download the ZIP file directly. It’s worth trying various ways to set up
    a project because you’ll probably stumble upon some projects that are not directly
    available as Git repositories. To use the ZIP file, go to the GitHub repository
    at [*https://<wbr>github<wbr>.com<wbr>/DashBookProject<wbr>/Plotly<wbr>-Dash*](https://github.com/DashBookProject/Plotly-Dash),
    click **Code**, and then click **Download ZIP**, as shown in [Figure 4-1](chapter4.xhtml#fig4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: Downloading the
    app code from GitHub</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the *Plotly-Dash-master.zip* file on your computer, open it and
    go into the *[Chapter-4](chapter4.xhtml)* folder. Copy all the files from that
    folder into your recently created *my-first-app* project folder. The project folder
    should have files in the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">– my-first-app</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">|––assets</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      ––mystyles.css</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">|––tweets.csv</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">|––twitter_app.py</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The *assets* folder will hold the CSS script. The *tweets.csv* file holds the
    data we’ll use, and *twitter_app.py* is the main app file we’ll use to run the
    app.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now install the necessary libraries in our virtual environment. Go to
    the Terminal tab in the bottom part of the PyCharm window, shown in [Figure 4-2](chapter4.xhtml#fig4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: Opening the terminal
    in PyCharm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and execute the following lines of code to install pandas and Dash (the
    Plotly package is automatically installed with Dash, so there is no need to install
    Plotly, and the NumPy package is automatically installed with pandas):'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">pip
    install pandas</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">pip
    install dash</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'To check that the libraries are installed correctly, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">pip
    list</samp>
  prefs: []
  type: TYPE_NORMAL
- en: This will create a list of all the Python packages currently in your virtual
    environment. If they’re all listed, you can move on. Note that all dependencies
    of pandas and Dash will also be listed, so you might see many more libraries than
    just the two you installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open *twitter_app.py* inside PyCharm and run the script. You should see
    the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">* Serving Flask app "twitter_app"
    (lazy loading)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">* Environment: production</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">WARNING: This is a development
    server. Do not use it in a production deployment.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Use a production WSGI server instead.</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">* Debug mode: on</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Dash is running on</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">http://127.0.0.1:8050/</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The warning just reminds us that the app is in a development server and it is
    completely normal. To open your app, click the HTTP link or copy and paste it
    into your browser’s address bar.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You should now see your first Dash app, which should look like
    [Figure 4-3](chapter4.xhtml#fig4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: The Twitter Likes
    Analysis app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Have fun! Play around with your dashboard app. Change the dropdown values, click
    the links, click on the graph legend, and zoom in to a certain date range by holding
    down the mouse’s left-click button and dragging the mouse. See what information
    you can deduce.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a look at the code of the app. Most Dash apps have a similar
    code layout:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Import the necessary Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Read in the data.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Assign a stylesheet to describe how the app should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Build the app layout that will define how to display all the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Create the callbacks to enable interactivity between the app components.
  prefs: []
  type: TYPE_NORMAL
- en: Because Dash apps mostly follow this outline, we’ll go through the code in this
    order.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Importing the Libraries</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first look at the libraries we’ll use, shown in [Listing 4-1](chapter4.xhtml#List4-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import pandas as pd</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import plotly.express as px</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">from dash import Dash, dcc, html,
    Input, Output</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: The import section
    of</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We first import pandas to handle the data. We then import Plotly, a popular
    Python visualization library. There are two main ways to create graphs in Plotly.
    We’re using *Plotly Express*, a high-level interface for creating graphs in single
    function calls, with very few lines of code. It has enough features to allow you
    to build graphs seamlessly and quickly, and is the easier of the two to use for
    simpler apps.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative is *Plotly Graph Objects*, a low-level interface for creating
    graphs from the bottom up. When using Graph Objects, you need to define the data,
    layout, and, at times, frames, all of which make the graph-building process more
    involved. That said, its full set of features allows you to customize your graphs
    in ways that add much richness to them, so you might want to use Plotly Graph
    Objects once you’ve mastered Dash basics and you have more complicated graphs
    to build. We’ll use Plotly Express in most cases and revert to Graph Objects in
    more complex situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we import some Dash libraries to handle components and dependencies.
    *Components* are the building blocks that can be combined to create rich, complex
    interfaces for your users, such as dropdown menus, range sliders, and radio buttons.
    Dash comes bundled with two key component libraries maintained by Plotly: dash-html-components
    (HTML) and dash-core-components (DCC). The *dash-html-components* library contains
    structural elements such as headings and dividers that style and position elements
    on the page, while *dash-core-components* provides core functionality for your
    app, such as user input fields and figures.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Data Management</samp>
  prefs: []
  type: TYPE_NORMAL
- en: In this app, we’re using a CSV spreadsheet as our data source. To use the data,
    we need to read it into memory via pandas, but before that we have to *clean*
    the data. This means preparing the data for analysis and plotting by doing things
    like standardizing capitalization of strings and formats of time, stripping whitespace,
    and adding nulls for missing values. When the data is *dirty*, it’s often unorganized
    and might contain missing values. If you try to use dirty data, the plot may not
    work, the analysis is likely to be inaccurate, and you’ll find filtering difficult.
    Cleaning the data ensures that it is readable, presentable, and plottable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-2](chapter4.xhtml#List4-2) shows the data management section of
    the code.'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ <samp class="SANS_TheSansMonoCd_W5Regular_11">df =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">pd.read_csv("tweets.csv")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">df["name"] = pd.Series(df["name"]).str.lower()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">df["date_time"] = pd.to_datetime(df["date_time"])</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">df = (</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   df.groupby([df["date_time"].dt.date,
    "name"])[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      ["number_of_likes", "number_of_shares"]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   ]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   .mean()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   .astype(int)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">df = df.reset_index()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: The data management
    section of</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At ❶ we take the CSV spreadsheet and read it into a pandas DataFrame called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">df</samp>. The DataFrame at the
    beginning of a Dash app is commonly referred to as a *global DataFrame* and the
    data is a *global variable* (*global* means the object is declared outside a function,
    meaning it’s accessible throughout the app).
  prefs: []
  type: TYPE_NORMAL
- en: To clean the data, we change the strings of the celebrity <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    column to lowercase so that we can readily compare them, we convert the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">date_time</samp> column into a date recognizable
    by pandas, and we group the data by <samp class="SANS_TheSansMonoCd_W5Regular_11">date_time</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> so that each row
    has a unique date stamp and name. If we did not group the data this way, we would
    end up with multiple rows with the same date and name, which would create a messy
    line chart that’s impossible to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the data, add the following line of code to the script, right after
    <samp class="SANS_TheSansMonoCd_W5Regular_11">df</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">df.reset_index()</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(df.head())</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you run the script anew, you should see something like the following inside
    the Python terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">date_time</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_likes</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_shares</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">2010-01-06</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">selenagomez</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">278</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">695</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">2010-01-07</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jtimberlake</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">62</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">189</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">2010-01-07</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">selenagomez</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">201</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">630</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">2010-01-08</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">jtimberlake</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">27</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">107</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">2010-01-08</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">selenagomez</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">349</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">935</samp> |'
  prefs: []
  type: TYPE_TB
- en: As you can see, the result is a neat pandas DataFrame with rows of data that
    represent the average number of likes and shares per celebrity, per day.
  prefs: []
  type: TYPE_NORMAL
- en: It’s always a good practice to read in and prepare your data at the beginning
    of the app because reading data can be a memory-expensive task; by inserting the
    data at the beginning, you ensure that the app loads the data into memory only
    once and does not repeat this process every time a user interacts with the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Layout and Styling</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to manage the layout and styling of the app components, such
    as the title, graph, and dropdown menus. We’ll learn more about the components
    in “Dash Components” later in this chapter; here we’ll just focus on the layout
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In a Dash app, the *layout* refers to the alignment of the components within
    the app. The *style* refers to how the elements look, such as the color, size,
    spacing, and other properties (known in Dash as *props*). Styling the app allows
    for a more customized, professional presentation. Without styling, you could end
    up with an app like the one shown in [Figure 4-4](chapter4.xhtml#fig4-4), where
    the title is not centered, the dropdown field stretches over the whole page, and
    there is no space between the link and the dropdown above it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The Twitter Likes
    Analysis app without proper layout and styling</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Alignment</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Dash apps are web-based, so they use the standard language of web pages: HTML
    (HyperText Markup Language). Luckily, Dash includes the Dash HTML Components module,
    which converts Python to HTML, meaning we can use Python to write our HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most essential components of HTML is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>,
    short for *division*, which is simply a container for other elements and a way
    to group elements together. Every component we use in a Dash app will be contained
    inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>, and a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> can contain multiple components.
    We build the <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>, then style
    it to tell the web browser exactly where to position it and how much space it
    should take up.
  prefs: []
  type: TYPE_NORMAL
- en: Say we’re creating a dashboard app with three dropdown menus, represented by
    the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>, as
    in [Listing 4-3](chapter4.xhtml#List4-3).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div([</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.Div(dcc.Dropdown()),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.Div(dcc.Dropdown()),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.Div(dcc.Dropdown()),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">])</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: Example Div code
    (not part of the main app)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The line <samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout</samp> creates
    a layout for this Dash app. Everything related to the layout must be placed within
    <samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout</samp>. We then create
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> that contains three
    dropdown menus.
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> by default will take
    up the full width of the parent container, meaning it’s assumed to be one big
    cell that takes up the width of the page. As it is, the first <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>
    will appear in the top left and fill the whole page from left to right. The second
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp> will appear right
    below the first <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>
    and fill the whole width of the page as well, and so on with the third <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>.
    In other words, each <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    will take up the full width of the page and force neighboring elements onto a
    new line.
  prefs: []
  type: TYPE_NORMAL
- en: To best control how much space a <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    is allocated, we should define the web page as a grid of rows and columns and
    place each <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> within a specific
    cell inside that grid. We can quickly define rows and columns using a premade
    CSS stylesheet. CSS (Cascading Style Sheets) is another web language used to define
    how a page should be displayed. We put the stylesheet in an external file or call
    one from an online directory into our app. We’re using a stylesheet from [*https://<wbr>codepen<wbr>.io*](https://codepen.io).
    Written by Chris Parmer, the creator of Plotly Dash, the stylesheet is comprehensive
    and suitable to use for a basic Dash app. In [Listing 4-4](chapter4.xhtml#List4-4),
    we import the CSS. We also tell *twitter_app.py* to grab the CSS stylesheet from
    the web and incorporate it into the app, and we instantiate our app with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dash</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">stylesheets = ['</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">https://codepen.io/chriddyp/pen/bWLwgP.css']</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">app = Dash(__name__, external_stylesheets=stylesheets)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Importing a stylesheet
    into</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our CSS stylesheet describes the width and height of the columns and rows on
    the page using CSS classes. We just need to refer to these classes within our
    Dash code to place the <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    content in specific cells inside the grid.
  prefs: []
  type: TYPE_NORMAL
- en: First, we must assign the rows because the columns should be wrapped by rows.
    To do so, we set a string value <samp class="SANS_TheSansMonoCd_W5Regular_11">"row"</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">className</samp>. Let’s build
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> example in [Listing
    4-3](chapter4.xhtml#List4-3), assuming this code has imported the custom stylesheet;
    the new code is in bold (see [Listing 4-5](chapter4.xhtml#List4-5)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout = html.Div([</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.Div(dcc.Dropdown()),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.Div(dcc.Dropdown()),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.Div(dcc.Dropdown()),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">],</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">className="row"</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Example Div code
    with className</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">(not part
    of the main app)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we assign one row to the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div</samp>
    that houses all three dropdowns, so all these dropdowns will be displayed in the
    same row on the page ([Figure 4-5](chapter4.xhtml#fig4-5)). <samp class="SANS_TheSansMonoCd_W5Regular_11">className</samp>
    is a prop that can be assigned classes from a CSS stylesheet to tell Dash how
    to style an element. Here we assign it the <samp class="SANS_TheSansMonoCd_W5Regular_11">row</samp>
    class, which tells the app that all the components inside this <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    should be on the same row. Every Dash component will have a <samp class="SANS_TheSansMonoCd_W5Regular_11">className</samp>,
    commonly used to style and define layouts. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">className</samp>
    prop of <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div</samp> to describe
    the row and column layout of each <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the row, we need to define the columns’ widths so that Dash knows
    how many columns of space to allocate to each component within that row. We do
    this for each <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div</samp> contained
    in the row, as shown in bold in [Listing 4-6](chapter4.xhtml#List4-6).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div([</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.Div(dcc.Dropdown(),</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">className="four columns"</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.Div(dcc.Dropdown(),</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">className="four columns"</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.Div(dcc.Dropdown(),</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">className="four columns"</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">], className=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">"row")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Setting the column
    width (not part of the main app)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We set the number of columns of space each <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    component should fill with a string value set to <samp class="SANS_TheSansMonoCd_W5Regular_11">className</samp>
    and formatted like <samp class="SANS_TheSansMonoCd_W5Regular_11">"one column"</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">"two columns"</samp> and so on.
    Most web pages will have a maximum of 12 columns (and a potentially unlimited
    number of rows), meaning the sum of the components’ column widths must never surpass
    12, so here we set them to fill 4 columns each. Note that we don’t have to fill
    all 12 columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-5](chapter4.xhtml#fig4-5) shows how this simple page would be displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: Demo of three dropdowns
    on one row</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: With all this in mind, let’s have a look at [Listing 4-7](chapter4.xhtml#List4-7),
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div</samp> section of our
    *twitter_app.py* file, which has fewer than 12 columns.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   [</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp>❶ <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        dcc.Dropdown(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           id="my-dropdown",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           multi=True,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           options=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">              {"label": x, "value":
    x}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              for x in sorted(df["name"].unique())</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">        value=["taylorswift13",
    "cristiano", "jtimberlake"],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        className="three columns",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">     ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp>❷ <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        html.A(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           id="my-link",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           children="Click here
    to Visit Twitter",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           href="</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">https://twitter.com/explore",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           target="_blank",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        className="two columns",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">    ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   className="row",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: The Dropdown</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">section of</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that the row contains two <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>s:
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp> that offers multiple
    celebrities to choose from ❶ and a link for the user to click ❷. Those two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>s have the sum of just five
    columns, meaning they’re left-aligned on the page, as shown in [Figure 4-6](chapter4.xhtml#fig4-6).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: Components that
    are five columns wide</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that some stylesheets, including the one we’re working with here, require
    us to create the parent <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    first and assign a row to it. Then, within the children of the parent <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>,
    we define the column width of each inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Styling: Embellishing
    Your App</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The styling is what gives life to the app. We can add color, change the font
    and size of the text, underline text, and much more. There are two main ways to
    alter the style of the app. The first is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp>
    prop inside the Dash HTML component. This allows the user to specify CSS styling
    declarations that will be applied directly to the component.
  prefs: []
  type: TYPE_NORMAL
- en: The second method is to refer to a CSS stylesheet, like we did to create rows
    and columns. We’ll show you how to integrate the additional stylesheet *mystyles.css*
    into the app; if you downloaded the files as described in “Setting Up the Project”
    earlier in this chapter, this should be in your *assets* folder. Let’s first look
    at how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp> prop
    to alter the app.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using the style Prop</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp> prop expects
    a Python dictionary, with keys that specify what aspect we want to alter and values
    that set the style. In our *twitter_app.py* file, we’ll change the text color
    of the link to red by defining the <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp>
    prop within the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.A</samp> component
    used for adding URL links, as shown in [Listing 4-8](chapter4.xhtml#List4-8).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.A(id="my-link", children="Click
    here to Visit Twitter",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      href="</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">https://twitter.com/explore",</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">target="_blank",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp>❶   <samp class="SANS_TheSansMonoCd_W5Regular_11">style={"color":
    "red"}),</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   className="two columns")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-8: Styling HTML elements
    of</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At ❶ we assign a dictionary to the <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp>
    prop, where the key is <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    and the value is <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>. This
    tells the browser to render this link with red text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll add a yellow background color to the same link by adding another
    key-value pair to the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">style={"color": "red",</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">"backgroundColor": "yellow"</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the dictionary key is a camelCased string. In Dash, the keys in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp> dictionary should
    always be camelCased.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we’ll change the link’s font size to 40 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">style={"color": "red", "backgroundColor":
    "yellow",</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">"fontSize": "40px"</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A beautiful thing about Dash is that styling is not limited to HTML components;
    we can also style the Core components, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>.
    For example, to change the text color of the dropdown options to green, we add
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp> prop within <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown</samp>, as shown in [Listing
    4-9](chapter4.xhtml#List4-9).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   dcc.Dropdown(id="my-dropdown",
    multi=True,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">           options=[{"label":
    x, "value": x}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                 for x in sorted(df["name"].unique())],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           value=["taylorswift13",
    "cristiano", "jtimberlake"],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">           </samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">style={"color":
    "green"}</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   className="three columns"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-9: Styling Core components
    in</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The dropdown options shown in the bottom-left corner of [Figure 4-7](chapter4.xhtml#fig4-7)
    will now be green instead of black.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: Dropdown options
    that appear in green when run on your computer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using a Stylesheet</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The second way to style app components is to define styles through elements
    or classes. Typically, we use this method when a lot of code is needed for the
    styling. To reduce the amount of code present in the app itself, we use styling
    code in an external CSS stylesheet. CSS stylesheets are also reusable; you can
    define a particular class once and apply it to multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSS stylesheet we’ll use is *mystyles.css*, and it should already be in
    the *assets* folder you downloaded with the book’s resources. Open the CSS stylesheet
    inside PyCharm or your preferred text editor by double-clicking it, and you should
    see these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">/*</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">h1 {font-size: 8.6rem; line-height:
    1.35; letter-spacing: -.08rem;</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">margin-bottom: 1.2rem; margin-top:
    1.2rem;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">*/</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">/*</samp> is comment syntax,
    so to enable the styling, delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">/*</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">*/</samp> symbols below and
    above the CSS code. Here <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp>
    is the *selector*, which specifies the element we want to apply the subsequent
    styles to; in this case, it’s all <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp>
    elements. Inside the curly brackets we declare properties and property values
    that will set various styles inside the app. In this example, we set the element’s
    font size to 8.6, the line height to 1.35, the spacing between letters to –0.08,
    and the top and bottom margins to 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-10](chapter4.xhtml#List4-10) shows how the <samp class="SANS_TheSansMonoCd_W5Regular_11">H1</samp>
    heading component in our app uses this CSS stylesheet.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(html.H1("Twitter Likes
    Analysis of Famous People",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">                 style={"textAlign":
    "center"}),</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         className="row"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-10: The html.H1 component
    in</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1</samp> through <samp
    class="SANS_TheSansMonoCd_W5Regular_11">html.H6</samp> components are used to
    define headings, with <samp class="SANS_TheSansMonoCd_W5Regular_11">H1</samp>
    representing the highest heading level and <samp class="SANS_TheSansMonoCd_W5Regular_11">H6</samp>
    representing the lowest heading level. [Figure 4-8](chapter4.xhtml#fig4-8) shows
    how this header styling should look.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: App title styled
    with CSS</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see if you compare [Figure 4-8](chapter4.xhtml#fig4-8) to [Figure
    4-6](chapter4.xhtml#fig4-6), the result is a much larger font size for the app’s
    title, with more top and bottom margin space around the title and less space between
    the letters. If your app’s title did not change in size, restart your app to see
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to revert back to a smaller font size for the title, simply comment
    out the CSS code by reinserting the <samp class="SANS_TheSansMonoCd_W5Regular_11">/*</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">*/</samp> symbols, as such:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">/*</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">h1 {font-size: 8.6rem; line-height:
    1.35; letter-spacing: -.08rem;</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">margin-bottom: 1.2rem; margin-top:
    1.2rem;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">*/</samp>
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to manipulate the style and layout of your app with pure
    Python. This is just the beginning, though. In [Chapter 5](chapter5.xhtml), we
    will dive into dash-bootstrap-components, which will make the layout design and
    styling of the dashboard app even easier and more varied.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dash Components</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we’ll provide an overview of some common components in Dash, provided by
    the dash-html-components and dash-core-components libraries. There are many other
    component libraries, and you can even write your own! But dash-html-components
    and dash-core-components contain most of the basic functionality we need. The
    HTML components are generally for composing the layout of the web page and include
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">H1</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Form</samp>,
    among many others. The Core components—such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Checklist</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">RangeSlider</samp>,
    and many more—are for creating an interactive experience. All HTML and Core components
    have props that add to their functionality. For a full list of these props and
    their components, visit the Dash documentation on HTML and Core components at
    [*https://<wbr>dash<wbr>.plotly<wbr>.com<wbr>/dash<wbr>-core<wbr>-components*](https://dash.plotly.com/dash-core-components).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">HTML Components</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Dash HTML components are written in Python and are automatically converted to
    HTML, so there’s no need to become an expert on HTML or CSS to use Dash apps.
    The following line of code in Python
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"><h1> Twitter Likes Analysis of
    Famous People </h1></samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'is roughly equivalent to the following line of HTML that is read by a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1("Twitter Likes Analysis
    of Famous People")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a complete dashboard app is now possible in pure Python: Python forever!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an HTML component, you use dot notation between the <samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp>
    keyword and the component name. For example, for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    component you would use <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div</samp>,
    as we saw earlier. We also saw two additional HTML components: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1</samp>,
    which creates a top-level heading, and <samp class="SANS_TheSansMonoCd_W5Regular_11">html.A</samp>,
    which creates a hyperlink. Let’s take a closer look at the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1</samp>
    to represent the title of the page, with the title itself written as a string,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1("Twitter Likes Analysis
    of Famous People")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This assigns the string to the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    prop, which is usually the first positional argument of any component that accepts
    children. <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>, in this
    context, is a prop that places a component or element (like a text label) within
    another component. Written in full, the previous line looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1(children="Twitter Likes
    Analysis of Famous People")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first three examples of the following code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    prop adds text to the page. In the last example, with <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp> prop adds the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1</samp> component to the
    page, which has text as well. The <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    prop can take an integer, a string, a Dash component, or a list of any of these.
    All these examples are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1(children=2),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1(children="Twitter Likes
    Analysis of Famous People"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H1(children=["Twitter Likes
    Analysis of Famous People"]),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(children=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.H1("Twitter Likes Analysis
    of Famous People"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   html.H2("Twitter Likes Analysis
    of Famous People")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">])</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">html.A</samp> component creates
    an <samp class="SANS_TheSansMonoCd_W5Regular_11"><a></samp> HTML5 element, which
    is used to create hyperlinks. In this component, shown in [Listing 4-11](chapter4.xhtml#List4-11),
    we use four props: <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">children</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">href</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.A(id="my-link", children=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">"Click here to Visit Twitter",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   href="</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">https://twitter.com/explore",</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">target="_blank")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-11: The HTML link
    component in</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value we assign to <samp class="SANS_TheSansMonoCd_W5Regular_11">href</samp>
    is the full link destination, where the user will end up after clicking the link.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp> prop indicates
    where the link will open: if its assigned value is <samp class="SANS_TheSansMonoCd_W5Regular_11">_self</samp>,
    the link will open in the same tab of the browser the user is in; if its assigned
    value is <samp class="SANS_TheSansMonoCd_W5Regular_11">_blank</samp>, the link
    will open in a new browser tab. The <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    prop defines the content of the component, which here is a string value representing
    the link’s text that the user sees on the page.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> prop is important
    because Dash components use <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>
    to identify and interact with each other, which gives the dashboard app its interactive
    capabilities. We’ll go over this in more detail in “Callback Decorator” later
    in this chapter. For now, just note that the value assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>
    must be a unique string so that it can be used to identify the component.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Core Components</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dash Core components are prebuilt components from the Dash library that
    allow the user to interact with the app in an intuitive way. In this app we use
    two Core components: <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>. To build or
    access a particular Core component, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc</samp>
    keyword and the dot notation before the component name, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Graph Component</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> component allows
    you to incorporate data visualizations into your app in the form of plots, charts,
    and graphs written with Plotly. It’s one of the most popular of the Core components,
    and you’ll likely see it in every analytic dashboard app.
  prefs: []
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> component has
    two main props: <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">figure</samp>. Here’s the template for
    defining a <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> component:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph(id="line-chart", figure={})</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> prop gives the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> component a unique ID. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp> prop is the placeholder
    for the Plotly chart. Once a Plotly chart is created, we would assign it to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp> prop in place of the
    empty dictionary. For example, in our app we create a Plotly line chart with the
    line shown in [Listing 4-12](chapter4.xhtml#List4-12).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import plotly.express as px</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">snip--</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">fig = px.line(data_frame=df_filtered,
    x="date_time", y="number_of_likes",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   color="name", log_y=True)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-12: Creating a Plotly
    chart in</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go through Plotly charts in “Plotly Express Line Charts” later in this
    chapter. For now, this line simply describes how the chart should look and assigns
    it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fig</samp> object, making
    it a Plotly figure. We can then insert <samp class="SANS_TheSansMonoCd_W5Regular_11">fig</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp>’s <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp>
    prop to display the line chart on the page. [Listing 4-13](chapter4.xhtml#List4-13)
    shows the code from the *twitter_app.py* file that does just that, assigned to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(dcc.Graph(id="line-chart",
    figure=fig), className="row")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-13: Pulling the chart
    into the Graph component in</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We put the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> component
    inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> component
    and assign it to a single row on the page. Once the complete app script is activated,
    the line chart should display on the page.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete video tutorial on the Dash <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    component and its usage, see the video “All About the Graph Component” at [*https://<wbr>learnplotlydash<wbr>.com*](https://learnplotlydash.com).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Dropdown Component</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp> component
    allows users to choose options from a dropdown menu to dynamically filter data
    and update graphs. We define the <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>
    component by providing values for four props: <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">multi</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>, as shown in [Listing
    4-14](chapter4.xhtml#List4-14). This menu is shown in [Figure 4-9](chapter4.xhtml#fig4-9).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown(id="my-dropdown",
    multi=True,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">              options=[{"label":
    x, "value": x}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                 for x in sorted(df["name"].unique())],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              value=["taylorswift13",
    "cristiano", "jtimberlake"])</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-14: Creating a Dropdown
    component in</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">multi</samp> prop allows us
    to choose whether the user can select multiple values at once or just one value
    at a time. When this prop is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the app user can select multiple values. When it’s set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    the app user can select only one value at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> prop represents
    the values the user can choose from when they click the <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>.
    We assign it a list of dictionaries of <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> keys, where each
    dictionary represents one menu option. The <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    is the name the user sees as the option, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    is the actual data read by the app.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: App dropdown options</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 4-14](chapter4.xhtml#List4-14), we assigned the list of dictionaries
    using list comprehension, a Python shortcut that creates a new list based on values
    of another list (or any other Python iterable). For every unique value in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> column of our pandas
    DataFrame, this line creates a dictionary of <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'If instead we only have a few values, it may be easier to write out each dictionary
    instead of using list comprehension. For example, in [Listing 4-15](chapter4.xhtml#List4-15)
    we build a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp> with
    only two values: <samp class="SANS_TheSansMonoCd_W5Regular_11">taylorswift13</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">cristiano</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown(id="my-dropdown",
    multi=True,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">             options=[{"label":
    "Taylor", "value": "taylorswift13"},</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">                      {"label":
    "Ronaldo", "value": "cristiano"}]</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-15: A Dropdown example
    not in</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we use the values as they appear in the DataFrame so that filtering is
    easier. But we can then choose a human-friendly representation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    key to make it more recognizable to the user. When the user clicks on the dropdown,
    they will see the two options *Taylor* and *Ronaldo*, which are read by the app
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">taylorswift13</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cristiano</samp>, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp> prop
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> (not to be confused
    with the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    key), and it consists of the default value the <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>
    will take when the user starts the app. Since we have a multivalue <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>,
    we use an initial value of three strings from the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    column of the DataFrame: <samp class="SANS_TheSansMonoCd_W5Regular_11">taylorswift13</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cristiano</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">jtimberlake</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: These strings correspond to the values generated in the <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>
    prop in [Listing 4-14](chapter4.xhtml#List4-14). The strings are preloaded, so
    these three values are automatically chosen before the user even clicks the dropdown
    menu. Once the user chooses a different value in the dropdown menu, these values
    change accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete video tutorial on the Dash <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>
    component and its usage, see the video “Dropdown Selector” at [*https://<wbr>learnplotlydash<wbr>.com*](https://learnplotlydash.com).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dash Callbacks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *Dash callback* enables user interactivity within the dashboard app; it is
    the mechanism that connects the Dash components to each other so that performing
    one action causes something else to happen. When the app user selects a dropdown
    value, the figure is updated; when the user clicks a button, the color of the
    app’s title changes or another graph is added to the page. The possible interactions
    between Dash components are infinite, and without callbacks, the app is static
    and the user cannot modify anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dash callback has two parts, the callback decorator that identifies the
    relevant components, defined in the layout section:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.callback()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'and the callback function that defines how those Dash components should interact:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def function_name(y):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return x</samp>
  prefs: []
  type: TYPE_NORMAL
- en: This simple app only has one callback, though more complicated apps will have
    many.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Callback Decorator</samp>
  prefs: []
  type: TYPE_NORMAL
- en: A callback decorator registers the callback function with your Dash app, telling
    it when to call the function and how to use the return value of the function to
    update the app. (We discussed decorators in [Chapter 1](chapter1.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback decorator should be placed right above the callback function,
    and there must be no space between the decorator and the function. The decorator
    takes two main arguments: <samp class="SANS_TheSansMonoCd_W5Regular_11">Output</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Input</samp>, which refer to
    the component that should change (<samp class="SANS_TheSansMonoCd_W5Regular_11">Output</samp>)
    in response to the user’s action on a different component (<samp class="SANS_TheSansMonoCd_W5Regular_11">Input</samp>).
    For example, the output might be the line chart, which should change depending
    on the user’s input in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>
    component, as shown in [Listing 4-16](chapter4.xhtml#List4-16).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.callback(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   Output(component_id="line-chart",
    component_property="figure"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   [Input(component_id="my-dropdown",
    component_property="value")],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-16: A callback decorator
    from</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Output</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Input</samp> take two arguments: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">component_id</samp>, which should correspond
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> of a particular
    Dash component, and <samp class="SANS_TheSansMonoCd_W5Regular_11">component_property</samp>,
    which should correspond to a particular prop of that same component. In [Listing
    4-16](chapter4.xhtml#List4-16), the <samp class="SANS_TheSansMonoCd_W5Regular_11">component_id</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Input</samp> refers to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">my-dropdown Dropdown</samp> we defined
    earlier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">component_property</samp>
    refers specifically to the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    prop of <samp class="SANS_TheSansMonoCd_W5Regular_11">my-dropdown</samp>, which
    is the Twitter users’ data to show, initially set to <samp class="SANS_TheSansMonoCd_W5Regular_11">["taylorswift13",
    "cristiano", "jtimberlake"]</samp>, as in [Listing 4-14](chapter4.xhtml#List4-14).'
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Output</samp> we refer
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp> prop of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp>, which we also defined
    earlier in the layout, as shown in [Listing 4-17](chapter4.xhtml#List4-17).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph(id="line-chart", figure={})</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-17: The Graph component
    within the layout section in</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp> prop is
    currently an empty dictionary, because the callback function will create a line
    chart based on the input and assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp>.
    Let’s dive into the callback function to fully understand how this happens.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Callback Function</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Our app’s callback function, named <samp class="SANS_TheSansMonoCd_W5Regular_11">update_graph()</samp>,
    holds a series of <samp class="SANS_TheSansMonoCd_W5Regular_11">if-else</samp>
    statements that filter the DataFrame <samp class="SANS_TheSansMonoCd_W5Regular_11">df</samp>
    and create a line chart depending on the input values chosen. [Listing 4-18](chapter4.xhtml#List4-18)
    shows the callback function in our app.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def update_graph(chosen_value):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   print(f"Values chosen by user:
    {chosen_value}")</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if len(chosen_value) == 0:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      return {}</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   else:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">     df_filtered = df[df["name"].isin(chosen_value)]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">     fig = px.line(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        data_frame=df_filtered,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        x="date_time",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        y="number_of_likes",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        color="name",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        log_y=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">True,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        labels={</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">           "number_of_likes":
    "Likes",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">           "date_time": "Date",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">           "name": "Celebrity",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        },</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      return fig</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-18: The callback
    function in</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll go over the logic here line by line in a moment. First, though, let’s
    discuss what this function achieves. When executed, <samp class="SANS_TheSansMonoCd_W5Regular_11">update_graph()</samp>
    returns an object named <samp class="SANS_TheSansMonoCd_W5Regular_11">fig</samp>,
    which in this case contains the Plotly Express line chart. The object <samp class="SANS_TheSansMonoCd_W5Regular_11">fig</samp>
    is returned to the component and property we specified in <samp class="SANS_TheSansMonoCd_W5Regular_11">Output</samp>
    in the callback decorator. As we know, the callback decorator refers to a Dash
    component in the layout. Here, then, <samp class="SANS_TheSansMonoCd_W5Regular_11">fig</samp>
    is assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp>
    prop of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> component
    in the layout section, so the callback is telling the app to display a line chart.
    Here’s what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> component
    would look like after the callback function <samp class="SANS_TheSansMonoCd_W5Regular_11">update_graph()</samp>
    executes:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph(id="line-chart", figure=fig)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp> prop is now
    assigned the object <samp class="SANS_TheSansMonoCd_W5Regular_11">fig</samp> instead
    of the empty dictionary we saw originally, in [Listing 4-17](chapter4.xhtml#List4-17).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll summarize this because this process is extremely important! Once the callback
    function is activated by user input, it returns an object that is tied to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">component_property</samp> of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Output</samp> in the callback decorator.
    Given that the component property represents an actual prop of a component inside
    the app layout, the result is an app that is constantly being updated through
    user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete video tutorial on the Dash callback decorator and its usage,
    see the video “The Dash Callback—Input, Output, State, and More” at [*https://<wbr>learnplotlydash<wbr>.com*](https://learnplotlydash.com).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Activating the Callback</samp>
  prefs: []
  type: TYPE_NORMAL
- en: To activate the callback, the user must interact with the component specified
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">Input</samp> inside the callback
    decorator. In this app, the component property represents the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>, so every time the app
    user chooses a different dropdown value (a Twitter handle), the callback function
    is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the callback decorator had three <samp class="SANS_TheSansMonoCd_W5Regular_11">Input</samp>s,
    the user would need to supply three arguments to trigger the callback function.
    In our case, the callback decorator has only one <samp class="SANS_TheSansMonoCd_W5Regular_11">Input</samp>;
    therefore, the callback function will take only one argument: <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_value</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">How the Function Works</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine [Listing 4-19](chapter4.xhtml#List4-19), which shows what is happening
    inside the app’s callback function.
  prefs: []
  type: TYPE_NORMAL
- en: ❶  <samp class="SANS_TheSansMonoCd_W5Regular_11">def update_graph(chosen_value):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">        print(f"Values chosen
    by user: {chosen_value}")</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ <samp class="SANS_TheSansMonoCd_W5Regular_11">if len(chosen_value) == 0:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">     return {}</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   else:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      df_filtered = df[df["name"].isin(chosen_value)]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      fig =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">px.line(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        data_frame=df_filtered,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        x="date_time",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        y="number_of_likes",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        color="name",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        log_y=True,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        labels={</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">           "number_of_likes":
    "Likes",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">           "date_time": "Date",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">           "name": "Celebrity",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        },</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      return fig</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-19: The callback
    function for</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_value</samp> argument
    ❶ refers to the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown</samp>,
    which is a list of Twitter usernames. Whenever a user chooses new options, the
    function is activated. The user can choose any number of available celebrities,
    and the number of items inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_value</samp>
    list will increase or decrease accordingly. It may be a list of 3 values, 10 values,
    or even no values. We therefore check the length of the <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_value</samp>
    list ❷. If it is equal to zero and so is an empty list, the function returns an
    empty dictionary, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">fig</samp>
    object returned displays an empty graph.
  prefs: []
  type: TYPE_NORMAL
- en: If the length of the <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_value</samp>
    list does not equal zero, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch we use pandas to filter the DataFrame to only those rows that contain the
    selected Twitter usernames. The filtered DataFrame is saved to <samp class="SANS_TheSansMonoCd_W5Regular_11">df_filtered</samp>
    and is then used as the data to create the line chart, which is saved as a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fig</samp> object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fig</samp>
    object is returned to display the line chart on the app page.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important note on these functions: if the original DataFrame is altered
    in any way, you should always make a copy of the original DataFrame, as we did
    when we created <samp class="SANS_TheSansMonoCd_W5Regular_11">df_filtered</samp>.
    The original DataFrame defined at the beginning of the app, in [Listing 4-2](chapter4.xhtml#List4-2),
    is considered a global variable. Global variables should never be altered, because
    doing so affects the variables seen by other users of the app. For example, if
    one user changed the global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">price_values</samp>
    in a financial dashboard app, all users would see these changed prices. This could
    cause significant damage and confusion.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Callback Diagram</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Dash has a powerful callback diagram tool that displays the structure of the
    callback and delineates how elements are tied together. You should use this tool
    when defining callbacks, especially when they have multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">Input</samp>s
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Output</samp>s, where it is
    harder to grasp the callback structure. To open the callback diagram, click the
    blue button in the bottom-right corner of the app page, shown in [Figure 4-10](chapter4.xhtml#fig4-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: Click the button
    in the bottom-right corner to open the menu.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Then click the gray **Callbacks** button, shown in [Figure 4-11](chapter4.xhtml#fig4-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-11: Click the Callbacks
    button to see the callback diagram.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The result should look like [Figure 4-12](chapter4.xhtml#fig4-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-12: The callback diagram
    for</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The element on the left is the component property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Input</samp>.
    The element in the middle describes the number of times the callback has been
    triggered in this session (once, in this case) as well as the time it took for
    the callback to fully execute (614 ms). The element on the right is the component
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Output</samp>. The
    diagram helps paint a clear picture of how the <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>
    values (<samp class="SANS_TheSansMonoCd_W5Regular_11">Input</samp>) influence
    the line chart’s figure (<samp class="SANS_TheSansMonoCd_W5Regular_11">Output</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and trigger the callback by changing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>
    celebrity names on the main app page. See how the green element in the middle
    changes? Explore this diagram by clicking the left and right elements; you should
    see extra information within each element.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to turn debug mode off with <samp class="SANS_TheSansMonoCd_W5Regular_11">debug</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    before you deploy your app to the web in order to turn off the diagram. Otherwise,
    the end user will have access to the diagram as well.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Plotly Express Line Charts</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we’ll review how to create Plotly graphs. We’ll focus on line charts, since
    that’s what we use in this app, and we’ll review other types of graphs in future
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plotly Express is a high-level interface for creating graphs quickly and intuitively.
    It contains dozens of figures to choose from, ranging from scientific, statistical,
    and financial graphs to 3D charts and maps. Every figure has numerous attributes
    that allow you to customize figures according to users’ needs. Here’s a complete
    list of the attributes available for the Plotly Express line chart, all currently
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">plotly.express.line(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">data_frame=None, x</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">=None,
    y=None</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, line_group=None,
    color=None, line_dash=None, hover_name=None, hover_data=None, custom_data=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">None, text=None, facet_row=None, facet_col=None,
    facet_col_wrap=0, facet_row_spacing=None, facet_col_spacing=None, error_x=None,
    error_x_minus=None, error_y=None, error_y_minus=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">None,
    animation_frame=None, animation_group=None, category_orders={}, labels={}, orientation=None,
    color_discrete_sequence=None, color_discrete_map={}, line_dash_sequence=None,
    line_dash_map={}, log_x=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">False,
    log_y=False, range_x=None, range_y=None, line_shape=None, render_mode='auto',
    title=None, template=None,width=None, height=None)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The beautiful thing about Plotly Express is that, in most cases, all you need
    to know to create a graph are the first three attributes: <samp class="SANS_TheSansMonoCd_W5Regular_11">data_frame</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    shown in bold in the example. These represent the DataFrame, the column of data
    to use for the x-axis, and the column to use for the y-axis, respectively. Here
    we plot a really simple line chart:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import plotly.express as px</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">px.line(data_frame=df, x="some_xaxis_data",
    y="some_yaxis_data")</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">fig.show()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: This creates the most basic line chart, charting the relationship between two
    data columns, giving us something like [Figure 4-13](chapter4.xhtml#fig4-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-13: The simplest line
    chart</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The more comfortable you become with Plotly Express, the more attributes you
    will find yourself adding to the figure. For example, to differentiate groups
    of data with color, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    attribute and assign it a column from the hypothetical DataFrame used:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">px.line(data_frame=df, x="some_
    xaxis _data", y="some_yaxis_data",</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">color</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">="some_data"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we would see something like [Figure 4-14](chapter4.xhtml#fig4-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-14: Adding a color
    attribute to the simple chart</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the height of the figure, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">height</samp>
    attribute and assign it a number of pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">px.line(data_frame=df, x="some_xaxis_data",
    y='some_yaxis_data',</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">height=300</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Here we make the height of the entire graph 300 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: In our Twitter Likes Analysis app, the line chart includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">data_frame</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> attributes, as
    well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">labels</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">log_y</samp> attributes. [Listing 4-20](chapter4.xhtml#List4-20)
    shows our Plotly chart code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">fig = px.line(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   data_frame=df_filtered,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   x="date_time",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   y=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">"number_of_likes",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   color="name",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   log_y=True,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   labels={</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">      "number_of_likes": "Likes",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">      "date_time": "Date",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">      "name": "Celebrity",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   },</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-20: The Plotly line
    chart for</samp> <samp class="SANS_Futura_Std_Book_11">twitter_app.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">log_y</samp> attribute tells
    the app to use a logarithmic scale on the y-axis data. Logarithmic scaling is
    recommended when the chart has a few data points that are much larger or smaller
    than the bulk of the data, as it makes for a clearer visualization. We won’t go
    into the details of logarithmic scales here, but try changing the attribute from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    and then refresh the app to see the updated graph. Which one do you prefer?
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">labels</samp> attribute changes
    the axis labels seen by the app users. The three columns used to plot the line
    chart are <samp class="SANS_TheSansMonoCd_W5Regular_11">date_time</samp> (x-axis),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_likes</samp> (y-axis),
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> (color). These are
    the names of the columns in the pandas DataFrame, and we must maintain their format
    and spelling to match to the right column. With the <samp class="SANS_TheSansMonoCd_W5Regular_11">labels</samp>
    attribute, we change what the user sees on the app page to make it more user friendly
    so that <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_likes</samp> simply
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">Likes</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Each attribute is described in detail in the Plotly documentation at [*https://<wbr>plotly<wbr>.com<wbr>/python<wbr>-api<wbr>-reference*](https://plotly.com/python-api-reference).
    It’s worth spending time reading the descriptions because it will help you understand
    all the ways you can customize the line chart and other types of figures.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete video tutorial on the Plotly Express line chart with <samp class="SANS_TheSansMonoCd_W5Regular_11">Dropdown</samp>,
    see the video “Line Plot (Dropdown)” at [*https://<wbr>learnplotlydash<wbr>.com*](https://learnplotlydash.com).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_11">TOOL TIPS</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">There’s one common attribute that we don’t
    use in the app but is common enough that it’s worth mentioning here:</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">hover_data</samp><samp class="SANS_Futura_Std_Book_11">,
    which allows you to provide extra information in tool tips that appear when the
    user hovers over particular elements of the graph with the mouse cursor. You place
    the values assigned to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">hover_data</samp>
    <samp class="SANS_Futura_Std_Book_11">inside a list or a dictionary.</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">When you use a list, the graph’s hover
    tool tip will include the values in the list. For example, if we use the</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_shares</samp> <samp class="SANS_Futura_Std_Book_11">column
    as the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">hover_data</samp>
    <samp class="SANS_Futura_Std_Book_11">list, the hover tool tip will include those
    pieces of data when the user hovers over the lines of our graph. To try this out,
    make the following change and rerun the app:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">fig = px.line(data_frame=df_filtered,
    x="date_time", y="number_of_likes",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">color="name",
    hover_data=["number_of_shares"])</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">The following figure shows the difference
    in the hover information.</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg69.png)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Example tool tip with “number
    of shares” included in hover data</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">Make sure to delete the change when you’re
    done.</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">When you use a dictionary instead of a
    list, the keys are DataFrame columns and the values are Booleans you use to display
    (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp><samp class="SANS_Futura_Std_Book_11">)
    or not display (</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp><samp
    class="SANS_Futura_Std_Book_11">) the data in the hover tool tip. For example,
    if you add the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_likes</samp>
    <samp class="SANS_Futura_Std_Book_11">column</samp> <samp class="SANS_Futura_Std_Book_11">as
    the dictionary key and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    <samp class="SANS_Futura_Std_Book_11">as the dictionary value, the data representing
    the number of likes per celebrity will no longer show in the hover tool tip:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">hover_data={"number_of_likes":
    False}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">We can also use the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">hover_data</samp>
    <samp class="SANS_Futura_Std_Book_11">dictionary to format the hover data seen
    in the tool tip. For example, by default the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_likes</samp>
    <samp class="SANS_Futura_Std_Book_11">is displayed with the letter “k” to represent
    10,000 (200,000 is written as 200k). However, if we’d prefer to show the full
    number with a comma as the group separator (200,000), we would use:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">hover_data={"number_of_likes":
    '':,''}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter introduced you to the essential elements of a basic Dash app:
    Python libraries needed to program the app, the data used, Dash HTML and Core
    components, using the layout section to position the app components on the page,
    using callbacks to connect the components to each other and create interactivity,
    and the Plotly Express graphing library. In the next chapter we’ll build on the
    skills learned here to develop more sophisticated Dash apps.'
  prefs: []
  type: TYPE_NORMAL
