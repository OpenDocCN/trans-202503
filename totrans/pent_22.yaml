- en: Chapter 17. A Stack-Based Buffer Overflow in Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will look at exploiting a stack-based buffer overflow in
    an older version of a Windows-based FTP server. As we did in [Chapter 16](ch16.xhtml
    "Chapter 16. A Stack-Based Buffer Overflow in Linux"), we will attempt to overwrite
    the return pointer saved onto the stack when a function is called, as shown earlier
    in [Figure 16-3](ch16.xhtml#stack_after_call_to_function1 "Figure 16-3. Stack
    after call to function1"). When the function `main` calls `function1`, the next
    instruction to be executed is saved on the stack, and a stack frame for `function1`
    is added to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The size of `function1`’s local variables is determined when the application
    is compiled and fixed. The amount of space “reserved” on the stack for these local
    variables is fixed, too. This reservation is called a *stack buffer*. If we put
    more data in the stack buffer than it can hold, we will cause the buffer to overflow.
    Then we may be able to overwrite the saved return address, which is placed after
    the stack buffer, and take control of program execution. (For a more detailed
    review of this process, see [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based
    Buffer Overflow in Linux").)
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your Virtual Lab"), we installed
    War-FTP version 1.65 on the Windows XP target, but we didn’t start it. We have
    exploited the FileZilla FTP server in previous chapters, and if you’ve been following
    along, that FTP server is still running. Before we can use War-FTP, we need to
    stop the FileZilla FTP server using the XAMPP control panel. This will open TCP
    port 21 for War-FTP. Open War-FTP on the Windows XP desktop by double clicking
    its icon (see [Figure 17-1](ch17.xhtml#war-ftp_icon "Figure 17-1. War-FTP icon")),
    and click the lightning bolt in the top-left corner of the War-FTP window to put
    it online (see [Figure 17-2](ch17.xhtml#war-ftp_1dot65_gui "Figure 17-2. War-FTP
    1.65 GUI")).
  prefs: []
  type: TYPE_NORMAL
- en: '![War-FTP icon](httpatomoreillycomsourcenostarchimages2030510.png.jpg)Figure 17-1. War-FTP
    icon'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for a Known Vulnerability in War-FTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A search on Google for known vulnerabilities in War-FTP 1.65 finds the following
    information on *SecurityFocus.com*:'
  prefs: []
  type: TYPE_NORMAL
- en: War-FTP Username Stack-Based Buffer-Overflow Vulnerability
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: War-FTP is prone to a stack-based buffer-overflow vulnerability because it fails
    to properly check boundaries on user-supplied data before copying it to an insufficiently
    sized buffer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exploiting this issue could lead to denial-of-service conditions and to the
    execution of arbitrary machine code in the context of the application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer Overflow in Linux"),
    we overflowed a function’s local variable on the stack with supplied input and
    redirected execution to a memory location of our choosing. Based on this information
    from *SecurityFocus.com*, it looks like we can do something similar with War-FTP
    1.65\. In this chapter, we will manually exploit War-FTP 1.65’s stack-based buffer
    overflow vulnerability in the Username field of the FTP login. Now that we are
    using a real program rather than demo code, we will learn more about writing real
    exploits. For example, this time we won’t be able to simply redirect execution
    to another function; we will instead need to introduce instructions to be executed
    as part of our attack string.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, make sure War-FTP 1.65 is open and running on your Win-dows
    XP virtual machine. (The lightning bolt icon in the top-left corner of the GUI
    shown in [Figure 17-2](ch17.xhtml#war-ftp_1dot65_gui "Figure 17-2. War-FTP 1.65
    GUI") tells the server to listen for incoming connections.)
  prefs: []
  type: TYPE_NORMAL
- en: The issue we are going to exploit is particularly dangerous because an attacker
    does not need to log in to the FTP server before launching an attack. Thus, we
    do not need to add any legitimate users to the FTP server for this attack to work.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive in and start trying to exploit War-FTP, let’s hook it up to a
    debugger. Immunity Debugger should be on the desktop of your Windows XP target
    because we installed it in [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your
    Virtual Lab"). If it is not, follow the instructions in [Chapter 1](ch01.xhtml
    "Chapter 1. Setting Up Your Virtual Lab") for setting up Immunity Debugger and
    the Mona plugin. Like GDB, Immunity Debugger will allow us to see the internals
    of memory as we attempt to exploit War-FTP. Unfortunately, we don’t have source
    code to guide us toward a successful exploit, but by watching our program in memory
    as we send it attack strings, we should still be able to develop a working exploit.
  prefs: []
  type: TYPE_NORMAL
- en: '![War-FTP 1.65 GUI](httpatomoreillycomsourcenostarchimages2030512.png.jpg)Figure 17-2. War-FTP
    1.65 GUI'
  prefs: []
  type: TYPE_NORMAL
- en: Start Immunity Debugger, open the **File** menu, and select **Attach**. We want
    to attach Immunity Debugger to the running War-FTP process, which we see in the
    process list in [Figure 17-3](ch17.xhtml#process_list_in_the_immunity_debugger_in
    "Figure 17-3. Process list in the Immunity Debugger interface"). Highlight War-FTP
    1.65, and click **Attach**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Process list in the Immunity Debugger interface](httpatomoreillycomsourcenostarchimages2030514.png.jpg)Figure 17-3. Process
    list in the Immunity Debugger interface'
  prefs: []
  type: TYPE_NORMAL
- en: When Immunity Debugger first attaches to a process, it pauses the process’s
    execution. If at any point your exploit just randomly stops working, check to
    make sure the process is running. A paused process isn’t listening for incoming
    connections, and, as you can see in the lower-right corner of the Immunity Debugger
    window in [Figure 17-4](ch17.xhtml#war-ftp_pauses_in_immunity_debuggerdot "Figure 17-4. War-FTP
    pauses in Immunity Debugger."), the process is paused. Click the **Play** button
    at the top-left corner of the screen to tell the process to continue running.
  prefs: []
  type: TYPE_NORMAL
- en: '![War-FTP pauses in Immunity Debugger.](httpatomoreillycomsourcenostarchimages2030516.png.jpg)Figure 17-4. War-FTP
    pauses in Immunity Debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: With War-FTP running in Immunity Debugger, we can figure out how to exploit
    its buffer overflow vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Causing a Crash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 19](ch19.xhtml "Chapter 19. Fuzzing, Porting Exploits, and Metasploit
    Modules"), we will use a technique called *fuzzing* to look for potential vulnerabilities
    in programs, but for now, follow my lead on which attack strings to use to crash
    the program. In the Username field of the FTP login, let’s send a string of 1,100
    *A*s instead of a username. Rather than attacking our program locally, as we did
    in the previous example, this time we will create our exploit in Kali Linux and
    set up the exploit to talk to the FTP server over the network. [Example 17-1](ch17.xhtml#python_exploit_to_crash_war-ftp
    "Example 17-1. Python exploit to crash War-FTP") shows a starter exploit that
    will cause the War-FTP program to crash.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our exploit examples are written in Python, but they can easily be ported into
    another language if you’d prefer to use a different one.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-1. Python exploit to crash War-FTP
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the exploit shown in [Example 17-1](ch17.xhtml#python_exploit_to_crash_war-ftp
    "Example 17-1. Python exploit to crash War-FTP"), we first import the socket Python
    library. Next, we create a string called *buffer*, which contains 1,100 *A*s,
    and set up a socket at ❶ to connect to our Windows XP machine on port 21, where
    the War-FTP server is listening. Next, we accept and print out the FTP server’s
    banner to the screen at ❷. Our exploit then sends over the `USER` command with
    1,100 *A*s ❸ for the username in hopes of causing the FTP server to crash.
  prefs: []
  type: TYPE_NORMAL
- en: If the server responds and asks for our password, the exploit is ready to finish
    the connection with the password, *PASSWORD*. However, if our exploit succeeds,
    it won’t matter if our credentials are valid, because the program will crash before
    it finishes the login process. Finally, we close our socket, and the exploit finishes.
    Make sure the Python script is executable with `chmod +x`, and run the exploit
    as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous example, we hope to overwrite the saved return address
    with a string of *A*s and cause the program to crash. The War-FTP server sends
    over its welcome banner, prompts us for our username, and then asks for a password.
    Take a look at War-FTP in Immunity Debugger, as shown in [Figure 17-5](ch17.xhtml#war-ftp_crashes_due_to_a_buffer_overflow
    "Figure 17-5. War-FTP crashes due to a buffer overflow."), to see if our exploit
    managed to cause a crash.
  prefs: []
  type: TYPE_NORMAL
- en: '![War-FTP crashes due to a buffer overflow.](httpatomoreillycomsourcenostarchimages2030518.png.jpg)Figure 17-5. War-FTP
    crashes due to a buffer overflow.'
  prefs: []
  type: TYPE_NORMAL
- en: After we run our exploit, we see that War-FTP is paused due to an access violation
    when attempting to execute an instruction at `41414141`. Based on what we learned
    in the Linux buffer overflow example in [Chapter 16](ch16.xhtml "Chapter 16. A
    Stack-Based Buffer Overflow in Linux"), this result should seem familiar. A return
    address was overwritten by our long string of *A*s, so when the function returned,
    `41414141` was loaded into the EIP register. The program attempted to execute
    the instructions at that memory location, which was out of bounds and caused a
    crash.
  prefs: []
  type: TYPE_NORMAL
- en: Locating EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the previous example, we need to know which four *A*s in our string
    are overwriting the return address. Unfortunately, 1,100 *A*s is a bit more than
    the 30 we used in the previous chapter, so just counting in memory is more difficult
    in this case. Also, we can’t be sure if the first *A*s we’re seeing on the stack
    are the first *A*s sent as part of the exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the next step would be to crash the program again with 550 *A*s
    followed by 550 *B*s. If the program crashed with `41414141` in EIP, then the
    return address overwrite occurred in the first 550 bytes; if it crashed with `42424242`
    in EIP, the overwrite was in the second half. From there, the half of the string
    in question would be split into 275 *A*s followed by 275 *B*s. Slowly but surely,
    this method would narrow down the exact location.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Cyclical Pattern to Determine Offset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Luckily, we can use Mona to generate a unique cyclic pattern to find the right
    four bytes for the return address overwrite in only one iteration. To use Mona
    for this task, enter **`!mona pattern_create`** with length **1100** as an argument
    at the bottom of the Immunity Debugger window, as shown in [Figure 17-6](ch17.xhtml#using_patternunderscorecreate_in_mona
    "Figure 17-6. Using pattern_create in Mona").
  prefs: []
  type: TYPE_NORMAL
- en: '![Using pattern_create in Mona](httpatomoreillycomsourcenostarchimages2030520.png.jpg)Figure 17-6. Using
    `pattern_create` in Mona'
  prefs: []
  type: TYPE_NORMAL
- en: The 1,100-character cyclic pattern is written to the file *C:\logs\war-ftpd\pattern.txt*,
    as shown in [Example 17-2](ch17.xhtml#output_of_the_patternunderscorecreate_co
    "Example 17-2. Output of the pattern_create command").
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-2. Output of the `pattern_create` command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are going to replace the long string of *A*s with the unique pattern shown
    in [Example 17-2](ch17.xhtml#output_of_the_patternunderscorecreate_co "Example 17-2. Output
    of the pattern_create command"). But before running the exploit again, we need
    to restart War-FTP from the previous crash. In Immunity Debugger, go to **Debug**
    ▸ **Restart**, and then press the **Play** button and click the lightning bolt
    icon to tell War-FTP to listen on the network. (Follow these steps each time you
    need to restart War-FTP after a crash.) Alternatively, you can close Immunity
    Debugger, restart War-FTP manually, and attach to the new process in the debugger.
    Replace the value of the buffer in the exploit with the pattern from [Example 17-2](ch17.xhtml#output_of_the_patternunderscorecreate_co
    "Example 17-2. Output of the pattern_create command"), surrounded by quotation
    marks to make it a string in Python, as shown in [Example 17-3](ch17.xhtml#exploit_with_cyclic_pattern
    "Example 17-3. Exploit with cyclic pattern").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If War-FTP refuses to restart with the error *Unknown format for user database*,
    find and delete the files *FtpDaemon.dat* and/or *FtpDaemon.ini* that were created
    on the desktop by War-FTP. This should fix the problem and War-FTP should start
    normally.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-3. Exploit with cyclic pattern
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now run the exploit again with the generated pattern starting at ❶, replacing
    the 1,100 *A*s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Having run our exploit with Metasploit’s pattern, look back at Immunity Debugger,
    as shown in [Figure 17-7](ch17.xhtml#finding_the_return_address_overwrite "Figure 17-7. Finding
    the return address overwrite"), to see what value is contained in EIP and to find
    out where in our attack string we overwrite the return address.
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the return address overwrite](httpatomoreillycomsourcenostarchimages2030522.png.jpg)Figure 17-7. Finding
    the return address overwrite'
  prefs: []
  type: TYPE_NORMAL
- en: 'War-FTP has crashed again, but this time EIP contains four bytes of our generated
    pattern: `32714131`. We can use Mona to determine where exactly in the 1,100-character
    cyclic pattern the ASCII equivalent of `32714131` is. Enter **`!mona pattern_offset
    32714131`** to get just the offset, or enter **`!mona findmsp`** at the Immunity
    Debugger prompt, as shown in [Figure 17-8](ch17.xhtml#finding_the_pattern_offsets_in_mona
    "Figure 17-8. Finding the pattern offsets in Mona"), to have Mona perform additional
    analysis on all registers and on instances of the pattern in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the pattern offsets in Mona](httpatomoreillycomsourcenostarchimages2030524.png.jpg)Figure 17-8. Finding
    the pattern offsets in Mona'
  prefs: []
  type: TYPE_NORMAL
- en: Mona finds instances of the cyclic pattern in memory. The output of the command
    is written to *C:\logs\war-ftpd\findmsp.txt*. Part of the output is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Verifying Offsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to Mona, our return address overwrite is 485 bytes into the attack
    string. We can verify this, as shown in [Example 17-4](ch17.xhtml#verifying_the_eip_offset
    "Example 17-4. Verifying the EIP offset").
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-4. Verifying the EIP offset
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll create an attack string that contains 485 *A*s, 4 *B*s, and 611 *C*s
    as shown at ❶ in [Example 17-4](ch17.xhtml#verifying_the_eip_offset "Example 17-4. Verifying
    the EIP offset"). With our new string in place, if EIP contains `42424242` when
    the program crashes, we’ll know we have found the correct four bytes for the return
    address. (Remember to restart War-FTP in Immunity Debugger before running the
    exploit again.) Now, check EIP, as shown in [Figure 17-9](ch17.xhtml#war-ftp_crashes_with_eip_filled_with_bs
    "Figure 17-9. War-FTP crashes with EIP filled with Bs").
  prefs: []
  type: TYPE_NORMAL
- en: As expected, War-FTP has crashed again, this time with `42424242` in EIP. This
    result confirms that we have found the location of the return address in our attack
    string. Next we need to find someplace to redirect execution and exploit this
    buffer overflow vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '![War-FTP crashes with EIP filled with Bs](httpatomoreillycomsourcenostarchimages2030526.png.jpg)Figure 17-9. War-FTP
    crashes with EIP filled with Bs'
  prefs: []
  type: TYPE_NORMAL
- en: Hijacking Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the exploit example discussed in [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based
    Buffer Overflow in Linux"), we sent execution to another function. Unfortunately,
    because we don’t have the source code of War-FTP to review for potentially interesting
    code, we’ll use a more typical technique for exploit development this time. Instead
    of redirecting execution to somewhere else in the program, we will introduce our
    own instructions and redirect execution to part of our attack string.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to find out if part of our attack string is easily accessible
    at the time of the crash. Look back at the output of the `!mona findmsp` command
    in *C:\logs\warftp-d\findmsp.txt*, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In addition to taking control of EIP, the registers ESP, EDI, and EBP also point
    to part of the attack string. In other words, our attack string decides the contents
    of these registers, and there’s nothing to stop us from replacing the part of
    the attack string (the *C*s in our current crash) with useful instructions for
    the CPU to execute.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that ESP is at memory address `00AFFD48`, while EBP is slightly higher
    in memory at address `00AFFDA0`. EDI is at `00AFFE48`. We could redirect execution
    to any of these locations, but with the lower address farther up the stack, we
    have a little more space for our instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also, note that ESP does not point directly to the beginning of our Cs. Our
    saved return pointer overwrite is at byte 485 in the pattern, but ESP is at 493,
    eight bytes away (four bytes for the return address and four bytes of Cs).
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **ESP** in the top right of the Immunity Debugger window, and select
    **Follow in Stack**. The stack is shown in the bottom right of the Immunity Debugger
    window. Scroll up a few lines, as shown in [Figure 17-10](ch17.xhtml#esp_controlled_by_the_attack_string
    "Figure 17-10. ESP controlled by the attack string").
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the line above ESP also contains four *C*s, and above that are four
    *B*s for the return address. This tells us that we need to start our malicious
    instructions for the CPU to execute four bytes into our *C*s in the attack string
    (because ESP is four bytes into the *C*s); otherwise, the first four bytes of
    our shellcode will be missed. (This sort of scenario will come up frequently because
    these four *C*s are caused by a calling convention and indicate that the function
    has cleaned-up arguments.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calling conventions are a set of rules implemented in a compiler, describing
    how a child function will receive arguments from its caller function. Some conventions
    will cause the caller function to remove the arguments from the stack, while others
    state that the child function must remove the arguments. The latter will cause
    one or more dwords (depending on the number of arguments) to be skipped on the
    stack automatically, as shown in [Figure 17-10](ch17.xhtml#esp_controlled_by_the_attack_string
    "Figure 17-10. ESP controlled by the attack string"), as soon as the child function
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: '![ESP controlled by the attack string](httpatomoreillycomsourcenostarchimages2030528.png.jpg)Figure 17-10. ESP
    controlled by the attack string'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can just put `00AFFD48` into the return address, replace our *C*s with
    shellcode, and we will have a complete exploit, right? Close, but not quite. Unfortunately,
    if we just hardcode the address `00AFFD48` into our return address, the exploit
    may work just fine for us but not in other cases—and we want it to work as universally
    as possible. As we saw in [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer
    Overflow in Linux"), the locations of registers like ESP can change based on program
    factors such as the length of provided arguments or because the stack is tied
    to a thread, which means the stack address can differ the next time you attack
    the application. Lucky for us, jumping to a CPU register to execute its contents
    is denoted by the assembly language instruction `JMP ESP` (or another register
    name, as needed). In pre-ASLR operating systems, such as our Windows XP SP3 target,
    Windows DLLs were loaded into the same place in memory every time. That means
    if we find a `JMP ESP` inside an executable module on our Windows XP target, it
    should be in the same place on every Windows XP SP3 English-language machine.
  prefs: []
  type: TYPE_NORMAL
- en: For that matter, `JMP ESP` is not our only option. As long as we end up with
    execution pointed to ESP, we can use an equivalent instruction to `JMP ESP` or
    even a series of instructions. For example, `CALL ESP` will work, or `PUSH ESP`
    followed by `RET`, which sends execution to the memory address in ESP.
  prefs: []
  type: TYPE_NORMAL
- en: We can find all the occurrences of `JMP ESP` and the logical equivalents in
    the executable modules for War-FTP with the command `!mona jmp -r esp`, as shown
    in [Figure 17-11](ch17.xhtml#searching_for_jmp_esp_with_mona "Figure 17-11. Searching
    for JMP ESP with Mona").
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching for JMP ESP with Mona](httpatomoreillycomsourcenostarchimages2030530.png.jpg)Figure 17-11. Searching
    for `JMP ESP` with Mona'
  prefs: []
  type: TYPE_NORMAL
- en: The results are written to *C:\logs\war-ftpd\jmp.txt*. We are presented with
    84 possible `JMP ESP` (or equivalent) instructions. Some may contain bad characters
    (as we’ll discuss later in the chapter)—which instructions should we choose? As
    a rule of thumb, go for modules that belong to the application itself and not
    to the operating system. If that is not possible, try relatively stable modules
    such *MSVCRT.dll* because very few changes have been made to this module in Windows
    patches compared with other Windows modules (although changes are still possible
    based on the language of the operating system). The `JMP ESP` instructions Mona
    found in *MSVCRT.dll* are shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use the first one: the `PUSH ESP` followed by a `RET` at `0x77C35459`.
    As in [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer Overflow in Linux"),
    we can set a breakpoint to pause execution when we reach our instructions to redirect
    execution to ESP and make sure everything is working correctly before we replace
    our *C*s with instructions to be executed. Set a breakpoint at the memory address
    `0x77C35459` with the command **`bp`** **`0x77C35459`** in Immunity Debugger,
    as shown in [Figure 17-12](ch17.xhtml#breakpoints_in_immunity_debugger "Figure 17-12. Breakpoints
    in Immunity Debugger"). (To view all currently set breakpoints, go to **View**
    ▸ **Breakpoints** in Immunity Debugger.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breakpoints in Immunity Debugger](httpatomoreillycomsourcenostarchimages2030532.png.jpg)Figure 17-12. Breakpoints
    in Immunity Debugger'
  prefs: []
  type: TYPE_NORMAL
- en: Now replace the four *B*s in your exploit string with the location of the redirection
    to ESP, as shown in [Example 17-5](ch17.xhtml#using_a_return_address_from_an_executabl
    "Example 17-5. Using a return address from an executable module").
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-5. Using a return address from an executable module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With a breakpoint prepared, let’s place our new return address at the right
    location in our attack string at ❶ and change the 611 *C*s to four *C*s followed
    by 607 *D*s to account for the four bytes of the attack string before ESP. Once
    the attack string is in place, run the exploit against War-FTP, and see if it
    reaches our breakpoint in Immunity Debugger, as shown in [Figure 17-13](ch17.xhtml#we_reached_our_breakpointdot
    "Figure 17-13. We reached our breakpoint.").
  prefs: []
  type: TYPE_NORMAL
- en: '![We reached our breakpoint.](httpatomoreillycomsourcenostarchimages2030534.png.jpg)Figure 17-13. We
    reached our breakpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: Perfect—notice in the bottom of the Immunity Debugger window that we hit our
    breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you forget to take endianness into account, you might not reach your breakpoint;
    instead, the program will crash with an access violation at `5954C377`. Be sure
    to flip the bytes around to little-endian format.
  prefs: []
  type: TYPE_NORMAL
- en: The next command to be executed is shown in the top left of the Immunity Debugger
    window in the CPU pane. Use F7 to execute one command at a time rather than have
    the program continue running normally. We press **F7** twice to execute the `PUSH
    ESP` and `RET` instructions, and, as expected, execution is redirected to the
    beginning of our *D*s (44 in hex), as shown in [Figure 17-14](ch17.xhtml#redirecting_execution_to_our_attack_stri
    "Figure 17-14. Redirecting execution to our attack string").
  prefs: []
  type: TYPE_NORMAL
- en: '![Redirecting execution to our attack string](httpatomoreillycomsourcenostarchimages2030536.png.jpg)Figure 17-14. Redirecting
    execution to our attack string'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we just need to put something useful in place of the *D*s from the previous
    section for the CPU to execute on our behalf. In [Chapter 4](ch04.xhtml "Chapter 4. Using
    the Metasploit Framework"), we used the Metasploit tool Msfvenom to generate malicious
    executables. We can also use it to create raw shellcode to put in our handwritten
    exploits. For instance, we can tell our hijacked CPU to open a bind shell on TCP
    port 4444 (or any other port) by using Msfvenom to generate the shellcode for
    a Metasploit payload.
  prefs: []
  type: TYPE_NORMAL
- en: We need to tell Msfvenom the payload to use—in this case *windows/shell_bind_tcp*,
    the inline Windows command shell. We also need to provide it with the maximum
    size we can have for our shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you experiment with crashing War-FTP, you will notice that you can actually
    make the attack string slightly bigger, but things start to act strangely around
    1,150 characters. (We will see what this is all about in [Chapter 18](ch18.xhtml
    "Chapter 18. Structured Exception Handler Overwrites").) At 1,100 characters we
    are safe, and our exploit will work as expected each time.
  prefs: []
  type: TYPE_NORMAL
- en: Our current exploit string has 607 *D*s, so we have 607 bytes for our shellcode.
    Finally, we need to tell Msfvenom which special characters to avoid when creating
    the payload. In this case, we need to avoid the null byte (\x00), carriage return
    (\x0d), line feed (\x0a), and @ (\x40).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finding bad characters is an advanced topic beyond the scope of this book,
    so just trust me that these are the right ones for this exploit. These bad characters
    make sense: The null byte terminates a string, carriage return and line feed denote
    a new line, and *@* will break the *user@server* syntax for an FTP login. For
    more information on this topic, check out my blog post “Finding Bad Characters
    with Immunity Debugger and Mona.py” (*[http://www.bulbsecurity.com/finding-bad-characters-with-immunity-debugger-and-mona-py/](http://www.bulbsecurity.com/finding-bad-characters-with-immunity-debugger-and-mona-py/)*).'
  prefs: []
  type: TYPE_NORMAL
- en: Feed this information into Msfvenom, as shown in [Example 17-6](ch17.xhtml#generating_shellcode_with_msfvenom
    "Example 17-6. Generating shellcode with Msfvenom").
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-6. Generating shellcode with Msfvenom
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Msfvenom generated our shellcode in 368 bytes, leaving us plenty of room to
    spare. Replace the *D*s in the exploit with the generated shellcode, as shown
    in [Example 17-7](ch17.xhtml#our_finished_exploit "Example 17-7. Our finished
    exploit").
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-7. Our finished exploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When you try running the exploit, something unexpected happens. Though we are
    still able to hit our breakpoint and redirect execution to our shellcode, War-FTP
    crashes before we receive our bind shell on port 4444\. Something in the shellcode
    is causing a crash, as shown in [Figure 17-15](ch17.xhtml#war-ftp_crashes "Figure 17-15. War-FTP
    crashes").
  prefs: []
  type: TYPE_NORMAL
- en: '![War-FTP crashes](httpatomoreillycomsourcenostarchimages2030538.png.jpg)Figure 17-15. War-FTP
    crashes'
  prefs: []
  type: TYPE_NORMAL
- en: Msfvenom’s encoded shellcode needs to first decode itself before executing,
    and as part of the decoding process, it needs to find its location in memory using
    a routine called getPC. A common technique for finding the current location in
    memory includes using an instruction called `FSTENV`, which writes a structure
    onto the stack, overwriting what’s there—in our case part of the shellcode. All
    we need to do to fix this is move ESP away from the shellcode, so getPC has room
    to work without corrupting our shellcode. (The problem in general is that if the
    values in EIP and ESP are too close together, shellcode tends to corrupt itself,
    either during decoding or during execution.) This is what caused our crash in
    the previous run.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Metasm utility to turn a simple assembly instruction into shellcode
    that we can drop into our exploit. We need to move ESP away from our shellcode
    in memory. We can do this using the assembly `ADD` instruction. The syntax is
    `ADD` *`destination, amount`*. Because our stack consumes lower memory addresses,
    let’s subtract 1,500 bytes from ESP. The number of bytes should be large enough
    to avoid corruption; 1,500 bytes is usually a safe choice.
  prefs: []
  type: TYPE_NORMAL
- en: Change directories to */usr/share/metasploit-framework/tools* and start *metasm_shell.rb*,
    as shown in [Example 17-8](ch17.xhtml#generating_shellcode_with_metasm "Example 17-8. Generating
    shellcode with Metasm").
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-8. Generating shellcode with Metasm
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we try **`sub esp, 1500`** ❶, the resulting shellcode includes null bytes,
    and, as discussed earlier, a null byte is a bad character that needs to be avoided
    due to the FTP specification. Instead, enter **`add esp, -1500`** ❷ (a logical
    equivalent) into the `metasm` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Now add the resulting shellcode to the exploit right before the *windows/shell_bind_tcp*
    shellcode, as shown in [Example 17-9](ch17.xhtml#exploit_with_esp_moved_out_of_the_way
    "Example 17-9. Exploit with ESP moved out of the way").
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-9. Exploit with ESP moved out of the way
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With ESP out of the way, and knowing that our shellcode won’t be corrupted in
    the process of being decoded or executed, run the exploit again and use Netcat
    on Kali Linux to connect to TCP port 4444 on the Windows target, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, we now have a shell on the Windows target, as shown by the Windows
    command prompt above.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter we used our knowledge from [Chapter 16](ch16.xhtml "Chapter 16. A
    Stack-Based Buffer Overflow in Linux") to exploit a real-world vulnerable program:
    the War-FTP program with a buffer overflow issue in the Username field. We crashed
    the program and located the return address, and then, instead of hardcoding a
    memory address for the overwritten return address, we found a `JMP ESP` instruction
    in a loaded DLL. We then filled the attacker-controlled ESP register with shellcode
    generated by Msfvenom. Now we’ve managed to hijack control of a real program.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at another Windows exploitation technique,
    structured exception handler overwrites.
  prefs: []
  type: TYPE_NORMAL
