- en: Appendix F. Solutions to Selected Exercises
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录F。选定练习的解决方案
- en: '[Chapter 5](ch05.html "Chapter 5. File I/O: Further Details")'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。文件I/O：进一步细节")'
- en: 'A solution is provided in the file `fileio/atomic_append.c` in the source code
    distribution for this book. Here is an example of the results that we see when
    we run this program as suggested:'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书源代码分发中的`fileio/atomic_append.c`文件中找到。以下是运行此程序时看到的结果示例：
- en: '[PRE0]'
  id: totrans-3
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because the combination of *lseek()* plus *write()* is not atomic, one instance
    of the program sometimes overwrote bytes written by the other instance. As a result,
    the file `f2` contains less than 2 million bytes.
  id: totrans-4
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为*lseek()*和*write()*的组合不是原子性的，程序的一个实例有时会覆盖另一个实例写入的字节。因此，文件`f2`的内容少于200万字节。
- en: 'A call to *dup()* can be rewritten as:'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对*dup()*的调用可以重写为：
- en: '[PRE1]'
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A call to *dup2()* can be rewritten as:'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对*dup2()*的调用可以重写为：
- en: '[PRE2]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first point to realize is that, since *fd2* is a duplicate of *fd1*, they
    both share a single open file description, and thus a single file offset. However,
    because *fd3* is created via a separate call to *open()*, it has a separate file
    offset.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个要意识到的点是，由于*fd2*是*fd1*的副本，它们共享一个单一的打开文件描述符，因此共享一个文件偏移量。然而，因为*fd3*是通过单独的*open()*调用创建的，所以它有一个单独的文件偏移量。
- en: After the first *write()*, the file contents are `Hello`,.
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次*write()*之后，文件内容为`Hello`。
- en: Since *fd2* shares a file offset with *fd1*, the second *write()* call appends
    to the existing text, yielding `Hello, world`.
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于*fd2*与*fd1*共享一个文件偏移量，因此第二次*write()*调用会将文本追加到现有文本中，得到`Hello, world`。
- en: The *lseek()* call adjusts the single file offset shared by *fd1* and *fd2*
    to point to the start of the file, and thus the third *write()* call overwrites
    part of the existing text to yield `HELLO, world`.
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lseek()*调用调整了*fd1*和*fd2*共享的单个文件偏移量，使其指向文件的开始，因此第三次*write()*调用覆盖了现有文本的一部分，结果为`HELLO,
    world`。'
- en: The file offset for *fd3* has not so far been modified, and so points to the
    start of the file. Therefore, the final *write()* call changes the file contents
    to `Gidday world`.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fd3*的文件偏移量迄今为止没有被修改，因此指向文件的开始。因此，最终的*write()*调用将文件内容更改为`Gidday world`。'
- en: Run the program `fileio/multi_descriptors.c` in the source code distribution
    for this book to see these results.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行本书源代码分发中的程序`fileio/multi_descriptors.c`以查看这些结果。
- en: '[Chapter 6](ch06.html "Chapter 6. Processes")'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章。进程")'
- en: Since the array *mbuf* is not initialized, it is part of the uninitialized data
    segment. Therefore, no disk space is required to hold this variable. Instead,
    it is allocated (and initialized to 0) when the program is loaded.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于数组*mbuf*没有初始化，它是未初始化数据段的一部分。因此，不需要磁盘空间来存储该变量。相反，它在程序加载时分配（并初始化为0）。
- en: A demonstration of the incorrect usage of *longjmp()* is provided in the file
    `proc/bad_longjmp.c` in the source code distribution for this book.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书源代码分发中的`proc/bad_longjmp.c`文件提供了*longjmp()*使用不当的示例。
- en: Sample implementations of *setenv()* and *unsetenv()* are provided in the file
    `proc/setenv.c` in the source code distribution for this book.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书源代码分发中的`proc/setenv.c`文件提供了*setenv()*和*unsetenv()*的示例实现。
- en: '[Chapter 8](ch08.html "Chapter 8. Users and Groups")'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。用户与组")'
- en: The two *getpwnam()* calls are executed before the *printf()* output string
    is constructed, and—since *getpwnam()* returns its result in a statically allocated
    buffer—the second call overwrites the result returned by the first call.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个*getpwnam()*调用在构建*printf()*输出字符串之前执行，并且由于*getpwnam()*将其结果返回到一个静态分配的缓冲区，因此第二次调用会覆盖第一次调用返回的结果。
- en: '[Chapter 9](ch09.html "Chapter 9. Process Credentials")'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。进程凭证")'
- en: In considering the following, remember that changes to the effective user ID
    always also change the file-system user ID.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在考虑以下内容时，请记住，更改有效用户ID总是也会更改文件系统用户ID。
- en: '*real=2000, effective=2000, saved=2000, file-system=2000*'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*real=2000, effective=2000, saved=2000, file-system=2000*'
- en: '*real=1000, effective=2000, saved=2000, file-system=2000*'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*real=1000, effective=2000, saved=2000, file-system=2000*'
- en: '*real=1000, effective=2000, saved=0, file-system=2000*'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*real=1000, effective=2000, saved=0, file-system=2000*'
- en: '*real=1000, effective=0, saved=0, file-system=2000*'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*real=1000, effective=0, saved=0, file-system=2000*'
- en: '*real=1000, effective=2000, saved=3000, file-system=2000*'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*real=1000, effective=2000, saved=3000, file-system=2000*'
- en: Strictly speaking, such a process is unprivileged, since its effective user
    ID is nonzero. However, an unprivileged process can use the *setuid()*, *setreuid()*,
    *seteuid()*, or *setresuid()* calls to set its effective user ID to the same value
    as its real user ID or saved set-user-ID. Thus, this process could use one of
    these calls to regain privilege.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 严格来说，这样的进程是没有特权的，因为它的有效用户 ID 非零。然而，一个没有特权的进程可以使用 *setuid()*、*setreuid()*、*seteuid()*
    或 *setresuid()* 调用，将其有效用户 ID 设置为与实际用户 ID 或保存的设置用户 ID 相同的值。因此，该进程可以使用这些调用中的一个来重新获得特权。
- en: The following code shows the steps for each system call.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码展示了每个系统调用的步骤。
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the exception of *setuid()*, the answers are the same as for the previous
    exercise, except that we can substitute the value 0 for the variable *e*. For
    *setuid()*, the following holds:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了 *setuid()*，其他的答案与前一个练习相同，只不过我们可以将变量 *e* 的值替换为 0。对于 *setuid()*，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Chapter 10](ch10.html "Chapter 10. Time")'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章。时间")'
- en: The maximum unsigned 32-bit integer value is 4,294,967,295. Divided by 100 clock
    ticks per second, this corresponds to slightly more than 497 days. Divided by
    1 million (`CLOCKS_PER_SEC`), this corresponds to 71 minutes and 35 seconds.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大的无符号 32 位整数值是 4,294,967,295。除以每秒 100 个时钟滴答声后，这相当于略多于 497 天。除以 100 万（`CLOCKS_PER_SEC`）后，这相当于
    71 分钟 35 秒。
- en: '[Chapter 12](ch12.html "Chapter 12. System and Process Information")'
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。系统和进程信息")'
- en: A solution is provided in the file `sysinfo/procfs_user_exe.c` in the source
    code distribution for this book.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书的源代码分发包中的文件 `sysinfo/procfs_user_exe.c` 中找到。
- en: '[Chapter 13](ch13.html "Chapter 13. File I/O Buffering")'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第13章](ch13.html "第13章。文件 I/O 缓冲")'
- en: This sequence of statements ensures that the data written to a *stdio* buffer
    is flushed to the disk. The *fflush()* call flushes the *stdio* buffer for *fp*
    to the kernel buffer cache. The argument given to the subsequent *fsync()* is
    the file descriptor underlying *fp*; thus, the call flushes the (recently filled)
    kernel buffer for that file descriptor to disk.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段语句确保写入 *stdio* 缓冲区的数据被刷新到磁盘。*fflush()* 调用将 *fp* 的 *stdio* 缓冲区刷新到内核缓冲区缓存中。随后传递给
    *fsync()* 的参数是 *fp* 所对应的文件描述符；因此，该调用将该文件描述符的（最近填充的）内核缓冲区刷新到磁盘。
- en: When standard output is sent to a terminal, it is line-buffered, so that the
    output of the *printf()* call appears immediately, and is followed by the output
    of *write()*. When standard output is sent to a disk file, it is block-buffered.
    Consequently, the output of the *printf()* is held in a *stdio* buffer and is
    flushed only when the program exits (i.e., after the *write()* call). (A complete
    program containing the code of this exercise is available in the file `filebuff/mix23_linebuff.c`
    in the source code distribution for this book.)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当标准输出发送到终端时，它是行缓冲的，因此 *printf()* 调用的输出会立即显示，并紧接着是 *write()* 的输出。当标准输出发送到磁盘文件时，它是块缓冲的。因此，*printf()*
    的输出会保存在 *stdio* 缓冲区中，只有在程序退出时（即在 *write()* 调用之后）才会刷新。 (包含本练习代码的完整程序可在本书的源代码分发包中的文件
    `filebuff/mix23_linebuff.c` 中找到。)
- en: '[Chapter 15](ch15.html "Chapter 15. File Attributes")'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第15章](ch15.html "第15章。文件属性")'
- en: The *stat()* system call doesn’t change any file timestamps, since all it does
    is fetch information from the file i-node (and there is no *last i-node access*
    timestamp).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*stat()* 系统调用不会更改任何文件的时间戳，因为它所做的只是从文件 i-node 获取信息（而且没有 *最后 i-node 访问* 时间戳）。'
- en: The GNU C library provides just such a function, named *euidaccess()*, in the
    library source file `sysdeps/posix/euidaccess.c`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GNU C 库提供了这样一个函数，名为 *euidaccess()*，位于库的源文件 `sysdeps/posix/euidaccess.c` 中。
- en: 'In order to do this, we must use two calls to *umask()*, as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须使用两个 *umask()* 调用，具体如下：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note, however, that this solution is not thread-safe, since threads share the
    process umask setting.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，请注意，这个解决方案不是线程安全的，因为线程共享进程的 umask 设置。
- en: A solution is provided in the file `files/chiflag.c` in the source code distribution
    for this book.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书的源代码分发包中的文件 `files/chiflag.c` 中找到。
- en: '[Chapter 18](ch18.html "Chapter 18. Directories and Links")'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第18章](ch18.html "第18章。目录和链接")'
- en: Using *ls -li* shows that the executable file has different i-node numbers after
    each compilation. What happens is that the compiler removes (unlinks) any existing
    file with the same name as its target executable, and then creates a new file
    with the same name. It is permissible to unlink an executable file. The name is
    removed immediately, but the file itself remains in existence until the process
    executing it terminates.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*ls -li*显示可执行文件在每次编译后具有不同的i节点编号。发生的情况是，编译器删除（取消链接）任何与目标可执行文件同名的现有文件，然后创建一个具有相同名称的新文件。取消链接可执行文件是允许的。文件名会立即删除，但文件本身在执行该文件的进程终止之前依然存在。
- en: The file `myfile` is created in the subdirectory `test`. The *symlink()* call
    creates a relative link in the parent directory. Despite appearances, this is
    a dangling link, since it is interpreted relative to the location of the link
    file, and thus refers to a nonexistent file in the parent directory. Consequently,
    *chmod()* fails with the error `ENOENT` (“No such file or directory”). (A complete
    program containing the code of this exercise is available in the file `dirs_links/bad_symlink.c`
    in the source code distribution for this book.)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件`myfile`是在子目录`test`中创建的。*symlink()*调用在父目录中创建了一个相对链接。尽管看起来是这样，但这是一个悬挂链接，因为它是相对于链接文件的位置解释的，因此指向了父目录中一个不存在的文件。因此，*chmod()*失败并显示错误`ENOENT`（“没有这样的文件或目录”）。
    （包含此练习代码的完整程序可以在本书源代码分发包中的文件`dirs_links/bad_symlink.c`中找到。）
- en: A solution is provided in the file `dirs_links/list_files_readdir_r.c`, which
    can be found in the source code distribution for this book.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书源代码分发包中的文件`dirs_links/list_files_readdir_r.c`中找到。
- en: A solution is provided in the file `dirs_links/file_type_stats.c`, which can
    be found in the source code distribution for this book.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书源代码分发包中的文件`dirs_links/file_type_stats.c`中找到。
- en: 'Using *fchdir()* is more efficient. If we are performing the operation repeatedly
    within a loop, then with *fchdir()* we can perform one call to *open()* before
    executing the loop, and with *chdir()* we can place the *getcwd()* call outside
    the loop. Then we are measuring the difference between repeated calls to *fchdir(fd)*
    and *chdir(buf)*. Calls to *chdir()* are more expensive for two reasons: passing
    the *buf* argument to the kernel requires a larger data transfer between user
    space and kernel space, and the pathname in *buf* must be resolved to the corresponding
    directory i-node on each call. (Kernel caching of directory entry information
    reduces the work required for the second point, but some work must still be done.)'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*fchdir()*更加高效。如果我们在循环中反复执行此操作，那么通过*fchdir()*我们可以在执行循环之前调用一次*open()*，而使用*chdir()*时，我们可以将*getcwd()*调用放在循环外。然后，我们比较反复调用*fchdir(fd)*和*chdir(buf)*之间的差异。调用*chdir()*的代价较高，有两个原因：将*buf*参数传递给内核需要在用户空间和内核空间之间进行较大的数据传输，并且每次调用时，*buf*中的路径名必须解析为相应的目录i节点。（内核对目录项信息的缓存减少了第二点所需的工作量，但仍然需要进行一些工作。）
- en: '[Chapter 20](ch20.html "Chapter 20. Signals: Fundamental Concepts")'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第20章](ch20.html "第20章. 信号：基本概念")'
- en: A solution is provided in the file `signals/ignore_pending_sig.c` in the source
    code distribution for this book.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书源代码分发包中的文件`signals/ignore_pending_sig.c`中找到。
- en: A solution is provided in the file `signals/siginterrupt.c` in the source code
    distribution for this book.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书源代码分发包中的文件`signals/siginterrupt.c`中找到。
- en: '[Chapter 22](ch22.html "Chapter 22. Signals: Advanced Features")'
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第22章](ch22.html "第22章. 信号：高级特性")'
- en: As with most UNIX implementations, Linux delivers standard signals before realtime
    signals (SUSv3 doesn’t require this). This makes sense, because some standard
    signals indicate critical conditions (e.g., hardware exceptions) that a program
    should deal with as soon as possible.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与大多数UNIX实现一样，Linux在实时信号之前交付标准信号（SUSv3并不要求如此）。这是有道理的，因为一些标准信号表示程序应该尽快处理的关键条件（例如硬件异常）。
- en: Replacing *sigsuspend()* plus a signal handler with *sigwaitinfo()* in this
    program provides a 25 to 40 percent speed improvement. (The exact figure varies
    somewhat across kernel versions.)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个程序中，将*sigsuspend()*和信号处理程序替换为*sigwaitinfo()*提供了25%到40%的速度提升。（具体数字会根据不同的内核版本略有不同。）
- en: '[Chapter 23](ch23.html "Chapter 23. Timers and Sleeping")'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第23章](ch23.html "第23章. 定时器与睡眠")'
- en: A modified program using *clock_nanosleep()* is provided in the file `timers/t_clock_nanosleep.c`
    in the source code distribution for this book.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*clock_nanosleep()*的修改版程序已在本书的源代码分发包中的文件`timers/t_clock_nanosleep.c`中提供。
- en: A solution is provided in the file `timers/ptmr_null_evp.c` in the source code
    distribution for this book.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书的源代码分发包中的文件`timers/ptmr_null_evp.c`中提供。
- en: '[Chapter 24](ch24.html "Chapter 24. Process Creation")'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第24章](ch24.html "第24章. 进程创建")'
- en: The first *fork()* call creates one new child. Both parent and child carry on
    to execute the second *fork()*, and thus each creates a further process, making
    a total of four processes. All four processes carry on to execute the next *fork()*,
    each creating a further child. Consequently, a total of seven new processes are
    created.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次*fork()*调用创建了一个新的子进程。父进程和子进程都继续执行第二次*fork()*，因此每个进程都会创建一个新的进程，总共创建了四个进程。所有四个进程继续执行下一个*fork()*，每个进程都会创建一个新的子进程。结果，总共创建了七个新的进程。
- en: A solution is provided in the file `procexec/vfork_fd_test.c` in the source
    code distribution for this book.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书的源代码分发包中的文件`procexec/vfork_fd_test.c`中提供。
- en: If we call *fork()*, and then have the child call *raise()* to send itself a
    signal such as `SIGABRT`, this will yield a core dump file that closely mirrors
    the state of the parent at the time of the *fork()*. The *gdb gcore* command allows
    us to perform a similar task for a program, without needing to change the source
    code.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们调用*fork()*，然后让子进程调用*raise()*发送一个信号，例如`SIGABRT`，这将生成一个核心转储文件， closely mirror
    父进程在*fork()*时的状态。*gdb gcore*命令允许我们对程序执行类似的操作，而无需更改源代码。
- en: 'Add a converse *kill()* call in the parent:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父进程中添加一个相反的*kill()*调用：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And in the child, add a converse *sigsuspend()* call:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且在子进程中，添加一个相反的*sigsuspend()*调用：
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Chapter 25](ch25.html "Chapter 25. Process Termination")'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第25章](ch25.html "第25章. 进程终止")'
- en: Assuming a two’s complement architecture, where -1 is represented by a bit pattern
    with all bits on, then the parent will see an exit status of 255 (all bits on
    in the least significant 8 bits, which are all that is passed back to the parent
    when it calls *wait())*. (The presence of the call *exit(-1)* in a program is
    usually a programmer error resulting from confusion with the -1 return used to
    indicate failure of a system call.)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设使用的是二进制补码架构，其中-1由所有位都为1的位模式表示，那么父进程将看到一个退出状态255（最低有效的8位全部为1，这也是父进程在调用*wait()*时所返回的内容）。(*exit(-1)*的调用通常是程序员的错误，源于与用于指示系统调用失败的-1返回值的混淆。)
- en: '[Chapter 26](ch26.html "Chapter 26. Monitoring Child Processes")'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第26章](ch26.html "第26章. 监控子进程")'
- en: A solution is provided in the file `procexec/orphan.c` in the source code distribution
    for this book.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书的源代码分发包中的文件`procexec/orphan.c`中提供。
- en: '[Chapter 27](ch27.html "Chapter 27. Program Execution")'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第27章](ch27.html "第27章. 程序执行")'
- en: The *execvp()* function first fails to exec the file `xyz` in `dir1`, because
    execute permission is denied. It therefore continues its search in `dir2`, where
    it successfully execs `xyz`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*execvp()*函数首先因没有执行权限而无法执行`dir1`中的文件`xyz`。因此，它继续在`dir2`中查找，并成功执行了`xyz`。'
- en: A solution is provided in the file `procexec/execlp.c` in the source code distribution
    of this book.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书的源代码分发包中的文件`procexec/execlp.c`中提供。
- en: 'The script specifies the *cat* program as its interpreter. The *cat* program
    “interprets” a file by printing its contents—in this case with the *-n* (line
    numbering) option enabled (as though we had entered the command *cat -n ourscript*).
    Thus, we would see the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本指定了*cat*程序作为其解释器。*cat*程序通过打印文件内容来“解释”文件——在这种情况下启用了*-n*（行号）选项（就像我们输入了命令*cat
    -n ourscript*）。因此，我们会看到如下内容：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Two successive *fork()* calls yield a total of three processes related as parent,
    child, and grandchild. Having created the grandchild process, the child immediately
    exits, and is reaped by the *waitpid()* call in the parent. As a consequence of
    being orphaned, the grandchild is adopted by *init* (process ID of 1). The program
    doesn’t need to perform a second *wait()* call, since *init* automatically reaps
    the zombie when the grandchild terminates. Therein lies a possible use for this
    code sequence: if we need to create a child for which we can’t later wait, then
    this sequence can be used to ensure that no zombie results. One example of such
    a requirement is where the parent execs some program that is not guaranteed to
    perform a wait (and we don’t want to rely on setting the disposition of `SIGCHLD`
    to `SIG_IGN`, since the disposition of an ignored `SIGCHLD` after an *exec()*
    is left unspecified by SUSv3).'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两次连续调用*fork()*会产生总共三个进程，它们之间的关系是父进程、子进程和孙进程。创建了孙进程后，子进程立即退出，并通过父进程中的*waitpid()*调用被收割。由于被孤儿化，孙进程被*init*（进程ID为1）收养。程序不需要执行第二次*wait()*调用，因为*init*会在孙进程终止时自动收割僵尸进程。这个代码序列的一个可能用途就是：如果我们需要创建一个子进程，但之后不能等待它，那么这个序列可以确保不会产生僵尸进程。一个这样的需求示例是，父进程执行某个程序，该程序并不保证执行*wait*（而且我们不想依赖设置`SIGCHLD`的处理方式为`SIG_IGN`，因为SUSv3对*exec()*之后忽略的`SIGCHLD`的处理方式没有明确规定）。
- en: The string given to *printf()* doesn’t include a newline character, and therefore
    the output is not flushed before the *execlp()* call. The *execlp()* overwrites
    the existing program’s data segments (as well as the heap and stack), which contain
    the *stdio* buffers, and thus the unflushed output is lost.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给*printf()*的字符串不包含换行符，因此在*execlp()*调用之前，输出不会被刷新。*execlp()*会覆盖现有程序的数据段（以及堆和栈），这些段包含*stdio*缓冲区，因此未刷新的输出会丢失。
- en: '`SIGCHLD` is delivered to the parent. If the `SIGCHLD` handler attempts to
    do a *wait()*, then the call returns an error (`ECHILD`) indicating that there
    were no children whose status could be returned. (This assumes that the parent
    had no other terminated children. If it did, then the *wait()* would block; or
    if *waitpid()* was used with the `WNOHANG` flag, *waitpid()* would return 0.)
    This is exactly the situation that may arise if a program establishes a handler
    for `SIGCHLD` before calling *system()*.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SIGCHLD`会传递给父进程。如果`SIGCHLD`处理程序尝试执行*wait()*，那么该调用会返回一个错误（`ECHILD`），表示没有子进程的状态可以返回。（这假设父进程没有其他已终止的子进程。如果有，则*wait()*会阻塞；或者如果使用了带有`WNOHANG`标志的*waitpid()*，*waitpid()*会返回0。）如果程序在调用*system()*之前为`SIGCHLD`设置了处理程序，就会出现这种情况。'
- en: '[Chapter 29](ch29.html "Chapter 29. Threads: Introduction")'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第29章](ch29.html "第29章. 线程：介绍")'
- en: 'There are two possible outcomes (both permitted by SUSv3): the thread deadlocks,
    blocked while trying to join with itself, or the *pthread_join()* call fails,
    returning the error `EDEADLK`. On Linux, the latter behavior occurs. Given a thread
    ID in *tid*, we can prevent such an eventuality using the following code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两种可能的结果（都由SUSv3允许）：线程死锁，在尝试与自身连接时被阻塞，或者*pthread_join()*调用失败，返回错误`EDEADLK`。在Linux上，会发生后一种行为。给定一个线程ID在*tid*中，我们可以使用以下代码来防止这种情况的发生：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the main thread terminates, *threadFunc()* will continue working with
    storage on the main thread’s stack, with unpredictable results.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主线程终止后，*threadFunc()*将继续使用主线程栈上的存储，可能导致不可预知的结果。
- en: '[Chapter 31](ch31.html "Chapter 31. Threads: Thread Safety and Per-Thread Storage")'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第31章](ch31.html "第31章. 线程：线程安全和每线程存储")'
- en: A solution is provided in the file `threads/one_time_init.c` in the source code
    distribution for this book.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书源代码发布包中的`threads/one_time_init.c`文件中提供。
- en: '[Chapter 33](ch33.html "Chapter 33. Threads: Further Details")'
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第33章](ch33.html "第33章. 线程：进一步的细节")'
- en: The `SIGCHLD` signal that is generated on child termination is process-directed.
    It may be delivered to any thread (not necessarily the one that called *fork()*)
    that is not blocking the signal.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于子进程终止而生成的`SIGCHLD`信号是进程导向的。它可能会被传递给任何未阻塞该信号的线程（不一定是调用了*fork()*的线程）。
- en: '[Chapter 34](ch34.html "Chapter 34. Process Groups, Sessions, and Job Control")'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第34章](ch34.html "第34章. 进程组、会话和作业控制")'
- en: 'Suppose that the program is part of a shell pipeline:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设该程序是一个Shell管道的一部分：
- en: '[PRE10]*`some string`*[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE10]*`某个字符串`*[PRE11]'
- en: The problem is that *grep* will be part of the same process group as *ourprog*,
    and therefore the *killpg()* call will also terminate the *grep* process. This
    is probably not desired, and is likely to confuse users. The solution is to use
    *setpgid()* to ensure that the child processes are placed in their own new group
    (the process ID of the first child could be used as the process group ID of the
    group), and then signal that process group. This also removes the need for the
    parent to make itself immune to the signal.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题在于*grep*将与*ourprog*处于同一进程组中，因此*killpg()*调用也会终止*grep*进程。这可能不是预期的行为，并且可能会让用户困惑。解决方案是使用*setpgid()*确保子进程被放入各自的新组（第一个子进程的进程ID可以用作该组的进程组ID），然后发送信号到该进程组。这也不再需要父进程使其自己对信号免疫。
- en: If the `SIGTSTP` signal is unblocked before raising it again, then there is
    a small window of time (between the calls to *sigprocmask()* and *raise()*) during
    which, if the user types a second suspend character (*Control-Z*), the process
    will be stopped while still in the handler. Consequently, two `SIGCONT` signals
    will be required to resume the process.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在再次发送`SIGTSTP`信号之前解除对该信号的屏蔽，则会存在一个小的时间窗口（在调用*sigprocmask()*和*raise()*之间），在此期间，如果用户再次输入暂停字符（*Control-Z*），则进程会在处理程序中被停止。因此，需要发送两个`SIGCONT`信号来恢复进程。
- en: '[Chapter 35](ch35.html "Chapter 35. Process Priorities and Scheduling")'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第35章](ch35.html "第35章. 进程优先级和调度")'
- en: A solution is provided in the file `procpri/demo_sched_fifo.c` in the source
    code distribution for this book.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书的源代码分发包中的`procpri/demo_sched_fifo.c`文件中提供。
- en: '[Chapter 36](ch36.html "Chapter 36. Process Resources")'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第36章](ch36.html "第36章. 进程资源")'
- en: A solution is provided in the file `procres/rusage_wait.c` in the source code
    distribution for this book.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书的源代码分发包中的`procres/rusage_wait.c`文件中提供。
- en: A solution is provided in the files `rusage.c` and `print_rusage.c` in the `procres`
    subdirectory in the source code distribution for this book.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书的源代码分发包中的`procres`子目录下的`rusage.c`和`print_rusage.c`文件中提供。
- en: '[Chapter 37](ch37.html "Chapter 37. Daemons")'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第37章](ch37.html "第37章. 守护进程")'
- en: A solution is provided in the file `daemons/t_syslog.c` in the source code distribution
    for this book.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书的源代码分发包中的`daemons/t_syslog.c`文件中提供。
- en: '[Chapter 38](ch38.html "Chapter 38. Writing Secure Privileged Programs")'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第38章](ch38.html "第38章. 编写安全的特权程序")'
- en: Whenever a file is modified by an unprivileged user, the kernel clears the file’s
    set-user-ID permission bit. The set-group-ID permission bit is similarly cleared
    if the group-execute permission bit is enabled. (As detailed in Section 55.4,
    the combination of having the set-group-ID bit on while the group-execute bit
    is *off* has nothing to do with set-group-ID programs; instead, it is used to
    enable mandatory locking, and for this reason modifications to such a file don’t
    disable the set-group-ID bit.) Clearing these bits ensures that if the program
    file is writable by arbitrary users, then it can’t be modified and still retain
    its ability to give privileges to users executing the file. A privileged (`CAP_FSETID`)
    process can modify a file without the kernel clearing these permission bits.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当一个非特权用户修改文件时，内核会清除该文件的设置用户ID权限位。如果启用了组执行权限位，设置组ID权限位也会被清除。（如第55.4节所述，设置组ID位开启且组执行位*关闭*的组合与设置组ID程序无关；相反，它用于启用强制锁定，因此修改此类文件不会禁用设置组ID位。）清除这些位确保了，如果程序文件可由任意用户写入，则该文件不能被修改后仍然保留给予执行该文件的用户特权的能力。一个特权的（`CAP_FSETID`）进程可以修改文件而不清除这些权限位。
- en: '[Chapter 44](ch44.html "Chapter 44. Pipes and FIFOs")'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第44章](ch44.html "第44章. 管道和FIFO")'
- en: A solution is provided in the file `pipes/change_case.c` in the source code
    distribution for this book.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书的源代码分发包中的`pipes/change_case.c`文件中提供。
- en: It creates a race condition. Suppose that between the time the server sees end-of-file
    and the time it closes the file reading descriptor, a client opens the FIFO for
    writing (this will succeed without blocking), and then writes data to the FIFO
    *after* the server has closed the reading descriptor. At this point, the client
    will receive a `SIGPIPE` signal, since no process has the FIFO open for reading.
    Alternatively, the client might be able to both open the FIFO and write data to
    it before the server closes the reading descriptor. In this case, the client’s
    data would be lost, and it wouldn’t receive a response from the server. As a further
    exercise, you could try to demonstrate these behaviors by making the suggested
    modification to the server and creating a special-purpose client that repeatedly
    opens the server’s FIFOs, sends a message to the server, closes the server’s FIFO,
    and reads the server’s response (if any).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个竞争条件。假设在服务器看到文件结束标志和关闭文件读取描述符之间，客户端打开了FIFO进行写入（这将成功且不会阻塞），然后在服务器关闭读取描述符之后向FIFO写入数据。此时，客户端将收到`SIGPIPE`信号，因为没有进程打开FIFO进行读取。或者，客户端可能能够在服务器关闭读取描述符之前同时打开FIFO并向其写入数据。在这种情况下，客户端的数据将丢失，并且它不会收到服务器的响应。作为进一步的练习，您可以通过对服务器进行建议的修改，并创建一个专用客户端，该客户端反复打开服务器的FIFO，向服务器发送消息，关闭服务器的FIFO，并读取服务器的响应（如果有的话），来演示这些行为。
- en: One possible solution would be to set a timer on the *open()* of the client
    FIFO using *alarm()*, as described in Section 23.3\. This solution suffers from
    the drawback that the server would still be delayed for the period of the timeout.
    Another possible solution would be to open the client FIFO using the `O_NONBLOCK`
    flag. If this fails, then the server can assume a misbehaving client. This latter
    solution also requires changes to the client, which needs to ensure that it opens
    its FIFO (also using the `O_NONBLOCK` flag) prior to sending a request to the
    server. For convenience, the client should then turn off the `O_NONBLOCK` flag
    for the FIFO file descriptor, so that the subsequent *read()* call blocks. Finally,
    it is possible to implement a concurrent server solution for this application,
    with the main server process creating a child to send the response message to
    each client. (This would represent a rather resource-expensive solution in the
    case of this simple application.)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是在客户端FIFO的*open()*操作上设置定时器，使用*alarm()*，如第23.3节所述。该解决方案的缺点是服务器仍然会在超时期间延迟。另一种可能的解决方案是使用`O_NONBLOCK`标志打开客户端FIFO。如果失败，则服务器可以假定客户端行为异常。后一种解决方案还需要对客户端进行更改，确保它在向服务器发送请求之前先打开其FIFO（同样使用`O_NONBLOCK`标志）。为了方便起见，客户端应关闭FIFO文件描述符的`O_NONBLOCK`标志，以便后续的*read()*调用可以阻塞。最后，可以为该应用程序实现并发服务器解决方案，主服务器进程为每个客户端创建一个子进程来发送响应消息。（在这种简单应用程序的情况下，这将是一个相当耗费资源的解决方案。）
- en: Other conditions that are not handled by this server remain. For example, it
    doesn’t handle the possibilities of the sequence number overflowing or a misbehaving
    client requesting large groups of sequence numbers in order to produce such overflows.
    The server also does not handle the possibility that the client specifies a negative
    value for the sequence length. Furthermore, a malicious client could create its
    reply FIFO, and then open the FIFO for reading and writing, and fill it with data
    before sending a request to the server; as a consequence, the server would be
    able to successfully open the reply FIFO, but would block when it tries to write
    the reply. As a further exercise, you could try to devise strategies for dealing
    with these possibilities.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该服务器未处理的其他条件仍然存在。例如，它没有处理序列号溢出或恶意客户端请求大量序列号以产生溢出的情况。服务器也没有处理客户端指定负值作为序列长度的可能性。此外，恶意客户端可以创建其回复FIFO，然后打开FIFO进行读写，并在向服务器发送请求之前向其中填充数据；因此，服务器能够成功打开回复FIFO，但在尝试写入回复时将会阻塞。作为进一步的练习，您可以尝试设计策略来处理这些可能性。
- en: 'In Section 44.8, we also noted another limitation that applies to the server
    in [Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs"): if a client sends a message that contains the
    wrong number of bytes, then the server will be out of step when reading all subsequent
    client messages. One simple way to deal with this problem is to discard the use
    of fixed-length messages in favor of the use of a delimiter character.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第44.8节中，我们还提到过另一个适用于[示例44-7](ch44.html#an_iterative_server_using_fifos "示例44-7.
    使用FIFO的迭代服务器")中服务器的限制：如果客户端发送了包含错误字节数的消息，那么服务器在读取所有后续客户端消息时会步调不一致。处理此问题的一种简单方法是放弃使用固定长度的消息，转而使用定界符字符。
- en: '[Chapter 45](ch45.html "Chapter 45. Introduction to System V IPC")'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第45章](ch45.html "第45章. System V IPC简介")'
- en: A solution is provided in the file `svipc/t_ftok.c` in the source code distribution
    for this book.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书的源代码分发包中的`svipc/t_ftok.c`文件中找到。
- en: '[Chapter 46](ch46.html "Chapter 46. System V Message Queues")'
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第46章](ch46.html "第46章. System V消息队列")'
- en: The value 0 is a valid message queue identifier, but 0 can’t be used as a message
    type.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值0是一个有效的消息队列标识符，但0不能作为消息类型使用。
- en: '[Chapter 47](ch47.html "Chapter 47. System V Semaphores")'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第47章](ch47.html "第47章. System V信号量")'
- en: A solution is provided in the file `svsem/event_flags.c` in the source code
    distribution for this book.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书的源代码分发包中的`svsem/event_flags.c`文件中找到。
- en: A reserve operation can be implemented by reading a byte from the FIFO. Conversely,
    a release operation can be implemented by writing a byte to the FIFO. A conditional
    reserve operation can be implemented as a nonblocking read of a byte from the
    FIFO.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预留操作可以通过从FIFO中读取一个字节来实现。相反，释放操作可以通过向FIFO写入一个字节来实现。条件预留操作可以通过非阻塞读取FIFO中的一个字节来实现。
- en: '[Chapter 48](ch48.html "Chapter 48. System V Shared Memory")'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第48章](ch48.html "第48章. System V共享内存")'
- en: Since access to the *shmp-> cnt* value in the `for` loop increment step is no
    longer protected by the semaphore, there is a race condition between the writer
    next updating this value and the reader fetching it.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`for`循环增量步骤中的*shmp->cnt*值的访问不再受到信号量的保护，因此写入者更新该值与读取者获取该值之间存在竞争条件。
- en: A solution is provided in the file `svshm/svshm_mon.c` in the source code distribution
    for this book.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书的源代码分发包中的`svshm/svshm_mon.c`文件中找到。
- en: '[Chapter 49](ch49.html "Chapter 49. Memory Mappings")'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第49章](ch49.html "第49章. 内存映射")'
- en: A solution is provided in the file `mmap/mmcopy.c` in the source code distribution
    for this book.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书的源代码分发包中的`mmap/mmcopy.c`文件中找到。
- en: '[Chapter 50](ch50.html "Chapter 50. Virtual Memory Operations")'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第50章](ch50.html "第50章. 虚拟内存操作")'
- en: A solution is provided in the file `vmem/madvise_dontneed.c` in the source code
    distribution for this book.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书的源代码分发包中的`vmem/madvise_dontneed.c`文件中找到。
- en: '[Chapter 52](ch52.html "Chapter 52. POSIX Message Queues")'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第52章](ch52.html "第52章. POSIX消息队列")'
- en: A solution is provided in the file `pmsg/mq_notify_sigwaitinfo.c` in the source
    code distribution for this book.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书的源代码分发包中的`pmsg/mq_notify_sigwaitinfo.c`文件中找到。
- en: It would not be safe to make *buffer* global. Once message notification is reenabled
    in *threadFunc()*, there is a chance that a second notification would be generated
    while *threadFunc()* is still executing. This second notification could initiate
    a second thread that executes *threadFunc()* at the same time as the first thread.
    Both threads would attempt to use the same global *buffer*, with unpredictable
    results. Note that the behavior here is implementation-dependent. SUSv3 permits
    an implementation to sequentially deliver notifications to the same thread. However,
    it is also permissible to deliver notifications in separate threads that execute
    concurrently, and this is what Linux does.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*buffer*设置为全局变量是不安全的。一旦在*threadFunc()*中重新启用消息通知，就有可能在*threadFunc()*仍在执行时生成第二个通知。这个第二个通知可能会启动第二个线程，在第一个线程执行的同时运行*threadFunc()*。两个线程都会尝试使用相同的全局*buffer*，结果不可预测。请注意，这里的行为是依赖于实现的。SUSv3允许实现按顺序将通知发送到同一线程。然而，也可以允许在多个线程中发送通知，这些线程可以并发执行，这也是Linux的实现方式。
- en: '[Chapter 53](ch53.html "Chapter 53. POSIX Semaphores")'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第53章](ch53.html "第53章. POSIX信号量")'
- en: A solution is provided in the file `psem/psem_timedwait.c` in the source code
    distribution for this book.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案可以在本书的源代码分发包中的`psem/psem_timedwait.c`文件中找到。
- en: '[Chapter 55](ch55.html "Chapter 55. File Locking")'
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第55章](ch55.html "第55章. 文件锁定")'
- en: 'The following hold for *flock()* on Linux:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下内容适用于Linux上的*flock()*：
- en: A series of shared locks can starve a process waiting to place an exclusive
    lock.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一系列共享锁可能会导致等待放置独占锁的进程发生饥饿现象。
- en: There are no rules regarding which process is granted the lock. Essentially,
    the lock is granted to the process that is next scheduled. If that process happens
    to be one that obtains a shared lock, then all other processes requesting shared
    locks will also be able to have their requests granted simultaneously.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于哪个进程被授予锁，并没有规则。实质上，锁会授予下一个被调度的进程。如果该进程恰好获得了共享锁，那么所有请求共享锁的其他进程也将能够同时获得它们的请求。
- en: The *flock()* system call doesn’t detect deadlock. This is true of most *flock()*
    implementations, except those that implement *flock()* in terms of *fcntl()*.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*flock()*系统调用不会检测死锁。这适用于大多数*flock()*实现，除了那些通过*fcntl()*实现*flock()*的情况。'
- en: In all except early (1.2 and earlier) Linux kernels, the two types of locking
    operate independently, and have no affect on one another.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了早期的（1.2及更早版本的）Linux内核之外，两种类型的锁是独立操作的，并且互不影响。
- en: '[Chapter 57](ch57.html "Chapter 57. Sockets: UNIX Domain")'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第57章](ch57.html "第57章. 套接字：UNIX域")'
- en: On Linux, the *sendto()* call fails with the error `EPERM`. On some other UNIX
    systems, a different error results. Some other UNIX implementations don’t enforce
    this constraint, letting a connected UNIX domain datagram socket receive datagrams
    from a sender other than its peer.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux上，*sendto()*调用会失败并返回错误`EPERM`。在一些其他UNIX系统上，会出现不同的错误。其他一些UNIX实现并不强制执行此约束，允许已连接的UNIX域数据报套接字接收来自其他发送方的数据报。
- en: '[Chapter 59](ch59.html "Chapter 59. Sockets: Internet Domains")'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第59章](ch59.html "第59章. 套接字：互联网域")'
- en: A solution is provided in the files `read_line_buf.h` and `read_line_buf.c`
    in the `sockets` subdirectory in the source code distribution for this book.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书源代码分发中的`sockets`子目录下的`read_line_buf.h`和`read_line_buf.c`文件中提供。
- en: A solution is provided in the files `is_seqnum_v2_sv.c`, `is_seqnum_v2_cl.c`,
    and `is_seqnum_v2.h` in the `sockets` subdirectory in the source code distribution
    for this book.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书源代码分发中的`sockets`子目录下的`is_seqnum_v2_sv.c`、`is_seqnum_v2_cl.c`和`is_seqnum_v2.h`文件中提供。
- en: A solution is provided in the files `unix_sockets.h`, `unix_sockets.c`, `us_xfr_v2.h`,
    `us_xfr_v2_sv.c`, and `us_xfr_v2_cl.c` in the `sockets` subdirectory in the source
    code distribution for this book.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书源代码分发中的`sockets`子目录下的`unix_sockets.h`、`unix_sockets.c`、`us_xfr_v2.h`、`us_xfr_v2_sv.c`和`us_xfr_v2_cl.c`文件中提供。
- en: In the Internet domain, datagrams from a nonpeer socket are silently discarded.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在互联网域中，来自非对等套接字的数据报会被默默丢弃。
- en: '[Chapter 60](ch60.html "Chapter 60. Sockets: Server Design")'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第60章](ch60.html "第60章. 套接字：服务器设计")'
- en: A solution is provided in the file `sockets/is_echo_v2_sv.c` in the source code
    distribution for this book.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书源代码分发中的`sockets/is_echo_v2_sv.c`文件中提供。
- en: '[Chapter 61](ch61.html "Chapter 61. Sockets: Advanced Topics")'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第61章](ch61.html "第61章. 套接字：高级主题")'
- en: Since the send and receive buffers for a TCP socket have a limited size, if
    the client sent a large quantity of data, then it might fill these buffers, at
    which point a further *write()* would (permanently) block the client before it
    read any of the server’s response.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于TCP套接字的发送和接收缓冲区大小有限，如果客户端发送大量数据，可能会填满这些缓冲区，此时进一步的*write()*会（永久性地）阻塞客户端，直到它读取到服务器的响应。
- en: A solution is provided in the file `sockets/sendfile.c` in the source code distribution
    for this book.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书源代码分发中的`sockets/sendfile.c`文件中提供。
- en: '[Chapter 62](ch62.html "Chapter 62. Terminals")'
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第62章](ch62.html "第62章. 终端")'
- en: The *tcgetattr()* fails if it is applied to a file descriptor that doesn’t refer
    to a terminal.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*tcgetattr()*应用于一个不指向终端的文件描述符，则会失败。
- en: A solution is provided in the file `tty/ttyname.c` in the source code distribution
    for this book.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书源代码分发中的`tty/ttyname.c`文件中提供。
- en: '[Chapter 63](ch63.html "Chapter 63. Alternative I/O Models")'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第63章](ch63.html "第63章. 替代I/O模型")'
- en: A solution is provided in the file `altio/select_mq.c` in the source code distribution
    for this book.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案已在本书源代码分发中的`altio/select_mq.c`文件中提供。
- en: 'A race condition would result. Suppose the following sequence of events: (a)
    after *select()* has informed the program that the self-pipe has data, it performs
    the appropriate actions in response to the signal; (b) another signal arrives,
    and the handler writes a byte to the self-pipe and returns; and (c) the main program
    drains the self-pipe. As a consequence, the program misses the signal that was
    delivered in step (b).'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会导致竞争条件。假设发生以下事件序列：（a）在*select()*通知程序自管道有数据后，它执行适当的操作以响应信号；（b）另一个信号到达，处理程序向自管道写入一个字节并返回；（c）主程序清空自管道。因此，程序会错过在步骤（b）中传递的信号。
- en: The *epoll_wait()* call blocks, even when the interest list is empty. This can
    be useful in a multithreaded program, where one thread might add a descriptor
    to the *epoll* interest list, while another thread is blocked in an *epoll_wait()*
    call.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*epoll_wait()*调用会阻塞，即使兴趣列表为空。这在多线程程序中非常有用，在这种程序中，一个线程可能会将描述符添加到*epoll*兴趣列表，而另一个线程则会在*epoll_wait()*调用中被阻塞。'
- en: Successive *epoll_wait()* calls cycle through the list of ready file descriptors.
    This is useful because it helps prevent file-descriptor starvation, which could
    occur if *epoll_wait()* always (for example) returned the lowest-numbered ready
    file descriptor, and that file descriptor always had some input available.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连续的*epoll_wait()*调用会循环遍历准备好的文件描述符列表。这很有用，因为它有助于防止文件描述符饥饿，如果*epoll_wait()*总是（例如）返回最小编号的准备好的文件描述符，并且该文件描述符始终有输入可用，就可能发生饥饿。
- en: '[Chapter 64](ch64.html "Chapter 64. Pseudoterminals")'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第64章](ch64.html "第64章. 伪终端")'
- en: First, the child shell process terminates, followed by the *script* parent process.
    Since the terminal is operating in raw mode, the *Control-D* character is not
    interpreted by the terminal driver, but is instead passed as a literal character
    to the *script* parent process, which writes it to the pseudoterminal master.
    The pseudoterminal slave is operating in canonical mode, so this *Control-D* character
    is treated as an end-of-file, which causes the child shell’s next *read()* to
    return 0, with the result that the shell terminates. The termination of the shell
    closes the only file descriptor referring to the pseudoterminal slave. As a consequence,
    the next *read()* by the parent *script* process fails with the error `EIO` (or
    end-of-file on some other UNIX implementations), and this process then terminates.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，子 shell 进程终止，然后是*script*父进程终止。由于终端处于原始模式，*Control-D*字符不会被终端驱动程序解释，而是作为字面字符传递给*script*父进程，后者将其写入伪终端主设备。伪终端从设备处于规范模式，因此*Control-D*字符被视为文件结束符，这导致子
    shell 的下一个*read()*返回0，从而导致 shell 终止。shell 的终止关闭了唯一一个指向伪终端从设备的文件描述符。因此，父进程*script*的下一次*read()*会失败，并返回错误`EIO`（或在其他一些
    UNIX 实现中为文件结束符），然后该进程终止。
- en: A solution is provided in the file `pty/unbuffer.c` in the source code distribution
    for this book.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案在本书的源代码分发包中的文件`pty/unbuffer.c`中提供。
