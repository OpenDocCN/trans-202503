- en: Appendix F. Solutions to Selected Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. File I/O: Further Details")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A solution is provided in the file `fileio/atomic_append.c` in the source code
    distribution for this book. Here is an example of the results that we see when
    we run this program as suggested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the combination of *lseek()* plus *write()* is not atomic, one instance
    of the program sometimes overwrote bytes written by the other instance. As a result,
    the file `f2` contains less than 2 million bytes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A call to *dup()* can be rewritten as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A call to *dup2()* can be rewritten as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first point to realize is that, since *fd2* is a duplicate of *fd1*, they
    both share a single open file description, and thus a single file offset. However,
    because *fd3* is created via a separate call to *open()*, it has a separate file
    offset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the first *write()*, the file contents are `Hello`,.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since *fd2* shares a file offset with *fd1*, the second *write()* call appends
    to the existing text, yielding `Hello, world`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lseek()* call adjusts the single file offset shared by *fd1* and *fd2*
    to point to the start of the file, and thus the third *write()* call overwrites
    part of the existing text to yield `HELLO, world`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The file offset for *fd3* has not so far been modified, and so points to the
    start of the file. Therefore, the final *write()* call changes the file contents
    to `Gidday world`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the program `fileio/multi_descriptors.c` in the source code distribution
    for this book to see these results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Processes")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the array *mbuf* is not initialized, it is part of the uninitialized data
    segment. Therefore, no disk space is required to hold this variable. Instead,
    it is allocated (and initialized to 0) when the program is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A demonstration of the incorrect usage of *longjmp()* is provided in the file
    `proc/bad_longjmp.c` in the source code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sample implementations of *setenv()* and *unsetenv()* are provided in the file
    `proc/setenv.c` in the source code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. Users and Groups")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two *getpwnam()* calls are executed before the *printf()* output string
    is constructed, and—since *getpwnam()* returns its result in a statically allocated
    buffer—the second call overwrites the result returned by the first call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. Process Credentials")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In considering the following, remember that changes to the effective user ID
    always also change the file-system user ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*real=2000, effective=2000, saved=2000, file-system=2000*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*real=1000, effective=2000, saved=2000, file-system=2000*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*real=1000, effective=2000, saved=0, file-system=2000*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*real=1000, effective=0, saved=0, file-system=2000*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*real=1000, effective=2000, saved=3000, file-system=2000*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Strictly speaking, such a process is unprivileged, since its effective user
    ID is nonzero. However, an unprivileged process can use the *setuid()*, *setreuid()*,
    *seteuid()*, or *setresuid()* calls to set its effective user ID to the same value
    as its real user ID or saved set-user-ID. Thus, this process could use one of
    these calls to regain privilege.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following code shows the steps for each system call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the exception of *setuid()*, the answers are the same as for the previous
    exercise, except that we can substitute the value 0 for the variable *e*. For
    *setuid()*, the following holds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Chapter 10](ch10.html "Chapter 10. Time")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The maximum unsigned 32-bit integer value is 4,294,967,295. Divided by 100 clock
    ticks per second, this corresponds to slightly more than 497 days. Divided by
    1 million (`CLOCKS_PER_SEC`), this corresponds to 71 minutes and 35 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. System and Process Information")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `sysinfo/procfs_user_exe.c` in the source
    code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html "Chapter 13. File I/O Buffering")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This sequence of statements ensures that the data written to a *stdio* buffer
    is flushed to the disk. The *fflush()* call flushes the *stdio* buffer for *fp*
    to the kernel buffer cache. The argument given to the subsequent *fsync()* is
    the file descriptor underlying *fp*; thus, the call flushes the (recently filled)
    kernel buffer for that file descriptor to disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When standard output is sent to a terminal, it is line-buffered, so that the
    output of the *printf()* call appears immediately, and is followed by the output
    of *write()*. When standard output is sent to a disk file, it is block-buffered.
    Consequently, the output of the *printf()* is held in a *stdio* buffer and is
    flushed only when the program exits (i.e., after the *write()* call). (A complete
    program containing the code of this exercise is available in the file `filebuff/mix23_linebuff.c`
    in the source code distribution for this book.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 15](ch15.html "Chapter 15. File Attributes")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *stat()* system call doesn’t change any file timestamps, since all it does
    is fetch information from the file i-node (and there is no *last i-node access*
    timestamp).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GNU C library provides just such a function, named *euidaccess()*, in the
    library source file `sysdeps/posix/euidaccess.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to do this, we must use two calls to *umask()*, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note, however, that this solution is not thread-safe, since threads share the
    process umask setting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A solution is provided in the file `files/chiflag.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 18](ch18.html "Chapter 18. Directories and Links")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using *ls -li* shows that the executable file has different i-node numbers after
    each compilation. What happens is that the compiler removes (unlinks) any existing
    file with the same name as its target executable, and then creates a new file
    with the same name. It is permissible to unlink an executable file. The name is
    removed immediately, but the file itself remains in existence until the process
    executing it terminates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file `myfile` is created in the subdirectory `test`. The *symlink()* call
    creates a relative link in the parent directory. Despite appearances, this is
    a dangling link, since it is interpreted relative to the location of the link
    file, and thus refers to a nonexistent file in the parent directory. Consequently,
    *chmod()* fails with the error `ENOENT` (“No such file or directory”). (A complete
    program containing the code of this exercise is available in the file `dirs_links/bad_symlink.c`
    in the source code distribution for this book.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `dirs_links/list_files_readdir_r.c`, which
    can be found in the source code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `dirs_links/file_type_stats.c`, which can
    be found in the source code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using *fchdir()* is more efficient. If we are performing the operation repeatedly
    within a loop, then with *fchdir()* we can perform one call to *open()* before
    executing the loop, and with *chdir()* we can place the *getcwd()* call outside
    the loop. Then we are measuring the difference between repeated calls to *fchdir(fd)*
    and *chdir(buf)*. Calls to *chdir()* are more expensive for two reasons: passing
    the *buf* argument to the kernel requires a larger data transfer between user
    space and kernel space, and the pathname in *buf* must be resolved to the corresponding
    directory i-node on each call. (Kernel caching of directory entry information
    reduces the work required for the second point, but some work must still be done.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 20](ch20.html "Chapter 20. Signals: Fundamental Concepts")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `signals/ignore_pending_sig.c` in the source
    code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `signals/siginterrupt.c` in the source code
    distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 22](ch22.html "Chapter 22. Signals: Advanced Features")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most UNIX implementations, Linux delivers standard signals before realtime
    signals (SUSv3 doesn’t require this). This makes sense, because some standard
    signals indicate critical conditions (e.g., hardware exceptions) that a program
    should deal with as soon as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replacing *sigsuspend()* plus a signal handler with *sigwaitinfo()* in this
    program provides a 25 to 40 percent speed improvement. (The exact figure varies
    somewhat across kernel versions.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 23](ch23.html "Chapter 23. Timers and Sleeping")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A modified program using *clock_nanosleep()* is provided in the file `timers/t_clock_nanosleep.c`
    in the source code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `timers/ptmr_null_evp.c` in the source code
    distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 24](ch24.html "Chapter 24. Process Creation")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first *fork()* call creates one new child. Both parent and child carry on
    to execute the second *fork()*, and thus each creates a further process, making
    a total of four processes. All four processes carry on to execute the next *fork()*,
    each creating a further child. Consequently, a total of seven new processes are
    created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `procexec/vfork_fd_test.c` in the source
    code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we call *fork()*, and then have the child call *raise()* to send itself a
    signal such as `SIGABRT`, this will yield a core dump file that closely mirrors
    the state of the parent at the time of the *fork()*. The *gdb gcore* command allows
    us to perform a similar task for a program, without needing to change the source
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a converse *kill()* call in the parent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And in the child, add a converse *sigsuspend()* call:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Chapter 25](ch25.html "Chapter 25. Process Termination")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming a two’s complement architecture, where -1 is represented by a bit pattern
    with all bits on, then the parent will see an exit status of 255 (all bits on
    in the least significant 8 bits, which are all that is passed back to the parent
    when it calls *wait())*. (The presence of the call *exit(-1)* in a program is
    usually a programmer error resulting from confusion with the -1 return used to
    indicate failure of a system call.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 26](ch26.html "Chapter 26. Monitoring Child Processes")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `procexec/orphan.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 27](ch27.html "Chapter 27. Program Execution")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *execvp()* function first fails to exec the file `xyz` in `dir1`, because
    execute permission is denied. It therefore continues its search in `dir2`, where
    it successfully execs `xyz`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `procexec/execlp.c` in the source code distribution
    of this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script specifies the *cat* program as its interpreter. The *cat* program
    “interprets” a file by printing its contents—in this case with the *-n* (line
    numbering) option enabled (as though we had entered the command *cat -n ourscript*).
    Thus, we would see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Two successive *fork()* calls yield a total of three processes related as parent,
    child, and grandchild. Having created the grandchild process, the child immediately
    exits, and is reaped by the *waitpid()* call in the parent. As a consequence of
    being orphaned, the grandchild is adopted by *init* (process ID of 1). The program
    doesn’t need to perform a second *wait()* call, since *init* automatically reaps
    the zombie when the grandchild terminates. Therein lies a possible use for this
    code sequence: if we need to create a child for which we can’t later wait, then
    this sequence can be used to ensure that no zombie results. One example of such
    a requirement is where the parent execs some program that is not guaranteed to
    perform a wait (and we don’t want to rely on setting the disposition of `SIGCHLD`
    to `SIG_IGN`, since the disposition of an ignored `SIGCHLD` after an *exec()*
    is left unspecified by SUSv3).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The string given to *printf()* doesn’t include a newline character, and therefore
    the output is not flushed before the *execlp()* call. The *execlp()* overwrites
    the existing program’s data segments (as well as the heap and stack), which contain
    the *stdio* buffers, and thus the unflushed output is lost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SIGCHLD` is delivered to the parent. If the `SIGCHLD` handler attempts to
    do a *wait()*, then the call returns an error (`ECHILD`) indicating that there
    were no children whose status could be returned. (This assumes that the parent
    had no other terminated children. If it did, then the *wait()* would block; or
    if *waitpid()* was used with the `WNOHANG` flag, *waitpid()* would return 0.)
    This is exactly the situation that may arise if a program establishes a handler
    for `SIGCHLD` before calling *system()*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 29](ch29.html "Chapter 29. Threads: Introduction")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two possible outcomes (both permitted by SUSv3): the thread deadlocks,
    blocked while trying to join with itself, or the *pthread_join()* call fails,
    returning the error `EDEADLK`. On Linux, the latter behavior occurs. Given a thread
    ID in *tid*, we can prevent such an eventuality using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the main thread terminates, *threadFunc()* will continue working with
    storage on the main thread’s stack, with unpredictable results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 31](ch31.html "Chapter 31. Threads: Thread Safety and Per-Thread Storage")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `threads/one_time_init.c` in the source code
    distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 33](ch33.html "Chapter 33. Threads: Further Details")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SIGCHLD` signal that is generated on child termination is process-directed.
    It may be delivered to any thread (not necessarily the one that called *fork()*)
    that is not blocking the signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 34](ch34.html "Chapter 34. Process Groups, Sessions, and Job Control")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that the program is part of a shell pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]*`some string`*[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The problem is that *grep* will be part of the same process group as *ourprog*,
    and therefore the *killpg()* call will also terminate the *grep* process. This
    is probably not desired, and is likely to confuse users. The solution is to use
    *setpgid()* to ensure that the child processes are placed in their own new group
    (the process ID of the first child could be used as the process group ID of the
    group), and then signal that process group. This also removes the need for the
    parent to make itself immune to the signal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the `SIGTSTP` signal is unblocked before raising it again, then there is
    a small window of time (between the calls to *sigprocmask()* and *raise()*) during
    which, if the user types a second suspend character (*Control-Z*), the process
    will be stopped while still in the handler. Consequently, two `SIGCONT` signals
    will be required to resume the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 35](ch35.html "Chapter 35. Process Priorities and Scheduling")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `procpri/demo_sched_fifo.c` in the source
    code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 36](ch36.html "Chapter 36. Process Resources")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `procres/rusage_wait.c` in the source code
    distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the files `rusage.c` and `print_rusage.c` in the `procres`
    subdirectory in the source code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 37](ch37.html "Chapter 37. Daemons")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `daemons/t_syslog.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 38](ch38.html "Chapter 38. Writing Secure Privileged Programs")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever a file is modified by an unprivileged user, the kernel clears the file’s
    set-user-ID permission bit. The set-group-ID permission bit is similarly cleared
    if the group-execute permission bit is enabled. (As detailed in Section 55.4,
    the combination of having the set-group-ID bit on while the group-execute bit
    is *off* has nothing to do with set-group-ID programs; instead, it is used to
    enable mandatory locking, and for this reason modifications to such a file don’t
    disable the set-group-ID bit.) Clearing these bits ensures that if the program
    file is writable by arbitrary users, then it can’t be modified and still retain
    its ability to give privileges to users executing the file. A privileged (`CAP_FSETID`)
    process can modify a file without the kernel clearing these permission bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 44](ch44.html "Chapter 44. Pipes and FIFOs")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `pipes/change_case.c` in the source code
    distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates a race condition. Suppose that between the time the server sees end-of-file
    and the time it closes the file reading descriptor, a client opens the FIFO for
    writing (this will succeed without blocking), and then writes data to the FIFO
    *after* the server has closed the reading descriptor. At this point, the client
    will receive a `SIGPIPE` signal, since no process has the FIFO open for reading.
    Alternatively, the client might be able to both open the FIFO and write data to
    it before the server closes the reading descriptor. In this case, the client’s
    data would be lost, and it wouldn’t receive a response from the server. As a further
    exercise, you could try to demonstrate these behaviors by making the suggested
    modification to the server and creating a special-purpose client that repeatedly
    opens the server’s FIFOs, sends a message to the server, closes the server’s FIFO,
    and reads the server’s response (if any).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One possible solution would be to set a timer on the *open()* of the client
    FIFO using *alarm()*, as described in Section 23.3\. This solution suffers from
    the drawback that the server would still be delayed for the period of the timeout.
    Another possible solution would be to open the client FIFO using the `O_NONBLOCK`
    flag. If this fails, then the server can assume a misbehaving client. This latter
    solution also requires changes to the client, which needs to ensure that it opens
    its FIFO (also using the `O_NONBLOCK` flag) prior to sending a request to the
    server. For convenience, the client should then turn off the `O_NONBLOCK` flag
    for the FIFO file descriptor, so that the subsequent *read()* call blocks. Finally,
    it is possible to implement a concurrent server solution for this application,
    with the main server process creating a child to send the response message to
    each client. (This would represent a rather resource-expensive solution in the
    case of this simple application.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other conditions that are not handled by this server remain. For example, it
    doesn’t handle the possibilities of the sequence number overflowing or a misbehaving
    client requesting large groups of sequence numbers in order to produce such overflows.
    The server also does not handle the possibility that the client specifies a negative
    value for the sequence length. Furthermore, a malicious client could create its
    reply FIFO, and then open the FIFO for reading and writing, and fill it with data
    before sending a request to the server; as a consequence, the server would be
    able to successfully open the reply FIFO, but would block when it tries to write
    the reply. As a further exercise, you could try to devise strategies for dealing
    with these possibilities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Section 44.8, we also noted another limitation that applies to the server
    in [Example 44-7](ch44.html#an_iterative_server_using_fifos "Example 44-7. An
    iterative server using FIFOs"): if a client sends a message that contains the
    wrong number of bytes, then the server will be out of step when reading all subsequent
    client messages. One simple way to deal with this problem is to discard the use
    of fixed-length messages in favor of the use of a delimiter character.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Chapter 45](ch45.html "Chapter 45. Introduction to System V IPC")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `svipc/t_ftok.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 46](ch46.html "Chapter 46. System V Message Queues")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The value 0 is a valid message queue identifier, but 0 can’t be used as a message
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 47](ch47.html "Chapter 47. System V Semaphores")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `svsem/event_flags.c` in the source code
    distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A reserve operation can be implemented by reading a byte from the FIFO. Conversely,
    a release operation can be implemented by writing a byte to the FIFO. A conditional
    reserve operation can be implemented as a nonblocking read of a byte from the
    FIFO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 48](ch48.html "Chapter 48. System V Shared Memory")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since access to the *shmp-> cnt* value in the `for` loop increment step is no
    longer protected by the semaphore, there is a race condition between the writer
    next updating this value and the reader fetching it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `svshm/svshm_mon.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 49](ch49.html "Chapter 49. Memory Mappings")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `mmap/mmcopy.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 50](ch50.html "Chapter 50. Virtual Memory Operations")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `vmem/madvise_dontneed.c` in the source code
    distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 52](ch52.html "Chapter 52. POSIX Message Queues")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `pmsg/mq_notify_sigwaitinfo.c` in the source
    code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It would not be safe to make *buffer* global. Once message notification is reenabled
    in *threadFunc()*, there is a chance that a second notification would be generated
    while *threadFunc()* is still executing. This second notification could initiate
    a second thread that executes *threadFunc()* at the same time as the first thread.
    Both threads would attempt to use the same global *buffer*, with unpredictable
    results. Note that the behavior here is implementation-dependent. SUSv3 permits
    an implementation to sequentially deliver notifications to the same thread. However,
    it is also permissible to deliver notifications in separate threads that execute
    concurrently, and this is what Linux does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 53](ch53.html "Chapter 53. POSIX Semaphores")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `psem/psem_timedwait.c` in the source code
    distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 55](ch55.html "Chapter 55. File Locking")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following hold for *flock()* on Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A series of shared locks can starve a process waiting to place an exclusive
    lock.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There are no rules regarding which process is granted the lock. Essentially,
    the lock is granted to the process that is next scheduled. If that process happens
    to be one that obtains a shared lock, then all other processes requesting shared
    locks will also be able to have their requests granted simultaneously.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The *flock()* system call doesn’t detect deadlock. This is true of most *flock()*
    implementations, except those that implement *flock()* in terms of *fcntl()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In all except early (1.2 and earlier) Linux kernels, the two types of locking
    operate independently, and have no affect on one another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 57](ch57.html "Chapter 57. Sockets: UNIX Domain")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Linux, the *sendto()* call fails with the error `EPERM`. On some other UNIX
    systems, a different error results. Some other UNIX implementations don’t enforce
    this constraint, letting a connected UNIX domain datagram socket receive datagrams
    from a sender other than its peer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 59](ch59.html "Chapter 59. Sockets: Internet Domains")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the files `read_line_buf.h` and `read_line_buf.c`
    in the `sockets` subdirectory in the source code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the files `is_seqnum_v2_sv.c`, `is_seqnum_v2_cl.c`,
    and `is_seqnum_v2.h` in the `sockets` subdirectory in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the files `unix_sockets.h`, `unix_sockets.c`, `us_xfr_v2.h`,
    `us_xfr_v2_sv.c`, and `us_xfr_v2_cl.c` in the `sockets` subdirectory in the source
    code distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Internet domain, datagrams from a nonpeer socket are silently discarded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 60](ch60.html "Chapter 60. Sockets: Server Design")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `sockets/is_echo_v2_sv.c` in the source code
    distribution for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 61](ch61.html "Chapter 61. Sockets: Advanced Topics")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the send and receive buffers for a TCP socket have a limited size, if
    the client sent a large quantity of data, then it might fill these buffers, at
    which point a further *write()* would (permanently) block the client before it
    read any of the server’s response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `sockets/sendfile.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 62](ch62.html "Chapter 62. Terminals")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *tcgetattr()* fails if it is applied to a file descriptor that doesn’t refer
    to a terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `tty/ttyname.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 63](ch63.html "Chapter 63. Alternative I/O Models")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is provided in the file `altio/select_mq.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A race condition would result. Suppose the following sequence of events: (a)
    after *select()* has informed the program that the self-pipe has data, it performs
    the appropriate actions in response to the signal; (b) another signal arrives,
    and the handler writes a byte to the self-pipe and returns; and (c) the main program
    drains the self-pipe. As a consequence, the program misses the signal that was
    delivered in step (b).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *epoll_wait()* call blocks, even when the interest list is empty. This can
    be useful in a multithreaded program, where one thread might add a descriptor
    to the *epoll* interest list, while another thread is blocked in an *epoll_wait()*
    call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Successive *epoll_wait()* calls cycle through the list of ready file descriptors.
    This is useful because it helps prevent file-descriptor starvation, which could
    occur if *epoll_wait()* always (for example) returned the lowest-numbered ready
    file descriptor, and that file descriptor always had some input available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 64](ch64.html "Chapter 64. Pseudoterminals")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, the child shell process terminates, followed by the *script* parent process.
    Since the terminal is operating in raw mode, the *Control-D* character is not
    interpreted by the terminal driver, but is instead passed as a literal character
    to the *script* parent process, which writes it to the pseudoterminal master.
    The pseudoterminal slave is operating in canonical mode, so this *Control-D* character
    is treated as an end-of-file, which causes the child shell’s next *read()* to
    return 0, with the result that the shell terminates. The termination of the shell
    closes the only file descriptor referring to the pseudoterminal slave. As a consequence,
    the next *read()* by the parent *script* process fails with the error `EIO` (or
    end-of-file on some other UNIX implementations), and this process then terminates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A solution is provided in the file `pty/unbuffer.c` in the source code distribution
    for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
