- en: '[3](nsp-boxall502581-0008.xhtml#rch03)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[3](nsp-boxall502581-0008.xhtml#rch03)'
- en: Getting and Displaying Input
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和显示输入
- en: '![](images/nsp-boxall502581-ct.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-boxall502581-ct.jpg)'
- en: AVR microcontrollers can process input from the outside world and react with
    output, which offers huge potential for interactive projects—for example, those
    that react to the surrounding temperature. In this chapter, you’ll program ATtiny85s
    and ATmega328P-PUs to detect input signals from external devices and put them
    to work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: AVR微控制器可以处理来自外部世界的输入并作出反应，这为互动项目提供了巨大的潜力——例如，能够响应周围温度的项目。在本章中，你将编程ATtiny85和ATmega328P-PU，检测外部设备的输入信号并加以应用。
- en: 'In particular, you will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，你将：
- en: • Learn about digital inputs and buttons.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 学习数字输入和按钮的使用。
- en: • Make decisions with `if...else` and `switch...case` statements.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`if...else`和`switch...case`语句做决策。
- en: • Use seven-segment LED displays to make a digital counter.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用七段LED显示器制作数字计数器。
- en: • Make a single-cell battery tester.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 制作一个单节电池测试仪。
- en: • Learn about the TMP36 temperature sensor.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 了解TMP36温度传感器。
- en: • Make a digital thermometer.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 制作一个数字温度计。
- en: Along the way, you’ll learn how to counter switch bounce with resistors, as
    well as gaining more experience with programming in C by creating your own functions
    and using floating-point variable and analog inputs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你将学习如何使用电阻来对抗开关弹跳，并通过创建自己的函数以及使用浮点变量和模拟输入，获得更多的C语言编程经验。
- en: '[Digital Inputs](nsp-boxall502581-0008.xhtml#rah0501)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[数字输入](nsp-boxall502581-0008.xhtml#rah0501)'
- en: 'In [Chapter 2](nsp-boxall502581-0012.xhtml#ch02) , you learned to use digital
    I/O pins as outputs. You can use the same pins to accept input from users and
    other components. Just like digital outputs, digital inputs have two states: instead
    of *on* or *off* , they’re *high* and *low* . Using digital I/O pins for input
    is similar to controlling the outputs, too. In this section, you’ll set up the
    DDR *x* , then monitor the value of another register called the *PINx* that stores
    the status of the digital input pins. Let’s get started!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](nsp-boxall502581-0012.xhtml#ch02)中，你学会了使用数字I/O引脚作为输出。你也可以使用这些引脚接收来自用户和其他组件的输入。和数字输出一样，数字输入也有两种状态：它们的状态分别是*高*和*低*，而不是*开*或*关*。使用数字I/O引脚作为输入与控制输出类似。在这一节中，你将设置DDR
    *x*，然后监控另一个寄存器的值，称为*PINx*，它存储数字输入引脚的状态。让我们开始吧！
- en: '[Introducing the Pushbutton](nsp-boxall502581-0008.xhtml#rbh0501)'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[介绍按钮](nsp-boxall502581-0008.xhtml#rbh0501)'
- en: One of the simplest forms of digital input is the *pushbutton* , shown in [Figure 3-1](nsp-boxall502581-0013.xhtml#f03001)
    . Pushbuttons are easy to insert into a solderless breadboard. When pressed, they
    allow an electrical current to pass, which your microcontroller can detect through
    a digital input.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的数字输入形式之一是*推按钮*，如[图3-1](nsp-boxall502581-0013.xhtml#f03001)所示。推按钮很容易插入到无焊面包板中。当按下时，它们允许电流通过，微控制器可以通过数字输入检测到电流。
- en: '![Four tactile buttons sitting on a solderless breadboard](images/nsp-boxall502581-f03001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![四个触觉按钮放置在无焊面包板上](images/nsp-boxall502581-f03001.jpg)'
- en: 'Figure 3-1: Simple pushbuttons on a breadboard'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1：面包板上的简单按键
- en: You’ll use pushbuttons in the [next project](nsp-boxall502581-0013.xhtml#pro8)
    , so note how the pushbutton at the bottom of [Figure 3-1](nsp-boxall502581-0013.xhtml#f03001)
    is inserted into the breadboard. The legs bridge rows 23 and 25 so that when you
    press the button, an electrical connection is made between those two rows. [Figure
    3-2](nsp-boxall502581-0013.xhtml#f03002) shows the schematic symbol for this type
    of pushbutton.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[下一个项目](nsp-boxall502581-0013.xhtml#pro8)中使用推按钮，因此请注意[图3-1](nsp-boxall502581-0013.xhtml#f03001)底部的按钮是如何插入到面包板上的。它的引脚跨越了23行和25行，这样当你按下按钮时，会在这两行之间建立电连接。[图3-2](nsp-boxall502581-0013.xhtml#f03002)展示了这种类型的按键的原理图符号。
- en: '![Schematic symbol for a four-legged tactile button](images/nsp-boxall502581-f03002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![四脚触觉按钮的原理图符号](images/nsp-boxall502581-f03002.jpg)'
- en: 'Figure 3-2: Pushbutton schematic symbol'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2：推按钮原理图符号
- en: The lines labeled 1 and 2 represent the pushbutton’s legs on one side, with
    3 and 4 representing the legs on the other side. When you compare the schematic
    symbol against the real pushbutton in [Figure 3-1](nsp-boxall502581-0013.xhtml#f03001)
    , the legs labeled 1 and 2 are in row 23, and the legs labeled 3 and 4 are in
    row 25\. The broken line represents an open switch inside the pushbutton. Pins
    1 and 2 are electrically connected, as are 3 and 4, so you don’t need to run a
    wire to both pins on each side of the button. When you press the button, the switch
    closes, allowing current to flow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '标记为 1 和 2 的线路代表按键的一侧脚，标记为 3 和 4 的线路代表另一侧的脚。当你将电路图符号与 [图3-1](nsp-boxall502581-0013.xhtml#f03001)
    中的实际按键进行比较时，标记为 1 和 2 的脚在第 23 行，标记为 3 和 4 的脚在第 25 行。虚线表示按键内部的开关。当你按下按钮时，开关闭合，允许电流流动，因此你不需要在按钮的两侧各接一根线。 '
- en: '[Reading the Status of Digital Input Pins](nsp-boxall502581-0008.xhtml#rbh0502)'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[读取数字输入引脚的状态](nsp-boxall502581-0008.xhtml#rbh0502)'
- en: Once you set an I/O pin to an input by assigning a value to `DDRB` , the status
    of each input pin is stored in the PIN *x* register. Just like the other registers,
    the PIN *x* register is 8 bits wide, and each bit corresponds to a physical I/O
    pin.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过将值赋给 `DDRB` 设置 I/O 引脚为输入，该输入引脚的状态将存储在 PIN *x* 寄存器中。像其他寄存器一样，PIN *x* 寄存器是
    8 位宽的，每一位对应一个物理 I/O 引脚。
- en: Think of the PIN *x* register as a binary number, where each bit represents
    the state of the matching physical pin. If a bit is 1, there is current at the
    pin and the pin is *high* ; if the bit is 0, there’s no current and the pin is
    *low* . For example, on an ATtiny85 with all I/O pins set to inputs, if pins 5 (PB0)
    and 6 (PB1) were high, then the PINB register would have a value of `0b00000011`
    .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将 PIN *x* 寄存器视为一个二进制数，其中每个位代表对应物理引脚的状态。如果某位为1，说明该引脚有电流，通过该引脚时为 *高电平*；如果某位为0，说明该引脚没有电流，通过时为
    *低电平*。例如，在所有 I/O 引脚都设置为输入的 ATtiny85 上，如果引脚 5（PB0）和 6（PB1）为高电平，那么 PINB 寄存器的值将是
    `0b00000011`。
- en: The numerical value of the PIN *x* register is assigned to an integer variable,
    which is then compared against another number. For example, to check whether input
    pins PB0 and PB1 are high, you would compare the value of PINB to `0b00000011`
    .
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: PIN *x* 寄存器的数值被赋给一个整数变量，然后与另一个数字进行比较。例如，要检查输入引脚 PB0 和 PB1 是否为高电平，你可以将 PINB 的值与
    `0b00000011` 进行比较。
- en: But enough theory—let’s build some simple circuits that demonstrate inputs and
    outputs with microcontrollers!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但够了理论——让我们来制作一些简单的电路，展示微控制器的输入和输出功能！
- en: '[Project 8: Blinking an LED on Command](nsp-boxall502581-0008.xhtml#rpro8)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目8：按命令闪烁 LED](nsp-boxall502581-0008.xhtml#rpro8)'
- en: In this project, you’ll experiment with ATtiny85 digital inputs by blinking
    an LED, as you did in [Chapter 2](nsp-boxall502581-0012.xhtml#ch02) . This time,
    however, that LED will blink only when you press a pushbutton.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将通过使 LED 闪烁来实验 ATtiny85 的数字输入，就像你在 [第2章](nsp-boxall502581-0012.xhtml#ch02)
    中做的那样。不过这次，只有在你按下按键时，LED 才会闪烁。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0503)'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh0503)'
- en: 'You will need the following hardware:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • ATtiny85–20PU microcontroller
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATtiny85–20PU 微控制器
- en: • One LED
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 LED
- en: • One 560 Ω resistor
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 560 Ω 电阻
- en: • One pushbutton
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个按键
- en: • One 10 kΩ resistor
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 10 kΩ 电阻
- en: • Jumper wires
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: Assemble the circuit shown in [Figure 3-3](nsp-boxall502581-0013.xhtml#f03003)
    on your breadboard. When you’re done experimenting with this project, keep the
    circuit together; you’ll use it for [Projects 9](nsp-boxall502581-0013.xhtml#pro9)
    , [10](nsp-boxall502581-0013.xhtml#pro10) , and [11](nsp-boxall502581-0013.xhtml#pro11)
    as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在面包板上组装 [图3-3](nsp-boxall502581-0013.xhtml#f03003) 中显示的电路。实验完成后，将电路保留在一起；你将在
    [项目9](nsp-boxall502581-0013.xhtml#pro9)、[项目10](nsp-boxall502581-0013.xhtml#pro10)
    和 [项目11](nsp-boxall502581-0013.xhtml#pro11) 中继续使用这个电路。
- en: '![Schematic diagram for Project 8](images/nsp-boxall502581-f03003.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![项目8的电路图](images/nsp-boxall502581-f03003.jpg)'
- en: 'Figure 3-3: The main circuit for [Project 8](nsp-boxall502581-0013.xhtml#pro8)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3： [项目8](nsp-boxall502581-0013.xhtml#pro8) 的主要电路
- en: With your circuit assembled, connect the USBasp programmer to the ATtiny85\.
    Repeat the connections as shown in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201)
    in [Chapter 2](nsp-boxall502581-0012.xhtml#ch02) .
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将电路组装好后，将 USBasp 编程器连接到 ATtiny85。按照 [第2-1表](nsp-boxall502581-0012.xhtml#tab0201)
    中的连接方式与 [第2章](nsp-boxall502581-0012.xhtml#ch02) 中的说明重复连接。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0504)'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh0504)'
- en: Open a terminal window, navigate to the *Project 8* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` . The toolchain will compile
    the program file and then upload the data to the microcontroller. At this point,
    the circuit won’t do anything until you press the button. When you do so, the
    LED should stay on for about one second.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到本书*第3章*文件夹下的*第8项目*子文件夹，然后输入命令`make flash`。工具链将编译程序文件，并将数据上传到微控制器。此时，电路不会执行任何操作，直到你按下按钮。当你按下时，LED应保持亮起约一秒钟。
- en: 'Let’s see how this works. Open the *main.c* file for [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    :'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的。打开[第8项目](nsp-boxall502581-0013.xhtml#pro8)的*main.c*文件：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code tells the microcontroller to continually check whether pin 3 (PB4)
    is high. If it is, we turn on an LED connected to pin 5 (PB0) for about one second.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉微控制器不断检查引脚3（PB4）是否为高电平。如果是，我们会将连接到引脚5（PB0）的LED点亮约一秒钟。
- en: First we set the DDRB register so that pins PB0 to PB3 are outputs and pins
    PB4 to PB7 are inputs ❶. Although the ATtiny85 only has eight pins in total, and
    up to six for inputs and outputs, we still include all eight bits in the `DDRB`
    statement. Next, we turn off the internal pullup resistors ❷. (I’ll return to
    pullup resistors later in this chapter.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置DDRB寄存器，使得PB0到PB3为输出，PB4到PB7为输入❶。虽然ATtiny85总共有八个引脚，并且最多有六个引脚用于输入和输出，但我们仍然在`DDRB`语句中包含所有八个引脚。接下来，我们关闭内部上拉电阻❷。（稍后我会在本章中详细讲解上拉电阻。）
- en: After that, the program compares the value of the PINB register to the value
    `0b00010000` ❸. If an electrical current is present at PB4 (pin 3), the fourth
    bit will be 1 and thus the PINB register will match `0b00010000` . If the comparison
    results in two equal numbers, the code between the curly brackets will run ❹,
    turning the LED on for a second and then off again.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，程序将PINB寄存器的值与`0b00010000`进行比较❸。如果PB4（引脚3）上有电流，第四位将为1，因此PINB寄存器将与`0b00010000`匹配。如果比较结果为相等，花括号中的代码将运行❹，使LED亮起一秒钟，然后熄灭。
- en: In the next section we’ll take a closer look at `if` statements like the one
    in this project, which are used to make comparisons and decisions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将详细了解像本项目中的`if`语句，这些语句用于进行比较和决策。
- en: '[Making Decisions in Code](nsp-boxall502581-0008.xhtml#rah0502)'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码中的决策](nsp-boxall502581-0008.xhtml#rah0502)'
- en: Sometimes you’ll want certain code to run only if a condition is true or false,
    such as whether or not a button is pressed. You can use `if` statements, `if...else`
    statements, and `switch...case` statements to test those conditions and decide
    what code to execute next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你希望某些代码仅在条件为真或为假时才执行，比如按钮是否被按下。你可以使用`if`语句、`if...else`语句和`switch...case`语句来测试这些条件，并决定接下来要执行的代码。
- en: '[if Statements](nsp-boxall502581-0008.xhtml#rbh0505)'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[if语句](nsp-boxall502581-0008.xhtml#rbh0505)'
- en: The first line of an `if` statement like the one in [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    tests for a condition. If the condition is true (in [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    , if the value of `PINB` matches the number `0b00010000` ), then the code in the
    curly brackets executes. If the condition is false, then the code in the curly
    brackets is ignored.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[第8项目](nsp-boxall502581-0013.xhtml#pro8)中的`if`语句的第一行测试一个条件。如果条件为真（在[第8项目](nsp-boxall502581-0013.xhtml#pro8)中，如果`PINB`的值与`0b00010000`相匹配），那么花括号中的代码将执行。如果条件为假，则花括号中的代码将被忽略。
- en: 'To test conditions, you’ll use one or more of the following *comparison operators*
    inside the `if` statement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试条件，你将在`if`语句中使用以下一个或多个*比较运算符*：
- en: '• Equal to: `==`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 等于：`==`
- en: '• Not equal to: `!=`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 不等于：`!=`
- en: '• Greater than: `>`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 大于：`>`
- en: '• Less than: `<`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 小于：`<`
- en: '• Greater than or equal to: `>=`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 大于或等于：`>=`
- en: '• Less than or equal to: `<=`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 小于或等于：`<=`
- en: Over time, you’ll use the comparison operators more often and they’ll become
    second nature.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你将更频繁地使用比较运算符，它们会变得像第二天性一样。
- en: Warning One common mistake is to use a single equal sign ( `=` ), which means
    “make equal to,” in a test statement instead of a double equal sign ( `==` ),
    which says, “test if it is equal to.” You may not get an error message from the
    toolchain, but your code probably won’t work properly!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：一个常见的错误是，在测试语句中使用单个等号（`=`），它表示“设为相等”，而不是使用双等号（`==`），它表示“测试是否相等”。你可能不会收到工具链的错误消息，但你的代码可能无法正常工作！
- en: You can also make various types of comparisons where there are two or more options
    to choose from, which can save code space. These are explained in the following
    sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以进行各种类型的比较，其中有两个或更多选项供你选择，这可以节省代码空间。以下各节会解释这些情况。
- en: '[if . . . else Statements](nsp-boxall502581-0008.xhtml#rbh0506)'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[if ... else 语句](nsp-boxall502581-0008.xhtml#rbh0506)'
- en: 'You can add another action to an `if` statement using `else` . For example,
    you can rewrite the code in [Project 8](nsp-boxall502581-0013.xhtml#pro8) as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`else`为`if`语句添加另一个动作。例如，你可以将[项目 8](nsp-boxall502581-0013.xhtml#pro8)中的代码重写如下：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this modification, the LED turns on if you press the button and off if
    you don’t press the button.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此修改，当你按下按钮时，LED会亮起，若不按下按钮，LED则熄灭。
- en: '[Making Two or More Comparisons](nsp-boxall502581-0008.xhtml#rbh0507)'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[进行两项或更多比较](nsp-boxall502581-0008.xhtml#rbh0507)'
- en: 'You can also use two or more comparisons in the same `if` using *comparison
    operators* . For example, to compare the value of the integer variable `counter`
    against a range between 23 and 42, use two comparisons joined with the AND operator,
    `&&` :'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在同一个`if`语句中使用两个或更多条件，通过*比较运算符*来实现。例如，要将整数变量`counter`的值与23和42之间的范围进行比较，可以使用两个条件并通过AND运算符`&&`将其连接起来：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the AND operator used for comparisons ( `&&` ) is different from the
    bitwise arithmetic AND operator ( `&` ) introduced in [Chapter 2](nsp-boxall502581-0012.xhtml#ch02)
    .
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用于比较的AND运算符（`&&`）与在[第2章](nsp-boxall502581-0012.xhtml#ch02)中介绍的按位算术AND运算符（`&`）不同。
- en: 'You can also use an OR comparison. For example, if you need to test for cases
    in which the value of the `counter` variable is less than 100 or greater than
    115, use two comparisons joined with the operator `||` :'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用OR比较。例如，如果你需要测试`counter`变量的值是否小于100或大于115，可以使用两个条件并通过`||`运算符将其连接起来：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You’ll expand your knowledge of these useful operators in later projects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在后续项目中扩展对这些有用运算符的理解。
- en: '[switch . . . case Statements](nsp-boxall502581-0008.xhtml#rbh0508)'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[switch ... case 语句](nsp-boxall502581-0008.xhtml#rbh0508)'
- en: To compare two or more variables, it’s easier to use a `switch...case` statement
    instead of several `if...else` statements. The `switch...case` statement runs
    code when one of the defined comparisons is true.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较两个或多个变量，使用`switch...case`语句比使用多个`if...else`语句更为简便。`switch...case`语句会在某个已定义的条件为真时执行代码。
- en: 'For example, say you want to run different code for each possible value of
    the integer variable `counter` , 1, 2, or 3\. You could use one `switch...case`
    statement instead of multiple `if...else` statements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你希望根据整数变量`counter`的值分别执行不同的代码，如1、2或3。你可以使用一个`switch...case`语句，而不是多个`if...else`语句：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The optional `default` section at the end of this code lets you run code when
    there aren’t any true comparisons in the `switch...case` statement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码末尾的可选`default`部分让你在`switch...case`语句中没有任何条件为真的情况下执行代码。
- en: '[Creating Your Own Functions](nsp-boxall502581-0008.xhtml#rah0503)'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[创建你自己的函数](nsp-boxall502581-0008.xhtml#rah0503)'
- en: Sooner or later, you’ll want to repeat sections of code more than once or define
    your own set of instructions. You can achieve both goals by creating your own
    functions that either take care of a task, accept variables and act upon them,
    or return a value as their result, like a mathematical function. We’ll discuss
    these three types of functions in the next three projects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早，你会希望多次重复某些代码段或定义自己的指令集。你可以通过创建自己的函数来实现这两个目标，函数可以处理任务、接收变量并对其进行操作，或者像数学函数一样返回一个结果值。我们将在接下来的三个项目中讨论这三种类型的函数。
- en: 'The first type of function simply repeats some code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种类型的函数仅仅是重复一些代码：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, `name()` is a placeholder. You can name your function almost
    anything you’d like, but the name must always be preceded with `void` . Additionally,
    you can’t use *reserved keywords* in your own creations, since the language already
    uses them. For example, you can’t call a function `void void()` because `void`
    is a reserved keyword in C, C++, and other languages. You can find a complete
    list of reserved keywords in C at [https://en.cppreference.com/w/c/keyword](https://en.cppreference.com/w/c/keyword)
    .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`name()`是一个占位符。你可以将你的函数命名为任何你喜欢的名称，但名称必须始终以`void`为前缀。此外，你不能在自己的创建中使用*保留字*，因为这些词已经在语言中被使用。例如，你不能将函数命名为`void
    void()`，因为`void`在C、C++等语言中是保留字。你可以在[https://en.cppreference.com/w/c/keyword](https://en.cppreference.com/w/c/keyword)找到C语言的完整保留字列表。
- en: The function’s code goes inside the curly brackets. Always put your custom functions
    before the `int main(void)` section of your code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的代码放在花括号内。始终将自定义函数放在`int main(void)`部分之前。
- en: '[Project 9: A Simple Custom Function](nsp-boxall502581-0008.xhtml#rpro9)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 9：一个简单的自定义函数](nsp-boxall502581-0008.xhtml#rpro9)'
- en: This project demonstrates the creation of a simple custom function that performs
    a task. Using the hardware from [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    , open a terminal window, navigate to the *Project 9* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` to upload the code for
    [Project 9](nsp-boxall502581-0013.xhtml#pro9) as usual. You should see the LED
    blink twice every five seconds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目演示了创建一个执行任务的简单自定义函数。使用[项目 8](nsp-boxall502581-0013.xhtml#pro8)的硬件，打开终端窗口，导航到本书*第3章*文件夹中的*项目
    9*子文件夹，并输入命令`make flash`，按照常规上传[项目 9](nsp-boxall502581-0013.xhtml#pro9)的代码。你应该会看到LED每五秒闪烁两次。
- en: 'Let’s take a look at the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下代码：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The custom function `blinkTwice()` ❶ makes the LED blink twice, as it sets the
    entire PORTB register on and off twice with a short delay. Once you’ve created
    a function like this, you can call it anywhere in the code ❷.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义函数`blinkTwice()` ❶使LED闪烁两次，因为它会将整个PORTB寄存器开关两次，并且有短暂的延时。一旦你创建了这样的函数，你可以在代码的任何地方调用它
    ❷。
- en: 'What if you want to be able to easily change how many times the LED blinks?
    That’s where the second type of custom function—functions to which you can pass
    values—comes in handy:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望能够轻松地改变LED闪烁的次数，第二种自定义函数——可以传递值的函数——就派上用场了：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, you’ll give your function a name, but this time the parentheses will
    contain two parameters that will be used in the code inside the parentheses after
    the function name: `type` and `variable` , which specify the type and name of
    the variable being passed to the function, respectively.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你会给你的函数命名，但这次括号里会包含两个参数，它们将在函数名称后的代码中使用：`type` 和 `variable`，分别指定传递给函数的变量的类型和名称。
- en: '[Project 10: Custom Functions with Internal Variables](nsp-boxall502581-0008.xhtml#rpro10)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 10：带内部变量的自定义函数](nsp-boxall502581-0008.xhtml#rpro10)'
- en: This project demonstrates the creation of custom functions that accept variables
    as parameters, then act upon those variables. Using the same hardware from [Project
    8](nsp-boxall502581-0013.xhtml#pro8) , navigate to the *Project 10* subfolder
    of this book’s *Chapter 3* folder in your terminal window and enter the command
    `make flash` to upload the code for [Project 10](nsp-boxall502581-0013.xhtml#pro10)
    . You should see the LED blink on and off 11 times.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目演示了创建接受变量作为参数并对这些变量执行操作的自定义函数。使用[项目 8](nsp-boxall502581-0013.xhtml#pro8)的相同硬件，打开终端窗口，导航到本书*第3章*文件夹中的*项目
    10*子文件夹，并输入命令`make flash`，上传[项目 10](nsp-boxall502581-0013.xhtml#pro10)的代码。你应该会看到LED闪烁11次。
- en: 'Let’s take a look at the code in this project’s *main.c* file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个项目的*main.c*文件中的代码：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function `blinkLED(uint8_t blinks)` ❶ accepts an unsigned integer and uses
    it in a `for` loop to blink the LED that number of times. Now you can call the
    `blinkLED()` function with different values anywhere in your code. For example,
    in this project’s code we call `blinkLED(10)` ❷ to make the LED blink 11 times.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`blinkLED(uint8_t blinks)` ❶接受一个无符号整数，并在`for`循环中使用它来使LED闪烁指定的次数。现在，你可以在代码的任何地方用不同的值调用`blinkLED()`函数。例如，在这个项目的代码中，我们调用`blinkLED(10)`
    ❷使LED闪烁11次。
- en: 'To pass more than one variable into a custom function, just add a comma between
    each variable within the parentheses after the function name. For example, here
    I’ve added a second parameter, `blinkDelay` , to the `blinkLED()` function, which
    allows you to set the value of the delay between the LED turning on and off. This
    parameter is then passed into the `delay_ms()` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要将多个变量传递到自定义函数中，只需在函数名后的括号内，每个变量之间加上逗号。例如，这里我为`blinkLED()`函数添加了第二个参数`blinkDelay`，它允许你设置LED开关之间的延迟时间。这个参数接着被传递到`delay_ms()`函数中：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code for [Project 10](nsp-boxall502581-0013.xhtml#pro10) actually defines
    two custom functions: the first one is `delay_ms(int ms)` . Sometimes you might
    want a delay function in your code, and you’ll want to specify the length of that
    delay using a variable. That isn’t possible with the standard `_delay_ms()` function,
    so just create your own!'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 10 项工程](nsp-boxall502581-0013.xhtml#pro10)的代码实际上定义了两个自定义函数：第一个是`delay_ms(int
    ms)`。有时你可能需要在代码中使用延时函数，并且希望通过变量来指定延时的长度。使用标准的`_delay_ms()`函数无法做到这一点，所以你可以创建自己的延时函数！'
- en: '[Project 11: Custom Functions That Return Values](nsp-boxall502581-0008.xhtml#rpro11)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 11 项工程：返回值的自定义函数](nsp-boxall502581-0008.xhtml#rpro11)'
- en: 'In this project I’ll demonstrate the third type of custom function you can
    create: one that accepts one or more variables, uses them in a mathematical operation,
    and then returns the result.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我将演示第三种自定义函数的创建方式：接受一个或多个变量，在数学运算中使用它们，然后返回结果。
- en: 'Functions that return the result of an operation can be incredibly useful.
    Think of them as mathematical formula black boxes: values go in on one end, operations
    are performed on them, and the result pops out the other end. You can create such
    a function as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回操作结果的函数非常有用。可以把它们看作是数学公式的黑盒：数值从一端输入，进行运算，结果从另一端输出。你可以按如下方式创建这样的函数：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the variable you declare must be of the same type as the function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你声明的变量必须与函数返回的类型相同。
- en: Let’s put this into action. Using the same hardware from [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    , navigate to the *Project 11* subfolder of this book’s *Chapter 3* folder in
    your terminal window and enter the command `make flash` to upload the code for
    [Project 11](nsp-boxall502581-0013.xhtml#pro11) . You should see the LED blink
    12 times every 2 seconds.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其付诸实践。使用[第 8 项工程](nsp-boxall502581-0013.xhtml#pro8)中的相同硬件，在终端窗口中导航到本书*第
    3 章*文件夹的*第 11 项工程*子文件夹，输入命令`make flash`来上传[第 11 项工程](nsp-boxall502581-0013.xhtml#pro11)的代码。你应该会看到
    LED 每 2 秒闪烁 12 次。
- en: 'To see how this works, open the *main.c* file for this project:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解其工作原理，请打开本项目的*main.c*文件：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’re still blinking the LED (this is the last time, I promise!), but now we
    call `blinkLED` with `k` , which is set to the result of the `timesThree()` function.
    The `timesThree()` function multiplies an integer by three. First we declare what
    type of variable the function will return—in this case, an integer ( `uint8_t`
    ) ❶. This is followed by the function name, `timesThree()` , and the variable
    that will contain the number we pass into the function. Inside the function, we
    declare another variable to hold the result of the multiplication operation ❷.
    Next, we call `return` to pass the result back to the code ❸.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍在闪烁 LED（这是最后一次了，我保证！），但这次我们调用`blinkLED`，并将`k`设置为`timesThree()`函数的返回值。`timesThree()`函数将一个整数乘以三。首先我们声明该函数将返回的变量类型——在此为整数(`uint8_t`)
    ❶。接着是函数名称`timesThree()`和一个将保存传入函数的数字的变量。在函数内部，我们声明另一个变量来保存乘法操作的结果 ❷。然后，我们调用`return`将结果传回代码
    ❸。
- en: 'To actually use `timesThree()` in other parts of your program, just call it
    with an argument and set a variable equal to it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要在程序的其他部分实际使用`timesThree()`，只需传递一个参数并将变量设置为其返回值：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you gain more experience with microcontrollers, you’ll find that creating
    your own functions can save you quite a bit of time. For now, though, let’s turn
    to discussing possible problems that can arise when using buttons, and how to
    solve them in order to create more reliable projects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在微控制器方面经验的积累，你会发现创建自己的函数可以节省大量时间。不过现在，让我们讨论一下使用按钮时可能出现的问题，以及如何解决这些问题，以便创建更可靠的项目。
- en: '[Switch Bounce](nsp-boxall502581-0008.xhtml#rah0504)'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[开关抖动](nsp-boxall502581-0008.xhtml#rah0504)'
- en: Pushbuttons, which you first encountered in [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    , are prone to *switch bounce* (also known as *switch bouncing* ), a button’s
    tendency to turn on and off several times after being pressed only once by the
    user. Switch bounce occurs because the metal contacts inside a pushbutton are
    so small that they can vibrate after the button has been released, causing the
    switch to quickly and repeatedly open and close until the vibration ends.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮（你在[第 8 项工程](nsp-boxall502581-0013.xhtml#pro8)中首次接触到）容易出现*开关抖动*（也称为*开关弹跳*），即按钮在用户仅按下一次后，可能会多次开关。开关抖动是因为按键内部的金属接触点非常小，释放按钮后可能会发生震动，导致开关快速反复地打开和关闭，直到震动停止。
- en: Switch bounce can be observed using a *digital storage oscilloscope (DSO)* ,
    a device that plots the change in a voltage over a period of time. [Figure 3-4](nsp-boxall502581-0013.xhtml#f03004)
    shows a DSO displaying the voltage measured across a pushbutton during a switch
    bounce.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用*数字存储示波器（DSO）*观察开关反弹，DSO是一种绘制电压随时间变化的设备。[图3-4](nsp-boxall502581-0013.xhtml#f03004)显示了DSO在开关反弹期间测量的按钮电压。
- en: '![A screenshot showing electrical signals during switch bounce on an oscilloscope](images/nsp-boxall502581-f03004.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![示波器上显示开关反弹期间的电气信号的屏幕截图](images/nsp-boxall502581-f03004.jpg)'
- en: 'Figure 3-4: Measuring switch bounce'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4：测量开关反弹
- en: The top half of the display in [Figure 3-4](nsp-boxall502581-0013.xhtml#f03004)
    shows the result of the button being pressed several times. When the voltage line
    in the lower half of the image is at the higher horizontal position (5 V), the
    button is on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-4](nsp-boxall502581-0013.xhtml#f03004)中的显示器上半部分显示了按钮按下几次后的结果。当图像下半部分的电压线位于较高的水平位置（5
    V）时，按钮处于打开状态。'
- en: Underneath the word Stop at the top right, two vertical lines highlight a slice
    of time. The pushbutton voltage during this time is magnified in the bottom half
    of the screen. At A, the user releases the button and the line drops down to 0
    V. However, due to physical vibration, it immediately jumps back up to 5 V again
    until B, when it vibrates off and then on again until C, where it settles at the
    low (off) state. In effect, instead of relaying one button press to our microcontroller,
    we have unwittingly sent three.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角的"停止"字样下方，两条垂直线突出显示了一段时间。此时间段内按钮的电压被放大显示在屏幕的下半部分。在A处，用户释放按钮，电压线降至0 V。然而，由于物理振动，电压立即跃升至5
    V，直到B处，电压发生振荡后才重新归于低电平（关闭状态）直至C处。实际上，我们并没有向微控制器传递一次按钮按下，而是不经意地传递了三次。
- en: 'You can’t prevent switch bounce, but you can prevent your program from reacting
    to it: just use the `_delay_ms()` function to force the program to wait before
    executing any more code after detecting a button press. About 50 ms should be
    long enough, but test this with your own hardware to find the precise length of
    time that meets your needs.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法阻止开关反弹，但你可以防止程序对其做出反应：只需使用`_delay_ms()`函数，在检测到按钮按下后，强制程序在执行更多代码之前等待。大约50毫秒应该足够长，但请用你自己的硬件测试，找到满足你需求的确切时间长度。
- en: '[Protecting Your AVR from Fluctuating Voltages](nsp-boxall502581-0008.xhtml#rah0505)'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[保护你的AVR免受电压波动影响](nsp-boxall502581-0008.xhtml#rah0505)'
- en: In a perfect world, a digital input pin would see either a 5 V electrical signal
    (high) or no electrical signal (low). In reality, switch bounce and other imperfections
    can cause the voltage at an input pin to vary wildly between 5 V and 0 V.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，数字输入引脚要么接收到5 V的电信号（高电平），要么没有电信号（低电平）。但实际上，开关反弹和其他缺陷可能会导致输入引脚的电压在5 V和0
    V之间剧烈波动。
- en: Adding delays in your program helps prevent software malfunctions due to switch
    bounce, but these fluctuations can happen even when you’re not using the pin,
    which can confuse or even damage your AVR. Fortunately, you can protect the AVR
    with pullup or pulldown resistors.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中加入延迟有助于防止因开关反弹导致的软件故障，但即使在没有使用引脚时，这些波动也可能发生，这可能会混淆或甚至损坏你的AVR。幸运的是，你可以通过上拉或下拉电阻来保护AVR。
- en: '[Pullup Resistors](nsp-boxall502581-0008.xhtml#rbh0509)'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[上拉电阻](nsp-boxall502581-0008.xhtml#rbh0509)'
- en: A *pullup resistor* , illustrated in [Figure 3-5](nsp-boxall502581-0013.xhtml#f03005)
    , keeps the voltage at a digital input pin as close as possible to a high state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*上拉电阻*，如[图3-5](nsp-boxall502581-0013.xhtml#f03005)所示，可以将数字输入引脚的电压保持尽可能接近高电平。'
- en: '![Pullup resistor example schematic](images/nsp-boxall502581-f03005.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![上拉电阻示例原理图](images/nsp-boxall502581-f03005.jpg)'
- en: 'Figure 3-5: Example use of a pullup resistor'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5：上拉电阻的示例应用
- en: The voltage at input pin 3 on the microcontroller will always be connected to
    a high signal, until the button is pressed, at which point pin 3 will be directly
    connected to GND and become low. The resistor prevents you from shorting 5 V to
    GND (which can damage your hardware) when you press the button.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器输入引脚3的电压将始终连接到高电平信号，直到按钮被按下，此时引脚3将直接连接到GND并变为低电平。电阻器防止你在按下按钮时将5 V短路到GND（这可能会损坏硬件）。
- en: AVR microcontrollers have internal pullup resistors. This is a neat way to reduce
    the size of a circuit, but the catch is that you’ll have to invert the logic in
    your programs. For example, if you have a button connected between a digital input
    pin and GND and the internal pullups are enabled, the input goes low (instead
    of high) when the button is pressed. This is a small price to pay for convenience.
    To turn on the internal pullup resistors for pins that are set as inputs, write
    1s to the corresponding bits in PORT *x* ; to turn internal pullups off, write
    0s to those bits.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: AVR微控制器有内置的上拉电阻。这是一种减少电路体积的巧妙方式，但问题是，你需要在程序中反转逻辑。例如，如果你有一个按钮连接在数字输入引脚和地（GND）之间，并且内置上拉电阻已启用，那么按下按钮时，输入信号会变为低电平（而不是高电平）。这是为方便而付出的一个小代价。要为设置为输入的引脚启用内置上拉电阻，可以将1写入PORT
    *x*中的相应位；要关闭内置上拉电阻，可以将0写入这些位。
- en: '[Pulldown Resistors](nsp-boxall502581-0008.xhtml#rbh0510)'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[下拉电阻](nsp-boxall502581-0008.xhtml#rbh0510)'
- en: A *pulldown* resistor, illustrated in [Figure 3-6](nsp-boxall502581-0013.xhtml#f03006)
    , keeps the voltage at a digital input pin as close as possible to a low state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*下拉*电阻，如[图3-6](nsp-boxall502581-0013.xhtml#f03006)所示，可以将数字输入引脚的电压保持在尽可能低的状态。
- en: '![Pulldown resistor example schematic](images/nsp-boxall502581-f03006.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![下拉电阻示意图](images/nsp-boxall502581-f03006.jpg)'
- en: 'Figure 3-6: Example use of a pulldown resistor'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-6：下拉电阻的示例使用
- en: The voltage at pin 3 on the microcontroller connects to a low signal until the
    button is pressed. Then pin 3 directly connects to 5 V (high). Again, we use the
    resistor to avoid a dead short between the 5 V and GND when the button is pressed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器引脚3的电压在按钮未按下时保持低电平。当按钮被按下时，引脚3直接连接到5V（高电平）。再次提醒，我们使用电阻来避免当按钮按下时，5V与GND之间发生短路。
- en: '[Introducing Seven-Segment LED Displays](nsp-boxall502581-0008.xhtml#rah0506)'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[介绍七段式LED显示](nsp-boxall502581-0008.xhtml#rah0506)'
- en: 'One way to make your microcontroller react to input is by displaying a number.
    To do that, you can add a new component to your toolbox: the *seven-segment LED
    display* , shown in [Figure 3-7](nsp-boxall502581-0013.xhtml#f03007) .'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使微控制器响应输入的一种方式是通过显示一个数字。为此，你可以向工具箱中添加一个新组件：*七段式LED显示器*，如[图3-7](nsp-boxall502581-0013.xhtml#f03007)所示。
- en: '![Two examples of seven-segment LED displays](images/nsp-boxall502581-f03007.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![两个七段式LED显示器的示例](images/nsp-boxall502581-f03007.jpg)'
- en: 'Figure 3-7: Seven-segment LED display modules'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-7：七段式LED显示模块
- en: These small plastic bricks contain eight LEDs, arranged into a familiar digital-number
    display with a decimal point. You’ll find them in various household appliances,
    and they’re great for displaying numbers, letters, or even symbols.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小塑料积木包含八个LED，排列成一个熟悉的数字显示，带有小数点。你可以在各种家用电器中找到它们，它们非常适合显示数字、字母或符号。
- en: 'Seven-segment displays are available in a myriad of sizes and colors, and electrically
    they are the same as eight separate LEDs, with one catch: to reduce the number
    of pins used by the display, all of the anodes or cathodes of the LEDs are connected
    together. These are called *common-anode* and *common-cathode* configurations,
    respectively. All seven-segment displays in this book use common-cathode modules.
    The schematic symbol for this example display is shown in [Figure 3-8](nsp-boxall502581-0013.xhtml#f03008)
    .'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 七段显示器有多种尺寸和颜色可供选择，电气上，它们与八个独立的LED相同，但有一个注意点：为了减少显示器使用的引脚数，所有LED的阳极或阴极都被连接在一起。它们分别称为*共阳极*和*共阴极*配置。本书中所有的七段显示都使用共阴极模块。该示例显示器的原理符号如[图3-8](nsp-boxall502581-0013.xhtml#f03008)所示。
- en: '![Schematic symbol for a seven-segment LED display](images/nsp-boxall502581-f03008.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![七段式LED显示器的原理符号](images/nsp-boxall502581-f03008.jpg)'
- en: 'Figure 3-8: Schematic symbol for a seven-segment common-cathode LED display
    module'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-8：七段式共阴极LED显示模块的原理符号
- en: Next to each LED’s cathode is its matching segment. The display’s LEDs are labeled
    A to G and DP (for the decimal point) with an anode pin for each LED segment,
    and the cathodes are connected to one or two common cathode pins.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个LED的阴极旁边是其对应的段。显示器的LED从A到G以及DP（小数点）标记，每个LED段有一个阳极引脚，阴极则连接到一个或两个共阴极引脚。
- en: Seven-segment display pin layouts vary by manufacturer, so when you purchase
    them, make sure the supplier gives you the data sheet showing which pins are the
    anodes for each segment, and which pin is the cathode. If in doubt, note that
    most common models have pin 1 at the bottom-left corner of the display with the
    rest numbered counterclockwise. Remember that they’re still individual LEDs, and
    you’ll still need a current-limiting resistor for each one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 12: Building a Single-Digit Numerical Counter](nsp-boxall502581-0008.xhtml#rpro12)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consolidate what you’ve learned so far by making an interactive device
    that I hope will spur your imagination: a single-digit numerical counter. Your
    counter will have two buttons (one to increase the count, and another to reset
    the counter to zero) and a seven-segment display.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0511)'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One common-cathode seven-segment LED display
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Seven 560 Ω resistors (R1–R7)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two pushbuttons
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 10 kΩ resistors (R8, R9)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 3-9](nsp-boxall502581-0013.xhtml#f03009)
    .
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 12](images/nsp-boxall502581-f03009.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-9: The main circuit for [Project 12](nsp-boxall502581-0013.xhtml#pro12)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: By now you should remember on your own to connect the USBasp and wire it to
    the circuit before getting started, so after this project I’ll stop reminding
    you.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0512)'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 12* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` . Once you’ve uploaded
    the code to your microcontroller, press the button connected to PD0 to increase
    the counter, and press the other button to reset the count to zero.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file for [Project 12](nsp-boxall502581-0013.xhtml#pro12)
    :'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code defines a new function, `displayNumber()` , that receives an integer
    and sets the PORTB outputs to turn individual segments of the LED display on or
    off, thus displaying a digit from 0 to 9 ❶. By using a `switch...case` statement,
    the code can neatly decide which `PORTB` command to run based on what digit you
    want to display.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The variable `i` keeps track of what number you want to display ❷. This variable
    is initialized with a value of zero so that the counter starts at zero when the
    power is turned on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up the I/O pins, using PORTB as outputs for the LEDs and PORTD
    as inputs that detect when the buttons are pressed ❸. The internal pullup resistors
    are turned off for pins PD0 and PD1 ❹ because the buttons are connected to those
    pins, and the pullups are turned on for the rest of PORTD. This ensures that the
    unused pins in PORTD will always be high.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Every time the code loops, it first displays the value of the count ❺, then
    checks if the reset or count buttons have been pressed. Note that when the code
    compares `PIND` against the binary values representing button presses on PD0 ❻
    or PD1 ❼, the unused bits (or inputs) in the comparison are 1s, not 0s. This is
    because the internal pullup resistors have been activated for the unused inputs,
    keeping them at 1.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每次代码循环时，首先显示计数的值 ❺，然后检查重置或计数按钮是否已按下。请注意，当代码将`PIND`与表示PD0 ❻或PD1 ❼上按钮按下的二进制值进行比较时，比较中未使用的位（或输入）为1，而不是0。这是因为未使用的输入已激活了内部上拉电阻，使其保持为1。
- en: When you press the count button, the count variable `i` should increase by one.
    If the count is greater than 9, it should reset back to 0 because you’re working
    with a single-digit display.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按下计数按钮时，计数变量`i`应增加一。如果计数大于9，则应将其重置为0，因为您正在使用单位数显示器。
- en: Once you’ve completed this project, you’ll have a nifty display—but remember,
    you learn by doing. Experiment with this program! For example, try changing it
    to a countdown timer or creating changing patterns with the LEDs instead of numbers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个项目后，您将拥有一个精巧的显示器—但请记住，实践是学习的途径。尝试使用这个程序进行实验！例如，尝试将其改为倒计时器或者通过LED创建不同的模式而不是数字。
- en: If possible, keep this project assembled, as you’ll reuse most of it for [Project
    14](nsp-boxall502581-0013.xhtml#pro14) .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，请保持此项目组装完好，因为您将在[项目14](nsp-boxall502581-0013.xhtml#pro14)中重新使用大部分内容。
- en: '[Analog Inputs](nsp-boxall502581-0008.xhtml#rah0507)'
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[模拟输入](nsp-boxall502581-0008.xhtml#rah0507)'
- en: 'Up to this point, your projects have used digital electrical signals with just
    two levels: high and low. For your microcontrollers, high is close to 5 V and
    low is close to 0 V (or GND). We used the PORT *x* register to blink LEDs and
    the PIN *x* register to measure whether a digital input was high or low. [Figure 3-10](nsp-boxall502581-0013.xhtml#f03010)
    illustrates a digital signal measured with a DSO.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的项目使用了只有两个电平的数字电信号：高电平和低电平。对于您的微控制器而言，高电平接近5V，低电平接近0V（或GND）。我们使用PORT
    *x*寄存器来闪烁LED，并使用PIN *x*寄存器来检测数字输入是高还是低。[图3-10](nsp-boxall502581-0013.xhtml#f03010)展示了用DSO测量的数字信号。
- en: '![A screenshot of a digital signal in the form of a square wave displayed on
    an oscilloscope](images/nsp-boxall502581-f03010.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![示波器显示的方波数字信号截图](images/nsp-boxall502581-f03010.jpg)'
- en: 'Figure 3-10: A digital signal, with highs appearing as horizontal lines at
    the top and lows appearing at the bottom'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-10：数字信号，高电平显示为顶部的水平线，低电平显示为底部
- en: Unlike digital signals, *analog signals* can vary with an indefinite number
    of steps between high and low. For example, [Figure 3-11](nsp-boxall502581-0013.xhtml#f03011)
    shows an analog voltage signal that looks like a sine wave.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字信号不同，*模拟信号* 可以在高低之间的步骤数不定的情况下变化。例如，[图3-11](nsp-boxall502581-0013.xhtml#f03011)显示了一个类似正弦波的模拟电压信号。
- en: '![A screenshot of an analog signal in the form of a sine wave displayed on
    an oscilloscope](images/nsp-boxall502581-f03011.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![示波器显示的正弦模拟信号截图](images/nsp-boxall502581-f03011.jpg)'
- en: 'Figure 3-11: A sinusoidal analog signal'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-11：正弦模拟信号
- en: Notice that as time progresses, the voltage moves fluidly between high and low
    levels. Analog signals can represent all sorts of information from various devices,
    such as temperature or distance sensors. To use analog signals in your projects,
    you measure the voltage values of the signal using certain I/O pins in your microcontrollers,
    which are connected to *analog-to-digital converters (ADCs)* . An ADC can convert
    a voltage to a number, which you can then use in your code. Refer to the pinout
    and port register diagrams in [Chapter 2](nsp-boxall502581-0012.xhtml#ch02) ;
    the analog inputs are marked as ADC *x* for *analog-to-digital converter x* .
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意随着时间的推移，电压在高低电平之间流动。模拟信号可以表示各种设备的各种信息，例如温度或距离传感器。要在项目中使用模拟信号，您需要使用微控制器中连接到特定I/O引脚的电压值来测量信号，这些引脚连接到*模拟-数字转换器（ADCs）*
    。ADC可以将电压转换为数字，然后您可以在代码中使用。参考第[2章](nsp-boxall502581-0012.xhtml#ch02)中的引脚图和端口寄存器图示；模拟输入标记为ADC
    *x*代表*模拟-数字转换器x*。
- en: On the ATtiny85 you have PB0, PB1, PB2, and PB5 (physical pins 5–7 and 1). On
    the ATmega328P-PU you have a whole new register (PORTC), which has six ADCs from
    PC0 to PC5.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在ATtiny85上，您有PB0、PB1、PB2和PB5（物理引脚5–7和1）。在ATmega328P-PU上，您有一个全新的寄存器（PORTC），它具有从PC0到PC5的六个ADC。
- en: '[Using ATtiny85 ADCs](nsp-boxall502581-0008.xhtml#rah0508)'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[使用ATtiny85 ADCs](nsp-boxall502581-0008.xhtml#rah0508)'
- en: 'To set up the ADC pins on the ATtiny85, you’ll need to set two new registers.
    (Yes, more registers! You’ll get used to them the more you use them.) The first,
    ADMUX, selects which pin you’ll connect to the ADC. You’ll leave the first six
    bits as `001000` and use the last two bits to select the physical pin for the
    ADC. They’re `00` for ADC0 (pin 1), `01` for ADC1 (pin 7), `10` for ADC2 (pin
    3), and `11` for ADC3 (pin 2). For example, to use physical pin 3 as the analog
    input, set ADMUX as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second register to set, called ADCSRA, is responsible for several settings,
    including the speed of the ADC. All ATtiny85 projects in this book set the speed
    to 1 MHz. As the ADC section of the microcontroller operates at a different speed,
    you’ll use ADCSRA to set a prescale value that determines the ADC speed. You’ll
    typically use a prescaler of 8, which brings the ADC speed down to 125 kHz (which
    we calculate by dividing the speed of 1 MHz by 8). The matching ADCSRA line is:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It’s a good idea to put the two register settings in their own custom function,
    which you could name `startADC()` , for example. This keeps your code neat and
    makes it easy to call the function wherever you need it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: When using ADCs, it can be helpful to use a different way of addressing bits
    in a register—using bitwise operations. For now I’ll keep it simple and just show
    you how this works; we’ll revisit this topic (and the use of prescalers) in more
    detail in [Chapter 6](nsp-boxall502581-0016.xhtml#ch06) .
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'To measure a value from your preset ADC pin, first start the ADC with the line:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This sets the ADSC bit in the ADCSRA register to 1, which tells your ATtiny85
    to read the analog input and convert it to a value. When the ATtiny85 has finished,
    the ADSC bit returns to 0\. You’ll need to tell your code to wait a moment until
    this happens, like so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This compares the ADSC bit in the ADCSRA register to 1 and does nothing if they’re
    both 1\. When the ADC process is complete, the ADSC bit returns to 0, the `while()`
    function finishes, and the microcontroller progresses.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the value from the ADC is stored in the variable `ADCH` . The value
    of `ADCH` should be between 0 and 255\. You can then work with `ADCH` as required.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 13: Making a Single-Cell Battery Tester](nsp-boxall502581-0008.xhtml#rpro13)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll put your ATtiny85’s ADC to work by making a simple battery
    tester. You can use this to check the voltage of AA, AAA, C, or D cell batteries.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Warning Do not connect any battery (or other power source) with a voltage greater
    than 5 V to your tester, and don’t connect the battery the wrong way around (check
    the schematic in [Figure 3-12](nsp-boxall502581-0013.xhtml#f03012) ). Doing either
    will damage your ATtiny85.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: This tester uses two LEDs to indicate whether the battery is good (with a voltage
    greater than or equal to 1.4 V) or bad (with a voltage less than 1.4 V).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0513)'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny85–20PU microcontroller
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two LEDs
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 560 Ω resistor
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 3-12](nsp-boxall502581-0013.xhtml#f03012)
    . Note that the two wires labeled positive (+) and negative (−) are jumper wires
    used to contact the battery you want to test. Connect the + and − wires to the
    matching points on the battery.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 13](images/nsp-boxall502581-f03012.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-12: Schematic for [Project 13](nsp-boxall502581-0013.xhtml#pro13)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: You may find that it helps to use some insulation tape to keep the wires connected
    to the battery under test. You might also use red and green LEDs to indicate whether
    the battery under test is “bad” or “good.”
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0514)'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 13* subfolder of the *Chapter
    3* folder for this book, and enter the command `make flash` . Once you’ve uploaded
    the code, find a AA, AAA, C, or D cell battery, and connect the positive and negative
    leads to the circuit as shown in the schematic. If the voltage is greater than
    or equal to 1.4 V, LED2 should turn on; if it’s less than 1.4 V, LED1 should turn
    on.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this is implemented, open the *main.c* file for [Project 13](nsp-boxall502581-0013.xhtml#pro13)
    :'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '}The function `startADC()` sets physical pin 3 to use its ADC function and
    sets the prescaler for 1 MHz operation ❶. We need to call this function before
    using the ADC ❷. We then activate the ADC for a reading and wait for it to complete
    ❸.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The value from the ADC—a number between 0 and 255—is stored in the variable
    `ADCH` . This value maps to the voltage range of the ADC, which is 0 to 5 V. You
    can find the ADC value with some basic math:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: (Map Voltage × 256) / Supply Voltage = ADC Value
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we calculate the matching ADC value for 1.4 V as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: (1.4 V × 256 / 5 V) = 71.68
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Based on this calculation, 1.4 V maps to an ADC value of 71.4, which we round
    to 71 in our code because we’re using whole numbers in this project. This is the
    value used in the `if` statements at and to determine whether the battery is good
    to use ❹ or not ❺.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should understand how to read analog signals in the form
    of varying voltages from external devices. This is incredibly useful, as there
    are many types of sensors whose values are returned as a varying voltage and thus
    are easy to read with the ADC pin of your microcontroller.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the ADCs on the ATmega328P-PU, along with some more information
    about variable types.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the ATmega328P-PU ADCs](nsp-boxall502581-0008.xhtml#rah0509)'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up the ADC pins on the ATmega328P-PU is similar to setting them up
    on the ATtiny85\. You’ll start by setting up some registers. The first is ADMUX,
    which has two functions: indicating which ADC pin you want to use and selecting
    the source of the reference voltage the ADC compares against the analog signal
    being measured.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'First you’ll set the REFS0 bit in the ADMUX register to 1, which tells the
    microcontroller to use the voltage connected to AV [CC] (pin 20) for comparisons
    with analog signals. Again, you can use a bitwise operation for this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a simpler and less error-prone method of setting individual bits in
    a register, as it lets you avoid having to deal with all eight bits at once—you
    only set the bit you want to change. Also remember that you only need to set bits
    to 1, as by default they’re all 0.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’ll set the MUX2 and MUX0 bits to 1, which tells the ADC to read signals
    coming in on pin 28:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second register you’ll set, ADCSRA, activates the ADC and sets the speed
    of the ADC in the microcontroller. All your ATmega328P-PU projects from here until
    [Chapter 13](nsp-boxall502581-0023.xhtml#ch13) will use the speed 1 MHz, and the
    matching ADCSRA line is:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, you need to activate the ADC by setting the ADEN bit to 1:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As in [Project 12](nsp-boxall502581-0013.xhtml#pro12) , it’s a good idea to
    put the register settings in their own custom function, which I’ve named `startADC()`
    .
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to measure a value from the preset ADC pin, you first need to
    start the ADC as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This sets the ADSC bit in the ADCSRA register to 1, which tells your ATmega328P-PU
    to read the analog input and convert it to a value. This is not instantaneous;
    your code needs to wait until the ATmega328P-PU has finished the ADC reading,
    at which point the ADSC bit returns to 0\. The following is a convenient space-saving
    function that can be used to monitor changes of bits in registers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, it forces the code to wait until the ADSC bit returns to 0; when
    this happens, the ADC process is complete, and the code can then continue.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The value from the ADC is a 10-bit number, which the toolchain makes available
    in a virtual register variable called, you guessed it, `ADC` . However, for purposes
    where accuracy isn’t entirely necessary, you can just use an 8-bit value, dropping
    the last 2 bits off the ADC register like so:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where `ADCvalue` is an integer variable used to hold the value from the ADC.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when using the same power to run the microcontroller and its internal
    ADC, it’s wise to use a small smoothing capacitor over the positive and negative
    power supply lines, as shown in the [following project](nsp-boxall502581-0013.xhtml#pro14)
    .
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[Introducing the Variable Resistor](nsp-boxall502581-0008.xhtml#rah0510)'
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variable resistors, also known as *potentiometers* , can generally be adjusted
    from 0 Ω up to their rated value. [Figure 3-13](nsp-boxall502581-0013.xhtml#f03013)
    shows their schematic symbol.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![Potentiometer schematic symbol](images/nsp-boxall502581-f03013.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-13: Variable resistor (potentiometer) symbol'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Variable resistors have three electrical connections, one in the center and
    one on each side. As the shaft of the variable resistor is turned, it increases
    the resistance between one side and the center and decreases the resistance between
    the opposite side and the center.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable resistors can be either *linear* or *logarithmic* . The resistance
    of linear models changes at a constant rate when turning, while the resistance
    of logarithmic models changes slowly at first and then increases rapidly. Logarithmic
    potentiometers are used more often in audio amplifier circuits because they model
    the human hearing response. You can generally identify whether a potentiometer
    is logarithmic or linear via the marking on the rear. Most will have either an
    A or a B next to the resistance value: A for logarithmic, B for linear. Most projects
    use linear variable resistors such as the one shown in [Figure 3-14](nsp-boxall502581-0013.xhtml#f03014)
    .'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of a variable resistor](images/nsp-boxall502581-f03014.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-14: A typical linear variable resistor'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Miniature variable resistors are known as *trimpots* or *trimmers* (see [Figure
    3-15](nsp-boxall502581-0013.xhtml#f03015) ). Because of their size, trimpots are
    more useful for making adjustments in circuits, but they’re also very useful for
    breadboard work because they can be slotted in.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Three different styles of trimpot](images/nsp-boxall502581-f03015.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-15: Various trimpots'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: When shopping for trimpots, take note of the type. If possible, you’ll want
    one that is easy to adjust with the screwdriver you have on hand. The enclosed
    types pictured in [Figure 3-15](nsp-boxall502581-0013.xhtml#f03015) are also preferable,
    as they last longer than the cheaper, open-contact types.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 14: Experimenting with an ATmega328P-PU ADC](nsp-boxall502581-0008.xhtml#rpro14)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll experiment with an ADC on the larger ATmega328P-PU microcontroller,
    along with practicing with more involved decision-making code. This project measures
    the signal from a trimpot, which varies between 0 V and 5 V. The value falls into
    one of four ranges and is indicated by one of the four LEDs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0515)'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny328P-PU microcontroller
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Four LEDs
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Four 560 Ω resistors
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 0.1 μF ceramic capacitor
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ breadboard-compatible linear trimpot
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 3-16](nsp-boxall502581-0013.xhtml#f03016)
    .
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 14](images/nsp-boxall502581-f03016.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-16: Schematic for [Project 14](nsp-boxall502581-0013.xhtml#pro14)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t get a breadboard-compatible trimpot, you can use a full-size potentiometer,
    although you’ll need to solder jumper wires to the potentiometer’s three pins
    in order to make contact with the solderless breadboard.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0516)'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 14* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` to upload the code for
    [Project 14](nsp-boxall502581-0013.xhtml#pro14) as usual. Once you’ve uploaded
    the code, start slowly moving the trimpot toward one limit, then turn it through
    the other direction to the other limit. The LEDs should indicate which quartile
    of the trimpot range you are currently turning through.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine how this works. Open the *main.c* file for [Project 14](nsp-boxall502581-0013.xhtml#pro14)
    and take a look at the code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First we specify the pins used for outputs (LEDs—PORTB) and inputs for ADC ❷,
    then we call the function `startADC()` ❶ to set up the ADC ❸. We measure the value
    fed from the trimpot to the ADC via pin PC5 ❹ and store it into the integer variable
    `ADCvalue` ❻ after a short delay ❺ to give the ADC time to complete its conversion
    of data.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code evaluates the value of the ADC using a series of `if...else`
    functions ❼. Each of these checks if the ADC value falls within a certain range
    using the `AND` ( `&&` ) conditional operator, then activates an LED to provide
    a visual indication if the result of the test is true.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the LED is turned off at the end of the main loop after a short delay
    to allow time for indication, and the process starts again.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[Doing Arithmetic with an AVR](nsp-boxall502581-0008.xhtml#rah0511)'
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like a pocket calculator, the AVR can perform basic calculations for you. This
    is really handy when you’re dealing with analog-to-digital conversions. Here are
    some of the mathematical operations available for your AVR:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The C language handles some kinds of calculations a little differently than
    a pocket calculator, though. For example, when dividing two integers, the AVR
    simply discards the remainder rather than rounding the quotient up or down: 16
    divided by 2 equals 8, 10 divided by 3 equals 3, and 18 divided by 8 equals 2\.
    I’ll explain a few other oddities as they come up.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with numbers that have or will result in a decimal point (for
    example, dividing 1 by 3), you will need to use a new type of variable called
    a *float* . The values that can be stored in a float can fall between −3.39 ×
    10 ^(38) and 3.39 × 10 ^(38) . To use floating-point math in your code, you’ll
    need to include a new library:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You’ll get used to this math by using it in [Project 15](nsp-boxall502581-0013.xhtml#pro15)
    , along with your first analog sensor, which I’ll introduce next.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[Using External Power](nsp-boxall502581-0008.xhtml#rah0512)'
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point you’ve been powering your projects directly from the AVR programmer,
    which is a neat solution for small projects and experiments. However, this method
    leaves less than 5 V of output voltage available to your circuit, as the internal
    circuitry of the programmer reduces the voltage.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: If you use a multimeter to measure the voltage across pins 7 and 8 of your ATmega328P-PU
    in [Project 14](nsp-boxall502581-0013.xhtml#pro14) or others created earlier,
    you’ll find it’s less than 5 V. When working with parts that expect 5 V (such
    as the TMP36 used in the [next project](nsp-boxall502581-0013.xhtml#pro15) ),
    you’ll need an external power supply for accuracy and reliability.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: One easy way to add external 5 V power is to use a breadboard power supply module,
    such as the one from PMD Way (part number 20250303) shown in [Figure 3-17](nsp-boxall502581-0013.xhtml#f03017)
    .
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![Power supply module fitted to the end of a solderless breadboard](images/nsp-boxall502581-f03017.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-17: A breadboard power supply module'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The PMD Way module is inserted into the end of your breadboard and is powered
    by a common AC to DC wall wart power supply. The unit supplies 5 V or 3.3 V to
    both sides of the breadboard and has a neat power switch for control. It is a
    small and very convenient outlay.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[The TMP36 Temperature Sensor](nsp-boxall502581-0008.xhtml#rah0513)'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the TMP36 temperature sensor (shown in [Figure 3-18](nsp-boxall502581-0013.xhtml#f03018)
    ) and a little math, you can turn your AVR into a thermometer. This inexpensive
    and easy-to-use analog sensor outputs a voltage that changes with the temperature
    around it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![A TMP36 temperature sensor](images/nsp-boxall502581-f03018.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-18: The TMP36 temperature sensor'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The TMP36 has three legs. When you’re looking at the flat side of the sensor
    with the writing on it, the legs are (from left to right) voltage in, voltage
    out, and GND. You’ll connect pin 1 to the 5 V power in your projects, pin 2 to
    an analog input on the microcontroller, and pin 3 to GND. [Figure 3-19](nsp-boxall502581-0013.xhtml#f03019)
    shows the schematic symbol for the TMP36.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the TMP36 temperature sensor](images/nsp-boxall502581-f03019.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-19: Schematic symbol for the TMP36'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The voltage output from the TMP36 is a representation of the temperature around
    the sensor; for example, at 25 degrees Celsius, the output is 750 mV (or 0.75
    V), and for every change of one degree, the voltage output changes by 10 mV. The
    TMP36 can measure temperatures from −40 to 125 degrees Celsius, but for the [next
    project](nsp-boxall502581-0013.xhtml#pro15) you’ll just measure room temperatures.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: To determine the temperature from the voltage, multiply the value in ADC by
    5, then divide by 1,024, which gives you the actual voltage returned by the sensor.
    Next, subtract 0.5 (0.5 V is the offset used by the TMP36 to allow for temperatures
    below 0) then multiply by 100, which gives you the temperature in degrees Celsius.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Note If you want to work in Fahrenheit, multiply the Celsius value by 1.8 and
    add 32 to the result.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: As this is an analog device, the output voltage is determined by the input voltage.
    If you don’t have 5 V or very close to 5 V on the input, your output and thus
    the temperature reading will not be correct.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 15: Creating a Digital Thermometer](nsp-boxall502581-0008.xhtml#rpro15)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll use what you learned from [Project 12](nsp-boxall502581-0013.xhtml#pro12)
    to create a numeric display with the ADC on the ATmega328P-PU that acts as a digital
    thermometer. To keep things simple, this project will display temperatures starting
    from 0 degrees Celsius and going up; negative readings are not included.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0517)'
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build your thermometer, you’ll read the TMP36 analog temperature sensor with
    the microcontroller, which will then display the temperature one digit at a time
    using the seven-segment LED display from [Project 12](nsp-boxall502581-0013.xhtml#pro12)
    .
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One TMP36 temperature sensor
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One common-cathode seven-segment LED display
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Seven 560 Ω resistors (R1–R7)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 0.1 μF ceramic capacitor
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 3-20](nsp-boxall502581-0013.xhtml#f03020)
    .
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 15](images/nsp-boxall502581-f03020.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-20: Schematic for [Project 15](nsp-boxall502581-0013.xhtml#pro15)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the 0.1 μF capacitor to help maintain a smooth power supply to the
    TMP36 temperature sensor; it should be mounted as close as possible to the TMP36’s
    5 V and GND pins.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0518)'
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 15* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` to upload the code for
    [Project 15](nsp-boxall502581-0013.xhtml#pro15) as usual. Once you’ve uploaded
    the code, the LED module should display the approximate temperature one digit
    at a time. For example, if the temperature were 8 degrees Celsius, the display
    would show a 0, followed by a short delay, and then an 8.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file for [Project 15](nsp-boxall502581-0013.xhtml#pro15)
    and take a look at the code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code, we first include the necessary libraries (among them, *math.h*
    , for the floating-point math) ❶. We add the function `startADC()` to start the
    ADC ❷ (this function is called at the start of the main part of the code), and
    we reuse the `displayNumber()` function from [Project 12](nsp-boxall502581-0013.xhtml#pro12)
    ❸.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main section of the code, we declare the required variables, define
    the input and output pins, and initialize the ADC ❹. The main loop of the code
    is broken into five steps:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The voltage from the TMP36 is measured by the ADC and stored in the variable
    `ADCvalue` ❺.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Using the formula described in “Introducing the TMP36 Temperature Sensor,”
    the code converts the value of the ADC to a voltage. This voltage is then converted
    to the temperature in degrees Celsius ❻.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. The digits used to represent the temperature are extracted from `finalTemp`
    and then rounded up or down to the nearest whole number with `round()` . The code
    determines the left digit (for tens) by dividing the temperature by 10\. If the
    temperature is less than 10 degrees, this will be 0\. It determines the right
    digit (for ones) by taking the remainder from dividing the temperature by 10 with
    modulo ❼.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. The `displayNumber()` function is used to display the tens and ones digits
    of the temperature, respectively, with a quarter-second delay between the digits
    ❽.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5\. Finally, the display is turned off for a second ❾, giving a visual break
    between the displayed value and the new value to come.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This seemingly complex project just combines your existing knowledge in new
    ways, which I hope is starting to fire up your imagination. In [Chapter 4](nsp-boxall502581-0014.xhtml#ch04)
    , we’ll turn to a new topic: enabling bidirectional communication between your
    microcontroller and a PC for the purposes of data capture and control.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
