- en: '[3](nsp-boxall502581-0008.xhtml#rch03)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting and Displaying Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AVR microcontrollers can process input from the outside world and react with
    output, which offers huge potential for interactive projects—for example, those
    that react to the surrounding temperature. In this chapter, you’ll program ATtiny85s
    and ATmega328P-PUs to detect input signals from external devices and put them
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: • Learn about digital inputs and buttons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Make decisions with `if...else` and `switch...case` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Use seven-segment LED displays to make a digital counter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Make a single-cell battery tester.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Learn about the TMP36 temperature sensor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Make a digital thermometer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, you’ll learn how to counter switch bounce with resistors, as
    well as gaining more experience with programming in C by creating your own functions
    and using floating-point variable and analog inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Digital Inputs](nsp-boxall502581-0008.xhtml#rah0501)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 2](nsp-boxall502581-0012.xhtml#ch02) , you learned to use digital
    I/O pins as outputs. You can use the same pins to accept input from users and
    other components. Just like digital outputs, digital inputs have two states: instead
    of *on* or *off* , they’re *high* and *low* . Using digital I/O pins for input
    is similar to controlling the outputs, too. In this section, you’ll set up the
    DDR *x* , then monitor the value of another register called the *PINx* that stores
    the status of the digital input pins. Let’s get started!'
  prefs: []
  type: TYPE_NORMAL
- en: '[Introducing the Pushbutton](nsp-boxall502581-0008.xhtml#rbh0501)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the simplest forms of digital input is the *pushbutton* , shown in [Figure 3-1](nsp-boxall502581-0013.xhtml#f03001)
    . Pushbuttons are easy to insert into a solderless breadboard. When pressed, they
    allow an electrical current to pass, which your microcontroller can detect through
    a digital input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Four tactile buttons sitting on a solderless breadboard](images/nsp-boxall502581-f03001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: Simple pushbuttons on a breadboard'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use pushbuttons in the [next project](nsp-boxall502581-0013.xhtml#pro8)
    , so note how the pushbutton at the bottom of [Figure 3-1](nsp-boxall502581-0013.xhtml#f03001)
    is inserted into the breadboard. The legs bridge rows 23 and 25 so that when you
    press the button, an electrical connection is made between those two rows. [Figure
    3-2](nsp-boxall502581-0013.xhtml#f03002) shows the schematic symbol for this type
    of pushbutton.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for a four-legged tactile button](images/nsp-boxall502581-f03002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: Pushbutton schematic symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The lines labeled 1 and 2 represent the pushbutton’s legs on one side, with
    3 and 4 representing the legs on the other side. When you compare the schematic
    symbol against the real pushbutton in [Figure 3-1](nsp-boxall502581-0013.xhtml#f03001)
    , the legs labeled 1 and 2 are in row 23, and the legs labeled 3 and 4 are in
    row 25\. The broken line represents an open switch inside the pushbutton. Pins
    1 and 2 are electrically connected, as are 3 and 4, so you don’t need to run a
    wire to both pins on each side of the button. When you press the button, the switch
    closes, allowing current to flow.
  prefs: []
  type: TYPE_NORMAL
- en: '[Reading the Status of Digital Input Pins](nsp-boxall502581-0008.xhtml#rbh0502)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you set an I/O pin to an input by assigning a value to `DDRB` , the status
    of each input pin is stored in the PIN *x* register. Just like the other registers,
    the PIN *x* register is 8 bits wide, and each bit corresponds to a physical I/O
    pin.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the PIN *x* register as a binary number, where each bit represents
    the state of the matching physical pin. If a bit is 1, there is current at the
    pin and the pin is *high* ; if the bit is 0, there’s no current and the pin is
    *low* . For example, on an ATtiny85 with all I/O pins set to inputs, if pins 5 (PB0)
    and 6 (PB1) were high, then the PINB register would have a value of `0b00000011`
    .
  prefs: []
  type: TYPE_NORMAL
- en: The numerical value of the PIN *x* register is assigned to an integer variable,
    which is then compared against another number. For example, to check whether input
    pins PB0 and PB1 are high, you would compare the value of PINB to `0b00000011`
    .
  prefs: []
  type: TYPE_NORMAL
- en: But enough theory—let’s build some simple circuits that demonstrate inputs and
    outputs with microcontrollers!
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 8: Blinking an LED on Command](nsp-boxall502581-0008.xhtml#rpro8)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll experiment with ATtiny85 digital inputs by blinking
    an LED, as you did in [Chapter 2](nsp-boxall502581-0012.xhtml#ch02) . This time,
    however, that LED will blink only when you press a pushbutton.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0503)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny85–20PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 560 Ω resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One pushbutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 10 kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit shown in [Figure 3-3](nsp-boxall502581-0013.xhtml#f03003)
    on your breadboard. When you’re done experimenting with this project, keep the
    circuit together; you’ll use it for [Projects 9](nsp-boxall502581-0013.xhtml#pro9)
    , [10](nsp-boxall502581-0013.xhtml#pro10) , and [11](nsp-boxall502581-0013.xhtml#pro11)
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 8](images/nsp-boxall502581-f03003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: The main circuit for [Project 8](nsp-boxall502581-0013.xhtml#pro8)'
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp programmer to the ATtiny85\.
    Repeat the connections as shown in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201)
    in [Chapter 2](nsp-boxall502581-0012.xhtml#ch02) .
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0504)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 8* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` . The toolchain will compile
    the program file and then upload the data to the microcontroller. At this point,
    the circuit won’t do anything until you press the button. When you do so, the
    LED should stay on for about one second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works. Open the *main.c* file for [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code tells the microcontroller to continually check whether pin 3 (PB4)
    is high. If it is, we turn on an LED connected to pin 5 (PB0) for about one second.
  prefs: []
  type: TYPE_NORMAL
- en: First we set the DDRB register so that pins PB0 to PB3 are outputs and pins
    PB4 to PB7 are inputs ❶. Although the ATtiny85 only has eight pins in total, and
    up to six for inputs and outputs, we still include all eight bits in the `DDRB`
    statement. Next, we turn off the internal pullup resistors ❷. (I’ll return to
    pullup resistors later in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: After that, the program compares the value of the PINB register to the value
    `0b00010000` ❸. If an electrical current is present at PB4 (pin 3), the fourth
    bit will be 1 and thus the PINB register will match `0b00010000` . If the comparison
    results in two equal numbers, the code between the curly brackets will run ❹,
    turning the LED on for a second and then off again.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we’ll take a closer look at `if` statements like the one
    in this project, which are used to make comparisons and decisions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Making Decisions in Code](nsp-boxall502581-0008.xhtml#rah0502)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you’ll want certain code to run only if a condition is true or false,
    such as whether or not a button is pressed. You can use `if` statements, `if...else`
    statements, and `switch...case` statements to test those conditions and decide
    what code to execute next.
  prefs: []
  type: TYPE_NORMAL
- en: '[if Statements](nsp-boxall502581-0008.xhtml#rbh0505)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first line of an `if` statement like the one in [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    tests for a condition. If the condition is true (in [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    , if the value of `PINB` matches the number `0b00010000` ), then the code in the
    curly brackets executes. If the condition is false, then the code in the curly
    brackets is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test conditions, you’ll use one or more of the following *comparison operators*
    inside the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '• Equal to: `==`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Not equal to: `!=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Greater than: `>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Less than: `<`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Greater than or equal to: `>=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Less than or equal to: `<=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over time, you’ll use the comparison operators more often and they’ll become
    second nature.
  prefs: []
  type: TYPE_NORMAL
- en: Warning One common mistake is to use a single equal sign ( `=` ), which means
    “make equal to,” in a test statement instead of a double equal sign ( `==` ),
    which says, “test if it is equal to.” You may not get an error message from the
    toolchain, but your code probably won’t work properly!
  prefs: []
  type: TYPE_NORMAL
- en: You can also make various types of comparisons where there are two or more options
    to choose from, which can save code space. These are explained in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[if . . . else Statements](nsp-boxall502581-0008.xhtml#rbh0506)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can add another action to an `if` statement using `else` . For example,
    you can rewrite the code in [Project 8](nsp-boxall502581-0013.xhtml#pro8) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With this modification, the LED turns on if you press the button and off if
    you don’t press the button.
  prefs: []
  type: TYPE_NORMAL
- en: '[Making Two or More Comparisons](nsp-boxall502581-0008.xhtml#rbh0507)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use two or more comparisons in the same `if` using *comparison
    operators* . For example, to compare the value of the integer variable `counter`
    against a range between 23 and 42, use two comparisons joined with the AND operator,
    `&&` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the AND operator used for comparisons ( `&&` ) is different from the
    bitwise arithmetic AND operator ( `&` ) introduced in [Chapter 2](nsp-boxall502581-0012.xhtml#ch02)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use an OR comparison. For example, if you need to test for cases
    in which the value of the `counter` variable is less than 100 or greater than
    115, use two comparisons joined with the operator `||` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You’ll expand your knowledge of these useful operators in later projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[switch . . . case Statements](nsp-boxall502581-0008.xhtml#rbh0508)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To compare two or more variables, it’s easier to use a `switch...case` statement
    instead of several `if...else` statements. The `switch...case` statement runs
    code when one of the defined comparisons is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you want to run different code for each possible value of
    the integer variable `counter` , 1, 2, or 3\. You could use one `switch...case`
    statement instead of multiple `if...else` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The optional `default` section at the end of this code lets you run code when
    there aren’t any true comparisons in the `switch...case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating Your Own Functions](nsp-boxall502581-0008.xhtml#rah0503)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sooner or later, you’ll want to repeat sections of code more than once or define
    your own set of instructions. You can achieve both goals by creating your own
    functions that either take care of a task, accept variables and act upon them,
    or return a value as their result, like a mathematical function. We’ll discuss
    these three types of functions in the next three projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first type of function simply repeats some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `name()` is a placeholder. You can name your function almost
    anything you’d like, but the name must always be preceded with `void` . Additionally,
    you can’t use *reserved keywords* in your own creations, since the language already
    uses them. For example, you can’t call a function `void void()` because `void`
    is a reserved keyword in C, C++, and other languages. You can find a complete
    list of reserved keywords in C at [https://en.cppreference.com/w/c/keyword](https://en.cppreference.com/w/c/keyword)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The function’s code goes inside the curly brackets. Always put your custom functions
    before the `int main(void)` section of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 9: A Simple Custom Function](nsp-boxall502581-0008.xhtml#rpro9)'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates the creation of a simple custom function that performs
    a task. Using the hardware from [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    , open a terminal window, navigate to the *Project 9* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` to upload the code for
    [Project 9](nsp-boxall502581-0013.xhtml#pro9) as usual. You should see the LED
    blink twice every five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The custom function `blinkTwice()` ❶ makes the LED blink twice, as it sets the
    entire PORTB register on and off twice with a short delay. Once you’ve created
    a function like this, you can call it anywhere in the code ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you want to be able to easily change how many times the LED blinks?
    That’s where the second type of custom function—functions to which you can pass
    values—comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you’ll give your function a name, but this time the parentheses will
    contain two parameters that will be used in the code inside the parentheses after
    the function name: `type` and `variable` , which specify the type and name of
    the variable being passed to the function, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 10: Custom Functions with Internal Variables](nsp-boxall502581-0008.xhtml#rpro10)'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates the creation of custom functions that accept variables
    as parameters, then act upon those variables. Using the same hardware from [Project
    8](nsp-boxall502581-0013.xhtml#pro8) , navigate to the *Project 10* subfolder
    of this book’s *Chapter 3* folder in your terminal window and enter the command
    `make flash` to upload the code for [Project 10](nsp-boxall502581-0013.xhtml#pro10)
    . You should see the LED blink on and off 11 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code in this project’s *main.c* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The function `blinkLED(uint8_t blinks)` ❶ accepts an unsigned integer and uses
    it in a `for` loop to blink the LED that number of times. Now you can call the
    `blinkLED()` function with different values anywhere in your code. For example,
    in this project’s code we call `blinkLED(10)` ❷ to make the LED blink 11 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass more than one variable into a custom function, just add a comma between
    each variable within the parentheses after the function name. For example, here
    I’ve added a second parameter, `blinkDelay` , to the `blinkLED()` function, which
    allows you to set the value of the delay between the LED turning on and off. This
    parameter is then passed into the `delay_ms()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for [Project 10](nsp-boxall502581-0013.xhtml#pro10) actually defines
    two custom functions: the first one is `delay_ms(int ms)` . Sometimes you might
    want a delay function in your code, and you’ll want to specify the length of that
    delay using a variable. That isn’t possible with the standard `_delay_ms()` function,
    so just create your own!'
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 11: Custom Functions That Return Values](nsp-boxall502581-0008.xhtml#rpro11)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project I’ll demonstrate the third type of custom function you can
    create: one that accepts one or more variables, uses them in a mathematical operation,
    and then returns the result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that return the result of an operation can be incredibly useful.
    Think of them as mathematical formula black boxes: values go in on one end, operations
    are performed on them, and the result pops out the other end. You can create such
    a function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the variable you declare must be of the same type as the function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put this into action. Using the same hardware from [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    , navigate to the *Project 11* subfolder of this book’s *Chapter 3* folder in
    your terminal window and enter the command `make flash` to upload the code for
    [Project 11](nsp-boxall502581-0013.xhtml#pro11) . You should see the LED blink
    12 times every 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’re still blinking the LED (this is the last time, I promise!), but now we
    call `blinkLED` with `k` , which is set to the result of the `timesThree()` function.
    The `timesThree()` function multiplies an integer by three. First we declare what
    type of variable the function will return—in this case, an integer ( `uint8_t`
    ) ❶. This is followed by the function name, `timesThree()` , and the variable
    that will contain the number we pass into the function. Inside the function, we
    declare another variable to hold the result of the multiplication operation ❷.
    Next, we call `return` to pass the result back to the code ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually use `timesThree()` in other parts of your program, just call it
    with an argument and set a variable equal to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you gain more experience with microcontrollers, you’ll find that creating
    your own functions can save you quite a bit of time. For now, though, let’s turn
    to discussing possible problems that can arise when using buttons, and how to
    solve them in order to create more reliable projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Switch Bounce](nsp-boxall502581-0008.xhtml#rah0504)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pushbuttons, which you first encountered in [Project 8](nsp-boxall502581-0013.xhtml#pro8)
    , are prone to *switch bounce* (also known as *switch bouncing* ), a button’s
    tendency to turn on and off several times after being pressed only once by the
    user. Switch bounce occurs because the metal contacts inside a pushbutton are
    so small that they can vibrate after the button has been released, causing the
    switch to quickly and repeatedly open and close until the vibration ends.
  prefs: []
  type: TYPE_NORMAL
- en: Switch bounce can be observed using a *digital storage oscilloscope (DSO)* ,
    a device that plots the change in a voltage over a period of time. [Figure 3-4](nsp-boxall502581-0013.xhtml#f03004)
    shows a DSO displaying the voltage measured across a pushbutton during a switch
    bounce.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing electrical signals during switch bounce on an oscilloscope](images/nsp-boxall502581-f03004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-4: Measuring switch bounce'
  prefs: []
  type: TYPE_NORMAL
- en: The top half of the display in [Figure 3-4](nsp-boxall502581-0013.xhtml#f03004)
    shows the result of the button being pressed several times. When the voltage line
    in the lower half of the image is at the higher horizontal position (5 V), the
    button is on.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath the word Stop at the top right, two vertical lines highlight a slice
    of time. The pushbutton voltage during this time is magnified in the bottom half
    of the screen. At A, the user releases the button and the line drops down to 0
    V. However, due to physical vibration, it immediately jumps back up to 5 V again
    until B, when it vibrates off and then on again until C, where it settles at the
    low (off) state. In effect, instead of relaying one button press to our microcontroller,
    we have unwittingly sent three.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t prevent switch bounce, but you can prevent your program from reacting
    to it: just use the `_delay_ms()` function to force the program to wait before
    executing any more code after detecting a button press. About 50 ms should be
    long enough, but test this with your own hardware to find the precise length of
    time that meets your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Protecting Your AVR from Fluctuating Voltages](nsp-boxall502581-0008.xhtml#rah0505)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a perfect world, a digital input pin would see either a 5 V electrical signal
    (high) or no electrical signal (low). In reality, switch bounce and other imperfections
    can cause the voltage at an input pin to vary wildly between 5 V and 0 V.
  prefs: []
  type: TYPE_NORMAL
- en: Adding delays in your program helps prevent software malfunctions due to switch
    bounce, but these fluctuations can happen even when you’re not using the pin,
    which can confuse or even damage your AVR. Fortunately, you can protect the AVR
    with pullup or pulldown resistors.
  prefs: []
  type: TYPE_NORMAL
- en: '[Pullup Resistors](nsp-boxall502581-0008.xhtml#rbh0509)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *pullup resistor* , illustrated in [Figure 3-5](nsp-boxall502581-0013.xhtml#f03005)
    , keeps the voltage at a digital input pin as close as possible to a high state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pullup resistor example schematic](images/nsp-boxall502581-f03005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: Example use of a pullup resistor'
  prefs: []
  type: TYPE_NORMAL
- en: The voltage at input pin 3 on the microcontroller will always be connected to
    a high signal, until the button is pressed, at which point pin 3 will be directly
    connected to GND and become low. The resistor prevents you from shorting 5 V to
    GND (which can damage your hardware) when you press the button.
  prefs: []
  type: TYPE_NORMAL
- en: AVR microcontrollers have internal pullup resistors. This is a neat way to reduce
    the size of a circuit, but the catch is that you’ll have to invert the logic in
    your programs. For example, if you have a button connected between a digital input
    pin and GND and the internal pullups are enabled, the input goes low (instead
    of high) when the button is pressed. This is a small price to pay for convenience.
    To turn on the internal pullup resistors for pins that are set as inputs, write
    1s to the corresponding bits in PORT *x* ; to turn internal pullups off, write
    0s to those bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[Pulldown Resistors](nsp-boxall502581-0008.xhtml#rbh0510)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *pulldown* resistor, illustrated in [Figure 3-6](nsp-boxall502581-0013.xhtml#f03006)
    , keeps the voltage at a digital input pin as close as possible to a low state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pulldown resistor example schematic](images/nsp-boxall502581-f03006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6: Example use of a pulldown resistor'
  prefs: []
  type: TYPE_NORMAL
- en: The voltage at pin 3 on the microcontroller connects to a low signal until the
    button is pressed. Then pin 3 directly connects to 5 V (high). Again, we use the
    resistor to avoid a dead short between the 5 V and GND when the button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Introducing Seven-Segment LED Displays](nsp-boxall502581-0008.xhtml#rah0506)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to make your microcontroller react to input is by displaying a number.
    To do that, you can add a new component to your toolbox: the *seven-segment LED
    display* , shown in [Figure 3-7](nsp-boxall502581-0013.xhtml#f03007) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two examples of seven-segment LED displays](images/nsp-boxall502581-f03007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-7: Seven-segment LED display modules'
  prefs: []
  type: TYPE_NORMAL
- en: These small plastic bricks contain eight LEDs, arranged into a familiar digital-number
    display with a decimal point. You’ll find them in various household appliances,
    and they’re great for displaying numbers, letters, or even symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seven-segment displays are available in a myriad of sizes and colors, and electrically
    they are the same as eight separate LEDs, with one catch: to reduce the number
    of pins used by the display, all of the anodes or cathodes of the LEDs are connected
    together. These are called *common-anode* and *common-cathode* configurations,
    respectively. All seven-segment displays in this book use common-cathode modules.
    The schematic symbol for this example display is shown in [Figure 3-8](nsp-boxall502581-0013.xhtml#f03008)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for a seven-segment LED display](images/nsp-boxall502581-f03008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-8: Schematic symbol for a seven-segment common-cathode LED display
    module'
  prefs: []
  type: TYPE_NORMAL
- en: Next to each LED’s cathode is its matching segment. The display’s LEDs are labeled
    A to G and DP (for the decimal point) with an anode pin for each LED segment,
    and the cathodes are connected to one or two common cathode pins.
  prefs: []
  type: TYPE_NORMAL
- en: Seven-segment display pin layouts vary by manufacturer, so when you purchase
    them, make sure the supplier gives you the data sheet showing which pins are the
    anodes for each segment, and which pin is the cathode. If in doubt, note that
    most common models have pin 1 at the bottom-left corner of the display with the
    rest numbered counterclockwise. Remember that they’re still individual LEDs, and
    you’ll still need a current-limiting resistor for each one.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 12: Building a Single-Digit Numerical Counter](nsp-boxall502581-0008.xhtml#rpro12)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consolidate what you’ve learned so far by making an interactive device
    that I hope will spur your imagination: a single-digit numerical counter. Your
    counter will have two buttons (one to increase the count, and another to reset
    the counter to zero) and a seven-segment display.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0511)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One common-cathode seven-segment LED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Seven 560 Ω resistors (R1–R7)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two pushbuttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 10 kΩ resistors (R8, R9)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 3-9](nsp-boxall502581-0013.xhtml#f03009)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 12](images/nsp-boxall502581-f03009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-9: The main circuit for [Project 12](nsp-boxall502581-0013.xhtml#pro12)'
  prefs: []
  type: TYPE_NORMAL
- en: By now you should remember on your own to connect the USBasp and wire it to
    the circuit before getting started, so after this project I’ll stop reminding
    you.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0512)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 12* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` . Once you’ve uploaded
    the code to your microcontroller, press the button connected to PD0 to increase
    the counter, and press the other button to reset the count to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file for [Project 12](nsp-boxall502581-0013.xhtml#pro12)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a new function, `displayNumber()` , that receives an integer
    and sets the PORTB outputs to turn individual segments of the LED display on or
    off, thus displaying a digit from 0 to 9 ❶. By using a `switch...case` statement,
    the code can neatly decide which `PORTB` command to run based on what digit you
    want to display.
  prefs: []
  type: TYPE_NORMAL
- en: The variable `i` keeps track of what number you want to display ❷. This variable
    is initialized with a value of zero so that the counter starts at zero when the
    power is turned on.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up the I/O pins, using PORTB as outputs for the LEDs and PORTD
    as inputs that detect when the buttons are pressed ❸. The internal pullup resistors
    are turned off for pins PD0 and PD1 ❹ because the buttons are connected to those
    pins, and the pullups are turned on for the rest of PORTD. This ensures that the
    unused pins in PORTD will always be high.
  prefs: []
  type: TYPE_NORMAL
- en: Every time the code loops, it first displays the value of the count ❺, then
    checks if the reset or count buttons have been pressed. Note that when the code
    compares `PIND` against the binary values representing button presses on PD0 ❻
    or PD1 ❼, the unused bits (or inputs) in the comparison are 1s, not 0s. This is
    because the internal pullup resistors have been activated for the unused inputs,
    keeping them at 1.
  prefs: []
  type: TYPE_NORMAL
- en: When you press the count button, the count variable `i` should increase by one.
    If the count is greater than 9, it should reset back to 0 because you’re working
    with a single-digit display.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve completed this project, you’ll have a nifty display—but remember,
    you learn by doing. Experiment with this program! For example, try changing it
    to a countdown timer or creating changing patterns with the LEDs instead of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: If possible, keep this project assembled, as you’ll reuse most of it for [Project
    14](nsp-boxall502581-0013.xhtml#pro14) .
  prefs: []
  type: TYPE_NORMAL
- en: '[Analog Inputs](nsp-boxall502581-0008.xhtml#rah0507)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to this point, your projects have used digital electrical signals with just
    two levels: high and low. For your microcontrollers, high is close to 5 V and
    low is close to 0 V (or GND). We used the PORT *x* register to blink LEDs and
    the PIN *x* register to measure whether a digital input was high or low. [Figure 3-10](nsp-boxall502581-0013.xhtml#f03010)
    illustrates a digital signal measured with a DSO.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a digital signal in the form of a square wave displayed on
    an oscilloscope](images/nsp-boxall502581-f03010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-10: A digital signal, with highs appearing as horizontal lines at
    the top and lows appearing at the bottom'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike digital signals, *analog signals* can vary with an indefinite number
    of steps between high and low. For example, [Figure 3-11](nsp-boxall502581-0013.xhtml#f03011)
    shows an analog voltage signal that looks like a sine wave.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of an analog signal in the form of a sine wave displayed on
    an oscilloscope](images/nsp-boxall502581-f03011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-11: A sinusoidal analog signal'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that as time progresses, the voltage moves fluidly between high and low
    levels. Analog signals can represent all sorts of information from various devices,
    such as temperature or distance sensors. To use analog signals in your projects,
    you measure the voltage values of the signal using certain I/O pins in your microcontrollers,
    which are connected to *analog-to-digital converters (ADCs)* . An ADC can convert
    a voltage to a number, which you can then use in your code. Refer to the pinout
    and port register diagrams in [Chapter 2](nsp-boxall502581-0012.xhtml#ch02) ;
    the analog inputs are marked as ADC *x* for *analog-to-digital converter x* .
  prefs: []
  type: TYPE_NORMAL
- en: On the ATtiny85 you have PB0, PB1, PB2, and PB5 (physical pins 5–7 and 1). On
    the ATmega328P-PU you have a whole new register (PORTC), which has six ADCs from
    PC0 to PC5.
  prefs: []
  type: TYPE_NORMAL
- en: '[Using ATtiny85 ADCs](nsp-boxall502581-0008.xhtml#rah0508)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up the ADC pins on the ATtiny85, you’ll need to set two new registers.
    (Yes, more registers! You’ll get used to them the more you use them.) The first,
    ADMUX, selects which pin you’ll connect to the ADC. You’ll leave the first six
    bits as `001000` and use the last two bits to select the physical pin for the
    ADC. They’re `00` for ADC0 (pin 1), `01` for ADC1 (pin 7), `10` for ADC2 (pin
    3), and `11` for ADC3 (pin 2). For example, to use physical pin 3 as the analog
    input, set ADMUX as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The second register to set, called ADCSRA, is responsible for several settings,
    including the speed of the ADC. All ATtiny85 projects in this book set the speed
    to 1 MHz. As the ADC section of the microcontroller operates at a different speed,
    you’ll use ADCSRA to set a prescale value that determines the ADC speed. You’ll
    typically use a prescaler of 8, which brings the ADC speed down to 125 kHz (which
    we calculate by dividing the speed of 1 MHz by 8). The matching ADCSRA line is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It’s a good idea to put the two register settings in their own custom function,
    which you could name `startADC()` , for example. This keeps your code neat and
    makes it easy to call the function wherever you need it.
  prefs: []
  type: TYPE_NORMAL
- en: When using ADCs, it can be helpful to use a different way of addressing bits
    in a register—using bitwise operations. For now I’ll keep it simple and just show
    you how this works; we’ll revisit this topic (and the use of prescalers) in more
    detail in [Chapter 6](nsp-boxall502581-0016.xhtml#ch06) .
  prefs: []
  type: TYPE_NORMAL
- en: 'To measure a value from your preset ADC pin, first start the ADC with the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the ADSC bit in the ADCSRA register to 1, which tells your ATtiny85
    to read the analog input and convert it to a value. When the ATtiny85 has finished,
    the ADSC bit returns to 0\. You’ll need to tell your code to wait a moment until
    this happens, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This compares the ADSC bit in the ADCSRA register to 1 and does nothing if they’re
    both 1\. When the ADC process is complete, the ADSC bit returns to 0, the `while()`
    function finishes, and the microcontroller progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the value from the ADC is stored in the variable `ADCH` . The value
    of `ADCH` should be between 0 and 255\. You can then work with `ADCH` as required.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 13: Making a Single-Cell Battery Tester](nsp-boxall502581-0008.xhtml#rpro13)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll put your ATtiny85’s ADC to work by making a simple battery
    tester. You can use this to check the voltage of AA, AAA, C, or D cell batteries.
  prefs: []
  type: TYPE_NORMAL
- en: Warning Do not connect any battery (or other power source) with a voltage greater
    than 5 V to your tester, and don’t connect the battery the wrong way around (check
    the schematic in [Figure 3-12](nsp-boxall502581-0013.xhtml#f03012) ). Doing either
    will damage your ATtiny85.
  prefs: []
  type: TYPE_NORMAL
- en: This tester uses two LEDs to indicate whether the battery is good (with a voltage
    greater than or equal to 1.4 V) or bad (with a voltage less than 1.4 V).
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0513)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny85–20PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 560 Ω resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 3-12](nsp-boxall502581-0013.xhtml#f03012)
    . Note that the two wires labeled positive (+) and negative (−) are jumper wires
    used to contact the battery you want to test. Connect the + and − wires to the
    matching points on the battery.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 13](images/nsp-boxall502581-f03012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-12: Schematic for [Project 13](nsp-boxall502581-0013.xhtml#pro13)'
  prefs: []
  type: TYPE_NORMAL
- en: You may find that it helps to use some insulation tape to keep the wires connected
    to the battery under test. You might also use red and green LEDs to indicate whether
    the battery under test is “bad” or “good.”
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0514)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 13* subfolder of the *Chapter
    3* folder for this book, and enter the command `make flash` . Once you’ve uploaded
    the code, find a AA, AAA, C, or D cell battery, and connect the positive and negative
    leads to the circuit as shown in the schematic. If the voltage is greater than
    or equal to 1.4 V, LED2 should turn on; if it’s less than 1.4 V, LED1 should turn
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this is implemented, open the *main.c* file for [Project 13](nsp-boxall502581-0013.xhtml#pro13)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '}The function `startADC()` sets physical pin 3 to use its ADC function and
    sets the prescaler for 1 MHz operation ❶. We need to call this function before
    using the ADC ❷. We then activate the ADC for a reading and wait for it to complete
    ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value from the ADC—a number between 0 and 255—is stored in the variable
    `ADCH` . This value maps to the voltage range of the ADC, which is 0 to 5 V. You
    can find the ADC value with some basic math:'
  prefs: []
  type: TYPE_NORMAL
- en: (Map Voltage × 256) / Supply Voltage = ADC Value
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we calculate the matching ADC value for 1.4 V as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (1.4 V × 256 / 5 V) = 71.68
  prefs: []
  type: TYPE_NORMAL
- en: Based on this calculation, 1.4 V maps to an ADC value of 71.4, which we round
    to 71 in our code because we’re using whole numbers in this project. This is the
    value used in the `if` statements at and to determine whether the battery is good
    to use ❹ or not ❺.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should understand how to read analog signals in the form
    of varying voltages from external devices. This is incredibly useful, as there
    are many types of sensors whose values are returned as a varying voltage and thus
    are easy to read with the ADC pin of your microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the ADCs on the ATmega328P-PU, along with some more information
    about variable types.
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the ATmega328P-PU ADCs](nsp-boxall502581-0008.xhtml#rah0509)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up the ADC pins on the ATmega328P-PU is similar to setting them up
    on the ATtiny85\. You’ll start by setting up some registers. The first is ADMUX,
    which has two functions: indicating which ADC pin you want to use and selecting
    the source of the reference voltage the ADC compares against the analog signal
    being measured.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First you’ll set the REFS0 bit in the ADMUX register to 1, which tells the
    microcontroller to use the voltage connected to AV [CC] (pin 20) for comparisons
    with analog signals. Again, you can use a bitwise operation for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a simpler and less error-prone method of setting individual bits in
    a register, as it lets you avoid having to deal with all eight bits at once—you
    only set the bit you want to change. Also remember that you only need to set bits
    to 1, as by default they’re all 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’ll set the MUX2 and MUX0 bits to 1, which tells the ADC to read signals
    coming in on pin 28:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second register you’ll set, ADCSRA, activates the ADC and sets the speed
    of the ADC in the microcontroller. All your ATmega328P-PU projects from here until
    [Chapter 13](nsp-boxall502581-0023.xhtml#ch13) will use the speed 1 MHz, and the
    matching ADCSRA line is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to activate the ADC by setting the ADEN bit to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As in [Project 12](nsp-boxall502581-0013.xhtml#pro12) , it’s a good idea to
    put the register settings in their own custom function, which I’ve named `startADC()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to measure a value from the preset ADC pin, you first need to
    start the ADC as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the ADSC bit in the ADCSRA register to 1, which tells your ATmega328P-PU
    to read the analog input and convert it to a value. This is not instantaneous;
    your code needs to wait until the ATmega328P-PU has finished the ADC reading,
    at which point the ADSC bit returns to 0\. The following is a convenient space-saving
    function that can be used to monitor changes of bits in registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it forces the code to wait until the ADSC bit returns to 0; when
    this happens, the ADC process is complete, and the code can then continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value from the ADC is a 10-bit number, which the toolchain makes available
    in a virtual register variable called, you guessed it, `ADC` . However, for purposes
    where accuracy isn’t entirely necessary, you can just use an 8-bit value, dropping
    the last 2 bits off the ADC register like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: where `ADCvalue` is an integer variable used to hold the value from the ADC.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when using the same power to run the microcontroller and its internal
    ADC, it’s wise to use a small smoothing capacitor over the positive and negative
    power supply lines, as shown in the [following project](nsp-boxall502581-0013.xhtml#pro14)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[Introducing the Variable Resistor](nsp-boxall502581-0008.xhtml#rah0510)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variable resistors, also known as *potentiometers* , can generally be adjusted
    from 0 Ω up to their rated value. [Figure 3-13](nsp-boxall502581-0013.xhtml#f03013)
    shows their schematic symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '![Potentiometer schematic symbol](images/nsp-boxall502581-f03013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-13: Variable resistor (potentiometer) symbol'
  prefs: []
  type: TYPE_NORMAL
- en: Variable resistors have three electrical connections, one in the center and
    one on each side. As the shaft of the variable resistor is turned, it increases
    the resistance between one side and the center and decreases the resistance between
    the opposite side and the center.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable resistors can be either *linear* or *logarithmic* . The resistance
    of linear models changes at a constant rate when turning, while the resistance
    of logarithmic models changes slowly at first and then increases rapidly. Logarithmic
    potentiometers are used more often in audio amplifier circuits because they model
    the human hearing response. You can generally identify whether a potentiometer
    is logarithmic or linear via the marking on the rear. Most will have either an
    A or a B next to the resistance value: A for logarithmic, B for linear. Most projects
    use linear variable resistors such as the one shown in [Figure 3-14](nsp-boxall502581-0013.xhtml#f03014)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of a variable resistor](images/nsp-boxall502581-f03014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-14: A typical linear variable resistor'
  prefs: []
  type: TYPE_NORMAL
- en: Miniature variable resistors are known as *trimpots* or *trimmers* (see [Figure
    3-15](nsp-boxall502581-0013.xhtml#f03015) ). Because of their size, trimpots are
    more useful for making adjustments in circuits, but they’re also very useful for
    breadboard work because they can be slotted in.
  prefs: []
  type: TYPE_NORMAL
- en: '![Three different styles of trimpot](images/nsp-boxall502581-f03015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-15: Various trimpots'
  prefs: []
  type: TYPE_NORMAL
- en: When shopping for trimpots, take note of the type. If possible, you’ll want
    one that is easy to adjust with the screwdriver you have on hand. The enclosed
    types pictured in [Figure 3-15](nsp-boxall502581-0013.xhtml#f03015) are also preferable,
    as they last longer than the cheaper, open-contact types.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 14: Experimenting with an ATmega328P-PU ADC](nsp-boxall502581-0008.xhtml#rpro14)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll experiment with an ADC on the larger ATmega328P-PU microcontroller,
    along with practicing with more involved decision-making code. This project measures
    the signal from a trimpot, which varies between 0 V and 5 V. The value falls into
    one of four ranges and is indicated by one of the four LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0515)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Four LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Four 560 Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 0.1 μF ceramic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ breadboard-compatible linear trimpot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 3-16](nsp-boxall502581-0013.xhtml#f03016)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 14](images/nsp-boxall502581-f03016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-16: Schematic for [Project 14](nsp-boxall502581-0013.xhtml#pro14)'
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t get a breadboard-compatible trimpot, you can use a full-size potentiometer,
    although you’ll need to solder jumper wires to the potentiometer’s three pins
    in order to make contact with the solderless breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0516)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 14* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` to upload the code for
    [Project 14](nsp-boxall502581-0013.xhtml#pro14) as usual. Once you’ve uploaded
    the code, start slowly moving the trimpot toward one limit, then turn it through
    the other direction to the other limit. The LEDs should indicate which quartile
    of the trimpot range you are currently turning through.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine how this works. Open the *main.c* file for [Project 14](nsp-boxall502581-0013.xhtml#pro14)
    and take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First we specify the pins used for outputs (LEDs—PORTB) and inputs for ADC ❷,
    then we call the function `startADC()` ❶ to set up the ADC ❸. We measure the value
    fed from the trimpot to the ADC via pin PC5 ❹ and store it into the integer variable
    `ADCvalue` ❻ after a short delay ❺ to give the ADC time to complete its conversion
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code evaluates the value of the ADC using a series of `if...else`
    functions ❼. Each of these checks if the ADC value falls within a certain range
    using the `AND` ( `&&` ) conditional operator, then activates an LED to provide
    a visual indication if the result of the test is true.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the LED is turned off at the end of the main loop after a short delay
    to allow time for indication, and the process starts again.
  prefs: []
  type: TYPE_NORMAL
- en: '[Doing Arithmetic with an AVR](nsp-boxall502581-0008.xhtml#rah0511)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like a pocket calculator, the AVR can perform basic calculations for you. This
    is really handy when you’re dealing with analog-to-digital conversions. Here are
    some of the mathematical operations available for your AVR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The C language handles some kinds of calculations a little differently than
    a pocket calculator, though. For example, when dividing two integers, the AVR
    simply discards the remainder rather than rounding the quotient up or down: 16
    divided by 2 equals 8, 10 divided by 3 equals 3, and 18 divided by 8 equals 2\.
    I’ll explain a few other oddities as they come up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with numbers that have or will result in a decimal point (for
    example, dividing 1 by 3), you will need to use a new type of variable called
    a *float* . The values that can be stored in a float can fall between −3.39 ×
    10 ^(38) and 3.39 × 10 ^(38) . To use floating-point math in your code, you’ll
    need to include a new library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get used to this math by using it in [Project 15](nsp-boxall502581-0013.xhtml#pro15)
    , along with your first analog sensor, which I’ll introduce next.
  prefs: []
  type: TYPE_NORMAL
- en: '[Using External Power](nsp-boxall502581-0008.xhtml#rah0512)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point you’ve been powering your projects directly from the AVR programmer,
    which is a neat solution for small projects and experiments. However, this method
    leaves less than 5 V of output voltage available to your circuit, as the internal
    circuitry of the programmer reduces the voltage.
  prefs: []
  type: TYPE_NORMAL
- en: If you use a multimeter to measure the voltage across pins 7 and 8 of your ATmega328P-PU
    in [Project 14](nsp-boxall502581-0013.xhtml#pro14) or others created earlier,
    you’ll find it’s less than 5 V. When working with parts that expect 5 V (such
    as the TMP36 used in the [next project](nsp-boxall502581-0013.xhtml#pro15) ),
    you’ll need an external power supply for accuracy and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: One easy way to add external 5 V power is to use a breadboard power supply module,
    such as the one from PMD Way (part number 20250303) shown in [Figure 3-17](nsp-boxall502581-0013.xhtml#f03017)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Power supply module fitted to the end of a solderless breadboard](images/nsp-boxall502581-f03017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-17: A breadboard power supply module'
  prefs: []
  type: TYPE_NORMAL
- en: The PMD Way module is inserted into the end of your breadboard and is powered
    by a common AC to DC wall wart power supply. The unit supplies 5 V or 3.3 V to
    both sides of the breadboard and has a neat power switch for control. It is a
    small and very convenient outlay.
  prefs: []
  type: TYPE_NORMAL
- en: '[The TMP36 Temperature Sensor](nsp-boxall502581-0008.xhtml#rah0513)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the TMP36 temperature sensor (shown in [Figure 3-18](nsp-boxall502581-0013.xhtml#f03018)
    ) and a little math, you can turn your AVR into a thermometer. This inexpensive
    and easy-to-use analog sensor outputs a voltage that changes with the temperature
    around it.
  prefs: []
  type: TYPE_NORMAL
- en: '![A TMP36 temperature sensor](images/nsp-boxall502581-f03018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-18: The TMP36 temperature sensor'
  prefs: []
  type: TYPE_NORMAL
- en: The TMP36 has three legs. When you’re looking at the flat side of the sensor
    with the writing on it, the legs are (from left to right) voltage in, voltage
    out, and GND. You’ll connect pin 1 to the 5 V power in your projects, pin 2 to
    an analog input on the microcontroller, and pin 3 to GND. [Figure 3-19](nsp-boxall502581-0013.xhtml#f03019)
    shows the schematic symbol for the TMP36.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the TMP36 temperature sensor](images/nsp-boxall502581-f03019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-19: Schematic symbol for the TMP36'
  prefs: []
  type: TYPE_NORMAL
- en: The voltage output from the TMP36 is a representation of the temperature around
    the sensor; for example, at 25 degrees Celsius, the output is 750 mV (or 0.75
    V), and for every change of one degree, the voltage output changes by 10 mV. The
    TMP36 can measure temperatures from −40 to 125 degrees Celsius, but for the [next
    project](nsp-boxall502581-0013.xhtml#pro15) you’ll just measure room temperatures.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the temperature from the voltage, multiply the value in ADC by
    5, then divide by 1,024, which gives you the actual voltage returned by the sensor.
    Next, subtract 0.5 (0.5 V is the offset used by the TMP36 to allow for temperatures
    below 0) then multiply by 100, which gives you the temperature in degrees Celsius.
  prefs: []
  type: TYPE_NORMAL
- en: Note If you want to work in Fahrenheit, multiply the Celsius value by 1.8 and
    add 32 to the result.
  prefs: []
  type: TYPE_NORMAL
- en: As this is an analog device, the output voltage is determined by the input voltage.
    If you don’t have 5 V or very close to 5 V on the input, your output and thus
    the temperature reading will not be correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 15: Creating a Digital Thermometer](nsp-boxall502581-0008.xhtml#rpro15)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll use what you learned from [Project 12](nsp-boxall502581-0013.xhtml#pro12)
    to create a numeric display with the ADC on the ATmega328P-PU that acts as a digital
    thermometer. To keep things simple, this project will display temperatures starting
    from 0 degrees Celsius and going up; negative readings are not included.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0517)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build your thermometer, you’ll read the TMP36 analog temperature sensor with
    the microcontroller, which will then display the temperature one digit at a time
    using the seven-segment LED display from [Project 12](nsp-boxall502581-0013.xhtml#pro12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One TMP36 temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One common-cathode seven-segment LED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Seven 560 Ω resistors (R1–R7)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 0.1 μF ceramic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 3-20](nsp-boxall502581-0013.xhtml#f03020)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 15](images/nsp-boxall502581-f03020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-20: Schematic for [Project 15](nsp-boxall502581-0013.xhtml#pro15)'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the 0.1 μF capacitor to help maintain a smooth power supply to the
    TMP36 temperature sensor; it should be mounted as close as possible to the TMP36’s
    5 V and GND pins.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0518)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 15* subfolder of this book’s
    *Chapter 3* folder, and enter the command `make flash` to upload the code for
    [Project 15](nsp-boxall502581-0013.xhtml#pro15) as usual. Once you’ve uploaded
    the code, the LED module should display the approximate temperature one digit
    at a time. For example, if the temperature were 8 degrees Celsius, the display
    would show a 0, followed by a short delay, and then an 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file for [Project 15](nsp-boxall502581-0013.xhtml#pro15)
    and take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first include the necessary libraries (among them, *math.h*
    , for the floating-point math) ❶. We add the function `startADC()` to start the
    ADC ❷ (this function is called at the start of the main part of the code), and
    we reuse the `displayNumber()` function from [Project 12](nsp-boxall502581-0013.xhtml#pro12)
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main section of the code, we declare the required variables, define
    the input and output pins, and initialize the ADC ❹. The main loop of the code
    is broken into five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The voltage from the TMP36 is measured by the ADC and stored in the variable
    `ADCvalue` ❺.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Using the formula described in “Introducing the TMP36 Temperature Sensor,”
    the code converts the value of the ADC to a voltage. This voltage is then converted
    to the temperature in degrees Celsius ❻.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. The digits used to represent the temperature are extracted from `finalTemp`
    and then rounded up or down to the nearest whole number with `round()` . The code
    determines the left digit (for tens) by dividing the temperature by 10\. If the
    temperature is less than 10 degrees, this will be 0\. It determines the right
    digit (for ones) by taking the remainder from dividing the temperature by 10 with
    modulo ❼.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. The `displayNumber()` function is used to display the tens and ones digits
    of the temperature, respectively, with a quarter-second delay between the digits
    ❽.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5\. Finally, the display is turned off for a second ❾, giving a visual break
    between the displayed value and the new value to come.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This seemingly complex project just combines your existing knowledge in new
    ways, which I hope is starting to fire up your imagination. In [Chapter 4](nsp-boxall502581-0014.xhtml#ch04)
    , we’ll turn to a new topic: enabling bidirectional communication between your
    microcontroller and a PC for the purposes of data capture and control.'
  prefs: []
  type: TYPE_NORMAL
