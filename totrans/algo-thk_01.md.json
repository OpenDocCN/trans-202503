["```\n3, 9, 15, 2, 1, 10\n```", "```\n8, 4, 8, 9, 2, 8\n```", "```\n1, 2, 3, 4, 5, 6\n```", "```\n1, 2, 3, 4, 5, 6\n```", "```\n1, 2, 3, 4, 5, 6\n```", "```\n4, 5, 6, 1, 2, 3\n```", "```\n1, 2, 3, 4, 5, 6\n```", "```\n3, 2, 1, 6, 5, 4\n```", "```\nTwin integers found.\n```", "```\nNo two integers are alike.\n```", "```\nvoid identify_identical(int values[], int n) {\n  int i, j;\n  for (i = 0; i < n; i++) {\n  ❶ for (j = i + 1; j < n; j++) {\n       if (values[i] == values[j]) {\n         printf(\"Twin integers found.\\n\");\n         return;\n       }\n     }\n }\n printf(\"No two integers are alike.\\n\");\n}\n```", "```\nint main(void) {\n  int a[5] = {1, 2, 3, 1, 5};\n  identify_identical(a, 5);\n  return 0;\n}\n```", "```\nint identical_right(int snow1[], int snow2[], int start)\n```", "```\n// bugged!\nint identical_right(int snow1[], int snow2[], int start) {\n  int offset;\n  for (offset = 0; offset < 6; offset++) {\n ❶ if (snow1[offset] != snow2[start + offset])\n      return 0;\n }\n return 1;\n}\n```", "```\nint identical_right(int snow1[], int snow2[], int start) {\n  int offset, snow2_index;\n  for (offset = 0; offset < 6; offset++) {\n    snow2_index = start + offset;\n    if (snow2_index >= 6)\n      snow2_index = snow2_index - 6;\n        if (snow1[offset] != snow2[snow2_index])\n      return 0;\n  }\n  return 1;\n}\n```", "```\nint identical_right(int snow1[], int snow2[], int start) {\n  int offset;\n  for (offset = 0; offset < 6; offset++) {\n    if (snow1[offset] != snow2[(start + offset) % 6])\n      return 0;\n  }\n  return 1;\n}\n```", "```\nint identical_left(int snow1[], int snow2[], int start) {\n  int offset, snow2_index;\n  for (offset = 0; offset < 6; offset++) {\n    snow2_index = start - offset;\n    if (snow2_index <= -1)\n      snow2_index = snow2_index + 6;\n    if (snow1[offset] != snow2[snow2_index])\n      return 0;\n  }\n  return 1;\n}\n```", "```\nint are_identical(int snow1[], int snow2[]) {\n  int start;\n  for (start = 0; start < 6; start++) {\n ❶ if (identical_right(snow1, snow2, start))\n      return 1;\n ➋ if (identical_left(snow1, snow2, start))\n      return 1;\n  }\n  return 0;\n}\n```", "```\nvoid identify_identical(int snowflakes[][6], int n) {\n  int i, j;\n  for (i = 0; i < n; i++) {\n    for (j = i + 1; j < n; j++) {\n      if (are_identical(snowflakes[i], snowflakes[j])) {\n        printf(\"Twin snowflakes found.\\n\");\n        return;\n      }\n    }\n  }\n  printf(\"No two snowflakes are alike.\\n\");\n}\n```", "```\n#define SIZE 100000\n\nint main(void) {\n❶ static int snowflakes[SIZE][6];\n   int n, i, j;\n   scanf(\"%d\", &n);\n   for (i = 0; i < n; i++)\n     for (j = 0; j < 6; j++)\n       scanf(\"%d\", &snowflakes[i][j]);\n   identify_identical(snowflakes, n);\n   return 0;\n}\n```", "```\nint compare(const void *first, const void *second) {\n  int i;\n  const int *snowflake1 = first;\n  const int *snowflake2 = second;\n  if (are_identical(snowflake1, snowflake2))\n    return 0;\n  for (i = 0; i < 6; i++)\n    if (snowflake1[i] < snowflake2[i])\n      return -1;\n  return 1;\n}\n```", "```\n4\n3 4 5 6 1 2\n2 3 4 5 6 7\n4 5 6 7 8 9\n1 2 3 4 5 6\n```", "```\n1, 2, 3, 4, 5, 6\n```", "```\n82, 100, 3, 1, 2, 999\n```", "```\n3, 1, 2, 999, 82, 100\n```", "```\n82, 100, 3, 1, 2, 999\n```", "```\nint code(int snowflake[]) {\n  return (snowflake[0] + snowflake[1] + snowflake[2]\n          + snowflake[3] + snowflake[4] + snowflake[5]);\n}\n```", "```\n1000000, 2000000, 3000000, 4000000, 5000000, 6000000\n```", "```\n#define SIZE 100000\n\nint code(int snowflake[]) {\n  return (snowflake[0] + snowflake[1] + snowflake[2]\n          + snowflake[3] + snowflake[4] + snowflake[5]) % SIZE;\n}\n```", "```\n    for (j = 0; j < 6; j++)\n      scanf(\"%d\", &snowflakes[i][j]);\n```", "```\ntypedef struct snowflake_node {\n  int snowflake[6];\n  struct snowflake_node *next;\n} snowflake_node;\n```", "```\nint main(void) {\n❶ static snowflake_node *snowflakes[SIZE] = {NULL};\n➋ snowflake_node *snow;\n   int n, i, j, snowflake_code;\n   scanf(\"%d\", &n);\n   for (i = 0; i < n; i++) {\n  ➌ snow = malloc(sizeof(snowflake_node));\n    if (snow == NULL) {\n      fprintf(stderr, \"malloc error\\n\");\n      exit(1);\n    }\n    for (j = 0; j < 6; j++)\n   ➍ scanf(\"%d\", &snow->snowflake[j]);\n  ➎ snowflake_code = code(snow->snowflake);\n  ➏ snow->next = snowflakes[snowflake_code];\n  ❼ snowflakes[snowflake_code] = snow;\n  }\n  identify_identical(snowflakes);\n  // deallocate all malloc'd memory, if you want to be good\n  return 0;\n}\n```", "```\n4\n1 2 3 4 5 6\n8 3 9 10 15 4\n16 1 1 1 1 1\n100016 1 1 1 1 1\n```", "```\nvoid identify_identical(snowflake_node *snowflakes[]) {\n  snowflake_node *node1, *node2;\n  int i;\n  for (i = 0; i < SIZE; i++) {\n ❶ node1 = snowflakes[i];\n    while (node1 != NULL) {\n   ➋ node2 = node1->next;\n      while (node2 != NULL) {\n        if (are_identical(node1->snowflake, node2->snowflake)) {\n          printf(\"Twin snowflakes found.\\n\");\n          return;\n        }\n        node2 = node2->next;\n      }\n   ➌ node1 = node1->next;\n    }\n  }\n  printf(\"No two snowflakes are alike.\\n\");\n}\n```", "```\n#define hashsize(n) ((unsigned long)1 << (n))\n#define hashmask(n) (hashsize(n) - 1)\n\nunsigned long oaat(char *key, unsigned long len, unsigned long bits) {\n  unsigned long hash, i;\n  for (hash = 0, i = 0; i < len; i++) {\n    hash += key[i];\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n  }\n  hash += (hash << 3);\n  hash ^= (hash >> 11);\n  hash += (hash << 15);\n  return hash & hashmask(bits);\n}\n\nint main(void) { // sample call of oaat\n  char word[] = \"hello\";\n  // 2^17 is the smallest power of 2 that is at least 100000\n❶ unsigned long code = oaat(word, strlen(word), 17);\n   printf(\"%u\\n\", code);\n   return 0;\n}\n```", "```\n❶ 6\n➋ 2 dish\n   1 brandish\n   1 radishes\n   1 aaa\n➌ 2 dish\n➍ 2 a\n```", "```\n0\n2\n3\n```", "```\n❶ #define MAX_USERS 100000\n  #define MAX_PASSWORD 10\n\n  int main(void) {\n    static char users[MAX_USERS][MAX_PASSWORD + 1];\n    int num_ops, op, op_type, total, j;\n    char password[MAX_PASSWORD + 1];\n    int num_users = 0;\n    scanf(\"%d\", &num_ops);\n    for (op = 0; op < num_ops; op++) {\n      scanf(\"%d%s\", &op_type, password);\n\n   ➋ if (op_type == 1) {\n        strcpy(users[num_users], password);\n        num_users++;\n\n   ➌ } else {\n        total = 0;\n        for (j = 0; j < num_users; j++)\n          if (strstr(users[j], password))\n            total++;\n        printf(\"%d\\n\", total);\n      }\n    }\n    return 0;\n}\n```", "```\n#define MAX_PASSWORD 10\n\ntypedef struct password_node {\n  char password[MAX_PASSWORD + 1];\n  int total;\n  struct password_node *next;\n} password_node;\n```", "```\n#define NUM_BITS 20\n\npassword_node *in_hash_table(password_node *hash_table[], char *find) {\n  unsigned password_code;\n  password_node *password_ptr;\n❶ password_code = oaat(find, strlen(find), NUM_BITS);\n➋ password_ptr = hash_table[password_code];\n   while (password_ptr) {\n  ➌ if (strcmp(password_ptr->password, find) == 0)\n       return password_ptr;\n     password_ptr = password_ptr->next;\n  }\n  return NULL;\n}\n```", "```\nvoid add_to_hash_table(password_node *hash_table[], char *find) {\n  unsigned password_code;\n  password_node *password_ptr;\n❶ password_ptr = in_hash_table(hash_table, find);\n   if (!password_ptr) {\n     password_code = oaat(find, strlen(find), NUM_BITS);\n     password_ptr = malloc(sizeof(password_node));\n     if (password_ptr == NULL) {\n       fprintf(stderr, \"malloc error\\n\");\n       exit(1);\n    }\n    strcpy(password_ptr->password, find);\n ➋ password_ptr->total = 0;\n    password_ptr->next = hash_table[password_code];\n    hash_table[password_code] = password_ptr;\n  }\n➌ password_ptr->total++;\n}\n```", "```\n// bugged!\nint main(void) {\n❶ static password_node *hash_table[1 << NUM_BITS] = {NULL};\n   int num_ops, op, op_type, i, j;\n   char password[MAX_PASSWORD + 1], substring[MAX_PASSWORD + 1];\n   password_node *password_ptr;\n   scanf(\"%d\", &num_ops);\n   for (op = 0; op < num_ops; op++) {\n     scanf(\"%d%s\", &op_type, password);\n\n  ➋ if (op_type == 1) {\n       for (i = 0; i < strlen(password); i++)\n         for (j = i; j < strlen(password); j++) {\n           strncpy(substring, &password[i], j - i + 1);\n           substring[j - i + 1] = '\\0';\n        ➌ add_to_hash_table(hash_table, substring);\n        }\n\n  ➍ } else {\n    ➎ password_ptr = in_hash_table(hash_table, password);\n    ➏ if (!password_ptr)\n         printf(\"0\\n\");\n       else\n         printf(\"%d\\n\", password_ptr->total);\n    }\n  }\n  return 0;\n}\n```", "```\n6\n2 dish\n1 brandish\n1 radishes\n1 aaa\n2 dish\n2 a\n```", "```\n0\n2\n3\n```", "```\n0\n2\n5\n```", "```\n❶ int already_added(char all_substrings[][MAX_PASSWORD + 1],\n                     int total_substrings, char *find) {\n     int i;\n     for (i = 0; i < total_substrings; i++)\n       if (strcmp(all_substrings[i], find) == 0)\n         return 1;\n     return 0;\n  }\n\n  int main(void) {\n    static password_node *hash_table[1 << NUM_BITS] = {NULL};\n    int num_ops, op, op_type, i, j;\n    char password[MAX_PASSWORD + 1], substring[MAX_PASSWORD + 1];\n    password_node *password_ptr;\n    int total_substrings;\n    char all_substrings[MAX_PASSWORD * MAX_PASSWORD][MAX_PASSWORD + 1];\n    scanf(\"%d\", &num_ops);\n    for (op = 0; op < num_ops; op++) {\n      scanf(\"%d%s\", &op_type, password);\n\n      if (op_type == 1) {\n        total_substrings = 0;\n        for (i = 0; i < strlen(password); i++)\n          for (j = i; j < strlen(password); j++) {\n            strncpy(substring, &password[i], j - i + 1);\n            substring[j - i + 1] = '\\0';\n          ➋ if (!already_added(all_substrings, total_substrings, substring)) {\n               add_to_hash_table(hash_table, substring);\n               strcpy(all_substrings[total_substrings], substring);\n               total_substrings++;\n             }\n          }\n\n      } else {\n        password_ptr = in_hash_table(hash_table, password);\n        if (!password_ptr)\n          printf(\"0\\n\");\n        else\n          printf(\"%d\\n\", password_ptr->total);\n  }\n }\n return 0;\n}\n```", "```\nabcdxxxef\nabcdxxef\n```", "```\n3\n5 6 7\n```", "```\n// long long is a very large integer type in C99\nunsigned long long prefix1[1000001];\nprefix1[0] = 0;\nfor (i = 1; i <= strlen(first_string); i++)\n❶ prefix1[i] = prefix1[i - 1] * 39 + first_string[i];\n```", "```\nabcdxxxef\nabcdxxef\n```", "```\nint prefix_length(char s1[], char s2[]) {\n  int i = 1;\n  while (s1[i] == s2[i])\n    i++;\n  return i - 1;\n}\n```", "```\nint suffix_length(char s1[], char s2[], int len) {\n  int i = len;\n  while (i >= 2 && s1[i] == s2[i - 1])\n    i--;\n  return len - i;\n}\n```", "```\n #define SIZE 1000000\n\n int main(void) {\n❶ static char s1[SIZE + 2], s2[SIZE + 2];\n   int len, prefix, suffix, total;\n➋ gets(&s1[1]);\n➌ gets(&s2[1]);\n\n   len = strlen(&s1[1]);\n   prefix = prefix_length(s1, s2);\n   suffix = suffix_length(s1, s2, len);\n➍ total = (prefix + 1) - (len - suffix) + 1;\n➎ if (total < 0)\n  ➏ total = 0;\n\n❼ printf(\"%d\\n\", total);\n❽ for (int i = 0; i < total; i++) {\n     printf(\"%d\", i + len - suffix);\n     if (i < total - 1)\n       printf(\" \");\n     else\n       printf(\"\\n\");\n  }\n  return 0;\n}\n```"]