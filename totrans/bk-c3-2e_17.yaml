- en: '**17**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GRIDLAYOUT**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Grids are a fundamental design technique. Simple grids have been used by calligraphers
    since medieval times, and the modern typographic grid has been in use since the
    second half of the 20th century. For a few years now, efforts have been made to
    bring grid-based design to the Web, with a number of frameworks using floats,
    padding, and margins to emulate the possibilities of print, although these efforts
    have always felt like somewhat of a fragile hack.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, however, browsers have begun to implement a native CSS grid layout
    system, as detailed in the Grid Layout Module (*[http://www.w3.org/TR/css-grid-1/](http://www.w3.org/TR/css-grid-1/)*).
    This module provides a series of properties designed specifically to create grids
    on screen, meaning the developer no longer has to hack them together from existing
    properties and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The full range of properties in the Grid Layout Module is quite extensive, so
    I’ll focus on the most immediately useful aspects and not get too bogged down
    in detail that could be potentially confusing. When appropriate, I’ll flag spots
    where I’ve omitted some detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Grid Terminology**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before introducing the new CSS grid syntax, I’ll explain some of the terminology
    used in the Grid Layout Module. Even if you think you’re familiar with typographic
    grids, take time to read through these definitions as the terminology used in
    CSS grids is quite distinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key terms used in the Grid Layout Module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grid container** The container element that acts as the boundary and sets
    the dimensions of the grid.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grid lines** The dividing lines between rows and columns. These lines are
    notional, not actual.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grid tracks** A shorthand name for both rows and columns. Each column or
    row created in the grid is referred to as a *track*. Tracks are the spaces between
    lines.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grid cells** Each intersection of a column and a row creates a *cell*. These
    are like cells in a table.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grid areas** A cell or multiple cells that mark the space in which a *grid
    item* will be placed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grid items** Each child element placed in the grid.'
  prefs: []
  type: TYPE_NORMAL
- en: A grid is created by first setting a number of lines on the grid container to
    create a series of tracks. Grid items are then positioned on the tracks using
    lines as coordinates to create areas, as shown in [Figure 17-1](ch17.html#ch17fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f17-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: A simple 3×3 grid showing the core terms used in the CSS Grid
    Layout syntax*'
  prefs: []
  type: TYPE_NORMAL
- en: The grid lines are the lines between cells. They define a series of rows and
    columns, which are numbered for coordinate placement. (I’ll explain this concept
    in stages as I proceed through this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaring and Defining the Grid**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step in creating a grid is to declare the *grid container,* the element
    used as the grid’s foundation. The dimensions of the grid container are the limits
    of the grid, and all of the grid’s properties are applied to it. To declare the
    grid container, use the `display` property with the new value `grid` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This declaration creates a block-level grid container. The next step is to define
    its tracks (rows and columns). You can define tracks on an *explicit grid*, with
    a precise number of columns and rows, or on an *implicit grid,* which is created
    relative to its content. You can also combine both explicit and implicit grids,
    and I’ll explain each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Explicit Grids by Setting Track Size***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In an explicit grid, you can define a specific number of grid tracks by setting
    their size using a pair of properties: `grid-template-columns` and `grid-template-rows`.
    The value for each property is a space-separated list of lengths, which sets the
    width of the column or the height of the row. For example, the following code
    snippet creates a three-column grid, where the first and last columns are set
    to 20 percent of the width of the grid container and the second to 60 percent
    of the width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use percentages or any unit of length, including the specialized grid
    unit of length called a *fraction (fr)*. One fr is equivalent to one equal share
    of any unassigned length in a grid. I’ll explain what I mean. Take a look at this
    code, where the grid container has a width value of 600px, and three columns each
    have a defined width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The total width of the columns is 400px, which is 200px less than the width
    of the container. In this case, adding an extra column of 1fr width makes that
    column as wide as all of the remaining space, or 200px:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding another column of the same width makes both columns 100px in width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And making one of those columns 3fr in width means the remaining width is divided
    into four equal portions of 50px each, making 1fr equal to 50px and 3fr equal
    150px:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning to the first example in this section, you could replace the percentages
    with the fr unit to achieve the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*See “Fractions vs. Percentages” on [page 213](ch17.html#page_213) for an explanation
    of the advantages of using fractions for laying out grids.*'
  prefs: []
  type: TYPE_NORMAL
- en: This code actually defines three grid lines, with an additional one automatically
    created at the start of the writing direction (which is left, in languages written
    from left to right). These lines create three vertical grid tracks, or columns,
    as shown in [Figure 17-2](ch17.html#ch17fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f17-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: A simple three-column grid in the ratio 1:3:1 (grid lines and
    numbers added for clarity)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You add rows in the same way. For example, to create three rows with the first
    one 60px high, the second with the value of `auto` so it’s as high as its content,
    and the third 5em high, you could use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining these properties lets you fully define your grid. For example, this
    code creates a basic grid of three columns and three rows, for a total of nine
    cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The columns of this grid are distributed in the ratio 1:3:1, and the rows are
    60px at the top, 5em at the bottom, with a central row set to automatic height
    to accommodate its content. The resulting grid looks something like [Figure 17-3](ch17.html#ch17fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f17-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: A 3×3 explicit grid (lines and numbers added for clarity)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**FRACTIONS VS. PERCENTAGES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When used on their own, percentages and fractions are interchangeable. For
    example, in this code, the two rules have the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Where they differ is when they are mixed with length units such as `px` or
    `em`. Say you have a grid with one 15em column and you want to fill the remaining
    space with two equally sized columns. With percentages, you can’t really do this,
    unless you know the width of the container and are happy to perform some complex
    calculations. You might think you could use `calc()` (see [Chapter 16](ch16.html#ch16))
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But the spec isn’t clear if `calc()` is permitted, and no current grid implementations
    (at the time of writing) allow you to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these cases, fractions prove more useful than percentages. When you recall
    that a grid fraction, or fr, sets aside an equal share of any space yet to be
    distributed, the fraction-based code you would use for this example becomes clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, any undistributed width in the grid will be divided into two equally sized
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: Although, at times, you may be able to use percentages easily in your grids,
    fractions keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: '***Placing Items in an Explicit Grid***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every immediate child of a grid container becomes a grid item and should be
    placed in the grid. To do so, you assign the item a cell coordinate using a set
    of placement properties. The first of these are `grid-column-start` and `grid-row-start`,
    and each takes a single whole number as a value. This number refers to the line
    at the start of a grid track (whether a column or a row), and the combined track
    references create the coordinate of a cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to place an item in the cell in the second row of the second column,
    you use this code ([Figure 17-4](ch17.html#ch17fig4) shows the result):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](graphics/f17-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: An item placed on the grid in the second row of the second column
    (lines added for clarity)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value of both the `grid-column-start` and `grid-row-start` properties
    is 1, so omitting either value places the item in the first row or column. For
    example, the following code places the item in the cell in the second column of
    the first row, as shown in [Figure 17-5](ch17.html#ch17fig5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](graphics/f17-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: A second item placed on the grid in the second column, first
    row (lines added for clarity)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the item is fitted into the designated cell only, with any content
    that doesn’t fit overflowing the cell vertically. You can make an item expand
    in size to create an area that covers multiple cells in rows or columns by using
    the `grid-column-end` and `grid-row-end` properties. Just like their counterparts,
    these properties take a single whole number value, which designates the line that
    the cell should end in. For example, to have an item span three rows, starting
    at line 1 and ending at 4, here’s the code you use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The item is placed in the first column by default; it starts at line 1 and ends
    at line 4, meaning it spans three rows, as shown in [Figure 17-6](ch17.html#ch17fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f17-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-6: An item on the grid spanning three rows of the first column (lines
    added for clarity)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to the method just shown, you can, instead, use the `span`
    keyword, followed by the number of tracks the item spans. The rewritten rule looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `span` keyword becomes quite useful when you want to remain agnostic about
    the line at which a grid item will start, but you always want it to span the same
    number of columns.
  prefs: []
  type: TYPE_NORMAL
- en: '***Grid Placement Shorthand Properties***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Writing four individual properties to place an element in a grid seems somewhat
    verbose, and, indeed, shorthand properties will make your code more terse. The
    properties in question are `grid-column` and `grid-row`, and each has the same
    syntax. The first, `grid-column`, is short for `grid-column-start` and `grid-column-end`,
    divided by a slash; and the same goes for `grid-row` being short for `grid-row-start`
    and `grid-row-end`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll illustrate how to use them. Take a look at all of the individual properties
    applied to the same element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the shorthand properties, you can write these in a much more manageable
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If even two properties are too much for you, you can actually combine all of
    these instructions in a single shorthand rule, `grid-area`, which covers all four
    properties. Here’s the basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inserting the appropriate values gives us this very terse—although, arguably,
    harder to read—rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '***Repeating Grid Lines***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although simple grids are fine for some real-world situations, more complex
    grids give you finer control over content. Having upward of 12 columns in large
    typographic grids is quite common, and each column usually has a *gutter* (empty
    space) between it and its neighbor. Defining a grid of 12 columns could be repetitive
    using the Grid Layout syntax, as you can see in this example code where I’ve mapped
    out 12 columns of 1fr each, with a gutter of 10px between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `repeat()` function to avoid this type of repetition when using
    larger grids. This function takes two arguments: an integer that sets the number
    of repetitions, followed by a comma separator, and the grid line values to be
    repeated. For example, the following rule creates the same grid as in the previous
    example, but much more concisely; it defines one track that is 1fr wide and then
    uses `repeat()` to create a pattern of a 10px gutter followed by a 1fr column
    eleven times, for a total of 12 columns of 1fr each.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '***Named Grid Areas***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to placing items in a grid based on coordinates, you can also place
    items in *named areas* with the `grid-template-areas` property. With this property,
    you can give grid areas specific names using a series of unique identifiers in
    strings of text. Here, I’ll show you what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Two of these rules should be familiar now: line ➊ sets the element to act as
    a grid container, and line ➌ creates three columns of 1fr each. Line ➋ uses the
    `grid-template-areas` property to name each of the columns: each identifier in
    the space-separated string (*a*, *b*, and *c*) is matched to the columns, in turn.
    This output is shown in [Figure 17-7](ch17.html#ch17fig7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f17-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-7: Three columns made with named areas*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To place an item using a named area, you use the area’s identifier as a value
    for the `grid-area` property. For example, to place an item in the middle (*b*)
    column of my example grid, I use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t have to use single characters to name areas, as I’ve done here; you
    can use any string of characters, as long as they don’t contain a space. For example,
    to make your content more human-readable, you may want to describe the purpose
    of each area. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Each string of identifiers represents a grid row, so to add a new row, you
    just add a new string. If you use the same identifier multiple times in the same
    string, the area will span that number of columns. If you use the same identifier
    in the same position in different rows, the area will span that number of rows.
    You can see what I mean in the following code; in the first row, one column is
    called *nav* and two are called *head*, so the *head* area will span two columns;
    the second row also has a first column called *nav*, so the *nav* area will span
    two rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using this code, you can place grid items into areas that span multiple tracks.
    In the following snippet, element `*F*` is placed into the *head* area, meaning
    it spans the second and third columns of the first row, and element `*G*` will
    be placed into the *nav* area, making it span the first and second row in the
    first column. This is shown in [Figure 17-8](ch17.html#ch17fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](graphics/f17-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-8: Items placed on the grid in named areas (lines added for clarity)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you use multiple string identifiers, you must use the same number of columns
    in each grid; otherwise, the rule will be declared invalid and be ignored.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The grid-template Shorthand***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To avoid having to write three separate rules to define a grid (`grid-template-columns`,
    `grid-template-rows`, and `grid-template-areas`), you can use the `grid-template`
    shorthand. This shorthand makes defining your columns and rows, without named
    areas, simple. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the property with named grid areas, you add the identifiers after the
    slash, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you also want to define heights for the rows, you can add the length
    value of the row after each identifier string. Let’s look back at the full grid
    defined in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how that grid looks if written using the `grid-template` shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I don’t declare the row height after the second named area string because
    it defaults to* `*auto*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Implicit Grids***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Implicit grids are defined by their contents, rather than the specified length
    values of explicit grids. When you don’t care how many rows or columns there are
    in your grid, only that each item in the grid has a place, you can use the `grid-auto-columns`
    and `grid-auto-rows` properties. Each property takes a single value to specify
    the width of the row or column. For example, this code says that any created columns
    should be 1fr wide, and that any new rows should be 80px:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now any item with a `grid-column` or `grid-row` value will be placed in the
    grid, and the grid will automatically adjust its size to accommodate the items,
    keeping all columns and rows at the set size. For example, the following code
    shows a grid item set to start in the second column of the first row, and to span
    two rows and two columns. The grid will expand to fit this item, as you can see
    in [Figure 17-9](ch17.html#ch17fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](graphics/f17-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-9: An implicit grid created by the item it contains (lines added
    for clarity)*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Grid Items Without a Declared Place***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What happens to children of the grid container that have no declared place in
    the grid because they don’t have either `grid-column` or `grid-row` values? They
    fall back to the default values of 1 and are stacked into the same cell at row
    one, column one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can alter this default behavior with the `grid-auto-flow` property, which
    ensures that any items without an assigned place are inserted into the grid where
    space is available. You can also add a level of control over where they’re placed.
    Here is the basic form of this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The keyword can be `column` or `row`. If you use `column`, items will fill empty
    cells in columns, moving down the column; if you use use `row`, the items will
    fill empty rows, moving across the row. For example, in [Figure 17-10](ch17.html#ch17fig10),
    the container on the left has a `grid-auto-flow` value of `column`, so the items
    that haven’t been placed fill the cells of each row down the current column and
    then skip up to the next column when the first column is filled. On the other
    hand, the container on the right has the value of `row`, so the items are placed
    across the row until the row is filled, at which point the items move to the second
    row.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f17-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-10: Comparing automatic flow: (left) items flowed into columns and
    (right) items flowed into rows*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining Explicit and Implicit Grids**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you create explicit grids, you may find that the number of available grid
    tracks is fewer than you need for your items. Say you have a three-column grid,
    but a grid item is supposed to span four columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the grid will expand to contain the tracks created by the item;
    an extra column will be added to the grid, making four in total. You can set the
    size of these extra tracks with the `grid-auto-columns` and `grid-auto-rows` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates an explicit grid of three columns and two rows and
    allows for any items exceeding this explicit grid by adding an implicit grid.
    The extra columns in the implicit grid are defined as 1fr wide, with extra rows
    being 80px high:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now any items placed in this grid will fill an area that matches the dimensions
    of the explicit grid.
  prefs: []
  type: TYPE_NORMAL
- en: '***The grid Shorthand***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Defining a grid with both explicit and implicit properties can lead to a large
    list of rules. For example, the following code shows an element with rules to
    create an explicit grid with named areas, as well as implicit grid properties
    to allow for any items that might extend the grid, giving you a total of six rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, a shorthand property is available for this list of rules. The
    shorthand is called `grid`—however, you can only use it to set either explicit
    or implicit grids, not both. To use it to set implicit grids, use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So here is the shorthand for the implicit grid rules shown in the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grid` syntax for setting explicit grids is exactly the same as for the
    `grid-template` property you saw earlier in this chapter. That being the case,
    here is the shorthand for the explicit grid rules shown at the start of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You might find it strange that two shorthand properties do exactly the same
    thing. I can only agree with you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Grid Item Stacking Order**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When placing items on a grid, areas will sometimes overlap. To handle such an
    eventuality, you can create a stacking order to define the way that items are
    stacked in the grid. For example, you could say that items that start in the third
    row should be stacked on top of items that start in the first row, regardless
    of their order in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the stacking order with the `z-index` property. The items with
    the highest `z-index` value will be stacked above all others. For example, the
    following markup shows two `div` elements that will become grid items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ll place both items in the grid, but by adding the following code I ensure
    that `*item-one*` will be stacked on top of `*item-two*` by making its starting
    column and row greater than those of `*item-two*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the result in the example on the left of [Figure 17-11](ch17.html#ch17fig11):
    `*item-one*` is stacked above `*item-two*`. But if you increase the `z-index`
    of `*item-two*` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: you’ll see that `*item-two*` is now stacked above `*item-one*`, as shown on
    the right of [Figure 17-11](ch17.html#ch17fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f17-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-11: Comparing stacking order: (left) stacking follows placement,
    (right) stacking set by* `*z-index*`'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach uses the `order` property, introduced as part of the
    Flexbox Module (see [Chapter 15](ch15.html#ch15)). In explicit grids, this property
    acts exactly like `z-index`, changing the stacking order; in implicit grids, however,
    it also changes the order in which items are placed in the grid.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this in action in [Figure 17-12](ch17.html#ch17fig12), where I’ve
    flowed three grid items (`*item-one*`, `*item-two*`, and `*item-three*`) into
    a grid with a `grid-auto-flow` value of `column`. In the left grid, the items
    are flowed into the grid in the order in which they appear in the DOM, but in
    the right grid, the order of two of the items is changed, as shown in [Figure
    17-12](ch17.html#ch17fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](graphics/f17-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-12: Stacking with the* `*order*` *property in implicit grids: (left)
    in DOM order and (right) order set with the* `*order*` *property*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internet Explorer’s Grid Layout Syntax**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internet Explorer 10 was the first browser to implement the Grid Layout properties,
    although with a syntax that has since become outdated. So you can replicate certain
    grid layouts in IE10 and IE11 if you use caution, but with very strict limits—the
    most notable being that you can only create explicit grids.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the IE grid properties use the `-ms-` prefix, as does the value of the
    `display` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You create tracks with the `-ms-grid-columns` and `-ms-grid-rows` properties,
    which are analogous to `grid-template-columns` and `grid-template-rows`. The difference
    is in the way you repeat track lines: When designing for IE, you put the width
    values in parentheses, followed by the number of repetitions in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Grid items are placed with the `-ms-grid-column` and `-ms-grid-row` properties,
    which function like `grid-column` and `grid-row`, but only allow a single numeric
    value. To span items across multiple cells, you must use `-ms-grid-column-span`
    and `-ms-grid-row-span` to set the number of tracks an item should span (like
    the `span` keyword.)
  prefs: []
  type: TYPE_NORMAL
- en: 'That being the case, the rules applied to elements `*E*` and `*F*` in this
    code block are identical in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As of this writing, the IE syntax has no named areas, nor does it have anything
    equivalent to `grid-column-end` or `grid-row-end`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Grids are the first step toward a whole new way of laying out content on the
    Web. The combination of Grid Layout, Flexbox positioning, and Media Queries makes
    possible rich layouts that you can adapt to many different devices and viewports,
    ushering in a whole new world of web design, free from the constraints of float
    hacks and restrictive markup.
  prefs: []
  type: TYPE_NORMAL
- en: '**Grid Layout: Browser Support**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  prefs: []
  type: TYPE_TB
- en: '| Grid layout | No^([*](ch17.html#footnote39a)) | No | No | IE10^([†](ch17.html#footnote40a))
    |'
  prefs: []
  type: TYPE_TB
- en: '[*](ch17.html#footnote_39a) Implemented but off by default'
  prefs: []
  type: TYPE_NORMAL
- en: '[†](ch17.html#footnote_40a) Syntax different from the spec; with vendor prefix'
  prefs: []
  type: TYPE_NORMAL
