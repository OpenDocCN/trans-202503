- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 8 LOCAL INFORMATION GATHERING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous two chapters, we gained an initial foothold on several hosts.
    In this chapter, we’ll perform local reconnaissance to identify assets of interest,
    leaving no stone unturned on the path to taking over other hosts on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing where to find sensitive information once you successfully compromise
    a host is a critical skill. We’ll focus on key categories of information you can
    gather: identities (like users and groups), files (including logs and configurations),
    network information, automation workflows, installed software and firmware, running
    processes, and security mechanisms. We’ll cover other information, such as credentials,
    in [Chapter 9](chapter9.xhtml), when we discuss privilege escalation techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In real-life scenarios, the post-compromise phase is also where your chances
    of getting caught by defenders increase, as the information you gather could leave
    a trail. For this reason, we’ll default as much as possible to using native Linux
    utilities and files to collect information in an attempt to *live off the land*:
    making do with what’s available on a host while avoiding the use of external tools,
    which could trigger alerts.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the shell commands presented in the chapter on all the hosts you’ve
    compromised thus far, as well as any new machines you compromise as you progress
    through the book. You could even build a script from these commands to easily
    execute the same ones on all machines.
  prefs: []
  type: TYPE_NORMAL
- en: The Filesystem Hierarchy Standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data of interest could live in many areas of a Linux filesystem. To efficiently
    explore the systems on which you’ve obtained shell access, consult the *Filesystem
    Hierarchy Standard (FHS)*, which describes the structure of directories and their
    locations on a Linux system. This hierarchical standard makes it easier for users
    and programs to search for files of interest, such as log or configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux filesystem’s hierarchy starts at the root (*/*) directory, which is
    the entry point into the filesystem directory tree structure. [Table 8-1](chapter8.xhtml#tab8-1)
    shows the main subdirectories under root and their primary uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1: Filesystem Hierarchy Standard Directory Layout'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| / | Primary parent directory, also called the root directory. |'
  prefs: []
  type: TYPE_TB
- en: '| /var | Directory for nonstatic (variable) files. Often contains application
    logfiles under the /var/log directory or contains processed tasks, such as scheduled
    and print jobs, under /var/spool. It may also contain cache files in /var/cache
    and system-related runtime data under /var/run. |'
  prefs: []
  type: TYPE_TB
- en: '| /etc | Directory for configuration files. Application software installed
    on the system keeps dedicated configuration files in this directory (usually with
    the *.conf extension). This directory also contains files such as /etc/passwd,
    /etc/group, and /etc/shadow, where user accounts, group information, and password
    hashes, respectively, exist. |'
  prefs: []
  type: TYPE_TB
- en: '| /bin | Directory for binary utilities. Commonly used for storing binaries
    related to system tasks such as navigation commands (cd), file copying (cp), directory
    creation (mkdir), or file creation (touch). |'
  prefs: []
  type: TYPE_TB
- en: '| /sbin | Directory for system binaries, such as system debugging, disk manipulation,
    and service management utilities that are intended for use by the system administrator.
    |'
  prefs: []
  type: TYPE_TB
- en: '| /dev | Directory that represents and provides access to device files, such
    as disk partitions, thumb drives, and external hard drives. |'
  prefs: []
  type: TYPE_TB
- en: '| /boot | Directory for bootloaders, kernel files, and initial random-access
    memory (RAM) disks (initrd). |'
  prefs: []
  type: TYPE_TB
- en: '| /home | Directory containing the home directory of local system user accounts.
    Active system user accounts usually have a subdirectory as their assigned home
    directory. |'
  prefs: []
  type: TYPE_TB
- en: '| /root | Directory containing the home directory of the root user account.
    |'
  prefs: []
  type: TYPE_TB
- en: '| /tmp | Directory for temporarily written files and directories. The /var/tmp
    directory is another temporary directory often used for temporary files. |'
  prefs: []
  type: TYPE_TB
- en: '| /proc | Virtual filesystem for processes and kernel data. Gets automatically
    created on system boot. |'
  prefs: []
  type: TYPE_TB
- en: '| /usr | Directory for user binaries, manual pages, kernel sources, header
    files, and more (including games, in the past). |'
  prefs: []
  type: TYPE_TB
- en: '| /run | Directory for runtime data. Describes the state of the system since
    it was last booted. |'
  prefs: []
  type: TYPE_TB
- en: '| /opt | Directory for software applications. Often hosts data related to third-party
    software installations. |'
  prefs: []
  type: TYPE_TB
- en: '| /mnt | Directory for mounting network shares or other network devices, mostly
    used for mounting devices to the local filesystem either temporarily or permanently.
    |'
  prefs: []
  type: TYPE_TB
- en: '| /media | Directory for removable devices, such as CD drives. Serves as a
    mount point. |'
  prefs: []
  type: TYPE_TB
- en: '| /lib, /lib32, /lib64 | Directory for shared libraries needed to boot the
    system and run commands. |'
  prefs: []
  type: TYPE_TB
- en: '| /srv | Directory for data commonly served by network services, such as web
    servers and file servers. |'
  prefs: []
  type: TYPE_TB
- en: Production systems could have thousands of files scattered across their systems,
    so it’s important to know what sensitive data to search for and where to search
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: While FHS aims to standardize the layout of the filesystem, systems can deviate
    from the standard. Additionally, the system administrator can store application
    files wherever they like. For example, nothing stops a system administrator from
    serving their entire web server content from a directory such as */mywebsite*
    and writing logs to a directory such as */data/logs*.
  prefs: []
  type: TYPE_NORMAL
- en: The Shell Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From an information-gathering perspective, the shell environment is important
    because it can reveal information such as where the system looks for executables
    to run. Custom applications may add new directory paths to the PATH environment
    variable so that the application can run custom libraries and executables from
    nonstandard locations. You might also find credentials and other secrets in these
    custom configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Environment Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When compromising a host, it’s often useful to dump its environment variables
    by using the env or printenv commands. Administrators tend to store credentials
    in environment variables to avoid writing the credentials to files on disk. Delivery
    systems can inject credentials into the application’s runtime via these environment
    variables, which the application then reads. In addition, you may find other important
    information in environment variables, such as addresses of adjacent servers and
    runtime configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive Information in Bash Profiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 2](chapter2.xhtml), we used the *~/.bashrc* file and bash aliases
    to set up shortcuts to commands. System administrators could easily include credentials
    in shell scripts such as *~/.bashrc* to avoid having to manually supply credentials
    on the command line, so always poke around to see if any customizations were made;
    you may find credentials or commands used for administration purposes. Here are
    some common profile files to look for: */etc/profile*, */etc/bashrc*, *~/.bashrc*,
    *~/.profile*, *~/.bash_profile*, *~/.env*, *~/.bash_login*, and *~/.bash_logout*.'
  prefs: []
  type: TYPE_NORMAL
- en: Shells other than bash, such as the Z Shell, can also exist on a system. In
    these cases, you might want to look at files such as */etc/zprofile*, */etc/zshrc*,
    *~/.zprofile*, and *~/.zshrc*.
  prefs: []
  type: TYPE_NORMAL
- en: Use the man command to learn more about the environment and profile files of
    the various shells. For example, run man bash for the bash shell, man zsh for
    the Z Shell, and man csh for the C Shell.
  prefs: []
  type: TYPE_NORMAL
- en: Users and Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should gather information about the various users and groups found on the
    system. Systems can be provisioned with user accounts for human operators, but
    you may also run into systems that have no accounts other than the default ones
    of a Linux machine. This is especially true in environments where hosts are spun
    up and down many times per day, such as in containerized environments. Short-lived
    servers aren’t generally managed using local system accounts; rather, orchestration
    and provisioning tools automate the entire process of rollouts, upgrades, downgrades,
    scaling in and out, scaling up and down, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Local Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux systems come with several default users and groups. You can find user
    accounts in */etc/passwd* and groups in */etc/group*, which even low-privileged
    users should be able to read. These files don’t contain sensitive data but can
    help you figure out other directories and files to look for, as everything on
    a Linux system is owned by a user and group.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Hackers frequently go after both* /etc/passwd *and* /etc/group*, so security
    defenders with proper monitoring in place will watch for any read or write attempts
    made to these files.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s view the */etc/passwd* files on the compromised hosts. Run the command
    in [Listing 8-1](chapter8.xhtml#Lis8-1) on *p-web-01* (172.16.10.10), *p-web-02*
    (172.16.10.12), and *p-jumpbox-01* (172.16.10.13) to see the list of users and
    their properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: Viewing users on a system'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we get a list of values separated by colons (:). Each line is
    a unique user account, and each field represents specific information about it.
    Of particular interest to us is the first line in the output, which indicates
    that there is a *root* user account. [Table 8-2](chapter8.xhtml#tab8-2) breaks
    this line into its constituent fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-2: Fields of the /etc/passwd File'
  prefs: []
  type: TYPE_NORMAL
- en: '| Account | Password | User ID | Group ID | Comment | Home directory | Default
    shell |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| root | x | 0 | 0 | root | /root | /bin/bash |'
  prefs: []
  type: TYPE_TB
- en: The first field is the account’s username, and the *x* in the second field represents
    the password. You can find corresponding password hashes in a separate file named
    */etc/shadow*, which we’ll cover in later chapters when we discuss credential
    access. The third and fourth fields represent the user’s user ID (UID) and group
    ID (GID), respectively. The fifth field is a comment field that can contain details
    about the user (such as their full name, location, and employee ID). The sixth
    field represents the user’s home directory (in this case, */root*), and the seventh
    field represents their default shell environment (in this case, */bin/bash*).
  prefs: []
  type: TYPE_NORMAL
- en: Using bash, we can parse the */etc/passwd* output to extract certain desired
    fields. For example, to extract the username (in the first field), the home directory
    (in the sixth field), and the default shell (in the seventh field) of each user,
    run the command in [Listing 8-2](chapter8.xhtml#Lis8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: Extracting key information from /etc/passwd'
  prefs: []
  type: TYPE_NORMAL
- en: Because the fields are separated by colons, we can easily use awk and sed to
    retrieve the fields of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Local Groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, run the command in [Listing 8-3](chapter8.xhtml#Lis8-3) to see the list
    of local groups.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: Viewing groups on a system'
  prefs: []
  type: TYPE_NORMAL
- en: 'The */etc/group* file is formatted as follows: the first field is a unique
    value representing the group’s name, the second field represents the password,
    the third field is the GID, and the last field is the list of members of each
    group, separated by commas. As you can see in the bolded part of the output, the
    *ubuntu* user account is part of the *adm* group, which is a group used for system
    administration tasks such as viewing logs.'
  prefs: []
  type: TYPE_NORMAL
- en: Home Folder Access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, only the user or a superuser, such as the *root* user, can access
    that user’s home directory. Run the command in [Listing 8-4](chapter8.xhtml#Lis8-4)
    to list all user home directories and their permissions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: Viewing home directories and permissions'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, each home directory is owned by the user to which it belongs.
    We’ll discuss directory permissions in more detail in [Chapter 9](chapter9.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a small bash script to check whether we can access users’ home directories.
    This is useful because permissions can get messed up by mistake, such as when
    they’re changed recursively or when they’re part of large systems that may have
    dozens of user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This chapter’s scripts are available at* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch08](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch08).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script in [Listing 8-5](chapter8.xhtml#Lis8-5) will take the following
    steps: check whether the running user can read */etc/passwd*, and if so, read
    its contents; extract the default home directory path of each user account; check
    whether the current user can read each home directory; and print the results.'
  prefs: []
  type: TYPE_NORMAL
- en: home_dir _access_check.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: Attempting to access users’ home directories'
  prefs: []
  type: TYPE_NORMAL
- en: In a while loop, we read the */etc/passwd* file line by line ❶. At ❷ and ❸,
    we assign the account and home_dir variables to the first and sixth fields of
    each line, respectively. We then check whether the home directory starts with
    the string /home by using the caret (^) character ❹ and the grep -q (quiet) option
    so that the output of the command won’t be printed to the standard output stream.
    At ❺, if our previous check succeeded, we check whether the home directory is
    readable with -r and print the result to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Valid Shells
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We mentioned that the seventh field of */etc/passwd* is the user’s default
    shell. However, the system administrator can assign users an invalid shell as
    a security hardening measure. For hackers, accounts with real shells (such as
    */bin/bash*) should thus indicate one of two possibilities: that the account belongs
    to a real user or service with a possible need to log in, or that the account
    has a possible misconfiguration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When system administrators add an account to a Linux machine by using the command
    useradd or adduser, the default shell is determined by the SHELL setting in the
    file */etc/default/useradd* or by DSHELL in */etc/adduser.conf*, as you can see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With some advanced bash and awk, we can filter for lines containing valid shells
    such as */bin/bash* or */bin/sh*, then focus our future efforts on those accounts
    only ([Listing 8-6](chapter8.xhtml#Lis8-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-6: Using advanced awk syntax to find accounts with active shells'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve intentionally made this command slightly more complicated than necessary
    so you can see how powerful awk can be for parsing purposes. In [Listing 8-6](chapter8.xhtml#Lis8-6),
    awk uses its built-in if condition and an OR operator (||) to check whether the
    seventh field of the file equals */bin/sh* or */bin/bash*. It then prints the
    first and seventh fields if the expression is true.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with anything in bash, you can achieve the same objective with an even
    simpler command ([Listing 8-7](chapter8.xhtml#Lis8-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-7: Using grep to find accounts with active shells'
  prefs: []
  type: TYPE_NORMAL
- en: This simpler grep command is more prone to errors, however, because it will
    print any field that contains either of the two strings (not specifically the
    seventh field, where the default shell is defined).
  prefs: []
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumerating running processes is an extremely important step of successful reconnaissance.
    Processes help us identify all code that a system is running, allowing us to focus
    our efforts on specific applications. Processes are also important because they
    help us understand a host’s defense systems.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Process Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each process on a Linux host has a dedicated directory under */proc* that is
    named after its process identifier (PID), which is a numerical value. Let’s run
    a simple ls command (using the -1 option to list one file per line) and grep with
    a special regular expression to list all files in this directory that have numbers
    as their name ([Listing 8-8](chapter8.xhtml#Lis8-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-8: Filtering for PIDs in the /proc directory'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because new processes frequently spawn and then die, you’ll likely see different
    PID numbers from those in this output (with the exception of 1, also called the
    *init process*, which should always be present). Let’s explore the information
    available to us in the folder for the init process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The folder contains many files, some of which are more interesting than others
    to penetration testers. For example, the following files contain useful information:'
  prefs: []
  type: TYPE_NORMAL
- en: '***/proc/<pid>/cmdline*** Contains the full command used to start the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '***/proc/<pid>/cwd*** Points to the working directory of the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '***/proc/<pid>/environ*** Contains the environment variables at the process’s
    start time.'
  prefs: []
  type: TYPE_NORMAL
- en: '***/proc/<pid>/exe*** Points to the binary that started the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '***/proc/<pid>/task*** Contains subdirectories for each thread started by the
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: '***/proc/<pid>/status*** Contains information about the process, such as its
    state, virtual memory size, number of threads, thread ID, and process *umask*
    (a four-digit value used to determine the permissions of freshly created files).'
  prefs: []
  type: TYPE_NORMAL
- en: '***/proc/<pid>/fd*** Contains the *file descriptors* in use. File descriptors
    are nonnegative (unsigned) integers used by processes to describe open files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore some of these files to see what they can tell us about PID 1
    on the system. On *p-web-01* (172.16.10.10), run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a python3 command starts this process. The output is a little
    hard to read because its elements are separated by null bytes. We can make it
    more readable by using the following command to replace null bytes with spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, look at the symbolic link */proc/1/cwd* to determine the working directory
    of process 1 by running the following ls command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first character in the output is l, which stands for a symbolic link. You
    can also see we have an arrow (->) from */proc/1/cwd* to */app*, indicating that
    the *cwd* symbolic link points to the */app* directory.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to discover any other files that live under the */proc* directory
    and their purposes. You can find a well-explained list of these files in the proc
    manual page (by running man proc).
  prefs: []
  type: TYPE_NORMAL
- en: Running ps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Utilities such as ps can enable us to explore processes without having to manually
    navigate the /*proc* directory. Run the following command to see the list of processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output is lightweight because the lab runs on containers, and containers
    are designed to use the smallest number of resources possible. On production systems
    running non-container-based servers, you’ll likely see many more processes. You
    can run the same command on your Kali host to see the differences in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ps command uses the */proc* virtual filesystem to display process information
    in a more digestible way. Let’s use some of its built-in filtering capabilities
    to extract key information from the output, such as the running user, the PID,
    and the executed command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the same command against all boxes we’ve compromised so far and note your
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Root Processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ownership of processes is also an important element to consider. Processes
    running as root can lead to privilege escalation vulnerabilities if they are written
    insecurely. For example, when we compromised the *p-web-01* web server (172.16.10.10),
    we landed in the shell as the *root* user because the *root* user initialized
    and started the application.
  prefs: []
  type: TYPE_NORMAL
- en: Running applications as a superuser is generally considered bad practice, but
    it makes our lives as penetration testers much easier. If the application were
    started with a custom application user, we would have had to seek privilege escalation
    opportunities. As you may recall, when we compromised the *p-web-02* (172.16.10.12)
    machine, we landed as the *www-data* user, not root.
  prefs: []
  type: TYPE_NORMAL
- en: As another example of why using the *root* user for an application runtime is
    bad practice, imagine that a bash script executes a file called */tmp/update.sh*
    every 10 minutes as a background job run by root, and say the file also happens
    to be writable by other system users. In this example, someone could write an
    instruction inside the file to grant themselves additional permissions, and since
    the process runs as root, the execution of the *update.sh* file would also run
    in the *root* user context.
  prefs: []
  type: TYPE_NORMAL
- en: The Operating System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux operating system has so many variations that special websites such
    as *[https://distrowatch.com](https://distrowatch.com)* are dedicated to tracking
    them. How do you know exactly which operating system is running on the box you
    just took over?
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating systems may place information about themselves in different places,
    but for the most part, you’ll find it under the */etc* directory. Check the following
    locations: */etc/os-release*, */etc/issue*, */usr/lib/os-release*, */proc/version*,
    */etc/*-release*, and */etc/*-version*. For example, on the Ubuntu-based *p-web-01*
    machine (172.16.10.10), you should be able to find information about the operating
    system in */etc/os-release*.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to files, some utilities could also help you identify the operating
    system. Try running uname -o or uname -a, lsb_release, hostnamectl, and hostname.
    Although commands such as hostname and hostnamectl aren’t designed to show operating
    system information, they could reveal it if the system administrator set the machine’s
    hostname to include the operating type, such as *ubuntu-prod-01*. The same applies
    to the built-in environment variable $HOSTNAME, which also holds the hostname
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12: Writing a Linux Operating System Detection Script'
  prefs: []
  type: TYPE_NORMAL
- en: Try writing a script that can identify the operating system type (such as Ubuntu,
    Debian, or other) of any Linux-based operating system. To achieve this, the script
    should look for specific files of interest and extract information from them.
    Also, because anyone should be able to run the script on any Linux system and
    expect it to fail gracefully, you need to think about how you’ll handle errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps the script should take:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The script should use one or more of the available methods to gather the
    operating system–related information we highlighted earlier, using either a command
    or a file. You can also perform your own research to implement other local operating
    system discovery methods.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  If you haven’t found an operating system detection method, the script needs
    to handle this condition and indicate it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The script should exit with the correct status code for the runtime result.
  prefs: []
  type: TYPE_NORMAL
- en: The script *os_detect.sh* in this book’s GitHub repository is an example of
    an operating system detection script.
  prefs: []
  type: TYPE_NORMAL
- en: Login Sessions and User Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user logs in to a system or opens a new terminal session, the system
    records this information. This occurs no matter whether the user logs in locally
    (on a laptop, for example) or remotely, over a protocol such as SSH or Telnet.
  prefs: []
  type: TYPE_NORMAL
- en: This information is valuable because it could tell you about previous connections,
    including source IP addresses used to connect. For example, if a system administrator
    uses a dedicated management server to connect to other servers, collecting login
    sessions would reveal the IP address of the management server.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting User Sessions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To view the current users on a system, use the w or who commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These commands show information such as the user’s username, their login time,
    and the command of their current process. The commands read this information from
    the */var/run/utmp* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last command shows historical logins taken from the file */var/log/wtmp*,
    which contains both current and past user sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Attempt these commands on the *p-jumpbox-01* machine (172.16.10.13) after logging
    in via SSH with the backup user.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful command is lastb (last bad). This command displays a list of
    bad login attempts, taken from */var/log/btmp*, if such a file exists on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Files such as */var/run/utmp* and */var/log/wtmp* are binary files. If you try
    to read them by using the cat command, the output will be garbled. Some systems
    may have the utmpdump command, which takes in these files as arguments and prints
    them in proper format to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating Executed Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user starts executing commands in the shell, the system captures this
    information and writes it to *history files*, which are usually hidden files (those
    starting with a dot) stored in the user’s home folder. For example, the *root*
    user’s history file is located at */root/.bash_history*. For normal users, the
    history file is usually saved under */home/<user>/.bash_history*. Different shells
    may name history files differently. For example, the Z Shell history file is named
    *.zsh_history*.
  prefs: []
  type: TYPE_NORMAL
- en: 'History files are interesting because they’re essentially a summary of a user’s
    actions on the command line. If someone ran a curl command with credentials to
    authenticate to a remote website, the command, along with the credentials, would
    be recorded in the history file. To see the history file of the current user,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A quick bash one-liner using find can help us search for hidden files with the
    *_history* suffix ([Listing 8-9](chapter8.xhtml#Lis8-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-9: Searching for shell command history files'
  prefs: []
  type: TYPE_NORMAL
- en: This command starts the search from the root directory (*/*) and performs a
    case-sensitive search of files (-type f) whose filenames end with the string *_history*.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Network information is among the most important data to gather about a system.
    During penetration tests, you may know of only one network (the one you’re connected
    to physically if you’re on an on-site engagement, for example), but that doesn’t
    mean this is the only network available. You may discover new networks if you
    happen to hack a *multi-homed* host: a machine with multiple network interfaces
    connected to different networks.'
  prefs: []
  type: TYPE_NORMAL
- en: Network Interfaces and Routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On a compromised host, a simple way to obtain all network interfaces is by
    looking at the files under the */sys/class/net* directory. Go ahead and try listing
    files on the compromised boxes. The following examples are from the *p-web-01*
    box (172.16.10.10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Each file is a symbolic link containing the name of a network interface, and
    each link points to a directory under */sys/devices/virtual/net/*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also use this network interface analysis to identify whether a network
    device is physical or virtual. It’s worth noting that an administrator can change
    network interface names, so these aren’t reliable indicators. However, physical
    network devices should show up differently when you list files under */sys/devices/virtual/net*.
    Run the previous command on your Kali machine. You should see output similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all devices are virtual except eth0, which has a Peripheral
    Component Interconnect bus identifier, pci0000:00/0000:00:03.0. On your machine,
    this might look different depending on the network card you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Definitively identifying a target as a physical or a virtual server requires
    using multiple heuristics. Network collection can produce false positives.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to print all network interfaces without using special network utilities
    is by inspecting the */proc/net/route* file, which contains information about
    network routing. Manually inspecting this file can be useful on hardened hosts
    or lightweight Linux containers, where you may not have access to common network
    utilities such as ifconfig, ip, netstat, or ss (socket statistics):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of the file is the column headers line, and each subsequent
    line corresponds to a network route, its network interface, and other routing-related
    information in hexadecimal format. For example, in the first line, under Gateway,
    the value 010A10AC represents the gateway IP address of the network interface.
    If you convert each byte to a decimal value, you should get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 011
  prefs: []
  type: TYPE_NORMAL
- en: 0A10
  prefs: []
  type: TYPE_NORMAL
- en: 1016
  prefs: []
  type: TYPE_NORMAL
- en: AC172
  prefs: []
  type: TYPE_NORMAL
- en: 'This is 172.16.10.1, the gateway IP address for the interface eth0, in little-endian
    format. You can use *[https://ascii.cl/conversion.htm](https://ascii.cl/conversion.htm)*
    to convert values from hexadecimal to decimal or do so with bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using the arithmetic operators $(()) and the character sequence 16#, which represents
    hexadecimal (or *base16*), you can convert any hexadecimal value to a decimal
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The */proc/net/route* file didn’t give us the IP addresses of the network interfaces
    on the host. However, we can get this information by looking at the */proc/net/fib_trie*
    file. This file contains data that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To parse this output to obtain only the network interface IP addresses, we can
    use the bash script in [Listing 8-10](chapter8.xhtml#Lis8-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-10: Extracting the IP addresses of network interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: 'What about MAC addresses, the physical addresses of the network interfaces?
    We can get this information through the */sys* virtual filesystem too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'On nonhardened hosts, you may have access to network utilities such as ifconfig,
    a very popular command found on Linux hosts. This command lets you view all the
    necessary network information in a more digestible way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You should receive information such as MAC addresses, netmask and broadcast
    addresses, and some network statistics for each interface, such as the number
    of bytes of transmitted and received packets. By default, ifconfig will display
    only network interfaces that are in an “up” state; use the -a flag to display
    all interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative command to ifconfig is ip, which displays the same type of information,
    including routing details. Run ip addr to show all network interfaces and ip addr
    to show all network routes.
  prefs: []
  type: TYPE_NORMAL
- en: Try running these commands on the remaining boxes (*p-web-02* and *p-jumpbox-01*);
    you should notice that one of the boxes is connected to another internal network
    at the address 10.1.0.0/24\. This means one of the compromised hosts has a network
    leg into another network!
  prefs: []
  type: TYPE_NORMAL
- en: Connections and Neighbors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Networks are talkative; packets move in and out of systems continuously. Hosts
    that serve a purpose are rarely idle, and you can passively learn about their
    environment without sending network packets by simply collecting connection information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try collecting such information directly from the */proc* virtual filesystem
    by using the */proc/net/tcp* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this file is a *TCP socket table* in which each row represents
    a connection between two addresses: a local address (local_address) and a remote
    address (rem_address). The data is in hexadecimal, so we must once again convert
    it to decimal to understand the IP addresses and ports behind each connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We use awk to print the second and third fields only, then pipe these to the
    tail -n +2 command to remove the table headers from the output. This table will
    grow as more connections are made between the compromised host and other clients
    and servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use Netstat to print network connections. Netstat prettifies the
    output of each connection and helps highlight which connections are currently
    active, which ones have timed out, and which PID and program name they are related
    to. Run the following command on *p-web-01* (172.16.10.10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let’s focus on the columns that are most valuable to us. The first column represents
    the protocol (for example, TCP or UDP), the fourth column is the local address
    and port, the fifth column is the *foreign address* (the remote address of the
    connection), and the sixth column is the program name and PID. Note that when
    Netstat is executed using a nonroot user, the PID column may not have information
    such as the PID and program name populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we executed the Netstat command, no connections were being made to the
    web application. Let’s simulate an incoming connection to see the socket table
    change. On your Kali host, run the following Netcat command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the Netstat command we showed previously on the compromised *p-web-01*
    host (172.16.10.10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a new line was added to the connection table, representing the
    remote IP address of the client connecting on port 8081\. This remote address
    belongs to the host on which you ran Netcat (in this case, Kali).
  prefs: []
  type: TYPE_NORMAL
- en: Firewall Rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Host *firewall rules* are also a source of network information. A firewall table
    may include rules that block certain networks or individual IP addresses from
    communicating with the host. This information can teach us about other nearby
    networks, servers, or clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common host firewall found on Linux servers is iptables. Let’s run the following
    iptables command to see the rules configured on *p-web-01* (172.16.10.10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a rule blocks the network 10.1.0.0/24 from connecting to the
    *p-web-01* box; this is another indication that an adjacent network at 10.1.0.0/24
    exists. Note that reading the rule table with the iptables command usually requires
    elevated permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Network Interface Configuration Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Network interfaces may have dedicated configuration files that, for example,
    configure a network IP address statically for a specific interface or ensure that
    a network card is enabled on boot by default. Linux distributions can place their
    network configurations in different places, but you’ll commonly find them in the
    following locations: */etc/network/interfaces*, */etc/network/interfaces.d/*,
    */etc/netplan/*, */lib/netplan/*, */run/netplan/*, and */etc/sysconfig/network-scripts/*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If configured statically, network interfaces can shed light on the DNS servers
    in use. Network interfaces can also provide information such as the IP scheme,
    gateway addresses, and more. Here is a static network configuration file available
    in later versions of Ubuntu-based Linux systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This file configures the eth0 network interface with a default gateway of 172.16.10.1,
    as well as Google DNS servers 8.8.8.8 and 8.8.4.4.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Resolvers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hosts are usually configured to use DNS to translate domain names, such as *example.com*,
    to IP addresses. DNS servers can be hosted locally on the network or in other
    places, such as public cloud instances. No matter where they’re running, they
    can be vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could find DNS server configurations in a few places on a Linux operating
    system, including in the */etc/resolv.conf* file using a nameserver entry, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'DNS servers can also be configured within the */etc/hosts* configuration file,
    as shown here for *p-web-01* (172.16.10.10). This */etc/hosts* file may include
    a list of alternative networks and hosts you could target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: DNS servers can also be configured in the individual network interface files,
    as discussed in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: DNS servers can also be configured automatically by using a *Dynamic Host Configuration
    Protocol* server, a network service responsible for handing out network configurations
    dynamically, in which case the DNS server won’t be explicitly set in any configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Software Installations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unmaintained operating system images tend to suffer from a wide variety of vulnerabilities,
    especially if they include many packages installed by default. We should investigate
    the software bundled with an operating system because it can lead us to interesting
    vulnerabilities that can help us escalate our privileges or obtain access to unauthorized
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to investigate installed software is with a package manager. You’ll
    find a few types of package managers commonly available on Linux operating systems:
    Advanced Package Tool (APT) on systems such as Debian and Ubuntu, Yellowdog Updater
    Modified on systems such as Red Hat, CentOS, and Fedora, and Alpine Package Keeper
    on container-based operating systems such as Alpine Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running the following apt command to list installed packages on any of
    the compromised hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get a slightly nicer output by using dpkg instead. Note that this command
    is mostly found on Ubuntu- or Debian-based Linux systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a list of packages using other software managers, you could try any
    of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: yum list installed
  prefs: []
  type: TYPE_NORMAL
- en: apk list --installed
  prefs: []
  type: TYPE_NORMAL
- en: rpm -qa
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use bash to parse these package lists and obtain the software’s name
    and version, as well as do some clever searches. To list only the package names,
    run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following to list only the package versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to search for a specific package and then print its version
    by using an exact match search? We can do so with awk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We use an awk delimiter (-F) consisting of a forward slash and a space and surround
    it with square brackets [/] to define more than one delimiter. We then check whether
    the first field equals openssl; if it does, we print the third field, which is
    the version field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even use awk to partially match package names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the total number of installed packages, run apt list and pipe it to
    the wc (word count) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You could use these package names and versions as lookup queries on websites
    that source vulnerability data, such as the National Vulnerability Database (*[https://nvd.nist.gov](https://nvd.nist.gov)*)
    or the MITRE Common Vulnerabilities and Exposures (CVE) database (*[https://cve.mitre.org](https://cve.mitre.org)*).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the package manager might not list all software installed on a server.
    For example, a server could install Java directly from the source without using
    package management tools, in which case it won’t be shown in the package list.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From a security perspective, server storage is interesting for several reasons.
    Multiple servers could share the same storage system or use it to share files
    with end users. And if you can write into storage systems, you might be able to
    achieve code execution on adjacent servers if they source files, such as shell
    scripts, from the compromised storage system.
  prefs: []
  type: TYPE_NORMAL
- en: Server storage can be virtual or physical, and servers can run on a single local
    disk or multiple local disks. Servers can also use multiple disks to form a redundant
    array of inexpensive disks system, which provides improved redundancy and performance
    and can back up critical data.
  prefs: []
  type: TYPE_NORMAL
- en: Linux systems can mount remote storage systems as local directories (usually
    under the */mnt* directory). These can act as an integral part of the operating
    system. You’ll see remote storage implemented using network-attached storage or
    storage area network devices and protocols like Network File System or Common
    Internet File System.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remote storage is useful to investigate because systems can use it for a variety
    of purposes: as a data backup location, for centralized security logging, as a
    remote file share, or even to store remote user home folders. Application logs
    are often written to remote storage devices in a folder like */mnt/log_storage/*,
    which might be physically connected to a completely different server.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore ways to identify disks, partitions, and mount points on a compromised
    host.
  prefs: []
  type: TYPE_NORMAL
- en: Block Devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let’s look at which block devices exist by using the command lsblk.
    *Block devices* are data storage devices such as CDs, floppy disks, and hard disks.
    The following output is from *p-web-01* (172.16.10.10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have two primary devices: sr0 and vda. The sr0 device is
    of type rom, and vda is of type disk. The other names you see on the list, such
    as vda1, vda2, and vda5, are all partitions of the vda disk. Run the same command
    against the remaining compromised machines you have access to and take note of
    the findings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to view the list of partitions is by reading */proc/partitions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The */proc* filesystem also exposes a file named */proc/mounts*, which provides
    a list of all mounts, their mount options, and additional attributes about the
    mount points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could just call the mount command to get this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick way to get a view of the various mounted filesystems is by using the
    df command, which will also indicate the available and total disk sizes of each
    filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The -h and -T flags will print out a human-readable version of the output and
    the filesystem type, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed a mount point at */mnt/scripts* on *p-web-01* (172.16.10.10).
    Take note of this, as it will come in handy in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The Filesystem Tab File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The */etc/fstab* file is a static configuration file that controls the mounting
    of devices and partitions. Mounting devices and partitions without the necessary
    security measures can lead to filesystem-level vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: You can mount a device or partition at specific filesystem locations by using
    special options that control what can and cannot be done using the mount point.
    For example, you could configure a volume from a remote storage system to be mounted
    on */mnt/external_storage* upon system boot. You could also configure it to be
    a read-only filesystem, which wouldn’t allow writes, or remove execution options,
    so users won’t be able to run binaries from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few mount options that can be beneficial to know about as penetration
    testers:'
  prefs: []
  type: TYPE_NORMAL
- en: dev Interprets special block devices, such as device files.
  prefs: []
  type: TYPE_NORMAL
- en: nodev The opposite of dev; will not interpret special block devices.
  prefs: []
  type: TYPE_NORMAL
- en: noexec Forbids the execution of binaries. Scripts such as bash will still be
    allowed.
  prefs: []
  type: TYPE_NORMAL
- en: suid Allows the use of programs set with the setuid flag, which lets users execute
    a program by using the permissions of the file’s user or group owner.
  prefs: []
  type: TYPE_NORMAL
- en: nosuid The opposite of the suid option; won’t allow the use of programs set
    with the setuid flag.
  prefs: []
  type: TYPE_NORMAL
- en: exec Allows the execution of binaries and other types of files.
  prefs: []
  type: TYPE_NORMAL
- en: ro Forbids writing into the filesystem; in other words, creates a read-only
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: rw Allows writing into the filesystem as well as reading.
  prefs: []
  type: TYPE_NORMAL
- en: nosymfollow Restricts the following of symbolic links created on the filesystem.
    This option would still allow creating symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: 'defaults Uses the following mount options: rw, suid, dev, exec, and a few others.'
  prefs: []
  type: TYPE_NORMAL
- en: If you return to the mount command output shown previously, you’ll see what
    mount options are set on each mount point, if defined.
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications usually generate some sort of runtime output, and this output is
    sometimes written into logfiles. The content of these logfiles will vary depending
    on the application but generally indicates whether everything is working correctly
    or if an error has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Certain logfiles are part of the Linux operating system, while others are related
    to third-party applications such as web servers and databases. Additionally, you
    might find custom application logs written by the company against which you’re
    performing a penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux systems, both system and application logfiles are usually written
    to the */var/log* directory. Custom applications can write their logs anywhere
    but generally write them to files under the */var* directory too. Here is an example
    find command that can search for logfiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This command finds files with the extensions *.log* and *.out*.
  prefs: []
  type: TYPE_NORMAL
- en: System Logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a list of common system logs on Linux systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/var/log/auth.log                     /var/log/faillog*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/var/log/secure                       /var/log/lastlog*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/var/log/audit/audit.log         /var/log/dpkg*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/var/log/dmesg                      /var/log/boot.log*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/var/log/messages                 /var/log/cron*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/var/log/syslog*'
  prefs: []
  type: TYPE_NORMAL
- en: Of particular interest are files such as */var/log/auth.log*, */var/log/secure*,
    and */var/log/lastlog*, which are related to authentication and can contain juicy
    information regarding clients connecting to servers. The */var/log/audit/audit.log*
    file is used by auditing systems such as Auditd to log events such as command
    line activity, authentication attempts, and general system calls.
  prefs: []
  type: TYPE_NORMAL
- en: Application Logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application logs can also contain interesting information for penetration testers.
    For example, if a server is running a website, the web engine may generate logs
    about clients connecting to it and the web paths they are requesting. This could
    reveal other clients and servers that are on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Web servers like Apache and nginx usually write their logs to directories such
    as */var/log/apache2/*, */var/log/httpd/*, or */var/log/nginx/*. Other types of
    applications, such as proxies, email servers, printer servers, file transfer servers,
    relational databases, message queues, and cache databases, also produce logs you’ll
    want to look out for. [Table 8-3](chapter8.xhtml#tab8-3) lists the locations of
    common application logs you may run into.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-3: Log Locations'
  prefs: []
  type: TYPE_NORMAL
- en: '| Log type | Logfiles |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Web servers | /var/log/apache2/access.log /var/log/httpd/access.log'
  prefs: []
  type: TYPE_NORMAL
- en: /var/log/nginx/access.log
  prefs: []
  type: TYPE_NORMAL
- en: /var/log/lighttpd/access.log |
  prefs: []
  type: TYPE_NORMAL
- en: '| Databases | /var/log/mysql/mysql.log /var/log/postgresql'
  prefs: []
  type: TYPE_NORMAL
- en: /var/log/redis
  prefs: []
  type: TYPE_NORMAL
- en: /var/log/mongodb/mongod.log
  prefs: []
  type: TYPE_NORMAL
- en: /var/log/elasticsearch/elasticsearch.log |
  prefs: []
  type: TYPE_NORMAL
- en: '| Printer servers | /var/log/cups |'
  prefs: []
  type: TYPE_TB
- en: '| File transfer servers | /var/log/vsftpd /var/log/proftpd |'
  prefs: []
  type: TYPE_TB
- en: '| Monitoring systems | /var/log/icinga2 /var/log/zabbix'
  prefs: []
  type: TYPE_NORMAL
- en: /var/log/logstash
  prefs: []
  type: TYPE_NORMAL
- en: /var/log/nagios/nagios.log
  prefs: []
  type: TYPE_NORMAL
- en: /var/log/cacti |
  prefs: []
  type: TYPE_NORMAL
- en: Note that some logs will require elevated privileges because of their sensitivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13: Recursively Searching for Readable Logfiles'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you’ll write a script that looks for logfiles. It should
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Take a path as command line input. By default, it should use */var/log*
    if no argument is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Recursively walk through the path to find readable files.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Copy these files into a centralized directory of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Compress the folder by using the tar command.
  prefs: []
  type: TYPE_NORMAL
- en: To aid your script writing, we recommend looking into the find command, which
    has many powerful built-in features that allow you to search by user and group
    ownership.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a full solution, *recursive_file_search.sh*, in the book’s GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Kernels and Bootloaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main component of operating systems such as Linux is called the *kernel*.
    The kernel is responsible for core functionalities such as process and memory
    management, drivers, security, and more. It is a highly complex piece of software
    and, as such, is prone to vulnerabilities. One example of a kernel exploit is
    the *Dirty COW vulnerability* (CVE-2016-5195), which allowed remote execution
    and the ability to obtain root access without leaving system traces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discovering the version of the kernel running on a system may allow you to
    escalate privileges with kernel exploits. To check the kernel version, use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As the lab machines are based on Docker, they share the host’s (Kali’s) kernel,
    and running uname will print Kali’s kernel version.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Linux system could have more than one kernel version installed to allow for
    rollbacks in cases of system failure. Kernel files are located under the */boot*
    directory. You can also find out which kernels are installed by running either
    of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to use the correct package manager command for the host system.
  prefs: []
  type: TYPE_NORMAL
- en: Unstable kernel exploits are dangerous to run and can crash and take down a
    server if they aren’t tested properly. We recommend obtaining explicit authorization
    before attempting to run these types of exploits.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already highlighted a few types of configuration files in this chapter.
    Though these files are highly application dependent, they can often include sensitive
    data. During local reconnaissance, you’ll want to go after them, especially those
    that are related to web applications, which generally rely on many services as
    part of their normal operations. The web applications need to connect to these
    services, usually with some form of authentication, so you’ll probably find credentials
    nearby.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration files primarily live under the */etc* directory and may or may
    not have an associated file extension, such as **.conf*, **.cfg*, **.ini **, *.cnf*,
    and **.cf*. You might also find configuration files under users’ hidden directories,
    such as */home/user/.config/* or */home/user/.local*. To perform a wide search
    for configuration files, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To search a specific folder, change the find / portion of the command to another
    directory, such as find /etc. You can even chain multiple directories together,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Third-party software also tends to include custom configuration that can be
    interesting. For example, WordPress usually uses a database for storing blog-related
    data, and its config file, *wp-config.php*, usually contains credentials related
    to databases such as MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The location of this file depends on where WordPress was installed because
    it usually resides within the application’s root directory, such as */var/www/html/wp-config.php*.
    As you can see, it has a.*php* extension, because WordPress is written in the
    PHP language. The search we used earlier wouldn’t have caught this file, but we
    can tweak our command to search for files with the word *config* in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We already know that the *p-web-02* server (172.16.10.12) runs WordPress; can
    you find its configuration file? Hint: it lives alongside the application in the
    web root directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Being aware of common configuration files and their locations helps when you
    identify services of interest that are running on the host. [Table 8-4](chapter8.xhtml#tab8-4)
    lists some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-4: Common Configuration File Locations'
  prefs: []
  type: TYPE_NORMAL
- en: '| Server type | File location |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Web servers | /etc/httpd/httpd.conf /etc/httpd/conf/httpd.conf'
  prefs: []
  type: TYPE_NORMAL
- en: /etc/apache2/apach2.conf
  prefs: []
  type: TYPE_NORMAL
- en: /etc/lighttpd/lighttpd.conf
  prefs: []
  type: TYPE_NORMAL
- en: /etc/nginx/nginx.conf |
  prefs: []
  type: TYPE_NORMAL
- en: '| File-sharing and file-transfer servers | /etc/vsftpd/vsftpd.conf /etc/protftpd.conf
    /usr/local'
  prefs: []
  type: TYPE_NORMAL
- en: /etc/proftpd.conf
  prefs: []
  type: TYPE_NORMAL
- en: /etc/samba/smb.conf |
  prefs: []
  type: TYPE_NORMAL
- en: '| Databases | /etc/mysql/my.cnf /etc/my.cnf'
  prefs: []
  type: TYPE_NORMAL
- en: /etc/redis/redis.conf
  prefs: []
  type: TYPE_NORMAL
- en: /etc/mongo.conf
  prefs: []
  type: TYPE_NORMAL
- en: /etc/cassandra |
  prefs: []
  type: TYPE_NORMAL
- en: '| Domain name servers | /etc/bind/named.conf /etc/dnsmasq.conf |'
  prefs: []
  type: TYPE_TB
- en: '| Mail servers | /etc/postfix/main.cf /etc/mail/sendmail.cf'
  prefs: []
  type: TYPE_NORMAL
- en: /etc/dovecot/dovecot.conf |
  prefs: []
  type: TYPE_NORMAL
- en: '| Virtual private network servers | /etc/openvpn /etc/ipsec.conf |'
  prefs: []
  type: TYPE_TB
- en: This table isn’t comprehensive, but it should give you an idea of where popular
    network servers commonly store their configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduled Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Scheduled tasks* allow you to specify a command or script for the system to
    run automatically at a specified interval. They’re interesting from a penetration-testing
    standpoint because they can often be written in a way that allows for privilege
    escalation conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, a task could read and execute instructions from world-writable
    files, and if a malicious user is able to write malicious instructions into them,
    the system might execute them with elevated privileges. A user could then take
    malicious actions, such as creating a privileged user, changing the folder permissions
    of a protected folder like */root*, adding permissions to the existing user, starting
    custom malicious processes, and deleting or overwriting sensitive information
    in files.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux, we have two common mechanisms for scheduling tasks: Cron and At.'
  prefs: []
  type: TYPE_NORMAL
- en: Cron
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s write a small script that creates a file and appends the current date
    and time to it ([Listing 8-11](chapter8.xhtml#Lis8-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-11: A simple cron job'
  prefs: []
  type: TYPE_NORMAL
- en: Save this file and give it the name *cron_task.sh*. Make sure it is executable
    by using chmod u+x cron_task.sh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll use Cron to run this script every minute. Run the following to
    open a text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now append the following to the end of the */etc/crontab* file and save it.
    Make sure you change the path to the place where you saved your script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be asking yourself what those five asterisks (*) are all about. Cron
    has special syntax to describe its execution schedule. The format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, the following syntax describes an echo task that will run every
    day at 11:30 PM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The Cron process should execute the script. To make sure it worked, run ls
    in the */tmp* folder. You should see the file */tmp/my_scheduled_job* containing
    updates about the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the context of penetration testing, cron jobs can be insecure. For example,
    a task may copy sensitive files to paths that are world-readable, allowing untrusted
    local users to obtain access to them. Here is an example of a backup job that
    is very insecure if it runs with the context of the *root* user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Cron jobs like this will copy the sensitive directories */etc* and */var* to
    the */home* directory. Since the */home* directory is accessible to all local
    users, anyone with read access can copy this file or view it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-5](chapter8.xhtml#tab8-5) lists additional files that Cron uses for
    its runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-5: Cron Files'
  prefs: []
  type: TYPE_NORMAL
- en: '| Purpose | Files |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Cron logs | /var/spool/cron /var/spool/cron/crontab |'
  prefs: []
  type: TYPE_TB
- en: '| Job configuration | /etc/crontab /etc/cron.d'
  prefs: []
  type: TYPE_NORMAL
- en: /etc/cron.hourly
  prefs: []
  type: TYPE_NORMAL
- en: /etc/cron.daily
  prefs: []
  type: TYPE_NORMAL
- en: /etc/cron.weekly
  prefs: []
  type: TYPE_NORMAL
- en: /etc/cron.monthly |
  prefs: []
  type: TYPE_NORMAL
- en: '| Cron security | /etc/cron.deny /etc/cron.allow |'
  prefs: []
  type: TYPE_TB
- en: A user’s cron jobs are usually stored in */var/spool/cron/crontab/USER*, and
    system-wide cron jobs are defined at */etc/crontab*. Directories such as */etc/cron.hourly*,
    */etc/cron.daily*, */etc/cron.weekly*, and */etc/cron.monthly* contain shell scripts
    executed by the Cron process, and the */etc/crontab* file defines the intervals
    at which scripts in these directories are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'System administrators can restrict users from creating cron jobs. Two access
    control files define who can run the crontab command: */etc/cron.allow* and */etc/cron.deny*.
    If the */etc/cron.allow* file exists, users listed in this file will be able to
    schedule tasks with Cron. If it doesn’t exist, all users can schedule tasks except
    for any user listed in */etc/cron.deny*. If neither file exists, only privileged
    users can schedule tasks. If a user is listed in both the allow and deny files,
    the user will still be able to schedule tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: At
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*At* is another job-scheduling tool in Linux, though it’s less common than
    Cron and uses a simpler approach. It works by specifying the shell command in
    the at prompt or piping the command to at as standard input by using |. The following
    example uses the at prompt to schedule a task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by specifying the schedule, using now + 1 minute to tell At to run
    commands one minute from now. At also takes in schedule syntax in additional formats.
    Here are a few examples of schedule definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The first example schedules commands to run at 10 PM in military time. The second
    example runs at 11 PM three days from today. The third example runs commands tomorrow
    at the current time, and the fourth on Sunday at the current time. The final example
    runs on May 27, 2050.
  prefs: []
  type: TYPE_NORMAL
- en: After specifying the time, At will drop your shell into a dedicated command
    prompt (at>), where you can enter shell commands line by line. To save the job,
    use CTRL-D.
  prefs: []
  type: TYPE_NORMAL
- en: 'The at command also provides a way to see the queue of jobs (by using atq)
    and remove them (by using atrm). To list all queued At jobs, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Each job has an ID (1 and 2 in this case), the time at which they will execute,
    and the user who scheduled it. After a job is submitted, you can generally find
    the job definition located under */var/spool/cron/atjobs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: By default, unprivileged users cannot read this directory. Other possible At
    job directories include */var/spool/cron/atspool*, */var/spool/at*, and */var/spool/
    at/spool*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove queued jobs by using atrm followed by the job ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Like Cron, At uses deny (*/etc/at.deny*) and allow (*/etc/at.allow*) files to
    determine which users can schedule jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14: Writing a Cron Job Script to Find Credentials'
  prefs: []
  type: TYPE_NORMAL
- en: 'The objective of this exercise is to write a monitoring cron job script. This
    script should periodically search the system for files containing credentials.
    Create a cron job to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Run every 10 minutes, every day of the week, all year.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Look for files containing the words *username* or *password* under the */tmp*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  When such a file is found, run grep on the line containing the strings to
    write only the strings to a writable location of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: To test your script, you can create a fake file containing the string username=administrator
    or password=12345 and save it into the */tmp* directory. If your cron job is working
    as expected, you should be able to see these two strings in the destination directory.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can collect hardware-related information, such as memory allocation details,
    the number of CPUs and cores, and the manufacturer of hardware components such
    as the motherboard, network card, and other peripherals. To collect these details,
    you use commands such as lshw, dmidecode, and hwinfo.
  prefs: []
  type: TYPE_NORMAL
- en: These commands may show only partial information when run using a nonprivileged
    user, because they often read from system files accessible only to the *root*
    user. They also may not necessarily be installed by default, so you might have
    to manually gather hardware information by looking at specific files and directories
    under */proc*, */dev*, and */sys*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output we get by running lshw on one of the lab machines,
    such as *p-web-01* (172.16.10.10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Remember that our lab is virtual, so the output may not accurately report the
    underlying physical hardware, such as the size of the memory, motherboard vendor,
    and sound card.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lshw command takes a -class (-C) argument, which allows you to view specific
    classes of hardware, such as disk (-C disk), processor (-C cpu), and network (-C
    network):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this disk example, you can see that the vendor name is VirtualBox, which
    hints that we ran this command in a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware utilities gather information from various files. [Table 8-6](chapter8.xhtml#tab8-6)
    compiles some of the files and directories from which these tools aggregate hardware
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-6: Hardware Information Locations in the Filesystem'
  prefs: []
  type: TYPE_NORMAL
- en: '| Virtual filesystem | Files and directories |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| /proc | /proc/bus/usb/devices /proc/dma'
  prefs: []
  type: TYPE_NORMAL
- en: /proc/interrupts
  prefs: []
  type: TYPE_NORMAL
- en: /proc/partitions
  prefs: []
  type: TYPE_NORMAL
- en: /proc/modules
  prefs: []
  type: TYPE_NORMAL
- en: /proc/cpuinfo
  prefs: []
  type: TYPE_NORMAL
- en: /proc/devices-tree
  prefs: []
  type: TYPE_NORMAL
- en: /proc/devices
  prefs: []
  type: TYPE_NORMAL
- en: /proc/efi/systab
  prefs: []
  type: TYPE_NORMAL
- en: /proc/ide
  prefs: []
  type: TYPE_NORMAL
- en: /proc/kcore
  prefs: []
  type: TYPE_NORMAL
- en: /proc/mounts
  prefs: []
  type: TYPE_NORMAL
- en: /proc/net/dev
  prefs: []
  type: TYPE_NORMAL
- en: /proc/scsi
  prefs: []
  type: TYPE_NORMAL
- en: /proc/sys
  prefs: []
  type: TYPE_NORMAL
- en: /proc/sys/abi
  prefs: []
  type: TYPE_NORMAL
- en: /proc/sys/dev/sensors |
  prefs: []
  type: TYPE_NORMAL
- en: '| /sys | /sys/bus /sys/class'
  prefs: []
  type: TYPE_NORMAL
- en: /sys/devices
  prefs: []
  type: TYPE_NORMAL
- en: /sys/firmware
  prefs: []
  type: TYPE_NORMAL
- en: /sys/firmware/dmi/tables/DMI |
  prefs: []
  type: TYPE_NORMAL
- en: '| /dev | /dev/cdrom /dev/input'
  prefs: []
  type: TYPE_NORMAL
- en: /dev/fb*
  prefs: []
  type: TYPE_NORMAL
- en: /dev/machines
  prefs: []
  type: TYPE_NORMAL
- en: /dev/snd
  prefs: []
  type: TYPE_NORMAL
- en: /dev/mem
  prefs: []
  type: TYPE_NORMAL
- en: /dev/scsi* |
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Administrators could install an operating system directly on a physical server
    or run a hypervisor (such as VirtualBox, Microsoft Hyper-V, or VMware ESXi) to
    host multiple virtual machines on the same hardware. Alternatively, they might
    use containerization technology to run virtual servers as containers.
  prefs: []
  type: TYPE_NORMAL
- en: Determining whether an environment is virtual or physical is often important
    in the context of defense evasion. For example, malicious software often implements
    checks for virtual environments so they can evade reverse engineering attempts,
    since analysts often examine malware in such virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: As in previous scenarios, we can use dedicated tools as well as living-off-the-land
    approaches to find this information. We’ll explore both options.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dedicated Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tools such as virt-who and virt-what can examine a system to determine whether
    it is physical or virtual. Here is the output of virt-what when run on Kali in
    VirtualBox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful tool, systemd-detect-virt, offers a comprehensive list of enumeration
    techniques to identify virtual environments for systemd-based systems. It can
    fingerprint numerous hypervisors and container runtime environments, a list of
    which you can find here: *[https://www.freedesktop.org/software/systemd/man/systemd-detect-virt.html](https://www.freedesktop.org/software/systemd/man/systemd-detect-virt.html)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running systemd-detect-virt on any of the lab machines to see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the dmesg command, you can also read virtualization information from
    the kernel ring buffer log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this example, oracle is the virtualization software, as we’re running VirtualBox,
    which is developed and maintained by Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Living Off the Land
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s highlight a few of the ways we can determine whether a system is running
    virtually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Desktop Management Interface (DMI) is a management and tracking framework
    for hardware and software in a system. Under the */sys/class/dmi/id* directory,
    a few files related to DMI could give away information about the various virtualization
    vendors. These files include *product_name*, *sys_vendor*, *board_vendor*, *bios_vendor*,
    and *product_version*. Take a look at their contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The file */sys/hypervisor/type* might also hint at the underlying hypervisor.
    For example, The Xen hypervisor might insert the value xen in that file, whereas
    Microsoft Hyper-V would use Hyper-V.
  prefs: []
  type: TYPE_NORMAL
- en: Another file, accessible only to the *root* user, */proc/1/environ*, may contain
    an environment variable named container= with relevant information. For example,
    Linux containers may use container=lxc, while Podman containers may use container=podman.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some container technologies, including Podman and Docker, use *env* files placed
    in specific locations. The existence of either of these would indicate a container
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/run/.containerenv*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/.dockerenv*'
  prefs: []
  type: TYPE_NORMAL
- en: 'On systemd systems, the */run/systemd/container* file may exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Try running this command in any of the lab machines you have access to.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Information Gathering with LinEnum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you should realize that valuable information can live anywhere on the
    operating system. To efficiently cover certain base areas, including users and
    groups, cron jobs, processes, and so on, we can run information-gathering scripts,
    which rely on the predictability of file locations and common search patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '*LinEnum* is a local information-gathering shell script used to automatically
    gather data from a host. It covers collection areas such as system information,
    user information, services and processes, versions, and privileges.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use LinEnum to collect files locally in an automated fashion. First, we
    need to get LinEnum onto the compromised machine. As it’s a single shell script
    file, we can simply copy and paste it into a new file on the machine. Copy the
    content of */home/kali/tools/LinEnum.sh* and save the file as *LinEnum.sh* on
    the compromised machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run LinEnum with -t (thorough collection) and -r (report) to specify a
    file to send the output to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Read through the findings to see the kind of information that was collected.
    In the following exercise, you’ll read LinEnum’s code, build new functionality,
    and tailor it to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15: Adding Custom Functionality to LinEnum'
  prefs: []
  type: TYPE_NORMAL
- en: During penetration testing, you may find yourself repurposing proof-of-concept
    exploit code and scripts to suit a particular use case. This is an important skill
    to master because if you can avoid writing scripts from scratch, you can save
    a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, your goal is to modify the LinEnum source code to build new
    features into it:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Carefully read the LinEnum script’s source code. While it contains roughly
    1,300 lines, it should be pretty simple to understand because it follows a consistent
    pattern, such as executing commands and then saving the output to variables.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Modify the source code to collect the content of files that you are interested
    in and that it doesn’t already collect. Alternatively, implement your own idea
    for a new feature.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Add another command line option to LinEnum to compress (-c) the report into
    a *tar.gz* file by using the tar command.
  prefs: []
  type: TYPE_NORMAL
- en: Reading foreign code is just as important as writing code. Everyone has their
    own style of writing and way of implementing logic, and you can learn a lot about
    the internal plumbing of tools as well as ways to tailor them to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we highlighted the major categories of data collection you
    can conduct on a compromised host, such as the operating system and kernel, adjacent
    networks and connections, running processes and user activity sessions, environment
    data, user and group identities, system and third-party logfiles, and configuration
    files. In addition, we used Cron and At to schedule the execution of shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: As you progress through the book, you’ll continue collecting data to aid with
    privilege escalation, credential access, and other nefarious hacking activities.
  prefs: []
  type: TYPE_NORMAL
