["```\nchar c = '√ø';  // extended character\nif (c == EOF) puts(\"end of file\");\n```", "```\nchar c = '√ø';\nif (isdigit((unsigned char)c)) {\n  puts(\"c is a digit\");\n}\n```", "```\n-fexec-charset=`charset`\n```", "```\n-fwide-exec-charset=`charset`\n```", "```\n-finput-charset=`charset`\n```", "```\nint SomeFuncA(LPSTR SomeString);\nint SomeFuncW(LPWSTR SomeString);\n```", "```\nSomeFuncW(L\"String\");\nSomeFuncA(\"String\");\n```", "```\n#include <locale.h>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">#include <uchar.h></samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">#include <stdio.h></samp>\n#include <wchar.h>\n\nstatic_assert(__STDC_UTF_16__ == 1, \"UTF-16 is not supported\"); ‚ù∂\n\nsize_t utf8_to_utf16(size_t utf8_size, const char utf8[utf8_size], char16_t *utf16) {\n  size_t code, utf8_idx = 0, utf16_idx = 0;\n  mbstate_t state = {0};\n  while ((code = ‚ù∑ mbrtoc16(&utf16[utf16_idx],\n    &utf8[utf8_idx], utf8_size - utf8_idx, &state))) {\n    switch(code) {\n    case (size_t)-1: // invalid code unit sequence detected\n    case (size_t)-2: // code unit sequence missing elements\n      return 0;\n    case (size_t)-3: // high surrogate from a surrogate pair\n      utf16_idx++;\n      break;\n    default:         // one value written\n      utf16_idx++;\n      utf8_idx += code;\n    }\n  }\n  return utf16_idx + 1;\n}\n\nint main() {\n  setlocale(LC_ALL, \"es_MX.utf8\"); ‚ù∏\n  char utf8[] = u8\"I <samp class=\"SANS_DejaVu_Sans_Book_11\">‚ô•</samp> üåÆ s!\";\n  char16_t utf16[sizeof(utf8)]; // UTF-16 requires less code units than UTF-8\n  size_t output_size = utf8_to_utf16(sizeof(utf8), utf8, utf16);\n  printf(\"%s\\nConverted to %zu UTF-16 code units: [\", utf8, output_size);\n  for (size_t x = 0; x < output_size; ++x) {\n    printf(\"%#x \", utf16[x]);\n  }\n  puts(\"]\");\n}\n```", "```\n#define S_INIT \"abc\"\n// `--snip--`\nconst char s[4] = S_INIT;\n```", "```\n#define S_INIT \"abc**d**\"\n// `--snip--`\nconst char s[4] = S_INIT;\n```", "```\nconst char s[] = S_INIT;\n```", "```\nsize_t size = sizeof(s);\n```", "```\nconst char *foo = S_INIT;\n```", "```\nsize_t length = strlen(foo) + 1U;\n```", "```\nchar str[100] = \"Here comes the sun\";\nsize_t str_size = sizeof(str); // str_size is 100\n```", "```\nchar str[100] = \"Here comes the sun\";\nsize_t str_len = strlen(str); // str_len is 18\n```", "```\nwchar_t str[100] = L\"Here comes the sun\";\nsize_t str_len = wcslen(str); // str_len is 18\n```", "```\n// narrow strings\nchar *str1 = \"Here comes the sun\";\nchar *str2 = malloc(strlen(str1) + 1);\n\n// wide strings\nwchar_t *wstr1 = L\"Here comes the sun\";\nwchar_t *wstr2 = malloc((wcslen(wstr1) + 1) * sizeof(*wstr1));\n```", "```\nsize_t strlen(const char * str) {\n  const char *s;\n  for (s = str; *s; ++s) {}\n  return s - str;\n}\n```", "```\nchar str[100] = \"Here comes the sun\";\nsize_t str_size = strlen(str) + 1;\nchar *dest = (char *)malloc(str_size);\nif (dest) {\n  strcpy(dest, str);\n}\nelse {\n  /* handle error */\n}\n```", "```\nchar *strcpy(char *dest, const char *src) {\n  char *save = dest;\n  while ((*dest++ = *src++));\n  return save;\n}\n```", "```\nvoid *memcpy(void * restrict dest, const void * restrict src, size_t size);\n```", "```\nstrcat(strcat(strcat(strcat(strcpy(name, first), \" \"), middle), \" \"), last);\n```", "```\n#define _XOPEN_SOURCE 700\n#include <string.h>\n```", "```\nvoid *memccpy(void * restrict s1, const void * restrict s2, int c, size_t n);\n```", "```\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n\nconstexpr size_t name_size = 18U;\n\nchar *vstrcat(char *buff, size_t buff_length, ...) {\n  char *ret = buff;\n  va_list list;\n  va_start(list, buff_length);\n  const char *part = nullptr;\n  size_t offset = 0;\n  while ((part = va_arg(list, const char *))) {\n  ‚ù∂ buff = (char *)memccpy(buff, part, '\\0', buff_length - offset);\n    if (buff == nullptr) {\n      ret[0] = '\\0';\n      break;\n    }\n  ‚ù∑ offset = --buff - ret;\n  }\n  va_end(list);\n  return ret;\n}\n\nint main() {\n  char name[name_size] = \"\";\n  char first[] = \"Robert\";\n  char middle[] = \"C.\";\n  char last[] = \"Seacord\";\n\n  puts(vstrcat(\n    name, sizeof(name), first, \" \",\n    middle, \" \", last, nullptr\n  ));\n}\n```", "```\nvoid *memset(void *s, int c, size_t n);\n```", "```\nvoid check_password() {\n  char pwd[64];\n  if (get_password(pwd, sizeof(pwd))) {\n    /* check password */\n  }\n  memset(pwd, 0, sizeof(pwd));\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctypes.h>\n\nvoid get_y_or_n(void) {\n  char response[8];\n  puts(\"Continue? [y] n: \");\n  gets(response);\n  if (tolower(response[0]) == 'n') exit(EXIT_SUCCESS);\n  return;\n}\n```", "```\nchar *gets(char *dest) {\n  int c;\n  char *p = dest;\n  while ((c = getchar()) != EOF && c != '\\n') {\n    *p++ = c;\n  }\n  *p = '\\0';\n  return dest;\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\nvoid get_y_or_n(void) {\n  char response[8];\n  puts(\"Continue? [y] n: \");\n  int c;\n  char *p = response;\n‚ù∂ while ((c = getchar()) != EOF && c != '\\n') {\n    *p++ = c;\n  }\n  *p = '\\0';\n  if (response[0] == 'n')\n    exit(0);\n}\n```", "```\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nvoid get_y_or_n(void) {\n  char response[8];\n  puts(\"Continue? [y] n: \");\n  gets_s(response, sizeof(response));\n  if (tolower(response[0]) == 'n') {\n    exit(EXIT_SUCCESS);\n  }\n}\n```", "```\nerrno_t strcpy_s(\n  char * restrict s1, rsize_t s1max, const char * restrict s2\n);\n```", "```\nint main(void) {\n  constraint_handler_t oconstraint =\n    set_constraint_handler_s(ignore_handler_s);\n  get_y_or_n();\n}\n```", "```\nconst char *temp = getenv(\"TMP\");\nif (temp != nullptr) {\n  char *tmpvar = strdup(temp);\n  if (tmpvar != nullptr) {\n    printf(\"TMP = %s.\\n\", tmpvar);\n    free(tmpvar);\n  }\n}\n```", "```\n_invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler)\n```"]