<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_25"/><strong>3 MD380 Null Pointer, DFU</strong></h2>&#13;
<p class="noindent">While it’s brutally effective to exploit a chip vendor’s bootloader in ROM, many device vendors add a second bootloader in flash memory. This is the story, first told in Goodspeed (2016b), of how I dumped a two-way radio’s firmware through a null pointer read vulnerability. It is also the story of how the firmware update cryptography was broken, from Rütten and Goodspeed (2016).</p>&#13;
<p class="indent">The Tytera MD380 is a handheld radio transceiver that uses either analog FM or Digital Mobile Radio (DMR). DMR provides some of the features of GSM, such as text messaging and timesharing of the repeater tower, without the hassles of SIM cards. Many people purchased the MD380 for use in amateur radio; it was just too tempting to rip out its firmware and patch in new features for the ham radio community.</p>&#13;
<p class="indent">The CPU of this radio is an STM32F405 in the LQFP100 package, with a megabyte of flash and 192kB of RAM.<sup><a id="ch3fn_1" href="footnotes.xhtml#ch3fn1">1</a></sup> The STM32 has both JTAG and a ROM bootloader, but these are protected by the readout device protection (RDP) feature in its most secured setting, where JTAG connections are entirely disallowed.</p>&#13;
<h3 class="h3" id="ch00lev1sec8"><strong>Reading a Null Pointer</strong></h3>&#13;
<p class="noindent">Instead of jumping in with the STM32 vulnerability presented in <a href="ch02.xhtml#ch02">Chapter 2</a>, I began by writing some of my own USB drivers for the radio. As we’ll soon see, this was not a waste of time.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_26"/><img id="ch3fig1" src="../images/f0026-01.jpg" alt="Image" width="681" height="1107"/></div>&#13;
<p class="figcap">Figure 3.1: Tytera MD380 Radio</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_27"/><img id="ch3fig2" src="../images/f0027-01.jpg" alt="Image" width="777" height="744"/></div>&#13;
<p class="figcap">Figure 3.2: STM32F405</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_28"/>The MD380 has <em>three</em> separate implementations of the USB device firmware update (DFU) protocol: one in ROM, a second at the beginning of flash that is used for firmware updates and recovery, and a third in the main radio application. The second and third speak largely the same protocol, and we can exploit either of them in roughly the same way.</p>&#13;
<p class="indent">I reverse engineered the protocol by running the vendor’s Windows application under VMWare, then patching the <span class="literal">.vmx</span> file with the lines in <a href="ch03.xhtml#ch3fig4">Figure 3.4</a> to write USB traffic to a log file. These days, I’d probably use <span class="literal">usbmon</span> on a Linux host while running Windows in a Qemu VM.</p>&#13;
<p class="indent">The logs showed that the MD380’s variant of DFU included non-standard commands. In particular, the LCD screen would say “PC Program USB Mode” for the official client applications, but not for any third-party application. Before I could do a proper read, I had to find the commands that would enter this programming mode.</p>&#13;
<p class="indent">DFU implementations often hide extra commands in the <span class="literal">UPLOAD</span> and <span class="literal">DNLOAD</span> commands, when the block address is less than two. To erase a block, a DFU host downloads <span class="literal">0x41</span> followed by a little endian address to block zero. To mass erase all of memory, the host sends just <span class="literal">0x41</span> with no extra bytes to block zero. To set the address pointer, the host sends <span class="literal">0x21</span> followed by a little endian address. See <a href="ch02.xhtml#ch2fig4">Figure 2.4</a> for a list of the STM32’s standard extensions that are called in this manner.</p>&#13;
<p class="indent">In addition to those documented commands, the MD380 also uses a number of two-byte (rather than five-byte) <span class="literal">DNLOAD</span> transactions, none of which exist in the standard DFU protocol. I observed the commands in <a href="ch03.xhtml#ch3fig5">Figure 3.5</a>, many of which I still only partly understand.</p>&#13;
<p class="indent">It wasn’t hard to patch the open source DFU client from Michael Ossmann’s Ubertooth project to read and write the radio’s configuration. This configuration, called a “codeplug” by radio users, is held in SPI flash and does not include any firmware. Instead, it holds radio channel settings and frequencies.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_29"/><img id="ch3fig3" src="../images/f0029-01.jpg" alt="Image" width="578" height="610"/></div>&#13;
<p class="figcap">Figure 3.3: Simplified STM32F405 Memory Map</p>&#13;
<div class="image"><img id="ch3fig4" src="../images/f0029-02.jpg" alt="Image" width="812" height="135"/></div>&#13;
<p class="figcap">Figure 3.4: USB Sniffing with VMWare</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_30"/><img id="ch3fig5" src="../images/f0029-02a.jpg" alt="Image" width="557" height="315"/></div>&#13;
<p class="figcap">Figure 3.5: DNLOAD Extensions for the MD380</p>&#13;
<div class="image"><img id="ch3fig6" src="../images/f0030-01.jpg" alt="Image" width="819" height="525"/></div>&#13;
<p class="figcap">Figure 3.6: Dumping Flash Memory</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_31"/><img id="ch3fig7" src="../images/f0031-01.jpg" alt="Image" width="591" height="271"/></div>&#13;
<p class="figcap">Figure 3.7: Interrupt Table from the MD380</p>&#13;
<p class="indent">If none of the extended commands from <a href="ch03.xhtml#ch3fig5">Figure 3.5</a> are sent before a read, a very interesting pattern would be read out, shown in <a href="ch03.xhtml#ch3fig7">Figure 3.7</a>. You can think of this as simply not selecting a memory source.</p>&#13;
<p class="indent">Interpreted as little-endian, this begins with the words <span class="literal">0x2000-1a30</span>, <span class="literal">0x08005615</span>, <span class="literal">0x08005429</span>, and a bunch of other odd pointers to addresses in the STM32’s flash memory. This is the interrupt table at the beginning of flash memory, and I was seeing the first kilobyte of the flash bootloader at <span class="literal">0x08000000</span>!</p>&#13;
<p class="indent">What was happening internally? Well, each DFU transaction would attempt to read a block from memory, but because the custom commands hadn’t been sent to choose a source, the non-existent buffer was never populated. And what does a nonexistent buffer at an uninitialized location happen to contain on an STM32F4? Well, <span class="literal">0x00000000</span> helpfully mirrors whichever memory the chip was booted from, so reading a kilobyte from <span epub:type="pagebreak" id="page_32"/>there instead gives a kilobyte from <span class="literal">0x08000000</span>, and that’s why we get the first kilobyte of the bootloader.</p>&#13;
<p class="indent">Reading past the first block, we find that every block has the same kilobyte. This is because DFU is addressed in terms of block numbers, but the buffer remains uninitialized, so that all block addresses get rerouted to the very beginning of flash. Though it’s useless to change the block index, we can grab more than a kilobyte by increasing the block size with the <span class="literal">--transfer-size</span> option of <span class="literal">dfu-util</span>. The maximum transfer size varies by operating system and USB controller, but my iMac was able to pull out <span class="literal">0xC000</span> bytes, the full length of the recovery bootloader!</p>&#13;
<h3 class="h3" id="ch00lev1sec9"><strong>Patching Out Protections</strong></h3>&#13;
<p class="noindent">So now we have the recovery bootloader, but we don’t have the application that follows it in memory at <span class="literal">0x0800C000</span>. We’ll get that code by patching the recovery bootloader to disable the readout protection, and then use the STM32’s ROM bootloader to dump all memory over USB.</p>&#13;
<p class="indent">To load the image into a reverse engineering tool, such as IDA Pro or Ghidra, simply set an instruction set of ARM/Cortex and a base address of <span class="literal">0x08000000</span>. It sometimes helps the decompiler to mark the image as having no write permissions, so that it knows that the code will not be self-modifying. It’s also important to mark the I/O region at <span class="literal">0x40000000</span> as volatile, to prevent the decompiler from optimizing away the majority of your interrupt handler code.</p>&#13;
<p class="indent">Searching for the IO address <span class="literal">OPTCR_BYTE1_ADDRESS</span> (<span class="literal">0x4002-3C15</span>), we quickly find that <span class="literal">FLASH_OB_RDPConfig()</span> from the STM32 examples is included at <span class="literal">0x08001fb0</span>. It is called from <span class="literal">main()</span> with a parameter of <span class="literal">0x55</span> in the instruction at <span class="literal">0x0800-44A8</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_33"/><img id="ch3fig8" src="../images/f0033-01.jpg" alt="Image" width="821" height="739"/></div>&#13;
<p class="figcap">Figure 3.8: This function sets the RDP protection level.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_34"/><img id="ch3fig9" src="../images/f0034-01.jpg" alt="Image" width="778" height="712"/></div>&#13;
<p class="figcap">Figure 3.9: Tapping the BOOT0 Pin</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_35"/>We can then patch a single byte so that instead of writing <span class="literal">0x55</span> for RDP Level 1 with Read Protection, the bootloader will write <span class="literal">0xAA</span> for RDP Level 0 with No Protection.</p>&#13;
<div class="imagel"><img src="../images/f0035-01.jpg" alt="Image" width="812" height="183"/></div>&#13;
<p class="indent">So now we have a bootloader that will not lock the chip, but it is still necessary to install it. We do this by holding the CPU’s <span class="literal">BOOT0</span> pin high during a reboot, with the hardware modified as shown in <a href="ch03.xhtml#ch3fig9">Figure 3.9</a>, to start the ROM bootloader. At this point we are still in RDP Level 1 (Read Protection), but we can drop to Level 0 by sending the Mass Erase command, wiping everything in flash memory and leaving the radio without firmware.</p>&#13;
<p class="indent">We then write our patched bootloader into flash memory, and reboot the radio while holding the top and bottom buttons on the right side of the radio to start it. The LED will begin blinking red and green. At this stage, the device is ready to accept an update, but as yet has no application image, so we use the vendor’s Windows application to install an encrypted firmware update. This gives us a working radio!</p>&#13;
<p class="indent">We reboot again into the ROM bootloader from <a href="ch02.xhtml#ch02">Chapter 2</a> by holding the <span class="literal">BOOT0</span> pin high on a reset. This time, we are in RDP Level 0 (No Protection), and we can freely dump all flash memory, where the radio firmware begins at <span class="literal">0x0800C000</span>. Because the device remains unlocked, we can also patch the application image and write that back into the radio.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_36"/><img id="ch3fig10" src="../images/f0036-01.jpg" alt="Image" width="822" height="717"/></div>&#13;
<p class="figcap">Figure 3.10: Decompiled Decryption Function</p>&#13;
<h3 class="h3" id="ch00lev1sec10"><span epub:type="pagebreak" id="page_37"/><strong>Cracking the Update Cryptography</strong></h3>&#13;
<p class="noindent">By this point, we have cleartext dumps of both the recovery bootloader and the application, as well as an encrypted firmware update of the application. All that’s left to do is to break the encryption, and that’s exactly the trick that my good friend Christiane Rütten contributed in Rütten and Goodspeed (2016).</p>&#13;
<p class="indent">Different forms of cryptography require different techniques, of course. If the vendor had been signing updates with public-key crypto, we might be out of luck. If a standard symmetric crypto algorithm such as AES were used, we might have luck searching for constant tables, then tracing references back until we found the code that decrypted the firmware.</p>&#13;
<p class="indent">Instead, Rütten noticed that there were repeating sequences within the encrypted firmware update, something that oughtn’t happen if the encryption were done right. She then took the encrypted firmware update and XORed it with the cleartext application that I had dumped from memory.</p>&#13;
<p class="indent">Lo and behold, XORing the cleartext with the update file produced a repeating pattern of 1,024 bytes! See <a href="ch03.xhtml#page_38">page 38</a> for Python code that uses these bytes to wrap a firmware blob into an encrypted update, compatible with the manufacturer’s own tools.</p>&#13;
<p class="indent">The firmware function that performs this XOR is shown in <a href="ch03.xhtml#ch3fig10">Figure 3.10</a>. Note that 1,024 bytes are XORed with bytes of <span class="literal">firmwarekey</span> regardless of the block size being written, but that the amount being copied is taken as a parameter.</p>&#13;
<p class="indent">These exploits made possible the MD380Tools project, an open source collection of patches against the MD380 firmware that added promiscuous mode, a phone book of all registered amateur DMR operators, and raw packet capture.<sup><a id="ch3fn_2" href="footnotes.xhtml#ch3fn2">2</a></sup> It also made possible Goodspeed (2016a), in which I re-linked the firmware into an ARM/Linux executable for freely encoding and decoding DMR’s AMBE+2 audio codec on a desktop or server.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_38"/><img src="../images/f0038-01.jpg" alt="Image" width="819" height="1003"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_39"/><img src="../images/f0039-01.jpg" alt="Image" width="819" height="725"/><span epub:type="pagebreak" id="page_40"/></div>&#13;
</div>
</div>
</body></html>