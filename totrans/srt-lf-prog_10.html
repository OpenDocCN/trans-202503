<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_259"/><strong><span class="big">10</span><br/>APPLICATION AND SYSTEM PROGRAMMING</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent"><a href="ch09.xhtml#ch09">Chapter 9</a> covered how web browsers work. You learned that browsers are complex application programs that provide software-implemented “computers” that support very high-level “instructions.” In this chapter, we’ll write a program that runs in a browser, followed by a similar program that doesn’t use the browser. The structure of the two programs is shown in <a href="ch10.xhtml#ch10fig01">Figure 10-1</a>.</p>
<p class="indent">The operating system hides much of the I/O device complexity from user programs. In a similar manner, a complex user program such as a browser hides much of the complexity of dealing with operating systems from application programs that are built on top of them. This is fine if you’re going to limit yourself to being a high-level application writer. But you need to know more if you’re going to be a system programmer.</p>
<span epub:type="pagebreak" id="page_260"/>
<div class="image"><a id="ch10fig01"/><img src="../images/10fig01.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-1: Two program scenarios</em></p>
<p class="indent">This chapter includes lengthier JavaScript and C code examples than you’ve seen before. Don’t worry if you’re not fluent in these languages—you don’t need to know all the details to follow along.</p>
<p class="indent">Let’s look at a game in which the computer asks the user a series of questions to try to guess an animal. New animals and questions that distinguish them are added to the program as needed. The program “learns” by constructing a binary tree of knowledge.</p>
<p class="indent">The interaction between the <em>computer</em> (the <code>literal</code> text) and the <em>user</em> (the <span class="codestrong">literal bold</span> text) looks something like this:</p>
<pre>Think of an animal.<br/>
Does it bark?<span class="codestrong1"/><br/>
<span class="codestrong1">Yes</span><br/>
Is it a dog?<br/>
<span class="codestrong1">Yes</span><br/>
I knew it!<br/>
Let's play again.<br/>
Think of an animal.<br/>
Does it bark?<br/>
<span class="codestrong1">Yes</span><br/>
Is it a dog?<br/>
<span class="codestrong1">No</span><br/>
I give up. What is it?<br/>
<span class="codestrong1">giant purple snorklewhacker</span><br/>
What's a question that I could use to tell a giant purple snorklewhacker from a dog?<br/>
<span class="codestrong1">Does it live in an anxiety closet?</span><br/>
Thanks. I'll remember that.<br/>
Let's play again.<br/>
Think of an animal.<br/>
Does it bark?<br/>
<span epub:type="pagebreak" id="page_261"/><span class="codestrong1">Yes</span><br/>
Is it a dog?<br/>
<span class="codestrong1">No</span><br/>
Does it live in an anxiety closet?<br/>
<span class="codestrong1">Yes</span><br/>
Is it a giant purple snorklewhacker?<br/>
<span class="codestrong1">Yes</span><br/>
I knew it!<br/>
Let's play again.</pre>
<p class="indent"><a href="ch10.xhtml#ch10fig02">Figure 10-2</a> shows the implementation plan.</p>
<div class="image"><a id="ch10fig02"/><img src="../images/10fig02.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-2: Guess the Animal flowchart</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_262"/>As you can see, we ask questions that guide our descent through the tree of knowledge. We congratulate ourselves when we guess correctly. Otherwise, we ask the user to supply the answer and a question, add them to the tree, and start over.</p>
<p class="indent">The program follows a path down the tree of knowledge on the left side. When it reaches the end of the path on the right, it either brags or adds to the knowledge base.</p>
<h3 class="h3" id="ch10lev1sec1"><strong>Guess the Animal Version 1: HTML and JavaScript</strong></h3>
<p class="noindent">On to the program. We’ll go about this in a way that, although convenient, will upset some of my colleagues. This is a <em>clever hack</em>—something that works but is a bit twisted and ugly. As you saw in the previous chapter, the DOM is a tree that is a subset of a DAG—same with a binary tree. We’re going to build the binary tree of knowledge in the DOM as a set of nested, invisible <code>&lt;div&gt;</code>s. We could create a data structure in JavaScript, but the browser already has something easy that works. As <a href="ch10.xhtml#ch10fig03">Figure 10-3</a> shows, our program starts off with an initial question and two answers in the knowledge tree.</p>
<div class="image"><a id="ch10fig03"/><img src="../images/10fig03.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-3: Initial knowledge tree</em></p>
<p class="indent">Let’s play the game. We answer <code>yes</code> in response to <code>Does it bark?</code> and when the program guesses <code>Is it a dog?</code> we answer <code>no</code>. The program then asks <code>What is it?</code> and we respond with <code>giant purple snorklewhacker</code>. The program then asks us what question would distinguish a giant purple snorklewhacker from a dog and uses our response of <code>Does it live in an anxiety closet?</code> to modify the knowledge tree, as shown in <a href="ch10.xhtml#ch10fig04">Figure 10-4</a>.</p>
<div class="image"><a id="ch10fig04"/><img src="../images/10fig04.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-4: Modified knowledge tree</em></p>
<h4 class="h4" id="ch10lev2sec1"><span epub:type="pagebreak" id="page_263"/><strong><em>Application-Level Skeleton</em></strong></h4>
<p class="noindent"><a href="ch10.xhtml#ch10list01">Listing 10-1</a> shows the web page skeleton into which we’ll add the code. Purists would be very upset at this because it combines HTML, CSS, and JavaScript into a single file. But we’re building a simple program, not a website, so it’s convenient to have everything in one place.</p>
<pre> 1 &lt;html&gt;<br/>
 2   &lt;head&gt;<br/>
 3     &lt;!-- include jQuery --&gt;<br/>
 4     &lt;script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"&gt; &lt;/script&gt;<br/>
 5<br/>
 6     &lt;title&gt;Web Page Skeleton&lt;/title&gt;<br/>
 7<br/>
 8     &lt;style&gt;<br/>
 9       &lt;!-- CSS goes here --&gt;<br/>
10     &lt;/style&gt;<br/>
11<br/>
12     &lt;script type="text/javascript"&gt;<br/>
13<br/>
14       &lt;!-- JavaScript goes here --&gt;<br/>
15<br/>
16       $(function() {<br/>
17         &lt;!-- JavaScript to run when document ready --&gt;<br/>
18       });<br/>
19<br/>
20     &lt;/script&gt;<br/>
21   &lt;/head&gt;<br/>
22<br/>
23   &lt;body&gt;<br/>
24     &lt;!-- HTML goes here --&gt;<br/>
25   &lt;/body&gt;<br/>
26 &lt;/html&gt;</pre>
<p class="listing" id="ch10list01"><em>Listing 10-1: Web page skeleton</em></p>
<p class="indent">You can change the <code>title</code> to something like <code>Guess the Animal</code> yourself.</p>
<p class="indent">You learned about web browser components in the last chapter (see <a href="ch09.xhtml#ch09fig09">Figure 9-9</a>). Now we’ll put some of them to use.</p>
<h4 class="h4" id="ch10lev2sec2"><strong><em>Web Page Body</em></strong></h4>
<p class="noindent">Let’s start by looking at the <code>&lt;body&gt;</code> of the program in <a href="ch10.xhtml#ch10list02">Listing 10-2</a>. This replaces the <code>&lt;!-- HTML goes here --&gt;</code> from line 24 of <a href="ch10.xhtml#ch10list01">Listing 10-1</a>.</p>
<pre> 1 &lt;!-- This is the knowledge tree that is never visible --&gt;<br/>
 2<br/>
 3 &lt;div id="root" class="invisible"&gt;<br/>
 4   &lt;div string="Does it bark"&gt;<br/>
 5     &lt;div string="dog"&gt;&lt;/div&gt;<br/>
 6     &lt;div string="cat"&gt;&lt;/div&gt;<br/>
 7  &lt;/div&gt;<br/>
 8 &lt;/div&gt;<br/>
 9<br/>
<span epub:type="pagebreak" id="page_264"/>10 &lt;div id="dialog"&gt;<br/>
11   &lt;!-- The conversation will go here --&gt;<br/>
12 &lt;/div&gt;<br/>
13<br/>
14 &lt;!-- Get new animal name dialog --&gt;<br/>
15<br/>
16 &lt;div id="what-is-it" class="start-hidden"&gt;<br/>
17   &lt;input id="what" type="text"/&gt;<br/>
18   &lt;button id="done-what"&gt;Done&lt;/button&gt;<br/>
19 &lt;/div&gt;<br/>
20<br/>
21 &lt;!-- Get new animal question dialog --&gt;<br/>
22<br/>
23 &lt;div id="new-question" class="start-hidden"&gt;<br/>
24   What's a good question that I could use to tell a<br/>
25   &lt;span id="new"&gt;&lt;/span&gt; from a &lt;span id="old"&gt;&lt;/span&gt;?<br/>
26   &lt;input id="question" type="text"/&gt;<br/>
27   &lt;button id="done-question"&gt;Done&lt;/button&gt;<br/>
28 &lt;/div&gt;<br/>
29<br/>
30 &lt;!-- Yes and no buttons --&gt;<br/>
31<br/>
32 &lt;div id="yesno" class="start-hidden"&gt;<br/>
33   &lt;button id="yes"&gt;Yes&lt;/button&gt;<br/>
34   &lt;button id="no"&gt;No&lt;/button&gt;<br/>
35 &lt;/div&gt;</pre>
<p class="listing" id="ch10list02"><em>Listing 10-2: Guess the Animal HTML</em></p>
<p class="indent">You can see in lines 3 through 8 that the knowledge tree is preloaded with an initial question and answers. The <code>string</code> attribute is the question, except for leaf nodes where it is the animal name. The question contains two <code>&lt;div&gt;</code>s, the first being for the <code>yes</code> answer and the second for the <code>no</code>. The tree is wrapped in a <code>&lt;div&gt;</code> styled so that it’s never visible.</p>
<p class="indent">The <code>dialog</code> in lines 10 through 12 holds the conversation between the computer and the player. Then <code>what-is-it</code> (lines 16–19) contains a text field for the name of a new animal and a button the player presses when done. After that, <code>new-question</code> (lines 23–28) contains a text field for the new question and a button the player presses when done. The yes and no buttons are in <code>yesno</code> (lines 32–35). The three user input <code>&lt;div&gt;</code>s (lines 16, 23, and 32) have a <code>start-hidden</code> class that is used to make these values invisible at the beginning of a game.</p>
<h4 class="h4" id="ch10lev2sec3"><strong><em>The JavaScript</em></strong></h4>
<p class="noindent">Let’s move on to the actual JavaScript. The first part is shown in <a href="ch10.xhtml#ch10list03">Listing 10-3</a>.</p>
<p class="indent">The first thing we do is declare the variable <code>node</code> where the skeleton says <code>&lt;!-- JavaScript goes here --&gt;</code> on line 14 of <a href="ch10.xhtml#ch10list01">Listing 10-1</a>. Although it could go inside the document ready function, putting it outside makes it easier to access using the browser developer console. We also declare two functions outside of the document ready function since they don’t rely on the page being loaded.</p>
<span epub:type="pagebreak" id="page_265"/>
<pre> 1 var node; // current position in tree of knowledge<br/>
 2<br/>
 3 // Append the supplied html to the dialog. Bail if the new node has<br/>
 4 // no children because there is no question to ask. Otherwise, make<br/>
 5 // the new node the current node and ask a question using the string<br/>
 6 // attribute of the node. Turn the animal name into a question if a<br/>
 7 // leaf node. Returns true if the new node is a leaf node.<br/>
 8<br/>
 9 function<br/>
10 question(new_node, html)<br/>
11 {<br/>
12    $('#dialog').append(html);     // add the html to the dialog<br/>
13<br/>
14    if ($(new_node).length == 0) { // no question if no children<br/>
15      return (true);<br/>
16    }<br/>
17    else {<br/>
18      node = new_node;             // descend to new node<br/>
19<br/>
20      if ($(node).children().length == 0)<br/>
21        $('#dialog').append('Is it a ' + $(node).attr('string') + '?');<br/>
22      else<br/>
23        $('#dialog').append($(node).attr('string') + '?');<br/>
24<br/>
25      return (false);<br/>
26    }<br/>
27 }<br/>
28<br/>
29 // Restarts the game. Hides all buttons and text fields, clears<br/>
30 // the text fields, sets the initial node and greeting, asks the<br/>
31 // first question, displays the yes/no buttons.<br/>
32<br/>
33 function<br/>
34 restart()<br/>
35 {<br/>
36    $('.start-hidden').hide();<br/>
37    $('#question,#what').val('');<br/>
38    question($('#root&gt;div'), '&lt;div&gt;&lt;b&gt;Think of an animal.&lt;/b&gt;&lt;/div&gt;');<br/>
39    $('#yesno').show();<br/>
40 }</pre>
<p class="listing" id="ch10list03"><em>Listing 10-3: Guess the Animal JavaScript variable and functions</em></p>
<p class="indent">Next, the <code>&lt;!-- JavaScript to run when document ready --&gt;</code> from line 17 of <a href="ch10.xhtml#ch10list01">Listing 10-1</a> gets the five things shown in <a href="ch10.xhtml#ch10list04">Listing 10-4</a>.</p>
<pre> 1 restart(); // Sets everything up the first time through.<br/>
 2<br/>
 3 // The user has entered a new question. Make a node with that<br/>
 4 // question and put the old no-node into it. Then, make a node<br/>
 5 // with the new animal and put it into the new question node ahead<br/>
 6 // of the old no-node so that it becomes the yes choice. Start over.<br/>
 7<br/>
<span epub:type="pagebreak" id="page_266"/> 8 $('#done-question').click(function() {<br/>
 9   $(node).wrap('&lt;div string="' + $('#question').val() + '"&gt;&lt;/div&gt;');<br/>
10   $(node).parent().prepend('&lt;div string="' + $(what).val() + '"&gt;&lt;/div&gt;');<br/>
11   $('#dialog').append("&lt;div&gt;Thanks! I'll remember that.&lt;/div&gt;&lt;p&gt;");<br/>
12   restart();<br/>
13 });<br/>
14<br/>
15 // The user has entered a new animal name and clicked done. Hide<br/>
16 // those items and make the new-question text field and done button<br/>
17 // visible. Plug the old and new animal names into the query.<br/>
18<br/>
19 $('#done-what').click(function() {<br/>
20    $('#what-is-it').hide();<br/>
21    $('#new').text($('#what').val());<br/>
22    $('#old').text($(node).attr('string'));<br/>
23    $('#new-question').show();<br/>
24    $('#dialog div:last').append(' &lt;i&gt;' + $('#what').val() + '&lt;/i&gt;');<br/>
25 });<br/>
26<br/>
27 // The user clicked yes in answer to a question. Descend the tree<br/>
28 // unless we hit bottom in which case we boast and start over.<br/>
29<br/>
30 $('#yes').click(function() {<br/>
31    if (question($(node).children(':first-child'), ' &lt;i&gt;yes&lt;/i&gt;&lt;br&gt;')) {<br/>
32      $('#dialog').append("&lt;div&gt;I knew it! I'm so smart!&lt;/div&gt;&lt;p&gt;");<br/>
33      restart();<br/>
34    }<br/>
35 });<br/>
36<br/>
37 // The user clicked no in answer to a question. Descend the tree<br/>
38 // unless we hit bottom, in which case we hide the yes/no buttons<br/>
39 // and make the what-is-it text field and done button visible.<br/>
40<br/>
41 $('#no').click(function() {<br/>
42    if (question($(node).children(':last-child'), ' &lt;i&gt;no&lt;/i&gt;&lt;br&gt;')) {<br/>
43      $('#yesno').hide();<br/>
44      $('#dialog').append('&lt;div&gt;I give up. What is it?&lt;/div&gt;');<br/>
45      $('#what-is-it').show();<br/>
46    }<br/>
47 });</pre>
<p class="listing" id="ch10list04"><em>Listing 10-4: Guess the Animal document ready function JavaScript</em></p>
<p class="indent">We invoke the <code>restart</code> function (line 1) to start the game. The other four things are <em>event handlers</em>, the JavaScript equivalent of the interrupt handlers introduced in <a href="ch05.xhtml#ch05">Chapter 5</a>. There is one event handler for each of the four <code>button</code> elements. Each handler calls an anonymous function (an inline function that doesn’t have a name) when the associated button is pressed.</p>
<p class="indent">Practice your text-editing skills by typing in the program. Save the results in a file named something like <em>gta.html</em> and then open the file in your browser. Play the game. Open up the developer tools in your browser and find the HTML inspector; this allows you to look at the HTML that makes up the web page. Watch the tree of knowledge get built as you play.</p>
<h4 class="h4" id="ch10lev2sec4"><span epub:type="pagebreak" id="page_267"/><strong><em>The CSS</em></strong></h4>
<p class="noindent">As we touched on in <a href="ch09.xhtml#ch09">Chapter 9</a>, classes give us a way to label elements so that they can be easily selected. CSS is primarily used for static declarations of properties; it becomes dynamic mostly via programmatic manipulation. The HTML in <a href="ch10.xhtml#ch10list02">Listing 10-2</a> has two CSS classes: <code>start-hidden</code> is dynamic, and <code>invisible</code> is static.</p>
<p class="indent">The <code>class</code> attribute is used to make several of the HTML elements in <a href="ch10.xhtml#ch10list05">Listing 10-5</a> members of the <code>start-hidden</code> class. This isn’t just to make our program classy; it’s to give us a way to locate all of these elements with a simple selector. These elements are made invisible whenever the program is started or restarted. They’re made visible as the program runs, and <code>start-hidden</code> allows us to reset everything simply.</p>
<p class="indent">The element with the <code>invisible</code> class is always invisible, as it’s the tree of knowledge. Thus, the CSS shown in <a href="ch10.xhtml#ch10list05">Listing 10-5</a> replaces the <code>&lt;!-- CSS goes here --&gt;</code> in line 9 of <a href="ch10.xhtml#ch10list01">Listing 10-1</a>.</p>
<pre>1 invisible {<br/>
2   display: none; <span class="codeitalic1">/* elements with this class are not displayed */</span><br/>
3 }</pre>
<p class="listing" id="ch10list05"><em>Listing 10-5: Guess the Animal CSS</em></p>
<p class="indent">Note that you can use <em>inline style</em> for simple CSS instead, because of course there has to be more than one way to do things in a browser. Writing line 3 of <a href="ch10.xhtml#ch10list02">Listing 10-2</a> as <code>&lt;div id="root" style="display: none"&gt;</code> would have the same effect.</p>
<h3 class="h3" id="ch10lev1sec2"><strong>Guess the Animal Version 2: C</strong></h3>
<p class="noindent">As I’ve mentioned, browsers are high-level virtual machines—all their functionality is implemented in software. This enables us to quickly and easily construct our program in part by hiding some of the important underpinnings. Let’s rewrite the program in C so that more of the primitive actions that browsers hide are exposed. This discussion assumes a UNIX-derived operating system.</p>
<h4 class="h4" id="ch10lev2sec5"><strong><em>Terminals and the Command Line</em></strong></h4>
<p class="noindent">Our C program is going to be extremely retro in that it’s not going to have any fancy buttons or graphics. It will use the command line in a manner similar to the ancient game of <em>Adventure</em>. This is a great opportunity to learn more about how input and output work rather than relying on the fancy widgets built into browsers.</p>
<p class="indent">What do I mean by “retro” and “command line”? As <a href="ch01.xhtml#ch01">Chapter 1</a> mentions, human language likely started as sounds and gestures, with writing being invented <em>much</em> later. Computer language is the opposite. While interaction did start with pushing buttons and flipping switches when computers still had <span epub:type="pagebreak" id="page_268"/>front panels, it quickly evolved to written language, with gesture and sound recognition coming later. Humans would type and computers would “type back” on terminals (see “<a href="ch06.xhtml#ch06lev2sec19">Terminals</a>” on <a href="ch06.xhtml#page_176">page 176</a>).</p>
<p class="indent">You probably use a <em>graphical user interface (GUI)</em> to communicate with your computer. It’s actually pretty Stone Age if you think about it. <em>“Ugh! Look! Button! Press! Friend! Cat video! Like! Tweet Tweet Tweet!”</em> GUIs mostly use gestural language, which works well for casual computer users because it doesn’t rely too much on users’ memories—or at least it didn’t in the days before all the icons were changed to be universally unrecognizable.</p>
<p class="indent">Most computer systems still support a written command line interface behind all the fancy graphics. Terminals are now implemented in software instead of being a piece of hardware external to the computer. You’ll get a <em>command prompt</em> if you open up the terminal application on your computer; you can type in it, and it will respond.</p>
<p class="indent">Instead of using buttons for yes and no, the C version of our program expects the player to type <code>y</code> or <code>n</code> into the terminal program, followed by the <small>ENTER</small>, <small>RETURN</small>, or ↵ key (depending on keyboard). The player similarly types in new animal names and questions. The program also accepts <code>q</code> to quit.</p>
<h4 class="h4" id="ch10lev2sec6"><strong><em>Building the Program</em></strong></h4>
<p class="noindent">Because C is a compiled language, we can’t just “run” the source code like we could with the interpreted JavaScript version. We have to convert it into machine language first. We can do this pretty easily using the command line. If the source is in a file named, for example, <em>gta.c</em>, you can generate a machine language file called <em>gta</em> by typing the command shown in <a href="ch10.xhtml#ch10fig05">Figure 10-5</a> into your terminal.</p>
<div class="image"><a id="ch10fig05"/><img src="../images/10fig05.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-5: Building the program</em></p>
<p class="indent">Once you have the output file, you can typically just type its name to run it.</p>
<h4 class="h4" id="ch10lev2sec7"><strong><em>Terminals and Device Drivers</em></strong></h4>
<p class="noindent">A terminal is an I/O device, and—as mentioned in “<a href="ch05.xhtml#ch05lev1sec8">System and User Space</a>” on <a href="ch05.xhtml#page_133">page 133</a>—user programs don’t talk to I/O devices directly; the operating system mediates, as shown in <a href="ch10.xhtml#ch10fig06">Figure 10-6</a>.</p>
<span epub:type="pagebreak" id="page_269"/>
<div class="image"><a id="ch10fig06"/><img src="../images/10fig06.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-6: I/O device mediation</em></p>
<p class="indent">Back when terminals were separate devices, the computer and the terminal were connected through an RS-232 serial connection (see “<a href="ch06.xhtml#ch06lev2sec9">Serial Communication</a>” on <a href="ch06.xhtml#page_152">page 152</a>). There were physical wires connecting terminals and computers. Operating systems still pretend that this type of connection exists today, mimicking it in software so that legacy programs continue to work unmodified.</p>
<h4 class="h4" id="ch10lev2sec8"><strong><em>Context Switching</em></strong></h4>
<p class="noindent">The device driver is more complicated than it seems because a primary reason we have operating systems is so that more than one user program can run at the same time. Because the computer has only one set of registers, the OS must save and restore their contents when switching between user programs. There’s actually a lot of stuff that needs to be saved and restored other than the CPU registers, including the MMU registers and state of any I/O. The whole pile is called the <em>process context</em>, or just <em>context</em>. We don’t want to do <em>context switching</em> frivolously because the size of the context makes it comparatively expensive. The system call process is shown in <a href="ch10.xhtml#ch10fig07">Figure 10-7</a>.</p>
<div class="image"><a id="ch10fig07"/><img src="../images/10fig07.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-7: Context switching</em></p>
<p class="indent">As you can see, a lot of work happens behind the scenes when a system call is made. And, as mentioned back in “<a href="ch05.xhtml#ch05lev1sec5">Relative Addressing</a>” on <a href="ch05.xhtml#page_128">page 128</a>, sometimes the OS will <em>sleep</em> a user program, even when it can fulfill a request, in order to give another user program a chance to run.</p>
<p class="indent"><span epub:type="pagebreak" id="page_270"/>We don’t want to do a context switch every time a user presses a key. One way to minimize context switching in this case is to realize we usually don’t care what the user is typing until they hit <small>ENTER</small>. The user program uses a system call to indicate that it wants to <em>read</em> from the terminal. This puts the user program to sleep, because it can’t do anything while it’s waiting, which allows the OS to perform some other operation, such as switching to run another program. The <em>device driver</em> that handles the idiosyncrasies of the physical device can save characters from the terminal in a <em>buffer</em> and <em>wake up</em> the user program only when the user hits <small>ENTER</small> instead of on every keypress.</p>
<p class="indent">What’s a buffer? We saw one back in <a href="ch06.xhtml#ch06fig25">Figure 6-25</a>; it’s a <em>first-in, first-out (FIFO)</em> data structure, at least in software land. (In hardware land, a buffer is often a circuit used to protect delicate components from buffoons.) <a href="ch10.xhtml#ch10fig08">Figure 10-8</a> depicts a FIFO, also known as a <em>queue</em>, which is similar to being in line at the grocery store. As with stacks, a FIFO can overflow by running out of space and underflow by fetching from an empty queue.</p>
<div class="image"><a id="ch10fig08"/><img src="../images/10fig08.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-8: Dog in queue</em></p>
<p class="indent">Terminals usually operate in full-duplex mode (see “<a href="ch06.xhtml#ch06lev2sec9">Serial Communication</a>” on <a href="ch06.xhtml#page_152">page 152</a>), which means there is no direct connection between the keyboard and the display; the keyboard sends data to the computer, and the display receives data from the computer. Originally, as mentioned earlier, there were separate physical wires for each direction. It’s not enough, then, for the terminal device driver to buffer up the input because the user will get confused unless what they type is <em>echoed</em> so they can see it. And terminals are often slower than programs that write to them, so an <em>output buffer</em> is used in addition to the <em>input buffer</em>. A program is put to sleep if it tries to write to a full output buffer. The driver might provide the user some feedback, such as beeping if the input buffer becomes full. The part of the driver that we’ve been discussing looks like <a href="ch10.xhtml#ch10fig09">Figure 10-9</a>.</p>
<div class="image"><a id="ch10fig09"/><img src="../images/10fig09.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-9: Terminal device driver buffering and echoing</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_271"/>Real device drivers are more complicated. Additional system calls are used to modify the driver settings. Echoing can be turned on and off. Buffering can be turned off, which is known as <em>raw</em> mode, whereas turning it on is known, of course, as <em>cooked</em> mode. The key(s) that wake up the user program can be set, along with much more, such as which key erases characters (usually <small>BACKSPACE</small> or <small>DELETE</small>).</p>
<h4 class="h4" id="ch10lev2sec9"><strong><em>Standard I/O</em></strong></h4>
<p class="noindent">Buffering in the device driver solves only part of the problem. User programs have similar issues. It doesn’t do any good to have the device driver buffer up input just to have a user program make a system call for each character. The output buffer doesn’t help too much if the user program makes a system call to write each character. This is a common enough situation that it prompted the creation of the <em>standard input/output</em> library (<code>stdio</code>), which contains buffered I/O functions for user programs.</p>
<p class="indent">The <code>stdio</code> library supports buffered input, in which as much input as possible is read from the device driver in a single system call and placed into a buffer. The user program gets characters from the buffer until it’s empty, then tries to get more. On the output side, characters are buffered until either the buffer is full or an important character such as a newline occurs. Together it looks like <a href="ch10.xhtml#ch10fig10">Figure 10-10</a>.</p>
<div class="image"><a id="ch10fig10"/><img src="../images/10fig10.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-10: User program with <span class="codeitalic">stdio</span> buffering</em></p>
<p class="indent">Seems like a lot of work just to make things run efficiently! And we’re not done yet. How does the user program get connected to the terminal device driver?</p>
<p class="indent">It’s way easier to reference someone by their name than it is to provide their complete description, and operating systems take a similar approach to access files. The <code>open</code> system call converts a filename into a <em>handle</em> or <em>file descriptor</em> that can be used to reference the file until it is closed via the <code>close</code> system call. This is akin to getting a claim ticket when you check your backpack in a museum. The <code>stdio</code> library includes analogous <code>fopen</code> and <code>fclose</code> <span epub:type="pagebreak" id="page_272"/>functions that use the system calls but also set up and tear down the buffering system. Because the UNIX abstractions treat devices just like files, you can open a special file such as <em>/dev/tty</em> to access a terminal device.</p>
<h4 class="h4" id="ch10lev2sec10"><strong><em>Circular Buffers</em></strong></h4>
<p class="noindent">Earlier I said queues are like being in line at a grocery store. Although they do have that outward appearance, that’s not how buffers such as the <code>stdio</code> output buffer in <a href="ch10.xhtml#ch10fig10">Figure 10-10</a> are actually implemented.</p>
<p class="indent">Think about what happens in a grocery line. When the person in front is done, everybody else in line must move forward one position. Let’s queue up a <code>frog</code>, as shown in <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>. As you can see, we need to keep track of the end of the line so we know where to insert things.</p>
<div class="image"><a id="ch10fig11"/><img src="../images/10fig11.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-11: Inserting into a queue</em></p>
<p class="indent">Now let’s look at what happens when the <code>frog</code> is removed from the queue (<a href="ch10.xhtml#ch10fig12">Figure 10-12</a>).</p>
<div class="image"><a id="ch10fig12"/><img src="../images/10fig12.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-12: Removing from a queue</em></p>
<p class="indent">As you can see, a lot of work is involved. When the <code>f</code> is removed, the <code>r</code> must be copied to where the <code>f</code> was, then the <code>o</code> to where the <code>r</code> was, and so on. Let’s try a different approach. Rather than everyone in the line moving, let’s have the checker get some exercise in <a href="ch10.xhtml#ch10fig13">Figure 10-13</a>.</p>
<div class="image"><a id="ch10fig13"/><img src="../images/10fig13.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-13: Removing from a queue by moving the checker</em></p>
<p class="indent">This is a lot less work, except for the checker. But it causes a new problem. At some point, the line backs up to the door even though there’s space at the front. Nobody else can get in line.</p>
<p class="indent"><span epub:type="pagebreak" id="page_273"/>What we need is some way to funnel new people into the space at the front of the line. We can do this by bending the line so that it’s circular, as shown in <a href="ch10.xhtml#ch10fig14">Figure 10-14</a>.</p>
<div class="image"><a id="ch10fig14"/><img src="../images/10fig14.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-14: Circular buffer</em></p>
<p class="indent">As you can see, data can be added to the queue as long as the <em>in</em> arrow is clockwise from the <em>out</em> arrow. Likewise, data in the queue can be removed as long as the out arrow is counterclockwise from the in arrow. A bit of arithmetic is needed to wrap around from the end of the buffer to the beginning. The next location is the current one plus 1, modulo the buffer size.</p>
<p class="indent">These structures have many names, including <em>circular buffers</em>, <em>circular queues</em>, and <em>ring buffers</em>. They’re a pretty standard approach, and not just in <code>stdio</code> or device drivers.</p>
<h4 class="h4" id="ch10lev2sec11"><strong><em>Better Code Through Good Abstractions</em></strong></h4>
<p class="noindent">Every time we play the Guess the Animal game, we start over from scratch with a program that knows only about cats and dogs. It would be nice if we could remember our game and continue where we left off. That’s easy to do in our C program; it’s a side benefit that results from the file abstraction.</p>
<p class="indent">Adding such a feature to the JavaScript version is much more difficult. <a href="ch10.xhtml#ch10fig15">Figure 10-15</a> illustrates why.</p>
<div class="image"><a id="ch10fig15"/><img src="../images/10fig15.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-15: Browser and operating system interfaces</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_274"/>You can see that the OS has a single interface that works for both devices and files. This interface is used both by the browser on the left and by the C version of the program on the right. That means the C program, like the browser, can use the same code to read input from a file as it does to read user input from a device. But the browser doesn’t pass this abstraction on to the JavaScript programmer. Instead, a completely separate piece of code using a completely different interface would be needed to add the new feature there. The choice of interface can have a big impact on both the ease of programming and the clarity of the result.</p>
<h4 class="h4" id="ch10lev2sec12"><strong><em>Some Mechanics</em></strong></h4>
<p class="noindent">Back to our C program. Getting a C program ready to run requires compiling it and then <em>linking</em> it to other code that it uses, such as the <code>stdio</code> library. The section “<a href="ch05.xhtml#ch05lev1sec12">Running Programs</a>” on <a href="ch05.xhtml#page_137">page 137</a> mentions that a runtime library is also included; the C version is often named <code>crt0</code>. It’s responsible for tasks like setting up the stack and the heap so they’re ready to use. It also opens up a pair of files that are connected to the terminal device driver by default, one for input and one for output.</p>
<p class="indent">The <code>stdio</code> library maps the system file descriptors into <em>file pointers</em>, addresses that reference the data structures that it uses for buffering and bookkeeping. It starts with three: <code>stdin</code> (standard input), <code>stdout</code> (standard output), and <code>stderr</code> (standard error). The intent is for things that are important to go to <code>stderr</code> instead of <code>stdout</code>; they both go to the same place, but <code>stderr</code> is unbuffered and <code>stdout</code> is buffered. If you use <code>stdout</code> for error messages, they get buffered, and you may never see them if your program crashes. The file pointers <code>stdout</code> and <code>stderr</code> share the same file descriptor, as shown in <a href="ch10.xhtml#ch10fig16">Figure 10-16</a>, unless changed.</p>
<div class="image"><a id="ch10fig16"/><img src="../images/10fig16.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-16: The file pointers <span class="codeitalic">stdin</span>, <span class="codeitalic">stdout</span>, and <span class="codeitalic">stderr</span></em></p>
<p class="indent">Invention is often sparked by strange events. According to Steve Johnson, <code>stderr</code> was not part of the original <code>stdio</code> library; it was added as a side effect of the development of the first computer typesetting software (<code>troff</code>, written by Joseph Ossanna, 1928–1977) for the C/A/T photoypesetter. You take laser and inkjet printing for granted, but this beast projected images onto silver photographic paper, which then had to be developed. That became <span epub:type="pagebreak" id="page_275"/>very expensive when the Hunt brothers cornered the silver market, and folks were asked to cut down on phototypesetter use. It was not uncommon to send a job to the typesetter only to get back a beautifully formatted page containing a <code>cannot open file</code> error message. The <code>stderr</code> file pointer was born so that error messages could go to the terminal instead of to the typesetter in order to save money.</p>
<h4 class="h4" id="ch10lev2sec13"><strong><em>Buffer Overflow</em></strong></h4>
<p class="noindent">As long as we’re on the subject of <code>stdio</code>, let’s talk about a class of very serious system programming errors called <em>buffer overflow</em>. When <code>stdio</code> was originally written, it included a function called <code>gets</code> that read a string up to the next newline character from <code>stdin</code> into a user-supplied buffer. We could use it as shown in <a href="ch10.xhtml#ch10list06">Listing 10-6</a> to read the <code>y</code>, <code>n</code>, or <code>q</code> response; there’s room in <code>buffer</code> for the character and a NUL terminator.</p>
<pre>1 char buffer[2];<br/>
2<br/>
3 gets(buffer);</pre>
<p class="listing" id="ch10list06"><em>Listing 10-6: Using <span class="codeitalic">gets</span> to read input</em></p>
<p class="indent">Why might this be a problem? Because <code>gets</code> doesn’t check to make sure that the input doesn’t run off the end of the buffer. Say we have a more serious program that also has a variable named <code>launch_missiles</code>, which just happens to be the next thing in memory (<a href="ch10.xhtml#ch10fig17">Figure 10-17</a>).</p>
<div class="image"><a id="ch10fig17"/><img src="../images/10fig17.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-17: Buffer overflow in memory</em></p>
<p class="indent">A malicious user might discover that answering <code>yyy</code> would store a <code>y</code> in <code>launch_missiles</code>, which for all intents and purposes is the same as the nonexistent <code>buffer[2]</code>. That could get really ugly. As a matter of fact, it has. A very large number of discovered security issues result from exactly this sort of buffer overflow bug. This was fixed in <code>stdio</code> by the addition of an <code>fgets</code> function that checks bounds. But be careful—there are many, many ways in which buffer overflow bugs can occur. <em>Never, ever assume that buffer sizes are big enough!</em> There’s more detail about buffer overflows in <a href="ch13.xhtml#ch13">Chapter 13</a>.</p>
<h4 class="h4" id="ch10lev2sec14"><strong><em>The C Program</em></strong></h4>
<p class="noindent">There are many C libraries in addition to <code>stdio</code>. The <code>string</code> library, for example, includes functions for comparing and copying strings, and the catchall standard library <code>stdlib</code> includes functions for memory management.</p>
<p class="indent"><span epub:type="pagebreak" id="page_276"/><a href="ch10.xhtml#ch10list07">Listing 10-7</a> shows the C program for our game’s prologue. The first part brings in the library information we need (lines 1–3). Next, a node structure is declared (lines 5–9) that contains pointers to two leaves and a placeholder for the question or animal string. Note that we didn’t have to do something like this in our JavaScript version because we took advantage of the existing HTML <code>&lt;div&gt;</code>; had we not done that, there would have been a JavaScript equivalent. Notice that the node structure is defined such that we can allocate the node and string together, as in “<a href="ch07.xhtml#ch07lev1sec8">More Efficient Memory Allocation</a>” on <a href="ch07.xhtml#page_196">page 196</a>.</p>
<pre>1 #include &lt;stdio.h&gt;  // standard I/O library<br/>
2 #include &lt;stdlib.h&gt; // standard library for exit and malloc<br/>
3 #include &lt;string.h&gt; // string library<br/>
4<br/>
5 struct node {<br/>
6   struct node *no;  // references no answer node<br/>
7   struct node *yes; // references yes answer node<br/>
8   char string[1];   // question or animal<br/>
9 };</pre>
<p class="listing" id="ch10list07"><em>Listing 10-7: Guess the Animal in C: prologue</em></p>
<p class="indent">Next, we define a function to help with memory allocation (<a href="ch10.xhtml#ch10list08">Listing 10-8</a>). Although memory allocation is no big deal, we need to do it in several places, and it gets tedious to check for errors each time. More recent languages include exception-handling constructs that make this sort of thing simpler.</p>
<p class="indent">Since the only time that we need to allocate memory is when making a new <code>node</code>, we use a function that takes the <code>string</code> to install in the <code>node</code>. In addition to allocating memory, the <code>string</code> is copied into the <code>node</code>, and the <code>yes</code> and <code>no</code> pointers are initialized.</p>
<pre>10 struct  node    *<br/>
11 make_node(char *string)<br/>
12 {<br/>
13     struct  node    *memory;        // newly allocated memory<br/>
14<br/>
15     if ((memory = (struct node *)malloc(sizeof (struct node) + strlen(string))) == (struct node *)0) {<br/>
16         (void)fprintf(stderr, "gta: out of memory.\n");<br/>
17         exit(-1);<br/>
18     }<br/>
19<br/>
20     (void)strcpy(memory-&gt;string, string);<br/>
21     memory-&gt;yes = memory-&gt;no = (struct node *)0;<br/>
22<br/>
23     return (memory);<br/>
24 }</pre>
<p class="listing" id="ch10list08"><em>Listing 10-8: Guess the Animal in C: memory allocator</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_277"/>We use the <code>fprintf</code> function in <code>stdio</code> for our error message because, as discussed earlier, things sent to <code>stderr</code> are unbuffered, which gives us a better chance of seeing the message if the program fails unexpectedly.</p>
<p class="indent">Note that the cast operator is used to cast the <code>fprintf</code> as <code>void</code> on line 16. When <code>fprintf</code> returns a value that we’re ignoring, the cast tells the compiler that we’re doing it deliberately, instead of forgetting to check something, so that it doesn’t generate warning messages. It also informs someone reading the code that the return value is being deliberately ignored, so it’s not a mistake. Recent changes to some compilers eliminate these warnings unless explicitly requested.</p>
<p class="indent">The call to <code>exit</code> on line 17 terminates the program. That’s the only reasonable option when there isn’t enough memory available to continue running the program.</p>
<p class="indent">The <code>printf</code> (<em>print formatted</em>) function is part of <code>stdio</code> and has made its way into many other languages. The first argument is a <em>format string</em> that determines the interpretation of the remainder of the arguments. A <code>%</code> followed by a code means “replace me with the next argument according to the code.” In this case, <code>%s</code> means “treat the next argument as a string.”</p>
<p class="indent">The rest of the program is shown in <a href="ch10.xhtml#ch10list09">Listing 10-9</a>.</p>
<pre> 25 int<br/>
 26 main(int argc, char *argv[])<br/>
 27 {<br/>
 28     char            animal[50];     // new animal name buffer<br/>
 29     char            buffer[3];      // user input buffer<br/>
 30     int             c;              // current character from buffer<br/>
 31     struct  node    **current;      // current tree traversal node<br/>
 32     FILE            *in;            // input file for training data or typing<br/>
 33     struct  node    *new;           // newly created node<br/>
 34     FILE            *out;           // output file for saving training data<br/>
 35     char            *p;             // newline removal pointer<br/>
 36     char            question[100];  // new question buffer<br/>
 37     struct  node    *root;          // root of the tree of knowledge<br/>
 38<br/>
 39     //  Process the command line arguments.<br/>
 40<br/>
 41     in = out = (FILE *)0;<br/>
 42<br/>
 43     for (argc--, argv++; argc &gt; 1 &amp;&amp; argc % 2 == 0; argc -= 2, argv += 2) {<br/>
 44         if (strcmp(argv[0], "-i") == 0 &amp;&amp; in == (FILE *)0) {<br/>
 45             if ((in = fopen(argv[1], "r")) == (FILE *)0) {<br/>
 46                 (void)fprintf(stderr, "gta: can't open input file `%s'.\n", argv[1]);<br/>
 47                 exit(-1);<br/>
 48             }<br/>
 49         }<br/>
 50<br/>
 51         else if (strcmp(argv[0], "-o") == 0 &amp;&amp; out == (FILE *)0) {<br/>
<span epub:type="pagebreak" id="page_278"/> 52             if ((out = fopen(argv[1], "w")) == (FILE *)0) {<br/>
 53                 (void)fprintf(stderr, "gta: can't open output file `%s'.\n", argv[1]);<br/>
 54                 exit(-1);<br/>
 55             }<br/>
 56         }<br/>
 57<br/>
 58         else<br/>
 59             break;<br/>
 60     }<br/>
 61<br/>
 62     if (argc &gt; 0) {<br/>
 63         (void)fprintf(stderr, "usage: gta [-i input-file-name] [-o output-file-name]\n");<br/>
 64         exit(-1);<br/>
 65     }<br/>
 66<br/>
 67     //  Read from standard input if no input file was specified on the command line.<br/>
 68<br/>
 69     if (in == (FILE *)0)<br/>
 70         in = stdin;<br/>
 71<br/>
 72     //  Create the initial tree of knowledge.<br/>
 73<br/>
 74     root = make_node("Does it bark");<br/>
 75     root-&gt;yes = make_node("dog");<br/>
 76     root-&gt;no = make_node("cat");<br/>
 77<br/>
 78     for (;;) {      // play games until the user quits.<br/>
 79<br/>
 80         if (in == stdin)<br/>
 81             (void)printf("Think of an animal.\n");<br/>
 82<br/>
 83         current = &amp;root;    //  start at the top<br/>
 84<br/>
 85         for (;;) {          // play a game<br/>
 86<br/>
 87             for (;;) {      // get valid user input<br/>
 88                 if (in == stdin) {<br/>
 89                     if ((*current)-&gt;yes == (struct node *)0)<br/>
 90                         (void)printf("Is it a ");<br/>
 91<br/>
 92                     (void)printf("%s?[ynq] ", (*current)-&gt;string);<br/>
 93                 }<br/>
 94<br/>
 95                 if (fgets(buffer, sizeof (buffer), in) == (char *)0 || strcmp(buffer, "q\n") == 0) {<br/>
 96                     if (in != stdin) {<br/>
 97                         (void)fclose(in);<br/>
 98                         in = stdin;<br/>
 99                     }<br/>
100                     else {<br/>
101                         if (in == stdin)<br/>
102                             (void)printf("\nThanks for playing.  Bye.\n");<br/>
103                         exit(0);<br/>
104                     }<br/>
105                 }<br/>
<span epub:type="pagebreak" id="page_279"/>106                 else if (strcmp(buffer, "y\n") == 0) {<br/>
107                     if (out != (FILE *)0)<br/>
108                         fputs("y\n", out);<br/>
109<br/>
110                     current = &amp;((*current)-&gt;yes);<br/>
111<br/>
112                     if (*current == (struct node *)0) {<br/>
113                         (void)printf("I knew it!\n");<br/>
114                         break;<br/>
115                     }<br/>
116                 }<br/>
117                 else if (strcmp(buffer, "n\n") == 0) {<br/>
118                     if (out != (FILE *)0)<br/>
119                         fputs("n\n", out);<br/>
120<br/>
121                     if ((*current)-&gt;no == (struct node *)0) {<br/>
122                         if (in == stdin)<br/>
123                             (void)printf("I give up.  What is it? ");<br/>
124<br/>
125                         fgets(animal, sizeof (animal), in);<br/>
126<br/>
127                         if (out != (FILE *)0)<br/>
128                             fputs(animal, out);<br/>
129<br/>
130                         if ((p = strchr(animal, '\n')) != (char *)0)<br/>
131                             *p = '\0';<br/>
132<br/>
133                         if (in == stdin)<br/>
134                             (void)printf(<br/>
135                              "What's a good question that I could use to tell a %s from a %s? ",<br/>
136                               animal, (*current)-&gt;string);<br/>
137                         fgets(question, sizeof (question), in);<br/>
138<br/>
139                         if (out != (FILE *)0)<br/>
140                             fputs(question, out);<br/>
141<br/>
142                         if ((p = strchr(question, '\n')) != (char *)0)<br/>
143                             *p = '\0';<br/>
144<br/>
145                         new = make_node(question);<br/>
146                         new-&gt;yes = make_node(animal);<br/>
147                         new-&gt;no = *current;<br/>
148                         *current = new;<br/>
149<br/>
150                         if (in == stdin)<br/>
151                             (void)printf("Thanks!  I'll remember that.\n");<br/>
152<br/>
153                         break;<br/>
154                     }<br/>
155<br/>
156                     else<br/>
157                         current = &amp;((*current)-&gt;no);<br/>
158                 }<br/>
159                 else {<br/>
<span epub:type="pagebreak" id="page_280"/>160                     if (in == stdin)<br/>
161                         (void)printf("Huh?  Please answer y for yes, n for no, or q for quit.\n");<br/>
162<br/>
163                     while ((c = getc(in)) != '\n' &amp;&amp; c != EOF)<br/>
164                         ;<br/>
165                 }<br/>
166             }<br/>
167<br/>
168             break;<br/>
169         }<br/>
170<br/>
171         if (in == stdin)<br/>
172             (void)printf("Let's play again.\n\n");<br/>
173     }<br/>
174 }</pre>
<p class="listing" id="ch10list09"><em>Listing 10-9: Guess the Animal in C: mainline</em></p>
<p class="indent">There’s nothing particularly interesting about this code except the memory management, as the program does pretty much the same thing as the JavaScript version. Lines 28 through 37 declare variables. Lines 74 through 76 create the initial nodes depicted in <a href="ch10.xhtml#ch10fig18">Figure 10-18</a>. Note that all the strings are NUL-terminated (<code>'\0'</code>).</p>
<div class="image"><a id="ch10fig18"/><img src="../images/10fig18.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-18: Guess the Animal in C: initial nodes</em></p>
<p class="indent">Let’s play the game as we did earlier in “<a href="ch10.xhtml#ch10lev1sec1">Guess the Animal Version 1: HTML and JavaScript</a>” on <a href="ch10.xhtml#page_262">page 262</a>. After the player supplies a new question, a new node is allocated for it. There are a couple of points of interest here. Be careful getting the length of a string using the <code>strlen</code> (<em>string length</em>) function. It returns the actual length of the string, not the amount of memory used, which is 1 byte more to account for the NUL terminator. But notice that we don’t add 1 when allocating memory for strings because of the way we’re allocating memory for the node, which already includes the extra byte.</p>
<p class="indent">Whenever we descend the tree in response to a yes or no answer, we keep a <code>current</code> pointer to make it easy to insert the new question node. We need to detach either the <code>yes</code> or <code>no</code>, which we do by having <code>current</code> point to <span epub:type="pagebreak" id="page_281"/>whatever node pointer is being replaced. Because <code>current</code> points to a node pointer, it’s a pointer to a pointer. When we say <code>*current = new;</code> we’re dereferencing the pointer and saying “replace whatever the pointer is pointing to.” In <a href="ch10.xhtml#ch10fig19">Figure 10-19</a>, the <code>no</code> pointer in the <code>new</code> node is set to <code>current</code>, which is the old answer, and <code>current</code> points to the <code>yes</code> pointer in the <code>root</code> node, which gets replaced with the pointer to the <code>new</code> node.</p>
<div class="image"><a id="ch10fig19"/><img src="../images/10fig19.jpg" alt="Image"/></div>
<p class="figcap"><em>Figure 10-19: Guess the Animal in C: adding new nodes</em></p>
<h4 class="h4" id="ch10lev2sec15"><strong><em>Training</em></strong></h4>
<p class="noindent">Recall that our C program can be run with command line options for reading and writing training data. We can run the program as follows:</p>
<pre>prompt&gt; gta -o training<br/>
Think of an animal.<br/>
Does it bark?<br/>
<span class="codestrong1">n</span><br/>
Is it a dog?<br/>
<span class="codestrong1">n</span><br/>
I give up. What is it?<br/>
<span class="codestrong1">giant purple snorklewhacker</span><br/>
What's a question that I could use to tell a giant purple snorklewhacker from a dog?<br/>
<span class="codestrong1">Does it live in an anxiety closet?</span><br/>
Thanks. I'll remember that.<br/>
Let's play again.<br/>
Think of an animal.<br/>
Does it bark?<br/>
<span class="codestrong1">q</span><br/>
Thanks for playing. Bye.</pre>
<span epub:type="pagebreak" id="page_282"/>
<p class="noindent">Now, if you look in the <code>training</code> file, you’ll see that it contains exactly what you typed:</p>
<pre><span class="codestrong1">n</span><br/>
<span class="codestrong1">n</span><br/>
<span class="codestrong1">giant purple snorklewhacker</span><br/>
<span class="codestrong1">Does it live in an anxiety closet?</span></pre>
<p class="indent">If we rerun the program as:</p>
<pre>prompt&gt; gta -i training</pre>
<p class="noindent">the contents of the <code>training</code> file will get read in so that the program starts where we left off.</p>
<p class="indent">Way back in “<a href="intro.xhtml#introlev1sec6">What Is Computer Programming?</a>” on <a href="intro.xhtml#page_xxix">page xxix</a>, I mentioned that you need to know a lot about everything in order to be a good programmer. Our program isn’t very good grammatically. It works fine if the animal is a dog, because it will ask <code>Is it a dog?</code>. But what if it’s an elephant? It’s not grammatically correct to ask <code>Is it a elephant?</code>. What are the rules for making sure the grammar is correct? Can you modify the code to make it grammatically more better?</p>
<h3 class="h3" id="ch10lev1sec3"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you’ve seen a program written in two ways: once as a high-level application and once as a lower-level system program. On one hand, writing high-level application programs can be easier because many small details are handled automatically. On the other hand, some features, such as recording and playback, are much more difficult to implement in environments that don’t include uniform interfaces.</p>
<p class="indent">Furthermore, using very complex application environments for simple applications increases the likelihood of bugs. The probability of bugs is the sum of your application code and the code for the environment in which it runs. How many times has your browser begun running very slowly and needed to be restarted, usually due to internal memory management errors? How often has your browser just crashed?</p>
<p class="indent">You’ve seen that system programming involves much more attention to detail, such as the management of strings, memory, and buffers. But these details are important when the goal is to craft code that is concise and secure. In the next chapter, we’ll look at a different type of detail: structuring problems so that they’re easier to solve.</p>
</body></html>