- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11'
- en: INSIDE THE MAIN FUNCTION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**在主函数内部**'
- en: '![Image](../images/pg235_Image_254.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg235_Image_254.jpg)'
- en: As you learned in [Chapter 10](ch10.xhtml), a C program begins by executing
    a function named `main`, which is called from a startup function in the C hosted
    environment. The `main` function will call other functions (*subfunctions*) to
    do most of the processing. Even a simple “Hello, World!” program needs to call
    another function to write the message on the screen.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第10章](ch10.xhtml)中学到的，C程序开始时会执行一个名为`main`的函数，该函数从C宿主环境中的启动函数调用。`main`函数将调用其他函数（*子函数*）来执行大部分处理。即使是一个简单的“Hello,
    World!”程序，也需要调用另一个函数来在屏幕上显示消息。
- en: In this chapter, we’ll focus on the `main` function, but the concepts apply
    to all the functions we’ll be writing. We’ll begin with a detailed look at the
    call stack, which is used for saving values and for local variables. Then we’ll
    look at how to process data in a function and how to pass arguments to other functions.
    I’ll wrap up the chapter by showing you how to use this knowledge to write the
    `main` function in assembly language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点讲解`main`函数，但这些概念适用于我们将编写的所有函数。我们将从详细了解调用栈开始，它用于保存值和局部变量。然后，我们将探讨如何在函数中处理数据，以及如何将参数传递给其他函数。最后，我将通过向你展示如何使用这些知识来编写汇编语言中的`main`函数来结束本章。
- en: '**Using the Call Stack**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用调用栈**'
- en: The *call stack*, commonly referred to simply as the *stack*, is a very useful
    place for creating local variables and saving items within a function. Before
    we cover how to use the stack for these purposes, you need to understand what
    stacks are and how they work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用栈*，通常简称为*栈*，是创建局部变量和在函数中保存项目的非常有用的地方。在我们讲解如何使用栈来完成这些目的之前，你需要了解栈是什么以及它是如何工作的。'
- en: '***Stacks in General***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***栈的一般操作***'
- en: A stack is a linear data structure created in memory to store data items. Insertion
    of a data item onto (or deletion from) a stack can be done at only one end, called
    the *top*. Programs keep track of the top of the stack with a *stack pointer*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种线性数据结构，创建于内存中用于存储数据项。数据项的插入（或删除）只能在栈的一端进行，这一端被称为*栈顶*。程序通过*栈指针*来跟踪栈顶。
- en: 'Informally, you can think of a stack as being organized like a stack of dinner
    plates on a shelf. You need to be able to access only the item at the top of the
    stack. (And, yes, if you pull out a plate from somewhere within the stack, you
    will probably break something.) There are two fundamental operations on a stack:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，你可以把栈想象成像架子上的餐盘堆叠。你只需要能够访问栈顶的那个项目。（是的，如果你从栈的某个地方取出餐盘，可能会弄坏一些东西。）栈有两个基本操作：
- en: push data_item Places the data_item at the top of the stack and moves the stack
    pointer to point to this latest item
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: push data_item 将 data_item 放置到栈顶，并将栈指针移动到指向此最新项。
- en: pop location Moves the data item at the top of the stack to location and moves
    the stack pointer to point to the item now at the top of the stack
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: pop location 将栈顶的项目移动到位置，并将栈指针移动到指向栈顶当前的项目。
- en: The stack is a *last in, first out (LIFO)* data structure. The last thing to
    be pushed onto the stack is the first thing to be popped off.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种*后进先出（LIFO）*数据结构。最后被推入栈的项将是第一个被弹出的项。
- en: 'To illustrate the stack concept, let’s continue with the dinner plate example.
    Say we have three differently colored dinner plates: a red one on the dining table,
    a green one on the kitchen counter, and a blue one on the bedside table. We’ll
    stack them on the shelf in the following way:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明栈的概念，我们继续使用餐盘的例子。假设我们有三个颜色不同的餐盘：一个红色的放在餐桌上，一个绿色的放在厨房台面上，另一个蓝色的放在床头柜上。我们将它们按照以下方式堆叠在架子上：
- en: Push red plate.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推入红色餐盘。
- en: Push green plate.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推入绿色餐盘。
- en: Push blue plate.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推入蓝色餐盘。
- en: At this point, our stack of plates looks like [Figure 11-1](ch11.xhtml#ch11fig1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时刻，我们的餐盘堆叠看起来像[图 11-1](ch11.xhtml#ch11fig1)。
- en: '![image](../images/pg236_Image_255.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg236_Image_255.jpg)'
- en: '*Figure 11-1: Three dinner plates in a stack*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：堆叠的三个餐盘*'
- en: 'Now we perform the next operation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们执行下一个操作：
- en: Pop kitchen counter.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从厨房台面弹出。
- en: This moves the blue plate to the kitchen counter (recall that the blue plate
    was previously on the bedside table) and leaves the stack of dinner plates as
    shown in [Figure 11-2](ch11.xhtml#ch11fig2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把蓝色餐盘移到厨房台面（回想一下，蓝色餐盘之前是放在床头柜上的），并留下如[图 11-2](ch11.xhtml#ch11fig2)所示的餐盘堆叠。
- en: '![image](../images/pg237_Image_256.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg237_Image_256.jpg)'
- en: '*Figure 11-2: One dinner plate has been popped from the stack.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：一个晚餐盘已从栈中弹出。*'
- en: 'If you have guessed that it’s easy to really mess up a stack, you’re right.
    A stack must be used according to a strict discipline. Within any function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你猜到栈很容易被搞砸，那么你是对的。栈必须按照严格的规则使用。在任何一个函数内：
- en: Always push an item onto the stack before popping anything off.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在弹出任何东西之前，始终先将项推入栈中。
- en: Never pop more things off than you have pushed on.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要弹出比你推入的更多的东西。
- en: Always pop everything off the stack that you have pushed on.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远弹出所有你已经推入栈中的项。
- en: If you have no use for the item(s) that you have pushed onto the stack, you
    may simply set the stack pointer to where it was when the function was first entered.
    This is equivalent to discarding the items that are popped off. (Our dinner plate
    analogy breaks down here.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对推入栈中的项没有使用需求，可以将栈指针设置回函数最初进入时的位置。这相当于丢弃已弹出的项。（我们的晚餐盘比喻在这里就不成立了。）
- en: A good way to maintain this discipline is to think of the use of parentheses
    in an algebraic expression. A push is analogous to a left parenthesis and a pop
    to a right parenthesis. The pairs of parentheses can be nested, but they have
    to match. An attempt to push too many items onto a stack is called *stack overflow*.
    An attempt to pop items off the stack beyond the bottom is called *stack underflow*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 维持这一纪律的一个好方法是将栈的使用类比于代数表达式中的括号。推入栈就像左括号，而弹出则像右括号。括号对可以嵌套，但必须匹配。试图向栈中推入过多项的情况叫做*栈溢出*。试图弹出栈底以下的项叫做*栈下溢*。
- en: A stack is implemented by dedicating a contiguous area of main memory to it.
    Stacks can grow in either direction in memory, into higher addresses or lower.
    An *ascending stack* grows into higher addresses, and a *descending stack* grows
    into lower addresses. The stack pointer can point to the top item on the stack,
    a *full stack*, or to the memory location where the next item will be pushed onto
    the stack, an *empty stack*. These four possible stack implementations are shown
    in [Figure 11-3](ch11.xhtml#ch11fig3), with the integers 1, 2, and 3 pushed onto
    the stack in that order. Notice that memory addresses are *increasing downward*
    in this figure, which is the way we usually view them in the `gdb` debugger.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是通过专门分配一块连续的主内存区域来实现的。栈可以在内存中向任何一个方向增长，向更高的地址或更低的地址。*上升栈*向更高的地址增长，*下降栈*向更低的地址增长。栈指针可以指向栈顶的项，即*满栈*，也可以指向下一个将被推入栈中的项所在的内存位置，即*空栈*。这四种可能的栈实现方式如[图11-3](ch11.xhtml#ch11fig3)所示，其中整数1、2和3按顺序推入栈中。注意，在这个图中，内存地址是*向下增加*的，这是我们通常在`gdb`调试器中查看的方式。
- en: '![image](../images/pg237_Image_257.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg237_Image_257.jpg)'
- en: '*Figure 11-3: Four ways to implement a stack*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：实现栈的四种方式*'
- en: The call stack in our environment is a *full descending stack*. To understand
    this choice, think about how you might organize things in memory. Recall that
    the control unit automatically increments the program counter as your program
    is executed. Programs come in vastly different sizes, so storing the program instructions
    at low memory addresses allows maximum flexibility with respect to program size.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们环境中的调用栈是一个*满的下降栈*。要理解这个选择，想想你可能如何在内存中组织事物。回想一下控制单元在程序执行时会自动递增程序计数器。程序的大小差异巨大，因此将程序指令存储在较低的内存地址处，可以在程序大小上提供最大的灵活性。
- en: The stack is a dynamic structure. You don’t know how much stack space will be
    required by any given program as it executes, so it’s impossible to know how much
    space to allocate. To allocate as much space as possible, while preventing it
    from colliding with program instructions, start the stack at the highest memory
    address and have it grow toward lower addresses.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个动态结构。你无法预测任何给定程序执行时所需的栈空间，因此也不可能知道需要分配多少空间。为了分配尽可能多的空间，同时避免与程序指令发生冲突，应从最高的内存地址开始分配栈空间，并让它向较低的地址增长。
- en: This is a highly simplified rationalization for implementing stacks that grow
    “downward” in memory. The organization of various program elements in memory is
    much more complex than the description given here, but this may help you understand
    that there are some good reasons for what may seem to be a rather odd implementation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高度简化的对栈在内存中“向下”增长的实现方式的合理化解释。程序中各个元素在内存中的组织比这里所描述的要复杂得多，但这可能帮助你理解为什么这种看起来有些奇怪的实现方式实际上是有充分理由的。
- en: The A64 architecture does not have `push` and `pop` instructions. It has instructions
    that allow you to effectively push items onto or pop items off of the stack, but
    most of the operations on the stack are done by allocating memory on the call
    stack and then directly storing items into or loading items from this allocated
    memory. Next, we’ll look at how functions use the call stack.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: A64架构没有`push`和`pop`指令。它有允许你有效地将项目推入栈或从栈中弹出项目的指令，但栈上的大多数操作都是通过在调用栈上分配内存并直接将项目存储到该内存或从中加载项目来完成的。接下来，我们将看看函数如何使用调用栈。
- en: '***The Stack Frame***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***栈帧***'
- en: 'Each function that calls another function needs to allocate memory on the stack
    for that function to use to save items and store local variables. This allocated
    memory is called a *stack frame* or *activation record*. To see how this works,
    we’ll start with a program that has one local variable and calls two functions
    in the C standard library: `printf` and `scanf`. The program is shown in [Listing
    11-1](ch11.xhtml#ch11list1).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个调用其他函数的函数都需要在栈上为被调用函数分配内存，用于保存项目和存储局部变量。这块分配的内存叫做*栈帧*或*激活记录*。为了理解这一过程，我们将从一个包含一个局部变量并调用两个C标准库函数的程序开始：`printf`和`scanf`。该程序见[列表
    11-1](ch11.xhtml#ch11list1)。
- en: '*inc_int.c*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc_int.c*'
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: A program to increment an integer*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-1：一个用于递增整数的程序*'
- en: You can see how a stack frame is created by looking at the assembly language
    generated by the compiler, shown in [Listing 11-2](ch11.xhtml#ch11list2). I’ll
    be referring to the numbered lines in this listing in the next several sections
    of this chapter, through [page 222](ch11.xhtml#page_222).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看编译器生成的汇编语言来看到栈帧是如何创建的，见[列表 11-2](ch11.xhtml#ch11list2)。在本章接下来的几个部分中，我将引用这个列表中的编号行，通过[第222页](ch11.xhtml#page_222)。
- en: '*inc_int.s*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc_int.s*'
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-2: The compiler-generated assembly language for the program in
    [Listing 11-1](ch11.xhtml#ch11list1)*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-2：编译器生成的程序汇编语言，见[列表 11-1](ch11.xhtml#ch11list1)*'
- en: 'The instructions used to create the stack frame form the *function prologue*.
    The first instruction in a function prologue is usually an `stp` instruction:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建栈帧的指令形成了*函数前言*。函数前言中的第一条指令通常是`stp`指令：
- en: stp**—Store register pair**
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: stp**—存储寄存器对**
- en: '`stp w`s1, `w`s2, [`x`b`{,` offset`}]` stores the value in `w`s1 at the address
    in `x`b and the value in `w`s2 at `x`b + 4\. If offset exists, it must be a multiple
    of 4 and is added to the address before storing the register values; `x`b is not
    changed.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`stp w`s1, `w`s2, [`x`b`{,` 偏移量`}]`将`w`s1的值存储在`x`b地址处，将`w`s2的值存储在`x`b + 4的位置。如果存在偏移量，它必须是4的倍数，并且在存储寄存器值之前添加到地址；`x`b不会改变。'
- en: '`stp x`s1, `x`s2 , [`x`b{`,` offset`}]` stores the value in `x`s1 at the address
    in `x`b and the value in `x`s2 at `x`b + 8\. If offset exists, it must be a multiple
    of 8 and is added to the address before storing the register values; `x`b is not
    changed.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`stp x`s1, `x`s2 , [`x`b{`,` 偏移量`}]`将`x`s1的值存储在`x`b地址处，将`x`s2的值存储在`x`b + 8的位置。如果存在偏移量，它必须是8的倍数，并且在存储寄存器值之前添加到地址；`x`b不会改变。'
- en: stp**—Store register pair, pre-index**
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: stp**—存储寄存器对，前索引**
- en: '`stp w`s1, `w`s2, [`x`b`,` offset`]!` adds offset, which must be a multiple
    of 4, to `x`b. It then stores the value in `w`s1 at the new address in `x`b and
    the value in `w`s2 at `x`b + 4.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`stp w`s1, `w`s2, [`x`b`,` 偏移量`]!`将偏移量（必须是4的倍数）加到`x`b。然后它将`w`s1的值存储在`x`b的新地址处，将`w`s2的值存储在`x`b
    + 4的位置。'
- en: '`stp x`s1, `x`s2, [`x`b`,` offset`]!` adds offset, which must be a multiple
    of 8, to `x`b. It then stores the value in `x`s1 at the new address in `x`b and
    the value in `x`s2 at `x`b + 8.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`stp x`s1, `x`s2, [`x`b`,` 偏移量`]!`将偏移量（必须是8的倍数）加到`x`b。然后它将`x`s1的值存储在`x`b的新地址处，将`x`s2的值存储在`x`b
    + 8的位置。'
- en: stp**—Store register pair, post-index**
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: stp**—存储寄存器对，后索引**
- en: '`stp w`s1, `w`s2, [`x`b`],` offset stores the value in `w`s1 at the address
    in `x`b and the value in `w`s2 at `x`b + 4\. It then adds offset, which must be
    a multiple of 4, to `x`b.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`stp w`s1, `w`s2, [`x`b`],` 偏移量将`w`s1的值存储在`x`b地址处，将`w`s2的值存储在`x`b + 4的位置。然后它将偏移量（必须是4的倍数）加到`x`b。'
- en: '`stp x`s1, `x`s2, [`x`b`],` offset stores the value in `x`s1 at the address
    in `x`b and the value in `x`s2 at `x`b + 8\. It then adds offset, which must be
    a multiple of 8, to `x`b.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`stp x`s1, `x`s2, [`x`b`],` 偏移量将`x`s1的值存储在`x`b地址处，将`x`s2的值存储在`x`b + 8的位置。然后它将偏移量（必须是8的倍数）加到`x`b。'
- en: '**NOTE**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The operand order for almost all other A64 instructions is* `destination(s),
    source(s)`, *but for the store instructions, it’s the opposite.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*几乎所有其他A64指令的操作数顺序是* `destination(s), source(s)`，*但是对于存储指令，则是相反的。*'
- en: 'Almost all the functions we’ll write will begin with an `stp` instruction that
    looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写的大多数函数都将以类似这样的`stp`指令开始：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The compiler did this at the beginning of the function in [Listing 11-2](ch11.xhtml#ch11list2),
    creating the stack frame ❸.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在[清单 11-2](ch11.xhtml#ch11list2)中函数的开始处做了这件事，创建了堆栈帧 ❸。
- en: The *Procedure Call Standard for the Arm 64-Bit Architecture (AArch64)* documentation
    (available in PDF and HTML formats at *[https://github.com/ARM-software/abi-aa/releases](https://github.com/ARM-software/abi-aa/releases)*)
    specifies that the *frame pointer* (stored in register `x29`, also named `fp`)
    should point to the top of the stack frame, which is where the calling function’s
    frame pointer is stored. The instruction `mov x29, sp` will set the called function’s
    frame pointer, as shown in [Listing 11-2](ch11.xhtml#ch11list2).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 《*ARM 64位架构过程调用标准 (AArch64)*》文档（可在* [https://github.com/ARM-software/abi-aa/releases](https://github.com/ARM-software/abi-aa/releases)*中以PDF和HTML格式获取）规定，*帧指针*（存储在寄存器`x29`中，也称为`fp`）应该指向堆栈帧的顶部，即调用函数的帧指针所在的位置。指令`mov
    x29, sp`将设置被调用函数的帧指针，如[清单 11-2](ch11.xhtml#ch11list2)所示。
- en: The way the `stp` instruction has specified the stack memory address here, `[sp,
    -32]!`, probably doesn’t make a lot of sense to you. Let’s look at how instructions
    access memory in the A64 architecture.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`stp`指令在此处指定堆栈内存地址的方式，`[sp, -32]!`，可能对你来说没有太多意义。让我们来看一下在A64架构中，指令是如何访问内存的。'
- en: '***A64 Memory Addressing***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***A64 内存寻址***'
- en: 'There are two ways that an instruction might refer to a memory address: the
    address could be encoded as part of the instruction, usually called an *absolute
    address*, or it could use *relative addressing*, where the instruction specifies
    an *offset* from a *base address*. In the latter case, the size of the offset
    and the location of the base address are encoded in the instruction.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可能以两种方式引用内存地址：地址可以作为指令的一部分进行编码，通常称为*绝对地址*，或者它可以使用*相对寻址*，其中指令指定一个*偏移量*，相对于*基地址*。在后一种情况下，偏移量的大小和基地址的位置会被编码在指令中。
- en: All instructions in the A64 architecture are 32 bits long, but addresses are
    64 bits long. We’ll look at the details of the machine code in [Chapter 12](ch12.xhtml),
    but it’s clear that a 64-bit address will not fit within a 32-bit instruction.
    To refer to a 64-bit address, instructions use one of the relative addressing
    modes listed in [Table 11-1](ch11.xhtml#ch11tab1) to compute the address when
    they are executed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: A64架构中的所有指令长度为32位，但地址是64位长的。我们将在[第12章](ch12.xhtml)中详细介绍机器码，但显然，64位地址无法适配32位指令。为了引用64位地址，指令使用[表
    11-1](ch11.xhtml#ch11tab1)中列出的相对寻址模式，在执行时计算地址。
- en: '**Table 11-1:** A64 Addressing Modes'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-1：** A64 寻址模式'
- en: '| **Mode** | **Syntax** | **Note** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **语法** | **备注** |'
- en: '| --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Literal | label | `pc`-relative |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 字面值 | 标签 | `pc`-相对 |'
- en: '| Base register | `[`base`]` | Register only |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 基寄存器 | `[`base`]` | 仅寄存器 |'
- en: '| Base plus offset | `[`base`,` offset`]` | Register-relative |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 基址加偏移 | `[`base`,` offset`]` | 寄存器相对 |'
- en: '| Pre-indexed | `[`base`,` offset`]!` | Add offset to register before |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 预索引 | `[`base`,` offset`]!` | 在寄存器前加偏移 |'
- en: '| Post-indexed | `[`base`],` offset | Add offset to register after |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 后索引 | `[`base`],` offset | 在寄存器后加偏移 |'
- en: Each of the addressing modes in [Table 11-1](ch11.xhtml#ch11tab1) starts with
    a 64-bit address in a *base register*. The literal mode uses pc-*relative addressing*,
    where the program counter serves as the base register. If label is in the same
    section as the instruction that references it, the assembler computes the address
    offset from the referencing instruction to the labeled instruction and fills in
    this offset as part of the referencing instruction. If the label is in another
    section, the linker will compute the offset and fill that in where the label is
    referenced. The number of bits allowed in the instruction limits the size of the
    address offset.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-1](ch11.xhtml#ch11tab1)中的每种寻址方式都以*基寄存器*中的64位地址开始。字面模式使用pc-*相对寻址*，其中程序计数器作为基寄存器。如果标签与引用它的指令位于同一段中，汇编器会计算从引用指令到标签指令的地址偏移量，并将该偏移量填入引用指令中。如果标签位于另一段中，链接器会计算偏移量，并在引用标签的位置填充该偏移量。指令中允许的位数限制了地址偏移量的大小。'
- en: One of the advantages of `pc`-relative addressing is that it gives us *position-independent
    code (PIC)*, which means the function will execute correctly no matter where it
    is loaded into memory. The default for the `gcc` compiler in our environment is
    to produce PIC, with the linking phase producing a *position-independent executable
    (PIE)*. This means the linker doesn’t specify a load address for the program,
    so the operating system can load the program wherever it chooses. Not including
    the load address with the executable file improves security.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`pc`相对寻址的一个优点是它为我们提供了*位置无关代码（PIC）*，这意味着无论函数加载到内存的哪里，它都会正确执行。我们环境中`gcc`编译器的默认设置是生成PIC，链接阶段生成*位置无关可执行文件（PIE）*。这意味着链接器不会为程序指定加载地址，因此操作系统可以将程序加载到任何它选择的位置。这样做的好处是，不包括加载地址在可执行文件中可以提高安全性。'
- en: In the other four modes, the base register is a general-purpose register, `x0`–`x30`,
    or `sp`. For the base-plus-offset mode, the offset can be an immediate value or
    in a register. The offset is sign-extended to 64 bits and added to the value in
    the base register to compute the address. If the offset is in a register, it can
    be scaled so that it is a multiple of the number of bytes being loaded or stored.
    You’ll see how this works when you learn to process integer arrays in [Chapter
    17](ch17.xhtml).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在另外四种模式中，基址寄存器是一个通用寄存器，`x0`–`x30`或`sp`。对于基址加偏移模式，偏移量可以是一个立即数或寄存器中的值。偏移量会被符号扩展到64位，并加到基址寄存器中的值上以计算地址。如果偏移量在寄存器中，它可以被缩放，以使其成为加载或存储字节数的倍数。当你学习如何处理整数数组时，你会看到这一点，在[第17章](ch17.xhtml)中会介绍。
- en: In the pre-indexed mode, the computed address is stored in the base register
    *before* loading or storing the value. In the post-indexed mode, the computed
    address is stored in the base register *after* loading or storing the value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在预索引模式下，计算出的地址会在加载或存储值之前存储到基址寄存器中。而在后索引模式下，计算出的地址会在加载或存储值之后存储到基址寄存器中。
- en: For the pre-indexed mode, the offset can only be an immediate value. The post-indexed
    mode allows an immediate value for the offset or, for some advanced programming
    techniques, an offset value in a register.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预索引模式，偏移量只能是一个立即数。后索引模式允许偏移量是一个立即数，或者对于一些高级编程技巧，偏移量可以是寄存器中的值。
- en: The call stack in our environment is full-descending (see [Figure 11-3](ch11.xhtml#ch11fig3)),
    so the `stp` instruction uses the pre-indexed addressing mode. In the function
    in [Listing 11-2](ch11.xhtml#ch11list2), the address is specified as `[sp, -32]!`
    ❸. This subtracts 32 from the stack pointer *before* storing the caller’s frame
    pointer and return address on the stack. This effectively allocates 16 bytes on
    the stack for this function’s use, then pushes the return address and the caller’s
    frame pointer onto the call stack. The number of bytes allocated for the stack
    frame must always be a multiple of 16 because the stack pointer, `sp`, must always
    be aligned on a 16-byte address boundary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们环境中的调用栈是全下降式的（见[图11-3](ch11.xhtml#ch11fig3)），因此`stp`指令使用预索引寻址模式。在[清单11-2](ch11.xhtml#ch11list2)中的函数中，地址指定为`[sp,
    -32]!` ❸。这会在将调用者的帧指针和返回地址存储到栈上之前，先将32从栈指针中减去。这实际上为该函数分配了16字节的栈空间，然后将返回地址和调用者的帧指针压入调用栈。栈帧分配的字节数必须始终是16的倍数，因为栈指针`sp`必须始终对齐到16字节的地址边界。
- en: 'After the function has completed its processing, we need a *function epilogue*
    to restore the caller’s frame pointer and link register and to delete the stack
    frame. In the function in [Listing 11-2](ch11.xhtml#ch11list2), this is done with
    the following instruction:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数完成其处理后，我们需要一个*函数尾部*来恢复调用者的帧指针和链接寄存器，并删除栈帧。在[清单11-2](ch11.xhtml#ch11list2)中的函数，通过以下指令完成这一操作：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This instruction loads the two values at the top of the stack into the frame
    pointer and link register, then adds 32 to the stack pointer ❽. This effectively
    pops the two values off the top of the stack into the `x29` and `x30` registers
    and then deletes this function’s stack frame. Let’s look at some variants of the
    `ldp` instruction, which allows us to load two values at a time from memory:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将栈顶的两个值加载到帧指针和链接寄存器中，然后将栈指针加32❽。这实际上将栈顶的两个值弹出到`x29`和`x30`寄存器中，然后删除该函数的栈帧。让我们来看一下`ldp`指令的一些变种，它允许我们一次从内存中加载两个值：
- en: ldp**—Load register pair**
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ldp**—加载寄存器对**
- en: '`ldp w`d1, `w`d2, `[x`b`{,` offset`}]` loads the value at the address in `x`b
    into `w`d1 and the value at `x`b + 4 into `w`d2. If offset exists, it must be
    a multiple of 4 and is added to the address before loading the values; `x`b is
    not changed.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldp w`d1, `w`d2, `[x`b`{,` offset`}]` 会将`x`b地址处的值加载到`w`d1中，并将`x`b + 4处的值加载到`w`d2中。如果偏移量存在，它必须是4的倍数，并在加载值之前加到地址上；`x`b本身不会改变。'
- en: '`ldp x`d1, `x`d2, [`x`b`{,` offset`}]` loads the value at the address in `x`b
    into `x`d1 and the value at `x`b + 8 into `x`d2. If offset exists, it must be
    a multiple of 8 and is added to the address before loading the values; `x`b is
    not changed.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldp x`d1, `x`d2, [`x`b`{,` offset`}]` 会将`x`b地址处的值加载到`x`d1中，并将`x`b + 8处的值加载到`x`d2中。如果偏移量存在，它必须是8的倍数，并在加载值之前加到地址上；`x`b本身不会改变。'
- en: ldp**—Load register pair, pre-index**
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ldp**—加载寄存器对，预索引**
- en: '`ldp w`d1, `w`d2, `[x`b, offset`]!` adds offset, which must be a multiple of
    4, to `x`b. It then loads the value at the new address in `x`b into `w`d1 and
    the value at `x`b + 4 into `w`d2.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldp w`d1, `w`d2, `[x`b, offset`]!` 会将偏移量（必须是4的倍数）加到`x`b。接着，它会将新的`x`b地址处的值加载到`w`d1中，并将`x`b
    + 4处的值加载到`w`d2中。'
- en: '`ldp x`d1, `x`d2, [`x`b`,` offset`]!` adds offset, which must be a multiple
    of 8, to `x`b. It then loads the value at the new address in `x`b into `x`d1 and
    the value at `x`b + 8 into `x`d2.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldp x`d1, `x`d2, [`x`b`,` offset`]!` 会将偏移量（必须是8的倍数）加到`x`b。接着，它会将新的`x`b地址处的值加载到`x`d1中，并将`x`b
    + 8处的值加载到`x`d2中。'
- en: ldp**—Load register pair, post-index**
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ldp**—加载寄存器对，后索引**
- en: '`ldp w`d1, `w`d2, [`x`b`],` offset loads the value at the address in `x`b into
    `w`d1 and the value at `x`b + 4 into `w`d2. It then adds offset, which must be
    a multiple of 4, to `x`b.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldp w`d1, `w`d2, [`x`b`],` 偏移量会将`x`b地址处的值加载到`w`d1中，并将`x`b + 4处的值加载到`w`d2中。接着，它会将偏移量（必须是4的倍数）加到`x`b。'
- en: '`ldp x`d1, `x`d2, [`x`b`],` offset loads the value at the address in `x`b into
    `x`d1 and the value at `x`b + 8 into `x`d2. It then adds offset, which must be
    a multiple of 8, to `x`b.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldp x`d1, `x`d2, [`x`b`],` 偏移量会将`x`b地址处的值加载到`x`d1中，并将`x`b + 8处的值加载到`x`d2中。接着，它会将偏移量（必须是8的倍数）加到`x`b。'
- en: Next, we’ll see how this function uses the other 16 bytes of stack memory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到该函数如何使用栈内存中的其他16字节。
- en: '***Local Variables on the Call Stack***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用栈中的局部变量***'
- en: Local variables in C can be directly accessed by their names only in the function
    where they’re defined. We can allow another function to access a local variable
    in our function, including changing its value, by passing the address of that
    variable to the other function. This is what enables `scanf` to store a value
    for `x`, as you’ll see on [page 221](ch11.xhtml#commonL2).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的局部变量只能在定义它们的函数中通过名称直接访问。我们可以通过将该变量的地址传递给另一个函数，来允许其他函数访问我们函数中的局部变量，包括修改其值。这就是`scanf`能够为`x`存储值的原因，你将在[第221页](ch11.xhtml#commonL2)看到这一点。
- en: You learned in [Chapter 9](ch09.xhtml) that CPU registers can be used as variables.
    But if we were to use CPU registers to hold all of our variables, we’d soon run
    out of registers, even in a small program. So, we need to allocate space in memory
    for variables.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第9章](ch09.xhtml)中学到过CPU寄存器可以作为变量使用。但如果我们将所有的变量都存储在CPU寄存器中，即使是一个小程序，也很快就会用完寄存器。因此，我们需要在内存中为变量分配空间。
- en: As we’ll see later in this chapter, a function needs to preserve the contents
    of some registers for the calling function. If we want to use such a register
    in our function, a local variable would be a good place to store a copy of its
    content so we can restore it before returning to the calling function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章后续所示，函数需要保存一些寄存器的内容，以便调用函数使用。如果我们想在自己的函数中使用这样的寄存器，将它的内容存储到一个局部变量中是一个不错的选择，这样在返回调用函数之前我们可以恢复它。
- en: 'The stack frame meets the requirements of local variables. It’s created when
    the function first starts, and it’s deleted once the function completes. The memory
    in a stack frame is easily accessed using the base-plus-offset addressing mode
    (see [Table 11-1](ch11.xhtml#ch11tab1)), with `sp` as the base addressing register.
    An example in [Listing 11-2](ch11.xhtml#ch11list2) is where we load the integer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 栈帧满足局部变量的要求。它在函数首次开始时创建，在函数完成时删除。栈帧中的内存可以通过基址加偏移寻址模式轻松访问（参见[表11-1](ch11.xhtml#ch11tab1)），`sp`作为基址寄存器。在[清单11-2](ch11.xhtml#ch11list2)中有一个例子，我们在其中加载整数：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This instruction loads the 32-bit word located 28 bytes from the address in
    `sp` into `w0` ❻. The function treats its stack frame as a record rather than
    a stack with this code. You’ll learn about records in [Chapter 17](ch17.xhtml).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将位于 `sp` 地址偏移 28 字节处的 32 位字加载到 `w0` ❻ 中。该函数将其堆栈帧视为记录，而非堆栈，使用此代码。你将在 [第 17
    章](ch17.xhtml) 中学习关于记录的内容。
- en: '[Figure 11-4](ch11.xhtml#ch11fig4) gives a pictorial view of the completed
    stack frame for the `main` function in [Listings 11-1](ch11.xhtml#ch11list1) and
    [11-2](ch11.xhtml#ch11list2).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-4](ch11.xhtml#ch11fig4) 给出了 [列表 11-1](ch11.xhtml#ch11list1) 和 [11-2](ch11.xhtml#ch11list2)
    中 `main` 函数完成的堆栈帧的示意图。'
- en: '![image](../images/pg244_Image_258.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg244_Image_258.jpg)'
- en: '*Figure 11-4: The stack frame for the function in [Listings 11-1](ch11.xhtml#ch11list1)
    and [11-2](ch11.xhtml#ch11list2)*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4： [列表 11-1](ch11.xhtml#ch11list1) 和 [11-2](ch11.xhtml#ch11list2) 中函数的堆栈帧*'
- en: The two addresses on the stack each take 8 bytes, and the `int` variable, `x`,
    takes 4 bytes. The memory in the gray area is unused but necessary for keeping
    the stack pointer, `sp`, aligned on a 16-byte address boundary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈上的两个地址各占 8 字节，而 `int` 变量 `x` 占 4 字节。灰色区域中的内存未使用，但对于保持堆栈指针 `sp` 在 16 字节地址边界上对齐是必要的。
- en: Now that you know how to use a stack frame, let’s look at how this function
    processes data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用堆栈帧了，我们来看一下这个函数是如何处理数据的。
- en: '**Processing Data in a Function**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数中的数据处理**'
- en: A64 is a *load–store architecture*, which means the instructions that operate
    on data cannot access memory. There is a separate group of instructions for moving
    data to and from memory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: A64 是一种*加载–存储架构*，这意味着操作数据的指令不能访问内存。对于数据在内存之间的移动，有一组单独的指令。
- en: This is in contrast to a *register–memory architecture*, which includes instructions
    that can operate on data in memory. The data operations are still performed by
    the arithmetic/logic unit in the CPU (see [Figure 9-1](ch09.xhtml#ch9fig1)), but
    they use registers that are hidden from the programmer. The Intel x86 is an example
    of a register–memory architecture.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*寄存器–内存架构*相对，后者包含能够操作内存中数据的指令。数据操作仍然由 CPU 的算术/逻辑单元执行（参见 [图 9-1](ch09.xhtml#ch9fig1)），但它们使用的寄存器对程序员是隐藏的。Intel
    x86 就是寄存器–内存架构的一个例子。
- en: 'The processing in the `main` function in [Listing 11-2](ch11.xhtml#ch11list2)
    is very simple: the program adds 1 to an integer. But before it can perform this
    operation, it needs to load the value into a register using the `ldr` instruction
    ❻. Since this program changes the value in the variable, the new value must be
    stored back into memory with the `str` instruction ❼.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 11-2](ch11.xhtml#ch11list2) 中的 `main` 函数的处理非常简单：程序将 1 加到一个整数上。但在执行此操作之前，它需要通过
    `ldr` 指令 ❻ 将值加载到寄存器中。由于该程序会改变变量中的值，因此新的值必须通过 `str` 指令 ❼ 存回内存。
- en: 'Let’s look at some common instructions used for loading values from memory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常用的指令，用于从内存加载值：
- en: ldr**—Load register,** pc**-relative**
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ldr**—加载寄存器，** pc**相对**
- en: '`ldr w`d`,` addr loads `w`d with the 32-bit value at memory location addr,
    which must be ±1MB from this instruction. Bits 63 to 32 of `x`d are set to `0`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr w`d, `addr` 将 `w`d 加载为位于地址 `addr` 处的 32 位值，该地址必须与此指令的地址 ±1MB 之内。`x`d 的位
    63 到 32 被设置为 `0`。'
- en: '`ldr x`d`,` addr loads `x`d with the 64-bit value at memory location addr,
    which must be ±1MB from this instruction.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr x`d, `addr` 将 `x`d 加载为位于地址 `addr` 处的 64 位值，该地址必须与此指令的地址 ±1MB 之内。'
- en: ldr**—Load register, base register–relative**
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ldr**—加载寄存器，基址寄存器相对**
- en: '`ldr w`d, `[x`b`{,` offset`}]` loads `w`d with the 32-bit value at the memory
    location obtained by adding the address in `x`b and the optional offset, which
    is a multiple of 4 in the range 0 to 16,380\. Bits 63 to 32 of `x`d are set to
    `0`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr w`d, `[x`b`{,` offset`}]` 将 `w`d 加载为通过将 `x`b 中的地址与可选偏移（该偏移量是 4 的倍数，范围为
    0 到 16,380）相加得到的内存位置中的 32 位值。`x`d 的位 63 到 32 被设置为 `0`。'
- en: '`ldr x`d, `[x`b`{,` offset`}]` loads `x`d with the 64-bit value at the memory
    location obtained by adding the address in `x`b and the optional offset, which
    is a multiple of 8 in the range 0 to 32,760.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr x`d, `[x`b`{,` offset`}]` 将 `x`d 加载为通过将 `x`b 中的地址与可选偏移（该偏移量是 8 的倍数，范围为
    0 到 32,760）相加得到的内存位置中的 64 位值。'
- en: ldrsw**—Load register, signed word, base register–relative**
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ldrsw**—加载寄存器，带符号字，基址寄存器相对**
- en: '`ldrsw w`d, `[x`b`{,` offset`}]` loads `w`d with the 32-bit value at the memory
    location obtained by adding the address in `x`b and the optional offset, which
    is a multiple of 4 in the range 0 to 16,380\. Bits 63 to 32 of `x`d are set to
    a copy of bit 31 of the loaded word.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldrsw w`d, `[x`b`{,` offset`}]` 将 `w`d 加载为位于内存位置的 32 位值，该位置是通过将 `x`b 中的地址与可选的偏移量相加得到的，偏移量是
    4 的倍数，范围是 0 到 16,380。`x`d 的第 63 位到第 32 位被设置为加载字的第 31 位副本。'
- en: ldrb**—Load register, unsigned byte, base register–relative**
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ldrb**—加载寄存器，无符号字节，基寄存器相对**
- en: '`ldrb w`d, `[x`b`{,` offset`}]` loads the low-order byte of `w`d with the 8-bit
    value at the memory location obtained by adding the address in `x`b and the optional
    offset, which is in the range 0 to 4,095\. Bits 31 to 8 of `x`d are set to `0`;
    bits 63 to 32 are unchanged.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldrb w`d, `[x`b`{,` offset`}]` 将 `w`d 的低位字节加载为位于内存位置的 8 位值，该位置是通过将 `x`b 中的地址与可选的偏移量相加得到的，偏移量的范围是
    0 到 4,095。`x`d 的第 31 位到第 8 位被设置为 `0`；第 63 位到第 32 位不变。'
- en: ldrsb**—Load register, signed byte, base register–relative**
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ldrsb**—加载寄存器，带符号字节，基寄存器相对**
- en: '`ldrsb w`d, `[x`b`{,` offset`}]` loads the low-order byte of `w`d with the
    8-bit value at the memory location obtained by adding the address in `x`b and
    the optional offset, which is in the range 0 to 4,095\. Bits 31 to 8 of `x`d are
    set to a copy of bit 7 of the loaded byte; bits 63 to 32 are unchanged.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldrsb w`d, `[x`b`{,` offset`}]` 将 `w`d 的低位字节加载为位于内存位置的 8 位值，该位置是通过将 `x`b 中的地址与可选的偏移量相加得到的，偏移量的范围是
    0 到 4,095。`x`d 的第 31 位到第 8 位被设置为加载字节的第 7 位副本；第 63 位到第 32 位不变。'
- en: 'Here are some similar instructions for storing values in memory:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于将值存储到内存中的类似指令：
- en: str**—Store register,** pc**-relative**
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: str**—存储寄存器，pc 相对**
- en: '`str w`s`,` addr stores the 32-bit value in `w`s at memory location addr, which
    must be ±1MB from this instruction.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`str w`s, addr` 将 `w`s 中的 32 位值存储到地址为 addr 的内存位置，该位置必须与此指令相差 ±1MB。'
- en: '`str x`s`,` addr stores the 64-bit value in `x`s at memory location addr, which
    must be ±1MB from this instruction.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`str x`s, addr` 将 `x`s 中的 64 位值存储到内存位置 addr，该位置必须与此指令相差 ±1MB。'
- en: str**—Store register, base register–relative**
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: str**—存储寄存器，基寄存器相对**
- en: '`str w`s, `[x`b`{,` offset`}]` stores the 32-bit value in `w`s at the memory
    location obtained by adding the address in `x`b and the optional offset, which
    is a multiple of 4 in the range 0 to 16,380.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`str w`s, `[x`b`{,` offset`}]` 将 `w`s 中的 32 位值存储到内存位置，该位置是通过将 `x`b 中的地址与可选的偏移量相加得到的，偏移量是
    4 的倍数，范围是 0 到 16,380。'
- en: '`str x`s, `[x`b`{,` offset`}]` stores the 64-bit value in `x`s at the memory
    location obtained by adding the address in `x`b and the optional offset, which
    is a multiple of 8 in the range 0 to 32,670.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`str x`s, `[x`b`{,` offset`}]` 将 `x`s 中的 64 位值存储到内存位置，该位置是通过将 `x`b 中的地址与可选的偏移量相加得到的，偏移量是
    8 的倍数，范围是 0 到 32,670。'
- en: strb**—Store register, byte, base register–relative**
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: strb**—存储寄存器，字节，基寄存器相对**
- en: '`strb w`s, `[x`b`{,` offset`}]` stores the low-order 8 bits in `w`s at the
    memory location obtained by adding the address in `x`b and the optional offset,
    which is in the range 0 to 4,095.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`strb w`s, `[x`b`{,` offset`}]` 将低位 8 位的值存储在 `w`s 中，存储位置是通过将 `x`b 中的地址与可选的偏移量相加得到的，偏移量的范围是
    0 到 4,095。'
- en: 'The program simply adds 1 to the variable, which can be done with the `add`
    instruction. I’ll include the `sub` instruction here because it’s very similar,
    but I’ll give only some basic syntax (both instructions have several options,
    which are described in the manuals):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 程序简单地将 1 加到变量上，这可以通过 `add` 指令完成。我这里会提到 `sub` 指令，因为它与之非常相似，但只会给出一些基本语法（这两条指令有多个选项，具体内容可以在手册中找到）：
- en: add**—Add extended register**
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: add**—扩展寄存器加法**
- en: '`add w`d, `w`s1, `w`s2`{,` xtnd amnt`}` adds the values in `w`s1 and `w`s2
    and stores the result in `w`d. The value added from `w`s2 can be a byte, halfword,
    word, or doubleword. It can be sign- or zero-extended and then left-shifted 0
    to 4 bits before the addition, using the xtnd amnt option.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`add w`d, `w`s1, `w`s2`{,` xtnd amnt`}` 将 `w`s1 和 `w`s2 中的值相加，并将结果存储在 `w`d
    中。从 `w`s2 加的值可以是字节、半字、字或双字。它可以进行符号扩展或零扩展，然后在加法之前左移 0 到 4 位，使用 xtnd amnt 选项。'
- en: '`add x`d, `x`s1, `x`s2`{,` xtnd amnt`}` adds the values in `x`s1 and `x`s2
    and stores the result in `x`d. The value added from `x`s2 can be a byte, halfword,
    word, or doubleword. It can be sign- or zero-extended and then left-shifted 0
    to 4 bits before the addition, using the xtnd amnt option.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`add x`d, `x`s1, `x`s2`{,` xtnd amnt`}` 将 `x`s1 和 `x`s2 中的值相加，并将结果存储在 `x`d
    中。从 `x`s2 加的值可以是字节、半字、字或双字。它可以进行符号扩展或零扩展，然后在加法之前左移 0 到 4 位，使用 xtnd amnt 选项。'
- en: add**—Add immediate**
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: add**—加法立即数**
- en: '`add w`d, `w`s`,` imm`{,` shft`}` adds imm to the value in `w`s and stores
    the result in `w`d. The imm operand is an unsigned integer in the range 0 to 4,095,
    which can be left-shifted 0 or 12 bits before the addition, using the shft option.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`add w`d, `w`s`,` imm`{,` shft`}` 将 imm 加到 `w`s 的值中，并将结果存储在 `w`d 中。imm 操作数是一个无符号整数，范围从
    0 到 4,095，在加法前可以使用 shft 选项将其左移 0 或 12 位。'
- en: '`add x`d, `x`s`,` imm`{,` shft`}` adds imm to the value in `x`s and stores
    the result in `x`d. The imm operand is an unsigned integer in the range 0 to 4,095,
    which can be left-shifted 0 or 12 bits before the addition, using the shft option.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`add x`d, `x`s`,` imm`{,` shft`}` 将 imm 加到 `x`s 的值中，并将结果存储在 `x`d 中。imm 操作数是一个无符号整数，范围从
    0 到 4,095，在加法前可以使用 shft 选项将其左移 0 或 12 位。'
- en: sub**—Subtract extended register**
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: sub**—减法扩展寄存器**
- en: '`sub w`d, `w`s1, `w`s2`{,` xtnd amnt`}` subtracts the value in `w`s2 from `w`s1
    and stores the result in `w`d. The value subtracted from `w`s2 can be a byte,
    halfword, word, or doubleword. It can be sign- or zero-extended and then left-shifted
    0 to 4 bits before the subtraction, using the xtnd amnt option.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub w`d, `w`s1, `w`s2`{,` xtnd amnt`}` 从 `w`s2 中减去 `w`s1 的值，并将结果存储在 `w`d 中。要从
    `w`s2 中减去的值可以是字节、半字、字或双字。它可以是符号扩展或零扩展，然后在减法前使用 xtnd amnt 选项将其左移 0 到 4 位。'
- en: '`sub x`d, `x`s1, `x`s2`{,` xtnd amnt`}` subtracts the value in `x`s2 from `x`s1
    and stores the result in `x`d. The value subtracted from `x`s2 can be a byte,
    halfword, word, or doubleword. It can be sign- or zero-extended and then left-shifted
    0 to 4 bits before the subtraction, using the xtnd amnt option.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub x`d, `x`s1, `x`s2`{,` xtnd amnt`}` 从 `x`s2 中减去 `x`s1 的值，并将结果存储在 `x`d 中。要从
    `x`s2 中减去的值可以是字节、半字、字或双字。它可以是符号扩展或零扩展，然后在减法前使用 xtnd amnt 选项将其左移 0 到 4 位。'
- en: sub**—Subtract immediate**
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: sub**—减法立即数**
- en: '`sub w`d, `w`s`,` imm`{,` shft`}` subtracts imm from the value in `w`s and
    stores the result in `w`d. The imm operand is an unsigned integer in the range
    0 to 4,095, which can be left-shifted 0 or 12 bits before the subtraction, using
    the shft option.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub w`d, `w`s`,` imm`{,` shft`}` 从 `w`s 中减去 imm，并将结果存储在 `w`d 中。imm 操作数是一个无符号整数，范围从
    0 到 4,095，在减法前可以使用 shft 选项将其左移 0 或 12 位。'
- en: '`sub x`d, `x`s`,` imm`{,` shft`}` subtracts imm from the value in `x`s and
    stores the result in `x`d. The imm operand is an unsigned integer in the range
    0 to 4,095, which can be left-shifted 0 or 12 bits before the subtraction, using
    the shft option.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub x`d, `x`s`,` imm`{,` shft`}` 从 `x`s 中减去 imm，并将结果存储在 `x`d 中。imm 操作数是一个无符号整数，范围从
    0 到 4,095，在减法前可以使用 shft 选项将其左移 0 或 12 位。'
- en: '[Table 11-2](ch11.xhtml#ch11tab2) lists the allowable values for the xtnd option
    in the `add` and `sub` instructions.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-2](ch11.xhtml#ch11tab2) 列出了 `add` 和 `sub` 指令中 xtnd 选项的允许值。'
- en: '**Table 11-2:** Allowable Values for xtnd in `add` and `sub` Instructions'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-2：** `add` 和 `sub` 指令中 xtnd 的允许值'
- en: '| xtnd | **Effect** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| xtnd | **效果** |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `uxtb` | Unsigned extension of byte |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `uxtb` | 无符号扩展字节 |'
- en: '| `uxth` | Unsigned extension of halfword |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `uxth` | 无符号扩展半字 |'
- en: '| `uxtw` | Unsigned extension of word |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `uxtw` | 无符号扩展字 |'
- en: '| `uxtx` | Unsigned extension of doubleword |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `uxtx` | 无符号扩展双字 |'
- en: '| `sxtb` | Signed extension of byte |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `sxtb` | 带符号扩展字节 |'
- en: '| `sxth` | Signed extension of halfword |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `sxth` | 带符号扩展半字 |'
- en: '| `sxtw` | Signed extension of word |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `sxtw` | 带符号扩展字 |'
- en: '| `sxtx` | Signed extension of doubleword |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `sxtx` | 双字的带符号扩展 |'
- en: The extension begins with the indicated low-order portion of the source register
    and adds bits to the left to match the width of the other registers in the instruction.
    For unsigned extension, the added bits are all `0`. For signed extension, the
    added bits are copies of the highest-order bit of the starting value. When using
    `w` registers, `uxtw` can be replaced with `lsl`; with `x` registers, `uxtx` can
    be replaced with `lsl`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展从源寄存器的指定位开始，向左添加位以匹配指令中其他寄存器的宽度。对于无符号扩展，添加的位全是 `0`。对于符号扩展，添加的位是起始值的最高位的副本。在使用
    `w` 寄存器时，`uxtw` 可以替换为 `lsl`；在使用 `x` 寄存器时，`uxtx` 可以替换为 `lsl`。
- en: It might seem meaningless to extend a doubleword, which is already 64 bits wide,
    to match the size of an `x` register, but the instruction syntax requires that
    we use the entire xtnd amnt option if we wish to shift the value.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展一个已经是 64 位宽的双字，以匹配 `x` 寄存器的大小，可能看起来没有意义，但指令语法要求我们在希望移位时使用整个 xtnd amnt 选项。
- en: 'As an example of how these size extensions work, let’s start with the following
    values in `x2` and `x3`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `x2` 和 `x3` 中的以下值为例，演示这些大小扩展的工作原理：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The instruction sequence
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 指令序列
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'gives:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 给出：
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ll see other instructions that use these width extensions as we continue
    through the book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 随着书中的进展，我们将看到其他使用这些宽度扩展的指令。
- en: Now that you know how to do the arithmetic, let’s look at how to call the other
    functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何进行算术运算了，让我们看看如何调用其他函数。
- en: '**Passing Arguments in Registers**'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过寄存器传递参数**'
- en: There are several ways for a function to pass arguments to another function.
    I’ll start by describing how to use registers for passing arguments. I’ll discuss
    other ways when I cover subfunctions in more detail in [Chapter 14](ch14.xhtml).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 函数传递参数给另一个函数有几种方法。我将首先介绍如何使用寄存器传递参数。在[第14章](ch14.xhtml)更详细讲解子函数时，我将讨论其他方法。
- en: Recall from [Chapter 2](ch02.xhtml) that when a function calls another function,
    it can pass arguments that the called function can use as parameters. In principle,
    the C compiler—or you, when you’re writing in assembly language—could use any
    of the 31 general-purpose registers, except the link register, `x30`, to pass
    arguments from one function to another. Just store the arguments in the registers
    and call the desired function. Of course, the calling and called functions need
    to agree on exactly which register each argument is in.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在[第2章](ch02.xhtml)中提到的，当一个函数调用另一个函数时，它可以传递被调用函数作为参数使用的参数。原则上，C编译器—或者你在编写汇编语言时—可以使用31个通用寄存器中的任何一个，除了链接寄存器`x30`，来在函数之间传递参数。只需将参数存储在寄存器中，然后调用所需的函数。当然，调用函数和被调用函数需要就每个参数所在的寄存器达成一致。
- en: The best way to avoid making mistakes is to follow a standard set of rules.
    This is especially important if more than one person is writing code for a program.
    Other people have realized the importance of having such standards and have developed
    an *application binary interface (ABI)* that includes a set of standards for passing
    arguments in the A64 architecture. The compiler we’re using, `gcc`, follows the
    rules in the *Procedure Call Standard for the Arm 64-Bit Architecture* (referenced
    on [page 213](ch11.xhtml#commonL3)), and we’ll do the same for the assembly language
    we write.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 避免犯错的最佳方法是遵循一套标准规则。这一点尤其重要，如果有多人为同一个程序编写代码。其他人已经意识到拥有这种标准的重要性，并开发了一个*应用二进制接口（ABI）*，其中包括一套用于在A64架构中传递参数的标准。我们使用的编译器`gcc`遵循*Arm
    64位架构的过程调用标准*（请参见[第213页](ch11.xhtml#commonL3)），我们在编写汇编语言时也将遵循这些规则。
- en: '[Table 11-3](ch11.xhtml#ch11tab3) summarizes the standards for how the called
    function uses the registers.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[表11-3](ch11.xhtml#ch11tab3)总结了被调用函数如何使用寄存器的标准。'
- en: '**Table 11-3:** General-Purpose Register Usage'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**表11-3：** 通用寄存器的使用'
- en: '| **Register** | **Usage** | **Save?** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器** | **用途** | **是否保存？** |'
- en: '| --- | --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x0`–`x7` | Parameter; result | No |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `x0`–`x7` | 参数；结果 | 否 |'
- en: '| `x8` | Address of result | No |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `x8` | 结果地址 | 否 |'
- en: '| `x9`–`x18` | Scratch | No |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `x9`–`x18` | 临时寄存器 | 否 |'
- en: '| `x19`–`x28` | Variables | Yes |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `x19`–`x28` | 变量 | 是 |'
- en: '| `x29` | Frame pointer | Yes |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `x29` | 帧指针 | 是 |'
- en: '| `x30` | Link register | Yes |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `x30` | 链接寄存器 | 是 |'
- en: '| `sp` | Stack pointer | Yes |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `sp` | 栈指针 | 是 |'
- en: '| `xzr` | Zero register | N/A |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `xzr` | 零寄存器 | 不适用 |'
- en: We would use `w`n instead of `x`n for 32-bit register names. We’re using 64-bit
    addressing in this book. Because `x29` and `x30` will always contain addresses,
    we’ll never use `w29` or `w30`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`w`n代替`x`n来表示32位寄存器名称。本书中使用的是64位寻址。由于`x29`和`x30`将始终包含地址，因此我们永远不会使用`w29`或`w30`。
- en: The “Save?” column shows whether a called function needs to preserve the value
    in that register for the calling function. If we need to use a register that must
    be preserved, we’ll create a local variable in our stack frame for that purpose.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: “是否保存？”列显示被调用函数是否需要保留该寄存器中的值以供调用函数使用。如果我们需要使用必须保留的寄存器，我们将在栈帧中为此创建一个局部变量。
- en: The calling function passes the arguments in the registers in the order in which
    they’re listed, from left to right in a C function, starting with `x0` (or `w0`
    for a 32-bit value). This allows for the passing of up to eight arguments, `x0`–`x7`.
    You’ll see how to use the call stack to pass more than eight arguments in [Chapter
    14](ch14.xhtml).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数按从左到右的顺序在寄存器中传递参数，从`x0`开始（对于32位值为`w0`）。这允许传递最多八个参数，`x0`–`x7`。你将在[第14章](ch14.xhtml)中看到如何使用调用栈传递超过八个参数。
- en: 'For an example of how to pass arguments, let’s look at the call to `scanf`
    in [Listing 11-1](ch11.xhtml#ch11list1):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以如何传递参数为例，让我们看看在[示例11-1](ch11.xhtml#ch11list1)中调用`scanf`的情况：
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s start with the second argument, the address of `x`. In [Figure 11-4](ch11.xhtml#ch11fig4),
    `x` is located at an offset of 28 bytes from the stack pointer, `sp`. Looking
    at the assembly language generated by the compiler in [Listing 11-2](ch11.xhtml#ch11list2),
    you can see that computing the address can be done by adding 28 to `sp` ❹. Since
    it’s the second argument, it needs to be moved to `x1`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第二个参数开始，`x` 的地址。在 [图 11-4](ch11.xhtml#ch11fig4) 中，`x` 位于栈指针 `sp` 偏移量 28
    字节的位置。从编译器生成的汇编语言中可以看到，在 [清单 11-2](ch11.xhtml#ch11list2) 中，计算该地址可以通过将 28 加到 `sp`
    ❹ 来完成。由于这是第二个参数，它需要移动到 `x1`。
- en: 'The first argument—the text string `"%i"`, which is created with a `.string`
    assembler directive ❷—is more complex. The general format for the `.string` directive
    is:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数——文本字符串 `"%i"`，它是通过 `.string` 汇编指令 ❷ 创建的——比较复杂。`.string` 指令的通用格式是：
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This creates a C-style text string as a `char` array with one byte for each
    character code point in text, plus one byte for the terminating `NUL` character.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个 C 风格的文本字符串，作为一个 `char` 数组，每个字符代码点占用一个字节，再加上一个字节用于终止的 `NUL` 字符。
- en: The compiler places the three text strings in this program in the `.rodata`
    section ❶ of the object file. The loader/linker typically loads `.rodata` sections
    into the `text` segment following the executable code. Notice that each text string
    is aligned to an 8-byte (64 bits) address boundary with a `.align 3` directive.
    This might make the code execute a little faster.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将程序中的三个文本字符串放置在目标文件的 `.rodata` 区段 ❶ 中。加载器/链接器通常将 `.rodata` 区段加载到执行代码后的 `text`
    段中。注意，每个文本字符串都按 8 字节（64 位）对齐，通过 `.align 3` 指令来实现。这可能使得代码执行得稍微更快。
- en: 'When you pass an array to a function in C, only the address of the first element
    in the array gets passed. So, the address of the first character of `"%i"` is
    passed to `scanf`. The A64 architecture provides two instructions for getting
    an address into a register:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 C 中将一个数组传递给函数时，只有数组第一个元素的地址会被传递。所以，`"%i"` 的第一个字符的地址会被传递给 `scanf`。A64 架构提供了两条指令来将地址加载到寄存器中：
- en: adr**—Address**
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: adr**—地址**
- en: '`adr x`d`,` addr loads the memory address addr into `x`d; addr must be within
    ±1MB of this instruction.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`adr x`d`,` addr 将内存地址 addr 加载到 `x`d 中；addr 必须在 ±1MB 范围内。'
- en: adrp**—Address page**
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: adrp**—地址页面**
- en: '`adrp x`d`,` addr loads the page address of addr into bits 63 to 12 of `x`d,
    with bits 11 to 0 set to `0`. The page address is the next-lower 4KB address boundary
    of addr, and addr must be within ±4GB of this instruction.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`adrp x`d`,` addr 将 addr 的页面地址加载到 `x`d 的第 63 至 12 位中，低 12 位设为 `0`。页面地址是 addr
    的下一个较低的 4KB 地址边界，并且 addr 必须在 ±4GB 范围内。'
- en: Both instructions use the literal addressing mode (see [Table 11-1](ch11.xhtml#ch11tab1))
    to refer to a memory address. They each allow a 21-bit offset value, hence the
    ±1MB range for `adr`. With `0`s in the low-order 12 bits, the `adrp` instruction
    gives a 33-bit offset from the `pc`, for an addressing range of ±4GB from the
    `pc`, but with 4KB granularity.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 两条指令都使用字面寻址模式（见 [表 11-1](ch11.xhtml#ch11tab1)）来引用内存地址。它们每条指令都允许一个 21 位的偏移量值，因此
    `adr` 的范围为 ±1MB。由于低 12 位为 0，`adrp` 指令从 `pc` 给出了一个 33 位的偏移量，因此从 `pc` 的寻址范围为 ±4GB，但具有
    4KB 的粒度。
- en: The `adrp` instruction effectively treats memory as being divided into 4KB *pages*.
    (These pages are conceptually distinct from the memory pages that the operating
    system uses to manage main memory.) It loads the beginning address of a 4KB page,
    the *page address*, into the destination register. Compared to the `adr` instruction,
    this increases the range of addresses we can load into a register from ±1MB to
    ±4GB, but we still need to add the offset within the 4KB page to the page address
    in the register.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`adrp` 指令有效地将内存视为被分成 4KB *页面*。（这些页面在概念上与操作系统用来管理主内存的内存页面是不同的。）它将 4KB 页面开始的地址，即
    *页面地址*，加载到目标寄存器中。与 `adr` 指令相比，这增加了我们可以加载到寄存器中的地址范围，从 ±1MB 增加到 ±4GB，但我们仍然需要将 4KB
    页面内的偏移量加到寄存器中的页面地址上。'
- en: 'Thus, we can load a 64-bit address located within ±4GB with a two-instruction
    sequence. The compiler did this in [Listing 11-2](ch11.xhtml#ch11list2) using
    the following code ❺:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过两条指令的序列加载位于 ±4GB 范围内的 64 位地址。编译器在 [清单 11-2](ch11.xhtml#ch11list2) 中使用以下代码
    ❺ 完成了这个操作：
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the label `.LC1` is in the `.rodata` section, the linker computes the
    offset from the instruction to the label. The `adrp` instruction loads the page
    number of that offset into `x0`. The `:lo12:` modifier tells the assembler to
    use only the low-order 12 bits of the offset as the immediate value for the `add`
    instruction. This two-step process may seem a bit puzzling to you. It’s due to
    the limited number of bits available for immediate values in an instruction; you’ll
    see the details when we cover how instructions are coded in binary in [Chapter
    12](ch12.xhtml).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标签`.LC1`位于`.rodata`段中，链接器计算从指令到标签的偏移量。`adrp`指令将该偏移量的页号加载到`x0`中。`:lo12:`修饰符告诉汇编器只使用偏移量的低12位作为`add`指令的立即数。这一过程可能对您来说有些困惑。这是因为指令中用于立即数的位数有限；当我们讲解如何将指令编码为二进制时，您将看到详细信息，参见[第12章](ch12.xhtml)。
- en: 'After loading the arguments into registers, we transfer the program flow to
    the other function with a `bl` or a `blr` instruction:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在将参数加载到寄存器后，我们通过`bl`或`blr`指令将程序流转移到另一个函数：
- en: bl**—Branch and link**
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: bl**—分支并链接**
- en: '`bl` addr adds 4 to the address in the `pc` and loads the sum into `x30`. It
    then loads the memory address of addr into the `pc`, thus branching to addr, which
    must be within ±128MB of this instruction.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`bl` addr将地址`pc`加上4，并将结果加载到`x30`中。然后，它将地址`addr`的内存地址加载到`pc`中，从而跳转到`addr`，该地址必须位于此指令的±128MB范围内。'
- en: blr**—Branch and link, register**
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: blr**—分支并链接，寄存器**
- en: '`blr x`s adds 4 to the address in the `pc` and loads the sum into `x30`. It
    then moves the 64-bit address in `x`s to the `pc`, thus branching to that address.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`blr x`s将地址`pc`加上4，并将结果加载到`x30`中。然后，它将`x`s中的64位地址移动到`pc`，从而跳转到该地址。'
- en: These instructions are used to call a function. Adding 4 to the address in the
    `pc` gives the address of the instruction immediately after the `bl` or `blr`
    in memory. We usually want the called function to return to this location. The
    `x30` register is used as a link register by these two branching instructions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令用于调用函数。将地址`pc`加4后，得到`bl`或`blr`指令后面的内存地址。我们通常希望被调用的函数返回到这个位置。`x30`寄存器被这两条分支指令用作链接寄存器。
- en: In the next section, we’ll write the program in assembly language. It’ll be
    very similar to what the compiler generated, but we’ll use names that make it
    easier to read.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将用汇编语言编写程序。它将与编译器生成的代码非常相似，但我们将使用更易读的名称。
- en: '**Writing main in Assembly Language**'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用汇编语言编写main函数**'
- en: '[Listing 11-3](ch11.xhtml#ch11list3) shows my assembly language version of
    the `inc_int` program. It closely follows the assembly language generated from
    the C version by the compiler in [Listing 11-2](ch11.xhtml#ch11list2), but I’ve
    added comments and used more meaningful labels for the string constants. This
    should make it a little easier to understand how the program uses the stack and
    passes arguments to other functions.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表11-3](ch11.xhtml#ch11list3)展示了我用汇编语言编写的`inc_int`程序版本。它紧密跟随编译器从C版本生成的汇编代码，见[列表11-2](ch11.xhtml#ch11list2)，但我添加了注释，并为字符串常量使用了更有意义的标签。这应该能让您更容易理解程序如何使用栈并将参数传递给其他函数。'
- en: '*inc_int.s*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc_int.s*'
- en: '[PRE11]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 11-3: A program to increment an integer, in assembly language*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-3：用汇编语言递增一个整数的程序*'
- en: 'We see another assembler directive, `.equ`, in [Listing 11-3](ch11.xhtml#ch11list3).
    The format is:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[列表11-3](ch11.xhtml#ch11list3)中看到了另一个汇编指令`.equ`。其格式为：
- en: '[PRE12]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The expression must evaluate to an integer, and the assembler sets symbol equal
    to that value. You can then use the symbol in your code, making it much easier
    to read, and the assembler will plug in the value of the expression. The expression
    is often just an integer. For example, I have equated the symbol `FRAME` to the
    integer 32 ❷. This allows us to write code that is self-documenting ❹. I’ve also
    used the assembler names, `fp` and `lr`, for the register names `x29` and `x30`,
    respectively.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式必须计算为一个整数，汇编器将符号设置为该值。然后，您可以在代码中使用该符号，使代码更易读，汇编器将插入表达式的值。该表达式通常只是一个整数。例如，我将符号`FRAME`等于整数32
    ❷。这使我们能够编写自文档化的代码 ❹。我还使用了汇编器的名称`fp`和`lr`，分别表示寄存器`x29`和`x30`。
- en: Note that we don’t need to specify the `.text` segment for the `.rodata` section
    ❸. The assembler and linker produce a `.rodata` section, and it’s up to the operating
    system to determine where to load it. I didn’t align the text strings in the `.rodata`
    section either. Although alignment might make the code execute a little faster,
    it could waste a few bytes of memory. (Both factors are irrelevant for the programming
    we’re doing in this book.) I’ve also used `adr` instead of `adrp` to load the
    addresses of the strings. The programs we’ll be writing in this book are very
    simple, so I expect the strings in the `.rodata` section to be within ±1MB of
    the instructions that use them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为 `.rodata` 段指定 `.text` 段 ❸。汇编器和链接器会生成 `.rodata` 段，操作系统决定它的加载位置。我也没有对
    `.rodata` 段中的文本字符串进行对齐。尽管对齐可能会让代码执行得更快一点，但也可能浪费一些内存字节。（对于我们在本书中做的编程，这两个因素都无关紧要。）我还使用了
    `adr` 而不是 `adrp` 来加载字符串的地址。我们在本书中编写的程序非常简单，因此我预计 `.rodata` 段中的字符串会在使用它们的指令的 ±1MB
    范围内。
- en: Finally, I’ve called `scanf` instead of `__isoc99_scanf` ❺. The `__isoc99_`
    prefix disallows several nonstandard conversion specifiers; again, this is beyond
    the scope of this book.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我调用了 `scanf` 而不是 `__isoc99_scanf` ❺。`__isoc99_` 前缀禁止使用一些非标准的转换说明符；再次强调，这超出了本书的范围。
- en: Our variable, `x`, is in the stack frame ❶. The stack frame is created in the
    function prologue ❹ and deleted in the function epilogue ❻, making `x` an automatic
    local variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变量 `x` 位于栈帧 ❶ 中。栈帧在函数前言 ❹ 中创建，并在函数尾声 ❻ 中删除，这使得 `x` 成为一个自动局部变量。
- en: '**YOUR TURN**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 11.1     You can tell the `gcc` compiler to optimize the code it generates for
    speed with the `-Ofast` option or for size with the `-Os` option. Generate the
    assembly language for the program in [Listing 11-1](ch11.xhtml#ch11list1) for
    each option. What are the differences?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 11.1     你可以告诉 `gcc` 编译器使用 `-Ofast` 选项为速度优化生成的代码，或者使用 `-Os` 选项为大小优化生成的代码。为每个选项生成
    [列表 11-1](ch11.xhtml#ch11list1) 中程序的汇编语言代码。有什么不同？
- en: 11.2     Modify the program in [Listing 11-3](ch11.xhtml#ch11list3) so that
    it inputs two integers and then displays the sum and difference of the two.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 11.2     修改 [列表 11-3](ch11.xhtml#ch11list3) 中的程序，使其输入两个整数，并显示这两个数的和与差。
- en: '11.3     Enter the following C code in a file named *sum_diff.c*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 11.3     在一个名为 *sum_diff.c* 的文件中输入以下 C 代码：
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Modify the program in [Listing 11-3](ch11.xhtml#ch11list3) so that it inputs
    two integers, calls `sum_diff` to compute the sum and difference of the two integers,
    and then displays the two results.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 [列表 11-3](ch11.xhtml#ch11list3) 中的程序，使其输入两个整数，调用 `sum_diff` 计算这两个整数的和与差，然后显示两个结果。
- en: '**What You’ve Learned**'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: '**Call stack** An area of memory used for storing program data and addresses
    that grows and shrinks as needed.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用栈** 用于存储程序数据和地址的内存区域，按需增长和收缩。'
- en: '**Stack frame** Memory on the call stack used for saving the return address
    and caller’s frame pointer, as well as for creating local variables.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈帧** 调用栈上的内存，用于保存返回地址和调用者的帧指针，以及用于创建局部变量。'
- en: '**Function prologue** The instructions that create a stack frame.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数前言** 创建栈帧的指令。'
- en: '**Function epilogue** The instructions that restore the caller’s link register
    and frame pointer and delete the stack frame.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数尾声** 恢复调用者的链接寄存器和帧指针并删除栈帧的指令。'
- en: '**Automatic local variables** Variables created anew each time a function is
    called. They can easily be created on the call stack.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动局部变量** 每次调用函数时新创建的变量。它们可以很容易地创建在调用栈上。'
- en: '**Passing arguments to a subfunction** Up to eight arguments are passed in
    the `x0`–`x7` registers.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**向子函数传递参数** 最多可以通过 `x0`–`x7` 寄存器传递八个参数。'
- en: '**Calling a function** The branch and link instructions, `bl` and `blr`, transfer
    program flow to a function, storing the return address in `x30`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用函数** 分支和链接指令 `bl` 和 `blr` 将程序流转移到一个函数，并将返回地址存储在 `x30` 中。'
- en: '**A64 addressing** There are several modes for generating a 64-bit address
    with a 32-bit instruction.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**A64 寻址** 有多种模式可以使用 32 位指令生成 64 位地址。'
- en: '**Position-independent executable** The operating system can load the program
    anywhere in memory, and it will execute correctly.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置无关可执行文件** 操作系统可以将程序加载到内存中的任何位置，并且它将正确执行。'
- en: '**Load–store architecture** Instructions can operate only on data that is in
    registers.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载-存储架构** 指令只能对寄存器中的数据进行操作。'
- en: In the next chapter, we’ll take a brief look at how instructions are coded in
    machine language. This will help you understand the reasons for some of the limitations
    of instructions, such as the size of offset when referring to a memory address.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将简要了解指令是如何在机器语言中编码的。这将帮助你理解一些指令限制的原因，例如在引用内存地址时偏移量的大小。
