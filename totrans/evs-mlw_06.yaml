- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ENUMERATING
    OPERATING SYSTEM ARTIFACTS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A normal, “real” user environment looks much different from a malware sandbox
    or lab environment. A typical user will likely have installed common applications,
    such as Microsoft Office, email clients, multiple web browsers, and so on. They
    probably wouldn’t be using a VM, Wireshark, or Procmon, nor are they likely to
    have installed malware analysis tools such as IDA Pro or sandboxing tools like
    Cuckoo. A sandbox or lab environment, on the other hand, typically has analysis
    software installed in a VM.
  prefs: []
  type: TYPE_NORMAL
- en: This is indicated by references to the hypervisor in the names and properties
    of various *operating system artifacts*, such as the currently running processes,
    configured registry keys, and installed devices and drivers. Malware can extract
    this information to understand its environment, choose its target, and decide
    whether or not to execute its payload on the host. This is known as *enumeration*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll walk you through enumeration techniques for several OS
    artifacts and explain how malware might use the information it gathers to identify
    an analysis environment or inappropriate target. Many of the techniques we’ll
    explore in this and the next few chapters can be circumvented by a specially tuned
    malware analysis environment, which we’ll discuss in [Appendix A](appendix-A.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Processes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Malware can use process enumeration techniques to detect VMs and sandboxes
    and better understand its operating environment. The primary Windows API functions
    that malware may use to enumerate processes are <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>. The following malware
    sample excerpt enumerates running processes on a host to look for the target process
    *VboxTray.exe*, which is common in some VirtualBox VMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>
    function creates a snapshot of the processes running on the victim’s host and
    returns a handle to it ❶. This handle is pushed to the stack, along with a pointer
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">peInfo</samp> buffer, which
    will store the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>
    function ❷. <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>
    outputs information about the first process running on the host, <samp class="SANS_TheSansMonoCd_W5Regular_11">peInfo.szExeFile</samp>.
    After calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>,
    the malware compares <samp class="SANS_TheSansMonoCd_W5Regular_11">peInfo.szExeFile</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">vboxtray_process_name</samp>
    variable, which was previously defined as <samp class="SANS_TheSansMonoCd_W5Regular_11">"VboxTray.exe"</samp>
    ❸. (This variable assignment isn’t shown in the code snippet.) If the process
    names don’t match, the program jumps to the next area of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the pointer to the buffer and the process snapshot handle are again pushed
    to the stack to prepare for the next function: <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>
    ❹, which does exactly the same thing as <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>
    but will iterate over the remaining processes running on the system. After the
    next process is enumerated and stored in the buffer, the malware does another
    comparison to the <samp class="SANS_TheSansMonoCd_W5Regular_11">vboxtray_process_name</samp>
    variable. This time, if the names don’t match, the code will loop to execute <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp> again, repeating
    until it enumerates all processes or finds the target process ❺.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re analyzing malware and you spot it enumerating the process list and
    checking for a specific process name such as *VboxTray.exe* or *Vmtoolsd.exe*,
    it should raise a red flag. Here are some of the common VM-related process names
    malware might be targeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware**'
  prefs: []
  type: TYPE_NORMAL
- en: '*TPAutoConnSvc.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*VGAuthService.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*VMwareService.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vm3dservice.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vmtoolsd.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vmwaretray.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vmwareuser.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox**'
  prefs: []
  type: TYPE_NORMAL
- en: '*VboxControl.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*VBoxService.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*VboxTray.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some malware variants also search for typical malware analysis tools (such
    as Procmon, Wireshark, Process Explorer, and Fiddler), which may be running on
    the analyst’s workstation at the time of detonation. If the malware finds any
    of the following example processes running on the system, it may decide to terminate
    itself or take other evasive actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*autoruns.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*fiddler.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ollydbg.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*procexp.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*procmon.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*tcpview.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*wireshark.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x64dbg.exe*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oftentimes, you can simply rename the executable file for these tools before
    running the process. For example, renaming *procmon.exe* to *nomcorp.exe* may
    evade basic malware checks. This trick won’t work for malware that looks at the
    window title bar, however.
  prefs: []
  type: TYPE_NORMAL
- en: When enumerating and searching for specific process names, some malware will
    use hashed names instead of cleartext strings so that its target won’t be readily
    apparent to the malware analyst. For example, the MD5 hash sum of the process
    name *fiddler.exe* is 447c259d51c2d1cd320e71e6390b8495, so if you were debugging
    a particular malware sample or inspecting it in a disassembler, you might notice
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">447c259d51c2d1cd320e71e6390b8495</samp>
    rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">fiddler.exe</samp>.
    You can see how this would slow down analysis and possibly stump an inexperienced
    analyst.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing in this way will be covered in more depth in [Chapter 16](chapter16.xhtml).
    For now, just keep in mind that you might not see nice, cleartext process names
    when analyzing a malware sample; always be aware of possible hashing. This is
    true not only for processes but also for filenames, services, and other strings
    that the malware may be searching for.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Directories and Files</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enumerating directories and files is another technique malware can use to detect
    sandboxes and VMs. Malware may search for specific files and directories associated
    with hypervisor software (such as VMware Workstation and VirtualBox) or with automated
    malware sandboxes (such as Cuckoo).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows a malware sample calling <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp>
    with *C:\Windows\System32\drivers\vm** as a target. The sample is searching the
    Windows *drivers* directory for any driver files with a prefix of *vm*, which
    is a common pattern for VMware Workstation driver files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction compares
    the value of the returned filename to *C:\Windows\System32\drivers\vm**. If the
    result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (meaning there’s no
    match), the code jumps to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_2</samp>,
    which contains the next function call, <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp>.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp> executes, and
    the same <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction
    compares the filenames. If the test instruction returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    the program jumps to <samp class="SANS_TheSansMonoCd_W5Regular_11">loc_2</samp>
    again. <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp> will
    continue to execute until there’s a match or there are no more files.
  prefs: []
  type: TYPE_NORMAL
- en: 'While file enumeration in malware is very common for many reasons, the presence
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp> could mean the malware
    sample may be attempting to detect an analysis environment. VMware Workstation
    and VirtualBox file and directory paths that malware might target include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware files**'
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Windows\System32\drivers\vm**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Windows\System32\vm**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Windows\SysWOW64\vm**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMware directories**'
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Program Files\VMware\*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Program Files\Common Files\VMware\*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox files**'
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Windows\System32\VBox**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C:\Windows\System32\drivers\VBox**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox directories**'
  prefs: []
  type: TYPE_NORMAL
- en: '*C:\Program Files\Oracle\VirtualBox Guest Additions\*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to VMs, automated sandbox environments often contain specific folders
    and files that malware may find suspicious. Many Cuckoo installations, for example,
    contain several scripts and files like *Analyzer.py* and *analysis.conf*. Some
    Cuckoo versions may even have a directory called *cuckoo* or *agent* under the
    *C:\* directory path. Keep this in mind when analyzing evasive malware in an automated
    malware analysis sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, malware can use directories and file enumeration to identify its operating
    environment and profile its target. For example, if a malware sample is targeting
    a certain organization or type of system, it might enumerate the filesystem to
    look for specific directories and files containing the target company name. This
    check would allow the malware to infect only systems in the scope of its attack.
    A good example of such a system is Stuxnet, mentioned in the introduction. As
    part of its exploitation tactics, Stuxnet searches for several files related to
    the Siemens Step7 software on the victim host. If these files don’t exist, the
    system will not be infected.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Some of these files and directories can be renamed or even removed without
    affecting the VM environment. I’ll discuss this in more detail in [Appendix A](appendix-A.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Shared Folders</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To share files between VMs and the host OS, an analyst can configure *shared
    folders*. But while shared folders allow easy transfer of files from the host
    to the guest and vice versa, they also give malware another clue that it’s being
    analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can enumerate shared folders by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">WNetGetProviderName</samp>
    Windows API function, which retrieves network resource information. As VM shared
    folders are effectively network resources, calling this function on a VirtualBox
    VM configured with shared folders may return a result of <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualBox
    Shared Folders</samp>, for example, which is a dead giveaway that this machine
    is hosted on a VirtualBox hypervisor.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, because VM shared folders function like network drives, they can
    be identified via normal file and folder enumeration functions, such as the previously
    discussed <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp>. The target
    path for these functions would be the name of the VM network drive. Some common
    network drive names are *\\VboxSrv* (for VirtualBox) and *\\vmware-host* (for
    VMware Workstation).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Registry</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Windows registry contains information about installed software, hardware
    configurations, the network, language and location settings, and many other data
    points that Windows uses to function. As a result, malware attempting to understand
    the target environment or detect a VM or sandbox will often query the registry.
    It might enumerate entire hives of the registry and search for suspect VM-related
    strings, or it might simply inspect a few keys of specific interest. The following
    excerpt shows how this might look in an actual malware sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKey</samp>
    to open a specific key of interest, followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumValue</samp>
    function to enumerate all values and data under this registry key. Let’s break
    this code down a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: First, the malware moves the <samp class="SANS_TheSansMonoCd_W5Regular_11">lpSubKey</samp>
    value, which represents the registry key it’s interested in, into the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdx</samp>
    register ❶. In this case, this registry key is <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System</samp>.
    The value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdx</samp> register
    is used as a parameter for the subsequent call to <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKeyExA</samp>
    ❷. Next, the code loads pointers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">lpData</samp>
    ❸ and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpValueName</samp> ❹ structures.
    Then, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumValueA</samp>
    ❺, which stores the returned values and data for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System</samp>
    registry key in <samp class="SANS_TheSansMonoCd_W5Regular_11">lpValueName</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">lpData</samp>, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, malware will call <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>
    multiple times in a loop, as each iteration of <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>
    stores only one value and data item. For simplicity’s sake, I included only one
    call to this function in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the malware compares the suspect value, <samp class="SANS_TheSansMonoCd_W5Regular_11">VBOX
    -1</samp>, to the value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">lpdata</samp>
    buffer ❻. If they match, the malware assumes it’s running in a VirtualBox VM and
    terminates itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware may also query certain areas of the registry for environment profiling.
    For example, it might attempt to detect whether it’s running on a computer system
    of a certain company in order to avoid inadvertently infecting the wrong target.
    In the following pseudocode, this malware sample is querying the registry for
    software related to its target, a company called NewCorp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example is using the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKey</samp>
    Windows API function to search for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU\Software\NewCorp</samp>
    registry key of the host’s system. If the malware finds the key, it assumes it’s
    running on a system within the NewCorp organization; otherwise, it terminates
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can also query the registry using Windows command line tools, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">reg query</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command would succeed if the key exists on the victim’s system and fail
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final way in which malware can query the registry is by using Windows Management
    Instrumentation (WMI), PowerShell, and other native Windows tools, as we’ll discuss
    in [Chapter 15](chapter15.xhtml). For now, the point is that there are many methods
    of querying the registry, but it’s also important to note that malware and benign
    software alike both query the registry for many reasons; a query doesn’t always
    indicate that malware is using a profiling or evasion technique. Registry keys
    that malware may search for in an attempt to identify a VM analysis environment
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware Workstation**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKCU:\SOFTWARE\VMware, Inc.</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Classes\Applications\VMwareHostOpen.exe</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Classes\VMwareHostOpen.AssocFile</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Classes\VMwareHostOpen.AssocURL</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VMware
    User Process</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VMware
    VM3DService Process</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\RegisteredApplications\VMware
    Host Open</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\WOW6432Node\RegisteredApplications\VMware
    Host Open</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\CurrentControlSet\Enum\IDE\DiskVMware_Virtual_IDE_Hard_Drive___________00000001\</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\ACPI\DSDT\VBOX__</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\ACPI\FADT\VBOX__</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\ACPI\RSDT\VBOX__</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VBoxTray</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Oracle
    VM VirtualBox Guest Additions</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Oracle\VirtualBox
    Guest Additions</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxMouse</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxSF</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxService</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxVideo</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\ControlSet001\services\VBoxGuest</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**General**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System\BIOS\SystemManufacturer</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System\BIOS\SystemProductName</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System\SystemBiosVersion</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Store\Configuration\OEMID</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\SYSTEM\CurrentControlSet\Control\Class\</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the Windows tool *regedit.exe* on your own analysis VM to investigate
    these keys and get an idea of what malware may be looking for. For example, when
    I inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM:\HARDWARE\Description\System</samp>
    registry key in my own analysis machine, I can spot certain values and data that
    may be interesting to malware (see [Figure 4-1](chapter4.xhtml#fig4-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The hardware description
    in</samp> <samp class="SANS_Futura_Std_Book_11">regedit.exe</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The obvious data points of interest here are the <samp class="SANS_TheSansMonoCd_W5Regular_11">VBOX
    -1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Oracle VM VirtualBox</samp>
    strings. Another big hint is the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemBiosDate</samp>
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">06/23/99</samp>, which indicates
    the VirtualBox hypervisor. Once again, these registry keys are only examples.
    They may or may not exist on your VMs, depending on your hypervisor version, installed
    software, and other factors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*These registry keys can typically be renamed or removed completely in order
    to trick malware and bypass its evasion techniques. I’ll discuss this in more
    detail in [Appendix A](appendix-A.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Services</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Services* are applications that typically start at system boot-up and run
    in the background of a user’s session, and they’re yet another way in which malware
    may attempt to identify a VM or sandbox environment. Some services are unique
    to a certain brand of hypervisor, giving away its presence, and some services
    can also identify installed malware analysis tools. For example, malware may be
    looking for the *VirtualBox Guest Additions Service*, which indicates the presence
    of VirtualBox.'
  prefs: []
  type: TYPE_NORMAL
- en: Malware may query services in multiple ways. One of the most common techniques
    is using the Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumServiceStatus</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumServiceStatusEx</samp>, which
    will return a list of services on the host and their associated statuses, which
    are usually either <samp class="SANS_TheSansMonoCd_W5Regular_11">running</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">stopped</samp>. Malware can also
    use the function <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenService</samp>
    to open a handle to a specific service. If it successfully obtains a handle (meaning
    the service exists), the return code will be <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to Windows API functions, there are other methods of enumerating
    services that malware can employ. For example, malware can use the Windows <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sc</samp> command line tool to query a
    list of services or a specific service, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, malware can use the WMI command line tool <samp class="SANS_TheSansMonoCd_W5Regular_11">wmic</samp>
    to query all services on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, since some service information is stored in the registry, malware can
    query the registry for service information. If you see malware using service-related
    API functions, using tools such as <samp class="SANS_TheSansMonoCd_W5Regular_11">sc</samp>,
    or querying the registry to find specific hypervisor services, the sample may
    be attempting to detect an analysis environment.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand and explore the services running on your VMs and sandboxes,
    you can use the Windows native application *services.exe* to get a list of services
    configured on the system. In [Figure 4-2](chapter4.xhtml#fig4-2), you can see
    the VirtualBox Guest Additions Service running, which can signal to malware that
    it is running in a VM environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The output of</samp>
    <samp class="SANS_Futura_Std_Book_11">services.exe</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-1](chapter4.xhtml#tab4-1) lists some of the common services created
    by VMware and VirtualBox.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Hypervisor Services</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">VGAuthService</samp> | <samp
    class="SANS_Futura_Std_Book_11">VMware Guest Authentication Service</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">VMTools</samp> | <samp class="SANS_Futura_Std_Book_11">VMware
    Tools Service</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxService</samp> | <samp
    class="SANS_Futura_Std_Book_11">VirtualBox Guest Additions Service</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_B_11">Installed Software</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Malware may enumerate the installed software on your analysis machine and look
    for keywords that represent common analysis tools or sandbox-related artifacts.
    This technique can also be used for target profiling; malware may simply query
    the host, looking for installed software indicating that this system is a valid
    target.
  prefs: []
  type: TYPE_NORMAL
- en: To search for installed software, the malware might use a Windows API function
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">MsiEnumProducts</samp> or
    inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKLM\Software\Microsoft\Windows\Current
    Version\Uninstall</samp> registry key, whose contents from my malware analysis
    machine are shown in [Figure 4-3](chapter4.xhtml#fig4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: Enumerating the
    HKLM\Software\Microsoft\ Windows\Current Version\Uninstall registry key</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see several analysis tools, as well as VirtualBox Guest Additions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Software installers create many artifacts on the host, such as new folders,
    files, and registry entries, all of which can be enumerated by malware. Sometimes
    it’s a better approach to use the* portable *versions of analysis tools, which
    don’t need to be installed and are run directly from a self-contained executable
    file.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mutexes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As [Chapter 1](chapter1.xhtml) explained, a *mutex* is an object that helps
    control access to resources, acting as a sort of gatekeeper. Certain sandboxes
    and hypervisors have unique mutexes that may be interesting to malware. For example,
    VMware typically uses mutexes that begin with *VMware*, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestCopyPasteMutex</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can use the Windows API function <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateMutex</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenMutex</samp> to search for
    specific mutex values, as shown in this sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The malware pushes the <samp class="SANS_TheSansMonoCd_W5Regular_11">mutex_name</samp>
    variable, which contains the mutex that the malware wants to find (<samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestCopyPasteMutex</samp>),
    to the stack. It also pushes two other values that are required for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenMutex</samp> function but aren’t important
    here. Next, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenMutexA</samp>
    and uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction
    to check whether that function succeeded or failed. If the function call succeeded,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestCopyPasteMutex</samp>
    exists on the system, meaning that the system is likely running inside a VMware
    hypervisor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that not all mutex-related activity is malicious. Mutexes are
    standard Windows objects and are not inherently malicious *or* benign. If you
    spot malware enumerating mutexes and attempting to find very specific strings
    such as the examples just given, it could be using this detection technique. Some
    mutexes that may reveal a VM environment include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware Workstation**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VMToolsHookQueueLock</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestCopyPasteMutex</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VMwareGuestDnDDataMutex</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxService</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxTray</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pipes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *pipe* is a Windows object that allows for interprocess communication. Some
    hypervisors create unique pipes on the guest OS that may give away their presence
    to malware. Malware can call several different functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateFile</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CallNamedPipe</samp>, to search
    for specific named pipes.
  prefs: []
  type: TYPE_NORMAL
- en: A great way to check your own VMs for these pipes is to use the tool Pipelist,
    which is part of the Windows Sysinternals suite from Mark Russinovich. [Figure
    4-4](chapter4.xhtml#fig4-4) shows the output from running the <samp class="SANS_TheSansMonoCd_W5Regular_11">pipelist</samp>
    command on a VMware Workstation VM. If you look closely, you may spot the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">vgauth-service</samp> pipe, which is unique
    to VMware.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: Output from running
    the pipelist command on a VMware Workstation VM</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the common pipes that may reside on your VMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware Workstation**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Vmmemctl</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vgauth-service</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxTray</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxTrayIPC</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxGuest</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxVideo</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxMouse</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxMiniRdr</samp>  ### <samp
    class="SANS_Futura_Std_Bold_B_11">Devices and Drivers</samp>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hypervisors often install specific devices and drivers on guest operating systems.
    *Devices* are objects that often represent physical hardware on the system, such
    as USB controllers or hard disk volumes. *Drivers* are software objects that control
    hardware, allowing the OS and devices to communicate. Device and driver objects
    are typically managed by the Windows object manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can enumerate devices and driver objects using two Windows functions:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenDirectoryObject</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryObject</samp>. The
    following code shows these functions in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see a handle to the *\\Driver* directory being loaded into register
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rcx</samp> ❶, using the instruction
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>, or *load effective address*.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction calculates
    the address of an operand and loads it into a target register. This is followed
    by a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenDirectoryObject</samp>,
    which opens *\\Driver* in preparation for the subsequent <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryObject</samp>
    function call ❷. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryObject</samp>
    ❹ queries the *\\Driver* directory objects and stores the list of objects in a
    buffer specified previously ❸. The malware then searches through this buffer,
    looking for specific drivers often used in VMs. Devices can be queried in the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the contents of the Windows object manager, you can view
    it directly on your Windows VMs using the WinObj tool from Sysinternals. [Figure
    4-5](chapter4.xhtml#fig4-5) shows some of the VirtualBox-related drivers installed
    on my analysis VM using WinObj. Feel free to explore them on your own analysis
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: Exploring drivers
    with WinObj</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common hypervisor drivers for VMware Workstation and VirtualBox include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware Workstation**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmp</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmp-debug</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmp-stats</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmp-sloader</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vmci</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vmhgfs</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VMMemCtl</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vmmouse</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vmrawdsk</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vmusbmouse</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vsock</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxGuest</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxMouse</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxSF</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxVideo</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxWddm</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are some common devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VMware Workstation**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VMCIGuestDev</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VMCIHostDev</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vm3dmpDevice</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vmci</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">vmmemctl</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirtualBox**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxGuest</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">VBoxMiniRdr</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Usernames and Hostnames</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many automated malware analysis sandboxes have a default list of possible usernames
    assigned to user accounts on the system. These usernames may be randomized, but
    they’re often hardcoded. System hostnames may similarly be hardcoded and randomized
    at boot-up time. This isn’t simply a characteristic of automated sandboxes, however.
    Malware analysts may also configure their analysis VMs with usernames or hostnames
    that may be generic, well known, or otherwise not how a “real” user would configure
    their system.
  prefs: []
  type: TYPE_NORMAL
- en: Some malware can take advantage by enumerating the user accounts and hostname
    of the system, specifically searching for generic usernames such as *Administrator*,
    *User*, or *John*, or hostnames such as *Cuckoo*, *Test*, *Desktop*, *Workstation*,
    or *Lab*. *TequilaBoomBoom*, at one point the hostname for VirusTotal’s sandboxing
    service, is also a common check.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Configure your VMs and sandbox environments with nongeneric usernames and
    hostnames. Try to use values that an actual end user or enterprise environment
    would use, or randomize the names.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Locale and Language Settings</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Keyboard and language settings can be used to determine a potential victim’s
    location. Malware might use this technique to include or exclude a host as a valid
    target for geographic or geopolitical reasons, or to evade analysis. For example,
    say a malware sample wants to determine whether a potential victim is located
    in Russia or speaks Russian. Depending on this information, it may then choose
    to deploy its payload on the host or quietly terminate itself. Here are three
    different approaches it can use to extract this information:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the keyboard layout language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating the language settings of the system itself, such as the display
    language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining the host’s locale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first method is perhaps the most common. The Windows function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKeyboardLayout</samp>
    returns the active keyboard language of the host, and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKeyboardLayoutList</samp>
    returns a complete list of all keyboard languages that are installed on the host.
  prefs: []
  type: TYPE_NORMAL
- en: There are several possible Windows functions to get the host’s language settings.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetUserDefaultUILanguage</samp>,
    for example, returns the currently logged-in user’s user interface language. <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetSystemDefaultUILanguage</samp> returns
    the system language, or more specifically, the language in which the OS was installed.
    Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcessPreferredUILanguages</samp>
    will list languages that the user’s running processes may be utilizing. Talk about
    options!
  prefs: []
  type: TYPE_NORMAL
- en: The *locale* of the host is different from the host’s keyboard and UI language
    settings in that it’s a list of language-related settings for a particular language-and-country
    combination. Some items that may be included as part of a locale are currency
    and date/time display formats, as well as a language identifier. The Windows API
    functions <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemDefaultLCID</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetUserDefaultLCID</samp> return
    locale information that can be used to profile a host or user. Processes and threads
    may also have their own custom locales, which malware can query using the function
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadLocale</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a malware sample, you’d likely see a call to one of the previously mentioned
    functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKeyboardLayout</samp>,
    followed by a comparison to several values that represent Windows language identifiers.
    The following pseudocode shows this technique in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This malware sample calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetKeyboardLayout</samp>
    function and compares the result to the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x419</samp>,
    which is the Russian language identifier in hexadecimal (also known as *in hex*).
    If this Russian language identifier is in use, the malware executes <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-2](chapter4.xhtml#tab4-2) lists some of the language identifiers for
    Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Language Identifiers</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Identifier (in hex)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Language (and associated country)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x402</samp> | <samp class="SANS_Futura_Std_Book_11">Bulgarian
    (Bulgaria)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x4</samp> | <samp class="SANS_Futura_Std_Book_11">Chinese
    (Simplified) (China)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x809</samp> | <samp class="SANS_Futura_Std_Book_11">English
    (United Kingdom)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x409</samp> | <samp class="SANS_Futura_Std_Book_11">English
    (United States)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x407</samp> | <samp class="SANS_Futura_Std_Book_11">German
    (Germany)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x418</samp> | <samp class="SANS_Futura_Std_Book_11">Romanian
    (Romania)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x419</samp> | <samp class="SANS_Futura_Std_Book_11">Russian
    (Russia)</samp> |'
  prefs: []
  type: TYPE_TB
- en: There are several other, more covert methods for enumerating or inferring a
    potential victim’s language and locale settings, such as enumerating the date/time
    formats, currency formats, or even calendar information. The potential list is
    so extensive that a portion of this book could be dedicated to this technique
    alone. What’s most important is that you now have the necessary knowledge to identify
    many of the common methods that malware may use to profile a victim’s language
    and locale.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Operating System Version Information</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before infecting a victim machine, malware often needs to determine whether
    that machine is running a certain OS. Stuxnet, for example, infected only Windows
    XP computers because its authors knew that the target facilities used Windows
    XP to control the Siemens programmable logic controllers. A malware sample that
    can run on only a certain version of Windows may attempt to identify the OS before
    infecting the host to avoid inadvertently crashing it. For example, if the malware
    contains exploit code that works for only a specific sub-version of Windows, such
    as Windows 7 Service Pack 1, but causes system instability for Windows 7 Service
    Pack 2, it might want to determine a victim’s OS sub-version first to prevent
    an unintended crash that would potentially alert the victim to its presence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique isn’t usually implemented as a detection or evasion technique,
    but it’s worth discussing in this context because it can still interfere with
    the analysis process. For example, if you were researching Stuxnet and decided
    to run the sample in a VM or sandbox with a modern Windows OS, it likely wouldn’t
    run correctly, thereby unintentionally evading automated and dynamic analysis
    methods. This is an important point to keep in mind: a malware sample that doesn’t
    execute correctly in your analysis environment isn’t necessarily intentionally
    trying to be evasive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways of enumerating the target’s OS and version via the
    Windows API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionEx</samp>
    function, along with its close cousin <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersion</samp>,
    accomplishes this, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionExA</samp> function
    takes a buffer as an argument. This buffer will be the area of memory where the
    returned OS information will be stored after <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionExA</samp>
    is called. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction
    loads the buffer address, <samp class="SANS_TheSansMonoCd_W5Regular_11">[ebp-0A0h]</samp>,
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> register, and
    then the buffer address is pushed to the stack with <samp class="SANS_TheSansMonoCd_W5Regular_11">push
    eax</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the sample must define the size of the data that will be returned from
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionExA</samp> function
    call. This data will be stored in a structure called <samp class="SANS_TheSansMonoCd_W5Regular_11">VersionInformation</samp>.
    This sample specifies the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">VersionInformation</samp>
    structure as <samp class="SANS_TheSansMonoCd_W5Regular_11">9C</samp>, which in
    hex is equal to 156 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetVersionExA</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">call GetVersionExA</samp>) to get
    the OS version, then later checks that information by comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMajorVersion</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, which represents
    a very old version of Windows. (For some perspective, <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    is the version number for Windows XP!) Essentially, this malware sample is testing
    to see how old this host’s Windows version is.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-3](chapter4.xhtml#tab4-3) contains a subset of the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMajor</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMinor</samp> OS versions.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMajor</samp>
    <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dbMinor</samp>
    <samp class="SANS_Futura_Std_Book_11">OS Versions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operating system</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dwMajorVersion</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMinorVersion</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Windows 10</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Windows Server 2016</samp> | <samp
    class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Windows 8.1</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Windows Server 2012</samp> | <samp
    class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Windows 7</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Windows Server 2008</samp> | <samp
    class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Windows Vista</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Windows XP</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we covered many common (and some not-so-common) ways in which
    malware can detect an analysis environment by inspecting operating system objects
    and artifacts. In the next chapter, we’ll explore some techniques malware can
    use to look for evidence of legitimate user activity (or lack thereof!) to reveal
    the underlying VM or sandbox environment.
  prefs: []
  type: TYPE_NORMAL
