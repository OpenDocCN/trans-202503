<html><head></head><body>
<section aria-labelledby="ch4" epub:type="chapter" role="doc-chapter">
<span aria-label="73" epub:type="pagebreak" id="pg_73" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch4">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">EXPRESSIONS AND OPERATORS</samp></span>
</h1>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">In this chapter, you’ll learn about operators and how to write simple expressions to perform operations on various object types. An <i>operator</i> is a keyword or one or more punctuation characters used to perform an operation. When an operator is applied to one or more operands, it becomes an expression that computes a value and that might have side effects. <i>Expressions</i> are sequences of operators and operands that compute a value or accomplish another purpose. The operands can be identifiers, constants, string literals, and other expressions.</p>
<p class="TX">In this chapter, we discuss simple assignment before stepping back to examine the mechanics of expressions (operators and operands, value computations, side effects, precedence, and order of evaluation). We then consider specific operators including <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>, arithmetic, bitwise, cast, <span aria-label="74" epub:type="pagebreak" id="pg_74" role="doc-pagebreak"/>conditional, alignment, relational, compound assignment, and the comma operator. We’ve introduced many of these operators and expressions in previous chapters; here, we detail their behavior and how best to use them. Finally, we end the chapter with a discussion of pointer arithmetic.</p>
<section aria-labelledby="sec1" epub:type="division">

<h2 class="H1" id="sec1"><span id="h1-31"/><samp class="SANS_Futura_Std_Bold_B_11">Simple Assignment</samp></h2>
<p class="TNI">A <i>simple assignment</i> replaces the value stored in the object designated by the left operand with the right operand. The value of the right operand is converted to the type of the assignment expression. Simple assignment has three components: the left operand, the assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) operator, and the right operand, as shown in the following example:</p>

<pre><code>int i = 21; // declaration with initializer
int j = 7;  // declaration with initializer
i = j;      // simple assignment</code></pre>
<p class="TX">The first two lines are <i>declarations</i> that define and initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> with the value 21 and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> with the value 7. Initialization is different from simple assignment despite having similar syntax. An <i>initializer</i> is an optional part of a declaration; when present, it provides the initial value for the object. If the initializer is not present, objects (with automatic storage duration) are uninitialized.</p>
<p class="TX">The third line contains a simple assignment. You must define or declare all identifiers that appear in an expression (such as a simple assignment) for your code to compile.</p>
<p class="TX">The left operand in a simple assignment is always an expression (with an object type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>), referred to as an <i>lvalue</i>. The <i>l</i> in lvalue originally comes from it being the <i>left</i> operand, but it may be more correct to think of it as standing for <i>locator value</i>, because it must designate an object. The right operand is also an expression, but it can simply be a value and doesn’t need to identify an object. We refer to this value as an <i>rvalue</i> (<i>right</i> operand) or <i>expression value</i>. In this example, the identifiers for both objects <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> are lvalues. An lvalue can also be an expression, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">*(p + 4)</samp>, provided it references an object in memory.</p>
<p class="TX">In a simple assignment, the rvalue is converted to the type of the lvalue and then stored in the object designated by the lvalue. In the assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>, the value is read from <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> and written to <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. Because both <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> are the same type (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>), no conversion is necessary. The assignment expression has the value of the result of the assignment and the type of the lvalue.</p>
<p class="TX">The rvalue does not need to refer to an object, as you can see in the following statement, which uses the types and values from the preceding example:</p>

<pre><code>j = i + 12; // j now has the value 19</code></pre>
<p class="TX">The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> is not an lvalue, because there is no underlying object storing the result. Instead, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> by itself is an lvalue that is automatically <span aria-label="75" epub:type="pagebreak" id="pg_75" role="doc-pagebreak"/>converted into an rvalue to be used as an operand to the addition operation. The resulting value from the addition operation (which has no memory location associated with it) is also an rvalue. C constrains where lvalues and rvalues may appear. The following statements illustrate the correct and incorrect use of lvalues and rvalues:</p>

<pre><code>int i;
i = 5;     // i is an lvalue, 5 is an rvalue
int j = i; // lvalues can appear on the right side of an assignment
7 = i;     // error: rvalues can't appear on the left side of an assignment</code></pre>
<p class="TX">The assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> doesn’t compile because the rvalue must always appear on the right side of the operator.</p>
<p class="TX">In the following example, the right operand has a different type from the assignment expression, so the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is first converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> type. The value of the expression enclosed in parentheses is then converted to the <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> type and assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>:</p>

<pre><code>signed char c;
int i = INT_MAX;
long k;
k = (c = i);</code></pre>
<p class="TX">Assignment must deal with real-world constraints. Specifically, simple assignment can result in truncation if a value is converted to a narrower type. As mentioned in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, each object requires a fixed number of bytes of storage. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> can always be represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> (a larger type of the same signedness). However, in this example, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> (the type of the assignment expression <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>). The value of the expression enclosed in parentheses is then converted to the type of the outer assignment expression—that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> type. If your implementation’s <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> type has insufficient width to fully represent the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, values greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp> are truncated, and the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> (−1) is truncated. To prevent values from being truncated, make sure that you choose sufficiently wide types that can represent any value that might arise.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">

<h2 class="H1" id="sec2"><span id="h1-32"/><samp class="SANS_Futura_Std_Bold_B_11">Evaluations</samp></h2>
<p class="TNI">Now that we’ve looked at simple assignment, let’s step back for a moment and look at how expressions are evaluated. <i>Evaluation</i> mostly means simplifying an expression down to a single value. The evaluation of an expression can include both value computations and the initiation of side effects.</p>
<p class="TX">A <i>value computation</i> is the calculation of the value that results from the evaluation of the expression. Computing the final value may involve determining the identity of the object or reading the value previously assigned <span aria-label="76" epub:type="pagebreak" id="pg_76" role="doc-pagebreak"/>to an object. For example, the following expression contains several value computations to determine the identity of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp>:</p>

<pre><code>a[i] + f() + 9</code></pre>
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is a function and not an object, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> doesn’t involve determining the identity of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>. The value computations of operands must occur before the value computation of the result of the operator. In this example, separate value computations read the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> and determine the value returned by the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> function. A third computation then sums these values to obtain the value returned by the overall expression. If <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> is an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, the result of the expression will have the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type.</p>
<p class="TX"><i>Side effects</i> are changes to the state of the execution environment. Side effects include writing to an object, accessing (reading or writing) a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified object, input/output (I/O), assignment, or calling a function that does any of these things. We can slightly modify the previous example to add an assignment. Updating the stored value of <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is a side effect of the assignment:</p>

<pre><code>int j;
j = a[i] + f() + 9;</code></pre>
<p class="TX">The assignment to <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is a side effect that changes the state of the execution environment. Depending on the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> function, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> may also have side effects.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h2 class="H1" id="sec3"><span id="h1-33"/><samp class="SANS_Futura_Std_Bold_B_11">Function Invocation</samp></h2>
<p class="TNI">A <i>function designator</i> is an expression that has a function type and is used to invoke a function. In the following function invocation, <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> is the function designator:</p>

<pre><code>int x = 11;
int y = 21;
int max_of_x_and_y = max(x, y);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> function returns the larger of its two arguments. In an expression, a function designator is converted to a <i>pointer-to-function returning type</i> at compile time. The value of each argument must be of a type that can be assigned to an object with (the unqualified version of) the type of its corresponding parameter. The number and type of each argument must agree with the number and type of each parameter accepted by the function. Here, that means two integer arguments. C also supports <i>variadic functions</i>, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>, which accept a variable number of arguments.</p>
<p class="TX">We can also pass one function to another, as shown by <a href="chapter4.xhtml#Lis4-1">Listing 4-1</a>.</p>
<span id="Lis4-1"/>
<pre><code>int f() {
  // <var>--snip--</var>
<span aria-label="77" epub:type="pagebreak" id="pg_77" role="doc-pagebreak"/>  return 0;
}
void g(int (*func)()) {
  // <var>--snip--</var>
  if (func() != 0)
    printf("g failed\n");
  // <var>--snip--</var>
}
// <var>--snip--</var>
g(f); // call g with function-pointer argument
// <var>--snip--</var></code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: Passing one function to another function</samp></p>
<p class="TX">This code passes the address of a function designated by <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> to another function, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> accepts a pointer to a function that accepts no arguments and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. A function passed as an argument is implicitly converted to a function pointer. The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> makes this explicit; an equivalent declaration is <samp class="SANS_TheSansMonoCd_W5Regular_11">void g(int func(void))</samp>.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">

<h2 class="H1" id="sec4"><span id="h1-34"/><samp class="SANS_Futura_Std_Bold_B_11">Increment and Decrement Operators</samp></h2>
<p class="TNI">The <i>increment</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>) and <i>decrement</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>) operators increment and decrement a modifiable lvalue, respectively. Both are <i>unary operators</i> because they take a single operand.</p>
<p class="TX">These operators can be used as either <i>prefix operators</i>, which appear before the operand, or <i>postfix operators</i>, which come after the operand. The prefix and postfix operators have different behaviors, which means they are commonly used as trick questions in quizzes and interviews. A prefix increment performs the increment before returning the value, whereas a postfix increment returns the value and then performs the increment. <a href="chapter4.xhtml#Lis4-2">Listing 4-2</a> illustrates these behaviors by performing a prefix or postfix increment or decrement operation and then assigning the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.</p>
<span id="Lis4-2"/>
<pre><code>int i = 5;
int e;    // expression result
e = i++;  // postfix increment: e ← 5, i ← 6
e = i--;  // postfix decrement: e ← 6, i ← 5
e = ++i;  // prefix increment: e ← 6, i ← 6
e = --i;  // prefix decrement: e ← 5, i ← 5</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: The prefix and postfix increment and decrement operators</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp> operation in this example returns the unchanged value <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>, which is then assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is then incremented as a side effect of the operation.</p>
<p class="TX">The <i>prefix</i> increment operator increments the value of the operand, and the expression returns the new value of the operand after it has been incremented. Consequently, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, except that <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is evaluated only once. The <samp class="SANS_TheSansMonoCd_W5Regular_11">++i</samp> operation in this example returns the incremented value <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>, which is then assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<span aria-label="78" epub:type="pagebreak" id="pg_78" role="doc-pagebreak"/>
<h2 class="H1" id="sec5"><span id="h1-35"/><samp class="SANS_Futura_Std_Bold_B_11">Operator Precedence and Associativity</samp></h2>
<p class="TNI">In mathematics and computer programming, the <i>order of operations</i> (or <i>operator precedence</i>) is a collection of rules that dictates the order in which operations are performed during the evaluation of an expression. For example, multiplication is granted a higher precedence than addition. Therefore, the expression 2 + 3 × 4 is interpreted to have the value 2 + (3 × 4) = 14, not (2 + 3) × 4 = 20.</p>
<p class="TX"><i>Associativity</i> determines how operators of the same precedence are grouped when no parentheses are used. C associativity differs from mathematics associativity. For example, while floating-point addition and multiplication are both commutative (<i>a</i> + <i>b</i> = <i>b</i> + <i>a</i> and <i>a</i> × <i>b</i> = <i>b</i> × <i>a</i>), they are not necessarily associative. If adjacent operators have equal precedence, the choice of which operation to apply first is determined by the associativity. <i>Left-associative</i> operators cause the operations to be grouped from the left, while <i>right-associative</i> operators cause the operations to be grouped from the right. You can think of grouping as the implicit introduction of parentheses. For example, the addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) operator has left associativity, so the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">((a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>. The assignment operator is right-associative, so the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">(a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c))</samp>.</p>
<p class="TX"><a href="chapter4.xhtml#tab4-1">Table 4-1</a>, derived from the C Operator Precedence table at the C++ References website (<i><a href="https://en.cppreference.com/w/c/language/operator_precedence">https://<wbr/>en<wbr/>.cppreference<wbr/>.com<wbr/>/w<wbr/>/c<wbr/>/language<wbr/>/operator<wbr/>_precedence</a></i>), lists the precedence and associativity of C operators, as specified by the language syntax. Operators are listed in order of descending precedence (that is, higher rows have higher precedence).</p>
<p class="TT" id="tab4-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Operator Precedence and Associativity</samp></p>
<span aria-label="79" epub:type="pagebreak" id="pg_79" role="doc-pagebreak"/>
<table class="Basic-Table1">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Associativity</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">(...)</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Forced grouping</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Left</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Postfix increment and decrement</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Left</samp></p></td>
</tr>
<tr>
<td class="TB"/>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">()</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Function call</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB"/>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Array subscripting</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB"/>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Structure and union member access</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB"/>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Structure and union member access through pointer</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB"/>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">){</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Compound literal</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">2</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Prefix increment and decrement</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Right</samp></p></td>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unary plus and minus</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">! ~</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Logical NOT and bitwise NOT</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">type</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Type cast</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Indirection (dereference)</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Address-of</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Size of</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Alignment requirement</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">3</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">* / %</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Multiplication, division, and remainder</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Left</samp></p></td>
</tr>
<tr>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Addition and subtraction</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">5</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt; &gt;&gt;</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Bitwise left shift and right shift</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt; &lt;=</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Relational operators &lt; and ≤</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt; &gt;=</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Relational operators &gt; and ≥</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">7</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Equal to and not equal to</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">8</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Bitwise AND</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">9</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Bitwise XOR (exclusive or)</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Bitwise OR (inclusive or)</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Logical AND</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">12</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Logical OR</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">13</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">? :</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Conditional operator</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Right</samp></p></td>
</tr>
<tr>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">14</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Simple assignment</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Assignment by sum and difference</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Assignment by product, quotient, and remainder</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;=</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Assignment by bitwise left shift and right shift</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TB gcell"/>
<td class="TB gcell"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp></p></td>
<td class="TB gcell"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Assignment by bitwise AND, XOR, and OR</samp></p></td>
<td class="TB gcell"/>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">15</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Expression sequencing</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Left</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Sometimes operator precedence can be intuitive, and sometimes it can be misleading. For example, the postfix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operators have higher precedence than both the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operators, which in turn have the same precedence as the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is a pointer, then <samp class="SANS_TheSansMonoCd_W5Regular_11">*p++</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(p++)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">++(*p)</samp>, because both the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> operator and the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator are right-associative. If two operators have the same precedence and associativity, they are evaluated from left to right. <a href="chapter4.xhtml#Lis4-3">Listing 4-3</a> illustrates the precedence rules among these operators.</p>
<span id="Lis4-3"/>
<pre><code>char cba[] = "cba";
char *p = cba;
printf("%c", ++*p);

char xyz[] = "xyz";
char *q = xyz;
printf("%c", *q++);</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: The operator precedence rules</samp></p>
<p class="TX"><span aria-label="80" epub:type="pagebreak" id="pg_80" role="doc-pagebreak"/>The pointer in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">++*p</samp> is first dereferenced, producing the <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> character. This value is then incremented, resulting in the character <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>. In this case, the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> operator operates on the object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and not the pointer. On the other hand, the pointer in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">*q++</samp> is incremented first, so it refers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> character. However, the result of <i>postfix</i> increment operators is the value of the operand so that the original pointer value is dereferenced, producing the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> character. Consequently, this code prints out the characters <samp class="SANS_TheSansMonoCd_W5Regular_11">dx</samp>. You can use parentheses to change or clarify the order of operations.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">

<h2 class="H1" id="sec6"><span id="h1-36"/><samp class="SANS_Futura_Std_Bold_B_11">Order of Evaluation</samp></h2>
<p class="TNI">The <i>order of evaluation</i> of the operands of any C operator, including the order of evaluation of any subexpressions, is generally unspecified. The compiler will evaluate them in any order and may choose a different order when the same expression is evaluated again. This latitude allows the compiler to produce faster code by choosing the most efficient order. The order of evaluation is constrained by operator precedence and associativity.</p>
<p class="TX"><a href="chapter4.xhtml#Lis4-4">Listing 4-4</a> demonstrates the order of evaluation for function arguments.</p>
<span id="Lis4-4"/>
<pre><code>int glob;  // static storage initialized to 0

int f(void) {
  return glob + 10;
}
int g(void) {
  glob = 42;
  return glob;
}
int main(void) {
  int max_value = max(f(), g());
  // <var>--snip--</var>
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: The order of evaluation for function arguments</samp></p>
<p class="TX">Both functions <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> access the global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">glob</samp>, meaning they rely on a shared state. Because the order of evaluation of functions <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> is unspecified, the arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> may differ between compilations. If <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is called first, it will return 10, but if it’s called last, it will return 52. Function <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> always returns 42 regardless of the order of evaluation. Consequently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> function (which returns the greater of the two values) may return either 42 or 52, depending on the order of evaluation of its arguments. The only <i>sequencing guarantees</i> provided by this code are that both <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> are called before <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> and that the executions of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> do not interleave.</p>
<p class="TX">We can rewrite this code as follows to ensure it always behaves in a predictable, portable manner:</p>

<pre><code><span aria-label="81" epub:type="pagebreak" id="pg_81" role="doc-pagebreak"/>int f_val = f();
int g_val = g();
int max_value = max(f_val, g_val);</code></pre>
<p class="TX">In this revised program, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is called to initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">f_val</samp> variable. This is guaranteed to be sequenced before the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>, which is called in the subsequent declaration to initialize the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">g_val</samp>. If one evaluation is <i>sequenced before</i> another evaluation, the first evaluation must complete before the second evaluation can begin. You can use sequence points (discussed in the following subsections) to guarantee that an object will be written before it is read. The execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> is guaranteed to be sequenced before the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> because a sequence point exists between the evaluation of one full expression and the next full expression.</p>
<section aria-labelledby="sec7" epub:type="division">

<h3 class="H2" id="sec7"><span id="h2-48"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsequenced and Indeterminately Sequenced Evaluations</samp></h3>
<p class="TNI">The executions of unsequenced evaluations can <i>interleave</i>, meaning that the instructions can be executed in any order, provided that reads and writes are performed in the order specified by the program. A program that performs reads and writes in the order specified by the program is <i>sequentially consistent</i> (Lamport 1979).</p>
<p class="TX">Some evaluations are <i>indeterminately sequenced</i>, which means they cannot interleave but can still be executed in any order. For example, the following statement contains several value computations and side effects:</p>

<pre><code>printf("%d\n", ++i + ++j * --k);</code></pre>
<p class="TX">The values of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> must be read before their values can be incremented or decremented. This means that the reading of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> must be sequenced before the increment side effect, for example. Similarly, all side effects for the operands of the multiplication operation need to complete before the multiplication can occur. The multiplication must complete before the addition because of operator precedence rules. Finally, all side effects on the operands of the addition operation must complete before the addition can occur. These constraints produce a partial ordering among these operations because they don’t require that <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> be incremented before <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> is decremented, for example. Unsequenced evaluations in this expression can be performed in any order, which allows the compiler to both reorder operations and to cache values in registers, allowing for faster overall execution. Function executions, on the other hand, are indeterminately sequenced and do not interleave with each other.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h3 class="H2" id="sec8"><span id="h2-49"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sequence Points</samp></h3>
<p class="TNI">A <i>sequence point</i> is the juncture at which all side effects will have completed. These are implicitly defined by the language, but you can control when they occur by how you code.</p>
<p class="TX">The sequence points are enumerated in Annex C of the C Standard. A sequence point occurs between the evaluation of one <i>full expression</i> (an <span aria-label="82" epub:type="pagebreak" id="pg_82" role="doc-pagebreak"/>expression that is not part of another expression or declarator) and the next full expression to be evaluated. A sequence point also occurs upon entering or exiting a called function.</p>
<p class="TX">If a side effect is unsequenced relative to either a different side effect on the same scalar or a value computation that uses the value of the same scalar object, the code has undefined behavior. A <i>scalar type</i> is either an arithmetic type or pointer type. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">* i++</samp> performs two unsequenced operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> as the following code snippet shows:</p>

<pre><code>int i = 5;
printf("Result = %d\n", i++ * i++);</code></pre>
<p class="TX">You might think this code will produce the value 30, but because it has undefined behavior, that outcome isn’t guaranteed.</p>
<p class="TX">Conservatively, we can ensure that side effects have completed before the value is read by placing every side-effecting operation in its own full expression. We can rewrite that code as follows to eliminate the undefined behavior:</p>

<pre><code>int i = 5;
int j = i++;
int k = i++;
printf("Result = %d\n", j * k);</code></pre>
<p class="TX">This example now contains a sequence point between every side-effecting operation. However, it’s impossible to tell whether this rewritten code represents the programmer’s original intent because the original code had no defined meaning. If you choose to omit sequence points, you must be sure you completely understand the sequencing of side effects. We also can write this same code as follows without changing the behavior:</p>

<pre><code>int i = 5;
int j = i++;
printf("Result = %d\n", j * i++);</code></pre>
<p class="TX">Now that we have described the mechanics of expressions, we’ll return to discussing specific operators.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">

<h2 class="H1" id="sec9"><span id="h1-37"/><samp class="SANS_Futura_Std_Bold_B_11">sizeof Operator</samp></h2>
<p class="TNI">We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator to find the size in bytes of its operand; specifically, it returns an unsigned integer of <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type that represents the size. Knowing the correct size of an operand is necessary for most memory operations, including allocating and copying storage. The <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type is defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stddef.h&gt;</samp> as well as in other header files. We need to include one of these header files to compile any code that references the <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type.</p>
<p class="TX">We can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator an unevaluated expression of a complete object type or a parenthesized name of such a type:</p>

<pre><code><span aria-label="83" epub:type="pagebreak" id="pg_83" role="doc-pagebreak"/>int i;
size_t i_size = sizeof i;      // the size of the object i
size_t int_size = sizeof(int); // the size of the type int</code></pre>
<p class="TX">It’s always safe to parenthesize the operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>, because parenthesizing an expression doesn’t change the way the size of the operand is calculated. The result of invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator is a constant expression unless the operand is a variable-length array. The operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> is not evaluated.</p>
<p class="TX">If you need to determine the number of bits of storage available, you can multiply the size of an object by <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>, which gives the number of bits contained in a byte. For example, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT * sizeof(int)</samp> will produce the number of bits in an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">

<h2 class="H1" id="sec10"><span id="h1-38"/><samp class="SANS_Futura_Std_Bold_B_11">Arithmetic Operators</samp></h2>
<p class="TNI">Operators that perform arithmetic operations on arithmetic types are detailed in the following sections. We can also use some of these operators with nonarithmetic operands.</p>
<section aria-labelledby="sec11" epub:type="division">

<h3 class="H2" id="sec11"><span id="h2-50"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unary + and –</samp></h3>
<p class="TNI">The <i>unary</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> <i>operators</i> operate on a single operand of arithmetic type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> operator returns the negative of its operand (that is, it behaves as though the operand were multiplied by –1). The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator just returns the value. These operators exist primarily to express positive and negative numbers.</p>
<p class="TX">If the operand has a small integer type, it’s promoted (see <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>), and the result of the operation has the result of the promoted type. As a point of trivia, C has no negative integer literals. A value such as <samp class="SANS_TheSansMonoCd_W5Regular_11">–25</samp> is actually an rvalue of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp> preceded by the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp> operator. However, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-25</samp> is guaranteed to be a constant integer expression.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">

<h3 class="H2" id="sec12"><span id="h2-51"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logical Negation</samp></h3>
<p class="TNI">The result of the unary logical negation operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>) is as follows:</p>
<ul class="ul">
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> if the evaluated value of its operand is not <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> if the evaluated value of its operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></li>
</ul>
<p class="TX">The operand is a scalar type. The result has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> for historical reasons. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">(0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">E</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>. The logical negation operator is frequently used to check for null pointers; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">!p</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">(nullptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">p)</samp>. Null pointers may not hold the value zero but are guaranteed to evaluate to false.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">

<h3 class="H2" id="sec13"><span id="h2-52"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Additive</samp></h3>
<p class="TNI">The binary additive operators include addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) and subtraction (<samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp>). We can apply addition and subtraction to two operands of arithmetic types, <span aria-label="84" epub:type="pagebreak" id="pg_84" role="doc-pagebreak"/>but we can also use them to perform scaled pointer arithmetic. I’ll discuss pointer arithmetic near the end of this chapter.</p>
<p class="TX">The binary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operator sums its two operands. The binary <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> operator subtracts the right operand from the left operand. The usual arithmetic conversions are performed on operands of arithmetic type for both operations.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">

<h3 class="H2" id="sec14"><span id="h2-53"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiplicative</samp></h3>
<p class="TNI">The binary multiplicative operators include multiplication (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>), division (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>), and remainder (<samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>). The usual arithmetic conversions are implicitly performed on multiplicative operands to find a common type. You can multiply and divide both floating-point and integer operands, but remainder operates only on integer operands.</p>
<p class="TX">Various programming languages implement different kinds of integer division operations, including Euclidean, flooring, and truncating. In <i>Euclidean division</i>, the remainder is always nonnegative (Boute 1992). In <i>flooring division</i>, the quotient is rounded toward negative infinity (Knuth 1997). In <i>truncating division</i>, the fractional part of the quotient is discarded, which is often referred to as <i>truncation toward zero</i>.</p>
<p class="TX">The C programming language implements truncating division, meaning that the remainder always has the same sign as the dividend, as shown in <a href="chapter4.xhtml#tab4-2">Table 4-2</a>.</p>
<p class="TT" id="tab4-2"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp> <samp class="SANS_Futura_Std_Book_11">Truncating Division</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">/</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Quotient</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">%</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Remainder</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">  10 / 3</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">  3</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">  10 % 3</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">  1</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">  10 / –3</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–3</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">  10 % –3</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">  1</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–10 / 3</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–3</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–10 % 3</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–1</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–10 / –3</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">  3</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–10 % –3</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">  1</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">To generalize, if the quotient <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp> is representable, then the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(a / b) * b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a % b</samp> equals <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. Otherwise, if the value of the divisor is equal to 0 or <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp> overflows, both <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">a % b</samp> will result in undefined behavior.</p>
<p class="TX">It’s worth taking the time to understand the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> operator to avoid surprises. For example, the following code defines a faulty function called <samp class="SANS_TheSansMonoCd_W5Regular_11">is_odd</samp> that attempts to test whether an integer is odd:</p>

<pre><code>bool is_odd(int n) {
  return n % 2 == 1;
}</code></pre>
<p class="TX">Because the result of the remainder operation always has the sign of the dividend <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>, when <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is negative and odd, <samp class="SANS_TheSansMonoCd_W5Regular_11">n % 2</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>, and the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.</p>
<p class="TX">A correct, alternative solution is to test that the remainder is not <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> (because a remainder of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> is the same regardless of the sign of the dividend):</p>

<pre><code><span aria-label="85" epub:type="pagebreak" id="pg_85" role="doc-pagebreak"/>bool is_odd(int n) {
  return n % 2 != 0;
}</code></pre>
<p class="TX">Many central processing units (CPUs) implement remainder as part of the division operator, which can overflow if the dividend is equal to the minimum negative value for the signed integer type and the divisor is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">−1</samp>. This occurs even though the mathematical result of such a remainder operation is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>
<p class="TX">The C standard library provides floating-point remainder, truncation, and rounding functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">fmod</samp>, among others.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">

<h2 class="H1" id="sec15"><span id="h1-39"/><samp class="SANS_Futura_Std_Bold_B_11">Bitwise Operators</samp></h2>
<p class="TNI">We use <i>bitwise operators</i> to manipulate the bits of an object or any integer expression. Bitwise operators (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>) treat the bits as a pure binary model without concern for the values represented by these bits. Typically, they’re used on objects that represent <i>masks</i> or <i>bitmaps</i> where each bit indicates that something is “on” or “off,” “enabled” or “disabled,” or some other binary pairing. Using a mask, multiple bits can be set, unset, or inverted in a single bitwise operation. Masks and bitmaps are best represented as unsigned integer types, as the sign bit can be better used as a value and unsigned operations are less prone to undefined behavior.</p>
<section aria-labelledby="sec16" epub:type="division">

<h3 class="H2" id="sec16"><span id="h2-54"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Complement</samp></h3>
<p class="TNI">The <i>unary complement operator</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>) works on a single operand of integer type and returns the <i>bitwise complement</i> of its operand—that is, a value in which each bit of the original value is flipped. The complement operator is used in applying the POSIX <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp>, for example. The <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp> masks or subtracts permissions. For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">umask</samp> of <samp class="SANS_TheSansMonoCd_W5Regular_11">077</samp> turns off read, write, and execute permissions for the group and others. A file’s permission mode is the result of a logical AND operation between the complement of the mask and the process’s requested permission mode setting.</p>
<p class="TX">Integer promotions are performed on the operand of the complement operator, and the result has the promoted type. For example, the following code snippet applies the <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operator to a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> type:</p>

<pre><code>unsigned char uc = UCHAR_MAX; // 0xFF
int i = ~uc;</code></pre>
<p class="TX">On an architecture with an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type and 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type, <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp> is assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>. When <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp> is used as the operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">uc</samp> is promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> by zero-extending it to 32 bits, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x000000FF</samp>. The complement of this value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFF00</samp>. Therefore, on this platform, complementing an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> type always results in a negative value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>. As a general policy and to avoid surprises such as this, bitwise <span aria-label="86" epub:type="pagebreak" id="pg_86" role="doc-pagebreak"/>operations should operate only on values of sufficiently wide unsigned integer types.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">

<h3 class="H2" id="sec17"><span id="h2-55"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shift</samp></h3>
<p class="TNI"><i>Shift operations</i> shift the value of each bit of an operand of integer type by a specified number of positions. Shifting is commonly performed in system programming, where bitmasks are common. Shift operations may also be used in code that manages network protocols or file formats to pack or unpack data. They include left-shift operations of the form</p>

<pre><code><var>shift expression &lt;&lt; additive expression</var></code></pre>
<p class="Continued">and right-shift operations of the form:</p>

<pre><code><var>shift expression &gt;&gt; additive expression</var></code></pre>
<p class="TX">The <i>shift expression</i> is the value to be shifted, and the <i>additive expression</i> is the number of bits by which to shift the value. <a href="chapter4.xhtml#fig4-1">Figure 4-1</a> illustrates a logical left shift of 1 bit.</p>
<figure class="IMG"><img alt="" class="img5" id="fig4-1" src="../images/f04001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A logical left shift of 1 bit</samp></p></figcaption>
</figure>
<p class="TX">The additive expression determines the number of bits by which to shift the value. For example, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1 &lt;&lt; E2</samp> is the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> left-shifted <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> bit positions; vacated bits are filled with zeros. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has an unsigned type, the resulting value is <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>. Values that cannot be represented in the resulting type will wrap around. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has a signed type and nonnegative value and if <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">×</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp> is representable in the result type, then that is the resulting value; otherwise, it is undefined behavior. Similarly, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1 &gt;&gt; E2</samp> is the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> right-shifted <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> bit positions. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has an unsigned type or if <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of <samp class="SANS_TheSansMonoCd_W5Regular_11">E1/2</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUP_11">E2</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> has a signed type and a negative value, the resulting value is implementation defined and may be either an arithmetic (sign-extended) shift or a logical (unsigned) shift, as shown in <a href="chapter4.xhtml#fig4-2">Figure 4-2</a>.</p>
<figure class="IMG"><img alt="" class="img1" id="fig4-2" src="../images/f04002.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: An arithmetic (signed) right shift and a logical (unsigned) right shift of 1 bit</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label="87" epub:type="pagebreak" id="pg_87" role="doc-pagebreak"/>In both shift operations, the integer promotions are performed on the operands, each of which has an integer type. The type of the result is that of the promoted left operand. The usual arithmetic conversions are <i>not</i> performed.</p>
<p class="TX"><a href="chapter4.xhtml#Lis4-5">Listing 4-5</a> shows how to perform right-shift operations on signed and unsigned integers that are free from undefined behavior.</p>
<span id="Lis4-5"/>
<pre><code>extern int si1, si2, sresult;
extern unsigned int ui1, ui2, uresult;
// <var>--snip--</var>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> if ((si2 &lt; 0) || (si2 &gt;= sizeof(si1)*CHAR_BIT)) {
  /* error */
}
else {
  sresult = si1 &gt;&gt; si2;
}
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> if (ui2 &gt;= sizeof(unsigned int)*CHAR_BIT) {
  /* error */
}
else {
  uresult = ui1 &gt;&gt; ui2;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Correct right-shift operations</samp></p>
<p class="TX">For signed integers <span aria-label="annotation1" class="CodeAnnotation">❶</span>, you must ensure that the number of bits shifted is not negative, greater than, or equal to the width of the promoted left operand. For unsigned integers <span aria-label="annotation2" class="CodeAnnotation">❷</span>, you omit the test for negative values, as unsigned integers can never be negative. You can perform safe left-shift operations in a similar manner.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">

<h3 class="H2" id="sec18"><span id="h2-56"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise AND</samp></h3>
<p class="TNI">The binary <i>bitwise AND operator</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>) returns the bitwise AND of two operands of integer type. The usual arithmetic conversions are performed on both operands. Each bit in the result is set if and only if each of the corresponding bits in the converted operands is set, as shown in <a href="chapter4.xhtml#tab4-3">Table 4-3</a>.</p>
<p class="TT" id="tab4-3"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise AND Truth Table</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">y</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&amp;</samp> <samp class="SANS_Futura_Std_Heavy_B_11">y</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
</tr>
</tbody>
</table>
</section>
<section aria-labelledby="sec19" epub:type="division">
<span aria-label="88" epub:type="pagebreak" id="pg_88" role="doc-pagebreak"/>
<h3 class="H2" id="sec19"><span id="h2-57"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise Exclusive OR</samp></h3>
<p class="TNI">The <i>bitwise exclusive OR operator</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>) returns the bitwise exclusive OR of the operands of integer type. The operands must be integers, and the usual arithmetic conversions are performed on both. Each bit in the result is set if and only if exactly one of the corresponding bits in the converted operands is set, as shown in <a href="chapter4.xhtml#tab4-4">Table 4-4</a>. You can also think of this operation as “one or the other, but not both.”</p>
<p class="TT" id="tab4-4"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-4:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise Exclusive OR Truth Table</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">y</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">^</samp> <samp class="SANS_Futura_Std_Heavy_B_11">y</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Exclusive OR is equivalent to the addition operation on the integers modulo 2—that is, because of wraparound 1 + 1 mod 2 = 0 (Lewin 2012).</p>
<p class="TX">Beginners commonly mistake the exclusive OR operator for an exponent operator, erroneously believing that the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> will compute 2 raised to the power of 7. The correct way to raise a number to a certain power in C is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp> functions defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp>, as shown in <a href="chapter4.xhtml#Lis4-6">Listing 4-6</a>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp> functions operate on floating-point arguments and return a floating-point result, so be aware that these functions might fail to produce the expected results because of truncation or other errors.</p>
<span id="Lis4-6"/>
<pre><code>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int main(void) {
  int i = 128;
  if (i == pow(2, 7)) {
    puts("equal");
  }
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Using the</samp> <samp class="I">pow</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">functions</samp></p>
<p class="TX">This code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pow</samp> function to compute 2 raised to the power of 7. Because 2<sup>7</sup> equals 128, this program will print <samp class="SANS_TheSansMonoCd_W5Regular_11">equal</samp>.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">

<h3 class="H2" id="sec20"><span id="h2-58"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bitwise Inclusive OR</samp></h3>
<p class="TNI">The <i>bitwise inclusive OR</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>) <i>operator</i> returns the bitwise inclusive OR of two operands. Each bit in the result is set if and only if at least one of the corresponding bits in the converted operands is set, as shown in <a href="chapter4.xhtml#tab4-5">Table 4-5</a>.</p>
<p class="TT" id="tab4-5"><span aria-label="89" epub:type="pagebreak" id="pg_89" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-5:</samp> <samp class="SANS_Futura_Std_Book_11">Bitwise Inclusive OR Truth Table</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">y</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">|</samp> <samp class="SANS_Futura_Std_Heavy_B_11">y</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The operands must be integers, and the usual arithmetic conversions are performed on both.</p>
</section>
</section>
<section aria-labelledby="sec21" epub:type="division">

<h2 class="H1" id="sec21"><span id="h1-40"/><samp class="SANS_Futura_Std_Bold_B_11">Logical Operators</samp></h2>
<p class="TNI">The <i>logical AND</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp>) and <i>OR</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>) <i>operators</i> are used primarily for logically joining two or more expressions of scalar type. They’re commonly used in condition tests to combine multiple comparisons together, such as in the first operand of the conditional operator, the controlling expression of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, or the controlling expression of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. You shouldn’t use logical operators with bitmap operands, as they are intended primarily for Boolean logic.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp> operator returns 1 if neither of its operands is equal to 0 and returns 0 otherwise. Logically, this means that <samp class="SANS_TheSansMonoCd_W5Regular_11">a &amp;&amp; b</samp> is true only if both <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is true and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is true.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operator returns 1 if either of its operands is not equal to 0 and returns 0 otherwise. Logically, this means that <samp class="SANS_TheSansMonoCd_W5Regular_11">a || b</samp> is true if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is true, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is true, or both <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are true.</p>
<p class="TX">The C standard defines both operations in terms of “not equal to zero” because the operands can have values other than 0 and 1. Both operators accept operands of scalar type (integers, floats, and pointers), and the result of the operation has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>
<p class="TX">Unlike the corresponding bitwise binary operators, the logical AND operator and logical OR operator guarantee left-to-right evaluation. Both operators <i>short-circuit</i>: The second operand is not evaluated if the result can be deduced solely by evaluating the first operand. If the second operand is evaluated, there is a sequence point between the evaluations of the first and second operands. For example, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">0 &amp;&amp; unevaluated</samp> returns 0 regardless of the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp> because there is no possible value for <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp> that produces a different result. Because of this, <samp class="SANS_TheSansMonoCd_W5Regular_11">unevaluated</samp> is not evaluated to determine its value. The same is true for <samp class="SANS_TheSansMonoCd_W5Regular_11">1 || unevaluated</samp> because this expression always returns 1.</p>
<p class="TX">Short-circuiting is commonly used in operations with pointers:</p>

<pre><code>bool isN(int* ptr, int n) {
  return ptr &amp;&amp; *ptr == n; // avoid a null pointer dereference
}</code></pre>
<p class="TX"><span aria-label="90" epub:type="pagebreak" id="pg_90" role="doc-pagebreak"/>This code tests the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is null, the second <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp> operand is not evaluated, preventing a null pointer dereference.</p>
<p class="TX">Short-circuiting can also be used to avoid unnecessary computing. In the following expression, the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp> predicate function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if the file is ready:</p>

<pre><code>is_file_ready() || prepare_file()</code></pre>
<p class="TX">When the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_file_ready</samp> function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, the second <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operand is not evaluated, as there is no need to prepare the file. This avoids potential errors or, when <samp class="SANS_TheSansMonoCd_W5Regular_11">prepare_file</samp> is idempotent, unnecessary computing, assuming the cost of determining whether the file is ready is less than the cost of preparing the file.</p>
<p class="TX">Programmers should exercise caution if the second operand contains side effects, because it may not be apparent whether these side effects occur. For example, in the following code, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is incremented only when <samp class="SANS_TheSansMonoCd_W5Regular_11">i &gt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>:</p>

<pre><code>enum {max = 15};
int i = 17;

if ((i &gt;= 0) &amp;&amp; ((i++) &lt;= max)) {
  // <var>--snip--</var>
}</code></pre>
<p class="Continued">This code may be correct, but it’s likely a programmer error.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">

<h2 class="H1" id="sec22"><span id="h1-41"/><samp class="SANS_Futura_Std_Bold_B_11">Cast Operators</samp></h2>
<p class="TNI"><i>Casts</i> (also known as <i>type casts</i>) explicitly convert a value of one type to a value of another type. To perform a cast, we precede an expression with a parenthesized type name, which converts the value of the expression to the unqualified version of the named type. The following code illustrates an explicit conversion, or cast, of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> from type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:</p>

<pre><code>double x = 1.2;
int sum = (int)x + 1;  // explicit conversion from double to int</code></pre>
<p class="TX">Unless the type name specifies a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type, the type name must be a qualified or unqualified scalar type. The operand must also have scalar type; a pointer type cannot be converted to any floating-point type, and vice versa.</p>
<p class="TX">Casts are extremely powerful and must be used carefully. For one thing, casts may reinterpret the existing bits as a value of the specified type without changing the bits:</p>

<pre><code>intptr_t i = (intptr_t)a_pointer; // reinterpret bits as an integer</code></pre>
<p class="TX"><span aria-label="91" epub:type="pagebreak" id="pg_91" role="doc-pagebreak"/>Casts may also change these bits into whatever bits are needed to represent the original value in the resulting type:</p>

<pre><code>int i = (int)a_float; // change bits to an integer representation</code></pre>
<p class="TX">Casts can also disable diagnostics. For example:</p>

<pre><code>char c;
// <var>--snip--</var>
while ((c = fgetc(in)) != EOF) {
  // <var>--snip--</var>
}</code></pre>
<p class="TX">This generates the following diagnostic when compiled with Visual C++ 2022 with warning level <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp>:</p>

<pre><code>Severity  Code   Description
Warning   C4244  '=': conversion from 'int' to 'char', possible loss of data</code></pre>
<p class="TX">Adding a cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> disables the diagnostic without fixing the problem:</p>

<pre><code>char c;
while ((c = <b>(char)</b>fgetc(in)) != EOF) {
  // <var>--snip--</var>
}</code></pre>
<p class="TX">To mitigate these risks, C++ defines its own casts, which are less powerful.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">

<h2 class="H1" id="sec23"><span id="h1-42"/><samp class="SANS_Futura_Std_Bold_B_11">Conditional Operator</samp></h2>
<p class="TNI">The <i>conditional operator</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">? :</samp>) is the only C operator that takes three operands. It returns a result based on the condition. You can use the conditional operator like this:</p>

<pre><code>result = condition ? valueReturnedIfTrue : valueReturnedIfFalse;</code></pre>
<p class="TX">The conditional operator evaluates the first operand, called the <i>condition</i>. The second operand (<samp class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfTrue</samp>) is evaluated if the condition is true, or the third operand (<samp class="SANS_TheSansMonoCd_W5Regular_11">valueReturnedIfFalse</samp>) is evaluated if the condition is false. The result is the value of either the second or third operand (depending on which operand was evaluated).</p>
<p class="TX">This result is converted to a common type based on the second and third operands. There is a sequence point between the evaluation of the first operand and the evaluation of the second or third operand (whichever is evaluated) so that the compiler will ensure that all side effects resulting from evaluating the condition have completed before the second or third operand is evaluated.</p>
<p class="TX"><span aria-label="92" epub:type="pagebreak" id="pg_92" role="doc-pagebreak"/>The conditional operator is similar to an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> control flow block but returns a value as a function does. Unlike with an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> control flow block, you can use the conditional operator to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified object:</p>

<pre><code>const int x = (a &lt; b) ? b : a;</code></pre>
<p class="TX">The first operand to the conditional operator must have scalar type. The second and third operands must have compatible types (roughly speaking). For more details on the constraints for this operator and the specifics of determining the return type, refer to Section 6.5.15 of the C standard (ISO/IEC 9899:2024).</p>
</section>
<section aria-labelledby="sec24" epub:type="division">

<h2 class="H1" id="sec24"><span id="h1-43"/><samp class="SANS_Futura_Std_Bold_B_11">alignof Operator</samp></h2>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp> operator yields an integer constant representing the alignment requirement of its operand’s declared complete object type. It does not evaluate the operand. When applied to an <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> type, it returns the alignment requirement of the element type. An alternative spelling of <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp> is available for this operator. Prior to C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp> spelling was available through a convenience macro provided in the header <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdalign.h&gt;</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp> operator is useful in static assertions that are used to verify assumptions about your program (discussed further in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>). The purpose of these assertions is to diagnose situations in which your assumptions are invalid. <a href="chapter4.xhtml#Lis4-7">Listing 4-7</a> demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp> operator.</p>
<span id="Lis4-7"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdalign.h&gt;
#include &lt;assert.h&gt;

int main(void) {
  int arr[4];
  static_assert(alignof(arr) == 4, "unexpected alignment");
  static_assert(alignof(max_align_t) == 16, "unexpected alignment");
  printf("Alignment of arr = %zu\n", alignof(arr));
  printf("Alignment of max_align_t = %zu\n", alignof(max_align_t));
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: The</samp> <samp class="I">alignof</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator</samp></p>
<p class="TX">This simple program doesn’t accomplish anything particularly useful. It declares an array <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> of four integers followed by a static assertion concerning the alignment of the array and a runtime assertion concerning the alignment of <samp class="SANS_TheSansMonoCd_W5Regular_11">max_align_t</samp> (an object type whose alignment is the greatest fundamental alignment). It then prints out these values. This program will not compile if either static assertion is false, or it will output the following:</p>

<pre><code>Alignment of arr = 4
Alignment of max_align_t = 16</code></pre>
<p class="TX">These alignments are characteristic of the x86-64 architecture.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<span aria-label="93" epub:type="pagebreak" id="pg_93" role="doc-pagebreak"/>
<h2 class="H1" id="sec25"><span id="h1-44"/><samp class="SANS_Futura_Std_Bold_B_11">Relational Operators</samp></h2>
<p class="TNI">The <i>relational operators</i> include equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>), not equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>), less than (<samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp>), greater than (<samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp>), less than or equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp>), and greater than or equal to (<samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</samp>). Each returns 1 if the specified relationship is true and 0 if it is false. The result has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, again, for historical reasons.</p>
<p class="TX">Note that C does not interpret the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b &lt; c</samp> to mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> but less than <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, as ordinary mathematics does. Instead, the expression is interpreted to mean <samp class="SANS_TheSansMonoCd_W5Regular_11">(a &lt; b) &lt; c</samp>. In English, if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, the compiler should compare <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>; otherwise, it compares <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. If this is your intent, include the parentheses to make that clear to any potential code reviewer. Some compilers such as GCC and Clang provide the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wparentheses</samp> flag to diagnose those problems. To determine whether <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> but less than <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, you can write this test: <samp class="SANS_TheSansMonoCd_W5Regular_11">(a &lt; b) &amp;&amp; (b &lt; c)</samp>.</p>
<p class="TX">The equality and inequality operators have lower precedence than the relational operators—and assuming otherwise is a common mistake. This means that the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c &lt; d</samp> is evaluated the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">(a &lt; b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(c &lt; d)</samp>. In both cases, the comparisons <samp class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">c &lt; d</samp> are evaluated first, and the resulting values (either <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>) are compared for equality.</p>
<p class="TX">We can use these operators to compare arithmetic types or pointers. When we compare two pointers, the result depends on the relative locations in the address space of the objects pointed to. If both pointers point to the same object, they are equal.</p>
<p class="TX">Equality and inequality operators differ from the other relational operators. For example, you cannot use the other relational operators on two pointers to unrelated objects, because doing so makes no sense and is consequently undefined behavior:</p>

<pre><code>int i, j;
bool b1 = &amp;i &lt; &amp;j;  // undefined behavior
bool b2 = &amp;i == &amp;j; // OK, but tautologically false</code></pre>
<p class="TX">You might compare pointers, for example, to determine whether you have reached the too-far element of an array.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">

<h2 class="H1" id="sec26"><span id="h1-45"/><samp class="SANS_Futura_Std_Bold_B_11">Compound Assignment Operators</samp></h2>
<p class="TNI"><i>Compound assignment operators</i>, shown in <a href="chapter4.xhtml#tab4-6">Table 4-6</a>, modify the current value of an object by performing an operation on it.</p>
<p class="TT" id="tab4-6"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-6:</samp> <samp class="SANS_Futura_Std_Book_11">Compound Assignment Operators</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assignment by</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Sum and difference</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Product, quotient, and remainder</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;=</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Bitwise left shift and right shift</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;= ^=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Bitwise AND, XOR, and OR</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label="94" epub:type="pagebreak" id="pg_94" role="doc-pagebreak"/>A compound assignment of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> <i>=</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">E2</samp> is equivalent to the simple assignment expression <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(E2)</samp>, except that <samp class="SANS_TheSansMonoCd_W5Regular_11">E1</samp> is evaluated only once. Compound assignments are primarily used as shorthand notation. There are no compound assignment operators for logical operators.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">

<h2 class="H1" id="sec27"><span id="h1-46"/><samp class="SANS_Futura_Std_Bold_B_11">Comma Operator</samp></h2>
<p class="TNI">In C, we use commas in two distinct ways: as operators and to separate items in a list (such as arguments to functions or lists of declarations). The <i>comma</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>) <i>operator</i> is a way to evaluate one expression before another. First, the left operand of a comma operator is evaluated as a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> expression. There is a sequence point between the evaluation of the left operand and the evaluation of the right operand. Then, the right operand is evaluated after the left. The comma operation has the type and value of the right operand—mostly because it is the last expression evaluated.</p>
<p class="TX">You can’t use the comma operator in contexts in which a comma might separate items in a list. Instead, you would include a comma within a parenthesized expression or within the second expression of a conditional operator. For example, assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> each have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in the following call to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>:</p>

<pre><code>f(a, (t=3, t+2), c)</code></pre>
<p class="TX">The first comma separates the first and second arguments to the function. The second comma is a comma operator. The assignment is evaluated first, followed by the addition. Because of the sequence point, the assignment is guaranteed to complete before the addition takes place. The result of the comma operation has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and value <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. The third comma separates the second and third arguments to the function.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">

<h2 class="H1" id="sec28"><span id="h1-47"/><samp class="SANS_Futura_Std_Bold_B_11">Pointer Arithmetic</samp></h2>
<p class="TNI">Earlier in this chapter, we mentioned that the additive operators (addition and subtraction) can be used with either arithmetic operands or object pointers. In this section, we discuss adding a pointer and an integer, subtracting two pointers, and subtracting an integer from a pointer.</p>
<p class="TX">Adding or subtracting an expression that has an integer type to or from a pointer returns a value with the type of the pointer operand. If the pointer operand points to an element of an array, then the result points to an element offset from the original element. If the resulting pointer is beyond the bounds of the array, undefined behavior occurs. The difference of the array subscripts of the resulting and original array elements equals the integer expression:</p>

<pre><code>int arr[100];
int *arrp1 = &amp;arr[40];
int *arrp2 = arrp1 + 20; // arrp2 points to arr[60]
printf("%td\n", arrp2 - arrp1); // prints 20</code></pre>
<p class="TX"><span aria-label="95" epub:type="pagebreak" id="pg_95" role="doc-pagebreak"/>Pointer arithmetic is automatically <i>scaled</i> to the size of the array element, rather than individual bytes. C allows a pointer to be formed to each element of an array, including one past the last element of the array object (also referred to as the <i>too-far</i> pointer). While this might seem unusual or unnecessary, many early C programs incremented a pointer until it was equal to the too-far pointer, and the C standards committee didn’t want to break all this code, which is also idiomatic in C++ iterators. <a href="chapter4.xhtml#fig4-3">Figure 4-3</a> illustrates forming the <i>too-far</i> pointer.</p>
<figure class="IMG"><img alt="" class="img5" id="fig4-3" src="../images/f04003.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: One past the last element of an array object</samp></p></figcaption>
</figure>
<p class="TX">If both the pointer operand and the result point to elements of the same array object or the too-far pointer, the evaluation did not overflow; otherwise, the behavior is undefined. To satisfy the too-far requirement, an implementation need only provide one extra byte (which can overlap another object in the program) just after the end of the object.</p>
<p class="TX">C also allows objects to be treated as an array containing only a single element, allowing you to obtain a too-far pointer from a scalar.</p>
<p class="TX">The too-far special case allows us to advance a pointer until it is equal to the too-far pointer, as in the following function:</p>

<pre><code>int m[2] = {1, 2};

int sum_m_elems(void) {
  int *pi; int j = 0;
  for (pi = &amp;m[0]; pi &lt; &amp;m[2]; ++pi) j += *pi;
  return j;
}</code></pre>
<p class="TX">Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement (explained in detail in the next chapter) in the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum_m_elems</samp> function loops while <samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp> is less than the address of the too-far pointer for the array <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>. The pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pi</samp> is incremented at the end of each iteration of the loop until the too-far pointer is formed, causing the loop condition to evaluate to 0 when tested.</p>
<p class="TX">When we subtract one pointer from another, both must point to elements of the same array object or the too-far element. This operation returns the difference of the subscripts of the two array elements. The type of the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp> (a signed integer type). You should take care when subtracting pointers, because the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp> may not be sufficient to represent the difference of pointers to elements of very large character arrays.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<span aria-label="96" epub:type="pagebreak" id="pg_96" role="doc-pagebreak"/>
<h2 class="H1" id="sec29"><span id="h1-48"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned how to use operators to write simple expressions that perform operations on various object types. Along the way, you learned about some core C concepts, such as lvalues, rvalues, value computations, and side effects, which determine how expressions are evaluated. You also learned how operator precedence, associativity, order of evaluation, sequencing, and interleaving can affect the total order in which a program is executed. In the next chapter, you’ll learn more about how to control the execution of your program by using selection, iteration, and jump statements.</p>
</section>
</section>
</body></html>