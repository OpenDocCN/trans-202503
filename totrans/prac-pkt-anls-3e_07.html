<html><head></head><body>
<h2 class="h2"><a id="ch07"/><span epub:type="pagebreak" id="page_119"/><strong><span class="big">7</span></strong><br/><strong>NETWORK LAYER PROTOCOLS</strong></h2>&#13;
<div class="image"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindent"><span class="big1">Whether you’re troubleshooting latency issues, identifying malfunctioning applications, or zeroing in on security threats in order to spot abnormal traffic, you must first understand normal traffic. In the next couple of chapters, you’ll learn how normal network traffic works at</span> the packet level as we journey from the bottom of the OSI model all the way to the top. Each protocol section has at least one associated capture file, which you can download and work with directly.</p>&#13;
<p class="indent">In this chapter, we’ll specifically focus on the network layer protocols that are the workhorses of network communication: ARP, IPv4, IPv6, ICMP, and ICMPv6.</p>&#13;
<p class="indent">The next three chapters on network protocols are arguably the most important chapters in this book. Skipping this discussion would be like making Thanksgiving dinner without preheating the oven. Even if you already have a good grasp of how each protocol functions, give these chapters at least a quick read in order to review the packet structure of each.</p>&#13;
<h3 class="h3"><a id="ch07lev1sec1"/><span epub:type="pagebreak" id="page_120"/><strong>Address Resolution Protocol (ARP)</strong></h3>&#13;
<p class="noindent">Both logical and physical addresses are used for communication on a network. Logical addresses allow for communication among multiple networks and indirectly connected devices. Physical addresses facilitate communication on a single network segment for devices that are directly connected to each other with a switch. In most cases, these two types of addressing must work together in order for communication to occur.</p>&#13;
<p class="indent">Consider a scenario in which you wish to communicate with a device on your network. This device may be a server of some sort or just another workstation you need to share files with. The application you are using to initiate the communication is already aware of the remote host’s IP address (via DNS, covered in <a href="ch09.xhtml#ch09">Chapter 9</a>), meaning the system should have all it needs to build the layer 3 through 7 information of the packet it wants to transmit. The only piece of information it needs at this point is the layer 2 data link information containing the MAC address of the target host.</p>&#13;
<p class="indent">MAC addresses are needed because a switch that interconnects devices on a network uses a <em>Content Addressable Memory (CAM) table</em>, which lists the MAC addresses of all devices plugged into each of its ports. When the switch receives traffic destined for a particular MAC address, it uses this table to know which port to send the traffic through. If the destination MAC address is unknown, the transmitting device will first check for the address in its cache; if the address isn’t there, then it must be resolved through additional communication on the network.</p>&#13;
<p class="indent">The resolution process that TCP/IP networking (with IPv4) uses to resolve an IP address to a MAC address is called the <em>Address Resolution Protocol (ARP)</em>, which is defined in RFC 826. The ARP resolution process uses only two packets: an ARP request and an ARP response (see <a href="ch07.xhtml#ch07fig1">Figure 7-1</a>).</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>An RFC, or Request for Comments, is a technical publication from the Internet Engineering Task Force (IETF) and Internet Society (ISOC) and is the mechanism used to define the implementation standards for protocols. You can search for RFC documentation at the RFC Editor home page,</em> http://www.rfc-editor.org/.</p>&#13;
</div>&#13;
<p class="indent">The transmitting computer sends out an ARP request that basically says, “Howdy, everybody. My IP address is 192.168.0.101, and my MAC address is f2:f2:f2:f2:f2:f2. I need to send something to whoever has the IP address 192.168.0.1, but I don’t know the hardware address. Will whoever has this IP address please respond with your MAC address?”</p>&#13;
<p class="indent">This packet is broadcast to every device on the network segment. Any device that doesn’t have this IP address simply discards the packet. The device that does have the address sends an ARP reply with an answer such as “Hey, transmitting device, I’m the one you’re looking for with the IP address 192.168.0.1. My MAC address is 02:f2:02:f2:02:f2.”</p>&#13;
<p class="indent">Once this resolution process is completed, the transmitting device updates its cache with the MAC-to-IP address association of the receiving device and can begin sending data.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_121"/><img alt="image" src="../images/f121-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig1"/><em>Figure 7-1: The ARP resolution process</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>You can view the ARP table of a Windows host by typing <span class="literal">arp –a</span> from a command prompt.</em></p>&#13;
</div>&#13;
<p class="indent">Seeing this process in action will help you understand how it works. But before we look at some examples, let’s examine the ARP packet header.</p>&#13;
<h4 class="h4"><a id="ch07lev2sec1"/><strong><em>ARP Packet Structure</em></strong></h4>&#13;
<p class="noindenta">As shown in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>, the ARP header includes the following fields:</p>&#13;
<p class="noindentla"><strong>Hardware Type</strong>   The layer 2 type used—in most cases, this is Ethernet (type 1)</p>&#13;
<p class="noindentla"><strong>Protocol Type</strong>   The higher-layer protocol for which the ARP request is being used</p>&#13;
<p class="noindentla"><strong>Hardware Address Length</strong>   The length (in octets/bytes) of the hardware address in use (6 for Ethernet)</p>&#13;
<p class="noindentla"><strong>Protocol Address Length</strong>   The length (in octets/bytes) of the logical address of the specified protocol type</p>&#13;
<p class="noindentla"><strong>Operation</strong>   The function of the ARP packet: either 1 for a request or 2 for a reply</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_122"/><img alt="image" src="../images/f122-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig2"/><em>Figure 7-2: The ARP packet structure</em></p>&#13;
<p class="noindentla"><strong>Sender Hardware Address</strong>   The hardware address of the sender</p>&#13;
<p class="noindentla"><strong>Sender Protocol Address</strong>   The sender’s upper-layer protocol address</p>&#13;
<p class="noindentla"><strong>Target Hardware Address</strong>   The intended receiver’s hardware address (all zeroes in ARP requests)</p>&#13;
<p class="noindentl"><strong>Target Protocol Address</strong>   The intended receiver’s upper-layer protocol address</p>&#13;
<div class="note1">&#13;
<p class="noindent"><em>arp_resolution.pcapng</em></p>&#13;
</div>&#13;
<p class="indent">Now open the file <em>arp_resolution.pcapng</em> to see this resolution process in action. We’ll focus on each packet individually as we walk through this process.</p>&#13;
<h4 class="h4"><a id="ch07lev2sec2"/><strong><em>Packet 1: ARP Request</em></strong></h4>&#13;
<p class="noindent">The first packet is the ARP request, as shown in <a href="ch07.xhtml#ch07fig3">Figure 7-3</a>. We can confirm that this packet is a true broadcast packet by examining the Ethernet header in Wireshark’s Packet Details pane. The packet’s destination address is ff:ff:ff:ff:ff:ff <span class="ent">➊</span>. This is the Ethernet broadcast address, and anything sent to it will be broadcast to all devices on the current network segment. The source address of this packet in the Ethernet header is listed as our MAC address <span class="ent">➋</span>.</p>&#13;
<p class="indent">Given this structure, we can discern that this is indeed an ARP request on an Ethernet network using IPv4. The sender’s IP address (192.168.0.114) and MAC address (00:16:ce:6e:8b:24) are listed <span class="ent">➌</span>, as is the IP address of the target (192.168.0.1) <span class="ent">➎</span>. The MAC address of the target—the information we are trying to get—is unknown, so the target MAC is listed as 00:00:00:00:00:00 <span class="ent">➍</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_123"/><img alt="image" src="../images/f123-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig3"/><em>Figure 7-3: An ARP request packet</em></p>&#13;
<h4 class="h4"><a id="ch07lev2sec3"/><strong><em>Packet 2: ARP Response</em></strong></h4>&#13;
<p class="noindenta">In the response to the initial request (see <a href="ch07.xhtml#ch07fig4">Figure 7-4</a>), the Ethernet header now has a destination address of the source MAC address from the first packet. The ARP header looks similar to that of the ARP request, with a few changes:</p>&#13;
<p class="bullet">•     The packet’s operation code (opcode) is now 0x0002 <span class="ent">➊</span>, indicating a reply rather than a request.</p>&#13;
<p class="bullet">•     The addressing information is reversed—the sender MAC address and IP address are now the target MAC address and IP address <span class="ent">➌</span>.</p>&#13;
<p class="bulleta">•     Most important, all the information is present, meaning we now have the MAC address (00:13:46:0b:22:ba) <span class="ent">➋</span> of our host at 192.168.0.1.</p>&#13;
<div class="image"><img alt="image" src="../images/f123-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig4"/><em>Figure 7-4: An ARP reply packet</em></p>&#13;
<h4 class="h4"><a id="ch07lev2sec4"/><span epub:type="pagebreak" id="page_124"/><strong><em>Gratuitous ARP</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>arp_gratuitous.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">Where I come from, when something is done “gratuitously,” the word usually carries a negative connotation. A <em>gratuitous ARP</em>, however, is a good thing.</p>&#13;
<p class="indent">In many cases, a device’s IP address can change. When this happens, the IP-to-MAC address mappings that hosts on the network have in their caches will be invalid. To prevent this from causing communication errors, a gratuitous ARP packet is transmitted on the network to force any device that receives it to update its cache with the new IP-to-MAC address mapping (see <a href="ch07.xhtml#ch07fig5">Figure 7-5</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f124-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig5"/><em>Figure 7-5: The gratuitous ARP process</em></p>&#13;
<p class="indent">A few different scenarios can spawn a gratuitous ARP packet. One of the most common is the changing of an IP address. Open the capture file <em>arp_gratuitous.pcapng</em>, and you’ll see this in action. This file contains only a single packet (see <a href="ch07.xhtml#ch07fig6">Figure 7-6</a>) because that’s all that’s involved in gratuitous ARP.</p>&#13;
<div class="image"><img alt="image" src="../images/f124-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig6"/><em>Figure 7-6: A gratuitous ARP packet</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_125"/>Examining the Ethernet header, you can see that this packet is sent as a broadcast so that all hosts on the network receive it <span class="ent">➊</span>. The ARP header looks like an ARP request, except that the sender IP address <span class="ent">➋</span> and the target IP address <span class="ent">➌</span> are the same. When received by other hosts on the network, this packet will cause them to update their ARP tables with the new IP-to-MAC address association. Because this ARP packet is unsolicited but results in a client updating its ARP cache, the packet is considered gratuitous.</p>&#13;
<p class="indent">You’ll notice gratuitous ARP packets in a few situations. As mentioned, changing a device’s IP address will generate a gratuitous packet. Also, some operating systems will perform a gratuitous ARP on startup. Additionally, some systems use gratuitous ARP packets to support load balancing.</p>&#13;
<h3 class="h3"><a id="ch07lev1sec2"/><strong>Internet Protocol (IP)</strong></h3>&#13;
<p class="noindent">The primary purpose of protocols at layer 3 of the OSI model is to allow for communication between networks. As you just saw, MAC addresses are used for communication on a single network at layer 2. In much the same fashion, layer 3 is responsible for addresses used in internetwork communication. A few protocols can do this, but the most common is the <em>Internet Protocol (IP)</em>, which currently has two versions in use—IP version 4 and IP version 6. We’ll start by examining IP version 4 (IPv4), which is defined in RFC 791.</p>&#13;
<h4 class="h4"><a id="ch07lev2sec5"/><strong><em>Internet Protocol Version 4 (IPv4)</em></strong></h4>&#13;
<p class="noindent">To understand the functionality of IPv4, you need to know how traffic flows between networks. IPv4 is the workhorse of the communication process and is ultimately responsible for carrying data between devices, regardless of where the communication endpoints are located.</p>&#13;
<p class="indent">A simple network in which all devices are connected via hubs or switches is called a <em>local area network (LAN)</em>. When you want to connect two LANs, you can do so with a router. Complex networks can consist of thousands of LANs connected through thousands of routers worldwide. The internet itself is a collection of millions of LANs and routers.</p>&#13;
<h5 class="h5"><strong>IPv4 Addresses</strong></h5>&#13;
<p class="noindent"><em>IPv4 addresses</em> are 32-bit assigned numbers used to uniquely identify devices connected to a network. It’s a bit much to expect someone to remember a sequence of ones and zeros that is 32 characters long, so IP addresses are written in <em>dotted-quad</em> (or <em>dotted-decimal</em>) <em>notation</em>.</p>&#13;
<p class="indent">In dotted-quad notation, each of the four sets of ones and zeros that make up an IP address is converted to base 10 and represented as a number between 0 and 255 in the format <em>A.B.C.D</em> (see <a href="ch07.xhtml#ch07fig7">Figure 7-7</a>). For example, consider the IP address 11000000 10101000 00000000 00000001. This value is obviously a bit much to remember or notate. Fortunately, using dotted-quad notation, we can represent it as 192.168.0.1.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_126"/><img alt="image" src="../images/f126-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig7"/><em>Figure 7-7: Dotted-quad IPv4 address notation</em></p>&#13;
<p class="indent">An IP address consists of two parts: a <em>network portion</em> and a <em>host portion</em>. The network portion identifies the LAN the device is connected to, and the host portion identifies the device itself on that network. The determination of which part of the IP address belongs to the network or host portion is not always the same. This information is communicated by another set of addressing information called the <em>network mask (netmask)</em> or sometimes referred to as a <em>subnet mask</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>In this book, when we refer to an IP address, we will always be referring to an IPv4 address. Later in this chapter, we will look at IP version 6, which uses a different set of rules for addressing. Whenever we refer to an IPv6 address, it will be explicitly labeled as such.</em></p>&#13;
</div>&#13;
<p class="indent">The netmask identifies which part of the IP address belongs to the network portion and which part belongs to the host portion. The netmask number is also 32 bits long, and every bit that is set to a 1 identifies the part of the IP address that is reserved for the network portion. The remaining bits are set to 0 to identify the host portion.</p>&#13;
<p class="indent">For example, consider the IP address 10.10.1.22, represented in binary as 00001010 00001010 00000001 00010110. To determine the allocation of each section of the IP address, we can apply our netmask. In this case, our netmask is 11111111 11111111 00000000 00000000. This means that the first half of the IP address (10.10 or 00001010 00001010) is reserved for the network portion, and the last half of the IP address (.1.22 or 00000001 00010110) identifies the individual host on this network, as shown in <a href="ch07.xhtml#ch07fig8">Figure 7-8</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f126-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig8"/><em>Figure 7-8: The netmask determines the allocation of the bits in an IP address.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_127"/>As indicated in <a href="ch07.xhtml#ch07fig8">Figure 7-8</a>, netmasks can also be written in dotted-quad notation. For example, the netmask 11111111 11111111 00000000 00000000 is written as 255.255.0.0.</p>&#13;
<p class="indent">IP addresses and netmasks are commonly written in <em>Classless Inter-Domain Routing (CIDR) notation</em>. In this form, an IP address is written in full, followed by a forward slash (/) and the number of bits that represent the network portion of the IP address. For example, an IP address of 10.10.1.22 and a netmask of 255.255.0.0 would be written in CIDR notation as 10.10.1.22/16.</p>&#13;
<h5 class="h5"><strong>IPv4 Packet Structure</strong></h5>&#13;
<p class="noindent">The source and destination IP addresses are the crucial components of the IPv4 packet header, but that’s not all of the IP information you’ll find in a packet. The IP header is quite complex compared to the ARP packet we just examined; it includes a lot of extra functionality that helps IP do its job.</p>&#13;
<p class="indenta">As shown in <a href="ch07.xhtml#ch07fig9">Figure 7-9</a>, the IPv4 header has the following fields:</p>&#13;
<p class="noindentla"><strong>Version</strong>   The version of IP being used (this will always be 4 for IPv4). <strong>Header Length</strong> The length of the IP header.</p>&#13;
<p class="noindentla"><strong>Type of Service</strong>   A precedence flag and type of service flag, which are used by routers to prioritize traffic.</p>&#13;
<p class="noindentla"><strong>Total Length</strong>   The length of the IP header and the data included in the packet.</p>&#13;
<p class="noindentla"><strong>Identification</strong>   A unique identification number used to identify a packet or sequence of fragmented packets.</p>&#13;
<p class="noindentla"><strong>Flags</strong>   Used to identify whether a packet is part of a sequence of fragmented packets.</p>&#13;
<p class="noindentla"><strong>Fragment Offset</strong>   If a packet is a fragment, the value of this field is used to reassemble the packets in the correct order.</p>&#13;
<p class="noindentla"><strong>Time to Live</strong>   Defines the lifetime of the packet, measured in hops or seconds through routers.</p>&#13;
<p class="noindentla"><strong>Protocol</strong>   Identifies the transport layer header that encapsulates the IPv4 header.</p>&#13;
<p class="noindentla"><strong>Header Checksum</strong>   An error-detection mechanism used to verify that the contents of the IP header are not damaged or corrupted.</p>&#13;
<p class="noindentla"><strong>Source IP Address</strong>   The IP address of the host that sent the packet.</p>&#13;
<p class="noindentla"><strong>Destination IP Address</strong>   The IP address of the packet’s destination.</p>&#13;
<p class="noindentla"><strong>Options</strong>   Reserved for additional IP options. It includes options for source routing and timestamps.</p>&#13;
<p class="noindentla"><strong>Data</strong>   The actual data being transmitted with IP.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_128"/><img alt="image" src="../images/f128-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig9"/><em>Figure 7-9: The IPv4 packet structure</em></p>&#13;
<h5 class="h5"><strong>Time to Live</strong></h5>&#13;
<div class="note1">&#13;
<p class="noindent"><em>ip_ttl_source.pcapng ip_ttl_dest.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The <em>Time to Live (TTL)</em> value defines a period of time that can elapse or a maximum number of routers a packet can traverse before the packet is discarded for IPv4. A TTL is defined when a packet is created and generally is decremented by 1 every time the packet is forwarded by a router. For example, if a packet has a TTL of 2, the first router it reaches will decrement the TTL to 1 and forward it to the second router. This router will then decrement the TTL to zero, and if the final destination of the packet is not on that network, the packet will be discarded (see <a href="ch07.xhtml#ch07fig10">Figure 7-10</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f128-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig10"/><em>Figure 7-10: The TTL of a packet decreases every time it traverses a router.</em></p>&#13;
<p class="indent">Why is the TTL value important? Typically, we are concerned about the lifetime of a packet only in terms of the time that it takes to travel from its source to its destination. However, consider a packet that must travel to a host across the internet while traversing dozens of routers. At some point in that packet’s path, it could encounter a misconfigured router and lose the path to its final destination. In such a case, the router could do a number of things, one of which could result in the packet’s being forwarded around a network in a never-ending loop.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_129"/>An infinite loop can cause all sorts of issues, but it typically results in the crash of a program or an entire operating system. Theoretically, the same thing could occur with packets on a network. The packets would keep looping between routers. As the number of looping packets increased, the available bandwidth on the network would deplete until a denial of service condition occurred. To prevent this, TTL was created.</p>&#13;
<p class="indent">Let’s look at an example of this in Wireshark. The file <em>ip_ttl_source.pcapng</em> contains two ICMP packets. ICMP (discussed later in this chapter) uses IP to deliver packets, as we can see by expanding the IP header section in the Packet Details pane (see <a href="ch07.xhtml#ch07fig11">Figure 7-11</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f129-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig11"/><em>Figure 7-11: The IP header of the source packet</em></p>&#13;
<p class="indent">You can see that the version of IP being used is version 4 <span class="ent">➊</span>, the IP header length is 20 bytes <span class="ent">➋</span>, the total length of the header and payload is 60 bytes <span class="ent">➌</span>, and the value of the TTL field is 128 <span class="ent">➍</span>.</p>&#13;
<p class="indent">The primary purpose of an ICMP ping is to test communication between devices. Data is sent from one host to another as a request, and the receiving host should send that data back as a reply. In this file, we have one device with the address of 10.10.0.3 <span class="ent">➎</span> sending an ICMP request to a device with the address 192.168.0.128 <span class="ent">➏</span>. This initial capture file was created at the source host, 10.10.0.3.</p>&#13;
<p class="indent">Now open the file <em>ip_ttl_dest.pcapng</em>. In this file, the data was captured at the destination host, 192.168.0.128. Expand the IP header of the first packet in this capture to examine its TTL value (see <a href="ch07.xhtml#ch07fig12">Figure 7-12</a>).</p>&#13;
<p class="indent">You should immediately notice that the TTL value is 127 <span class="ent">➊</span>, 1 less than the original TTL of 128. Without even knowing the architecture of the network, we can conclude that one router separates these devices and thus the passage through that router reduced the TTL value by 1.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_130"/><img alt="image" src="../images/f130-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig12"/><em>Figure 7-12: The IP header shows us that the TTL has been decremented by 1.</em></p>&#13;
<h5 class="h5"><strong>IP Fragmentation</strong></h5>&#13;
<div class="note1">&#13;
<p class="noindent"><em>ip_frag_source.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent"><em>Packet fragmentation</em> is a feature of IP that permits reliable delivery of data across varying types of networks by splitting a data stream into smaller fragments.</p>&#13;
<p class="indent">The fragmentation of a packet is based on the <em>maximum transmission unit (MTU)</em> size of the layer 2 data link protocol in use and the configuration of the devices using this layer 2 protocol. In most cases, the layer 2 data link protocol in use is Ethernet. Ethernet has a default MTU of 1,500, which means that the maximum packet size that can be transmitted over an Ethernet network is 1,500 bytes (not including the 14-byte Ethernet header itself).</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Although there are standard MTU settings, the MTU of a device can be reconfigured manually in most cases. An MTU setting is assigned on a per-interface basis and can be modified on Windows and Linux systems, as well as on the interfaces of managed routers.</em></p>&#13;
</div>&#13;
<p class="indent">When a device prepares to transmit an IP packet, it determines whether it must fragment the packet by comparing the packet’s data size to the MTU of the network interface from which the packet will be transmitted. If the data size is greater than the MTU, the packet will be fragmented. Fragmenting a packet involves the following steps:</p>&#13;
<ol>&#13;
<li class="nump"><p class="number">The device splits the data into the number of packets required for successful data transmission.</p></li>&#13;
<li class="nump"><p class="number">The Total Length field of each IP header is set to the segment size of each fragment.</p></li>&#13;
<li class="nump"><p class="number"><span epub:type="pagebreak" id="page_131"/>The More fragments flag is set to 1 on all packets in the data stream, except for the last one.</p></li>&#13;
<li class="nump"><p class="number">The Fragment offset field is set in the IP header of the fragments.</p></li>&#13;
<li class="nump"><p class="number">The packets are transmitted.</p></li>&#13;
</ol>&#13;
<p class="indent">The file <em>ip_frag_source.pcapng</em> was taken from a computer with the address 10.10.0.3, transmitting a ping request to a device with the address 192.168.0.128. Notice that the Info column of the Packet List pane lists two fragmented IP packets, followed by the ICMP (ping) request.</p>&#13;
<p class="indent">Begin by examining the IP header of packet 1 (see <a href="ch07.xhtml#ch07fig13">Figure 7-13</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f131-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig13"/><em>Figure 7-13: More fragments and Fragment offset values can indicate a fragmented packet.</em></p>&#13;
<p class="indent">You can see that this packet is part of a fragment based on the More fragments and Fragment offset fields. Packets that are fragments will either have a positive Fragment offset value or have the More fragments flag set. In the first packet, the More fragments flag is set <span class="ent">➊</span>, indicating that the receiving device should expect to receive another packet in this sequence. The Fragment offset is set to 0 <span class="ent">➋</span>, indicating that this packet is the first in a series of fragments.</p>&#13;
<p class="indent">The IP header of the second packet (see <a href="ch07.xhtml#ch07fig14">Figure 7-14</a>) also has the More fragments flag set <span class="ent">➊</span>, but in this case, the Fragment offset value is 1480 <span class="ent">➋</span>. This is indicative of the 1,500-byte MTU, minus 20 bytes for the IP header.</p>&#13;
<p class="indent">The third packet (see <a href="ch07.xhtml#ch07fig15">Figure 7-15</a>) does not have the More fragments flag set <span class="ent">➋</span>, which marks it as the last fragment in the data stream, and the Fragment offset is set to 2960 <span class="ent">➌</span>, the result of 1480 + (1500 – 20). These fragments can all be identified as part of the same series of data because they have the same values in the Identification field of the IP header <span class="ent">➊</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_132"/><img alt="image" src="../images/f132-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig14"/><em>Figure 7-14: The Fragment offset value increases based on the size of the packets.</em></p>&#13;
<div class="image"><img alt="image" src="../images/f132-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig15"/><em>Figure 7-15: More fragments is not set, indicating that this fragment is the last.</em></p>&#13;
<p class="indent">While it isn’t as common to see fragmented packets on a network as it used to be, understanding why packets are fragmented is useful so that when you do encounter them, you can diagnose issues or spot missing fragments.</p>&#13;
<h4 class="h4"><a id="ch07lev2sec6"/><span epub:type="pagebreak" id="page_133"/><strong><em>Internet Protocol Version 6 (IPv6)</em></strong></h4>&#13;
<p class="noindent">When the IPv4 specification was written, nobody had any idea that we would eventually have the number of internet-connected devices that exist today. The maximum IPv4 addressable space was limited to just south of 4.3 billion addresses. The actual amount of addressable space shrinks even further when you subtract ranges reserved for special uses such as testing, broadcast traffic, and RFC1918 internal addresses. While several efforts were made to delay the exhaustion of IPv4 addresses, ultimately the only way to address this limitation was to develop a new version of the IP specification.</p>&#13;
<p class="indent">Thus, the IPv6 specification was created, with its first version released in 1998 as RFC 2460. This version provided several performance enhancements, including a much larger address space. In this section, we’ll look at the IPv6 packet structure and discuss how IPv6 communications differ from those of its predecessor.</p>&#13;
<h5 class="h5"><strong>IPv6 Addresses</strong></h5>&#13;
<p class="noindent">IPv4 addresses were limited to 32 bits, a length that provided an addressable space measured in the billions. IPv6 addresses are 128 bit, providing an addressable space measured in undecillions (a trillion trillion trillion). That’s quite an upgrade!</p>&#13;
<p class="indent">Since IPv6 addresses are 128 bits, they are unwieldy to manage in binary form. Most of the time, an IPv6 address is written in eight groups of 2 bytes in hexadecimal notation, with each group separated by a colon. For example, a very simple IPv6 address looks like this:</p>&#13;
<p class="programs">1111:aaaa:2222:bbbb:3333:cccc:4444:dddd</p>&#13;
<p class="indent">Your first thought is probably the same one many have who are used to remembering IPv4 addresses: IPv6 addresses are virtually impossible to memorize. That is an unfortunate trade-off for a much larger address space.</p>&#13;
<p class="indent">One feature of IPv6 address notation that will help in some cases is that some groups of zeroes can be collapsed. For example, consider the following IPv6 address:</p>&#13;
<p class="programs">1111:0000:2222:0000:3333:4444:5555:6666</p>&#13;
<p class="indent">You can collapse the grouping containing the zeroes completely so it isn’t visible, like this:</p>&#13;
<p class="programs">1111::2222:0000:3333:4444:5555:6666</p>&#13;
<p class="indent">However, you can only collapse a single group of zeroes, so the following address would be invalid:</p>&#13;
<p class="programs">1111::2222::3333:4444:5555:6666</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_134"/>Another consideration is that leading zeroes can be dropped from IPv6 addresses. Consider this example in which there are zeroes in front of the fourth, fifth, and six groups:</p>&#13;
<p class="programs">1111:0000:2222:0333:0044:0005:ffff:ffff</p>&#13;
<p class="indent">You could represent the address more efficiently like this:</p>&#13;
<p class="programs"><span class="literal">1111::2222:333:44:5:ffff:ffff</span></p>&#13;
<p class="indent">This isn’t quite as easy to use as an IPv4 address, but it’s a lot easier to deal with than the longer notation.</p>&#13;
<p class="indent">An IPv6 address has a network portion and a host portion, often called a <em>network prefix</em> and <em>interface identifier</em>, respectively. The distribution of these fields varies depending on the classification of the IPv6 communication. IPv6 traffic is broken down into three classifications: unicast, multicast, or anycast. In most cases, you’ll probably be working with link-local unicast traffic, which is communication from one device to another inside a network. The format of a link-local unicast IPv6 address is shown in <a href="ch07.xhtml#ch07fig16">Figure 7-16</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f134-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig16"/><em>Figure 7-16: The parts of an IPv6 link-local unicast address</em></p>&#13;
<p class="indent">Link-local addresses are used when communication is intended for another device within the same network. A link-local address can be identified by having its most significant 10 bits set to 1111111010 and the next 54 bits set to all zeroes. Thus, you can spot a link-local address when the first half is fe80:0000:0000:0000.</p>&#13;
<p class="indent">The second half of a link-local IPv6 address is the interface ID portion, which uniquely identifies a network interface on an endpoint host. On Ethernet networks, this can be based on the MAC address of the interface. However, a MAC address is only 48 bits. To fill up the entire 64-bit space, the MAC address is cut in half, and the value 0xfffe is added between each half as padding to create a unique identifier. Lastly, the seventh bit of the first byte is inverted. That’s a bit complex, but consider the interface ID in <a href="ch07.xhtml#ch07fig17">Figure 7-17</a>. The original MAC address for the device represented by this ID was 78:31:c1:cb:b2:56. The bytes 0xfffe were added in the middle, and flipping the seventh bit of the first byte changed the <em>8</em> to an <em>a</em>.</p>&#13;
<div class="image"><img alt="image" src="../images/f134-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig17"/><em>Figure 7-17: The interface ID utilizes an interface MAC address and padding.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_135"/>IPv6 addresses can be represented with CIDR notation just like IPv4 addresses. In this example, 64 bits of addressable space are represented with a link-local address:</p>&#13;
<p class="programs">fe80:0000:0000:0000:/64</p>&#13;
<p class="indent">The composition of an IPv6 address changes when it is used with global unicast traffic that is routed over the public internet (see <a href="ch07.xhtml#ch07fig18">Figure 7-18</a>). When used in this manner, a global unicast is identified by having its first 3 bits set to 001, followed by a 45-bit global routing prefix. The global routing prefix, which is assigned to organizations by the Internet Assigned Numbers Authority (IANA), is used to uniquely identify an organization’s IP space. The next 16 bits are the subnet ID, which can be used for hierarchical addressing, similar to the netmask portion of an IPv4 address. The final 64 bits are used for the interface ID, just as with link-local unicast addresses. The routing prefix and subnet ID can vary in size.</p>&#13;
<div class="image"><img alt="image" src="../images/f135-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig18"/><em>Figure 7-18: The parts of an IPv6 global unicast address</em></p>&#13;
<p class="indent">IPv6 provides a lot more efficiency than IPv4 in terms of routing packets to their destination and making effective use of address space. This efficiency is due to the larger range of addresses available and the use of link-local and global addressing along with unique host identifiers.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>It’s easy for you to visually differentiate IPv6 and IPv4 addresses, but many programs cannot do so. If you need to specify an IPv6 address, some applications, such as browsers or command line utilities, require you to place square brackets around the address, like this: [1111::2222:333:44:5:ffff]. This requirement isn’t always documented well and has been a source of frustration for many as they learn IPv6.</em></p>&#13;
</div>&#13;
<h5 class="h5"><strong>IPv6 Packet Structure</strong></h5>&#13;
<div class="note1">&#13;
<p class="noindent"><em>http_ip4and6.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The structure of the IPv6 header has grown to support more features, but it was also designed to be easier to parse. Instead of being variable in size with a header length field that needs to be checked to parse the header, headers are now a fixed 40 bytes. Additional options are provided via extension headers. The benefit is that most routers only need to process the 40-byte header to forward the packet along.</p>&#13;
<p class="indenta">As shown in <a href="ch07.xhtml#ch07fig19">Figure 7-19</a>, the IPv6 header has the following fields:</p>&#13;
<p class="noindentla"><strong>Version</strong>   The version of IP being used (this is always 6 for IPv6).</p>&#13;
<p class="noindentla"><strong>Traffic Class</strong>   Used to prioritize certain classes of traffic.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_136"/><img alt="image" src="../images/f136-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig19"/><em>Figure 7-19: The IPv6 packet structure</em></p>&#13;
<p class="noindentla"><strong>Flow Label</strong>   Used by a source to label a set of packets belonging to the same flow. This field is typically used for quality of service (QoS) management and to ensure packets that are part of the same flow take the same path.</p>&#13;
<p class="noindentla"><strong>Payload Length</strong>   The length of the data payload following the IPv6 header.</p>&#13;
<p class="noindentla"><strong>Next Header</strong>   Identifies the layer 4 header that encapsulates the IPv6 header. This field replaces the Protocol field in IPv4.</p>&#13;
<p class="noindentla"><strong>Hop Limit</strong>   Defines the lifetime of the packet, measured in hops through routers. This field replaces the TTL field in IPv4.</p>&#13;
<p class="noindentla"><strong>Source IP Address</strong>   The IP address of the host that sent the packet.</p>&#13;
<p class="noindentl"><strong>Destination IP Address</strong>   The IP address of the packet’s destination.</p>&#13;
<p class="indent">Let’s compare an IPv4 and an IPv6 packet to examine a few of the differences by looking at <em>http_ip4and6.pcapng</em>. In this capture, a web server was configured to listen for both IPv4 and IPv6 connections on the same physical host. A single client configured with both IPv4 and IPv6 addresses browsed to a server using each of its addresses independently and downloaded the <em>index.php</em> page using HTTP via the curl application (<a href="ch07.xhtml#ch07fig20">Figure 7-20</a>).</p>&#13;
<p class="indent">Upon opening the capture, you should readily see which packets belong to which conversation based on the addresses in the Source and Destination columns in the Packet List area. Packets 1 through 10 represent the IPv4 stream (stream 0), and packets 11 through 20 represent the IPv6 stream (stream 1). You can filter for each of these streams from the Conversations window or by entering <span class="codestrong">tcp.stream == 0</span> or <span class="codestrong">tcp.stream == 1</span> in the filter bar.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_137"/><img alt="image" src="../images/f137-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig20"/><em>Figure 7-20: Connections between the same physical hosts using different IP versions</em></p>&#13;
<p class="indent">We’ll cover HTTP, the protocol responsible for serving web pages on the internet, in depth in <a href="ch08.xhtml#ch08">Chapter 8</a>. In this example, just note that the business of serving web pages remains consistent regardless of which lower-layer network protocol is used. The same can be said of TCP, which also operates in a consistent manner. This is a prime example of encapsulation in action. Although IPv4 and IPv6 function differently, the protocols functioning at different layers are unaffected.</p>&#13;
<p class="indenta"><a href="ch07.xhtml#ch07fig21">Figure 7-21</a> provides a side-by-side comparison of two packets with the same function—packets 1 and 11. Both packets are TCP SYN packets designed to initiate a connection from the client to the server. The Ethernet and TCP sections of these packets are nearly identical. However, the IP sections are completely different.</p>&#13;
<p class="bullet">•     The source and destination address formats are different <span class="ent">➏</span><span class="ent">➓</span>.</p>&#13;
<p class="bullet">•     The IPv4 packet is 74 bytes with a 60-byte total length <span class="ent">➊</span>, which includes both the IPv4 header and payload and a 14-byte Ethernet header. The IPv6 packet is 96 bytes with a 40-byte IPv6 payload <span class="ent">➐</span> and a separate 40-byte IPv6 header along with the 14-byte Ethernet header. The IPv6 header is 40 bytes, double the IPv4 header’s 20 bytes, to accommodate the larger address size.</p>&#13;
<p class="bullet">•     IPv4 identifies the protocol with the Protocol field <span class="ent">➍</span>, whereas IPv6 identifies it with the Next header field (which can also be used to specify extension headers) <span class="ent">➑</span>.</p>&#13;
<p class="bullet">•     IPv4 has a TTL field <span class="ent">➌</span>, whereas IPv6 accomplishes the same functionality using the Hop limit field <span class="ent">➒</span>.</p>&#13;
<p class="bullet">•     IPv4 includes a header checksum value <span class="ent">➎</span>, while IPv6 does not.</p>&#13;
<p class="bulleta">•     The IPv4 packet is not fragmented, but it still includes values for those options <span class="ent">➋</span>. The IPv6 header doesn’t contain this information because, if fragmentation were required, it would be implemented in an extension header.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_138"/><img alt="image" src="../images/f138-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig21"/><em>Figure 7-21: A side-by-side comparison of IPv4 (top) and IPv6 (bottom) packets performing the same function</em></p>&#13;
<p class="indent">Performing side-by-side comparisons of IPv4 and IPv6 traffic is a great way to fully appreciate the difference between how the two protocols operate.</p>&#13;
<h5 class="h5"><strong>Neighbor Solicitation and ARP</strong></h5>&#13;
<div class="note1">&#13;
<p class="noindent"><em>icmpv6_neighbor_solicitation.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">When we discussed the different classifications of traffic earlier, I listed uni-cast, multicast, and anycast but did not list broadcast traffic. IPv6 doesn’t <span epub:type="pagebreak" id="page_139"/>support broadcast traffic because broadcast is viewed as an inefficient mechanism for transmission. Because there is no broadcast, ARP can’t be used for hosts to find each other on a network. So, how do IPv6 devices find each other?</p>&#13;
<p class="indent">The answer lies with a new feature called <em>neighbor solicitation</em>, a function of Neighbor Discovery Protocol (NDP), which utilizes ICMPv6 (discussed in the last section of this chapter) to do its legwork. To accomplish this task, ICMPv6 uses multicast, a type of communication in which only hosts that subscribe to a data stream will receive and process it. Multicast traffic can be identified quickly because it has its own reserved IP space (ff00::/8).</p>&#13;
<p class="indent">Although the address resolution process relies on a different protocol, it still uses a very simple request/response workflow. For example, let’s consider a scenario in which a host with the IPv6 address 2001:db8:1:2::1003 wants to communicate with another host identified by the address 2001:db8:1:2::1000. Just as with IPv4, the source device must be able to determine the link-layer (MAC) address of the host it wants to communicate with, since this is intra-network communication. This process is described in <a href="ch07.xhtml#ch07fig22">Figure 7-22</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f139-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig22"/><em>Figure 7-22: The neighbor solicitation process for address resolution</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_140"/>In this process, the host 2001:db8:1:2::1003 sends a Neighbor Solicitation (ICMPv6 type 135) packet to every device on the network via multicast, asking, “What is the MAC address for the device whose IP address is 2001:db8:1:2::1000? My MAC address is 00:0C:29:2f:80:31.”</p>&#13;
<p class="indent">The device assigned that IPv6 address will receive this multicast transmission and respond to the originating host with a Neighbor Advertisement (ICMPv6 type 136) packet. This packet says, “Hi, my network address is 2001:db8:1:2::1000 and my MAC address is 00:0c:29:1f:a7:55.” Once this message is received, communication can begin.</p>&#13;
<p class="indent">You can see this process in action in the capture file <em>icmpv6_neighbor _solicitation.pcapng</em>. This capture embodies the example we’ve just discussed in which 2001:db8:1:2::1003 wants to communicate with 2001:db8:1:2::1000. Look at the first packet and expand the ICMPv6 portion in the Packet Details window (<a href="ch07.xhtml#ch07fig23">Figure 7-23</a>) to see that the packet is ICMP type 135 <span class="ent">➋</span> and was sent from 2001:db8:1:2::1003 to the multicast address ff02::1:ff00:1000 <span class="ent">➊</span>. The source host provided the target IPv6 address it wanted to communicate with <span class="ent">➌</span>, along with its own layer 2 MAC address <span class="ent">➍</span>.</p>&#13;
<div class="image"><img alt="image" src="../images/f140-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig23"/><em>Figure 7-23: A neighbor solicitation packet</em></p>&#13;
<p class="indent">The response to the solicitation is found in the second packet in the capture file. Expanding the ICMPv6 portion of the Packet Details window (<a href="ch07.xhtml#ch07fig24">Figure 7-24</a>) reveals this packet is ICMP type 136 <span class="ent">➋</span>, was sent from 2001:db8:1:2::1000 back to 2001:db8:1:2::1003 <span class="ent">➊</span>, and contains the MAC address 00:0c:29:1f:a7:55 associated with 2001:db8:1:2::1000 <span class="ent">➌</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_141"/><img alt="image" src="../images/f141-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig24"/><em>Figure 7-24: A neighbor advertisement packet</em></p>&#13;
<p class="indent">Upon completion of this process, 2001:db8:1:2::1003 and 2001:db8:1:2::1000 begin communicating normally with ICMPv6 echo request and reply packets, indicating the neighbor solicitation process and link-layer address resolution was successful.</p>&#13;
<h5 class="h5"><strong>IPv6 Fragmentation</strong></h5>&#13;
<div class="note1">&#13;
<p class="noindent"><em>ipv6_fragments.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">Fragmentation support was built into the IPv4 header because it ensured packets could traverse all sorts of networks at a time when network MTUs varied wildly. In IPv6, fragmentation is used less, so the options supporting it are not included in the IPv6 header. A device transmitting IPv6 packets is expected to perform a process called <em>MTU discovery</em> to determine the maximum size of packets it can send before actually sending them. In the event that a router receives a packet that is too large for the MTU on the network it is forwarding to, it will drop the packet and return an ICMPv6 Packet Too Big (type 2) message to the originating host. Upon receipt, the originating host will attempt to resend the packet with a smaller MTU, if such action is supported by the upper-layer protocol. This process will repeat until a small enough MTU is reached or until the payload can be fragmented no more (<a href="ch07.xhtml#ch07fig25">Figure 7-25</a>). A router will never be responsible for fragmenting packets on its own; the source device is responsible for determining an appropriate MTU for the transmission path and fragmenting appropriately.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_142"/><img alt="image" src="../images/f142-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig25"/><em>Figure 7-25: IPv6 MTU path discovery</em></p>&#13;
<p class="indent">If the upper-layer protocol being used in conjunction with IPv6 can’t limit the size of the packet payload, then fragmentation must still be used. A fragmentation extension header can be added to the IPv6 packet to support this scenario. You will find a sample capture showing IPv6 fragmentation in the file named <em>ipv6_fragments.pcapng</em>.</p>&#13;
<p class="indent">Because the receiving device has a smaller MTU than the sending device, there are two fragmented packets to represent each ICMPv6 echo request and reply in the capture file. The fragmentation header from the first packet is shown in <a href="ch07.xhtml#ch07fig26">Figure 7-26</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f142-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig26"/><em>Figure 7-26: An IPv6 fragment header extension</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_143"/>The 8-byte extension header contains all the same fragmentation properties that are found in an IPv4 packet, such as a Fragment offset <span class="ent">➋</span>, More Fragments flag <span class="ent">➌</span>, and Identification field <span class="ent">➍</span>. Instead of being present in every packet, it is only added to the end of packets requiring fragmentation. This more efficient process still allows the receiving system to reassemble the fragments appropriately. Additionally, if this extension header is present, the Next header field will point to the extension header rather than the encapsulating protocol <span class="ent">➊</span>.</p>&#13;
<h5 class="h5"><strong>IPv6 Transitional Protocols</strong></h5>&#13;
<p class="noindenta">IPv6 addresses a very real problem, but its adoption has been slow because of the effort required to transition network infrastructure to it. To ease this transition, several protocols allow IPv6 communication to be tunneled across networks that support only IPv4 communication. In this respect, tunneling means that IPv6 communication is encapsulated inside of IPv4 communications just as other protocols may be encapsulated. Encapsulation is usually done in one of three ways:</p>&#13;
<p class="noindentla"><strong>Router to Router</strong>   Uses a tunnel to encapsulate IPv6 traffic from the transmitting and receiving hosts on their networks over an IPv4 network. This method allows entire networks to communicate in IPv6 over intermediary IPv4 links.</p>&#13;
<p class="noindentla"><strong>Host to Router</strong>   Uses encapsulation at the router level to transmit traffic from an IPv6 host over an IPv4 network. This method allows an individual host to communicate in IPv6 to an IPv6 network when the host resides on an IPv4-only network.</p>&#13;
<p class="noindentl"><strong>Host to Host</strong>   Uses a tunnel between two endpoints to encapsulate IPv6 traffic between IPv4- or IPv6-capable hosts. This method allows IPv6 endpoints to communicate directly across an IPv4 network.</p>&#13;
<p class="indenta">While this book won’t cover transitional protocols in depth, it’s helpful to be aware of their existence in case you ever need to investigate them while performing analysis at the packet level. The following are a few common protocols:</p>&#13;
<p class="noindentla"><strong>6to4</strong>   Also known as <em>IPv6 over IPv4</em>, this transitional protocol allows IPv6 packets to be transmitted across an IPv4 network. This protocol supports relays and routers to provide router-to-router, host-to-router, and host-to-host IPv6 communication.</p>&#13;
<p class="noindentla"><strong>Teredo</strong>   This protocol, used for IPv6 unicast communications over an IPv4 network using NAT (network address translation), works by sending IPv6 packets over IPv4 encapsulated in the UDP transport protocol.</p>&#13;
<p class="noindentla"><strong>ISATAP</strong>   This intrasite protocol allows communication between IPv4-and IPv6-only devices within a network in a host-to-host manner.</p>&#13;
<h3 class="h3"><a id="ch07lev1sec3"/><span epub:type="pagebreak" id="page_144"/><strong>Internet Control Message Protocol (ICMP)</strong></h3>&#13;
<p class="noindent"><em>Internet Control Message Protocol (ICMP)</em> is the utility protocol of TCP/IP, responsible for providing information regarding the availability of devices, services, or routes on a TCP/IP network. Most network-troubleshooting techniques and tools center around common ICMP message types. ICMP is defined in RFC 792.</p>&#13;
<h4 class="h4"><a id="ch07lev2sec7"/><strong><em>ICMP Packet Structure</em></strong></h4>&#13;
<p class="noindenta">ICMP is part of IP, and it relies on IP to transmit its messages. ICMP contains a relatively small header that changes depending on its purpose. As shown in <a href="ch07.xhtml#ch07fig27">Figure 7-27</a>, the ICMP header contains the following fields:</p>&#13;
<p class="noindentla"><strong>Type</strong>   The type or classification of the ICMP message, based on the RFC specification</p>&#13;
<p class="noindentla"><strong>Code</strong>   The subclassification of the ICMP message, based on the RFC specification</p>&#13;
<p class="noindentla"><strong>Checksum</strong>   Used to ensure that the contents of the ICMP header and data are intact upon arrival</p>&#13;
<p class="noindentla"><strong>Variable</strong>   A portion that varies depending on the Type and Code fields</p>&#13;
<div class="image"><img alt="image" src="../images/f144-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig27"/><em>Figure 7-27: The ICMP header</em></p>&#13;
<h4 class="h4"><a id="ch07lev2sec8"/><strong><em>ICMP Types and Messages</em></strong></h4>&#13;
<p class="noindent">As noted, the structure of an ICMP packet depends on its purpose, as defined by the values in the <em>Type</em> and <em>Code</em> fields.</p>&#13;
<p class="indent">You might consider the ICMP Type field the packet’s classification and the Code field its subclass. For example, a Type field value of 3 indicates “destination unreachable.” While this information alone might not be enough to troubleshoot a problem, if that packet were also to specify a Code field value of 3, indicating “port unreachable,” you could conclude that there is an issue with the port with which you are attempting to communicate.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>For a full list of available ICMP types and codes, see</em> http://www.iana.org/assignments/icmp-parameters/.</p>&#13;
</div>&#13;
<h4 class="h4"><a id="ch07lev2sec9"/><span epub:type="pagebreak" id="page_145"/><strong><em>Echo Requests and Responses</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>icmp_echo.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">ICMP’s biggest claim to fame is the ping utility. <em>Ping</em> is used to test for connectivity to a device. While ping itself isn’t a part of the ICMP spec, it utilizes ICMP to achieve its core functionality.</p>&#13;
<p class="indent">To use ping, enter <span class="literal">ping<span class="codeitalic"/> ipaddress</span> at the command prompt, replacing <span class="codeitalic">ipaddress</span> with the actual IP address of a device on your network. If the target device is turned on, your computer has a communication route to it, and there is no firewall blocking that communication, you should see replies to your <span class="literal">ping</span> command.</p>&#13;
<p class="indent">The example in <a href="ch07.xhtml#ch07fig28">Figure 7-28</a> shows four successful replies that display their size; round trip time (or RTT), which is the time it takes for the packet to arrive and a response to be received; and TTL used. The Windows utility also provides a summary detailing how many packets were sent, received, and lost. If communication fails, you should see a message telling you why.</p>&#13;
<div class="image"><img alt="image" src="../images/f145-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig28"/><em>Figure 7-28: The <span class="literal">ping</span> command being used to test connectivity</em></p>&#13;
<p class="indent">Basically, the <span class="literal">ping</span> command sends one packet at a time to a device and listens for a reply to determine whether there is connectivity to that device, as shown in <a href="ch07.xhtml#ch07fig29">Figure 7-29</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f145-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig29"/><em>Figure 7-29: The <span class="literal">ping</span> command involves only two steps.</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Although ping has long been the bread and butter of IT, its results can be a bit deceiving when host-based firewalls are deployed. Many of today’s firewalls limit the ability of a device to respond to ICMP packets. This is great for security, because potential attackers using ping to determine whether a host is accessible might be deterred, but troubleshooting is also more difficult—it can be frustrating to ping a device to test for connectivity and not receive a reply when you know you can communicate with that device.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_146"/>The ping utility in action is a great example of simple ICMP communication. The packets in the file <em>icmp_echo.pcapng</em> demonstrate what happens when you run ping.</p>&#13;
<p class="indent">The first packet (see <a href="ch07.xhtml#ch07fig30">Figure 7-30</a>) shows that host 192.168.100.138 is sending a packet to 192.168.100.1 <span class="ent">➊</span>. When you expand the ICMP portion of this packet, you can determine the ICMP packet type by looking at the Type and Code fields. In this case, the packet is type 8 <span class="ent">➋</span> and the code is 0 <span class="ent">➌</span>, indicating an echo request. (Wireshark should tell you what the displayed type/code actually is.) This echo (ping) request is the first half of the equation. It is a simple ICMP packet, sent using IP, that contains a small amount of data. Along with the type and code designations and the checksum, we also have a sequence number that is used to pair requests with replies, and there is a random text string in the variable portion of the ICMP packet.</p>&#13;
<div class="image"><img alt="image" src="../images/f146-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig30"/><em>Figure 7-30: An ICMP echo request packet</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>The terms</em> echo <em>and</em> ping <em>are often used interchangeably, but remember that</em> ping <em>is actually the name of a tool. The ping tool is used to send ICMP echo request packets.</em></p>&#13;
</div>&#13;
<p class="indent">The second packet in this sequence is the reply to our request (see <a href="ch07.xhtml#ch07fig31">Figure 7-31</a>). The ICMP portion of the packet is type 0 <span class="ent">➊</span> and code 0 <span class="ent">➋</span>, indicating that this is an echo reply. Because the sequence number and identifier in the second packet match those of the first <span class="ent">➌</span>, we know that this echo reply matches the echo request in the previous packet. Wireshark displays the values of these fields in big-endian (BE) and little-endian (LE) format. In other words, it represents the data in a different order based on how a particular endpoint might process the data. This reply packet also contains the same 32-byte string of data that was transmitted with the initial request <span class="ent">➍</span>. Once this second packet has been received by 192.168.100.138, ping will report success.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_147"/><img alt="image" src="../images/f147-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig31"/><em>Figure 7-31: An ICMP echo reply packet</em></p>&#13;
<p class="indent">Note that you can use variations of the ping command to increase the size of the data padding in echo requests, which forces packets to be fragmented for various types of network troubleshooting. This may be necessary when you’re troubleshooting networks that require a smaller fragment size.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>The random text used in an ICMP echo request can be of great interest to a potential attacker. Attackers can use the information in this padding to profile the operating system used on a device. Additionally, attackers can place small bits of data in this field as a method of covert communication.</em></p>&#13;
</div>&#13;
<h4 class="h4"><a id="ch07lev2sec10"/><strong><em>traceroute</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>icmp_traceroute.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The traceroute utility is used to identify the path from one device to another. On a simple network, a path may go through only a single router or no router at all. On a complex network, however, a packet may need to go through dozens of routers to reach its final destination. Thus, it is crucial to be able to trace the exact path a packet takes from one destination to another in order to troubleshoot communication.</p>&#13;
<p class="indent">By using ICMP (with a little help from IP), traceroute can map the path packets take. For example, the first packet in the file <em>icmp_traceroute.pcapng</em> is pretty similar to the echo request we looked at in the previous section (see <a href="ch07.xhtml#ch07fig32">Figure 7-32</a>).</p>&#13;
<p class="indent">In this capture, the packets were generated by running the command <span class="literal">tracert 4.2.2.1</span>. To use traceroute on Windows, enter <span class="literal">tracert<span class="codeitalic"/> ipaddress</span> at the command prompt, replacing <span class="codeitalic">ipaddress</span> with the actual IP address of a device whose path you want to discover. To use traceroute on Linux or Mac, use the command <span class="literal">traceroute<span class="codeitalic"/> ipaddress</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_148"/><img alt="image" src="../images/f148-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig32"/><em>Figure 7-32: An ICMP echo request packet with a TTL value of 1</em></p>&#13;
<p class="indent">At first glance, this packet appears to be a simple echo request <span class="ent">➌</span> from 192.168.100.138 to 4.2.2.1 <span class="ent">➊</span>, and everything in the ICMP portion of the packet is identical to the formatting of an echo request packet. However, when you expand the IP header of this packet, you’ll notice something odd: the packet’s TTL value is set to 1 <span class="ent">➋</span>, meaning that the packet will be dropped at the first router that it hits. Because the destination 4.2.2.1 address is an internet address, we know that there must be at least one router between our source and destination devices, so there is no way this packet will reach its destination. That’s good for us, because traceroute relies on the fact that this packet will make it to only the first router it traverses.</p>&#13;
<p class="indent">The second packet is, as expected, a reply from the first router we reached along the path to our destination (see <a href="ch07.xhtml#ch07fig33">Figure 7-33</a>). This packet reached this device at 192.168.100.1, its TTL was decremented to 0, and the packet could not be transmitted further, so the router replied with an ICMP response. This packet is type 11 <span class="ent">➊</span> and code 0 <span class="ent">➋</span>, data that tells us that the destination was unreachable because the packet’s TTL was exceeded during transit.</p>&#13;
<p class="indent">This ICMP packet is sometimes called a <em>double-headed packet</em>, because the tail end of its ICMP portion contains a copy of the IP header <span class="ent">➌</span> and ICMP data <span class="ent">➍</span> that were sent in the original echo request. This information can prove very useful for troubleshooting.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_149"/><img alt="image" src="../images/f149-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig33"/><em>Figure 7-33: An ICMP response from the first router along the path</em></p>&#13;
<p class="indent">This process of sending packets with a TTL value of 1 occurs two more times before we get to packet 7. Here, you see the same thing you saw in the first packet, except that this time, the TTL value in the IP header is set to 2, which ensures the packet will make it to the second hop router before it is dropped. As expected, we receive a reply from the next hop router, 12.180.241.1, with the same ICMP destination unreachable and TTL exceeded messages.</p>&#13;
<p class="indent">This process continues, with the TTL value increasing by 1, until the destination 4.2.2.1 is reached. Right before that happens, however, you’ll see in <a href="ch07.xhtml#ch07fig34">Figure 7-34</a> that the request on line 8 timed out. How can a request along the path time out and the process still complete successfully? Typically, this happens when a router is configured to not respond to ICMP requests. The router still receives the request and passes the data forward to the next router, which is why we’re able to see the next hop on line 9 in <a href="ch07.xhtml#ch07fig34">Figure 7-34</a>. It just didn’t generate the ICMP time to live exceeded packet as the other hops did. With no response, tracert assumes the request has timed out and moves on to the next one.</p>&#13;
<p class="indent">To sum up, this traceroute process has communicated with each router along the path, building a map of the route to the destination. An example map is shown in <a href="ch07.xhtml#ch07fig34">Figure 7-34</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_150"/><img alt="image" src="../images/f150-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch07fig34"/><em>Figure 7-34: A sample output from the traceroute utility</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>The discussion here on traceroute is generally Windows focused because this utility uses ICMP exclusively. The traceroute utility on Linux is a bit more versatile and can utilize other protocols in order to perform route path tracing.</em></p>&#13;
</div>&#13;
<h4 class="h4"><a id="ch07lev2sec11"/><strong><em>ICMP Version 6 (ICMPv6)</em></strong></h4>&#13;
<p class="noindent">The updated version of IP relies heavily on ICMP for functions such as neighbor solicitation and path discovery, as demonstrated in earlier examples. <em>ICMPv6</em> was established with RFC 4443 to support the feature set needed for IPv6, along with additional enhancements. We don’t cover ICMPv6 separately in this book because it uses the same packet structure as do ICMP packets.</p>&#13;
<p class="indent">ICMPv6 packets are generally classified as either error messages or informational messages. You can find a full list of the available types and codes from IANA here: <em>http://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml</em>.</p>&#13;
<p class="indent">This chapter has introduced you to a few of the most important protocols you will examine during the process of packet analysis. ARP, IP, and ICMP are at the foundation of all network communications, and they are critical to just about every daily task you will perform. In <a href="ch08.xhtml#ch08">Chapter 8</a>, we will look at common transport layer protocols, TCP and UDP.</p>&#13;
</body></html>