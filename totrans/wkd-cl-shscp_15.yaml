- en: '**14**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IMAGEMAGICK AND WORKING WITH GRAPHICS FILES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The command line has an extraordinary range of capabilities in the Linux world,
    but because it’s text based, there’s not much you can do with graphics. Or is
    there?
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that a hugely powerful suite of command line utilities, ImageMagick,
    is available for just about every command line environment, from OS X to Linux
    to many more. To use the scripts in this chapter, you’ll need to download and
    install the suite from *[http://www.imagemagick.org/](http://www.imagemagick.org/)*
    or from a package manager such as `apt`, `yum`, or `brew`, if you didn’t already
    do so in [Script #91](ch13.xhtml#ch13lev1sec03) on [page 304](ch13.xhtml#page_304).'
  prefs: []
  type: TYPE_NORMAL
- en: Because the utilities are designed to work on the command line, they require
    very little disk space, coming in at 19MB or so (for the Windows release). You
    can also get the source code if you want to dive into some powerful and flexible
    software. Open source for the win, again.
  prefs: []
  type: TYPE_NORMAL
- en: '**#94 A Smarter Image Size Analyzer**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `file` command offers the ability to ascertain the file type and, in some
    cases, the dimensions of an image. But too often it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: PNG and GIF files work, but what about the more common JPEG? The `file` command
    can’t figure out the image’s dimensions. Annoying!
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s fix that with a script ([Listing 14-1](ch14.xhtml#ch14ex1)) that uses
    the `identify` tool from ImageMagick to far more accurately ascertain image dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-1: The* `*imagesize*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you use the `-verbose` flag, the `identify` tool extracts an extraordinary
    amount of information about each image analyzed, as shown in its output for just
    one PNG graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a lot of data. Too much data, you might think. But without the `-verbose`
    flag, the output is rather cryptic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We want a happy medium, and getting there is where the output format string
    is helpful. Let’s look more closely at [Listing 14-1](ch14.xhtml#ch14ex1), focusing
    on the only meaningful line in the script ➊.
  prefs: []
  type: TYPE_NORMAL
- en: The `-format` string has almost 30 options, allowing you to extract specific
    data you want from one or many images in exactly the format desired. We’re tapping
    into `%f` for the original filename, `%G` as a shortcut for width × height, and
    `%k` as a calculated value for the maximum number of colors used in the image.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the `-format` options at *[http://www.imagemagick.org/script/escape.php](http://www.imagemagick.org/script/escape.php)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ImageMagick does all the work, so this script is mostly just a way to encode
    the specific output format desired. Getting info on your images is fast and easy,
    as [Listing 14-2](ch14.xhtml#ch14ex2) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-2: Running the* `*imagesize*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Currently, we see the pixel size and available color set of the image, but a
    very useful addition would be the file size. However, any more information would
    be hard to read unless a little reformatting of the output is done.
  prefs: []
  type: TYPE_NORMAL
- en: '**#95 Watermarking Images**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re looking to protect your images and other content when you post online,
    you’re bound to be disappointed. Anything online is open to copying, no matter
    if you have a password, use a strong copyright notice, or even add code to your
    website that tries to inhibit users from saving individual images. The fact is
    that for a computer to be able to render anything online, it has to use the image
    buffer on the device, and that buffer can then be duplicated through a screen
    capture or similar tool.
  prefs: []
  type: TYPE_NORMAL
- en: But all is not lost. You can do two things to protect your online images. One
    is to only post small image sizes. Look at professional photographers’ sites and
    you’ll see what we mean. Usually they share only thumbnails because they want
    you to buy the larger image file.
  prefs: []
  type: TYPE_NORMAL
- en: Watermarking is another solution, though some artists balk at the work of adding
    a copyright image or other identifying information directly to the photograph.
    But with ImageMagick, adding watermarks is easy, even in bulk, as shown in [Listing
    14-3](ch14.xhtml#ch14ex3).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-3: The* `*watermark*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just about all the confusing code in this script is courtesy of ImageMagick.
    Yes, it’s doing complicated things, but even then, there’s something about how
    it’s designed and documented that makes ImageMagick a challenge to work with.
    Still, don’t be tempted to throw out the proverbial baby with the bathwater because
    the features and functionality of the various ImageMagick tools are amazing and
    well worth the learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to get the dimensions of the image ➊ so that the water-mark
    overlay will have exactly the same dimensions. Bad things happen if they don’t
    match!
  prefs: []
  type: TYPE_NORMAL
- en: The `"%G"` produces width × height, which is then given to the `convert` program
    as the size of the new canvas to produce. The `convert` line at ➋ is one we copied
    from the ImageMagick documentation because, quite frankly, it’s tricky to get
    just right from scratch. (To learn more about the specifics of the `convert -draw`
    parameter language, we encourage you to do a quick online search. Or you can just
    copy our code!)
  prefs: []
  type: TYPE_NORMAL
- en: The new filename should be the base filename with `"+wm"` added, and that’s
    what the three lines at ➌ accomplish. The `rev` command reverses its input character
    by character so that the `cut -d. -f1` gets the filename suffix, since we don’t
    know how many dots are going to appear in the filename. Then the suffix is reordered
    the right way and `"+wm."` is added.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the `composite` utility ➍ to pull the pieces together and make
    our watermarked image. You can experiment with different `-dissolve` values to
    make the overlay more or less opaque.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The script takes two arguments: the name of the image to watermark and the
    text of the watermarking sequence itself. If the watermark will be more than a
    single word, make sure the entire phrase is in quotes so it transfers properly,
    as [Listing 14-4](ch14.xhtml#ch14ex4) shows.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-4: Running the* `*watermark*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The result is shown in [Figure 14-1](ch14.xhtml#ch14fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: Image with automatically applied watermark*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run into an `unable to read font` error, then you are likely missing
    the Ghostscript software suite (common on OS X). To remedy this, install Ghostscript
    with your package manager. For example, use this command to install the `brew`
    package manager on OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The font size used for the watermark should be a function of the size of the
    image. If the image is 280 pixels wide, a 44-point watermark would be too big,
    but if the image is 3800 pixels wide, 44 points might be too small. Choosing an
    appropriate font size or text placement can be left to the user by adding it to
    the script as another parameter.
  prefs: []
  type: TYPE_NORMAL
- en: ImageMagick also knows the fonts on your system, so it would be helpful to allow
    users to specify a font by name to use as the watermark.
  prefs: []
  type: TYPE_NORMAL
- en: '**#96 Framing Images**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s often useful to be able to wrap a border or fancy frame around an image,
    and ImageMagick has a lot of capabilities in this regard through the `convert`
    utility. The problem is, as with the rest of the suite, it’s hard to figure out
    how to use this tool from the ImageMagick documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s the explanation of the `-frame` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: The size portion of the *geometry* argument indicates the amount of extra width
    and height that is added to the dimensions of the image. If no offsets are given
    in the *geometry* argument, then the border added is a solid color. Offsets *x*
    and *y*, if present, specify that the width and height of the border is partitioned
    to form an outer bevel of thickness *x* pixels and an inner bevel of thickness
    *y* pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Got it?
  prefs: []
  type: TYPE_NORMAL
- en: Maybe it would be easier to just see an example. In fact, that’s exactly what
    we’ll do with the `usage()` function in this script, as shown in [Listing 14-5](ch14.xhtml#ch14ex5).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-5: The* `*frameit*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we’ve already explored `getopts` as a way to gracefully parse complex
    parameters to a script, this wrapper script is pretty straightforward, with most
    of the work happening in the last few lines. In the `for` loop ➊, a new version
    of the filename specified is created with a `"+f"` suffix (prior to the file type
    suffix).
  prefs: []
  type: TYPE_NORMAL
- en: For a filename like *abandoned-train.png*, the suffix would be `png` and the
    prefix would be `abandoned-train`. Notice we lost the period (`.`), but we’ll
    add that back in when we build the new filename ➋. Once that’s accomplished, it’s
    just a matter of invoking the `convert` program with all the parameters ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Specify the type of frame you want—either with `-frame` (for more elaborate,
    3D effects) or with `-border` (for a simple border)—along with the appropriate
    ImageMagick geometry values, a preferred color for the border or matte portion,
    and the input filename (or filenames). [Listing 14-6](ch14.xhtml#ch14ex6) shows
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-6: Running the* `*frameit*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The result of this invocation is shown in [Figure 14-2](ch14.xhtml#ch14fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: A museum-style 3D matte frame*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you forget a parameter, ImageMagick issues a typically baffling error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A smart hack would be to add additional error testing in the script to save
    the user from these ugly things, don’t you think?
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible that this script might hiccup with filenames that include spaces.
    Of course, spaces should never be included in a filename that’s intended to go
    on a web server, but you should still fix the script to remove this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**#97 Creating Image Thumbnails**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re surprised how often this problem crops up: someone either includes a
    ridiculously large image on a web page or emails a photograph far larger than
    the computer screen. It’s not only annoying but also a waste of bandwidth and
    computer resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script we will implement creates a thumbnail image from any picture you
    give it, allowing you to specify detailed height and width parameters or simply
    indicate that the resultant smaller image must fit within certain dimensions.
    Indeed, creating thumbnails is an officially recommended use of the cool `mogrify`
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that generally you want to create your thumbnails in a parallel directory
    rather than in the same directory as the original images. In fact, the `mogrify`
    utility can be quite dangerous if misused, as it can overwrite all the images
    in a directory with a thumbnail version, destroying the original copy. To alleviate
    this concern, the `mogrify` command creates 100 × 100 thumbnail images in the
    *thumbs* subdirectory, converting them from JPEG to GIF along the way.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful but still narrow in application. Let’s create a more general
    purpose thumbnail-processing script, like the one shown in [Listing 14-7](ch14.xhtml#ch14ex7).
    It could certainly be used to accomplish the above task, but it can also be used
    for a lot of other image reduction tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-7: The* `*thumbnails*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ImageMagick is so complicated, it just begs for scripts like this one that can
    simplify common tasks. In this script, we’re tapping into a couple of additional
    features, including the `-strip` ➋ parameter to remove the exchangeable image
    file format (EXIF) information that’s useful for photo archives but unnecessary
    for online use (for example, camera used, ISO speed of photograph, f-stop, geolocation
    data, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The other new flag is `-unsharp` ➊, a filter that ensures the shrunk thumbnails
    don’t end up blurry from the processing. Explaining the potential values for this
    parameter and how they would affect the result would involve a whole lotta science,
    so in the spirit of keeping things simple, we’re using the parameter `0x.5` without
    explanation. Want to know more? A web search will pull up the details quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to understand the difference between thumbnails of an exact size
    and those that fit within certain dimensions is to see examples, as in [Figure
    14-3](ch14.xhtml#ch14fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Difference between a thumbnail of an exact given size (*`*-e*`
    *argument) and one set to fit certain dimensions proportionally (*`*-f*` *argument)*'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between creating an exact thumbnail and a fitted thumbnail internally
    is just a single exclamation mark. That’s what’s going on at ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, you’ve seen everything in this script before, from the breakdown
    and reassembly of filenames to the use of the `-format` flag to get the height
    or width of the current image.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-8](ch14.xhtml#ch14ex8) shows the script at work, creating new thumbnails
    in different sizes for a photo of Hawaii.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-8: Running the* `*thumbnails*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A neat addition to this script would be the ability to make an assortment of
    thumbnails based on multiple size ranges passed in, so for example, you could
    create a 100 × 100, 500 × 500, and wallpaper-sized 1024 × 768 image all in one
    go. On the other hand, perhaps such a task is better left to another shell script.
  prefs: []
  type: TYPE_NORMAL
- en: '**#98 Interpreting GPS Geolocation Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most photographs nowadays are taken with cell phones or other smart digital
    devices that know their latitude and longitude. There’s a privacy issue with this,
    of course, but there’s also something interesting about being able to pinpoint
    where a photograph was taken. Unfortunately, while ImageMagick’s `identify` tool
    lets you extract that GPS information, the format of the data makes it hard to
    read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The information shown is in degrees, minutes, and seconds—which makes sense—but
    the format is nonintuitive, particularly since the format that a site like Google
    Maps or Bing Maps expects is more akin to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This script translates the EXIF information into the latter format so you can
    copy and paste the data directly into a mapping program. As part of that process,
    the script has to solve some rudimentary equations (notice that the seconds value
    of the latitude provided by the `identify` tool is 1983/100, which equals 19.83).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The idea of latitude and longitude is older than you might think. In fact,
    Portuguese mapmaker Pedro Reinel first drew latitude lines on his maps back in
    1504\. The calculations also involve some peculiar math. Fortunately, we don’t
    have to work them out. Instead, we just need to know how to convert the EXIF latitude
    and longitude values into those that modern mapping applications expect, as you’ll
    see in [Listing 14-9](ch14.xhtml#ch14ex9). This script also makes use of the `echon`
    script from [Script #8](ch01.xhtml#ch01lev1sec09) on [page 33](ch01.xhtml#page_33).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-9: The* `*geoloc*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every time we explore using ImageMagick, we find that there’s another parameter
    and another way to utilize its capabilities. In this case, it turns out that you
    can use the `-format` argument at ➊ to extract only specific matching parameters
    from the EXIF information associated with an image.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use `GPSL` as the pattern to `grep` for, not `GPS`. That’s so we
    won’t have to pick through the additional GPS-related information that would be
    reported. Try removing the `L` and see how much other EXIF data is printed!
  prefs: []
  type: TYPE_NORMAL
- en: After that, it’s a matter of extracting specific fields of information and solving
    the mathematical equations with `scriptbc` to convert the data to a meaningful
    format, as demonstrated by the `latdeg` lines at ➋.
  prefs: []
  type: TYPE_NORMAL
- en: By this point, pipes with `cut` used more than once should be familiar to you.
    These are a super useful scripting tool!
  prefs: []
  type: TYPE_NORMAL
- en: Once all the data is extracted and all the equations solved, we need to reassemble
    the information in a manner consistent with the standard notation for latitude
    and longitude, as we do at ➌. And we’re done!
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Give the script an image, and if the file includes latitude and longitude information,
    the script will convert it to a format that’s ready to be analyzed by Google Maps,
    Bing Maps, or any other major mapping program, as [Listing 14-10](ch14.xhtml#ch14ex10)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-10: Running the* `*geoloc*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What happens if you input a photograph that doesn’t have EXIF information? That’s
    something that the script should address gracefully, not just output an ugly error
    message from a failed call to `bc` or print empty coordinates, don’t you think?
    Adding some more defensive code that ensures the GPS location values pulled from
    ImageMagick are sane would be a useful addition.
  prefs: []
  type: TYPE_NORMAL
