<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_3" aria-label="3"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch1">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">1</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">HELLO, WORLD OF ASSEMBLY LANGUAGE</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This “quick-start” chapter gets you writing basic assembly language programs as rapidly as possible, giving you the skills you need to learn new assembly language features in the following chapters. You’ll learn the foundations of 64-bit ARM architecture and the basic syntax of the GNU assembler (Gas) program, a compiler for assembly language.</p>&#13;
<p class="TX">You’ll also learn to set aside memory for variables, control the CPU by using machine instructions, and link a Gas program with C/C++ code so that you can call routines in the C standard library (C stdlib). Gas running under Linux and macOS is by far the most common assembler for writing real-world ARM assembly language programs. Vendors (especially Apple) have produced variants of Gas with slightly different syntax; for instance, under macOS, Gas is known as the <i>Clang</i> or <i>Mach-O</i> assembler. To make the source code in this book portable between macOS and Linux, this chapter <span role="doc-pagebreak" epub:type="pagebreak" id="pg_4" aria-label="4"/>also introduces a header file, <i>aoaa.inc</i>, that eliminates the differences between Gas and the Clang assembler.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-8"/><span class="SANS_Futura_Std_Bold_B_11">1.1 What You’ll Need</span></h3>&#13;
<p class="TNI1">To learn assembly language programming with Gas, you’ll need a version of the assembler for your platform, plus a text editor for creating and modifying Gas source files, a linker, various library files, and a C++ compiler. You’ll learn to set up the Gas assembler and text editor in this section, and the other tools later in this chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-1"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.1.1 Setting Up Gas</span></h4>&#13;
<p class="TNI1">The GNU Compiler Collection (GCC) emits Gas source code as its output (which Gas then converts to object code). Therefore, if you have the compiler suite running on your system, you also have Gas. Apple macOS uses a compiler based on the LLVM compiler suite rather than GCC, so if you have a macOS, you’ll need to install its Xcode integrated development environment (IDE) to gain access to the assembler (see <span class="Xref"><a href="appendix-C.xhtml">Appendix C</a></span>). Otherwise, if you don’t have the GCC compiler, install it with the instructions in your operating system (OS) documentation.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The GNU assembler and the Clang assembler’s executable name is actually</i> <span class="note_Italic">as</span> <i>(assembler). The examples in this book rarely invoke the assembler directly, so you won’t use the</i> <span class="note_Italic">as</span> <i>program often. Therefore, this book refers to the assembler by using the name</i> <span class="note_Italic">Gas</span> <i>rather than</i> <span class="note_Italic">as</span> <i>(or Clang assembler).</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-2"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.1.2 Setting Up a Text Editor</span></h4>&#13;
<p class="TNI1">To write ARM assembly language programs, you will need some sort of programmer’s text editor to create assembly language source files. The choice of editor is dictated by personal tastes and editor availability for your OS or development suite.</p>&#13;
<p class="TX">The standard suffix for assembly language source files is <i>.s</i>, since GCC emits this suffix when it converts a C/C++ file into assembly language during compilation. For handwritten assembly language source files, the <i>.S</i> suffix is a better choice, since it tells the assembler to route the source file through the C preprocessor (CPP) before assembly. Since this allows the use of CPP macros (<span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements), conditional compilation, and other facilities, all example files in this book use <i>.S</i>.</p>&#13;
<p class="TX">GCC always produces assembly language output files, which are then processed by Gas. GCC automatically invokes the assembler and then deletes the assembly source file after the assembly is complete.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-3"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.1.3 Understanding C/C++ Examples</span></h4>&#13;
<p class="TNI1">Today’s software engineers drop into assembly language only when their C/C++, C#, Java, Swift, or Python code is running too slowly and they need <span role="doc-pagebreak" epub:type="pagebreak" id="pg_5" aria-label="5"/>to improve the performance of certain modules or functions. The examples in this book use C/C++ because you’ll typically interface assembly language with C/C++ or other high-level language (HLL) code in the real world.</p>&#13;
<p class="TX">The C/C++ standard library is another good reason to use this language. To make the C stdlib immediately accessible to Gas programs, I present examples with a short C++ main function that calls a single external function written in assembly language using Gas. Compiling the C++ main program along with the Gas source file produces a single executable file that you can run and test.</p>&#13;
<p class="TX">This book spoon-feeds you the C++ you’ll need to run the example HLL programs, so you’ll be able to follow even if you’re not fluent in the language. However, you’ll have an easier time if you have a little prior familiarity with C/C++. At minimum, this book assumes that you have some experience in a language such as Pascal (or Delphi), Java, Swift, Rust, BASIC, Python, or any other imperative or object-oriented programming language.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-9"/><span class="SANS_Futura_Std_Bold_B_11">1.2 The Anatomy of an Assembly Language Program</span></h3>&#13;
<p class="TNI1">A typical (stand-alone) Gas program takes the form shown in Listing 1-1.</p>&#13;
<pre id="pre-4"><code>// Listing1-1.S&#13;
//&#13;
// Comments consist of all text from a //&#13;
// sequence to the end of the line.&#13;
// The .text directive tells Gas that the&#13;
// statements following this directive go in the&#13;
// section of memory reserved for machine&#13;
// instructions (code).&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> .text&#13;
&#13;
// Here is the main function. (This example assumes&#13;
// that the assembly language program is a&#13;
// stand-alone program with its own main function.)&#13;
//&#13;
// Under macOS, the main program must have the name&#13;
// _main beginning with an underscore. Linux&#13;
// systems generally don't require the underscore.&#13;
//&#13;
// The .global _main statement makes the _main&#13;
// procedure's name visible outside this source file&#13;
// (needed by the linker to produce an executable).&#13;
&#13;
        .global _main, main&#13;
&#13;
// The .align 2 statement tells the assembler to&#13;
// align the following code on a 4-byte boundary&#13;
// (required by the ARM CPU). The 2 operand&#13;
// specifies 2 raised to this power (2), which is 4.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_6" aria-label="6"/>      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> .align 2&#13;
&#13;
// Here's the actual main program. It consists of a&#13;
// single ret (return) instruction that simply&#13;
// returns control to the operating system.&#13;
&#13;
_main:&#13;
main:&#13;
        ret</code></pre>&#13;
<p class="TX">Assembly language programs are broken into <i>sections</i>. Some sections contain data, some contain constants, some contain machine instruction (executable statements), and so on. Listing 1-1 contains a single code section, called <i>text</i> in macOS and Linux. The <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> statement <span class="CodeAnnotation" aria-label="annotation1">❶</span> tells the assembler that the following statements are associated with the code section.</p>&#13;
<p class="TX">In assembly language source files, symbols are usually local or private to a source file. When creating an executable source file, you must pass one or more symbols to the system linker—at least the name of the main program. You can accomplish this by using the <span class="SANS_TheSansMonoCd_W5Regular_11">.global</span> statement, specifying the global name as an operand: <span class="SANS_TheSansMonoCd_W5Regular_11">_main</span> in the macOS case, <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> in the Linux case. Leaving out this statement gives you an error when you try to compile the source file.</p>&#13;
<p class="TX">The ARM instruction set requires all machine instructions to begin on a 32-bit (4-byte) boundary in memory. Therefore, before the first machine instruction in a <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, tell the assembler to align the addresses on a 4-byte boundary. The <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> statement <span class="CodeAnnotation" aria-label="annotation2">❷</span> raises 2 to the power specified by its operand and aligns the next instruction on that boundary. Since 2<sup>2</sup> is equal to 4, this statement aligns the next instruction on a 4-byte boundary.</p>&#13;
<p class="TX">A procedure, or function, in ARM assembly simply consists of the name of that function (<span class="SANS_TheSansMonoCd_W5Regular_11">_main</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> in this case) followed by a colon. The machine instructions follow. The main program in this example consists of a single machine instruction: <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> (return). This instruction immediately returns control to whatever called the main program—that is, the OS.</p>&#13;
<p class="TX">Identifiers in Gas are similar to identifiers in most HLLs. Gas identifiers may begin with a dollar sign (<span class="SANS_TheSansMonoCd_W5Regular_11">$</span>), an underscore (<span class="SANS_TheSansMonoCd_W5Regular_11">_</span>), or an alphabetic character and may be followed by zero or more alphanumeric, dollar sign, or underscore characters. Symbols are case sensitive.</p>&#13;
<aside class="box" aria-label="box-1">&#13;
<p class="BH" id="box-1"><span class="SANS_Dogma_OT_Bold_B_11">LINUX VS. MACOS: GLOBAL NAMES</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">The C/C++ compiler treats global (</span><span class="SANS_TheSansMonoCd_W5Regular_11">extern</span><span class="SANS_Futura_Std_Book_11">) names differently in macOS and Linux programs. The Clang compiler (macOS) automatically prepends an underscore character (</span><span class="SANS_TheSansMonoCd_W5Regular_11">_</span><span class="SANS_Futura_Std_Book_11">) to the beginning of each external/global symbol, as in</span> <span class="SANS_TheSansMonoCd_W5Regular_11">_main</span> <span class="SANS_Futura_Std_Book_11">in Listing 1-1; the GCC compiler does not.</span></p>&#13;
<p class="BoxBodyLast"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_7" aria-label="7"/><span class="SANS_Futura_Std_Book_11">I’ve written the source code appearing in this book to make it easy to port between the two OSes, by using equates for all the global symbols so that they have to be changed in only one spot. We’ll discuss using equates to resolve external symbols in section 4.1, “Gas Constant Declarations,” on <a href="chapter4.xhtml#pg_170">page 170</a>; also see section 1.12, “For More Information,” on <a href="chapter1.xhtml#pg_43">page 43</a> for details specific to macOS and Linux assembly language programming.</span></p>&#13;
</aside>&#13;
<p class="TX">While the program in Listing 1-1 doesn’t really <i>do</i> anything, you can use it to learn how to use the assembler, linker, and other tools necessary for writing ARM assembly language programs, as we’ll do in the next section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-10"/><span class="SANS_Futura_Std_Bold_B_11">1.3 Running Your First Assembly Language Program</span></h3>&#13;
<p class="TNI1">Once you have an assembly source file, you can compile and run that program. In theory, you could run the assembler (<span class="SANS_TheSansMonoCd_W5Regular_11">as</span>) and then the linker (<span class="SANS_TheSansMonoCd_W5Regular_11">ld</span>, supplying appropriate library files needed by the OS). Here’s how that would look for macOS (where the <span class="SANS_TheSansMonoCd_W5Regular_11">$</span> appearing at the beginning of each line is the OS’s shell prompt):</p>&#13;
<pre id="pre-5"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">as -arch arm64 Listing1-1.S -o Listing1-1.o</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">ld -o Listing1-1 Listing1-1.o -lSystem \</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">     -syslibroot</span> <span class="SANS_TheSansMonoCd_W7Bold_11">`xcrun -sdk macosx --show-sdk-path` \</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">     -e _main -arch arm64</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing1-1</span> </code></pre>&#13;
<p class="TX">However, the command lines differ depending on your OS, and producing an executable in this way takes a lot of typing. An easier way to compile the program and produce an executable is to use the GCC compiler (<span class="SANS_TheSansMonoCd_W5Regular_11">g++</span>) by running this command:</p>&#13;
<pre id="pre-6"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">g++ -o Listing1-1 Listing1-1.S</span> </code></pre>&#13;
<p class="TX">This command line even works on macOS, which uses the Clang compiler rather than GCC; macOS has an alias for Clang named <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span>. On macOS, you could also use the <span class="SANS_TheSansMonoCd_W5Regular_11">clang -o Listing1-1 Listing1-1.S</span> command line. This book, however, will stick to the <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span> command line, as that works on macOS and Linux.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span> command is smart enough to note that this is an assembly language source file and run Gas on it to produce an object file. GCC will then run the linker (<span class="SANS_TheSansMonoCd_W5Regular_11">ld</span>) and supply all the default libraries the OS requires.</p>&#13;
<p class="TX">You can run the resulting executable file from the command line as follows:</p>&#13;
<pre id="pre-7"><code>$<span class="SANS_TheSansMonoCd_W7Bold_11"> ./Listing1-1</span> </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_8" aria-label="8"/>This program immediately returns without any output, since that’s all Listing 1-1 does; it’s simply intended to demonstrate how to compile and run ARM assembly language programs.</p>&#13;
<p class="TX">In addition to reducing the amount of typing required, using <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span> to assemble your assembly language source files provides another advantage: it’s the easiest way to run the CPP, which many of the example files in this book require. You can invoke the CPP (by itself) on an assembly source file by using a command like the following, to see the modifications the CPP makes to your assembly source files:</p>&#13;
<pre id="pre-8"><code><span class="SANS_TheSansMonoCd_W7Bold_11">$ g++ -E Listing1-1.S</span> </code></pre>&#13;
<p class="TX">You can even pipe the output from the CPP to Gas, using the following command:</p>&#13;
<pre id="pre-9"><code><span class="SANS_TheSansMonoCd_W7Bold_11">$ g++ -E Listing1-1.S | as -o Listing1-1.o</span> </code></pre>&#13;
<p class="TX">However, at that point, you may as well have typed</p>&#13;
<pre id="pre-10"><code><span class="SANS_TheSansMonoCd_W7Bold_11">$ g++ -o Listing1-1.o Listing1-1.S</span> </code></pre>&#13;
<p class="Continued1">as it’s shorter and easier to input.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-11"/><span class="SANS_Futura_Std_Bold_B_11">1.4 Running Your First Gas/C++ Hybrid Program</span></h3>&#13;
<p class="TNI1">This book commonly combines an assembly language module containing one or more functions written in assembly language with a C/C++ main program that calls those functions. Because the compilation and execution process is slightly different from a stand-alone Gas program, this section demonstrates how to create, compile, and run a hybrid assembly/C++ program. Listing 1-2 provides the main C++ program that calls the assembly language module.</p>&#13;
<pre id="pre-11"><code>// Listing1-2.S &#13;
//&#13;
// A simple C++ program that calls &#13;
// an assembly language function &#13;
//&#13;
// Need to include stdio.h so this &#13;
// program can call printf().&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
// extern "C" namespace prevents &#13;
// "name mangling" by the C++&#13;
// compiler. &#13;
&#13;
extern "C"&#13;
{&#13;
    // Here's the external function, &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_9" aria-label="9"/>    // written in assembly language, &#13;
    // that this program will call: &#13;
&#13;
     void asmMain(void); &#13;
};&#13;
&#13;
int main(void) &#13;
{&#13;
    printf("Calling asmMain:\n"); &#13;
    asmMain();&#13;
    printf("Returned from asmMain\n"); &#13;
}</code></pre>&#13;
<p class="TX">Listing 1-3, a slight modification of the stand-alone Gas program, contains the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain()</span> function that the C++ program calls. The main difference between Listing 1-3 and Listing 1-1 is that the function’s name changes from <span class="SANS_TheSansMonoCd_W5Regular_11">_main</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">_asmMain</span>. The C++ compiler and linker would get confused if we continued to use the name <span class="SANS_TheSansMonoCd_W5Regular_11">_main</span>, as that’s also the name of the C++ main function.</p>&#13;
<pre id="pre-12"><code>// Listing1-3.S &#13;
//&#13;
// A simple Gas module that contains &#13;
// an empty function to be called by &#13;
// the C++ code in Listing 1-2 &#13;
&#13;
        .text &#13;
&#13;
// Here is the asmMain function: &#13;
&#13;
        .global _asmMain, asmMain &#13;
        .align  2    // Guarantee 4-byte alignment. &#13;
_asmMain: &#13;
asmMain: &#13;
&#13;
// Empty function just returns to C++ code. &#13;
&#13;
        ret          // Returns to caller </code></pre>&#13;
<p class="TX">Finally, to compile and run these source files, run the following commands:</p>&#13;
<pre id="pre-13"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">g++ -o Listing1-2 Listing1-2.cpp Listing1-3.S</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing1-2</span> &#13;
Calling asmMain: &#13;
Returned from asmMain &#13;
$</code></pre>&#13;
<p class="TX">Granted, this assembly language example doesn’t accomplish much other than demonstrate how to compile and run some assembly code. To write real assembly code, you’re going to need a lot of support code. The <span role="doc-pagebreak" epub:type="pagebreak" id="pg_10" aria-label="10"/>next section describes the <i>aoaa.inc</i> header file that provides some of this support.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-12"/><span class="SANS_Futura_Std_Bold_B_11">1.5 The aoaa.inc Include File</span></h3>&#13;
<p class="TNI1">The example code in this book was written to be as portable between macOS and Linux assemblers as possible, a difficult task requiring considerable advanced behind-the-scenes trickery. Many of those tricks are a bit too advanced to easily explain to beginning ARM programmers, so I’ve incorporated all this magic code in a special header file, <i>aoaa.inc</i>, that I use in most of the example programs from this point forward.</p>&#13;
<p class="TX">This human-readable include file is little more than a typical advanced C/C++ header file; it just contains a bunch of macros (for example, C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements) that help smooth out some of the differences between the macOS and Linux versions of the assembler. By the time you get to the end of this book (especially by the time you read <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>), most of the material in the header file will make perfect sense. For now, I won’t distract you with advanced macros and conditional assembly information.</p>&#13;
<p class="TX">You can find <i>aoaa.inc</i> along with all the other example code at <i><a href="https://artofarm.randallhyde.com">https://<wbr/>artofarm<wbr/>.randallhyde<wbr/>.com</a></i>. If you’re curious about this file’s content and don’t want to wait for <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>, load it into a text editor and take a look.</p>&#13;
<p class="TX">To include this file in an assembly, use the following CPP statement in your assembly language source files:</p>&#13;
<pre id="pre-14"><code>#include "aoaa.inc"</code></pre>&#13;
<p class="TX">Just as in C/C++, this statement will automatically insert the content of this file into the current source file during assembly (at the point of the <span class="SANS_TheSansMonoCd_W5Regular_11">#include</span> statement).</p>&#13;
<p class="TX">Gas has its own include statement, used as follows:</p>&#13;
<pre id="pre-15"><code>.include "include_file_name"</code></pre>&#13;
<p class="TX">However, don’t use this statement to include <i>aoaa.inc</i> in your source files. The Gas <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive executes after the CPP runs, but <i>aoaa.inc</i> contains CPP macros, conditional compilation statements, and other code that must be processed by the CPP. If you use the <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive rather than <span class="SANS_TheSansMonoCd_W5Regular_11">#include</span>, the CPP will never see the contents of the <i>aoaa.inc</i> file, and Gas will generate errors when it processes the file.</p>&#13;
<p class="TX">The <i>aoaa.inc</i> file must be present in the same directory as your assembly source file during the assembly process (or you must supply an appropriate path to the file in the <span class="SANS_TheSansMonoCd_W5Regular_11">#include "aoaa.inc"</span> statement). If the header file isn’t in the current directory, Gas will complain that it can’t find the file and terminate the assembly. Also remember to use the <i>.S</i> suffix with your assembly source files when using <span class="SANS_TheSansMonoCd_W5Regular_11">#include "aoaa.inc"</span>, or GCC won’t run the CPP on those files.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_11" aria-label="11"/>&#13;
<h3 class="H1" id="sec9"><span id="h1-13"/><span class="SANS_Futura_Std_Bold_B_11">1.6 The ARM64 CPU Architecture</span></h3>&#13;
<p class="TNI1">Thus far, you’ve seen a pair of Gas programs that compile and run. However, the statements appearing in those programs do nothing more at this point than return control to the OS. Before you learn some real assembly language, you’ll need to understand the basic structure of the ARM CPU family so you can follow the machine instructions.</p>&#13;
<p class="TX">The ARM CPU family is generally classified as a Von Neumann architecture machine. Von Neumann computer systems contain three main building blocks: the <i>central processing unit (CPU)</i>, <i>memory</i>, and <i>input/output (I/0) devices</i>. These three components are interconnected via the <i>system bus</i> (consisting of the address, data, and control buses). <a href="chapter1.xhtml#fig1-1">Figure 1-1</a> shows this relationship.</p>&#13;
<figure class="IMG"><img class="img5" id="fig1-1" src="../images/Figure1-1.jpg" alt="" width="619" height="508"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-1: A Von Neumann computer system block diagram</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The CPU communicates with memory and I/O devices by placing a numeric value on the address bus to select one of the memory or I/O device port locations, each of which has a unique binary numeric <i>address</i>. Then the CPU, memory, and I/O devices pass data among themselves by placing the data on the data bus. The control bus contains signals that determine the direction of the data transfer (to/from memory and to/from an I/O device).</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-4"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.6.1 ARM CPU Registers</span></h4>&#13;
<p class="TNI1">There are two categories of ARM CPU registers: <i>general-purpose registers</i> and <i>special-purpose kernel-mode registers</i>. The special-purpose registers are intended for writing OSes, debuggers, and other system-level tools. Such software construction is well beyond the scope of this text.</p>&#13;
<p class="TX">The ARM64 supports 32 general-purpose 64-bit registers (named X0 through X31) and 32 general-purpose 32-bit registers (named W0 through W31). This doesn’t imply there are 64 registers total; instead, the 32-bit registers overlay the low-order (LO) 32 bits of each of the 64-bit registers. (<span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> discusses LO components in more depth.) Modifying one of the 32-bit registers also modifies the corresponding 64-bit register, and vice versa, as outlined in <a href="chapter1.xhtml#fig1-2">Figure 1-2</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_12" aria-label="12"/>&#13;
<figure class="IMG"><img class="img5" id="fig1-2" src="../images/Figure1-2.jpg" alt="" width="474" height="1814"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-2: The 32- and 64-bit registers on the ARM</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Those new to assembly language are often surprised that all calculations on the ARM64 involve a register. For example, to add two variables together, storing the sum into a third variable, you must load one of the variables into a register, add the second operand to the value in the register, and then store the register away in the destination variable. Registers are a middleman in nearly every calculation, so they’re important in ARM64 assembly language programs.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_13" aria-label="13"/>Although these registers are known as <i>general-purpose</i> registers, a few of them have special purposes:</p>&#13;
<ul class="ul">&#13;
<li class="BL">X31, usually referred to as <i>SP</i> in code, is called the <i>stack pointer</i>, since it’s used to maintain a <i>hardware stack</i> on the ARM (another non-RISC, or reduced instruction set computer, feature), always as a 64-bit register. Because it’s used as the stack pointer, SP cannot be used for other purposes in most code. This register is accessible only by a few instructions.</li>&#13;
<li class="BL">The XZR/WZR register (also treated as X31/W31 by the hardware) is called the <i>zero</i> register. It always returns 0 when read and is a convenient way to obtain the constant 0 in a program.</li>&#13;
<li class="BL">Register X30 is the <i>link register</i>, referred to by the name <i>LR</i> rather than X30. The ARM CPU uses this register to hold <i>return addresses</i> when the code makes a function call. (<span class="listbullet_Xref"><a href="chapter5.xhtml">Chapter 5</a></span> discusses the LR in greater detail.) This register is also always accessed in 64-bit mode. While you could theoretically use X30/W30 as a general-purpose register, you should avoid doing so, because function calls will wipe out the value in this register.</li>&#13;
<li class="BL">Although this special purpose isn’t enforced by the hardware, most software uses X29 as a 64-bit <i>frame pointer (FP)</i>. Software generally uses this register to provide access to function parameters and local variables. Technically, you could use any of the general-purpose registers for this purpose, but using X29/FP is conventional.</li>&#13;
<li class="BL">Apple reserves X18 for its own internal purposes. Programs written for macOS, iOS, iPadOS, and so on must not use this register. Since 29 other registers are available, the examples in this book don’t use X18, even for Linux examples.</li>&#13;
</ul>&#13;
<p class="TX">In addition to the 32 general-purpose registers, the ARM64 CPUs have two additional special-purpose registers accessible to user programs: the 32-bit <i>processor state (PSTATE)</i> register and the 64-bit <i>program counter (PC)</i> register. The PC register always contains the address of the machine instruction being executed. Because instructions are always 32 bits long, the CPU will increment this register by 4 whenever it finishes the execution of one instruction and moves on to the next (more on this activity in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>).</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>32-bit ARM CPUs refer to the PSTATE register as the</i> <span class="note_Italic">CPSR</span> <i>or</i> <span class="note_Italic">PSR</span><i>. You may see references to those names in various documents.</i></p>&#13;
<p class="TX">The PSTATE register is 32 bits wide (of which only 16 bits are used at the time of this writing) and is really just a collection of individual Boolean flags. Its layout appears in <a href="chapter1.xhtml#fig1-3">Figure 1-3</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig1-3" src="../images/Figure1-3.jpg" alt="" width="1689" height="101"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-3: The PSTATE register layout</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_14" aria-label="14"/>Most user applications use only the N, Z, C, and V bits in the PSTATE register. These bits, also known as the <i>condition codes</i>, have the following meanings:</p>&#13;
<div class="top">&#13;
<p class="RunInPara1"><b>N</b>    Negative (sign) flag, set when an instruction produces a negative result</p>&#13;
<p class="RunInPara1"><b>Z</b>    Zero flag, set when an instruction produces a zero result</p>&#13;
<p class="RunInPara1"><b>C</b>    Carry flag, set when an unsigned arithmetic overflow occurs</p>&#13;
<p class="RunInPara1"><b>V</b>    Overflow flag, set when a signed arithmetic overflow occurs</p>&#13;
</div>&#13;
<p class="TX">Most of the remaining flags are inaccessible or of little use in user programs. UAO and PAN control CPU access features, allowing user programs to access kernel memory. SS is the single-step control bit for debugging. IL is the illegal instruction flag, set when the CPU executes an illegal instruction. D, A, I, and F are interrupt flags. cEL selects an exception level, usually 00 for user mode. SPS selects a stack pointer to use (kernel versus user mode).</p>&#13;
<p class="TX">In addition to the 32 general-purpose registers, the ARM64 provides 32 floating-point and vector registers to handle nonintegral arithmetic. <span class="Xref"><a href="chapter6.xhtml">Chapters 6</a></span> and <span class="Xref"><a href="chapter11.xhtml">11</a></span> discuss these registers in greater detail when covering floating-point arithmetic and single-instruction/multiple data (SIMD) operations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-5"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.6.2 The Memory Subsystem</span></h4>&#13;
<p class="TNI1">A typical ARM64 processor running a modern 64-bit OS can access a maximum of 2<sup>48</sup> memory locations, or just over 256TB—probably far more than any of your programs will ever need. Since the ARM64 supports byte-addressable memory, the basic memory unit is a byte, which is sufficient to hold a single character or a very small integer value (discussed further in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>).</p>&#13;
<p class="TX">Because 2<sup>48</sup> is a frightfully large number, the following discussion uses the 4GB address space of 32-bit ARM processors. Scaled up, the same discussion applies to 64-bit ARM processors.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>While the ARM64 supports 64 address bits in software, the hardware supports only 48 to 52 address bits for virtual memory operations. Most OSes limit this to 48 bits.</i></p>&#13;
<p class="TX">Think of memory as a linear array of bytes. The address of the first byte is 0, and the address of the last byte is 2<sup>32</sup> – 1. For an ARM processor, the following pseudo-Pascal array declaration is a good approximation of memory:</p>&#13;
<pre id="pre-16"><code>Memory: array [0..4294967295] of byte; </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_15" aria-label="15"/>C/C++ and Java users might prefer the following syntax:</p>&#13;
<pre id="pre-17"><code>byte Memory[4294967296]; </code></pre>&#13;
<p class="TX">To execute the equivalent of the Pascal statement <span class="SANS_TheSansMonoCd_W5Regular_11">Memory [125] := 0;</span>, the CPU places the value 0 on the data bus, places the address 125 on the address bus, and asserts the write line (which generally involves setting that line to 0), as shown in <a href="chapter1.xhtml#fig1-4">Figure 1-4</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig1-4" src="../images/Figure1-4.jpg" alt="" width="748" height="375"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-4: The memory write operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To execute the equivalent of <span class="SANS_TheSansMonoCd_W5Regular_11">CPU := Memory [125];</span>, the CPU places the address 125 on the address bus, asserts the read line (because the CPU is reading data from memory), and reads the resulting data from the data bus (see <a href="chapter1.xhtml#fig1-5">Figure 1-5</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig1-5" src="../images/Figure1-5.jpg" alt="" width="748" height="376"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-5: The memory read operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This discussion applies only when accessing a single byte in memory. To store values larger than a single byte, like <i>half words</i> (2 bytes) and <i>words</i> (4 bytes), the ARM uses a sequence of consecutive memory locations, as shown in <a href="chapter1.xhtml#fig1-6">Figure 1-6</a>. The memory address is the address of each object’s first byte (that is, the lowest address).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_16" aria-label="16"/>&#13;
<figure class="IMG"><img class="img5" id="fig1-6" src="../images/Figure1-6.jpg" alt="" width="755" height="813"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-6: Byte, half-word, and word storage in memory</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The ARM64 generally supports <i>unaligned memory access</i>, meaning the CPU can read or write an object of any size—byte, half word, word, or double word (dword)—at any address in memory. Certain instructions, however, require that memory access be aligned on the natural size of the transfer. Generally, this means that 16-, 32-, and 64-bit memory accesses must take place on addresses that are a multiple of 2, 4, or 8; otherwise, the CPU may raise an exception. Regardless of exceptions, the CPU can usually access memory locations aligned on a natural boundary faster.</p>&#13;
<p class="TX">Modern ARM processors don’t connect directly to memory. Instead, a special memory buffer on the CPU known as the <i>cache</i> (pronounced “cash”) acts as a high-speed intermediary between the CPU and main memory. You’ll learn to set the alignment of memory objects and the effects of the cache on data alignment in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-14"/><span class="SANS_Futura_Std_Bold_B_11">1.7 Declaring Memory Variables in Gas</span></h3>&#13;
<p class="TNI1">Referencing memory by using numeric addresses in assembly language is possible, but painful and error-prone. Rather than having your program state, “Give me the 32-bit value held in memory location 192 and the 16-bit value held in memory location 188,” it’s much nicer to state, “Give me the contents of <span class="SANS_TheSansMonoCd_W5Regular_11">elementCount</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">portNumber</span>.” Using variable names, rather than memory addresses, makes your program much easier to write, read, and maintain.</p>&#13;
<p class="TX">To create (writable) data variables, you have to put them in a data section of the Gas source file, defined using the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> directive. The <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> directive tells Gas that all following statements (up to the next <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> or other section-defining directive) will define data declarations to be grouped into a read/write section of memory.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label="17"/>Within a <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, Gas allows you to declare variable objects by using a set of data declaration directives. The basic form of a data declaration directive is</p>&#13;
<pre id="pre-18"><code><var>label</var>:<var>  directive value(s)</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> is a legal Gas identifier and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">directive</span> is one of the directives in the following list:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.byte</span>    Byte (8-bit) values. One or more comma-separated 8-bit expressions appear in the operand field (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">values</span>).</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.hword</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_11">.short</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_11">.2byte</span>    Half-word (16-bit) values. One or more comma-separated 16-bit expressions appear in the operand field.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.word</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_11">.4byte</span>    Word (32-bit) values. One or more comma-separated 32-bit expressions appear in the operand field.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.quad</span><b>,</b> <span class="SANS_TheSansMonoCd_W7Bold_11">.8byte</span>    Dword (64-bit) values. One or more comma-separated 64-bit expressions appear in the operand field. <span class="SANS_TheSansMonoCd_W5Regular_11">.quad</span> is an unfortunate misnomer for ARM64, since a 64-bit value is actually a double word, not a quad word (on the ARM, a quad word is 128 bits). The term predates the ARM assembler, coming from “quad word” in the x86 and 68000 assembly language days. To avoid confusion, this book uses the <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> directive in place of <span class="SANS_TheSansMonoCd_W5Regular_11">.quad</span>.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.dword</span>    The <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> macro appearing in the <i>aoaa.inc</i> include file is a synonym for the <span class="SANS_TheSansMonoCd_W5Regular_11">.quad</span> directive that emits 8 bytes (64 bits) for each operand. Using <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> is preferable to <span class="SANS_TheSansMonoCd_W5Regular_11">.quad</span>. You must include the <i>aoaa.inc</i> file in order to use this directive.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.octa</span>    Octaword (oword, 128-bit/16-byte) values. One or more comma-separated 128-bit expressions appear in the operand field. <span class="SANS_TheSansMonoCd_W5Regular_11">.octa</span> is an unfortunate misnomer for ARM64, since a 128-bit value is actually a quad word, not an “octa” word (on the ARM, an octaword is 256 bits). To avoid confusion, this book avoids the <span class="SANS_TheSansMonoCd_W5Regular_11">.octa</span> directive and uses <span class="SANS_TheSansMonoCd_W5Regular_11">.qword</span> instead.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.qword</span>    This is a macro appearing the <i>aoaa.inc</i> include file. It is a synonym for the <span class="SANS_TheSansMonoCd_W5Regular_11">.octa</span> directive and emits 16 bytes for each operand. You must include the <i>aoaa.inc</i> file in order to use this directive.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.ascii</span>    String values. A single string constant (surrounded by quotation marks) appears in the operand field. Note that Gas does not terminate this string with a 0 byte.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.asciz</span>    Zero-terminated string values. A single string constant (surrounded by quotation marks) appears in the operand field. Gas will emit a 0 after the last character in the string operand.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.float</span>    Single-precision floating-point values. One or more comma-separated 32-bit single-precision floating-point expressions appear in the operand field.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">.double</span>    Double-precision floating-point values. One or more comma-separated 64-bit double-precision floating-point expressions appear in the operand field.</p>&#13;
</div>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_18" aria-label="18"/>Gas provides additional synonyms for some of the directives in this list; see the link to the Gas documentation in section 1.12, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_43">page 43</a></span>.</p>&#13;
<p class="TX">Here are some examples of valid Gas data declarations:</p>&#13;
<pre id="pre-19"><code>byteVar:    .byte   0 &#13;
halfVar:    .hword  1,2  // Actually reserves 2 half-words &#13;
wordVar:    .word   -1 &#13;
dwordVar:   .dword  123456789012345 &#13;
str1:       .ascii  "Hello, world!\n"  // Uses C-style escape for newline &#13;
str2:       .asciz  "How are you?\n"   // Sequences are legal. &#13;
pi:         .float  3.14159 &#13;
doubleVar:  .double 1.23456e-2 </code></pre>&#13;
<p class="TX">Whenever you declare a variable in this manner, Gas will associate the current location in the output object-code file with the label at the beginning of the line. It will then emit the appropriate-sized data value into memory at that location, adjusting the assembler’s <i>location counter</i> (which tracks the current location) by the size of each operand it emits.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">label</span> field in these data declaration directives is optional. If you do not include the label, Gas simply emits the data in the operand field, starting at the current location counter and incrementing the location counter afterward. This is useful, for example, when you want to insert a control character or special Unicode character into a string:</p>&#13;
<pre id="pre-20"><code>longStr:   .ascii "A bell character follows this string"&#13;
           .byte  7, 0   // Bell (7) and zero termination </code></pre>&#13;
<p class="TX">Gas allows C-style escape sequences within quoted strings. Although Gas doesn’t support the full set of escape characters, it does support the following:</p>&#13;
<div class="top">&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_11">\b</span>        Backspace character (0x08)</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_11">\n</span>        Newline character/line feed (0x0A)</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_11">\r</span>        Carriage return (0x0D)</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_11">\t</span>         Tab (0x09)</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_11">\f</span>        Form feed character (0x0C)</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_11">\\</span>         Backslash character</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">\nnn</span>    Where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nnn</span> is a three-digit octal value; emit the value to the code stream</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_11">\x</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">hh</span>    Where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">hh</span> is a two-digit hexadecimal value; emit the value to the code stream</p>&#13;
</div>&#13;
<p class="TX">Gas does not support <span class="SANS_TheSansMonoCd_W5Regular_11">\a</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">\e</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">\f</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">\v</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">\'</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">\"</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">\?</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">\u</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">hhhh</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">\U</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">hhhh</span> escape sequences.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_19" aria-label="19"/>&#13;
<h4 class="H2" id="sec13"><span id="h2-6"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.7.1 Associating Memory Addresses with Variables</span></h4>&#13;
<p class="TNI1">With an assembler like Gas, you don’t have to worry about numeric memory addresses. Once you declare a variable in Gas, the assembler associates that variable with a unique set of memory addresses. For example, say you have the following declaration section:</p>&#13;
<pre id="pre-21"><code>      .data&#13;
i8:   .byte   0&#13;
i16:  .hword  0&#13;
i32:  .word   0&#13;
i64:  .dword  0</code></pre>&#13;
<p class="TX">Gas will find an unused 8-bit byte in memory and associate it with the <span class="SANS_TheSansMonoCd_W5Regular_11">i8</span> variable; it will likewise associate a pair of consecutive unused bytes with <span class="SANS_TheSansMonoCd_W5Regular_11">i16</span>, 4 consecutive unused bytes with <span class="SANS_TheSansMonoCd_W5Regular_11">i32</span>, and 8 consecutive unused bytes with <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span>. You’ll always refer to these variables by their names and generally don’t have to concern yourself with their numeric addresses. Still, be aware that Gas is doing this for you.</p>&#13;
<p class="TX">When Gas is processing declarations in a <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, it assigns consecutive memory locations to each variable. Assuming <span class="SANS_TheSansMonoCd_W5Regular_11">i8</span> (in the previous declarations) as a memory address of 101, Gas will assign the addresses appearing in <a href="chapter1.xhtml#tab1-1">Table 1-1</a> to <span class="SANS_TheSansMonoCd_W5Regular_11">i8</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">i16</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">i32</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span>.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab1-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 1-1:</span></span> <span class="SANS_Futura_Std_Book_11">Variable Address Assignments</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Variable</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Memory address</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB"><span class="SANS_TheSansMonoCd_W5Regular_11">i8</span></p></td>&#13;
<td class="TBF"><p class="TB"><span class="SANS_Futura_Std_Book_11">101</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB"><span class="SANS_TheSansMonoCd_W5Regular_11">i16</span></p></td>&#13;
<td class="TB"><p class="TB"><span class="SANS_Futura_Std_Book_11">102 (address of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">i8</span> <span class="SANS_Futura_Std_Book_11">plus 1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB"><span class="SANS_TheSansMonoCd_W5Regular_11">i32</span></p></td>&#13;
<td class="TB"><p class="TB"><span class="SANS_Futura_Std_Book_11">104 (address of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">i16</span> <span class="SANS_Futura_Std_Book_11">plus 2)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB"><span class="SANS_TheSansMonoCd_W5Regular_11">i64</span></p></td>&#13;
<td class="TBL"><p class="TB"><span class="SANS_Futura_Std_Book_11">108 (address of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">i32</span> <span class="SANS_Futura_Std_Book_11">plus 4)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Technically, Gas assigns offsets into the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.data</span> section to variables. Linux/macOS converts these offsets to physical memory addresses when it loads the program into memory at runtime.</p>&#13;
<p class="TX">Whenever you have multiple operands in a data declaration statement, Gas will emit the values to sequential memory locations in the order in which they appear in the operand field. The label associated with the data declaration (if one is present) is associated with the address of the first (leftmost) operand’s value. See <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> for more details.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-7"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.7.2 Aligning Variables</span></h4>&#13;
<p class="TNI1">As noted already, your programs may run faster if your variables are aligned on a <i>natural boundary</i> (alignment to the size of the object). Alignment is accomplished with the <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> directive, which you saw in Listing 1-1.</p>&#13;
<p class="TX">Byte variables don’t require any alignment. Use the <span class="SANS_TheSansMonoCd_W5Regular_11">.align 1</span> directive to put half words at an even address (2-byte boundary); remember, Gas will <span role="doc-pagebreak" epub:type="pagebreak" id="pg_20" aria-label="20"/>align the next statement on a boundary that is equal to 2<i><sup>n</sup></i>, where <i>n</i> is the <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> statement’s operand. For words, use the <span class="SANS_TheSansMonoCd_W5Regular_11">.align 2</span> directive. For double words (<span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span>), use the <span class="SANS_TheSansMonoCd_W5Regular_11">.align 3</span> directive.</p>&#13;
<p class="TX">For example, let’s return to the declaration given earlier:</p>&#13;
<pre id="pre-22"><code>     .data &#13;
i8:  .byte   0 &#13;
i16: .hword  0 &#13;
i32: .word   0 &#13;
i64: .dword  0 </code></pre>&#13;
<p class="TX">Sticking <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> directives in front of every declaration (except <span class="SANS_TheSansMonoCd_W5Regular_11">i8</span>) will start to clutter up your code and make it harder to read:</p>&#13;
<pre id="pre-23"><code>     .data &#13;
i8:  .byte   0  // No alignment necessary for bytes &#13;
     .align  1 &#13;
i16: .hword  0 &#13;
     .align  2 &#13;
i32: .word   0 &#13;
     .align  3 &#13;
i64: .dword  0 </code></pre>&#13;
<p class="TX">If your variables don’t have to be declared in a particular order, you can clean this up by declaring the largest variables first and the remaining variables sorted by decreasing size. If you do this, you have to align only the first variable in your declaration list:</p>&#13;
<pre id="pre-24"><code>            .data &#13;
     .align  3 &#13;
i64: .dword  0 &#13;
i32: .word   0 &#13;
i16: .hword  0 &#13;
i8:  .byte   0  // No alignment necessary for bytes </code></pre>&#13;
<p class="TX">Because the <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span> declaration appears immediately after the <span class="SANS_TheSansMonoCd_W5Regular_11">.align 3</span> statement in this code, the <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span> address will be aligned on an 8-byte boundary. As <span class="SANS_TheSansMonoCd_W5Regular_11">i32</span> immediately follows <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span> in memory, it will also be aligned on an 8-byte boundary (which, of course, is also a 4-byte boundary). This is because <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span> is aligned on an 8-byte boundary and consumes 8 bytes; therefore, the address following <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span> (the address of <span class="SANS_TheSansMonoCd_W5Regular_11">i32</span>) will also be 8-byte aligned.</p>&#13;
<p class="TX">Meanwhile, because <span class="SANS_TheSansMonoCd_W5Regular_11">i16</span> immediately follows <span class="SANS_TheSansMonoCd_W5Regular_11">i32</span> in memory, it will be aligned on a 4-byte boundary (which is also an even address). The alignment of <span class="SANS_TheSansMonoCd_W5Regular_11">i8</span> doesn’t matter, but it happens to be at an even address, as it follows <span class="SANS_TheSansMonoCd_W5Regular_11">i16</span>, which was aligned on a 4-byte boundary and consumes 2 bytes.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_21" aria-label="21"/><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Gas also provides a</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.balign</span> <i>directive whose operand must be a power of 2 (1, 2, 4, 8, 16, ...) to specify the alignment value directly, rather than as a power of 2. While this book uses</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.align</span> <i>because it’s the original directive, feel free to use</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.balign</span> <i>if you prefer.</i></p>&#13;
<p class="TX">Strings are sequences of bytes, so their alignment usually doesn’t matter. However, it is possible to write very high-performance string functions in assembly language that process strings eight or more characters at a time. If you have access to such library code, it might run faster if your strings are aligned on an 8-byte boundary.</p>&#13;
<p class="TX">Of course, floats and doubles should be aligned on 4-byte and 8-byte boundaries for the highest performance. In fact, as you’ll see in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>, 16-byte alignment is also sometimes better.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-8"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.7.3 Declaring Named Constants in Gas</span></h4>&#13;
<p class="TNI1">Gas allows you to declare manifest constants by using the <span class="SANS_TheSansMonoCd_W5Regular_11">.equ</span> directive. A <i>manifest constant</i> is a symbolic name (identifier) that Gas associates with a value. Everywhere the symbol appears in the program, Gas will directly substitute its value.</p>&#13;
<p class="TX">A manifest constant declaration takes the following form:</p>&#13;
<pre id="pre-25"><code>.equ <var>label</var>, <var>expression</var></code></pre>&#13;
<p class="TX">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> is a legal Gas identifier, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> is a constant arithmetic expression (typically a single literal constant value). The following example defines the symbol <span class="SANS_TheSansMonoCd_W5Regular_11">dataSize</span> to be equal to 256:</p>&#13;
<pre id="pre-26"><code>.equ dataSize, 256</code></pre>&#13;
<p class="TX">Constant declarations, or <i>equates</i> in Gas terminology, may appear anywhere in your Gas source file prior to their first use: in a <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, in a <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, or even outside any sections.</p>&#13;
<p class="TX">Once you define a constant symbol with <span class="SANS_TheSansMonoCd_W5Regular_11">.equ</span>, it cannot be further modified in the source file during assembly. If you need to reassign the value associated with a label during assembly (see <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> for reasons you’d want to do this), use the <span class="SANS_TheSansMonoCd_W5Regular_11">.set</span> directive:</p>&#13;
<pre id="pre-27"><code>    .set valueCanChange, 6&#13;
      .&#13;
      .  // valueCanChange has the value 6 here.&#13;
      .&#13;
    .set valueCanChange, 7&#13;
&#13;
// From this point forward, valueCanChange has the value 7.</code></pre>&#13;
<p class="TX">Equates can specify textual arguments as well as numeric constants.</p>&#13;
<p class="TX">Because Gas will run your source files through the CPP if the filename suffix is <i>.S</i>, you can also use the CPP <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> macro definition to create <span role="doc-pagebreak" epub:type="pagebreak" id="pg_22" aria-label="22"/>named constants. Although the <span class="SANS_TheSansMonoCd_W5Regular_11">.equ</span> directive is probably the better choice, the C macro form offers a few advantages, like allowing arbitrary textual substitution, not just numeric expression substitution. For more on this, see <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-9"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.7.4 Creating Register Aliases in Gas and Substituting Text</span></h4>&#13;
<p class="TNI1">As you begin to write more complex ARM assembly language programs, you’ll discover that the 32 general-purpose register names (X0 to X30 and SP) obscure the meaning of their values in the program. It’s been decades since BASIC supported only variable names like A0, A1, B2, and Z3. To avoid returning to those days by using meaningless two-character names, Gas provides a way to create more meaningful aliases of register names in your programs: the <span class="SANS_TheSansMonoCd_W5Regular_11">.req</span> directive.</p>&#13;
<p class="TX">The syntax of the <span class="SANS_TheSansMonoCd_W5Regular_11">.req</span> directive is</p>&#13;
<pre id="pre-28"><code><var>symbolicName</var>  .req  <var>register</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">symbolicName</span> is any valid Gas identifier and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">register</span> is one of the 32- or 64-bit register names. After this statement in the source file, if you use <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">symbolicName</span> in place of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">register</span>, Gas will automatically substitute that register for the name.</p>&#13;
<p class="TX">Sadly, the <span class="SANS_TheSansMonoCd_W5Regular_11">.req</span> directive works only for creating register aliases; you can’t use it as a general-purpose text-substitution facility. However, if you name your assembly language source files with <i>.S</i>, Gas/GCC will first run your source file through the CPP. This allows you to embed C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements in your assembly source file, and the CPP will happily expand any symbols you define in such statements throughout your source file. The following example demonstrates using <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span>:</p>&#13;
<pre id="pre-29"><code>#define arrayPtr X0&#13;
&#13;
// From this point forward, you can use arrayPtr in place of X0.</code></pre>&#13;
<p class="TX">Typically, you’ll use <span class="SANS_TheSansMonoCd_W5Regular_11">.req</span> for register aliases and <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> for any other textual substitutions in the source file, though my personal preference is to use the <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statement for both purposes in this book. Since <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> also accepts parameters, it’s flexible. Gas also supports textual substitution via <i>macros</i>; see <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> for more on this.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h1-15"/><span class="SANS_Futura_Std_Bold_B_11">1.8 Basic ARM Assembly Language Instructions</span></h3>&#13;
<p class="TNI1">Thus far, the programming examples in this chapter have consisted of functions that use only the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction. This section describes a few more instructions to get you started writing more meaningful assembly language programs.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_23" aria-label="23"/>&#13;
<h4 class="H2" id="sec18"><span id="h2-10"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.8.1 ldr, str, adr, and adrp</span></h4>&#13;
<p class="TNI1">One solidly RISC feature of ARM is its use of <i>load/store architecture</i>. All computational activity takes place in the ARM’s registers; the only instructions that access main memory are those that load a value from memory or store a value into memory.</p>&#13;
<p class="TX">Although the ARM64 has many general-purpose registers for holding variable values (and thus can avoid using memory), most applications use more variable data than can fit in all the registers. This is especially true for larger objects like arrays, structs, and strings. Furthermore, programming conventions—known as the <i>application binary interface (ABI)</i>, discussed later in this chapter—often reserve many of ARM’s registers so they cannot be used to hold application variables for any length of time. So variables must be placed in main memory and accessed via these <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> (load) and <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> (store) instructions.</p>&#13;
<p class="TX">This is the generic syntax for the load and store instructions</p>&#13;
<pre id="pre-30"><code>ldr{<var>size</var>}  <var>reg</var>, <var>mem</var>&#13;
str{<var>size</var>}  <var>reg</var>, <var>mem</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span> is either absent or one of the character sequences <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">h</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sb</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sh</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">sw</span>; <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span> is one of the ARM’s 32- or 64-bit registers; and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mem</span> is a memory addressing mode that specifies where to fetch the data from in memory. The <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction loads the register specified by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span> from the memory location specified by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mem</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instruction stores the value held in the register operand into the memory location.</p>&#13;
<p class="TX"><span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> discusses the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span> operand in greater depth, but this chapter largely ignores the size suffixes on the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions. Without a size prefix, the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span> operand determines the operation’s size. If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span> is X<i>n</i>, the instruction transfers 64 bits; if it’s W<i>n</i>, then the instruction transfers 32 bits.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mem</span> operand is either the name of a variable in your program, typically in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section (Linux only), or a register name surrounded by square brackets (<span class="SANS_TheSansMonoCd_W5Regular_11">[]</span>). In this latter case, the register holds the numeric memory address of the memory location to access. See <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> for more on <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mem</span>.</p>&#13;
<aside class="box" aria-label="box-2">&#13;
<p class="BH" id="box-2"><span class="SANS_Dogma_OT_Bold_B_11">LINUX VS. MACOS: POSITION-INDEPENDENT EXECUTABLES</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">One major OS policy difference between macOS and Linux ARM assembly language is that macOS requires the use of</span> <span class="SANS_Futura_Std_Book_Oblique_11">position-independent executables (PIE)</span><span class="SANS_Futura_Std_Book_11">, while Linux only encourages them. PIE allows the system to load the various sections of a program into different memory locations at runtime. This is important for two reasons: it enables the use of shared libraries and addresses security concerns.</span></p>&#13;
<p class="BTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_24" aria-label="24"/><span class="SANS_Futura_Std_Book_Oblique_11">Shared libraries</span> <span class="SANS_Futura_Std_Book_11">contain code shared among applications. An OS will load only one copy of a library’s code into physical memory and share that single copy among multiple running applications. However, the library code has to sit at an address in a given application’s memory space in order for that application to call functions within the library, yet the address used for a library function in one application may already be in use when a second application attempts to load the library. Therefore, the second application will need to call that function at a different address in its own virtual memory address space.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">If two separate copies of the function were made in real memory, calling the function at different addresses in memory wouldn’t be an issue; the first application could locate the function at an address completely independent of the second. However, one major reason to use shared libraries is to share the exact same code in real (physical) memory.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">The OS resolves the virtual memory address conflicts by programming the memory management unit (MMU) to map that physical memory to two separate virtual memory addresses in the two applications. However, for this to work, the library code must not access any</span> <span class="SANS_Futura_Std_Book_Oblique_11">absolute</span> <span class="SANS_Futura_Std_Book_11">(fixed) memory addresses; if it does, the second application maps the function to a different address in the virtual memory address space, and the sharing concept fails. For example, if the library code transfers control from location 0x12_3456 to location 0x12_3500 in memory, this transfer will fail if the code is moved to a different location; the application will still want to transfer to location 0x12_3500, even though the code has moved elsewhere.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">For machine instructions, this is not a problem. The ARM instructions that transfer control typically use</span> <span class="SANS_Futura_Std_Book_Oblique_11">program-counter-relative (PC-relative)</span> <span class="SANS_Futura_Std_Book_11">addressing. Rather than transfer control to a fixed location (like 0x12_3500), they transfer control to a location relative to the current location. That is, they transfer to a location a certain number of bytes before or after the current value in the PC register. If the code moves to a different fixed address in memory, the instruction will still transfer to the correct place, because the destination location moved along with the current instruction.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">Unfortunately, this scheme doesn’t work for data. If a shared library accesses global data, the OS has to create a separate block of data for each application that uses the shared library; you typically don’t want one application to affect the data in another application. That means data addresses must be relocatable as well.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">The ARM CPU can also access data at locations relative to the PC, so in theory, the OS can remap the data to a different location for each application, as it does for the code. However, using PIE is still wise for security reasons. In the past, various hacks have taken advantage of the fact that the data for a shared library sits at a fixed offset from the code. To help prevent such exploits, macOS and Linux support</span> <span class="SANS_Futura_Std_Book_Oblique_11">address space layout randomization (ASLR)</span><span class="SANS_Futura_Std_Book_11">. With this feature, the OS randomly assigns a different address to the code and data sections of a program (or library) code when loading it into memory. This makes it more difficult for a hack to exploit the code.</span></p>&#13;
<p class="BoxBodyLast"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_25" aria-label="25"/><span class="SANS_Futura_Std_Book_11">ASLR also makes it slightly more difficult (and less efficient) to access that data. Worse still, Linux and macOS provide completely different mechanisms for accessing position-independent data. This is transparent to HLL programmers, but it has to be handled explicitly when writing assembly language code. This creates problems in a book such as this one, where the goal is to provide example code that compiles and runs on different OSes. As for other Linux versus macOS issues, the</span> <span class="SANS_Futura_Std_Book_Oblique_11">aoaa.inc</span> <span class="SANS_Futura_Std_Book_11">header file contains macros and other code to resolve these issues. I’ll have more to say about PIE in <a href="chapter3.xhtml">Chapter 3</a>.</span></p>&#13;
</aside>&#13;
<p class="TX">Because macOS requires that your applications be written in a position-independent fashion (as we just discussed in <span class="Xref">“Linux vs. macOS: Position-Independent Executables”</span>), you will not be able to use an <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction of this form:</p>&#13;
<pre id="pre-31"><code>ldr x0, i64   // i64 is a 64-bit variable declared&#13;
              // in the .data section by using .dword.</code></pre>&#13;
<p class="TX">To access the <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span> variable, you must first load its address into a 64-bit register, then access that data by using the <i>register-indirect addressing mode</i>, or X<i>n</i>. To do so, place the address of the variable you want to access in the register by using the <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span> instructions:</p>&#13;
<pre id="pre-32"><code>adr  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span>, <var>mem</var>&#13;
adrp <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span>, <var>mem</var></code></pre>&#13;
<p class="TX">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span> is the name of a 64-bit general-purpose register, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mem</span> is a memory addressing mode, like the name of a global variable. The <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> instruction loads <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span> with the address of the memory variable, which must be ±1MB from the <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> instruction if the operand is just the name of a variable (like <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span> from the previous example). The <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span> instruction loads the 64-bit destination register with the page (4,096-byte boundary) containing the memory object. That value will have the LO 12 bits containing all 0s.</p>&#13;
<p class="TX">Because of macOS’s PIE requirements, it doesn’t take kindly to instructions such as the following:</p>&#13;
<pre id="pre-33"><code>ldr x0, i64</code></pre>&#13;
<p class="TX">On the Mac, you must use the register-indirect addressing mode to access a global variable. Unfortunately</p>&#13;
<pre id="pre-34"><code>adr x1, i64</code></pre>&#13;
<p class="Continued1">fails for the same reason: you’re not allowed to specify the name of a global variable.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_26" aria-label="26"/>In this book, to get the address of a global variable into a register under macOS, we’ll use the following statement:</p>&#13;
<pre id="pre-35"><code>lea <var>reg</var>, <var>mem</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> (load effective address) macro, included in <i>aoaa.inc</i>, will expand into two instructions (different ones depending on your OS). These instructions will load the address of the second operand (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mem</span>) into the 64-bit register specified by the first operand (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span>). You can use <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> in any projects where you’ve included <i>aoaa.inc</i> at the beginning of your source file.</p>&#13;
<p class="TX">As noted, the <i>aoaa.inc</i> macros make the code in this book portable between OSes. However, you can choose to go with the appropriate OS-specific code, which can sometimes be more efficient, once you master basic ARM assembly language programming. See <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> for more details on <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span>.</p>&#13;
<p class="TX">To conclude this discussion of taking the address of a variable, let’s recap how to load and store values by using <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str</span>:</p>&#13;
<pre id="pre-36"><code>        .data&#13;
i64:    .dword  0  // This also requires the aoaa.inc file.&#13;
         .&#13;
         .&#13;
         .&#13;
// Load i64's value into X0:&#13;
&#13;
        lea x0, i64&#13;
        ldr x0, [x0]&#13;
         .&#13;
         .&#13;
         .&#13;
// Store X0 into i64:&#13;
&#13;
        lea x1, i64&#13;
        str x0, [x1]</code></pre>&#13;
<p class="TX">When loading X0 with a variable’s value, you can first load X0 with the address of the variable and then load X0 indirectly from the location held in X0. This winds up using only a single register. However, when storing data to memory, you need a second register to hold the address (X1 in this example).</p>&#13;
<p class="TX">If you are referencing a particular variable several times within a small section of code, it’s more efficient to load its address into a register just once and reuse that register value multiple times, rather than constantly reloading the address:</p>&#13;
<pre id="pre-37"><code>lea x1, i64&#13;
ldr x0, [x1]&#13;
 .&#13;
 .&#13;
 .&#13;
str x0, [x1]</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_27" aria-label="27"/>Of course, this means you can’t use the register for any other purpose while it holds <span class="SANS_TheSansMonoCd_W5Regular_11">i64</span>’s address. Fortunately, for just this reason, the ARM64 has lots of registers.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-11"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.8.2 mov</span></h4>&#13;
<p class="TNI1">Beyond the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions, the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction handles two additional data movement operations: moving data between a pair of registers and copying a constant into a register. The generic syntax for <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> is as follows:</p>&#13;
<pre id="pre-38"><code>mov <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src</span>&#13;
mov <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, #<var>constant</var></code></pre>&#13;
<p class="TX">The first <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction copies the data in the source register (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src</span>) into the destination register (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>). This instruction is equivalent to the C/C++ statement <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src</span><span class="SANS_TheSansMonoCd_W5Regular_11">;</span>. The source and destination registers can be any of the general-purpose registers but must be the same size (32 or 64 bits).</p>&#13;
<p class="TX">The second <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction moves a small integer constant into the destination register. Constants encoded as part of the instruction are known as <i>immediate constants</i> and are generally preceded by a <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> character (though Gas often allows you to drop the <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> when specifying literal numeric constants). <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> discusses limitations on constants, but for now, assume any constant less than ±2,047 will work.</p>&#13;
<p class="TX">Here are two examples of the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction:</p>&#13;
<pre id="pre-39"><code>mov x1, x0   // X1 = X0&#13;
mov x2, #10  // X2 = 10</code></pre>&#13;
<p class="TX">There are many additional variants of <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span>, covered in depth in later chapters. For example, if you encounter a constant you cannot load into a register with a single <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction, other variants of <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> let you load any arbitrary 32- or 64-bit constant by using two to three instructions. In the meantime, this variant of the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction will load any constant into a register:</p>&#13;
<pre id="pre-40"><code>ldr <var>reg</var>, =<var>veryLargeConstant</var></code></pre>&#13;
<p class="TX">The assembler will simply store <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">veryLargeConstant</span> in a memory location somewhere and then load the contents of that memory location to the specified register. Use this handy pseudo-instruction when you need to load a large constant into a register with a single instruction.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_28" aria-label="28"/>&#13;
<h4 class="H2" id="sec20"><span id="h2-12"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.8.3 add and sub</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> instructions handle simple arithmetic on the ARM CPU. These instructions take many forms covered more thoroughly in the next couple of chapters. Their basic forms are the following:</p>&#13;
<pre id="pre-41"><code>add  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rsrc</span> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsr</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">c</span> + <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rsrc</span>&#13;
add  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span>, #<var>const</var> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span> + <var>const</var>&#13;
adds <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rsrc</span> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span> + <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rsrc</span>&#13;
adds <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span>, #<var>const</var> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span> + <var>const</var>&#13;
sub  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rsrc</span> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span> - <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rsrc</span>&#13;
sub  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span>, #<var>const</var> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span> - <var>const</var>&#13;
subs <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rsrc</span> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span> - <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rsrc</span>&#13;
subs <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span>, #<var>const</var> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span> - <var>const</var></code></pre>&#13;
<p class="Continued1">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">lsrc</span>, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">rsrc</span> are 32- or 64-bit registers (which must all be the same size for a given instruction), and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">const</span> is an immediate constant in the range 0 to 4,095. You’ll learn to specify larger constants later, but these forms are sufficient for the example programs in the next few chapters.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Some assemblers allow a range of –4,095 to +4,095 and swap the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">add</span> <i>and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">sub</span> <i>instructions if the immediate constant is negative.</i></p>&#13;
<p class="TX">The instructions with the <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix affect the condition code flags. They set the flags according to the conditions specified in the following list:</p>&#13;
<div class="top">&#13;
<p class="RunInPara1"><b>N</b>    Set if the arithmetic operation produces a negative result (high-order, or HO, bit is set); clear if it produces a nonnegative result (HO bit is clear).</p>&#13;
<p class="RunInPara1"><b>Z</b>    Set if the arithmetic operation produces a 0 result; clear if it produces a nonzero result.</p>&#13;
<p class="RunInPara1"><b>C</b>    Set if the addition operation produces an unsigned overflow (carry out of the HO bit). Clear if a subtraction operation produces a borrow (unsigned underflow), and set otherwise.</p>&#13;
<p class="RunInPara1"><b>V</b>    Set if the arithmetic operation produces a signed overflow (carry out of the next-to-HO bit).</p>&#13;
</div>&#13;
<p class="TX">The following instructions negate their source operands, because they subtract the source register from 0 (remember that WZR and XZR are the zero registers and return 0 when read):</p>&#13;
<pre id="pre-42"><code>sub <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest32</span>, wzr, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src32</span> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest32</span> = -<var> reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src32</span>&#13;
sub <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest64</span>, xzr, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src64</span> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest64</span> = -<var> reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">s</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rc64</span></code></pre>&#13;
<p class="TX">Gas provides synonyms for these instructions:</p>&#13;
<pre id="pre-43"><code>neg  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest32</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src32</span> // Negate instruction, no flags&#13;
negs <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest32</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src32</span> // Negate instruction, w/flags&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_29" aria-label="29"/>neg  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest64</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src64</span> // Negate instruction, no flags&#13;
negs <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest64</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src64</span> // Negate instruction, w/flags</code></pre>&#13;
<p class="TX">These forms are a little easier to read.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-13"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.8.4 bl, blr, and ret</span></h4>&#13;
<p class="TNI1">Calling procedures and functions is handled by the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> (branch and link) and <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span> (branch and link through register) instructions. Here’s their syntax</p>&#13;
<pre id="pre-44"><code>bl  <var>label</var>&#13;
blr X<var>n</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> is a statement label preceding code in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, and <span class="SANS_TheSansMonoCd_W5Regular_11">X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> represents one of the 64-bit registers. These two instructions copy the address of the next instruction (following the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span> instruction) into the link register (LR/X30), then transfer control either to the target <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> or to the address specified by the contents of X<i>n</i>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction does have a minor limitation: it can transfer control only to a statement label within ±128MB of the current instruction. This is generally far more than enough for any function you’ll write. In theory, if the OS loads code into another section (besides <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span>), it could be placed sufficiently far away that it would exceed this range. The OS linker will probably complain if this occurs. This book generally places all code within the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, as it would be rare for such programs to exceed this limitation.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span> instruction copies the full 64-bit address from X<i>n</i> into the PC (after copying the address of the next instruction into LR). Therefore, <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span> does not have the range limitation of the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction. If you ever do encounter the range limitation when using <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span>, overcome it by using the following sequence:</p>&#13;
<pre id="pre-45"><code>lea x0, <var>farAwayProcedure</var>&#13;
blr x0</code></pre>&#13;
<p class="TX">This will load the address of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">farAwayProcedure</span> into X0 (no matter where it appears in memory), then transfer control to that procedure via <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction has appeared in several examples up to this point. It copies the contents of the LR (X30) register into the PC. Assuming that LR was loaded with a value as a result of executing the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span> instruction, this returns control to the instruction following the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">blr</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instructions have one issue: the ARM architecture tracks only a single subroutine call with the LR register. Consider the following code fragment:</p>&#13;
<pre id="pre-46"><code>someFunc:&#13;
        ret&#13;
         .&#13;
         .&#13;
         .&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_30" aria-label="30"/>main:&#13;
        bl someFunc&#13;
        ret</code></pre>&#13;
<p class="TX">When the OS calls the main program, it loads the LR register with the return address back to the OS. Normally, when the main program completes execution, its <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction transfers control to this location. However, that’s not the case in this example: when the main program begins execution, it immediately calls <span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction. This instruction copies its return address (the address of the main program’s <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction) into the LR register, wiping out the OS’s return address currently residing there. When <span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span> executes the return instruction, it returns control back to the main program.</p>&#13;
<p class="TX">Upon return from <span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span>, the main program executes the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction. However, the LR register now contains the return address of the <span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span> call, which is the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction in the main program, so control transfers there, re-executing <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span>. The LR register’s value hasn’t changed; it still points at that <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction, meaning this code enters an infinite loop continuously executing the return and transferring control back to the return (where LR continues to point).</p>&#13;
<p class="TX"><span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> discusses the high-level solution to this problem. For the time being, we must save the LR register value in the main program before calling <span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span>. One quick-and-dirty way to do this is to copy it into another (unused by main) register and restore LR before the final return:</p>&#13;
<pre id="pre-47"><code>someFunc:&#13;
        ret&#13;
         .&#13;
         .&#13;
         .&#13;
main:&#13;
        mov x1, lr&#13;
        bl someFunc&#13;
        mov lr, x1&#13;
        ret</code></pre>&#13;
<p class="TX">This code saves the return address (in LR) in the X1 register and restores it after returning from <span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span> (the call to <span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span> overwrote the value in LR).</p>&#13;
<p class="TX">In general, saving the return address in the X1 register is a bad idea, because the ARM’s designers reserve X1 for passing parameters. (Using X1 worked in this example because <span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span> doesn’t have any parameters, as it just returns to its caller.) The next section covers in greater depth which registers are reserved for various purposes.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h3 class="H1" id="sec22"><span id="h1-16"/><span class="SANS_Futura_Std_Bold_B_11">1.9 The ARM64 Application Binary Interface</span></h3>&#13;
<p class="TNI1">A CPU’s <i>application binary interface (ABI)</i> describes how programs should use registers, pass parameters between functions, represent data, and many <span role="doc-pagebreak" epub:type="pagebreak" id="pg_31" aria-label="31"/>other conventions. Its primary purpose is to provide interoperability among programming languages and systems. The ARM64’s ABI, for example, describes the conventions that allow C/C++ programs to call functions written in Swift, Pascal, and other languages. Since the GCC (and Clang) compilers follow these rules, you must also follow them to pass information between your assembly language code and code written in an HLL such as C/C++.</p>&#13;
<p class="TX">An ABI is a <i>convention</i>, not an absolute rule. It is a contract between the code being called and the code making the call. When writing your own assembly language functions to be called by your own assembly language code, you are under no obligation to use the ABI and can use whatever inter-code communication scheme you like. However, if you call C/C++ code from your assembly functions, or if your assembly code is being called from C/C++, you must follow the ARM64 ABI. Since this book uses a considerable mixture of C/C++ and assembly code, understanding the ARM64 ABI is critical for our purposes.</p>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h2-14"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.9.1 Register Usage</span></h4>&#13;
<p class="TNI1">The ARM64 ABI reserves some of its 32 general-purpose registers for specific uses and defines whether registers are <i>volatile</i> (meaning you don’t have to preserve their values) or <i>nonvolatile</i> (meaning that you must preserve their values within a function). <a href="chapter1.xhtml#tab1-2">Table 1-2</a> describes the special purposes and volatility of the 32 ARM registers.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_32" aria-label="32"/>&#13;
&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab1-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 1-2:</span></span> <span class="SANS_Futura_Std_Book_11">ARM64 ABI Register Conventions</span></p>&#13;
</caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Register</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Volatile</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Special meaning</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X0/W0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass parameter 1 here, return function results here. Registers X0 through X7 can also be used as a scratchpad/temporary/ local variable if not used as a parameter.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X1/W1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass parameter 2 here, return function results here.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X2/W2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass parameter 3 here, return function results here.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X3/W3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass parameter 4 here, return function results here.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X4/W4</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass parameter 5 here, return function results here.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X5/W5</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass parameter 6 here, return function results here.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X6/W6</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass parameter 7 here, return function results here.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X7/W7</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass parameter 8 here, return function results here.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X8/W8</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pointer to large function return results (for example, a large C structure returned by value).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X9/W9<br/>X10/W10<br/>X11/W11<br/>X12/W12<br/>X13/W13<br/>X14/W14<br/>X15/W15</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes<br/>Yes<br/>Yes<br/>Yes<br/>Yes<br/>Yes<br/>Yes</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Can be used as a scratchpad/temporary/local variable.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X16/W16/IP0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes, but ...</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">You can use this register as a temporary variable, but its value may change across the execution of a control-transfer instruction; the system linker/loader may use this register to create a</span> <span class="SANS_Futura_Std_Book_Oblique_11">veneer</span><span class="SANS_Futura_Std_Book_11">, also known as a</span> <span class="SANS_Futura_Std_Book_Oblique_11">trampoline</span> <span class="SANS_Futura_Std_Book_11">(more on this in <a href="chapter7.xhtml">Chapter 7</a>).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X17/W17/IP1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Yes, but ...</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">You can use this register as a temporary variable, but its value may change across the execution of a control-transfer instruction; the system linker/loader may use this register to create a</span> <span class="SANS_Futura_Std_Book_Oblique_11">veneer</span><span class="SANS_Futura_Std_Book_11">, also known as a</span> <span class="SANS_Futura_Std_Book_Oblique_11">trampoline</span> <span class="SANS_Futura_Std_Book_11">(more on this in <a href="chapter7.xhtml">Chapter 7</a>).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X18/W18/Plat</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">No access</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">This register is reserved for use by the OS, and application programs must not modify its value. Under macOS, you definitely must not modify this register; under Linux, you may get away with using this register if you preserve its value, but the safe choice is to avoid using this register.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X19/W19<br/>X20/W20<br/>X21/W21<br/>X22/W22<br/>X23/W23<br/>X24/W24<br/>X25/W25<br/>X26/W26<br/>X27/W27<br/>X28/W28</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">No<br/>No<br/>No<br/>No<br/>No<br/>No<br/>No<br/>No<br/>No<br/>No</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">A function using this register must save and restore the register’s value so that it contains its original value when the function returns.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X29/W29/FP</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N/A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Reserved for use as the system frame pointer.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X30/W30/LR</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N/A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Reserved for holding function return addresses.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">SP /X31/W31</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N/A</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Reserved for use as the system stack pointer.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Conveniently, when using volatile registers in a function, you don’t have to preserve (save and restore) their values within the function. However, this means that you also cannot expect them to maintain their values across any functions you call via <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span>. Nonvolatile registers will maintain their values across function calls you make, but you must explicitly preserve their values if you modify them within your functions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-15"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.9.2 Parameter Passing and Function Result Conventions</span></h4>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> provides a complete discussion of parameter passing and function results in assembly language. However, when calling functions written in a different languages (particularly HLLs), you must adhere to the conventions that language uses. Most HLLs use the ARM ABI as the convention for passing parameters.</p>&#13;
<p class="TX">The ARM ABI uses registers X0 through X7 to pass up to eight integer parameters to a function. These parameters can be 8-, 16-, 32-, or 64-bit entities. You pass the first parameter in X0, the second in X1, and so on. To pass fewer than eight parameters, simply ignore the additional registers in this set. <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> discusses how to pass more than eight parameters and how to pass data types larger than 64 bits, including arrays and structs. <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> covers how to pass floating-point values to a function.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_33" aria-label="33"/>You can also return function results in these registers. Most functions return integer results in X0. If you’re returning a large object by value, like a structure, array, or string, you typically use X8 to return a pointer to that data object. <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> discusses returning floating-point function results.</p>&#13;
<p class="TX">Registers X0 through X7 are volatile, meaning you can’t expect a called function to preserve the original register values on return. This is true even if you don’t use all eight registers to pass parameter values. If you want to preserve a value across function calls, use a nonvolatile register.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h1-17"/><span class="SANS_Futura_Std_Bold_B_11">1.10 Calling C Library Functions</span></h3>&#13;
<p class="TNI1">All the coding examples in this book so far have immediately returned to the OS, apparently without accomplishing anything. While it is theoretically possible for a pure assembly language program to produce its own output, it takes a lot of work and is largely beyond the scope of this book. Instead, this book calls prewritten C/C++ library code to do the I/O. This section discusses how this is done.</p>&#13;
<p class="TX">Most other books on assembly language that use libraries in this way call the OS by using available <i>application programming interfaces (APIs)</i>. This is a reasonable approach, but such code is tied to the particular OS for which the calls are made (see <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span> for examples). This book instead relies on library functions written in the C stdlib, since it’s available on many OSes.</p>&#13;
<p class="TX">In most introductory programming books, the first programming example provided is the venerable “Hello, world!” program. Here’s that program written in C:</p>&#13;
<pre id="pre-48"><code>#include &lt;stdio.h&gt;&#13;
int main(int argc, char **argv) &#13;
{&#13;
   printf("Hello, world!\n"); &#13;
}</code></pre>&#13;
<p class="TX">Except for an actual <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> statement, the assembly language source files given thus far have fulfilled the purpose of the “Hello, world!” example: learning how to edit, compile, and run a simple program.</p>&#13;
<p class="TX">Most of this book uses the C <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function to handle program output to the console. This function requires one or more arguments—that is, a <i>variable-length</i> parameter list. The first argument is the address of a <i>format string</i>. If that string requires it, additional parameters provide data to convert to string form. For the “Hello, world!” program, the format string (<span class="SANS_TheSansMonoCd_W5Regular_11">"Hello, world!\n"</span>) is the only argument.</p>&#13;
<p class="TX">The C stdlib—and all C functions, for that matter—adheres to the ARM ABI. Therefore, <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> expects its first argument, the format string, in the X0 register. Instead of trying to pass a string (with 14 characters, including the newline) in a 64-bit register, we pass the address of that string in memory. If we put the string <span class="SANS_TheSansMonoCd_W5Regular_11">"Hello, world!\n"</span> in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section along with the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_34" aria-label="34"/>program (out of the way, so the CPU doesn’t try to execute it as code), then we can compute the address of that string by using the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro:</p>&#13;
<pre id="pre-49"><code>hwStr:   .asciz  "Hello, world!\n"&#13;
           . &#13;
           . &#13;
           . &#13;
          lea    x0, hwStr </code></pre>&#13;
<p class="TX">Once we have this string address in X0, calling <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> prints that string to the standard output device:</p>&#13;
<pre id="pre-50"><code>lea x0, hwStr &#13;
bl  printf </code></pre>&#13;
<p class="TX">To run, this program must be linked against the C stdlib and a small C/C++ program like the one in Listing 1-2. Rather than grabbing that program, I’ll create a slightly better version in Listing 1-4 to use with almost every example program in the rest of this book.</p>&#13;
<pre id="pre-51"><code>// Listing1.4.cpp &#13;
//&#13;
// Generic C++ driver program to call AoAA example programs &#13;
// Also includes a "readLine" function that reads a string &#13;
// from the user and passes it on to the assembly language &#13;
// code &#13;
//&#13;
// Need to include stdio.h so this program can call "printf"&#13;
// and stdio.h so this program can call strlen. &#13;
&#13;
#include &lt;errno.h&gt;&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
&#13;
// Extern "C" namespace prevents "name mangling" by the C++&#13;
// compiler: &#13;
&#13;
extern "C"&#13;
{&#13;
    // asmMain is the assembly language code's "main program":&#13;
&#13;
    <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> void asmMain(void); &#13;
&#13;
    // getTitle returns a pointer to a string of characters &#13;
    // from the assembly code that specifies the title of that &#13;
    // program (that makes this program generic and usable &#13;
    // with a large number of sample programs in "The Art of &#13;
    // ARM Assembly Language"):&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> char *getTitle(void); &#13;
&#13;
    // C++ function that the assembly &#13;
    // language program can call: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_35" aria-label="35"/><span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> int readLine(char *dest, int maxLen); &#13;
&#13;
};&#13;
&#13;
// readLine reads a line of text from the user (from the &#13;
// console device) and stores that string into the destination &#13;
// buffer the first argument specifies. Strings are limited in &#13;
// length to the value specified by the second argument &#13;
// (minus 1). &#13;
//&#13;
// This function returns the number of characters actually &#13;
// read, or -1 if there was an error. &#13;
//&#13;
// If the user enters too many characters (maxLen or &#13;
// more), this function returns only the first maxLen - 1 &#13;
// characters. This is not considered an error. &#13;
&#13;
int readLine(char *dest, int maxLen) &#13;
{&#13;
    // Note: fgets returns NULL if there was an error, else &#13;
    // it returns a pointer to the string data read (which &#13;
    // will be the value of the dest pointer): &#13;
&#13;
    char *result = fgets(dest, maxLen, stdin); &#13;
    if(result != NULL) &#13;
    {&#13;
        // Wipe out the newline character at the &#13;
        // end of the string: &#13;
&#13;
        int len = strlen(result); &#13;
        if(len &gt; 0) &#13;
        {&#13;
            dest[len - 1] = 0; &#13;
        }&#13;
        return len; &#13;
    }&#13;
    return -1; // If there was an error &#13;
}&#13;
&#13;
int main(void) &#13;
{&#13;
    // Get the assembly language program's title: &#13;
&#13;
    char *title = getTitle();&#13;
&#13;
    printf("Calling %s:\n", title); &#13;
    asmMain();&#13;
    printf("%s terminated\n", title); &#13;
&#13;
}</code></pre>&#13;
<p class="TX">This program contains a few additional features over Listing 1-2. First, the name of the assembly language function has changed to <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain()</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the assembly language main program. This code also requires a second <span role="doc-pagebreak" epub:type="pagebreak" id="pg_36" aria-label="36"/>assembly function, <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle()</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This function, provided by the assembly language source code, returns a pointer to a zero-terminated string containing the program’s title. The program displays this title before and after calling <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain()</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">readLine()</span> function appears in the C program that reads a line of text from the user and stores that text into a buffer specified by the caller <span class="CodeAnnotation" aria-label="annotation3">❸</span>. You can call this function from the example assembly code, sparing you from having to write the function in assembly (it’s grunt work better done in C). You’ll see examples of this function call in later chapters.</p>&#13;
<p class="TX">This file (appearing as <i>Listing1-4.cpp</i> or <i>c.cpp</i> in the online code) requires the assembly code to provide a <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle()</span> function that returns the address of a string so the C program can display the name. This string is embedded in the assembly language source file, since most of the programs in this book use only one version of <i>c.cpp</i>. The <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle()</span> function is the same in every program</p>&#13;
<pre id="pre-52"><code>getTitle: &#13;
            lea     x0, title  // C expects pointer in X0. &#13;
            ret </code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_11">title</span> is a zero-terminated string appearing elsewhere in your program (usually in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section). That declaration will usually take this form:</p>&#13;
<pre id="pre-53"><code>title:      .asciz "Listing1-5"</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle</span> function returns the address of this string to the <i>c.cpp</i> program. The string following the <span class="SANS_TheSansMonoCd_W5Regular_11">.asciz</span> directive will typically be the name of the assembly language source file (I used <i>Listing1-5</i> in this example).</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h2-16"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.10.1 Assembling Programs Under Multiple OSes</span></h4>&#13;
<p class="TNI1">We could easily bang out a “Hello, world!” program for Linux or macOS at this point, but the programs would be slightly different for each OS. So that we don’t need to use a different include file for each OS, I’ve modified <i>aoaa.inc</i> to look for a couple of symbol definitions: <span class="SANS_TheSansMonoCd_W5Regular_11">isMacOS</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">isLinux</span>. Both symbols must be defined with the CPP <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> declaration, and one must be true (1) while the other is false (0). The <i>aoaa.inc</i> file uses these symbols to adjust the definitions present in the file for the appropriate OS.</p>&#13;
<p class="TX">In theory, we could use code like the following to define these symbols:</p>&#13;
<pre id="pre-54"><code>#define isMacOS (1)&#13;
#define isLinux (0)&#13;
#include "aoaa.inc"</code></pre>&#13;
<p class="TX">However, this would force every example program to have two versions, one for macOS (the example just given) and one for Linux, containing the following statements:</p>&#13;
<pre id="pre-55"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_37" aria-label="37"/>#define isMacOS (0)&#13;
#define isLinux (1)&#13;
#include "aoaa.inc"</code></pre>&#13;
<p class="TX">GCC has a preferable command line option that lets you define a preprocessor symbol and give it a value:</p>&#13;
<pre id="pre-56"><code>-D <var>name</var>=<var>value</var></code></pre>&#13;
<p class="TX">This way, the following commands will automatically define the symbol prior to assembling the <i>source.S</i> file:</p>&#13;
<pre id="pre-57"><code>g++ -D isMacOS=1 source.S&#13;
g++ -D isLinux=1 source.S</code></pre>&#13;
<p class="TX">We can specify the OS from the command line in this way so that the source files (<i>source.S</i> and <i>aoaa.inc</i>) don’t require any changes under either macOS or Linux. To avoid any extra typing required to assemble the program, we’ll use a command line program known as a <i>shell script</i>.</p>&#13;
<p class="TX">While writing a shell script for this purpose, I also further automated the build process. The script, named <i>build</i>, accepts the base name of an example file without a suffix and automatically deletes any existing object or executable files with that base name (a <i>clean</i> operation, in Unix terminology). It then determines which OS <i>build</i> is running on and then automatically generates the appropriate GCC command line to build the example.</p>&#13;
<aside class="box" aria-label="box-3">&#13;
<p class="BH" id="box-3"><span class="SANS_Dogma_OT_Bold_B_11">SHELL SCRIPTS VS. MAKEFILES</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">If you have experience developing software by using the command line, you may wonder why I haven’t built the examples with a makefile. I discuss makefiles further in <a href="chapter15.xhtml">Chapter 15</a>, but I’ve chosen not to use them here for a couple of reasons:</span></p>&#13;
<ul class="ul">&#13;
<li class="BoxListBullet"><span class="SANS_Futura_Std_Book_11">If you don’t already know the Make language, I’d prefer to put off teaching that until you’ve mastered a little more assembly language.</span></li>&#13;
<li class="BoxListBullet"><span class="SANS_Futura_Std_Book_11">Using Make would mean writing a separate makefile for each example program. However, the</span> <span class="SANS_Futura_Std_Book_Oblique_11">build</span> <span class="SANS_Futura_Std_Book_11">shell script this section describes works for nearly all the example programs in this book.</span></li>&#13;
</ul>&#13;
</aside>&#13;
<p class="TX">For example, to build a file named <i>example.S</i>, you’d execute the following command:</p>&#13;
<pre id="pre-58"><code><span class="SANS_TheSansMonoCd_W7Bold_11">./build example</span></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_38" aria-label="38"/>Under Linux, this would generate the following command:</p>&#13;
<pre id="pre-59"><code>g++ -D isLinux=1 -o example c.cpp example.S</code></pre>&#13;
<p class="TX">Under macOS, it would generate the following:</p>&#13;
<pre id="pre-60"><code>g++ -D isMacOS=1 -o example c.cpp example.S</code></pre>&#13;
<p class="TX">The <i>build</i> script also supports a couple of command line options: <span class="SANS_TheSansMonoCd_W5Regular_11">-c</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">-pie</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">-c</span> (compile-only) option generates the following command line, which only assembles the assembly file to an object file; it does not compile <i>c.cpp</i>, nor does it produce an executable:</p>&#13;
<pre id="pre-61"><code><span class="SANS_TheSansMonoCd_W7Bold_11">./build -c example</span></code></pre>&#13;
<p class="TX">This executes the following command as appropriate:</p>&#13;
<pre id="pre-62"><code>g++ -c -D isMacOS=1 -o example.o example.S</code></pre>&#13;
<p class="Continued1">or</p>&#13;
<pre id="pre-63"><code>g++ -c -D isLinux=1 -o example.o example.S</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-pie</span> option applies only to Linux. It issues the appropriate commands to tell Linux to produce a position-independent executable file (by default, Linux produces a non-position-independent executable). Because macOS’s assembler always produces PIE code, this option is ignored under macOS.</p>&#13;
<p class="TX">For the curious, I’ve provided the text for this shell script in the file <i>build</i> without further comment, as writing shell scripts is beyond the scope of this book:</p>&#13;
<pre id="pre-64"><code>#!/bin/bash&#13;
#&#13;
# build&#13;
#&#13;
# Automatically builds an Art of ARM Assembly&#13;
# example program from the command line&#13;
#&#13;
# Usage:&#13;
#&#13;
#    build {options} fileName&#13;
#&#13;
# (no suffix on the filename.)&#13;
#&#13;
# options:&#13;
#&#13;
#    -c: Assemble .S file to object code only.&#13;
#    -pie: On Linux, generate a PIE executable.&#13;
&#13;
fileName=""&#13;
compileOnly=" "&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_39" aria-label="39"/>pie="-no-pie"&#13;
cFile="c.cpp"&#13;
lib=" "&#13;
while [[$# -gt 0]]&#13;
do&#13;
&#13;
    key="$1"&#13;
    case $key in&#13;
&#13;
        -c)&#13;
        compileOnly='-c'&#13;
        shift&#13;
        ;;&#13;
&#13;
        -pie)&#13;
        pie='-pie'&#13;
        shift&#13;
        ;;&#13;
&#13;
        -math)&#13;
        math='-lm'&#13;
        shift&#13;
        ;;&#13;
&#13;
        *)&#13;
        fileName="$1"&#13;
        shift&#13;
        ;;&#13;
    esac&#13;
done&#13;
&#13;
# If -c option was provided, only assemble the .S&#13;
# file and produce an .o output file.&#13;
#&#13;
# If -c not specified, compile both c.cpp and the .S&#13;
# file and produce an executable:&#13;
&#13;
if ["$compileOnly" = '-c']; then&#13;
    objectFile="-o $fileName".o&#13;
    cFile=" "&#13;
else&#13;
    objectFile="-o $fileName"&#13;
fi&#13;
&#13;
# If the executable already exists, delete it:&#13;
&#13;
if test -e "$fileName"; then&#13;
    rm "$fileName"&#13;
fi&#13;
&#13;
# If the object file already exists, delete it:&#13;
&#13;
if test -e "$fileName".o; then&#13;
    rm "$fileName".o&#13;
fi&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_40" aria-label="40"/># Determine what OS you're running under (Linux or Darwin [macOS]) and&#13;
# issue the appropriate GCC command to compile/assemble the files.&#13;
&#13;
unamestr=$(uname)&#13;
if ["$unamestr" = 'Linux']; then&#13;
    g++<span class="SANS_TheSansMonoCd_W7Bold_11"> </span>-D isLinux=1 $pie $compileOnly $objectFile  $cFile $fileName.S $math&#13;
elif ["$unamestr" = 'Darwin']; then&#13;
    g++<span class="SANS_TheSansMonoCd_W7Bold_11"> </span>-D isMacOS=1  $compileOnly $objectFile $cFile  $fileName.S -lSystem $math&#13;
fi</code></pre>&#13;
<p class="TX">Check out a book on GNU’s bash shell interpreter if you want to learn how this works (see section 1.12, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_43">page 43</a></span>).</p>&#13;
<p class="TX">The <i>build</i> shell script is available in electronic form at <i><a href="https://artofarm.randallhyde.com">https://<wbr/>artofarm<wbr/>.randallhyde<wbr/>.com</a></i>. Execute the following command to make this file executable from the bash command line on your Linux or macOS system:</p>&#13;
<pre id="pre-65"><code><span class="SANS_TheSansMonoCd_W7Bold_11">chmod u+x build</span></code></pre>&#13;
<p class="TX">This makes the <i>build</i> script executable. See <span class="Xref"><a href="appendix-D.xhtml">Appendix D</a></span> for more information about the <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span> command.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h2-17"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">1.10.2 Writing a “Hello, World!” Program</span></h4>&#13;
<p class="TNI1">You finally have the pieces in place to write a complete “Hello, world!” program, as shown in Listing 1-5.</p>&#13;
<pre id="pre-66"><code>// Listing1-5.S&#13;
//&#13;
// The venerable "Hello, world!" program, written&#13;
// in ARM assembly by calling the C stdlib printf&#13;
// function&#13;
//&#13;
// aoaa.inc is the Art of ARM Assembly include file.&#13;
//&#13;
// This makes asmMain global and&#13;
// automatically converts it to _asmMain&#13;
// if this program is being assembled under macOS.&#13;
// It also converts printf to _printf for macOS.&#13;
&#13;
            #include "aoaa.inc"&#13;
&#13;
            .data&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> title:      .asciz  "Listing 1-5"&#13;
saveLR:     .dword  0       // Save LR here.&#13;
hwStr:      .asciz  "Hello, world!\n"&#13;
&#13;
            .text&#13;
&#13;
// getTitle function, required by c.cpp, returns the&#13;
// name of this program. The title string must&#13;
// appear in the .text section:&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_41" aria-label="41"/>            .align  2       // Code must be 4-byte aligned.&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> getTitle:&#13;
            lea     x0, title&#13;
            ret&#13;
&#13;
&#13;
// Here's the main function called by the c.cpp function:&#13;
&#13;
asmMain:&#13;
&#13;
// LR is *highly* volatile and will be wiped&#13;
// out when this code calls the printf() function.&#13;
// We need to save LR in memory somewhere so we&#13;
// can return back to the OS using its value.&#13;
// For now, save it in the saveLR global&#13;
// variable:&#13;
&#13;
            lea     x0, saveLR&#13;
            str     lr, [x0]&#13;
&#13;
// Set up printf parameter (format string)&#13;
// and call printf():&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> lea     x0, hwStr   // hwStr must be in .text.&#13;
            bl      printf      // Print the string.&#13;
&#13;
// Back from printf(), restore LR with its original&#13;
// value so we can return to the OS:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> lea     x0, saveLR&#13;
            ldr     lr, [x0]&#13;
&#13;
// Return to the OS:&#13;
&#13;
            ret</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">title</span> string <span class="CodeAnnotation" aria-label="annotation1">❶</span> holds the program’s title (<span class="SANS_TheSansMonoCd_W5Regular_11">"Listing 1-5"</span> in this example). The <span class="SANS_TheSansMonoCd_W5Regular_11">hwStr</span> variable holds the <span class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</span> string that the main program will pass to the <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function. The <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle()</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> returns the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">title</span> string to the <i>c.cpp</i> program. As per the ARM ABI, this function returns the function result in the X0 register.</p>&#13;
<p class="TX">Upon entry into the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain()</span> function (the assembly language main program), the code must preserve the contents of the LR register because the call to <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> will overwrite its value. This code saves the LR register (which holds the return address to the <i>c.cpp</i> main function) in the <span class="SANS_TheSansMonoCd_W5Regular_11">saveLR</span> global variable in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Saving the LR register value in this fashion is not good practice. In <a href="chapter3.xhtml">Chapter 3</a> you’ll learn about the ARM stack and discover a much better place to save return addresses held in LR.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_42" aria-label="42"/>The code that actually prints <span class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> loads X0 with the <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> format string as per the ARM ABI, then calls <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction. Before returning to <i>c.cpp</i>, the assembly code must reload LR with the returned address held in <span class="SANS_TheSansMonoCd_W5Regular_11">saveLR</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Here are the commands to build and run the program in Listing 1-5, along with the program’s output:</p>&#13;
<pre id="pre-67"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing1-5</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing1-5</span>&#13;
Calling Listing1-5:&#13;
Hello, world!&#13;
Listing1-5 terminated</code></pre>&#13;
<p class="TX">You now have a functioning “Hello, world!” program in assembly language.</p>&#13;
<aside class="box" aria-label="box-4">&#13;
<p class="BH" id="box-4"><span class="SANS_Dogma_OT_Bold_B_11">LINUX VS. MACOS: VARIADIC PARAMETERS</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">Passing parameters to functions with a variable number of parameters, such as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span><span class="SANS_Futura_Std_Book_11">, works differently in the standard ARM ABI and the macOS variant. Linux, using the standard ABI, passes the first eight parameters in registers X0 through X7, as <a href="chapter1.xhtml#tab1-2">Table 1-2</a> describes. However, macOS unfortunately passes only the first parameter of a</span> <span class="SANS_Futura_Std_Book_Oblique_11">variadic function</span> <span class="SANS_Futura_Std_Book_11">(a function with a variable number of parameters) in register X0. It passes all remaining parameters on the</span> <span class="SANS_Futura_Std_Book_Oblique_11">stack</span> <span class="SANS_Futura_Std_Book_11">(described in <a href="chapter3.xhtml">Chapters 3</a> and <a href="chapter5.xhtml">5</a>).</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">To allow us to write code that will assemble and run on both OSes, the</span> <span class="SANS_Futura_Std_Book_Oblique_11">aoaa.inc</span> <span class="SANS_Futura_Std_Book_11">include file comes to the rescue once again. This file contains six macros with the following names:</span></p>&#13;
<pre id="pre-68"><code>vparm2, vparm3, ..., vparm7</code></pre>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">Each macro takes a single argument: the name of a variable in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> <span class="SANS_Futura_Std_Book_11">section. These macros will load the specified variable into the appropriate location (a register or on the stack) for that parameter. For this to work under macOS, the following statement must appear at the very beginning of your</span> <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain()</span> <span class="SANS_Futura_Std_Book_11">function:</span></p>&#13;
<pre id="pre-69"><code>sub sp, sp, #64</code></pre>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">You must also include the following statement before the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> <span class="SANS_Futura_Std_Book_11">instruction at the end of your</span> <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain()</span> <span class="SANS_Futura_Std_Book_11">function:</span></p>&#13;
<pre id="pre-70"><code>add sp, sp, #64</code></pre>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11"><a href="chapter5.xhtml">Chapter 5</a> fully explains the purpose of these instructions; just trust them for now (they are required for macOS and do no harm under Linux).</span></p>&#13;
<p class="BTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_43" aria-label="43"/><span class="SANS_Futura_Std_Book_11">If you have two variables,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">j</span><span class="SANS_Futura_Std_Book_11">, declared as words in your</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> <span class="SANS_Futura_Std_Book_11">section, here’s how to print them by using</span> <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span></p>&#13;
<pre id="pre-71"><code>lea x0, fmtStr // Parameter 1 is still passed in X0.&#13;
vparm2 i&#13;
vparm3 j&#13;
bl printf</code></pre>&#13;
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">where</span> <span class="SANS_TheSansMonoCd_W5Regular_11">fmtStr</span> <span class="SANS_Futura_Std_Book_11">is something like this:</span></p>&#13;
<pre id="pre-72"><code>fmtStr: .asciz "i=%d, j=%d\n"</code></pre>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">We use</span> <span class="SANS_TheSansMonoCd_W5Regular_11">vparm2</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">vparm3</span><span class="SANS_Futura_Std_Book_11">, and so on only for variadic functions. Functions with a fixed number of parameters use registers X0 through X7 for the first eight parameters on both Linux and macOS.</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h3 class="H1" id="sec28"><span id="h1-18"/><span class="SANS_Futura_Std_Bold_B_11">1.11 Moving On</span></h3>&#13;
<p class="TNI1">This chapter equipped you with the prerequisites to start learning new assembly language features in the chapters that follow. You learned the basic syntax of a Gas program and the basic 64-bit ARM architecture, and how to use the <i>aoaa.inc</i> header file to make source files portable between macOS and Linux. You also learned how to declare some simple global variables, use a few machine instructions, and assemble a Gas program with C/C++ code so you can call routines in the C stdlib (using the <i>build</i> script file). Finally, you ran that program from the command line.</p>&#13;
<p class="TX">The next chapter introduces you to <i>data representation</i>, one of the main reasons for learning assembly language in the first place.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h3 class="H1" id="sec29"><span id="h1-19"/><span class="SANS_Futura_Std_Bold_B_11">1.12 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">For more information about the bash shell interpreter, visit the reference manual at <i><a href="https://www.gnu.org/software/bash/manual/bash.html">https://<wbr/>www<wbr/>.gnu<wbr/>.org<wbr/>/software<wbr/>/bash<wbr/>/manual<wbr/>/bash<wbr/>.html</a></i>.</li>&#13;
<li class="BL">For more information about the GNU assembler, visit the reference manual at <i><a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html">https://<wbr/>ftp<wbr/>.gnu<wbr/>.org<wbr/>/old<wbr/>-gnu<wbr/>/Manuals<wbr/>/gas<wbr/>-2<wbr/>.9<wbr/>.1<wbr/>/html<wbr/>_chapter<wbr/>/as<wbr/>_toc<wbr/>.html</a></i>.</li>&#13;
<li class="BL">You can find an online guide to 64-bit ARM assembly language at <i><a href="https://modexp.wordpress.com/2018/10/30/arm64-assembly/">https://<wbr/>modexp<wbr/>.wordpress<wbr/>.com<wbr/>/2018<wbr/>/10<wbr/>/30<wbr/>/arm64<wbr/>-assembly<wbr/>/</a></i>.</li>&#13;
<li class="BL">If you’re interested in programming ARM assembly language on Apple platforms, see <i><a href="https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms">https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/xcode<wbr/>/writing<wbr/>-arm64<wbr/>-code<wbr/>-for<wbr/>-apple<wbr/>-platforms</a></i>.</li>&#13;
<li class="BL">The ARM developer portal at <i><a href="https://developer.arm.com">https://<wbr/>developer<wbr/>.arm<wbr/>.com</a></i> provides generic information about ARM CPUs and ARM assembly language programming.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-5">&#13;
<p class="BH" id="box-5"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_44" aria-label="44"/><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What is the name of the Gas executable program file?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  What are the names of the three main system buses?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  Which register holds the condition code bits?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  How many bytes are consumed by the following data types?</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  Word</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  Dword</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  Oword</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">d.  Double</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  What is the destination (register) operand size for the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> <span class="SANS_Futura_Std_Book_11">macro?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  What is the name of the assembly language instruction you use to call a procedure or function?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  What is the name of the assembly language instruction you use to return from a procedure or function?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  What does</span> <span class="SANS_Futura_Std_Book_Oblique_11">ABI</span> <span class="SANS_Futura_Std_Book_11">stand for?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  9.  In the ARM ABI, where do you return the following function return results?</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  8-bit byte values</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  16-bit word values</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  32-bit integer values</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">d.  64-bit integer values</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">e.  64-bit pointer values</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">10.  Where do you pass the first, second, third, and fourth parameters to an ARM ABI-compatible function?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>