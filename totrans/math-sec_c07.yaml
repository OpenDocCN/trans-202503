- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Geometry to Improve Security Practices
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: When you think about modern security, geometry might not immediately come to
    mind. However, using computer algorithms to solve classic geometric problems such
    as line length, shape area, and object intersections allows you to analyze spatial
    relationships, which in turn can inform your security practices. This field is
    known as *computational geometry.*
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next few chapters, we’ll apply geometry to problems that relate data
    to the physical world using geometric rules. In [Chapter 8](c08.xhtml), we’ll
    use the properties of shapes to locate an imaginary perpetrator using cell phone
    data and MapBox Maps through a process you’ve probably heard of: location triangulation.
    Then, in [Chapter 9](c09.xhtml), we’ll put on our resource planning hats and look
    at the distribution of emergency services (like fire stations) using one of my
    favorite geometric algorithms, Voronoi tessellation. Finally, in [Chapter 10](c10.xhtml),
    we’ll explore using geometry for facial recognition.'
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to cover computational geometry more generally. We’ll begin
    this chapter by going over the essential theory with Python examples. We’ll use
    a Python library called Shapely, which abstracts away a lot of common tasks such
    as defining shapes and checking if two shapes touch or overlap at any points.
  prefs: []
  type: TYPE_NORMAL
- en: Describing Shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Geometry is one of those areas of mathematics that is relatively intuitive
    for human brains. If I showed you a shape and asked you to label it as a square,
    triangle, or circle, you wouldn’t even have to consciously think about the definition
    of the shape; you’d simply “know” the matching name. Encoding geometric intuition
    into computers has proven less straightforward. Before we can discuss how to analyze
    shapes, then, we need a way to describe the shapes in a data format our programs
    can digest. Then we need to define a series of mathematical checks for each type
    of shape we want to be able to identify. Luckily, most of the heavy lifting has
    already been done for us in Python’s Shapely library. In this section, we’ll use
    Shapely to define some of the key shapes we’ll need to understand for the upcoming
    projects to make sense. We’ll start with the very basic building blocks of shapes:
    points and lines. From there we can build increasingly complex shape representations,
    combine shapes to form 2D models, and look at some of the interesting analysis
    functions Shapely provides.'
  prefs: []
  type: TYPE_NORMAL
- en: Points and Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start with an empty universe represented as a 2D Cartesian plane. Only two
    types of object exist in this world: a point and a line segment. A *point* denotes
    an exact place on the plane using the common (*x*, *y*) coordinate system. A *line
    segment* is a part of an infinitely long line; it is bounded by, and contains
    every point on the line between, two distinct end points. In theory there are
    an infinite number of points between the two end points; in practice, the number
    of distinct points is limited by the floating-point precision of the platform
    or programming language. Python supports 17 decimal places of precision, which
    will be more than enough for our tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: In Shapely, you define a point by telling the library what the point’s associated
    *x* and *y* values should be, as in [Listing 7-1](#listing7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: Defining a point in Shapely'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code creates two `Point` objects on our Cartesian plane: `point_a` at
    (2.0, 4.0) and `point_b` at (0.0, 0.0).'
  prefs: []
  type: TYPE_NORMAL
- en: To create a line segment, we can call the `LineString` class in Shapely and
    pass in the starting point (*x*, *y*) and the end point (*x*, *y*). We can pass
    in either tuples or `Point` objects. [Listing 7-2](#listing7-2) shows how to create
    a `LineString` object from scratch or from the two previously created points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: Creating a `LineString` from `Point` objects'
  prefs: []
  type: TYPE_NORMAL
- en: The two line segments defined in [Listing 7-2](#listing7-2) are identical from
    the library’s perspective, so you’re free to use whichever syntax suits your code
    best. If you plan to reuse the same points throughout your application, creating
    the `Point` objects first makes the code cleaner and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Points and line segments are the most basic building blocks of shapes. Let’s
    look at how we can combine them to define more complex shapes known as polygons.
  prefs: []
  type: TYPE_NORMAL
- en: Polygons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By combining points and line segments in various configurations, we can build
    polygons like squares, stars, and even a very close approximation of circles.
    In geometry, a polygon *P* is a plane figure that is described by a finite number
    of points connected by line segments that form a closed chain. A *closed chain*
    means that the first and last point in the sequence are always the same, so the
    series of line segments always ends by connecting back to the origin. Line segments
    used in constructing *P* may be referred to as *edges*, *sides*, and *faces* interchangeably.
    The points along the boundary of *P* are often referred to as the *vertices* (singular
    *vertex*) of the shape. [Listing 7-3](#listing7-3) shows how to create a polygon
    with the Shapely library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: Creating a `Polygon` from `Point` objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the `Polygon` class, which allows us to define polygons similar
    to how we defined `LineString` objects in [Listing 7-2](#listing7-2). The major
    difference with the `Polygon` class is that Shapely creates an additional point
    to close the shape boundary if it isn’t explicitly defined (as with `poly_a`).
    The second object, `poly_b`, shows how you can mix `Point` objects and hardcoded
    values when defining a polygon’s perimeter. It also demonstrates how to explicitly
    close a polygon by including a final point that matches the initial point in the
    perimeter. Remember: whenever possible, explicit is better than implicit.'
  prefs: []
  type: TYPE_NORMAL
- en: A *regular* polygon is one where all angles and sides are equal. Any polygon
    that doesn’t satisfy this criteria (which is the majority of them) is considered
    *irregular*. A *simple* polygon has only one boundary, which doesn’t intersect
    itself at any point. A *complex* polygon has one or more edges that intersect,
    making the shape twist across itself. Many rules about simple polygons don’t work
    for complex polygons, so we’ll avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Polygons can be very complex shapes with hundreds of edges and vertices, but
    all possible polygons can be classified into one of two categories. A *convex*
    polygon is one where all its interior angles are less than 180 degrees. All the
    vertices of the polygon will point outward, away from the interior of the shape.
    A *concave* polygon is any polygon that does not satisfy the convex definition.
    A simple rule of thumb is that if you can travel counterclockwise around the entire
    perimeter of the shape using only left turns, then the shape is convex. If you
    ever have to veer right to get to the next vertex, then the shape is concave.
    [Figure 7-1](#figure7-1) illustrates the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/f07001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: Concave vs. convex shapes'
  prefs: []
  type: TYPE_NORMAL
- en: The shape on the left has two points where the perimeter moves toward the interior
    (1, 1) and (0.8, 1). If you were walking around the perimeter of this shape counterclockwise,
    you’d have to turn right when you reached either of these points. The shape on
    the right has no vertices that point inward. You could indeed walk counterclockwise
    around the whole shape using only left turns, so it is convex.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to how you can combine points and line segments to make basic shapes,
    you can combine a simple polygon and a special object called a *linear ring* polygon
    (*ring* or *hole* for short) to create voids in the interior. [Figure 7-2](#figure7-2)
    shows the result of combining a simple polygon with a ring.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/f07002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: Comparing polygon types'
  prefs: []
  type: TYPE_NORMAL
- en: A ring polygon *rph* (the leftmost image of [Figure 7-2](#figure7-2)) is a hollow
    shape with no solid region. It’s composed entirely of the points and line segments
    that fall along its defining border, the thick black outline in the image.
  prefs: []
  type: TYPE_NORMAL
- en: A simple polygon *P* (the middle image) is a solid plane region that contains
    all the points within its boundaries as well as all the points along the defining
    perimeter, shown by the black shape in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: The polygon with a hole (the right image) combines the ring polygon on the left
    with the simple polygon in the middle. To combine the two, we subtract the points
    in the ring from the set of points in *P* (*P*2 = *P*1 ∉ *rph*). The points that
    fall within the ring shape are excluded from the geometry of the overall polygon.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-4](#listing7-4) shows how we can construct the three different classes
    of polygon in the figure.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: Creating a polygon with a hole in Shapely'
  prefs: []
  type: TYPE_NORMAL
- en: We define the main polygon, `poly_a`, the same as in [Listing 7-3](#listing7-3),
    using its bounding vertices. To define the ring polygon, `poly_hole`, we create
    a `LinearRing` object by passing in the vertices defining its perimeter. We create
    the final polygon by combining the two shapes into a new `Polygon` object. The
    `poly_hole` object is passed inside a list to support multiple holes in the same
    polygon. Holes may not cross each other or the exterior of the polygon; they can
    touch only at a single point. Shapely doesn’t prevent you from creating invalid
    features, but it will raise exceptions when you try to operate on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'By combining individual points, line segments, polygons, and holes, we can
    begin to model the physical space around us with enough accuracy to be useful.
    We can use complex polygons to define the bounds of a space and use holes inside
    the complex polygons to denote areas people can’t travel due to obstructions.
    We’ll dive into this more in the “[Scenario: Planning Security for a Concert](#h1-502567c07-0002)”
    section, but first let’s cover some best practices to help your code run smoothly.'
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create a shape, the order of the vertices matters. The standard practice
    is to pass the vertices in counterclockwise order (`ccw` in Shapely) around the
    perimeter. Having points in a known order makes several operations—like checking
    if a point falls inside a shape or if a polygon is convex—considerably faster
    to compute. Shapely has a couple of functions to help with this. In [Listing 7-5](#listing7-5)
    we check if an object is in counterclockwise orientation and, if not, translate
    its point order so that it is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: Checking and fixing the order of vertices'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a `LinearRing` object. You can prove to yourself on a piece
    of graph paper that the order of the vertices, from left to right, forms a clockwise
    description of a triangle. We can use Shapely to check if the vertices are in
    counterclockwise order by printing the Boolean attribute `is_ccw`, which will
    be `False`. To translate the list into counterclockwise order, we use a Python
    list inversion (`[::-1]`), which adds the coordinates in reverse order to a new
    list, then assigns the newly reordered list to a new `LinearRing` object called
    `new_ring`. Printing `is_ccw` on `new_ring` will now return `True`, confirming
    the new ordering is indeed counterclockwise.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can describe shapes in a way the computer can work with, let’s
    look at some common operations you’ll repeatedly use when geometrically analyzing
    security problems. In the next section we’ll cover useful algorithms for finding
    areas, determining overlaps and intersections, and calculating perimeter lengths
    for irregular shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: Planning Security for a Concert'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to get acquainted with computational geometry theory is to apply
    it in a scenario, so imagine you’re asked to plan the security for a concert being
    held at a local park. You need to decide how many security personnel to assign
    to the event and where they’ll be positioned, and you need to provide the event
    coordinators with recommendations for safe attendance capacity. [Figure 7-3](#figure7-3)
    shows the park layout from an overhead view.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/f07003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: The park as a polygon with holes'
  prefs: []
  type: TYPE_NORMAL
- en: The outline of the polygon represents a tall fence around the park. The small
    square near the bottom of the park is an information booth that can’t be accessed
    by attendees, so we subtract it from the usable area. The rectangle near the top
    of the park is the stage, which also can’t be accessed by attendees, so we remove
    it as well. The remaining gray area is the part of the park that’s accessible
    to attendees. We’ll calculate this area and then use the result to figure out
    the number of attendees that can safely and comfortably attend the event.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Safe Occupancy Limits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find the area of irregular shapes like the park, first we must decompose
    the shape into a set of simple shapes, like triangles, and then sum the area of
    each composite shape. The act of decomposing a shape like this is known as *tessellation*,
    and involves overlaying a plane using one or more geometric shapes, called *tiles*,
    with no overlaps and no gaps. [Figure 7-4](#figure7-4) shows two approaches to
    triangular tessellation for the park space.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/f07004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: A triangular tessellation of a simple polygon and a polygon with
    holes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple approach on the left tessellates the base polygon and temporarily
    ignores the holes. You calculate the total area of this shape and then subtract
    the areas for the two restricted zones. I used this method by hand back in my
    early days. The approach on the right tessellates the complex shape with holes
    included using Shapely’s `triangulate` function (not to be confused with location
    triangulation, which we’ll cover in [Chapter 8](c08.xhtml)). We can find the area
    by summing the *n* areas of each gray triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/m07001.png)'
  prefs: []
  type: TYPE_IMG
- en: Here *P*[Δ[][*i*][]]*B* and *P*[Δ[][*i*][]]*H* are the base and height measurements,
    respectively, for the *i*th triangle in *P*[Δ].
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we don’t have to worry about manual tessellation just to find the area
    of the complex shape. The Shapely library automatically handles all of this under
    the hood when you create a shape. [Listing 7-6](#listing7-6) shows how to create
    the park shape and calculate the usable area for attendees.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: Creating the complex park shape and calculating the area'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating the outermost `Polygon` to represent the bounds of the
    event space. We then create a `LinearRing` object for both the stage and information
    booth. Next, we create the complex polygon representing the shape of the usable
    space in the venue. The library provides an `area` attribute for polygons that
    respects any holes we passed in during creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re dealing with really big shapes like the park, it’s common practice
    to apply a scaling factor—that is, to shrink the whole shape by some known constant
    to make the numbers easier to work with. In Figures 7-3 and 7-4, one unit is equal
    to 10 meters, or a scaling factor of 0.1, so multiplying the `event_shape.area`
    by 10 adjusts the result for the scaling applied to the map. The output of the
    `print` statement is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know the usable area, we can calculate the number of attendees that
    can safely fill it. [Listing 7-7](#listing7-7) shows how to convert the area result
    to attendee count by dividing the usable area by the amount of space we aim to
    provide each attendee.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: Calculating capacity based on usable area'
  prefs: []
  type: TYPE_NORMAL
- en: 'Years ago, I settled on 0.75 square meters—a little over 8 square feet—per
    person for events with a mixture of seated and standing attendees. (I later discovered
    others had reached roughly the same numbers for similar scenarios.) We multiply
    the `event_area` by 0.75 to find the number of people that can comfortably attend
    the event with room for some people to sit on a blanket and others to walk around.
    To find the maximum number of people that can safely stand in an area, we can
    cut the spacing roughly in half to 0.37 square meters, or about 4 square feet
    per person. Now, we can multiply the event area by 0.37 to find the “standing
    room only” capacity of the venue, `max_capacity`. This tight spacing would be
    like standing in a crowded hallway: you’re not quite bumping into other people
    yet, but almost. The output from the code should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To estimate the number of security personnel for the event, we’ll round the
    846 attendees up to 900\. From experience, I use a ratio of 60:1 attendees to
    security, which in this case means 900 / 60 = 15\. However, 900 includes everyone
    that will be in the event area, including security personnel, so in a real scenario
    you actually want to round in the other direction and recommend a max comfortable
    capacity of 830 attendees while estimating the security detail for the higher
    crowd number, 900\.
  prefs: []
  type: TYPE_NORMAL
- en: After applying this formula to some real venues, you’ll notice your comfortable
    numbers are usually lower than those recommended by safety codes issued from the
    fire department, which is intentional. The fire department numbers are concerned
    with the number of people that can safely evacuate in the event of an emergency
    and have nothing to do with crowd security or comfort. You’ll also find that event
    coordinators will settle somewhere between the number you suggest and the number
    the fire department will allow (hence rounding up in planning for personnel and
    rounding down when recommending attendance).
  prefs: []
  type: TYPE_NORMAL
- en: Determining Placement of Security Personnel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know how many security personnel we need, let’s address where to
    place them. We’ll use tessellation combined with another common operation known
    as *centroid location*, which finds the point that’s equidistant from all of the
    perimeter vertices of a polygon (that is, the *centroid*). The centroid of a convex
    object always lies inside the object’s area. A concave object might have a centroid
    that is outside the area, but since we’re tessellating the shape first, each resulting
    triangle will be convex and the centroid will be located within the perimeter.
  prefs: []
  type: TYPE_NORMAL
- en: The centroid of *P* = [(*x*0, *y*0), (*x*1, *y*1), . . . , (*xn –* 1, *yn* –
    1)] is the point C(*x*, *y*), where
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/m07002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The term *A* is the signed area of *P*, which is calculated using the *shoelace
    algorithm*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/m07003.png)'
  prefs: []
  type: TYPE_IMG
- en: The points in *P* need to be in sequential order along the perimeter for this
    to work. If the order of the vertices is counterclockwise, the area will be a
    negative value; otherwise, it will be positive. In either case the absolute value
    of *C*[(][*x,y*][)] will be correct. We can use this information to place each
    of the 15 security personnel in the centroid location of the triangle with the
    largest area that hasn’t been assigned a guard yet. [Listing 7-8](#listing7-8)
    shows how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: A centroid-based personnel dispersion algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: We start by triangulating the `event_shape` object from [Listing 7-6](#listing7-6)
    using the `triangulate` function. The result is a set of `Polygon` objects representing
    the triangles making up the shape (denoted as *P*[Δ]). We then use a dictionary
    comprehension to create a sortable list of triangle index and corresponding area.
    We use the `sorted` function to sort the `area_dict` by value. Using descending
    order with `reverse=True` allows us to use the coordinates for the centroid of
    the first 15 triangles to estimate a good dispersion of security personnel. [Figure
    7-5](#figure7-5) shows the resulting placement plan.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/f07005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: The centroid placement for security personnel'
  prefs: []
  type: TYPE_NORMAL
- en: The triangulation is identical to the one shown in [Figure 7-4](#figure7-4).
    The gray plus symbols are the centroids for each of the selected triangles. As
    you can see, the result of this fairly basic algorithm is pretty good. Regardless
    of where you’re standing in the venue, you’re never far from one or more security
    stations. Using a dispersion method like this ensures that security can respond
    quickly regardless of where they’re needed. The one problem is the fact that it
    placed a guard in one of the unusable parts of the venue, right on stage! We’ll
    see how to improve this algorithm and fix the placement of that guard in the “[Improving
    Guard Placement](#h2-502567c07-0007)” section, but for the moment, let’s look
    at another useful piece of analysis that will help us plan and schedule walking
    patrols.
  prefs: []
  type: TYPE_NORMAL
- en: Estimating Guard Patrol Timing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perimeter length is a great way to estimate timing for patrols. For simplicity,
    let’s assume the guards patrolling the perimeter of the event don’t count against
    the 15 guards we already placed. We could assign the misplaced guard position
    to patrol, but that would change the ratio of security to attendees in the venue
    (albeit only slightly). For now, let’s pretend we have another two guards positioned
    along the perimeter so they don’t count toward attendance. One is located at a
    stationary point (say, at a primary access point like a gate) and another is walking
    around the perimeter. For safety, the patrol guard should have scheduled check-in
    times with the stationary guard. The question is how long a normal patrol should
    take. This is where perimeter length comes in handy. For a polygon, the length
    of its perimeter is the sum of the lengths of the individual line segments it
    comprises. To figure out how long the walk should take around the park, we can
    divide the outer perimeter’s length by the guard’s estimated walking speed. [Listing
    7-9](#listing7-9) shows how to compute this time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: Computing guard patrol times'
  prefs: []
  type: TYPE_NORMAL
- en: 'The exterior `length` attribute of a complex shape like the `event_shape` object
    is a `LinearRing` object representing the outermost points of the figure. To get
    the actual distance around the fence, we multiply the `LinearRing`’s length property
    by the scaling factor. Next we need an estimate for the guard’s speed. According
    to Wikipedia, the average human walking speed at crosswalks is about 1.4 meters
    per second (m/s), or about 3.1 miles per hour (mph). We can assume our security
    will be walking a bit slower than this (they’re observing the area as they patrol,
    after all). We set the rate variable to 1.1 m/s or about 2.5 mph. To get the per-minute
    rate, we multiply the m/s rate by 60\. Then, we calculate the `walk_time` with
    time = distance / rate. The result from [Listing 7-9](#listing7-9) should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can use this information to justify a policy that the patrol guard should
    check in at a given place along the perimeter every 5.49 minutes. In practice,
    you’d want to contact the patrol person if you didn’t receive a check-in within
    6 minutes or so.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Guard Placement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s improve our guard placement from [Listing 7-8](#listing7-8) by adding
    the concept of *co-location*, when two objects occupy the same space on the Cartesian
    plane. With co-location, we’ll be able to determine when a guard has been placed
    in an unusable part of the venue. Shapely provides functions—such as `contains`,
    `intersects`, `overlaps`, `touches`, and `distance`—to check relationships between
    geometric objects. Each function takes in a second object as a parameter and answers
    the question its name suggests. For example, `contains` checks if object B resides
    completely within the interior of object A. The result will be `True` if no points
    of B are on the exterior of A and at least one point of the interior of B lies
    within the interior of A. There’s an inverse relationship function, `within`,
    such that `A.contains(B) = B.within(A)`. The Shapely documentation contains very
    good explanations of each function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-10](#listing7-10) extends the code from [Listing 7-8](#listing7-8)
    so that it doesn’t place the guard station on the stage.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: Reassigning guard stations from unusable areas'
  prefs: []
  type: TYPE_NORMAL
- en: Because `LinearRing` objects are hollow, they don’t actually contain the points
    within their bounds, so first we need to change the `stage` and `info_booth` objects
    to `Polygon` objects ❶. A polygon is assumed to be filled, so any point within
    its bounds will return `True` when we call the `contains` function ❷. By looping
    over each set of coordinates in the `sec_list`, we can cast them to `Points` and
    check if the stage or information booth polygons contain that point. If so, we
    can reassign it to one of the other unoccupied triangles by starting at the 16th
    triangle (index 15) and assigning the guard station to the new position ❸. We
    repeat the process of assigning the guard to a new position and checking if that
    position is contained by one of the unusable areas until we find a usable triangle.
    [Figure 7-6](#figure7-6) shows the result of running the improved code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/f07006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-6: The improved security placement results'
  prefs: []
  type: TYPE_NORMAL
- en: When you compare [Figure 7-6](#figure7-6) with [Figure 7-5](#figure7-5), you
    can see the guard station got moved from the stage area to the area below the
    information booth, which was previously empty. This change places all 15 guards
    in usable areas of the venue, making sure to assign guards to the largest unprotected
    sections first. By combining this information with the attendance recommendation
    and the scheduled patrol routes, we have a good start on an event security plan.
    We can take this basic recommendation and further refine it with our knowledge
    of the venue, the event taking place, and so on, to produce a fully formed security
    strategy that should include contingency plans for more security personnel and
    attendee overflow areas.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The power of computational geometry for security lies in the ability to encode
    physical features in a way machines can interpret: as points, line segments, and
    polygons. Once you encode the features, you can calculate the area, centroid location,
    perimeter length, and object relationships to analyze security problems. You’ve
    already seen how you can use geometry to describe a physical space like a park
    and place security personnel effectively. You’ve also seen how shapes can be combined
    to make more complex representations using hole objects. Finally, we covered some
    other common functions that you’ll encounter often in practice. There are many
    more functions available in the Shapely library, but the ones presented in this
    chapter represent a majority of the work you’ll need to perform when analyzing
    problems geometrically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ll see over the next three chapters, we can combine these operations
    to create other very interesting security tools. There’s still plenty of research
    to dive into on your own. Geometry has a long history in the security industry,
    and many research questions can be restated such that you can apply geometric
    algorithms to them. Of course, none of this even touches on geometry in cryptography,
    which is its own beast and needs a book of its own. If you’re interested in this
    field, though, check out the paper “Geometric Cryptography: Identification by
    Angle Trisection.”^([1](b01.xhtml#c07-endnote-001)) If you’re interested in how
    you can apply geometric algorithms to privacy issues, you’ll want to research
    the field of privacy-preserving computational geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue our exploration of computational geometry with the topic of geographic
    location data. In the next chapter, we’ll combine MapBox and OpenCellID data to
    triangulate the location of a cell phone.
  prefs: []
  type: TYPE_NORMAL
