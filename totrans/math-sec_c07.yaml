- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Using Geometry to Improve Security Practices
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用几何改善安全实践
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: When you think about modern security, geometry might not immediately come to
    mind. However, using computer algorithms to solve classic geometric problems such
    as line length, shape area, and object intersections allows you to analyze spatial
    relationships, which in turn can inform your security practices. This field is
    known as *computational geometry.*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到现代安全性时，几何学可能不会立刻浮现在脑海里。然而，利用计算机算法解决经典的几何问题，如线段长度、形状面积和物体交集，可以帮助你分析空间关系，而这些分析反过来可以指导你的安全实践。这个领域被称为*计算几何*。
- en: 'In the next few chapters, we’ll apply geometry to problems that relate data
    to the physical world using geometric rules. In [Chapter 8](c08.xhtml), we’ll
    use the properties of shapes to locate an imaginary perpetrator using cell phone
    data and MapBox Maps through a process you’ve probably heard of: location triangulation.
    Then, in [Chapter 9](c09.xhtml), we’ll put on our resource planning hats and look
    at the distribution of emergency services (like fire stations) using one of my
    favorite geometric algorithms, Voronoi tessellation. Finally, in [Chapter 10](c10.xhtml),
    we’ll explore using geometry for facial recognition.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将把几何应用于将数据与物理世界联系起来的问题，并利用几何规则。在[第8章](c08.xhtml)中，我们将利用形状的特性，通过你可能听说过的过程——位置三角测量，使用手机数据和MapBox地图定位一个假想的犯罪嫌疑人。然后，在[第9章](c09.xhtml)中，我们将戴上资源规划的帽子，使用我最喜欢的几何算法之一——Voronoi镶嵌，来看紧急服务（如消防站）的分布。最后，在[第10章](c10.xhtml)中，我们将探索使用几何进行人脸识别。
- en: But first, we need to cover computational geometry more generally. We’ll begin
    this chapter by going over the essential theory with Python examples. We’ll use
    a Python library called Shapely, which abstracts away a lot of common tasks such
    as defining shapes and checking if two shapes touch or overlap at any points.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要更一般地讲解计算几何。我们将从本章开始，通过Python示例讲解基本理论。我们将使用一个叫做Shapely的Python库，它可以抽象化很多常见的任务，例如定义形状和检查两个形状是否在任何点上接触或重叠。
- en: Describing Shapes
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述形状
- en: 'Geometry is one of those areas of mathematics that is relatively intuitive
    for human brains. If I showed you a shape and asked you to label it as a square,
    triangle, or circle, you wouldn’t even have to consciously think about the definition
    of the shape; you’d simply “know” the matching name. Encoding geometric intuition
    into computers has proven less straightforward. Before we can discuss how to analyze
    shapes, then, we need a way to describe the shapes in a data format our programs
    can digest. Then we need to define a series of mathematical checks for each type
    of shape we want to be able to identify. Luckily, most of the heavy lifting has
    already been done for us in Python’s Shapely library. In this section, we’ll use
    Shapely to define some of the key shapes we’ll need to understand for the upcoming
    projects to make sense. We’ll start with the very basic building blocks of shapes:
    points and lines. From there we can build increasingly complex shape representations,
    combine shapes to form 2D models, and look at some of the interesting analysis
    functions Shapely provides.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 几何是数学中相对直观的领域之一。如果我给你展示一个形状并让你标出它是正方形、三角形还是圆形，你甚至不需要刻意思考形状的定义；你会“知道”对应的名称。将几何直觉编码到计算机中却并非易事。因此，在我们讨论如何分析形状之前，我们需要一种方式，将形状描述为程序能够理解的数据格式。接下来，我们需要为每种我们希望能够识别的形状定义一系列数学检查。幸运的是，大部分繁重的工作已经通过Python的Shapely库为我们完成了。在本节中，我们将使用Shapely定义一些我们需要理解的关键形状，以便后续的项目能够理解。我们将从形状的基本构建块开始：点和线。从这里开始，我们可以构建越来越复杂的形状表示，组合形状形成2D模型，并查看Shapely提供的一些有趣分析功能。
- en: Points and Lines
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点与线
- en: 'We start with an empty universe represented as a 2D Cartesian plane. Only two
    types of object exist in this world: a point and a line segment. A *point* denotes
    an exact place on the plane using the common (*x*, *y*) coordinate system. A *line
    segment* is a part of an infinitely long line; it is bounded by, and contains
    every point on the line between, two distinct end points. In theory there are
    an infinite number of points between the two end points; in practice, the number
    of distinct points is limited by the floating-point precision of the platform
    or programming language. Python supports 17 decimal places of precision, which
    will be more than enough for our tasks.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个空的宇宙开始，表示为二维笛卡尔平面。这个世界中只有两种类型的对象：一个点和一个线段。*点*表示平面上的一个精确位置，使用常见的 (*x*, *y*)
    坐标系统。*线段*是无限长线的一部分；它由两个不同的端点界定，并包含线段之间的每个点。理论上，在两个端点之间有无限多个点；但在实际应用中， distinct
    points 的数量受到平台或编程语言浮动点精度的限制。Python 支持 17 位小数精度，这对于我们的任务来说已经足够了。
- en: In Shapely, you define a point by telling the library what the point’s associated
    *x* and *y* values should be, as in [Listing 7-1](#listing7-1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Shapely 中，你通过告诉库点的 *x* 和 *y* 值来定义一个点，参见 [Listing 7-1](#listing7-1)。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Defining a point in Shapely'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-1: 在 Shapely 中定义一个点'
- en: 'This code creates two `Point` objects on our Cartesian plane: `point_a` at
    (2.0, 4.0) and `point_b` at (0.0, 0.0).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在我们的笛卡尔平面上创建了两个 `Point` 对象：`point_a` 在 (2.0, 4.0) 处，`point_b` 在 (0.0, 0.0)
    处。
- en: To create a line segment, we can call the `LineString` class in Shapely and
    pass in the starting point (*x*, *y*) and the end point (*x*, *y*). We can pass
    in either tuples or `Point` objects. [Listing 7-2](#listing7-2) shows how to create
    a `LineString` object from scratch or from the two previously created points.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个线段，我们可以调用 Shapely 中的 `LineString` 类，并传入起始点 (*x*, *y*) 和终点 (*x*, *y*)。我们可以传入元组或
    `Point` 对象。[Listing 7-2](#listing7-2) 显示了如何从头开始或从之前创建的两个点创建一个 `LineString` 对象。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: Creating a `LineString` from `Point` objects'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-2: 从 `Point` 对象创建 `LineString`'
- en: The two line segments defined in [Listing 7-2](#listing7-2) are identical from
    the library’s perspective, so you’re free to use whichever syntax suits your code
    best. If you plan to reuse the same points throughout your application, creating
    the `Point` objects first makes the code cleaner and easier to understand.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 7-2](#listing7-2) 中定义的两个线段从库的角度来看是相同的，因此你可以自由选择适合你代码的语法。如果你打算在整个应用中重复使用相同的点，首先创建
    `Point` 对象会使代码更简洁、易懂。
- en: Points and line segments are the most basic building blocks of shapes. Let’s
    look at how we can combine them to define more complex shapes known as polygons.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 点和线段是形状的最基本构建块。让我们来看一下如何将它们组合起来定义更复杂的形状，称为多边形。
- en: Polygons
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多边形
- en: By combining points and line segments in various configurations, we can build
    polygons like squares, stars, and even a very close approximation of circles.
    In geometry, a polygon *P* is a plane figure that is described by a finite number
    of points connected by line segments that form a closed chain. A *closed chain*
    means that the first and last point in the sequence are always the same, so the
    series of line segments always ends by connecting back to the origin. Line segments
    used in constructing *P* may be referred to as *edges*, *sides*, and *faces* interchangeably.
    The points along the boundary of *P* are often referred to as the *vertices* (singular
    *vertex*) of the shape. [Listing 7-3](#listing7-3) shows how to create a polygon
    with the Shapely library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以各种配置组合点和线段，我们可以构建多边形，如正方形、星形，甚至是非常接近的圆形近似图形。在几何学中，多边形 *P* 是由有限数量的点构成的平面图形，这些点通过线段连接，形成一个闭合链条。*闭合链条*意味着序列中的第一个点和最后一个点始终相同，因此这组线段总是通过连接回原点来结束。构建
    *P* 时使用的线段可以互换地称为 *边*、*侧* 或 *面*。沿着 *P* 边界的点通常称为该形状的 *顶点*（单数 *顶点*）。[Listing 7-3](#listing7-3)
    显示了如何使用 Shapely 库创建一个多边形。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-3: Creating a `Polygon` from `Point` objects'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-3: 从 `Point` 对象创建 `Polygon`'
- en: 'First, we import the `Polygon` class, which allows us to define polygons similar
    to how we defined `LineString` objects in [Listing 7-2](#listing7-2). The major
    difference with the `Polygon` class is that Shapely creates an additional point
    to close the shape boundary if it isn’t explicitly defined (as with `poly_a`).
    The second object, `poly_b`, shows how you can mix `Point` objects and hardcoded
    values when defining a polygon’s perimeter. It also demonstrates how to explicitly
    close a polygon by including a final point that matches the initial point in the
    perimeter. Remember: whenever possible, explicit is better than implicit.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`Polygon`类，它允许我们像在[列表 7-2](#listing7-2)中定义`LineString`对象一样定义多边形。与`Polygon`类的主要区别在于，Shapely会在没有显式定义形状边界的情况下自动创建一个额外的点来闭合形状（如`poly_a`）。第二个对象`poly_b`展示了如何在定义多边形周长时混合`Point`对象和硬编码值。它还演示了如何通过包含一个最终与初始点相匹配的点来显式闭合多边形。记住：尽可能显式定义比隐式定义更好。
- en: A *regular* polygon is one where all angles and sides are equal. Any polygon
    that doesn’t satisfy this criteria (which is the majority of them) is considered
    *irregular*. A *simple* polygon has only one boundary, which doesn’t intersect
    itself at any point. A *complex* polygon has one or more edges that intersect,
    making the shape twist across itself. Many rules about simple polygons don’t work
    for complex polygons, so we’ll avoid them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*规则*多边形是所有角度和边长都相等的多边形。任何不满足此条件的多边形（大多数多边形）都被认为是*不规则*的。*简单*多边形只有一个边界，且在任何点都不会与自身相交。*复杂*多边形有一个或多个相交的边，使得形状扭曲自我。许多关于简单多边形的规则不适用于复杂多边形，因此我们将避免使用它们。'
- en: Polygons can be very complex shapes with hundreds of edges and vertices, but
    all possible polygons can be classified into one of two categories. A *convex*
    polygon is one where all its interior angles are less than 180 degrees. All the
    vertices of the polygon will point outward, away from the interior of the shape.
    A *concave* polygon is any polygon that does not satisfy the convex definition.
    A simple rule of thumb is that if you can travel counterclockwise around the entire
    perimeter of the shape using only left turns, then the shape is convex. If you
    ever have to veer right to get to the next vertex, then the shape is concave.
    [Figure 7-1](#figure7-1) illustrates the difference.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形可以是非常复杂的形状，具有数百条边和顶点，但所有可能的多边形都可以分为两类之一。*凸*多边形是指所有内部角度都小于180度的多边形。多边形的所有顶点都将指向外部，远离形状的内部。*凹*多边形是指任何不符合凸形定义的多边形。一个简单的经验法则是，如果你可以仅使用左转逆时针绕着整个形状的周长行走，那么形状是凸的。如果你必须右转才能到达下一个顶点，那么形状是凹的。[图
    7-1](#figure7-1)展示了它们的区别。
- en: '![](image_fi/502567c07/f07001.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c07/f07001.png)'
- en: 'Figure 7-1: Concave vs. convex shapes'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：凹形与凸形的区别
- en: The shape on the left has two points where the perimeter moves toward the interior
    (1, 1) and (0.8, 1). If you were walking around the perimeter of this shape counterclockwise,
    you’d have to turn right when you reached either of these points. The shape on
    the right has no vertices that point inward. You could indeed walk counterclockwise
    around the whole shape using only left turns, so it is convex.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的形状有两个点，周长向内部移动（1, 1）和（0.8, 1）。如果你逆时针沿着这个形状的周长行走，当你到达这两个点中的任何一个时，你都必须右转。右边的形状没有任何指向内部的顶点。你确实可以逆时针绕着整个形状行走，只需要左转，所以它是凸形的。
- en: Similar to how you can combine points and line segments to make basic shapes,
    you can combine a simple polygon and a special object called a *linear ring* polygon
    (*ring* or *hole* for short) to create voids in the interior. [Figure 7-2](#figure7-2)
    shows the result of combining a simple polygon with a ring.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于你可以通过组合点和线段来创建基本形状，你也可以通过组合简单多边形和一种叫做*线环*多边形（简称*环*或*孔*）来在内部创建空洞。[图 7-2](#figure7-2)展示了将简单多边形与环组合的结果。
- en: '![](image_fi/502567c07/f07002.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c07/f07002.png)'
- en: 'Figure 7-2: Comparing polygon types'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：比较多边形类型
- en: A ring polygon *rph* (the leftmost image of [Figure 7-2](#figure7-2)) is a hollow
    shape with no solid region. It’s composed entirely of the points and line segments
    that fall along its defining border, the thick black outline in the image.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个环形多边形*rph*（[图 7-2](#figure7-2)中的最左侧图像）是一个空心形状，没有实心区域。它完全由沿其定义边界的点和线段组成，即图像中的粗黑色轮廓线。
- en: A simple polygon *P* (the middle image) is a solid plane region that contains
    all the points within its boundaries as well as all the points along the defining
    perimeter, shown by the black shape in the middle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的多边形*P*（中图）是一个实心平面区域，包含其边界内的所有点以及沿着定义周长的所有点，如中间的黑色形状所示。
- en: The polygon with a hole (the right image) combines the ring polygon on the left
    with the simple polygon in the middle. To combine the two, we subtract the points
    in the ring from the set of points in *P* (*P*2 = *P*1 ∉ *rph*). The points that
    fall within the ring shape are excluded from the geometry of the overall polygon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 带孔的多边形（右图）将左侧的环形多边形与中间的简单多边形结合起来。为了将两者合并，我们从*P*的点集中减去环形中的点（*P*2 = *P*1 ∉ *rph*）。落在环形内的点会被排除在整体多边形的几何形状之外。
- en: '[Listing 7-4](#listing7-4) shows how we can construct the three different classes
    of polygon in the figure.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-4](#listing7-4)展示了我们如何在图中构建三种不同类别的多边形。'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-4: Creating a polygon with a hole in Shapely'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-4：在 Shapely 中创建带孔的多边形
- en: We define the main polygon, `poly_a`, the same as in [Listing 7-3](#listing7-3),
    using its bounding vertices. To define the ring polygon, `poly_hole`, we create
    a `LinearRing` object by passing in the vertices defining its perimeter. We create
    the final polygon by combining the two shapes into a new `Polygon` object. The
    `poly_hole` object is passed inside a list to support multiple holes in the same
    polygon. Holes may not cross each other or the exterior of the polygon; they can
    touch only at a single point. Shapely doesn’t prevent you from creating invalid
    features, but it will raise exceptions when you try to operate on them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了主要的多边形`poly_a`，与[列表 7-3](#listing7-3)中一样，使用其边界顶点来定义。为了定义环形多边形`poly_hole`，我们创建了一个`LinearRing`对象，通过传入定义其周长的顶点。我们通过将这两种形状合并成一个新的`Polygon`对象来创建最终的多边形。`poly_hole`对象被放入一个列表中，以支持在同一个多边形中使用多个孔。孔不能相互交叉，也不能与多边形的外部交叉；它们只能在一个点上相接。Shapely
    并不会阻止你创建无效的特征，但当你尝试对其进行操作时，它会抛出异常。
- en: 'By combining individual points, line segments, polygons, and holes, we can
    begin to model the physical space around us with enough accuracy to be useful.
    We can use complex polygons to define the bounds of a space and use holes inside
    the complex polygons to denote areas people can’t travel due to obstructions.
    We’ll dive into this more in the “[Scenario: Planning Security for a Concert](#h1-502567c07-0002)”
    section, but first let’s cover some best practices to help your code run smoothly.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合单个点、线段、多边形和孔，我们可以开始以足够的精度模拟周围的物理空间，以便它能发挥作用。我们可以使用复杂的多边形来定义空间的边界，并在复杂多边形内部使用孔来表示由于障碍物人们无法通行的区域。我们将在“[场景：规划音乐会的安全](#h1-502567c07-0002)”部分深入讨论这一点，但首先，让我们先了解一些最佳实践，帮助您的代码顺利运行。
- en: Vertex Order
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶点顺序
- en: When you create a shape, the order of the vertices matters. The standard practice
    is to pass the vertices in counterclockwise order (`ccw` in Shapely) around the
    perimeter. Having points in a known order makes several operations—like checking
    if a point falls inside a shape or if a polygon is convex—considerably faster
    to compute. Shapely has a couple of functions to help with this. In [Listing 7-5](#listing7-5)
    we check if an object is in counterclockwise orientation and, if not, translate
    its point order so that it is.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个形状时，顶点的顺序很重要。标准做法是按逆时针顺序（在 Shapely 中为`ccw`）传递顶点，围绕形状的周长。确保点按已知顺序排列可以大大加快一些操作的计算速度——例如检查某个点是否在形状内或多边形是否为凸形。Shapely
    提供了一些函数来帮助处理这一点。在[列表 7-5](#listing7-5)中，我们检查一个对象是否为逆时针方向，如果不是，则转换它的点顺序，使其变为逆时针方向。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-5: Checking and fixing the order of vertices'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-5：检查和修复顶点顺序
- en: We start by creating a `LinearRing` object. You can prove to yourself on a piece
    of graph paper that the order of the vertices, from left to right, forms a clockwise
    description of a triangle. We can use Shapely to check if the vertices are in
    counterclockwise order by printing the Boolean attribute `is_ccw`, which will
    be `False`. To translate the list into counterclockwise order, we use a Python
    list inversion (`[::-1]`), which adds the coordinates in reverse order to a new
    list, then assigns the newly reordered list to a new `LinearRing` object called
    `new_ring`. Printing `is_ccw` on `new_ring` will now return `True`, confirming
    the new ordering is indeed counterclockwise.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个`LinearRing`对象开始。你可以在一张坐标纸上验证，顶点的顺序从左到右，形成一个顺时针方向的三角形描述。我们可以使用Shapely通过打印布尔属性`is_ccw`来检查顶点是否按逆时针顺序排列，结果将为`False`。为了将列表转换为逆时针顺序，我们使用Python的列表反转（`[::-1]`），它会将坐标按相反顺序添加到一个新列表中，然后将重新排序后的列表赋给一个名为`new_ring`的新`LinearRing`对象。打印`new_ring`上的`is_ccw`将返回`True`，确认新的顺序确实是逆时针的。
- en: Now that you can describe shapes in a way the computer can work with, let’s
    look at some common operations you’ll repeatedly use when geometrically analyzing
    security problems. In the next section we’ll cover useful algorithms for finding
    areas, determining overlaps and intersections, and calculating perimeter lengths
    for irregular shapes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以以计算机能够处理的方式描述形状，让我们来看看一些常见的操作，这些操作在几何分析安全问题时会反复使用。在下一节中，我们将介绍一些有用的算法，用于计算面积、确定重叠和交集，以及计算不规则形状的周长。
- en: 'Scenario: Planning Security for a Concert'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景：为音乐会规划安全措施
- en: The best way to get acquainted with computational geometry theory is to apply
    it in a scenario, so imagine you’re asked to plan the security for a concert being
    held at a local park. You need to decide how many security personnel to assign
    to the event and where they’ll be positioned, and you need to provide the event
    coordinators with recommendations for safe attendance capacity. [Figure 7-3](#figure7-3)
    shows the park layout from an overhead view.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 了解计算几何理论的最佳方法是将其应用于场景中，所以假设你被要求为在当地公园举办的音乐会规划安全措施。你需要决定为活动分配多少安保人员，并确定他们的站位，同时向活动协调员提供安全的参会人数建议。[图
    7-3](#figure7-3)展示了从上空视角看公园的布局。
- en: '![](image_fi/502567c07/f07003.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c07/f07003.png)'
- en: 'Figure 7-3: The park as a polygon with holes'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：带孔的公园多边形
- en: The outline of the polygon represents a tall fence around the park. The small
    square near the bottom of the park is an information booth that can’t be accessed
    by attendees, so we subtract it from the usable area. The rectangle near the top
    of the park is the stage, which also can’t be accessed by attendees, so we remove
    it as well. The remaining gray area is the part of the park that’s accessible
    to attendees. We’ll calculate this area and then use the result to figure out
    the number of attendees that can safely and comfortably attend the event.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形的轮廓代表了围绕公园的高围栏。公园底部附近的小方块是一个信息亭，参会者无法进入，因此我们从可用区域中减去它。公园顶部附近的矩形是舞台，参会者也无法进入，因此我们也将其移除。剩余的灰色区域是参会者可以进入的公园部分。我们将计算这个区域的面积，然后用结果来确定可以安全舒适地参加活动的人数。
- en: Calculating Safe Occupancy Limits
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算安全容纳人数限制
- en: To find the area of irregular shapes like the park, first we must decompose
    the shape into a set of simple shapes, like triangles, and then sum the area of
    each composite shape. The act of decomposing a shape like this is known as *tessellation*,
    and involves overlaying a plane using one or more geometric shapes, called *tiles*,
    with no overlaps and no gaps. [Figure 7-4](#figure7-4) shows two approaches to
    triangular tessellation for the park space.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算像公园这样的不规则形状的面积，首先我们必须将该形状分解为一组简单形状，如三角形，然后将每个组合形状的面积相加。将形状分解的过程称为*镶嵌*，涉及使用一个或多个几何形状，称为*瓦片*，在平面上进行覆盖，要求没有重叠和空隙。[图
    7-4](#figure7-4)展示了两种为公园空间进行三角形镶嵌的方法。
- en: '![](image_fi/502567c07/f07004.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c07/f07004.png)'
- en: 'Figure 7-4: A triangular tessellation of a simple polygon and a polygon with
    holes'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：简单多边形的三角形镶嵌和带孔多边形
- en: 'The simple approach on the left tessellates the base polygon and temporarily
    ignores the holes. You calculate the total area of this shape and then subtract
    the areas for the two restricted zones. I used this method by hand back in my
    early days. The approach on the right tessellates the complex shape with holes
    included using Shapely’s `triangulate` function (not to be confused with location
    triangulation, which we’ll cover in [Chapter 8](c08.xhtml)). We can find the area
    by summing the *n* areas of each gray triangle:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的简单方法对基础多边形进行镶嵌，并暂时忽略孔洞。你可以计算出这个形状的总面积，然后减去两个限制区域的面积。我在早期使用手动方法做过这种计算。右边的方法则使用
    Shapely 的 `triangulate` 函数对包含孔洞的复杂形状进行镶嵌（不要与我们在[第 8 章](c08.xhtml)中将要讨论的位置三角测量混淆）。我们可以通过将每个灰色三角形的
    *n* 个面积相加来找到总面积：
- en: '![](image_fi/502567c07/m07001.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c07/m07001.png)'
- en: Here *P*[Δ[][*i*][]]*B* and *P*[Δ[][*i*][]]*H* are the base and height measurements,
    respectively, for the *i*th triangle in *P*[Δ].
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*P*[Δ[][*i*][]]*B* 和 *P*[Δ[][*i*][]]*H* 分别是第 *i* 个三角形的底边和高度测量值，位于 *P*[Δ]
    中。
- en: Luckily, we don’t have to worry about manual tessellation just to find the area
    of the complex shape. The Shapely library automatically handles all of this under
    the hood when you create a shape. [Listing 7-6](#listing7-6) shows how to create
    the park shape and calculate the usable area for attendees.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要担心手动镶嵌，只为找出复杂形状的面积。Shapely 库会在你创建形状时自动处理所有这些工作。[列表 7-6](#listing7-6)
    展示了如何创建公园形状并计算参与者可用的面积。
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-6: Creating the complex park shape and calculating the area'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-6：创建复杂的公园形状并计算面积
- en: We start by creating the outermost `Polygon` to represent the bounds of the
    event space. We then create a `LinearRing` object for both the stage and information
    booth. Next, we create the complex polygon representing the shape of the usable
    space in the venue. The library provides an `area` attribute for polygons that
    respects any holes we passed in during creation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建最外层的 `Polygon` 来表示活动空间的边界。然后，我们为舞台和信息亭分别创建一个 `LinearRing` 对象。接下来，我们创建一个表示场地可用空间形状的复杂多边形。该库为多边形提供了一个
    `area` 属性，该属性会尊重我们在创建时传入的任何孔洞。
- en: 'When you’re dealing with really big shapes like the park, it’s common practice
    to apply a scaling factor—that is, to shrink the whole shape by some known constant
    to make the numbers easier to work with. In Figures 7-3 and 7-4, one unit is equal
    to 10 meters, or a scaling factor of 0.1, so multiplying the `event_shape.area`
    by 10 adjusts the result for the scaling applied to the map. The output of the
    `print` statement is:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理像公园这样非常大的形状时，常见的做法是应用一个缩放因子——也就是说，将整个形状按某个已知常数缩小，以使得数字更易于处理。在图 7-3 和 7-4
    中，1 个单位等于 10 米，或者说缩放因子是 0.1，因此通过将 `event_shape.area` 乘以 10，可以调整结果以适应地图的缩放。`print`
    语句的输出是：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we know the usable area, we can calculate the number of attendees that
    can safely fill it. [Listing 7-7](#listing7-7) shows how to convert the area result
    to attendee count by dividing the usable area by the amount of space we aim to
    provide each attendee.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了可用面积，可以计算出能够安全容纳的参与者人数。[列表 7-7](#listing7-7) 展示了如何通过将可用面积除以每个参与者所需的空间来转换为参与者人数。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-7: Calculating capacity based on usable area'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-7：基于可用面积计算容纳能力
- en: 'Years ago, I settled on 0.75 square meters—a little over 8 square feet—per
    person for events with a mixture of seated and standing attendees. (I later discovered
    others had reached roughly the same numbers for similar scenarios.) We multiply
    the `event_area` by 0.75 to find the number of people that can comfortably attend
    the event with room for some people to sit on a blanket and others to walk around.
    To find the maximum number of people that can safely stand in an area, we can
    cut the spacing roughly in half to 0.37 square meters, or about 4 square feet
    per person. Now, we can multiply the event area by 0.37 to find the “standing
    room only” capacity of the venue, `max_capacity`. This tight spacing would be
    like standing in a crowded hallway: you’re not quite bumping into other people
    yet, but almost. The output from the code should be:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，我为包含坐席和站立的与会者混合的活动定下了每人0.75平方米（大约8平方英尺）的标准面积。（后来我发现其他人对类似场景得出了大致相同的数字。）我们将`event_area`乘以0.75，以找到可以舒适容纳与会者的最大人数，同时为一些人留出坐在毯子上的空间，而另一些人可以四处走动。为了找到一个区域内可以安全站立的最大人数，我们可以将间距大致减半，变为每人0.37平方米，约为4平方英尺。现在，我们可以将活动区域乘以0.37，来找出场地的“站立区”最大容量`max_capacity`。这种紧密的间距就像站在一个拥挤的走廊里：你几乎要碰到其他人了，但还没有。代码的输出应为：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To estimate the number of security personnel for the event, we’ll round the
    846 attendees up to 900\. From experience, I use a ratio of 60:1 attendees to
    security, which in this case means 900 / 60 = 15\. However, 900 includes everyone
    that will be in the event area, including security personnel, so in a real scenario
    you actually want to round in the other direction and recommend a max comfortable
    capacity of 830 attendees while estimating the security detail for the higher
    crowd number, 900\.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了估算活动所需的安保人员数量，我们将846名与会者四舍五入为900人。根据经验，我使用一个60:1的比例，即每60名与会者配备1名安保人员，在这种情况下，900
    / 60 = 15。 但是，900人包括所有将进入活动区域的人，包括安保人员，所以在实际情况下，你实际上需要反向四舍五入，建议的最大舒适容量为830名与会者，同时根据更高的观众数量（900人）估算安保人员数量。
- en: After applying this formula to some real venues, you’ll notice your comfortable
    numbers are usually lower than those recommended by safety codes issued from the
    fire department, which is intentional. The fire department numbers are concerned
    with the number of people that can safely evacuate in the event of an emergency
    and have nothing to do with crowd security or comfort. You’ll also find that event
    coordinators will settle somewhere between the number you suggest and the number
    the fire department will allow (hence rounding up in planning for personnel and
    rounding down when recommending attendance).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这个公式应用于一些实际场地之后，你会发现你的舒适人数通常低于消防部门安全规范推荐的人数，这是故意的。消防部门的数字关注的是在紧急情况下能安全疏散的人数，与人群安保或舒适性无关。你还会发现活动协调员通常会选择你建议的数字和消防部门允许的数字之间的某个数值（因此在规划人员时向上四舍五入，而在推荐与会人数时向下四舍五入）。
- en: Determining Placement of Security Personnel
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定安保人员的部署位置
- en: Now that we know how many security personnel we need, let’s address where to
    place them. We’ll use tessellation combined with another common operation known
    as *centroid location*, which finds the point that’s equidistant from all of the
    perimeter vertices of a polygon (that is, the *centroid*). The centroid of a convex
    object always lies inside the object’s area. A concave object might have a centroid
    that is outside the area, but since we’re tessellating the shape first, each resulting
    triangle will be convex and the centroid will be located within the perimeter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了需要多少安保人员，接下来我们来确定他们的部署位置。我们将使用镶嵌技术，并结合另一种常见的操作——*质心定位*，它找到一个与多边形所有边界顶点等距的点（即*质心*）。一个凸形物体的质心总是位于物体区域内部。一个凹形物体的质心可能位于物体外部，但由于我们首先进行的是镶嵌，每个生成的三角形都是凸形的，因此质心将位于边界内。
- en: The centroid of *P* = [(*x*0, *y*0), (*x*1, *y*1), . . . , (*xn –* 1, *yn* –
    1)] is the point C(*x*, *y*), where
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*的质心 = [(*x*0, *y*0)，(*x*1, *y*1)，……，(*xn –* 1, *yn* – 1)] 是点C(*x*，*y*)，其中'
- en: '![](image_fi/502567c07/m07002.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c07/m07002.png)'
- en: 'The term *A* is the signed area of *P*, which is calculated using the *shoelace
    algorithm*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*是*P*的有符号面积，通过*鞋带算法*计算得出：'
- en: '![](image_fi/502567c07/m07003.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c07/m07003.png)'
- en: The points in *P* need to be in sequential order along the perimeter for this
    to work. If the order of the vertices is counterclockwise, the area will be a
    negative value; otherwise, it will be positive. In either case the absolute value
    of *C*[(][*x,y*][)] will be correct. We can use this information to place each
    of the 15 security personnel in the centroid location of the triangle with the
    largest area that hasn’t been assigned a guard yet. [Listing 7-8](#listing7-8)
    shows how to achieve this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*中的点需要按顺序沿着周边排列才能使该方法有效。如果顶点的顺序是逆时针方向，面积将为负值；否则，面积为正值。在任一情况下，*C*[(][*x,y*][)]的绝对值都是正确的。我们可以利用这一信息，将每个警卫部署在还未分配警卫的、面积最大的三角形的质心位置。[清单
    7-8](#listing7-8)展示了如何实现这一点。'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-8: A centroid-based personnel dispersion algorithm'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 7-8: 基于质心的人员分布算法'
- en: We start by triangulating the `event_shape` object from [Listing 7-6](#listing7-6)
    using the `triangulate` function. The result is a set of `Polygon` objects representing
    the triangles making up the shape (denoted as *P*[Δ]). We then use a dictionary
    comprehension to create a sortable list of triangle index and corresponding area.
    We use the `sorted` function to sort the `area_dict` by value. Using descending
    order with `reverse=True` allows us to use the coordinates for the centroid of
    the first 15 triangles to estimate a good dispersion of security personnel. [Figure
    7-5](#figure7-5) shows the resulting placement plan.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过`triangulate`函数从[清单 7-6](#listing7-6)中三角化`event_shape`对象。结果是一个由`Polygon`对象组成的集合，表示构成该形状的三角形（记作*P*[Δ]）。然后，我们使用字典推导式创建一个可排序的三角形索引和对应面积的列表。我们使用`sorted`函数按值对`area_dict`进行排序。使用降序排列（`reverse=True`）使我们能够使用前15个三角形质心的坐标来估算安保人员的合理分布。[图
    7-5](#figure7-5)展示了结果的部署计划。
- en: '![](image_fi/502567c07/f07005.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c07/f07005.png)'
- en: 'Figure 7-5: The centroid placement for security personnel'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '图 7-5: 安保人员的质心部署'
- en: The triangulation is identical to the one shown in [Figure 7-4](#figure7-4).
    The gray plus symbols are the centroids for each of the selected triangles. As
    you can see, the result of this fairly basic algorithm is pretty good. Regardless
    of where you’re standing in the venue, you’re never far from one or more security
    stations. Using a dispersion method like this ensures that security can respond
    quickly regardless of where they’re needed. The one problem is the fact that it
    placed a guard in one of the unusable parts of the venue, right on stage! We’ll
    see how to improve this algorithm and fix the placement of that guard in the “[Improving
    Guard Placement](#h2-502567c07-0007)” section, but for the moment, let’s look
    at another useful piece of analysis that will help us plan and schedule walking
    patrols.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 三角剖分与[图 7-4](#figure7-4)中展示的完全相同。灰色的加号符号是每个选定三角形的质心。正如你所看到的，这个相对基础的算法结果相当不错。无论你站在场地的哪个位置，都不会离一个或多个安保站点太远。使用这种分散方法可以确保安保人员能够快速响应，无论他们被需要在哪里。唯一的问题是它将一名警卫安排到了场地中不可用的区域，正好是舞台上！我们将在“[改进警卫部署](#h2-502567c07-0007)”部分中看到如何改进这个算法，并修正该警卫的位置，但现在，我们先来看一个有用的分析工具，它可以帮助我们规划和安排步巡。
- en: Estimating Guard Patrol Timing
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 估算警卫巡逻时间
- en: Perimeter length is a great way to estimate timing for patrols. For simplicity,
    let’s assume the guards patrolling the perimeter of the event don’t count against
    the 15 guards we already placed. We could assign the misplaced guard position
    to patrol, but that would change the ratio of security to attendees in the venue
    (albeit only slightly). For now, let’s pretend we have another two guards positioned
    along the perimeter so they don’t count toward attendance. One is located at a
    stationary point (say, at a primary access point like a gate) and another is walking
    around the perimeter. For safety, the patrol guard should have scheduled check-in
    times with the stationary guard. The question is how long a normal patrol should
    take. This is where perimeter length comes in handy. For a polygon, the length
    of its perimeter is the sum of the lengths of the individual line segments it
    comprises. To figure out how long the walk should take around the park, we can
    divide the outer perimeter’s length by the guard’s estimated walking speed. [Listing
    7-9](#listing7-9) shows how to compute this time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 周边长度是估算巡逻时间的一个好方法。为了简化假设，我们假设巡逻事件周边的守卫不计入我们已经布置的15名守卫。在这种情况下，我们可以安排一个未布置的守卫位置进行巡逻，但这会改变场地内安保与观众的比例（尽管只有轻微的变化）。暂时假设我们在周边有另外两名守卫，他们不计入参与人数。一个守卫位于一个固定点（例如，主入口处），另一个则在周边巡逻。为了安全，巡逻守卫应该与固定守卫有安排好的签到时间。问题是，正常的巡逻应该需要多长时间。这时周边长度就派上了用场。对于一个多边形，其周边长度是构成该图形的各条线段长度之和。为了计算绕公园走一圈需要多长时间，我们可以将外周边的长度除以守卫的预估步行速度。[列表
    7-9](#listing7-9)展示了如何计算这个时间。
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-9: Computing guard patrol times'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-9：计算守卫巡逻时间
- en: 'The exterior `length` attribute of a complex shape like the `event_shape` object
    is a `LinearRing` object representing the outermost points of the figure. To get
    the actual distance around the fence, we multiply the `LinearRing`’s length property
    by the scaling factor. Next we need an estimate for the guard’s speed. According
    to Wikipedia, the average human walking speed at crosswalks is about 1.4 meters
    per second (m/s), or about 3.1 miles per hour (mph). We can assume our security
    will be walking a bit slower than this (they’re observing the area as they patrol,
    after all). We set the rate variable to 1.1 m/s or about 2.5 mph. To get the per-minute
    rate, we multiply the m/s rate by 60\. Then, we calculate the `walk_time` with
    time = distance / rate. The result from [Listing 7-9](#listing7-9) should be:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂形状如`event_shape`对象的外部`length`属性是一个`LinearRing`对象，代表该图形最外层的各个点。为了得到围栏周围的实际距离，我们将`LinearRing`的长度属性乘以缩放因子。接下来，我们需要估算守卫的步速。根据维基百科，行人过马路的平均步速大约是每秒1.4米（m/s），即每小时约3.1英里（mph）。我们可以假设我们的安保人员走得稍慢一点（毕竟他们在巡逻时要观察周围的情况）。我们将步速设为每秒1.1米，即每小时约2.5英里。为了得到每分钟的步速，我们将每秒的步速乘以60。然后，我们通过时间
    = 距离 / 步速来计算`walk_time`。从[列表 7-9](#listing7-9)得到的结果应该是：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can use this information to justify a policy that the patrol guard should
    check in at a given place along the perimeter every 5.49 minutes. In practice,
    you’d want to contact the patrol person if you didn’t receive a check-in within
    6 minutes or so.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这些信息来支持一种政策，即巡逻守卫应每5.49分钟在周边的某个特定地点签到。实际上，如果你没有在大约6分钟内收到签到，你应该联系巡逻人员。
- en: Improving Guard Placement
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进守卫布置
- en: Now let’s improve our guard placement from [Listing 7-8](#listing7-8) by adding
    the concept of *co-location*, when two objects occupy the same space on the Cartesian
    plane. With co-location, we’ll be able to determine when a guard has been placed
    in an unusable part of the venue. Shapely provides functions—such as `contains`,
    `intersects`, `overlaps`, `touches`, and `distance`—to check relationships between
    geometric objects. Each function takes in a second object as a parameter and answers
    the question its name suggests. For example, `contains` checks if object B resides
    completely within the interior of object A. The result will be `True` if no points
    of B are on the exterior of A and at least one point of the interior of B lies
    within the interior of A. There’s an inverse relationship function, `within`,
    such that `A.contains(B) = B.within(A)`. The Shapely documentation contains very
    good explanations of each function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-10](#listing7-10) extends the code from [Listing 7-8](#listing7-8)
    so that it doesn’t place the guard station on the stage.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-10: Reassigning guard stations from unusable areas'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Because `LinearRing` objects are hollow, they don’t actually contain the points
    within their bounds, so first we need to change the `stage` and `info_booth` objects
    to `Polygon` objects ❶. A polygon is assumed to be filled, so any point within
    its bounds will return `True` when we call the `contains` function ❷. By looping
    over each set of coordinates in the `sec_list`, we can cast them to `Points` and
    check if the stage or information booth polygons contain that point. If so, we
    can reassign it to one of the other unoccupied triangles by starting at the 16th
    triangle (index 15) and assigning the guard station to the new position ❸. We
    repeat the process of assigning the guard to a new position and checking if that
    position is contained by one of the unusable areas until we find a usable triangle.
    [Figure 7-6](#figure7-6) shows the result of running the improved code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c07/f07006.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-6: The improved security placement results'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: When you compare [Figure 7-6](#figure7-6) with [Figure 7-5](#figure7-5), you
    can see the guard station got moved from the stage area to the area below the
    information booth, which was previously empty. This change places all 15 guards
    in usable areas of the venue, making sure to assign guards to the largest unprotected
    sections first. By combining this information with the attendance recommendation
    and the scheduled patrol routes, we have a good start on an event security plan.
    We can take this basic recommendation and further refine it with our knowledge
    of the venue, the event taking place, and so on, to produce a fully formed security
    strategy that should include contingency plans for more security personnel and
    attendee overflow areas.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The power of computational geometry for security lies in the ability to encode
    physical features in a way machines can interpret: as points, line segments, and
    polygons. Once you encode the features, you can calculate the area, centroid location,
    perimeter length, and object relationships to analyze security problems. You’ve
    already seen how you can use geometry to describe a physical space like a park
    and place security personnel effectively. You’ve also seen how shapes can be combined
    to make more complex representations using hole objects. Finally, we covered some
    other common functions that you’ll encounter often in practice. There are many
    more functions available in the Shapely library, but the ones presented in this
    chapter represent a majority of the work you’ll need to perform when analyzing
    problems geometrically.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 计算几何学在安全中的力量在于能够将物理特征编码为机器可以理解的形式：如点、线段和多边形。一旦你对特征进行了编码，你就可以计算面积、质心位置、周长和对象关系来分析安全问题。你已经看到如何使用几何学描述像公园这样的物理空间，并有效地安排安全人员。你还看到了如何将形状结合起来，通过孔对象制作更复杂的表示。最后，我们还介绍了一些在实际应用中常见的其他常用函数。Shapely库中还有许多其他可用函数，但本章中展示的这些代表了在几何问题分析中你需要执行的大部分工作。
- en: 'As you’ll see over the next three chapters, we can combine these operations
    to create other very interesting security tools. There’s still plenty of research
    to dive into on your own. Geometry has a long history in the security industry,
    and many research questions can be restated such that you can apply geometric
    algorithms to them. Of course, none of this even touches on geometry in cryptography,
    which is its own beast and needs a book of its own. If you’re interested in this
    field, though, check out the paper “Geometric Cryptography: Identification by
    Angle Trisection.”^([1](b01.xhtml#c07-endnote-001)) If you’re interested in how
    you can apply geometric algorithms to privacy issues, you’ll want to research
    the field of privacy-preserving computational geometry.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在接下来的三章中看到的，我们可以将这些操作结合起来，创造出其他非常有趣的安全工具。仍然有很多研究等待你深入探索。几何学在安全行业中有着悠久的历史，许多研究问题可以重新表述，使得你能够将几何算法应用于其中。当然，这些内容甚至没有涉及到密码学中的几何学，而那是一个独立的领域，需要一本书来深入探讨。如果你对这个领域感兴趣，可以查阅论文《几何密码学：通过角平分法进行身份识别》。^([1](b01.xhtml#c07-endnote-001))
    如果你对如何将几何算法应用于隐私问题感兴趣，你可以研究隐私保护计算几何学领域。
- en: Let’s continue our exploration of computational geometry with the topic of geographic
    location data. In the next chapter, we’ll combine MapBox and OpenCellID data to
    triangulate the location of a cell phone.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索计算几何学，这次的主题是地理位置数据。在下一章中，我们将结合MapBox和OpenCellID数据，三角定位一个手机的位置。
