- en: '**Motors**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Old-School Analog Dial**
  prefs: []
  type: TYPE_NORMAL
- en: Old-fashioned analog displays have a certain charm. In this project I’ll demonstrate
    how to make your own.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0084-01.jpg)![Image](../images/p0085-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tower Pro SG90 9g servomotor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Photoresistor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10k-ohm resistor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARY REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Servo**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Today, visual representations of measurements are usually displayed digitally
    on an LCD screen or with LED digits, but not that long ago analog dials were always
    used to show pressure, speed, and even time! The Arduino can detect a voltage
    input from a sensor, and we’ll use that capability here to create a dial that
    the Arduino moves in response to the input received. We can use this dial in lots
    of ways to show measurements for different projects.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we’ll use a photoresistor to measure light input, but you could
    easily swap in a water sensor to make a rain detector, or a gas sensor for a warning
    meter. A *photoresistor*, also referred to as a *light-dependent resistor*, produces
    a variable resistance depending on the amount of light the sensor detects, as
    discussed in Project 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principles for adding an analog sensor are the same for whichever sensor
    you choose. Most sensors have three connections: ground, +5V, and a signal connection
    that connects to the analog A0 pin on the Arduino—this makes it easy to swap in
    a different sensor. The photoresistor is slightly different because it has only
    two connections, so one will go to power and one to A0.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the sensor to measure light levels, and the Arduino will use that
    measurement to move the arm of a small servomotor (or “servo” for short) to the
    corresponding angle. The angle of the motor arm indicates the strength of the
    light input.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *servo*, shown in [Figure 10-1](ch10.xhtml#ch10fig1), is a small, cheap,
    mass-produced motor used for small robotics and a variety of electronics tasks.
    The servo is controlled by three wires: ground (black or brown), power (red),
    and signal or control (typically orange, yellow, or white). Pulses are sent from
    the Arduino over the control wire via pulse width modulation (PWM; discussed in
    Project 5), and the input received by the photoresistor determines the angle of
    the servo’s actuator arm. The servo expects a pulse every 20 milliseconds in order
    to retrieve the correct information about the angle.'
  prefs: []
  type: TYPE_NORMAL
- en: The pulse width dictates the range of the servo’s angular motion. Typically,
    a servo pulse width of 1.5 milliseconds sets the servo to its “neutral” position
    of 45 degrees, a pulse width of 1.25 milliseconds sets the angle to 0 degrees,
    and a pulse width of 1.75 milliseconds sets the angle to 90 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 10-1:** A servomotor'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f10-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The physical limits of the arm angle and the timing of the servo hardware vary
    across brands and models, but in general a servo’s angular motion travels in the
    range of 90 to 180 degrees and the neutral position is almost always at 1.5 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Connect the servo’s red (power) wire directly to +5V on the Arduino, the brown
    (ground) wire to Arduino GND, and the yellow (signal) wire to Arduino pin 9, as
    shown in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **SERVO** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Red (power) wire | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Brown (ground) wire | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Yellow signal (control) wire | Pin 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Place the photoresistor in the breadboard and connect one leg to +5V on the
    Arduino. Connect the photoresistor’s other leg to a 10k-ohm resistor, as shown
    in the circuit diagram in [Figure 10-2](ch10.xhtml#ch10fig2), and use a jumper
    wire to connect this resistor leg to Arduino pin A0 (see the following table).
    Connect the other leg of the 10k-ohm resistor to GND.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **PHOTORESISTOR** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Leg 1 | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Leg 2 | Pin A0 via 10k-ohm resistor |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**FIGURE 10-2:** The photoresistor is connected to Arduino pin A0 and measures
    the amount of light. The servo is connected to pin 9 and moves according to the
    amount of light.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f10-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Upload the code in “[The Sketch](ch10.xhtml#ch00lev1sec41)” on [page 89](ch10.xhtml#page_89).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a faceplate for your dial, like the one in [Figure 10-3](ch10.xhtml#ch10fig3),
    and attach it to the servo. Be sure the servo arm can move over the measurements
    of the dial like a pointer. Cover the photoresistor completely when you add power
    to the Arduino, and then mark this position as 0 on the faceplate. Shine a bright
    flashlight at the light resistor to get the maximum value, and then mark that
    position on the faceplate as well. Add equally spaced marks between 0 and the
    max value to give you a scale.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 10-3:** An example faceplate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f10-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The servo’s actuator arm will move up the scale as it detects light, depending
    on the brightness. For example, on the left of [Figure 10-4](ch10.xhtml#ch10fig4),
    the servo arm is shown at position 0\. On the right, the servo arm displays the
    brightness measurement when light—in this case, a laser—is applied to the photoresistor.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 10-4:** When light shines on the photoresistor, the servo arm moves.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f10-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch first calls the Servo library, which is already built into the Arduino
    IDE (so there’s no need to download and install this library). We give the servo
    position a starting value of `0`, and set the photoresistor pin as A0\. We assign
    Arduino pin 9 to control the servo and then read the value from the analog pin.
    Pin A0 is capable of reading an analog value from the photoresistor and converting
    it to a digital value in the range 0–1,023, so we scale this down to 0–179 (180
    possible values) to fit the servo arm’s 180-degree range of movement. If no light
    is applied to the photoresistor, the value will be `0` and the servo position
    will be 0\. As you add light, the servo arm will move, up to a maximum of 180
    degrees. The angle depends on the brightness.
  prefs: []
  type: TYPE_NORMAL
- en: /* Created by David Cuartielles modified 30 Aug 2011 by Tom Igoe
  prefs: []
  type: TYPE_NORMAL
- en: This example code is in the public domain [http://arduino.cc/en/Tutorial/AnalogInput](http://arduino.cc/en/Tutorial/AnalogInput)
    */
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Servo.h> // Call the Servo library (built into the IDE)'
  prefs: []
  type: TYPE_NORMAL
- en: Servo myservo;
  prefs: []
  type: TYPE_NORMAL
- en: int pos = 0; // Give the position a value
  prefs: []
  type: TYPE_NORMAL
- en: int lightPin = A0; // Pin connected to the photoresistor
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: myservo.attach(9); // Pin connected to the servo
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: // Read voltage from photoresistor, can read 1024 possible values
  prefs: []
  type: TYPE_NORMAL
- en: int lightLevel = analogRead(lightPin);
  prefs: []
  type: TYPE_NORMAL
- en: // Scale 1024 values to 180
  prefs: []
  type: TYPE_NORMAL
- en: lightLevel = map(lightLevel, 0, 1023, 0, 179);
  prefs: []
  type: TYPE_NORMAL
- en: // Scale of 0-179 (180 values)
  prefs: []
  type: TYPE_NORMAL
- en: pos = constrain(lightLevel, 0, 179);
  prefs: []
  type: TYPE_NORMAL
- en: myservo.write(pos); // Set the servo angle
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the servo does not move when light is applied
    to the photoresistor.*'
  prefs: []
  type: TYPE_NORMAL
- en: • If the servo does not move at all, make sure that your wiring matches the
    diagram in [Figure 10-2](ch10.xhtml#ch10fig2) and that there’s power going to
    the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: • Connect the Arduino to your PC and open the Serial Monitor to check that there’s
    a reading from the photoresistor. If no reading is registered, check that the
    photoresistor is securely inserted into the breadboard. If you still get no reading,
    your photoresistor may be faulty, so replace it with another one.
  prefs: []
  type: TYPE_NORMAL
- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stepper Motor**
  prefs: []
  type: TYPE_NORMAL
- en: In this project I’ll introduce you to a stepper motor (or step motor), set it
    up, and discuss how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0091-01.jpg)![Image](../images/p0092-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**28BYJ-48 stepper motor with ULN2003 driver module**'
  prefs: []
  type: TYPE_NORMAL
- en: '**50k-ohm potentiometer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARY REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stepper**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *stepper motor*, like the one shown in [Figure 11-1](ch11.xhtml#ch11fig1),
    is a direct current (DC) electric motor that divides a full rotation of the arm
    into a number of equal steps. Unlike the servomotor used in Project 10, this stepper
    motor turns 360 degrees and has the advantage of being able to position itself
    with great accuracy or rotate continuously.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 11-1:** A 28BYJ-48 stepper motor'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f11-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The stepper motor’s data sheet will state the number of steps it performs per
    revolution; a *step* is just one movement within one revolution. A motor with
    200 steps per revolution will turn through 360 degrees in 200 steps, or 1.8 degrees
    per step. Within a stepper motor there are two interlocked discs, similar to gears,
    with teeth of opposing magnetism that alternate and connect to the center shaft
    or rotor. The motor moves in steps when power is sent to its *windings*—a series
    of wire coils that become electromagnets when voltage is applied. When powered,
    these electromagnets attract or oppose the gear-shaped discs and rotate the shaft.
  prefs: []
  type: TYPE_NORMAL
- en: You can control the motor’s position and speed by commanding it to move to and
    hold at one of these steps. Since we know the angle each step represents, we can
    get accurate and precise turning angles and distance measurements. Stepper motors
    are commonly used in CD and DVD players and in 3D printers, where movements need
    to be very accurate.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re looking to buy a stepper motor, there are a few things to consider.
    The first is whether or not it has a gearbox. A gearbox will improve the *torque*
    (moving power) but reduce the *revolutions per minute* (RPM, or speed).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next consideration is whether the stepper motor is bipolar or unipolar.
    *Bipolar* motors switch polarity of the coils. Polarity is the direction the current
    flows; so if, for example, we reversed the 5V and GND connections, the motor would
    turn in the opposite direction. Bipolar motors have simpler windings but require
    more complicated drivers as they reverse the polarity for us. *Unipolar* motors
    essentially have a winding per polarity, but they can use simpler drivers. You
    can check whether your motor is bipolar or unipolar by looking at the connections:
    a bipolar motor has four connections, and a unipolar motor has five to eight connections.
    In this project we’re using a unipolar motor, the 28BYJ-48 stepper motor with
    the ULN2003 driver test module—a board that makes it easy to control the motor
    with the Arduino, like the module board for the LED matrix in Project 4\. Some
    driver boards will have a slightly different setup, so I’d recommend getting the
    model of motor listed here for the project so you can follow the instructions
    closely.'
  prefs: []
  type: TYPE_NORMAL
- en: Turning the potentiometer alters the angle of the stepper motor arm, so as you
    move the potentiometer to the left or right, the stepper motor arm will follow
    your input. (A *potentiometer* is a variable resistor with a knob.) The resistance
    of the potentiometer changes as you turn the knob. They are commonly used in electrical
    devices such as volume controls on audio equipment.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect the stepper motor to the driver board, as shown in [Figure 11-2](ch11.xhtml#ch11fig2).
    From the outermost pin to the innermost pin in the middle of the board, connect
    the wires from the motor in the following order: blue, pink, yellow, orange, red.
    The connector can only be inserted in this way.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 11-2:** Connecting the stepper to the driver board'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f11-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Connect the driver board pins 1, 2, 3, and 4 at the other end of the board directly
    to Arduino pins 8, 9, 10, and 11, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **STEPPER DRIVER BOARD** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| IN1 | Pin 8 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| IN2 | Pin 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| IN3 | Pin 10 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| IN4 | Pin 11 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| +5V | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Insert a potentiometer into the breadboard, connecting its center pin to Arduino
    A0 and its outer two pins to Arduino +5V and GND in any order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **POTENTIOMETER** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Left pin | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Center pin | A0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Right pin | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Connect the driver board GND and +5V to the breadboard GND and +5V, and connect
    the breadboard rails to the Arduino. Don’t forget to attach the power rails of
    the breadboard to GND and +5V too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that your setup matches the final configuration shown in [Figure 11-3](ch11.xhtml#ch11fig3),
    and upload the code in “[The Sketch](ch11.xhtml#ch00lev1sec45)” below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 11-3:** The circuit diagram for the stepper motor'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f11-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code comes with the Arduino IDE and can be found at File ▸ Examples ▸ Stepper
    ▸ MotorKnob. I’ve reproduced it here as you’ll see it in the IDE. It uses the
    built-in stepper library, `<Stepper.h>`. The potentiometer is connected to the
    Arduino A0 pin and gives a variable voltage depending on the turn of the potentiometer,
    which then controls the position of the stepper motor.
  prefs: []
  type: TYPE_NORMAL
- en: /* MotorKnob
  prefs: []
  type: TYPE_NORMAL
- en: '* [http://www.arduino.cc/en/Reference/Stepper](http://www.arduino.cc/en/Reference/Stepper)'
  prefs: []
  type: TYPE_NORMAL
- en: '* This example code is in the public domain.'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Stepper.h>'
  prefs: []
  type: TYPE_NORMAL
- en: // Change this to the number of steps on your motor
  prefs: []
  type: TYPE_NORMAL
- en: '#define STEPS 100'
  prefs: []
  type: TYPE_NORMAL
- en: // Create an instance of the stepper class, specifying the number of
  prefs: []
  type: TYPE_NORMAL
- en: // steps of the motor and the pins it's attached to
  prefs: []
  type: TYPE_NORMAL
- en: Stepper stepper(STEPS, 8, 10, 9, 11);
  prefs: []
  type: TYPE_NORMAL
- en: // The previous reading from the analog input
  prefs: []
  type: TYPE_NORMAL
- en: int previous = 0;
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: // Set the speed of the motor to 700 RPM
  prefs: []
  type: TYPE_NORMAL
- en: stepper.setSpeed(30);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: // Get the sensor value
  prefs: []
  type: TYPE_NORMAL
- en: int val = analogRead(0);
  prefs: []
  type: TYPE_NORMAL
- en: // Move a number of steps equal to change in the sensor reading
  prefs: []
  type: TYPE_NORMAL
- en: stepper.step(val - previous);
  prefs: []
  type: TYPE_NORMAL
- en: // Remember the previous value of the sensor
  prefs: []
  type: TYPE_NORMAL
- en: previous = val;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the stepper motor does not move.*'
  prefs: []
  type: TYPE_NORMAL
- en: • When you power the motor, lights should blink on the driver motor board. If
    they don’t, there’s an issue with power, so check that your setup matches the
    circuit diagram in [Figure 11-3](ch11.xhtml#ch11fig3). Make sure the stepper motor
    connection is firmly inserted into the driver motor board—it can only go in one
    way.
  prefs: []
  type: TYPE_NORMAL
- en: • If the driver board lights but the motor does not move, check that the connections
    to the potentiometer are secure and match the tables shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '**12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Temperature-Controlled Fan**
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we’ll use an LM35 temperature sensor to turn a fan on automatically
    when the temperature is too high.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0098-01.jpg)![Image](../images/p0099-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LM35 temperature sensor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**5V single-channel relay module**'
  prefs: []
  type: TYPE_NORMAL
- en: '**12V mini computer cooling fan**'
  prefs: []
  type: TYPE_NORMAL
- en: '**9V battery snap and battery**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LM35 temperature sensor (shown in [Figure 12-1](ch12.xhtml#ch12fig1)) senses
    the temperature and sends that measurement to the Arduino in voltage. The Arduino
    converts this voltage value to temperature in degrees Celsius and then converts
    this value to degrees Fahrenheit. When the temperature reading is above 71 degrees
    Fahrenheit, the Arduino sends power to the relay, which turns on the computer
    fan.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 12-1:** The LM35 temperature sensor: the left pin is +5V, center is
    data out, and right is GND.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f12-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The computer fan requires more power than the Arduino can provide, so we need
    to give it its own power supply: a 9V battery. This circuit is controlled by an
    *electronic relay*—an electronically operated switch that in this case uses an
    electromagnet to mechanically open or close the circuit (shown in [Figure 12-2](ch12.xhtml#ch12fig2)).
    A relay is generally used when a low-power device is required to switch on or
    off a much higher-voltage device. Our relay is powered by 5 volts to operate the
    mechanical switch. In this project the circuit is only 9 volts, but the relay
    could control a circuit up to 240 volts. Adding higher-voltage circuits can be
    very dangerous, however, so do this only if you are comfortable working with electricity
    or can seek professional advice.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 12-2:** A 5V single-channel relay'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f12-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Insert the LM35 sensor into the breadboard with the front of the sensor (the
    flat surface with text on it) facing you. Connect the left pin to the +5V rail
    on the breadboard, the center pin to Arduino A0, and the right pin to the GND
    rail, as shown in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LM35 SENSOR** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Left pin | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Center pin | A0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Right pin | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: There are a number of connections on the relay, as shown in [Figure 12-3](ch12.xhtml#ch12fig3).
    If your relay module has a different layout, adapt the wiring accordingly (using
    the data sheet or the pin markings on the module). Our relay has an LED marked
    PWR to indicate when it’s receiving power, and another LED to show when the electromagnetic
    switch is on (you can usually hear this, too, as it makes a satisfying clicking
    noise). The relay can be set to be `HIGH` or `LOW` when triggered, as indicated
    by a small jumper switch or pins. For our project, make sure the jumper is set
    to `HIGH` so the relay will send power when it is triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 12-3:** Relay connections (your relay pins may differ, so follow the
    data sheet provided)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f12-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As [Figure 12-3](ch12.xhtml#ch12fig3) shows, the pins on the right side of the
    relay module are Signal, GND, and +5V. Attach the relay’s Signal pin to Arduino
    pin 5, GND to Arduino GND, and +5V to the Arduino power via the breadboard rails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **5V RELAY** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Signal | Pin 5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| +5V | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: On the left side of the relay module are the connections for the electromagnetic
    switch ([Figure 12-3](ch12.xhtml#ch12fig3)). The center pin is the common connection;
    the left pin is marked NO for *normally open*, meaning the circuit is broken and
    the default state is off; and the right pin is marked NC for *normally closed*,
    meaning the default state is on. If the relay is not switched, the common pin
    is connected to the NC pin. If the relay is switched, the common pin is connected
    to the NO pin. Because we want the circuit to be off until we use the switch,
    we will use the NO pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect the black GND wire of the fan to the GND wire of the 9V battery.
    Then, as shown in the following table, attach the red positive wire of the fan
    to the common pin on the relay, and connect the positive wire of the 9V battery
    to NO on the relay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **5V RELAY** | **FAN/9V BATTERY** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| NO (normally open) | 9V battery’s positive wire |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Common | Fan’s positive wire |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| NC (normally closed) | Not connected |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Connect the breadboard power rails to each other and to the Arduino GND and
    +5V pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your setup matches the circuit diagram in [Figure 12-4](ch12.xhtml#ch12fig4),
    and then upload the code in “[The Sketch](ch12.xhtml#ch00lev1sec49)” on [page
    103](ch12.xhtml#page_103).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 12-4:** The circuit diagram for the temperature-controlled fan'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f12-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this sketch we first set the sensor pin for the LM35 as A0 on the Arduino,
    define the fan as pin 5, and create a variable to read the value from the LM35\.
    We then create a variable to store the temperature and set the fan pin as an output.
    A small calculation turns the voltage reading from the sensor into a temperature
    value in degrees Fahrenheit. We then start the Serial Monitor so you can see the
    LM35 reading value when the Arduino is connected to your PC, which is handy for
    making sure the sensor is working correctly. A loop reads the sensor every second,
    and if the temperature reaches 71 degrees Fahrenheit, power is sent to the fan
    pin, which triggers the relay and switches on the fan. If the temperature falls
    below 71, the relay switches the fan off.
  prefs: []
  type: TYPE_NORMAL
- en: '#define SENS_PIN A0 // Defines A0 pin as "sensor"'
  prefs: []
  type: TYPE_NORMAL
- en: '#define FAN_PIN 5'
  prefs: []
  type: TYPE_NORMAL
- en: int Vin; // Reads value from Arduino pin
  prefs: []
  type: TYPE_NORMAL
- en: float Temperature; // Receives converted voltage value to temp
  prefs: []
  type: TYPE_NORMAL
- en: float TF; // Receives converted value in °F
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(FAN_PIN, OUTPUT); // Fan pin as an output
  prefs: []
  type: TYPE_NORMAL
- en: Serial.begin(9600); // Start Serial Monitor
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: // Tells Arduino to read pin and stores value in Vin
  prefs: []
  type: TYPE_NORMAL
- en: Vin = analogRead(SENS_PIN);
  prefs: []
  type: TYPE_NORMAL
- en: // Converts voltage value into temperature and
  prefs: []
  type: TYPE_NORMAL
- en: // stores value in Temperature (as °F)
  prefs: []
  type: TYPE_NORMAL
- en: Temperature = (500 * Vin) / 1023 * (1.8) + 32;
  prefs: []
  type: TYPE_NORMAL
- en: TF = Temperature;
  prefs: []
  type: TYPE_NORMAL
- en: 'Serial.print("Temperature: "); // Sends text to display screen'
  prefs: []
  type: TYPE_NORMAL
- en: Serial.print(TF); // Shows value of temperature in Serial Monitor
  prefs: []
  type: TYPE_NORMAL
- en: Serial.println(" F"); // Writes F to indicate it is in Fahrenheit
  prefs: []
  type: TYPE_NORMAL
- en: if (TF > 71) { // If temperature is more than 71
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(FAN_PIN, HIGH); // Turn fan on
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (TF < 71) {
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(FAN_PIN, LOW); // Or keep fan off
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: delay(1000); // Waits for a second to read the pin again
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The fan does not turn on when expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure the connections to the LM35 match the tables in this chapter and
    the circuit diagram in [Figure 12-4](ch12.xhtml#ch12fig4). Connect the Arduino
    to your computer and open the IDE Serial Monitor to check whether the Arduino
    is reading the sensor correctly. If the reading is incorrect, recheck your wiring
    or change the sensor to another.
  prefs: []
  type: TYPE_NORMAL
- en: • Remember, your relay may not match the one used here, so the connections may
    be in a slightly different order; alter the wiring according to your relay and
    data sheet.
  prefs: []
  type: TYPE_NORMAL
- en: • The fan used here takes between 9 and 12 volts, so a 9V battery has enough
    power to run it. If you used a fan that requires more voltage, you will need to
    match its voltage input accordingly with a more powerful battery.
  prefs: []
  type: TYPE_NORMAL
