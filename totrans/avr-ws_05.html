<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch05">
  <div id="header0501" class="chapter">
   <h1 class="cn">
    <span class="page" id="p115">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch05">
     5
    </a>
   </h1>
   <h1 class="ctfm">
    Taking Control with Hardware Interrupts
   </h1>
  </div>
  <div class="figure" id="ct05">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   So far, the code for your projects in this book has been sequential. Any deviations from a linear pattern, such as detecting button presses, required you to monitor digital inputs. However, preplanning button presses in your code isn’t always efficient or realistic.
   <i class="calibre5">
    Hardware interrupts
   </i>
   allow your programs to respond to events more efficiently and dynamically.
  </p>
  <p class="calibre8">
   Hardware interrupts enable the AVR microcontroller to react to a change of state at a digital input pin at any time. In a way, they allow your AVR to multitask: when a button is pressed or when a signal is received at a digital input, the AVR will stop what it is doing and run some other code, called an
   <i class="calibre5">
    interrupt service routine (ISR)
   </i>
   . After the ISR code runs, the AVR picks up execution where it left off before the interrupt.
  </p>
  <p class="calibre8">
   Interrupts allow you to write more logical code and make your AVR-based projects operate more intuitively. This chapter covers two kinds of hardware interrupts, external interrupts and pin-change interrupts, using
   <span id="p116">
   </span>
   the ATmega328P-PU microcontroller. Both interrupts are triggered by state changes in pins (for instance, a change from high to low voltage). Pin-change interrupts can occur on all the pins, while external interrupts can only happen on two pins. Once you’ve got the basics down, you’ll use interrupts to create a counting device with a USART-based display.
  </p>
  <div class="chapter">
   <h2 class="ah" id="ah0701">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0701">
     External Interrupts
    </a>
   </h2>
   <p class="paft">
    This section walks you through the basics of initializing external interrupts, which you’ll put to use in
    <a class="url" href="nsp-boxall502581-0015.xhtml#pro22">
     Project 22
    </a>
    . The ATmega328P-PU uses pins 4 and 5, referenced as INT0 and INT1, for external interrupts. These two pins can detect and report changes in the electrical signal connected to them. The interrupts can be set to react to one of the following four possible changes in state at the pin:
   </p>
   <p class="pcust1">
    <span class="hemb">
     Low level
    </span>
    The voltage at the pin changes to a low state (equivalent to GND).
   </p>
   <p class="pcust1">
    <span class="hemb">
     Any logic change
    </span>
    The voltage at the pin changes in any way, either from high to low or from low to high.
   </p>
   <p class="pcust1">
    <span class="hemb">
     Falling edge
    </span>
    The voltage changes from high to low.
   </p>
   <p class="pcust1">
    <span class="hemb">
     Rising edge
    </span>
    The voltage changes from low to high.
   </p>
   <p class="calibre8">
    Consider which of these options would allow your code to respond to a button press. For example, if you had a button connected to GND and a microcontroller input with a pullup resistor, then the button press would switch the input from high to low. In this situation, you would typically use the falling edge interrupt option. Conversely, if you had a button connected between 5 V and the microcontroller input with a pulldown resistor, the button press would switch the input from low to high. In this case you could use a rising edge or any logic change interrupt.
   </p>
   <p class="calibre8">
    Overall, the choice of interrupt type will be determined by the external circuitry connected to the interrupt pin. I’ll demonstrate various types of interrupts in action in this chapter, so you can use these examples to help you determine what’s right for your own projects.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0701">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0701">
      Setting Up Interrupts in Code
     </a>
    </h3>
    <p class="paft">
     To use interrupts, first add the interrupt library as follows:
    </p>
    <pre>
     <p class="cls">
      #include &lt;avr/interrupt.h&gt;
     </p>
    </pre>
    <p class="calibre8">
     Next, you’ll need to set up a few registers—we’ll step through them one by one below. The first of these is the EICRA register, which we use to determine which of the four state changes the pin will respond to. Here’s the template for setting the EICRA register in any AVR program:
    </p>
    <pre>
     <p class="cls">
      EICRA = 0b0000
      <code class="i1">
       abcd
      </code>
      ;
     </p>
    </pre>
    <p class="calibre8">
     <span id="p117">
     </span>
     Set interrupt INT0 (pin 4) with bits
     <code class="i1">
      c
     </code>
     and
     <code class="i1">
      d
     </code>
     and interrupt INT1 (pin 5) with bits
     <code class="i1">
      a
     </code>
     and
     <code class="i1">
      b
     </code>
     , using the guidelines in
     <a class="url" href="nsp-boxall502581-0015.xhtml#tab0501">
      Table 5-1
     </a>
     .
    </p>
    <table id="tab0501" class="calibre13">
     <thead class="calibre14">
      <tr class="calibre15">
       <th colspan="3" class="calibre16">
        <p class="th1">
         <span class="calibre4">
          Table 5-1
         </span>
         : EICRA Register Option Bits
        </p>
       </th>
      </tr>
      <tr class="calibre15">
       <th scope="col" class="calibre16">
        <p class="tch">
         Bit a/c
        </p>
       </th>
       <th scope="col" class="calibre16">
        <p class="tch">
         Bit b/d
        </p>
       </th>
       <th scope="col" class="calibre16">
        <p class="tch">
         Interrupt type
        </p>
       </th>
      </tr>
     </thead>
     <tbody class="calibre17">
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         0
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         0
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Low level
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         0
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         1
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Any logic change
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         1
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         0
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Falling edge
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         1
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         1
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Rising edge
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p class="calibre8">
     For example, you could set up INT0 for a rising edge interrupt as follows, using the
     <code class="i1">
      c
     </code>
     and
     <code class="i1">
      d
     </code>
     bits:
    </p>
    <pre>
     <p class="cls">
      EICRA = 0b00000011; // INT0 rising edge
     </p>
    </pre>
    <p class="calibre8">
     Next, set up the EIMSK register, which is used to turn on the interrupt function, as follows:
    </p>
    <pre>
     <p class="cls">
      EIMSK = 0b000000
      <code class="i1">
       ab
      </code>
      ;
     </p>
    </pre>
    <p class="calibre8">
     Here, bit
     <code class="i1">
      a
     </code>
     is INT1 and bit
     <code class="i1">
      b
     </code>
     is INT0. Set each bit to 1 for on or 0 for off. For example, to turn the interrupt function on for INT0, use:
    </p>
    <pre>
     <p class="cls">
      EIMSK = 0b00000001;
     </p>
    </pre>
    <p class="calibre8">
     Since only the last bit is set to 1, only INT0 will be turned on.
    </p>
    <p class="calibre8">
     After setting the EICRA and EIMSK registers, enable interrupts in your code using this function call:
    </p>
    <pre>
     <p class="cls">
      sei();
     </p>
    </pre>
    <p class="calibre8">
     Don’t forget this step—if you skip it, even if you’ve set your registers properly, the interrupt won’t be triggered.
    </p>
    <p class="calibre8">
     Here’s a recap of the code required for interrupts so far:
    </p>
    <pre>
     <p class="cl1f">
      #include &lt;avr/interrupt.h&gt; // Enable the interrupt library
     </p>
     <p class="cl1">
      EICRA = 0b0000
      <code class="i1">
       abcd
      </code>
      ;        // Determine which state changes the interrupt pin responds to
     </p>
     <p class="cl1">
      EIMSK = 0b000000
      <code class="i1">
       ab
      </code>
      ;        // Turn on the required interrupt
     </p>
     <p class="cl1l">
      sei();    // Enable interrupts in your code
     </p>
    </pre>
    <p class="calibre8">
     Once you’ve prepared your AVR to respond to interrupts, you must define your ISR—the code that runs when the interrupt is triggered. The ISR is a custom function with the following structure:
    </p>
    <pre>
     <p class="clf">
      ISR (INT
      <code class="i1">
       x
      </code>
      _vect)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Code to be executed when an interrupt is triggered
     </p>
     <p class="cl">
      EIFR =
      <code class="i1">
       y
      </code>
      ;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     <span id="p118">
     </span>
     The parameter
     <code class="calibre23">
      INT
     </code>
     <code class="i1">
      x
     </code>
     <code class="calibre23">
      _vect
     </code>
     specifies the pin that the ISR responds to. When you pass a value to the function, replace the
     <code class="i1">
      x
     </code>
     in
     <code class="calibre23">
      INT
     </code>
     <code class="i1">
      x
     </code>
     <code class="calibre23">
      _vect
     </code>
     with
     <code class="calibre23">
      0
     </code>
     for INT0 or
     <code class="calibre23">
      1
     </code>
     for INT1. The body of the function is the code that executes when the interrupt is triggered. We always end this ISR code section with this command:
    </p>
    <pre>
     <p class="cls">
      EIFR =
      <code class="i1">
       y
      </code>
      ;
     </p>
    </pre>
    <p class="calibre8">
     This sets the external interrupt flag registers back to zero, telling the microcontroller that the interrupt code for this particular ISR is complete and the AVR can return to normal operation. If you are using only one interrupt, you can use the following values for
     <code class="i1">
      y
     </code>
     :
     <code class="calibre23">
      0b00000001
     </code>
     for INT0 and
     <code class="calibre23">
      0b00000010
     </code>
     for INT1. However, if your project is using both interrupts, if you set the EIFR register with an entire 8-bit value, you will alter both interrupts. Instead, you can use the following, which will just turn off one interrupt:
    </p>
    <pre>
     <p class="clf">
      EIFR &amp;= ~(1&lt;&lt;0); // Set interrupt flag register for INT0 to zero
     </p>
     <p class="cll">
      EIFR &amp;= ~(1&lt;&lt;1); // Set interrupt flag register for INT1 to zero
     </p>
    </pre>
    <p class="calibre8">
     This way of addressing register bits individually will be explained in detail in the
     <a class="url" href="nsp-boxall502581-0016.xhtml#ch06">
      next chapter
     </a>
     . In the meanwhile, let’s put pin-change interrupts to the test in the
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro22">
      following project
     </a>
     .
    </p>
    <p class="hd" id="pro22">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro22">
      <span class="ccust1">
       Project 22: Experimenting with Rising Edge Interrupts
      </span>
     </a>
    </p>
    <p class="paft">
     In this project, you’ll first program your microcontroller to rapidly blink an LED, then add logic so that pressing a button interrupts the blinking LED and runs some other code, keeping the LED on for two seconds before it returns to its blinking pattern. You’ll accomplish this using a rising edge interrupt.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0702">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0702">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • One LED
     </li>
     <li class="bl">
      • One 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistor
     </li>
     <li class="bl">
      • One pushbutton
     </li>
     <li class="bll">
      • One 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistor
     </li>
    </ul>
    <p class="calibre8">
     <span id="p119">
     </span>
     First, assemble the circuit shown in
     <a class="url" href="nsp-boxall502581-0015.xhtml#f05001">
      Figure 5-1
     </a>
     .
    </p>
    <div class="figure" id="f05001">
     <p class="fig">
      <img alt="Schematic diagram for Project 22" height="1200" src="images/nsp-boxall502581-f05001.jpg" width="1135" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 5-1:
       </span>
       The main circuit for
       <a class="url" href="nsp-boxall502581-0015.xhtml#pro22">
        Project 22
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     The resistor and button are in the pulldown configuration that I introduced in
     <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
      Chapter 3
     </a>
     . When you press the button the current will flow to pin 4, changing its state from low to high. This rising edge state change will trigger the interrupt.
    </p>
    <p class="calibre8">
     With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard, as you did in previous projects.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0703">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0703">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window and navigate to the
     <i class="calibre5">
      Project 22
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 5
     </i>
     folder, then enter the command
     <code class="b">
      make flash
     </code>
     . The toolchain should compile the program file and upload the data to the microcontroller, at which point the LED should begin to blink rapidly, turning on
     <span id="p120">
     </span>
     and off every 50 milliseconds. Press the button quickly (don’t leave your finger on it for long, since this will trigger switch bouncing), and the LED should stay on for two seconds, then resume blinking.
    </p>
    <p class="calibre8">
     Open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro22">
      Project 22
     </a>
     to see how this code works:
    </p>
    <pre>
     <p class="clf">
      // Project 22 - Experimenting with Rising Edge Interrupts
     </p>
     <p class="clf">
      // Blink PORTB. If button pressed, turn on PORTB for 2 seconds.
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/interrupt.h&gt;
     </p>
     <p class="clf">
      ISR (INT0_vect)
     </p>
     <p class="cl">
      {                     // Code to be executed when interrupt is triggered
     </p>
     <p class="cl">
      PORTB = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ PORTB = 0b00000000;
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ EIFR = 0b00000001; // Clear external interrupt flag register
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void startInt0()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Initialize interrupt 0 (PD2/INT0/pin 4)
     </p>
     <p class="cl">
      // Rising edge (LOW to HIGH at pin 4)
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ EICRA = 0b00000011;
     </p>
     <p class="cl">
      // Turn on interrupt INT0
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ EIMSK = 0b00000001;
     </p>
     <p class="cl">
      // Turn on global interrupt enable flag in order for interrupts to be processed
     </p>
     <p class="cl">
      sei();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Declare global variables
     </p>
     <p class="cl">
      // Set up GPIO pins etc.
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ DDRB = 0b11111111; // Set PORTB register as outputs
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ DDRD = 0b00000000; // Set PORTD pins 4 and 5 as inputs
     </p>
     <p class="clf">
      // Initialize interrupt
     </p>
     <p class="cl">
      startInt0();
     </p>
     <p class="clf">
      for(;;)
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ {
     </p>
     <p class="cl">
      // Blink LED connected to PB7 (pin 10)
     </p>
     <p class="cl">
      PORTB = 0b00000001;
     </p>
     <p class="cl">
      _delay_ms(50);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      _delay_ms(50);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     <span id="p121">
     </span>
     This code defines a
     <code class="calibre23">
      startInt0()
     </code>
     function to initialize the interrupts. Within this function, we first set the EICRA register so that INT0 reacts to a rising edge interrupt
     <!--<ccust1>3</ccust1>-->
     ❸, then set the EIMSK register to turn INT0 on
     <!--<ccust1>4</ccust1>-->
     ❹, and finally call
     <code class="calibre23">
      sei()
     </code>
     to enable interrupts. In the main section of the code, we set up PORTB pins as outputs to control the LED
     <!--<ccust1>5</ccust1>-->
     ❺ and set PORTD pins as inputs
     <!--<ccust1>6</ccust1>-->
     ❻. PORTD includes digital pin 4, which will act as input for the interrupt INT0.
    </p>
    <p class="calibre8">
     Once everything is initialized, the for loop
     <!--<ccust1>7</ccust1>-->
     ❼ makes the LED blink on and off. Because there’s an interrupt, when you press the button, the resulting rising edge triggers the hardware interrupt INT0. This tells the AVR to stop blinking the LED and run the code in the ISR
     <!--<ccust1>1</ccust1>-->
     ❶. When the ISR code has finished, the EIFR register is set to 0
     <!--<ccust1>2</ccust1>-->
     ❷ and the LED returns to rapidly blinking as normal.
    </p>
    <p class="calibre8">
     Congratulations! You’ve just seen the most common kind of interrupt in action. Less often, you’ll need to detect when current stops flowing to the microcontroller, which you can do using a falling edge interrupt. You’ll try this out in the
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro23">
      next project
     </a>
     .
    </p>
    <p class="hd" id="pro23">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro23">
      <span class="ccust1">
       Project 23: Experimenting with Falling Edge Interrupts
      </span>
     </a>
    </p>
    <p class="paft">
     This project has the same result as
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro22">
      Project 22
     </a>
     , but this time the circuit uses the pullup configuration introduced in
     <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
      Chapter 3
     </a>
     . By default, there will be current at digital pin 4. When you press the button, current should stop flowing to pin 4, changing its state from high to low to trigger the falling edge interrupt.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0704">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0704">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • One LED
     </li>
     <li class="bl">
      • One 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistor
     </li>
     <li class="bl">
      • One pushbutton
     </li>
     <li class="bll">
      • One 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistor
     </li>
    </ul>
    <p class="calibre8">
     Start by assembling the circuit shown in
     <a class="url" href="nsp-boxall502581-0015.xhtml#f05002">
      Figure 5-2
     </a>
     .
    </p>
    <div class="figure" id="f05002">
     <p class="fig">
      <span id="p122">
      </span>
      <img alt="Schematic diagram for Project 23" height="1200" src="images/nsp-boxall502581-f05002.jpg" width="1135" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 5-2:
       </span>
       The main circuit for
       <a class="url" href="nsp-boxall502581-0015.xhtml#pro23">
        Project 23
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard as you did in previous projects.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0705">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0705">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 23
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 5
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Once the project’s code has been uploaded, the LED should begin to blink rapidly. Quickly press the button. The LED should stay on for two seconds, then resume blinking.
    </p>
    <p class="calibre8">
     To see how this works, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro23">
      Project 23
     </a>
     :
    </p>
    <pre>
     <p class="clf">
      // Project 23 - Experimenting with Falling Edge Interrupts
     </p>
     <p class="clf">
      // Blink PORTB. If button is pressed, turn on PORTB for 2 seconds.
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/interrupt.h&gt;
     </p>
     <p class="clf">
      ISR (INT0_vect) {     // Code to be executed when interrupt is triggered
     </p>
     <p class="cl">
      PORTB = 0b11111111;
     </p>
     <p class="cl">
      <span id="p123">
      </span>
      _delay_ms(2000);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      EIFR = 0b00000001;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void startInt0()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Initialize interrupt 0 (PD2/INT0/pin 4)
     </p>
     <p class="cl">
      // Falling edge (HIGH to LOW at pin 4)
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ EICRA = 0b00000010;
     </p>
     <p class="cl">
      // Turn on interrupt INT0
     </p>
     <p class="cl">
      EIMSK = 0b00000001;
     </p>
     <p class="cl">
      // Turn on global interrupt enable flag for interrupts to be processed
     </p>
     <p class="cl">
      sei();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Declare global variables
     </p>
     <p class="cl">
      // Set up GPIO pins etc.
     </p>
     <p class="cl">
      DDRB = 0b11111111; // Set PORTB register as outputs
     </p>
     <p class="cl">
      DDRD = 0b00000000; // Set PORTD pins 4 and 5 as inputs
     </p>
     <p class="clf">
      // Initialize interrupt
     </p>
     <p class="cl">
      startInt0();
     </p>
     <p class="clf">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000001;
     </p>
     <p class="cl">
      _delay_ms(50);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      _delay_ms(50);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     The code for this project is identical to that of
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro22">
      Project 22
     </a>
     , except for one change: we set the EICRA register to
     <code class="calibre23">
      0b00000010
     </code>
     instead of
     <code class="calibre23">
      0b00000011
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶. Per
     <a class="url" href="nsp-boxall502581-0015.xhtml#tab0501">
      Table 5-1
     </a>
     , the last two bits (
     <code class="calibre23">
      10
     </code>
     ) set INT0 to the falling edge type of interrupt. EIMSK stays the same, since we’re still using INT0 as the interrupt pin, and as usual we call
     <code class="calibre23">
      sei()
     </code>
     to enable the interrupt.
    </p>
    <p class="calibre8">
     Play with these projects to familiarize yourself with both rising and falling edge interrupts. Once you feel comfortable using both options for digital inputs, you can choose whether to trigger an interrupt with a high or low signal in your own projects, depending on how the circuit you’re working with is built. This may sound like a trivial choice now, but it’ll become important as you create more complicated AVR-based projects. In some situations, you can’t choose the hardware or the circuit, and you’ll have to work around their limitations using code.
    </p>
    <p class="calibre8">
     Now let’s try something more interesting. As I mentioned earlier, the ATmega328P-PU has two interrupt pins. In the
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro24">
      next project
     </a>
     , you’ll use both to make the microcontroller respond to two different interrupts.
    </p>
    <p class="hd" id="pro24">
     <span class="page" id="p124">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro24">
      <span class="ccust1">
       Project 24: Experimenting with Two Interrupts
      </span>
     </a>
    </p>
    <p class="paft">
     This project uses two buttons to allow you to trigger two interrupts for different responses. One button triggers a rising edge interrupt and turns on the LED for one second, while the other triggers a falling edge interrupt that turns on the LED for two seconds.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0706">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0706">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • One LED
     </li>
     <li class="bl">
      • One 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistor
     </li>
     <li class="bl">
      • Two pushbuttons
     </li>
     <li class="bll">
      • Two 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistors
     </li>
    </ul>
    <p class="calibre8">
     Assemble the circuit shown in
     <a class="url" href="nsp-boxall502581-0015.xhtml#f05003">
      Figure 5-3
     </a>
     .
    </p>
    <div class="figure" id="f05003">
     <p class="fig">
      <img alt="Schematic diagram for Project 24" height="1200" src="images/nsp-boxall502581-f05003.jpg" width="1067" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 5-3:
       </span>
       The main circuit for
       <a class="url" href="nsp-boxall502581-0015.xhtml#pro24">
        Project 24
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p125">
     </span>
     With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard as in the previous projects.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0707">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0707">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 24
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 5
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . As in the previous two projects, once the code has been uploaded the LED should start to blink rapidly. Press the button connected to INT0 (digital pin 4), and the LED should stay on for one second. Press the button connected to INT1 (digital pin 5), and the LED should stay on for two seconds.
    </p>
    <p class="calibre8">
     To see how the code handles these interrupts, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro24">
      Project 24
     </a>
     :
    </p>
    <pre>
     <p class="clf">
      // Project 24 - Experimenting with Two Interrupts
     </p>
     <p class="clf">
      // PORTB blinks, INT0 rising interrupt, INT1 falling interrupt
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/interrupt.h&gt;
     </p>
     <p class="clf">
      ISR (INT0_vect)
     </p>
     <p class="cl">
      {                     // Code to be executed when interrupt INT0 is triggered
     </p>
     <p class="cl">
      PORTB = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      EIFR &amp;= ~(1&lt;&lt;0);   // Set interrupt flag register for INT0 to zero
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      ISR (INT1_vect)
     </p>
     <p class="cl">
      {                     // Code to be executed when interrupt INT1 is triggered
     </p>
     <p class="cl">
      PORTB = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      EIFR &amp;= ~(1&lt;&lt;1);   // Set interrupt flag register for INT1 to zero
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void startInts()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Initialize interrupt 0 (PD2/INT0/pin 4)
     </p>
     <p class="cl">
      // Rising edge (LOW to HIGH at pin 4)
     </p>
     <p class="cl">
      // Initialize interrupt 1 (PD3/INT1/pin 5)
     </p>
     <p class="cl">
      // Falling edge (HIGH to LOW at pin 5)
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ EICRA = 0b00001011;
     </p>
     <p class="clf">
      // Turn on interrupts INT0 and INT1
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ EIMSK = 0b00000011;
     </p>
     <p class="cl">
      // Turn on global interrupt enable flag for interrupts to be processed
     </p>
     <p class="cl">
      sei();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Declare global variables
     </p>
     <p class="cl">
      <span id="p126">
      </span>
      // Set up GPIO pins etc.
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ DDRB = 0b11111111; // Set PORTB register as outputs
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ DDRD = 0b00000000; // Set PORTD pins 4 and 5 as inputs
     </p>
     <p class="cl">
      // Initialize interrupts
     </p>
     <p class="cl">
      startInts();
     </p>
     <p class="clf">
      for(;;)
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ {
     </p>
     <p class="cl">
      PORTB = 0b00000001;
     </p>
     <p class="cl">
      _delay_ms(50);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      _delay_ms(50);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code is similar to the code for
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro22">
      Projects 22
     </a>
     and
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro23">
      23
     </a>
     , again with a little modification. As usual, we start by defining a
     <code class="calibre23">
      startInts()
     </code>
     function to initialize the interrupts. Inside this function, we set the EICRA register to respond to each interrupt
     <!--<ccust1>1</ccust1>-->
     ❶. Remember that the register is set with the formula
     <code class="calibre23">
      0b0000
     </code>
     <code class="i1">
      abcd
     </code>
     , where bits
     <code class="i1">
      a
     </code>
     and
     <code class="i1">
      b
     </code>
     correspond to pin 5 and bits
     <code class="i1">
      c
     </code>
     and
     <code class="i1">
      d
     </code>
     correspond to pin 6. Here, we’ve set EICRA so that INT0 reacts to a rising edge interrupt and INT1 reacts to a falling edge interrupt (
     <code class="calibre23">
      0b00001011
     </code>
     ). Next, we set the EIMSK register to turn on both INT0 and INT1 by setting the last two bits to 1
     <!--<ccust1>2</ccust1>-->
     ❷, then we call
     <code class="calibre23">
      sei()
     </code>
     to enable interrupts.
    </p>
    <p class="calibre8">
     In the main section of the code, we set up PORTB as outputs so that the code will control the LED
     <!--<ccust1>3</ccust1>-->
     ❸. We also set up PORTD as inputs to cover digital pins 4 and 5, which will act as inputs for INT0 and INT1, respectively
     <!--<ccust1>4</ccust1>-->
     ❹. Once everything is initialized, the code in the
     <code class="calibre23">
      for
     </code>
     loop
     <!--<ccust1>5</ccust1>-->
     ❺ will cause the LED to blink on and off. However, when one of the buttons is pressed, the corresponding interrupt will trigger and the code in the interrupt’s ISR will run.
    </p>
    <p class="calibre8">
     When planning projects with multiple interrupts, remember that an interrupt cannot be called by another interrupt. That is, if one interrupt’s ISR code is running, triggering another interrupt will not affect the operation of that ISR. You can’t interrupt an interrupt!
    </p>
    <p class="calibre8">
     What if you need to use more than two interrupt pins, or can’t use digital pins 4 and 5 but still need your project to respond to state change triggers? The solution is to use pin-change interrupts.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0702">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0702">
     Pin-Change Interrupts
    </a>
   </h2>
   <p class="paft">
    While using the external interrupts INT0 and INT1 is simple, straightforward, and gives you lots of control, working with just two interrupts is a huge limitation. Using
    <i class="calibre5">
     pin-change interrupts
    </i>
    is a little trickier, but gives you as many interrupts as you have pins.
   </p>
   <p class="calibre8">
    Pin-change interrupts can only tell you if a pin has changed state—they can’t provide any details about that change of state. While an external interrupt can detect a change from low to high or high to low, a pin-change
    <span id="p127">
    </span>
    interrupt can only detect that a change happened. That means any change in state will trigger the interrupt, and you’ll have to decide in your code if you want to respond to that change.
   </p>
   <p class="calibre8">
    The pins used for pin-change interrupts are organized into three banks:
   </p>
   <p class="pcust1">
    <span class="hemb">
     Bank 0
    </span>
    Includes PCINT0 through PCINT7.
   </p>
   <p class="pcust1">
    <span class="hemb">
     Bank 1
    </span>
    Includes PCINT8 through PCINT14.
   </p>
   <p class="pcust1">
    <span class="hemb">
     Bank 2
    </span>
    Includes PCINT16 through PCINT23.
   </p>
   <p class="calibre8">
    PCINT stands for
    <i class="calibre5">
     pin-change interrupt
    </i>
    . Each bank has its own ISR code, giving you three types of level changes that you can use with their respective pins. This gives you more flexibility, but it means you can’t assume that each ISR function corresponds to a single pin. Rather, each ISR function responds to any state change in any of the pins in its corresponding bank. Thus, your code will have to determine not only what the state change was but which pin it came from before it can respond appropriately. Note that there is no PCINT15.
   </p>
   <p class="pcust">
    <span class="ccust">
     Note
    </span>
    PCINT numbers are not the same as pin numbers: for example, PCINT8 is pin 23, not pin 8. Refer to the pinout diagram in
    <a class="url" href="nsp-boxall502581-0015.xhtml#f05004">
     Figure 5-4
    </a>
    for each PCINT value’s pin number, and make sure not to confuse the two numbers in your code. Each bank’s byte in binary represents the order of pins in the bank, from highest to lowest.
   </p>
   <p class="calibre8">
    You can match the three PCINT
    <i class="calibre5">
     xx
    </i>
    banks to physical pin numbers using the ATmega328P-PU’s pinout diagram, shown in
    <a class="url" href="nsp-boxall502581-0015.xhtml#f05004">
     Figure 5-4
    </a>
    .
   </p>
   <div class="figure" id="f05004">
    <p class="fig">
     <img alt="Diagram of ATmega328P-PU microcontroller with pins and their functions" height="805" src="images/nsp-boxall502581-f05004.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 5-4:
      </span>
      ATmega328P-PU pinout diagram
     </p>
    </div>
   </div>
   <p class="calibre8">
    For example, Bank 0 responds to PCINT0–PCINT7, meaning you can trigger it with pins 15–19 at the bottom right of
    <a class="url" href="nsp-boxall502581-0015.xhtml#f05004">
     Figure 5-4
    </a>
    and pins 9, 10, and 14 at the bottom left.
   </p>
   <p class="calibre8">
    Using pin-change interrupts in your code is similar to using external interrupts. Once again, first include the interrupt library.
   </p>
   <pre>
    <p class="cls">
     <span id="p128">
     </span>
     #include &lt;avr/interrupt.h&gt;
    </p>
   </pre>
   <p class="calibre8">
    Next, set the PCICR register to turn on the required PCI (pin-change interrupt) banks, using this formula:
   </p>
   <pre>
    <p class="cls">
     PCICR = 0b00000
     <code class="i1">
      xyz
     </code>
     ;
    </p>
   </pre>
   <p class="calibre8">
    Bank 0 is set with bit
    <code class="i1">
     z
    </code>
    , bank 1 with bit
    <code class="i1">
     y
    </code>
    , and bank 2 with bit
    <code class="i1">
     x
    </code>
    . For example, to turn on banks 0 and 2, you would use:
   </p>
   <pre>
    <p class="cls">
     PCICR = 0b00000101;
    </p>
   </pre>
   <p class="calibre8">
    Remember that each bank can respond to several pins, so you’ll need to select which pins in each of the banks can be used for an interrupt by turning on the interrupt function corresponding to each pin you select. Each bank has its own interrupt function that you can turn on with the registers PCMSK0, PCMSK1, and PCMSK2. Pins are turned on or off with a 1 or 0 in that pin’s spot. To use pin 15 in bank 0, pin 23 in bank 1, and pin 13 in bank 2, you’d set the PCMSK
    <i class="calibre5">
     x
    </i>
    registers like this:
   </p>
   <pre>
    <p class="clf">
     PCMSK0 = 0b00000010; // We'll use PCINT1 (pin 15) for bank 0 ...
    </p>
    <p class="cl">
     PCMSK1 = 0b00000001; // and use PCINT8 (pin 23) for bank 1 ...
    </p>
    <p class="cll">
     PCMSK2 = 0b10000000; // and use PCINT23 (pin 13) for bank 2
    </p>
   </pre>
   <p class="calibre8">
    Once you’ve selected the pins in each bank that should trigger an interrupt, enable the interrupts with the line:
   </p>
   <pre>
    <p class="cls">
     sei();
    </p>
   </pre>
   <p class="calibre8">
    Finally, define your ISR. Each PCI has its own ISR with the following structure:
   </p>
   <pre>
    <p class="clf">
     ISR (PCINT
     <code class="i1">
      x
     </code>
     _vect)
    </p>
    <p class="cl">
     {
    </p>
    <p class="cl">
     // Code to be executed when interrupt is triggered
    </p>
    <p class="cl">
     EIFR &amp;= ~(1&lt;&lt;
     <code class="i1">
      x
     </code>
     ); // Set interrupt flag register to zero
    </p>
    <p class="cll">
     }
    </p>
   </pre>
   <p class="calibre8">
    Replace the
    <code class="i1">
     x
    </code>
    in
    <code class="calibre23">
     PCINT
    </code>
    <code class="i1">
     x
    </code>
    <code class="calibre23">
     _vect
    </code>
    with
    <code class="calibre23">
     0
    </code>
    for bank 0,
    <code class="calibre23">
     1
    </code>
    for bank 1, and
    <code class="calibre23">
     2
    </code>
    for bank 2, and you’re ready to add your interrupt code. We always end this ISR code section with the following command:
   </p>
   <pre>
    <p class="cls">
     PCIFR =
     <code class="i1">
      y
     </code>
     ;
    </p>
   </pre>
   <p class="calibre8">
    This sets the pin-change interrupt flag register back to zero, which tells the microcontroller that the interrupt code for that particular bank has completed and that it can return to running the code in the main loop as normal. You can use the following values for
    <code class="i1">
     y
    </code>
    in order to set the pin-change interrupt flag:
    <code class="calibre23">
     0b00000001
    </code>
    for bank 0,
    <code class="calibre23">
     0b00000010
    </code>
    for bank 1, and
    <code class="calibre23">
     0b00000100
    </code>
    for bank 2.
   </p>
   <p class="calibre8">
    You’ll put pin-change interrupts to the test in the following project.
   </p>
   <p class="hd" id="pro25">
    <span class="page" id="p129">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro25">
     <span class="ccust1">
      Project 25: Experimenting with Pin-Change Interrupts
     </span>
    </a>
   </p>
   <p class="paft">
    This project expands on the previous ones, using three buttons, in conjunction with a pin on each of the three PCI banks, to demonstrate how to use pin-change interrupts. Pressing each button should trigger a different interrupt, which should turn the LED on for a certain period of time.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0708">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0708">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • One LED
     </li>
     <li class="bl">
      • One 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistor
     </li>
     <li class="bl">
      • Three pushbuttons
     </li>
     <li class="bll">
      • Three 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistors
     </li>
    </ul>
    <p class="calibre8">
     To begin, assemble the circuit shown in
     <a class="url" href="nsp-boxall502581-0015.xhtml#f05005">
      Figure 5-5
     </a>
     .
    </p>
    <div class="figure" id="f05005">
     <p class="fig">
      <img alt="Schematic diagram for Project 25" height="1200" src="images/nsp-boxall502581-f05005.jpg" width="1134" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 5-5:
       </span>
       The main circuit for
       <a class="url" href="nsp-boxall502581-0015.xhtml#pro25">
        Project 25
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p130">
     </span>
     With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard as you have for the previous projects.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0709">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0709">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 25
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 5
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     to upload the project’s code, as usual. Once the code has uploaded, the LED should start to blink rapidly. Pressing the different buttons should turn the LED on for one, two, or three seconds, as defined in the ISR for each pin-change interrupt bank.
    </p>
    <p class="calibre8">
     To see how this works, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro25">
      Project 25
     </a>
     :
    </p>
    <pre>
     <p class="clf">
      // Project 25 - Experimenting with Pin-Change Interrupts
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/interrupt.h&gt;
     </p>
     <p class="clf">
      ISR (PCINT0_vect)
     </p>
     <p class="cl">
      {   // Code to be executed when PCI bank 0 PCINT1 pin 15 is triggered
     </p>
     <p class="cl">
      PORTB = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      PCIFR = 0b00000001;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      ISR (PCINT1_vect)
     </p>
     <p class="cl">
      {   // Code to be executed when PCI bank 1 PCINT8 pin 23 is triggered
     </p>
     <p class="cl">
      PORTB = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      PCIFR = 0b00000010;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      ISR (PCINT2_vect)
     </p>
     <p class="cl">
      {   // Code to be executed when PCI bank 2 PCINT23 pin 13 is triggered
     </p>
     <p class="cl">
      PORTB = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(3000);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      PCIFR = 0b00000100;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void startInts()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ PCICR = 0b00000111;  // Activate all three PCIs
     </p>
     <p class="cl">
      PCMSK0 = 0b00000010; // We'll use PCINT1 (pin 15) for bank 0 ...
     </p>
     <p class="cl">
      PCMSK1 = 0b00000001; // and use PCINT8 (pin 23) for bank 1 ...
     </p>
     <p class="cl">
      PCMSK2 = 0b10000000; // and use PCINT23 (pin 13) for bank 2
     </p>
     <p class="cl">
      sei();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set up GPIO pins etc.
     </p>
     <p class="cl">
      <span id="p131">
      </span>
      <!--<ccust1>2</ccust1>-->
      ❷ DDRB = 0b11111101;  // Set up PORTB register (pin 15 input, rest outputs)
     </p>
     <p class="cl">
      DDRC = 0b00000000;  // Set up PORTC register (all inputs)
     </p>
     <p class="cl">
      DDRD = 0b01111111;  // Set up PORTD register (pin 13 input, rest outputs)
     </p>
     <p class="clf">
      // Initialize interrupts
     </p>
     <p class="cl">
      startInts();
     </p>
     <p class="clf">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Blink LED connected to PB7 (pin 10)
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ PORTB = 0b00000001;
     </p>
     <p class="cl">
      _delay_ms(50);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      _delay_ms(50);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code has the same structure as the code for the external interrupt projects. First, we define a
     <code class="calibre23">
      startInts()
     </code>
     function to initialize the interrupts. Inside this function, we set the PCICR register to enable all three banks of PCIs
     <!--<ccust1>1</ccust1>-->
     ❶; then we set the physical pins to use as each bank’s interrupt pin using the three following lines and make a call to
     <code class="calibre23">
      sei()
     </code>
     to enable interrupts.
    </p>
    <p class="calibre8">
     In the main section of the code, we set up PORTB and PORTD so that the LED pin is an output and PORTC as inputs for the interrupt pins
     <!--<ccust1>2</ccust1>-->
     ❷. Once the initializations have taken place, the code in the
     <code class="calibre23">
      for
     </code>
     loop
     <!--<ccust1>3</ccust1>-->
     ❸ will make the LED blink on and off. However, when you press one of the buttons, you’ll trigger the interrupt for the corresponding PCI bank, running the code in that bank’s matching ISR. We end the code run for each interrupt by setting the PCIFR flag to 1 for that particular bank.
    </p>
    <p class="calibre8">
     At this point, you’ve seen how to use interrupts with digital inputs to activate code on demand when required by the user. To finish off this chapter’s experiments, I’ll show you how to use interrupts in a more practical situation.
    </p>
    <p class="hd" id="pro26">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro26">
      <span class="ccust1">
       Project 26: Creating an Up/Down Counter Using Interrupts
      </span>
     </a>
    </p>
    <p class="paft">
     This project combines what you’ve learned about interrupts with sending data to your computer via the USART (covered in
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro18">
      Project 18
     </a>
     in
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     ). You’ll build a counting device that uses two buttons to accept user input: one button increases the count by one, and the other decreases it. Each button will trigger a rising edge interrupt and call a matching ISR to add to or subtract from the counter’s tally.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0710">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0710">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      <span id="p132">
      </span>
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • USB to serial converter
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • Two pushbuttons
     </li>
     <li class="bll">
      • Two 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistors
     </li>
    </ul>
    <p class="calibre8">
     Assemble the circuit shown in
     <a class="url" href="nsp-boxall502581-0015.xhtml#f05006">
      Figure 5-6
     </a>
     .
    </p>
    <div class="figure" id="f05006">
     <p class="fig">
      <img alt="Schematic diagram for Project 26" height="1042" src="images/nsp-boxall502581-f05006.jpg" width="1083" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 5-6:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0015.xhtml#pro26">
        Project 26
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard as in the previous projects. Next, connect your USB-to-serial converter to your computer, just as you did in
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     .
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0711">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0711">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 26
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 5
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     to upload the project’s code as usual. Now run your terminal software on your computer, as you did in
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     , and click the
     <b class="calibre4">
      Connect
     </b>
     button. After a moment, the terminal software should display the value of the counting variable.
    </p>
    <p class="calibre8">
     Try pressing each button. The counter value should increase or decrease with each button press, giving you output like that shown in
     <a class="url" href="nsp-boxall502581-0015.xhtml#f05007">
      Figure 5-7
     </a>
     .
    </p>
    <div class="figure" id="f05007">
     <p class="fig">
      <span id="p133">
      </span>
      <img alt="A screenshot of the output of Project 26 in the terminal software on Windows 11" height="1200" src="images/nsp-boxall502581-f05007.jpg" width="1051" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 5-7:
       </span>
       Our counter in action
      </p>
     </div>
    </div>
    <p class="calibre8">
     In this figure, the counter doesn’t always appear to increase or decrease by just one. That’s because the count is only updated every second, and you can press a button many times in the span of one second.
    </p>
    <p class="calibre8">
     To see how this is implemented, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0015.xhtml#pro26">
      Project 26
     </a>
     :
    </p>
    <pre>
     <p class="clf">
      // Project 26 - Creating an Up/Down Counter Using Interrupts
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdlib.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/interrupt.h&gt;
     </p>
     <p class="clf">
      #define USART_BAUDRATE 4800
     </p>
     <p class="cl">
      #define UBRR_VALUE 12
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ volatile uint8_t i = 100; // Initial value for counter
     </p>
     <p class="cl">
      void USARTInit(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set baud rate registers
     </p>
     <p class="cl">
      UBRR0H = (uint8_t)(UBRR_VALUE&gt;&gt;8);
     </p>
     <p class="cl">
      UBRR0L = (uint8_t)UBRR_VALUE;
     </p>
     <p class="clf">
      // Set data frame format to 8 data bits, no parity, 1 stop bit
     </p>
     <p class="cl">
      <span id="p134">
      </span>
      UCSR0C |= (1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
     </p>
     <p class="clf">
      // Enable transmission and reception
     </p>
     <p class="cl">
      UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void USARTSendByte(uint8_t u8Data)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait while previous byte is sent
     </p>
     <p class="cl">
      while(!(UCSR0A&amp;(1&lt;&lt;UDRE0))){};
     </p>
     <p class="cl">
      // Transmit data
     </p>
     <p class="cl">
      UDR0 = u8Data;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void sendString(char myString[])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t a = 0;
     </p>
     <p class="cl">
      while (myString[a])
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      USARTSendByte(myString[a]);
     </p>
     <p class="cl">
      a++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ ISR (INT0_vect)
     </p>
     <p class="cl">
      {                   // Code to be executed when interrupt INT0 is triggered
     </p>
     <p class="cl">
      i = i - 1;       // Subtract one from the counter
     </p>
     <p class="cl">
      EIFR &amp;= ~(1&lt;&lt;0); // Set interrupt flag register for INT0 to zero
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ ISR (INT1_vect)
     </p>
     <p class="cl">
      {                   // Code to be executed when interrupt INT1 is triggered
     </p>
     <p class="cl">
      i = i + 1;       // Add one to the counter
     </p>
     <p class="cl">
      EIFR &amp;= ~(1&lt;&lt;1); // Set interrupt flag register for INT1 to zero
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>4</ccust1>-->
      ❹ void startInts()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Initialize interrupt 0 (PD2/INT0/pin 4)
     </p>
     <p class="cl">
      // Rising edge (LOW to HIGH at pin 4)
     </p>
     <p class="cl">
      // Initialize interrupt 1 (PD3/INT1/pin 5)
     </p>
     <p class="cl">
      // Rising edge (LOW to HIGH at pin 5)
     </p>
     <p class="cl">
      EICRA = 0b00001111;
     </p>
     <p class="clf">
      // Turn on interrupts INT0 and INT1
     </p>
     <p class="cl">
      EIMSK = 0b00000011;
     </p>
     <p class="cl">
      // Turn on global interrupt enable flag
     </p>
     <p class="cl">
      sei();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      char a[10] = "Count - "; // Make sure you have " instead of ”
     </p>
     <p class="cl">
      char s[10] = "";         // For our itoa() conversion used in the main loop
     </p>
     <p class="cl">
      char newline[] = "\r\n";
     </p>
     <p class="clf">
      <span id="p135">
      </span>
      // Set up pins 4 and 5 as inputs for INT0 and INT1
     </p>
     <p class="cl">
      DDRD = 0b00000000;
     </p>
     <p class="clf">
      // Initialize interrupts
     </p>
     <p class="cl">
      startInts();
     </p>
     <p class="clf">
      // Initialize USART
     </p>
     <p class="cl">
      USARTInit();
     </p>
     <p class="clf">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Send the value of our counter to the USART for display on the PC
     </p>
     <p class="cl">
      itoa(i, s, 10);
     </p>
     <p class="cl">
      sendString(a);
     </p>
     <p class="cl">
      sendString(s);
     </p>
     <p class="cl">
      sendString(newline);
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This project demonstrates how to use interrupts to receive user input, using much less code than if we had to check for a button press in every cycle of the main code. First we set up the library initialization and functions required to use the USART. Then we declare the
     <code class="calibre23">
      i
     </code>
     variable
     <!--<ccust1>1</ccust1>-->
     ❶, which stores the value of the counter, followed by the convenient functions used in the
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      last chapter
     </a>
     to send text and numbers via the USART to the PC.
    </p>
    <p class="calibre8">
     Both the main code and the ISR functions need to be able to access the
     <code class="calibre23">
      i
     </code>
     variable, which is why it’s defined outside the
     <code class="calibre23">
      int main(void)
     </code>
     section. Declaring a variable outside the main code makes it a
     <i class="calibre5">
      global variable
     </i>
     , which means any part of the code can access it, not just the code in the particular function in which the variable could be declared. When you declare a global variable, you should place the
     <code class="calibre23">
      volatile
     </code>
     keyword before its data type to let the compiler know that it could change at any time, so the microcontroller needs to reload it from memory every time the program uses it.
    </p>
    <p class="calibre8">
     This project uses pins 4 and 5 as external rising edge interrupts, so next we define the code to run when the INT0
     <!--<ccust1>2</ccust1>-->
     ❷ and INT1
     <!--<ccust1>3</ccust1>-->
     ❸ interrupts are triggered and initialize them using EICRA and EIMSK
     <!--<ccust1>4</ccust1>-->
     ❹. Once the main code starts running, it should send the value of the counter variable to your PC via the USART every second. Thanks to the power of the interrupts (and the buttons connected to them), each time you trigger one of the interrupts, the relevant ISR code should add or subtract one to or from the counter variable, depending on which button is pressed. You can test this by pressing either button on and off rapidly; as the variable changes, the updated value should display in your terminal.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0703">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0703">
     Final Notes on Interrupts
    </a>
   </h2>
   <p class="paft">
    Working with hardware interrupts can give your AVR-based projects more options to complete tasks on demand, instead of during a preprogrammed
    <span id="p136">
    </span>
    sequence of events. To simplify this introduction to interrupts, this chapter focused on creating circuits that react to button presses. However, in real-world projects, you’ll more often program interrupts to respond to limit switches in machinery or signals from sensors to help your project make a decision.
   </p>
   <p class="calibre8">
    When using interrupts, always declare the pins used to trigger interrupts as inputs using a
    <code class="calibre23">
     DDR
    </code>
    <code class="i1">
     x
    </code>
    function, or the microcontroller won’t detect the trigger. Also declare any variables used in both your main code and ISRs as
    <code class="calibre23">
     volatile
    </code>
    and make them global variables.
   </p>
   <p class="calibre8">
    The
    <a class="url" href="nsp-boxall502581-0016.xhtml#ch06">
     next chapter’s
    </a>
    projects expand on interrupts, showing you how to use them to run functions after a preset period of time.
   </p>
  </div>
 </div>
</div></body></html>