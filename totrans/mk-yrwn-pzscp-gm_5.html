<html><head></head><body>
<p class="timage5"><span epub:type="pagebreak" id="page_101"/><img alt="image" src="../images/pg101-01.jpg"/></p>&#13;
<h2 class="h2a" id="ch05"><span class="big">5</span><br/>Robot Heist: Creating Consequences for Losing</h2>&#13;
<p class="noindent">Now that our game has lasers, danger is a possibility, which means there’s the potential for the player to <em>lose</em>. What does losing mean in a game?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_102"/>In <em>Herding Cats</em>, the player could get stuck and have to restart the level, which was a form of losing. In that case, when players make a mistake, they need to try again. So one way to think of losing is as a process by which the player learns. Every time the player makes a mistake, they learn what not to do next time. We used the same thought process when we were figuring out how to make our lasers work. A good game always makes it clear to the player what they did wrong.</p>&#13;
<p class="indent">Do all games need to let the player lose? Not at all! Some games are just about exploring, telling a story, or petting a dog. Can you lose the experience of petting a dog? Losing doesn’t make sense in some contexts.</p>&#13;
<p class="image"><img alt="image" src="../images/pg102-01.jpg"/></p>&#13;
<p class="indent"><em>Robot Heist</em>, on the other hand, is about trying to break into a bank without being detected. The possibility of getting caught makes the game more exciting and tense. Because the players can lose if they’re not careful, they can also feel like they’ve outsmarted the game when they succeed. Feeling challenged gives the player the opportunity to overcome obstacles, which can motivate them to beat the game. Let’s look at how to make losing feel like losing.</p>&#13;
<h3 class="h3" id="ch5.1"><span epub:type="pagebreak" id="page_103"/>Getting Caught</h3>&#13;
<p class="noindent">What does getting caught look like in <em>Robot Heist</em>? Remember that losing is the process of making mistakes and learning from them. We should make sure that when the player loses, they understand that they made a mistake and they should understand what the mistake is. That’s the only way they’ll learn.</p>&#13;
<p class="indent">Click <strong>Rebuild</strong> and try moving a robot through a laser. What happens? <em>Nothing!</em></p>&#13;
<p class="indent">We need to decide what losing looks and sounds like when a laser hits a robot. Perhaps an alarm should go off when the robots trip a security laser? We can play an alarm noise to let the player know they did something wrong.</p>&#13;
<p class="indent">The player also needs to know what they did wrong so they can change their strategy. We’ll let the players know by making them stop in their tracks when they’re caught. That way, if they were caught stepping into a laser, the player can see <em>that</em> was the mistake. We’ll turn both robots red (because they’ve been caught <em>red-handed</em>) to show they can no longer move. Even if only one robot is spotted, when the alarm goes off, the jig is up for both of them.</p>&#13;
<p class="indent">We’ll need to add two new objects to the game to serve as the caught, red versions of each robot, as shown here.</p>&#13;
<pre><span class="green">VertibotCaught</span>&#13;
<span class="red">red</span> <span class="darkgray">darkgray</span>&#13;
<span class="lightgray">.</span><span class="red">000</span><span class="lightgray">.</span>&#13;
<span class="lightgray">.</span><span class="darkgray">1</span><span class="red">0</span><span class="darkgray">1</span><span class="lightgray">.</span>&#13;
<span class="lightgray">.</span><span class="red">000</span><span class="lightgray">.</span>&#13;
<span class="lightgray">.</span><span class="darkgray">111</span><span class="lightgray">.</span>&#13;
<span class="lightgray">.</span><span class="red">000</span><span class="lightgray">.</span>&#13;
&#13;
<span class="green">HoribotCaught</span>&#13;
<span class="red">red</span> <span class="darkgray">darkgray</span>&#13;
<span class="lightgray">.....</span>&#13;
<span class="red">0</span><span class="darkgray">1</span><span class="red">0</span><span class="darkgray">1</span><span class="red">0</span>&#13;
<span class="red">00000</span>&#13;
<span class="red">0</span><span class="darkgray">111</span><span class="red">0</span>&#13;
<span class="lightgray">.....</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_104"/><span class="literal">VertibotCaught</span> and <span class="literal">HoribotCaught</span> are just <span class="literal">Vertibot</span> and <span class="literal">Horibot</span> colored red. We don’t need to worry about adding these new objects to the legend, because the robots will never start a level already caught: that would be a very hard game to win!</p>&#13;
<p class="indent">Let’s think about whether we can add any groups to the legend at this point to make writing our rules easier. If the awake robot walks into a laser, the sleeping robot should get caught too. Therefore, it shouldn’t matter whether the robot is awake or asleep. So let’s make groups that let us refer to each robot regardless of what state they’re in.</p>&#13;
<p class="indent">Add these two groups to the <span class="literal">LEGEND</span> section:</p>&#13;
<pre><span class="green">Vbot</span> <span class="white">=</span> <span class="green">Vertibot</span> <span class="purplebold">or</span> <span class="green">VertibotSleeping</span>&#13;
<span class="green">Hbot</span> <span class="white">=</span> <span class="green">Horibot</span> <span class="purplebold">or</span> <span class="green">HoribotSleeping</span></pre>&#13;
<p class="indent">We call the groups <span class="literal">Vbot</span> and <span class="literal">Hbot</span> because <span class="literal">Vertibot</span> and <span class="literal">Horibot</span> are already being used; they refer to the awake robots. Here, we tell PuzzleScript that <span class="literal">Vertibot</span> and <span class="literal">VertibotSleeping</span> count as <span class="literal">Vbot</span>, and <span class="literal">Horibot</span> and <span class="literal">HoribotSleeping</span> count as <span class="literal">Hbot</span>. Now we can use <span class="literal">Vbot</span> and <span class="literal">Hbot</span> to check whether the robots are caught and whether they’re awake.</p>&#13;
<p class="indent">Next, we need an alarm sound.</p>&#13;
<p class="image"><img alt="image" src="../images/pg104-01.jpg"/></p>&#13;
<h4 class="h4" id="ch5.1.1"><span epub:type="pagebreak" id="page_105"/>Adding Sound Effects</h4>&#13;
<p class="noindent">Our “You got caught!” sound doesn’t need to sound exactly like an alarm, but it <em>should</em> sound menacing! When a player hears it, they should immediately know there’s <em>trouble</em>. Click the sound effects buttons until you find a sound you like (try the *, :(, or ? button). Then copy and paste the sound into the <span class="literal">SOUNDS</span> section of your script. Alternatively, you can copy the numbers as shown here:</p>&#13;
<pre><span class="lightgray">=======</span>&#13;
<span class="purplebold">SOUNDS</span>&#13;
<span class="lightgray">=======</span>&#13;
<span class="purplebold">sfx0</span> <span class="orangeund">72277508</span></pre>&#13;
<p class="indent">In PuzzleScript, each sound is a set of numbers. We have to give our sound a name before we can use it. We’ll call this sound <span class="literal">sfx0</span>, and when we add this name to a rule, the sound should play whenever the rule runs.</p>&#13;
<h4 class="h4" id="ch5.1.2">Adding Caught Robots to the Collision Layers</h4>&#13;
<p class="noindent">Now we’re ready to put the caught robot objects on collision layers. Try doing that on your own! Make sure you add them to the same collision layer as the other robot objects.</p>&#13;
<p class="indent">Click <strong>Rebuild</strong>, and just to be safe, make sure there are no errors! If you forgot to add the new objects to the <span class="literal">COLLISIONLAYERS</span> section, you might see an error message like this below the game window:</p>&#13;
<p class="image"><img alt="image" src="../images/pg105-01.jpg"/></p>&#13;
<p class="caption"><em>An error message</em></p>&#13;
<p class="indent">Usually, an error message tells you what you forgot to do. In this case, it’s clear that the error is caused by the objects not being assigned to a collision layer. If this is what you see, go to the <span class="literal">COLLISIONLAYERS</span> section and make sure to add the objects!</p>&#13;
<h4 class="h4" id="ch5.1.3"><span epub:type="pagebreak" id="page_106"/>Writing the Rules for Getting Caught</h4>&#13;
<p class="noindent">Let’s write some rules to make the robots turn into their caught forms if they touch a laser. Keep in mind that you can show that two objects are in the same space by putting them both in square brackets with no vertical bar dividing them. Because it doesn’t matter whether the robots are asleep or awake when they get caught, we’ll simply use the <span class="literal">Vbot</span> and <span class="literal">Hbot</span> groups that we created earlier. Add the following lines under your existing code in the <span class="literal">RULES</span> section:</p>&#13;
<pre><span class="blueitalic">(getting caught)</span>&#13;
<span class="fuschia">late</span> <span class="white">[</span> <span class="green">Vbot</span> <span class="green">Laser</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">VertibotCaught</span> <span class="white">]</span> <span class="purple">sfx0</span>&#13;
<span class="fuschia">late</span> <span class="white">[</span> <span class="green">Hbot</span> <span class="green">Laser</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">HoribotCaught</span> <span class="white">]</span> <span class="purple">sfx0</span></pre>&#13;
<p class="indent">The rules are marked as <em>late</em> because we want them to happen after the robot has walked into a laser, not before. Be sure to put <span class="literal">sfx0</span> at the end of each rule to make your cool sound effect play when the rules run.</p>&#13;
<p class="indent">Click <strong>Rebuild</strong> and try the program. When you move a robot into a laser, it should turn red like this.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg106-01.jpg"/></p>&#13;
<p class="caption"><em>Testing the rules for getting caught</em></p>&#13;
<p class="indent">Try using one robot to push the other sleeping robot into the laser. The sleeping robot should also turn red when it touches the laser beam. <span epub:type="pagebreak" id="page_107"/>Because the caught forms of the characters don’t count as players according to the legend, you shouldn’t be able to move them after they turn red. <em>Caught red-handed!</em></p>&#13;
<p class="indent">Right now, only the robot that touches the laser gets caught. But we want them both to get caught, even when only one messes up. Let’s add a rule that makes sure that both robots get caught.</p>&#13;
<pre><span class="blueitalic">(getting caught)</span>&#13;
<span class="fuschia">late</span> <span class="white">[</span> <span class="green">Vbot</span> <span class="green">Laser</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">VertibotCaught</span> <span class="white">]</span> <span class="purple">sfx0</span>&#13;
<span class="fuschia">late</span> <span class="white">[</span> <span class="green">Hbot</span> <span class="green">Laser</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">HoribotCaught</span> <span class="white">]</span> <span class="purple">sfx0</span>&#13;
<span class="fuschia">late</span> <span class="white">[</span> <span class="green">VertibotCaught</span> <span class="white">] [</span> <span class="green">Hbot</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">VertibotCaught</span> <span class="white">] [</span> <span class="green">HoribotCaught</span> <span class="white">]</span>&#13;
<span class="fuschia">late</span> <span class="white">[</span> <span class="green">HoribotCaught</span> <span class="white">] [</span> <span class="green">Vbot</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">HoribotCaught</span> <span class="white">] [</span> <span class="green">VertibotCaught</span> <span class="white">]</span></pre>&#13;
<p class="indent">With this rule, when PuzzleScript sees that <span class="literal">Vertibot</span> has been caught, <span class="literal">Horibot</span> becomes caught too, and vice versa. Because you have two different pairs of square brackets on the same side of the arrow, both of those objects can be <em>anywhere</em> in the room. Recall that when we wrote the rules for switching earlier, having two objects in their own sets of square brackets means they don’t need to be next to each other. This rule makes sure that if the alarm goes off, it doesn’t matter where the robots are: they’re both busted.</p>&#13;
<p class="indent">Click <strong>Rebuild</strong> to test this new rule! Now both characters should get caught at the same time.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg107-01.jpg"/></p>&#13;
<p class="caption"><em>Both robots get caught</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_108"/>You can see that when <span class="literal">Horibot</span> triggers the alarm by crossing a laser, both <span class="literal">Horibot</span> and <span class="literal">Vertibot</span> turn red to show that they’re caught.</p>&#13;
<p class="indent">But notice that something weird happened. The characters get caught, but you also get a <span class="literal">Win Condition Satisfied</span> message and the level ends! This is the opposite of what we want to happen. Winning is the opposite of losing! Why do we win <em>instead</em> of losing?</p>&#13;
<h4 class="h4" id="ch5.1.4">Updating the Win Conditions</h4>&#13;
<p class="noindent">Let’s put our detective hats on again to figure out why the win condition is met when <span class="literal">Vertibot</span> and <span class="literal">Horibot</span> get caught. Because PuzzleScript gave us the <span class="literal">Win Condition Satisfied</span> message, maybe we should check our <span class="literal">WINCONDITIONS</span> section, which currently looks like this:</p>&#13;
<pre><span class="lightgray">==============</span>&#13;
<span class="purplebold"><span class="codestrong1">WINCONDITIONS</span></span>&#13;
<span class="lightgray">==============</span>&#13;
<span class="purple">all</span> <span class="green">Buddy</span> <span class="purple">on</span> <span class="green">Exit</span></pre>&#13;
<p class="indent">Our <span class="literal">Buddy</span> group currently contains <span class="literal">Horibot</span>, <span class="literal">Vertibot</span>, <span class="literal">HoribotSleeping</span>, and <span class="literal">VertibotSleeping</span>. Recall that <span class="literal">all Buddy on Exit</span> means all the buddies on the screen, regardless of how many there are, should be on the <span class="literal">Exit</span> objects for the player to win the level. The <span class="literal">Buddy</span> grouping should still hold true even if there are <em>no</em> buddies on the screen. The problem is that when <span class="literal">Vertibot</span> and <span class="literal">Horibot</span> become <span class="literal">VertibotCaught</span> and <span class="literal">HoribotCaught</span>, they no longer count as buddies because <span class="literal">VertibotCaught</span> and <span class="literal">HoribotCaught</span> don’t belong to the <span class="literal">Buddy</span> group.</p>&#13;
<p class="indent">This means that when the robots are caught, there are no objects that could possibly meet the win condition. And because there are no buddies <em>not</em> on exits, PuzzleScript decides that the win condition is met. Computers are more logical than we are, but they’re way less smart. When PuzzleScript checks the win condition <span class="literal">all Buddy on Exit</span>, it’s making sure that there are <em>no</em> buddies anywhere other than on exits. If there are no buddies at all, then as far as PuzzleScript is concerned, all the buddies on the screen (that is, zero!) are on exits.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>Fortunately, we can have multiple win conditions in our game. Let’s add new win conditions to the <span class="literal">WINCONDITIONS</span> section that specify the player can’t win when both robots are caught, like this:</p>&#13;
<pre>all Buddy on Exit&#13;
<span class="purplebold">no</span> <span class="green">VertibotCaught</span>&#13;
<span class="purplebold">no</span> <span class="green">HoribotCaught</span></pre>&#13;
<p class="indent">The code <span class="literal">no VertibotCaught</span> checks that there are no <span class="literal">VertibotCaught</span> objects in the level. To win a level, all the win conditions need to be satisfied at the same time, so the level can’t be won if PuzzleScript finds any caught robots, even if they are all on the exit.</p>&#13;
<p class="indent">This new win condition should work fine (try it and see!). But we could simplify this even further by making a group that contains both caught robots, which we’ll call <span class="literal">Trouble</span>. Add this line to the <span class="literal">LEGEND</span> section:</p>&#13;
<pre><span class="green">Trouble</span> <span class="white">=</span> <span class="green">VertibotCaught</span> <span class="purplebold">or</span> <span class="green">HoribotCaught</span></pre>&#13;
<p class="indent">So we’ll finish the level with <span class="literal">no Trouble</span>. The player wins if they’ve gotten both buddies onto the exit without running into any <span class="literal">Trouble</span>. Now we can use the <span class="literal">Trouble</span> group to streamline our <span class="literal">WINCONDITIONS</span> section code, like this:</p>&#13;
<pre>==============&#13;
WINCONDITIONS&#13;
==============&#13;
all Buddy on Exit&#13;
<span class="purple">no</span> <span class="green">Trouble</span></pre>&#13;
<p class="indent">Now that we’ve written rules for how the robots should interact with lasers and how that should affect the outcome of the game, let’s add a few more threats to make our game more exciting.</p>&#13;
<h3 class="h3" id="ch5.2">Adding Robot Guards</h3>&#13;
<p class="noindent">The second threat we’ll add to the game are robot security guards that patrol the Data Bank. If the robot guards find Vertibot or Horibot, the player will lose!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_110"/>The challenge will be to make the guards move on their own, because this can be a very complicated process to program. Have you ever played <em>Hide and Seek</em>? A lot of decisions go into finding your friends when they’re hidden. You probably know the best hiding spots in the area in which you’re playing. You know your friends. You know which friend always surprises you by trying to pick the cleverest hiding spot. You remember which places you’ve already looked in. You look over your shoulder sometimes in case someone is sneaking around behind you. Somehow a human being can synthesize all of this information to make decisions quickly. How can we possibly program a video game guard that’s as smart as a person?</p>&#13;
<p class="indent">Fortunately, we don’t have to, because this is only a robot guard. It’s okay if it follows a very simple pattern. In fact, it’s probably better if the guard’s actions are predictable. For example, if it covers the same ground over and over, the player can anticipate its path and sneak around it. If the guards were as smart as real humans, our game would be impossible to win.</p>&#13;
<p class="indent">The simplest way we can code this kind of patrolling movement is to have the guard move in a straight line and then turn when it reaches a wall. We can have it continue moving forward and turning in the same direction until it eventually returns to the point where it started and then starts over again.</p>&#13;
<h4 class="h4" id="ch5.2.1">Creating Guard Objects</h4>&#13;
<p class="noindent">Let’s start by creating the objects. We’ll need four guard objects: one for each direction the guard can move in (up, down, left, and right). We start with one of the objects and then change it into the next type of object when it runs into a wall. A benefit of using four distinct objects is that we can change each object to look different depending on the direction in which it’s moving. That way, the player can look at the screen and see where the guards are going.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_111"/>Let’s add four new objects to the game.</p>&#13;
<pre><span class="green">GuardUp</span>&#13;
<span class="gray">gray</span> <span class="red">red</span>&#13;
<span class="gray">..0..</span>&#13;
<span class="gray">.0</span><span class="red">1</span><span class="gray">0.</span>&#13;
<span class="gray">00000</span>&#13;
<span class="gray">00000</span>&#13;
<span class="gray">.000.</span>&#13;
&#13;
<span class="green">GuardRight</span>&#13;
<span class="gray">gray</span> <span class="red">red</span>&#13;
<span class="gray">.00..</span>&#13;
<span class="gray">0000.</span>&#13;
<span class="gray">000</span><span class="red">1</span><span class="gray">0</span>&#13;
<span class="gray">0000.</span>&#13;
<span class="gray">.00..</span>&#13;
&#13;
<span class="green">GuardDown</span>&#13;
<span class="gray">gray</span> <span class="red">red</span>&#13;
<span class="gray">.000.</span>&#13;
<span class="gray">00000</span>&#13;
<span class="gray">00000</span>&#13;
<span class="gray">.0</span><span class="red">1</span><span class="gray">0.</span>&#13;
<span class="gray">..0..</span>&#13;
&#13;
<span class="green">GuardLeft</span>&#13;
<span class="gray">gray</span> <span class="red">red</span>&#13;
<span class="gray">..00.</span>&#13;
<span class="gray">.0000</span>&#13;
<span class="gray">0</span><span class="red">1</span><span class="gray">000</span>&#13;
<span class="gray">.0000</span>&#13;
<span class="gray">..00.</span></pre>&#13;
<p class="indent">We’ll name them <span class="literal">GuardUp</span>, <span class="literal">GuardRight</span>, <span class="literal">GuardDown</span>, and <span class="literal">GuardLeft</span>. As you can see, the red pixel should signal to the player which direction each object can move in.</p>&#13;
<h4 class="h4" id="ch5.2.2"><span epub:type="pagebreak" id="page_112"/>Adding Guards to the Legend and the Collision Layers</h4>&#13;
<p class="noindent">Now we need to put these guards into the legend. We also need to assign a symbol for each direction, so we can use it to choose which direction the guards start in. Add the following lines to your existing code in the <span class="literal">LEGEND</span> section:</p>&#13;
<pre><span class="green">8</span> <span class="white">=</span> <span class="green">GuardUp</span>&#13;
<span class="green">6</span> <span class="white">=</span> <span class="green">GuardRight</span>&#13;
<span class="green">2</span> <span class="white">=</span> <span class="green">GuardDown</span>&#13;
<span class="green">4</span> <span class="white">=</span> <span class="green">GuardLeft</span></pre>&#13;
<p class="indent">I chose those numbers as symbols because of their placement on the keyboard’s keypad (the part that looks like a calculator). An up arrow is on the 8, a right arrow is on the 6, and so on. When I see these numbers in a level and forget which direction it is, I can just glance at the keypad on my keyboard to remind myself.</p>&#13;
<p class="indent">Let’s also add a <span class="literal">Guard</span> group to the legend that will let us refer to all guard objects regardless of which direction a guard is facing, like this:</p>&#13;
<pre>Buddy = Player or HoribotSleeping or VertibotSleeping&#13;
<span class="green">Guard</span> <span class="white">=</span> <span class="green">GuardUp</span> <span class="purple">or</span> <span class="green">GuardRight</span> <span class="purple">or</span> <span class="green">GuardDown</span> <span class="purple">or</span> <span class="green">GuardLeft</span>&#13;
Depresser = Player or Pushable <span class="purple">or</span> <span class="green">Guard</span>&#13;
Blocker = Wall or GateClosed or Crate or Gun <span class="purple">or</span> <span class="green">Guard</span></pre>&#13;
<p class="indent">Note that the <span class="literal">Guard</span> group should come before the <span class="literal">Depresser</span> group in your script. The reason is that we want guards to be able to step on panels like the other depresser objects and be able to block lasers as a blocker. Before we can add <span class="literal">Guard</span> to the <span class="literal">Depresser</span> and <span class="literal">Blocker</span> groups, we first need to tell PuzzleScript what a guard is. Only <em>then</em> can we tell PuzzleScript that a guard can be a depresser and a blocker.</p>&#13;
<p class="indent">Last but not least, be sure to add all four guard objects to a collision layer. Put them on the same layer as the robots and all the other solid objects. Then click <strong>Rebuild</strong> to make sure there aren’t any errors.</p>&#13;
<p class="indent">Now let’s write the rules that make our guards patrol.</p>&#13;
<h4 class="h4" id="ch5.2.3"><span epub:type="pagebreak" id="page_113"/>Writing Rules to Move Guards Forward</h4>&#13;
<p class="noindent">A guard’s motion has two parts: it moves forward, and then, when it bumps into a wall, it turns to the right.</p>&#13;
<p class="image"><img alt="image" src="../images/pg113-01.jpg"/></p>&#13;
<p class="indent">Let’s add the forward movement first by adding the following to the <span class="literal">RULES</span> section:</p>&#13;
<pre><span class="blueitalic">(guardbots)</span>&#13;
<span class="fuschia">left</span> <span class="white">[</span> <span class="green">GuardLeft</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardLeft</span> <span class="white">]</span>&#13;
<span class="fuschia">down</span> <span class="white">[</span> <span class="green">GuardDown</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardDown</span> <span class="white">]</span>&#13;
<span class="fuschia">right</span> <span class="white">[</span> <span class="green">GuardRight</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardRight</span> <span class="white">]</span>&#13;
<span class="fuschia">up</span> <span class="white">[</span> <span class="green">GuardUp</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardUp</span> <span class="white">]</span></pre>&#13;
<p class="indent">At every turn, we just change our guards into moving guards. Because the four rules are directional, the <span class="literal">&gt;</span> simply matches the direction of the rule. For example, <span class="literal">GuardLeft</span> always moves left, <span class="literal">GuardDown</span> always moves down, and so on.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_114"/>Put together a simple test level to check that this script works now. Be sure to include all four objects on your test level, like this:</p>&#13;
<pre><span class="lightgray">########</span>&#13;
<span class="lightgray">#..6...#</span>&#13;
<span class="lightgray">#......#</span>&#13;
<span class="lightgray">#..I..2#</span>&#13;
<span class="lightgray">#8..H..#</span>&#13;
<span class="lightgray">#......#</span>&#13;
<span class="lightgray">#...4..#</span>&#13;
<span class="lightgray">########</span></pre>&#13;
<p class="indent">Try playing your level! You should see something like this.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg114-01.jpg"/></p>&#13;
<p class="caption"><em>Guard test level</em></p>&#13;
<p class="indent">If your guards start one space forward from where you put them, it’s because of <span class="literal">run_rules_on_level_start</span>! Don’t worry—this won’t be an issue when we turn on realtime mode shortly. The guards should move only when the player moves. Wiggle the player back and forth and watch how the guards behave. They’ll move forward until they hit the wall. Then they’ll get stuck because we haven’t told them what to do when they run into a wall. Let’s tell them to turn to the right after bumping into something.</p>&#13;
<span epub:type="pagebreak" id="page_115"/>&#13;
<div class="note">&#13;
<p class="note1"><strong><span class="snote">NOTE:</span></strong> If you get an error message that says, “Trying to access a level that doesn’t exist,” try pressing <strong>Rebuild</strong> and start a new game.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch5.2.4">Writing Rules for Turning Right</h4>&#13;
<p class="noindent">Before we can make the guards turn, let’s define a new group in the legend called <span class="literal">Obstacle</span> for every object that could get in a guard’s way. Add the following to the <span class="literal">LEGEND</span> section:</p>&#13;
<pre><span class="green">Guard</span> <span class="white">=</span> <span class="green">GuardUp</span> <span class="purple">or</span> <span class="green">GuardRight</span> <span class="purple">or</span> <span class="green">GuardDown</span> <span class="purple">or</span> <span class="green">GuardLeft</span>&#13;
<span class="green">Obstacle</span> <span class="white">=</span> <span class="green">Wall</span> <span class="purple">or</span> <span class="green">Crate</span> <span class="purple">or</span> <span class="green">GateClosed</span> <span class="purple">or</span> <span class="green">Gun</span> <span class="purple">or</span> <span class="green">Guard</span></pre>&#13;
<p class="indent">The new <span class="literal">Obstacle</span> group includes all the solid objects a guard can run into.</p>&#13;
<p class="indent">Now we can add rules to make the guards turn when they bump into any obstacle. Guards turn clockwise (to the right) whenever they bump into something. We’ll make guards turn by replacing them entirely with another object that points in the new direction. Add the following to the <span class="literal">RULES</span> section to do this:</p>&#13;
<pre><span class="whiteitalic">(guardbots)</span>&#13;
<span class="white">left [ GuardLeft ] -&gt; [ &gt; GuardLeft ]</span>&#13;
<span class="white">down [ GuardDown ] -&gt; [ &gt; GuardDown ]</span>&#13;
<span class="white">right[ GuardRight ] -&gt; [ &gt; GuardRight ]</span>&#13;
<span class="white">up[ GuardUp ] -&gt; [ &gt; GuardUp ]</span>&#13;
&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardLeft</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">GuardUp</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardDown</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">GuardLeft</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardRight</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">GuardDown</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Guardup</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">GuardRight</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span></pre>&#13;
<p class="indent">When a guard tries to move into an obstacle, it instead is turned into the guard object facing the next direction clockwise. <span class="literal">GuardLeft</span> turns into <span class="literal">GuardUp</span>, <span class="literal">GuardUp</span> turns into <span class="literal">GuardRight</span>, <span class="literal">GuardRight</span> turns into <span class="literal">GuardDown</span>, and <span class="literal">GuardDown</span> turns into <span class="literal">GuardLeft</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>Note that I’ve grouped the rules so all the guards move forward at the same time and then all the guards turn at the same time, because rules are run in order from top to bottom. Click <strong>Save</strong> now. To see what can happen when you change the order of the rules, try moving the <span class="literal">[ &gt; GuardLeft | Obstacle ] -&gt; [ GuardUp | Obstacle ]</span> rule before the <span class="literal">up [ GuardUp ] -&gt; [ &gt; GuardUp ]</span> rule. Then try grouping the rules so each guard object’s move and turn rules are together.</p>&#13;
<pre><span class="blueitalic">(guardbots)</span>&#13;
<span class="fuschia">left</span> <span class="white">[</span> <span class="green">GuardLeft</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardLeft</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardLeft</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">GuardUp</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span>&#13;
&#13;
<span class="fuschia">down</span> <span class="white">[</span> <span class="green">GuardDown</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardDown</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardDown</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">GuardLeft</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span>&#13;
&#13;
<span class="fuschia">right</span> <span class="white">[</span> <span class="green">GuardRight</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardRight</span> <span class="white">]</span>&#13;
<span class="white">[</span> &gt; <span class="green">GuardRight</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">GuardDown</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span>&#13;
&#13;
<span class="fuschia">up</span> <span class="white">[</span> <span class="green">GuardUp</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardUp</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardUp</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">GuardRight</span> <span class="white">|</span> <span class="green">Obstacle</span> <span class="white">]</span></pre>&#13;
<p class="indent">Click <strong>Rebuild</strong> and try playing the game with this updated code. You should see that one of the guards moves differently than the others. In this example, <span class="literal">GuardLeft</span> turns into <span class="literal">GuardUp</span> after it runs into a wall. But because of the misplaced code, <span class="literal">GuardUp</span> moves one step forward immediately after turning instead of turning in place and waiting a turn to move like the others. This is why it’s important to always think about the order in which your rules execute. When <span class="literal">GuardLeft</span> hits a wall, it turns into <span class="literal">GuardUp</span> and immediately moves up; the other guards wait a turn after turning to move. Can you read through the rules one by one and see why?</p>&#13;
<p class="indent">Early in the rules, <span class="literal">GuardLeft</span> becomes <span class="literal">GuardUp</span>. But a later rule moves <span class="literal">GuardUp</span> up. Because the turning rule for <span class="literal">GuardLeft</span> happens before the moving rule for <span class="literal">GuardUp</span>, the guard turns and moves on the same turn!</p>&#13;
<p class="indent">Click the <strong>Load</strong> menu and return to the game you last saved.</p>&#13;
<h4 class="h4" id="ch5.2.5"><span epub:type="pagebreak" id="page_117"/>Catching the Intruders</h4>&#13;
<p class="noindent">Let’s create rules that let the guards actually <em>catch</em> Horibot and Vertibot by adding these two lines to the guardbots section in the <span class="literal">RULES</span> section:</p>&#13;
<pre><span class="blueitalic">(guardbots)</span>&#13;
<span class="fuschia">left</span> <span class="white">[</span> <span class="green">GuardLeft</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardLeft</span> <span class="white">]</span>&#13;
<span class="fuschia">down</span> <span class="white">[</span> <span class="green">GuardDown</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardDown</span> <span class="white">]</span>&#13;
<span class="fuschia">right</span> <span class="white">[</span> <span class="green">GuardRight</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardRight</span> <span class="white">]</span>&#13;
<span class="fuschia">up</span> <span class="white">[</span> <span class="green">GuardUp</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardUp</span> <span class="white">]</span>&#13;
&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Guard</span> <span class="white">|</span> <span class="green">Hbot</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Guard</span> <span class="white">|</span> <span class="green">HoribotCaught</span> <span class="white">]</span> <span class="purple">sfx0</span>&#13;
<span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Guard</span> <span class="white">|</span> <span class="green">Vbot</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="green">Guard</span> <span class="white">|</span> <span class="green">VertibotCaught</span> <span class="white">]</span> <span class="purple">sfx0</span></pre>&#13;
<p class="indent">Now if a guard tries to move into either robot, the robot turns into its caught equivalent, setting off the alarm sound at the same time. (I know the guards are robot guards, but whenever I mention “robots,” I’m referring to just Vertibot and Horibot.)</p>&#13;
<p class="indent">Notice how grouping helps us write fewer rules. The <span class="literal">Guard</span> group includes four different guard objects, and <span class="literal">Hbot</span> and <span class="literal">Vbot</span> include two objects each: the sleeping and awake versions of the robots. Without groups, we’d need to write 16 different rules to cover all the different combinations!</p>&#13;
<p class="indent">Click <strong>Rebuild</strong> to test your game. Try moving a robot in front of a guard’s patrol path. Then try putting an asleep robot in front of a guard’s patrol path. When the guard bumps into the robot, the robot should turn red just like it would when it walks into a laser.</p>&#13;
<p class="image"><img alt="image" src="../images/pg117-01.jpg"/></p>&#13;
<h4 class="h4" id="ch5.2.6"><span epub:type="pagebreak" id="page_118"/>Testing the Guards</h4>&#13;
<p class="noindent">Earlier, we put guards in <span class="literal">Depresser</span> and <span class="literal">Blocker</span> groups in the legend. Let’s make some test levels to test those features.</p>&#13;
<p class="indent">Here’s a level that tests how guards work with panels.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg118-01.jpg"/></p>&#13;
<p class="caption"><em>Testing guards and panels</em></p>&#13;
<p class="indent">Because a guard is a depresser, the gates should open when the guard moves onto the panel and close when the guard moves off the panel. If you want the gate to stay open for a longer time, try putting a bunch of panels in a row, so it will take the guard longer to get past them.</p>&#13;
<p class="indent">Next, try making a level to test whether guards will block lasers. Can you come up with a level where the robots need to time their movements with the guards to sneak past lasers?</p>&#13;
<p class="indent">As a last test, let’s see what happens when a guard runs into a dead end. Make a level shaped like the following.</p>&#13;
<p class="imagel"><span epub:type="pagebreak" id="page_119"/><img alt="image" src="../images/pg119-01.jpg"/></p>&#13;
<p class="caption"><em>Testing guards at a dead end</em></p>&#13;
<p class="indent">When the guard bumps into the dead end in the upper left, it turns to the right. Then it immediately bumps into another wall and turns right again. Now it should head back down. What do you think will happen when it gets back to the bottom and bumps into the wall there? You should see something like this.</p>&#13;
<p class="imagel"><img alt="image" src="../images/pg119-02.jpg"/></p>&#13;
<p class="caption"><em>Guard stuck in a dead-end path</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_120"/>It should turn right again, just like we told it to. It should turn around and start heading back up. This guard will keep going up and down this pathway forever and never return to its original patrol path. Keep this example in mind when you design your levels so you won’t make the same mistake!</p>&#13;
<h3 class="h3" id="ch5.3">Realtime Mode</h3>&#13;
<p class="noindent">All the games we’ve made so far are called <em>turn-based</em> games. In a turn-based game, one player has a turn and then the next player takes a turn, as in a game of <em>Checkers</em>. In <em>Herding Cats</em>, the cats move only when the player moves.</p>&#13;
<p class="indent">In <em>Robot Heist</em>, we want characters that move on their own. Right now, the security guards in our game move only when the player moves. But if we switch our game into realtime mode, they’ll move on their own, even when the player isn’t moving. Realtime refers to basing the movements of game objects on the amount of time that has passed in the real world, not the movements of the player character.</p>&#13;
<p class="indent">How does realtime feel different than a turn-based game? First, there’s an element of <em>time pressure</em>. Even when the player is not moving, the guards are patrolling. That means the player won’t be able to sit and think about their next move for as long as they want. As in a real heist, the player has to think and act quickly. It also helps create the sense that these guards have a life of their own, outside the player. After all, real security guards wouldn’t wait for an intruder’s permission to move, would they?</p>&#13;
<h4 class="h4" id="ch5.3.1">Making Objects Move in Realtime</h4>&#13;
<p class="noindent">Let’s make objects move by themselves by turning on realtime mode in PuzzleScript. We can tell PuzzleScript how often we want objects to move, such as once every second. Then, every time a second passes, PuzzleScript runs all the rules whether or not the player has moved.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_121"/>To turn on realtime mode, simply add the following line to the beginning of your PuzzleScript code:</p>&#13;
<pre><span class="white">title</span> <span class="whiteitalic">Robot Heist</span>&#13;
<span class="white">author</span> <span class="whiteitalic">anna anthropy</span>&#13;
<span class="white">run_rules_on_level_start</span>&#13;
<span class="purplebold">realtime_interval</span> <span class="orangeitalic">0.2</span></pre>&#13;
<p class="indent">The number after <span class="literal">realtime_interval</span> tells PuzzleScript how often to run the game rules, in seconds. So <span class="literal">realtime_interval 1</span> would be once every second. And <span class="literal">0.5</span> would be once every half a second, or two moves per second. Our example has <span class="literal">realtime_interval 0.2</span>, which is two-tenths of a second, or five moves every second.</p>&#13;
<p class="indent">Realtime works best if you add a couple more of PuzzleScript’s optional features, like <span class="literal">throttle_movement</span> and <span class="literal">norepeat_action</span> (the latter of which was added in <a href="ch04.xhtml">Chapter 4</a>). Add both below realtime mode, like so:</p>&#13;
<pre><span class="white">title</span> <span class="whiteitalic">Robot Heist</span>&#13;
<span class="white">author</span> <span class="whiteitalic">anna anthropy</span>&#13;
<span class="white">run_rules_on_level_start</span>&#13;
<span class="white">realtime_interval</span> <span class="whiteitalic">0.2</span>&#13;
<span class="purplebold">throttle_movement</span>&#13;
<span class="white">norepeat_action</span></pre>&#13;
<p class="indent">The <span class="literal">throttle_movement</span> feature limits the player’s movement speed. Without it, pressing an arrow key a bunch of times can make you move faster than just holding down the arrow key. That’s not a big deal if everything in the world moves at the same speed as you, but it’s important if everything else is moving at its own speed. And it isn’t a big deal if everyone else in the game moves whenever the player moves. But if guards are moving at their own speed, the player can move way faster than them by mashing buttons. And because this game is about planning and strategy, not about button mashing, we’ll use <span class="literal">throttle_movement</span> to keep the player from mashing buttons in order to win.</p>&#13;
<p class="indent">Without <span class="literal">norepeat_action</span>, holding down the action key will continue switching between both robots, meaning it’s easier to accidentally switch more times than you want to. Also, <span class="literal">norepeat_action</span> makes sure the <span epub:type="pagebreak" id="page_122"/>player releases the action key before they can press it again. Adding both features makes the game more user-friendly.</p>&#13;
<p class="indent">Click <strong>Rebuild</strong> and watch your guards go! They should start moving on their own in a beautiful, synchronized ballet, even when your robots aren’t moving.</p>&#13;
<p class="indent">Now try moving the robots. <em>Whoa!</em></p>&#13;
<p class="image"><img alt="image" src="../images/pg122-01.jpg"/></p>&#13;
<p class="indent">When you move the robots, you should see that the guards speed up and move super fast whenever you move! Yikes! What’s going on?</p>&#13;
<h4 class="h4" id="ch5.3.2">Checking for a Stationary Player</h4>&#13;
<p class="noindent">Instead of calling a turn as normal (running the rules, then moving objects, and then running late moves) PuzzleScript’s realtime mode calls a turn every 0.2 seconds. So the rules for guards are run even when the player hasn’t pressed any keys. But we haven’t accounted for the fact that PuzzleScript still calls a turn whenever the player presses a key. This means that the guards move on their own every 0.2 seconds and move <em>again</em> when the player moves. We want the guards to move independently of the player, not to move faster when the player moves.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_123"/>We need the guards to move <em>only</em> every 0.2 seconds, but <em>not</em> when the player moves. To do that, we just need to check that the player is <em>stationary</em> whenever we try to move the guards. Go back to the rules for moving guards in the <span class="literal">RULES</span> section, and add <span class="literal">[ stationary Player ]</span> to both sides of each arrow, like this:</p>&#13;
<pre><span class="fuschia">left</span> <span class="white">[</span> <span class="green">GuardLeft</span> <span class="white">]</span> <span class="white">[</span> <span class="fuschia">stationary</span> <span class="green">Player</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardLeft</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">stationary</span> <span class="green">Player</span> <span class="white">]</span>&#13;
<span class="fuschia">down</span> <span class="white">[</span> <span class="green">GuardDown</span> <span class="white">]</span> <span class="white">[</span> <span class="fuschia">stationary</span> <span class="green">Player</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardDown</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">stationary</span> <span class="green">Player</span> <span class="white">]</span>&#13;
<span class="fuschia">right</span> <span class="white">[</span> <span class="green">GuardRight</span> <span class="white">]</span> <span class="white">[</span> <span class="fuschia">stationary</span> <span class="green">Player</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">GuardRight</span> <span class="white">]</span>&#13;
<span class="white">[</span> <span class="fuschia">stationary</span> <span class="green">Player</span> <span class="white">]</span>&#13;
<span class="fuschia">up</span> <span class="white">[</span> <span class="green">Guardup</span> <span class="white">]</span> <span class="white">[</span> <span class="fuschia">stationary</span> <span class="green">Player</span> <span class="white">]</span> <span class="red">-&gt;</span> <span class="white">[</span> <span class="fuschia">&gt;</span> <span class="green">Guardup</span> <span class="white">]</span>&#13;
<span class="white">[</span><span class="fuschia">stationary</span> <span class="green">Player</span> <span class="white">]</span></pre>&#13;
<p class="indent">Adding <span class="literal">[ stationary Player ]</span> lets guards move forward only when there’s a stationary (non-moving) player somewhere in the level. Note that this doesn’t change the player at all. These rules just make sure that guards move every 0.2 seconds, but <em>not</em> when the player robots move.</p>&#13;
<p class="indent">Click <strong>Rebuild</strong> and try moving around. The guards’ speed should remain constant no matter what the player does.</p>&#13;
<h3 class="h3" id="ch5.4">Extra Challenges: Make It Look Good</h3>&#13;
<p class="noindent">Here are some extra touches I added to the finished version of <em>Robot Heist</em> to make the game look more appealing. The challenges are listed in order of difficulty. Can you figure out how to script them? If you need help, hack my finished <em>Robot Heist</em> game and look at how I did it.</p>&#13;
<p class="bqpara"><strong>Challenge 1: Make characters bigger than a single space</strong> If you look closely at the player robots in <em>Robot Heist</em>, you’ll see that they’re slightly larger than the 5 × 5 pixel size of most PuzzleScript objects. In fact, each player robot is made up of three separate objects that all move together.</p>&#13;
<p class="bqpara"><strong>Challenge 2: Randomize the walls</strong> One way to keep the walls from looking too similar is to create a bunch of slightly different wall objects. When the level starts, each wall changes <span epub:type="pagebreak" id="page_124"/>its appearance at random. These walls all behave in the same way, but they add visual variety to the levels.</p>&#13;
<p class="bqpara"><strong>Challenge 3: Add animation</strong> In a realtime game, we can make objects change appearance over time and animate them. For example, the solid gold superconductor—the treasure the robots are trying to steal—shines and gleams by changing between three different objects, each representing a single frame of animation.</p>&#13;
<p class="bqpara"><strong>Challenge 4: Wire paths</strong> To make it easier for the player to make the connection between panels and the gates they open, I drew wires leading from the panels to the gates. These work a lot like the lasers do: at the beginning of the level, the player looks around for adjacent wires and then draws connections between them.</p>&#13;
<h3 class="h3" id="ch5.5">What You Learned</h3>&#13;
<p class="noindent">In this chapter, you added the ability to <em>lose</em> the game. You gave lasers and robot guards the ability to catch the player, adding an element of tension to the game. You learned what losing looks like and why you might want to give the player the possibility of losing. And you made the guards move in realtime, patrolling for the robots instead of waiting for them to move.</p>&#13;
<p class="indent">Now you have a complete cast of objects: the robot protagonists, crates to push, gates to open and close, security lasers, and patrolling guards. You’re ready to combine all these objects into action-packed levels. In the next chapter, you’ll do just that.</p>&#13;
</body></html>