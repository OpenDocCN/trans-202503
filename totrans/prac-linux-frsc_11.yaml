- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FORENSIC TRACES OF ATTACHED PERIPHERAL DEVICES**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, peripheral devices refer to externally connected hardware such
    as storage, cameras, webcams, printers, scanners, mobile devices, and so on. We
    will try to identify and analyze these attached devices from traces in the logs
    and configuration files. From a forensics perspective, we are attempting to learn
    as much about the devices as possible; in particular, any unique identifying information
    and evidence of use. Knowing what devices were attached to a system and how they
    were used helps to reconstruct past events and activity.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice the absence of Bluetooth devices in this chapter. They are also
    considered peripherals, but they’re covered together with the other wireless analysis
    topics in [Chapter 8](ch08.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Peripheral Devices**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common interfaces used to connect external peripheral devices are USB
    and Thunderbolt. USB devices make up the vast majority of externally attached
    devices, far outnumbering any other external interface. Thunderbolt’s physical
    interface now uses USB3C and provides the ability to connect PCI Express devices.
    In addition, Fibre Channel (FC) and serial attached SCSI (SAS) PCI boards provide
    external interfaces that are found primarily in enterprise environments.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux Device Management***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 2](ch02.xhtml), when Unix was first developed, a core
    philosophy (that Linux adopted) was “everything is a file.” This revolutionary
    idea enabled access to hardware devices through special files that interacted
    with the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Device files can be one of two types (block or character), and they have associated
    numbers (major and minor) that specify the class and instance of a device. Character
    devices are sequentially accessed (or streamed) one byte at a time, and they’re
    used for keyboards, video, printers, and other serial devices. Block devices are
    accessed in block-sized chunks, can be cached or randomly accessed, and are typically
    used for storage devices.
  prefs: []
  type: TYPE_NORMAL
- en: Device files are normally located in the */dev/* directory and are created dynamically
    by the udev daemon (systemd-udevd). The */dev/* directory is a pseudo-filesystem
    that a running kernel provides in memory. Thus, the device files in this directory
    will not exist during a postmortem forensic examination.^([1](footnotes.xhtml#ch11foot_01))
    Device files are not required to be in */dev/* and can be created anywhere using
    the `mknod` command or `mknod` system call. However, a device file anywhere outside
    */dev/* is suspicious and worth closer examination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The systemd-udevd daemon notices when devices are attached or removed from
    the system by the kernel, and sets up the appropriate device files using udev
    rules specified in rule files. Software packages may create udev rule files in
    the */usr/lib/udev/rules.d/* directory, and system administrators create custom
    udev rule files in the */etc/udev/rules.d/* directory. Here is an example of a
    udev rule file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The system owner (`sam`) created a rule for a Nitrokey authentication stick
    with a USB device ID of 20a0:4108 to define how the permissions and group ownership
    are set.
  prefs: []
  type: TYPE_NORMAL
- en: An examination of */etc/udev/rules.d/* will reveal any files tweaked or created
    by the system’s owner. See the udev(7) man page for more information about udev.
  prefs: []
  type: TYPE_NORMAL
- en: '***Identify Attached USB Devices***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: USB indexUSB deviceswas created to consolidate and replace aging external peripheral
    interfaces such as RS-232, the parallel printer interface, PS/2 keyboard and mouse,
    and other proprietary PC interfaces. It was designed to accommodate multipurpose
    functionality such as disks, keyboards, mice, sound, network connections, printing
    and scanning, and connecting small devices (mobile phones and the like). A growing
    number of IoT devices can be attached to a PC via USB and may contain data useful
    as forensic evidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'During a forensic examination, creating a list of attached USB devices will
    help answer questions related to an investigation, providing information such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: Indication of human proximity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity at a certain point in time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional devices to find and analyze
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association of a particular device to the system under analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of a forensic investigation, we are especially interested in
    unique identifiers and timestamps. The unique identifiers will link a particular
    device to a particular computer within the context of an incident or crime. USB
    unique identifiers may include hardware serial numbers or UUIDs stored in the
    device firmware or in the device’s memory. When trying to identify USB devices,
    we can examine logfiles, configuration files, and other persistent data.
  prefs: []
  type: TYPE_NORMAL
- en: 'USB devices appear in the kernel logs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This example shows that an Apple AirPod charging case was connected on December
    30 at 9:13 AM (`09:13:20`). The serial number provides a unique identification.
    The disconnect log entry shows the AirPod case was unplugged several minutes later.
    When analyzing storage device logs, the device number and USB port (`36` and `5-3.2`
    in this example) are the only information shown in the kernel logs upon removal
    of the device. These provide an association to the other log entries that contain
    more detailed device information (manufacturer, product, serial number, and so
    on).
  prefs: []
  type: TYPE_NORMAL
- en: From a forensics perspective, the insertion and removal timestamps are interesting.
    They provide an indicator that a person was in physical proximity of the computer
    when the device was plugged in and unplugged, and suggest a possible duration
    of use. Other logs and information may need to corroborate with these timestamps
    before definite usage conclusions can be made. The port where the USB device was
    inserted indicates which physical connector was used to plug in the device. This
    could be useful information, for example, if the USB device was plugged in to
    a server in the middle of a row of racks; the front or back location could correlate
    with activity observed in data center CCTV footage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Video conferencing has become more popular recently, and Linux supports video
    conferencing software like Zoom, Teams, Jitsi, and more. This software relies
    on USB webcams and microphones (internal on laptops; external on desktops). These
    devices can be found in the same manner as other devices described in this section,
    but Linux manages video devices through the Video4Linux (V4L) framework, which
    is part of the Linux media subsystem. When a video device is attached to a Linux
    system, the kernel detects it and a */dev/video0* device is created (multiple
    cameras will appear as */dev/video1*, */dev/video2*, and so on). Typical video
    devices include webcams, digital video cameras, TV tuners, and video grabbers.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the USB device is detected with make/model/serial information, and then
    the Linux video driver is started, which enables the use of video equipment for
    recording, video conferencing, or watching television.
  prefs: []
  type: TYPE_NORMAL
- en: A list of known USB hardware IDs can be found in the */usr/share/hwdata/ usb.ids*
    file or from the *[http://www.linux-usb.org/usb-ids.html](http://www.linux-usb.org/usb-ids.html)*
    website. This list is formatted by vendor, device, and interface name, and is
    maintained by community effort.
  prefs: []
  type: TYPE_NORMAL
- en: '***Identify PCI and Thunderbolt Devices***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PCI Express or PCIe (Peripheral Component Interconnect Express) is a specification
    (*[https://pcisig.com/](https://pcisig.com/)*) for a bus interface to attach PCIe
    devices. PCIe devices are typically cards plugged in to PCIe slots on the mainboard
    or devices integrated into the mainboard itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding PCIe devices in the logs depends on the device’s kernel module, with
    some modules logging more than others. The following example shows a kernel module
    logging information about a PCIe device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here an Nvidia GP107 PCIe graphics card is detected in the physical slot (bus)
    2 of the mainboard. We can analyze the kernel logs describing the physical PCIe
    slots and associate them with PCIe devices that were detected.
  prefs: []
  type: TYPE_NORMAL
- en: The string `0000:02:00.0` in the above example is represented in `<domain>:`
    `<bus>:<device>.<function>` format. This format describes where the PCIEe device
    is located in the system, and the function number for multifunction devices. The
    string `[10de:1c82]` refers to the device vendor (NVIDIA) and the product (GP107).
  prefs: []
  type: TYPE_NORMAL
- en: For a list of known PCI hardware IDs, see the */usr/share/hwdata/pci.ids* file
    or the *[http://pci-ids.ucw.cz/](http://pci-ids.ucw.cz/)* website. These lists
    are formatted by vendor, device, subvendor, and subdevice names, and are maintained
    by community effort. The pci.ids(5) man page describes the file in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Thunderbolt was developed jointly by Apple and Intel as a high-speed external
    interface to connect disks, video displays, and PCIe devices using a single interface.
    Using the code name Light Peak, it was originally intended to be a fiber-optic
    connection. Apple is largely responsible for Thunderbolt’s popularity (primarily
    among Apple users), promoting it with Apple hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The physical interface uses Mini DisplayPort for Thunderbolt 1 and Thunderbolt
    2, and transitions to the USB Type-C cable and connector for
  prefs: []
  type: TYPE_NORMAL
- en: Thunderbolt 3\. The Thunderbolt 3 interface combines PCIe, DisplayPort, and
    USB3 into a single interface. Thunderbolt 1, 2, and 3 offer speeds of 10, 20,
    and 40Gbps, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a Thunderbolt device connected to a Linux laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The logs show that a Thunderbolt gigabit Ethernet adapter was inserted on at
    10:45 on December 30 and was unplugged several minutes later (10:50). On this
    machine, the systemd-networkd daemon is managing the network and notices the Ethernet
    link status (carrier).
  prefs: []
  type: TYPE_NORMAL
- en: Thunderbolt 3 introduced several security features to mitigate unauthorized
    access to memory via direct memory access (DMA).^([2](footnotes.xhtml#ch11foot_02))
    The `boltd` daemon (seen in the preceding example) manages the authorization of
    Thunderbolt 3 devices that have a security level enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '**Printers and Scanners**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Printing and printers have been part of Unix computing since the beginning.
    One of the first applications of Unix was to perform text formatting^([3](footnotes.xhtml#ch11foot_03))
    for printing documents (patent applications) at Bell Labs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Printers and scanners serve as the bridge between the digital and physical
    worlds of documentation. Printers and scanners perform opposite functions: one
    converts electronic files into paper documents, and the other converts paper documents
    into electronic files. Both are standard components'
  prefs: []
  type: TYPE_NORMAL
- en: in offices today and are well supported by Linux systems. Analysis of printing
    and scanning is a standard part of a forensic examination when identifying artifacts
    left behind on a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analysis of Printers and Printing History***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Traditional Unix printing commonly used the BSD line printer daemon (`lpd`)
    to accept and queue print jobs for installed printers. Modern Linux systems adopted
    the common Unix printing system (CUPS), which has had significant involvement
    and support from Apple since it was originally used in its Unix-based OS X operating
    system. Forensic analysis of the printing system may reveal information about
    past printing activity.
  prefs: []
  type: TYPE_NORMAL
- en: The CUPS software package can be configured to use printers that are directly
    connected (typically via USB) or over a network. When printing over a network,
    a variety of protocols are available (IPP, lpr, HP JetDirect, and more), with
    the internet printing protocol (IPP) being preferred. The `cupsd` daemon listens
    for print requests and manages the printing system through a local web server
    on TCP port 631.
  prefs: []
  type: TYPE_NORMAL
- en: 'The */etc/cups/* directory contains the CUPS configuration, and individual
    printers are added to the *printers.conf* file (using the CUPS interface or a
    GUI provided by the distro). Here’s an example */etc/cups/printers.conf* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The printer name `bro` is specified with `<printer bro>` and `</printer>` tags
    (this HTML-like tagging allows multiple printers to be configured in the same
    file). Information about the make and model is recorded, and several time-stamps
    are updated when the printer configuration or attributes change.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to print jobs, the cupsd daemon manages configuration requests and
    other local management tasks. This activity is logged in the */var/log/cups/*
    directory, which may contain the *access_log*, *error_log*, and *page_log* files
    that log information about CUPS activity, including configured printer activity.
    The logs are documented in the cupsd-logs(5) man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *access_log* file records administrative activity as well as print requests
    to different configured printers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the printer is paused and resumed, and then a document is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *error_log* file records various error and warning messages, and it may
    contain interesting information about failed printer installations, problems with
    printing, and other unusual events that could be relevant to an investigation,
    such as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The *error_log* lines begin with a letter (`E` for error, `W` for warning, and
    so on). These error letters are listed in the cupsd-logs(5) man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *page_log* file is especially interesting for investigators because it
    records a history of past printing jobs and filenames; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Two print jobs are shown with the printer name (`bro`), the user who printed
    the job (`sam`), the time of printing, and the filenames.
  prefs: []
  type: TYPE_NORMAL
- en: These logfiles may rotate over time and have a numeric extension added (*error_log.1*,
    *page_log.2*, and so on). In contrast to other user activity, not much information
    is stored in the user’s home directory. The print jobs are passed to the CUPS
    daemon, which manages the configuration and logging as a system-wide function.
    These logs are used for both local and network-configured printers. CUPS has more
    than a dozen man pages, so start with the cups(1) man page or *[https://www.cups.org/](https://www.cups.org/)*
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to CUPS logs, attaching a USB printer to a local machine will generate
    logs in the systemd journal, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, a Brother printer is plugged in at 2:42 PM (`14:42:41`) and unplugged
    a few minutes later at 2:45 PM (`14:45:19`). The model and serial number are shown.
    The USB device (`usblp0`) is also logged, which is useful information when multiple
    printers are attached to a single system.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analysis of Scanning Devices and History***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Scanning under Linux uses the Scanner Access Now Easy (SANE) API. An older competing
    system is TWAIN (*[https://www.twain.org/](https://www.twain.org/)*), but most
    distros are now using SANE. SANE’s popularity is partly because of the separation
    of the frontend GUIs and backend scanner configuration drivers (found in */etc/sane.d/*),
    and the SANE daemon (`saned`) for scanning over a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plugging a USB scanner in to a Linux machine will cause information to be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, a Canon CanoScan device is plugged in a little after 3:00 PM and is then
    unplugged 17 minutes later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any frontend application can use the API provided by the SANE backend libraries.
    This means that interesting logging and persistent data from a forensics perspective
    will be application specific. The following example shows the simple-scan app
    installed by default on Linux Mint. This information is found in the user’s home
    directory in the *~/.cache/simple-scan/ simple-scan.log* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This scan log is recreated each time the `simple-scan` program is used (overwriting
    previous logs). The log times reflect the number of seconds since the program
    started, and timestamps can be calculated by adding these values to the logfile’s
    creation timestamp. Here we see that the program was started and a document was
    scanned a minute later (which took about 25 seconds to complete). Three minutes
    later, the document was saved to the user’s *Documents* folder with the name *Scanned
    Document.pdf* (the `%20` in the log represents a space).
  prefs: []
  type: TYPE_NORMAL
- en: In a forensic examination involving a scanner, you need to determine which scanning
    software was used and then analyze the artifacts for that particular program (XDG
    directories, logs, cache, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '**External Attached Storage**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many forensic investigations, especially those involving the possession of
    illicit material or stolen documents, it is important to identify all storage
    devices that have been attached to the computer under examination. On Linux systems,
    we can find this information in several places.
  prefs: []
  type: TYPE_NORMAL
- en: External storage attaches to a computer system through a hardware interface
    such as USB or Thunderbolt. The computer communicates with these drives over the
    interface using a low-level protocol (SCSI, ATA, USB BoT, and others) to read
    and write sectors (which form the filesystem blocks). Storage devices such as
    USB thumb drives or external disks have the interface electronics and media integrated
    into a single device. However, in some cases, the drive and storage media are
    separate and known as removable media devices. Examples of this include SD cards,
    optical discs (CD/DVD), and magnetic tapes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Storage Hardware Identification***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a new storage device is attached to a Linux system, the appropriate device
    drivers are set up and the device files are created. After the setup is complete,
    filesystems can be mounted. Mounting filesystems can be automatic, manual, or
    performed during system startup. Setting up a newly attached device in the kernel
    is separate and independent from mounting any filesystems it contains. This is
    why we can take a forensic image of a device without mounting it (by accessing
    the device sectors directly).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the kernel recognizes a new storage device, device files are created in
    the */dev/* directory (with the help of udevd), which can be found in the kernel’s
    dmesg log or other system logs. The following example is from the systemd journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the kernel detected a new USB device, determined it was storage, and created
    the `sdc` device. The number of 512-byte sectors is shown, indicating the drive’s
    size (`30031872 512-byte logical blocks`). Information about the manufacturer,
    product, and serial number is also logged. The device name used (`[sdc]` here)
    may be found in other logs during the time the drive was connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a storage device is removed from a Linux system, as mentioned previously,
    the kernel doesn’t generate much information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the USB stick is removed around 15 minutes after being plugged
    in. (Information related to the mounting and unmounting of the drive is described
    in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be obvious from the product, manufacturer, and size whether the storage
    device is a USB stick or an external disk enclosure. But in some cases, you may
    want an additional indicator. If a normal SATA drive housed in a drive enclosure
    is an Advanced Format or 4K Native drive, it may show an additional log line with
    `4096-byte physical blocks`. USB sticks (and older hard drives) will show only
    the 512-byte logical block line. An example of this additional log is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, a disk in an external USB enclosure (a SATA docking station) logs the
    4096-byte physical blocks (4K Native sectors). My previous book, *Practical Forensic
    Imaging* (No Starch Press, 2016), explains Advance Format and 4K Native drives
    in much more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '***Evidence of Mounted Storage***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the kernel has set up the device driver and device files have been created,
    the filesystems can be mounted. Evidence of mounted external drives can be found
    in several places.
  prefs: []
  type: TYPE_NORMAL
- en: 'On servers, filesystems on permanently attached external storage are statically
    configured in the */etc/fstab* file so they are automatically mounted every time
    the system starts up. An example *fstab* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `/` is the root filesystem with the installed operating system, and `/data`
    is the external data drive added by the administrator. This file contains the
    unique UUID, mount directory, and possibly comments added by the administrator.
    Other device-identifying information may be found in the logs (as described in
    the previous section).
  prefs: []
  type: TYPE_NORMAL
- en: On desktop machines, Linux distros want to provide an easy and comfortable user
    experience and typically mount filesystems automatically and display them on the
    desktop or in a file manager. This is done with the `udisks` program that is called
    (via D-Bus) after the system has set up the devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The udisks program creates a temporary mount point in */media/* or */run/ media/*
    where it then mounts the drive. It is then displayed on the user’s desktop or
    in the file manager. The following example shows a log from an automatically mounted
    drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The mounted drive has the volume name `My Awesome Vids`. When the drive is
    unmounted via the Eject menu item on the desktop, it will remove the temporary
    directory after unmounting and log it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The drive can then be physically removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manual mounting will also leave traces in system logfiles. When a system administrator
    mounts a filesystem on the command line to a mount point of their choosing, evidence
    of the manual mounting may be found in the logs and in the shell history. If a
    non-root user manually mounts a filesystem, they will need escalated privileges
    and typically will prefix their command with `sudo`. Here are two examples of
    `mount` commands, one in the shell history of the root user and one in that of
    a normal user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Other indicators to look for may include error messages related to storage,
    bad sectors, or storage removed without cleanly dismounting. Also, depending on
    the file manager used, there may be cached information, history, or bookmarks,
    indicating the use of peripheral storage.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter has covered the analysis of external peripheral devices attached
    to a Linux system. Attaching and removing peripherals leaves traces in the logs,
    which can be examined. In addition, this chapter describes how to analyze the
    printing subsystem and how scanning works. You now should be able to look for
    evidence of attached and removed peripherals and scanned and printed documents.
  prefs: []
  type: TYPE_NORMAL
