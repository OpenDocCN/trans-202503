<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch1" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch1">
<span class="CN"><span aria-label=" Page 1. " epub:type="pagebreak" id="pg_1" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">MAKING THE MOST OF THE TYPE SYSTEM</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" height="191" src="../images/opener-img.png" width="191"/>
</figure>
<p class="COS">Clear and readable source code matters much more to humans than it does to computers. Whether we’re trying to debug existing code or learning to use a new feature, we inevitably find ourselves reading through source code. It’s important to ensure that our code is as readable as possible so that its meaning is clear to other readers. Code that’s hard to follow or easily misunderstood is a breeding ground for errors.</p>
<p class="TX">One way to improve the clarity of our code is to use the type system to our advantage by creating our own types and giving them names that clearly describe their purpose. Good names are important for all the types in a system, but it’s easy to neglect the simple value types that represent an application’s most granular information.</p>
<p class="TX">In this chapter, we’ll examine a short but unclear piece of code and improve it over several iterations through a series of techniques that will <span aria-label=" Page 2. " epub:type="pagebreak" id="pg_2" role="doc-pagebreak"/>help you learn how to use the type system effectively. By the end of the chapter, you’ll have a better understanding of how custom value types contribute to easy-to-understand code and how to incorporate a rich set of types into your designs.</p>
<p class="TX">We’ll explore the following:</p>
<ul class="BL">
<li class="BL">How custom types can help express meaning and make code more self-documenting</li>
<li class="BL">How to encapsulate domain-specific behavior to reduce errors</li>
<li class="BL">Where to use some syntax features from C# v9.0 and v10.0 for compact and readable code</li>
<li class="BL">How to make using custom types easy and natural in commonplace code</li>
</ul>
<p class="TX">To begin, let’s look at a simple example of value types in action and why they’re such an important feature of our designs</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-5"/><samp class="SANS_Futura_Std_Bold_B_11">The Value of Good Names</samp></h2>
<p class="TNI">Choosing good names for identifiers can be difficult but has a major impact on the clarity of our code. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method in <a href="#list1-1">Listing 1-1</a>.</p>
<pre id="list1-1"><code>public static (double, double)&#13;
Displacement(double t, double v, double s)&#13;
{&#13;
    var x = v * s * Math.Cos(t);&#13;
    var y = v * s * Math.Sin(t) - 0.5 * 9.81 * Math.Pow(s, 2);&#13;
    return (x, y);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: An example of bad variable naming</samp></p>
<p class="TX">The method’s three parameters—<samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>—are poorly named, and their purpose isn’t immediately clear. We’ll use this code throughout the chapter to explore a variety of ways to improve it and better define its intent.</p>
<p class="TX">The purpose of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method is to calculate the position of a projectile on its ballistic arc, given an initial angle and velocity, and the time elapsed since the projectile was launched. If you’re familiar with the equations for projectile motion, you may recognize the algorithm, but the variable names provide no clue whatsoever to their purpose. When called, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method calculates the coordinate value of the projectile relative to its launch point, as illustrated in <a href="#fig1-1">Figure 1-1</a>.</p>
<span aria-label=" Page 3. " epub:type="pagebreak" id="pg_3" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img50" height="287" id="fig1-1" src="../images/Figure1-1.png" width="377"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Projectile displacement</samp></p></figcaption>
</figure>
<p class="TX">The angle, initial speed, and time labels in <a href="#fig1-1">Figure 1-1</a> correspond to the <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, respectively. The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values correspond to the components of the tuple returned by that method. The projectile is launched with an initial speed, at a particular angle, and follows a well-defined ballistic arc. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method calculates the projectile’s position on that arc after a given amount of time has passed.</p>
<p class="TX">We won’t go into the algorithm being used here, as our focus is merely on making the purpose of this method more immediately clear. The first barrier to our understanding of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method is the meaning of its parameters and return value.</p>
<p class="TX">I have deliberately exaggerated the issue with single-letter names, but I’ve seen similar examples in the real world and thought, <i>What on earth do those parameters represent?</i> Even if we carefully inspect how the parameters have been used, determining their meaning requires being familiar with the equations. That is just poor code craft. Not all of us have kept up with our ballistics studies.</p>
<p class="TX">We want to make it as easy as possible for the reader to determine the purpose of the method, whether they’re familiar with the topic or not. The quickest way to accomplish this is to ensure that the parameter names better reflect what they represent. In particular, code should avoid relying on specialist jargon. The <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> here stands for <i>theta</i>, which is typically used in physics to represent the magnitude of an angle, but even if we replaced <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> with the full word <samp class="SANS_TheSansMonoCd_W5Regular_11">theta</samp>, readers unfamiliar with this mathematical convention would be unlikely to make that connection.</p>
<p class="TX">Instead of using potentially obscure single-letter names, let’s give the parameters names that properly signify their meaning:</p>
<pre><code>public static (double, double)&#13;
Displacement(double <b>angle</b>, double <b>speed</b>, double <b>elapsedTime</b>)&#13;
{&#13;
<var>--snip--</var></code></pre>
<p class="TX">By renaming <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">angle</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">elapsedTime</samp>, we’ve made their purpose clearer. Changing velocity to speed might seem a minor <span aria-label=" Page 4. " epub:type="pagebreak" id="pg_4" role="doc-pagebreak"/>change, but the names we use <i>matter</i>. While the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> for <i>velocity</i> is common, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> is a more accurate description of this value’s purpose. <i>Velocity</i> is a technical term with a specific meaning in physics; it represents <i>both</i> magnitude (speed) and direction. If we name code elements as accurately and properly as we can, we reduce the risk of those names being misunderstood.</p>
<p class="TX">Selecting good names is a first step toward making code clearer and easier to read. However, we can do much more to improve our code’s clarity and remove ambiguity about what those identifiers represent. We might reasonably ask, for example, in what units the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> parameters are measured. We’ll address that later in the chapter, but first we need a more sophisticated mechanism than the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type allows.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h-6"/><samp class="SANS_Futura_Std_Bold_B_11">Adding Clarity Through Types</samp></h2>
<p class="TNI">All the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method’s parameters are of the same type: <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. This makes it easy for anyone, including ourselves, to accidentally mix up argument values when calling the method—without any warning from the compiler.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type itself is not the specific culprit here; we’d have the same problem if the parameters were all <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> or all <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> types. Even if each parameter were of a different built-in numeric type, plenty of potential for problems would still remain because of the presence of the implicit promotion rules between them. Moreover, clarifying the parameter names doesn’t necessarily help the calling code, especially if the method is called with plain constant values like so:</p>
<pre><code>var result = Displacement(.523, 65, 4);</code></pre>
<p class="TX">Hard-coded values such as those used in this example are called <i>magic numbers</i> because there’s no explanation of their meaning or purpose. We could replace the magic numbers with better-named variables to make their purpose clearer, but the caller of the method might still supply the arguments in the wrong order.</p>
<p class="TX">One common way for the calling code to address such out-of-order errors is to specify the parameter name for each argument. Let’s see that in practice before looking at how to use different types to distinguish between the argument values.</p>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-7"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Named Arguments</samp></h3>
<p class="TNI">Embedding the parameter name for each argument being passed to a method makes the purpose of those arguments much more visible in the calling code, as shown here:</p>
<pre><code>var result = Displacement(angle: .523, speed: 65, elapsedTime: 4);</code></pre>
<p class="TX"><span aria-label=" Page 5. " epub:type="pagebreak" id="pg_5" role="doc-pagebreak"/>This call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method specifies which parameter receives each value being supplied. The caller must match the parameter names of the method but can order them in any way they like:</p>
<pre><code>var result = Displacement(elapsedTime: 4, speed: 65, angle: .523);</code></pre>
<p class="TX">Naming the arguments makes the order in which they’re passed irrelevant. The compiler will ensure that each argument value gets passed to the right parameter according to its name, not its position.</p>
<p class="TX">This technique puts the responsibility of clarity onto the <i>caller</i> of the method. If the caller forgets or doesn’t bother to name the arguments, the compiler won’t warn them. The compiler will also give no warning if the caller mixes up the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>. The code will compile, and the program will run, but it will almost certainly give incorrect results. Worse, the code might give a result that is almost correct for one specific set of arguments and then fail at the worst possible moment when different values are passed. The causes of errors like this can be difficult to track down.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h-8"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Custom Types</samp></h3>
<p class="TNI">The problems we’re seeing with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method stem from using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type to represent several distinct concepts. This is a variation of the <i>Primitive Obsession</i> code smell, which describes any code that has an overreliance on primitive types—that is, those types that are built into the language, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.</p>
<p class="TX">Measurements and quantities such as speed commonly have numerical representations, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type is too general; it can be used to represent a wide variety of values, including <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> in our example, making it possible for the caller of the code to provide the wrong values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> quantities are measured in different ways to mean different things. Using a raw <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> does not express the distinctions between them clearly enough. An angle of 45 degrees is a very different value from a speed of 45 meters per second.</p>
<p class="TX">The well-known solution to primitive obsession is to provide our own types with distinct purposes and to ensure that no implicit conversions exist between them. This enables the compiler to identify any arguments that are used inappropriately. Instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to store quantities of <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, <a href="#list1-2">Listing 1-2</a> defines two types that more positively convey their differences.</p>
<pre id="list1-2"><code>public struct Angle&#13;
{&#13;
    public double Size {get; set;}&#13;
}&#13;
public struct Speed&#13;
{&#13;
    public double Amount {get; set;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-2: Defining our own types</samp></p>
<p class="TX"><span aria-label=" Page 6. " epub:type="pagebreak" id="pg_6" role="doc-pagebreak"/>Our user-defined structs <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> are still quite primitive; they’re merely wrappers around a public property (<samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>, respectively) that allows us to read or write the value being represented in each case. We’ll improve this design, but for now it meets the immediate need: to distinguish values of angle from values of speed by their type rather than just by the parameter names.</p>
<p class="TX"><a href="#list1-3">Listing 1-3</a> demonstrates how we use these new types for the parameters to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method.</p>
<pre id="list1-3"><code>public static (double, double)&#13;
Displacement(<b>Angle</b> angle, <b>Speed</b> speed, <b>TimeSpan</b> elapsedTime)&#13;
{&#13;
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3: Using custom types as parameters</samp></p>
<p class="TX">The C# Standard Library does not provide any abstractions for angles or speeds, but it does have the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> type, which is ideal for the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> parameter. Now the <i>type</i> of each parameter describes its value, so the parameter names have less responsibility. Any attempt to provide the arguments in the incorrect order, like substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>, will cause the compiler to complain with a fairly obvious error message about not being able to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-9"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encapsulation</samp></h3>
<p class="TNI">Using distinct types for the values in a design emphasizes each value’s role rather than its representation, making the code more self-documenting for human readers and allowing better error checking by the compiler. We’ve achieved our stated goal of preventing arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> from being positioned incorrectly, but right now <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> are simple types that just <i>have</i> a value, rather than <i>being</i> a particular kind of value.</p>
<p class="TX">These types do not encapsulate their values in any way because their values are exposed as the publicly mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> properties. Those properties are currently the only way to create instances of those types, as we do in <a href="#list1-4">Listing 1-4</a>, where we use object initialization to set the property values.</p>
<pre id="list1-4"><code>var result = Displacement(angle: new Angle {Size = .523},&#13;
                          speed: new Speed {Amount = 65},&#13;
                          elapsedTime: seconds);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-4: Using object initialization to create inline argument instances</samp></p>
<p class="TX">Using the public properties to set the values here is unnecessarily verbose. <a href="#list1-5">Listing 1-5</a> simplifies the syntax by adding constructors so we can create new instances directly with a value instead of having to set a public property.</p>
<pre id="list1-5"><code><span aria-label=" Page 7. " epub:type="pagebreak" id="pg_7" role="doc-pagebreak"/>public struct Speed&#13;
{&#13;
    <b>public Speed(double amount)</b>&#13;
        <b>=&gt;</b> <b>Amount</b> <b>=</b> <b>amount;</b>&#13;
    public double Amount {get; set;}&#13;
}&#13;
public struct Angle&#13;
{&#13;
    <b>public Angle(double size)</b>&#13;
        <b>=&gt;</b> <b>Size</b> <b>=</b> <b>size;</b>&#13;
    public double Size {get; set;}&#13;
}&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span><samp class="SANS_TheSansMonoCd_W5Regular_11"> var result = Displacement(new Angle(.523), new Speed(65), seconds);</samp></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-5: Adding constructors for Speed and Angle</samp></p>
<p class="TX">Here, when we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances with their values instead of setting their properties <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Now that the type names are more descriptive, the order of the arguments is not ambiguous, so naming the arguments is no longer so important.</p>
<p class="TX">These constructors use the <i>expression body syntax</i>, introduced for methods in C# v6.0 and available since C# v7.0 for constructors. With this syntax, instead of a block enclosed by braces <samp class="SANS_TheSansMonoCd_W5Regular_11">{…}</samp>, the expression is a single assignment separated from the constructor’s signature by the <samp class="SANS_TheSansMonoCd_W5Regular_11">=&gt;</samp> symbol. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> each have only a single property to initialize, the expression-bodied constructors are concise and convenient.</p>
<p class="TX">Compare the final line with <a href="#list1-4">Listing 1-4</a>. The changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in <a href="#list1-5">Listing 1-5</a> allow us to construct the values we want instead of using the object initializer in each case. This reduces the amount of typing the caller has to do but, more importantly, expresses more directly that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> <i>is</i> a value instead of just <i>having</i> a value.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H2" id="sec6"><span id="h-10"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Immutability</samp></h3>
<p class="TNI">Currently, our values are all mutable, but once we’ve given an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> a value in its constructor, we don’t need to allow that value to change. If we require an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> with a different value, we can create a new instance with that value.</p>
<p class="TX">We achieve this immutability by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> to make it a read-only property. Then the only way to provide a value is via the constructor, and that value is permanent and immutable. We’ll do the same for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, as shown in <a href="#list1-6">Listing 1-6</a>.</p>
<pre id="list1-6"><code><span aria-label=" Page 8. " epub:type="pagebreak" id="pg_8" role="doc-pagebreak"/>public <b>readonly</b> struct Speed&#13;
{&#13;
    public Speed(double amount)&#13;
        =&gt; Amount = amount;&#13;
    public double Amount <b>{get;}</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-6: Making Speed immutable</samp></p>
<p class="TX">To ensure that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance can’t change, we also make it <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>. The compiler will then ensure that no members of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> can modify the state and will fail to compile any attempt to change an instance.</p>
<p class="TX">Designing our types to be immutable makes our code easier to reason about during code inspection because we don’t need to consider the various ways that instances of our type might change. This is especially important in multithreaded programs, but making value types read-only can also improve performance in some circumstances by enabling the compiler to use certain optimizations.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-11"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Validation</samp></h3>
<p class="TNI">Having introduced constructors for our types, we can use those constructors to check for invalid arguments and raise exceptions if the user passes illegal values. For example, sensible values for a speed must be nonnegative. In <a href="#list1-7">Listing 1-7</a>, we check that the value given the constructor is not less than 0 and throw an exception if it is.</p>
<pre id="list1-7"><code>public Speed(double amount)&#13;
{&#13;
    if(amount &lt; 0)&#13;
        throw new ArgumentOutOfRangeException(&#13;
            <b>paramName:</b> nameof(amount),&#13;
              <b>message:</b> "Speed must be positive");&#13;
    Amount = amount;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-7: Prohibiting out-of-range values</samp></p>
<p class="TX">The constructor of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> validates the value provided, and since the constructor is the only way to provide a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, we ensure that only legal <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values can be created. We should use the constructor to prohibit other illegal argument values, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>, and perhaps even add an upper limit of the speed of light. If we attempt to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> with an illegal value, we get a run-time exception.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp> type is defined in the Standard Library and is a good example of a descriptively named type. Note that in <a href="#list1-7">Listing 1-7</a>, we name the arguments for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp> constructor, <i>which takes two plain</i> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">string</samp> <i>parameters</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">paramName:</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">message:</samp>). Otherwise, the order of those arguments is easily muddled, especially since the similarly named <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentException</samp> takes the same parameters in the reverse order!</p>
<p class="TX"><span aria-label=" Page 9. " epub:type="pagebreak" id="pg_9" role="doc-pagebreak"/>Validating the parameter value in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor is one example of encapsulation: we’ve put the validation logic in one place instead of scattering it among any methods that use it. Now, any methods that use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance automatically benefit from the range check performed by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>A major benefit of creating our own types is that we encapsulate their responsibilities, thereby reducing the responsibilities of the methods that use them. Minimizing duplicated code is yet another way we make our code clearer, easier to use, and much less difficult to maintain.</i></p>
<p class="TX">The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> establishes a <i>class invariant</i>—a condition that must hold for the lifetime of any instance of the type—specifying that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value is never less than 0. The invariant can never be broken because we made <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> immutable. Once a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance is created, its value never changes, and it’s impossible to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance with an invalid value.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H2" id="sec8"><span id="h-12"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing</samp></h3>
<p class="TNI">By encapsulating the validation within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type, we can also test the class invariant independently of any algorithms that depend on it. In <a href="#list1-8">Listing 1-8</a>, we attempt to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance with a negative value to test that the constructor throws an exception.</p>
<pre id="list1-8"><code>[Test]&#13;
public void Speed_cannot_be_negative()&#13;
{&#13;
    Assert.That(&#13;
        () =&gt; new Speed(-1),&#13;
        Throws.TypeOf&lt;ArgumentOutOfRangeException&gt;());&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-8: Testing constraints on Speed</samp></p>
<p class="TX">Because the validation code is encapsulated within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type, we need only this one test for it. We don’t need to separately test that <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, or any other method using <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, rejects invalid speed values. All the testing for <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> can focus on ensuring that the algorithm is correct, without being concerned about parameter validation.</p>
<p class="TX">Using types for domain concepts, then, has several advantages. Code using our types is clearer because of the self-describing characteristics of the type. We separate concerns, making the program easier to understand and the testing more focused and specific. This makes the tests simpler, and easier to maintain when the code being tested needs to change.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h2 class="H1" id="sec9"><span id="h-13"/><samp class="SANS_Futura_Std_Bold_B_11">Refactoring</samp></h2>
<p class="TNI">Now that we’ve addressed the issues with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method’s parameters, let’s look at its method body to see if we can make further improvements <span aria-label=" Page 10. " epub:type="pagebreak" id="pg_10" role="doc-pagebreak"/>by refactoring the implementation. <a href="#list1-9">Listing 1-9</a> shows our current code for <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>.</p>
<pre id="list1-9"><code>public static (double, double)&#13;
Displacement(Angle angle, Speed speed, TimeSpan elapsedTime)&#13;
{&#13;
    var x = speed.Amount * elapsedTime.TotalSeconds * Math.Cos(angle.Size);&#13;
    var y = speed.Amount * elapsedTime.TotalSeconds * Math.Sin(angle.Size)&#13;
            - 0.5 * 9.81 * Math.Pow(elapsedTime.TotalSeconds, 2);&#13;
    return (x, y);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-9: The current Displacement implementation</samp></p>
<p class="TX">This code works correctly, but we have some issues to take care of. We’ve made the code more verbose by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> types as parameters, requiring us to access properties of those parameters to obtain their values. Note that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> property here; one common error is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp> property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> object when the intention is to obtain the total number of seconds being represented, but <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp> returns only the seconds component of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>. Given a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> representing 1 minute precisely, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp> property would return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, while the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> would be <samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method would be clearer if we could use the variables <i>directly</i> in the algorithm, like this:</p>
<pre><code>    var x = speed * elapsedTime * Math.Cos(angle);&#13;
    var y = speed * elapsedTime * Math.Sin(angle)&#13;
            - 0.5 * 9.81 * Math.Pow(elapsedTime, 2);</code></pre>
<p class="TX">The algorithm also relies on three hard-coded values. Magic numbers like this often indicate that we need to provide names to clarify their purpose. It’s common to find the same magic number used in more than one place, so if the value changed for any reason, we’d need to hunt for every use and make sure we updated them all.</p>
<p class="TX">While we can see that multiplying by <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> is the same as dividing by <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, the meaning of <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp> is much less obvious. The value <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> used in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Pow</samp> are simply arithmetic values; giving them names might obscure their purpose rather than clarifying it. The value <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>, on the other hand, stands out as having a more significant purpose. Once again, to understand the meaning of this number, we need prior knowledge that <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp> is an approximation of the effects of Earth’s gravity on an object. We’ll address this issue first with the simple fix of naming this value.</p>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H2" id="sec10"><span id="h-14"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Magic Numbers with Named Constants</samp></h3>
<p class="TNI">Replacing magic numbers in code with a descriptive name clarifies their meaning to readers unfamiliar with the algorithm’s details. One way to do this is to create a new value type, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, to represent the measurement. However, when we need only a few well-known values, using named <span aria-label=" Page 11. " epub:type="pagebreak" id="pg_11" role="doc-pagebreak"/>constants to represent them is often simpler. For now, we need only a single value (for Earth’s gravity). <a href="#list1-10">Listing 1-10</a> shows one way we could indicate that value’s purpose by giving it a meaningful name.</p>
<pre id="list1-10"><code>public static class Gravity&#13;
{&#13;
    public const double Earth = 9.81;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-10: Simple encoding of magic numbers</samp></p>
<p class="TX">While the named constant for gravity is the simplest replacement for the magic number, we’re passing up an opportunity to benefit from a more general type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Acceleration</samp> or something similar. Doing so would give us the greatest flexibility but would also increase complexity and maintenance. Keeping code simple has its own benefits.</p>
<p class="TX">We should, however, keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> values like this are baked into our code by the compiler, so if we change the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp> but compile against a prebuilt assembly that uses the same constant, the overall program could use two different values for the same constant. In the interests of brevity and simplicity, we’ll keep the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> value and replace the hard-coded number in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp> constant so human readers know immediately what it means:</p>
<pre><code>  <var>--snip--</var> - 0.5 * Gravity.Earth * Math.Pow(elapsedTime.TotalSeconds, 2);</code></pre>
<p class="TX">Now if we want to use a more precise approximation of gravity, we only need to change the constant’s value instead of searching for all uses of the magic number <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>, with the caveat that we must remember to recompile any other modules that use that constant.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-15"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying Properties and Values</samp></h3>
<p class="TNI">Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method is now much more explicit about the meanings of the variables it uses. <a href="#list1-11">Listing 1-11</a> shows its current implementation.</p>
<pre id="list1-11"><code>public static (double, double)&#13;
Displacement(Angle angle, Speed speed, TimeSpan elapsedTime)&#13;
{&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> var x = speed.Amount * elapsedTime.TotalSeconds&#13;
          <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> * Math.Cos(angle.Size);&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> var y = speed.Amount * elapsedTime.TotalSeconds * Math.Sin(angle.Size)&#13;
            - 0.5 * Gravity.Earth * Math.Pow(elapsedTime.TotalSeconds, 2);&#13;
    return (x, y);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-11: Displacement using explicit property access</samp></p>
<p class="TX">As noted earlier, accessing the properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> makes the implementation quite verbose. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method would be tidier and easier still to read if we could access these properties directly <span aria-label=" Page 12. " epub:type="pagebreak" id="pg_12" role="doc-pagebreak"/>in the operations where they were used. The <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property is being multiplied by <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp> is used to call both <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Each use of our types requires us to explicitly obtain the corresponding property value in order to multiply two values together, and to pass them as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods.</p>
<p class="TX">We can’t change the behavior of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> variable to allow it to be multiplied by a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, but a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> can be multiplied by a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> value. If we could use <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances as if they were <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values, we would avoid having to explicitly use their properties in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, making the method less cluttered; that is, we would be able to multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> without using the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp> property. Likewise, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> type, we could call methods such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, which both expect a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> argument, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> variable directly if we could treat <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> instances as <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values.</p>
<p class="TX">The result of the whole expression would be a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>, which is the result type from multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> by a number, so we’d need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> property at some point. Still, removing the need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> would simplify and shorten the method’s implementation.</p>
<p class="TX">One way to achieve that outcome is by defining our own implicit conversion operators. This approach is superficially appealing because it is simple to implement, but it has several drawbacks. Let’s examine some of those potential problems.</p>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implicit Conversions</samp></h4>
<p class="TNI">We define an implicit conversion for our own types by implementing an implicit conversion operator method and specifying the target type we need, as shown for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in <a href="#list1-12">Listing 1-12</a>.</p>
<pre id="list1-12"><code>public readonly struct Speed&#13;
{&#13;
    <var>--snip--</var>&#13;
    public static implicit operator double(Speed speed)&#13;
        =&gt; speed.Amount;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-12: Defining an implicit conversion for Speed</samp></p>
<p class="TX">The target type here is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and we simply return the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property. We also add a similar conversion operator for <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> (not shown here) that returns its <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> property. Now we no longer need to explicitly use <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp> when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, and we can multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> by the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp> value without needing to get the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp> property. Compare <a href="#list1-13">Listing 1-13</a> with the earlier version in <a href="#list1-11">Listing 1-11</a>.</p>
<pre id="list1-13"><code>var x = speed * elapsedTime.TotalSeconds * Math.Cos(angle);&#13;
var y = speed * elapsedTime.TotalSeconds * Math.Sin(angle)&#13;
        - 0.5 * Gravity.Earth * Math.Pow(elapsedTime.TotalSeconds, 2);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-13: Using implicit conversions</samp></p>
<p class="TX"><span aria-label=" Page 13. " epub:type="pagebreak" id="pg_13" role="doc-pagebreak"/>Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> is now much more compact—but we’ve introduced some hidden problems.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Unexpected Interactions</samp></h4>
<p class="TNI">Implicit conversions weaken the interface to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> by allowing them to participate everywhere that a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> might be used, which means they can be used in expressions where it’s not appropriate. For example, dividing a speed by an angle would be a legal expression, as demonstrated in <a href="#list1-14">Listing 1-14</a>.</p>
<pre id="list1-14"><code>var angle = new Angle(.523);&#13;
var speed = new Speed(65);&#13;
var unknown = speed / angle;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-14: Unplanned behavior resulting from an implicit conversion</samp></p>
<p class="TX">This expression is valid owing to the implicit conversions from both <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, but the result is meaningless, and we get no warning from the compiler. In addition, implicit conversions are usually invisible in our code. If we pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value to <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> instead of an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, the resulting calculation errors could be hard to find.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Discarded Invariants</samp></h4>
<p class="TNI">One of the benefits we realized by introducing a custom type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> was that we could encapsulate validation logic in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor.</p>
<p class="TX">Allowing the implicit conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> means that code using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> result can breach the constraints on the allowable range of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>. In <a href="#list1-15">Listing 1-15</a>, we subtract one <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> from another smaller value, leaving us with a result that’s less than 0.</p>
<pre id="list1-15"><code>var verySlow = new Speed(10);&#13;
var reduceBy = new Speed(30);&#13;
var outOfRange = verySlow - reduceBy;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-15: Unchecked constraints resulting from an implicit conversion</samp></p>
<p class="TX">This subtraction expression, which is between two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values as a result of the implicit conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, will run just fine. The result is negative and thus out of range for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, but it’s a perfectly legal <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> value.</p>
<p class="TX">To address this out-of-range value, we need to restrict the permitted operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> so they make sense for those measurements. This was the whole purpose of introducing a class invariant for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to ensure that instances of it always have a valid value. Furthermore, we want to prohibit operations that make no sense, ideally in a way that would allow the compiler to tell us when something is wrong.</p>
<p class="TX"><span aria-label=" Page 14. " epub:type="pagebreak" id="pg_14" role="doc-pagebreak"/>We introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> as specific types so that we could tell them apart, and because using a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> was simply too general to represent those measurements. However, the implicit conversions make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> indistinguishable from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>
<p class="TX">We can still achieve our objective of making our types easy to use in arithmetic expressions, but we need to keep control over which operations those types can perform. We’ll allow specific operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> without sacrificing their natural usage or compromising the encapsulation of the types.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="H2" id="sec15"><span id="h-16"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overloading Arithmetic Operators</samp></h3>
<p class="TNI">Our initial motivation for introducing implicit conversions for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> was to support the multiplication operation between a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> value. Currently, we must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to make that calculation, as shown here:</p>
<pre><code>var x = speed.Amount * elapsedTime.TotalSeconds *&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">--snip--</samp></code></pre>
<p class="TX">Arithmetic operations such as <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> for multiplication are predefined for the built-in numeric types like <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. We can define the meaning of these symbols for our own types by providing arithmetic operator overloads.</p>
<p class="TX"><a href="#list1-16">Listing 1-16</a> shows the multiplication operator overload for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.</p>
<pre id="list1-16"><code>public readonly struct Speed&#13;
{&#13;
    public static Speed operator*(Speed left, double right)&#13;
        =&gt; new (left.Amount * right);&#13;
    <var>--snip--</var>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-16: Supporting multiplication in Speed</samp></p>
<p class="TX">We use a target-typed <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> expression, introduced in C# v9.0, to create the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp> to return. The compiler knows that the expected type is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, as it’s being directly returned, so we don’t need to explicitly specify the type as <samp class="SANS_TheSansMonoCd_W5Regular_11">new Speed(…)</samp>. The compiler will infer the type according to the value expected by the left side of the expression.</p>
<p class="TX">Being able to multiply a speed value by a number makes intuitive sense; something might be traveling at double the speed of something else, for example. We implement the operator by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> from the product of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property and the value passed to the operator’s parameter. The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> will check that the result is within the allowed range of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and will throw an exception if the result is out of range. We can demonstrate that this works with a simple test, such as <a href="#list1-17">Listing 1-17</a>, where we attempt to multiply a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by a negative number.</p>
<pre id="list1-17"><code><span aria-label=" Page 15. " epub:type="pagebreak" id="pg_15" role="doc-pagebreak"/>var speed = new Speed(4);&#13;
Assert.That(&#13;
    () =&gt; speed * -1,&#13;
    Throws.TypeOf&lt;ArgumentOutOfRangeException&gt;());&#13;
var expect = new Speed(2);&#13;
Assert.That(speed * 0.5, Is.EqualTo(expect));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-17: Testing the multiplication operator</samp></p>
<p class="TX">We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and then verify that when we try multiplying it by <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, the constructor throws an exception. We also ensure that when we halve the value, the operation succeeds with the expected result.</p>
<p class="TX">We can define operator overloads for other arithmetic operations and specify precisely the expressions in which <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is permitted to take part. Values commonly overload arithmetic operators, where it is appropriate to do so.</p>
<p class="TX">Not all values are arithmetic in nature, so we need to carefully consider whether to support those operations for a type. For example, creating our own value type to represent a UK postal code would be perfectly natural, but multiplying a postal code by a number or by another postal code makes no sense whatsoever, because postal codes are not arithmetic values. Examples of other nonarithmetic values include US ZIP codes and colors.</p>
<p class="TX">By contrast, <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values should naturally take part in some, but not all, arithmetic expressions. It makes sense to be able to double a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, but not to multiply two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values together. We can use custom arithmetic operator overloads to control which expressions should be permitted, and by adding explicit support for them, we make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> easier to use.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H2" id="sec16"><span id="h-17"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining a Need for New Types</samp></h3>
<p class="TNI">Whenever we refactor a piece of code, we may discover a requirement or opportunity to introduce a new type. The need for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types was fairly plain because we introduced them to replace primitive parameter variables. Not all missing abstractions are so obvious.</p>
<p class="TX">If we multiply a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by a number, the result is a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, but our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method multiplies a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> value, which is not simply a number. Here we split that calculation into separate parts to make it clearer:</p>
<pre><code>var tmp = speed * elapsedTime.TotalSeconds; // a Speed value&#13;
var x = tmp * Math.Cos(angle.Size);</code></pre>
<p class="TX">As noted earlier, multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by a number intuitively produces a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>. Both <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> here are therefore instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, because of our implementation of the multiplication operator, but note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp> value is not just any number but rather a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> instance representing a <i>time</i>. Mathematically, the result of this expression is <span aria-label=" Page 16. " epub:type="pagebreak" id="pg_16" role="doc-pagebreak"/>not a speed at all: multiplying a speed by a time produces a <i>distance</i>, which we can represent directly in our code by introducing a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type, as shown in <a href="#list1-18">Listing 1-18</a>.</p>
<pre id="list1-18"><code>public readonly struct Distance&#13;
{&#13;
    public Distance(double amount)&#13;
        =&gt; Amount = amount;&#13;
    public double Amount {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-18: The Distance type</samp></p>
<p class="TX">We can now create a new overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> that multiplies a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> directly by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> and produces a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>. Even better, we can define this overload in addition to the multiplication operator we’ve already defined that takes a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and returns a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>. <a href="#list1-19">Listing 1-19</a> shows both operator overloads.</p>
<pre id="list1-19"><code>public readonly struct Speed&#13;
{&#13;
    public static Speed operator*(Speed left, double right)&#13;
        =&gt; new (left.Amount * right);&#13;
    public static Distance operator*(Speed left, TimeSpan right)&#13;
        =&gt; new (left.Amount * right.TotalSeconds);&#13;
    <var>--snip--</var>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-19: Overloading operator*</samp></p>
<p class="TX">Overloading is versatile. We can overload a method with different types of parameters, and each overload can return a different type. The rules for overloading consider only the method signature—that is, the number and types of the parameters. We can therefore return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> from the overload taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> from the method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> instance.</p>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Refining the New Type</samp></h4>
<p class="TNI">Next, we need to add behavior to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type so that it will work correctly in our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> implementation. Multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> gives us a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> value, which we use in further arithmetic expressions of its own, shown in <a href="#list1-20">Listing 1-20</a>.</p>
<pre id="list1-20"><code>var distance = speed * elapsedTime;    // a Distance&#13;
var x = distance * Math.Cos(angle.Size);&#13;
var y = distance * Math.Sin(angle.Size)&#13;
        - 0.5 * Gravity.Earth * Math.Pow(elapsedTime.TotalSeconds, 2);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-20: The Distance type in use</samp></p>
<p class="TX"><span aria-label=" Page 17. " epub:type="pagebreak" id="pg_17" role="doc-pagebreak"/>The expressions for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are both now multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> value by the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>. This code will fail to compile because <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> needs its own overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>.</p>
<p class="TX">As with <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values, multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> by a simple number produces a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>. The results of <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, apart from being out of our control, are scalar values, so when we multiply them by a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>, the result is another <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.</p>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> also requires an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator-</samp> so that the subtraction operation used in the calculation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> value will compile. As with the multiplication, the expression on the right of the subtraction gives a scalar value, so we add the multiplication and subtraction operators for <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> in <a href="#list1-21">Listing 1-21</a>.</p>
<pre id="list1-21"><code>public static Distance operator*(Distance left, double right)&#13;
    =&gt; new (left.Amount * right);&#13;
public static Distance operator-(Distance left, double right)&#13;
    =&gt; new (left.Amount - right);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-21: Arithmetic operations for Distance values</samp></p>
<p class="TX">With these overloads, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> values naturally together to produce <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values. Those values, in turn, work seamlessly with the other required expressions.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Design Imperfection</samp></h4>
<p class="TNI">Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method returns a tuple of two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values. However, with our changes, the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values being returned have become instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> rather than plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values. This introduces another terminology problem with respect to the return value: in physics, a distance, like a speed, is always either 0 or a positive value. Combining a distance with the result of a trigonometric function like <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> is a coordinate position, rather than a distance, and can be negative.</p>
<p class="TX">We identified the <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type from the result of multiplying a speed by a time, but there is no straightforward way to distinguish the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> from a plain number like <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>, denying us the opportunity to add an overload of the multiplication operator in <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> to return a new type, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>, rather than another <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>. We have reached the limits of exploiting the types we have chosen for modeling real-world concepts.</p>
<p class="TX">An obstacle like this may be the symptom of a deeper design smell, an indication that the problem might be resolved by a change in design perspective. In this instance, we may be able to achieve a more complete solution by reworking <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>’s algorithm in terms of a full-fledged <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type instead of the relatively primitive <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types. Exploring that solution is fairly complex, however, and best left to a text dedicated to modeling physics problems, leaving us with a pragmatic decision to make.</p>
<p class="TX"><span aria-label=" Page 18. " epub:type="pagebreak" id="pg_18" role="doc-pagebreak"/>One option is to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp> type, or something similar, to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>. This approach suffers from the drawback that the arithmetic operations we defined for <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> do not apply so naturally to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>. Moreover, if <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> is useful elsewhere in an application, it makes complete sense that when we multiply a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>, the result is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>, not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>.</p>
<p class="TX">An alternative approach is to do nothing and permit <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> to have negative values in the context of our application. While <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> would then be an imperfect representation of its counterpart in physics, this approach benefits from simple and natural uses in other areas. In <a href="#list1-22">Listing 1-22</a>, we change the return type of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values directly, which further simplifies the implementation.</p>
<pre id="list1-22"><code><b>public static (Distance, Distance)</b>&#13;
Displacement(Angle angle, Speed speed, TimeSpan elapsedTime)&#13;
{&#13;
    var x = speed * elapsedTime * Math.Cos(angle.Size);&#13;
    var y = speed * elapsedTime * Math.Sin(angle.Size)&#13;
            - 0.5 * Gravity.Earth * Math.Pow(elapsedTime.TotalSeconds, 2);&#13;
    return (x, y);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-22 The new Displacement method</samp></p>
<p class="TX">We could have retained the existing return type by returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> is already widely used, altering the type it returns might be intrusive. Nonetheless, introducing the richer <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type more widely in an application has benefits similar to replacing the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameters in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> types.</p>
<p class="TX">However we decide to best serve the requirements of the application and its users, we can make more pressing improvements to the types used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>. We’re still explicitly using <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method when we call methods in the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> static class. Before we attempt to address that, we need to think carefully about which units of measurement each type represents.</p>
</section>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h2 class="H1" id="sec19"><span id="h-18"/><samp class="SANS_Futura_Std_Bold_B_11">Encoding Units</samp></h2>
<p class="TNI">Measurements like speeds, angles, and distances can have multiple representations, according to the units we’re using for them. As our code stands, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> types do not make those units clear. For example, is speed in meters per second or miles per hour? Are the angles measured in degrees or radians? Using the wrong unit of measurement can introduce errors that are particularly hard to diagnose.</p>
<p class="TX">All the equations used in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> assume that speed is measured in meters per second. This is a reasonable default, because meters per second is the universal International System of Units (SI) unit of speed, but it is <span aria-label=" Page 19. " epub:type="pagebreak" id="pg_19" role="doc-pagebreak"/>implied. If we used a value for speed in kilometers per hour, we’d certainly get unexpected results.</p>
<p class="TX">Similarly, we don’t currently specify the units for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> type. Code that deals with trigonometry commonly uses radians as the unit of measurement, and all the trigonometric functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> class, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>, expect angle values in radians. Most people, however, think of angles in degrees, and confusing the two is a common source of error.</p>
<p class="TX">This exposes the issue of usability: should our code require units that are more convenient for their implementation or more intuitive for the user? Let’s consider this question and investigate whether it’s possible to achieve both aims simultaneously.</p>
<p class="TX">C# has several features we can use to encode units, and one common approach is to represent the different units by using an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>. At first glance, this might seem the obvious solution, but it can cause issues. We’ll explore this option and then investigate an alternative solution using static methods to create our types with the required units.</p>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H2" id="sec20"><span id="h-19"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Itemizing Units with enums</samp></h3>
<p class="TNI">An <i>enumerated type</i>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>, is a set of related strongly typed constants. Using an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> allows us to specify all the units our type supports. <a href="#list1-23">Listing 1-23</a> modifies our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type to use an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> to account for units.</p>
<pre id="list1-23"><code>public readonly struct Speed&#13;
{&#13;
    public enum Units&#13;
    {&#13;
        MetersPerSecond,&#13;
        KmPerSecond,&#13;
        KmPerHour&#13;
    }&#13;
    public Speed(double amount, Units unit)&#13;
    {&#13;
        if(amount &lt; 0)&#13;
            throw new ArgumentOutOfRangeException(&#13;
               paramName: nameof(amount),&#13;
               message: "Speed must be positive");&#13;
        Amount = amount;&#13;
        In = unit;&#13;
    }&#13;
    public double Amount {get;}&#13;
    public Units In {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-23: Specifying units for Speed by using an enum</samp></p>
<p class="TX">In this code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Units</samp> enumeration is a public type nested within <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, telling us that a speed can be represented in meters per second, kilometers per second, or kilometers per hour.</p>
<span aria-label=" Page 20. " epub:type="pagebreak" id="pg_20" role="doc-pagebreak"/>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>While it’s tempting to abbreviate all the names, shortening MetersPerSecond to Ms might be confused with</i> <span class="Roman">milliseconds</span><i>, so it’s best to spell out the unit in this case.</i></p>
<p class="TX">The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> takes a number for the magnitude, and the user must provide one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> values for the required units. The user can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> property later to discover which units were used when a particular <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance was created. By supporting several units of measurement, we make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> more generally useful in other applications.</p>
<p class="TX">Representing supported units with an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> is superficially appealing because it seems simple to implement. However, this approach suffers from drawbacks that become apparent when we need to decide how to handle two values that have different units.</p>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Comparisons and Unit Conversions</samp></h4>
<p class="TNI">We need to consider conversions between units in several places in our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> implementation. For instance, these two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values use different units but nevertheless represent the same speed:</p>
<pre><code>var limit = new Speed(3.6, Speed.Units.KmPerHour);&#13;
var unit  = new Speed(1,   Speed.Units.MetersPerSecond);</code></pre>
<p class="TX">These two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> variables do not compare equal by default, because their <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> properties have different values. We can address that problem by customizing the behavior of equality comparisons for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, perhaps by converting both values to meters per second and comparing those values for equality. However, we have other, more subtle problems to solve too.</p>
<p class="TX">Earlier, we added operator overloads to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to support multiplying them by a scalar value or a time. Adding support for other arithmetic operations, including adding two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>s, would be reasonable. We’d have to convert both values to a common unit in order to add them together, but what unit should the result be in?</p>
<p class="TX">One option would be to always scale every <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value to meters per second—as we do in <a href="#list1-24">Listing 1-24</a> by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor to convert the parameter value according to the required units—but this approach introduces different problems.</p>
<pre id="list1-24"><code>public Speed(double amount, Units unit)&#13;
{&#13;
    if(amount &lt; 0)&#13;
        throw new ArgumentOutOfRangeException(&#13;
            paramName: nameof(amount),&#13;
            message: "Speed must be positive");&#13;
    Amount = unit switch&#13;
    {&#13;
        Units.KmPerHour       =&gt; amount * 1000 / 3600,&#13;
        Units.KmPerSecond     =&gt; amount * 1000,&#13;
        Units.MetersPerSecond =&gt; amount,<span aria-label=" Page 21. " epub:type="pagebreak" id="pg_21" role="doc-pagebreak"/>&#13;
         _                    =&gt; throw new ArgumentException(&#13;
                                    message: $"Unexpected unit {unit}",&#13;
                                    paramName: nameof(unit))&#13;
    };&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-24: Scaling to a common value</samp></p>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property is assigned the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expression, available as of C# v8.0, which uses the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp> parameter value to scale the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> value to meters per second. The final <samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp> selector in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> is an example of a discard pattern and is used if the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp> doesn’t match any of the previous types. Here, we throw an exception in these circumstances, which might occur if we updated the <samp class="SANS_TheSansMonoCd_W5Regular_11">Units enum</samp> with a new element without updating the constructor.</p>
<p class="TX">Note that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp> parameter only to determine how to scale the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> parameter. The units are not stored, so there’s no <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> property either, because a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is always reported in meters per second.</p>
<p class="TX">Storing all instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> using the same units solves the problem of equality comparisons and arithmetic operations, but it has other drawbacks.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Limitations of Using enums for Units</samp></h4>
<p class="TNI">Being able to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances using various units is one thing, but users of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type will also likely expect to be able to obtain the value in different units. The necessary conversions are straightforward to implement: <a href="#list1-25">Listing 1-25</a> repurposes <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> as a method to convert from the internal meters per second value to the units required.</p>
<pre id="list1-25"><code>public Speed In(Units unit)&#13;
{&#13;
    var scaled = unit switch&#13;
    {&#13;
        Units.KmPerHour       =&gt; Amount / 1000 * 3600,&#13;
        Units.KmPerSecond     =&gt; Amount / 1000,&#13;
        Units.MetersPerSecond =&gt; Amount,&#13;
        _                     =&gt; throw new ArgumentException(&#13;
                                    message: $"Unexpected unit {unit}",&#13;
                                    paramName: nameof(unit))&#13;
    };&#13;
    return new Speed(scaled, unit);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-25: Obtaining converted values</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expressions, like those in <a href="#list1-24">Listings 1-24</a> and <a href="#list1-25">1-25</a>, are a characteristic of code that uses enumerations to distinguish different types. Those conversions can be cumbersome and would be a maintenance headache if we added new units.</p>
<p class="TX"><span aria-label=" Page 22. " epub:type="pagebreak" id="pg_22" role="doc-pagebreak"/>Always converting <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values to meters per second in the constructor presents an additional problem: the amount used to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is altered when we use units other than <samp class="SANS_TheSansMonoCd_W5Regular_11">MetersPerSecond</samp>. To demonstrate the issue, consider <a href="#list1-26">Listing 1-26</a>, where we copy a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value by using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property and the same units used to create the original.</p>
<pre id="list1-26"><code>var original = new Speed(3.6, Speed.Units.KmPerHour);&#13;
var copy = new Speed(original.Amount, Speed.Units.KmPerHour);&#13;
Assert.That(original.Equals(copy), Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-26: Testing equality of copied values</samp></p>
<p class="TX">Most people would expect this test to pass, but it fails because <samp class="SANS_TheSansMonoCd_W5Regular_11">original.Amount</samp> was converted to meters per second by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor. The solution is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> method to make the copy, like this:</p>
<pre><code>copy = original.In(Speed.Units.KmPerHour);</code></pre>
<p class="TX">Converting all <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values to the common unit of meters per second simplifies the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, but it’s less convenient for users wishing to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values measured in a different unit.</p>
<p class="TX">In the same way, although representing <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> values in radians is convenient when we need to use an angle in a trigonometric method, it’s much less convenient for users. As mentioned earlier, most humans naturally think of angles in degrees rather than radians, and while the conversion is relatively simple, it’s not part of the Standard Library.</p>
<p class="TX">We therefore still need to bridge the gap between what’s intuitive for a user and what our code uses internally. Next, we look at an alternative approach to enumerations: using static methods that make our types convenient for humans to use and also work seamlessly with standard methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>.</p>
</section>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h3 class="H2" id="sec23"><span id="h-20"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Creation Methods</samp></h3>
<p class="TNI">Instead of using a constructor with an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> parameter to represent units, we can employ the <i>Class Factory Method</i> pattern, which replaces public constructors with static methods to simplify creating instances. These methods have names that reflect the units they represent instead of requiring a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> value to identify those units.</p>
<p class="TX">In our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type, we use the class factory methods in <a href="#list1-27">Listing 1-27</a> to convert the input value to the units used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> internally, and return a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance with that converted value.</p>
<pre id="list1-27"><code>public static Speed FromMetersPerSecond(double amount)&#13;
    =&gt; new (amount);&#13;
public static Speed FromKmPerSecond(double amount)&#13;
    =&gt; new (amount * 1000);&#13;
<span aria-label=" Page 23. " epub:type="pagebreak" id="pg_23" role="doc-pagebreak"/>&#13;
public static Speed FromKmPerHour(double amount)&#13;
    =&gt; new (amount * 1000 / 3600);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-27: Using class factory methods to encode units</samp></p>
<p class="TX">Here, we have three separate ways to create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, each returning a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value converted from the units indicated by the name of the method. When we require a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance, we use the method representing the units we want, as demonstrated in <a href="#list1-28">Listing 1-28</a>.</p>
<pre id="list1-28"><code>var limit =  Speed.FromKmh(88);&#13;
var sound =  Speed.FromMetersPerSecond(343);&#13;
var escape = Speed.FromKmPerSecond(11.2);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-28: Creating Speed values with our new class factory methods</samp></p>
<p class="TX">Now there’s no need for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor to be public. If we allow our users to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances directly with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>, they’ll bypass the class factory methods and lose the benefits of the conversions. To avoid that, in <a href="#list1-29">Listing 1-29</a> we make the constructor private.</p>
<pre id="list1-29"><code>private Speed(double amount)&#13;
{&#13;
    if(amount &lt; 0)&#13;
    {&#13;
        throw new ArgumentOutOfRangeException(&#13;
            paramName: nameof(amount),&#13;
            message: "Speed must be positive");&#13;
    }&#13;
    Amount = amount;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-29: Making our Speed constructor private</samp></p>
<p class="TX">The constructor still contains the validation logic, but now it can be called only by our class factory methods, with the argument suitably scaled to meters per second. We can’t prevent instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> from being default-initialized, but that results in the value being <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, a value that is the same regardless of the units. Note that this is not always true, so we need to be alert for cases where this does <i>not</i> hold. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> degrees Celsius is not the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> degrees Fahrenheit for temperature.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h3 class="H2" id="sec24"><span id="h-21"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Symmetry in Design</samp></h3>
<p class="TNI">While our class factory methods allow us to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values from values measured in different units, the internal representation of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value is in meters per second. To improve usability, we need to provide corresponding conversions in the other direction, so users of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> can choose the units they want when they obtain the value. In <a href="#list1-30">Listing 1-30</a>, we add properties to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> from its internal value to the unit encoded in the name of the property.</p>
<pre id="list1-30"><code><span aria-label=" Page 24. " epub:type="pagebreak" id="pg_24" role="doc-pagebreak"/>public readonly struct Speed&#13;
{&#13;
    <var>--snip--</var>&#13;
    public double InMetersPerSecond =&gt; amount;&#13;
    public double InKmPerSecond     =&gt; amount / 1000.0;&#13;
    public double InKmPerHour       =&gt; amount / 1000 * 3600;&#13;
    private readonly double amount;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-30: Viewing Speed in different units</samp></p>
<p class="TX">We introduce a private data member that can be used from each of these properties. Doing so avoids <i>property forwarding</i> (one property invoking another to obtain the needed value) but also allows us to use an expression body for all three properties. This is largely an aesthetic choice; the most obvious alternative employing property forwarding is shown here:</p>
<pre><code>public double InMetersPerSecond {get;}&#13;
public double InKmPerSecond     =&gt; InMetersPerSecond / 1000.0;&#13;
public double InKmPerHour       =&gt; InMetersPerSecond / 1000 * 3600;</code></pre>
<p class="TX">Whichever approach we choose, we have, in effect, renamed the vague <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property as <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>, whose purpose is to return the internal value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>. The new name better expresses the property’s meaning, matches the naming convention used for the other properties, and mirrors the class factory method <samp class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp>.</p>
<p class="TX">By using similar naming conventions for the <samp class="SANS_TheSansMonoCd_W5Regular_11">From…</samp> methods and the <samp class="SANS_TheSansMonoCd_W5Regular_11">In…</samp> properties, we improve the clarity of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s interface. When we see a method such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmPerHour</samp>, we naturally expect a corresponding method or property that provides the reverse conversion.</p>
<p class="TX">The class factory methods and corresponding properties provide a compact way of expressing units in either direction, and they force us to consciously make clear what we mean when we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H2" id="sec25"><span id="h-22"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Units Explicit</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method does not directly use the units of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, because they are encapsulated in the multiplication operator we created for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>. <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> <i>does</i> use the units of an angle, although those units are currently implied in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.Size</samp> property, as shown in <a href="#list1-31">Listing 1-31</a>.</p>
<pre id="list1-31"><code>var x = speed * elapsedTime * Math.Cos(angle.Size);&#13;
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-31: Angles in Displacement</samp></p>
<p class="TX">Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> require a measurement of an angle in radians, the SI unit for measuring angles. In <a href="#list1-32">Listing 1-32</a>, we rename the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> property as <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> to make the units explicit, and add the conversions to and from degrees as well.</p>
<pre id="list1-32"><code><span aria-label=" Page 25. " epub:type="pagebreak" id="pg_25" role="doc-pagebreak"/>public readonly struct Angle&#13;
{&#13;
    private Angle(double size)&#13;
        =&gt; radians = size;&#13;
    public static Angle FromRadians(double size)&#13;
        =&gt; new (size);&#13;
    public static Angle FromDegrees(double size)&#13;
        =&gt; new (size * Math.PI / 180);&#13;
    public double InRadians =&gt; radians;&#13;
    public double InDegrees =&gt; radians * 180 / Math.PI;&#13;
    private readonly double radians;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-32: Adding unit conversions to Angle</samp></p>
<p class="TX">Just as we did for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, we’ve added class factory methods to create an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> in either degrees or radians, with corresponding properties to obtain the value in either unit. Now we can use an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> easily with methods that require a value in radians, and using <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> is also much more convenient for users, who tend to think in degrees.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h3 class="H2" id="sec26"><span id="h-23"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Choosing the Most Natural Usage</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> methods take a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> argument, so we need to explicitly access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.InRadians</samp> property to call those methods. We can’t change the parameter type of those methods because they’re part of the Standard Library, but we can add similarly named methods to the interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, which would allow us to encapsulate the explicit need to express the units. We can take three main approaches, each with its advantages and drawbacks, and each implemented by forwarding an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> value in radians to its counterpart static <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> static class.</p>
<p class="TX">The most direct approach is to introduce <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> instance methods for <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> field value to the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> method, like this:</p>
<pre><code>public readonly struct Angle&#13;
{&#13;
    <var>--snip--</var>&#13;
    public double Sin() =&gt; Math.Sin(size);&#13;
    public double Cos() =&gt; Math.Cos(size);&#13;
    private readonly double size;&#13;
}</code></pre>
<p class="TX">This approach works because we’ve chosen radians as the underlying unit for an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and we provide methods to convert to and from degrees. <span aria-label=" Page 26. " epub:type="pagebreak" id="pg_26" role="doc-pagebreak"/><a href="#list1-33">Listing 1-33</a> shows how we would use these instance methods in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method. Compare this with <a href="#list1-31">Listing 1-31</a>, where we called <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> directly.</p>
<pre id="list1-33"><code>var x = speed * elapsedTime * angle.Cos();&#13;
var y = speed * elapsedTime * angle.Sin()&#13;
        - 0.5 * Gravity.Earth * Math.Pow(elapsedTime .TotalSeconds, 2);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-33: Invoking our new instance trigonometric methods</samp></p>
<p class="TX">Our second option is to provide our own static class mirroring the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> class with static <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods that take an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> rather than a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> for their parameters. Each method would need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property because it would not have access to the private <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> field. While this approach follows a common convention established by the static <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> class, we lose the more compact usage of calling a member method.</p>
<p class="TX">The third alternative is to define <i>extension methods</i>, which are used as if they’re instance methods but are defined in a separate static class. <a href="#list1-34">Listing 1-34</a> defines <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> extension methods to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>’s interface.</p>
<pre id="list1-34"><code>public static class AngleExtensions&#13;
{&#13;
    public static double Cos(this Angle angle)&#13;
        =&gt; Math.Cos(angle.InRadians);&#13;
    public static double Sin(this Angle angle)&#13;
        =&gt; Math.Sin(angle.InRadians);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-34: Defining extension methods for Angle</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> methods in the static <samp class="SANS_TheSansMonoCd_W5Regular_11">AngleExtensions</samp> class use the special syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">this Angle</samp> for their parameter, which tells the compiler that the method is an extension for an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>. Each method simply forwards the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property of the angle to its counterpart method in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> namespace. We use the extension methods in exactly the same way we called the instance method versions in <a href="#list1-33">Listing 1-33</a>.</p>
<p class="TX">One benefit of both the static and extension method implementations that is sometimes overlooked is that neither version depends on the internal representation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>. The instance member methods could also be implemented in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property, but by extracting methods into separate types if they don’t rely on the private implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, we make the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> smaller and easier to comprehend. <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> explores this topic in more detail.</p>
<p class="TX">Whichever approach we choose, we’ll encapsulate the explicit need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.InRadians</samp> property in order to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> trigonometric methods, making it easy for anyone to use our <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> type.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h3 class="H2" id="sec27"><span id="h-24"/><span aria-label=" Page 27. " epub:type="pagebreak" id="pg_27" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Types Implied by Units</samp></h3>
<p class="TNI">Class factory methods such as those we’ve introduced for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> are a common way of simplifying the creation of value types. This technique is used by the Standard Library in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> type, which has methods such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FromSeconds</samp> paired with a <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> property. The methods encode the units in their names, so creating value instances is very direct:</p>
<pre><code>var speed = Speed.FromKmPerHour(234.0);&#13;
var angle = Angle.FromDegrees(30.0);&#13;
var seconds = TimeSpan.FromSeconds(4.0);</code></pre>
<p class="TX">When we initialize these variables, we’re being explicit about the expected type as well as the units, but a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">234.0kmh</samp> must be a speed. We can’t express this directly, but we can get close by using extension methods.</p>
<p class="TX">The value <samp class="SANS_TheSansMonoCd_W5Regular_11">234.0</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and while we can’t change its built-in definition, we can create extension methods for the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type, as <a href="#list1-35">Listing 1-35</a> shows.</p>
<pre id="list1-35"><code>public static class DoubleExtensions&#13;
{&#13;
    public static Speed Kmh(this double amount)&#13;
        =&gt; Speed.FromKmPerHour(amount);&#13;
    public static Angle Degrees(this double amount)&#13;
        =&gt; Angle.FromDegrees(amount);&#13;
    public static TimeSpan Seconds(this double amount)&#13;
        =&gt; TimeSpan.FromSeconds(amount);&#13;
    <var>--snip--</var>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-35: Extending the interface of double</samp></p>
<p class="TX">Each extension method returns a new instance of the type implied by the units in the method’s name, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">Kmh</samp> method returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> created using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed.FromKmPerHour</samp> class factory method. We use the new extension methods for <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> like this:</p>
<pre><code>var speed = 234.0.Kmh();&#13;
var angle = 30.0.Degrees();&#13;
var seconds = 4.0.Seconds();</code></pre>
<p class="TX">To avoid having to explicitly add the decimal point for the whole numbers, we could add overloads that extend <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> too. While this technique can <span aria-label=" Page 28. " epub:type="pagebreak" id="pg_28" role="doc-pagebreak"/>be useful to allow a compact syntax for <i>literal</i> values, it works less well with variables like this:</p>
<pre><code>    double value = 234.0;&#13;
    <var>--snip--</var>&#13;
    var speed = value.Kmh();</code></pre>
<p class="TX">However we choose to represent the units of measurement, they are a fundamental and intrinsic part of those types. Without units, a number is merely a number, even if the name of the type is descriptive. If we make the units of our value types easy to define and, just as importantly, make it easy to convert between common units, our custom value types will be easier to use and understand.</p>
</section>
</section>
<section aria-labelledby="sec28" epub:type="division">
<h2 class="H1" id="sec28"><span id="h-25"/><samp class="SANS_Futura_Std_Bold_B_11">A Fully Formed Encapsulated Value</samp></h2>
<p class="TNI">Long parameter lists are a hallmark of unclear code. They often indicate that a method doesn’t have one clear responsibility and so would benefit from being refactored. Some or all of the parameters may be related in some way, indicating a missing abstraction. In either case, reducing method parameter lists is another way to improve the clarity of our code.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method used throughout this chapter does have a single, clear responsibility and has only three parameters. However, two of those parameters are related: a velocity is a combination of a speed and a direction. We’ve defined rich types to represent speeds and angles that we can now combine to represent velocity with its own type. <a href="#list1-36">Listing 1-36</a> shows our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> struct.</p>
<pre id="list1-36"><code>public readonly struct Velocity&#13;
{&#13;
    public Velocity(Speed speed, Angle angle)&#13;
        =&gt; (Speed, Direction) = (speed, angle);&#13;
    public Speed Speed {get;}&#13;
    public Angle Direction {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-36: Defining an encapsulated Velocity type</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method no longer needs separate speed and angle values, because they’re now handled by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type:</p>
<pre><code>public static (Distance, Distance)&#13;
Displacement(Velocity v0, TimeSpan elapsedTime)&#13;
{&#13;
    <var>--snip--</var></code></pre>
<p class="TX">Wrapping <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> has two related benefits. First, methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> that required two parameters to represent a <span aria-label=" Page 29. " epub:type="pagebreak" id="pg_29" role="doc-pagebreak"/>velocity now need only one. Second, <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> is a new abstraction to represent a distinct concept. We can give <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> its own specific set of behaviors and semantics and test the semantics independently of anything else.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h2 class="H1" id="sec29"><span id="h-26"/><samp class="SANS_Futura_Std_Bold_B_11">Deciding Whether to Abstract Types</samp></h2>
<p class="TNI">Introducing a new type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> is not always the most appropriate approach. For example, consider the return value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method:</p>
<pre><code>public static (Distance, Distance) Displacement(&#13;
<var>--snip--</var></code></pre>
<p class="TX">With our discussion of using types to represent concepts, abstracting the tuple of <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values as a new type may seem attractive. But we should consider several factors, including how the values will be used, whether there’s any domain-specific behavior we want to associate with an independent type, and whether adding a new type will increase clarity or obscure it.</p>
<p class="TX">If a value is used in only a few places, creating a custom type to represent it may not be worthwhile, unless doing so will also reduce code duplication. If there’s behavior that we want to encapsulate, we’ll benefit from locating that behavior in one place and being able to test it in one place too.</p>
<p class="TX">Whether we can give a useful name to the new type is another important consideration. For example, the tuple of two <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values is similar to a coordinate point, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values representing distance traveled in two dimensions from a point of origin. However, the name <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> would be misleading, because the elements of a coordinate are positions or points rather than distances. Now that we’ve created a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type, however, we might consider revisiting the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> to try to resolve the design problems noted earlier when we introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type. Our example doesn’t warrant the extra complexity that would involve, so instead, we’ll take a simpler approach.</p>
<p class="TX">In the value returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, the names of the tuple components are more important than giving a name to a new type. Rather than defining a completely new type to return from <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, we can take advantage of rich tuple support in C# v7.0 and onward to directly “unpack” the return value into named variables, as shown in <a href="#list1-37">Listing 1-37</a>.</p>
<pre id="list1-37"><code><b>var (range, elevation)</b> = Displacement(velocity, TimeSpan.FromSeconds(0.9));&#13;
Assert.That(range.InMeters, Is.EqualTo(19.09).Within(.01));&#13;
Assert.That(elevation.InMeters, Is.EqualTo(18.78).Within(.01));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-37: Unpacking tuple values</samp></p>
<p class="TX">In this example we use <i>tuple deconstruction</i>, giving each member of the returned tuple value its own name. The compiler deduces the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">range</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">elevation</samp> variables from the values in the tuple, so in this example they’re both instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type. This has the advantages of being both compact and descriptive enough for many purposes.</p>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h2 class="H1" id="sec30"><span id="h-27"/><span aria-label=" Page 30. " epub:type="pagebreak" id="pg_30" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP"><i>We define abstraction as selective ignorance—concentrating on the ideas that are relevant to the task at hand, and ignoring everything else. [...] If abstractions are well designed and well chosen, we believe that we can use them even if we don’t understand all the details of how they work. We do not need to be automotive engineers to drive a car.</i></p>
<footer class="EPS">—Andrew Koenig and Barbara Moo, <i>Accelerated C</i><span class="symbol_Italic">++</span></footer></blockquote>
<p class="BodyContinued">C# provides a few primitive types, especially for numerical values, and it can be tempting to use them as they are. However, a method that just takes a long list of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameters can be difficult to decipher. This problem is not restricted to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>; methods with a long list of <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> parameters suffer from the same pitfalls, but the cure is broadly the same.</p>
<p class="TX">The built-in types are intended to be applicable to a wide range of problems and to be used as the building blocks for more sophisticated types. C# is, after all, an object-oriented language, and it allows us to model our problems with domain-specific types.</p>
<p class="TX">Replacing primitive values with our own types has several practical benefits. It can reduce accidental misuse and defects in the code by ensuring that arguments to methods are explicit. This allows us to take advantage of the compiler’s type checking. If we mistakenly transpose arguments, our code will fail to compile. This kind of early failure prevents those mistakes from causing problems at run time or, worse, making it into a live production system and causing us considerable embarrassment.</p>
<p class="TX">Creating even simple types also allows us to provide descriptive names that make our code more self-describing. In turn, this spares us from having to produce a lot of separate explanatory documentation, which has a tendency to become stale.</p>
<p class="TX">By separating the behavior of a type from the algorithms that use it, and encapsulating that behavior in the type itself, we can test it independently of those algorithms. The type is more cohesive, and the algorithms are clearer and often simpler. Those algorithms themselves become easier for us to test, without having to also test the assumptions and implementations captured by the domain type abstractions.</p>
</section>
</section>
</div></body></html>