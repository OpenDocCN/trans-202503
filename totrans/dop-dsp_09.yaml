- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Orchestrating with Kubernetes
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行编排
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: A container makes applications portable and consistent, but it’s only one piece
    of a modern application stack. Imagine needing to manage thousands of containers
    on different hosts, network ports, and shared volumes. What if one container stopped?
    How could you scale for load? How could you force containers to run on different
    hosts for availability? Container *orchestration* solves all these issues and
    more. *Kubernetes*, or *K8s*, is the open-source orchestration system many companies
    use to manage their containers. Kubernetes comes preloaded with some useful patterns
    (such as networking, role-based access control, and versioned APIs), but it’s
    meant to be the foundational framework on which to build your unique infrastructure
    and tools. Kubernetes is the standard in container orchestration. You can think
    of it as a low-level piece of your infrastructure, just like Linux.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使得应用程序变得便捷和一致，但它只是现代应用程序堆栈中的一部分。试想需要管理成千上万的容器，分布在不同的主机、网络端口和共享卷上。如果某个容器停止了怎么办？如何应对负载的扩展？如何强制容器在不同主机上运行以提高可用性？容器*编排*解决了所有这些问题以及更多问题。*Kubernetes*，或称*K8s*，是许多公司用来管理容器的开源编排系统。Kubernetes自带一些有用的模式（如网络、基于角色的访问控制和版本化的API），但它的目的是作为一个基础框架，在此基础上构建你独特的基础设施和工具。Kubernetes是容器编排的标准。你可以将它视为你的基础设施中的一个低级组件，就像Linux一样。
- en: In this chapter, you’ll learn some basic Kubernetes resources and concepts concerning
    container orchestration. To put orchestration into practice, you’ll deploy the
    telnet-server container image from Chapter 6 inside your Kubernetes cluster using
    the `kubectl` command line client.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习一些基本的Kubernetes资源和与容器编排相关的概念。为了实践编排，你将使用`kubectl`命令行客户端，在你的Kubernetes集群中部署第6章中的telnet-server容器镜像。
- en: Kubernetes from 30,000 Feet
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从30,000英尺的高度看Kubernetes
- en: Kubernetes (which means *helmsman* in Greek) evolved from its predecessors,
    Borg and Omega, at Google. It was open-sourced in 2014 and has received great
    community support and many enhancements since then.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes（在希腊语中意为*舵手*）是由Google的Borg和Omega系统演变而来。它于2014年开源，并自那时起获得了广泛的社区支持和多次增强。
- en: A Kubernetes cluster consists of one or more control plane nodes and one or
    more worker nodes. A *node* can be anything from a cloud VM to a bare-metal racked
    server to a Raspberry Pi. The *control plane nodes* handle things like the Kubernetes
    API calls, the cluster state, and the scheduling of containers. The core services
    (such as the API, etcd, and the scheduler) run on the control plane. The *worker
    nodes* run the containers and resources that are scheduled by the control plane.
    See [Figure 7-1](#figure7-1) for more details.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Kubernetes集群由一个或多个控制平面节点和一个或多个工作节点组成。*节点*可以是任何类型的计算资源，从云虚拟机到裸金属服务器，再到树莓派。*控制平面节点*处理像Kubernetes
    API调用、集群状态以及容器调度等任务。核心服务（如API、etcd和调度器）运行在控制平面上。*工作节点*运行由控制平面调度的容器和资源。更多细节见[图7-1](#figure7-1)。
- en: '![Diagram showing the command line interface, connected to the control plane
    node 1, which has the API server, scheduler, controller, and etcd layers. The
    control plane connects to the worker node 1\. Inside the worker node are pods
    1 and 2, docker, and the kubelet and kube-proxy layers.](image_fi/502482c07/f07001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图示显示了命令行界面，连接到控制平面节点1，该节点包括API服务器、调度器、控制器和etcd层。控制平面连接到工作节点1。工作节点内有pod 1和2、docker、kubelet和kube-proxy层。](image_fi/502482c07/f07001.png)'
- en: 'Figure 7-1: The basic building blocks of a Kubernetes cluster'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：Kubernetes集群的基本构建模块
- en: Networking and scheduling are the most complex issues you’ll encounter when
    orchestrating containers. When networking containers, you must consider all the
    ports and access they need. Containers can communicate with each other, both inside
    and outside the cluster. This happens with microservices internal communication
    or when running a public-facing web server. When scheduling containers, you must
    take into account the current system resources and any special placement strategies.
    You can tune a worker node for a specific use case, like high connections, and
    then create rules to ensure that the applications that need that feature end up
    on that specific worker node. This is called *node affinity*. As a container orchestrator,
    you also need to restrict user authentication and authorizations. You can use
    an approach like role-based access control, which allows containers to run in
    a safe and controlled manner. These approaches represent just a small part of
    the complex glue and wiring you’ll need. It takes a whole framework to successfully
    deploy and manage containers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和调度是你在编排容器时遇到的最复杂的问题。在容器网络配置时，你必须考虑所有需要的端口和访问权限。容器可以在集群内外相互通信。这发生在微服务的内部通信中，或者在运行面向公众的Web服务器时。当调度容器时，你必须考虑当前系统资源和任何特殊的部署策略。你可以针对特定的用例调整工作节点，例如高连接数，然后创建规则以确保需要该功能的应用程序最终会部署到该特定工作节点。这被称为*节点亲和性*。作为一个容器编排器，你还需要限制用户认证和授权。你可以使用像基于角色的访问控制这样的方式，它允许容器在安全和受控的方式下运行。这些方法仅代表了你需要的复杂“胶水”和“布线”的一小部分。成功部署和管理容器需要一个完整的框架。
- en: Kubernetes Workload Resources
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes工作负载资源
- en: A *resource* is a type of object that encapsulates state and intent. To make
    this concept a little clearer, let’s consider an automobile analogy. If a workload
    running on Kubernetes were a car, the resources would describe the parts of the
    car. For example, you could set your car to have two seats and four doors. You
    would not have to understand how to make a seat or a door. You would just need
    to know that Kubernetes will maintain the given count for both (no more, no less).
    Kubernetes resources are defined in a file called a *manifest*. Throughout this
    chapter, we will use the terms *resource* and *object* interchangeably.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*资源*是封装状态和意图的一种对象类型。为了让这个概念更清晰一点，我们可以用汽车做一个类比。如果运行在Kubernetes上的工作负载是一辆车，那么资源就描述了车的各个部分。例如，你可以设置你的车有两个座位和四个车门。你不需要了解如何制造座位或车门，你只需要知道Kubernetes会维持这两个部件的数量（不多也不少）。Kubernetes资源在一个叫做*manifest*的文件中定义。在本章中，我们将交替使用*资源*和*对象*这两个术语。'
- en: Let’s look at the most commonly used Kubernetes resources in a modern application
    stack.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看现代应用栈中最常用的Kubernetes资源。
- en: Pods
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pods
- en: '*Pods* are the smallest building blocks in Kubernetes, and they form the foundation
    for everything interesting you’ll do with containers. A Pod is made up of one
    or more containers that share network and storage resources. Each container can
    connect to the other containers, and all containers can share a directory between
    them by a mounted volume. You won’t deploy Pods directly; instead, they’ll be
    incorporated into a higher-level abstraction layer like a ReplicaSet.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pods*是Kubernetes中最小的构建模块，它们构成了你与容器进行各种操作的基础。一个Pod由一个或多个共享网络和存储资源的容器组成。每个容器都可以连接到其他容器，所有容器可以通过挂载的卷共享一个目录。你不会直接部署Pods；相反，它们会被集成到像ReplicaSet这样的更高层抽象中。'
- en: ReplicaSet
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReplicaSet
- en: A *ReplicaSet* resource is used to maintain a fixed number of identical Pods.
    If a Pod is killed or deleted, the ReplicaSet will create another Pod to take
    its place. You’ll only want to use a ReplicaSet if you need to create a custom
    orchestration behavior. Typically, you should reach for a Deployment to manage
    your application instead.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*ReplicaSet*资源用于维护固定数量的相同Pods。如果一个Pod被终止或删除，ReplicaSet会创建另一个Pod来替代它。如果你需要创建自定义的编排行为，才会使用ReplicaSet。通常，你应该选择Deployment来管理你的应用。'
- en: Deployments
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Deployments
- en: A *Deployment* is a resource that manages Pods and ReplicaSets. It is the most
    widely used resource for governing applications. A Deployment’s main job is to
    maintain the state that is configured in its manifest. For example, you can define
    the number of Pods (which are called *replicas* in this context) along with the
    strategy for deploying new Pods. The Deployment resource controls a Pod’s lifecycle—from
    creation, to updates, to scaling, to deletion. You can also roll back to earlier
    versions of a Deployment if needed. Anytime your application needs to be long
    lived and fault tolerant, a Deployment should be your first choice.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Deployment* 是一种资源，用于管理 Pods 和 ReplicaSets。它是管理应用程序时最常用的资源。Deployment 的主要任务是维持其清单中配置的状态。例如，你可以定义
    Pods 的数量（在这种情况下称为 *replicas*）以及部署新 Pods 的策略。Deployment 资源控制 Pod 的生命周期——从创建、更新、扩展到删除。如果需要，你还可以回滚到早期版本的
    Deployment。当你的应用程序需要长期运行且具备容错能力时，Deployment 应该是你的首选。'
- en: StatefulSets
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StatefulSets
- en: A *StatefulSet* is a resource for managing stateful applications, such as PostgreSQL,
    ElasticSearch, and etcd. Similar to a Deployment, it can manage the state of Pods
    defined in a manifest. However, it also adds features like managing unique Pod
    names, managing Pod creation, and ordering termination. Each Pod in a StatefulSet
    has its own state and data bound to it. If you are adding a stateful application
    to your cluster, choose a StatefulSet over a Deployment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*StatefulSet* 是用于管理有状态应用程序（如 PostgreSQL、ElasticSearch 和 etcd）的一种资源。类似于 Deployment，它可以管理清单中定义的
    Pods 的状态。但它还增加了管理唯一 Pod 名称、Pod 创建和终止顺序等功能。StatefulSet 中的每个 Pod 都有自己的状态和绑定的数据。如果你要将有状态应用程序添加到集群中，选择
    StatefulSet 而不是 Deployment。'
- en: Services
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Services
- en: '*Services* allow you to expose applications running in a Pod or group of Pods
    within the Kubernetes cluster or over the internet. You can choose from the following
    basic Service types:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*Services* 允许你将运行在 Pod 或一组 Pods 中的应用程序暴露到 Kubernetes 集群内部或互联网上。你可以选择以下基本 Service
    类型：'
- en: '`ClusterIP` This is the default type when you create a Service. It is assigned
    an internal routable IP address that proxies connections to one or more Pods.
    You can access a `ClusterIP` only from within the Kubernetes cluster.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ClusterIP` 是创建 Service 时的默认类型。它会分配一个内部可路由的 IP 地址，并将连接代理到一个或多个 Pods。你只能从 Kubernetes
    集群内部访问 `ClusterIP`。'
- en: '`Headless` This does not create a single-service IP address. It is not load
    balanced.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Headless` 不会创建单一的 Service IP 地址，也不会进行负载均衡。'
- en: '`NodePort` This exposes the Service on the node’s IP addresses and port.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NodePort` 通过节点的 IP 地址和端口来暴露 Service。'
- en: '`LoadBalancer` This exposes the Service externally. It does this either by
    using a cloud provider’s component, like AWS’s Elastic Load Balancing (ELB), or
    a bare-metal solution, like MetalLB.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoadBalancer` 将 Service 暴露到外部。它可以通过使用云服务提供商的组件，如 AWS 的 Elastic Load Balancing
    (ELB)，或者使用裸金属解决方案，如 MetalLB，来实现这一点。'
- en: '`ExternalName` This maps a Service to the contents of the `externalName` field
    to a `CNAME` record with its value.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExternalName` 将一个 Service 映射到 `externalName` 字段中的内容，并创建一个其值的 `CNAME` 记录。'
- en: You’ll use `ClusterIP` and `LoadBalancer` the most. Note that only the `LoadBalancer`
    and `NodePort` Services can expose a Service outside the Kubernetes cluster.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将最常使用 `ClusterIP` 和 `LoadBalancer`。请注意，只有 `LoadBalancer` 和 `NodePort` 类型的 Service
    才能将 Service 暴露到 Kubernetes 集群外部。
- en: Volumes
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Volumes
- en: A *Volume* is basically a directory, or a file, that all containers in a Pod
    can access, with some caveats. Volumes provide a way for containers to share and
    store data between them. If a container in a Pod is killed, the Volume and its
    data will survive; if the entire Pod is killed, the Volume and its contents will
    be removed. Thus, if you need storage that is not linked to a Pod’s lifecycle,
    use a *Persistent Volume (PV)* for your application. A PV is a resource in a cluster
    just like a node. Pods can use the PV resource, but the PV does not terminate
    when the Pod does. If your Kubernetes cluster is running in AWS, you can use *Amazon
    Elastic Block Storage (Amazon EBS)* as your PV. This makes Pod catastrophes easier
    to survive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*Volume* 本质上是一个目录或文件，Pod 中的所有容器都可以访问，但有一些限制。Volumes 提供了一种容器之间共享和存储数据的方式。如果
    Pod 中的一个容器被杀死，Volume 和其数据将存活；如果整个 Pod 被杀死，Volume 及其内容将被移除。因此，如果你需要的存储与 Pod 的生命周期无关，请为你的应用程序使用
    *Persistent Volume (PV)*。PV 是集群中的一种资源，就像节点一样。Pods 可以使用 PV 资源，但 PV 不会随着 Pod 的终止而结束。如果你的
    Kubernetes 集群运行在 AWS 上，你可以使用 *Amazon Elastic Block Storage (Amazon EBS)* 作为你的
    PV，这使得 Pod 故障更容易恢复。'
- en: Secrets
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Secrets
- en: '*Secrets* are convenient resources for safely and reliably sharing sensitive
    information (such as passwords, tokens, SSH keys, and API keys) with Pods. You
    can access Secrets either via environment variables or as a Volume mount inside
    a Pod. Secrets are stored in a RAM-backed filesystem on the Kubernetes nodes until
    a Pod requests them. When not used by a Pod, they are stored in memory, instead
    of in a file on disk. However, be careful because the Secrets manifest expects
    the data to be in Base64 encoding, which is not a form of encryption.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*秘密*是一个方便的资源，用于安全可靠地与Pods共享敏感信息（如密码、令牌、SSH密钥和API密钥）。你可以通过环境变量或作为Pod内的卷挂载来访问秘密。秘密存储在Kubernetes节点的内存文件系统中，直到Pod请求它们。当Pod不使用时，它们会保存在内存中，而不是磁盘上的文件中。然而，要小心，因为秘密清单要求数据以Base64编码的形式存储，这并不是一种加密形式。'
- en: With Secrets, sensitive information is kept separate from the application. This
    is because such information is more likely to be exposed in the continuous integration/continuous
    deployment process than if it’s living in a resource. You still need to keep your
    Secret manifests safe by using RBAC to restrict broad access to the Secrets API.
    You can also store the sensitive data encrypted in the Secret and have another
    process to decrypt it on the Pod once it is mounted or needed. Another option
    is to encrypt the manifests locally before adding them to version control. No
    matter which method you choose, make sure you have a secure plan for storing sensitive
    information in Secrets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用秘密，敏感信息与应用程序分开存储。这是因为这类信息在持续集成/持续部署过程中比存储在资源中时更容易暴露。你仍然需要通过使用RBAC来保护你的秘密清单，限制对Secrets
    API的广泛访问。你还可以将敏感数据加密存储在秘密中，并通过其他过程在Pod挂载或需要时解密它。另一个选项是在将其添加到版本控制之前先在本地加密清单。无论选择哪种方法，确保你有一个安全的计划来存储Secrets中的敏感信息。
- en: ConfigMaps
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置映射
- en: '*ConfigMaps* allow you to mount nonsensitive configuration files inside a container.
    A Pod’s containers can access the ConfigMap from an environment variable, from
    command line arguments, or as a file in a Volume mount. If your application has
    a configuration file, putting it into a ConfigMap manifest provides two main benefits.
    First, you can update or deploy a new manifest file without having to redeploy
    your whole application. Second, if you have an application that watches for changes
    in a configuration file, then when it gets updated, your application will be able
    to reload the configuration without having to restart.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*配置映射*允许你将非敏感的配置文件挂载到容器内。Pod中的容器可以通过环境变量、命令行参数，或作为卷挂载中的文件访问配置映射。如果你的应用有配置文件，将其放入配置映射清单提供了两个主要的好处。首先，你可以更新或部署新的清单文件，而不需要重新部署整个应用。其次，如果你的应用程序监控配置文件的变化，那么当配置文件更新时，应用程序将能够重新加载配置，而不必重启。'
- en: Namespaces
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: The *Namespace* resource allows you to divide a Kubernetes cluster into several
    smaller virtual clusters. When a Namespace is set, it provides a logical separation
    of resources, even though those resources can reside on the same nodes. If you
    don’t specify a Namespace when creating a resource, it will inherit the Namespace
    cleverly named *default*. If your team has many users and a lot of projects spread
    among them, you might split those teams or applications into separate Namespaces.
    This makes it easy to apply secure permissions or other constraints to only those
    resources.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间*资源允许你将一个Kubernetes集群划分为多个较小的虚拟集群。当设置了命名空间时，它提供了资源的逻辑分离，尽管这些资源可以位于相同的节点上。如果在创建资源时没有指定命名空间，它将继承巧妙地命名为*default*的命名空间。如果你的团队有很多用户，并且项目分布广泛，你可能会将这些团队或应用分割到不同的命名空间中。这样可以轻松地对这些资源应用安全权限或其他约束。'
- en: Deploying the Sample telnet-server Application
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署示例telnet-server应用
- en: To start exploring Kubernetes, you’ll create a Deployment and two Services for
    the telnet-server application. I have chosen a Deployment to provide fault tolerance
    for your application. The two Services will expose the telnet-server application
    port and the application metrics port. By the end of this section, you’ll have
    a Kubernetes Deployment with two Pods (replicas) running the telnet-server application
    that can be accessed from your local host.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始探索Kubernetes，你将创建一个Deployment和两个telnet-server应用的服务。我选择了Deployment来为你的应用提供容错性。这两个服务将暴露telnet-server应用的端口和应用的指标端口。在本节结束时，你将拥有一个Kubernetes
    Deployment，其中包含两个运行telnet-server应用的Pod（副本），并且可以从本地主机访问。
- en: Interacting with Kubernetes
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Kubernetes的交互
- en: Before you can deploy your telnet-server application, you’ll need to make sure
    you can connect to your Kubernetes cluster. The most direct way to interact with
    the cluster is to use the `kubectl` command line application, which you can get
    in two ways. The first way is to download the standalone binary from [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    for your specific OS. The second way, which you’ll use here, is to leverage minikube’s
    built-in support for `kubectl`. Minikube will fetch the `kubectl` binary for you
    the first time you invoke the `minikube kubectl` command (if it’s not already
    installed).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在你部署你的telnet-server应用程序之前，你需要确保可以连接到你的Kubernetes集群。与集群交互的最直接方式是使用`kubectl`命令行工具，你可以通过两种方式获得它。第一种方式是从[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)下载适合你操作系统的独立二进制文件。第二种方式，就是你将在这里使用的方式，即利用minikube内置的`kubectl`支持。每当你第一次调用`minikube
    kubectl`命令时（如果还没有安装），minikube会为你下载`kubectl`二进制文件。
- en: When using `minikube kubectl`, most commands will require double dashes (`--`)
    between `minikube kubectl` and subcommands. The standalone version of `kubectl`,
    however, does not need dashes between the commands. If you already have `kubectl`
    installed or want to use the standalone version, drop the `minikube` prefix and
    the double dashes from all the examples that follow.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`minikube kubectl`时，大多数命令需要在`minikube kubectl`和子命令之间加上双短横线（`--`）。然而，独立版本的`kubectl`则不需要命令之间的短横线。如果你已经安装了`kubectl`，或者希望使用独立版本，只需去掉接下来所有示例中的`minikube`前缀和双短横线。
- en: 'Let’s start out with a simple command so minikube can download the `kubectl`
    binary and test access to the cluster. Use the `cluster-info` subcommand for this
    example to verify that the cluster is up and running:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的命令开始，这样minikube就可以下载`kubectl`二进制文件并测试集群的访问。使用`cluster-info`子命令来验证集群是否已启动并正常运行：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’ll want to see similar output that indicates you can connect to the Kubernetes
    cluster. If there were an issue with talking to the cluster, you might see an
    error like `"The control plane node must be running for this command"`. If that
    happens, enter the `minikube status` command to make sure minikube is still up
    and running.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到类似的输出，表明你能够连接到Kubernetes集群。如果与集群的通信有问题，你可能会看到类似 `"The control plane node
    must be running for this command"` 的错误。如果发生这种情况，输入`minikube status`命令，确保minikube仍然正常运行。
- en: Reviewing the Manifests
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看清单
- en: Now that you have access to the cluster, review the provided manifests for the
    Deployment and Services. Kubernetes manifests are files designed to describe the
    desired state for applications and services. They manage resources like Deployments,
    Pods, and Secrets. These files can either be in JSON or YAML; we use the YAML
    format for this book, purely out of preference. The manifest files should be kept
    under source control. You’ll usually find the files co-residing with the application
    they describe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以访问集群，查看提供的部署（Deployment）和服务（Services）清单。Kubernetes 清单是用于描述应用程序和服务期望状态的文件。它们管理诸如部署（Deployments）、Pod和Secrets等资源。这些文件可以是JSON格式或YAML格式；我们在本书中使用YAML格式，纯粹是出于个人喜好。清单文件应当放在源代码管理下。你通常会发现这些文件与它们描述的应用程序共同存放。
- en: I have provided the manifest files to create the telnet-server Deployment and
    two Services. The files are located in the repository at [https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/).
    Navigate to the *telnet-server/* directory and list the files in the *kubernetes/*
    subdirectory. There, you should find two files. The first file, *deployment.yaml*,
    creates a Kubernetes Deployment with two Pods of the telnet-server container image.
    The second file, *service.yaml*, creates two separate Services. The first Service
    creates a `LoadBalancer` so you can connect to the telnet-server from outside
    the Kubernetes cluster. The other Service creates a `ClusterIP`, which exposes
    the metrics endpoint from within the cluster. Don’t worry about the metrics port
    for this chapter—we’ll use it in Chapter 9 when discussing monitoring and metrics.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我已提供清单文件来创建 telnet-server 部署和两个服务。这些文件位于仓库 [https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/)
    中。导航到 *telnet-server/* 目录，并列出 *kubernetes/* 子目录中的文件。你应该能找到两个文件。第一个文件，*deployment.yaml*，创建了一个包含两个
    telnet-server 容器镜像 Pod 的 Kubernetes 部署。第二个文件，*service.yaml*，创建了两个独立的服务。第一个服务创建了一个
    `LoadBalancer`，这样你就可以从 Kubernetes 集群外部连接到 telnet-server。另一个服务创建了一个 `ClusterIP`，它暴露了集群内部的度量端点。不要担心本章中的度量端口——我们将在第九章讨论监控和度量时使用它。
- en: 'These manifest files can be quite verbose, so we’ll focus on the basic structure
    each file contains. To describe a complex object, you’ll need multiple fields,
    subfields, and values to define how a resource behaves. Because of this, it can
    be difficult to write a manifest from scratch. Among all these fields and values,
    there is a subset of required fields called *top-level fields*. These are common
    across all manifest files. Understanding top-level fields makes it easier to remember
    and parse a manifest file. The four top-level fields are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些清单文件可能相当冗长，所以我们将重点关注每个文件包含的基本结构。为了描述一个复杂对象，你需要多个字段、子字段和数值来定义资源的行为。由于这个原因，从头开始编写清单可能会很困难。在所有这些字段和数值中，有一部分必需字段称为
    *顶级字段*。这些字段在所有清单文件中都是通用的。理解顶级字段使得记住和解析清单文件变得更容易。四个顶级字段如下：
- en: '`apiVersion` This is a Kubernetes API version and group, like apps/v1\. Kubernetes
    uses versioned APIs and groups to deliver different versions of features and support
    for resources.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`apiVersion` 这是一个 Kubernetes API 版本和组，例如 apps/v1。Kubernetes 使用版本化的 API 和组来提供不同版本的功能和资源支持。'
- en: '`kind` This is the type of resource you want to create, such as a Deployment.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kind` 这是你想要创建的资源类型，例如 Deployment。'
- en: '`metadata` This is where you set things like names, annotations, and labels.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`metadata` 这是你设置诸如名称、注解和标签之类内容的地方。'
- en: '`spec` This is where you set the desired behavior for the resource (kind).'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spec` 这是你设置资源（类型）所需行为的地方。'
- en: Each of these top-level fields contains multiple subfields. The subfields contain
    information such as name, replica count, template, and container image. For example,
    `metadata` has `name` and `labels` subfields. The formats for the fields can be
    different for each Kubernetes resource. I won’t describe every field, but I’ll
    often use the `labels` subfield. *Labels* provide a way for the user to tag a
    resource with identifiable key values. For example, you could add a label to all
    resources that are in the `production environment`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些顶级字段中的每一个都包含多个子字段。子字段包含诸如名称、副本数量、模板和容器镜像等信息。例如，`metadata` 包含 `name` 和 `labels`
    子字段。每个 Kubernetes 资源的字段格式可能有所不同。我不会描述每个字段，但我会经常使用 `labels` 子字段。*标签*为用户提供了一种方式，可以通过可识别的键值对标记资源。例如，你可以为所有处于
    `生产环境` 中的资源添加标签。
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can use these `labels` to narrow down search results and group similar applications
    together, as with a frontend website and its backend database counterpart. You’ll
    use `labels` later, when you invoke the `minikube kubectl` command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些 `labels` 来缩小搜索结果并将类似的应用程序分组在一起，比如前端网站和其后端数据库对应的应用。稍后，当你调用 `minikube
    kubectl` 命令时，你会使用 `labels`。
- en: 'Listing all the different field structures in a manifest file would take up
    a lot of real estate. Instead, you can explore the documentation in two different
    places. The Kubernetes documentation at [https://kubernetes.io/docs/concepts/overview/working-with-objects/](https://kubernetes.io/docs/concepts/overview/working-with-objects/)
    describes all the resources and provides examples. The second place to explore,
    which is my favorite, is the `explain` subcommand for `kubectl`. The `explain`
    subcommand describes the fields associated with each resource type. You can use
    the dot (`.`) notation as a type field separator when searching for nested fields.
    For example, to learn more about a Deployment’s `metadata` `labels` subfield,
    enter the following in a terminal:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列出清单文件中所有不同的字段结构会占用大量空间。相反，你可以在两个不同的地方探索文档。Kubernetes 文档在[https://kubernetes.io/docs/concepts/overview/working-with-objects/](https://kubernetes.io/docs/concepts/overview/working-with-objects/)中描述了所有资源并提供了示例。第二个探索的地方，是我最喜欢的，`kubectl`的`explain`子命令。`explain`子命令描述了与每个资源类型相关的字段。你可以在查找嵌套字段时使用点（`.`）符号作为字段分隔符。例如，要了解更多关于部署的`metadata`
    `labels`子字段的信息，可以在终端输入以下内容：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how this example first searches for the resource type, then its top-level
    field, and then the subfield.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，示例首先搜索资源类型，然后是其顶级字段，再然后是子字段。
- en: Examining the telnet-server Deployment
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查 telnet-server 部署
- en: 'Now that you have an understanding of the building blocks of a manifest file,
    let’s apply what you’ve learned to the telnet-server Deployment manifest. I’ve
    broken the *deployment.yaml* file into sections to make it easier to dissect.
    The first section at the top of the file has the `apiVersion`, `kind`, and `metadata`
    fields:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了清单文件的构建块，让我们将所学应用到 telnet-server 部署的清单中。我将*deployment.yaml*文件拆分为几个部分，以便更容易解析。文件顶部的第一部分包含了`apiVersion`、`kind`和`metadata`字段：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The type (`kind`) is `Deployment`, which uses the Kubernetes API group `apps`
    and API version `v1`. Under the `metadata` field, the Deployment `name` is set
    to `telnet-server`, and the `labels` are set to `app: telnet-server`. You’ll use
    this label when searching for the telnet-server Deployment later on.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '类型（`kind`）是`Deployment`，使用 Kubernetes API 组`apps`和 API 版本`v1`。在`metadata`字段下，部署的`name`设置为`telnet-server`，`labels`设置为`app:
    telnet-server`。你将在稍后查找 telnet-server 部署时使用这个标签。'
- en: 'The next section of the file contains the parent `spec` field that describes
    the behavior and specification of the Deployment. The `spec` field contains a
    lot of subfields and values:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的下一部分包含父级`spec`字段，它描述了部署的行为和规范。`spec`字段包含许多子字段和数值：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, `spec` describes the `replicas` count for the Deployment; it’s set to
    `2` to reflect the number of Pods you want to run. Inside the `selector` field,
    `matchLabels` locates the Pods that this Deployment will affect. The key value
    used in `matchLabels` must match the Pod’s template labels (more on this later).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`spec`描述了部署的`replicas`数量；它被设置为`2`，以反映你希望运行的 Pods 数量。在`selector`字段内，`matchLabels`定位此部署将影响的
    Pods。在`matchLabels`中使用的键值必须与 Pod 的模板标签匹配（稍后会详细讲解）。
- en: The `strategy` field describes how to replace the current running Pods with
    new ones during a rollout. This example uses a `RollingUpdate`, which will replace
    one Pod at a time as it goes. This is the default strategy for a Deployment. The
    other option for strategy, `Recreate`, kills the current running Pods before creating
    the new ones.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`strategy`字段描述了在滚动更新过程中如何用新 Pods 替换当前正在运行的 Pods。这个示例使用了`RollingUpdate`，它会一次替换一个
    Pod。这是部署的默认策略。另一种策略选项，`Recreate`，会在创建新 Pods 之前先终止当前正在运行的 Pods。'
- en: The `maxSurge` and `maxUnavailable` keys control the number of Pods created
    and terminated. Here, it’s set to bring up an extra Pod during a rollout, which
    temporarily brings the Pod count to `replicas` + 1 (or three, in this case). Once
    the new Pod is up and running, one of the old Pods will be terminated. Then, the
    process repeats until all the new Pods are running and the old Pods are terminated.
    These settings will ensure that there is always a Pod to serve traffic during
    a Deployment. See [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy/)
    for more information about strategy.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSurge` 和 `maxUnavailable` 键控制创建和终止 Pods 的数量。在这里，它被设置为在滚动更新期间启动一个额外的 Pod，这会暂时使
    Pod 数量达到 `replicas` + 1（在此例中为三）。一旦新的 Pod 启动并运行后，一个旧的 Pod 会被终止。然后，这个过程会重复，直到所有新的
    Pods 都在运行，旧的 Pods 被终止。这些设置将确保在 Deployment 期间始终有一个 Pod 来处理流量。有关策略的更多信息，请参见 [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy/)。'
- en: 'The next part of the `spec` section is the `template` field. This field (along
    with its subfields) describes the Pods that this Deployment will create. The major
    subfields in this section are `metadata` and `spec`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec` 部分的下一部分是 `template` 字段。这个字段（以及它的子字段）描述了这个 Deployment 将要创建的 Pods。此部分中的主要子字段是
    `metadata` 和 `spec`：'
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, the `app: telnet-server` key value is added for each Pod in the Deployment,
    using the `labels` subfield under `template` and `metadata`. The `app: telnet-server`
    label matches the key and value you used earlier in the `spec` `selector:` field.
    (You’ll use this label again when searching for the Pods later.)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`app: telnet-server` 键值对被添加到 Deployment 中每个 Pod 上，使用的是 `template` 下的 `labels`
    子字段以及 `metadata`。`app: telnet-server` 标签与你在 `spec` 的 `selector:` 字段中之前使用的键值匹配。（你稍后在查找
    Pods 时会再次使用这个标签。）'
- en: The `containers` field sets the container image for the first container in the
    Pod. In this case, it’s set to the *dftd/telnet-server:v1* image you built in
    Chapter 6. This container `name` is `telnet-server`, just like the Deployment.
    Using the same `name` isn’t a requirement; the `name` could be any string you
    choose so long as it is unique among the containers in the Pod.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`containers` 字段设置了 Pod 中第一个容器的容器镜像。在这个例子中，它被设置为你在第六章中构建的 *dftd/telnet-server:v1*
    镜像。这个容器的 `name` 是 `telnet-server`，就像在 Deployment 中一样。使用相同的 `name` 并不是必需的；`name`
    可以是任何你选择的字符串，只要它在 Pod 中的容器之间是唯一的。'
- en: The next subfield under `containers` is `resources`, which controls CPU and
    memory for a container. You can define `requests` and `limits` for each container
    individually. The `requests`are used for Kubernetes scheduling (orchestration)
    and overall application health. If a container needs a minimum of 2GB of memory
    and one CPU to start, you don’t want Kubernetes to schedule that Pod (container)
    on a node that has only 1GB of memory or no CPUs available. `Requests` are the
    minimum resources your application needs. `Limits`, on the other hand, control
    the maximum CPU and memory a container can use on a node. You don’t want a container
    to use all the memory or CPU on a node while starving any other containers running
    on it. In this example, the `CPU` limit is set to `500m` (millicpu), or half of
    a CPU. This unit can also be expressed as a decimal, like 0.5\. In Kubernetes,
    one CPU is equivalent to one CPU core. The `memory` limit is set to `100Mi`, or
    104,857,600 bytes. In Kubernetes, `memory` is expressed in bytes, but you can
    use more familiar units like M, Mi, G, and Gi. When these `limits` are set and
    the telnet-server container consumes more than `100Mi` of `memory`, Kubernetes
    will terminate it. However, if the `CPU` limit (`500m`) is surpassed, Kubernetes
    won’t just kill the container. It will throttle, or limit, the CPU request time
    for that container. For more details on how Kubernetes quantifies resources, see
    [https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The container `ports` field sets the exposed ports you want to announce. This
    example exposes ports `2323` (`telnet`) and `9000` (`metrics`). These port definitions
    are for informational purposes only and have no bearing on whether a container
    can receive traffic. They simply let the user and Kubernetes know on what ports
    you expect the container to be listening.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Examining the telnet-server Service
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next manifest to examine is the `Service` resource. The *service.yaml*
    file creates two separate Services: one to expose the telnet-server and the other
    to expose the application metrics. We’ll look at only the `telnet` Service and
    specific fields here since the `metric` Service is almost identical:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A `Service`resource is set in the `kind` field, which is different from the
    Deployment manifest shown earlier. The Service `name` can be anything, but it
    must be unique within a Kubernetes Namespace. I’ve kept the `names` consistent
    with the rest of the resources here, for ease of use. I’ve also used the same
    `app: telnet-server` label to make finding things uniform and simple.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The `ports` field tells the `Service` which port to expose and how to connect
    it to the Pods. This exposes port `2323` (`telnet`) and forwards any traffic to
    port `2323` on the Pod.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the `selector` field for a Deployment, a `Service` uses a `selector`
    field to find the Pods to forward traffic to. This instance uses the familiar
    Pod label `app: telnet-server` as the match for the `selector`, which means any
    Pods with the label `app: telnet-server` will receive traffic from this `Service`.
    If there is more than one Pod, like in the Deployment, the traffic will be sent
    to all the Pods in a round-robin manner. Since the goal of the `telnet-server`
    application is to be exposed outside the cluster, it’s set as a `LoadBalancer`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Deployment and Services
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is time to create the Deployment and Services. To turn the sample application
    into a Kubernetes Deployment, you’ll use the `minikube` `kubectl` command line
    tool and the manifest files you just reviewed ([https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and update resources, you can pass `minikube` `kubectl` two subcommands:
    `create` and `apply`. The `create` subcommand is *imperative*, which means it
    makes the resource reassemble the manifest file. It also throws an error if the
    resource already exists. The `apply` subcommand is *declarative*, which means
    it creates the resource if it does not exist and updates it if it does. For this
    scenario, you’ll use the `apply` command with an `-f` flag to instruct `kubectl`
    to run the operation against all the files in the *kubernetes/* directory. The
    `-f` flag can take filenames in lieu of directories as well.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'From within the *telnet-server/* directory, enter the following command to
    create the `Deployment` and two `Services`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output should show that all three resources have been `created`. Be sure
    to investigate any errors if they arise from this command. Common errors you might
    see are usually due to syntax errors or typos in the YAML file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the Deployment and Services
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the telnet-server Deployment and Services are created, you need to know
    how to find them. Kubernetes provides multiple ways to view any object’s status.
    The easiest method is to use the `minikube kubectl -- get <``resource``> <``name``>`
    command.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start by fetching the Deployment status by its name and then explore
    the Services. Enter the following to get the `Deployment` status for the `telnet-server`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The output should show that the `telnet-server` Deployment has two replicas
    (Pods) running (`2/2 READY`) and that they have been running for seven seconds
    (`7s AGE`). This should match the number of replicas set in the Deployment manifest.
    The `UP-TO-DATE` and `AVAILABLE` columns show how many Pods were updated to get
    to the desired number (`2`) and how many are available (`2`) to users, respectively.
    In this case, Kubernetes believes the Deployment is up and running and fully available.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run the `minikube kubectl get pods` command to find out whether
    a Deployment is ready for traffic. Because you could have hundreds of Pods, you
    want to narrow down your results with the `-l` label filter flag. Enter the following
    to show only the `telnet-server` Pods:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command lists any Pods that have the label `app: telnet-server` set; it’s
    the same label set in the *deployment.yaml* file under the `spec.template.metadata.labels`
    field. The output shows two `telnet-server` Pods ready for traffic. You know this
    because the `READY` column shows `1/1` containers running and your Deployment
    has only one container (`telnet-server`). If you had a Pod with multiple containers,
    you would want the number of running containers over the number of total containers
    to be the same.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use the same command as above but substitute `services` for the `pods`
    resource to display the two Services:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since you used the same label (`app: telnet-server`) to organize your application,
    you can use the `-l` flag to find your match. The output shows that two Services
    were created about 10 minutes ago. One Service type is a `LoadBalancer`, and the
    other is a `ClusterIP`. The `LoadBalancer` is for exposing the `telnet-server`
    application. Don’t be alarmed if your `EXTERNAL-IP` status is `<pending>`. Because
    you are running on minikube, no real `LoadBalancer` piece is included.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The `ClusterIP` Service allows the application metrics to be scraped from within
    the cluster. In this example, internal applications can reach the metrics endpoint
    by using either the `telnet-server-metrics` canonical name or the IP `10.96.53.191`.
    Using the canonical name is recommended.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Deployment and Services
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the telnet-server Deployment and Services are running, you’ll want
    to test connectivity and availability. You want to be able to access the telnet-server
    application, like you did in Chapter 6, with the telnet client. After that, you’ll
    test the Deployment’s resiliency by killing a telnet-server Pod and watching it
    recover. Finally, you’ll learn how to *scale*, meaning change the number of replicas
    that the Deployment has up and down from the command line, in the case of a change
    in load.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Telnet Server
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll use the `minikube tunnel` command to expose your `LoadBalancer` Service
    outside the Kubernetes cluster. This command will provide you with an IP address
    that you can use to connect, using the `telnet` `client` command again. The `tunnel`
    subcommand runs in the foreground, so it should be run in a terminal that won’t
    get closed. The command also requires *root* privileges. If you do not have *root*
    privileges on your local machine, use the `minikube service` command instead.
    Visit [https://minikube.sigs.k8s.io/docs/commands/service/](https://minikube.sigs.k8s.io/docs/commands/service/)
    for more details.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, enter the following to create the network `tunnel` to the `telnet-server`
    Service:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After entering your password, the command outputs a `route`, the `services`
    exposed, and any present `errors`. Make sure you leave this running while you
    try to connect to the `telnet-server`. Once the `tunnel` is closed, all the connections
    will drop. Since there are `no errors` to report, the `tunnel` should be operational
    at this point. Don’t do it now, but when you want to close the `tunnel`, press
    CTRL-C to shut it down.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码后，命令会输出一个`route`，暴露的`services`和任何出现的`errors`。确保在尝试连接到`telnet-server`时保持此命令运行。一旦`隧道`关闭，所有连接都会断开。由于没有需要报告的`errors`，此时`隧道`应该是可操作的。现在不要执行，但当你想关闭`隧道`时，按CTRL-C将其关闭。
- en: 'Now, with the tunnel up, you need to get the new external IP address for the
    `LoadBalancer` Service. As a shortcut, pass the Service name to `get services`
    `telnet-server` (in this case) to view only the Service you are interested in:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，隧道已经建立，你需要获取`LoadBalancer`服务的新外部IP地址。作为快捷方式，传递服务名称到`get services` `telnet-server`（在本例中）来查看你感兴趣的服务：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `EXTERNAL-IP` column should now be populated with an IP address instead
    of `<pending>`. Here, the `telnet-server` application IP address is set to `10.105.187.105`,
    and the external `PORT` is set to `2323`. Your `EXTERNAL-IP` may be different
    from mine, so just use the IP from this column.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXTERNAL-IP`列现在应该填充了一个IP地址，而不是`<pending>`。这里，`telnet-server`应用程序的IP地址被设置为`10.105.187.105`，外部`PORT`被设置为`2323`。你的`EXTERNAL-IP`可能与我的不同，因此请使用此列中的IP。'
- en: In another terminal that is not running the tunnel, use the `telnet client`
    command again (`telnet` `10.105.187.105`) with the new IP address to access the
    `telnet-server`, as shown in [Figure 7-2](#figure7-2).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个没有运行隧道的终端中，再次使用`telnet client`命令（`telnet` `10.105.187.105`）并输入新的IP地址以访问`telnet-server`，如[图7-2](#figure7-2)所示。
- en: As you can see, the telnet-server responded with the ASCII art logo. Press Q
    to quit, since you are just testing connectivity. The `tunnel` command made it
    possible to hit the Service using an assigned IP like it was a public-facing application.
    If this were on a cloud provider like AWS, the IP would be accessible to anyone
    on the internet. Feel free to kill the `tunnel` command in the other terminal,
    but you’ll use it again in future chapters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，telnet-server响应了ASCII艺术logo。按Q退出，因为你只是测试连接性。`隧道`命令使得使用分配的IP地址访问服务成为可能，就像它是一个面向公众的应用程序一样。如果这是在像AWS这样的云提供商上，IP将对互联网上的任何人可访问。可以随时关闭另一个终端中的`隧道`命令，但你将在未来章节中再次使用它。
- en: '![Screenshot showing the DFTD banner in green ASCII art in a terminal window
    with a black background](image_fi/502482c07/f07002.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![显示在终端窗口中的绿色ASCII艺术DFTD横幅，背景为黑色](image_fi/502482c07/f07002.png)'
- en: 'Figure 7-2: Testing telnet access to telnet-server'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2：测试telnet访问telnet-server
- en: Troubleshooting Tips
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除提示
- en: If you cannot connect to the telnet-server like in [Figure 7-2](#figure7-2),
    check that the Pods are still running and that they are reporting that `1/1` containers
    are `READY`. If the `READY` column shows `0/1` instead and the `STATUS` column
    has an error like `ImagePullBackOff`or `ErrImagePull`, then the Pod could not
    find the telnet-server image you built in Chapter 6. Make sure the image is built
    and available when you list the Docker images.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法像在[图7-2](#figure7-2)中那样连接到telnet-server，请检查Pods是否仍在运行，并且它们是否报告`1/1`容器是`READY`。如果`READY`列显示`0/1`，并且`STATUS`列有类似`ImagePullBackOff`或`ErrImagePull`的错误，那么Pod可能无法找到你在第6章中构建的telnet-server镜像。确保镜像已构建并且在列出Docker镜像时可用。
- en: 'If the `READY` and `STATUS` columns are correct, the next step is to make sure
    your Service is wired up to your Pods. One way to check this connection is with
    the `kubectl get endpoints` command, which will tell you if the Service can find
    the Pods you specified in the Service `spec.selector` field located in the *service.yaml*
    file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`READY`和`STATUS`列是正确的，下一步是确保你的服务已连接到你的Pods。检查此连接的一种方式是使用`kubectl get endpoints`命令，它会告诉你服务是否能够找到你在服务`spec.selector`字段中指定的Pods，该字段位于*service.yaml*文件中：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `ENDPOINTS` column shows the internal Pod IP addresses with ports. Since
    you have two Pods, there are two IP addresses separated by a comma for each Service.
    If the Service can’t locate the Pods, the `ENDPOINTS` column will be set to `<none>`.
    If your `ENDPOINTS` column has `<none>`, check that the `spec.selector` field
    in your Service matches what is in the `spec.template.metadata.labels` field in
    the *deployment.yaml* file. I have preset it to the label `app: telnet-server`
    in the example. Having mismatched labels between a Service and a resource is a
    common mistake; it will happen to you at least once.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Killing a Pod
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another great feature of Deployments is recovery. Failure is going to happen,
    so embrace it! A Deployment will get you back up and to full strength in no time.
    Remember, a Deployment’s main purpose is to keep the desired number of Pods running.
    To test this, you’ll delete one of the `telnet-server` Pods and then watch the
    Deployment respawn another in its place. First, you’ll need to fetch one of the
    `telnet-server` Pods’ names and delete it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following to get the `telnet-server` Pods again:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It really doesn’t matter which Pod you delete, so just choose the first one
    on the list, which is `telnet-server-775769766-2bmd5` on my cluster. (Your Pod
    names will be different, as they are autogenerated.)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, enter the following command to `delete` the selected Pod:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The command might appear to hang for a few seconds, but it will eventually finish
    when the Pod has terminated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'If you list the Pods again, you’ll see two Pods are still running, but now
    the `telnet-server-775769766-2bmd5` is gone and has been replaced with a new Pod:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This new Pod, named `telnet-server-775769766-rdg5w`, is more than a minute old,
    is `Running`, and is ready to accept connections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Scaling
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s pretend the telnet-server application really resonates with the nostalgic
    over-35 crowd and becomes a runaway success. The two telnet-servers will no longer
    be adequate for handling the increased traffic, so you’ll need to scale up your
    replicas to a count greater than two. You can do this in two ways. The first way
    is to edit the *deployment.yaml* manifest file and apply the changes to the cluster
    using the `minikube apply` command. The second way is to use the `minikube kubectl
    scale` command. I’ll demonstrate this example using the `minikube kubectl scale`
    command, since you already learned how to apply manifest files earlier in this
    chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to increase the Deployment replica count by one, bringing the
    total number of Pods to three. (In a real production environment, you would base
    the replica count number off some key metrics instead of a finger in the wind.)
    Enter the following command to scale up the `telnet-server` Deployment:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `scale deployment` command takes a `--replicas` flag to set the number of
    Pod replicas. The output shows the `telnet-server` Deployment has `scaled`, but
    let’s verify this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command to verify that the replica count has changed for
    your Deployment:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, you get the Deployment resource information for `telnet-server`. The Deployment
    has three out of three `(3/3)` replicas `READY`, up from the two it had earlier.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The `scale` command changes the replica count in real time on the cluster. This
    can be dangerous. If a colleague pushes out a new version of the `telnet-server`
    application right after you scaled from the command line, the replica state will
    not match. This is because when he or she runs the `minikube kubectl -- apply
    -f kubernetes/deployment.yaml` command, the Deployment replica count would go
    back to two, since that’s what’s stated in the *deployment.yaml* manifest file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last piece of orchestration to test is accessing the telnet-server application
    logs. Fortunately, Kubernetes makes this simple with the `kubectl` `logs` subcommand.
    You want to grab the logs for all three of your telnet-server Pods. One way to
    do this is to execute the `logs` command for each of the three Pods and view the
    results. Enter the following command to view one of the Pods logs (remember, your
    Pod names will be different from mine):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This works fine if you do not have many Pods or if you know which Pod an event
    happened on. If not, a better option is to grab all the Pods logs at the same
    time and mark each log line with the Pod name from which it came. Enter the following
    command to fetch all the logs for each Pod:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Quite a few flags are used in this command; let’s break each one down:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch only Pods with this label: `-l app=telnet-server`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you have multiple Pods and want to see all the logs: `--all-containers=true`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each log line with the Pod name from which the log came: `--prefix=true`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output should show at least six log lines—two start-up log lines for each
    Pod (3) and whatever other logs may have shown up from connecting earlier with
    the `telnet` command. The log output is not important now, as you just need to
    make sure you can access the logs for your application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to run the telnet-server container image inside
    a Kubernetes cluster. You successfully orchestrated your application by using
    a Kubernetes Deployment resource that you exposed to your local host via a Kubernetes
    Service. Finally, you explored how to create, query, and view your resources and
    logs with the `minikube kubectl` command. In the next chapter, you’ll learn to
    automate the deployment of telnet-server by implementing a simple delivery pipeline
    inside Kubernetes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
