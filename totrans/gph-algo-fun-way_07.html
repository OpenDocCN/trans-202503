<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label="63"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch5">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BREADTH-FIRST SEARCH</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro"><i>Breadth-first search</i> is an alternative approach for exploring graphs that progresses like a wave from a starting node. Whereas depth-first search prioritizes recently discovered nodes, breadth-first search prioritizes exploring nodes discovered earlier in the search. This simple change in prioritization leads to radically different behavior of the search algorithm, along with a variety of useful properties.</p>&#13;
<p class="TX">The key idea behind breadth-first search is that it explores nodes using a first-in, first-out ordering, such as that provided by a queue. Each time the search encounters a previously unseen node, it places that node in a queue of nodes to explore later. When it’s ready to move on to the next node, it doesn’t look at the current node’s neighbors, but rather it extracts the node from the front of the queue, meaning that it always picks the node that has been waiting the longest.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label="64"/>In the previous chapter, we visualized depth-first search as an adventurer exploring a labyrinth. We can picture breadth-first search as the same adventurer using a different strategy, meticulously working their way through a list of future rooms to explore. Determined to visit uncharted territories as soon as possible, the explorer enumerates all unexplored rooms in a list. Each time they find a new room, they append it to the bottom of the list. Resisting the temptation to ditch their plans and rush into this new location, they consult their list and turn to the topmost unvisited option instead.</p>&#13;
<p class="TX">This chapter introduces breadth-first search and examines its properties. In particular, breadth-first search finds the shortest path from a node to all other reachable nodes in unweighted graphs, making it a useful component in a variety of more complicated algorithms.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-51"/><samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp></h3>&#13;
<p class="TNI1">Breadth-first search maps naturally onto numerous real-world tasks, such as learning new concepts or exploring a new city.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-52"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Learning New Topics</samp></h4>&#13;
<p class="TNI1">Breadth-first search provides a systematic approach to learning new concepts that focuses on building up the foundations before investigating any one area too deeply. Suppose you’re learning a new programming language. Each node in the graph represents a concept you must learn, while the edges between the nodes represent pointers between the concepts. Perhaps you’re reading a chapter on Python that discusses both its syntax and its execution model. These concepts become neighbors of the current chapter, which we can either explore immediately or put on the list to explore later.</p>&#13;
<p class="TX">A breadth-first search approach to learning prioritizes the concepts that have been on our “to learn” list the longest. You might start at the general concept of the Python language, then note the immediate neighbor topics of syntax, execution model, and running a sample program. Each topic goes on your list to explore, and you proceed through them one at a time. While learning about syntax, you come across references to lists, sets, and dictionaries. Instead of flipping ahead to those chapters, you add each concept to the bottom of your list to explore later and continue to the next topic at the top of the list. This means you’re able to complete a simple “Hello, world!” program before delving into lambda expressions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-53"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring a New City</samp></h4>&#13;
<p class="TNI1">Suppose you’re exploring a new city, building your knowledge base by establishing a known area of explored nodes, then expanding the frontier into the unknown. One day after work, you travel that extra block to try the coffee shop you’ve seen down the street. Another day, you ask the age-old <span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label="65"/>question, “What’s over that hill?” As you discover new neighborhoods, you write down newly discovered but as-yet-unvisited areas for later adventures.</p>&#13;
<p class="TX">Contrast this breadth-first approach with the admittedly more adventurous depth-first method of walking in one direction until you hit the city limits. The latter tactic will efficiently expand the areas seen, but at the cost of deferring closer options. If you always go north when you have the option, you might end up 50 blocks north, yet remain completely unaware of the amazing coffee shop one block south of your apartment.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h-54"/><samp class="SANS_Futura_Std_Bold_B_11">The Breadth-First Search Algorithm</samp></h3>&#13;
<p class="TNI1">Breadth-first search operates by maintaining a <i>queue of nodes</i> and iteratively exploring them until the queue is empty. The nodes in the queue are reachable from a visited node but have not been visited themselves.</p>&#13;
<p class="TX">Breadth-first search begins by inserting a <i>starting node</i> into the queue. In many applications, the choice of the starting node is obvious. If you are browsing an online encyclopedia of coffee grinders, for example, the starting node is the first page you open. If you are searching for a path from your hotel to the closest coffee shop, the starting node will be the hotel. If you are searching through your social network for someone who can get you concert tickets, the starting node is yourself, the center of the network. In the examples in this chapter, we arbitrarily use node 0 as our starting point.</p>&#13;
<p class="TX">At the start of each iteration of a breadth-first search, the algorithm dequeues the first node and visits it. It then checks that node’s outgoing edges and adds any previously unvisited neighbors to the queue. The process continues, one node at a time, until the queue is empty.</p>&#13;
<p class="TX">If the graph being explored is not fully connected, the search terminates before visiting every node. In many cases, this is exactly what we want. If we are looking for a path from the hotel to a coffee shop, we do not care about unreachable coffee shops. Perhaps we are on a tropical island with a road network connecting our hotel to 10 coffee shops. Our search would spread out to find coffee shops across the island but would stop short of suggesting caf<span class="accent">é</span>s on neighboring islands.</p>&#13;
<p class="TX">However, in some cases, we need a more comprehensive search. If we are searching for information on coffee grinders, we do not want to miss important context simply because someone neglected to add a hyperlink. We can extend the breadth-first search to exhaustively explore every node by adding the first unexplored node to the queue whenever the queue is empty.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-55"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">The code for breadth-first search consists of a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop exploring new nodes until the queue of pending nodes is empty:</p>&#13;
<pre><code>def breadth_first_search(g: Graph, start: int) -&gt; list: &#13;
    seen: list = [False] * g.num_nodes&#13;
    last: list = [-1] * g.num_nodes&#13;
    pending: queue.Queue = queue.Queue()<span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label="66"/>&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> pending.put(start)&#13;
    seen[start] = True&#13;
&#13;
    while not pending.empty():&#13;
        index: int = pending.get()&#13;
        current: Node = g.nodes[index]&#13;
&#13;
        for edge in current.get_edge_list():&#13;
            neighbor: int = edge.to_node&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if not seen[neighbor]:&#13;
                pending.put(neighbor)&#13;
                seen[neighbor] = True&#13;
                last[neighbor] = index&#13;
&#13;
    return last&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">breadth_first_search()</samp> code starts by creating the helper data structures, including the list of which nodes have been seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>), a list of previous nodes in the search to represent the path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>), and a queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>). For the queue, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Queue</samp> data structure defined in Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp> library, which requires an additional <samp class="SANS_TheSansMonoCd_W5Regular_11">import queue</samp> in the file. However, it’s also possible to use a built-in data structure such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">list</samp>. Before the main loop begins, the code inserts the starting node into the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp> queue and marks it as seen <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">The function uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to continue exploring nodes until the queue is empty. During each iteration, it takes the node from the front of the queue and uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to check each of its neighbors. If the function has not already seen the neighbor <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>, it adds it to the queue, marks it as seen, and updates the pointer to the previous node. The function finishes by returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list, which captures the path taken by the search.</p>&#13;
<p class="TX">Unlike the implementations of depth-first search in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, which marked a node as seen when the search visited it, this breadth-first search implementation marks nodes as seen when it first adds them to the queue. This prevents repeat entries in the queue.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-56"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig5-1">Figure 5-1</a> shows an example of the steps of a breadth-first search through a graph with 10 nodes. The shaded nodes have been marked seen. Each subfigure shows the settings of the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array and the state of the queue with the front on the left-hand side.</p>&#13;
<p class="TX"><a href="#fig5-1">Figure 5-1(a)</a> represents the state of the search before we start the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop. The search has marked the starting node (0) as seen and placed it on the queue. All other nodes remain marked unseen. Every node has a back pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>) of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, including the starting node.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label="67"/>&#13;
<figure class="IMG"><img id="fig5-1" class="img80" src="../images/f05001.jpg" alt="In (A), only node 0 is shaded and all elements of the last array are set to –1. In (B), node 0 is enclosed in a dashed circle and its neighbors (nodes 1, 5, and 7) are shaded. The last array has entries of 0 for elements 1, 5, and 7." width="1238" height="1773"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: The steps of a breadth-first search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The search begins in earnest in <a href="#fig5-1">Figure 5-1(b)</a>, when it removes node 0 from the queue and explores it. It finds three neighbors (nodes 1, 5, and 7), marks each of these as seen, and places them in the queue to explore later. In this way, the queue is much like a daily to-do list: we cross an item off, realize that it leads to more tasks, and add those to the end of the list. We also update the last array to indicate the path we will take to each of these nodes. The value 0 indicates that node 0 precedes each of the nodes on the path.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_68" aria-label="68"/>The search next visits node 1 in <a href="#fig5-1">Figure 5-1(c)</a>. This node has only one unseen neighbor (node 2), since we have already seen node 0. The algorithm marks node 2 as seen, adds it to the queue, and sets its entry in the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.</p>&#13;
<p class="TX">In <a href="#fig5-1">Figure 5-1(d)</a>, we begin to see how this search diverges from the depth-first search. Rather than continuing down the current path, breadth-first search explores the earliest-seen node that is still unexplored. In this case, it moves to node 5. In the context of the adventurer exploring a labyrinth, this corresponds to exploring the room at the top of our hero’s list. Admittedly, this could be inefficient in the physical world. The adventurer may need to backtrack through much of the labyrinth to return to that room. However, this is not a problem in the computational realm. Once we have the index of a node, we can easily load it into memory.</p>&#13;
<p class="TX">In <a href="#fig5-1">Figure 5-1(d)</a>, the algorithm explores node 5 and finds two new neighbors, nodes 6 and 8. It marks each of these as seen and updates their last entries to point back to node 5. It then places 6 and 8 at the end of our list of nodes to explore; it will investigate them in due time.</p>&#13;
<p class="TX">The search continues in <a href="#fig5-1">Figure 5-1(e)</a> by exploring the last of node 0’s neighbors with a visit to node 7. While we have now seen a significant fraction of the nodes in the example graph, we have visited only nodes that are one or fewer steps from node 0. Our search is spreading like a wave from the starting node, visiting all the close nodes before hitting ones farther away.</p>&#13;
<p class="TX">The search continues through the rest of the figure. At each step, it retrieves the node at the front of the queue for exploration. This is the node that has been waiting longest on its list. It visits that node, checking for and processing any new neighbors. The search completes in <a href="#fig5-1">Figure 5-1(k)</a> when it extracts the final node from the queue.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h-57"/><samp class="SANS_Futura_Std_Bold_B_11">Finding Shortest Paths</samp></h3>&#13;
<p class="TNI1">A major benefit of breadth-first search is that it will find the shortest paths from the starting node to all reachable nodes on an unweighted graph. When working with unweighted graphs, we use the term <i>shortest paths</i> to indicate paths with the fewest number of edges. Breadth-first search is able to find such paths thanks to how the algorithm prioritizes which paths it explores. By using a first-in, first-out data structure, the algorithm effectively prioritizes unexplored nodes that are closest to the start node.</p>&#13;
<p class="TX"><a href="#fig5-2">Figure 5-2</a> illustrates this behavior, depicting the graph from <a href="#fig5-1">Figure 5-1</a> with dashed lines indicating the number of steps to each node. While exploring the starting node, breadth-first search enqueues all nodes that can be reached in one step from this node. Next, it explores each of those nodes in order. While exploring a node one step away, it might find new nodes that are two steps away. However, these are always added to the end of the queue and thus explored after all the nodes that are one step away have been visited. As a result, breadth-first search sweeps through all nodes <i>k</i> steps away before considering any that are <i>k</i> + 1 steps away.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label="69"/>&#13;
<figure class="IMG"><img id="fig5-2" class="img60" src="../images/f05002.jpg" alt="Node 0 is in the region labeled 0 steps. Nodes 1, 5, and 7 are in the region labeled 1 step." width="899" height="1045"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: Contour lines showing the expansion of breadth-first search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In weighted graphs, the concept of <i>shortest paths</i> is often used to describe the paths with the lowest sum of edge weights. Since breadth-first search does not consider edge weight, a breadth-first search will not find the shortest path in terms of cost.</p>&#13;
<p class="TX">As an example, consider the graph in <a href="#fig5-3">Figure 5-3</a>. Both nodes 1 and 2 will be seen by breadth-first search during the exploration of node 2. Both will be marked as seen, added to the queue, and assigned 0 as the previous node on their path, regardless of the edge weight to that node. The algorithm does not look for or find the lower weight path through node 1 to node 2, but it still finds the one with the fewest number of edges.</p>&#13;
<figure class="IMG"><img id="fig5-3" class="img60" src="../images/f05003.jpg" alt="A three-node graph with the same contour lines as figure 5-2. The edges are labeled with weights. (0, 1) has weight 1.0, (0, 2) has weight 10.0, and (1, 2) has weight 1.0. dashed lines indicating the number of steps to each node. Node 0 is in the region labeled 0 steps. Nodes 1 and 2 are in the region labeled 1 step." width="754" height="420"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: Contour lines showing the expansion of breadth-first search on a weighted graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label="70"/>We’ll consider the question of edge weights and shortest paths later in the book. <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> introduces a variety of shortest-path algorithms on weighted graphs, while <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> examines heuristic search algorithms that account for edge weights.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h-58"/><samp class="SANS_Futura_Std_Bold_B_11">Simple Path Planning</samp></h3>&#13;
<p class="TNI1">The fact that breadth-first search finds paths with the smallest number of edges makes it useful for a limited set of <i>path-planning</i> tasks. Consider the old-time video game task of planning a path on a flat two-dimensional grid where some squares are obstructed by boulders. This section discusses how to create a graph to represent this problem and the solution we get when running breadth-first search.</p>&#13;
<p class="TX">Breadth-first search path planning on a flat plane with obstacles provides a useful illustration of the operation of breadth-first search. It also introduces how we can think about representing path-planning problems in graph form, preparing us for later chapters that cover better algorithms for path planning. These include <i>lowest-cost path algorithms</i> that account for edge weights to simulate differing costs of various terrain and <i>heuristically guided search algorithms</i> that improve the running time of the search itself by prioritizing the most promising paths.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-59"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constructing a Graph from a Grid</samp></h4>&#13;
<p class="TNI1">Constructing a graph representation of a regular grid has a variety of uses, from path planning to computer vision. The underlying grid might represent spatial regions on a map (for path planning or scientific computation), pixels in an image (for computer vision), or even just an arrangement of nodes. For the purposes of this section, we’ll focus on a video game map.</p>&#13;
<p class="TX">We generate a grid-based graph by creating a single node for each grid square and a single undirected edge linking each pair of adjacent squares. For a grid where the number of rows = <i>height</i> and number of columns = <i>width</i>, we start by allocating <i>height</i> × <i>width</i> nodes. We can visually represent these in a grid pattern, as shown in <a href="#fig5-4">Figure 5-4(b)</a>, but technically they are stored in a single list within a graph data structure.</p>&#13;
<figure class="IMG"><img id="fig5-4" class="img40" src="../images/f05004.jpg" alt="(A) shows a 4 × 4 grid. (B) shows a 4 × 4 graph. Nodes in the graph are connected to their neighbors above, below, to the right, and to the left." width="679" height="362"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: A grid (a) and a graph representation of the grid (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label="71"/>We can map the grid coordinates for row <i>r</i> and column <i>c</i> to a corresponding node index as follows:</p>&#13;
<p class="EQ"><i>index</i> = <i>r</i> × <i>width</i> + <i>c</i></p>&#13;
<p class="TX">Because the edges are undirected, we can scan the nodes from top left to bottom right and insert edges to the nodes to the right of or below the current node. If we specify this as a loop over the <i>r</i> and <i>c</i> values of the grid, our tests of whether to include an edge are as follows:</p>&#13;
<p class="ListPlain">If <i>c</i> &lt; <i>width</i> – 1, the node has a neighbor to its right at <i>index</i> + 1.</p>&#13;
<p class="ListPlain">If <i>r</i> &lt; <i>height</i> – 1, the node has a neighbor below it at <i>index</i> + <i>width</i>.</p>&#13;
<p class="TX"><a href="#list5-1">Listing 5-1</a> shows the code for constructing a grid-based graph.</p>&#13;
<span id="list5-1"/>&#13;
<pre><code>def make_grid_graph(width: int, height: int) -&gt; Graph: &#13;
    num_nodes: int = width * height&#13;
&#13;
    g: Graph = Graph(num_nodes, undirected=True)&#13;
    for r in range(height):&#13;
        for c in range(width):&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> index: int = r * width + c&#13;
&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if (c &lt; width - 1):&#13;
                g.insert_edge(index, index + 1, 1.0)&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if (r &lt; height - 1):&#13;
                g.insert_edge(index, index + width, 1.0)&#13;
    return g&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: Creating a graph representation of a grid</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_grid_graph()</samp> code starts by creating an undirected graph <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> with one node for each grid square. It then loops over all the grid cells with two <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops, computes the corresponding node index <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>, and checks whether there should be an edge to the right of <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> or below <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> the current node. The code completes by returning the graph <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-60"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Obstacles</samp></h4>&#13;
<p class="TNI1">Path planning across a flat plane is not a particularly exciting task. Even in the context of describing breadth-first search, it amounts to little more than watching the frontier of visited nodes expand across the grid. To make the example more interesting, let’s add obstacles to the grid. We pass these to the code in the form of tuples (<i>r</i>, <i>c</i>) that indicate the obstacle’s row and column in the grid. This allows us to make grids like the one in <a href="#fig5-5">Figure 5-5</a>, where the open cells are traversable and the shaded circles represent obstacles.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label="72"/>&#13;
<figure class="IMG"><img id="fig5-5" class="img40" src="../images/f05005.jpg" alt="The obstacles are shaded circles. There are obstacles in the second and fifth cells along the top row. The top left cell is labeled with an s." width="503" height="503"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: A 6×6 grid with eight obstacles</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The code follows the same form as <a href="#list5-1">Listing 5-1</a> but uses this extra information:</p>&#13;
<pre><code>def make_grid_with_obstacles(width: int, height: int,&#13;
                             obstacles: set) -&gt; Graph: &#13;
    num_nodes: int = width * height&#13;
&#13;
    g: Graph = Graph(num_nodes, undirected=True)&#13;
    for r in range(height):&#13;
        for c in range(width):&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if (r, c) not in obstacles:&#13;
                index: int = r * width + c&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if (c &lt; width - 1) and (r, c + 1) not in obstacles:&#13;
                    g.insert_edge(index, index + 1, 1.0)&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if (r &lt; height - 1) and (r + 1, c) not in obstacles:&#13;
                    g.insert_edge(index, index + width, 1.0)&#13;
    return g&#13;
</code></pre>&#13;
<p class="TX">As in <a href="#list5-1">Listing 5-1</a>, the code starts by creating an undirected graph <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> with one node for each grid square. It then loops over all the grid cells with two <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops. At each grid square, it checks whether the current cell is blocked by an obstacle <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If it is blocked, the node has no edges into or out of it. If it isn’t blocked, the code computes the index in the node list, checks whether there should be an edge to the right of the current node <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>, and checks whether there should be an edge below the current node <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. Both edge checks include the additional constraint that the neighboring cell must not be blocked by an obstacle.</p>&#13;
<p class="TX">This function demonstrates the power of general graph representation, which allows us to fully capture the structure of the environment, including valid transitions and obstacles. If we can transition directly from one point to another, the graph has an edge between the corresponding nodes. Otherwise, no transition is allowed. We do not need to save the dimensions of the graph or the list of obstacles. We can use similar approaches to model walls in a maze. As we will see in later chapters, we can use edge weights and directionality to further increase modeling power.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_73" aria-label="73"/>&#13;
<h4 class="H2" id="sec11"><span id="h-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running Breadth-First Search</samp></h4>&#13;
<p class="TNI1">We can run breadth-first search on the grid-based graphs from the previous two sections without any modifications. After all, both functions are producing standard <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> objects. <a href="#fig5-6">Figure 5-6</a> shows the results of running breadth-first search on the grid from <a href="#fig5-5">Figure 5-5</a>, where <i>S</i> denotes the starting node at row 0, column 0.</p>&#13;
<figure class="IMG"><img id="fig5-6" class="img80" src="../images/f05006.jpg" alt="Both subfigures show the 6 × 6 grid from Figure 5-5. In the figure on the left the unoccupied cells are each numbered. The top left cell has the number zero and the one below it one. In the figure on the right the unoccupied cells have arrows pointing back to the cell that precedes them. The first cell in the second row points up to the top left cell." width="1073" height="545"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: Grids with the exploration order (a) and last pointers (b) after breadth-first search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The grid in <a href="#fig5-6">Figure 5-6(a)</a> shows the order in which the search visits each grid cell. It starts in the upper left-hand corner and expands outward like an oozing blob creature attempting to absorb the world. While the other cells are close by straight-line distance metrics, it takes a while for the search to visit them, because the search needs to navigate around the obstacles.</p>&#13;
<p class="TX">The grid in <a href="#fig5-6">Figure 5-6(b)</a> shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> pointers for each node in the graph. Using these, we can reconstruct the shortest path from any destination node back to the start node. For example, the cell in row 3, column 2 (labeled with a 9) can reach the origin by moving up, left, up, left, and up. We can reverse these pointers to get the shortest path <i>from</i> the start node to any reachable destination.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-62"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">Breadth-first search provides an alternate mechanism for searching graphs with different behavior. Due to the way it orders nodes to explore, it prioritizes nodes that are closest to the starting node as measured by the number of edges. As a result, breadth-first search explores outward from the starting node in a frontier and will find paths to each node with the fewest edges. This behavior makes this search a useful component of various more complex graph algorithms.</p>&#13;
<p class="TX">In addition, breadth-first search is both simple and efficient. Unlike the common recursive implementation of depth-first search, the standard <span role="doc-pagebreak" epub:type="pagebreak" id="pg_74" aria-label="74"/>implementation of breadth-first search uses an iterative <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop rather than recursive function calls to operate on the queue.</p>&#13;
<p class="TX">The next chapters explore a different type of graph search: algorithms that find the shortest paths on weighted graphs. These algorithms build on the basic searches we have introduced so far and unlock a range of new applications.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>