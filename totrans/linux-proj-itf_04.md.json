["```\n`$ ./copy oldfile newfile`\n```", "```\n`fileio/copy.c`\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\n#ifndef BUF_SIZE        /* Allow \"cc -D\" to override definition */\n#define BUF_SIZE 1024\n#endif\n\nint\nmain(int argc, char *argv[])\n{\n    int inputFd, outputFd, openFlags;\n    mode_t filePerms;\n    ssize_t numRead;\n    char buf[BUF_SIZE];\n\n    if (argc != 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s old-file new-file\\n\", argv[0]);\n\n    /* Open input and output files */\n\n    inputFd = open(argv[1], O_RDONLY);\n    if (inputFd == -1)\n        errExit(\"opening file %s\", argv[1]);\n\n    openFlags = O_CREAT | O_WRONLY | O_TRUNC;\n    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |\n                S_IROTH | S_IWOTH;      /* rw-rw-rw- */\n    outputFd = open(argv[2], openFlags, filePerms);\n    if (outputFd == -1)\n        errExit(\"opening file %s\", argv[2]);\n\n    /* Transfer data until we encounter end of input or an error */\n\n    while ((numRead = read(inputFd, buf, BUF_SIZE)) > 0)\n        if (write(outputFd, buf, numRead) != numRead)\n            fatal(\"couldn't write whole buffer\");\n    if (numRead == -1)\n        errExit(\"read\");\n\n    if (close(inputFd) == -1)\n        errExit(\"close input\");\n    if (close(outputFd) == -1)\n        errExit(\"close output\");\n\n    exit(EXIT_SUCCESS);\n}\n      `fileio/copy.c`\n```", "```\n`$ ./copy test test.old`           *Copy a regular file*\n`$ ./copy a.txt /dev/tty`          *Copy a regular file to this terminal*\n`$ ./copy /dev/tty b.txt`          *Copy input from this terminal to a regular file*\n`$ ./copy /dev/pts/16 /dev/tty`    *Copy input from another terminal*\n```", "```\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint `open`(const char **pathname*, int *flags*, ... /* mode_t *mode* */);\n```", "```\n/* Open existing file for reading */\n\n    fd = open(\"startup\", O_RDONLY);\n    if (fd == -1)\n        errExit(\"open\");\n\n    /* Open new or existing file for reading and writing, truncating to zero\n       bytes; file permissions read+write for owner, nothing for all others */\n\n    fd = open(\"myfile\", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n    if (fd == -1)\n        errExit(\"open\");\n\n    /* Open new or existing file for writing; writes should always\n       append to end of file */\n\n    fd = open(\"w.log\", O_WRONLY | O_CREAT | O_TRUNC | O_APPEND,\n                       S_IRUSR | S_IWUSR);\n    if (fd == -1)\n        errExit(\"open\");\n```", "```\nif (close(STDIN_FILENO) == -1)      /* Close file descriptor 0 */\n    errExit(\"close\");\n\nfd = open(pathname, O_RDONLY);\nif (fd == -1)\n    errExit(\"open\");\n```", "```\n#include <fcntl.h>\n\nint `creat`(const char **pathname*, mode_t *mode*);\n```", "```\nfd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);\n```", "```\n#include <unistd.h>\n\nssize_t `read`(int *fd*, void **buffer*, size_t *count*);\n```", "```\n#define MAX_READ 20\nchar buffer[MAX_READ];\n\nif (read(STDIN_FILENO, buffer, MAX_READ) == -1)\n    errExit(\"read\");\nprintf(\"The input data was: %s\\n\", buffer);\n```", "```\nchar buffer[MAX_READ + 1];\nssize_t numRead;\n\nnumRead = read(STDIN_FILENO, buffer, MAX_READ);\nif (numRead == -1)\n    errExit(\"read\");\n\nbuffer[numRead] = '\\0';\nprintf(\"The input data was: %s\\n\", buffer);\n```", "```\n#include <unistd.h>\n\nssize_t `write`(int fd, void **buffer*, size_t *count*);\n```", "```\n#include <unistd.h>\n\nint `close`(int *fd*);\n```", "```\nif (close(fd) == -1)\n    errExit(\"close\");\n```", "```\n#include <unistd.h>\n\noff_t `lseek`(int *fd*, off_t *offset*, int *whence*);\n```", "```\ncurr = lseek(fd, 0, SEEK_CUR);\n```", "```\nlseek(fd, 0, SEEK_SET);         /* Start of file */\nlseek(fd, 0, SEEK_END);         /* Next byte after the end of the file */\nlseek(fd, -1, SEEK_END);        /* Last byte of file */\nlseek(fd, -10, SEEK_CUR);       /* Ten bytes prior to current location */\nlseek(fd, 10000, SEEK_END);     /* 10001 bytes past last byte of file */\n```", "```\n`fileio/seek_io.c`\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    size_t len;\n    off_t offset;\n    int fd, ap, j;\n    char *buf;\n    ssize_t numRead, numWritten;\n\n    if (argc < 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s file {r<length>|R<length>|w<string>|s<offset>}...\\n\",\n                 argv[0]);\n\n    fd = open(argv[1], O_RDWR | O_CREAT,\n                S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |\n                S_IROTH | S_IWOTH);                     /* rw-rw-rw- */\n    if (fd == -1)\n        errExit(\"open\");\n\n    for (ap = 2; ap < argc; ap++) {\n        switch (argv[ap][0]) {\n        case 'r':   /* Display bytes at current offset, as text */\n        case 'R':   /* Display bytes at current offset, in hex */\n            len = getLong(&argv[ap][1], GN_ANY_BASE, argv[ap]);\n\n            buf = malloc(len);\n            if (buf == NULL)\n                errExit(\"malloc\");\n\n            numRead = read(fd, buf, len);\n            if (numRead == -1)\n                errExit(\"read\");\n\n            if (numRead == 0) {\n                printf(\"%s: end-of-file\\n\", argv[ap]);\n            } else {\n                printf(\"%s: \", argv[ap]);\n                for (j = 0; j < numRead; j++) {\n                    if (argv[ap][0] == 'r')\n                        printf(\"%c\", isprint((unsigned char) buf[j]) ?\n                                                buf[j] : '?');\n                    else\n                        printf(\"%02x \", (unsigned int) buf[j]);\n                }\n                printf(\"\\n\");\n            }\n\n            free(buf);\n            break;\n\n        case 'w':   /* Write string at current offset */\n            numWritten = write(fd, &argv[ap][1], strlen(&argv[ap][1]));\n            if (numWritten == -1)\n                errExit(\"write\");\n            printf(\"%s: wrote %ld bytes\\n\", argv[ap], (long) numWritten);\n            break;\n\n        case 's':   /* Change file offset */\n            offset = getLong(&argv[ap][1], GN_ANY_BASE, argv[ap]);\n            if (lseek(fd, offset, SEEK_SET) == -1)\n                errExit(\"lseek\");\n            printf(\"%s: seek succeeded\\n\", argv[ap]);\n            break;\n\n        default:\n            cmdLineErr(\"Argument must start with [rRws]: %s\\n\", argv[ap]);\n        }\n    }\n\n    exit(EXIT_SUCCESS);\n}\n      `fileio/seek_io.c`\n```", "```\n$ `touch tfile`                       *Create new, empty file*\n$ `./seek_io tfile s100000` ``*`wabc`*``      *Seek to offset 100,000, write “abc”*\ns100000: seek succeeded\nwabc: wrote 3 bytes\n$ `ls -l tfile`                       *Check size of file*\n-rw-r--r--    1 mtk    users   100003 Feb 10 10:35 tfile\n$ `./seek_io tfile s10000 R5`         *Seek to offset 10,000, read 5 bytes from hole*\ns10000: seek succeeded\nR5: 00 00 00 00 00                  *Bytes in the hole contain 0*\n```", "```\n#include <sys/ioctl.h>\n\nint `ioctl`(int *fd*, int *request*, ... /* *argp* */);\n```"]