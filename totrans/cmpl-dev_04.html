<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch3">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_33" aria-label=" Page 33. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">TYPESCRIPT</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">TypeScript is a programming language that adds static typing to the dynamically typed JavaScript language. It’s a strict syntactic superset of JavaScript, which means that all existing JavaScript is valid TypeScript. By contrast, TypeScript is not valid JavaScript, because it supplies additional features.</p>&#13;
<p class="TX">This chapter will introduce you to the pitfalls of working with JavaScript’s dynamic types and explain how TypeScript’s static typing helps catch errors early, increasing the stability of your code. Full-stack developers have embraced TypeScript: it was the runner-up in the <i>most wanted</i> category of a recent Stack Overflow Developer Survey, and 78 percent of participants in a <i>State of JS</i> survey reported using it. According to <a href="https://builtwith.com"><i>https://<wbr/>builtwith<wbr/>.com</i></a>, TypeScript underlies 7 percent of the top 10,000 sites.</p>&#13;
<p class="TX">We’ll cover the essential and advanced TypeScript concepts necessary for building full-stack applications. Along the way, you’ll get to know the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_34" aria-label=" Page 34. "/>language’s most common configuration options, its most important types, and how and when to use TypeScript’s static typing features.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-20"/><samp class="SANS_Futura_Std_Bold_B_11">Benefits of TypeScript</samp></h3>&#13;
<p class="TNI">TypeScript makes working with JavaScript’s type system less error prone, as its compiler helps us see type errors instantly. Because JavaScript is <i>dynamically</i> typed, you don’t need to specify a variable’s type when declaring it. As soon as the runtime executes the script, it checks these types based on usage. However, this means that errors resulting from invalid types (for example, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> on a variable that holds a number instead of an array) won’t be discovered until runtime, at which point the complete program fails.</p>&#13;
<p class="TX">In addition to being dynamically typed, JavaScript is also <i>weakly</i> typed, which means it implicitly converts variables to their most plausible values. <a href="chapter3.xhtml#Lis3-1">Listing 3-1</a> shows an implicit conversion from a number to a string.</p>&#13;
<span id="Lis3-1"/>&#13;
<pre class="pre-44"><code>let string = "1";&#13;
let number = 1;&#13;
let result;&#13;
&#13;
result = number + number;&#13;
console.log("value: ", result, " type of ", typeof(result));&#13;
&#13;
result = number + string;&#13;
console.log("value: ", result, " type of ", typeof(result));&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-1: Implicit conversion from a number to a string in JavaScript</span></p>&#13;
<p class="TX">We declare three variables, assigning the first a string, the second a numeric value, and the third the result of using the arithmetic plus (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) operator to add the number to itself. We then log the result of this sum operation and its type to the console. If you executed this code, you would see that the value is numeric and that the runtime assigned a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> to the variable.</p>&#13;
<p class="TX">Next, we use the same operator again, but instead of adding a numeric value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> variable, we add a string to it. You should see that the logged value is <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, as you might have expected. Moreover, the variable’s assigned type has changed to <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>. This happens because the runtime environment needs to handle an impossible task: adding a number and a string. It solves this issue by implicitly converting the number to a string, then using the plus operator to concatenate the two strings. Without TypeScript, we notice this conversion only when we run the code.</p>&#13;
<p class="TX">Another common problem caused by untyped variables relates to function and API <i>contracts</i>, or the agreements about what the code accepts and returns. When a function takes a parameter, it implicitly expects a parameter of a specific type. But without TypeScript, there is no way to ensure that the parameter type is correct. The same problem exists for the function’s return value. To illustrate this, <a href="chapter3.xhtml#Lis3-2">Listing 3-2</a> changes the code <span role="doc-pagebreak" epub:type="pagebreak" id="pg_35" aria-label=" Page 35. "/>from <a href="chapter3.xhtml#Lis3-1">Listing 3-1</a> so that it uses a function to calculate the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> variable.</p>&#13;
<span id="Lis3-2"/>&#13;
<pre class="pre-45"><code>let string = "1";&#13;
let number = 1;&#13;
let result;&#13;
&#13;
const calculate = (a, b) =&gt; a + b;&#13;
&#13;
result = calculate(number, number);&#13;
console.log("value: ", result, " type of ", typeof(result));&#13;
&#13;
result = calculate(number, string);&#13;
console.log("value: ", result, " type of ", typeof(result));&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-2: A function that could return an invalid type due to implicit type conversion</span></p>&#13;
<p class="TX">The new <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp> function takes two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and as before, adds the two values. Like in <a href="chapter3.xhtml#Lis3-1">Listing 3-1</a>, as soon as we pass a number and a string as parameters, the function returns a string instead of a number. Our function might expect both parameters to be numbers, but we can’t verify this without manually checking the type by using logic similar to that in <a href="chapter3.xhtml#Lis3-3">Listing 3-3</a>.</p>&#13;
<span id="Lis3-3"/>&#13;
<pre class="pre-46"><code>let string = "1";&#13;
let number = 1;&#13;
let result;&#13;
&#13;
const calculate = (a, b) =&gt; {&#13;
    if (Number.isInteger(a) === false || Number.isInteger(b) === false) {&#13;
        throw new Error("Invalid type: a parameter is not an integer");&#13;
    } else {&#13;
        return a + b;&#13;
    }&#13;
};&#13;
&#13;
result = calculate(number, number);&#13;
console.log("value: ", result, " type of ", typeof(result));&#13;
&#13;
result = calculate(number, string);&#13;
console.log("value: ", result, " type of ", typeof(result));&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-3: The refactored type-safe function</span></p>&#13;
<p class="TX">Here we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">isInteger</samp> function of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Number</samp> object to verify that the parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are integers. The first call of the function, in which we pass it two integers, should calculate the result as expected. The second call, in which we pass the function an integer and a string, looks fine in the editor. However, when we run the code, the runtime environment should throw the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid type: a parameter is not an integer</samp>.</p>&#13;
<p class="TX">There are two main concerns with manually checking the types. First, it adds a lot of noise to our code, as we need to check for all possible types every time we work with function or API contracts, such as when we accept a parameter or return a value. Second, we’re not notified of issues during <span role="doc-pagebreak" epub:type="pagebreak" id="pg_36" aria-label=" Page 36. "/>development. To see the errors in dynamically typed languages, we need to execute the code so that the interpreter can inform us about errors at runtime.</p>&#13;
<p class="TX">Unlike dynamically typed languages, <i>statically</i> typed languages perform type checks on the code compilation, before runtime. The TypeScript Compiler (TSC) handles this chore; it can run in the background of our code editor or IDE and instantly report all errors based on invalid type usage. Therefore, you can catch errors and see each variable’s assigned types and data structures early.</p>&#13;
<p class="TX">Even if you don’t set up instant feedback like that, running your code through TSC is necessary before it can be used, which ensures that these kinds of errors are caught earlier than they otherwise would be. The ability to check for these errors is one of the most important benefits of using TypeScript over JavaScript. We will discuss how to benefit from type annotations and when to use them in <span class="Xref">“Type Annotations” on page 38</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1"><span id="sec2"/><span id="h1-21"/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up TypeScript</samp></h3>&#13;
<p class="TNI">TypeScript’s syntax isn’t valid JavaScript, so a regular JavaScript runtime environment can’t execute it. To run TypeScript in Node.js or a browser, we first need to use TSC to convert it to regular, backward-compatible JavaScript. We then execute the resulting JavaScript.</p>&#13;
<p class="TX">Despite being called a compiler, TSC doesn’t actually compile TypeScript into JavaScript. Instead, it <i>transpiles</i> it. The difference lies in the level of abstraction. A compiler creates low-level code, while a transpiler is a source-to-source compiler that produces equivalent source code in a language of roughly the same abstraction. For example, you could transpile ES.Next to legacy JavaScript or Python 2 to Python 3. (That said, the terms <i>transpiling</i> and <i>compiling</i> are often used interchangeably.)</p>&#13;
<p class="TX">In addition to converting TypeScript to JavaScript, TSC checks your code for type errors and verifies the contracts between your functions. The transpiling and type-checking happen independently, and the TSC produces JavaScript regardless of the types you defined. TypeScript errors are merely warnings emitted during the build. They won’t stop the transpiling step as long as the JavaScript itself doesn’t produce an error.</p>&#13;
<p class="TX">The use of TypeScript won’t affect your code’s performance. The compiler removes types and type operations during the transpilation step, essentially stripping all TypeScript syntax from the actual JavaScript code. Therefore, they can’t affect the runtime or the size of the final code. TypeScript is consequently no slower than JavaScript, although the transpilation can take some time.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2"><span id="sec3"/><span id="h2-32"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installation in Node.js</samp></h4>&#13;
<p class="TNI">If you’re using Node.js, you should define TypeScript and all type definitions as development dependencies with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">-save-dev</samp> flag in your project’s <i>package.json</i> file. There is no need to install TypeScript globally. Just add TypeScript directly to your project with this npm command:</p>&#13;
&#13;
<pre class="pre-47"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_37" aria-label=" Page 37. "/>$ <b>npm install </b><b>-</b><b>-save-dev typescript</b></code></pre>&#13;
<p class="TX">TypeScript files use the extension <i>.ts</i>, and because TypeScript is a superset of JavaScript, all valid JavaScript code is automatically valid TypeScript code. Therefore, you can rename your <i>.js</i> files to <i>.ts</i> and instantly use the static type checker with your existing code.</p>&#13;
<p class="TX">A <i>tsconfig.json</i> file defines TSC configuration options. We’ll cover the most important ones in the next section. For now, run the following command to generate a new file with the default configuration:</p>&#13;
&#13;
<pre class="pre-48"><code>$ <b>npx tsc -init</b></code></pre>&#13;
<p class="TX">TSC looks for this file in the current path and all parent directories. The optional <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp> flag points the TypeScript compiler directly to the file. TSC then reads configuration information from this file and treats its folder as TypeScript’s root directory.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you want to follow this chapter’s examples without creating a dedicated project, you can run code in the online playground at</i> <a href="https://www.typescriptlang.org/play"><span class="note_LinkURL_Italic">https://<wbr/>www<wbr/>.typescriptlang<wbr/>.org<wbr/>/play</span></a> <i>instead of installing TypeScript locally.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2"><span id="sec4"/><span id="h2-33"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The tsconfig.json File</samp></h4>&#13;
<p class="TNI">Take a look at the basic structure of a <i>tsconfig.json</i> file. The content of the generated file depends on your installed TypeScript version, and there are around 100 configuration properties, but for most projects, only the following few are relevant:</p>&#13;
&#13;
<pre class="pre-49"><code>{&#13;
    "extends": "@tsconfig/recommended/tsconfig.json",&#13;
    "compilerOptions": {},&#13;
    "include": [],&#13;
    "exclude": []&#13;
}&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">extends</samp> option is a string that configures the path to another similar configuration file. Usually, this property extends a preset you used as a template with minor, project-specific tweaks. It works similarly to class-based inheritance in object-oriented programming. The preset overrides the base configuration, and the configuration’s key-value pairs overwrite the preset. The example shown here uses the recommended configuration file for TypeScript to override the default settings.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">compilerOptions</samp> field configures the transpiling step. We list its options in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span>. The value for <samp class="SANS_TheSansMonoCd_W5Regular_11">include</samp> is an array of strings that specifies the patterns or filenames to include for transpiling. The value for <samp class="SANS_TheSansMonoCd_W5Regular_11">exclude</samp> is an array of strings that specifies patterns or filenames to exclude. Keep in mind that TSC applies these patterns on the list of files found with the included pattern. Usually, we don’t need to include or exclude files, as <span role="doc-pagebreak" epub:type="pagebreak" id="pg_38" aria-label=" Page 38. "/>our whole project will consist of TypeScript code. Hence, we can leave the arrays empty.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2"><span id="sec5"/><span id="h2-34"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic Feedback with TypeScript</samp></h4>&#13;
<p class="TNI">Most modern code editors have support for TypeScript, and they show us the errors generated by TSC directly inside the code. Remember the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp> function we used to explain how TypeScript verifies function contracts? <a href="chapter3.xhtml#fig3-1">Figure 3-1</a> is a screenshot from Visual Studio Code highlighting the type error and hinting at the solution.</p>&#13;
<figure class="IMG"><img class="img1" id="fig3-1" src="../images/Figure3-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 3-1: Working with TypeScript in Visual Studio Code</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can use any code editor or IDE you’d like to write your TypeScript code, though one that shows dynamic feedback like this is recommended.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H1"><span id="sec6"/><span id="h1-22"/><samp class="SANS_Futura_Std_Bold_B_11">Type Annotations</samp></h3>&#13;
<p class="TNI">A type annotation is an optional way to explicitly tell the runtime environment which types to expect. You add them following this schema: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable: type</samp>. The following example shows a version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp> function in which we type both parameters as numbers:</p>&#13;
&#13;
<pre class="pre-50"><code>const calculate = (a: number, b: number) =&gt; a + b;</code></pre>&#13;
<p class="TX">Some developers tend to add types to everything in their code, and by doing so, they add noise that makes the code less readable. This antipattern, called <i>over-typing</i>, stems from a false understanding of how type annotations should work. The TypeScript compiler infers types from usage. Therefore, you don’t need to explicitly type everything. Instead, the code editor runs TSC in the background and leverages the results to display the inferred type information and compiler errors as you saw in <span class="Xref">the “Dynamic Feedback with TypeScript” section.</span></p>&#13;
<p class="TX">Rather, type annotations are a way to ensure that code honors the API contracts. There are three scenarios in which you’ll want to verify the contract, and only one of them is especially important. The first scenario, upon a variable’s declaration, is usually not recommended. The second, annotating the return value of a function, is optional, whereas the third scenario, annotating a function’s parameters, is essential. We’ll now take a look at all three of these cases in detail.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2"><span id="sec7"/><span id="h2-35"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_39" aria-label=" Page 39. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Variable</samp></h4>&#13;
<p class="TNI">The most obvious place to type a variable is upon an assignment or declaration. <a href="chapter3.xhtml#Lis3-4">Listing 3-4</a> demonstrates this by explicitly typing the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> as a string and then assigning it a string value.</p>&#13;
<span id="Lis3-4"/>&#13;
<pre class="pre-51"><code>let weather: string = "sunny";</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-4: Over-typing during the variable’s declaration</span></p>&#13;
<p class="TX">In most cases, however, this is a form of over-typing, as you could instead leverage the compiler’s type inference. <a href="chapter3.xhtml#Lis3-5">Listing 3-5</a> shows the alternative pattern of using type inference.</p>&#13;
<span id="Lis3-5"/>&#13;
<pre class="pre-52"><code>let weather = "sunny";</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-5: Inferring the variable’s type based on its value</span></p>&#13;
<p class="TX">Because TSC automatically infers the type of this variable, the code editor should show the type information when you hover over the variable. Without the explicit annotation, we have a much cleaner syntax and avoid the noise that the redundant type declaration adds to the code. This improves code readability, which is why this kind of over-typing is usually to be avoided.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2"><span id="sec8"/><span id="h2-36"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Return Value</samp></h4>&#13;
<p class="TNI">Although TypeScript can infer a function’s return type, you’ll usually want to annotate it explicitly. This code pattern ensures that the function’s contract is honored, as the compiler shows implementation errors where the function is defined instead of where it is used.</p>&#13;
<p class="TX">Another reason to use type annotations in this situation is that, as a programmer, you must explicitly define what a function does. By clarifying the function’s input and output types, you’ll gain a better understanding of what you actually want the function to do. <a href="chapter3.xhtml#Lis3-6">Listing 3-6</a> shows you how to declare a function’s return type upon declaration.</p>&#13;
<span id="Lis3-6"/>&#13;
<pre class="pre-53"><code>function getWeather(): string {&#13;
    const weather = "sunny";&#13;
    return weather;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-6: Typing a function’s return value upon declaration</span></p>&#13;
<p class="TX">We create a function that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> variable we declared earlier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> variable has the inferred string type. Hence, the function returns a string. Our type definition explicitly sets the function’s return type.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2"><span id="sec9"/><span id="h2-37"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Function’s Parameters</samp></h4>&#13;
<p class="TNI">It’s essential to annotate the parameters of a function, because TypeScript doesn’t have enough information to infer function parameters in most <span role="doc-pagebreak" epub:type="pagebreak" id="pg_40" aria-label=" Page 40. "/>cases. By typing these parameters, you’re telling the compiler to check the types when you call the function and pass it arguments. Take a look at <a href="chapter3.xhtml#Lis3-7">Listing 3-7</a> to see this pattern in action.</p>&#13;
<span id="Lis3-7"/>&#13;
<pre class="pre-54"><code>const weather = "sunny";&#13;
function getWeather(weather: string): string {&#13;
    return weather;&#13;
};&#13;
getWeather(weather);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-7: Typing a function’s parameters</span></p>&#13;
<p class="TX">Instead of declaring the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> variable as a constant inside the function, we want the returned value to be dynamic. Therefore, we modify the function to accept a parameter and return it immediately. We then call the function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> constant as a parameter.</p>&#13;
<p class="TX">Good TypeScript code avoids noise and relies on inferring type annotations. It always annotates a function’s parameters and opts for annotated return values but never annotates local variables.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H1"><span id="sec10"/><span id="h1-23"/><samp class="SANS_Futura_Std_Bold_B_11">Built-in Types</samp></h3>&#13;
<p class="TNI">Before you can use TypeScript and its annotations, you need to know what types are available to you. One of TypeScript’s main benefits is that it enables you to declare any of JavaScript’s primitive types explicitly. In addition, TypeScript adds its own types, the most important of which are <samp class="SANS_TheSansMonoCd_W5Regular_11">unions</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">tuples</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. You can also define custom types and interfaces.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2"><span id="sec11"/><span id="h2-38"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Primitive JavaScript Types</samp></h4>&#13;
<p class="TNI">JavaScript has five primitive types: strings, numbers, Booleans, undefined, and null. Everything else in the language is considered an object. <a href="chapter3.xhtml#Lis3-8">Listing 3-8</a> shows the syntax for defining variables of these primitive JavaScript types with additional TypeScript type annotations. (Remember that, most of the time, you can just rely on the compiler’s type inference in this situation.)</p>&#13;
<span id="Lis3-8"/>&#13;
<pre class="pre-55"><code>let stringType: string = "bar";&#13;
let booleanType: boolean = true;&#13;
let integerType: number = 1;&#13;
let floatType: number = 1.5;&#13;
let nullType: null = null;&#13;
let undefinedType: undefined = undefined;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-8: JavaScript’s primitive types with TypeScript’s type annotations</span></p>&#13;
<p class="TX">First we define a string variable and a Boolean with the TypeScript annotations. These are identical to strings and Booleans in JavaScript. Then we define two numbers. Like JavaScript, TypeScript uses a single generic type for numbers, without differentiating between integers and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_41" aria-label=" Page 41. "/>floating points. Finally, we look at TypeScript’s null and undefined types. These behave the same as JavaScript’s primitive types of the same name. <i>Null</i> refers to a value that either is empty or doesn’t exist, and it indicates the intentional absence of a value. In contrast, <i>undefined</i> indicates the unintentional absence of a value. We did not assign a value in <a href="chapter3.xhtml#Lis3-5">Listing 3-5</a> for the undefined type, because we don’t know it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2"><span id="sec12"/><span id="h2-39"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The union Type</samp></h4>&#13;
<p class="TNI">There are a few additional types you should know about, because the more precise your type annotations are, the more helpful you’ll find TSC to be. TypeScript introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> type to the JavaScript ecosystem. <i>Unions</i> are variables or parameters that can have more than one data type. <a href="chapter3.xhtml#Lis3-9">Listing 3-9</a> shows an example of a <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> type that can be a string or a number.</p>&#13;
<span id="Lis3-9"/>&#13;
<pre class="pre-56"><code>let stringOrNumberUnionType: string | number;&#13;
stringOrNumberUnionType = "bar";&#13;
stringOrNumberUnionType = 1;&#13;
stringOrNumberUnionType = true;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-9: TypeScript’s</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">union</samp> <span class="Futura_Std_Book_Oblique_BI_11">type</span></p>&#13;
<p class="TX">We declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>-type variable that can contain either a string or a number, but nothing else. As soon as we assign a Boolean variable, TSC throws an error, and the IDE shows the message <samp class="SANS_TheSansMonoCd_W5Regular_11">Type 'boolean' is not assignable to type 'string | number'</samp>.</p>&#13;
<p class="TX">While you might find <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> types useful for annotating function parameters and arrays that can contain different types, you should use them sparingly and avoid them whenever possible. This is because, before working with <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>-typed items, you need to perform additional manual type checks; otherwise, they could cause errors. For example, if you iterated over an array of strings or numbers and then added all items, you would first need to convert all strings to numbers. Otherwise, JavaScript would implicitly convert the numbers to strings, as shown earlier in this chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2"><span id="sec13"/><span id="h2-40"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The array Type</samp></h4>&#13;
<p class="TNI">TypeScript provides a generic <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> type that offers array functions similar to JavaScript’s array. However, take a close look at the syntax for typing the array, shown in <a href="chapter3.xhtml#Lis3-10">Listing 3-10</a>. You’ll notice that the type of the array depends on the type of the array items.</p>&#13;
<span id="Lis3-10"/>&#13;
<pre class="pre-57"><code>let genericArray: [] = [];&#13;
genericArray.push(1);&#13;
&#13;
let numberArray: number[] = [];&#13;
numberArray.push(1);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-10: Typed arrays</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_42" aria-label=" Page 42. "/>First we define an array without specifying the type of its items. Unfortunately, what seems to be a definition of a generic array leads to issues down the road. As soon as we try to add a value, TSC throws the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument of type 'number' is not assignable to parameter of type 'never'</samp>, because the array is not typed.</p>&#13;
<p class="TX">Hence, we need to type the items in the array. Therefore, we create an array, <samp class="SANS_TheSansMonoCd_W5Regular_11">numberArray</samp>, in which each item has the type of number. Now we can add numeric values to the array without running into errors.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2"><span id="sec14"/><span id="h2-41"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The object Type</samp></h4>&#13;
<p class="TNI">TypeScript’s built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> type is the same as JavaScript’s object. Although you can define the properties’ types for TSC to type-check, the compiler can’t ensure the order of the properties. Nonetheless, it typechecks them, as shown in <a href="chapter3.xhtml#Lis3-11">Listing 3-11</a>.</p>&#13;
<span id="Lis3-11"/>&#13;
<pre class="pre-58"><code>let weatherDetail: {&#13;
    weather: string,&#13;
    zipcode: string,&#13;
    temp: number&#13;
} = {weather: "sunny", zipcode: "00000", temp: 1};&#13;
weatherDetail.weather = 2;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-11: Typed objects</span></p>&#13;
<p class="TX">Here we define an object with three properties: two that take a string and another that takes a number. Then we try to assign a number to the property <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> annotated as a string. Now TSC notifies us with an error explaining that we assigned a value of the wrong type.</p>&#13;
<p class="TX">Note that, usually, you should avoid typing objects inline, as in this example. Instead, it is a best practice to create a custom type, which is reusable and avoids cluttering our code, enhancing its readability. We discuss how to create and use them in <span class="Xref">“Custom Types and Interfaces” on page 44</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2"><span id="sec15"/><span id="h2-42"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">tuple</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp></h4>&#13;
<p class="TNI">Another common type that TypeScript adds to JavaScript is the <samp class="SANS_TheSansMonoCd_W5Regular_11">tuple</samp> type. Shown in <a href="chapter3.xhtml#Lis3-12">Listing 3-12</a>, <i>tuples</i> are arrays with a specified number of typed items. TypeScript’s tuples are similar to those you might have encountered in programming languages such as Python and C#.</p>&#13;
<span id="Lis3-12"/>&#13;
<pre class="pre-59"><code>let validTuple: [string, number] = ["bar", 1];&#13;
let invalidTuple: [string, number] = [1, "bar"];&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-12: TypeScript’s</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tuple</samp> <span class="Futura_Std_Book_Oblique_BI_11">type</span></p>&#13;
<p class="TX">We define two tuples. In both, the first array item is a string, and the second is a number. If the type, order, or number of items added to the tuple differs from the tuple’s declaration, TSC throws an error. Here the first <span role="doc-pagebreak" epub:type="pagebreak" id="pg_43" aria-label=" Page 43. "/>assignment is acceptable, whereas the second one throws two errors indicating a mismatch in types.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2"><span id="sec16"/><span id="h2-43"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">any</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp></h4>&#13;
<p class="TNI">TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> type is generic, meaning it can take any value, and you should avoid using it. As you can see in <a href="chapter3.xhtml#Lis3-13">Listing 3-13</a>, it accepts all values without throwing an error, which defeats the purpose of static typing.</p>&#13;
<span id="Lis3-13"/>&#13;
<pre class="pre-60"><code>let indifferent: any = true;&#13;
indifferent = 1;&#13;
indifferent = [];&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-13: TypeScript’s</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp> <span class="Futura_Std_Book_Oblique_BI_11">type</span></p>&#13;
<p class="TX">Using <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> might seem like an easy choice, and it is tempting to rely on it as an escape hatch. Avoid this at all costs. When you pass <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> as a value to, say, a function, you break the contract you specified in the function declaration, and when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> to define the contract, there effectively isn’t one.</p>&#13;
<p class="TX">To view a scenario in which using the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> type causes problems, take a look at <a href="chapter3.xhtml#Lis3-14">Listing 3-14</a>.</p>&#13;
<span id="Lis3-14"/>&#13;
<pre class="pre-61"><code>const calculate = (a<b>: any</b>, b<b>: any</b>)<b>: any</b> =&gt; a + b;&#13;
console.log(calculate (1,1));&#13;
console.log(calculate (<b>"1"</b>,1));&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-14: Problems caused by the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp> <span class="Futura_Std_Book_Oblique_BI_11">type</span></p>&#13;
<p class="TX">We reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp> function, which adds two numbers. When we pass two numeric values, we receive the expected output of <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. In a previous example, we typed the parameters as numbers, thus preventing the use of invalid types as arguments.</p>&#13;
<p class="TX">However, when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> instead of a number and pass a string to the function, TSC doesn’t throw an error. JavaScript implicitly converts the number to a string and returns an unexpected value of <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>. We saw this behavior at the beginning of the chapter, in the untyped version of the function. As you can see, using <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> is the same as using no types at all.</p>&#13;
<p class="TX">While convenient, the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> type masks your bugs during programming and hides your type designs, rendering type-checking useless. It also prevents your IDE from displaying errors and invalid types.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2"><span id="sec17"/><span id="h2-44"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp></h4>&#13;
<p class="TNI">TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type is the opposite of <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>: it indicates no type at all. Its only use case is to annotate the return value of a function that shouldn’t have one, as shown in <a href="chapter3.xhtml#Lis3-15">Listing 3-15</a>.</p>&#13;
<span id="Lis3-15"/>&#13;
<pre class="pre-62"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_44" aria-label=" Page 44. "/>function log(msg: string)<b>: void</b> {&#13;
    console.log(msg);&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-15: TypeScript’s</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">void</samp> <span class="Futura_Std_Book_Oblique_BI_11">type</span></p>&#13;
<p class="TX">The custom log function we define here passes a parameter to the console. It doesn’t return anything, so we use <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> as the return type.</p>&#13;
<p class="TX">To learn more about TypeScript types and other important details of the language, take a look at <i>The TypeScript Handbook</i> at <a href="https://www.typescriptlang.org/docs/handbook/intro.html"><i>https://<wbr/>www<wbr/>.typescriptlang<wbr/>.org<wbr/>/docs<wbr/>/handbook<wbr/>/intro<wbr/>.html</i></a>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H1"><span id="sec18"/><span id="h1-24"/><samp class="SANS_Futura_Std_Bold_B_11">Custom Types and Interfaces</samp></h3>&#13;
<p class="TNI">The previous sections introduced you to enough TypeScript to begin using the language. However, you’ll find it helpful to know a few more advanced concepts. This section shows you how to create custom types and use untyped third-party libraries in your TypeScript code. You’ll also learn when to create a new type and use a custom interface.</p>&#13;
<p class="TX">While working with TypeScript, remember that a TypeScript file <i>without</i> top-level imports or exports is not a module; therefore, it runs in the <i>global</i> scope. Consequently, all of its declarations are accessible in other modules. By contrast, a TypeScript file <i>with</i> top-level imports or exports is its own module, and all declarations are limited to the <i>module</i> scope, meaning they’re available in the scope of this module only.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2"><span id="sec19"/><span id="h2-45"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Custom Types</samp></h4>&#13;
<p class="TNI">TypeScript lets you define custom types by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> keyword. Custom types are a great way to simplify your code. To see how, take a second look at the code shown back in <a href="chapter3.xhtml#Lis3-8">Listing 3-8</a>, when you created a typed object. Now consider <a href="chapter3.xhtml#Lis3-16">Listing 3-16</a>, which optimizes the code with a custom type definition. You should find it much cleaner and easier to read.</p>&#13;
<span id="Lis3-16"/>&#13;
<pre class="pre-63"><code><b>type</b> WeatherDetailType <b>= {</b>&#13;
    weather: string;&#13;
    zipcode: string;&#13;
    temp?: number;&#13;
};&#13;
&#13;
let weatherDetail: WeatherDetailType = {&#13;
    weather: "sunny",&#13;
    zipcode: "00000",&#13;
    temp: 30&#13;
};&#13;
const getWeatherDetail = (data: WeatherDetailType): WeatherDetailType =&gt; data;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-16: Custom types for typed objects with TypeScript</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_45" aria-label=" Page 45. "/>We create a custom type, <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> keyword. Note that the overall syntax is similar to that used to define an object; we use the equal sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) to assign the definition to the custom type.</p>&#13;
<p class="TX">The custom type has two required properties: <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>. In addition, it has an optional <samp class="SANS_TheSansMonoCd_W5Regular_11">temp</samp> property, as indicated by the question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>). Now when we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">getWeatherDetail</samp> function, we can annotate the parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherDetail</samp>, as an object with a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>. Using this technique, we avoid using inline annotations and can reuse our custom type later, such as to annotate the return type of a function.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h4 class="H2"><span id="sec20"/><span id="h2-46"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Interfaces</samp></h4>&#13;
<p class="TNI">In addition to types, TypeScript has interfaces. However, the difference between a type and an interface is blurry. You can freely decide which one to use, so long as you follow a convention in your code.</p>&#13;
<p class="TX">In general, we consider a <i>type</i> definition to answer the question, “Which type is this data?” A possible answer might be a union or a tuple. An <i>interface</i> is a way to describe the shape of some data, such as the properties of an object. It answers the question, “Which properties does this object have?” The most practical difference is that, unlike an interface, we cannot directly modify a type after we’ve declared it. For an in-depth look at the distinction, consult <i>The TypeScript Handbook</i>.</p>&#13;
<p class="TX">As a rule of thumb, use an interface to define a new object or the method of an object. More generally, consider using interfaces over types, as they provide more precise error messages. A classic React use case for interfaces is to define the properties of a specific component. <a href="chapter3.xhtml#Lis3-17">Listing 3-17</a> shows how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp> keyword to create a new interface to replace the type in <a href="chapter3.xhtml#Lis3-16">Listing 3-16</a>.</p>&#13;
<span id="Lis3-17"/>&#13;
<pre class="pre-64"><code><b>interface</b> WeatherProps<b> {</b>&#13;
    weather: string;&#13;
    zipcode: string;&#13;
    temp?: number;&#13;
}&#13;
&#13;
const weatherComponent = (props: WeatherProps): string =&gt; props.weather;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-17: Custom interfaces for TypeScript functions</span></p>&#13;
<p class="TX">Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp> keyword to define a new interface. Unlike a custom type’s definition, an interface definition does not use the equal sign to assign the interface’s properties to its name. We then use the custom interface to type the properties object <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherComponent</samp>, which returns a string.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h4 class="H2"><span id="sec21"/><span id="h2-47"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Type Declaration Files</samp></h4>&#13;
<p class="TNI">To use custom types universally, you can define them in <i>type declaration files</i>, which have the <i>.d.ts</i> extension. Unlike regular TypeScript files with the <i>.ts</i> or <i>.tsx</i> extension, type declaration files shouldn’t contain any implementation <span role="doc-pagebreak" epub:type="pagebreak" id="pg_46" aria-label=" Page 46. "/>code. Instead, TSC uses these type definitions to understand custom types and perform type checks. They aren’t transpiled to JavaScript and are never part of the executed script.</p>&#13;
<p class="TX">Type declaration files prove useful when you find yourself working with external code bases. Often, third-party libraries aren’t written in TypeScript. Therefore, they don’t provide type declaration files for their code bases. Luckily, the DefinitelyTyped repository at <a href="http://definitelytyped.github.io"><i>http://<wbr/>definitelytyped<wbr/>.github<wbr/>.io</i></a> provides type declaration files for more than 7,000 libraries. Use these files to add TypeScript support to these libraries.</p>&#13;
<p class="TX">Type declaration files are collected under the <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp> scope in npm. This scope holds all the declarations from DefinitelyTyped. Hence, they are easy to find and are grouped next to each other in your <i>package.json</i> file. All type declaration files from the <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp> scope should be considered development dependencies of your project. Hence, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--save-dev</samp> flag on the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install</samp> command to add them.</p>&#13;
<p class="TX"><a href="chapter3.xhtml#Lis3-18">Listing 3-18</a> shows a minimal example of a type declaration file that exports a type and interface for an API.</p>&#13;
<span id="Lis3-18"/>&#13;
<pre class="pre-65"><code>interface WeatherQueryInterface {&#13;
    zipcode: string;&#13;
}&#13;
&#13;
type WeatherDetailType = {&#13;
    weather: string;&#13;
    zipcode: string;&#13;
    temp?: number;&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-18: Defining custom types and interfaces</span></p>&#13;
<p class="TX">Save these definitions in a file called <i>custom.d.ts</i> in your root directory. TSC should automatically load these definitions. You can now use the types and interfaces from the file in your TypeScript modules.</p>&#13;
<p class="HeadProject"><span id="Exe3"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3: Extend Express.js with TypeScript</samp></p>&#13;
<p class="TNI">Let’s use your new knowledge of TypeScript to rewrite the Express.js server you created in Exercises 1 and 2. In addition to adding type annotations, we’ll add a new route to the server by using custom types.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h4 class="H2"><span id="sec22"/><span id="h2-48"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp></h4>&#13;
<p class="TNI">Begin by adding TypeScript to the project following the steps described in <span class="Xref">“Setting Up TypeScript” on page 36</span>. Next, because Express.js isn’t typed, add type definitions from DefinitelyTyped to your project by running the following:</p>&#13;
&#13;
<pre class="pre-66"><code>$ <b>npm install --save-dev @types/express</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_47" aria-label=" Page 47. "/>Your <i>package.json</i> file should now look like this:</p>&#13;
&#13;
<pre class="pre-67"><code>{&#13;
    "name": "sample-express",&#13;
    "version": "1.0.0",&#13;
    "description": "sample express server",&#13;
    "license": "ISC",&#13;
    "type": "module",&#13;
    "dependencies": {&#13;
        "express": "^4.18.2",&#13;
        "node-fetch": "^3.2.6"&#13;
    },&#13;
    "devDependencies": {&#13;
        <b>"@types/express": "^4.17.15",</b>&#13;
        <b>"typescript": "^4.9.4"</b>&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Now you can create configuration and type declaration files for the project.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h4 class="H2"><span id="sec23"/><span id="h2-49"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the tsconfig.json File</samp></h4>&#13;
<p class="TNI">Either create a new <i>tsconfig.json</i> file in the <i>sample-express</i> folder, next to the <i>index.ts</i> file, or open the one you created earlier. Then add or replace its content with the following code:</p>&#13;
&#13;
<pre class="pre-68"><code>{&#13;
    "compilerOptions": {&#13;
        "esModuleInterop": true,&#13;
        "module": "es6",&#13;
        "moduleResolution": "node",&#13;
        "target": "es6",&#13;
        "noImplicitAny": true&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">We configure TypeScript for our simple Express.js server, which requires only a few settings. We use ES.Next modules for our TypeScript code, and because we want to keep them after transpiling the TypeScript to JavaScript, we set <samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">es6</samp>. The <i>express</i> package is a CommonJS module. Therefore, we need to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">esModuleInterop</samp> option and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">moduleResolution</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>. Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">noImplicitAny</samp> option to disallow the implicit use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> type and require explicit typing. <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span> describes these configuration options in more detail.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h4 class="H2"><span id="sec24"/><span id="h2-50"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Custom Types</samp></h4>&#13;
<p class="TNI">For our server, we’ll follow a simple rule of thumb: every time we use an object, we should consider adding a custom type or interface to our project. If the object is a function parameter, we’ll create a custom interface. If we use this particular object more than once, we’ll create a custom type.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_48" aria-label=" Page 48. "/>To define the custom types for this sample project, we create a file <i>custom.d.ts</i> next to the <i>index.ts</i> file in the <i>sample-express</i> folder and add the code from <a href="chapter3.xhtml#Lis3-19">Listing 3-19</a>.</p>&#13;
<span id="Lis3-19"/>&#13;
<pre class="pre-69"><code>type responseItemType = {&#13;
    id: string;&#13;
    name: string;&#13;
};&#13;
&#13;
type WeatherDetailType = {&#13;
    zipcode: string;&#13;
    weather: string;&#13;
    temp?: number;&#13;
};&#13;
&#13;
interface WeatherQueryInterface {&#13;
    zipcode: string;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-19: The</span> <span class="Futura_Std_Book_11">custom.d.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We create two custom types and an interface. One defines the response items of the asynchronous API call. The other type and the interface are similar to examples shown earlier in this chapter. They are necessary for the new weather route we will create shortly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h4 class="H2"><span id="sec25"/><span id="h2-51"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Annotations to the routes.ts File</samp></h4>&#13;
<p class="TNI">Next, we must add type annotations to our server code. Rename the <i>routes.js</i> file in the <i>sample-express</i> folder to <i>routes.ts</i> to enable the TSC for this file. You should instantly see the errors and warnings appear in your editor. Take some time to look at these and then adjust the contents to match the code in <a href="chapter3.xhtml#Lis3-20">Listing 3-20</a>. We’ve bolded all type annotations.</p>&#13;
<span id="Lis3-20"/>&#13;
<pre class="pre-70"><code>import fetch from "node-fetch";&#13;
&#13;
const routeHello = ()<b>: string </b>=&gt; "Hello World!";&#13;
&#13;
const routeAPINames = async ()<b>: Promise&lt;string&gt; </b>=&gt; {&#13;
    const url = "https://www.usemodernfullstack.dev/api/v1/users";&#13;
    let data<b>: responseItemType[];</b>&#13;
    try {&#13;
        const response = await fetch(url);&#13;
        data = <b>(</b>await response.json()<b>) as responseItemType[];</b>&#13;
    } catch (err) {&#13;
        return "Error";&#13;
    }&#13;
    const names = data&#13;
        .map((item) =&gt; `id: ${item.id}, name: ${item.name}`)&#13;
        .join("&lt;br&gt;");&#13;
    return names;&#13;
};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_49" aria-label=" Page 49. "/>const routeWeather = (query<b>: WeatherQueryInterface</b>)<b>: WeatherDetailType </b>=&gt;&#13;
    queryWeatherData(query);&#13;
&#13;
const queryWeatherData = (query<b>: WeatherQueryInterface</b>)<b>: WeatherDetailType </b>=&gt; {&#13;
    return {&#13;
        zipcode: query.zipcode,&#13;
        weather: "sunny",&#13;
        temp: 35&#13;
    };&#13;
};&#13;
&#13;
export {routeHello, routeAPINames, routeWeather};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-20: The typed</span> <span class="Futura_Std_Book_11">routes.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">Following the principle discussed in <span class="Xref">“Type Annotations” on page 38</span>, we annotate only a function’s parameters and return types. We also annotate local variables only when their types cannot be inferred, as when converting the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> response to JSON. Here we need to explicitly type the variable with our custom <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp> and cast the conversion’s return value as an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp>s.</p>&#13;
<p class="TX">In the rest of the listing, we create the functions for the additional weather route. We use the custom interface for typing both functions’ parameters and the custom type for their return types. In this basic example, the query function returns mostly static data, except the ZIP code, which it takes from the passed parameters. A regular implementation would query a database with the ZIP code and retrieve actual data.</p>&#13;
<p class="TX">Finally, we add the new route for the weather endpoint to the <samp class="SANS_TheSansMonoCd_W5Regular_11">export</samp> statement.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h4 class="H2"><span id="sec26"/><span id="h2-52"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Annotations to the index.ts File</samp></h4>&#13;
<p class="TNI">Rename the file <i>index.js</i> in the <i>sample-express</i> folder to <i>index.ts</i> and adjust the code to match <a href="chapter3.xhtml#Lis3-20">Listing 3-20</a>. In addition to the necessary type annotations, create a new endpoint and follow the TypeScript convention to prefix unused parameters with an underscore (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>), shown in <a href="chapter3.xhtml#Lis3-21">Listing 3-21</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_50" aria-label=" Page 50. "/>&#13;
<span id="Lis3-21"/>&#13;
<pre class="pre-71"><code>import {routeHello, routeAPINames, <b>routeWeather</b>} from "./routes.js";&#13;
import express, {<b>Request, Response</b>} from "express";&#13;
&#13;
const server = express();&#13;
const port = 3000;&#13;
&#13;
server.get("/hello", function (<b>_req: Request</b>, res<b>: Response</b>): void {&#13;
    const response = routeHello();&#13;
    res.send(response);&#13;
});&#13;
&#13;
server.get("/api/names",&#13;
    async function (<b>_req: Request</b>, res<b>: Response): Promise&lt;void&gt;</b> {&#13;
        let response: string;&#13;
        try {&#13;
            response = await routeAPINames();&#13;
            res.send(response);&#13;
        } catch (err) {&#13;
            console.log(err);&#13;
        }&#13;
    }&#13;
);&#13;
&#13;
server.get(&#13;
    "/api/weather/<b>:zipcode</b>",&#13;
    function (req<b>: Request</b>, res<b>: Response</b>): <b>void</b> {&#13;
        const response = routeWeather({zipcode: <b>req.params.zipcode</b>});&#13;
        res.send(response);&#13;
    }&#13;
);&#13;
&#13;
server.listen(port, function (): void {&#13;
    console.log("Listening on " + port);&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 3-21: The typed</span> <span class="Futura_Std_Book_11">index.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">First we import the new weather route from the available routes and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Request</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp> types from the <i>express</i> package. These are all named exports. Thus, we use curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>).</p>&#13;
<p class="TX">Then, following best practices, we add code annotations and, at the same time, prefix the unused <samp class="SANS_TheSansMonoCd_W5Regular_11">req</samp> parameters with an underscore. TSC will follow the convention of functional programming languages by ignoring these parameters. The <i>api/names</i> entry point is marked as an async function, so it needs to return a value wrapped in a promise. Hence, nothing is returned, and we return <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> as the promise’s value.</p>&#13;
<p class="TX">In the following lines of code, we create an additional route for a new <i>/api/weather/:zipcode</i> endpoint. The colon (<samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>) creates a parameter on the request’s <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> object. We retrieve the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">req.params .zipcode</samp> and pass it down to the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeWeather</samp> function. Note that there is no underscore on the request parameter this time. Finally, we use the same function as before to start the Express.js server and listen to port 3000.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h4 class="H2"><span id="sec27"/><span id="h2-53"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transpiling and Running the Code</samp></h4>&#13;
<p class="TNI">To transpile the code with the TypeScript compiler to JavaScript, run TSC with <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> on the command line:</p>&#13;
&#13;
<pre class="pre-72"><code>$ <b>npx tsc</b></code></pre>&#13;
<p class="TX">TSC generates two new files, <i>index.js</i> and <i>routes.js</i>, from the TypeScript files. Start the server from your command line with the regular Node.js call:</p>&#13;
&#13;
<pre class="pre-73"><code>$ <b>node index.js</b>&#13;
Listening on 3000&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_51" aria-label=" Page 51. "/>Now visit <i>http://localhost:3000/api/weather/12345</i> in your browser. You should see the weather details with the ZIP code 12345, as shown in <a href="chapter3.xhtml#fig3-2">Figure 3-2</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig3-2" src="../images/Figure3-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 3-2: Browser response from the Node.js web server</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Success! You wrote your first TypeScript application.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h3 class="H1"><span id="sec28"/><span id="h1-25"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">This chapter taught you what you need to know about TypeScript to create a full-stack application. We set up TypeScript and TSC in a new project, then discussed its most important configuration options. Next, you learned to use TypeScript efficiently, leveraging type-annotation inference to avoid over-typing.</p>&#13;
<p class="TX">We also discussed primitive and advanced built-in types and how to create custom types and interfaces. Finally, you used your new knowledge to add TypeScript to the Express.js server built in previous exercises and refactored the code with type annotations, custom types, and interfaces.</p>&#13;
<p class="TX">If you want to become a TypeScript expert, I recommend <i>The TypeScript Handbook</i> and the tutorials at <a href="https://www.typescripttutorial.net"><i>https://<wbr/>www<wbr/>.typescripttutorial<wbr/>.net</i></a>. In the next chapter, you’ll get to know React, a declarative JavaScript library for building user interfaces.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>