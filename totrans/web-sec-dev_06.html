<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_35"/><strong><span class="big">5</span></strong><br/><strong>HOW PROGRAMMERS WORK</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="image" width="190" height="190"/></div>&#13;
<p class="noindent">Building and maintaining a website is an iterative process, not an end goal. Rarely does a web developer build a site and get every feature right the first time. (Unless you’re my friend Dave; stop making the rest of us look bad, <em>Dave</em>.) In web development, the product evolves and the codebase grows more complex, requiring developers to add features, fix bugs, and restructure code. Redesigns happen as a matter of course.</p>&#13;
<p class="indent">As a web developer, you need to make and roll out changes to your codebase in an orderly and disciplined fashion. It’s common for security vulnerabilities and bugs to creep in over time because of shortcuts taken in the face of deadlines. Most security vulnerabilities are introduced not through a lack of development knowledge, but because of a lack of attention to detail.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_36"/>This chapter focuses on how you <em>should</em> be writing secure code, by adhering to the <em>Software Development Life Cycle (SDLC)</em>, a fancy phrase for the process a development team follows when designing new website features, writing code, testing it, and pushing out changes. A chaotic and messy SDLC makes it impossible to track the code you’re running and its vulnerabilities, which inevitably leads to a buggy, insecure website. However, a well-structured SDLC allows you to root out bugs and vulnerabilities early in the process to protect your end-product site from attacks.</p>&#13;
<p class="indent">We’ll go through five phases of a good SDLC: design and analysis, writing code, pre-release testing, the release process, and post-release testing and observation. We’ll also briefly talk about securing <em>dependencies</em>, the third-party software that we use in our websites.</p>&#13;
<h3 class="h3" id="ch00lev1sec50"><strong>Phase 1: Design and Analysis</strong></h3>&#13;
<p class="noindent">The SDLC doesn’t begin with writing code; it begins with thinking about what code you <em>should</em> be writing. We call this first phase the <em>design and analysis</em> phase: you analyze the features you need to add and design their implementation. At the start of a project, this might consist of sketching out brief design aims. But by the time your site is up and running, you need to give changes a little more deliberation, because you don’t want to break functionality for existing users.</p>&#13;
<p class="indent">The most important objective of this phase is identifying the requirements the code is trying to address. Once the development team completes the code, everyone should be able to judge whether the new code changes properly address those requirements. If you’re writing code for a client, this phase means meeting with stakeholders and getting them to agree to a list of goals. For in-house development at a company or organization, it mostly means developing and documenting a shared vision of whatever you’re building.</p>&#13;
<p class="indent"><em>Issue-tracking software</em> helps immensely with design and analysis, especially when you’re diagnosing and fixing bugs in an existing site. (Issue trackers are also known as <em>bug trackers</em> for this reason.) Issue trackers describe individual development goals as <em>issues</em>—such as “build a customer checkout page” or “fix the spelling mistake on the home page.” Issues are then assigned to individual developers, who can rank their issue by priority, write code to fix them, and mark them as complete. Developers can link specific sets of code changes for the purpose of fixing a bug or adding a feature described in an issue. For large teams, managers can schedule issues with project management software for reporting purposes.</p>&#13;
<p class="indent">The amount of time you should spend working things out on paper before writing code can vary. Teams that write software for firmware devices or critical systems like nuclear reactors unsurprisingly spend a <em>lot</em> of time in the design phase, because they rarely get a chance to fix code after deploying it. Web developers tend to move more quickly.</p>&#13;
<h3 class="h3" id="ch00lev1sec51"><span epub:type="pagebreak" id="page_37"/><strong>Phase 2: Writing Code</strong></h3>&#13;
<p class="noindent">Once you have completed design and analysis, you can move on to the second phase of the SDLC: writing code. You can write code with a lot of tools, but you should always keep any code that’s not a one-off script in <em>source control software</em> (also known as <em>version control</em>), which allows you to store a backup copy of your codebase, browse previous versions of the codebase, track changes, and annotate the code changes you’re making. You can share changes with the rest of your team by pushing code changes to the source <em>repository</em>, usually via command line tools or plug-ins to other development tools, before releasing them to the world. <em>Pushing</em> your code changes to the centralized repository makes them available to other team members for review. <em>Releasing</em> your changes means deploying them to your <em>production</em> website—the website that your real users will see.</p>&#13;
<p class="indent">Using source control also allows you to browse the version of the codebase currently running on the production site, which is key to diagnosing vulnerabilities and investigating and resolving security issues found post-release. When a development team identifies and resolves a security issue, they should look over the code changes that introduced the vulnerability and check whether the changes affected any other parts of the site.</p>&#13;
<p class="indent">Source control is the number one tool all development teams need to use. (Even a development team of one!) Large companies usually run their own source control servers, while smaller companies and open source developers typically use a third-party hosted service.</p>&#13;
<h4 class="h4" id="ch00lev1sec52"><strong><em>Distributed vs. Centralized Version Control</em></strong></h4>&#13;
<p class="noindent">A variety of source control software exists, each with different syntax and features. Of the tools currently available, the most popular is Git, a tool originally created by Linus Torvalds, the founder of Linux, to help organize the development of the Linux kernel. Git is a <em>distributed version control system</em>, which means that every copy of the code kept under Git is a fully fledged repository. When a new developer <em>pulls</em> (downloads) a local copy of the code from the team repository for the first time, they get not only the latest version of the codebase, but also a complete history of changes to the codebase.</p>&#13;
<p class="indent">Distributed source control tools track the changes the developer makes, and transmit only those changes when the developer pushes the code. This model of source control differs from older software, which implements a <em>centralized</em> server from which developers download and to which they upload whole files.</p>&#13;
<p class="indent">Git has become popular in no small part because of <em>GitHub</em>, a website that makes it straightforward to set up an online Git repository and invite team members. Users can view code stored in GitHub in the browser and can easily document it in the Markdown language. GitHub also includes its own issue tracker and tools to manage competing code changes.</p>&#13;
<h4 class="h4" id="ch00lev1sec53"><span epub:type="pagebreak" id="page_38"/><strong><em>Branching and Merging Code</em></strong></h4>&#13;
<p class="noindent">Source control software allows you to be precise about which code changes get pushed out with each update to your website. Typically, code releases are managed using branches. A <em>branch</em> is a logical copy of the codebase, stored either within the source control server or a developer’s local repository. Developers can make local changes to their own branch without affecting the <em>master</em> codebase, and then <em>merge</em> the branch back into the master codebase when they’ve completed whatever feature or bug fix they were working on.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Larger development teams may have more-elaborate branching schemes. Source control software allows you to create branches off of branches off of branches ad infinitum, since branching is a cheap operation. A large team may have several developers contribute to the same</em> feature branch <em>for complex code updates.</em></p>&#13;
</div>&#13;
<p class="indent">Before a release takes place, several developers might merge different branches into the master codebase. If they’ve been making different edits to the same files, the source control software automatically attempts to merge those changes. If the differing changes can’t be merged automatically, a <em>merge conflict</em> occurs, which requires the development team to manually complete the merge process, choosing line by line how competing code changes should be applied. Resolving merge conflicts is the bane of a developer’s life: it’s extra work that needs doing after you think you’ve already finished an issue. And usually it’s because Dave decided to change the formatting in several thousand Python files. (Thanks, Dave.)</p>&#13;
<p class="indent">Merge time is an excellent opportunity to do <em>code reviews</em>, in which one or more team members look over the code changes and give feedback. A great way to catch potential security vulnerabilities is to follow the <em>four eyes principle</em>, which requires two separate people to see every code change before a release. Often, a fresh set of eyes looking over the code can see problems not anticipated by the original author. (Cyclopes are terrible coders, so it’s recommended that you double up on their reviews.)</p>&#13;
<p class="indent">Git-based tools can formalize code reviews by using pull requests. A <em>pull request</em> is a developer’s request to merge code into the master codebase, which allows tools like GitHub to ensure that another developer approves changes before the merge occurs. (Source control software often makes the approval of pull requests contingent on all tests passing in a continuous integration system, which we’ll discuss in the following section.)</p>&#13;
<h3 class="h3" id="ch00lev1sec54"><strong>Phase 3: Pre-Release Testing</strong></h3>&#13;
<p class="noindent">The third stage of the SDLC is testing. You should release code only after you’ve tested it thoroughly to catch any potential bugs and ensure that it works correctly. A good testing strategy is key to catching software defects, especially security vulnerabilities, before users experience them or hackers can exploit them. Anyone making code changes should manually test the site’s functionality before merging or releasing code. This is a basic level of diligence you should expect from all members of your team.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_39"/>Catching software defects earlier in the development life cycle saves a lot of time and effort, so you should complement your manual testing with unit testing. <em>Unit tests</em> are small scripts within the codebase that make basic assertions about how the code operates by executing various parts of the codebase and testing the output. You should run unit tests as part of your build process, and write unit tests for particularly sensitive or frequently changing areas of your code.</p>&#13;
<p class="indent">Keep unit tests simple, so that they test isolated functions of the code. Overly complex unit tests that test multiple pieces of functionality at once are <em>brittle</em>, prone to breaking as code changes are made. A good unit test, for instance, might assert that only authenticated users can view certain areas of the website, or that passwords have to meet a minimum complexity requirement. Good unit tests additionally act as a form of documentation, illustrating how the code should operate if implemented correctly.</p>&#13;
<h4 class="h4" id="ch00lev1sec55"><strong><em>Coverage and Continuous Integration</em></strong></h4>&#13;
<p class="noindent">When you run a unit test, it calls functions in your main codebase. When you run all your unit tests, the percentage of your codebase that they execute is called your <em>coverage</em>. Although aiming for 100 percent test coverage is laudable, it’s often impractical, so be careful in choosing which parts of the codebase you write unit tests for. (Besides, complete test coverage doesn’t guarantee correct code; just because every code path is executed doesn’t mean all scenarios are covered.) Writing good unit tests is a matter of judgment and should be part of a larger risk-assessment strategy. Here’s a good rule of thumb: when you discover a bug, write a unit test asserting the correct behavior, and <em>then</em> fix the bug. This prevents the issue from reoccurring.</p>&#13;
<p class="indent">Once you have sufficient test coverage, you should set up a continuous integration server. A <em>continuous integration server</em> connects to your source control repository and, whenever code changes are made, checks out a fresh version of the code and runs the build process while executing your unit tests. If the build process fails—perhaps because the unit tests start failing—your development team receives an alert. Continuous integration ensures that you spot software defects early and address them promptly.</p>&#13;
<h4 class="h4" id="ch00lev1sec56"><strong><em>Test Environments</em></strong></h4>&#13;
<p class="noindent">Once you’ve completed all code changes for a release, you should deploy them to a test environment for final testing. A <em>test environment</em> (often called a <em>staging</em>, <em>pre-production</em>, or <em>quality assurance environment</em>) should be a fully operational copy of the website, run on dedicated servers. A test environment is essential for detecting software defects such as security vulnerabilities before a release happens. Large development teams often employ <em>quality assurance (QA)</em> staff dedicated to testing software in such environments. If you’re integrating different sets of code changes together, this is sometimes called <em>integration testing</em>.</p>&#13;
<p class="indent">A good test environment should resemble the production environment as closely as possible, to ensure that the tests are meaningful. You should run your test environment on the same server and database technologies, <span epub:type="pagebreak" id="page_40"/>differing only in the configuration and the version of the code running on it. (You should still apply common sense. Your test environment shouldn’t be able to send email to real users, for instance, so impose deliberate limitations to your test environments as needed.)</p>&#13;
<p class="indent">This process is analogous to a cast and crew of a theatrical play undertaking a dress rehearsal before performing in front of a live audience for the first time. They put on the play in full costume before a small test audience. This allows them to work out the final kinks in their performance in a low-stakes environment, where every detail resembles the real opening-night performance as closely as possible.</p>&#13;
<p class="indent">Test environments are a key part of secure releases, but they also pose security risks of their own if not properly managed. Test and production environments need to be properly <em>segregated</em> at the network layer, meaning that communication between the two environments is impossible. You can’t give attackers the chance to compromise your website by allowing them to hop across the network from an unsecured test environment into your production environment.</p>&#13;
<p class="indent">Test environments usually have their own database, which requires realistic-looking test data in order to allow thorough testing of the site’s functionality. A common approach to generating good test data is copying over data from production systems. If you do this, take special care to <em>scrub</em> this kind of data-copy of sensitive information, including names, payment details, and passwords. Numerous high-profile data leaks in recent years have been caused by attackers stumbling across improperly scrubbed data in a test environment.</p>&#13;
<h3 class="h3" id="ch00lev1sec57"><strong>Phase 4: The Release Process</strong></h3>&#13;
<p class="noindent">Writing code for a website isn’t much use if you don’t ever push it out, so let’s talk about the fourth phase of the SDLC: the release process. A <em>release process</em> for websites involves taking code from source control, copying it onto a web server, and (typically) restarting the web server process. How you achieve this varies according to where you host your site and what technology you use. Whatever your approach, your release process needs to be reliable, reproducible, and revertible.</p>&#13;
<p class="indent">A <em>reliable</em> release process means that you can guarantee what code, dependencies, resources, and configuration files get deployed during the release. If your release process is unreliable, you may not be running the version of the code you think you’re running, which is a serious security risk. To ensure that your website deploys files reliably, release scripts typically use <em>checksums</em>—digital “fingerprints” that ensure that the files copied onto the server are identical to those held in source control.</p>&#13;
<p class="indent">A <em>reproducible</em> release process is one that you can rerun with the same results, in different environments, or with different versions of the code. Reproducibility means less room for manual error during a release. If your release process requires an administrator to perfectly perform 24 steps in <span epub:type="pagebreak" id="page_41"/>the correct order, you can expect them to make mistakes. Write scripts and automate your release process as much as possible! A reproducible process is also essential for setting up good test environments.</p>&#13;
<p class="indent">A <em>revertible</em> release process allows you to <em>roll back</em> releases. Sometimes unexpected contingencies make you want to “undo” a recent release and revert to a prior version of the code. This process should be as seamless as possible. Partially rolled-back code is a disaster waiting to happen, because you may be leaving an insecure configuration in place, or software dependencies with known vulnerabilities. Whatever release process you choose, you need to be able to reliably revert to a previous version of the codebase with minimal fuss.</p>&#13;
<h4 class="h4" id="ch00lev1sec58"><strong><em>Options for Standardized Deployment During Releases</em></strong></h4>&#13;
<p class="noindent">Hosting companies have invented <em>Platform as a Service (PaaS)</em> solutions that make releasing code easy and reliable. If “in the cloud” refers to running code on other people’s servers, using an “as a service” offering refers to running code on other people’s servers, with some helpful automation and an administrative website. (Hosting companies have a track record of inventing horrible marketing acronyms.)</p>&#13;
<p class="indent">Microsoft Azure, Amazon Web Services Elastic Beanstalk, Google App Engine, and Heroku are all PaaS providers that allow developers to release code with a single command line call. The platform takes care of almost everything else required during the release process: setting up virtualized servers, installing the operating system and virtual machines, running your build process (more on this later), loading dependencies, deploying the code to disk, and restarting the web server process. You can monitor and roll back releases in a web console or from the command line, and the platform performs various safety checks to ensure your code deploys cleanly. Using a PaaS-based release process minimizes downtime for your site, ensures a clean deployment of code, and produces a full audit trail.</p>&#13;
<p class="indent">PaaS solutions impose limitations. In exchange for this convenience and reliability, they support only certain programming languages and operating systems. They allow a limited amount of server configuration, and they don’t support complex network layouts. As a result, it can sometimes be difficult to retrofit legacy applications for deployment on this kind of platform.</p>&#13;
<h5 class="h5" id="ch00lev1sec59"><strong>Infrastructure as a Service and DevOps</strong></h5>&#13;
<p class="noindent">If you’re not using PaaS, because your application is too complex, too old, or the cost is too prohibitive, you’ll typically deploy your code to individual servers. These might be self-hosted, hosted in a data center, or hosted on virtualized servers in an <em>Infrastructure as a Service (IaaS)</em> solution such as Amazon Elastic Compute Cloud (EC2). In such a scenario, you’re responsible for authoring your own release process.</p>&#13;
<p class="indent">Historically, companies have employed dedicated systems administrator staff to design and run the release process. However, the rise of <em>DevOps</em> <span epub:type="pagebreak" id="page_42"/>(short for <em>developer operations</em>) tools has blurred these responsibilities and allowed developers more control in the way their code gets deployed. DevOps tools (which have a variety of evocative names like Puppet, Chef, and Ansible) make it easy to describe standard deployment scenarios and modularize release scripts, giving development teams the power to design their own deployment strategies. This approach tends to be far more reliable than writing custom release scripts to download and copy files onto servers. DevOps tools make it easy to follow best practices because most deployment scenarios are covered by existing “recipes” or scripts.</p>&#13;
<h5 class="h5" id="ch00lev1sec60"><strong>Containerization</strong></h5>&#13;
<p class="noindent">Another approach to standardizing deployment is using containerization. <em>Containerization</em> technologies such as Docker allow you to create configuration scripts known as <em>images</em> that describe which operating system, disk layout, and third-party software a server should use, and which web application you should deploy on top of the software stack. You deploy images to a <em>container</em> that abstracts various functions of the underlying operating system to allow consistent deployment; everything required specifically for the release is described in the image, and the container is a completely generic component.</p>&#13;
<p class="indent">You can deploy Docker images to real or virtualized servers in a reproducible manner, making for a reliable release process. Developers testing their code locally can use the same exact Docker image as the production site, resulting in fewer surprises when the code is released for real.</p>&#13;
<p class="indent">Containerization is a relatively new technology, but it promises to make deployment of complex applications more reliable and standardized. A host of associated technologies (for example, Docker Swarm and Kubernetes) allow complex, multiserver network configurations to be described in machine-readable configuration files. This makes rebuilding whole environments much more straightforward. A team could, for instance, easily start up a whole new test environment with multiple web servers and a database, since these individual services and the way they communicate with each other would be described in a configuration file that the hosting service can understand.</p>&#13;
<h4 class="h4" id="ch00lev1sec61"><strong><em>The Build Process</em></strong></h4>&#13;
<p class="noindent">Most codebases have a <em>build process</em>, invoked from the command line or development tools, that takes the static code and prepares it for deployment. Languages such as Java and C# compile source code into a deployable binary format during the build process, while languages that use package managers download and validate third-party code, also known as <em>dependencies</em>, when they run the build process.</p>&#13;
<p class="indent">Build processes for websites often preprocess client-side assets ready for deployment. Many developers use languages such as TypeScript and CoffeeScript that they need to compile into JavaScript by the build process. Whether JavaScript is coded by hand or generated, build processes usually <span epub:type="pagebreak" id="page_43"/><em>minify</em>, or obfuscate, JavaScript files in order to generate a compressed, less readable, but functionally equivalent version of each JavaScript file that will load more quickly in the browser.</p>&#13;
<p class="indent">Styling information for websites is typically held in CSS files, as discussed in <a href="ch03.xhtml#ch03">Chapter 3</a>. Managing CSS files for large websites can be a chore (because styling information is often duplicated in different places and needs to be updated in sync). Web developers often use <em>CSS pre-processors</em> such as Sass and SCSS—languages designed to make stylesheets more manageable, which need to be preprocessed into CSS files at build time.</p>&#13;
<p class="indent">Each programming language has a preferred build tool that your development team should be proficient with. You should run the build process locally before checking any code into source control, so you can be sure the process works before rerunning it during the release process. Use a continuous integration server, as mentioned previously, to make sure this happens.</p>&#13;
<h4 class="h4" id="ch00lev1sec62"><strong><em>Database Migration Scripts</em></strong></h4>&#13;
<p class="noindent">Adding new features to a website often requires new database tables or updates to existing tables. Databases store data that needs to persist between releases, so you can’t simply wipe down and install a new database with each release. You need to create and then run database <em>migration scripts</em> against the database as part of your release process to update your database structures before deploying your code; and undo the scripts if you roll back the code.</p>&#13;
<p class="indent">Some technologies (for example, Ruby on Rails) allow you to run migration scripts as part of the build process. If you can’t run them as part of the build process, you should keep the scripts under source control, and then run them with temporarily elevated permissions on the database during the release window. In some companies, especially large and complex databases often have dedicated <em>database administrators (DBAs)</em> who manage this process and grumpily act as gatekeepers to their beloved datastores.</p>&#13;
<p class="indent">If staff members are able to change database structures outside a release, that’s a security risk. We’ll discuss various ways to lock down permissions in <a href="ch11.xhtml#ch11">Chapter 11</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec63"><strong>Phase 5: Post-Release Testing and Observation</strong></h3>&#13;
<p class="noindent">Once you’ve deployed your code, you should perform <em>post-release testing</em> to ensure that you’ve deployed it correctly, and that your assumptions about the way the code would execute in production are correct. Theoretically, this post-release testing (often called <em>smoke testing</em>) can be pretty cursory if you have a good test environment and a reliable release process. Nevertheless, it’s a good idea to pay attention to your gut instincts and be risk-averse when deciding how much testing to perform at each stage of the SDLC. There’s a saying that goes, “Continue testing until fear turns into boredom.” It captures the appropriate sentiment.</p>&#13;
<h4 class="h4" id="ch00lev1sec64"><span epub:type="pagebreak" id="page_44"/><strong><em>Penetration Testing</em></strong></h4>&#13;
<p class="noindent">Security professionals and ethical hackers often perform <em>penetration testing</em>, which tests for security vulnerabilities by externally probing a website. Penetration testing can be useful for both pre-release and post-release testing. Additionally, the development team can employ sophisticated automated penetration testing tools that test websites for common security vulnerabilities by analyzing various URLs and attempting to craft malicious HTTP requests. Penetration testing can be expensive and time-consuming, but it’s much, <em>much</em> cheaper than getting hacked, so strongly consider adding it your testing procedures.</p>&#13;
<h4 class="h4" id="ch00lev1sec65"><strong><em>Monitoring, Logging, and Error Reporting</em></strong></h4>&#13;
<p class="noindent">Once you’ve released your code, your production environment needs to be observable at runtime. This helps administrators spot unusual and potentially malicious behavior and diagnose issues as they occur. Post-release observation should happen in the form of three activities: logging, monitoring, and error reporting.</p>&#13;
<p class="indent"><em>Logging</em>, the practice of having code write to a log file as the software application performs actions, helps administrators see what a web server is doing at any given time. Your code should log every HTTP request (with a timestamp, URL, and the HTTP response code), as well as significant actions performed by users (for example, authentication and password-reset requests) and the site itself (for example, sending email and calling APIs).</p>&#13;
<p class="indent">You should make logs available to administrators at runtime (either on the command line or through a web console) and archive them for later reading (in case postmortems are needed). Adding log statements to your code helps diagnose problems that occur on your site, but be careful not to write sensitive details like passwords and credit card information on your logs in case an attacker ever manages to get access to them.</p>&#13;
<p class="indent"><em>Monitoring</em> is the practice of measuring response times and other metrics on your website at runtime. Monitoring your web server and database helps administrators spot high-load scenarios or degraded performance by firing alerts when network speeds slow or database queries take a long time. You should pass HTTP and database response times into monitoring software, which should, in turn, raise alerts when server and database response times pass certain thresholds. Many cloud platforms have monitoring software built in, so take the time to configure your error conditions and your chosen alerting system appropriately.</p>&#13;
<p class="indent">You should use <em>error reporting</em> to capture and record unexpected errors in the code. You can establish error conditions by either picking them out of logs or capturing and recording them in the code itself. You can then collate those error conditions in a datastore you make available to administrators. Many security intrusions exploit badly handled error conditions, so be sure to pay attention to unexpected errors as they occur.</p>&#13;
<p class="indent">Third-party services such as Rollbar and Airbrake supply plug-ins that allow you to collect errors with a few lines of code, so if you don’t have the <span epub:type="pagebreak" id="page_45"/>time or inclination to set up your own error-reporting system, consider using these types of services. Alternatively, log-scraping tools such as Splunk allow you to pick out errors from log files and make sense of them.</p>&#13;
<h3 class="h3" id="ch00lev1sec66"><strong>Dependency Management</strong></h3>&#13;
<p class="noindent">One thing you need to consider alongside the regular SDLC is dependency management. A curious fact about modern web development is that you’ll likely write only a small minority of the code that runs your website. Your site will typically depend on operating system code, a programming language runtime and associated libraries, possibly a virtual machine, and a web server process running third-party code libraries. All of these third-party tools that you’ll have to rely on to support your website’s code are known as <em>dependencies</em>. (In other words, the software that <em>your</em> software depends on to run.)</p>&#13;
<p class="indent">Experts in their field write each of these dependencies, saving you the burden of having to write your own memory management or low-level TCP semantics. These experts also have a strong incentive to stay on top of security vulnerabilities and issue patches as they arise, so you should take advantage of the resources they provide!</p>&#13;
<p class="indent">Using other people’s code requires diligence on your part. A secure SDLC should include a process for reviewing third-party libraries and determining when patches need to be applied. This often needs to happen outside the regular development cycle, since hackers won’t wait until your next scheduled release date to begin trying to exploit a security vulnerability. Staying ahead of security advisories and deploying patches for other people’s code is just as key as securing the code your team writes. We’ll look at how to do this in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec67"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned that a well-structured software development life cycle allows you to avoid bugs and software vulnerabilities.</p>&#13;
<ul>&#13;
<li><p class="noindent">You should document design goals by using issue-tracking software.</p></li>&#13;
<li><p class="noindent">You should keep code in source control to make older versions of the code available for inspection, and to make it easy to organize code reviews.</p></li>&#13;
<li><p class="noindent">Before a release, you should test code in a dedicated and isolated test environment that resembles your production environment and that treats your data with utmost care.</p></li>&#13;
<li><p class="noindent">You should have a reliable, reproducible, and revertible release process. If you have a scripted build process that generates assets ready for deployment, you should run it regularly and with unit tests in a continuous integration environment to highlight potential problems early in the development life cycle.</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_46"/>After a release, you should use penetration testing to detect website vulnerabilities before a hacker can make use of them. You should also use monitoring, logging, and error reporting to detect and diagnose problems with your running site.</p></li>&#13;
<li><p class="noindent">You should stay ahead of security advisories for any third-party code you use, because you may need to deploy patches outside your regular release cycle.</p></li>&#13;
</ul>&#13;
<p class="indent">In the next chapter, you’ll (finally!) begin to look at specific software vulnerabilities and how to protect against them. You’ll begin by looking at one of the biggest threats websites face: malicious input designed to inject code into your web server.</p>&#13;
</div>



  </body></html>