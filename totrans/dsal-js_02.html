<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_3" aria-label="3"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch1">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">1</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">USING JAVASCRIPT</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">JavaScript has evolved and added significant functionality since its original 1995 version. The addition of <i>classes</i> to the language aided with object-oriented programming so that you no longer need to work with complex prototypes. <i>Destructuring</i> and <i>spread</i> operators have simplified working with objects and arrays, and they allow you to manage multiple assignments at once. The introduction of <i>arrow functions</i> lets you work in a more succinct, expressive way, enhancing JavaScript’s functional programming capability. Finally, the concept of <i>modules</i> has simplified code organization and lets you partition and group your code in logical ways. This chapter briefly explores these</p>&#13;
<p class="TNI1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_4" aria-label="4"/>modern features of the language that help you write better, shorter, more understandable code.</p>&#13;
<p class="TX">The JavaScript language isn’t the only thing that has evolved, however, so this chapter also will introduce some of the many tools that are now available to help you develop JavaScript code. Environments like Visual Studio Code with special fonts provide better code readability. Other tools help produce documented, well-formatted code, and validation utilities can detect static or type-related errors. In addition, many online tools exist to help deal with incompatibilities among browsers and servers.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-4"/><span class="SANS_Futura_Std_Bold_B_11">Modern JavaScript Features</span></h3>&#13;
<p class="TNI1">We’ll start with an exploration of some modern JavaScript features that will simplify coding: arrow functions, classes, spreading values, destructuring, and modules. This list isn’t exhaustive, and we’ll look at other features in later chapters, including functional programming, map/reduce and similar array methods, functions as first-class objects, recursion, and more. We certainly can’t cover all of the language’s features, but here the focus is on the most important and newer features that are used throughout the book.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-1"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Arrow Functions</span></h4>&#13;
<p class="TNI1">JavaScript provides many ways to specify a function, such as:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Named functions, which are the most common: <span class="SANS_TheSansMonoCd_W5Regular_11">function alpha() {...}</span></li>&#13;
<li class="ListBullet">Nameless function expressions: <span class="SANS_TheSansMonoCd_W5Regular_11">const bravo</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">function () {...}</span></li>&#13;
<li class="ListBullet">Named function expressions: <span class="SANS_TheSansMonoCd_W5Regular_11">const charlie</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">function something() {...}</span></li>&#13;
<li class="ListBullet">Function constructors: <span class="SANS_TheSansMonoCd_W5Regular_11">const delta</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">new Function()</span></li>&#13;
<li class="ListBullet">Arrow functions: <span class="SANS_TheSansMonoCd_W5Regular_11">const echo</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">()</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=&gt; {...}</span></li>&#13;
</ul>&#13;
<p class="TX">All of those definitions work basically the same way, but arrow functions—JavaScript’s new kids on the block—have these important differences:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">They may return a value even without including a <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement.</li>&#13;
<li class="ListBullet">They cannot be used as constructors or generators.</li>&#13;
<li class="ListBullet">They don’t bind the <span class="SANS_TheSansMonoCd_W5Regular_11">this</span> value.</li>&#13;
<li class="ListBullet">They don’t have an <span class="SANS_TheSansMonoCd_W5Regular_11">arguments</span> object or a <span class="SANS_TheSansMonoCd_W5Regular_11">prototype</span> property.</li>&#13;
</ul>&#13;
<p class="TX">In particular, the first characteristic in the previous list is used a lot in this book; being able to omit the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword will make for shorter, more succinct code. For example, in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, you will see the following function:</p>&#13;
<pre id="pre-1"><code>const _getHeight = (tree) =&gt; (isEmpty(tree) ? 0 : tree.height);</code></pre>&#13;
<p class="TX">Given a <span class="SANS_TheSansMonoCd_W5Regular_11">tree</span> argument, this function returns <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> if the tree is empty; otherwise, it returns the tree object’s <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attribute.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_5" aria-label="5"/>The following example uses <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> and is an equivalent (but longer) way to write the same function:</p>&#13;
<pre id="pre-2"><code>const _getHeight = (tree) =&gt; {&#13;
  return isEmpty(tree) ? 0 : tree.height;&#13;
};</code></pre>&#13;
<p class="TX">The longer version isn’t necessary: shorter code is good.</p>&#13;
<p class="TX">If you use the shortened version and want to return an object, you need to enclose it in parentheses. Here’s another arrow function example from <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>:</p>&#13;
<pre id="pre-3"><code>const newNode = (key) =&gt; ({&#13;
  key,&#13;
  left: null,&#13;
  right: null,&#13;
  height: 1&#13;
});</code></pre>&#13;
<p class="TX">Given a <span class="SANS_TheSansMonoCd_W5Regular_11">key</span>, this function returns a node (an object, in fact) with that <span class="SANS_TheSansMonoCd_W5Regular_11">key</span> as an attribute, plus null <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">right</span> links and a <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attribute set to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>.</p>&#13;
<p class="TX">Another common feature of the arrow function is providing default values for missing parameters:</p>&#13;
<pre id="pre-4"><code>const print = (tree,<b> s = ""</b>) =&gt; {&#13;
  if (tree !== null) {&#13;
    console.log(s, tree.key);&#13;
    print(tree.left, `${s}  L:`);&#13;
    print(tree.right, `${s}  R:`);&#13;
  }&#13;
};</code></pre>&#13;
<p class="Continued">You will see what this code does in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, but the interesting part is that the recursive function, if not provided with a value for <span class="SANS_TheSansMonoCd_W5Regular_11">s</span>, will initialize it with the empty string.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-2"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Classes</span></h4>&#13;
<p class="TNI1">Although we won’t use classes much in this book, modern JavaScript has come far from its beginnings, and instead of having to deal with the <span class="SANS_TheSansMonoCd_W5Regular_11">prototype</span> and adding tangled code to implement inheritance, now you can achieve inheritance easily. In the past you could use classes and subclasses, different constructors, and all of that, but implementing inheritance wasn’t easy. JavaScript classes now make it much more straightforward. (See <i><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance</a></i> if you want to learn how to do inheritance in old-style JavaScript.)</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_6" aria-label="6"/>Take a look at a partial, slightly modified example from <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> that shows an actual class and how to define it:</p>&#13;
<pre id="pre-5"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> class Tree {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> _children = [];&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> constructor(rootKey) {&#13;
    this._key = rootKey;&#13;
  }&#13;
&#13;
  isEmpty() {&#13;
    return this._key === undefined;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> get key() {&#13;
    this._throwIfEmpty();&#13;
    return this._key;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> set key(v) {&#13;
    this._key = v;&#13;
  }&#13;
}</code></pre>&#13;
<p class="TX">You can either define a simple class, as is the case here <span class="CodeAnnotation" aria-label="annotation1">❶</span>, or extend an existing one. For instance, you could have another <span class="SANS_TheSansMonoCd_W5Regular_11">class BinaryTree extends Tree</span> to define a class based on <span class="SANS_TheSansMonoCd_W5Regular_11">Tree</span>. You can define attributes outside a constructor <span class="CodeAnnotation" aria-label="annotation2">❷</span>; you don’t need to do it inside a constructor <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Constructors are available if you need more complex object instance initialization.</p>&#13;
<p class="TX">Getters <span class="CodeAnnotation" aria-label="annotation4">❹</span> and setters <span class="CodeAnnotation" aria-label="annotation5">❺</span> are other powerful features. They bind an object’s property to functions that are invoked whenever we try to modify or access that property.</p>&#13;
<p class="TX">Other features not used in this example are <span class="SANS_TheSansMonoCd_W5Regular_11">static</span> properties and methods; such attributes aren’t part of the class instances, but rather belong to the class itself.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Starting with ECMAScript 2022, JavaScript also includes</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">private</span> <i>properties: fields, methods, getters, setters, and so on.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-3"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Spread Operator</span></h4>&#13;
<p class="TNI1">The spread operator (<span class="SANS_TheSansMonoCd_W5Regular_11">...</span>) allows you to, well, <i>spread</i> an array, string, or object into separate values in a single operation, providing some interesting array and object usages.</p>&#13;
<p class="TX">Arrays are applied like this:</p>&#13;
<pre id="pre-6"><code>const myArray = [3, 1, 4, 1, 5, 9, 2, 6];&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const arrayMax = Math.max(...myArray);&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const newArray = [...myArray];</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_7" aria-label="7"/>Entering <span class="SANS_TheSansMonoCd_W5Regular_11">...myArray</span> is the same as entering <span class="SANS_TheSansMonoCd_W5Regular_11">3, 1, 4, 1, 5, 9, 2, 6</span>, so the first usage of <span class="SANS_TheSansMonoCd_W5Regular_11">...myArray</span> in this example produces <span class="SANS_TheSansMonoCd_W5Regular_11">9</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and the second provides a new array with exactly the same elements of <span class="SANS_TheSansMonoCd_W5Regular_11">myArray</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">You can also use the spread operator to build a copy of an object, which you can then modify independently:</p>&#13;
<pre id="pre-7"><code>const myObject = {last: "Darwin", year: 1809};&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newObject = {...myObject, first: "Charles", year: 1882};&#13;
// same as: {last: "Darwin", first: "Charles", year: 1882};</code></pre>&#13;
<p class="TX">In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">newObject</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> first gets a copy of the attributes of <span class="SANS_TheSansMonoCd_W5Regular_11">myObject</span>, and then the <span class="SANS_TheSansMonoCd_W5Regular_11">year</span> attribute is overwritten. You could do this “the old way” with many individual assignments, but using the spread operator allows for shorter and clearer code.</p>&#13;
<p class="TX">A third usage of the spread operator is for functions that need to deal with an undefined number of parameters. Earlier versions of JavaScript had the <span class="SANS_TheSansMonoCd_W5Regular_11">arguments</span> array-like object to handle this situation. The <span class="SANS_TheSansMonoCd_W5Regular_11">arguments</span> object is “array-like,” because <span class="SANS_TheSansMonoCd_W5Regular_11">.length</span> is the only array property it provides. The <span class="SANS_TheSansMonoCd_W5Regular_11">arguments</span> object doesn’t include any other properties that arrays have.</p>&#13;
<p class="TX">For example, you could write your own <span class="SANS_TheSansMonoCd_W5Regular_11">Math.max()</span> version like this:</p>&#13;
<pre id="pre-8"><code>const myMax = (...nums) =&gt; {&#13;
  let max = nums[0];&#13;
  for (let i = 1; i &lt; nums.length; i++) {&#13;
    if (max &lt; nums[i]) max = nums[i];&#13;
  }&#13;
  return max;&#13;
};</code></pre>&#13;
<p class="TX">You could now use <span class="SANS_TheSansMonoCd_W5Regular_11">myMax()</span> like you’d use <span class="SANS_TheSansMonoCd_W5Regular_11">Math.max()</span>, but there’s no reason to reinvent that function. This example shows how you can imitate the features of existing functions—in this case, the ability to pass many arguments to a function.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-4"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Destructuring Statement</span></h4>&#13;
<p class="TNI1">The <i>destructuring</i> statement is related to the spread operator. It allows you to assign several variables at the same time, which means you can combine several independent assignments into one and write shorter code. For example:</p>&#13;
<pre id="pre-9"><code>[first, last] = ["Abraham", "Lincoln"];</code></pre>&#13;
<p class="TX">In this case, you assign <span class="SANS_TheSansMonoCd_W5Regular_11">"Abraham"</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> variable and <span class="SANS_TheSansMonoCd_W5Regular_11">"Lincoln"</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> variable.</p>&#13;
<p class="TX">You also can mix destructuring and spreading:</p>&#13;
<pre id="pre-10"><code>[first, last, . . .years] = ["Abraham", "Lincoln", 1809, 1865];</code></pre>&#13;
<p class="TX">Assign the initial elements in the array to <span class="SANS_TheSansMonoCd_W5Regular_11">first</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">last</span>, as in the previous example, and assign all of the rest of the elements (the two numbers) to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_8" aria-label="8"/>the <span class="SANS_TheSansMonoCd_W5Regular_11">years</span> array. This combination lets you write code more succinctly, using a single statement, where previously several would have been required.</p>&#13;
<p class="TX">In addition, you can use default values when variables on the left side have no corresponding values on the right:</p>&#13;
<pre id="pre-11"><code>let [first, last, role = "President", party] = ["Abraham", "Lincoln"];</code></pre>&#13;
<p class="TX">In this example, the destructuring statement assigns a default value to <span class="SANS_TheSansMonoCd_W5Regular_11">role</span> and leaves <span class="SANS_TheSansMonoCd_W5Regular_11">party</span> undefined.</p>&#13;
<p class="TX">You can also swap or rotate variables, which is a technique used frequently later in this book. Consider this line from code in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>:</p>&#13;
<pre id="pre-12"><code>[heap[p], heap[i]] = [heap[i], heap[p]];</code></pre>&#13;
<p class="TX">This directly swaps the values of <span class="SANS_TheSansMonoCd_W5Regular_11">heap[p]</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">heap[i]</span> without using an auxiliary variable. You also could write something like <span class="SANS_TheSansMonoCd_W5Regular_11">[d, e, f]</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">[e, f, d]</span> to rotate the values of three variables, again without requiring more variables.</p>&#13;
<p class="TX">Finally, another pattern that we’ll often use is to return two or more values at once from a function. For example, you could write a function to return two values in order:</p>&#13;
<pre id="pre-13"><code>const order2 = (a, b) =&gt; {&#13;
  if (a &lt; b) {&#13;
    return [a, b];&#13;
  } else {&#13;
    return [b, a];&#13;
  }&#13;
};&#13;
&#13;
let [smaller, bigger] = order2(22, 9); // smaller==9, bigger==22</code></pre>&#13;
<p class="TX">The other way of returning many values at once is with an object. You still can do that, but returning an array and using destructuring is more compact.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-5"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Modules</span></h4>&#13;
<p class="TNI1"><i>Modules</i> allow you to split code into pieces you can import when needed, providing a way to package functionality that is easier to understand and maintain. Each module should be an aggregation of related functions and classes, providing a set of features. A standard practice related to using modules is <i>high cohesion</i>, which means elements you put together should truly belong together, as unrelated functionalities should not be mixed in the same module. A related concept called <i>low coupling</i> means that distinct modules should be interdependent as little as possible. JavaScript lets you package functions in modules to provide a well-structured design, with greater readability and maintainability.</p>&#13;
<p class="TX">Modules come in two formats: <i>CommonJS modules</i> (an earlier format, used mostly in Node.js) and <i>ECMAScript modules</i> (the latest format, generally used by browsers).</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_9" aria-label="9"/>&#13;
<h5 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">CommonJS Modules</span></h5>&#13;
<p class="TNI1">With CommonJS modules, write the code in the style of this (abridged) example from <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span>:</p>&#13;
<pre id="pre-14"><code>// file: radix_tree.js – in CommonJS style&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const EOW = "■";&#13;
const newRadixTree = () =&gt; null;&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const newNode = () =&gt; ({links: {}});&#13;
const isEmpty = (rt) =&gt; !rt; // null or undefined&#13;
const print = (trie, s = "") =&gt; {...}&#13;
const printWords = (trie, s = "") =&gt; {...}&#13;
const find = (trie, wordToFind) =&gt; {...}&#13;
const add = (trie, wordToAdd, dataToAdd) =&gt; {...}&#13;
const remove = (trie, wordToRemove) =&gt; {...}&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> module.exports = {&#13;
  add,&#13;
  find,&#13;
  isEmpty,&#13;
  newRadixTree,&#13;
  print,&#13;
  printWords,&#13;
  remove&#13;
};</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">module.exports</span> assignment at the end <span class="CodeAnnotation" aria-label="annotation3">❸</span> defines what parts of the module will be visible from the outside; whatever is not included <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> won’t be accessible for the rest of the system. This way of writing code is well aligned with the <i>black box</i> software concept. Users of a module shouldn’t need to learn or even know about its internal details to allow for higher maintainability. As long as the module keeps providing the same functionality, its developers are free to refactor or improve it without impacting any users.</p>&#13;
<p class="TX">If you wanted to import a pair of the functions that the module exports, for example, you’d use the following code style, which employs destructuring, to specify what you want:</p>&#13;
<pre id="pre-15"><code>const {newRadixTree, add} = require("radix_tree.js");</code></pre>&#13;
<p class="TX">This allows access (via destructuring) to the <span class="SANS_TheSansMonoCd_W5Regular_11">newRadixTree()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> functions, out of all the functions exported by the <span class="SANS_TheSansMonoCd_W5Regular_11">radix_tree</span> module. If you want to add something to the Radix tree, you can call <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> directly; similarly, you can call <span class="SANS_TheSansMonoCd_W5Regular_11">newRadixTree()</span> to create a new tree.</p>&#13;
<p class="TX">Of course, you can also do this:</p>&#13;
<pre id="pre-16"><code>const RadixTree = require("radix_tree.js");</code></pre>&#13;
<p class="TX">In order to add something to a tree or create a new one, you have to call <span class="SANS_TheSansMonoCd_W5Regular_11">RadixTree.add()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">RadixTree.newRadixTree()</span> instead. This usage makes for longer code, but it also lets you access all the functions in the <span class="SANS_TheSansMonoCd_W5Regular_11">radix_tree</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_10" aria-label="10"/>module. I prefer the first style that employs destructuring, because it makes clear what I am using, but it’s really up to you.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">ECMAScript Modules</span></h5>&#13;
<p class="TNI1">The more modern ECMAScript style of defining modules also works with separate files, but instead of creating a <span class="SANS_TheSansMonoCd_W5Regular_11">module.exports</span> object, you rewrite the module you just saw in the previous section as follows:</p>&#13;
<pre id="pre-17"><code>// file: radix_tree.js – in modern style&#13;
&#13;
const EOW = "■";&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span><b> export</b> const newRadixTree = () =&gt; null;&#13;
const newNode = () =&gt; ({links: {}});&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span><b> export </b>const isEmpty = (rt) =&gt; !rt; // null or undefined&#13;
const print = (trie, s = "") =&gt; {...}&#13;
const printWords = (trie, s = "") =&gt; {...}&#13;
const find = (trie, wordToFind) =&gt; {...}&#13;
const add = (trie, wordToAdd, dataToAdd) =&gt; {...}&#13;
const remove = (trie, wordToRemove) =&gt; {...}&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> export {&#13;
  add,&#13;
  find,&#13;
  print,&#13;
  printWords,&#13;
  remove&#13;
};</code></pre>&#13;
<p class="TX">You can export something directly wherever you define it <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> or postpone doing so until the end <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Both methods work (and I don’t think anybody would really use <i>both</i> styles, as I did for this example), but most people prefer having all <span class="SANS_TheSansMonoCd_W5Regular_11">export</span> statements together at the end. It’s really your choice.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can also use ECMAScript</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">import</span> <i>and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">export</span> <i>statements in Node.js, but only if you use the .mjs extension instead of the .js extension, which is reserved for CommonJS modules.</i></p>&#13;
<p class="TX">You can import functions from an ECMAScript module in the following way, which is a different usage in comparison with the CommonJS modules, although the end result is exactly the same:</p>&#13;
<pre id="pre-18"><code>import {newRadixTree, add} from "radix_tree.js";</code></pre>&#13;
<p class="TX">If you want to import everything, use the following code instead; this will give you access to an object, including all the functions exported by the module, as earlier:</p>&#13;
<pre id="pre-19"><code>import * as RadixTree from "radix_tree.js";</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_11" aria-label="11"/>All the exports you’ve seen so far are <i>named</i> exports; you can have as many of them as you want, and you can also have a single unnamed <span class="SANS_TheSansMonoCd_W5Regular_11">default</span> export. In a given file, instead of defining what you want to export, as described earlier, you include something like this instead:</p>&#13;
<pre id="pre-20"><code>// file: my_module.js&#13;
export default something = ... // whatever you want to export</code></pre>&#13;
<p class="TX">Then, in other parts of the code, you can do the following to import something:</p>&#13;
<pre id="pre-21"><code>import whatever from "my_module.js";</code></pre>&#13;
<p class="TX">You can name what you imported whatever you like (<span class="SANS_TheSansMonoCd_W5Regular_11">whatever</span> isn’t a good name) instead of using the name the module creator intended. That isn’t usual practice, but sometimes name conflicts arise when using modules by different authors.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-6"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Closures and Immediately Invoked Function Expressions</span></h4>&#13;
<p class="TNI1">Closures and immediately invoked function expressions aren’t actually new, but understanding them will be useful when following the examples in this book. A <i>closure</i> is the combination of a function plus its encompassing scope to which the function has access. It allows you to have private variables, which in turn allows you to create the equivalent of classes and modules. For instance, consider the following function:</p>&#13;
<pre id="pre-22"><code>function createPerson(firstN, lastN) {&#13;
  let first = firstN;&#13;
  let last = lastN;&#13;
  return {&#13;
    getFirst: function () {&#13;
      return first;&#13;
    },&#13;
&#13;
    getLast: function () {&#13;
      return last;&#13;
    },&#13;
&#13;
    fullName: function () {&#13;
      return first + " " + last;&#13;
    },&#13;
&#13;
    setName: function (firstN, lastN) {&#13;
      first = firstN;&#13;
      last = lastN;&#13;
    }&#13;
  };&#13;
}</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_12" aria-label="12"/>The returned value (an object) will have access to the first and last variables in the scope of the function. For example, consider the following:</p>&#13;
<pre id="pre-23"><code>const me = createPerson("Federico", "Kereki");&#13;
console.log(me.getFirst()); // Federico&#13;
console.log(me.getLast());  // Kereki&#13;
console.log(me.fullName()); // Federico Kereki&#13;
&#13;
me.setName("John", "Doe");&#13;
console.log(me.fullName()); // John Doe</code></pre>&#13;
<p class="TX">Those variables aren’t accessible anywhere else. If you try to access <span class="SANS_TheSansMonoCd_W5Regular_11">me.first</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">me.last</span>, you get <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>. Those variables are in the closure, but there’s no way to access them, because they work as private values.</p>&#13;
<p class="TX">Using closures also allows you to simulate modules. For that, you’ll need an <i>immediately invoked function expression (IIFE)</i>, pronounced “iffy,” which is a function defined and executed as soon as it’s defined.</p>&#13;
<p class="TX">Say you want a module to work with taxes. Without using the new modules, you could work in a similar way as with the <span class="SANS_TheSansMonoCd_W5Regular_11">createPerson(...)</span> function:</p>&#13;
<pre id="pre-24"><code>const tax = (function (basicTax) {&#13;
  let vat = basicTax;&#13;
  /*&#13;
    ...many more tax-related variables&#13;
  */&#13;
  return {&#13;
    setVat: function (newVat) {&#13;
      vat = newVat;&#13;
    },&#13;
    getVat: function () {&#13;
      return vat;&#13;
    },&#13;
    addVat: function (value) {&#13;
      return value * (1 + vat / 100);&#13;
    }&#13;
    /*&#13;
      ...many more tax-related functions&#13;
    */&#13;
  };&#13;
})(6);</code></pre>&#13;
<p class="TX">You create a (nameless) function and call it immediately, and the result works like a module. You can pass initial values to the IIFE, such as 6 percent for the default value-added tax (VAT). The <span class="SANS_TheSansMonoCd_W5Regular_11">vat</span> variable, and others you may declare, are internal and cannot be accessed directly. However, the provided functions, <span class="SANS_TheSansMonoCd_W5Regular_11">addVat(...)</span> and any others you may want, can work with all the internal variables.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_13" aria-label="13"/>Use the IIFE-based module as follows:</p>&#13;
<pre id="pre-25"><code>console.log(tax.getVat());    // 6: the initial default&#13;
tax.setVat(8);&#13;
console.log(tax.getVat());    // 8&#13;
console.log(tax.addVat(200)); // 216</code></pre>&#13;
<p class="TX">Modules can provide the same basic functionality, but you will see cases when you’ll want to use closures and IIFEs—for example, in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> where memoizing and precomputing an array of values are discussed.</p>&#13;
<aside class="box" aria-label="box-1">&#13;
<p class="BT" id="box-1"><span class="SANS_Dogma_OT_Bold_B_11">JAVASCRIPT STANDARDS AND VERSIONS</span></p>&#13;
<p class="BoxBodyFirst"><span class="SANS_Futura_Std_Book_11">JavaScript’s frequent updates have caused incompatibilities among versions. This book works with the latest version of the language, which is formally known as ECMAScript. ECMA originally stood for European Computer Manufacturers Association, but it’s now considered to be a noun rather than an acronym. See the ECMA website (</span><span class="SANS_Futura_Std_Book_Oblique_11"><a href="https://www.ecma-international.org">https://www.ecma-international.org</a></span><span class="SANS_Futura_Std_Book_11">) for more detailed information about JavaScript, including a very full specification of the whole language.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">The Mozilla Developer Network (MDN;</span> <span class="SANS_Futura_Std_Book_Oblique_11"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></span><span class="SANS_Futura_Std_Book_11">) is also an invaluable resource for information on features like functions, classes, and</span> <span class="SANS_Futura_Std_Book_11">modules</span><span class="SANS_Futura_Std_Book_Oblique_11">.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">All web browsers, as well as Node.js, may not implement the latest version of the language, but if you encounter an issue, you can use Babel to</span> <span class="SANS_Futura_Std_Book_Oblique_11">transpile</span> <span class="SANS_Futura_Std_Book_11">(transpile is a portmanteau of</span> <span class="SANS_Futura_Std_Book_Oblique_11">translate</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_Futura_Std_Book_Oblique_11">compile</span><span class="SANS_Futura_Std_Book_11">) your code into equivalent, but older (yet compatible) code, so you can still run it. See</span> <span class="SANS_Futura_Std_Book_Oblique_11"><a href="https://babeljs.io">https://babeljs.io</a></span> <span class="SANS_Futura_Std_Book_11">for more details on Babel as well as installation and configuration instructions. I ran all the code in the book in the current version of Node.js and didn’t encounter any problems. To install Node.js, see</span> <span class="SANS_Futura_Std_Book_Oblique_11"><a href="https://nodejs.org/en/download">https://nodejs.org/en/download</a></span><span class="SANS_Futura_Std_Book_11">.</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-5"/><span class="SANS_Futura_Std_Bold_B_11">JavaScript Development Tools</span></h3>&#13;
<p class="TNI1">Let’s turn our attention to some tools to add to your arsenal to help write better-looking code, check for common defects, and more. You won’t use all of them in this book, but they are helpful and usually the first things I install whenever I start a new project.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-7"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Visual Studio Code</span></h4>&#13;
<p class="TNI1">An integrated development environment (IDE) will help you write code quickly and easily. This book uses the Visual Studio Code (VSC) IDE. Other popular IDEs include Atom, Eclipse, Microsoft Visual Studio, NetBeans, Sublime, and Webstorm, and you could work with any of those as well.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_14" aria-label="14"/>Why use an IDE? Although a simple text editor, such as Notepad or vi, might be all you need, an IDE like VSC provides more functionality. With a text editor, you have to do more work yourself, constantly switching between tools and entering commands repeatedly. Using VSC (or any IDE) is a time-saver that allows you to work in an integrated fashion and with many tools in a single click.</p>&#13;
<p class="TX">VSC is open source, free, and updated monthly, with new features added frequently. You can use it for JavaScript and many other languages. Frontend developers use VSC for basic configuration and recognition (“IntelliSense”) for HTML, CSS, JSON, and more. You can expand it via a vast catalog of extensions as well.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Visual Studio Code, despite the similar name, is not related to Microsoft’s other IDE, Visual Studio. You can use Visual Studio Code in Windows, Linux, and macOS, because it was developed in JavaScript and packaged for the desktop using the Electron framework.</i></p>&#13;
<p class="TX">VSC also provides good performance, integrated debugging, an integrated terminal (to launch processes or run commands without having to leave VSC), and integration with source code management (typically Git). <a href="chapter1.xhtml#fig1-1">Figure 1-1</a> shows some of my own work in VSC with the code for this book.</p>&#13;
<figure class="IMG"><img class="img1" id="fig1-1" src="../images/Figure1-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-1: Using Visual Studio Code</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_15" aria-label="15"/>Go to <i><a href="https://code.visualstudio.com">https://code.visualstudio.com</a></i> to download the proper version for your environment and follow the installation instructions. If you like to live on the edge, install the Insiders’ Version to gain access to new features, but be aware that you risk suffering from some bugs. For some Linux distributions, instead of downloading and installing the package yourself, you can use your package manager to handle installation and updating.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-8"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Fira Code Font</span></h4>&#13;
<p class="TNI1">A quick way to start a (possibly heated) argument among developers is to mention that a given font is the best one for programming. Dozens of monospaced fonts for programming exist, but few include <i>ligatures</i>, which is when two or more characters are joined together. JavaScript code is a good candidate for ligatures, because otherwise you need to enter common symbols (such as ≥ or ≠) as two or three separate characters, which just doesn’t look as good.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The &amp; character originally was a ligature of E and t to spell et, which means “and” in Latin. Another ligature in English is</i> <span class="note_accent">æ</span> <i>(as in</i> encyclop<span class="note_accent">æ</span>dia <i>or</i> C<span class="note_accent">æ</span>sar<i>) combining the letters a and e. Many other languages include ligatures; German joins two s characters together in</i> <span class="note_accent">ß</span><i>, like in</i> Fu<span class="note_accent">ß</span>ball <i>(football).</i></p>&#13;
<p class="TX">The Fira Code font (<i><a href="https://github.com/tonsky/FiraCode">https://github.com/tonsky/FiraCode</a></i>) provides many ligatures and enhances the look of your code. <a href="chapter1.xhtml#fig1-2">Figure 1-2</a> shows all the possible ligatures for JavaScript. Fira Code includes ligatures for other languages as well.</p>&#13;
<figure class="IMG"><img class="img1" id="fig1-2" src="../images/Figure1-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-2: A sample of the many ligatures Fira Code font provides (cropped from the Fira Code website)</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_16" aria-label="16"/>After downloading and installing the font, if you are using Visual Studio Code, follow the instructions at <i><a href="https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions">https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions</a></i> to integrate the font with the IDE.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-9"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Prettier Formatting</span></h4>&#13;
<p class="TNI1">How to format source code can be another source of disagreements. Every developer you work with will likely have their own take on this issue, asserting that their standard is best. If you work with a team of developers, you may be familiar with the situation shown in the “How Standards Proliferate” xkcd comic (<a href="chapter1.xhtml#fig1-3">Figure 1-3</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig1-3" src="../images/Figure1-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-3: “How Standards Proliferate” (courtesy of xkcd,</span> <span class="SANS_Futura_Std_Book_11"><a href="https://xkcd.com/927">https://xkcd.com/927</a></span>)</p></figcaption>&#13;
</figure>&#13;
<p class="TX">Prettier is an “opinionated” source code formatter that reformats code according to its own set of rules and a few parameters you can set. Prettier’s website states, “By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles.” All the source code examples in this book are formatted with Prettier.</p>&#13;
<p class="TX">Installing Prettier is simple; follow the instructions at <i><a href="https://prettier.io">https://prettier.io</a></i>, and if you use Visual Studio Code, also install the Prettier extension from <i><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode</a></i>. Be sure to tweak VSC’s settings to enable the <span class="SANS_TheSansMonoCd_W5Regular_11">editor.formatOnSave</span> option so all code will be reformatted upon saving. Consult the documentation on the Prettier website to learn more about configuring Prettier to your liking.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-10"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">JSDoc Documentation</span></h4>&#13;
<p class="TNI1">Documenting your source code is development best practice. JSDoc (<i><a href="https://jsdoc.app">https://jsdoc.app</a></i>) is a tool that helps you produce documentation for your code by aggregating specifically formatted comments. If you add comments preceding your functions, methods, classes, and so on, JSDoc will use them to produce documentation for your code. We don’t use JSDoc in this book, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label="17"/>because the text explains the code. However, for normal work, using JSDoc helps developers understand all of a system’s pieces.</p>&#13;
<p class="TX">Here’s a code snippet that adds a key to a heap from <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> to show how JSDoc produces documentation:</p>&#13;
<pre id="pre-26"><code><b> </b>/**&#13;
 * Add a new key to a heap.&#13;
 *&#13;
 * @author F.Kereki&#13;
 * @version 1.0&#13;
 * @param {pointer} heap – Heap to which the key is added&#13;
 * @param {string} keyToAdd – Key to be added&#13;
 * @return Updated heap&#13;
 */&#13;
const add = (heap, keyToAdd) =&gt; {&#13;
  heap.push(keyToAdd);&#13;
  _bubbleUp(heap, heap.length – 1);&#13;
  return heap;&#13;
};</code></pre>&#13;
<p class="TX">JSDoc comments start with the <span class="SANS_TheSansMonoCd_W5Regular_11">/**</span> combination, which is like the usual comment format but with one extra asterisk. The <span class="SANS_TheSansMonoCd_W5Regular_11">@author</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">@version</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">@param</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">@return</span> tags describe specific information about the code; the names are self-explanatory. Other tags you can use include <span class="SANS_TheSansMonoCd_W5Regular_11">@class</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">@constructor</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">@deprecated</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">@exports</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">@property</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">@throws</span> (or <span class="SANS_TheSansMonoCd_W5Regular_11">@exception</span>). See <i><a href="https://jsdoc.app/index.html">https://jsdoc.app/index.html</a></i> for a complete list.</p>&#13;
<p class="TX">After installing JSDoc according to the instructions at <i><a href="https://github.com/jsdoc/jsdoc">https://github.com/jsdoc/jsdoc</a></i>, I processed this example file, which produced the results shown in <a href="chapter1.xhtml#fig1-4">Figure 1-4</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig1-4" src="../images/Figure1-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-4: A sample documentation web page automatically generated by JSDoc</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_18" aria-label="18"/>Of course, this is a simple example with only a single file. For a complete system, you would get a home page with links to every page of documentation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-11"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">ESLint</span></h4>&#13;
<p class="TNI1">JavaScript presents many possibilities for misuse and misunderstanding. Consider this simple example: if you use the <span class="SANS_TheSansMonoCd_W5Regular_11">==</span> operator instead of <span class="SANS_TheSansMonoCd_W5Regular_11">===</span>, you may find cases in which <span class="SANS_TheSansMonoCd_W5Regular_11">x==y</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y==z</span>, but <span class="SANS_TheSansMonoCd_W5Regular_11">x!=z</span>, no matter what the transitive law may say. (Try <span class="SANS_TheSansMonoCd_W5Regular_11">x=[]</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">y=0</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">z="0"</span>.) Another tricky case is if you accidentally enter <span class="SANS_TheSansMonoCd_W5Regular_11">(x=y)</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">(x==y)</span>, which would be an assignment rather than a comparison; it’s not very likely you want the former.</p>&#13;
<p class="TX">A <i>linter</i> is a tool that analyzes code and produces warning or error messages about any doubtful or error-prone features you might be using. In some cases, a linter may even fix your code properly. You also can use linters in conjunction with source code versioning tools. Linters can keep you from posting code that doesn’t pass all checks. If you use Git, go to <i><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks</a></i> to read about precommit hooks.</p>&#13;
<p class="TX">ESLint works well for linting in JavaScript. It was created in 2013 and is still going strong. Go to <i><a href="https://www.npmjs.com/package/eslint">https://www.npmjs.com/package/eslint</a></i> to download and install, and then configure it. Be sure to carefully read the rules at <i><a href="https://eslint.org/docs/rules/">https://eslint.org/docs/rules/</a></i>, because you can set many different rules, but you shouldn’t turn them all on unless you want to start some linting wars.</p>&#13;
<p class="TX">Finally, don’t forget the VSC extension at <i><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint</a></i>, so you can see whatever errors ESLint detects.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>With ESLint, the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">eqeqeq</span> <i>rule (see</i> <span class="note_LinkURL_Italic"><a href="https://eslint.org/docs/rules/eqeqeq">https://eslint.org/docs/rules/eqeqeq</a></span><i>) would have detected the problem with the type-unsafe</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">==</span> <i>operator and even would have fixed it by substituting</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">===</span> <i>instead. In addition, the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">no-cond-assign</span> <i>rule would have warned about the unexpected assignment.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-12"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Flow and TypeScript</span></h4>&#13;
<p class="TNI1">For large-scale coding, consider using Flow and TypeScript, which let you add information about data types to JavaScript. Flow adds comments that describe what data types are expected for function inputs and outputs, variables, and so forth. TypeScript is actually is a superset of JavaScript that is transpiled into it.</p>&#13;
<p class="TX"><a href="chapter1.xhtml#fig1-5">Figure 1-5</a> (shamelessly based on an example from the TypeScript home page) shows the kinds of errors you can detect with type information.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_19" aria-label="19"/>&#13;
<figure class="IMG"><img class="img1" id="fig1-5" src="../images/Figure1-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-5: A type error in TypeScript code caught on the fly by ESLint</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this example, I’m trying to access an attribute that doesn’t exist (<span class="SANS_TheSansMonoCd_W5Regular_11">user.name</span>) according to the type data deduced from earlier lines of code. (Note that I’m using ESLint, which is why I can see the error in real time.)</p>&#13;
<p class="TX">We won’t use either of these two tools in this book, but for big projects that involve many classes, methods, functions, types, and so on, consider adding them to your repertoire.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-13"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Online Feature Availability Resources</span></h4>&#13;
<p class="TNI1">If you’re working server-side with the latest version of Node.js, you probably won’t need to worry about any specific feature being available. However, if you’re doing frontend work, a given function may not be available, such as Internet Explorer support. If that happens, you’ll need to transpile with something like Babel, as mentioned earlier in the chapter.</p>&#13;
<p class="TX">The Kangax website (<i><a href="https://compat-table.github.io/compat-table/es2016plus/">https://compat-table.github.io/compat-table/es2016plus/</a></i>) provides information on multiple platforms, detailing whether a function is fully, partially, or not available. Kangax provides a listing of all the JavaScript language features, with examples for each, and you’ll find a table on the website that shows what features are available for each different JavaScript engine, such as features found on browsers and Node.js. Generally speaking, when you open it with a browser, green “Yes” boxes mean you can use the feature safely; boxes in different colors or text imply the feature is partially available or not available.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_20" aria-label="20"/>The <i>Can I Use?</i> website at <i><a href="https://www.caniuse.com/">https://www.caniuse.com/</a></i> lets you search by function and shows the available support in different browsers. For instance, if you search for arrow functions, the website will tell you which browsers support it, since what date, and the percentage of global users with direct access to that feature without polyfills or transpiling.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you are hazy on the term polyfill, see “What Is a Polyfill” at</i> <span class="note_LinkURL_Italic"><a href="https://remysharp.com/2010/10/08/what-is-a-polyfill">https://remysharp.com/2010/10/08/what-is-a-polyfill</a></span> <i>by Remy Sharp (creator of the concept). A polyfill is a way to “replicate an API ... if the browser doesn’t have it natively.” The MDN website often provides polyfills for new features, which is helpful if you need to deal with older browsers that don’t provide them or need details on how something works.</i></p>&#13;
<p class="TX"><a href="chapter1.xhtml#fig1-6">Figure 1-6</a> shows information on the availability of arrow functions across browsers; hovering with the mouse provides more data, such as when the feature was first available.</p>&#13;
<figure class="IMG"><img class="img1" id="fig1-6" src="../images/Figure1-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 1-6: The Can I Use? website shows whether a given feature is available in browsers.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The Can I Use? site provides information only about browsers; it doesn’t include server-side tools like Node.js, but you’ll likely find a need for it at some time.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_21" aria-label="21"/>&#13;
<h3 class="H1" id="sec18"><span id="h1-6"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter, we looked at some of JavaScript’s new and important modern features, including spreading, destructuring, arrow functions, classes, and modules. We also considered some additional tools you might want to include for your development work, such as the VSC IDE, Fira Code font for neater screen displays, Prettier for source code formatting, JSDoc to generate documentation, ESLint to check for defects or bad practices, and Flow or TypeScript to add data type checking. Finally, in order to ensure that you’re not using unavailable functions, two online resources were presented: Kangax, and Can I Use?, both of which will help you avoid unimplemented or only partially implemented JavaScript features.</p>&#13;
<p class="TX">In the next chapter, we’ll go deeper into JavaScript and explore its functional programming aspects, providing a starting point for the examples in the rest of this book.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>