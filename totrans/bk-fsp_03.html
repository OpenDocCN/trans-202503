<html><head></head><body><section class="chapter" title="Chapter&#xA0;3.&#xA0;Fundamentals" epub:type="chapter" id="fundamentals"><div class="titlepage"><div><div><h2 class="title">Chapter 3. Fundamentals</h2></div></div></div><p>In the previous chapter, you learned how F# Interactive can enhance your workflow through rapid feedback and task automation. Now we’ll put that knowledge to work as we explore some basic language features. The concepts introduced in this chapter apply regardless of whether you’re programming primarily in an imperative, object-oriented, or functional style.</p><p>Most of this chapter focuses on how F# handles concepts central to the .NET Framework, like the core data types, enumerations, flow control, generics, and exception handling. You’ll also learn how F# can help you write more predictable code through controlling side effects, default immutability, type inference, and option types. Regardless of the subject, though, you should start seeing how F# distinguishes itself as a compelling alternative to C# and Visual Basic.</p><div class="sect1" title="Immutability and Side Effects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="immutability_and_side_effects">Immutability and Side Effects</h2></div></div></div><p><a id="iddle1520" class="indexterm"/><a id="iddle1922" class="indexterm"/>If you’re coming to F# from a primarily object-oriented background, the feature you may find the most challenging to adjust to is <span class="emphasis"><em>default immutability</em></span>. This is a radical departure from traditional .NET languages that place few restrictions on what can change and when. Programs written in languages without default immutability can be unpredictable because system state (program data) can change at almost any time. We refer to these changes as <span class="emphasis"><em>side effects</em></span>.</p><p>Some side effects, like writing to the console, are relatively benign, but what about when they affect shared resources? What if invoking a function changes a value that’s used elsewhere? Will a function always yield the same result regardless of when it’s called? Consider this C# example that references a public field for some multiplication:</p><a id="pro_id00033"/><pre class="programlisting">//C#
using System;
using System.Linq;

class Example
{
  public static int multiplier = 1;

  private static void ① Multiply(int value)
  {
    var result = value * multiplier;
    Console.WriteLine("{0} x {1} = {2}", value, ②multiplier++, result);
  }

  static void Main()
  {
    var range = Enumerable.Range(1, 100);
    foreach(var i in range)
    {
      Multiply(i);
    }
  }
}

// First 10 results
// 1 x 1 = 1
// 2 x 2 = 4
// 3 x 3 = 9
// 4 x 4 = 16
// 5 x 5 = 25
// 6 x 6 = 36
// 7 x 7 = 49
// 8 x 8 = 64
// 9 x 9 = 81
// 10 x 10 = 100</pre><p>In this example, the <code class="literal">Multiply</code> method ① has a side effect where the <code class="literal">multiplier</code> is incremented ②. As long as nothing changes anywhere else <a id="iddle1468" class="indexterm"/><a id="iddle1797" class="indexterm"/><a id="iddle2102" class="indexterm"/>in the program it’s somewhat predictable, but as soon as you change the order of calls to the <code class="literal">Multiply</code> method, introduce another call to the <code class="literal">Multiply</code> method, or change the <code class="literal">multiplier</code> field through some other mechanism, all future results are brought into question.</p><p>To further complicate the issue, consider what happens when multiple calls to <code class="literal">Multiply</code> are made in parallel, in this revision of the <code class="literal">Main</code> method:</p><a id="pro_id00034"/><pre class="programlisting">//C#
static void Main()
{
  var range = Enumerable.Range(1, 100);
  System.Threading.Tasks.Parallel.ForEach(range, i =&gt; Multiply(i));
}

// First 10 results
// 1 x 1 = 1
// 6 x 3 = 18
// 7 x 4 = 28
// 5 x 2 = 10
// 10 x 6 = 60
// 11 x 7 = 77
// 12 x 8 = 96
// 13 x 9 = 117
// 14 x 10 = 140
// 15 x 11 = 165</pre><p>There’s no guarantee as to which operation will execute first when running in parallel, so running this 10 times is likely to give you 10 different results. The unpredictability that comes from using mutable values is why <span class="emphasis"><em>global state</em></span> (values accessible from anywhere within your application) is generally considered harmful. Properly managing global state requires discipline that can be increasingly difficult to enforce as teams and projects grow.</p></div><div class="sect1" title="Functional Purity"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="functional_purity">Functional Purity</h2></div></div></div><p>Functional languages like F# are often described in terms of their mathematical purity. In <span class="emphasis"><em>purely</em></span> functional languages like Haskell, programs are composed entirely of deterministic <span class="emphasis"><em>expressions</em></span> that always return a value, and side effects are expressly forbidden except in certain specific circumstances. In contrast, F# is an <span class="emphasis"><em>impure</em></span> functional language. As such, it takes an important step toward improving predictability by making values immutable by default.</p><p>That’s not to say that F# can’t use variables in the traditional sense; it just means that in order to change a value, you must explicitly allow it and should restrict the value’s scope as much as possible. By keeping the scope narrow, you can code in a primarily functional style but switch to a more imperative or object-oriented style in isolated fragments as appropriate.</p><p>By managing side effects through default immutability, F# code is more naturally suited for execution in parallel and concurrent environments. In many cases, carefully controlling what can change reduces, if not eliminates, the need to lock shared resources and ensures that multiple <a id="iddle1206" class="indexterm"/><a id="iddle1563" class="indexterm"/><a id="iddle1593" class="indexterm"/><a id="iddle1597" class="indexterm"/><a id="iddle1827" class="indexterm"/>processes don’t attempt to make potentially conflicting or behavior-altering changes to the overall system state. This added safety is increasingly important as software development evolves to take advantage of the multiprocessor or multicore systems that are so ubiquitous in modern computing.</p></div><div class="sect1" title="Bindings"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="bindings">Bindings</h2></div></div></div><p><span class="emphasis"><em>Bindings</em></span> are F#’s primary way of identifying values or executable code. There are three types of bindings—<code class="literal">let</code>, <code class="literal">use</code>, and <code class="literal">do</code>—and each has a specific purpose.</p><div class="sect2" title="let Bindings"><div class="titlepage"><div><div><h3 class="title" id="let_bindings">let Bindings</h3></div></div></div><p><code class="literal">let</code> bindings simply associate names with values. They are the most common and versatile binding type. (I briefly introduced <code class="literal">let</code> bindings in <a class="xref" href="ch02.html" title="Chapter 2. F# Interactive">Chapter 2</a>.) You create a <code class="literal">let</code> binding with the <code class="literal">let</code> keyword. For example, to bind an integer value you would use something like this:</p><a id="pro_id00035"/><pre class="programlisting">let intValue = 1</pre><p>Similarly, to bind a string you could use:</p><a id="pro_id00036"/><pre class="programlisting">let strValue = "hello"</pre><p>But <code class="literal">let</code> bindings aren’t restricted to simple assignments. You can also use them to identify functions or other expressions:</p><a id="pro_id00037"/><pre class="programlisting">let add a b = a + b
let sum = add 1 2</pre><div class="sect3" title="Literals"><div class="titlepage"><div><div><h4 class="title" id="literals">Literals</h4></div></div></div><p>Although the <code class="literal">let</code> bindings we’ve seen so far are immutable, they can’t be considered constant values in the traditional .NET sense. Bindings are more like <code class="literal">readonly</code> variables in C# (<code class="literal">ReadOnly</code> in Visual Basic) than they are constants, in that their values are resolved at run time rather than replaced inline at compile time. You can define a true .NET constant value, called a <span class="emphasis"><em>literal</em></span> in F#, by decorating a binding with the <code class="literal">Literal</code> attribute. (F# follows the same convention as other .NET languages by making the <code class="literal">Attribute</code> suffix optional, so in this example both <code class="literal">Literal</code> and <code class="literal">LiteralAttribute</code> are acceptable.)</p><a id="pro_id00038"/><pre class="programlisting"><span class="strong"><strong>[&lt;Literal&gt;]</strong></span>
let FahrenheitBoilingPoint = 212</pre><p>This causes the compiler to treat the definition the same as a <code class="literal">const</code> in C# (<code class="literal">Const</code> in Visual Basic), meaning that the value will be compiled inline wherever it is used. As such, bindings decorated as <code class="literal">Literal</code> must be a full constructed value type, string, or null.</p></div><div class="sect3" title="Mutable Bindings"><div class="titlepage"><div><div><h4 class="title" id="mutable_bindings">Mutable Bindings</h4></div></div></div><p><a id="iddle1003" class="indexterm"/><a id="iddle1159" class="indexterm"/><a id="iddle1236" class="indexterm"/><a id="iddle1658" class="indexterm"/><a id="iddle1659" class="indexterm"/><a id="iddle1660" class="indexterm"/><a id="iddle1844" class="indexterm"/><a id="iddle1849" class="indexterm"/>If you try to change the value of a default binding with the assignment operator (<code class="literal">&lt;-</code>), the compiler will tell you that you can’t.</p><a id="pro_id00039"/><pre class="programlisting">let name = "Dave"

name &lt;- "Nadia"
// Error – immutable binding</pre><p>To make a binding mutable, simply include the <code class="literal">mutable</code> keyword in its definition. Once a mutable binding is defined, you can change its value at will.</p><a id="pro_id00040"/><pre class="programlisting">let mutable name = "Dave"

name &lt;- "Nadia"
// OK – mutable binding</pre><p>There is, of course, a caveat: Mutable bindings don’t play nicely with <span class="emphasis"><em>closures</em></span> (inline functions that can access bindings visible within the scope where they’re defined).</p><a id="pro_id00041"/><pre class="programlisting">// Horrible, invalid code
let addSomeNumbers nums =
  let ① mutable sum = 0
  let add = ② (fun num -&gt; sum &lt;- sum + num)
  Array.iter (fun num -&gt; add num) [| 1..10 |]</pre><p>In this example, the mutable binding, <code class="literal">sum</code>①, is captured by the <code class="literal">add</code> closure ②. If you try to compile this code, the compiler politely informs you of the error and instructs you to either eliminate the mutation or use another mutable construct, a <span class="emphasis"><em>reference cell</em></span>, instead.</p></div><div class="sect3" title="Reference Cells"><div class="titlepage"><div><div><h4 class="title" id="reference_cells">Reference Cells</h4></div></div></div><p>Reference cells are like mutable bindings in that their values can be changed at run time, but they work much differently. A reasonable way to think of reference cells is that they are to pointers what mutable bindings are to traditional variables. That said, reference cells aren’t really pointers either because they’re concrete types that encapsulate a mutable value rather than pointing to a particular resource or memory address.</p><p>You create a new reference cell like a typical <code class="literal">let</code> binding except that you include the <code class="literal">ref</code> operator before the bound value.</p><a id="pro_id00042"/><pre class="programlisting">let cell = <span class="strong"><strong>ref</strong></span> 0</pre><p>Accessing and changing a reference cell’s value requires a different syntax than a standard binding because we need to affect the encapsulated value rather than the reference cell itself.</p><a id="pro_id00043"/><pre class="programlisting">① cell := 100
  printf "%i" ②! cell</pre><p><a id="iddle1056" class="indexterm"/><a id="iddle1057" class="indexterm"/><a id="iddle1207" class="indexterm"/><a id="iddle1511" class="indexterm"/><a id="iddle1842" class="indexterm"/><a id="iddle1843" class="indexterm"/><a id="iddle2083" class="indexterm"/><a id="iddle2088" class="indexterm"/><a id="iddle2093" class="indexterm"/>As you can see at ①, the <code class="literal">:=</code> operator is used to change the reference cell’s value, and at ② the <code class="literal">!</code> operator is used to return the cell’s value.</p></div></div><div class="sect2" title="use Bindings"><div class="titlepage"><div><div><h3 class="title" id="use_bindings">use Bindings</h3></div></div></div><p>F# provides a binding mechanism for types that implement the <code class="literal">IDisposable</code> interface in a way that’s similar to C#’s <code class="literal">using</code> statement. In F#, when you want the compiler to insert a call to an <code class="literal">IDisposable</code> object’s <code class="literal">Dispose</code> method, you can create a <code class="literal">use</code> binding with the <code class="literal">use</code> keyword.</p><p>Like the <code class="literal">using</code> statement, which delimits the block where the <code class="literal">IDisposable</code> object is in scope, objects created through <code class="literal">use</code> bindings are disposed of when their enclosing block terminates; that is, if a <code class="literal">use</code> binding is created at the top level of a function, the object will be disposed of immediately after the function returns. Similarly, if a <code class="literal">use</code> binding is created within a nested construct, like a loop, the object will be disposed of when the iteration completes.</p><p>The following example shows this principle in action:</p><a id="pro_id00044"/><pre class="programlisting">open System

let ① createDisposable name =
  printfn "creating: %s" name
  ②{ new IDisposable with
   member x.Dispose() =
     printfn "disposing: %s" name
  }

let ③testDisposable() =
  use root = createDisposable "outer"
  for i in [1..2] do
    use nested = createDisposable (sprintf "inner %i" i)
    printfn "completing iteration %i" i
  printfn "leaving function"</pre><p>In this example, the <code class="literal">createDisposable</code> function ① writes a message to the console telling you that a disposable object is being created. It then returns an object that prints a message when it’s disposed of ②. The <code class="literal">testDisposable</code> function ③ repeatedly invokes the <code class="literal">createDisposable</code> function both inside and outside of a simple <code class="literal">for</code> loop and writes out messages telling you when each block is terminating.</p><p>Invoking the <code class="literal">testDisposable</code> function produces the following output that shows when each object is created and disposed of in relation to its containing block.</p><a id="pro_id00045"/><pre class="programlisting">creating: outer
creating: inner 1
completing iteration 1
disposing: inner 1
creating: inner 2
completing iteration 2
disposing: inner 2
leaving function
disposing: outer</pre><p><a id="iddle2084" class="indexterm"/><a id="iddle2091" class="indexterm"/>A simple and more practical example of a <code class="literal">use</code> binding is writing some text to a file, like this:</p><a id="pro_id00046"/><pre class="programlisting">  open System.IO
① let writeToFile filename buffer =
    ②use fs = ③new FileStream(filename, FileMode.CreateNew, FileAccess.Write)
    fs.Write(buffer, 0, buffer.Length)</pre><p>Notice at ① that a <code class="literal">let</code> binding is used for the <code class="literal">writeToFile</code> function (functions are data in F#) and that at ② a <code class="literal">use</code> binding is used in conjunction with the <code class="literal">new</code> keyword ③ to create the <code class="literal">FileStream</code>. (The <code class="literal">new</code> keyword is optional in F#, but by convention it’s included whenever an <code class="literal">IDisposable</code> object is created to indicate that the object should be disposed of. If you create a <code class="literal">use</code> binding without the <code class="literal">new</code> keyword, the compiler will issue a warning.)</p><p><code class="literal">use</code> bindings can’t be used directly within a module, primarily because modules are essentially static classes that never go out of scope. If you try to define a <code class="literal">use</code> binding directly within a module, you’ll receive a compiler warning along with a note that the binding will be treated as a <code class="literal">let</code> binding instead, like this:</p><a id="pro_id00047"/><pre class="programlisting">warning FS0524: 'use' bindings are not permitted in modules and are
treated as 'let' bindings</pre><div class="sect3" title="using Function"><div class="titlepage"><div><div><h4 class="title" id="using_function">using Function</h4></div></div></div><p>For more control over an <code class="literal">IDisposable</code>, turn to the <code class="literal">using</code> function. Although not a binding in its own right, <code class="literal">using</code> offers functionality that’s a bit more like C#’s <code class="literal">using</code> statement: Give it an <code class="literal">IDisposable</code> and a function that accepts the instance, and <code class="literal">using</code> automatically calls <code class="literal">Dispose</code> when it completes, as shown here:</p><a id="pro_id00048"/><pre class="programlisting">open System.Drawing
using (Image.FromFile(@"C:\Windows\Web\Screen\img100.jpg"))
      (fun img -&gt; printfn "%i x %i" img.Width img.Height)</pre><p>In some ways <code class="literal">using</code> is more powerful than its C# counterpart because, like every expression in F#, it returns a value. Consider this revision of the previous example:</p><a id="pro_id00049"/><pre class="programlisting">  open System.Drawing
① let w, h = using (Image.FromFile(@"C:\Windows\Web\Screen\img100.jpg"))
                   (fun img -&gt; ②(img.Width, img.Height))
③ printfn "Dimensions: %i x %i" w h</pre><p><a id="iddle2090" class="indexterm"/>Instead of writing the dimensions to the console within the function passed to the <code class="literal">using</code> function at ②, we return them as a <span class="emphasis"><em>tuple</em></span> (a simple type containing multiple data items) and bind each component value to meaningful names as shown at ①, before writing them to the console at ③. Even in this simple example you can begin to see how F#’s composable, expressive syntax leads to more understandable solutions by eliminating most of the <span class="emphasis"><em>plumbing code</em></span> (code you have to write to satisfy the compiler), allowing you to focus on the problem itself.</p></div><div class="sect3" title="Replicating the using Function in C#"><div class="titlepage"><div><div><h4 class="title" id="replicating_the_using_function_in_chash">Replicating the using Function in C#</h4></div></div></div><p>I like F#’s <code class="literal">using</code> function so much that I’ve created a couple of static helper methods for use in my C# projects.</p><a id="pro_id00050"/><pre class="programlisting">// C#
public static class IDisposableHelper
{
  public static TResult Using&lt;TResource, TResult&gt;
    (TResource resource, Func&lt;TResource, TResult&gt; action)
      where TResource : IDisposable
  {
    using(resource) return action(resource);
  }

  public static void Using&lt;TResource&gt;
    (TResource resource, Action&lt;TResource&gt; action)
      where TResource : IDisposable
  {
    using(resource) action(resource);
  }
}</pre><p>They’re not exactly pretty, but they get the job done.</p><p>Now here’s the C# version of the preceding examples using my helper functions.</p><a id="pro_id00051"/><pre class="programlisting">// C#
// using System.Drawing
IDisposableHelper.Using(
  Image.FromFile(@"C:\Windows\Web\Screen\img100.jpg"),
  img =&gt; Console.WriteLine("Dimensions: {0} x {1}", img.Width, img.Height)
);

var dims =
  IDisposableHelper.Using(
    Image.FromFile(@"C:\Windows\Web\Screen\img100.jpg"),
    img =&gt; Tuple.Create(img.Width, img.Height)
  );

Console.WriteLine("Dimensions: {0} x {1}", dims.Item1, dims.Item2);</pre><p><a id="iddle1054" class="indexterm"/><a id="iddle1205" class="indexterm"/><a id="iddle1324" class="indexterm"/><a id="iddle1510" class="indexterm"/><a id="iddle1819" class="indexterm"/><a id="iddle2038" class="indexterm"/>Although the code looks and behaves like the F# version, I find the F# version much cleaner, especially with its syntactic support for tuples.</p></div></div><div class="sect2" title="do Bindings"><div class="titlepage"><div><div><h3 class="title" id="do_bindings">do Bindings</h3></div></div></div><p>The final type of binding is the <code class="literal">do</code> binding, defined with the <code class="literal">do</code> keyword. Unlike the other binding types, <code class="literal">do</code> bindings don’t attach values to a name; they’re used whenever you need to execute some code outside the context of a function or value definition.</p><p><code class="literal">do</code> bindings are commonly used within looping constructs, sequence expressions, class constructors, and module initialization. We’ll look at each scenario in turn as we encounter them in later chapters.</p></div></div><div class="sect1" title="Identifier Naming"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="identifier_naming">Identifier Naming</h2></div></div></div><p>We’ve seen quite a few identifiers already, but we haven’t really looked at what makes something a valid identifier. Like any programming language, F# has naming rules.</p><p>Identifiers in F# are pretty typical of most programming languages. In general, F# identifiers must start with an underscore (<span class="strong"><strong><code class="literal">_</code></strong></span>), an uppercase letter, or a lowercase letter, followed by any combination thereof. Numbers are also valid characters in identifiers so long as they are not the first character. For example, the following are valid identifiers.</p><a id="pro_id00052"/><pre class="programlisting">let myIdentifier = ""
let _myIdentifier1 = ""</pre><p>The most interesting thing about identifiers in F# is that there’s an alternative <span class="emphasis"><em>quoted identifier</em></span> format with fewer restrictions. By enclosing an identifier in double backtick characters (<code class="literal">"</code>), you can use virtually any string as a valid F# identifier, like so.</p><a id="pro_id00053"/><pre class="programlisting">let "This is a valid F# identifier" = ""</pre><p>It’s usually best to use quoted identifiers sparingly, but they can be incredibly useful in certain situations. For example, they’re often used for naming unit tests. By using quoted identifiers for test names, you can focus on describing the test rather than arguing over naming conventions. If you’re using a test framework (like NUnit), the full quoted name in the test list clarifies what is being tested.</p></div><div class="sect1" title="Core Data Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="core_data_types">Core Data Types</h2></div></div></div><p>As a .NET language, F# supports the full range of Common Language Infrastructure (CLI) types. Each of the core primitives and even some more complex types, like <code class="literal">System.String</code>, are exposed as <span class="emphasis"><em>type abbreviations</em></span> <a id="iddle1020" class="indexterm"/><a id="iddle1021" class="indexterm"/><a id="iddle1216" class="indexterm"/><a id="iddle1217" class="indexterm"/><a id="iddle1218" class="indexterm"/><a id="iddle1219" class="indexterm"/><a id="iddle1222" class="indexterm"/><a id="iddle1278" class="indexterm"/><a id="iddle1279" class="indexterm"/><a id="iddle1280" class="indexterm"/><a id="iddle1281" class="indexterm"/><a id="iddle1283" class="indexterm"/><a id="iddle1284" class="indexterm"/><a id="iddle1285" class="indexterm"/><a id="iddle1286" class="indexterm"/><a id="iddle1287" class="indexterm"/><a id="iddle1289" class="indexterm"/><a id="iddle1292" class="indexterm"/><a id="iddle1293" class="indexterm"/><a id="iddle1294" class="indexterm"/><a id="iddle1295" class="indexterm"/><a id="iddle1299" class="indexterm"/><a id="iddle1325" class="indexterm"/><a id="iddle1437" class="indexterm"/><a id="iddle1530" class="indexterm"/><a id="iddle1531" class="indexterm"/><a id="iddle1533" class="indexterm"/><a id="iddle1534" class="indexterm"/><a id="iddle1535" class="indexterm"/><a id="iddle1677" class="indexterm"/><a id="iddle1683" class="indexterm"/><a id="iddle1860" class="indexterm"/><a id="iddle2048" class="indexterm"/><a id="iddle2059" class="indexterm"/><a id="iddle2060" class="indexterm"/><a id="iddle2061" class="indexterm"/><a id="iddle2062" class="indexterm"/>(convenient aliases for existing types). Many of these even have additional syntax support to enhance <span class="emphasis"><em>type inference</em></span> (the compiler’s ability to automatically determine data types) or otherwise simplify working with them.</p><div class="sect2" title="Boolean Values and Operators"><div class="titlepage"><div><div><h3 class="title" id="boolean_values_and_operators">Boolean Values and Operators</h3></div></div></div><p>The <code class="literal">bool</code> type abbreviation exposes the standard <code class="literal">System.Boolean</code> structure. Just as in other languages, <code class="literal">bool</code> can have one of two values: <code class="literal">true</code> and <code class="literal">false</code>.</p><p>The F# language includes a few operators for comparing Boolean values, as listed in <a class="xref" href="ch03.html#boolean_operators" title="Table 3-1. Boolean Operators">Table 3-1</a>.</p><div class="table"><a id="boolean_operators"/><div class="table-title">Table 3-1. Boolean Operators</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Operator</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Description</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">not</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Negation</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">||</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>OR</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">&amp;&amp;</code></p></td><td style="vertical-align: top; "><p>AND</p></td></tr></tbody></table></div></div><p>The OR and AND operators are short-circuited so they immediately return when the expression on the left satisfies the overall condition. In the case of the OR operator, if the expression on the left is true, there is no need to evaluate the expression on the right. Similarly, the AND operator will evaluate the expression on the right only when the expression on the left is true.</p></div><div class="sect2" title="Numeric Types"><div class="titlepage"><div><div><h3 class="title" id="numeric_types">Numeric Types</h3></div></div></div><p>F# offers the same selection of numeric types as in other .NET languages. <a class="xref" href="ch03.html#common_numeric_types" title="Table 3-2. Common Numeric Types">Table 3-2</a> lists commonly used numeric types along with their corresponding .NET type, value range, and suffix.</p><div class="table"><a id="common_numeric_types"/><div class="table-title">Table 3-2. Common Numeric Types</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/><col class="c3"/><col class="c4"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type Abbreviation</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>.NET Type</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Range</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Suffix</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">byte</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.Byte</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 to 255</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">uy</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">sbyte</code>, <code class="literal">int8</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.SByte</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>–128 to 127</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">y</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">int16</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.Int16</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>–32,768 to 32,767</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">s</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">uint16</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.UInt16</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 to 65,535</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">us</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">int</code>, <code class="literal">int32</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.Int32</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>–2<sup>31</sup> to 2<sup>31</sup>–1</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">uint</code>, <code class="literal">uint32</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.UInt32</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 to 2<sup>32</sup>–1</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">u</code>, <code class="literal">ul</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">int64</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.Int64</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>–2<sup>63</sup> to 2<sup>63</sup>–1</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">L</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">uint64</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.UInt64</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 to 2<sup>64</sup>–1</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">UL</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">decimal</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.Decimal</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>–2<sup>96</sup>–1 to 2<sup>96</sup>–1</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">M</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">float</code>, <code class="literal">double</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.Double</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>64-bit double precision number precise to approximately 15 digits</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><a id="iddle1006" class="indexterm"/><a id="iddle1013" class="indexterm"/><a id="iddle1014" class="indexterm"/><a id="iddle1015" class="indexterm"/><a id="iddle1016" class="indexterm"/><a id="iddle1017" class="indexterm"/><a id="iddle1018" class="indexterm"/><a id="iddle1024" class="indexterm"/><a id="iddle1025" class="indexterm"/><a id="iddle1026" class="indexterm"/><a id="iddle1029" class="indexterm"/><a id="iddle1031" class="indexterm"/><a id="iddle1039" class="indexterm"/><a id="iddle1040" class="indexterm"/><a id="iddle1041" class="indexterm"/><a id="iddle1042" class="indexterm"/><a id="iddle1043" class="indexterm"/><a id="iddle1045" class="indexterm"/><a id="iddle1049" class="indexterm"/><a id="iddle1052" class="indexterm"/><a id="iddle1101" class="indexterm"/><a id="iddle1204" class="indexterm"/><a id="iddle1209" class="indexterm"/><a id="iddle1210" class="indexterm"/><a id="iddle1211" class="indexterm"/><a id="iddle1212" class="indexterm"/><a id="iddle1213" class="indexterm"/><a id="iddle1214" class="indexterm"/><a id="iddle1277" class="indexterm"/><a id="iddle1282" class="indexterm"/><a id="iddle1288" class="indexterm"/><a id="iddle1290" class="indexterm"/><a id="iddle1296" class="indexterm"/><a id="iddle1322" class="indexterm"/><a id="iddle1343" class="indexterm"/><a id="iddle1374" class="indexterm"/><a id="iddle1436" class="indexterm"/><a id="iddle1494" class="indexterm"/><a id="iddle1495" class="indexterm"/><a id="iddle1524" class="indexterm"/><a id="iddle1559" class="indexterm"/><a id="iddle1560" class="indexterm"/><a id="iddle1655" class="indexterm"/><a id="iddle1657" class="indexterm"/><a id="iddle1672" class="indexterm"/><a id="iddle1923" class="indexterm"/><a id="iddle1966" class="indexterm"/><a id="iddle2063" class="indexterm"/><a id="iddle2064" class="indexterm"/><a id="iddle2065" class="indexterm"/></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">float32</code>, <code class="literal">single</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.Single</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32-bit single precision number precise to approximately 7 digits</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">F, f</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">bigint</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.Numerics.BigInteger</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No defined upper or lower bounds</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">I</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">nativeint</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">System.IntPtr</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32-bit platform-specific integer</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">n</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">unativeint</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">System.UIntPtr</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>32-bit unsigned platform-specific integer</p></td><td style="vertical-align: top; "><p><code class="literal">un</code></p></td></tr></tbody></table></div></div><p>In general, the suffixes are used more frequently in F# than in other .NET languages because they provide the compiler with all of the information it needs to correctly infer the type.</p><div class="sect3" title="Numeric Operators"><div class="titlepage"><div><div><h4 class="title" id="numeric_operators">Numeric Operators</h4></div></div></div><p>As you might expect, F# includes a number of built-in operators for working with the numeric types. <a class="xref" href="ch03.html#numeric_operators-id00003" title="Table 3-3. Numeric Operators">Table 3-3</a> lists commonly used arithmetic, comparison, and bitwise operations.</p><div class="table"><a id="numeric_operators-id00003"/><div class="table-title">Table 3-3. Numeric Operators</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Operator</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Description</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">+</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Unary positive (does not change the sign of the expression)</p>
<p>Unchecked addition</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Unary negation (changes the sign of the expression)</p>
<p>Unchecked subtraction</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">*</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Unchecked multiplication</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">/</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Unchecked division</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Unchecked modulus</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">**</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Unchecked exponent (valid only for floating-point types)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">=</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Equality</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&gt;</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Greater than</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Less than</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&gt;=</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Greater than or equal</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;=</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Less than or equal</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;&gt;</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Not equal</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&amp;&amp;&amp;</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Bitwise AND</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">|||</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Bitwise OR</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">^^^</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Bitwise exclusive OR</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">~~~</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Bitwise negation</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">&lt;&lt;&lt;</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Bitwise left shift</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">&gt;&gt;&gt;</code></p></td><td style="vertical-align: top; "><p>Bitwise right shift</p></td></tr></tbody></table></div></div><p><a id="iddle1030" class="indexterm"/><a id="iddle1271" class="indexterm"/><a id="iddle1344" class="indexterm"/>It’s important to note that although most of the operators in <a class="xref" href="ch03.html#numeric_operators-id00003" title="Table 3-3. Numeric Operators">Table 3-3</a> work with any numeric type, the bitwise operators work only against the integral types. Also, because of the way floating-point numbers are represented in memory you should avoid using the equality operators with them directly or you may see incorrect results, as shown here:</p><a id="pro_id00054"/><pre class="programlisting">&gt; <span class="strong"><strong>let x = 0.33333</strong></span>
<span class="strong"><strong>let y = 1.0 / 3.0</strong></span>
<span class="strong"><strong>x = y;;</strong></span>

val x : float = 0.33333
val y : float = 0.3333333333
val it : bool = false</pre><p>Instead of using the equality operator (<code class="literal">=</code>), you can calculate the difference between the two floating-point values and verify that the difference is within a threshold. I generally prefer to define this type of operation as a function for reusability.</p><a id="pro_id00055"/><pre class="programlisting">&gt; <span class="strong"><strong>open System</strong></span>
<span class="strong"><strong>let approximatelyEqual (x : float) (y : float) (threshold : float) =</strong></span>
  <span class="strong"><strong>Math.Abs(x - y) &lt;= Math.Abs(threshold)</strong></span>
<span class="strong"><strong>approximatelyEqual 0.33333 (1.0 / 3.0) 0.001;;</strong></span>

val approximatelyEqual : x:float -&gt; y:float -&gt; threshold:float -&gt; bool
val it : bool = true</pre></div><div class="sect3" title="Numeric Conversion Functions"><div class="titlepage"><div><div><h4 class="title" id="numeric_conversion_functions">Numeric Conversion Functions</h4></div></div></div><p>When you’re working with numeric data types in F#, there are no implicit type conversions. This is largely because type conversions are considered side effects, and computation problems arising from implicit type conversions are often difficult to locate.</p><p>To work with different numeric types in the same expression, you’ll need to explicitly convert them using the appropriate built-in conversion functions. Each conversion function has the same name as the target type abbreviation, which makes them really easy to remember. For instance, to convert an integer value to a float you’d call the <code class="literal">float</code> function, as shown in this example.</p><a id="pro_id00056"/><pre class="programlisting">let marchHighTemps = [ 33.0; 30.0; 33.0; 38.0; 36.0; 31.0; 35.0;
                       42.0; 53.0; 65.0; 59.0; 42.0; 31.0; 41.0;
                       49.0; 45.0; 37.0; 42.0; 40.0; 32.0; 33.0;
                       42.0; 48.0; 36.0; 34.0; 38.0; 41.0; 46.0;
                       54.0; 57.0; 59.0 ]
let totalMarchHighTemps = List.sum marchHighTemps
let average = totalMarchHighTemps / float marchHighTemps.Length</pre></div></div><div class="sect2" title="Characters"><div class="titlepage"><div><div><h3 class="title" id="characters">Characters</h3></div></div></div><p><a id="iddle1229" class="indexterm"/><a id="iddle1291" class="indexterm"/><a id="iddle1345" class="indexterm"/><a id="iddle1956" class="indexterm"/><a id="iddle1957" class="indexterm"/><a id="iddle1960" class="indexterm"/><a id="iddle2066" class="indexterm"/>As a .NET language, F# carries on the tradition of using 16-bit Unicode for character data. Individual characters are represented by <code class="literal">System.Char</code> and exposed to F# via the <code class="literal">char</code> type abbreviation. You can bind most individual Unicode characters to an identifier by wrapping them in single quotes, while the remaining characters are represented with escaped character codes, as shown here.</p><a id="pro_id00057"/><pre class="programlisting">&gt; <span class="strong"><strong>let letterA = 'a'</strong></span>
<span class="strong"><strong>let copyrightSign = '\u00A9';;</strong></span>

val letterA : char = 'a'
val copyrightSign : char = '©'</pre><p>In addition to the Unicode character escape code, F# has a few other escape sequences for some common characters, as listed in <a class="xref" href="ch03.html#common_escape_sequences" title="Table 3-4. Common Escape Sequences">Table 3-4</a>.</p><div class="table"><a id="common_escape_sequences"/><div class="table-title">Table 3-4. Common Escape Sequences</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Character</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Sequence</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Backspace</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">\b</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Newline</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">\n</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Carriage return</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">\r</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Tab</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">\t</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Backslash</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">\\</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Quotation mark</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">\"</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>Apostrophe</p></td><td style="vertical-align: top; "><p><code class="literal">\'</code></p></td></tr></tbody></table></div></div></div><div class="sect2" title="Strings"><div class="titlepage"><div><div><h3 class="title" id="strings">Strings</h3></div></div></div><p>Strings are sequential collections of <code class="literal">char</code> and are represented by the <code class="literal">string</code> type abbreviation. There are three types of strings in F#: string literals, verbatim strings, and triple-quoted strings.</p><div class="sect3" title="String Literals"><div class="titlepage"><div><div><h4 class="title" id="string_literals">String Literals</h4></div></div></div><p>The most common string definition is the <span class="emphasis"><em>string literal</em></span>, which is enclosed in quotation marks as follows.</p><a id="pro_id00058"/><pre class="programlisting">&gt; <span class="strong"><strong>let myString = "hello world!";;</strong></span>
val myString : string = "hello world!"</pre><p>String literals can contain the same characters and escape sequences described in <a class="xref" href="ch03.html#common_escape_sequences" title="Table 3-4. Common Escape Sequences">Table 3-4</a>. Newlines within the string literal are retained unless they’re preceded by a backslash (<code class="literal">\</code>) character. If a backslash is present, the newline character will be removed.</p></div><div class="sect3" title="Verbatim Strings"><div class="titlepage"><div><div><h4 class="title" id="verbatim_strings">Verbatim Strings</h4></div></div></div><p><a id="iddle1009" class="indexterm"/><a id="iddle1051" class="indexterm"/><a id="iddle1067" class="indexterm"/><a id="iddle1255" class="indexterm"/><a id="iddle1950" class="indexterm"/><a id="iddle1951" class="indexterm"/><a id="iddle1952" class="indexterm"/><a id="iddle1954" class="indexterm"/><a id="iddle1958" class="indexterm"/><a id="iddle1961" class="indexterm"/><a id="iddle1962" class="indexterm"/><a id="iddle2025" class="indexterm"/><a id="iddle2105" class="indexterm"/><a id="iddle2106" class="indexterm"/><span class="emphasis"><em>Verbatim strings</em></span> are much like string literals except that they are preceded by the <code class="literal">@</code> character and ignore escape sequences. You can embed quotation marks within the string, but they must be written as <code class="literal">""</code>, like this:</p><a id="pro_id00059"/><pre class="programlisting">&gt; <span class="strong"><strong>let verbatimString = @"Hello, my name is ""Dave""";;</strong></span>
val verbatimString : string = "Hello, my name is "Dave""</pre><p>Not parsing escape sequences makes verbatim strings a good choice for representing system paths containing backslashes, provided that you don’t have them stored in a configuration setting somewhere. (You’re not hard-coding your paths, right?)</p></div><div class="sect3" title="Triple-Quoted Strings"><div class="titlepage"><div><div><h4 class="title" id="triple-quoted_strings">Triple-Quoted Strings</h4></div></div></div><p>As the name implies, <span class="emphasis"><em>triple-quoted strings</em></span> are enclosed in triple quotation marks like <code class="literal">""Klaatu barada nikto!""</code>. Triple-quoted strings are like verbatim strings in that they ignore all escape sequences, but they also ignore double quotes. This type of string is most useful when you’re working with formatted character data that naturally contains embedded quotes, like XML documents. For example:</p><a id="pro_id00060"/><pre class="programlisting">&gt; <span class="strong"><strong>let tripleQuoted = """&lt;person name="Dave" age="33" /&gt;""";;</strong></span>
val tripleQuoted : string = "&lt;person name="Dave" age="33" /&gt;"</pre></div><div class="sect3" title="String Concatenation"><div class="titlepage"><div><div><h4 class="title" id="string_concatenation">String Concatenation</h4></div></div></div><p>When you want to combine multiple strings, you can concatenate them in a variety of ways. First, there’s the traditional <code class="literal">Concat</code> method on the <code class="literal">System.String</code> class. This method is exactly what you’d expect from other .NET languages.</p><a id="pro_id00061"/><pre class="programlisting">&gt; <span class="strong"><strong>System.String.Concat("abc", "123");;</strong></span>
val it : string = "abc123"</pre><div class="warning" title="Warning" epub:type="warning"><h3 class="title"><a id="ch03note01"/>Warning</h3><p><span class="emphasis"><em>Be careful when using String.Concat to not accidentally use the concat extension method defined in FSharp.Core. The concat extension method has more in common with the String.Join method than it does with String.Concat.</em></span></p></div><p>You can also use the operators <code class="literal">+</code> and <code class="literal">^</code> to make the code a bit cleaner. For example:</p><a id="pro_id00062"/><pre class="programlisting">&gt; <span class="strong"><strong>"abc" + "123";;</strong></span>
val it : string = "abc123"</pre><p>The <code class="literal">+</code> operator is preferred, particularly in cross-language scenarios, because it’s defined on <code class="literal">System.String</code>. The <code class="literal">^</code> operator is provided for ML compatibility, and the compiler will issue a warning if you use it in your code.</p></div></div></div><div class="sect1" title="Type Inference"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="type_inference">Type Inference</h2></div></div></div><p><a id="iddle1698" class="indexterm"/><a id="iddle2049" class="indexterm"/><a id="iddle2103" class="indexterm"/>I’ve been very careful not to explicitly state any data types in examples so far in order to illustrate one of F#’s most interesting features: type inference. <span class="emphasis"><em>Type inference</em></span> means that the compiler can often deduce data types based on individual values and usage. In fact, F#’s type inference capabilities are so powerful that they often give newcomers to F# the impression that the language is dynamically typed when it’s actually statically typed.</p><p>F# certainly isn’t the first .NET language to include type inference. C# supports type inference through the <code class="literal">var</code> keyword, as does Visual Basic when <code class="literal">Option Infer</code> is enabled. However, while the type inference in C# and Visual Basic helps avoid some explicit type declarations, it works only in very limited situations. Furthermore, while both C# and Visual Basic can infer data types for individual values, they still generally require you to explicitly specify types in multiple places. In contrast, F#’s top-down evaluation takes type inference to levels never before seen in .NET.</p><p>F#’s type inference capabilities permeate the entire language. You’ve seen examples of type inference previously, ranging from simple values to function parameters and return types, but this feature even enters into F#’s object-oriented features.</p><p>At the risk of jumping too far ahead, let’s examine how much F#’s type inference helps with a simple class definition, beginning with an example in C#.</p><a id="pro_id00063"/><pre class="programlisting">// C#
using System;

public class Person
{
  public Person(Guid id, string name, int age)
  {
    Id = id;
    Name = name;
    Age = age;
  }

  public Guid Id { get; private set; }
  public string Name { get; private set; }
  public int Age { get; private set; }
}</pre><p>Even in this simple example, C# requires no fewer than six explicit type declarations. If you wanted to take it a step further and define <code class="literal">readonly</code> backing variables rather than using auto-implemented properties with private setters, you’d take the number of type declarations up to nine!</p><p>Now let’s look at an equivalent class in F#.</p><a id="pro_id00064"/><pre class="programlisting">type Person (id : System.Guid, name : string, age : int) =
  member x.Id = id
  member x.Name = name
  member x.Age = age</pre><p><a id="iddle2041" class="indexterm"/>Yes, those two definitions are indeed the same class! Not convinced? <a class="xref" href="ch03.html#comparison_of_compiled_fhash_and_chash_c" title="Figure 3-1. Comparison of compiled F# and C# classes">Figure 3-1</a> shows how each class looks in the compiled assemblies according to the decompiler, ILSpy.</p><div class="figure"><a id="comparison_of_compiled_fhash_and_chash_c"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00013"/><img src="httpatomoreillycomsourcenostarchimages1981218.png.jpg" alt="Comparison of compiled F# and C# classes"/></div></div><div class="figure-title">Figure 3-1. Comparison of compiled F# and C# classes</div></div><div class="note" title="Note"><h3 class="title"><a id="ch03note02"/>Note</h3><p><span class="emphasis"><em>There is a subtle difference between the two classes that isn’t pictured. The C# class sets the property values via the private setters, whereas the F# class foregoes the private setters and relies exclusively on the backing variables.</em></span></p></div><p>As you can see in the decompiled code, the classes are virtually identical. Ignoring the other syntactic differences between the two languages (object-oriented programming is covered in <a class="xref" href="ch04.html" title="Chapter 4. Staying Objective">Chapter 4</a>), you can see F#’s type inference in action throughout this example. In F# we needed to specify the data types for each member only once in the constructor, and in many cases the compiler can infer it there, too. Even each property’s data type is automatically inferred from that one definition!</p><p>In cases where the compiler can’t infer the type, you can add a <span class="emphasis"><em>type annotation</em></span> to tell it what the type should be. You can use type annotations anywhere you introduce a new value. For example, you can include a type annotation in a <code class="literal">let</code> binding like this:</p><a id="pro_id00065"/><pre class="programlisting">let <span class="strong"><strong>i : int</strong></span> = 42;;</pre><p>You can also annotate each part of a function definition. A function that adds two integers might be annotated like this:</p><a id="pro_id00066"/><pre class="programlisting">let add <span class="strong"><strong>(a : int) (b : int) : int</strong></span> = a + b</pre><p>In this example, no type inference is performed because the definitions explicitly specify the type.</p></div><div class="sect1" title="Nullability"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="nullability">Nullability</h2></div></div></div><p><a id="iddle1047" class="indexterm"/><a id="iddle1118" class="indexterm"/><a id="iddle1300" class="indexterm"/><a id="iddle1311" class="indexterm"/><a id="iddle1679" class="indexterm"/><a id="iddle1681" class="indexterm"/><a id="iddle1699" class="indexterm"/><a id="iddle1700" class="indexterm"/><a id="iddle1704" class="indexterm"/><a id="iddle1705" class="indexterm"/><a id="iddle1707" class="indexterm"/><a id="iddle1709" class="indexterm"/><a id="iddle1711" class="indexterm"/>If project structure differences and immutability aren’t enough to make your head spin, F# has yet another trick for you: <code class="literal">null</code> is almost never used! You can’t create null values directly with F# without resorting to a library function, and types defined in F# allow <code class="literal">null</code> as a valid value only if they’re decorated with the <code class="literal">AllowNullLiteral</code> attribute. If not for the need to interoperate with .NET assemblies written in languages that lack the same restrictions, <code class="literal">null</code> probably wouldn’t be included in the language at all.</p><p>By placing such tight restrictions around nulls, the F# language designers have greatly reduced the possibility of encountering stray null references, particularly when you’re working entirely within F#. This means that you get to spend less time checking to see if every reference type instance is <code class="literal">null</code> before doing anything with it.</p><p>That said, <code class="literal">null</code> is still a valid keyword in F#, and you will find that you do need to use it from time to time, particularly as you work with assemblies written in other .NET languages. Usually, you’ll pass <code class="literal">null</code> as a parameter to a library function or verify that the return value of a library function isn’t <code class="literal">null</code>.</p><div class="sect2" title="Options"><div class="titlepage"><div><div><h3 class="title" id="options">Options</h3></div></div></div><p>Although F# strives to eradicate nulls from your software, there are times when something legitimately doesn’t have a value. Without nulls this could seem like a problem, but the language has you covered.</p><p>Rather than simply allowing <code class="literal">null</code> to be valid for every reference type, F# takes an opt-in approach via the <code class="literal">Option&lt;'T&gt;</code> type. This type is a generic <span class="emphasis"><em>discriminated union</em></span> with two values: <code class="literal">Some('T)</code> and <code class="literal">None</code>. In some ways options are like nullable types, but their explicit nature makes it obvious that a meaningful value might not be present. (We’ll cover discriminated unions in <a class="xref" href="ch05.html" title="Chapter 5. Let’s Get Functional">Chapter 5</a>. Generics are covered later in this chapter.)</p><p>Options are so important in F# that they have syntactic support in type annotations through the <code class="literal">option</code> keyword, as shown here:</p><a id="pro_id00067"/><pre class="programlisting">&gt; <span class="strong"><strong>let middleName : string option = None;;</strong></span>
val middleName : string option = None

&gt; <span class="strong"><strong>let middleName = Some("William");;</strong></span>
val middleName : string option = Some "William"</pre><p>Options are also how the compiler represents optional parameters for constructors or methods. You make a parameter optional by prefixing it with a question mark (<code class="literal">?</code>). Optional parameters are allowed only at the end of the parameter list, as shown here:</p><a id="pro_id00068"/><pre class="programlisting">type Container() =
  member x.Fill ①?stopAtPercent =
    printfn "%s" &lt;| match (②defaultArg stopAtPercent 0.5) with
                    | 1.0 -&gt; "Filled it up"
                    | stopAt -&gt; sprintf "Filled to %s" (stopAt.ToString("P2"))
let bottle = Container()</pre><p><a id="iddle1034" class="indexterm"/><a id="iddle1046" class="indexterm"/><a id="iddle1070" class="indexterm"/><a id="iddle1297" class="indexterm"/><a id="iddle1449" class="indexterm"/><a id="iddle1519" class="indexterm"/><a id="iddle2069" class="indexterm"/><a id="iddle2071" class="indexterm"/><a id="iddle2111" class="indexterm"/>In the preceding example, ① is the optional <code class="literal">stopAtPercent</code> parameter. The function needs to account for the cases when <code class="literal">stopAtPercent</code> is <code class="literal">None</code>. One common way to provide a default value in these cases is with the <code class="literal">defaultArg</code> function ②. This function is kind of like C#’s null coalescing operator (<code class="literal">??</code>) except that it works with options instead of nulls. The <code class="literal">defaultArg</code> function accepts an option as its first argument and returns its value when it is <code class="literal">Some&lt;_&gt;</code>; otherwise, it returns the second argument.</p></div><div class="sect2" title="Unit Type"><div class="titlepage"><div><div><h3 class="title" id="unit_type">Unit Type</h3></div></div></div><p>Expressions must always evaluate to a value, but sometimes they’re evaluated solely for a side effect, such as writing to a log or updating a database. In these cases, turn to the <code class="literal">unit</code> type. The <code class="literal">unit</code> type, represented by <code class="literal">()</code> (an empty pair of parentheses), is a concrete type with a single value that signifies that no particular value is present, so the result of any expression that returns <code class="literal">unit</code> can safely be ignored. (In some ways, <code class="literal">unit</code> is like a manifestation of the <code class="literal">void</code> return type in C# in that it should be returned whenever a function doesn’t really return anything, but it’s also used syntactically to signify parameterless functions.)</p><p>Whenever an expression returns a value other than <code class="literal">unit</code>, F# expects you to do something with it. The compiler doesn’t care whether you bind the value to an identifier or pass it as an argument to a function; it just wants you to use it. When you don’t do something with the return value, the compiler warns that the expression should have type <code class="literal">unit</code> because it may actually indicate a program error (the warning is displayed only in compiled code and doesn’t appear in FSI). For example:</p><a id="pro_id00069"/><pre class="programlisting"><span class="strong"><strong>let add a b = a + b</strong></span>
// Compiler warning
add 2 3</pre><p>If you don’t want to do anything with the return value, you can pass the result to the <code class="literal">ignore</code> function, which accepts a single, unconstrained generic argument and returns <code class="literal">unit</code>.</p><a id="pro_id00070"/><pre class="programlisting"><span class="strong"><strong>let add a b = a + b</strong></span>
// No warning
add 2 3 |&gt; ignore</pre><p>In this example, the <code class="literal">add</code> function’s result is sent to the <code class="literal">ignore</code> function via the <span class="emphasis"><em>forward pipelining operator</em></span> (<code class="literal">|&gt;</code>). This operator evaluates the expression on the left and sends the result as the last argument to the expression on the right. We’ll look at the forward pipelining operator in detail in <a class="xref" href="ch05.html#pipelining" title="Pipelining">Pipelining</a>.</p></div></div><div class="sect1" title="Enumerations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="enumerations">Enumerations</h2></div></div></div><p><a id="iddle1337" class="indexterm"/><a id="iddle1338" class="indexterm"/><a id="iddle1339" class="indexterm"/><a id="iddle1340" class="indexterm"/><a id="iddle1434" class="indexterm"/><span class="emphasis"><em>Enumerations</em></span> help you write more readable code by letting you assign descriptive labels to integral values. F# enumerations compile to the same CLI type as in other .NET languages, so all of the capabilities and restrictions that apply in C# or Visual Basic apply in F# too.</p><p>The basic syntax of an enumeration in F# is:</p><a id="pro_id00071"/><pre class="programlisting">type enum-name =
   | value1 = integer-literal1
   | value2 = integer-literal2
   -- <span class="emphasis"><em>snip</em></span> --</pre><p>However, unlike in C# and Visual Basic, F# doesn’t automatically generate a value for each label in an enumeration, so you need to explicitly provide one. For example, if your program represents each day of the week as an integer, you might define a <code class="literal">DayOfWeek</code> enumeration like this:</p><a id="pro_id00072"/><pre class="programlisting">type DayOfWeek =
| Sunday = 0
| Monday = 1
| Tuesday = 2
| Wednesday = 3
| Thursday = 4
| Friday = 5
| Saturday = 6</pre><p>Should you want to base your enumerations on an integral type other than <code class="literal">int</code>, simply include the appropriate suffix for the data type in the label definition. For example, you could easily change the preceding <code class="literal">DayOfWeek</code> sample to use <code class="literal">sbyte</code> as its underlying type by changing the suffix on each value:</p><a id="pro_id00073"/><pre class="programlisting">type DayOfWeekByte =
| Sunday = <span class="strong"><strong>0y</strong></span>
| Monday = <span class="strong"><strong>1y</strong></span>
| Tuesday = <span class="strong"><strong>2y</strong></span>
-- <span class="emphasis"><em>snip</em></span> --</pre><div class="sect2" title="Flags Enumerations"><div class="titlepage"><div><div><h3 class="title" id="flags_enumerations">Flags Enumerations</h3></div></div></div><p>The enumerations we’ve seen so far represent only single values. However, it’s common for each label to represent a value by position in a bit mask so that multiple items can be combined.</p><p><a id="iddle1500" class="indexterm"/>For example, consider the case of the <code class="literal">RegexOptions</code> enumeration from the <code class="literal">System.Text.RegularExpressions</code> namespace. This enumeration allows you to control how the regular expression engine processes the pattern by combining multiple values with the logical <code class="literal">or</code> operator, like this:</p><a id="pro_id00074"/><pre class="programlisting">open System.Text.RegularExpressions
let re = new Regex("^(Didactic Code)$",
                   RegexOptions.Compiled ||| RegexOptions.IgnoreCase)</pre><p>To achieve this same result in your own enumerations, include the <code class="literal">Flags</code> attribute and use values that are powers of two.</p><a id="pro_id00075"/><pre class="programlisting">open System

<span class="strong"><strong>[&lt;Flags&gt;]</strong></span>
type DayOfWeek =
| None = 0
| Sunday = 1
| Monday = 2
| Tuesday = 4
| Wednesday = 8
| Thursday = 16
| Friday = 32
| Saturday = 64</pre><div class="note" title="Note"><h3 class="title"><a id="ch03note03"/>Note</h3><p><span class="emphasis"><em>The Flags attribute isn’t required, but it’s good practice to include it to show other developers how the enumeration should be used.</em></span></p></div><p>You can now represent the days in a weekend by combining the Saturday and Sunday values as we did previously.</p><a id="pro_id00076"/><pre class="programlisting">let weekend = DayOfWeek.Saturday ||| DayOfWeek.Sunday</pre><p>If you know that several values will be commonly combined, consider including those combinations in your enumeration definition. F# doesn’t allow referencing the other values in the definition by name, but you can still provide the appropriate corresponding integral value. In the case of <code class="literal">DayOfWeek</code> you could provide <code class="literal">Weekdays</code> and <code class="literal">WeekendDays</code> with the values <code class="literal">62</code> and <code class="literal">65</code>, respectively.</p><a id="pro_id00077"/><pre class="programlisting">open System

[&lt;Flags&gt;]
type DayOfWeek =
-- <span class="emphasis"><em>snip</em></span> --
| <span class="strong"><strong>Weekdays = 62</strong></span>
| <span class="strong"><strong>WeekendDays = 65</strong></span></pre><p>It’s easy to determine whether a particular enumeration value has a particular flag set with the <code class="literal">HasFlag</code> method of <code class="literal">System.Enum</code>.</p><a id="pro_id00078"/><pre class="programlisting">&gt; <span class="strong"><strong>DayOfWeek.Weekdays.HasFlag DayOfWeek.Monday;;</strong></span>
val it : bool = true
&gt; <span class="strong"><strong>DayOfWeek.Weekdays.HasFlag DayOfWeek.Thursday;;</strong></span>
val it : bool = true
&gt; <span class="strong"><strong>DayOfWeek.Weekdays.HasFlag DayOfWeek.Sunday;;</strong></span>
val it : bool = false</pre></div><div class="sect2" title="Reconstructing Enumeration Values"><div class="titlepage"><div><div><h3 class="title" id="reconstructing_enumeration_values">Reconstructing Enumeration Values</h3></div></div></div><p><a id="iddle1341" class="indexterm"/><a id="iddle1342" class="indexterm"/><a id="iddle1438" class="indexterm"/><a id="iddle1599" class="indexterm"/>Using named labels for integral values is a great way to avoid <span class="emphasis"><em>magic numbers</em></span> (numbers without any apparent meaning) in your code, but what if you save off the underlying value (say, to a database) and later want to reconstruct the original enumeration value from it? The built-in <code class="literal">enum</code> function allows you to do just that for integer (<code class="literal">int32</code>) values.</p><a id="pro_id00079"/><pre class="programlisting">&gt; <span class="strong"><strong>enum&lt;DayOfWeek&gt; 16;;</strong></span>
val it : DayOfWeek = Thursday</pre><p>When the enumeration’s underlying type is something other than <code class="literal">int32</code>, use the <code class="literal">EnumOfValue</code> function from the <code class="literal">Microsoft.FSharp.Core.LanguagePrimitives</code> module namespace instead.</p><a id="pro_id00080"/><pre class="programlisting">&gt; <span class="strong"><strong>open Microsoft.FSharp.Core.LanguagePrimitives</strong></span>
<span class="strong"><strong>EnumOfValue&lt;sbyte, DayOfWeek&gt; 16y;;</strong></span>
val it : DayOfWeek = Thursday</pre><div class="note" title="Note"><h3 class="title"><a id="ch03note04"/>Note</h3><p><span class="emphasis"><em>Enumeration types aren’t constrained to the values identified by labels, so when using these functions be sure to create only enumeration values that you’ve accounted for in your code.</em></span></p></div></div></div><div class="sect1" title="Flow Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="flow_control">Flow Control</h2></div></div></div><p>Despite its emphasis on functional programming, F# fully supports several imperative constructs for looping and branching. These are particularly useful in combination with other constructs like <span class="emphasis"><em>sequence expressions</em></span> (particularly the looping constructs), but they’re certainly useful in other contexts as well.</p><div class="sect2" title="Looping"><div class="titlepage"><div><div><h3 class="title" id="looping">Looping</h3></div></div></div><p><span class="emphasis"><em>Recursion</em></span> is the preferred looping mechanism in functional programming, but F# also includes a few approaches typically found in imperative languages. These looping structures are similar to those of other languages.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note05"/>Note</h3><p><span class="emphasis"><em>F# doesn’t provide mechanisms (like break or continue) for premature termination, so take extra care when using loops.</em></span></p></div><div class="sect3" title="while Loops"><div class="titlepage"><div><div><h4 class="title" id="while_loops">while Loops</h4></div></div></div><p><a id="iddle1327" class="indexterm"/><a id="iddle1439" class="indexterm"/><a id="iddle1441" class="indexterm"/><a id="iddle1442" class="indexterm"/><a id="iddle1443" class="indexterm"/><a id="iddle1515" class="indexterm"/><a id="iddle1600" class="indexterm"/><a id="iddle1601" class="indexterm"/><a id="iddle1602" class="indexterm"/><a id="iddle1888" class="indexterm"/><a id="iddle2023" class="indexterm"/><a id="iddle2113" class="indexterm"/>The simplest iterative structure is the <code class="literal">while...do</code> loop. As you might expect, this construct evaluates a Boolean expression and iterates as long as that condition is true. <code class="literal">while</code> loops are useful when you need to iterate an unknown number of times, but because they inherently rely on a state change, they can’t be used in pure functional programming. The body of the loop can be any expression that returns <code class="literal">unit</code>.</p><p>One scenario in which <code class="literal">while</code> loops are helpful is responding to user input. In the following example, the <code class="literal">echoUserInput</code> function uses a <code class="literal">while</code> loop to echo whatever the user enters at the console until it encounters the word <code class="literal">quit</code>.</p><a id="pro_id00081"/><pre class="programlisting">let echoUserInput (getInput : unit -&gt; string) =
  let mutable input = getInput()
  while not (input.ToUpper().Equals("QUIT")) do
    printfn "You entered: %s" input
    input &lt;- getInput()

echoUserInput (fun () -&gt; printfn "Type something and press enter"
                         System.Console.ReadLine())</pre></div><div class="sect3" title="for Loops"><div class="titlepage"><div><div><h4 class="title" id="for_loops">for Loops</h4></div></div></div><p>When you know how many iterations you need to perform, you can turn to one of the <code class="literal">for</code> loop variations: simple or enumerable. <span class="emphasis"><em>Simple</em></span> <code class="literal">for</code> loops are pretty restrictive in that they can iterate only over a range of integers and always return <code class="literal">unit</code>. Attempting to return something other than <code class="literal">unit</code> will result in a compilation error.</p><p>Simple <code class="literal">for</code> loops are useful when you know how many times you need to iterate. Here, the numbers 0 through 100 are printed in the body of a simple <code class="literal">for</code> loop:</p><a id="pro_id00082"/><pre class="programlisting">for i = 0 to 100 do printfn "%i" i</pre><p>By replacing the <code class="literal">to</code> keyword with the <code class="literal">downto</code> keyword, you can make a simple <code class="literal">for</code> loop count down instead.</p><a id="pro_id00083"/><pre class="programlisting">for i = 100 <span class="strong"><strong>downto</strong></span> 0 do printfn "%A" i</pre><p>The more powerful variation of the <code class="literal">for</code> loop is the <span class="emphasis"><em>enumerable</em></span> <code class="literal">for</code> loop. In some ways, the enumerable <code class="literal">for</code> loop is similar to C#’s <code class="literal">foreach</code> loop in that it operates over any sequence (collection types implementing <code class="literal">IEnumerable&lt;'T&gt;</code>). For instance, the enumerable <code class="literal">for</code> loop makes it easy to iterate over a range of integers, like this:</p><a id="pro_id00084"/><pre class="programlisting">for i in [0..10] do
  printfn "%A" i</pre><p><a id="iddle1220" class="indexterm"/><a id="iddle1312" class="indexterm"/><a id="iddle1331" class="indexterm"/><a id="iddle1440" class="indexterm"/><a id="iddle1518" class="indexterm"/>In reality, though, the enumerable <code class="literal">for</code> loop is a fancy syntactic shortcut for applying F#’s powerful pattern-matching capabilities over a sequence. With pattern matching, you can extract values from more complex types and even perform some rudimentary filtering right in the loop definition! No LINQ required!</p><a id="pro_id00085"/><pre class="programlisting">① type MpaaRating =
  | G
  | PG
  | PG13
  | R
  | NC17

② type Movie = { Title : string; Year : int; Rating : MpaaRating option }

③ let movies = [ { Title = "The Last Witch Hunter"; Year = 2014; Rating = None }
                 { Title = "Riddick"; Year = 2013; Rating = Some(R) }
                 { Title = "Fast Five"; Year = 2011; Rating = Some(PG13) }
                 { Title = "Babylon A.D."; Year = 2008; Rating = Some(PG13) } ]

④ for { Title = t; Year = y; Rating = Some(r) } in movies do
    printfn "%s (%i) - %A" t y r</pre><p>At ① we see a discriminated union representing the rating scale, at ② a record type representing a movie with an optional rating, at ③ an F# list, and finally at ④ the <code class="literal">for...in</code> loop with a pattern match to find all movies that have been rated. The compiler will highlight the pattern match and warn you about not having a covering case, but that’s okay because we’re using it as a filter.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note06"/>Note</h3><p><span class="emphasis"><em>Don’t worry about all this discussion of pattern matching, discriminated unions, record types, and other functional concepts yet. We’ll explore each in detail in <a class="xref" href="ch05.html" title="Chapter 5. Let’s Get Functional">Chapter 5</a> and <a class="xref" href="ch07.html" title="Chapter 7. Patterns, Patterns, Everywhere">Chapter 7</a>.</em></span></p></div></div></div><div class="sect2" title="Branching"><div class="titlepage"><div><div><h3 class="title" id="branching">Branching</h3></div></div></div><p>F# offers only a single imperative construct for branching: the <code class="literal">if...then...else</code> expression, as shown next. This expression evaluates a Boolean expression in the <code class="literal">if</code> part. When that expression evaluates to <code class="literal">true</code>, the <code class="literal">then</code> branch is executed; otherwise, the <code class="literal">else</code> branch is executed (if one is present).</p><a id="pro_id00086"/><pre class="programlisting">let isEven number =
  if number % 2 = 0 then
    printfn "%i is even" number
  else
    printfn "%i is odd" number</pre><p>You can chain multiple <code class="literal">if...then...else</code> expressions together with the <code class="literal">elif</code> keyword (a shortcut for <code class="literal">else if</code>), as shown next. This has the same effect as nesting them, though the result is much more readable.</p><a id="pro_id00087"/><pre class="programlisting">let isEven number =
  if number = 0 then
    printfn "zero"
  <span class="strong"><strong>elif</strong></span> number % 2 = 0 then
    printfn "%i is even" number
  else
    printfn "%i is odd" number</pre><p><a id="iddle1484" class="indexterm"/>Because the <code class="literal">if...then...else</code> expression returns a value, constructs like C#’s conditional operator (<code class="literal">?:</code>) aren’t necessary. You should know, though, that because the expression returns a value it behaves a bit differently depending on how it’s being used. When only the <code class="literal">if</code> branch is specified, its expression must evaluate to <code class="literal">unit</code>, but when both the <code class="literal">if</code> and <code class="literal">else</code> branches are specified, their expressions must both evaluate to the same type.</p><p>In each example so far, the result of the <code class="literal">if...then...else</code> expression has been <code class="literal">unit</code>, but what happens if you change the function to use <code class="literal">sprintf</code> instead of <code class="literal">printfn</code> like this?</p><a id="pro_id00088"/><pre class="programlisting">let <span class="strong"><strong>isEven</strong></span> number =
  if number = 0 then
    <span class="strong"><strong>sprintf</strong></span> "zero"
  elif number % 2 = 0 then
    <span class="strong"><strong>sprintf</strong></span> "%i is even" number
  else
    <span class="strong"><strong>sprintf</strong></span> "%i is odd" number</pre><p>Instead of printing the message to the console, the <code class="literal">isEven</code> function actually returns the message as a string. You can see this by invoking the function in FSI like so:</p><a id="pro_id00089"/><pre class="programlisting">&gt; <span class="strong"><strong>isEven 0;;</strong></span>
val it : string = "zero"
&gt; <span class="strong"><strong>isEven 1;;</strong></span>
val it : string = "1 is odd"
&gt; <span class="strong"><strong>isEven 2;;</strong></span>
val it : string = "2 is even"</pre></div></div><div class="sect1" title="Generics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="generics">Generics</h2></div></div></div><p>Don Syme, the designer and architect of F#, was heavily involved in the research and development of what eventually became generics in the .NET Framework. With a heritage like that, it’s no surprise that generics in F# are incredibly robust, in some ways even more powerful than in other .NET languages.</p><p>Generics allow you to define functions, classes, methods, interfaces, and structures that can work directly with any data type. Without generics, the only way to write type-safe code that works with multiple data types is to write a separate implementation for each type. However, this approach is limiting, because any new type that relies on that code will need its own <a id="iddle1064" class="indexterm"/><a id="iddle1133" class="indexterm"/><a id="iddle1191" class="indexterm"/><a id="iddle1485" class="indexterm"/><a id="iddle1487" class="indexterm"/><a id="iddle1566" class="indexterm"/><a id="iddle1590" class="indexterm"/><a id="iddle1939" class="indexterm"/>implementation. Generics abstract away this complexity by generating these implementations for you based on the type parameters you’ve supplied in your code.</p><p>To show how useful generics really are, consider how one of the original .NET collection types, the <code class="literal">ArrayList</code>, compares to its cousin, the generic list. The <code class="literal">ArrayList</code> class is a collection type that has been around since the earliest days of .NET and well before generics were available in the framework. In order for it to hold data of any type, it needed to treat every element as <code class="literal">System.Object</code>. As a result, code written with <code class="literal">ArrayList</code> almost always involved excessive type conversions of elements in the list. Worse, there was no way to enforce consistency between elements, so although a developer might believe that every element in the list was a string, it could very well also contain integers, floats, or instances of any other data type. This type of code was highly error prone and often had a negative impact on performance.</p><p>The generic <code class="literal">List&lt;'T&gt;</code> class, on the other hand, can be instantiated to work with any specific data type. It removes all ambiguity about what its elements are and typically eliminates the type conversions (subclassing notwithstanding), which leads to more reliable and efficient code.</p><p>Since their beginning, generics have played a starring role in virtually every innovation in .NET development, including LINQ and the Task Parallel Library. In some ways, they play an even greater part in F# development than in traditional .NET development because of their role in the type inference process and concepts like statically resolved type parameters (discussed in <a class="xref" href="ch03.html#statically_resolved_type_parameters" title="Statically Resolved Type Parameters">Statically Resolved Type Parameters</a>).</p><p>In F#, most generic type parameters are named with a leading apostrophe. For example, <code class="literal">'a</code>, <code class="literal">'A</code>, and <code class="literal">'TInput</code> are all valid type parameter names. By convention, F# uses sequential lowercase identifiers for inferred type parameters, whereas user-defined type parameters begin with an uppercase character.</p><div class="sect2" title="Automatic Generalization"><div class="titlepage"><div><div><h3 class="title" id="automatic_generalization">Automatic Generalization</h3></div></div></div><p>F#’s type inference feature favors generic types whenever possible through a process called <span class="emphasis"><em>automatic generalization</em></span>. Here it is in action:</p><a id="pro_id00090"/><pre class="programlisting">&gt; <span class="strong"><strong>let toTriple a b c = (a, b, c);;</strong></span>
val toTriple : a:'a -&gt; b:'b -&gt; c:'c -&gt; 'a * 'b * 'c</pre><p>In this example the <code class="literal">toTriple</code> function converts its three parameters into a three-item tuple (sometimes called a triple). We’ll explore the arrows and tuples in detail in <a class="xref" href="ch05.html" title="Chapter 5. Let’s Get Functional">Chapter 5</a>; for now just recognize that the compiler automatically generalized each of the three parameters to the types <code class="literal">'a</code>, <code class="literal">'b</code>, and <code class="literal">'c</code>, respectively.</p><p>Whether the compiler can automatically generalize a parameter depends largely on how and where it’s used. Automatic generalization is attempted only with immutable values on complete function definitions with explicit parameters.</p></div><div class="sect2" title="Explicit Generalization"><div class="titlepage"><div><div><h3 class="title" id="explicit_generalization">Explicit Generalization</h3></div></div></div><p><a id="iddle1263" class="indexterm"/><a id="iddle1471" class="indexterm"/><a id="iddle1474" class="indexterm"/><a id="iddle1479" class="indexterm"/><a id="iddle1481" class="indexterm"/><a id="iddle1486" class="indexterm"/>If the compiler can’t automatically generalize a parameter, or you want more control over it, you can explicitly generalize a parameter with a type annotation. This is especially useful when you want to constrain the types allowed. You could rewrite the previous <code class="literal">toTriple</code> example with explicit type parameters as follows:</p><a id="pro_id00091"/><pre class="programlisting">&gt; <span class="strong"><strong>let toTriple (a : 'A) (b : 'B) (c : 'C) = (a, b, c);;</strong></span>
val toTriple : a:'A -&gt; b:'B -&gt; c:'C -&gt; 'A * 'B * 'C</pre><p>When type parameters are unconstrained, you’re fairly limited in what you can do with them. Generally, you can use them only with other unconstrained generic types or functions, and good luck invoking any methods beyond those defined on <code class="literal">System.Object</code>. To do something that depends on some aspect of the type, such as calling an interface method, you’ll need to add a <span class="emphasis"><em>constraint</em></span>.</p><p>If you’re familiar with generic constraints in C# or Visual Basic, you may have been frustrated by the lack of things you can actually constrain. In those languages you can constrain type parameters only to reference types, value types, types with a default constructor, types that derive from a particular class, and types that derive from a particular interface. F# supports each of these but also adds a few other constraints.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note07"/>Note</h3><p><span class="emphasis"><em>Most constraint types apply to standard type parameters, but a few apply only to an F#-specific form of type parameters called</em></span> statically resolved type parameters. <span class="emphasis"><em>In the following examples, you’ll see these constraints defined in inline functions with a type parameter that uses a caret (^) instead of an apostrophe. Statically resolved type parameters are described later in this section.</em></span></p></div><p>You apply constraints by following the generic type annotation with <code class="literal">when</code> and the constraint. You can specify multiple constraints by combining them with <code class="literal">and</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p title="Subtype constraints"><span class="title"><strong><span class="strong"><strong>Subtype constraints</strong></span></strong></span>. A subtype constraint limits the acceptable types to the constraint type itself or any type that derives from that type. When the constraint type is an interface, the provided type needs to implement that interface.</p><a id="pro_id00092"/><pre class="programlisting">let myFunc (stream : 'T when 'T :&gt; System.IO.Stream) = ()</pre><p><span class="strong"><strong>Nullness constraints</strong></span> A nullness constraint limits the acceptable types to those where <code class="literal">null</code> is a valid value.</p><a id="pro_id00093"/><pre class="programlisting">let inline myFunc (a : ^T when ^T : null) = ()</pre></li><li class="listitem" style="list-style-type: none"><p title="Member constraints"><span class="title"><strong><span class="strong"><strong>Member constraints</strong></span></strong></span>. <a id="iddle1473" class="indexterm"/><a id="iddle1475" class="indexterm"/><a id="iddle1476" class="indexterm"/><a id="iddle1478" class="indexterm"/><a id="iddle1480" class="indexterm"/><a id="iddle1482" class="indexterm"/><a id="iddle1483" class="indexterm"/>A member constraint ensures that the supplied type includes a member with a specific signature. You can constrain the types based on either instance or static members.</p><a id="pro_id00094"/><pre class="programlisting">// instance member
let inline myFunc
  (a : ^T when ^T : (member ReadLine : unit -&gt; string)) = ()

// static member
let inline myFunc
  (a : ^T when ^T : (static member Parse : string -&gt; ^T)) = ()</pre></li><li class="listitem" style="list-style-type: none"><p title="Default constructor constraints"><span class="title"><strong><span class="strong"><strong>Default constructor constraints</strong></span></strong></span>. A default constructor constraint ensures that the supplied type has a default constructor.</p><a id="pro_id00095"/><pre class="programlisting">let myFunc (stream : 'T when 'T : (new : unit -&gt; 'T)) = ()</pre></li><li class="listitem" style="list-style-type: none"><p title="Value type constraints"><span class="title"><strong><span class="strong"><strong>Value type constraints</strong></span></strong></span>. A value type constraint restricts the supplied type to any .NET value types except <code class="literal">System.Nullable&lt;_&gt;</code>.</p><a id="pro_id00096"/><pre class="programlisting">let myFunc (stream : 'T when 'T : struct) = ()</pre></li><li class="listitem" style="list-style-type: none"><p title="Reference type constraints"><span class="title"><strong><span class="strong"><strong>Reference type constraints</strong></span></strong></span>. A reference type constraint ensures that the supplied type is a .NET reference type.</p><a id="pro_id00097"/><pre class="programlisting">let myFunc (stream : 'T when 'T : not struct) = ()</pre></li><li class="listitem" style="list-style-type: none"><p title="Enumeration constraints"><span class="title"><strong><span class="strong"><strong>Enumeration constraints</strong></span></strong></span>. An enumeration constraint limits the supplied types to enumerations with a specific underlying type.</p><a id="pro_id00098"/><pre class="programlisting">let myFunc (stream : 'T when 'T : enum&lt;int32&gt;) = ()</pre></li><li class="listitem" style="list-style-type: none"><p title="Delegate constraints"><span class="title"><strong><span class="strong"><strong>Delegate constraints</strong></span></strong></span>. A delegate constraint restricts the provided types to delegate types with a particular set of arguments and return type. Delegate constraints are intended primarily for use with traditional .NET event handlers.</p><a id="pro_id00099"/><pre class="programlisting">open Systemlet
myFunc (stream : 'T when 'T : delegate&lt;obj * EventArgs, unit&gt;) = ()</pre></li><li class="listitem" style="list-style-type: none"><p title="Unmanaged constraints"><span class="title"><strong><span class="strong"><strong>Unmanaged constraints</strong></span></strong></span>. Unmanaged constraints restrict the provided type to unmanaged types like some of the numeric primitives and enumeration types.</p><a id="pro_id00100"/><pre class="programlisting">let myFunc (stream : 'T when 'T : unmanaged) = ()</pre></li><li class="listitem" style="list-style-type: none"><p title="Equality constraints"><span class="title"><strong><span class="strong"><strong>Equality constraints</strong></span></strong></span>. <a id="iddle1065" class="indexterm"/><a id="iddle1435" class="indexterm"/><a id="iddle1472" class="indexterm"/><a id="iddle1477" class="indexterm"/><a id="iddle1488" class="indexterm"/><a id="iddle1489" class="indexterm"/><a id="iddle1940" class="indexterm"/><a id="iddle2117" class="indexterm"/>An equality constraint restricts the provided type to types that support equality. This constraint is considered weak because it’s satisfied by nearly every CLI type.</p><a id="pro_id00101"/><pre class="programlisting">let myFunc (stream : 'T when 'T : equality) = ()</pre></li><li class="listitem" style="list-style-type: none"><p title="Comparison constraints"><span class="title"><strong><span class="strong"><strong>Comparison constraints</strong></span></strong></span>. Comparison constraints are satisfied only by types that implement <code class="literal">System.IComparable</code>, arrays, <code class="literal">nativeint</code>, and <code class="literal">unativeint</code> unless the type has the <code class="literal">NoEquality</code> attribute.</p><a id="pro_id00102"/><pre class="programlisting">let myFunc (stream : 'T when 'T : comparison) = ()</pre></li></ul></div></div><div class="sect2" title="Flexible Types"><div class="titlepage"><div><div><h3 class="title" id="flexible_types">Flexible Types</h3></div></div></div><p>Although not strictly generic constructs, <span class="emphasis"><em>flexible types</em></span> are a syntactic shortcut for subtype constraints. They’re particularly useful with the function arguments of a higher-order function where automatic type conversion normally doesn’t automatically occur.</p><p>You can specify a flexible type by prefixing a type name with a <code class="literal">#</code> character within a type annotation.</p><a id="pro_id00103"/><pre class="programlisting">let myFunc (stream : #System.IO.Stream) = ()</pre></div><div class="sect2" title="Wildcard Pattern"><div class="titlepage"><div><div><h3 class="title" id="wildcard_pattern">Wildcard Pattern</h3></div></div></div><p>When you want to use a generic type as a parameter but want the compiler to infer the type, you can use the <span class="emphasis"><em>Wildcard pattern</em></span> in place of a named type parameter. The Wildcard pattern is represented with an underscore.</p><a id="pro_id00104"/><pre class="programlisting">let printList (l : List&lt;<span class="strong"><strong>_</strong></span>&gt;) = l |&gt; List.iter (fun i -&gt; printfn "%O" i)</pre><p>The preceding function will print each element in an F# list with its <code class="literal">ToString</code> function regardless of what type is contained in the list.</p></div><div class="sect2" title="Statically Resolved Type Parameters"><div class="titlepage"><div><div><h3 class="title" id="statically_resolved_type_parameters">Statically Resolved Type Parameters</h3></div></div></div><p>F# has two classifications of generics. The first (which we’ve focused on almost exclusively so far) is standard generics, the same generics as in other .NET languages. The second, called <span class="emphasis"><em>statically resolved type parameters</em></span>, is specific to F# and identified by a caret (<code class="literal">^</code>) instead of an apostrophe. Statically resolved type parameters force the compiler to resolve the types at compile time rather than run time. The implication is that the compiler generates a version of the generic type for each resolved type rather than a single version.</p><p>Statically resolved type parameters are primarily intended for use with inline functions and are especially well suited for custom operators, as shown here.</p><a id="pro_id00105"/><pre class="programlisting">let inline (!**) x = x ** 2.0</pre><p><a id="iddle1361" class="indexterm"/><a id="iddle1364" class="indexterm"/><a id="iddle1366" class="indexterm"/><a id="iddle1372" class="indexterm"/><a id="iddle1499" class="indexterm"/><a id="iddle1745" class="indexterm"/><a id="iddle2026" class="indexterm"/><a id="iddle2030" class="indexterm"/><a id="iddle2116" class="indexterm"/>When this operator is compiled, it uses static resolution with a constraint to ensure that any types that use it include the <code class="literal">Pow</code> function in their definition based on the use of the <code class="literal">**</code> operator.</p><a id="pro_id00106"/><pre class="programlisting">val inline ( !** ) :
  x: <span class="strong"><strong>^a</strong></span> -&gt; <span class="strong"><strong>^a</strong></span> when <span class="strong"><strong>^a</strong></span> : (static member <span class="strong"><strong>Pow</strong></span> : <span class="strong"><strong>^a</strong></span> * float -&gt; <span class="strong"><strong>^a</strong></span>)</pre></div></div><div class="sect1" title="When Things Go Wrong"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="when_things_go_wrong">When Things Go Wrong</h2></div></div></div><p>Despite your best efforts and the extra safety that F# provides, things can and will go wrong. Proper error handling is a critical piece of any program. F# builds upon the standard .NET exception mechanisms with additional syntactic support that allows you to <span class="emphasis"><em>throw</em></span> (or <span class="emphasis"><em>raise</em></span> in F# parlance) and handle exceptions with ease. (For convenience, the standard exception type, <code class="literal">System.Exception</code>, is abbreviated as <code class="literal">exn</code>.)</p><div class="sect2" title="Handling Exceptions"><div class="titlepage"><div><div><h3 class="title" id="handling_exceptions">Handling Exceptions</h3></div></div></div><p>Error conditions are always a possibility, so it’s important to know how to handle them properly when they arise. F# provides two constructs for error handling: <code class="literal">try...with</code> and <code class="literal">try...finally</code>. These constructs are strictly independent of each other; that is, there is no <code class="literal">try...with...finally</code> construct in F#. If you need both a <code class="literal">with</code> and a <code class="literal">finally</code> block, you’ll generally nest a <code class="literal">try...with</code> block within a <code class="literal">try...finally</code> block, although the nesting order doesn’t really matter.</p><div class="sect3" title="try. . .with Expressions"><div class="titlepage"><div><div><h4 class="title" id="trydot_dot_dotwith_expressions">try. . .with Expressions</h4></div></div></div><p>In a <code class="literal">try...with</code> construct, the expressions contained within the <code class="literal">try</code> block are evaluated and if any raise an exception, F# pattern matching is used to locate an appropriate handler in the <code class="literal">with</code> block.</p><p>Input/output-related operations, like reading from a file, are great examples of where you’d use the exception-handling constructs because you’re at the mercy of external factors like network availability issues or file permissions. In this example, we attempt to read a text file and write its contents to the console but do so in a <code class="literal">try</code> block.</p><a id="pro_id00107"/><pre class="programlisting">open System.IO

<span class="strong"><strong>try</strong></span>
  use file = File.OpenText "somefile.txt"
  file.ReadToEnd() |&gt; printfn "%s"
<span class="strong"><strong>with</strong></span>
| ①:? FileNotFoundException -&gt; printfn "File not found"
| ②_ -&gt; printfn "Error loading file"</pre><p>If an exception is raised, execution passes to the <code class="literal">with</code> block, where the system attempts to find a handler first using ①, a <span class="emphasis"><em>Type-Test pattern</em></span> (a pattern that matches a specific data type). In this case, the <span class="emphasis"><em>Wildcard pattern</em></span> ② <a id="iddle1368" class="indexterm"/><a id="iddle1428" class="indexterm"/><a id="iddle1851" class="indexterm"/>(a general-purpose pattern that matches everything) is used as a general exception handler. If a suitable match isn’t found, the exception bubbles up the call stack until a handler is found or the application fails.</p><p>Without delving too much into the specifics of pattern matching, we can look at a few ways to unlock the potential of the <code class="literal">with</code> block. As it stands now, the handler for <code class="literal">FileNotFoundException</code> isn’t very helpful because it doesn’t give any information about which file wasn’t found. You can capture the exception for use in the handler by including an identifier with the <code class="literal">as</code> keyword in the pattern.</p><a id="pro_id00108"/><pre class="programlisting">try
-- <span class="emphasis"><em>snip</em></span> --
with
| :? FileNotFoundException <span class="strong"><strong>as</strong></span> ①ex -&gt;
 ②printfn "% was not found" ex.FileName
| _ -&gt; printfn "Error loading file"</pre><p>Now that the <code class="literal">ex</code> identifier is defined ①, you can include the filename in the printed message ②.</p><p>You can even combine cases when two or more exception types should use the same handler.</p><a id="pro_id00109"/><pre class="programlisting">try
-- <span class="emphasis"><em>snip</em></span> --
with
| :? FileNotFoundException as ex -&gt;
  printfn "%s was not found" ex.FileName
<span class="strong"><strong>| :? PathTooLongException</strong></span>
<span class="strong"><strong>| :? ArgumentNullException</strong></span>
<span class="strong"><strong>| :? ArgumentException -&gt;</strong></span>
  <span class="strong"><strong>printfn "Invalid filename"</strong></span>
| _ -&gt; printfn "Error loading file"</pre><p>Sometimes you may want to partially handle an exception at one level but still allow it to traverse up the call stack to another handler. You could raise the exception normally with the <code class="literal">raise</code> function, but in doing so you’d lose the call stack information embedded in the exception and later handlers would recognize your handler as the source of the error. To preserve the stack trace, <span class="emphasis"><em>reraise</em></span> the exception with a function that’s valid only within a <code class="literal">with</code> block: <code class="literal">reraise</code>.</p><a id="pro_id00110"/><pre class="programlisting">try
-- <span class="emphasis"><em>snip</em></span> --
with
| :? FileNotFoundException as ex -&gt;
  printfn "%s was not found" ex.FileName
| _ -&gt;
  printfn "Error loading file"
  <span class="strong"><strong>reraise()</strong></span></pre><p><a id="iddle1367" class="indexterm"/><a id="iddle1369" class="indexterm"/><a id="iddle1820" class="indexterm"/><a id="iddle1822" class="indexterm"/><a id="iddle2027" class="indexterm"/>Unlike in C# and Visual Basic, F#’s <code class="literal">try...with</code> construct is an expression, so it returns a value. All of the examples so far have returned <code class="literal">unit</code>. This opens up more possibilities as to how you can use the construct, but it also means that each exception case must have the same return type as the <code class="literal">try</code> block.</p><p>A common practice is to have the <code class="literal">try...with</code> return an option type where the <code class="literal">try</code> block returns <code class="literal">Some&lt;_&gt;</code> and each exception case returns <code class="literal">None</code>. You can follow this pattern to return the contents of a text file.</p><a id="pro_id00111"/><pre class="programlisting">open System
open System.Diagnostics
open System.IO

let fileContents =
  try
    use file = File.OpenText "somefile.txt"
  ①Some &lt;| file.ReadToEnd()
  with
  | :? FileNotFoundException as ex -&gt;
    printfn "%s was not found" ex.FileName
  ②None
  | _ -&gt;
    printfn "Error loading file"
    reraise()</pre><p>In this example, you can see at ① where an option is created with the contents of the text file and returned. Returning <code class="literal">None</code> from the <code class="literal">FileNotFoundException</code> handler is shown at ②.</p></div><div class="sect3" title="try. . .finally Expressions"><div class="titlepage"><div><div><h4 class="title" id="trydot_dot_dotfinally_expressions">try. . .finally Expressions</h4></div></div></div><p>The <code class="literal">try...finally</code> construct is used to execute code that must run regardless of whether the code in the <code class="literal">try</code> block raises an exception.</p><p>Usually, <code class="literal">try...finally</code> is used to clean up any resources that might have been left open by the <code class="literal">try</code> block, as shown here:</p><a id="pro_id00112"/><pre class="programlisting">try
  use file = File.OpenText "somefile.txt"
  Some &lt;| file.ReadToEnd()
finally
  printfn "cleaning up"</pre></div></div><div class="sect2" title="Raising Exceptions"><div class="titlepage"><div><div><h3 class="title" id="raising_exceptions">Raising Exceptions</h3></div></div></div><p>An exception-handling mechanism isn’t much use if you’re stuck handling exceptions from library functions but can’t raise your own. You can raise an exception of any type with the <code class="literal">raise</code> function.</p><a id="pro_id00113"/><pre class="programlisting">let filename = "x"
if not (File.Exists filename) then
  <span class="strong"><strong>raise</strong></span> &lt;| FileNotFoundException("filename was null or empty")</pre><p><a id="iddle1126" class="indexterm"/><a id="iddle1274" class="indexterm"/><a id="iddle1362" class="indexterm"/><a id="iddle1363" class="indexterm"/><a id="iddle1365" class="indexterm"/><a id="iddle1420" class="indexterm"/><a id="iddle1421" class="indexterm"/><a id="iddle1422" class="indexterm"/><a id="iddle1545" class="indexterm"/><a id="iddle1821" class="indexterm"/>In addition to <code class="literal">raise</code>, F# includes a sprinkling of additional functions for raising some of the more commonly used exceptions. The <code class="literal">failwith</code> and <code class="literal">failwithf</code> functions are convenient for general exceptions. Both raise a <code class="literal">Microsoft.FSharp.Core.FailureException</code>, but the <code class="literal">failwithf</code> function allows you to use the F# format strings (discussed in <a class="xref" href="ch03.html#string_formatting" title="String Formatting">String Formatting</a>), as shown here.</p><a id="pro_id00114"/><pre class="programlisting">// failwith
if not (File.Exists filename) then
  <span class="strong"><strong>failwith "File not found"</strong></span>

// failwithf
if not (String.IsNullOrEmpty filename) then
  <span class="strong"><strong>failwithf "%s could not be found" filename</strong></span></pre><p>Another common exception type that’s easily raised through a built-in function is <code class="literal">System.ArgumentException</code>. To conveniently raise it, use the <code class="literal">invalidArg</code> function.</p><a id="pro_id00115"/><pre class="programlisting">if not (String.IsNullOrEmpty filename) then
  <span class="strong"><strong>invalidArg</strong></span> "filename" (sprintf "%s is not a valid file name" filename)</pre></div><div class="sect2" title="Custom Exceptions"><div class="titlepage"><div><div><h3 class="title" id="custom_exceptions">Custom Exceptions</h3></div></div></div><p>It’s usually best to use predefined exception types like <code class="literal">ArgumentException</code>, <code class="literal">FormatException</code>, or even <code class="literal">NullReferenceException</code>, but if you must define your own exception types, you can define a new class that extends <code class="literal">System.Exception</code>. For example:</p><a id="pro_id00116"/><pre class="programlisting">type MyException(message, category) =
  inherit exn(message)
  member x.Category = category
  override x.ToString() = sprintf "[%s] %s" category message</pre><p>You can raise your custom exception with the <code class="literal">raise</code> function and handle it in a <code class="literal">try...with</code> or <code class="literal">try...finally</code> block as with any other exception type. Here you can see the custom <code class="literal">MyException</code> exception raised and caught.</p><a id="pro_id00117"/><pre class="programlisting">try
  <span class="strong"><strong>raise</strong></span> &lt;| MyException("blah", "debug")
with
  | <span class="strong"><strong>:? MyException as ex</strong></span> -&gt; printfn "My Exception: %s" &lt;| ex.ToString()
  | _ as ex -&gt; printfn "General Exception: %s" &lt;| ex.ToString()</pre><p>There’s also a lightweight alternative to creating exception classes. In F# you can define a custom exception type and its associated data with the <code class="literal">exception</code> keyword. Exceptions created this way are still standard .NET exceptions that derive from <code class="literal">System.Exception</code>, but the syntax borrows from a few functional concepts (syntactic tuples and discriminated unions, in particular) to accomplish its magic.</p><a id="pro_id00118"/><pre class="programlisting"><span class="strong"><strong>exception</strong></span> RetryAttemptFailed of string * int
<span class="strong"><strong>exception</strong></span> RetryCountExceeded of string</pre><p>You raise these exceptions as you would any exception. However, handling them is streamlined because you can use the same pattern-matching syntax as discriminated unions (more on pattern matching in <a class="xref" href="ch07.html" title="Chapter 7. Patterns, Patterns, Everywhere">Chapter 7</a>) to not only determine which handler to use but also to bind the associated data to useful identifiers.</p><p>A generalized <code class="literal">retry</code> function might raise different exception types that indicate whether it should keep trying or give up depending on how many times it has tried to execute some action.</p><a id="pro_id00119"/><pre class="programlisting">let ①retry maxTries action =
  let ②rec retryInternal attempt =
    try
      if not (action()) then
        raise &lt;| if attempt &gt; maxTries then
                    ③RetryCountExceeded("Maximum attempts exceeded.")
                 else
                    ④RetryAttemptFailed(sprintf "Attempt %i failed." attempt, attempt)

   with
   | ⑤RetryAttemptFailed(msg, count) as ex -&gt; Console.WriteLine(msg)
                                             retryInternal (count + 1)
   | ⑥RetryCountExceeded(msg) -&gt; Console.WriteLine(msg)
                                reraise()
  ⑦retryInternal 1

retry 5 (fun() -&gt; false)</pre><p>In this example, the <code class="literal">retry</code> function ① accepts two parameters. The first indicates the maximum number of attempts and the second is a Boolean-returning function to invoke. All of the work is performed within <code class="literal">retryInternal</code> ②, a nested <span class="emphasis"><em>recursive function</em></span> that calls itself and that invokes the supplied function. If the supplied function returns <code class="literal">false</code>, it raises either a <code class="literal">RetryCountExceeded</code> exception ③ or a <code class="literal">RetryAttemptFailed</code> exception ④. When <code class="literal">RetryAttemptFailed</code> is raised, the handler ⑤ writes the exception message to the console before calling the <code class="literal">retryInternal</code> function again with an incremented counter. If a <code class="literal">RetryCountExceeded</code> exception is raised, the handler ⑥ writes the exception message to the console and then reraises the exception for another handler to process. Of course, this process has to start somewhere, so we make the initial call to <code class="literal">retryInternal</code> ⑦ with 1 to indicate the first attempt.</p><p>This syntactic simplicity does come at a cost. Despite <code class="literal">RetryAttemptFailed</code> and <code class="literal">RetryCountExceeded</code> being standard exceptions, you’ll really want to keep them isolated to your F# assemblies because consuming them in other languages can be cumbersome. The associated data is defined as a syntactic tuple, so the individual values don’t get descriptive names in the compiled code; instead, the values are assigned “useful” generated names like <code class="literal">Data0</code> and <code class="literal">Data1</code>. To confuse matters even more, the compiler has no way of <a id="iddle1258" class="indexterm"/><a id="iddle1259" class="indexterm"/><a id="iddle1778" class="indexterm"/><a id="iddle1779" class="indexterm"/><a id="iddle1938" class="indexterm"/><a id="iddle1953" class="indexterm"/><a id="iddle1959" class="indexterm"/><a id="iddle2022" class="indexterm"/>knowing which, if any, of the associated data items should be treated as the exception’s <code class="literal">Message</code> property, so the default message (from the base exception class) is used.</p></div></div><div class="sect1" title="String Formatting"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="string_formatting">String Formatting</h2></div></div></div><p>You probably guessed that the tried and tested <code class="literal">Console.Write</code>, <code class="literal">Console.WriteLine</code>, and <code class="literal">String.Format</code> methods are perfectly acceptable in F#. When you need absolute control over formatting, you’ll have to use them. As capable as they are, though, they don’t take advantage of all that F# has to offer.</p><p>F# has its own string formatting capabilities that you can use with the <code class="literal">printf</code>, <code class="literal">printfn</code>, and <code class="literal">sprintf</code> functions, among others. Why did the language designers choose to build another formatting mechanism when .NET’s built-in mechanism is already so capable? Because F#’s native formatting capabilities tie into the compiler better than the traditional ones. For one, the tokens used within the F# format strings are generally easier to remember than the format strings in the core methods, but that’s not the primary advantage. What really distinguishes the F# formatting system is that it ties in to the F# type inference system! The compiler will verify that each token has a matching value and that each supplied value is the correct type for the corresponding token!</p><p>To simply format a string, you could use the <code class="literal">sprintf</code> function. For example, here’s how to quickly format a basic integer value.</p><a id="pro_id00120"/><pre class="programlisting">&gt; <span class="strong"><strong>sprintf "%d" 123;;</strong></span>
val it : string = "123"</pre><p>Of course, integers aren’t the only data type you can format in this manner. <a class="xref" href="ch03.html#common_format_tokens" title="Table 3-5. Common Format Tokens">Table 3-5</a> shows a list of common format string tokens.</p><div class="table"><a id="common_format_tokens"/><div class="table-title">Table 3-5. Common Format Tokens</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Token</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Description</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%A</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Prints any value with F#’s default layout settings</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%b</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Formats a Boolean value as <code class="literal">true</code> or <code class="literal">false</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%c</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Formats a character</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%d</code>, <code class="literal">%i</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Formats any integer</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%e</code>, <code class="literal">%E</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Formats a floating-point number with scientific notation</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%f</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Formats a floating-point number</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%g</code>, <code class="literal">%G</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Shortcut for <code class="literal">%e</code> or <code class="literal">%f</code>; the more concise one will be selected automatically.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%M</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Formats a decimal value</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%o</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Octal</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%O</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Prints any value by calling its <code class="literal">ToString</code> method</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%s</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Formats a string</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">%x</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Lowercase hexadecimal</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">%X</code></p></td><td style="vertical-align: top; "><p>Uppercase hexadecimal</p></td></tr></tbody></table></div></div><p><a id="iddle1246" class="indexterm"/><a id="iddle2039" class="indexterm"/><a id="iddle2050" class="indexterm"/><a id="iddle2089" class="indexterm"/>To ensure that the formatted text is at least a certain number of characters wide, you can include an optional width value after the <code class="literal">%</code>. (The default formatter won’t truncate your data unless the format token explicitly allows it.) For example:</p><a id="pro_id00121"/><pre class="programlisting">&gt; <span class="strong"><strong>printfn "%5s" "ABC";;</strong></span>
ABC

&gt; <span class="strong"><strong>printfn "%5s" "ABCDEFGHI";;</strong></span>
ABCDEFGHI</pre><p>You can combine several modifiers with the tokens for a little extra flexibility in formatting, as listed in <a class="xref" href="ch03.html#numeric_format_string_modifiers" title="Table 3-6. Numeric Format String Modifiers">Table 3-6</a>.</p><div class="table"><a id="numeric_format_string_modifiers"/><div class="table-title">Table 3-6. Numeric Format String Modifiers</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/><col class="c3"/><col class="c4"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Modifier</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Effect</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Example</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Result</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">0</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>When used in conjunction with a width, pads any extra space with zeros</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">"%010d"</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">"0000000123"</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Left-justifies the text within the available space</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">"%-10d"</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">"123 "</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">+</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Prepends a positive sign if the number is positive</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">"%+d"</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">"+123"</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>(space)</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>Prepends a space if the number is positive</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">"% d"</code></p></td><td style="vertical-align: top; "><p><code class="literal">" 123"</code></p></td></tr></tbody></table></div></div><p>You can also combine several modifiers within a single token. For example, you could use the token <code class="literal">%+010d</code> to print a number front-padded with zeros and the plus (<code class="literal">+</code>) sign.</p></div><div class="sect1" title="Type Abbreviations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="type_abbreviations">Type Abbreviations</h2></div></div></div><p>Type abbreviations allow you to define a new name for an existing type just like the core data types are exposed to F#. It’s possible to do something similar in C# with the <code class="literal">using</code> directive, but F#’s type abbreviations allow you to use the name throughout your library (after its definition, of course) instead of only within a single file.</p><p>You define type abbreviations with the <code class="literal">type</code> keyword, an identifier, and the type. If you wanted to refer to <code class="literal">System.IO.FileStream</code> as <code class="literal">fs</code>, you’d use the following:</p><a id="pro_id00122"/><pre class="programlisting">type fs = System.IO.FileStream</pre></div><div class="sect1" title="Comments"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="comments">Comments</h2></div></div></div><p>When you want to describe what a particular piece of code is doing, use comments. There are three ways to comment your code in F#: end-of-line comments, block comments, and XML documentation.</p><div class="sect2" title="End-of-Line Comments"><div class="titlepage"><div><div><h3 class="title" id="end-of-line_comments">End-of-Line Comments</h3></div></div></div><p><a id="iddle1019" class="indexterm"/><a id="iddle1028" class="indexterm"/><a id="iddle1078" class="indexterm"/><a id="iddle1215" class="indexterm"/><a id="iddle1247" class="indexterm"/><a id="iddle1248" class="indexterm"/><a id="iddle1249" class="indexterm"/><a id="iddle1332" class="indexterm"/><a id="iddle2124" class="indexterm"/><span class="emphasis"><em>End-of-line</em></span> (or <span class="emphasis"><em>single-line</em></span>)<span class="emphasis"><em>comments</em></span> begin with two slash characters (<code class="literal">//</code>). As their name implies, they include everything until the end of the line. These comments frequently appear on a line of their own but can also appear at the end of a line.</p><a id="pro_id00123"/><pre class="programlisting">// This is an end-of-line comment
let x = 42 // Answer to the Ultimate Question of Life, The Universe, and Everything</pre></div><div class="sect2" title="Block Comments"><div class="titlepage"><div><div><h3 class="title" id="block_comments">Block Comments</h3></div></div></div><p><span class="emphasis"><em>Block comments</em></span> are delimited with <code class="literal">(*</code> and <code class="literal">*)</code> and are typically used for comments that need to span multiple lines.</p><a id="pro_id00124"/><pre class="programlisting">(* This is a block comment *)

(*
  So is this
*)</pre><p>You can also use block comments in the middle of a line of otherwise uncommented code.</p><a id="pro_id00125"/><pre class="programlisting">let x (* : int *) = 42</pre><p>Be careful with what you include in block comments because the compiler treats their content as strings, verbatim strings, and triple-quoted strings. If you happen to include a quotation mark (or three consecutive quotation marks), the compiler will insist that you’re beginning a string and will produce a syntax error if it doesn’t find the corresponding closing token.</p><a id="pro_id00126"/><pre class="programlisting">(* "This is ok" *)
(* """This is not *)</pre></div><div class="sect2" title="XML Documentation"><div class="titlepage"><div><div><h3 class="title" id="xml_documentation">XML Documentation</h3></div></div></div><p>Like the other .NET languages, F# allows <span class="emphasis"><em>XML documentation comments</em></span> with triple slashes (<code class="literal">///</code>). These comments are technically just a special case of end-of-line comments where the compiler retains the contents to build an XML document that can eventually serve as documentation.</p><p>A complete discussion of XML documentation comments is beyond the scope of this book, but keep in mind that comments are useful for documenting your API. At a minimum I recommend using them on all of your application’s public and internal types and members.</p><p>Your XML documentation comments will usually include a few elements like <code class="literal">summary</code>, <code class="literal">param</code>, and <code class="literal">returns</code>. <code class="literal">summary</code> elements briefly describe the documented code, <code class="literal">param</code> elements identify and describe individual function or constructor parameters, and <code class="literal">returns</code> elements describe a function’s return value.</p><p>You might document a function that calculates some circle measurements based on its radius like this:</p><a id="pro_id00127"/><pre class="programlisting"><span class="strong"><strong>/// &lt;summary&gt;</strong></span>
<span class="strong"><strong>/// Given a radius, calculate the diameter, area, and circumference</strong></span>
<span class="strong"><strong>/// of a circle</strong></span>
<span class="strong"><strong>/// &lt;/summary&gt;</strong></span>
<span class="strong"><strong>/// &lt;param name="radius"&gt;The circle's radius&lt;/param&gt;</strong></span>
<span class="strong"><strong>/// &lt;returns&gt;</strong></span>
<span class="strong"><strong>/// A triple containing the diameter, area, and circumference</strong></span>
<span class="strong"><strong>/// &lt;/returns&gt;</strong></span>
let measureCircle radius =
    let diameter = radius * 2.0
    let area = Math.PI * (radius ** 2.0)
    let circumference = 2.0 * Math.PI * radius
    (diameter, area, circumference)</pre><p>Even if you don’t intend to distribute the resulting XML file, XML documentation comments can help you by surfacing information about the documented types and members through IntelliSense. In <a class="xref" href="ch03.html#xml_documentation_in_intellisense" title="Figure 3-2. XML documentation in IntelliSense">Figure 3-2</a> you can see the summary from the preceding example included in the tool tip displayed when you hover the mouse over the <code class="literal">measureCircle</code> function in Visual Studio.</p><div class="figure"><a id="xml_documentation_in_intellisense"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00014"/><img src="httpatomoreillycomsourcenostarchimages1981220.png.jpg" alt="XML documentation in IntelliSense"/></div></div><div class="figure-title">Figure 3-2. XML documentation in IntelliSense</div></div><p>There’s a shortcut for XML documentation comments. When you’re writing only a summary, you can simply use the triple slashes and omit the tags. Here’s the summary in the previous example written using the shortcut:</p><a id="pro_id00128"/><pre class="programlisting">/// Given a radius, calculate the diameter, area, and circumference
/// of a circle
let measureCircle radius =
-- <span class="emphasis"><em>snip</em></span> --</pre><p>As you can see, when your comment is too long for a single line, you can write it on multiple lines as long as each line begins with triple slashes.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00004">Summary</h2></div></div></div><p>In this chapter, we’ve explored some of the fundamental concepts of the F# language. You’ve seen the problems that can arise from mutable data and how F#’s default immutability, type inference capabilities, and explicit opt-in approach for valueless data can help you write more robust, fault-tolerant code. You’ve also learned how F# supports the core CLI types and other base capabilities of the .NET Framework like enumerations, generics, exception handling, and string formatting.</p><p>What really makes F# stand out as a viable language for your projects, though, is how it expands upon so many concepts even at this fundamental level. Constructs like <code class="literal">use</code> bindings that dispose of objects without requiring additional nesting levels, exception handlers that return values, and string-formatting functions that tie into the compiler can have an immediate, positive impact on your productivity.</p><p>In the next chapter, we’ll build upon these concepts with a look into F#’s object-oriented capabilities. We’ll see how the concepts introduced here can help you quickly develop complex libraries while keeping you focused on the problem rather than the compiler.</p></div></section></body></html>