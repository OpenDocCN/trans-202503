<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_261"/><span class="big"><strong>11</strong></span><br/><strong>OS X SCRIPTS</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">One of the most important changes in the world of Unix and Unix-like operating systems was the release of the completely rewritten OS X system, built atop a reliable Unix core called Darwin. Darwin is an open source Unix based on BSD Unix. If you know your Unix at all, the first time you open the Terminal application in OS X, you’ll doubtless swoon with delight. Everything you’d want, from development tools to standard Unix utilities, is included in the latest generation of Mac computers, with a gorgeous GUI quite capable of hiding all that power for people who aren’t ready for it.</p>&#13;
<p class="indent">There are significant differences between OS X and Linux/Unix, however, so it’s good to learn some OS X tweaks that can help you in your day-to-day interaction. For example, OS X has an interesting command line <span epub:type="pagebreak" id="page_262"/>application called <span class="literal">open</span>, which allows you to launch graphical applications from the command line. But <span class="literal">open</span> isn’t very flexible. If you want to open, say, Microsoft Excel, entering <span class="literal">open excel</span> won’t work because <span class="literal">open</span> is picky and expects you to enter <span class="literal">open -a "Microsoft Excel"</span>. Later in this chapter, we’ll write a wrapper script to work around this picky behavior.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>FIXING OS X LINE ENDINGS</strong></p>&#13;
<p class="noindent">Here’s another occasional situation that’s made easier with a small tweak. If you work on the command line with files created for the GUI side of the Mac, you’ll find that the end-of-line character in these files isn’t the same as the character you need when working on the command line. In technical parlance, OS X systems have end-of-line carriage returns (using <span class="literal">\r</span> notation), while the Unix side wants line feeds (an <span class="literal">\n</span>). So instead of output in which each line is displayed one after the other, a Mac file will show up in the Terminal without the proper line breaks.</p>&#13;
<p class="indent">Have a file that’s suffering from this problem? Here’s what you’d see if you tried to use <span class="literal">cat</span> to output the file contents.</p>&#13;
<pre class="programs">$ <span class="codestrong">cat mac-format-file.txt</span>&#13;
$</pre>&#13;
<p class="indent">Yet you know that the file is not empty. To see that there’s content, use the <span class="literal">-v</span> flag to <span class="literal">cat</span>, which makes all otherwise hidden control characters visible. Now you see something like this:</p>&#13;
<pre class="programs">$ <span class="codestrong">cat -v mac-format-file.txt</span>&#13;
The rain in Spain^Mfalls mainly on^Mthe plain.^MNo kidding. It does.^M $</pre>&#13;
<p class="indent">Clearly there’s something wrong! Fortunately, it’s easy to use <span class="literal">tr</span> to replace the carriage returns with the proper newlines.</p>&#13;
<pre class="programs">$ <span class="codestrong">tr '\r' '\n' &lt; mac-format-file.txt &gt; unix-format-file.txt</span></pre>&#13;
<p class="indent">Once this is applied to the sample file, things make more sense.</p>&#13;
<pre class="programs">$ <span class="codestrong">tr '\r' '\n' &lt; mac-format-file.txt</span>&#13;
The rain in Spain&#13;
falls mainly on&#13;
the plain.&#13;
No kidding. It does.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_263"/>If you open a Unix file in a Mac application like Microsoft Word and it looks all wonky, you can also switch end-of-line characters in the other direction—toward an Aqua application.</p>&#13;
<pre class="programs">$ <span class="codestrong">tr '\n' '\r' &lt; unixfile.txt &gt; macfile.txt</span></pre>&#13;
<p class="indent">Well, that’s just one of the little differences you’ll see in OS X. We’ll have to deal with these quirks, but we’ll also be able to take advantage of OS X’s nicer features.</p>&#13;
<p class="indent">Let’s jump in, shall we?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch11lev1sec01"><strong>#79 Automating screencapture</strong></h3>&#13;
<p class="noindenta">If you’ve used a Mac for any length of time, you’ve learned that it has a builtin screen capture capability that you access by pressing <img src="../images/common2.jpg" alt="image"/>-<small>SHIFT</small>-3. You can also use the OS X utilities <span class="literal">Preview</span> or <span class="literal">Grab</span>, located in the Applications and Utilities folders, respectively, and there are excellent third-party choices too.</p>&#13;
<p class="indent">But did you know that there’s a command line alternative? The super useful program <span class="literal">screencapture</span> can take shots of the current screen and save them to the Clipboard or to a specific named file (in JPEG or TIFF format). Enter the command with an undefined argument and you’ll see the basics of its operation, as shown here:</p>&#13;
<pre class="programs">$ <span class="codestrong">screencapture -h</span>&#13;
screencapture: illegal option -- h&#13;
usage: screencapture [-icMPmwsWxSCUtoa] [files]&#13;
  -c         force screen capture to go to the clipboard&#13;
  -C         capture the cursor as well as the screen. only in non-interactive&#13;
modes&#13;
  -d         display errors to the user graphically&#13;
  -i         capture screen interactively, by selection or window&#13;
               control key - causes screen shot to go to clipboard&#13;
               space key   - toggle between mouse selection and&#13;
                             window selection modes&#13;
               escape key  - cancels interactive screen shot&#13;
  -m         only capture the main monitor, undefined if -i is set&#13;
  -M         screen capture output will go to a new Mail message&#13;
  -o         in window capture mode, do not capture the shadow of the window&#13;
  -P         screen capture output will open in Preview&#13;
  -s         only allow mouse selection mode&#13;
  -S         in window capture mode, capture the screen not the window&#13;
  -t&lt;format&gt; image format to create, default is png (other options include&#13;
pdf, jpg, tiff and other formats)&#13;
  -T&lt;seconds&gt; Take the picture after a delay of &lt;seconds&gt;, default is 5&#13;
  -w         only allow window selection mode&#13;
  -W         start interaction in window selection mode&#13;
  -x         do not play sounds&#13;
  -a         do not include windows attached to selected windows&#13;
  -r         do not add dpi meta data to image&#13;
  -l&lt;windowid&gt; capture this windowsid&#13;
  -R&lt;x,y,w,h&gt; capture screen rect&#13;
  files   where to save the screen capture, 1 file per screen</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/>This is an application begging for a wrapper script. For example, to take a shot of the screen 30 seconds in the future, you could use this:</p>&#13;
<pre class="programs">$ <span class="codestrong">sleep 30; screencapture capture.tiff</span></pre>&#13;
<p class="indent">But let’s make something more interesting, shall we?</p>&#13;
<h4 class="h4" id="ch11lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta"><a href="ch11.xhtml#ch11ex1">Listing 11-1</a> shows how we can automate the <span class="literal">screencapture</span> utility so it captures screenshots a bit more stealthily.</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # screencapture2--Use the OS X screencapture command to capture a sequence of&#13;
   #   screenshots of the main window, in stealth mode. Handy if you're in a&#13;
   #   questionable computing environment!&#13;
&#13;
   capture="$(which screencapture) -x -m -C"&#13;
<span class="ent">➊</span> freq=60         # Every 60 seconds&#13;
   maxshots=30     # Max screen captures&#13;
   animate=0       # Create animated gif? No.&#13;
&#13;
   while getopts "af:m" opt; do&#13;
     case $opt in&#13;
      a ) animate=1;                  ;;&#13;
      f ) freq=$OPTARG;               ;;&#13;
      m ) maxshots=$OPTARG;           ;;  # Quit after specified num of pics&#13;
      ? ) echo "Usage: $0 [-a] [-f frequency] [-m maxcaps]" &gt;&amp;2&#13;
          exit 1&#13;
     esac&#13;
   done&#13;
&#13;
   counter=0&#13;
&#13;
   while [ $counter -lt $maxshots ] ; do&#13;
     $capture capture${counter}.jpg   # Counter keeps incrementing.&#13;
     counter=$(( counter + 1 ))&#13;
     sleep $freq   # freq is therefore the number of seconds between pics.&#13;
   done&#13;
&#13;
   # Now, optionally, compress all the individual images into an animated GIF.&#13;
&#13;
   if [ $animate -eq 1 ] ; then&#13;
<span class="ent">➋</span>   convert -delay 100 -loop 0 -resize "33%" capture* animated-captures.gif&#13;
   fi&#13;
&#13;
   # No exit status to stay stealthy&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_265"/><a id="ch11ex1"/><em>Listing 11-1: The</em> <span class="literal"><em>screencapture2</em></span> <em>wrapper script</em></p>&#13;
<h4 class="h4" id="ch11lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This will take a screenshot every <span class="literal">$freq</span> seconds <span class="ent">➊</span> for up to <span class="literal">$maxshots</span> captures (with a default of every 60 seconds for 30 captures). The output is a series of JPEG files sequentially numbered starting at 0. This could be very useful for training purposes or perhaps if you’re suspicious that someone has been using your computer while you’re at lunch: set this up, and you can review what occurred without anyone being the wiser.</p>&#13;
<p class="indent">The last section of the script is interesting: it optionally produces an animated GIF one-third the size of the original by using the ImageMagick <span class="literal">convert</span> tool <span class="ent">➋</span>. This is a handy way of reviewing the images all at once. We’ll use ImageMagick a lot more in <a href="ch14.xhtml#ch14">Chapter 14</a>! You may not have this command by default on your OS X system, but by using a package manager like <span class="literal">brew</span>, you can install it with a single command (<span class="literal">brew install imagemagick</span>).</p>&#13;
<h4 class="h4" id="ch11lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Because this code is designed to run stealthily in the background, the basic invocation is easy:</p>&#13;
<pre class="programs">$ <span class="codestrong">screencapture2 &amp;</span>&#13;
$</pre>&#13;
<p class="indent">That’s all there is to it. Easy. As an example, to specify how many shots to take (30) and when to take them (every 5 seconds), you could start the <span class="literal">screencapture2</span> script like this:</p>&#13;
<pre class="programs">$ <span class="codestrong">screencapture2 -f 5 -m 30 &amp;</span>&#13;
$</pre>&#13;
<h4 class="h4" id="ch11lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Running the script results in zero output, but new files do show up, as shown in <a href="ch11.xhtml#ch11ex2">Listing 11-2</a>. (If you specify the <span class="literal">-a</span> animate flag, you’ll get an additional result.)</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -s *gif *jpg</span>&#13;
 4448 animated-captures.gif      4216 capture2.jpg      25728 capture5.jpg&#13;
 4304 capture0.jpg               4680 capture3.jpg      4456 capture6.jpg&#13;
 4296 capture1.jpg               4680 capture4.jpg</pre>&#13;
<p class="listcap"><a id="ch11ex2"/><em>Listing 11-2: The images of a screen that was captured over a period of time by</em> <span class="literal"><em>screencapture2</em></span></p>&#13;
<h4 class="h4" id="ch11lev2sec05"><span epub:type="pagebreak" id="page_266"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">For a long-term screen-monitoring tool, you’ll want to find some means of checking when the screen actually changes so you’re not wasting hard drive space with uninteresting screenshots. There are third-party solutions that should allow <span class="literal">screencapture</span> to run for much longer periods, saving the history of when the screen actually changes rather than dozens—or hundreds—of copies of the same unchanged screen. (Note that if you have a clock display on your screen, every single screen capture will be slightly different, making it much harder to avoid this problem!)</p>&#13;
<p class="indent">With this capability, you could have “monitor ON” and “monitor OFF” as a wrapper that starts the capture sequence and analyzes whether any of the images differ from the first capture. But if you were using this script’s GIFs to create an online training tutorial, you might use finer-grained controls to set the length of capture, using that period of time as a command line argument.</p>&#13;
<h3 class="h3" id="ch11lev1sec02"><strong>#80 Setting the Terminal Title Dynamically</strong></h3>&#13;
<p class="noindenta"><a href="ch11.xhtml#ch11ex3">Listing 11-3</a> is a fun little script for OS X users who like to work in the Terminal application. Instead of having to use the <strong>Terminal</strong> <img src="../images/common3.jpg" alt="image"/> <strong>Preferences</strong> <img src="../images/common3.jpg" alt="image"/> <strong>Profiles</strong> <img src="../images/common3.jpg" alt="image"/> <strong>Window</strong> dialog to set or change the window title, you can use this script to change it whenever you like. In this example, we’ll make the Terminal window’s title just a bit more useful by including the present working directory in it.</p>&#13;
<h4 class="h4" id="ch11lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # titleterm--Tells the OS X Terminal application to change its title&#13;
   #   to the value specified as an argument to this succinct script&#13;
&#13;
   if [ $# -eq 0 ]; then&#13;
     echo "Usage: $0 title" &gt;&amp;2&#13;
     exit 1&#13;
   else&#13;
<span class="ent">➊</span>   echo -e "\033]0;$@\007"&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch11ex3"/><em>Listing 11-3: The</em> <span class="literal"><em>titleterm</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch11lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The Terminal application has a variety of secret escape codes that it understands, and the <span class="literal">titleterm</span> script sends a sequence of <span class="literal">ESC ] 0; title BEL</span> <span class="ent">➊</span>, which changes the title to the specified value.</p>&#13;
<h4 class="h4" id="ch11lev2sec08"><span epub:type="pagebreak" id="page_267"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To change the title of the Terminal window, simply enter the new title you desire as the argument to <span class="literal">titleterm</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">There’s no apparent output from the command, as <a href="ch11.xhtml#ch11ex4">Listing 11-4</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">titleterm $(pwd</span>)&#13;
$</pre>&#13;
<p class="listcap"><a id="ch11ex4"/><em>Listing 11-4: Running the</em> <span class="literal"><em>titleterm</em></span> <em>script to set the terminal title to that of the current directory</em></p>&#13;
<p class="indent">However, it instantly changes the title of the Terminal window to the present working directory.</p>&#13;
<h4 class="h4" id="ch11lev2sec10"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">With one small addition to your login script (<em>.bash_profile</em> or something else, depending on what login shell you have), you can automatically have the Terminal window title always show the current working directory. To make this code show your current working directory, for example, you can use this at <span class="literal">tcsh</span>:</p>&#13;
<pre class="programs">alias precmd 'titleterm "$PWD"'                      [tcsh]</pre>&#13;
<p class="indent">Or this at <span class="literal">bash</span>:</p>&#13;
<pre class="programs">export PROMPT_COMMAND="titleterm \"\$PWD\""          [bash]</pre>&#13;
<p class="indent">Just drop one of the commands above into your login script, and starting the next time you open up a Terminal window, you’ll find that your window title changes each time you move into a new directory. Darn helpful.</p>&#13;
<h3 class="h3" id="ch11lev1sec03"><strong>#81 Producing Summary Listings of iTunes Libraries</strong></h3>&#13;
<p class="noindenta">If you’ve used iTunes for any length of time, you’re sure to have a massive list of music, audiobooks, movies, and TV shows. Unfortunately, for all its wonderful capabilities, iTunes doesn’t have an easy way to export a list of your music in a succinct and easy-to-read format. Fortunately, it’s not hard to write a script that offers this functionality, as <a href="ch11.xhtml#ch11ex5">Listing 11-5</a> shows. This script does rely on the “Share iTunes XML with other applications” feature of iTunes being enabled, so before running this script, ensure that it’s enabled in the iTunes preferences.</p>&#13;
<h4 class="h4" id="ch11lev2sec11"><span epub:type="pagebreak" id="page_268"/><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # ituneslist--Lists your iTunes library in a succinct and attractive&#13;
   #   manner, suitable for sharing with others, or for synchronizing&#13;
   #   (with diff) iTunes libraries on different computers and laptops&#13;
&#13;
   itunehome="$HOME/Music/iTunes"&#13;
   ituneconfig="$itunehome/iTunes Music Library.xml"&#13;
&#13;
<span class="ent">➊</span> musiclib="/$(grep '&gt;Music Folder&lt;' "$ituneconfig" | cut -d/ -f5- | \&#13;
     cut -d\&lt; -f1 | sed 's/%20/ /g')"&#13;
&#13;
   echo "Your library is at $musiclib"&#13;
&#13;
   if [ ! -d "$musiclib" ] ; then&#13;
     echo "$0: Confused: Music library $musiclib isn't a directory?" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   exec find "$musiclib" -type d -mindepth 2 -maxdepth 2 \! -name '.*' -print \&#13;
     | sed "s|$musiclib/||"</pre>&#13;
<p class="listcap"><a id="ch11ex5"/><em>Listing 11-5: The</em> <span class="literal"><em>ituneslist</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch11lev2sec12"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Like many modern computer applications, iTunes expects its music library to be in a standard location—in this case <em>~/Music/iTunes/iTunes Media/</em>— but allows you to move it elsewhere if you want. The script needs to be able to ascertain the different location, and that’s done by extracting the <span class="literal">Music Folder</span> field value from the iTunes preferences file. That’s what the pipe at <span class="ent">➊</span> accomplishes.</p>&#13;
<p class="indent">The preferences file (<span class="literal">$ituneconfig</span>) is an XML data file, so some chopping is necessary to identify the exact <span class="literal">Music Folder</span> field value. Here’s what the <span class="literal">iTunes Media</span> value in Dave’s iTunes config file looks like:</p>&#13;
<pre class="programs">file://localhost/Users/taylor/Music/iTunes/iTunes %20Media/</pre>&#13;
<p class="indent">The <span class="literal">iTunes Media</span> value is actually stored as a fully qualified URL, interestingly enough, so we need to chop off the <em>file://localhost/</em> prefix. This is the job of the first <span class="literal">cut</span> command. Finally, because many directories in OS X include spaces, and because the <span class="literal">Music Folder</span> field is saved as a URL, all spaces in that field are mapped to <span class="literal">%20</span> sequences and have to be restored to spaces by the <span class="literal">sed</span> invocation before proceeding.</p>&#13;
<p class="indent">With the <span class="literal">Music Folder</span> name determined, it’s now easy to generate music lists on two Mac systems and then use the <span class="literal">diff</span> command to compare them, making it a breeze to see which albums are unique to one or the other system and perhaps to sync them up.</p>&#13;
<h4 class="h4" id="ch11lev2sec13"><span epub:type="pagebreak" id="page_269"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">There are no command arguments or flags to this script.</p>&#13;
<h4 class="h4" id="ch11lev2sec14"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">If you have a large music collection, the output from the script can be large. <a href="ch11.xhtml#ch11ex6">Listing 11-6</a> shows the first 15 lines of the output from Dave’s music collection.</p>&#13;
<pre class="programs">$ <span class="codestrong">ituneslist | head -15</span>&#13;
Your library is at /Users/taylor/Music/iTunes/iTunes Media/&#13;
Audiobooks/Andy Weir&#13;
Audiobooks/Barbara W. Tuchman&#13;
Audiobooks/Bill Bryson&#13;
Audiobooks/Douglas Preston&#13;
Audiobooks/Marc Seifer&#13;
Audiobooks/Paul McGann&#13;
Audiobooks/Robert Louis Stevenson&#13;
iPod Games/Klondike&#13;
Movies/47 Ronin (2013)&#13;
Movies/Mad Max (1979)&#13;
Movies/Star Trek Into Darkness (2013)&#13;
Movies/The Avengers (2012)&#13;
Movies/The Expendables 2 (2012)&#13;
Movies/The Hobbit The Desolation of Smaug (2013)</pre>&#13;
<p class="listcap"><a id="ch11ex6"/><em>Listing 11-6: Running the</em> <span class="literal"><em>ituneslist</em></span> <em>script to print the top items in an iTunes collection</em></p>&#13;
<h4 class="h4" id="ch11lev2sec15"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">All right, this isn’t about hacking the script per se, but because the iTunes library directory is saved as a fully qualified URL, it would be interesting to experiment with having a web-accessible iTunes directory and then using the URL of that directory as the <span class="literal">Music Folder</span> value in the XML file. . . .</p>&#13;
<h3 class="h3" id="ch11lev1sec04"><strong>#82 Fixing the open Command</strong></h3>&#13;
<p class="noindenta">One neat innovation with OS X is the addition of the <span class="literal">open</span> command, which allows you to easily launch the appropriate application for just about any type of file, whether it’s a graphics image, a PDF document, or an Excel spreadsheet. The problem with <span class="literal">open</span> is that it’s a bit quirky. If you want it to launch a named application, you have to include the <span class="literal">-a</span> flag. And if you don’t specify the exact application name, it will complain and fail. This is a perfect job for a wrapper script like the one in <a href="ch11.xhtml#ch11ex7">Listing 11-7</a>.</p>&#13;
<h4 class="h4" id="ch11lev2sec16"><span epub:type="pagebreak" id="page_270"/><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # open2--A smart wrapper for the cool OS X 'open' command&#13;
   #   to make it even more useful. By default, 'open' launches the&#13;
   #   appropriate application for a specified file or directory&#13;
   #   based on the Aqua bindings, and it has a limited ability to&#13;
   #   launch applications if they're in the /Applications dir.&#13;
&#13;
   #   First, whatever argument we're given, try it directly.&#13;
&#13;
&#13;
<span class="ent">➊</span> if ! open "$@" &gt;/dev/null 2&gt;&amp;1 ; then&#13;
     if ! open -a "$@" &gt;/dev/null 2&gt;&amp;1 ; then&#13;
&#13;
       # More than one arg? Don't know how to deal with it--quit.&#13;
       if [ $# -gt 1 ] ; then&#13;
         echo "open: More than one program not supported" &gt;&amp;2&#13;
         exit 1&#13;
       else&#13;
<span class="ent">➋</span>         case $(echo $1 | tr '[:upper:]' '[:lower:]') in&#13;
           activ*|cpu   ) app="Activity Monitor"           ;;&#13;
           addr*        ) app="Address Book"               ;;&#13;
           chat         ) app="Messages"                   ;;&#13;
           dvd          ) app="DVD Player"                 ;;&#13;
           excel        ) app="Microsoft Excel"            ;;&#13;
           info*        ) app="System Information"         ;;&#13;
           prefs        ) app="System Preferences"         ;;&#13;
           qt|quicktime ) app="QuickTime Player"           ;;&#13;
           word         ) app="Microsoft Word"             ;;&#13;
           *            ) echo "open: Don't know what to do with $1" &gt;&amp;2&#13;
               exit 1&#13;
         esac&#13;
         echo "You asked for $1 but I think you mean $app." &gt;&amp;2&#13;
         open -a "$app"&#13;
       fi&#13;
     fi&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch11ex7"/><em>Listing 11-7: The</em> <span class="literal"><em>open2</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch11lev2sec17"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script revolves around the zero and nonzero return codes, with the <span class="literal">open</span> program having a zero return code upon success and a nonzero return code upon failure <span class="ent">➊</span>.</p>&#13;
<p class="indent">If the supplied argument is not a filename, the first conditional fails, and the script tests whether the supplied argument is a valid application name by adding <span class="literal">a</span>. If the second conditional fails, the script uses a <span class="literal">case</span> statement <span class="ent">➋</span> to test for common nicknames that people use to refer to popular applications.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_271"/>It even offers a friendly message when it matches a nickname, just before launching the named application.</p>&#13;
<pre class="programs">$ <span class="codestrong">open2 excel</span>&#13;
You asked for excel but I think you mean Microsoft Excel.</pre>&#13;
<h4 class="h4" id="ch11lev2sec18"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">The <span class="literal">open2</span> script expects one or more filenames or application names to be specified on the command line.</p>&#13;
<h4 class="h4" id="ch11lev2sec19"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Without this wrapper, an attempt to open the application Microsoft Word fails.</p>&#13;
<pre class="programs">$ <span class="codestrong">open "Microsoft Word</span>"&#13;
The file /Users/taylor/Desktop//Microsoft Word does not exist.</pre>&#13;
<p class="indent">Rather a scary error message, though it occurred only because the user did not supply the <span class="literal">-a</span> flag. The same invocation with the <span class="literal">open2</span> script shows that it is no longer necessary to remember the <span class="literal">-a</span> flag:</p>&#13;
<pre class="programs">$ <span class="codestrong">open2 "Microsoft Word"</span>&#13;
$</pre>&#13;
<p class="indent">No output is good: the application launched and ready to use. In addition, the series of nicknames for common OS X applications means that while <span class="literal">open -a word</span> definitely won’t work, <span class="literal">open2 word</span> works just fine.</p>&#13;
<h4 class="h4" id="ch11lev2sec20"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">This script could be considerably more useful if the nickname list were tailored to your specific needs or the needs of your user community. That should be easily accomplished!<span epub:type="pagebreak" id="page_272"/></p>&#13;
</body></html>