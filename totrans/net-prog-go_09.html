<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_141" title="141"/>7</span><br/>&#13;
<span class="ChapterTitle">Unix Domain Sockets</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">So far in this book, we’ve discussed communications between nodes on a network. But not all network programming occurs exclusively between separate nodes. Your applications may sometimes need to communicate with services, such as a database, hosted on the same node.</p>&#13;
<p>One way to connect your application to a database running on the same system would be to send data to the node’s IP address or localhost address—commonly 127.0.0.1—and the database’s port number. However, there’s another way: using Unix domain sockets. The <em>Unix domain socket</em> is a communication method that uses the filesystem to determine a packet’s destination address, allowing services running on the same node to exchange data with one another, a process known as <em>inter-process communication (IPC)</em>. </p>&#13;
<p>This chapter first defines exactly what Unix domain sockets are and how you can control read and write access to them. Next, you’ll explore the three types of Unix domain sockets available through Go’s <code>net</code> package and write <span epub:type="pagebreak" id="Page_142" title="142"/>a simple echo server in each of them. Finally, you’ll write a service that uses Unix domain sockets to authenticate clients based on their user and group ID information.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>Not all operating systems support the three types of Unix domain sockets. This chapter uses build constraints and special filename suffixes to identify the target platforms for each code listing.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="h1-500884c07-0001">What Are Unix Domain Sockets?</h2>&#13;
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, I defined a network socket as an IP address and port number. Socket addressing allows individual services on the same node, at the same IP address, to listen for incoming traffic. To illustrate the importance of socket addressing, just imagine how inefficient having a single phone line at a large corporation would be. If you wanted to speak to someone, you’d best hope the phone wasn’t already in use. That’s why, to alleviate the congestion, most corporations assign an extension number to each employee. This allows you to contact the person you want to speak to by dialing the company’s phone number (which is like the node’s IP address) followed by the employee’s extension (which is like the port number). Just as phone numbers and extensions allow you to individually call every single person at a corporation, the IP address and port number of a socket address allow you to communicate with every single service listening to each socket address on a node.</p>&#13;
<p><em>Unix domain sockets</em> apply the socket-addressing principle to the filesystem: each Unix domain socket has an associated file on the filesystem, which corresponds to a network socket’s IP address and port number. You can communicate with a service listening to the socket by reading from and writing to this file. Likewise, you can leverage the filesystem’s ownership and permissions to control read and write access to the socket. Unix domain sockets increase efficiency by bypassing the operating system’s network stack, eliminating the overhead of traffic routing. For the same reasons, you won’t need to worry about fragmentation or packet ordering when using Unix domain sockets. If you choose to forgo Unix domain sockets and exclusively use network sockets when communicating with local services (for example, to connect your application to a local database, a memory cache, and so on), you ignore significant security advantages and performance gains.</p>&#13;
<p>Though this system brings distinct advantages, it comes with a caveat: Unix domain sockets are local to the node using them, so you cannot use them to communicate with other nodes, as you can with network sockets. Therefore, Unix domain sockets may not be a good fit if you anticipate moving a service to another node or require maximum portability for your application. To maintain communication, you’d have to first migrate to a network socket. </p>&#13;
<h2 id="h1-500884c07-0002"><span epub:type="pagebreak" id="Page_143" title="143"/>Binding to Unix Domain Socket Files</h2>&#13;
<p class="BodyFirst">A Unix domain socket file is created when your code attempts to bind to an unused Unix domain socket address by using the <code>net.Listen</code>,<code> net.ListenUnix</code>, or <code>net.ListenPacket</code> functions. If the socket file for that address already exists, the operating system will return an error indicating that the address is in use. In most cases, simply removing the existing Unix domain socket file is enough to clear up the error. However, you should first make sure that the socket file exists not because a process is currently using that address but because you didn’t properly clean up the file from a defunct process.</p>&#13;
<p>If you wish to reuse a socket file, use the <code>net</code> package’s <code>FileListener</code> function to bind to an existing socket file. This function is beyond the scope of this book, but I encourage you to read its documentation.</p>&#13;
<h3 id="h2-500884c07-0001">Changing a Socket File’s Ownership and Permissions</h3>&#13;
<p class="BodyFirst">Once a service binds to the socket file, you can use Go’s <code>os</code> package to modify the file’s ownership and read/write permissions. Specifically, the <code>os.Chown</code> function allows you to modify the user and group that owns the file. Windows does not support this function, though this function is supported on Windows Subsystem for Linux (WSL), Linux, and macOS, among others outside the scope of this book. We’ll look at the lines of code that change file ownership and permissions now but cover them in context later in this chapter.</p>&#13;
<p>The following line instructs the operating system to update the user and group ownership of the given file:</p>&#13;
<pre><code>err := os.Chown("/path/to/socket/file", <span class="CodeAnnotation">1</span>-1, <span class="CodeAnnotation">2</span>100)</code></pre>&#13;
<p>The <code>os.Chown</code> function accepts three arguments: the path to a file, the user ID of the owner <span class="CodeAnnotation">1</span>, and the group ID of the owner <span class="CodeAnnotation">2</span>. A user or group ID of <code>-1</code> tells Go you want to maintain the current user or group ID. In this example, you want to maintain the socket file’s current user ID but set its group ID to 100, which here is assumed to be a valid group ID in the <em>/etc/group</em> file.</p>&#13;
<p>Go’s <code>os/user</code> package includes functions to help you translate between user and group names and IDs. For example, this line of code uses the <code>LookupGroup</code> function to find the group ID for the <em>users</em> group: </p>&#13;
<pre><code>grp, err := user.LookupGroup("users")</code></pre>&#13;
<p>Provided <code>user.LookupGroup</code> did not return an error, the <code>grp</code> variable’s <code>Gid</code> field contains the group ID for the <em>users</em> group.</p>&#13;
<p>The <code>os.Chmod</code> function changes the file’s mode and the numeric notation of Unix-compatible permission bits. These bits inform the operating system of the file’s mode, the file’s user read/write/execute permissions, the file’s group read/write/execute permissions, and the read/write/execute permissions for any user not in the file’s group:</p>&#13;
<pre><code>err := os.Chmod("/path/to/socket/file", os.ModeSocket|0660)</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_144" title="144"/>The <code>os.Chmod</code> function accepts a file path and an <code>os.FileMode</code>, which represents the file mode, the user permissions, the group permissions, and non-group user permissions. Since you’re dealing with a socket file, you should always set the <code>os.ModeSocket</code> mode on the file. You do that using a bitwise OR between the <code>os.ModeSocket</code> and the numeric file permission notation. Here, you’re passing the octal <code>0660</code>, which gives the user and group read and write access but prevents anyone outside the group from reading or writing to the socket. You can read more about <code>os.FileMode</code> in Go’s documentation at <a class="LinkURL" href="https://golang.org/pkg/os/#FileMode">https://golang.org/pkg/os/#FileMode</a> and familiarize yourself with filesystem permissions numeric notation at <a class="LinkURL" href="https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation">https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation</a>.</p>&#13;
<h3 id="h2-500884c07-0002">Understanding Unix Domain Socket Types</h3>&#13;
<p class="BodyFirst">There are three types of Unix domain sockets: <em>streaming sockets</em>, which operate like TCP; <em>datagram sockets</em>, which operate like UDP; and <em>sequence packet sockets</em>, which combine elements of both. Go designates these types as <code>unix</code>, <code>unixgram</code>, and<em> </em><code>unixpacket</code>, respectively. In this section, we’ll write echo servers that work with each of these types.</p>&#13;
<p>The <code>net.Conn</code> interface allows you to write code once and use it across multiple network types. It abstracts many of the differences between the network sockets used by TCP and UDP and Unix domain sockets, which means that you can take code written for communication over TCP, for example, and use it over a Unix domain socket by simply changing the address and network type. </p>&#13;
<h4 id="h3-500884c07-0001">The unix Streaming Socket</h4>&#13;
<p class="BodyFirst">The streaming Unix domain socket works like TCP without the overhead associated with TCP’s acknowledgments, checksums, flow control, and so on. The operating system is responsible for implementing the streaming inter-process communication over Unix domain sockets in lieu of TCP.</p>&#13;
<p>To illustrate this type of Unix domain socket, let’s write a function that creates a generic stream-based echo server (<a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a>). You’ll be able to use this function with any streaming network type. That means you can use it to create a TCP connection to a different node, but you’ll also be able to use it with the <code>unix</code> type to communicate with a Unix socket address. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>Linux, macOS, and Windows all support the <var>unix</var> network type. </p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<pre><code>package echo&#13;
&#13;
import (&#13;
    "context"&#13;
    "net"&#13;
)&#13;
&#13;
func <span class="CodeAnnotation">1</span>streamingEchoServer(ctx context.Context, network string,&#13;
<span epub:type="pagebreak" id="Page_145" title="145"/>    addr string) (net.Addr, error) {&#13;
    s, err := <span class="CodeAnnotation">2</span>net.Listen(network, addr)&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: Creating the streaming echo server function (<em>echo.go</em>)</p>&#13;
<p>The <code>streamingEchoServer</code> function <span class="CodeAnnotation">1</span> accepts a string representing a stream-based network and a string representing an address and returns an address object and an <code>error</code> interface. You should recognize these arguments and return types from earlier in the book. </p>&#13;
<p>Since you’ve made the echo server a bit more generic by accepting a context, a network string, and an address string, you can pass it any stream-based network type, such as <code>tcp</code>, <code>unix</code>, or <code>unixpacket</code>. The address would then need to correspond to the network type. The context is used for signaling the server to close. If the network type is <code>tcp</code>, the address string must be an IP address and port combination, such as 127.0.0.1:80. If the network type is <code>unix</code> or <code>unixpacket</code>, the address must be the path to a nonexistent file. The socket file will be created when the echo server binds to it <span class="CodeAnnotation">2</span>. Then the server will start listening for incoming connections.</p>&#13;
<p><a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a> completes the streaming echo server implementation.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    go func() {&#13;
        go func() {&#13;
          <span class="CodeAnnotation">1</span>&lt;-ctx.Done()&#13;
            _ = s.Close()&#13;
        }()&#13;
&#13;
        for {&#13;
            conn, err := <span class="CodeAnnotation">2</span>s.Accept()&#13;
            if err != nil {&#13;
                return&#13;
            }&#13;
&#13;
            go func() {&#13;
                defer func() { _ = conn.Close() }()&#13;
&#13;
                for {&#13;
                    buf := make([]byte, 1024)&#13;
                    n, err := <span class="CodeAnnotation">3</span>conn.Read(buf)&#13;
                    if err != nil {&#13;
                        return&#13;
                    }&#13;
&#13;
                    _, err = <span class="CodeAnnotation">4</span>conn.Write(buf[:n])&#13;
                    if err != nil {&#13;
                        return&#13;
                    }&#13;
                }&#13;
            }()&#13;
<span epub:type="pagebreak" id="Page_146" title="146"/>        }&#13;
    }()&#13;
&#13;
    return s.Addr(), nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: A stream-based echo server (<em>echo.go</em>)</p>&#13;
<p>A listener created with either <code>net.Listen</code> or <code>net.ListenUnix</code> will automatically remove the socket file when the listener exits. You can modify this behavior with <code>net.UnixListener</code>’s <code>SetUnlinkOnClose</code> method, though the default is ideal for most use cases. Unix domain socket files created with <code>net.ListenPacket</code> won’t be automatically removed when the listener exits, as you’ll see a little later in this chapter.</p>&#13;
<p>As before, you spin off the echo server in its own goroutine so it can asynchronously accept connections. Once the server accepts a connection <span class="CodeAnnotation">2</span>, you start a goroutine to echo incoming messages. Since you’re using the <code>net.Conn</code> interface, you can use its <code>Read</code><span class="CodeAnnotation">3</span> and <code>Write</code><span class="CodeAnnotation">4</span> methods to communicate with the client no matter whether the server is communicating over a network socket or a Unix domain socket. Once the caller cancels the context <span class="CodeAnnotation">1</span>, the server closes.</p>&#13;
<p><a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a> tests the streaming echo server over a Unix domain socket using the <code>unix</code> network type.</p>&#13;
<pre><code>package echo&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "context"&#13;
    "fmt"&#13;
    "io/ioutil"&#13;
    "net"&#13;
    "os"&#13;
    "path/filepath"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestEchoServerUnix(t *testing.T) {&#13;
    dir, err := <span class="CodeAnnotation">1</span>ioutil.TempDir("", "echo_unix")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer func() {&#13;
        if rErr := <span class="CodeAnnotation">2</span>os.RemoveAll(dir); rErr != nil {&#13;
            t.Error(rErr)&#13;
        }&#13;
    }()&#13;
&#13;
    ctx, cancel := context.WithCancel(context.Background())&#13;
    <span class="CodeAnnotationHang">3</span> socket := filepath.Join(dir, fmt.Sprintf("%d.sock", os.Getpid()))&#13;
    rAddr, err := streamingEchoServer(ctx, "unix", socket)&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="Page_147" title="147"/>        t.Fatal(err)&#13;
    }&#13;
&#13;
    err = <span class="CodeAnnotation">4</span>os.Chmod(socket, os.ModeSocket|0666)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: Setting up an echo server test over a <var>unix</var> domain socket (<em>echo_test.go</em>)</p>&#13;
<p>You create a subdirectory in your operating system’s temporary directory named <em>echo_unix</em><span class="CodeAnnotation">1</span> that will contain the echo server’s socket file. The deferred call to <code>os.RemoveAll</code> cleans up after the server <span class="CodeAnnotation">2</span> by removing your temporary subdirectory when the test completes. You pass a socket file named <em>#.sock</em><span class="CodeAnnotation">3</span>, where <em>#</em> is the server’s process ID, saved in the temporary subdirectory (<em>/tmp/echo_unix/123.sock</em>) to the <code>streamingEchoServer</code> function. Finally, you make sure everyone has read and write access to the socket <span class="CodeAnnotation">4</span>.</p>&#13;
<p><a href="#listing7-4" id="listinganchor7-4">Listing 7-4</a> makes a connection to the streaming echo server and sends a test.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    conn, err := net.Dial("unix", <span class="CodeAnnotation">1</span>rAddr.String())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer func() { _ = conn.Close() }()&#13;
&#13;
    msg := []byte("ping")&#13;
    <span class="CodeAnnotationHang">2</span> for i := 0; i &lt; 3; i++ { // write 3 "ping" messages&#13;
        _, err = conn.Write(msg)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
    }&#13;
&#13;
    buf := make([]byte, 1024)&#13;
    n, err := <span class="CodeAnnotation">3</span>conn.Read(buf) // read once from the server&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    expected := <span class="CodeAnnotation">4</span>bytes.Repeat(msg, 3)&#13;
    if !bytes.Equal(expected, buf[:n]) {&#13;
        t.Fatalf("expected reply %q; actual reply %q", expected,&#13;
            buf[:n])&#13;
    }&#13;
&#13;
    _ = closer.Close()&#13;
    &lt;-done&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: Streaming data over a Unix domain socket (<em>echo_test.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_148" title="148"/>You dial the server by using the familiar <code>net.Dial</code> function. It accepts the <code>unix </code>network type and the server’s address, which is the full path to the Unix domain socket file <span class="CodeAnnotation">1</span>.</p>&#13;
<p>You write three ping messages to the echo server before reading the first response <span class="CodeAnnotation">2</span>. The reasoning for sending three separate pings will be clear when you explore the <code>unixpacket</code> type later in this chapter. When you read the first response <span class="CodeAnnotation">3</span> with a buffer large enough to store the three messages you just sent, you receive all three ping messages <span class="CodeAnnotation">4</span> in a single read as the string <code>pingpingping</code>. Remember, a stream-based connection does not delineate messages. The onus is on you to determine where one message stops and another one starts when you read a series of bytes from the server.</p>&#13;
<h4 id="h3-500884c07-0002">The unixgram Datagram Socket</h4>&#13;
<p class="BodyFirst">Next let’s create an echo server that will communicate using datagram-based network types, such as <code>udp</code> and <code>unixgram</code>. Whether you’re communicating over UDP or a <code>unixgram</code> socket, the server you’ll write looks essentially the same. The difference is, you will need to clean up the socket file with a <code>unixgram</code> listener, as you’ll see in <a href="#listing7-5" id="listinganchor7-5">Listing 7-5</a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>Windows and Windows Subsystem for Linux do not support <var>unixgram</var> domain sockets.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func datagramEchoServer(ctx context.Context, network string,&#13;
    addr string) (net.Addr, error) {&#13;
    s, err := <span class="CodeAnnotation">1</span>net.ListenPacket(network, addr)&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    go func() {&#13;
        go func() {&#13;
            &lt;-ctx.Done()&#13;
            _ = s.Close()&#13;
            if network == "unixgram" {&#13;
                _ = <span class="CodeAnnotation">2</span>os.Remove(addr)&#13;
            }&#13;
        }()&#13;
&#13;
        buf := make([]byte, 1024)&#13;
        for {&#13;
            n, clientAddr, err := s.ReadFrom(buf)&#13;
            if err != nil {&#13;
                return&#13;
            }&#13;
&#13;
            _, err = s.WriteTo(buf[:n], clientAddr)&#13;
            if err != nil {&#13;
                return&#13;
<span epub:type="pagebreak" id="Page_149" title="149"/>            }&#13;
        }&#13;
    }()&#13;
&#13;
    return s.LocalAddr(), nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-5">Listing 7-5</a>: A datagram-based echo server (<em>echo.go</em>)</p>&#13;
<p>You call <code>net.ListenPacket</code><span class="CodeAnnotation">1</span>, which returns a <code>net.PacketConn</code>. As mentioned earlier in this chapter, since you don’t use <code>net.Listen</code> or <code>net.ListenUnix</code> to create the listener, Go won’t clean up the socket file for you when your server is done with it. You must make sure you remove the socket file yourself, <span class="CodeAnnotation">2</span> or subsequent attempts to bind to the existing socket file will fail.</p>&#13;
<p>Since the <code>unixgram</code> network type doesn’t work on Windows, <a href="#listing7-6" id="listinganchor7-6">Listing 7-6</a> uses a build constraint to make sure this code does not run on Windows and then imports the necessary packages. </p>&#13;
<pre><code>// +build darwin linux&#13;
&#13;
package echo&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "context"&#13;
    "fmt"&#13;
    "io/ioutil"&#13;
    "net"&#13;
    "os"&#13;
    "path/filepath"&#13;
    "testing"&#13;
)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-6">Listing 7-6</a>: Building constraints and imports for macOS and Linux (<em>echo_posix_test.go</em>)</p>&#13;
<p>The build constraint tells Go to include this code only if it’s running on a macOS or Linux operating system. Granted, Go supports other operating systems, many of which may offer <code>unixgram</code> support, that are outside the scope of this book. This build constraint does not take those other operating systems into account, and I encourage you to test this code on your target operating system.</p>&#13;
<p>With the build constraint in place, you can add the test in <a href="#listing7-7" id="listinganchor7-7">Listing 7-7</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func TestEchoServerUnixDatagram(t *testing.T) {&#13;
    dir, err := ioutil.TempDir("", "echo_unixgram")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer func() {&#13;
        if rErr := os.RemoveAll(dir); rErr != nil {&#13;
            t.Error(rErr)&#13;
<span epub:type="pagebreak" id="Page_150" title="150"/>        }&#13;
    }()&#13;
&#13;
    ctx, cancel := context.WithCancel(context.Background())&#13;
    <span class="CodeAnnotationHang">1</span> sSocket := filepath.Join(dir, fmt.Sprintf("s%d.sock", os.Getpid()))&#13;
    serverAddr, err := datagramEchoServer(ctx, "unixgram", sSocket)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer cancel()&#13;
&#13;
    err = os.Chmod(sSocket, os.ModeSocket|0622)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-7">Listing 7-7</a>: Instantiating the datagram-based echo server (<em>echo_posix_test.go</em>)</p>&#13;
<p>Just as with UDP connections, both the server and the client must bind to an address so they can send and receive datagrams. The server has its own socket file <span class="CodeAnnotation">1</span> that is separate from the client’s socket file in <a href="#listing7-8" id="listinganchor7-8">Listing 7-8</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    <span class="CodeAnnotationHang">1</span> cSocket := filepath.Join(dir, fmt.Sprintf("c%d.sock", os.Getpid()))&#13;
    client, err := net.ListenPacket("unixgram", cSocket)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    <span class="CodeAnnotationHang">2</span> defer func() { _ = client.Close() }()&#13;
&#13;
    err = <span class="CodeAnnotation">3</span>os.Chmod(cSocket, os.ModeSocket|0622)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-8">Listing 7-8</a>: Instantiating the datagram-based client (<em>echo_posix_test.go</em>)</p>&#13;
<p>The call to <code>os.Remove</code> in <a href="#listing7-5">Listing 7-5</a>’s <code>datagramEchoServer</code> function cleans up the socket file when the server closes. The client has some additional housecleaning, so you make the client clean up its own socket file <span class="CodeAnnotation">1</span> when it’s done listening to it. Thankfully, this is taken care of for you by the call to <code>os.RemoveAll</code> to remove your temporary subdirectory in <a href="#listing7-7">Listing 7-7</a>. Otherwise, you would need to add a call to <code>os.Remove</code> to remove the client’s socket file in the <code>defer</code><span class="CodeAnnotation">2</span>. Also, the server should be able to write to the client’s socket file as well as its own socket file, or the server won’t be able to reply to messages. In this example, you set very permissive permissions so all users can write to the socket <span class="CodeAnnotation">3</span>.</p>&#13;
<p>Now that the server and client are instantiated, <a href="#listing7-9" id="listinganchor7-9">Listing 7-9</a> tests the difference between a streaming echo server and a datagram echo server.</p>&#13;
<span epub:type="pagebreak" id="Page_151" title="151"/><pre><code><var>--snip--</var>&#13;
&#13;
    msg := []byte("ping")&#13;
    for i := 0; i &lt; 3; i++ { // write 3 "ping" messages&#13;
        _, err = <span class="CodeAnnotation">1</span>client.WriteTo(msg, serverAddr)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
    }&#13;
&#13;
    buf := make([]byte, 1024)&#13;
    for i := 0; i &lt; 3; i++ { // read 3 "ping" messages&#13;
        n, addr, err := <span class="CodeAnnotation">2</span>client.ReadFrom(buf)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
&#13;
        if addr.String() != serverAddr.String() {&#13;
            t.Fatalf("received reply from %q instead of %q", &#13;
                addr, serverAddr)&#13;
        }&#13;
&#13;
        if !bytes.Equal(msg, buf[:n]) {&#13;
            t.Fatalf("expected reply %q; actual reply %q", msg,&#13;
                buf[:n])&#13;
        }&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-9">Listing 7-9</a>: Using unixgram sockets to echo messages (<em>echo_posix_test.go</em>)</p>&#13;
<p>You write three ping messages to the server <span class="CodeAnnotation">1</span> before reading the first datagram. You then perform three reads <span class="CodeAnnotation">2</span> with a buffer large enough to fit all three ping messages. As expected, <code>unixgram</code> sockets maintain the delineation between messages; you sent three messages and read three replies. Compare this to the <code>unix</code> socket type in Listings 7-3 and 7-4, where you sent three messages and received all three replies with a single read from the connection.</p>&#13;
<h4 id="h3-500884c07-0003">The unixpacket Sequence Packet Socket</h4>&#13;
<p class="BodyFirst">The <em>sequence packet socket</em> type is a hybrid that combines the session-oriented connections and reliability of TCP with the clearly delineated datagrams of UDP. However, sequence packet sockets discard unrequested data in each datagram. If you read 32 bytes of a 50-byte datagram, for example, the operating system discards the 18 unrequested bytes.</p>&#13;
<p>Of the three Unix domain socket types, <code>unixpacket</code> enjoys the least cross-platform support. Coupled with <code>unixpacket</code>’s hybrid behavior and discarding of unrequested data, <code>unix</code> or <code>unixgram</code> are better suited for most applications. You are unlikely to find sequence packet sockets in use over the internet. It was largely used in old X.25 telecommunication networks, some types of financial transactions, and AX.25 used in amateur radio.</p>&#13;
<p><span epub:type="pagebreak" id="Page_152" title="152"/>The test code in <a href="#listing7-10" id="listinganchor7-10">Listing 7-10</a> sets up a demonstration of <code>unixpacket</code> sockets.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>Windows, WSL, and macOS do not support <var>unixpacket</var> domain sockets.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<pre><code>package echo&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "context"&#13;
    "fmt"&#13;
    "io/ioutil"&#13;
    "net"&#13;
    "os"&#13;
    "path/filepath"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestEchoServerUnixPacket(t *testing.T) {&#13;
    dir, err := ioutil.TempDir("", "echo_unixpacket")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer func() {&#13;
        if rErr := os.RemoveAll(dir); rErr != nil {&#13;
            t.Error(rErr)&#13;
        }&#13;
    }()&#13;
&#13;
    ctx, cancel := context.WithCancel(context.Background())&#13;
    socket := filepath.Join(dir, fmt.Sprintf("%d.sock", os.Getpid()))&#13;
    rAddr, err := streamingEchoServer(ctx, "unixpacket", socket)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer cancel()&#13;
&#13;
    err = os.Chmod(socket, os.ModeSocket|0666)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-10">Listing 7-10</a>: Instantiating a packet-based streaming echo server (<em>echo_linux_test.go</em>)</p>&#13;
<p>Notice first that you save this code in a file called <em>echo_linux_test.go. </em>The <em>_linux_test.go</em> suffix is a build constraint informing Go that it should include this file only when tests are invoked on Linux.</p>&#13;
<p><a href="#listing7-11" id="listinganchor7-11">Listing 7-11</a> dials the echo server and sends a series of ping messages.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    conn, err := <span class="CodeAnnotation">1</span>net.Dial("unixpacket", rAddr.String())&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="Page_153" title="153"/>        t.Fatal(err)&#13;
    }&#13;
    defer func() { _ = conn.Close() }()&#13;
&#13;
    msg := []byte("ping")&#13;
    <span class="CodeAnnotationHang">2</span> for i := 0; i &lt; 3; i++ { // write 3 "ping" messages&#13;
        _, err = conn.Write(msg)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
    }&#13;
&#13;
    buf := make([]byte, 1024)&#13;
    <span class="CodeAnnotationHang">3</span> for i := 0; i &lt; 3; i++ { // read 3 times from the server&#13;
        n, err := conn.Read(buf)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
&#13;
        if !bytes.Equal(msg, buf[:n]) {&#13;
            t.Errorf("expected reply %q; actual reply %q", msg, buf[:n])&#13;
        }&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-11">Listing 7-11</a>: Using a <var>unixpacket</var> socket to echo messages (<em>echo_linux_test.go</em>)</p>&#13;
<p>Since <code>unixpacket</code> is session oriented, you use <code>net.Dial</code><span class="CodeAnnotation">1</span> to initiate a connection with the server. You do not simply write to the server’s address, as you would if the network type were datagram based.</p>&#13;
<p>You can see the distinction between the <code>unix</code> and <code>unixpacket</code> socket types by writing three ping messages to the server <span class="CodeAnnotation">2</span> before reading the first reply. Whereas a <code>unix</code> socket type would return all three ping messages with a single read, <code>unixpacket</code> acts just like other datagram-based network types and returns one message for each read operation <span class="CodeAnnotation">3</span>.</p>&#13;
<p><a href="#listing7-12" id="listinganchor7-12">Listing 7-12</a> illustrates how <code>unixpacket</code> discards unrequested data in each datagram.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    for i := 0; i &lt; 3; i++ { // write 3 more "ping" messages&#13;
        _, err = conn.Write(msg)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
    }&#13;
&#13;
    <span class="CodeAnnotationHang">1</span> buf = make([]byte, 2)    // only read the first 2 bytes of each reply&#13;
    for i := 0; i &lt; 3; i++ { // read 3 times from the server&#13;
        n, err := conn.Read(buf)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
&#13;
        if !bytes.Equal(<span class="CodeAnnotation">2</span>msg[:2], buf[:n]) {&#13;
<span epub:type="pagebreak" id="Page_154" title="154"/>            t.Errorf("expected reply %q; actual reply %q", msg[:2],&#13;
                buf[:n])&#13;
        }&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-12">Listing 7-12</a>: Discarding unread bytes (<em>echo_linux_test.go</em>)</p>&#13;
<p>This time around, you reduce your buffer size to 2 bytes <span class="CodeAnnotation">1</span> and read the first 2 bytes of each datagram. If you were using a streaming network type like <code>tcp</code> or <code>unix</code>, you would expect to read <code>pi</code> for the first read and <code>ng</code> for the second read. But <code>unixpacket</code> discards the <code>ng</code> portion of the <code>ping</code> message because you requested only the first 2 bytes—<code>pi</code>. Therefore, you make sure you’re receiving only the first 2 bytes of the datagram with each read <span class="CodeAnnotation">2</span>.</p>&#13;
<h2 id="h1-500884c07-0003">Writing a Service That Authenticates Clients </h2>&#13;
<p class="BodyFirst">On Linux systems, Unix domain sockets allow you to glean details about the process on the other end of a socket—your peer—by receiving the credentials from your peer’s operating system. You can use this information to authenticate your peer on the other side of the Unix domain socket and deny access if the peer’s credentials don’t meet your criteria. For instance, if the user <em>davefromaccounting</em> connects to your administrative service through a Unix domain socket, the peer credentials might indicate that you should deny access; Dave should be crunching numbers, not sending bits to your administrative service.</p>&#13;
<p>You can create a service that allows connections only from specific users or any user in a specific group found in the <em>/etc/groups</em> file. Each named group in the <em>/etc/groups</em> file has a corresponding group ID number. When a client connects to your Unix domain socket, you can request the peer credentials and compare the client’s group ID in the peer credentials to the group ID of any allowed groups. If the client’s group ID matches one of the allowed group IDs, you can consider the client authenticated. Go’s standard library has useful support for working with Linux groups, which you’ll use in <span class="xref" itemid="xref_target_“Writing the Service” on page 156">“Writing the Service” on page 156</span>.</p>&#13;
<h3 id="h2-500884c07-0003">Requesting Peer Credentials</h3>&#13;
<p class="BodyFirst">The process of requesting peer credentials isn’t exactly straightforward. You cannot simply request the peer credentials from the connection object itself. Rather, you need to use the <code>golang.org/x/sys/unix</code> package to request peer credentials from the operating system, which you can retrieve using the following command:</p>&#13;
<pre><code>go get -u golang.org/x/sys/unix</code></pre>&#13;
<p><a href="#listing7-13" id="listinganchor7-13">Listing 7-13</a> shows a function that accepts a Unix domain socket connection and denies access if the peer isn’t a member of specific groups.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<span epub:type="pagebreak" id="Page_155" title="155"/><h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>The code in <a href="#listing7-13">Listings 7-13</a> through <a href="#listing7-16">7-16</a> works on Linux systems only.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<pre><code>package auth&#13;
&#13;
import (&#13;
    "log"&#13;
    "net"&#13;
    "golang.org/x/sys/unix"&#13;
)&#13;
&#13;
func Allowed(conn *net.UnixConn, groups map[string]struct{}) bool {&#13;
    if conn == nil || groups == nil || len(groups) == 0 {&#13;
        return false&#13;
    }&#13;
&#13;
    file, _ := <span class="CodeAnnotation">1</span>conn.File()&#13;
    defer func(){ _ = file.Close() }()&#13;
&#13;
    var (&#13;
        err   error&#13;
        ucred *unix.Ucred&#13;
    )&#13;
&#13;
    for {&#13;
        ucred, err = <span class="CodeAnnotation">2</span>unix.GetsockoptUcred(int(<span class="CodeAnnotation">3</span>file.Fd()), unix.SOL_SOCKET,&#13;
            unix.SO_PEERCRED)&#13;
        if err == unix.EINTR {&#13;
            continue // syscall interrupted, try again&#13;
        }&#13;
        if err != nil {&#13;
            log.Println(err)&#13;
            return false&#13;
        }&#13;
&#13;
        break&#13;
    }&#13;
&#13;
    u, err := <span class="CodeAnnotation">4</span>user.LookupId(string(ucred.Uid))&#13;
    if err != nil {&#13;
        log.Println(err)&#13;
        return false&#13;
    }&#13;
&#13;
    gids, err := <span class="CodeAnnotation">5</span>u.GroupIds()&#13;
    if err != nil {&#13;
        log.Println(err)&#13;
        return false&#13;
    }&#13;
&#13;
    for _, gid := range gids {&#13;
        if _, ok := <span class="CodeAnnotation">6</span>groups[gid]; ok {&#13;
<span epub:type="pagebreak" id="Page_156" title="156"/>            return true&#13;
        }&#13;
    }&#13;
&#13;
    return false&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-13">Listing 7-13</a>: Retrieving the peer credentials for a socket connection (<em>creds/auth/allowed_linux.go</em>)</p>&#13;
<p>To retrieve the peer’s Unix credentials, you first grab the underlying file object from <code>net.UnixConn</code><span class="CodeAnnotation">1</span>, the object that represents your side of the Unix domain socket connection. It’s analogous to <code>net.TCPConn</code> of a TCP connection in Go. Since you need to extract the file descriptor details from the connection, you cannot simply rely on the <code>net.Conn</code> interface that you receive from the listener’s <code>Accept</code> method. Instead, your <code>Allowed</code> function requires the caller to pass in a pointer to the underlying <code>net.UnixConn</code> object, typically returned from the listener’s <code>AcceptUnix</code> method. You’ll see this method in action in the next section.</p>&#13;
<p>You can then pass the file object’s descriptor <span class="CodeAnnotation">3</span>, the protocol-level <code>unix.SOL_SOCKET</code>, and the option name <code>unix.SO_PEERCRED</code> to the <code>unix.GetsockoptUcred</code> function <span class="CodeAnnotation">2</span>. Retrieving socket options from the Linux kernel requires that you specify both the option you want and the level at which the option resides. The <code>unix.SOL_SOCKET</code> tells the Linux kernel you want a socket-level option, as opposed to, for example,<code> unix.SOL_TCP</code>, which indicates TCP-level options. The <code>unix.SO_PEERCRED</code> constant tells the Linux kernel that you want the peer credentials option. If the Linux kernel finds the peer credentials option at the Unix domain socket level, <code>unix.GetsockoptUcred</code> returns a pointer to a valid <code>unix.Ucred</code> object. </p>&#13;
<p>The <code>unix.Ucred</code> object contains the peer’s process, user, and group IDs. You pass the peer’s user ID to the <code>user.LookupId</code> function <span class="CodeAnnotation">4</span>. If successful, you then retrieve a list of group IDs from the user object <span class="CodeAnnotation">5</span>. The user can belong to more than one group, and you want to consider each one for access. Finally, you check each group ID against a map of allowed groups <span class="CodeAnnotation">6</span>. If any one of the peer’s group IDs is in your map, you return <code>true</code>, allowing the peer to connect.</p>&#13;
<p>This example is largely didactic. You can achieve similar results by assigning group ownership to the socket file, as we discussed in <span class="xref" itemid="xref_target_“Changing a Socket File’s Ownership and Permissions” on page 143">“Changing a Socket File’s Ownership and Permissions” on page 143</span>. However, knowledge of group membership could be used for access control and other security decisions within your application.</p>&#13;
<h3 id="h2-500884c07-0004">Writing the Service</h3>&#13;
<p class="BodyFirst">Let’s now use this function in a service that you can run from the command line. This service will accept one or more group names found in the Linux operating system’s <em>/etc/group</em> file as arguments on the command line and begin listening to a Unix domain socket file. The service will allow clients to connect only if they are a member of one of the groups specified on the command line. Clients can then make a Unix domain socket connection to the <span epub:type="pagebreak" id="Page_157" title="157"/>service. The service will retrieve the peer credentials of the client and either allow the client to remain connected, if the client is a member of one of the allowed groups, or immediately disconnect the unauthorized client. The service doesn’t do anything beyond authenticating the client’s group ID.</p>&#13;
<p>In <a href="#listing7-14" id="listinganchor7-14">Listing 7-14</a>, you specify the imports you’ll need and create a meaningful usage message for the service.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "flag"&#13;
    "fmt"&#13;
    "log"&#13;
    "net"&#13;
    "os"&#13;
    "os/signal"&#13;
    "os/user"&#13;
    "path/filepath"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch07/creds/auth"&#13;
)&#13;
&#13;
func init() {&#13;
    flag.Usage = func() {&#13;
        _, _ = fmt.Fprintf(flag.CommandLine.Output(),&#13;
            "Usage:\n\t%s <span class="CodeAnnotation">1</span>&lt;group names&gt;\n", filepath.Base(os.Args[0]))&#13;
        flag.PrintDefaults()&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-14">Listing 7-14</a>: Expecting group names on the command line (<em>creds/creds.go</em>)</p>&#13;
<p>Our application expects a series of group names as arguments <span class="CodeAnnotation">1</span>. You’ll add the group ID for each group name to the map of allowed groups. The code in <a href="#listing7-15" id="listinganchor7-15">Listing 7-15</a> parses these group names.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func parseGroupNames(args []string) map[string]struct{} {&#13;
    groups := make(map[string]struct{})&#13;
&#13;
    for _, arg := range args {&#13;
        grp, err := <span class="CodeAnnotation">1</span>user.LookupGroup(arg)&#13;
        if err != nil {&#13;
            log.Println(err)&#13;
            continue&#13;
        }&#13;
&#13;
        groups[<span class="CodeAnnotation">2</span>grp.Gid] = struct{}{}&#13;
    }&#13;
&#13;
    return groups&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-15">Listing 7-15</a>: Parsing group names into group IDs (<em>creds/creds.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_158" title="158"/>The <code>parseGroupNames</code> function accepts a string slice of group names, retrieves the group information for each group name <span class="CodeAnnotation">1</span>, and inserts each group ID into the <code>groups</code> map <span class="CodeAnnotation">2</span>.</p>&#13;
<p><a href="#listing7-16" id="listinganchor7-16">Listing 7-16</a> ties the last few listings together into a service that you can connect to from the command line.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
&#13;
    groups := parseGroupNames(flag.Args())&#13;
    socket := filepath.Join(os.TempDir(), "creds.sock")&#13;
    addr, err := net.ResolveUnixAddr("unix", socket)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    s, err := net.ListenUnix("unix", addr)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    c := make(chan os.Signal, 1)&#13;
    signal.Notify(c, <span class="CodeAnnotation">1</span>os.Interrupt)&#13;
    <span class="CodeAnnotationHang">2</span> go func() {&#13;
        &lt;-c&#13;
        _ = s.Close()&#13;
    }()&#13;
&#13;
    fmt.Printf("Listening on %s ...\n", socket)&#13;
&#13;
    for {&#13;
        conn, err := <span class="CodeAnnotation">3</span>s.AcceptUnix()&#13;
        if err != nil {&#13;
            break&#13;
        }&#13;
        if <span class="CodeAnnotation">4</span>auth.Allowed(conn, groups) {&#13;
            _, err = conn.Write([]byte("Welcome\n"))&#13;
            if err == nil {&#13;
                // handle the connection in a goroutine here&#13;
                continue&#13;
            }&#13;
        } else {&#13;
            _, err = conn.Write([]byte("Access denied\n"))&#13;
        }&#13;
        if err != nil {&#13;
            log.Println(err)&#13;
        }&#13;
        _ = conn.Close()&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing7-16">Listing 7-16</a>: Authorizing peers based on their credentials (<em>creds/creds.go</em> continued)</p>&#13;
<p><span epub:type="pagebreak" id="Page_159" title="159"/>You start by parsing the command line arguments to create the map of allowed group IDs. You then create a listener on the <em>/tmp/creds.sock</em> socket. The listener accepts connections by using <code>AcceptUnix</code><span class="CodeAnnotation">3</span> so a <code>*net.UnixConn</code> is returned instead of the usual <code>net.Conn</code>, since your <code>auth.Allowed</code> function requires a <code>*net.UnixConn</code> type as its first argument. You then determine whether the peer’s credentials are allowed <span class="CodeAnnotation">4</span>. Allowed peers stay connected. Disallowed peers are immediately disconnected.</p>&#13;
<p>Since you’ll execute this service on the command line, you’ll stop the service by sending an interrupt signal, usually with the <span class="KeyCaps">ctrl</span>-C key combination. However, this signal abruptly terminates the service before Go has a chance to clean up the socket file, despite your diligent use of <code>net.ListenUnix</code>. Therefore, you need to listen for this signal <span class="CodeAnnotation">1</span> and spin off a goroutine in which you gracefully close the listener after receiving the signal <span class="CodeAnnotation">2</span>. This will make sure Go properly cleans up the socket file.</p>&#13;
<h3 id="h2-500884c07-0005">Testing the Service with Netcat</h3>&#13;
<p class="BodyFirst">Netcat is a popular command line utility that allows you to make TCP, UDP, and Unix domain socket connections. You’ll use it to test the service from the command line. You can likely find Netcat in your Linux distribution’s package manager. For example, to install the OpenBSD rewrite of Netcat on Debian 10, run the following command:</p>&#13;
<pre><code>$ <b>sudo apt install netcat-openbsd</b></code></pre>&#13;
<p>The command uses the <code>sudo</code> command line utility to run <code>apt install netcat-openbsd</code> masquerading as the <code>root</code> user. CentOS 8.1 offers Nmap’s Netcat replacement. Run this command to install it:</p>&#13;
<pre><code>$ <b>sudo dnf install nmap-ncat</b></code></pre>&#13;
<p>Once it’s installed, you should find the <em>nc</em> binary in your <code>PATH</code> environment variable.</p>&#13;
<p>Before you can connect to your credential-checking service, you need to run the service so that it binds to a socket file: </p>&#13;
<pre><code>$ <b>cd $GOPATH/src/github.com/awoodbeck/gnp/ch07/creds</b>&#13;
$ <b>go run . -- users staff</b>&#13;
Listening on /tmp/creds.sock …</code></pre>&#13;
<p>In this example, you allow connections from any peer in the <code>users</code> or <code>staff</code> groups. The service will deny access to any peers who are not in at least one of these groups. If these groups do not exist in your Linux distribution, choose any group in the <em>/etc/groups</em> file. The service is listening to the <em>/tmp/creds.sock</em> socket file, which is the address you give to Netcat.</p>&#13;
<p>Next, you need a way of changing your group ID so that you can test whether the service denies access to clients you haven’t allowed. Currently, the service is running with your user and group IDs, since you started the service. Therefore, it will accept all your connections, since the service <span epub:type="pagebreak" id="Page_160" title="160"/>allows its own group (which is our group) to authenticate, per the <code>groups</code> map in <a href="#listing7-15">Listing 7-15</a>. To change your group when initiating the socket connection with your service, you can use the <code>sudo</code> command line utility.</p>&#13;
<p>Since using <code>sudo</code> requires escalated privileges, you are usually prompted for your password when you attempt to do so. I’ve omitted password prompts from the following examples, but expect to be prompted for your password on <code>sudo</code>’s first invocation:</p>&#13;
<pre><code>$ <b>sudo -g staff -- nc -U /tmp/creds.sock</b>&#13;
Welcome&#13;
<b>^C</b>&#13;
$</code></pre>&#13;
<p>Using <code>sudo</code>, you modify your group by passing the group name to the <code>-g</code> flag. In this case, you set your group to <code>staff</code>. Then you execute the <code>nc</code> command. The <code>-U</code> flag tells Netcat to make a Unix domain socket connection to the <em>/tmp/creds.sock</em> file. </p>&#13;
<p>Since the <code>staff</code> group is one of the allowed groups, you receive the <code>Welcome</code> message upon connecting. You terminate your side of the connection by pressing <span class="KeyCaps">ctrl</span>-C.</p>&#13;
<p>If you repeat the test with a disallowed group, you should receive the opposite result: </p>&#13;
<pre><code>$ <b>sudo -g nogroup -- nc -U /tmp/creds.sock</b>&#13;
Access denied&#13;
$</code></pre>&#13;
<p>This time, you use the group <code>nogroup</code>, which the service doesn’t allow. As expected, you immediately receive the <code>Access denied</code> message, and the server side of the socket terminates your connection.</p>&#13;
<h2 id="h1-500884c07-0004">What You’ve Learned</h2>&#13;
<p class="BodyFirst">You started this chapter with a look at Unix domain sockets. A Unix domain socket is a file-based communication method for processes running on the same node. Two or more processes, such as a local database server and client, can send and receive data through a Unix domain socket. Since Unix domain sockets rely on the filesystem for addressing, you can leverage filesystem ownership and permissions to control access to processes communicating over Unix domain sockets.</p>&#13;
<p>You then learned about the types of Unix domain sockets that Go supports: <code>unix</code>, <code>unixgram</code>, and <code>unixpacket</code>. Go makes communication over Unix domain sockets relatively painless and handles many of the details for you, particularly if you stick to the <code>net</code> package’s interfaces. For example, code written for use over a stream-based TCP network will also work with little modification over the stream-based <code>unix</code> domain socket, albeit only for local process communication. Likewise, code written for use over a UDP network can be leveraged by the <code>unixgram</code> domain socket. You also touched on the hybrid Unix domain socket type, <code>unixpacket</code>, and learned that its drawbacks <span epub:type="pagebreak" id="Page_161" title="161"/>don’t outweigh its benefits for most applications, particularly with respect to cross-platform support. The other two Unix domain socket types are better options for most use cases.</p>&#13;
<p>This chapter introduced peer credentials and showed how you could use them to authenticate client connections. You can go beyond file-based access restrictions to a Unix domain socket and request details about the client on the other side of the Unix domain socket.</p>&#13;
<p>You should now be equipped to determine where Unix domain sockets best fit into your network stack.</p>&#13;
</section>&#13;
</body></html>