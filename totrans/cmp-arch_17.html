<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="chn"><span epub:type="pagebreak" id="page_339"/><strong>14</strong></h2>&#13;
<h2 class="cht"><strong>SMART ARCHITECTURES</strong></h2>&#13;
<div class="image1"><img src="../images/f0339-01.jpg" alt="Image" width="252" height="252"/></div>&#13;
<p class="chq"><em>Smart computing</em> means general-purpose computers built into low-power and/or mobile devices, such as phones, tablets, TVs, routers, and fridges. Unlike embedded systems, they run multiple easily installable and upgradable programs, often known as <em>apps</em>. Unlike desktop systems, they need to reduce power consumption, as they often run from batteries. <em>Reduced instruction set computing (RISC)</em> is a good fit for these requirements, so RISC architectures are generally found in smart systems. This chapter explores the RISC philosophy, smart devices, and the details of a particular RISC architecture, RISC-V. It’s shorter than the desktop chapter because RISC is simpler than CISC by design.</p>&#13;
<h3 class="h3" id="lev281"><span epub:type="pagebreak" id="page_340"/>Smart Devices</h3>&#13;
<p class="noindent">Early mobile phones were embedded systems whose primary purpose was to function as voice telephones. They had microcontrollers programmed to manage the telephone and user interaction via buttons and simple number-displaying screens. Over time, these microprocessors and interaction devices grew, and the firmware was extended to include features such as contact books, alarm clocks, and simple games like <em>Snake</em>.</p>&#13;
<p class="indent">Modern smartphones now provide such features, and many more, as software apps rather than firmware. They’ve replaced microcontrollers with fully fledged general-purpose architectures that typically run an operating system such as LineageOS, Replicant, or Android to host apps, much like a desktop PC.</p>&#13;
<p class="indent">The prefix <em>smart</em> emerged to describe these phones, but it’s now applied to anything that used to be an embedded system but has been upgraded to a general-purpose computer. For example, smart TVs (the left of <a href="ch14.xhtml#ch14fig1">Figure 14-1</a>) and smart fridges have moved beyond microcontrollers and firmware to the point where they can easily install and run multiple apps.</p>&#13;
<p class="indent">The modern consumer internet connection device shown on the right of <a href="ch14.xhtml#ch14fig1">Figure 14-1</a> and widely but wrongly known as a “router” is another example of a smart computer. Such devices now usually contain an operating system running many services, including routing, Wi-Fi, firewalling, and a web server (at least to run its configuration page). They should probably be renamed “smart routers” for this reason.</p>&#13;
<div class="image"><img id="ch14fig1" src="../images/f0340-01.jpg" alt="Image" width="874" height="390"/></div>&#13;
<p class="figcap"><em>Figure 14-1: The inside of a Toshiba smart TV (left) and a Zyxel router (right)</em></p>&#13;
<p class="indent">The “smart home” has been a computing industry ambition for several decades, and refers to a home in which most or all of the usual domestic appliances are upgraded to networked, general-purpose computers. For example, smart washing machines and smart central heating controllers will enable innovative, machine learning–based apps to compete against one another to make the best use of energy, given data from sensors monitoring the condition of clothes to be washed and the temperatures and usages of rooms. Linking these systems will enable automation chains such as your smart fridge predicting that the milk will run out later today, and placing an <span epub:type="pagebreak" id="page_341"/>automatic order to the local supermarket to deliver more, perhaps via a last-mile delivery robot and a smart drop-off box to receive the delivery. Or your heating system and fridge could be temporarily turned off while the washing machine is turned on, so that it can be powered entirely from the batteries in your parked electric car, charged from your solar panels, without needing to use the power grid.</p>&#13;
<p class="indent">Architectures for smart devices have similar requirements to embedded systems around reliability and energy usage. However, they also need more computing power than embedded microcontrollers. These requirements are a perfect match for the RISC philosophy, so let’s examine this philosophy in more detail.</p>&#13;
<h3 class="h3" id="lev282">RISC Philosophy</h3>&#13;
<p class="noindent">The RISC concept was invented by an American, David Patterson, but most successfully commercialized by the British. Patterson’s quantitative approach to architecture involved a statistical analysis of the instructions actually being used by real-world programs on processors of the 1990s. He found that the more complex instructions were used very rarely, in part because compiler back-end designers didn’t know or want to learn how to use them. He determined that roughly 90 percent of the work was being done by roughly 10 percent of the resources. This led him to the central RISC tenet that the silicon occupied by the rarely used instructions would be better put to work making the most popular 10 percent of instructions run very fast, at the expense of removing the other instructions altogether. Patterson and his co-architect, John Hennessy, won the 2017 Turing Award for their research on the use of quantitative methods to guide RISC architecture design.</p>&#13;
<p class="indent">RISC usually aims for every one of its streamlined set of instructions to be executed in a single CPU cycle. With fewer instructions available, RISC assembly programs are often quite verbose, but each instruction is simple, fast, and low-power to execute. Writing programs in RISC assembly and writing compilers for RISC is easy and fun because the instruction set architectures (ISAs) are small, simple, and understandable.</p>&#13;
<p class="indent">RISC CPUs themselves aren’t necessarily simple, however. While the instruction sets are by definition smaller, designers have found alternative ways to make efficient use of the available silicon. For example, RISC processors typically have many more registers than their CISC counterparts. Extra registers are especially useful in RISC because they help separate memory access from arithmetic. In RISC programming and RISC compilers, it’s common to try to bring all relevant variables into registers at the start of a subroutine, then do the entire function’s computations in registers, storing only the result back to main memory. This contrasts with CISC, where there can be continual loading and storing throughout the subroutine.</p>&#13;
<p class="indent">Because part of the RISC philosophy is that every instruction should execute in exactly one clock cycle, instruction-level parallelism through pipelining, branch prediction, and out-of-order execution (OOOE) are massively easier to manage. Every instruction has the same fetch-decode-execute step <span epub:type="pagebreak" id="page_342"/>duration, and each phase can be triggered regularly in open-loop style. Compare this with CISC architectures, where steps of different instructions can take different durations and must closed-loop trigger each other to say when they’ve been completed.</p>&#13;
<p class="indent">RISC was traditionally seen as a very academic philosophy, being beautiful in its design, lean and mean in its execution, and generally resisting the temptation to make a fast buck by bolting on new features to please specific customers by next Thursday. It was often associated with Britain and the British company ARM, though it originated at the University of California, Berkeley—located near to but separated from Silicon Valley. The stereotypical RISC advocate was more interested in beauty and cleverness of design than pragmatism, and for a long time such people were laughed at by more commercial-minded Silicon Valley architects. However, this is now changing: the beauty of RISC is paying off. Most processors now manufactured are RISC. This is largely due to the trend of smart and embedded devices replacing desktops, though serious thoughts are now turning to RISC for cloud servers, too. In 2020, Apple also moved its desktop machines to the RISC-based M1 architecture.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>FROM ACORN TO ARM</strong></p>&#13;
<p class="stext">The British company Acorn used the 6502 in their BBC Micro (“Beeb”), a classic piece of British engineering, brilliantly designed but commercially mistimed and mispositioned. Like much British technology, the Micro was government-funded, in this case via the national broadcaster, the BBC, who wanted a custom-designed, mass-market machine to go with an educational TV series.</p>&#13;
<p class="stext">Hackers today often play at buying a 6502 and building an 8-bit computer around it on a breadboard, and that was just what the Beeb designers did. Acorn was founded by a bunch of Cambridge people who used that pedigree to convince the establishment BBC to choose their design. The BBC gave a huge specification list for what their computer needed for their TV series. This had a strong education and science—rather than gaming—influence. For example, they didn’t include a joystick port but did include options for coprocessors and interfacing to maker-style electronics.</p>&#13;
<p class="stext">One year after the Beeb’s release, the Commodore 64 appeared, designed to be “for the masses, not the classes.” It had superior graphics and sound for game playing, and came at a much lower price. The C64 filled the full 64 k<sub>2</sub>B of addressable RAM, while the Beeb filled only 32 k<sub>2</sub>B. The C64 had the glorious SID sound chip, while the Beeb had only basic square waves, white noise, and amplitude envelopes from the poorer SN76489. Commodore had by this point bought out MOS, so it could involve the designers of the 6502 and related chips—including Chuck Peddle—directly in its computer designs to exploit its most advanced features.</p>&#13;
<p class="stext"><span epub:type="pagebreak" id="page_343"/>The C64 quickly made the Beeb seem overspecified and overpriced. However, Acorn used the Beeb internally to design their first RISC processor, the Acorn RISC Machine (ARM), for their next computer, the Archimedes—a fully 32-bit machine, released in 1987. Archimedes was technically a decade ahead of its time, though temporally and culturally it still belonged to the “16/32-bit era.” It was again sadly mismarketed, overspecified, and overpriced—for example, having eight-channel audio compared to the Amiga’s four, yet no joystick ports or TV output for games.</p>&#13;
<p class="stext">Acorn went on to spin out a new company, ARM, to focus on its ARM chip designs. ARM found success, as its chips now power most of the world’s smartphones, the M1 used in Apple’s tablets and desktops, and many smart devices such as the chips seen in <a href="ch14.xhtml#ch14fig1">Figure 14-1</a>.</p>&#13;
<p class="stext">Computing history could have been very different if the BBC had waited an extra year to put a C64 into every UK school. Commodore’s business management faced challenges that led to bankruptcy in 1994, but acceptance by the British establishment might have provided the stability needed to survive.</p>&#13;
<p class="stext">A strange legacy has been that Acorn’s OS for Archimedes, RISCOS, is still compatible with the latest ARM ISAs. It was painstakingly hand-coded in ARM assembly to squeeze power out of early 1990s CPUs, so it now runs blindingly fast on modern devices such as the Raspberry Pi. There’s been a resurgence of old Acorn user groups around this, in some cases resulting in old friends meeting up for the first time in 30 years.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev283">RISC-V</h3>&#13;
<p class="noindent">ARM’s RISC ISA designs are heavily patented, but others in the industry now wish for fully open source RISC ISA alternatives. As with the IBM-Intel-AMD license, computer builders want to genericize the ISA and enable multiple implementations to drive down processor prices through competition. A large consortium of major Silicon Valley companies is therefore now backing Patterson’s latest and fully open source RISC ISA family design, called RISC-V (V for, and pronounced, “five”), as the next standard for RISC. Note that RISC-V is a family of ISAs, not a hardware implementation of these ISAs. Companies may implement the open source ISAs in proprietary hardware and compete on implementation quality. There are also fully open source implementations by Patterson’s group and other members of the RISC-V movement.</p>&#13;
<h4 class="h4" id="lev284"><em>Understanding the Architecture</em></h4>&#13;
<p class="noindent">RISC-V is designed as a family of ISAs, rather than a single ISA. The family includes versions suitable for embedded, mobile, desktop, and server machines, including versions for 32-, 64-, and 128-bit ISAs. RISC-V defines a core ISA of instructions that all RISC-V systems need to implement. Like x86, RISC-V uses per-byte, little-endian addressing. RISC-V uses RISC-style instructions that separate memory access from arithmetic logic unit (ALU) <span epub:type="pagebreak" id="page_344"/>operations. It’s not an accumulator architecture, and ALU instructions explicitly specify the output register, so they usually have three arguments.</p>&#13;
<p class="indent">As we’ve discussed, the RISC philosophy is to reduce the number of instructions as much as possible. This means that some operations that you would usually expect to find in an ISA are absent if they can be achieved through other means, such as by calling other instructions in slightly odd ways. When such unusual uses of instructions are needed, RISC-V assemblers will sometimes provide <em>pseudo-instructions</em> that look like the classic instructions you expect. The assembler then converts them to the underlying, somewhat ugly RISC instructions. To a limited extent, some of the complexity of CISC digital logic is thus moved into the assembler, while keeping the machine code itself clean.</p>&#13;
<p class="indent">RISC-V registers have standard names and standard conventions for their typical uses, such as how to pass arguments to subroutines by storing them in registers. For example, the integer registers are always called x0 to x32 (and x0 always contains the constant 0). The RISC designers gave the integer registers secondary nickname mnemonics, shown in <a href="ch14.xhtml#ch14tab1">Table 14-1</a>, to encourage conventions for their use.</p>&#13;
<p class="tabcap" id="ch14tab1"><strong>Table 14-1:</strong> RISC-V Integer Registers</p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Name</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Mnemonic</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Intended convention</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">x0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">zero</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Value is always zero</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">x1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">ra</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">Return address for subroutine calls</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">x2</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">sp</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Stack pointer</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">x3</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">gp</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">Global pointer</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">x4</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">tp</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Thread pointer</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">x5–x7</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">t0–t2</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">Temporary</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">x8–x9</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">s0–s1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Saved</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">x10–x14</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">a0–a7</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">Arguments for subroutine calls</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">x18–x27</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">s2–s11</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Saved</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">x28–x31</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">t3–t6</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">Temporary</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As with instructions and pseudo-instructions, this is designed to keep the underlying architecture very clean and simple, while also providing the ability to think and code in terms of some CISC-like styles, if and only if the programmer wants to do that.</p>&#13;
<p class="indent">There may be a further 32 optional floating-point registers, also given mnemonics, which you can see in <a href="ch14.xhtml#ch14tab2">Table 14-2</a>.</p>&#13;
<p class="indent">The intended calling conventions for registers starting with <em>t</em> and <em>s</em> are temporary and safe—the same concepts seen but less standardized in the x86 calling conventions from <a href="ch13.xhtml">Chapter 13</a>.</p>&#13;
<p class="tabcap" id="ch14tab2"><span epub:type="pagebreak" id="page_345"/><strong>Table 14-2:</strong> RISC-V Floating-Point Registers</p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Name</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Mnemonic</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Intended convention</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">f0–7</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">ft0–7</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Floating-point temporaries</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">f8–9</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">fs0–1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">Floating-point saved registers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">f10–11</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">fa0–1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Floating-point arguments/return values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">f12–17</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">fa2–7</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">Floating-point arguments</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">f18–27</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">fs2–11</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Floating-point saved registers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">f28–31</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">ft8–11</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">Floating-point temporaries</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As with x86, the user can’t access internal registers directly. These internal registers include a program counter and status register.</p>&#13;
<h4 class="h4" id="lev285"><em>Programming Core RISC-V</em></h4>&#13;
<p class="noindent">Now we’ve seen the basic structures, let’s use them in some instructions to write RISC-V programs. As with the other architectures we’ve studied, we’ll first introduce data moves and control flow. RISC-V then has various optional extensions, including arithmetic, which we’ll also explore.</p>&#13;
<h4 class="h4a"><strong>Data Moves</strong></h4>&#13;
<p class="noindent">As a RISC system, data movement involving primary memory is cleanly separated from all other operations, which are performed only on data in registers. Loading from memory to registers, and storing to memory from registers, is done by the following instructions:</p>&#13;
<pre>lw x5, x6, 0            ; load word to x5, from content at address x6+0&#13;
sw x5, x6, 0            ; store value from reg x5 to address x6+0&#13;
la x6, mylabel          ; load address of mylabel (not its content) to x6</pre>&#13;
<p class="indent">Note that like NASM and Arduino assembly, RISC-V assembly writes the destination register first, followed by the inputs. You can see the RISC nature of the <span class="literal">lw</span> and <span class="literal">sw</span> instructions in the requirement for all three operands, even when the third operand is a 0 and thus isn’t being used, rather than providing a second form of these instructions with only two operands.</p>&#13;
<p class="indent">For convenience, a pseudo-instruction is provided to load content from a labeled address:</p>&#13;
<pre>lw x5, mylabel          ; load content at address mylabel to register x5</pre>&#13;
<p class="noindent">This actually gets assembled to two instructions. First, an <span class="literal">la</span> obtains the address of the label, and then an <span class="literal">lw</span> loads the content of that address.</p>&#13;
<p class="indent">Importantly, unlike in CISC, these instructions aren’t reused to copy data between registers. This clean separation of memory access instructions from between-register operations is often considered to be a defining feature of RISC. We’ll discuss how this is done in the “Arithmetic” section on <a href="ch14.xhtml#ch14lev1sec2">page 347</a>.</p>&#13;
<h4 class="h4a"><span epub:type="pagebreak" id="page_346"/><strong>Control Flow</strong></h4>&#13;
<p class="noindent">Unconditional jumps come in two forms:</p>&#13;
<pre>j mylabel               ; jump to address mylabel&#13;
jr x5                   ; jump to address in x5</pre>&#13;
<p class="indent">Conditional jumps include:</p>&#13;
<pre>beq x1, x2, mylabel     ; branch if x1==x2&#13;
bne x1, x2, mylabel     ; branch if not x1==x2&#13;
blt x1, x2, mylabel     ; branch if x1&lt;x2&#13;
bge x1, x2, mylabel     ; branch if x1&gt;=x2</pre>&#13;
<p class="indent">Subroutines are called by “jump and link.” The “link” here refers to saving the program counter in a register. For example:</p>&#13;
<pre>jal x1, mylabel         ; store current PC in x1 and jump to mylabel&#13;
jalr x1, x2, 0          ; store current PC in x1 and jump to address x2+0</pre>&#13;
<p class="noindent">This is why x1 is nicknamed ra, for return address.</p>&#13;
<p class="indent">There isn’t a return instruction because returning can be done, RISC-style, by reusing the jump instruction, jumping to what was previously saved in x1:</p>&#13;
<pre>jalr x0, x1, 0</pre>&#13;
<p class="noindent">That said, a <span class="literal">ret</span> pseudo-instruction may be provided and assembled into the appropriate <span class="literal">jalr</span> instruction.</p>&#13;
<p class="indent">Using <span class="literal">ret</span> enables you to call and return from a single subroutine, with the return address kept in x1. To call nested functions, however, you’ll also need a stack. The convention is to have the register x2 (sp) be the stack pointer. Here we push a 4-byte word to the stack:</p>&#13;
<pre>addi sp, sp, -4 ; grow stack&#13;
sw   a0, sp, 0 ; store a0 onto stack</pre>&#13;
<p class="noindent">The <span class="literal">addi</span> instruction means “add immediate,” in this case adding a constant (–4) to the stack pointer. (“Immediate” means that an operand contains the value itself, rather than an address or register containing the value.) Likewise, here we pop from the stack:</p>&#13;
<pre>lw   a0, sp, 0 ; retrieve data to a0 from stack&#13;
addi sp, sp, 4 ; shrink stack</pre>&#13;
<p class="indent">Note that this is done, RISC-style, by reusing existing instructions. Unlike CISC style, there are no additional stack instructions such as <span class="literal">push</span> and <span class="literal">pop</span>. Rather, you have to manage the stack yourself with the reduced instruction set.</p>&#13;
<h4 class="h4" id="lev286"><span epub:type="pagebreak" id="page_347"/><em>Extending RISC-V</em></h4>&#13;
<p class="noindent">RISC-V also defines many plug-ins or libraries of additional instructions that can be implemented optionally. Each of these extensions is given a single-letter code, including:</p>&#13;
<p class="block"><strong>I</strong>     Basic integer add/subtract/shift/bitwise logic</p>&#13;
<p class="block"><strong>M</strong>     Integer multiplication and division</p>&#13;
<p class="block"><strong>B</strong>     Bitwise Booleans</p>&#13;
<p class="block"><strong>F</strong>     Single-precision floating point</p>&#13;
<p class="block"><strong>D</strong>     Double-precision floating point</p>&#13;
<p class="block"><strong>Q</strong>     Quad-precision floating point</p>&#13;
<p class="indent">To specify a particular ISA, we write “RV” for RISC-V, then the word length, then the extensions used. For example, RV64IMF means “RISC-V, 64-bit, with extensions I, M, and F.” This design is intended to allow RISC-V to span all applications from embedded systems (such as RV8I) to high-end scientific computing clusters. Further standard extensions may be proposed as new letters or as arbitrary strings beginning with a Z, and local experimental extensions may be proposed as arbitrary strings beginning with an X.</p>&#13;
<h4 class="h4a" id="ch14lev1sec2"><strong>Arithmetic</strong></h4>&#13;
<p class="noindent">Integer arithmetic is performed with three operands. For example:</p>&#13;
<pre>add x6, x7, x8  ; x6 := x7 + x8&#13;
sub x6, x7, x8  ; x6 := x7 - x8&#13;
mul x6, x7, x8  ; x6 := x7 * x8&#13;
div x6, x7, x8  ; x6 := integer of x7 / x8&#13;
rem x6, x7, x8  ; x6 := remainder of x7 / x8</pre>&#13;
<p class="noindent">Bitwise Boolean operations are similar:</p>&#13;
<pre>and x6, x7, x8  ; x6 := x7 bitwise-and x8&#13;
or x6, x7, x8   ; x6 := x7 bitwise-or x8&#13;
xor x6, x7, x8  ; x6 := x7 bitwise-xor x8&#13;
not x6, x7      ; x6 := bitwise-not x7</pre>&#13;
<p class="noindent">Unusual cases such as division by zero and overflows are reported in the status register, which can be queried by further instructions.</p>&#13;
<p class="indent">In a RISC architecture, register-to-register operations belong to arithmetic rather than to data transfer in order to reduce the number of instructions and variations. Thus, there are no extra instructions for placing constants in registers or copying data between registers. Instead, we treat these as addition operations, with the always-zero x0 register used as one of the operands. For example:</p>&#13;
<pre>addi x1, x0, 3   ; load immediate integer 3 to x1&#13;
add x2, x1, x0   ; copy x1 to x2</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_348"/>The RISC-V assembler developed by the mainline RISC-V project includes alternative pseudo-instructions for these operations, for programmer convenience:</p>&#13;
<pre>li x2, 3         ; load integer 3 into x2&#13;
mv x2, x1        ; copy x1 to x2</pre>&#13;
<p class="noindent">These are assembled behind the scenes into the appropriate addition instructions.</p>&#13;
<h4 class="h4a"><strong>Floating Point</strong></h4>&#13;
<p class="noindent">Floating-point instructions begin with <span class="literal">f</span> and act on the floating-point registers, f0 to f31, such as:</p>&#13;
<pre>fadd f6, f7, f8  ; f6 := f7 + f8&#13;
fsub f6, f7, f8  ; f6 := f7 - f8&#13;
fmul f6, f7, f8  ; f6 := f7 * f8&#13;
fdiv f6, f7, f8  ; f6 := f7 / f8&#13;
fsqrt f6, f7     ; f6 := sqrt(f7)</pre>&#13;
<p class="indent">There are also instructions to load, store, and compare floats, and convert them to and from integers:</p>&#13;
<pre>flw f1, t0, 0    ; load float word to f1 from address t0+0&#13;
fsw t0, f1, 0    ; store float word to address t0+0 from f1&#13;
flt.s x6, f1, f2 ; x6 := (f1 &lt; f2)&#13;
fcvt.w.s x6, f1  ; convert float f1 to int x6&#13;
fcvt.s.w f1, x7  ; convert int x7 to float f1</pre>&#13;
<p class="indent">Here the <span class="literal">.s</span> and <span class="literal">.w</span> stand for single and word precision. There’s also <span class="literal">d</span> for double. These suffixes are similar to, and perhaps borrowed from, the 68000 discussed in <a href="ch11.xhtml">Chapter 11</a>. As with integers, RISC style can be seen in the clear separation of memory access (load and store) from the arithmetic performed.</p>&#13;
<h3 class="h3" id="lev287">Different RISC-V Implementations</h3>&#13;
<p class="noindent">As I’ve mentioned, RISC-V is a specification of a family of ISAs of the machine code interface between the programmer and the CPU. It doesn’t specify how the instructions should be implemented. Architects are free to design their own implementations of RISC-V as CPUs from digital logic (or from anything else).</p>&#13;
<p class="indentb">So far, there are three major open source hardware implementations of RISC-V. These are fully open source hardware in the sense that anyone can download, edit, and fabricate the files describing the CPU layouts, free of charge. The implementations are:</p>&#13;
<p class="block2"><span epub:type="pagebreak" id="page_349"/><strong>Berkeley Educational cores</strong> These are deliberately simple implementations of some limited RISC-V ISAs for educational use, being easier to understand and modify. They include non-pipelined and simple pipelined versions.</p>&#13;
<p class="block2"><strong>Rocket</strong> This is a family of CPU implementations using professional-quality pipelining. It’s a family rather than a single CPU because there are versions for different word lengths and for most of the ISA extensions. The Rocket chip generator program can generate a particular chip design and layout for most RISC-V descriptors.</p>&#13;
<p class="block2"><strong>BOOM (Berkeley Out-of-Order Machine)</strong> This is a high-performing implementation, using state-of-the-art OOOE. It’s a platform for much active research on OOOE and other hardware speedups.</p>&#13;
<h3 class="h3" id="lev288">RISC-V Toolchain and Community</h3>&#13;
<p class="noindent">RISC-V is more than just an architecture: it’s an open source community and ecosystem. For the first time in architecture history, a fully open source architecture and toolchain now exists that allows anyone in the world to download it, hack it, and burn it onto cheap field programmable gate arrays (FPGAs). These kinds of technologies used to be the preserve of a tiny group of professionals working at architecture companies, where they were closely guarded secrets. Now anyone can access and play with the same kinds of tools as those big companies. As a result of this opening up of the tool-chain, together with the pressure to develop radically new architectures due to the end of Moore’s law(s), there are now over 700 architecture start-up companies in Silicon Valley, and more around the world. Hennessy and Patterson’s 2017 Turing Award lecture declared a “new golden age” of architecture for the 2020s, and they encouraged everyone to get involved with this community.</p>&#13;
<p class="indent">To get involved yourself, you’ll need to download the RISC-V community’s tools and tutorials. RISC-V development is <em>de facto</em> led by Patterson’s group at the University of Berkeley, near Silicon Valley. This group has produced a standard set of tools that the community uses to design and build structures from transistor layouts all the way up to full CPUs. RISC-V development is usually done in the program Chisel, and indeed Chisel is developed by many of the same people as RISC-V.</p>&#13;
<h3 class="h3" id="lev289">Smart Computer Design</h3>&#13;
<p class="noindent">For smart computing applications, it’s usually desirable to place a RISC CPU on the same silicon as all the other components, such as memory and I/O, needed to make a complete computer. Such a chip is known as a <em>system-on-chip (SoC)</em>. This is a superficially similar idea to embedded microcontrollers, but with substantially larger and more powerful designs. An SoC is then typically mounted on a very small PCB together with only analog electronics for power management and physical I/O connectors.</p>&#13;
<p class="indentb"><span epub:type="pagebreak" id="page_350"/>Computer designers are now taking RISC-V chip designs and putting them onto SoCs and hardware boards. There are several commercial and research systems using silicon fabrications of RISC-V, including the following examples:</p>&#13;
<p class="block2"><strong>HiFive</strong> This closed source, commercial RISC-V product, designed by SiFive, was the first practical RISC-V hardware available to the public. It’s a $50 Raspberry Pi–style board that uses an OOOE implementation, capable of running Linux for applications, similar to the Raspberry Pi.</p>&#13;
<p class="block2"><strong>Mango Pi</strong> This is a RISC-V board with similar small form factor and capabilities to the Raspberry Pi Zero.</p>&#13;
<p class="block2"><strong>lowRISC</strong> This is an ongoing project to design and produce a fully open source hardware computer as an SoC, based on a Rocket CPU. To make a full computer, all the other non-CPU components also need to be designed as open source hardware, in particular I/O and devices for communications, such as USB and Ethernet controllers.</p>&#13;
<p class="block2"><strong>ROMA</strong> This is the first laptop design based on RISC-V. It was released by Xcalibyte in 2022.</p>&#13;
<p class="indenta">Beyond RISC CPUs, smart computing requirements have also led to developments in memory and I/O. Let’s look at some of the most common resulting computer design elements here.</p>&#13;
<h4 class="h4" id="lev290"><em>Low-Power DRAM</em></h4>&#13;
<p class="noindent">The DRAM used in phones and other mobile devices is of a special low-power (LP) type known as <em>LP-DRAM</em>. LP-DRAM is designed to reduce battery usage at the cost of some loss of speed and convenience. Primarily, this is achieved by turning off the power to large areas of memory that aren’t in use. This destroys their volatile contents but greatly reduces power consumption, as no electricity is needed to continually refresh the memory. The main cost is a delay in reactivating these regions when they’re needed again. For example, your phone’s batteries will last longer on an LP-DRAM machine if you close down all unnecessary apps, because the operating system will then free the memory they were using, which can be turned off to save power.</p>&#13;
<p class="indent">Like DRAM, LP-DRAM has been through many standards iterations. Various additional innovations beyond power switching include operating on reduced voltages such as 1.8 V, scaling the refresh rate as a function of temperature to reduce unnecessary refresh work, and multiple levels of shutdowns. The latter may be used to differentiate between a user putting their phone away in their pocket for many hours versus temporarily freeing memory from an app while continuing to use the rest of the phone.</p>&#13;
<h4 class="h4" id="lev291"><span epub:type="pagebreak" id="page_351"/><em>Cameras</em></h4>&#13;
<p class="noindent">Camera sensors, as shown in <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>, are active pixel sensors made from CMOS-like chips.</p>&#13;
<div class="image"><img id="ch14fig2" src="../images/f0351-01.jpg" alt="Image" width="825" height="316"/></div>&#13;
<p class="figcap"><em>Figure 14-2: A camera sensor (left) and a close-up showing its pixels (right)</em></p>&#13;
<p class="indent">Camera sensors are formed from 2D arrays of light sensors (pixels) created through photolithography, like chips. Usually each pixel contains three subpixels for sensing red, green, and blue light, as in displays.</p>&#13;
<h4 class="h4" id="lev292"><em>Touchscreens</em></h4>&#13;
<p class="noindent">The touchscreen used in a phone or tablet is produced as a distinct, transparent layer from the display screen placed beneath it. Like chips, touch-screens are produced via photolithography; layers of different materials are laid down in a pixel grid of small half-capacitors, as shown in <a href="ch14.xhtml#ch14fig3">Figure 14-3</a>.</p>&#13;
<div class="image"><img id="ch14fig3" src="../images/f0351-02.jpg" alt="Image" width="394" height="338"/></div>&#13;
<p class="figcap"><em>Figure 14-3: A touchscreen made from an array of half-capacitors, with 2D addressing</em></p>&#13;
<p class="indent">Human skin acts as the other half of the capacitor when in close proximity to these pixels, making the grid touch-sensitive.</p>&#13;
<p class="indent">To enable the touchscreen to act as a layer above a visible display, we need to build these half-capacitors and the wires connected to them from a material that’s both conductive (a metal) and also transparent to human-visible red, green, and blue light. This is a difficult requirement, because metals generally reflect all frequencies of light. Indium tin oxide (ITO) is a <span epub:type="pagebreak" id="page_352"/>very unusual compound, based on the rare element indium, that happens to have the desired property, so it’s used in most touchscreens.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>NOT SO DIFFERENT AFTER ALL?</strong></p>&#13;
<p class="stext">Unlike CISC, RISC doesn’t add extra instructions to make life easier for the programmer, who instead must often make use of sequences of more basic, general-purpose instructions with particular operands. This can make manual RISC assembly programming less interesting than CISC programming, but RISC assemblers can provide pseudo-instructions that function similarly to CISC instructions but are assembled into sequences of multiple RISC instructions. It’s also possible to build CISC architectures that do similar but in digital logic, fetching CISC-style instructions but decoding them into <em>sequences</em> of RISC instructions that are then executed in RISC style. Such designs look internally quite similar to the CISC microcode structures, suggesting that CISC and RISC don’t have to be so different after all.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev293">Summary</h3>&#13;
<p class="noindent">Smart devices are replacing embedded systems in many applications as the cost and power consumption of general-purpose computing falls and battery technology improves. RISC architectures are a good fit for smart computing needs, as their simplicity can reduce physical size, cost, and power requirements.</p>&#13;
<p class="indent">RISC architectures use small sets of simple instructions. They typically make a clean separation between instructions for memory access and for arithmetic. They try to have all instructions execute in the same time in order to simplify execution and enable smoother pipelining and OOOE. RISC assembly code is usually characterized by its appearance as homogeneous-looking lists of instructions with triple operands.</p>&#13;
<p class="indent">RISC-V is an open source family of RISC ISAs, with both open and closed source digital logic implementations and design toolchains available. RISC-V includes a core instruction set and various optional extension instruction sets, so variants can be used for small, cheap smart devices, and all the way up to higher-power servers.</p>&#13;
<h3 class="h3" id="lev294">Exercises</h3>&#13;
<h4 class="h4a"><strong>RISC-V Programming</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Install and run the Jupiter RISC-V simulator from <em><a href="https://github.com/andrescv/Jupiter">https://github.com/andrescv/Jupiter</a></em>.</li>&#13;
<li class="tm"><span epub:type="pagebreak" id="page_353"/>Enter some simple programs from the examples in this chapter. Jupiter requires a label called <span class="literal">__start</span> (with two underscores) to be defined and made global; this will be used as the entry point when the program runs. For example:<br/><pre>.globl __start&#13;
__start:&#13;
  li t0,0</pre></li>&#13;
<li class="tm">If you have data lines in your program, then by default Jupiter assumes a Harvard-style segmentation, which requires <span class="literal">.data</span> and <span class="literal">.txt</span> sections, such as:<br/><pre>.globl __start&#13;
.data&#13;
  mylabel: .word 17&#13;
  myfloat: .float 34.56&#13;
.text&#13;
__start:&#13;
  lw x5, mylabel ; load word to register x5, from content at address mylabel&#13;
  la x6, mylabel ; load address to x6, of mylabel (not its content)&#13;
myloop:&#13;
  sw x5, 0(x6)   ; store value from reg x5 to address 0+x6 (= mylabel)&#13;
  j myloop</pre></li>&#13;
<li class="tm">Save and assemble each program (<strong>Run ▸ Assemble</strong>) and run it in the simulator. You can place breakpoints at any time with the tick-boxes on the left of the lines, and inspect the registers and memory with the GUI on the right. To get back to the code, click <strong>Editor</strong> at the top left.</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>Challenging</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Try porting previous programs from the Analytical Engine and Manchester Baby to run on RISC-V. What’s easier or harder to do in modern RISC-V compared to those systems? How does it feel compared to x86?</li>&#13;
<li class="tm">Obtain a physical RISC-V board and use its tools and documents to run the same programs on it.</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>More Challenging</strong></h4>&#13;
<p class="noindent">Want to make a real, working CPU in your bedroom? Using RISC-V and Chisel, you can.</p>&#13;
<ol class="number">&#13;
<li class="tm">A full Chisel tutorial can be found at <em><a href="https://github.com/ucb-bar/chisel-tutorial">https://github.com/ucb-bar/chisel-tutorial</a></em>. Install Chisel and work through this tutorial.</li>&#13;
<li class="tm">All of the microcircuits used in Rocket and BOOM—including ALU, FPU, and control unit—are available as Chisel libraries. Download and build some of these and experiment with how they work.</li>&#13;
<li class="tm">The Rocket Chip Generator (<em><a href="https://github.com/chipsalliance/rocket-chip">https://github.com/chipsalliance/rocket-chip</a></em>) is a tool that takes a RISC-V CPU descriptor code such as RV64IMFP as input, and outputs Chisel and Verilog files (or a C++ <span epub:type="pagebreak" id="page_354"/>simulation) for the desired CPU. Install and run Rocket Chip. Study the outputs to find out how the microcircuits you looked at in the previous problem are used in the generated CPU.</li>&#13;
<li class="tm">Torture (<em><a href="https://github.com/ucb-bar/riscv-torture">https://github.com/ucb-bar/riscv-torture</a></em>) is a tool provided by the RISC-V community to test correct RISC-V execution in hardware designs, and to help locate errors. Install it, introduce a deliberate error to a Rocket Chip design, and use the tool to study the error.</li>&#13;
<li class="tm">Buy a cheap FPGA board and use the RISC-V documentation and mailing list archives to figure out how to burn your Rocket Chip netlist onto it to make a real physical CPU.</li>&#13;
<li class="tm">Join the RISC-V community discussions at <em><a href="https://riscv.org">https://riscv.org</a></em> and study the open lowRISC designs at <em><a href="https://github.com/lowrisc">https://github.com/lowrisc</a></em>. Use them to find an interesting piece of work that needs doing and contribute it to the RISC-V community.</li>&#13;
</ol>&#13;
<h3 class="h3" id="lev295">Further Reading</h3>&#13;
<ul class="bullet">&#13;
<li class="tm">For a detailed RISC-V tutorial, see Edson Borin, <em>An Introduction to Assembly Programming with RISC-V</em>, <em><a href="https://riscv-programming.org/book/riscv-book.html">https://riscv-programming.org/book/riscv-book.html</a></em>.</li>&#13;
<li class="tm">For the definitive RISC-V manual, see Andrew Waterman and Krste Asanović (eds.), <em>The RISC-V Instruction Set Manual Volume I: User-Level ISA</em> (Berkeley: RISC-V Foundation), <em><a href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf</a></em>.</li>&#13;
</ul>&#13;
</div>
</div>
</body></html>