<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="191" id="Page_191"/>11</span><br/>
<span class="ChapterTitle">Measuring and Simulating Time</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c11-0001" class="HeadProject"><span><span epub:type="pagebreak" title="192" id="Page_192"/>Sketch 86: Displaying a Clock</span></h2>
<p class="BodyFirst">Time in a computer program can mean many things. There is <span class="KeyTerm">execution time</span>, which is the number of CPU cycles used by a program to a particular point. There is <span class="KeyTerm">process time</span>, or the amount of time that a program has been active. There is <span class="KeyTerm">real time</span>, which is the time on your watch. We can also call that <span class="KeyTerm">clock time</span>. This sketch will acquire the clock time from the computer system and display it as the hands of a traditional clock.</p>
<p>Getting the time of day from Processing is easy. These are the basic functions:</p>
<ol class="none">
<li><code>hour()</code>: Returns the current hour in the day using a 24-hour clock.</li>
<li><code>minute()</code>: Returns the number of minutes past the hour.</li>
<li><code>second()</code>: Returns the number of seconds into the current minute.</li>
</ol>
<p>The clock will be a circle, and there will be three linear indicators (hands): a second hand, a minute hand, and an hour hand. Since there are 60 seconds in a minute, the second hand will rotate about its center point by 360/60, or 6 degrees each second. The same is true of the minute hand; since there are 60 seconds per minute and 60 minutes in an hour, it rotates 6 degrees per minute. The origin for drawing the second hand is the clock’s center, but the other endpoint is not known, only the angle. If the length of the second hand is <em>r</em>, then the second point can be determined with trigonometry, as seen in <a href="#figure86-1" id="figureanchor86-1">Figure 86-1</a>. </p>
<figure>
<img src="Images/f086001.png" alt="f086001" class="" width="616" height="305"/>
<figcaption><p><a id="figure86-1">Figure 86-1</a>: Determining the position of a clock hand</p></figcaption>
</figure>
<p>The angle as defined by Processing is not the same as that for a clock. On a clock, vertical represents 0, whereas in Processing that is −90 degrees. Drawing the second hand with (<code>cx</code>, <code>cy</code>) as the center point and with a length of <code>r</code> would be done as follows, where the variable <code>s</code> is the number of seconds <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>s = radians(second()*6 - 90.0);
line (cx, cy, cx + cos(s)*sr, cy+sin(s)*sr);</code></pre>
<p class="BodyContinued">The same scheme works for the minute hand, which is shorter. The hour hand should be shorter still, and the <code>hour()</code> value is divided by 2 if it exceeds 12. Also, there are only 12 hours in the 360-degree cycle, not 60, so each hour amounts to 30 degrees. The hour hand moves continuously around the face and does not jump when the hour changes, so each minute that passes should move the hour hand a little bit; 30 degrees (1 hour) is 60 minutes, so each minute moves the hour hand by 0.5 degrees <span class="CodeAnnotation" aria-label="annotation2">2</span>. This is the code:</p>
<pre><code>h = radians(hour()*30.0-90.0) + radians(minute()*0.5);</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>int cx=259, cy=380;
float hr = 8;
float mr = 15;
float sr = 20.0;
PImage clock;

void setup ()
{
  size(100,100);
  surface.setResizable(true);
  clock = loadImage ("clock.jpg");
  surface.setSize(clock.width, clock.height);
}

void draw ()
{
  float s, m, h;
  float angle, x, y;

  background(200);
  image (clock, 0, 0);

  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> s = radians(second()*6 - 90.0);
  m = radians(minute()*6 - 90.0);
  h = hour();

  if (h &gt; 12) h = h - 12;
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> h = radians(hour()*30.0-90.0) + radians(minute()*0.5);

  stroke(21);   // Draw the hands
  strokeWeight (2);
  line (cx, cy, cx + cos(s)*sr, cy + sin(s)*sr);
  line (cx, cy, cx + cos(m)*mr, cy + sin(m)*mr);
  strokeWeight(3);
  line (cx, cy, cx + cos(h)*hr, cy + sin(h)*hr);
}</code></pre>
<span epub:type="pagebreak" title="193" id="Page_193"/><figure class="graphic"><img src="Images/g086001.png" alt="g086001" width="449" height="546"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c11-0002" class="HeadProject"><span><span epub:type="pagebreak" title="194" id="Page_194"/>Sketch 87: Time Differences—Measuring Reaction Time</span></h2>
<p class="BodyFirst">Measuring the time between two events is the subject of this sketch: in particular, the time between a prompt by the computer and a response by the user, the <span class="KeyTerm">reaction time</span>. A typical (average) reaction time for a human is about 0.215 seconds. That is, between the time that a light goes on and the time that someone can press a button in response, an average of 215 milliseconds will pass. </p>
<p>This sketch measures reaction time by having the user click the mouse as quickly as they can when the background changes from grey to green. The background then changes back to grey, and the cycle repeats five times. The program measures the time between the screen turning green and the mouse click using the <code>millis()</code> function, and it averages the five trials to get a more precise measurement.</p>
<p>We use <code>millis()</code> because the function used in the previous sketch to move the second hand, <code>second()</code>, only returns whole seconds. <code>millis()</code> returns the number of milliseconds (1/1,000 seconds) since the sketch started executing. On the face of it, that value does not seem to have much meaning, but it does mean that the time difference between two events can be measured pretty accurately. Simply call <code>millis()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> when the first event happens, save the value, call it again when the second event occurs <span class="CodeAnnotation" aria-label="annotation2">2</span>, and subtract the two.</p>
<p>The <code>millis()</code> function can be used for other purposes, not the least of which is to determine how long it takes for a particular loop or function to execute. This sort of measurement is important when a program takes too long and the programmer needs to find ways to speed it up. Measuring one call to a function would not likely work, because most functions execute too quickly to measure, even slow functions. Instead, we put a function to be tested within a loop and execute it many times. We divide the time required to execute the loop by the number of iterations to determine the time needed for a single execution. Here is how the function <code>get(12,100)</code> could be timed:</p>
<pre><code>t1 = millis();
for (int i=0; i&lt;100000000; i++)   y = get(12,100);
t2 = millis();
println ("Time was "+(t2-t1)+" or "+((t2-t1)/100000000.0));</code></pre>
<p>The times obtained vary, so taking an average over many trials should give a more accurate result. Execution times may change depending on what other programs are executing at the same time or how many virtual memory page faults occurred.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>float m0,m1, sum=0;
int wait = 0, count=0;
boolean timing = false;

void setup () 
{
  size (400, 200);
  fill (0);
}

void draw () 
{
  if (timing) background(0,200,0);
  else background(200);
  text ("Count is "+count+"   You need "+(5-count)+" more trials.", 10, 180);
  text ("When the background turns green, click the mouse.", 10, 20);
  wait = wait + 1;
  if (wait &gt; random (5000) &amp;&amp; !timing) 
  {
    background(0, 200, 0);
    timing = true;
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> m0 = millis();
  }
  if (count == 5)
  {
    noLoop();
    sum = sum/count;  
    text ("Reaction time is "+sum/1000 + " seconds.", 20, 100);
  }
}

void mousePressed ()
{
  if (timing)
  {
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> m1 = millis();
    timing = false;
    sum = sum + (m1-m0);
    
    count = count + 1;
    wait = 0;
  } 
}</code></pre>
<span epub:type="pagebreak" title="195" id="Page_195"/><figure class="graphic"><img src="Images/g087001.png" alt="g087001" width="410" height="273"/></figure>
<figure class="graphic"><img src="Images/g087002.png" alt="g087002" width="410" height="204"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c11-0003" class="HeadProject"><span><span epub:type="pagebreak" title="196" id="Page_196"/>Sketch 88: M/M/1 Queue—Time in Simulations </span></h2>
<p class="BodyFirst">A <span class="KeyTerm">single-server queuing system</span>, or <span class="KeyTerm">M/M/1 queuing system</span>, is like a bank teller. Customers arrive at random times to the teller for service. The service requires some random amount of time, and then the customer departs. If the teller is busy with a customer when another one arrives, the new arrival waits in a <span class="KeyTerm">queue</span> or <span class="KeyTerm">waiting line</span>. When a departure occurs, the next customer in line is served; if there is no one in the queue, the teller (the <span class="KeyTerm">server</span>) becomes idle. This system resembles many that we see in real life: grocery checkouts, gas stations, waiting for a bus, even air traffic and ships arriving in a port.</p>
<p>This sketch simulates one server and one queue, but it can be adapted to do more, and it calculates the average queue length. The value in doing a simulation of such a system is in finding out how long the queue becomes, how much time a client spends in the queue, what percentage of the time the server is busy, and so on. All of this concerns costs and wasted time.</p>
<p>In the real world, time is continuous, but on the computer, that is not possible. Instead, the time of the simulation takes on discrete values: time = 0, time = 1.5, time = 3.99, and so on. When the simulation starts, we set the variable <code>time</code> to the time of the first arrival <span class="CodeAnnotation" aria-label="annotation1">1</span>, and the time after that will be the time of the event being processed. This is known as a <span class="KeyTerm">next event</span> simulation: the current time in the simulation keeps jumping ahead to the time of the next event (arrival or departure) that occurs.</p>
<p>Arrivals happen at random times according to a particular probability distribution. When an arrival happens, it (the customer) enters the queue for the service (teller). If there is no queue, it gets served immediately; otherwise it must wait. When it gets to the server (the teller), it will require some random amount of time to be served, and then it will leave. Here are the steps to handle each event:</p>
<table id="tabular-501645c11-0001" border="1"><tbody>
<tr>
<td><b>Arrival</b></td>
<td><b>Departure</b></td>
</tr>
<tr>
<td>1. Place the arrival into the queue <span class="CodeAnnotation" aria-label="annotation2">2</span>.</td>
<td>1. Remove the job from the queue <span class="CodeAnnotation" aria-label="annotation3">3</span>.</td>
</tr>
<tr>
<td>2. Is the server busy?</td>
<td>2. Queue empty?</td>
</tr>
<tr>
<td>3. If not, start the server.</td>
<td>3. If so, the server becomes idle.</td>
</tr>
</tbody>
<tbody>
<tr>
<td>4. Schedule the next arrival.</td>
<td>4. If not, schedule a departure.</td>
</tr>
</tbody>
</table>
<p>The queue is an array holding numbers. Adding to the queue means placing a new value (the randomly generated service time for the job) at the end of the queue. When a value departs the queue, it means removing the first element and moving each consecutive value forward by one place. The function <code>into(t)</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> inserts time <code>t</code> into the queue, whereas <code>out()</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> removes the front element from the queue. The queue is empty (or the system is idle) if there is nothing in the queue <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>The statistical distribution of times between arrivals and departures is according to the <span class="KeyTerm">negative exponential distribution</span>. If the average time between arrivals is μ, then this will be the time of the next arrival in the simulation:</p>
<p class="equation">–μ * log(<code>random(1)</code>)</p>
<p class="BodyContinued">A similar situation exists for departures.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>float queue[] = new float[200], end=2.0e3;
float miaTime=16.0, msTime=8.0,arrival,departure;
int Nqueue=0, nq;
float qsum=0.0, time=0.0; 
void setup ()
{
  size (500, 350);
  fill(0);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> arrival=-miaTime*log(random(1));
  departure = end*2;
}
void draw ()
{
  if (time&gt;end) return;
  background(200);
  if (arrival&lt;departure)
  {  // An arrival
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> into(time + -msTime*log(random(1)));
    arrival = time + -miaTime*log(random(1));
    if (departure&gt;end) departure = queue[Nqueue-1];
    time = arrival;
  } else if (departure&lt;end)
  { // A departure
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> out();
    time = departure;
    <span class="CodeAnnotationHang" aria-label="annotation4">4</span> if (Nqueue&gt;0) departure = queue[Nqueue-1];
    else departure = end*2;
  }
  fill (0); text ("Time "+time+"  Length is "+Nqueue+"  Mean length "+(qsum/nq),30,145);
  nq += 1; qsum += Nqueue;
}

<span class="CodeAnnotationHang" aria-label="annotation5">5</span> void into(float t)
{
  queue[Nqueue] = t;
  Nqueue = Nqueue + 1;
}

<span class="CodeAnnotationHang" aria-label="annotation6">6</span> void out ()
{
  if (Nqueue &lt;= 0) return;
  for (int i=0; i&lt;Nqueue-1; i++) queue[i] = queue[i+1];
  Nqueue = Nqueue - 1;
}</code></pre>
<span epub:type="pagebreak" title="197" id="Page_197"/><figure class="graphic"><img src="Images/g088001.png" alt="g088001" width="485" height="335"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>