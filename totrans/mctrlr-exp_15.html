<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2a" id="ch15"><span epub:type="pagebreak" id="page_143"/><strong>15  LPC1114 Bootloader Glitch</strong></h2>&#13;
<p class="noindent">In addition to the software vulnerabilities discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>, the LPC1114 and LPC1343 are vulnerable to voltage glitching attacks documented in Gerlinsky (2017), Nedospasov (2017), and Dewar (2018). This is a beginner’s glitching attack, a good first target to learn fault injection.</p>&#13;
<p class="indent">Before we get started, look at <a href="ch04.xhtml#ch4fig5">Figure 4.5</a> and review the explanation of the lock features in <a href="ch04.xhtml#ch04">Chapter 4</a>. When the lock level is CRP1, we can use the memory corruption exploit in that chapter to dump the chip’s memory, but in CRP2 and CRP3 the bootloader commands are so restricted that we can’t trigger the vulnerability. That’s where voltage glitching comes in.</p>&#13;
<p class="indent">You should also see in <a href="ch04.xhtml#ch4fig5">Figure 4.5</a> that a single word of flash memory controls the protection mode. <span class="literal">0x12345678</span> places us in CRP1, where the remote code execution exploit works. <span class="literal">0x4321-8765</span> places us in CRP3, where both JTAG and the ISP programming mode are entirely disabled. <span class="literal">0x87654321</span> is just as bad, allowing ISP but <em>only</em> the Mass Erase command.</p>&#13;
<p class="indent">The very last line of that table is the important one, and the reason why these chips are such an easy target for glitching. If the 32-bit word has <em>any other value</em> than the ones in that table, it defaults to being totally open to both JTAG debugging and ISP programming. While <span class="literal">0x43218765</span> or <span class="literal">0x87654321</span> will lock us out, a single bit error might change those to <span class="literal">0x43208765</span> or <span class="literal">0x87654331</span>, either of which would provide us with full access. The purpose of our fault injection will be to corrupt that word, providing just such a change.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_144"/><img id="ch15fig1" src="../images/f0144-01.jpg" alt="Image" width="777" height="869"/></div>&#13;
<p class="figcap">Figure 15.1: LPC111x</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_145"/><img id="ch15fig2" src="../images/f0145-01.jpg" alt="Image" width="951" height="647"/></div>&#13;
<p class="figcap">Figure 15.2: Olimex LPC-P1114 Schematic</p>&#13;
<h3 class="h3" id="ch00lev1sec47"><span epub:type="pagebreak" id="page_146"/><strong>Hardware Modifications</strong></h3>&#13;
<p class="noindent">Gerlinsky, Nedospasov, and Dewar each made slightly different modifications to the Olimex development kit in <a href="ch15.xhtml#ch15fig2">Figure 15.2</a>, but the general principle is the same.</p>&#13;
<p class="indent">First, we want to remove the 100nF decoupling capacitor, which is C4 in the schematic. The purpose of this capacitor is to prevent momentary drops in voltage from causing faults in the chip, and we’re removing it because our intention is to cause this momentary failure. Leaving it in would make glitching much more difficult.</p>&#13;
<p class="indent">The decoupling capacitor for this chip is designed to sit between the VSS and 3.3V VDD lines, but on many other chips you’ll find multiple decoupling capacitors or you’ll find that the cap is on a dedicated pin at a lower voltage, the CPU core voltage.</p>&#13;
<p class="indent">The board also has two traces that might be cut, and we need to cut both of them. <span class="literal">3.3V_IO_E</span> connects C1 and the VDDIO pin to the 3.3V power rail, while <span class="literal">3.3V_CORE</span> connects the VDD pin to the 3.3V rail. We’ll cut both, then reconnect the two sides of the cut <span class="literal">3.3V_CORE</span> trace with a 12 Ω resistor. This lets us measure the power consumption of the chip, as the current consumption will cause a very small voltage drop across the resistor. Such a measurement is not necessary to perform the glitch after timing is known but can be very handy for discovering the timing.</p>&#13;
<p class="indent">Shorting <span class="literal">P0_3</span> to ground will enable the bootloader mode. We will also add an SMA connector to expose ground and the 3.3V power rail to our voltage glitcher. The glitching hardware itself is just briefly shorting those two pins together, and while Dewar (2018) uses a ChipWhisperer and Gerlinsky (2017) uses a microcontroller board, you can short them with a transistor and nearly anything that sends a short pulse to that transistor with predictable timing after reset.</p>&#13;
<h3 class="h3" id="ch00lev1sec48"><span epub:type="pagebreak" id="page_147"/><strong>How Hard to Glitch?</strong></h3>&#13;
<p class="noindent">We now have an SMA connector through which we can glitch the chip, briefly shorting the voltage rail to ground without a decoupling capacitor to save it. Before we can get to the question of timing, we need to know at least roughly how much of a glitch to apply. Too much of a glitch will crash or reboot the target, while too little of a glitch will have no effect at all, as the voltage drop will be attenuated by the natural capacitance and line length until nothing happens.</p>&#13;
<p class="indent">If we imagine the idle state of this pin as a flat 3.3V voltage that we’ll drop low, there are two basic parameters to our glitch: the <em>depth</em> and the <em>duration</em>.</p>&#13;
<p class="indent">The depth of a glitch is the voltage to which we will drop the pin. It’s usually measured from the side of the glitcher, with the understanding that the target won’t fall immediately to that voltage and might not fall all the way to it. A “crowbar” glitcher, such as the ChipWhisperer, simply shorts the two rails together with a MOSFET, so its depth is effectively ground.</p>&#13;
<p class="indent">You’ll generally find crowbar glitchers on more recent devices, because the clock rate allows them to run fast enough that the glitch won’t crash the target. They are also quite simple to place on the circuit board, with nothing more than a MOSFET transistor controlled by a GPIO pin of the attacking microcontroller. Common choices of MOSFET include the IRLML6246 and IRF8736.</p>&#13;
<p class="indent">Back in the days of TV piracy, it was more common to use a 74HC4053 multiplexer to jump between full voltage and the deep voltage. During development, both could be supplied by a bench power supply, and the glitches would be a little wider but not quite so deep.</p>&#13;
<p class="indent">Having either one dimension (duration) or two (duration and <span epub:type="pagebreak" id="page_148"/>depth) to calibrate, we’d much rather find the right values before involving the extra dimension of time. This is most conveniently done by running a program from flash or from RAM that is intentionally designed to be an easy target.</p>&#13;
<p class="indent">When the settings are roughly correct, this code will start printing to the serial port. It’s important the three variables are all volatile so that the C compiler will not optimize away their differences.</p>&#13;
<div class="imagel"><img src="../images/f0148-01.jpg" alt="Image" width="811" height="229"/></div>&#13;
<p class="indent">Of course, we can only train our parameters on this code because the chip we are attacking is also available as an unlocked part for commercial use. When glitching a smart card, or anything else in which an unlocked sample is not available, the procedure is usually to glitch some other behavior, like the readout of the device serial number.</p>&#13;
<h3 class="h3" id="ch00lev1sec49"><strong>When to Glitch?</strong></h3>&#13;
<p class="noindent">Now that we know how wide (in duration) and how deep (in voltage) to glitch to cause a fault, we still need to know when to trigger the glitch. We’ll first choose a trigger as the beginning of time, then choose a measure of time to count after that trigger, and finally search for a range of times that might be running a vulnerable instruction worth glitching.</p>&#13;
<p class="indent">This is usually measured as some number of microseconds or clock cycles after a particular event, such as the reset line rising <span epub:type="pagebreak" id="page_149"/>high. It’s important to distinguish between the target’s clock signal, which will be rather tightly coupled to the internal CPU clock, and the attacker’s clock signal, which is rather loosely coupled and really just another way to measure wall clock time.</p>&#13;
<p class="indent">The target’s clock input pin used to be a very good way to accurately target specific instructions, but these days many chips like the LPC11 default to an internal oscillator as the bootloader’s system clock, only jumping over to an external crystal in the main application. Other chips use an internal phase-locked loop (PLL) to multiply an external clock’s frequency, providing some relation but at a weak resolution. In this chapter, we’ll ignore the external oscillator and use wall time instead.</p>&#13;
<p class="indent">Now that we have chosen a measure of time, and we have chosen the rise of the reset pin as zero time, we need to know when to apply a glitch to unlock the bootloader. On other targets, we might do this through power analysis, running our SMA connector to a T-junction that reaches both the glitcher and an oscilloscope. On this target we have something better: a dump of the boot ROM, which we made for writing our shellcode in <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>&#13;
<p class="indent">Recall from that chapter that the bootloader checks its lock state many times, but that it is always checking a copy in SRAM that is made early in the boot sequence. That’s why the shell-code for the software exploit simply rewrites the SRAM copy of the CRP level and jumps right back into the main loop of the bootloader, reusing its code with a privilege escalation.</p>&#13;
<div class="imagel"><img src="../images/f0149-01.jpg" alt="Image" width="811" height="159"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_150"/>In this glitching attack we don’t have a write primitive, of course, but we know that there is an instruction or two doing the copy. Maybe we flip a bit as it’s read from flash memory, or maybe we flip a bit as it’s written to SRAM, or maybe we flip an opcode bit to make it a different instruction.</p>&#13;
<p class="indent">On 8-bit CISC chips, we might come up with this by simply counting instructions and their cycle costs. As the LPC11 is a pipelined RISC chip, that becomes a little labor intensive, as any glitch will be impacting multiple instructions at once. Another option for some ARM chips is to use the Embedded Trace Macrocell (ETM), which allows an external debugger to trace every instruction as it’s executed. We might also run a modified version of the boot ROM from RAM, patched to reveal its timing through a GPIO pin.</p>&#13;
<p class="indent">Without resorting to those fancy tricks, we still have some timing clues. We know that the ROM can’t begin execution before the reset line goes high, and we know that it must be past the target instruction when it accepts our first command. If we’re patient, we can sweep across this entire range until the chip unlocks, then repeat the effect in far less time knowing the offset.</p>&#13;
<p class="indent">It’s not uncommon for chips to be exploited this way, with a glitcher sitting on a rack or in a closet for days or weeks before the right timing emerges.</p>&#13;
<p class="indent">Dewar (2018) suggests that attacking from a 100MHz clock, unlocks were seen with roughly ten glitches between 5,100 and 5,300 cycles. One board worked best with ten pulses at 5,211 ticks, while another worked best with eleven pulses at 5,181 ticks. The variance likely comes from the internal R/C oscillator of the target chip, or the room temperature, and it’s not at all strange for different targets to successfully unlock at different times.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_151"/><img src="../images/f0151-01.jpg" alt="Image" width="822" height="1103"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_152"/><img src="../images/f0152-01.jpg" alt="Image" width="822" height="1117"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_153"/><img src="../images/f0153-01.jpg" alt="Image" width="831" height="1117"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_154"/><img src="../images/f0154-01.jpg" alt="Image" width="832" height="1117"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_155"/><img src="../images/f0155-01.jpg" alt="Image" width="833" height="917"/><span epub:type="pagebreak" id="page_156"/></div>&#13;
</div>
</div>
</body></html>