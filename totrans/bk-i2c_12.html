<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_147" title="147"/>9</span><br/>&#13;
<span class="ChapterTitle">Raspberry Pi (and Linux) I<sup>2</sup>C Programming</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">After the Arduino, the Raspberry Pi probably ranks second highest in I<sup>2</sup>C bus usage. In some respects, the I<sup>2</sup>C bus is probably even more important to Raspberry Pi hardware hackers than Arduino users because the Pi provides nothing in the way of analog-to-digital converters. Most often, Pi users add such capabilities to their systems using the I<sup>2</sup>C bus.</p>&#13;
<p><span epub:type="pagebreak" id="Page_148" title="148"/>This chapter discusses the following:</p>&#13;
<ul>&#13;
<li>The I<sup>2</sup>C bus on the Raspberry Pi’s GPIO header </li>&#13;
<li>How to activate the I<sup>2</sup>C bus on the Raspberry Pi (by default, it is deactivated)</li>&#13;
<li>How to set the I<sup>2</sup>C bus speed, which may be necessary for slow peripherals as the Pi does not support clock stretching</li>&#13;
<li>How to use the I<sup>2</sup>C utility package on the Pi</li>&#13;
<li>Programming I<sup>2</sup>C devices on the Pi</li>&#13;
<li>I<sup>2</sup>C on other Linux-based systems</li>&#13;
<li>A bit-banging implementation of I<sup>2</sup>C on the Raspberry Pi to overcome some of the Pi’s limitations</li>&#13;
</ul>&#13;
<p>Although this chapter specifically discusses the Raspberry Pi single-board computer, Pi OS is really just a variant of the Linux operating system, so much of the information in this chapter covers generic Linux systems as well as the Raspberry Pi.</p>&#13;
<h2 id="h1-502468c09-0001">	9.1	The I<sup>2</sup>C Bus Pins on the Pi General-Purpose Input/Output Header</h2>&#13;
<p class="BodyFirst">The Raspberry Pi has always supported at least one I<sup>2</sup>C bus on the GPIO connector. Pins 3 and 5 (GPIO 2 and GPIO 3) provide the SDA and SCL lines, respectively. These pins were available on the original 26-pin GPIO header. </p>&#13;
<p>After the introduction of the Raspberry Pi B+, the GPIO header was extended to 40 pins, and a second hardware I<sup>2</sup>C bus was added. This second I<sup>2</sup>C bus (on pins 27 and 28 of the 40-pin header; see <a href="#figure9-1" id="figureanchor9-1">Figure 9-1</a>) was originally intended to connect to EEPROM devices on Pi HATs—Raspberry Pi add-on boards whose name stands for “hardware attached on top.” The I<sup>2</sup>C EEPROM device provided identification information for the board so the operating system could identify it and load an appropriate device driver in a “plug-and-play” fashion.</p>&#13;
<p>The second I<sup>2</sup>C lines were originally intended for EEPROM, camera, and DSI display use. Enabling these lines could cause the display, camera, and HAT units to malfunction, so most programmers and system designers leave these lines alone. However, if you are not using any of these devices, you could use the I<sup>2</sup>C bus on pins 27 and 28 for your own purposes.</p>&#13;
<p>Technically, there is a third I<sup>2</sup>C bus on the HDMI connector (a 5-V variant to support VESA E-DDC). In theory, you could use it with a bit of work. However, this book will not consider the use of that bus as it’s really intended for use by the video display subsystem.</p>&#13;
<span epub:type="pagebreak" id="Page_149" title="149"/><figure>&#13;
<img alt="" class="" height="917" src="image_fi/502468c09/f09001.png" width="659"/>&#13;
<figcaption><p><a id="figure9-1">Figure 9-1</a>: Main and alternate (HAT EEPROM) I<sup>2</sup>C pins on Raspberry Pi bus</p></figcaption>&#13;
</figure>&#13;
<p>With the arrival of the Raspberry Pi 4, the number of possible I<sup>2</sup>C buses increased yet again. <a href="#figure9-2" id="figureanchor9-2">Figure 9-2</a> shows the pinout of the 40-pin GPIO connector on the Raspberry Pi 4.</p>&#13;
<span epub:type="pagebreak" id="Page_150" title="150"/><figure>&#13;
<img alt="" class="" height="917" src="image_fi/502468c09/f09002.png" width="697"/>&#13;
<figcaption><p><a id="figure9-2">Figure 9-2</a>: Raspberry Pi 4 GPIO pinout</p></figcaption>&#13;
</figure>&#13;
<p><a href="#figure9-2">Figure 9-2</a> shows six I<sup>2</sup>C buses on the Raspberry Pi 4:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">i2c-0</span>  SDA0 and SCL0 on pins 27 and 28</li>&#13;
<li><span class="RunInHead">i2c-1</span>  SDA1 and SCL1 on pins 3 and 5 </li>&#13;
<li><span class="RunInHead">i2c-3</span>  SDA3 and SCL3 on pins 7 and 29</li>&#13;
<li><span class="RunInHead">i2c-4</span>  SDA4 and SCL4 on pins 31 and 26</li>&#13;
<li><span class="RunInHead">i2c-5</span>  SDA5 and SCL5 on pins 32 and 33</li>&#13;
<li><span class="RunInHead">i2c-6</span>  SDA6 and SCL6 on pins 15 and 16 (shares these pins with i2c-0)</li>&#13;
</ol>&#13;
<p><span epub:type="pagebreak" id="Page_151" title="151"/>Note that the i2c-1 bus on the Raspberry Pi provides pullup resistors to +3.3 V. The remaining I<sup>2</sup>C ports do not. Therefore, if you activate any I<sup>2</sup>C bus other than i2c-1, you will need to add pullup resistors for the bus to work properly.</p>&#13;
<h2 id="h1-502468c09-0002">	9.2	Manually Activating the I<sup>2</sup>C Buses </h2>&#13;
<p class="BodyFirst">By default, the Raspberry Pi OS does not enable any of the I<sup>2</sup>C buses on the GPIO connector—those pins default to their GPIO pin definitions. You can use the raspi-config application to activate the I<sup>2</sup>C bus. This application will automatically edit appropriate system files to activate the I<sup>2</sup>C bus. If you would like to manually make these changes yourself, you must edit a couple files on the Raspberry Pi to enable the appropriate I<sup>2</sup>C bus(es). </p>&#13;
<p>If you want to activate i2c-1, you will need to edit the <em>/boot/config.txt</em> text file as the superuser. In this file you will usually find the following line:</p>&#13;
<pre><code>#dtparam=i2c_arm=on</code></pre>&#13;
<p>The <code>#</code> at the beginning of this statement turns the whole line into a comment, making the statement invisible to the system and the I<sup>2</sup>C bus inactivated. To activate the I<sup>2</sup>C bus, simply delete the <code>#</code> character at the beginning of the line.</p>&#13;
<p>The <code>i2c_arm</code> label tells you that this particular I<sup>2</sup>C port is part of the ARM processor (the CPU on the Raspberry Pi). The second I<sup>2</sup>C port (pins 27 and 28, which is really Linux port i2c-0) is part of the video controller chip. You could activate that I<sup>2</sup>C bus with the following statement:</p>&#13;
<pre><code>dtparam=i2c_vc=on</code></pre>&#13;
<p>However, the Raspberry Pi documentation is pretty clear that i2c-0 is reserved for HAT EEPROMs and you are not supposed to use it for other purposes (see <a class="LinkURL" href="https://github.com/raspberrypi/hats/blob/master/designguide.md">https://github.com/raspberrypi/hats/blob/master/designguide.md</a>). Abuse this suggestion at your own risk.</p>&#13;
<p>If you edit the <code>dtparam=i2c_arm=on</code> statement in <em>/boot/config.txt</em> and reboot, you’ll discover that the I<sup>2</sup>C bus is still not available. This is because Raspberry Pi OS uses loadable kernel modules (LKMs) to handle I<sup>2</sup>C processing. At this point the system hasn’t loaded the appropriate module. To do that, execute the following two commands:</p>&#13;
<pre><code>modprobe i2c-bcm2708 #Note:use i2c-bcm2835 on Pi zero W, 3, and 4&#13;
modprobe i2c-dev</code></pre>&#13;
<p>Of course, manually loading these modules every time you boot the system can get old fast if you’re using the I<sup>2</sup>C all the time. If you edit the <em>/etc/modules</em> file as superuser and add the following two lines to the file, the system will automatically load those modules when you boot the system:</p>&#13;
<pre><code>i2c-bcm2708&#13;
i2c-dev</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_152" title="152"/>If you have a Raspberry Pi 4 system, you can enable additional I<sup>2</sup>C buses by adding one or more of the following lines to the <em>/boot/config.txt</em> text file:</p>&#13;
<pre><code>dtoverlay=i2c1,pins_2_3&#13;
dtoverlay=i2c3,pins_4_5&#13;
dtoverlay=i2c4,pins_6_7&#13;
dtoverlay=i2c5,pins_12_13&#13;
dtoverlay=i2c6,pins_22_23</code></pre>&#13;
<p>The pin numbers to which the <code>pins</code><var>_xx_yy</var> parameters refer are the GPIO pin numbers, not the physical pin numbers on the Pi 40-pin connector. <a href="#table9-1" id="tableanchor9-1">Table 9-1</a> lists the correspondence between GPIO pin numbers and physical pin numbers. See <a class="LinkURL" href="https://www.raspberrypi.com/documentation/computers/os.xhtml#gpio-and-the-40-pin-header">https://www.raspberrypi.com/documentation/computers/os.xhtml#gpio-and-the-40-pin-header</a> for more information.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table9-1">Table 9-1</a>: GPIO Pins to Physical Pin Numbers</p></figcaption>&#13;
<table border="1" id="table-502468c09-0001">&#13;
<thead>&#13;
<tr>&#13;
<td><b>GPIO pin number</b></td>&#13;
<td><b>Connector pin number</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>GPIO 2</td>&#13;
<td>Board pin 3</td>&#13;
</tr>&#13;
<tr>&#13;
<td>GPIO 3</td>&#13;
<td>Board pin 5</td>&#13;
</tr>&#13;
<tr>&#13;
<td>GPIO 4</td>&#13;
<td>Board pin 7</td>&#13;
</tr>&#13;
<tr>&#13;
<td>GPIO 5</td>&#13;
<td>Board pin 29</td>&#13;
</tr>&#13;
<tr>&#13;
<td>GPIO 6</td>&#13;
<td>Board pin 31</td>&#13;
</tr>&#13;
<tr>&#13;
<td>GPIO 7</td>&#13;
<td>Board pin 26</td>&#13;
</tr>&#13;
<tr>&#13;
<td>GPIO 12</td>&#13;
<td>Board pin 32</td>&#13;
</tr>&#13;
<tr>&#13;
<td>GPIO 13</td>&#13;
<td>Board pin 33</td>&#13;
</tr>&#13;
<tr>&#13;
<td>GPIO 22</td>&#13;
<td>Board pin 15</td>&#13;
</tr>&#13;
<tr>&#13;
<td>GPIO 23</td>&#13;
<td>Board pin 16</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>Finally, make sure the following line is present in <em>config.txt</em>:</p>&#13;
<pre><code>enable_uart= 1</code></pre>&#13;
<p>In theory, enabling the UART (serial port) shouldn’t have anything to do with I<sup>2</sup>C on the Pi. In practice (at least on a Pi 3), if you don’t include this line, the system will run the SCL line at about 65 kHz rather than the nominal 100 kHz.</p>&#13;
<h2 id="h1-502468c09-0003">	9.3	Changing the I<sup>2</sup>C Clock Frequency</h2>&#13;
<p class="BodyFirst">By default, Raspberry Pi sets the I<sup>2</sup>C clock frequency to 100 kHz. To change the speed of the main I<sup>2</sup>C bus (i2c-1), use the following statement in <em>/boot/config.txt</em>: </p>&#13;
<pre><code><code>dtparam=i2c_arm_baudrate=</code><var>xxxxxx</var></code></pre>&#13;
<p class="BodyContinued"><span epub:type="pagebreak" id="Page_153" title="153"/>where <var>xxxxxx</var> stands for the clock frequency (for example, <code>100000</code>) that you want to use. Normally, you would place this statement immediately after <code>dtparam=i2c_arm=on</code> in that file.</p>&#13;
<p>The Raspberry Pi OS will choose an available clock frequency that is less than or equal to the value you specify. </p>&#13;
<p>On the Raspberry Pi 4, you can set the clock frequency of i2c-3, -4, -5, and -6 using the following statements:</p>&#13;
<pre><code>dtoverlay=i2c3,pins_4_5&#13;
dtparam=baudrate=<var>xxxxxx</var> #sets clock frequency for i2c-3&#13;
dtoverlay=i2c4,pins_6_7&#13;
dtparam=baudrate=<var>xxxxxx</var> #sets clock frequency for i2c-4&#13;
dtoverlay=i2c5,pins_12_13&#13;
dtparam=baudrate=<var>xxxxxx</var> #sets clock frequency for i2c-5&#13;
dtoverlay=i2c6,pins_22_23&#13;
dtparam=baudrate=<var>xxxxxx</var> #sets clock frequency for i2c-6</code></pre>&#13;
<p>Once again, Pi OS will choose a clock frequency that is less than or equal to the actual value you specify.</p>&#13;
<h2 id="h1-502468c09-0004">	9.4	I<sup>2</sup>C Clock Stretching Issues and Solutions</h2>&#13;
<p class="BodyFirst">At the time of writing, there has long been a known issue with the I<sup>2</sup>C protocol on the Raspberry Pi: the Pi does not support clock stretching. This issue seems to be with the hardware; it’s been around so long (and across many different Raspberry Pi models) that you’d expect it to have been fixed by now if it were software. The bottom line is that if you have an I<sup>2</sup>C device that depends on adding wait states via clock stretching, that device may not work very well on a standard Pi I<sup>2</sup>C setup.</p>&#13;
<p>This problem has two solutions. The first is a big kludge: reduce the SCL clock frequency using the techniques from the previous section, hoping to slow the clock down enough that the clock period provides enough time for the peripheral to do its thing. Adafruit, for example, suggests setting the I<sup>2</sup>C clock frequency (<em>baudrate</em> in <em>config.txt</em> notation) to 10 kHz. Ideally, this is so slow that it gives your peripherals sufficient time to process the I<sup>2</sup>C data.</p>&#13;
<p>Slowing down the clock frequency is unsatisfactory for two main reasons. First, there is no guarantee that the new, slower clock frequency provides enough time for an arbitrary peripheral to do its work. Second, this technique slows down all bit transfers, including those to and from peripherals that don’t use clock stretching as well as all the bits that don’t need clock stretching on the devices that use it. In sum, this approach doesn’t guarantee success and is very inefficient to boot.</p>&#13;
<p>The second solution is to use a <em>bit-banging</em> (software) I<sup>2</sup>C transmission. Software I<sup>2</sup>C processing can handle bit stretching properly. True, bit-banging is much slower and less efficient than a hardware implementation, but probably no more so than slowing down the hardware SCL frequency.</p>&#13;
<p><span epub:type="pagebreak" id="Page_154" title="154"/>To set up a software-controlled I<sup>2</sup>C bus using (arbitrary) GPIO pins, add the following statement to your <em>/boot/config.txt</em> file:</p>&#13;
<pre><code>dtoverlay=i2c-gpio,bus=<var>x</var>,i2c_gpio_sda=<var>y</var>,i2c_gpio_scl=<var>z</var></code></pre>&#13;
<p class="BodyContinued">where <var>x</var> represents a bus number, and <var>y</var> and <var>z</var> represent GPIO pins on the Raspberry Pi GPIO connector. This creates an I<sup>2</sup>C device using the name <code>i2c-</code><var>x</var> that operates on the specified GPIO pins (these are the GPIO pin number designations, not the physical pin numbers on the Pi GPIO connector).</p>&#13;
<p>If the <code>i2c_gpio_sda</code> parameter is not present, the system will use GPIO 23 as the default (physical pin 16 on the connector). If the <code>i2c_gpio_scl</code> parameter is not present, the system will use GPIO 24 (physical pin 18) as the default. If the <code>bus</code> parameter is not present, the system will dynamically assign a device number, so you really should explicitly provide the <code>bus</code> argument.</p>&#13;
<p>Note that the i2c-gpio device can use any arbitrary GPIO pins; you don’t have to specify pins that have I<sup>2</sup>C hardware associated with them. This means you can actually increase the number of supported I<sup>2</sup>C buses in the system by using software-based I<sup>2</sup>C devices (though, to be honest, if you need additional I<sup>2</sup>C buses, an I<sup>2</sup>C multiplexer is probably a better solution).</p>&#13;
<p>As a general rule, I would advise putting all I<sup>2</sup>C devices that depend on clock stretching on an i2c-gpio device and place all other I<sup>2</sup>C devices on hardware-based I<sup>2</sup>C buses to make your system more efficient.</p>&#13;
<h2 id="h1-502468c09-0005">	9.5	Raspberry Pi OS (Linux) I<sup>2</sup>C Utilities</h2>&#13;
<p class="BodyFirst">Several I<sup>2</sup>C-specific utilities are useful on the Raspberry Pi. In addition to these, a few normal Linux and Raspberry Pi commands are also of interest when working with I<sup>2</sup>C devices.</p>&#13;
<p>First, to determine whether the I<sup>2</sup>C device drivers are even operational, enter the following Linux command:</p>&#13;
<pre><code><b>ls /dev/i2c*</b></code></pre>&#13;
<p>This command lists all the Linux I<sup>2</sup>C devices you can currently access. For example, on my Raspberry Pi 4, I got the following output:</p>&#13;
<pre><code>/dev/i2c-1 /dev/i2c-6</code></pre>&#13;
<p class="BodyContinued">which tells me that I<sup>2</sup>C interface 1 (i2c-1, on pins 3 and 5) and I<sup>2</sup>C interface 6 (i2c-6, on pins 15 and 16) are currently active. Before even attempting to run an application that uses the I<sup>2</sup>C signals, you should issue this command to verify that the I<sup>2</sup>C buses are functioning.</p>&#13;
<p>The remaining four utilities I will discuss in this section are part of the i2c-tools package. Originally, Raspberry Pi OS did not include these tools by default, though later versions of Pi OS seem to include them. If <span epub:type="pagebreak" id="Page_155" title="155"/>they are not present on your system, you must download them using the following command:</p>&#13;
<pre><code><b>sudo apt-get install i2c-tools libi2c-dev </b></code></pre>&#13;
<p>This installs the four programs, <code>i2cdetect</code>, <code>i2cdump</code>, <code>i2cget</code>, and <code>i2cset</code>, on your system. The <code>i2cdump</code> utility is mainly useful for viewing the contents of I<sup>2</sup>C EEPROM devices. We won’t consider that application any further here; see the Linux man page for more information about this code.</p>&#13;
<p>The <code>i2cget</code> and <code>i2cset</code> programs allow you to read a byte or word from certain I<sup>2</sup>C devices or write a byte or word to certain I<sup>2</sup>C devices. Because of the way they operate, they will prove to be of marginal value to us in this chapter. Both applications assume that they write a register number to the I<sup>2</sup>C address followed by additional data to write to that register (in the case of <code>i2cset</code>) or that they write a register number and then read data from the specified register number (in the case of <code>i2cget</code>). This works well for I<sup>2</sup>C devices such as the MCP23017 GPIO expander IC. It does not work well for devices such as the MCP4725 DAC we’re using as an example in this chapter. </p>&#13;
<p>To run the <code>i2cget</code> application, enter the following (the items in braces are optional):</p>&#13;
<pre><code><b>i2cget {-y}</b> <var class="bold">i2cbus</var> <var class="bold">device_address</var> <b>{</b><var class="bold">register</var> <b>{</b><var class="bold">mode</var><b>}}</b>&#13;
<b>i2cget -y</b> <var class="bold">i2cbus device_address register mode</var></code></pre>&#13;
<p class="BodyContinued">where <var>i2cbus</var> is the number of an active I<sup>2</sup>C bus (such as <em>1</em> for <em>i2c-1</em>), <var>device_address</var> is the 7-bit I<sup>2</sup>C address of the device to read from, <var>register</var> is an 8-bit register number (specifying a particular register on the device), and <var>mode</var> is one of the letters <code>b</code>, <code>w</code>, or <code>c</code> (corresponding to byte, word, or R/W byte, respectively). If the <var>register</var> operand is present, this command will place the I<sup>2</sup>C address on the bus and write the <var>register</var> value to the I<sup>2</sup>C address. On a device such as the MCP23017, this sets the register inside the IC to read. The next operation is a read operation, with the system reading the specified register value from the IC. In the case of the MCP4725, there are no registers you can select by first writing a byte to the IC, so you should never specify the <var>register</var> argument when using this command. Doing so will write a value to the MCP4725 and affect the analog output.</p>&#13;
<p>Unfortunately, the <code>i2cget</code> application is poorly matched to the MCP4725. The MCP4725 returns 5 bytes of data when you read from the chip. The <code>i2cget</code> command will read a maximum of 2 bytes. There is no real way to use this command to read all the MCP4725 data, so we will ignore this command until Chapter 13.</p>&#13;
<p>The <code>i2cset</code> command is the output version of the <code>i2cget</code> program. It has the following syntax:</p>&#13;
<pre><code><b>i2cset {-y}</b> <var class="bold">i2cbus</var> <var class="bold">device_address</var> <var class="bold">data_address</var> <b>{</b><var class="bold">value</var>} <b>{</b><var class="bold">mode</var><b>}</b></code></pre>&#13;
<p class="BodyContinued"><span epub:type="pagebreak" id="Page_156" title="156"/>where <var>i2cbus</var> and <var>device_address</var> have the same meanings as for the <code>i2cget</code> command. The <var>data_address</var> argument is effectively the same thing as the <var>register</var> operand in the <code>i2cget</code> command: it’s a byte value that is written to the IC immediately after the address byte is placed on the bus with the assumption that this is selecting some register on the IC. </p>&#13;
<p>Again, the fact that it expects to be able to write a register (<var>data_address</var>) makes this program somewhat incompatible with the MCP4725 DAC. However, with some hackery, this one can actually be made to work with the DAC. The MCP4725 expects a 3-byte transmission (for the Fast Mode Write command). The first byte, of course, is the address and R/W bit, the second byte is the HO 4 bits of the 12-bit DAC value, and the third byte is the LO 8 bits of the DAC value. As it turns out, the <code>i2cset</code> command can be coerced to output this data using the following syntax:</p>&#13;
<pre><code>i2cset -y <var>i2cbus</var> <var>device_address</var> <var>HOByte</var> <var>LOByte</var></code></pre>&#13;
<p class="BodyContinued">where <var>HOByte</var> is the upper 4 bits of the DAC output value and <var>LOByte</var> is the lower 8 bits of the DAC value.</p>&#13;
<p>Of the four utilities in the i2c-tools package, the <code>i2cdetect</code> program is, without question, the most useful of the batch. As its name suggests, this program detects I<sup>2</sup>C devices on the I<sup>2</sup>C bus. This program has three main forms, which the following paragraphs describe.</p>&#13;
<pre><code><b>i2cdetect -l</b></code></pre>&#13;
<p>The first form scans the system for all available I<sup>2</sup>C buses and displays them. Note that the command-line option is <code>l</code> (the letter L, for <em>list</em>), not <code>1</code> (one). This command is similar to using <code>ls /dev/i2c*</code> to identify available I<sup>2</sup>C buses. Executing this command on a Raspberry Pi 3 with I<sup>2</sup>C enabled, I get the following output:</p>&#13;
<pre><code>i2c-1 i2c bcm2835 (i2c@7e804000) I2C adapter</code></pre>&#13;
<p>The second form of the <code>i2cdetect</code> command outputs status and capability information about the I<sup>2</sup>C bus you specify as an argument:</p>&#13;
<pre><code><b>i2cdetect -F </b><var class="bold">bus</var></code></pre>&#13;
<p>Here’s some sample output on the Raspberry Pi for <code>i2c-1</code>:</p>&#13;
<pre><code>Functionalities implemented by /dev/i2c-1:&#13;
I2C                              yes&#13;
SMBus Quick Command              yes&#13;
SMBus Send Byte                  yes&#13;
SMBus Receive Byte               yes&#13;
SMBus Write Byte                 yes&#13;
SMBus Read Byte                  yes&#13;
SMBus Write Word                 yes&#13;
SMBus Read Word                  yes&#13;
SMBus Process Call               yes&#13;
SMBus Block Write                yes&#13;
<span epub:type="pagebreak" id="Page_157" title="157"/>SMBus Block Read                 no&#13;
SMBus Block Process Call         no&#13;
SMBus PEC                        yes&#13;
I2C Block Write                  yes&#13;
I2C Block Read                   yes</code></pre>&#13;
<p>For a description of these Linux-kernel level functionalities, visit <a class="LinkURL" href="https://www.kernel.org/doc/html/latest/i2c/functionality.xhtml">https://www.kernel.org/doc/html/latest/i2c/functionality.xhtml</a>.</p>&#13;
<p>The third form of the <code>i2cdetect</code> command scans the bus looking for valid I<sup>2</sup>C devices and (if possible) reports their presence: </p>&#13;
<pre><code><b>i2cdetect {-y} {-a} {-q|-r} </b><var class="bold">bus</var><b> {</b><var class="bold">first last</var><b>}</b></code></pre>&#13;
<p class="BodyContinued">where <var>bus</var> is an I<sup>2</sup>C bus specification (either an integer such as <code>1</code> or the bus name such as <code>i2c-1</code>). The optional <var>first</var> and <var>last</var> parameters are device addresses (with <var>first</var> &lt; <var>last</var>) that limit the range of I<sup>2</sup>C bus addresses that <code>i2cdetect</code> will scan.</p>&#13;
<p>Generally, use the command as follows or supply a different bus value as the argument:</p>&#13;
<pre><code><b>i2cdetect 1</b></code></pre>&#13;
<p>After entering the command, you’ll get a warning prompt that this command may mess with I<sup>2</sup>C devices on the bus. Knowing this, you’ll be asked to verify that you want the command to probe the bus. </p>&#13;
<p>If you would prefer not to respond to this prompt when running <code>i2cdetect</code> (for example, from within a shell script), add the <code>-y</code> option, which tells the program “answer yes to the question”:</p>&#13;
<pre><code><b>i2cdetect -y 1</b>&#13;
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f&#13;
00:          -- 04 -- -- -- -- -- -- -- -- -- -- -- &#13;
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- &#13;
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- &#13;
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- &#13;
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- &#13;
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- &#13;
60: -- -- 62 -- -- -- -- -- -- -- -- -- -- -- -- -- &#13;
70: -- -- -- -- -- -- -- --</code></pre>&#13;
<p>This matrix shows the valid I<sup>2</sup>C addresses and whether <code>i2cdetect</code> has found a device at that address. The <code>--</code> entries indicate that <code>i2cdetect</code> doesn’t believe a device is at that address, and a hexadecimal number in the matrix indicates that a device exists at that address. In this case, <code>i2cdetect</code> found two devices at addresses 0x04 (probably the Broadcom I<sup>2</sup>C hardware, as that address is reserved for high-speed controllers) and 0x62 (the Adafruit MCP4725 I currently have wired to the bus).</p>&#13;
<p>If a <code>UU</code> appears in one of the matrix entries, a device is installed at that address but is currently in use by the kernel, which commonly occurs, for example, when you’ve hooked a real-time clock (RTC) to the system to set the date and time automatically when the system boots.</p>&#13;
<p><span epub:type="pagebreak" id="Page_158" title="158"/>As noted in Chapter 2, the I<sup>2</sup>C bus does not provide a standardized mechanism for detecting devices. SMBus devices, in particular, can react in a bad way with simple attempts to read or write the device without a data payload. Therefore, it is possible for the <code>i2cdetect</code> program to change the state of an I<sup>2</sup>C device on the bus just by probing for it, which is why <code>i2cdetect</code> asks you to verify that you really want to scan the bus before it transmits data.</p>&#13;
<p>Because <code>i2cdetect</code> can mess with certain types of peripherals on the bus, it offers an option to limit the scanning to a certain range of addresses. For example, if you know an MCP4725 DAC is installed but don’t know what address it’s connected to, use the following command to search for the DAC:</p>&#13;
<pre><code><b>i2cdetect -y 1 0x60 0x67</b></code></pre>&#13;
<p>The <code>0x60</code> and <code>0x67</code> arguments limit the scanning range of the program (we know that the MCP4725 must have an address in the range of 0x60 to 0x67 because of its hardware design).</p>&#13;
<p>The <code>-q</code> (quick write) and <code>-r</code> (quick read) arguments are advanced options, and using those options can corrupt EEPROMs or hang the system. See the <code>i2cdetect</code> man page for details and seriously consider what you are doing before using those options.</p>&#13;
<h2 id="h1-502468c09-0006">	9.6	Reading and Writing I<sup>2</sup>C Data</h2>&#13;
<p class="BodyFirst">Once you have installed and initialized the I<sup>2</sup>C drivers, transmitting and receiving data on the I<sup>2</sup>C bus is relatively straightforward. Like most devices, Raspberry Pi OS (Linux) treats the I<sup>2</sup>C bus like a file. You open the device driver as a file and then read and write data using the Linux <code>read()</code> and <code>write()</code> functions.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	Note that to write to the I<sup>2</sup>C bus, you must run the program using administrative or root privileges.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>First, call the Linux <code>open()</code> function to get a file handle associated with the I<sup>2</sup>C bus:</p>&#13;
<pre><code><var>handle</var> = open( <var>busName</var>, O_RDWR );</code></pre>&#13;
<p class="BodyContinued">where <var>handle</var> is an integer (file descriptor) type and <var>busName</var> is a string containing the device name for the I<sup>2</sup>C bus you want to use. Bus names are the <em>/dev/i2c*</em> names for the buses you’ve defined in the <em>/boot/config.txt</em> file. For example, the standard I<sup>2</sup>C bus is <em>/dev/i2c-1</em>.</p>&#13;
<p>The <code>open()</code> function returns a negative number on an error and a non-negative file handle value if it is successful. Save the file handle value so you can read and write data later.</p>&#13;
<p><span epub:type="pagebreak" id="Page_159" title="159"/>Before accessing the I<sup>2</sup>C bus, you must set the address of the peripheral device you want to access using the Linux <code>ioctl()</code> (I/O control) function, as follows:</p>&#13;
<pre><code><var>result</var> = ioctl( <var>handle</var>, I2C_SLAVE, <var>i2cAddr</var> );</code></pre>&#13;
<p class="BodyContinued">where <var>result</var> is an integer variable that holds the error return result, <var>handle</var> is the handle the <code>open()</code> function call returns, and <var>i2cAddr</var> is the 7-bit address of the peripheral to access.</p>&#13;
<p>You can call <code>ioctl()</code> multiple times on the same file handle in order to access different peripherals on the same I<sup>2</sup>C bus. Raspberry Pi OS will continue to use the same peripheral address for all read and write operations until you explicitly change it.</p>&#13;
<p>To read data from an I<sup>2</sup>C peripheral, you use the Linux <code>read()</code> function using the following syntax:</p>&#13;
<pre><code><var>result</var> = read( <var>handle</var>, <var>buffer</var>, <var>bufferSize</var> );</code></pre>&#13;
<p class="BodyContinued">where <var>result</var> is an integer variable that will hold the function return result (a negative if an error or number of bytes read if non-negative), <var>handle</var> is the I<sup>2</sup>C bus handle returned by <code>open()</code>, <var>buffer</var> is an array of bytes that will receive the data, and <var>bufferSize</var> is the number of bytes to read. If everything happens correctly, the function returns <var>bufferSize</var> as the result.</p>&#13;
<p>To write data to the peripheral, use the <code>write</code> function:</p>&#13;
<pre><code><var>result</var> = write( <var>handle</var>, <var>buffer</var>, <var>bufferSize</var> );</code></pre>&#13;
<p>The arguments are the same as for <code>read()</code> except the buffer holds the data to be written (rather than being a storage location for the data read).</p>&#13;
<p>The program in <a href="#listing9-1" id="listinganchor9-1">Listing 9-1</a> demonstrates reading and writing data on the I<sup>2</sup>C bus using the <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>ioctl()</code> functions. As in the previous chapter, this program emits a triangle wave on the MCP4725 DAC outputs.</p>&#13;
<pre><code>// <a id="listing9-1">Listing9-1</a>.cpp&#13;
&#13;
// Demonstrates reading from and&#13;
// writing to an MCP4725 DAC.&#13;
&#13;
#include &lt;unistd.h&gt;        &#13;
#include &lt;fcntl.h&gt;         &#13;
#include &lt;sys/ioctl.h&gt;     &#13;
#include &lt;linux/i2c-dev.h&gt; &#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;errno.h&gt;&#13;
&#13;
<span epub:type="pagebreak" id="Page_160" title="160"/>#define ever ;;&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #define i2cDevname      "/dev/i2c-1"&#13;
//#define i2cAddr (0x60) // Adafruit MCP4725 address&#13;
#define i2cAddr (0x62)   // SparkFun MCP4725 address&#13;
&#13;
int main()&#13;
{&#13;
    #define bufferSize (5)&#13;
&#13;
    static unsigned char buffer[bufferSize + 1];&#13;
&#13;
    // Open the I2C interface (i2c-1):&#13;
&#13;
 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> int fd_i2c = open( i2cDevname, O_RDWR );&#13;
&#13;
    if( fd_i2c &lt; 0 )&#13;
    {&#13;
        printf&#13;
        ( &#13;
            "Error opening %s, terminating\n", &#13;
            i2cDevname &#13;
        );&#13;
        return -1;&#13;
    }&#13;
&#13;
    // Assign the device address of the MCP4725 to&#13;
    // the open handle:&#13;
&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> int result = ioctl( fd_i2c, I2C_SLAVE, i2cAddr );&#13;
    if( result &lt; 0 )&#13;
    {&#13;
        printf&#13;
        ( &#13;
            "Error attaching MCP4725: %d, %s\n", &#13;
            result, &#13;
            strerror( result ) &#13;
        );&#13;
        return result;&#13;
    }&#13;
&#13;
    // Just for fun, read the 5 data bytes from the&#13;
    // MCP4725.&#13;
&#13;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> result=read( fd_i2c , buffer, bufferSize );&#13;
    if( result &lt; 0 )&#13;
    {&#13;
        printf&#13;
        ( &#13;
            "Error reading from %s, terminating: %s\n", &#13;
            i2cDevname, &#13;
            strerror( errno )&#13;
        );&#13;
<span epub:type="pagebreak" id="Page_161" title="161"/>        return -1;&#13;
    }&#13;
&#13;
    printf( "Data from DAC:\n" );&#13;
    for ( int i = 0; i &lt; bufferSize; i++ )&#13;
    {&#13;
        printf( "0x%02x ", (int) buffer[i] );&#13;
    }&#13;
    printf( "\n" );&#13;
&#13;
    // Continuously send a triangle wave to the &#13;
    // MCP4725 until the user hits CTRL-C:&#13;
&#13;
    for(ever)&#13;
    {&#13;
        // Output the rising edge:&#13;
        &#13;
        for( int i=0; i &lt; 4095; ++i )&#13;
        {&#13;
            buffer[0] = (i &gt;&gt; 8) &amp; 0xf; // HO 4 bits is first&#13;
            buffer[1] = i &amp; 0xff;       // LO byte is second&#13;
&#13;
            // Write the two bytes to the DAC:&#13;
&#13;
          <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> result = write( fd_i2c, buffer, 2 );&#13;
        }&#13;
&#13;
        // Output the falling edge:&#13;
        &#13;
        for( int i=4095; i &gt; 1; --i )&#13;
        {&#13;
            buffer[0] = (i &gt;&gt; 8) &amp; 0xf; // HO 4 bits is first&#13;
            buffer[1] = i &amp; 0xff;       // LO byte is second&#13;
&#13;
            // Write the two bytes to the DAC:&#13;
&#13;
            result = write( fd_i2c, buffer, 2 );&#13;
        }&#13;
    }&#13;
&#13;
    return 0;&#13;
}</code></pre>&#13;
<p>In <a href="#listing9-1">Listing 9-1</a>, the Linux filename for the main Raspberry Pi I<sup>2</sup>C port is <code>"/dev/i2c-1"</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. To write to the Raspberry Pi I<sup>2</sup>C port, open it like a file <span aria-label="annotation2" class="CodeAnnotation">❷</span>. To read or write a particular I<sup>2</sup>C address, you must first issue an <code>ioctl()</code> call with the <code>I2C_SLAVE</code> argument and the I<sup>2</sup>C address to use. From that point forward (until another <code>ioctl()</code> call changes the address), reads and writes to the I<sup>2</sup>C bus will use this address <span aria-label="annotation3" class="CodeAnnotation">❸</span>. To read data from the I<sup>2</sup>C bus, just call the <code>read()</code> function specifying the file handle returned by the earlier <code>open()</code> call for the I<sup>2</sup>C port <span aria-label="annotation4" class="CodeAnnotation">❹</span>. To write data to the I<sup>2</sup>C bus, call the <code>write()</code> function and specify the I<sup>2</sup>C file handle <span aria-label="annotation5" class="CodeAnnotation">❺</span>.</p>&#13;
<p><span epub:type="pagebreak" id="Page_162" title="162"/><a href="#figure9-3" id="figureanchor9-3">Figure 9-3</a> shows the DAC output on an oscilloscope. </p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c09/f09003.png" width="416"/>&#13;
<figcaption><p><a id="figure9-3">Figure 9-3</a>: Triangle wave output from Raspberry Pi 3</p></figcaption>&#13;
</figure>&#13;
<p>The output is only 3.3 V (rather than 5 V) because the Pi is a 3.3-V machine (I’m running the MCP4725 at 3.3 V, though you could run it at 5 V as long as the SCL and SDA lines are 3.3 V).</p>&#13;
<h2 id="h1-502468c09-0007">	9.7	Advanced I<sup>2</sup>C Kernel Calls</h2>&#13;
<p class="BodyFirst">Although using <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>ioctl()</code> works reasonably well for simple I<sup>2</sup>C bus transactions, various forms of the <code>ioctl()</code> function provide more advanced operations called <em>kernel function calls</em>.</p>&#13;
<p>The kernel function calls take place through the Linux <code>ioctl()</code> API function. You marshal up some parameters in a data structure along with a function identifier and call <code>ioctl()</code>. The <code>ioctl()</code> function decodes its arguments and then passes the parameters along to the specified function. That function returns appropriate function results (via the <code>ioctl()</code> return value and the parameter list you pass to <code>ioctl()</code>). Consider the following <code>i2c_smbus_access()</code> function that sets parameters for various Linux SMBus (I<sup>2</sup>C) function calls:</p>&#13;
<pre><code>#include &lt;linux/i2c.h&gt;&#13;
&#13;
static inline __s32 i2c_smbus_access&#13;
(&#13;
    int file, &#13;
    char read_write, &#13;
    __u8 command,&#13;
    int size, &#13;
    union i2c_smbus_data *data&#13;
){&#13;
    struct i2c_smbus_ioctl_data args;&#13;
&#13;
    args.read_write = read_write;&#13;
<span epub:type="pagebreak" id="Page_163" title="163"/>    args.command = command;&#13;
    args.size = size;&#13;
    args.data = data;&#13;
    return ioctl( file,I2C_SMBUS,&amp;args );&#13;
}</code></pre>&#13;
<p>This function copies its arguments into a local data structure (<code>args</code>) and then passes them on to the <code>ioctl()</code> function with the <code>I2C_SMBUS</code> argument that tells <code>ioctl()</code> to call one of the SMBus functions; the <code>args.command</code> parameter specifies the particular function to call. Most of the <code>I2C_SMBUS</code> functions use the same parameter list: the <code>read_write</code>, <code>size</code>, and <code>data</code> fields of the <code>args</code> structure.</p>&#13;
<p>Note that <code>i2c_smbus_access()</code> isn’t actually a specific SMBus function. It’s the function that marshals the arguments and passes them on to <code>ioctl()</code>, a <em>dispatcher function</em>: a single entry point (into the OS in this case) that transfers (dispatches) control to one of several different functions. An example of a specific SMBus function is <code>i2c_smbus_read_byte()</code>:</p>&#13;
<pre><code>static inline __s32 i2c_smbus_read_byte( int file )&#13;
{&#13;
    union i2c_smbus_data data;&#13;
    if&#13;
    ( &#13;
        i2c_smbus_access&#13;
        (&#13;
            file,&#13;
            I2C_SMBUS_READ,&#13;
            0,&#13;
            I2C_SMBUS_BYTE,&#13;
            &amp;data&#13;
        )&#13;
    ){&#13;
        return -1;&#13;
    }&#13;
    return 0x0FF &amp; data.byte;&#13;
}</code></pre>&#13;
<p>This function uses <code>i2c_smbus_access()</code> to marshal the parameters and make the actual call to <code>ioctl()</code>. </p>&#13;
<p>The following subsections describe the SMBus functions available via the <code>ioctl()</code> dispatcher. While some of these functions are very SMBus specific, many of them are quite useful for normal I<sup>2</sup>C operations.</p>&#13;
<h3 id="h2-502468c09-0001">9.7.1	The i2c-dev Functions</h3>&#13;
<p class="BodyFirst">The <em>linux/i2c-dev.h</em> header file defines the SMBus functions that follow. The <code>apt-get install libi2c-dev</code> command entered earlier in this chapter installs this header file so you can use this library in your applications. You do not have to link a specific library against your code to use these functions, because the <code>i2c-dev</code> functions are installed as part of the kernel (or <span epub:type="pagebreak" id="Page_164" title="164"/>a loadable module) and accessed via the <code>ioctl()</code> API call. To access these functions, include the following statements at the beginning of your C/C++ applications:</p>&#13;
<pre><code><b>extern "C" { // Required for CPP compilation</b>&#13;
<b>    #include &lt;linux/i2c-dev.h&gt;</b>&#13;
<b>    #include &lt;i2c/smbus.h&gt;</b>&#13;
<b>    #include &lt;sys/ioctl.h&gt;</b>&#13;
<b>}</b></code></pre>&#13;
<p>The header file itself contains the function definitions that the following sections describe. They are all <em>static inline</em> functions, so the compiler expands them (as macros) directly in place of the calls you make.</p>&#13;
<p>This header file, through its own includes, defines the types shown in <a href="#table9-2" id="tableanchor9-2">Table 9-2</a>.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table9-2">Table 9-2</a>: Integer Types</p></figcaption>&#13;
<table border="1" id="table-502468c09-0002">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Type</b></td>&#13;
<td><b>Meaning</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>__u8</td>&#13;
<td>Unsigned 8-bit integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td>__u16</td>&#13;
<td>Unsigned 16-bit integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td>__u32</td>&#13;
<td>Unsigned 32-bit integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td>__s8</td>&#13;
<td>Signed 8-bit integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td>__s16</td>&#13;
<td>Signed 16-bit integer</td>&#13;
</tr>&#13;
<tr>&#13;
<td>__s32</td>&#13;
<td>Signed 32-bit integer</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>You must pass the following functions a file handle specifying the I<sup>2</sup>C bus to use. You obtain the file handle using the <code>open()</code> function (see section 9.6, “Reading and Writing I<sup>2</sup>C Data,” earlier in this chapter). You do not pass these functions a device address. Instead, specify the device address to use with an <code>ioctl()</code> call, for example, <code>ioctl(</code><var>handle</var><code>, I2C_SLAVE, </code><var>i2cAddr</var><code>)</code>. Once you set the device address for a given I<sup>2</sup>C bus (specified by the <var>handle</var>), that address remains in effect until you explicitly change it with another <code>ioctl()</code> call.</p>&#13;
<p>The following functions all return <code>-1</code> if an error occurs. The <code>write()</code> functions return <code>0</code> if they are successful. The <code>read()</code> functions will either return the value read from the bus (when reading a single value) or return the number of bytes read when reading a block of bytes.</p>&#13;
<h3 id="h2-502468c09-0002">9.7.2	The i2c_smbus_write_quick Function</h3>&#13;
<p class="BodyFirst">The <code>i2c_smbus_write_quick()</code> function writes a single bit value to an I<sup>2</sup>C device:</p>&#13;
<pre><code>__s32 i2c_smbus_write_quick( int file, __u8 value );</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_165" title="165"/>In this function, <code>file</code> is a file handle returned by the open function (generally specifying the I<sup>2</sup>C device, such as i2c-1), while <code>value</code> is the bit value (0 or 1) to write to the I<sup>2</sup>C bus specified by <code>file</code>.</p>&#13;
<p>This function writes a single bit to the I<sup>2</sup>C bus. The data payload is buried in the R/W bit of the address byte transmitted on the bus. This function transmits the start condition, the address byte (with data payload in R/W), and a stop condition. There are no data bytes transmitted as part of this operation.</p>&#13;
<h3 id="h2-502468c09-0003">9.7.3	The i2c_smbus_read_byte Function</h3>&#13;
<p class="BodyFirst">The <code>i2c_smbus_read_byte()</code> function reads a single byte from the I<sup>2</sup>C bus. Here is the prototype:</p>&#13;
<pre><code>__s32 i2c_smbus_read_byte( int file );</code></pre>&#13;
<p>This function returns a single byte from the I<sup>2</sup>C device on the bus specified by the file handle you pass as an argument (the device address was set up earlier with an <code>ioctl()</code> call). The function transmits a start condition and an address byte to the device. It then reads the response byte from the device. Finally, it transmits the stop condition. </p>&#13;
<p>Do not use this function to read a sequence of bytes from an I<sup>2</sup>C device—for example, reading all the status information from an MCP4725. Because it brackets the address and data values with start and stop conditions, you’ll likely wind up reading just the first byte of the data sequence twice in a row. The program in <a href="#listing9-2" id="listinganchor9-2">Listing 9-2</a> demonstrates this problem.</p>&#13;
<pre><code>// <a id="listing9-2">Listing9-2</a>.cpp&#13;
//&#13;
// Demonstration of two consecutive &#13;
// i2c_smbus_read_byte calls.&#13;
//&#13;
// gcc Listing9-2.c -li2c&#13;
&#13;
#include &lt;unistd.h&gt;             // Needed for I2C port&#13;
#include &lt;fcntl.h&gt;              // Needed for I2C port&#13;
extern "C"                      // Needed for C++ compiler&#13;
{&#13;
    #include &lt;linux/i2c-dev.h&gt;  // Needed for I2C port&#13;
    #include &lt;i2c/smbus.h&gt;&#13;
}&#13;
#include &lt;sys/ioctl.h&gt;&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
#define i2cDevname      "/dev/i2c-1"&#13;
#define i2cAddr (0x62)      // Adafruit MCP4725 address&#13;
//#define i2cAddr (0x60)    // SparkFun MCP4725 address&#13;
&#13;
int main()&#13;
{&#13;
    unsigned char buffer[2];&#13;
<span epub:type="pagebreak" id="Page_166" title="166"/>    int file;&#13;
&#13;
    file = open( i2cDevname, O_RDWR );&#13;
    ioctl( file, I2C_SLAVE, i2cAddr );&#13;
    buffer[0] = i2c_smbus_read_byte( file );&#13;
    buffer[1] = i2c_smbus_read_byte( file );&#13;
    printf( "Buffer[0,1]=%02x, %02x\n", buffer[0], buffer[1] );&#13;
    return 0;&#13;
&#13;
}</code></pre>&#13;
<p>When connected to a SparkFun MCP4725 at address 0x60, the program in <a href="#listing9-2">Listing 9-2</a> produced the following output:</p>&#13;
<pre><code>Buffer[0,1]=c0, c0</code></pre>&#13;
<p>The program just read the status information byte twice. When reading data from non-SMBus devices (such as the MCP4725), use standard I<sup>2</sup>C read operations; save this function for actual SMBus devices.</p>&#13;
<h3 id="h2-502468c09-0004">9.7.4	The i2c_smbus_write_byte() Function</h3>&#13;
<p class="BodyFirst">The <code>i2c_smbus_write_byte()</code> function writes a single byte to an I<sup>2</sup>C device:</p>&#13;
<pre><code>__s32 i2c_smbus_write_byte( int <var>file</var>, __u8 <var>value</var> );</code></pre>&#13;
<p>The <var>file</var> argument is a handle specifying the bus (device), and <var>value</var> is the byte to transmit on the bus. This function transmits a start condition, an address byte, a data byte, and, finally, a stop condition. </p>&#13;
<p>As with the <code>i2c_smbus_read_byte()</code> function, do not use this function to write a sequence of bytes to an I<sup>2</sup>C device (such as writing the DAC value to an MCP4725). Because it brackets the address and data values with start and stop conditions, you’ll likely wind up writing only the first byte of the data sequence twice in a row.</p>&#13;
<h3 id="h2-502468c09-0005">9.7.5	The i2c_smbus_read_byte_data() Function</h3>&#13;
<p class="BodyFirst">The <code>i2c_smbus_read_byte_data()</code> function writes a register number to an I<sup>2</sup>C device and then reads a data byte (presumably from the register specified by the write operation). The prototype is</p>&#13;
<pre><code>__s32 i2c_smbus_read_byte_data( int <var>file</var>, __u8 <var>command</var> );</code></pre>&#13;
<p class="BodyContinued">where <var>file</var> is the file handle specifying the I<sup>2</sup>C device and <var>command</var> is a register number or command byte to write to the device before reading from it. </p>&#13;
<p>This function transmits the start condition, the address byte with the R/W set to 0 (write), and then the <code>command</code> byte. Then it sends a (re)start condition, followed by another address byte (this time with the R/W bit set to 1). The peripheral responds by transmitting a data byte and then the controller puts a stop condition on the bus. The program in <a href="#listing9-3" id="listinganchor9-3">Listing 9-3</a> demonstrates this call.</p>&#13;
<pre><code><span epub:type="pagebreak" id="Page_167" title="167"/>// <a id="listing9-3">Listing9-3</a>.cpp&#13;
//&#13;
// Demonstration of i2c_smbus_read_byte_data call.&#13;
//&#13;
// gcc listing-9-3.c -li2c&#13;
&#13;
#include &lt;unistd.h&gt;&#13;
#include &lt;fcntl.h&gt;&#13;
extern "C"                     // Needed for C++ compiler&#13;
{&#13;
    #include &lt;linux/i2c-dev.h&gt; // Needed for I2C port&#13;
    #include &lt;i2c/smbus.h&gt;&#13;
}&#13;
#include &lt;sys/ioctl.h&gt;&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
#define i2cDevname      "/dev/i2c-1"&#13;
#define i2cAddr (0x62)         // Adafruit MCP4725 address&#13;
//#define i2cAddr (0x60)       // SparkFun MCP4725 address&#13;
&#13;
int main()&#13;
{&#13;
    unsigned char result;&#13;
    int file;&#13;
&#13;
    file = open( i2cDevname, O_RDWR );&#13;
    ioctl( file, I2C_SLAVE, i2cAddr );&#13;
    result = i2c_smbus_read_byte_data( file, 0 );&#13;
    printf( "Result=%02x\n", result );&#13;
    return 0;&#13;
}</code></pre>&#13;
<p><a href="#figure9-4" id="figureanchor9-4">Figure 9-4</a> shows the logic analyzer output when running the program in <a href="#listing9-3">Listing 9-3</a>. As you can see from this image, the <code>i2c_smbus_read_byte_data()</code> function call emits two I<sup>2</sup>C operations: a write operation (writing the byte 0, which was the command argument in the call) and a read operation, which winds up reading 0xC0 from the DAC (the status byte). You can’t see it because <a href="#figure9-4">Figure 9-4</a> is not in color, but between the two transmissions is a restart condition: a start condition without a stop condition from the previous transmission (the dot between the commands).</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="157" src="image_fi/502468c09/f09004.png" width="844"/>&#13;
<figcaption><p><a id="figure9-4">Figure 9-4</a>: Logic analyzer output when running the program in <a href="#listing9-3">Listing 9-3</a></p></figcaption>&#13;
</figure>&#13;
<p>Normally, you would not use this function on an MCP4725 DAC device. Writing a single byte wipes out the HO 4 bits of the output value (without <span epub:type="pagebreak" id="Page_168" title="168"/>affecting the LO byte). Of course, reading a single byte does very little good as well, unless you’re interested only in the status byte from the MCP4725.</p>&#13;
<p>Generally, you would use this function to talk to a more sophisticated device that requires writing a command or register byte before reading a byte back from the device, which is a common sequence with SMBus devices. For example, the MCP23017 GPIO expander IC works in this fashion. </p>&#13;
<p>The big difference between this function call and a call to write a byte followed by a call to read a byte is that the latter form would emit a stop condition after writing the first byte. This stop condition would reset the state machine logic of devices, such as the MCP23017, and might cause it to treat the second write as an independent operation, leaving the bus vulnerable to a different controller sending data.</p>&#13;
<h3 id="h2-502468c09-0006">9.7.6	The i2c_smbus_write_byte_data() Function</h3>&#13;
<p class="BodyFirst">The <code>i2c_smbus_write_byte_data()</code> function writes a byte to specify an I<sup>2</sup>C device register and then writes a second byte to that register. This is its prototype:</p>&#13;
<pre><code>static inline __s32 i2c_smbus_write_byte_data&#13;
(&#13;
    int file, &#13;
    __u8 command,&#13;
    __u8 value&#13;
);</code></pre>&#13;
<p>Like the <code>i2c_smbus_read_byte_data()</code> function, this call is mainly intended for use when communicating with devices such as the MCP23017 GPIO expander that expect you to transmit a register number immediately before transmitting the data byte.  </p>&#13;
<h3 id="h2-502468c09-0007">9.7.7	The i2c_smbus_read_word_data() Function</h3>&#13;
<p class="BodyFirst">The <code>i2c_smbus_read_word_data()</code> function writes a register number to an I<sup>2</sup>C device and then reads a pair of bytes from the device (presumably from the specified register). This is its prototype:</p>&#13;
<pre><code>__s32 i2c_smbus_read_word_data( int file, __u8 command );</code></pre>&#13;
<p>This function is similar to <code>i2c_smbus_read_byte_data()</code> except that it reads 2 bytes (a word) after writing the <code>command</code> byte to the I<sup>2</sup>C bus. </p>&#13;
<p>When this function executes, the following I<sup>2</sup>C bus transactions occur:</p>&#13;
<ol class="decimal">&#13;
<li value="1">A start condition is sent.</li>&#13;
<li value="2">The address byte with an R/W bit of 0 is sent.</li>&#13;
<li value="3">The <code>command</code> byte is sent.</li>&#13;
<li value="4">A (re)start condition is sent.</li>&#13;
<li value="5">The address byte with an R/W bit of 1 is sent.</li>&#13;
<li value="6">Two bytes are read from the peripheral device.</li>&#13;
<li value="7">A stop condition is sent.</li>&#13;
</ol>&#13;
<p><span epub:type="pagebreak" id="Page_169" title="169"/>This function reads the bytes back in little-endian order; that is, the first byte it reads from the bus is the LO byte, and the second byte it reads is the HO byte, which is often reversed from the way data actually arrives. For example, when using this function to read the MCP4725 DAC, the word comes back with the status byte in the LO 8 bits and the next byte read (which turns out, coincidentally, to be the HO 8 bits of the last DAC value written) in the HO byte. Be aware of that issue when using this function.</p>&#13;
<h3 id="h2-502468c09-0008">9.7.8	The i2c_smbus_write_word_data() Function</h3>&#13;
<p class="BodyFirst">The <code>i2c_smbus_write_word_data()</code> function writes 3 bytes to an I<sup>2</sup>C device: the first byte specifies a register number, and the next 2 bytes are a word value that is written to that register. This is its prototype:</p>&#13;
<pre><code>i2c_smbus_write_word_data( int file, __u8 command,__u16 value )</code></pre>&#13;
<p>This function is similar to <code>i2c_smbus_write_byte_data()</code>, except that it writes 2 bytes (a word) after writing the <code>command</code> byte to the I<sup>2</sup>C bus. Note that this function writes the bytes in little-endian order. Be aware of this issue when using this function.</p>&#13;
<p>When this function executes, the following I<sup>2</sup>C bus transactions occur:</p>&#13;
<ol class="decimal">&#13;
<li value="1">A start condition is sent.</li>&#13;
<li value="2">The address byte with an R/W bit of 0 is sent.</li>&#13;
<li value="3">The command byte is sent.</li>&#13;
<li value="4">The LO byte of value is sent.</li>&#13;
<li value="5">The HO byte of value is sent.</li>&#13;
<li value="6">A stop condition is sent.</li>&#13;
</ol>&#13;
<p>Note that, unlike the read word function, only a single address byte is sent with no restart conditions. This function simply writes 3 bytes (a command and 2 data bytes) after the address byte. The first byte, presumably, is a register or command byte followed by 2 data bytes.</p>&#13;
<h3 id="h2-502468c09-0009">9.7.9	The i2c_smbus_read_block_data() Function</h3>&#13;
<p class="BodyFirst">The <code>i2c_smbus_read_block_data()</code> function reads a block of data from the specified device and places that data in the <code>values</code> array. This function first writes the register number or command byte to the device, and then the device responds with the data. Here is its prototype:</p>&#13;
<pre><code>static inline __s32 i2c_smbus_read_block_data&#13;
(&#13;
    int file, &#13;
    __u8 command,&#13;
    __u8 *values&#13;
} </code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_170" title="170"/>This command is useful for very specific I<sup>2</sup>C devices. The bus transactions are the following:</p>&#13;
<ol class="decimal">&#13;
<li value="1">A start condition is sent.</li>&#13;
<li value="2">The address byte with an R/W bit of 0 is sent.</li>&#13;
<li value="3">The <code>command</code> byte is sent.</li>&#13;
<li value="4">A (re)start condition is sent.</li>&#13;
<li value="5">The address byte with an R/W bit of 1 is sent.</li>&#13;
<li value="6">The system reads a count byte (<em>n</em>) and then reads <em>n</em> bytes from the device (the particular device determines how many bytes are actually read).</li>&#13;
<li value="7">A stop condition is sent.&#13;
</li>&#13;
</ol>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	The <code>i2c_smbus_read_block_data()</code> function requires SMBus block read functionality. On the Raspberry Pi, the I<sup>2</sup>C device driver does not support this functionality, so this function will not work. Execute the <code class="bold">i2cdetect -F 1</code> command (or whatever bus you want to check in place of the <code>1</code>) to verify whether this function—and, indeed, any of these functions—work.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>To read an arbitrary block of bytes from the I<sup>2</sup>C bus, without a command or register byte, just use the Linux <code>read</code> function.</p>&#13;
<h3 id="h2-502468c09-0010">9.7.10	The i2c_smbus_write_block_data() Function</h3>&#13;
<p class="BodyFirst">The <code>i2c_smbus_write_block_data()</code> function writes a block of data to the specified device. This function first writes the register number or command byte to the device followed by the data. This is its prototype:</p>&#13;
<pre><code>static inline __s32 i2c_smbus_write_block_data&#13;
(&#13;
    int file, &#13;
    __u8 command,&#13;
    __u8 length, &#13;
    const __u8 *values&#13;
) </code></pre>&#13;
<p>This function writes a <code>command</code> byte to the device and then a write of <code>length</code> bytes specified by the values array. The bus transactions are the following:</p>&#13;
<ol class="decimal">&#13;
<li value="1">A start condition is put on the bus.</li>&#13;
<li value="2">An address byte with the R/W bit set to 0 is written to the bus.</li>&#13;
<li value="3">The <code>command</code> byte is written to the bus.</li>&#13;
<li value="4"><code>length</code> bytes from <code>values</code> are written to the bus.</li>&#13;
<li value="5">A stop condition is placed on the bus.</li>&#13;
</ol>&#13;
<p>No extra address byte is written after the <code>command</code> byte. Indeed, this function is roughly equivalent to sticking the <code>command</code> byte at the beginning of <span epub:type="pagebreak" id="Page_171" title="171"/>the <code>values</code> array and calling the Linux <code>write</code> function with <code>length+1</code> as the number of bytes to write.</p>&#13;
<h3 id="h2-502468c09-0011">9.7.11	Miscellaneous Functions</h3>&#13;
<p class="BodyFirst">There are a few other miscellaneous (SMBus-only), lesser-used functions that I’m not going to document here. For more information on those functions, check out the Linux kernel I<sup>2</sup>C documentation at <a class="LinkURL" href="https://www.kernel.org/doc/Documentation/i2c/smbus-protocol">https://www.kernel.org/doc/Documentation/i2c/smbus-protocol</a>.</p>&#13;
<h2 id="h1-502468c09-0008">	9.8	Reentrancy Issues with I<sup>2</sup>C Operations</h2>&#13;
<p class="BodyFirst">Keep in mind that Linux (Raspberry Pi OS) is a multitasking operating system. Therefore, it is perfectly possible for two different threads or processes to attempt to access the I<sup>2</sup>C bus concurrently. Linux will serialize access to the I<sup>2</sup>C/SMBus device driver automatically. Therefore, if some thread is currently executing I<sup>2</sup>C code inside the Linux kernel and another thread attempts to invoke some I<sup>2</sup>C kernel code, the Linux system will block the second task until the first thread exits the <code>ioctl()</code> call. In that sense, you don’t have to worry about reentrancy or anything like that.</p>&#13;
<p>That said, two different threads cannot talk concurrently to the same device, but two different threads can talk to two independent devices on the I<sup>2</sup>C bus. Therefore, Linux will allow two threads, or even the same thread, to open the same bus multiple times. This means that, for example, two different threads could open the i2c-1 bus and both of them could write data to the same MCP4725 DAC. Of course, the output of the DAC will be really messed up if both threads are writing to the DAC independently. Unfortunately, Linux cannot solve this problem for you. You must exercise care when writing multiple threads or programs that might access the same I<sup>2</sup>C device concurrently. </p>&#13;
<h2 id="h1-502468c09-0009">	9.9	Multicontroller Operation Under Linux</h2>&#13;
<p class="BodyFirst">As far as I can tell, the Raspberry Pi OS (and Linux in general) does not support multiple controllers on the same I<sup>2</sup>C bus. Linux is a single-controller, multiple-peripheral I<sup>2</sup>C interface. </p>&#13;
<p>I suspect the Raspberry Pi hardware will not support multiple controllers, given the aforementioned hardware issue with the Raspberry Pi I<sup>2</sup>C controller, which doesn’t handle clock stretching properly, and the fact that the same types of operations are necessary for clock synchronization and arbitration. Of course, this issue applies only to the Pi; other Linux systems will likely support multiple controllers on the same bus just fine.</p>&#13;
<h2 id="h1-502468c09-0010">	9.10	Other Linux Systems</h2>&#13;
<p class="BodyFirst">This chapter has largely focused on the Raspberry Pi, but in truth, the only really Pi-specific topic in this chapter is activating the I<sup>2</sup>C bus. Most of the <span epub:type="pagebreak" id="Page_172" title="172"/>functions and utilities this chapter discusses are generic to Linux. The following subsections describe some other common Linux-based systems that support I<sup>2</sup>C for general interfacing purposes.</p>&#13;
<h3 id="h2-502468c09-0012">9.10.1	PINE A64 and ROCKPro64</h3>&#13;
<p class="BodyFirst">The ROCKPro64 is a 64-bit ARM SBC built to look and behave a whole lot like the Raspberry Pi. While it is a great little board (along with its smaller brother, the PINE A64), the folks at PINE64 rely on third parties to provide their Linux operating system ports. Multiple ports are available, which makes it a bit difficult to find a reasonable tutorial on getting the SBC to enable the I<sup>2</sup>C lines. Here are some references (both describe I<sup>2</sup>C programming on the ROCKPro64 SBC) I’ve found that might prove helpful if you’re using one of these machines:</p>&#13;
<ul>&#13;
<li><a class="LinkURL" href="https://forum.armbian.com/topic/8792-i2c-and-i2s-on-rock64">https://forum.armbian.com/topic/8792-i2c-and-i2s-on-rock64</a></li>&#13;
<li><a class="LinkURL" href="http://synfare.com/599N105E/hwdocs/rock64/index.xhtml">http://synfare.com/599N105E/hwdocs/rock64/index.xhtml</a></li>&#13;
</ul>&#13;
<h3 id="h2-502468c09-0013">9.10.2	BeagleBone Black</h3>&#13;
<p class="BodyFirst">The BeagleBone Black is an open source alternative to the Raspberry Pi. Because this device was designed with hardware hackers in mind, it’s not surprising that it comes with the i2c-tools set already installed and I<sup>2</sup>C buses pre-activated.</p>&#13;
<p>On the BeagleBone Black, bus i2c-2 (pins 19 and 20 on the P9 connector; see Figure 6-10 in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>) is generally available for external use. Use <code>"/dev/i2c-2"</code> as the filename when opening the bus to access the bus on the BeagleBone Black.</p>&#13;
<h3 id="h2-502468c09-0014">9.10.3	Onion Omega2+</h3>&#13;
<p class="BodyFirst">The Onion Omega2+ is a small Linux-based module intended for IoT operation. This little module comes with I<sup>2</sup>C communication installed and ready to run. </p>&#13;
<p>Onion provides an I<sup>2</sup>C library you can link with to access I<sup>2</sup>C devices. Check out Onion’s I<sup>2</sup>C documentation at <a class="LinkURL" href="https://docs.onion.io/omega2-docs">https://docs.onion.io/omega2-docs</a>.</p>&#13;
<h2 id="h1-502468c09-0011">	9.11	Using the Raspberry Pi as an I<sup>2</sup>C Peripheral Device</h2>&#13;
<p class="BodyFirst">Although the standard Raspberry Pi hardware and device drivers do not support using the Pi as an I<sup>2</sup>C peripheral device, it is possible to do so using bit-banging techniques. The pigpio free software library (<a class="LinkURL" href="https://abyz.me.uk/rpi/pigpio">https://abyz.me.uk/rpi/pigpio</a>) provides an API for dealing with the GPIO pins on the Raspberry Pi. This library provides a software-based I<sup>2</sup>C interface supporting both controller and peripheral modes.</p>&#13;
<p><span epub:type="pagebreak" id="Page_173" title="173"/>The pigpio library also supports bit-banging controller operations. Using a software-controlled I<sup>2</sup>C driver provides additional features not possible with the hardware I<sup>2</sup>C system, including the following:</p>&#13;
<ul>&#13;
<li>Baud rates as low as 50</li>&#13;
<li>Repeated starts</li>&#13;
<li>Clock stretching</li>&#13;
<li>I<sup>2</sup>C on any pair of spare GPIO</li>&#13;
</ul>&#13;
<p class="BodyContinued">See <a class="LinkURL" href="https://abyz.me.uk/rpi/pigpio/cif.xhtml#bbI2COpen">https://abyz.me.uk/rpi/pigpio/cif.xhtml#bbI2COpen</a> for more information on the bit-banging I<sup>2</sup>C functions in the pigio library.</p>&#13;
<p>Finally, pigpio also provides a veneer (facade design pattern) over the existing <code>ioctl()</code> functions. See <a class="LinkURL" href="https://abyz.me.uk/rpi/pigpio/cif.xhtml#i2cOpen">https://abyz.me.uk/rpi/pigpio/cif.xhtml#i2cOpen</a> for a list of these functions.</p>&#13;
<h2 id="h1-502468c09-0012">	9.12	Chapter Summary</h2>&#13;
<p class="BodyFirst">This chapter discussed I<sup>2</sup>C programming on the Raspberry Pi, beginning with a discussion of the I<sup>2</sup>C pins on the Pi 40-pin GPIO header. It showed how to activate the I<sup>2</sup>C buses on the Pi and adjust the SCL clock frequency, and then it covered some issues with I<sup>2</sup>C on the Pi, such as its lack of support for clock stretching. You also learned various generic Linux utilities you can use to probe the I<sup>2</sup>C bus and access certain types of I<sup>2</sup>C peripherals. However, the real meat of this chapter was its treatment of reading and writing data on the I<sup>2</sup>C bus via Linux, including various advanced kernel calls. Unlike Arduino and other simple systems, Linux is a full multitasking/multiprocessing operating system. To address the problems in such systems, this chapter briefly discussed reentrancy issues and how to work around the problems when multiple threads or processes are accessing the same I<sup>2</sup>C bus concurrently.</p>&#13;
<p>Although this chapter focused on the Raspberry Pi, the Pi is a generic Linux system, and most of the comments in this chapter that are not Pi-hardware-specific apply to other Linux-based systems as well. Therefore, the chapter also gave an overview of I<sup>2</sup>C programming on the PINE A64 or ROCKPro64, the BeagleBone Black, and the Onion Omega2+. Finally, you learned to use the Raspberry Pi as an I<sup>2</sup>C peripheral device with the pigpio library, as well as how to use the same library for generic bit-banging I<sup>2</sup>C support.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>For More Information</h2>&#13;
<p class="BoxBodyFirst">Enabling I<sup>2</sup>C ports on Raspberry Pi:</p>&#13;
<ol class="none">&#13;
<li><a class="LinkURL" href="https://www.raspberrypi-spy.co.uk/2014/11/enabling-the-i2c-interface-on-the-raspberry-pi">https://www.raspberrypi-spy.co.uk/2014/11/enabling-the-i2c-interface-on-the-raspberry-pi</a></li>&#13;
<li><a class="LinkURL" href="https://www.instructables.com/id/How-to-enable-I2C-on-RaspberryPI">https://www.instructables.com/id/How-to-enable-I2C-on-RaspberryPI</a></li>&#13;
<li><span epub:type="pagebreak" id="Page_174" title="174"/>I<sup>2</sup>C/SMBus functions under Linux: <a class="LinkURL" href="https://www.kernel.org/doc/html/latest/i2c/smbus-protocol.xhtml">https://www.kernel.org/doc/html/latest/i2c/smbus-protocol.xhtml</a></li>&#13;
<li>I<sup>2</sup>C on the BeagleBone Black: <a class="LinkURL" href="http://beaglebone.cameon.net/home/i2c-devices">http://beaglebone.cameon.net/home/i2c-devices</a></li>&#13;
<li>I<sup>2</sup>C on the Onion Omega2+: <a class="LinkURL" href="https://docs.onion.io/omega2-docs/communicating-with-i2c-devices.xhtml">https://docs.onion.io/omega2-docs/communicating-with-i2c-devices.xhtml</a></li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>