<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_341"/><span class="big">13</span><br/>USING FILSKA</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">In <a href="ch12.xhtml#ch12">Chapter 12</a>, we designed and implemented Filska. Now, let’s use it to write some programs. We’ll develop six Filska programs of increasing complexity to gain experience thinking in the restricted world Filska offers us.</p>&#13;
<p class="indent">To be more specific, this rather long chapter comprises disconnected sections, each implementing a particular Filska example. You need not read straight through because no section builds necessarily upon any previous section. Instead, the goal of the chapter is to present case studies in using Filska, all with the hope of helping you think about how to code in Filska and, more importantly, how to think in new ways to help you be more creative in your own coding tasks, regardless of the language. So put on your dancing shoes, turn the fiddle music up to 11, and get ready to have some (possibly) high-spirited fun.</p>&#13;
<h3 class="h3" id="lev1sec85"><strong>Hello, World!</strong></h3>&#13;
<p class="noindent">We’d be remiss if we didn’t start with the expected “Hello, world!” example. The most obvious way to write it in Filska is to load the respective ASCII codes for each character into subprogram memory and call <code>chr</code> to output the string one character at a time. However, this is also quite boring and not <span epub:type="pagebreak" id="page_342"/>the least bit mathematical, so we’ll forgo the obvious and instead embrace the obfuscated.</p>&#13;
<h4 class="h4" id="lev2sec118"><strong><em>Hello, Math!</em></strong></h4>&#13;
<p class="noindent">Let’s develop the necessary sequence of characters as a series of simple math operations. We’ll use the X register and output it as a character when needed. Therefore, we need a subprogram to output the X register as a character.</p>&#13;
<pre>{ dump  txm chr jmp,main }</pre>&#13;
<p class="noindent">The above fits the bill. The first instruction moves X to the subprogram memory, and the second dumps the ASCII character it represents to the console. The final instruction returns to <code>main</code> and, as it is the final instruction, the next call from <code>main</code> to <code>dump</code> will loop around and begin again with <code>txm</code>, as we desire.</p>&#13;
<p class="indent">We can now dump ASCII characters in X to the console. Next we need our sequence of operations on X. The ASCII code for <code>H</code> is 72, so we’ll start there and move from the current character to the next via additions of positive and negative offsets. The sequence we need is</p>&#13;
<table class="all5">&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw">&#13;
<p class="taba"><em>X</em> ← 8</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> × 9</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> <em>–</em> 3</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> + 7</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> + 0</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> + 3</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> <em>–</em> 35</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> <em>–</em> 12</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> + 55</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> <em>–</em> 8</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> + 3</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> <em>–</em> 6</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> <em>–</em> 8</p>&#13;
<p class="taba"><em>X</em> ←<em>X</em> <em>–</em> 35</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">Note that here we output X with <code>dump</code> after each operation except the first.</p>&#13;
<p class="indent">We have an assignment, a multiplication, and a bunch of additions. So we need <code>set</code>, <code>mul</code>, and <code>add</code> along with <code>jmp</code> to call <code>dump</code>. Translating the sequence into code gives us <a href="ch13.xhtml#ch013list1">Listing 13-1</a>.</p>&#13;
<pre>{ main&#13;
    set,8&#13;
    tmx &#13;
    set,9       mul,x=mx    jmp,dump&#13;
    set,-3      add,x=mx    jmp,dump<span epub:type="pagebreak" id="page_343"/>&#13;
    set,7       add,x=mx    jmp,dump&#13;
    set,0       add,x=mx    jmp,dump&#13;
    set,3       add,x=mx    jmp,dump&#13;
    set,-35     add,x=mx    jmp,dump&#13;
    set,-12     add,x=mx    jmp,dump&#13;
    set,55      add,x=mx    jmp,dump&#13;
    set,-8      add,x=mx    jmp,dump&#13;
    set,3       add,x=mx    jmp,dump&#13;
    set,-6      add,x=mx    jmp,dump&#13;
    set,-8      add,x=mx    jmp,dump&#13;
    set,-35     add,x=mx    jmp,dump&#13;
    set,10&#13;
    chr &#13;
    hlt &#13;
}&#13;
&#13;
{ dump  txm chr jmp,main }</pre>&#13;
<p class="caption" id="ch013list1"><em>Listing 13-1: A first version of “Hello, world!” in Filska</em></p>&#13;
<p class="indent"><a href="ch13.xhtml#ch013list1">Listing 13-1</a> is in the file <em>hello.filska</em>. The code uses <code><em>main</em></code> ’s memory to hold the offset and X to hold the running total. Each operation on X is followed by a call to <code><em>dump</em></code> . The final three instructions output a newline character and then halt. As we might expect, removing <code><em>hlt</em></code> makes the code dump <code><em>HELLO</em>,</code> <code>WORLD!</code> forever.</p>&#13;
<h4 class="h4" id="lev2sec119"><strong><em>Hello, Poly!</em></strong></h4>&#13;
<p class="noindent"><a href="ch13.xhtml#ch013list1">Listing 13-1</a> is indeed obfuscated, but we can do better while still dumping <code>HELLO, WORLD!</code> to the console. The ASCII values we need to dump as characters are</p>&#13;
<pre>72, 69, 76, 76, 79, 44, 32, 87, 79, 82, 76, 68, 33</pre>&#13;
<p class="indent">Can we create a mathematical function, <em>y</em> = <em>f</em> (<em>x</em>), to generate this sequence for <em>x</em> ∈ [0, 12]? If we had such a function, we could generate <code>HELLO,</code> <code>WORLD!</code> character by character with repeated calls to <em>f</em> (<em>x</em>) for <em>x</em> = 0, 1, <em>…</em>, 12.</p>&#13;
<p class="indent">A good candidate for such a function is a polynomial. We remember these from our high school algebra days as sums of terms where each term is a coefficient multiplying some power of <em>x</em>. Let’s use a polynomial for <em>f</em> (<em>x</em>). The degree of the polynomial is the highest power of <em>x</em> present. We need to pick a degree for the polynomial and then find the set of coefficients. For example, if we decide to use a third-degree polynomial, we get</p>&#13;
<p class="equationc"><em>y</em> = <em>p</em><sub>0</sub><em>x</em><sup>3</sup> + <em>p</em><sub>1</sub><em>x</em><sup>2</sup> + <em>p</em><sub>2</sub><em>x</em> + <em>p</em><sub>3</sub></p>&#13;
<p class="noindent">Remember that <em>x</em><sup>1</sup> = <em>x</em> and <em>x</em><sup>0</sup> = 1. The <em>p</em>s are the coefficients, and we need to find them somehow after picking the degree.</p>&#13;
<p class="indent">What we are talking about here is known as <em>curve fitting</em>, which is the process of finding the equation of a curve that best fits a set of data. For us, <span epub:type="pagebreak" id="page_344"/>our dataset is the sequence of ASCII characters we want to generate along with the input <em>x</em> value, a sequence of points, (<em>x</em>, <em>y</em>), so that 72 = <em>f</em> (0), 69 = <em>f</em> (1), and so on.</p>&#13;
<pre>(0,72) (1,69) (2,76) (3,76) (4,79) (5,44) (6,32)&#13;
(7,87) (8,79) (9,82) (10,76) (11,68) (12,33)</pre>&#13;
<p class="indent">We’ll use a polynomial for <em>f</em> (<em>x</em>), but we still need to pick a degree and then learn how to fit a polynomial of that degree to the dataset. It’s known that an <em>n –</em> 1 degree polynomial can perfectly fit a dataset with <em>n</em> points. Generally, this isn’t what is wanted. The point of fitting the function is to explain the trend of the data using the function to make meaningful predictions at points not measured. However, we actually <em>do</em> want to hit each data point exactly. Therefore, let’s use a 12th degree polynomial to fit our 13 points (see Equation 13.1). We now need to find the coefficients of</p>&#13;
<div class="imagec"><img src="Images/13eqa01.jpg" alt="Image" width="578" height="64"/></div>&#13;
<p class="indent">Great! How do we find the coefficients? The answer is to use <em>least-squares fitting</em>, a method for finding the values for <em>p</em> that minimize the square of the difference between the data points and the function value at those data points. Implementing a routine to do least-squares fitting to a polynomial is beyond the scope of this book. Fortunately, we can use the power of NumPy to do it for us. Incidentally, we’ll encounter least-squares fitting of data later in this chapter when we write a Filska program to fit data to a line.</p>&#13;
<p class="indent">Consider the Python program in <em>hello.py</em>. We won’t show the code here, but please do review it. The code uses NumPy, specifically the <code>np.polyfit</code> routine, to fit the dataset and generate the coefficients we need. The same code also calculates the difference between the dataset and the polynomial values at the given <em>x</em> values, and generates a plot of the resulting polynomial. NumPy found the following coefficients:</p>&#13;
<pre>X**12, P = -4.6431994663395692e-05&#13;
X**11, P = 3.2633752799095354e-03&#13;
X**10, P = -1.0079445322316360e-01&#13;
X** 9, P = 1.7997278464174311e+00&#13;
X** 8, P = -2.0561041293073888e+01&#13;
X** 7, P = 1.5712412821126304e+02&#13;
X** 6, P = -8.1556740929381863e+02&#13;
X** 5, P = 2.8598281210109303e+03&#13;
X** 4, P = -6.5979225156803523e+03&#13;
X** 3, P = 9.4649124982355879e+03&#13;
X** 2, P = -7.5173478664143449e+03&#13;
X** 1, P = 2.4648319340174303e+03&#13;
X** 0, P = 7.2000000563347072e+01</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_345"/>Here, each <code>P</code> is the coefficient for the corresponding power of <em>x</em>. The polynomial is sensitive enough that all digits displayed are necessary. Our Filska program will use these constants in all their glory.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch013fig1">Figure 13-1</a> shows us what the polynomial looks like. The circles are the actual data points we want the polynomial to output, and the curve is the polynomial itself (Equation 13.1).</p>&#13;
<div class="image"><img id="ch013fig1" src="Images/13fig01.jpg" alt="Image" width="672" height="508"/></div>&#13;
<p class="figcap"><em>Figure 13-1: The polynomial of Equation 13.1 and the actual data points to output</em></p>&#13;
<p class="indent">A glance at <a href="ch13.xhtml#ch013fig1">Figure 13-1</a> shows that the 12th degree polynomial fit is hitting all the points we want it to hit, but the function itself acts wildly outside of those points, so it wouldn’t be a good fit to the dataset if we were looking to learn something about the general trend of the data. Thankfully, we aren’t. Instead, we’re looking to build a needlessly complicated implementation of <code>HELLO, WORLD!</code> so we are doing just fine with our 12th degree polynomial.</p>&#13;
<h4 class="h4" id="lev2sec120"><strong><em>Hello, Poly Implementation!</em></strong></h4>&#13;
<p class="noindent">Let’s start designing the Filska code. We need the equivalent of the Python code in <a href="ch13.xhtml#ch013list2">Listing 13-2</a>.</p>&#13;
<pre>from math import floor&#13;
&#13;
def f(x):&#13;
    return -4.6431994663395692e-05*x**12 +  \&#13;
            3.2633752799095354e-03*x**11 +  \<span epub:type="pagebreak" id="page_346"/>&#13;
           -1.0079445322316360e-01*x**10 +  \&#13;
            1.7997278464174311e+00*x**9  +  \&#13;
           -2.0561041293073888e+01*x**8  +  \&#13;
            1.5712412821126304e+02*x**7  +  \&#13;
           -8.1556740929381863e+02*x**6  +  \&#13;
            2.8598281210109303e+03*x**5  +  \&#13;
           -6.5979225156803523e+03*x**4  +  \&#13;
            9.4649124982355879e+03*x**3  +  \&#13;
           -7.5173478664143449e+03*x**2  +  \&#13;
            2.4648319340174303e+03*x**1  +  \&#13;
            7.2000000563347072e+01*x**0 &#13;
&#13;
for x in range(13):&#13;
    y = f(x)&#13;
    d = int(floor(y+0.5))&#13;
    print("%s" % chr(d), end="")&#13;
print()</pre>&#13;
<p class="caption" id="ch013list2"><em>Listing 13-2: Python code to generate <span class="codeitalic1">HELLO, WORLD!</span> with a polynomial</em></p>&#13;
<p class="indent">The function <code>f(x)</code> implements the polynomial returning the <em>y</em> for any given <em>x</em>. The <em>x</em> values we need are the numbers from 0 through 12. Looking at the <code>for</code> loop, each <em>x</em> is given to <em>f</em> (<em>x</em>) to create a <em>y</em> output, which is a floating-point number we need to round to the nearest integer. Rounding means <em>y</em> = 72<em>.</em>04 leads to <em>d</em> = 72 and <em>y</em> = 72<em>.</em>54 produces <em>d</em> = 73. It’s <em>d</em> we’ll treat as the ASCII character code to output, which is precisely what the <code>print</code> statement is doing via <code>chr</code>. To round <em>y</em> to get integer <em>d</em>, we use the standard trick of adding 0.5 followed by <code>floor</code> to arrive at <em>d</em>. Without this rounding, the output will not be <code>HELLO, WORLD!</code> but <code>HDKKN+VNQLD!</code></p>&#13;
<p class="indent">To generate Filska code equivalent to <a href="ch13.xhtml#ch013list2">Listing 13-2</a>, we need a subprogram implementing <em>f</em> (<em>x</em>) and a main loop over the integers from 0 through 12. After passing each integer to <em>f</em> (<em>x</em>) and rounding, we emit the result as a character. The complete code is in <em>hello2.filska</em>. We’ll present the important parts in <a href="ch13.xhtml#ch013list3">Listing 13-3</a>, but please review the entire file to see all the source code.</p>&#13;
<pre>{ main&#13;
 <span class="ent">➊</span> set,0       " M = 0&#13;
    tmx         " X = M&#13;
 <span class="ent">➋</span> jmp,calc    " Y = f(X)&#13;
    jmp,dump    " dump Y as character&#13;
 <span class="ent">➌</span> inc         " M = M + 1&#13;
 <span class="ent">➍</span> cmp,13      " M == 13?&#13;
    tst,e,2     " yes, done&#13;
    gto,-6      " no, loop&#13;
    set,10      " done&#13;
    chr&#13;
    hlt<span epub:type="pagebreak" id="page_347"/>&#13;
}&#13;
&#13;
{ dump tym chr jmp,main }</pre>&#13;
<p class="caption" id="ch013list3"><em>Listing 13-3: The <span class="codeitalic1">main</span> loop of hello2.filska</em></p>&#13;
<p class="indent"><a href="ch13.xhtml#ch013list3">Listing 13-3</a> presents <code>main</code> and <code>dump</code>. Let’s begin with <code>dump</code>. We’ve seen this subprogram before in <a href="ch13.xhtml#ch013list1">Listing 13-1</a>. It takes the contents of a register, here Y, and dumps it as a character to the console before returning to <code>main</code>.</p>&#13;
<p class="indent">The <code>main</code> subprogram of <a href="ch13.xhtml#ch013list3">Listing 13-3</a> implements the loop over <em>x</em> values. In this case, we’ll use the X register as <em>x</em>, so we initialize it to 0 <span class="ent">➊</span>. Next, we transfer control to the <code>calc</code> subprogram <span class="ent">➋</span>. This subprogram implements <em>y</em> = <em>f</em> (<em>x</em>) and returns <em>y</em> in the Y register. We’ll get to <code>calc</code>’s implementation momentarily. With Y, the ASCII value we want for the current X, we call <code>dump</code> to display the character at the console.</p>&#13;
<p class="indent">We want <em>x</em> from 0 through 12, so we increment memory, which holds our counter <span class="ent">➌</span>, and check to see if we’ve hit 13 characters <span class="ent">➍</span>. If memory equals 13, the <code>tst</code> returns true and we jump ahead two instructions. Otherwise, <em>x</em> &lt; 13 and we go back to the <code>tmx</code> instruction to move the new <em>x</em> value from memory to the X register. The program ends when <em>x</em> = 13 by outputting a newline character and calling <code>hlt</code>.</p>&#13;
<p class="indent">All we have left to implement is <code>calc</code>, the subprogram mapping X to Y via the polynomial. <a href="ch13.xhtml#ch013list2">Listing 13-2</a> points the way for us. We need something like <code>f(x)</code>, which calculates the polynomial term by term. If we create a sequence of Filska instructions that find <em>px</em><sup><em>n</em></sup> for some power, <em>n</em>, and some coefficient, <em>p</em>, we need only accumulate the terms for all powers and coefficients to arrive at <em>y</em>. We also need to round <em>y</em>, but that comes after we calculate it.</p>&#13;
<p class="indent">Rather than show all of <code>calc</code>, we’ll show how we start accumulating the proper terms of the polynomial, how we end, and how we round before returning to <code>main</code>. See <a href="ch13.xhtml#ch013list4">Listing 13-4</a>.</p>&#13;
<pre>{ calc&#13;
    " Y = P0*X**12&#13;
 <span class="ent">➊</span> set,12&#13;
    tmz&#13;
    pow,z=xz&#13;
    set,-4.6431994663395692e-05&#13;
    mul,y=mz&#13;
&#13;
    " Y += P1*X**11&#13;
 <span class="ent">➋</span> set,11&#13;
    tmz&#13;
    pow,z=xz&#13;
    set,3.2633752799095354e-03&#13;
    mul,m=mz&#13;
    add,y=my&#13;
<span class="codeitalic1">--snip--</span><span epub:type="pagebreak" id="page_348"/>&#13;
    " Y = floor(Y+0.5)&#13;
 <span class="ent">➌</span> set,0.5&#13;
    add,m=my&#13;
    flr&#13;
    tmy&#13;
    jmp,main&#13;
}</pre>&#13;
<p class="caption" id="ch013list4"><em>Listing 13-4: The <span class="codeitalic1">calc</span> subprogram of hello2.filska</em></p>&#13;
<p class="indent">The code is sectioned into blocks that each raise X to some power, multiply it by the proper coefficient, and add the product to the total in Y. The first block starts the chain, and the last block concludes it. Let’s start with the highest power of X, which is 12 <span class="ent">➊</span>.</p>&#13;
<p class="indent">To calculate <em>y</em> = <em>f</em> (<em>x</em>), we’ll use subprogram memory and Z as scratch space and accumulate the value of the polynomial term by term in Y. To start, we move 12 into M then to Z. Recall that <code>set</code> applies to only the current subprogram’s memory. Next, we calculate <em>x</em><sup>12</sup> by raising X to the Z power, putting the result back into Z. This is the <code>pow</code> instruction. Now we need to multiply <em>x</em><sup>12</sup> by the proper coefficient, so we set M to the necessary value, multiply by Z, and store the result in Y as the first term of the polynomial.</p>&#13;
<p class="indent">The next term of the polynomial is calculated similarly <span class="ent">➋</span>. The difference here is using 11 as the exponent, multiplying by the proper coefficient for <em>x</em><sup>11</sup>, and adding the product to Y via the <code>mul,m=mz</code> and <code>add,y=my</code> instructions. The polynomial’s remaining terms are found in precisely the same way, by replacing the exponent with 10, then 9, and so on down to 0, multiplying by the appropriate coefficients each time.</p>&#13;
<p class="indent">At this point, Y holds the answer. All that remains is to round it to the nearest integer <span class="ent">➌</span>. We add 0.5 to Y, leaving the answer in M. Then, we call <code><em>flr</em></code> , move the result back to Y, and jump back to <code>main</code> to output Y as a character.</p>&#13;
<p class="indent">In this section, we developed two obfuscated ways to dump the string <code>HELLO, WORLD!</code> to the console. How many more can you think of? If you create a novel approach, please share it with me, and I’ll put it on the book’s GitHub site.</p>&#13;
<p class="indent">Let’s move on to our next example: one that introduces us to execution tracing with Filska.</p>&#13;
<h3 class="h3" id="lev1sec86"><strong>Fibonacci, Anyone?</strong></h3>&#13;
<p class="noindent">In the previous section, we spent far too much energy developing cute ways to output the string <code>HELLO, WORLD!</code>. This section will work with a more straightforward example and use it to explore execution tracing. Our goal is to generate as many terms of the Fibonacci sequence as can fit properly in a Python float.</p>&#13;
<p class="indent">The Fibonacci sequence uses the recurrence relation</p>&#13;
<p class="equationc"><em>F</em><sub>1</sub> = 1,    <em>F</em><sub>2</sub> = 1<br/><em>F</em><em><sub>n</sub></em> = <em>F</em><sub><em>n</em><em>–</em>1</sub> + <em>F</em><sub><em>n</em><em>–</em>2</sub></p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_349"/>so that <em>F</em><sub>3</sub> = <em>F</em><sub>2</sub> + <em>F</em><sub>1</sub> = 1 + 1 = 2, and <em>F</em><sub>4</sub> = <em>F</em><sub>3</sub> + <em>F</em><sub>2</sub> = 2 + 1 = 3, and so on. The first few terms of the Fibonacci sequence are</p>&#13;
<p class="equationc">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …</p>&#13;
<p class="indent">The Fibonacci sequence is named after Leonardo Bonacci, sometimes referred to as Leonardo of Pisa or, most commonly, as Fibonacci. The sequence was known outside of Europe for well over a millennia when Fibonacci used it as an idealized example of rabbit population growth in his 1202 text <em>Liber Abaci</em> (<em>The Book of Calculation</em>).</p>&#13;
<p class="indent">Many books have been written about the Fibonacci sequence and all the places it appears in mathematics. There is even an academic publication, <em>The</em> Fibonacci Quarterly, with issues going back to 1963 (see <em><a href="https://www.fq.math.ca/">https://www.fq.math.ca/</a></em>). Here we’ll relate only a few interesting observations about the sequence.</p>&#13;
<p class="indent">The Fibonacci sequence is intimately related to <em>ϕ</em> (phi), also known as the golden ratio</p>&#13;
<div class="imagec"><img src="Images/f0349-01.jpg" alt="Image" width="308" height="49"/></div>&#13;
<p class="noindent">where the golden ratio is a solution to</p>&#13;
<div class="imagec"><img src="Images/f0349-02.jpg" alt="Image" width="162" height="45"/></div>&#13;
<p class="noindent">For example, if we set <em>y</em> = 1, we get</p>&#13;
<div class="imagec"><img src="Images/f0349-03.jpg" alt="Image" width="74" height="43"/></div>&#13;
<p class="noindent">or</p>&#13;
<p class="equationc"><em>x</em><sup>2</sup> <em>–</em> <em>x</em> <em>–</em> 1 = 0</p>&#13;
<p class="noindent">with the positive solution, via the quadratic formula, as</p>&#13;
<div class="imagec"><img src="Images/f0349-04.jpg" alt="Image" width="435" height="49"/></div>&#13;
<p class="noindent">which is <em>ϕ</em>. Like the Fibonacci sequence, <em>ϕ</em> shows up everywhere in mathematics and nature. A link to the Fibonacci sequence comes from the fact that as <em>n</em> →<em>∞</em>, the ratio of the <em>n</em> + 1th Fibonacci number to the <em>n</em>th approaches <em>ϕ</em></p>&#13;
<div class="imagec"><img src="Images/f0349-05.jpg" alt="Image" width="442" height="216"/></div>&#13;
<p class="noindent">where the last ratio is <em>ϕ</em> to the precision of a Python float.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_350"/>With <em>ϕ</em> in hand, we can calculate the <em>n</em>th Fibonacci number directly via</p>&#13;
<div class="image"><img src="Images/f0350-01.jpg" alt="Image" width="134" height="50"/></div>&#13;
<p class="noindent">which works in code for small values of <em>n</em>, but fails when <em>n</em> gets large because of precision issues.</p>&#13;
<p class="indent">We could fill the remainder of this book with fascinating facts and observations about the Fibonacci sequence, but we’ll bring things back to coding and implement the sequence in Filska (see <a href="ch13.xhtml#ch013list5">Listing 13-5</a>). The code itself is in <em>fib.filska</em>.</p>&#13;
<pre>{ main&#13;
 <span class="ent">➊</span> set,78      " number to generate&#13;
    dec         " dec twice, just printing the first two&#13;
    dec&#13;
    tmz         " Z is the counter&#13;
    set,1       " print '1' and '1'&#13;
    tmx         " X holds the i-2 value&#13;
    prt&#13;
    jmp,nl&#13;
    tmy         " Y holds the i-1 value&#13;
    prt &#13;
    jmp,nl&#13;
 <span class="ent">➋</span> add,m=xy    " find i-th value&#13;
    swp,xy      " X &lt;-- Y, new i-2 value&#13;
    tmy         " Y &lt;-- M, new i-1 value&#13;
    prt         " print ith value&#13;
    jmp,nl&#13;
    tzm         " decrement Z&#13;
    dec&#13;
    tst,z,3     " if zero, done&#13;
    tmz         " Z &lt;-- M&#13;
    gto,-9      " loop&#13;
    hlt         " quit&#13;
}&#13;
&#13;
{ nl  set,10 chr jpr,main }</pre>&#13;
<p class="caption" id="ch013list5"><em>Listing 13-5: Generating the Fibonacci sequence</em></p>&#13;
<p class="indent">In <a href="ch13.xhtml#ch013list5">Listing 13-5</a> we initialize a counter in Z set to 78 <span class="ent">➊</span>. Therefore, we’ll output 78 Fibonacci numbers, counting Z down by 1 each time until it is 0. Why 78? Because <em>F</em><sub>78</sub> = 8,944,394,323,791,464 is the largest Fibonacci number that fits in a 64-bit float. Were Filska extended to operate on integers as Python integers instead of Python floats, we could generate Fibonacci numbers until we run out of memory.</p>&#13;
<p class="indent">To get the first two numbers, we decrement Z twice and print the constant <code>1</code> twice. Boring, but effective. Then, we use the X and Y registers to</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_351"/>hold the previous two Fibonacci numbers and their sum to generate the next. The recurrence loop begins by calculating the next Fibonacci number <span class="ent">➋</span>. X and Y are updated by shifting the current value of Y to X and the new Fibonacci value in M to Y. We then decrement Z and branch forward to <code>hlt</code> if it is 0; otherwise, the loop repeats <span class="ent">➋</span>. <a href="ch13.xhtml#ch013list5">Listing 13-5</a> is straightforward; therefore, it’s a good example for execution tracing.</p>&#13;
<p class="indent">To run <em>fib.filska</em> with tracing, use a command line like this:</p>&#13;
<pre>&gt; <span class="codestrong1">python3 filska.py fib.filska -t</span></pre>&#13;
<p class="noindent">The <code>-t</code> flag is the signal to trace execution, one instruction at a time. Doing this presents us with</p>&#13;
<pre>CP:MAIN,PC:000,X:0.000000,Y:0.000000,Z:0.000000,M:0.000000,&#13;
   Z:0,E:0,L:0,G:0,  SET,78&#13;
&lt;enter&gt; or 'q' to quit:</pre>&#13;
<p class="noindent">and a prompt waiting for us to hit ENTER or <code>q</code> to quit. Let’s break down the status line:</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:45%"/>&#13;
<col style="width:55%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Displayed Text</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Description</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>CP:MAIN</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Current subprogram name</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>PC:000</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Current program counter</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>X:0.000000</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Register values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Y:0.000000</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Z:0.000000</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>M:0.000000</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Local memory value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Z:0</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">“Zero” flag</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>E:0</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">“Equal” flag</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>L:0</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">“Less than” flag</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>G:0</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">“Greater than” flag</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The next instruction is <code>set,78</code>. Hitting ENTER gives us</p>&#13;
<pre>CP:MAIN,PC:001,X:0.000000,Y:0.000000,Z:0.000000,M:78.000000,&#13;
   Z:0,E:0,L:0,G:0,     DEC&#13;
&lt;enter&gt; or 'q' to quit:</pre>&#13;
<p class="noindent">showing us that local memory is now 78 and that the next instruction is <code>dec</code>. If we press ENTER exactly seven times from this instruction, we pass through to the <code>jmp,nl</code> instruction</p>&#13;
<pre>CP:NL,PC:000,X:1.000000,Y:0.000000,Z:76.000000,M:0.000000,&#13;
   Z:0,E:0,L:0,G:0,  SET,10&#13;
&lt;enter&gt; or 'q' to quit:</pre>&#13;
<p class="noindent">telling us that we are about to execute the first instruction of subprogram <code>nl</code>. How do we know it’s the first instruction? Because the program counter, <span epub:type="pagebreak" id="page_352"/><code>PC</code>, is 0. Note also that the X register is 1, set previously by the <code>tmx</code> instruction in <code>main</code>.</p>&#13;
<p class="indent">After three more presses of ENTER, we get</p>&#13;
<pre>CP:MAIN,PC:008,X:1.000000,Y:0.000000,Z:76.000000,M:1.000000,&#13;
   Z:0,E:0,L:0,G:0,     TMY&#13;
&lt;enter&gt; or 'q' to quit:</pre>&#13;
<p class="noindent">which shows us back in <code>main</code> and about to execute instruction 8 to move the 1 from memory to Y.</p>&#13;
<p class="indent">Six more presses of ENTER later, and the one after that gives</p>&#13;
<pre>CP:MAIN,PC:011,X:1.000000,Y:1.000000,Z:76.000000,M:1.000000,&#13;
   Z:0,E:0,L:0,G:0, ADD,M=XY&#13;
&lt;enter&gt; or 'q' to quit: &#13;
CP:MAIN,PC:012,X:1.000000,Y:1.000000,Z:76.000000,M:2.000000,&#13;
   Z:0,E:0,L:0,G:0,  SWP,XY&#13;
&lt;enter&gt; or 'q' to quit:</pre>&#13;
<p class="noindent">The <code>add</code> instruction has set local memory to 2: <em>M</em> ←<em>X</em> + <em>Y</em>.</p>&#13;
<p class="indent">Repeated ENTER keypresses trace through the remainder of the recurrence loop to <code>tst</code> on Z equal to 0 and then follow <code>gto</code> back to <code>add</code>, looping until Z is eventually 0.</p>&#13;
<p class="indent">The tracing functionality is quite useful when developing Filska programs. Also helpful is working with code in small pieces—usually individual subprograms—to get them running as they should.</p>&#13;
<p class="indent">The remainder of this chapter presents several other Filska programs for fun and learning. Let’s see how Filska generates random numbers.</p>&#13;
<h3 class="h3" id="lev1sec87"><strong>Random Numbers</strong></h3>&#13;
<p class="noindent">Filska’s <code>rnd</code> instruction sets subprogram memory to a random floating-point number, [0,1). In reality, of course, this number isn’t random, but a pseudorandom approximation. Also, it’s cheating because <code>rnd</code> is using Python’s <code>random</code> module under the hood. Python’s <code>random</code> module uses the Mersenne Twister pseudorandom number generator, a pretty good generator that is sufficient for all but the most demanding of tasks. One measure of a pseudorandom generator’s quality is its <em>period</em>, that is, how many numbers it can generate before the sequence begins to repeat. For the Mersenne Twister, the period is 2<sup>19937</sup> <em>–</em> 1, which should be good enough for most anyone.</p>&#13;
<p class="indent">In this section, we’ll develop code to generate pseudorandom numbers with Filska <em>without</em> cheating, that is, without the <code>rnd</code> instruction. Instead, we’ll implement the Park and Miller linear congruential generator, also known as MINSTD. This linear congruential generator is a simple algorithm with a period of about 2<sup>31</sup>. Far less than the Mersenne Twister period, but still quite sufficient for many noncritical tasks like games.</p>&#13;
<h4 class="h4" id="lev2sec121"><span epub:type="pagebreak" id="page_353"/><strong><em>Implementing MINSTD</em></strong></h4>&#13;
<p class="noindent">Most pseudorandom number generators are iterative, meaning the previous pseudorandom value is used to generate the next. The first value in the sequence is generated from a user-supplied seed value. Fixing the seed value fixes the sequence of values generated. In this way, it’s possible to create a deterministic sequence of values that pass randomness tests, as strange as that sounds.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There exist pseudorandom generators capable of generating the <em>n</em>th value of the sequence for a specified seed <em>without</em> generating the</em> n – <em>1 values before it. To find such a generator, search for “counter-based random number generator.”</em></p>&#13;
</div>&#13;
<p class="indent">The Park and Miller algorithm runs as follows:</p>&#13;
<ol>&#13;
<li class="noindent">Select a seed value and call it <em>x</em><sub>0</sub>.</li>&#13;
<li class="noindent">Generate the next seed value: <em>x</em><sub><em>i</em>+1</sub> ← 48271<em>x</em><em><sub>i</sub></em> mod (2<sup>31</sup> <em>–</em> 1).</li>&#13;
<li class="noindent">Return the floating-point version: <em>x</em><sub><em>i</em>+1</sub>/(2<sup>31</sup> <em>–</em> 1).</li>&#13;
<li class="noindent">Use <em>x</em><sub><em>i</em>+1</sub>  as <em>x</em><sub><em>i</em></sub>  for the next pseudorandom value.</li>&#13;
</ol>&#13;
<p class="indent">The algorithm is a recurrence relation similar to what we used above for generating Fibonacci numbers. Therefore, we expect an initialization section followed by a loop that spits out the next number in the sequence as a float. For the seed, <em>x</em><sub>0</sub>, we are free to pick any integer in [1, 2<sup>31</sup> <em>–</em> 1). We’ll use 8,675,309, but you can replace it with any number you wish to get a different sequence of values. The code we need is in <em>random.filska</em> (see <a href="ch13.xhtml#ch013list6">Listing 13-6</a>).</p>&#13;
<pre>{ main&#13;
    set,8675309     " the seed&#13;
    tmx &#13;
    set,48271&#13;
    mul,x=mx&#13;
    set,2147483647  " 2^31 - 1 &#13;
    mod,x=xm&#13;
    jmp,make_float&#13;
    gto,-5&#13;
}&#13;
&#13;
{ make_float&#13;
    set,2147483647&#13;
    div,m=xm&#13;
    prt &#13;
    set,10&#13;
    chr &#13;
    jmp,main&#13;
}</pre>&#13;
<p class="caption" id="ch013list6"><em>Listing 13-6: Park and Miller LCG in Filska</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_354"/><a href="ch13.xhtml#ch013list6">Listing 13-6</a> initializes X with the desired seed, stores the multiplier (48,271) in memory, and starts the loop to calculate the next seed value. The recurrence relation is implemented in stages. First, the seed in X is multiplied by 48,271, with the result back in X. Then 2<sup>31</sup> <em>–</em> 1 is loaded into memory, followed by the modulo operation, again with the result in X. X is now the next value in the sequence. The floating-point version is output by <code>make_float</code>, which divides X by 2<sup>31</sup> <em>–</em> 1, dumping the result to the console along with a newline to get one pseudorandom float per line. Back in <code>main</code>, the loop continues, so the program dumps floats forever.</p>&#13;
<p class="indent">Run the program and direct output to a file, say <em>numbers.txt</em>.</p>&#13;
<pre>&gt; <span class="codestrong1">python3 filska.py random.filska &gt;numbers.txt</span></pre>&#13;
<p class="noindent">Allow the program to run for maybe 15 minutes, or until there are more than 1 million lines in the file. We need many values to get meaningful statistics on the quality of the output, and the more the merrier. When you get tired of waiting, use CTRL-C to exit the program.</p>&#13;
<h4 class="h4" id="lev2sec122"><strong><em>Evaluating MINSTD</em></strong></h4>&#13;
<p class="noindent">We now have a large text file of floating-point values. They certainly look random enough, but are they? How can we tell? The honest answer is that we can’t. We cannot <em>prove</em> these are random values, and in fact, we know that they aren’t because we used a deterministic method to generate them. John von Neumann, one of the founders of computer science, famously quipped that anyone considering deterministic methods for generating random numbers is “in a state of sin.” Still, we’d like to think the sequence we just generated is at least random-ish, meaning knowing one value doesn’t help us much in guessing the next value.</p>&#13;
<p class="indent">As it happens, there are many highly sophisticated ways to test for randomness. None are conclusive, but as a group, they lend credence to a belief that a sequence of values is random for all practical purposes. The tests are extensive, far beyond what we need, but fortunately for us, there is one that is simple, easy to evaluate, and included with standard Linux distributions. To boot, it has a cool, Tolkienesque name: <code>ent</code>.</p>&#13;
<p class="indent">However, <code>ent</code> only works with random <em>bytes</em>, not floating-point numbers. That’s okay; a snippet of Python converts our file of random floats into a file of random bytes.</p>&#13;
<pre>import numpy as np&#13;
d = np.loadtxt("numbers.txt")&#13;
b = []&#13;
for i in range(len(d)):&#13;
    b.append(int(np.floor(256*d[i])))&#13;
open("random.dat","wb").write(bytearray(b))</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_355"/>We assume the captured floats are in the file <em>numbers.txt</em>. The byte version is stored in <em>random.dat</em>. The array <code>d</code> contains the floats read from <em>numbers.txt</em>. The loop generates a list, <code>b</code>, of integers found by multiplying the float value by 256 and dropping any fractional part via <code>floor</code>. Lastly, the list of integers is formed into a byte array and dumped into the output file.</p>&#13;
<p class="indent">Let’s run <code>ent</code> on <em>random.dat</em></p>&#13;
<pre>&gt; <span class="codestrong1">ent random.dat</span></pre>&#13;
<p class="noindent">producing</p>&#13;
<pre>Entropy = 7.999803 bits per byte.&#13;
&#13;
Optimum compression would reduce the size&#13;
of this 1044919 byte file by 0 percent.&#13;
&#13;
Chi square distribution for 1044919 samples is 285.53, and randomly&#13;
would exceed this value 9.16 percent of the times.&#13;
&#13;
Arithmetic mean value of data bytes is 127.5722 (127.5 = random).&#13;
Monte Carlo value for Pi is 3.138619490 (error 0.09 percent).&#13;
Serial correlation coefficient is -0.001688 (totally uncorrelated = 0.0).</pre>&#13;
<p class="noindent">The values you see when you run the code will be slightly different because the number of randoms generated before hitting CTRL-C will be different, or if you change the seed value.</p>&#13;
<p class="indent">What to make of <code>ent</code>’s output? We’ll skip the chi-square part and consider the other metrics: entropy/compression, arithmetic mean value, estimate of <em>π</em>, and the serial correlation.</p>&#13;
<p class="indent">The <em>entropy</em> is a measure of the information content, in this case as bits per byte. There are eight bits in a byte, so the maximum possible entropy is 8.0. This means there is no way to simplify the file’s representatio, as there is no redundancy. Our file has an entropy of 7.999803 bits per byte, meaning it’s close to maximum randomness. This is essentially what the statement about optimum compression is saying.</p>&#13;
<p class="indent">If the file consists of purely random bytes, we expect as many bytes to be above the median value of 127.5 / 2 as below, so the arithmetic mean should be 127.5. Our file has a mean value of 127.5722, which, again, is pretty close to what we’d expect from a random sequence.</p>&#13;
<p class="indent">A Monte Carlo process simulates something. In this case, it’s using the random bytes to simulate dart throws then asking how many darts land inside a circle of radius 1 and how many land inside a square of side 1 circumscribed over the circle. The ratio of darts landing within the circle to those landing within the square leads to an estimate of <em>π</em>. Here, the estimate is in the ballpark but not too impressive. Also, there are only 1 million or so <span epub:type="pagebreak" id="page_356"/>values in the file. Most randomness tests want hundreds of millions to billions of examples before making a statement, so we are doing well here, too.</p>&#13;
<p class="indent">The final test is a serial correlation test. The earlier tests looked at the values without caring about their ordering in the file. The serial test pays attention to the order. It’s looking to see if knowing the value of one byte gives you knowledge about the value of the next byte. For a random sequence, there should be no such correlation. Here we get a slight negative correlation, which, again, is a reasonable statement that we’ve generated a (mostly) random sequence.</p>&#13;
<p class="indent">The results above give us confidence that our Filska pseudorandom number generator is working correctly. Let’s move on to our next example, one that also generates data to be captured in a file.</p>&#13;
<h3 class="h3" id="lev1sec88"><strong>A Simple Fractal</strong></h3>&#13;
<p class="noindent">In <a href="ch10.xhtml#ch10">Chapter 10</a> we briefly encountered the Sierpiński triangle. Let’s see how to generate the points of this fractal in Filska. The algorithm is</p>&#13;
<ol>&#13;
<li class="noindent">Define three triangle vertices: (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>),  (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>),  and (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>).</li>&#13;
<li class="noindent">Choose one vertex at random, say (<em>x</em>, <em>y</em>) = (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>).</li>&#13;
<li class="noindent">Select another vertex at random, say (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>).</li>&#13;
<li class="noindent">Update <img src="Images/f0356-01.jpg" alt="Image" width="210" height="26"/>.</li>&#13;
<li class="noindent">Output (<em>x</em>, <em>y</em>)  to be plotted later.</li>&#13;
<li class="noindent">Repeat from Step 3 for the desired number of points.</li>&#13;
</ol>&#13;
<p class="indent">In essence, we plot the midpoint between the current point and a randomly selected vertex of the triangle and repeat until we generate as many points as we wish to plot. Once again, this is a recurrence relation where the <em>n</em> + 1th point is constructed from the <em>n</em>th point, only now we are working in two dimensions, not one (see <a href="ch13.xhtml#ch013list7">Listing 13-7</a>).</p>&#13;
<pre>x,y = 1,0&#13;
repeat for N points:&#13;
    r = RND&#13;
    if (r &lt; 0.333333):&#13;
        x = 0.5*(x + 0) = 0.5*x&#13;
        y = 0.5*(y + 0) = 0.5*y&#13;
    elif (r &lt; 0.666666):&#13;
        x = 0.5*(x + 0.5) = 0.5*x + 0.25&#13;
        y = 0.5*(y + 1) = 0.5*y + 0.5&#13;
    else:&#13;
        x = 0.5*(x + 1) = 0.5*x + 0.5&#13;
        y = 0.5*(y + 0) = 0.5*y&#13;
    print x,y</pre>&#13;
<p class="caption" id="ch013list7"><em>Listing 13-7: Pseudocode for the Sierpiński triangle</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_357"/>Let’s make the algorithm explicit with pseudocode. First, we’ll pick the vertices of the triangle: (0,0); (0.5,1); (1,0). Then, we need to code <a href="ch13.xhtml#ch013list7">Listing 13-7</a> where <code>rnd</code> returns a random float, [0, 1). We initialize <em>x</em> and <em>y</em> to the point (1,0). Any of the three points would do.</p>&#13;
<p class="indent">Next, we start a loop for the desired number of points, <code>N</code>. The three cases select one of the three vertex points with equal probability. If the random value in <code>r</code> is below one-third, we’ve selected the first point, (0,0), so the midpoint is the average of both the <em>x</em> and <em>y</em> values plus 0 and 0. Similarly, if <code>r</code> is 0<em>.</em>333333 ≤<em>r</em> &lt; 0<em>.</em>666666, we select the vertex at (0.5,1). Lastly, if <code>r</code> is ≥ 0<em>.</em>666666, we use the vertex at (1,0). After updating <em>x</em> and <em>y</em>, we print them as a pair and repeat the loop.</p>&#13;
<p class="indent">The midpoint formulas simplify as shown in <a href="ch13.xhtml#ch013list7">Listing 13-7</a>. Observe that each pass through the loop updates <em>x</em> and <em>y</em> by first dividing by 2 (multiplying by 0.5) and then adding an offset depending upon the selected vertex. If the vertex is (0,0), the offset is 0 for both <em>x</em> and <em>y</em>. If the vertex is (0.5,1), the offset is 0.25 in <em>x</em> and 0.5 in <em>y</em>. Lastly, for (1,0), the offset is 0.5 in <em>x</em> and 0 for <em>y</em>.</p>&#13;
<p class="indent">This observation means the loop can be rewritten first to divide <em>x</em> and <em>y</em> by 2, and then we can add the offset—there is no need to have code that calculates the repeated instances of <code>0.5*x</code> and <code>0.5*y</code> as shown in <a href="ch13.xhtml#ch013list7">Listing 13-7</a>. This simplification helps considerably when writing the Filska implementation.</p>&#13;
<p class="indent">Our implementation uses three subprograms: <code>main</code>, <code>loop</code>, and <code>print</code>. Also, we’ll store the current <em>x</em> value in the X register and, not surprisingly, the current <em>y</em> value in the Y register. We’ll use <code>main</code> to initialize X and Y, set up the counter for the desired number of output points, which we’ll store in Z, and then transfer execution to <code>loop</code> (see <a href="ch13.xhtml#ch013list8">Listing 13-8</a>).</p>&#13;
<pre>{ main&#13;
    set,1       " start at 1,0 &#13;
    tmx &#13;
    set,0&#13;
    tmy &#13;
    set,60000   " number of points to output&#13;
    dec &#13;
    tmz &#13;
    jmp,loop&#13;
}</pre>&#13;
<p class="caption" id="ch013list8"><em>Listing 13-8: The <span class="codeitalic1">main</span> loop of sierpinski.filska</em></p>&#13;
<p class="indent">Next, we’ll use <code>print</code> to display the X and Y registers as an (<em>x</em>, <em>y</em>) pair on the same line (see <a href="ch13.xhtml#ch013list9">Listing 13-9</a>).</p>&#13;
<pre>{ print&#13;
    txm&#13;
    prt&#13;
    set,32&#13;
    chr chr&#13;
    tym<span epub:type="pagebreak" id="page_358"/>&#13;
    prt&#13;
    set,10&#13;
    chr&#13;
    jmp,loop&#13;
}</pre>&#13;
<p class="caption" id="ch013list9"><em>Listing 13-9: The <span class="codeitalic1">print</span> subprogram of sierpinski.filska</em></p>&#13;
<p class="indent"><a href="ch13.xhtml#ch013list9">Listing 13-9</a> first moves X to local memory to print it. Then it prints two spaces (character 32) before printing Y and a newline.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch013list10">Listing 13-10</a> contains the bulk of the program. It’s the body of the loop in <a href="ch13.xhtml#ch013list7">Listing 13-7</a>.</p>&#13;
<pre>{ loop&#13;
 <span class="ent">➊</span> set,2&#13;
    div,x=xm&#13;
    div,y=ym&#13;
 <span class="ent">➋</span> rnd&#13;
    cmp,0.333333&#13;
 <span class="ent">➌</span> tst,l,10&#13;
    cmp,0.666666&#13;
 <span class="ent">➍</span> tst,l,4&#13;
&#13;
 <span class="ent">➎</span> set,0.5&#13;
    add,x=xm&#13;
    gto,5&#13;
&#13;
 <span class="ent">➏</span> set,0.25&#13;
    add,x=xm&#13;
    set,0.5&#13;
    add,y=ym&#13;
&#13;
 <span class="ent">➐</span> jmp,print&#13;
&#13;
 <span class="ent">➑</span> tzm&#13;
    dec&#13;
    tst,z,3&#13;
    tmz&#13;
    jpr,loop&#13;
    hlt&#13;
}</pre>&#13;
<p class="caption" id="ch013list10"><em>Listing 13-10: The <span class="codeitalic1">loop</span> subprogram of sierpinski.filska</em></p>&#13;
<p class="indent">First, we divide the X and Y registers by 2 <span class="ent">➊</span>. Then, we use <code>loop</code>’s memory to hold a random value <span class="ent">➋</span>.</p>&#13;
<p class="indent">If the random value is less than 0.333333, the <code>tst,l,10</code> instruction <span class="ent">➌</span> is true and execution moves to the <code>jmp</code> to <code>print</code> <span class="ent">➐</span>. This is the (0,0) vertex where there is no offset to add. If memory is less than 0.666666 <span class="ent">➍</span>, execution moves to adding an offset of 0.25 to X and 0.5 to Y <span class="ent">➏</span>. This is the (0.5,1) <span epub:type="pagebreak" id="page_359"/>vertex case. Lastly, if memory is greater than or equal to 0.666666, we have the (1,0) case so we need only add an offset of 0.5 to X <span class="ent">➎</span>. After printing the new X and Y values <span class="ent">➐</span>, the Z register is decremented and tested for 0 <span class="ent">➑</span>. If Z is 0, <code>hlt</code> stops the program. If not, the <code>loop</code> subprogram is run from the beginning courtesy of the <code>jpr</code> instruction.</p>&#13;
<p class="indent">Let’s run the program and capture the output.</p>&#13;
<pre>&gt; <span class="codestrong1">python3 filska.py sierpinski.filska &gt;points.txt</span></pre>&#13;
<p class="noindent">Here, <em>points.txt</em> becomes a collection of 60,000 (<em>x</em>, <em>y</em>) pairs.</p>&#13;
<p class="indent">To see the fractal, we need to plot the points. A few lines of Python will do the trick.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import numpy as np</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">import matplotlib.pylab as plt</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">d = np.loadtxt("points.txt")</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">plt.plot(d[:,0],d[:,1], linestyle='none', marker=',')</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">plt.show()</span></pre>&#13;
<p class="noindent">The result should look very much like <a href="ch13.xhtml#ch013fig2">Figure 13-2</a>. Note that <a href="ch13.xhtml#ch013fig2">Figure 13-2</a> uses 600,000 points, 10 times as many as <em>sierpinski.filska</em> generates by default.</p>&#13;
<div class="image"><img id="ch013fig2" src="Images/13fig02.jpg" alt="Image" width="589" height="437"/></div>&#13;
<p class="figcap"><em>Figure 13-2: The Sierpiński triangle with 600,000 points</em></p>&#13;
<h3 class="h3" id="lev1sec89"><strong>Getting to the Roots of the Problem</strong></h3>&#13;
<p class="noindent">In algebra class, we all spent far too much time factoring quadratic equations of the form <em>ax</em><sup>2</sup> + <em>bx</em> + <em>c</em> to find the roots, that is, the values of <em>x</em> such that <em>ax</em><sup>2</sup> + <em>bx</em> + <em>c</em> = 0. After much consternation and many practice problems, we were told of the formula to find the roots directly. This is the quadratic formula, which we used above to find the value of <em>ϕ</em>, the golden ratio.</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_360"/><img src="Images/f0360-01.jpg" alt="Image" width="164" height="49"/></div>&#13;
<p class="indent">The value under the square root is known as the <em>discriminant</em>, Δ = <em>b</em><sup>2</sup> – 4<em>ac</em>. The sign of the discriminant tells us something useful about the roots.</p>&#13;
<div class="imagec"><img src="Images/f0360-02.jpg" alt="Image" width="260" height="87"/></div>&#13;
<p class="indent">For the first case, the discriminant is negative, and the square root of a negative number is imaginary. For the second case, the square root is 0, and the single root is <em>x</em> = <em>–b</em>/(2<em>a</em>). For the third case, the discriminant is positive, the square root exists, and there are two distinct real roots.</p>&#13;
<p class="indent">The file <em>roots.filska</em> contains a complete program to calculate the roots of an arbitrary quadratic polynomial. Let’s run it a few times to see what it outputs. Then, we’ll examine the portions of the code related to the discriminant and the roots themselves. The remainder of the code handles text output. It is primarily a series of <code>set</code> and <code>chr</code> instructions, which are essential to the nice formatting of the program, but not helpful in learning how to implement the calculations in Filska.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch013list11">Listing 13-11</a> shows the output for three separate runs of <em>roots.filska</em>.</p>&#13;
<pre>A? 1&#13;
B? 2&#13;
C? 4&#13;
&#13;
Complex roots: -1+1.732050808i&#13;
               -1-1.732050808i&#13;
-------------------------------&#13;
A? 1&#13;
B? 4&#13;
C? 2&#13;
&#13;
1st root: -0.5857864376&#13;
2nd root: -3.414213562&#13;
-------------------------------&#13;
A? -4&#13;
B? 12&#13;
C? -9&#13;
&#13;
One root: 1.5</pre>&#13;
<p class="caption" id="ch013list11"><em>Listing 13-11: Three runs of roots.filska</em></p>&#13;
<p class="indent">The prompts ask the user to enter the coefficients of the quadratic, the <em>a</em>, <em>b</em>, and <em>c</em> values. In the first case, we are asking for the roots of <em>x</em><sup>2</sup> + 2<em>x</em> + 4 and are told they are complex because the discriminant is negative. In the <span epub:type="pagebreak" id="page_361"/>second case, we want the roots of <em>x</em><sup>2</sup> + 4<em>x</em> + 2, which are real. The last case is asking about <em>–</em> 4<em>x</em><sup>2</sup> + 12<em>x –</em> 9, which leads to a zero discriminant and only one root.</p>&#13;
<p class="indent">The flow of this program is quite linear: the user enters the coefficients, the discriminant is calculated, and, based on the value of the discriminant, the proper roots are calculated. If you look at <em>roots.filska</em>, you’ll see that the key subprograms are <code>main</code>, <code>positive</code>, <code>equal</code>, and <code>negative</code>, along with three subprograms to get the coefficients: <code>getA</code>, <code>getB</code>, and <code>getC</code>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch013list12">Listing 13-12</a> presents the <code>main</code> subprogram.</p>&#13;
<pre>{ main&#13;
    "  Get a, b, and c&#13;
 <span class="ent">➊</span> jmp,getA&#13;
    jmp,getB&#13;
    jmp,getC&#13;
    &#13;
    "  Calculate D&#13;
 <span class="ent">➋</span> jmp,getA        " X=a &#13;
    set,4           " M=4 &#13;
    mul,m=mx        " M = M*X  (4a)&#13;
    jmp,getC        " X=c &#13;
    mul,m=mx        " M = M*X  (4ac)&#13;
    neg             " M = -M   (-4ac)&#13;
    tmz             " Z = M    (-4ac)&#13;
    jmp,getB        " X=b &#13;
    txm             " M=b &#13;
    mul,m=mx        " M = M*X  (b*b)&#13;
    add,m=mz        " M = M+Z  (b*b - 4ac)&#13;
    tmy             " Y = D    (disc)&#13;
    jmp,getA        " X = a &#13;
    txm             " M = X &#13;
    tmz             " Z = M    (a) &#13;
    jmp,getB        " X = b    (b) &#13;
    tym             " M = Y    (disc)&#13;
 <span class="ent">➌</span> cmp,0           " compare(M,0)&#13;
    tst,g,3         " D &gt; 0  --&gt; positive&#13;
    tst,e,3         " D == 0 --&gt; equal&#13;
    tst,l,3         " D &lt; 0  --&gt; negative&#13;
    jmp,positive&#13;
    jmp,equal&#13;
    jmp,negative&#13;
}</pre>&#13;
<p class="caption" id="ch013list12"><em>Listing 13-12: The <span class="codeitalic1">main</span> subprogram</em></p>&#13;
<p class="indent">From the comments, we see that <code>main</code> asks for <em>a</em>, <em>b</em>, and <em>c</em> and then calculates the discriminant (<code>D</code>) before using its value to jump to either <code>positive</code>, <code>equal</code>, or <code>negative</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_362"/>Let’s begin with the last three instructions in <code>main</code>. At first glance, it seems odd to put them one after the other, but that’s merely an illusion caused by thinking in terms of functions. We need to consider them in relation to the <code>cmp</code> and <code>tst</code> instructions above.</p>&#13;
<p class="indent">The <code>cmp</code> instruction compares <code>main</code>’s memory, the discriminant, to 0 <span class="ent">➌</span>. If the discriminant is greater than 0, we transfer control to the <code>positive</code> subprogram by branching three instructions forward using <code>tst,g,3</code>. Similarly, we transfer control to <code>equal</code> if the discriminant is 0 and <code>negative</code> if the discriminant is less than 0. All three of these subprograms eventually execute <code>hlt</code> and none return control to <code>main</code>.</p>&#13;
<p class="indent">Filska is quite limited in the data it can track, an intentional design goal to make us think more about how to arrange our programs, so we need to consider which values must be stored and when. We should ask the user for the coefficients of the quadratic. We also need to keep them somewhere and get them back on demand. We have the three registers, but if we store the coefficients in them, we have only the single memory location of each subprogram to use for calculations. We need the registers to transfer data between subprograms and to participate in calculations.</p>&#13;
<p class="indent">The solution is to create a subprogram that acts as a small object. The subprogram can store a value passed to it and then return the value on demand. Think of the subprogram as an instance of a simple class that we might express in Python as follows:</p>&#13;
<pre>class Store:&#13;
    def __init__(self, v):&#13;
        self.v = v&#13;
    def Get(self):&#13;
        return self.v</pre>&#13;
<p class="indent">Instances of this class are given a value to store when they are created, and later return that value when asked using the <code>Get</code> method. This is what we need: to assign a value once and then retrieve it multiple times later on.</p>&#13;
<p class="indent">In Filska, we get the same effect with a subprogram using its memory to store the value. Consider <code>getA</code>.</p>&#13;
<pre>{ getA&#13;
    set,65 chr&#13;
    set,63 chr&#13;
    set,32 chr&#13;
    ipt&#13;
    jmp,main&#13;
    tmx&#13;
    jmp,main&#13;
    gto,-2&#13;
}</pre>&#13;
<p class="indent">The first three lines of <code>getA</code> print <code>A?</code> and then ask for a number from the user with <code>ipt</code>. Whatever number the user enters is stored in local memory. Then, control is transferred back to <code>main</code> via <code>jmp</code>. The next transfer from <code>main</code> <span epub:type="pagebreak" id="page_363"/>back to <code>getA</code> begins with the <code>tmx</code> instruction to put the user’s value in the X register and then transfer back to <code>main</code>. However, any future transfer back to <code>getA</code> will begin with the <code>gto</code> instruction jumping back 2 to start again at <code>tmx</code>. This loop repeats indefinitely: <code>getA</code> will now only load X with the user’s value. We have a “write once, read many” place to hold a number—precisely what we need.</p>&#13;
<p class="indent">Looking again at <a href="ch13.xhtml#ch013list12">Listing 13-12</a>, we see the first three transfers to get the coefficients <span class="ent">➊</span>. This is followed later, during the calculation of the discriminant, by transfers to <code>getA</code>, <code>getB</code>, and <code>getC</code> when those values are needed.</p>&#13;
<p class="indent">Calculation of the discriminant is an exercise in juggling data values so that we do not run out of places to put them (see <a href="ch13.xhtml#ch013list12">Listing 13-12</a> <span class="ent">➋</span>). Let’s walk through the code. We need to calculate <em>b</em><sup>2</sup> <em>–</em> 4<em>ac</em> and begin by calculating <em>–</em> 4<em>ac</em>.</p>&#13;
<pre>    jmp,getA        " X=a &#13;
    set,4           " M=4 &#13;
    mul,m=mx        " M = M*X  (4a)&#13;
    jmp,getC        " X=c &#13;
    mul,m=mx        " M = M*X  (4ac)&#13;
    neg             " M = -M   (-4ac)&#13;
    tmz             " Z = M    (-4ac)</pre>&#13;
<p class="noindent">We store <em>–</em> 4<em>ac</em> temporarily in Z. Now we need to find <em>b</em><sup>2</sup> and add <em>–</em> 4<em>ac</em> to it.</p>&#13;
<pre>    jmp,getB        " X=b &#13;
    txm             " M=b &#13;
    mul,m=mx        " M = M*X  (b*b)&#13;
    add,m=mz        " M = M+Z  (b*b - 4ac)&#13;
    tmy             " Y = D    (disc)</pre>&#13;
<p class="indent">We now have the discriminant in Y. To calculate the roots, let’s rewrite the quadratic equation using the discriminant, Δ.</p>&#13;
<div class="imagec"><img src="Images/f0363-01.jpg" alt="Image" width="114" height="48"/></div>&#13;
<p class="indent">Writing the equation in this form buys us something: we need only <em>a</em>, <em>b</em>, and Δ to calculate the roots. Good! We have three registers available, so let’s use Z for <em>a</em>, X for <em>b</em>, and Y for Δ.</p>&#13;
<pre>    jmp,getA        " X = a &#13;
    txm             " M = X &#13;
    tmz             " Z = M    (a) &#13;
    jmp,getB        " X = b    (b) &#13;
    tym             " M = Y    (disc)</pre>&#13;
<p class="noindent">Here, the last instruction moves the discriminant to <code>main</code>’s memory for the <code>cmp</code> instruction of <a href="ch13.xhtml#ch013list12">Listing 13-12</a> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The remaining subprograms, <code>positive</code>, <code>equal</code>, and <code>negative</code>, and the subprograms used by them, calculate and output the specific roots. As mentioned, many of the instructions relate to formatting the output. You can <span epub:type="pagebreak" id="page_364"/>review those instructions on your own, but let’s conclude by stepping through <code>positive</code> to see how the calculation is done for two real roots.</p>&#13;
<pre>{ positive&#13;
 <span class="ent">➊</span> set,2           " M = 2&#13;
    mul,m=mz        " M = 2a&#13;
    div,m=xm        " M = b/(2a)&#13;
    neg             " M = -b/(2a)&#13;
    jmp,rest        " X = sqr(Y)/(2a)&#13;
    jmp,?double&#13;
    add,y=mx        " Y = M + X    (-b/(2a)+sqr(D)/(2a))&#13;
    jmp,?double&#13;
    sub,y=mx        " Y = M - X    (-b/(2a)-sqrt(D)/(2a))&#13;
    jmp,?double&#13;
}&#13;
&#13;
{ rest&#13;
    set,2&#13;
    mul,x=mz&#13;
    tym&#13;
    sqr&#13;
    div,x=mx&#13;
    jmp,positive&#13;
}</pre>&#13;
<p class="indent">Rewriting the quadratic equation one last time, we see that the two roots for a positive discriminant are</p>&#13;
<div class="imagec"><img src="Images/f0364-01.jpg" alt="Image" width="121" height="48"/></div>&#13;
<p class="noindent">implying we need both <em>– b</em>/(2<em>a</em>) and <img src="Images/f0394-01.jpg" alt="Image" width="80" height="22"/> so we can add and subtract them. The first term is built piece by piece, as indicated in the comments <span class="ent">➊</span>. It’s left in <code>positive</code>’s memory. Then, transfer to <code>rest</code> builds <img src="Images/f0394-01.jpg" alt="Image" width="80" height="22"/> in X. Notice that doing this destroys <em>b</em>, which was previously in X. That’s okay; we no longer need it. When <code>rest</code> transfers execution back to <code>positive</code>, X has the other term we need, so we first add the terms and call <code>?double</code> (read “print double”) to output what is in Y, subtract the terms, and call <code>?double</code> to get the other root. Notice also that using Y destroys the discriminant, but we no longer need it, either.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_365"/>Whew! That was a lot of steps for something that a more powerful language could implement quickly. Still, the challenge, and fun, is in getting a constrained language to do something useful.</p>&#13;
<h3 class="h3" id="lev1sec90"><strong>Linear Least-Squares Fit to a Line</strong></h3>&#13;
<p class="noindent">Previously, we fit a polynomial to a set of points to arrive at a silly way of printing <code>HELLO, WORLD!</code>. In this section, we’ll again use least-squares fitting, but this time to a line, which is far simpler. Specifically, we have a collection of (<em>x</em>, <em>y</em>) points, and we want to find the equation of a line that best fits them:</p>&#13;
<p class="equationc"><em>y</em> = <em>b</em><em>x</em> + <em>a</em></p>&#13;
<p class="noindent">for some <em>a</em> and <em>b</em> we need to calculate from the data.</p>&#13;
<p class="indent">Unlike least-squares fitting to a polynomial or other function, fitting a line to a dataset has a closed-form solution; this means we can write the equations that give us <em>a</em> and <em>b</em> (see Equation 13.2)</p>&#13;
<div class="imagec"><img src="Images/13eqa02.jpg" alt="Image" width="471" height="193"/></div>&#13;
<p class="noindent">for <em>N</em>, the number of points in the dataset.</p>&#13;
<p class="indent">Equation 13.2 appears a bit daunting at first. Don’t let it throw you. It says we must accumulate sums of all the <em>x</em> values and all <em>y</em> values along with the sums of <em>x</em><sup>2</sup> and <em>x</em> times <em>y</em>. Once we have these sums, calculating <em>b</em> (the slope) and <em>a</em> (the intercept) is straightforward because the ∑ terms become simple numbers.</p>&#13;
<p class="indent">The code for this example is in <em>linfit.filska</em>. From a programming perspective, we’ll see a new kind of Filska subprogram, one that expands on the “write once, read many” idea we used in the previous section. However, before we write code, we must decide how we’ll get Filska to read the datafile. Normally, we’d store the data points as (<em>x</em>, <em>y</em>) pairs, one pair per line. However, if we use redirection to send the data to the Filska program, the <code>ipt</code> instruction will read only one value per line of the input file. Also, we need to tell Filska to stop reading the file so we can complete our calculations.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_366"/>The solution is to put the data in the file with one value per line, first the <em>x</em> value and then the associated <em>y</em> value on the next line. To tell Filska we are done, we’ll end the file with a flag value, one that won’t show up in our dataset. We’ll use <em>–</em>999999, an unlikely data value.</p>&#13;
<p class="indent">For example, if our dataset is</p>&#13;
<p class="equationc">(0, 0<em>.</em>5), (1, 1<em>.</em>1), (2, 2<em>.</em>4), (3, 3<em>.</em>6)</p>&#13;
<p class="noindent">we’ll format it for input as</p>&#13;
<pre>0&#13;
0.5&#13;
1&#13;
1.1&#13;
2&#13;
2.4&#13;
3&#13;
3.6&#13;
-999999</pre>&#13;
<p class="noindent">so each <em>x</em> is followed by its <em>y</em>, and the last value, <code>-999999</code>, tells us there’s no more data to read.</p>&#13;
<p class="indent">As far as Equation 13.2 is concerned, we get the following sums for our example dataset:</p>&#13;
<div class="imagec"><img src="Images/f0366-01.jpg" alt="Image" width="470" height="185"/></div>&#13;
<p class="indent">Meaning the best fit line is</p>&#13;
<div class="imagec"><img src="Images/f0366-02.jpg" alt="Image" width="511" height="154"/></div>&#13;
<p class="noindent">or <em>y</em> = <em>bx</em> + <em>a</em> = 1<em>.</em>06<em>x</em> + 0<em>.</em>31.</p>&#13;
<p class="indent">Let’s see the code in action; then we’ll dive into it. I’ve included a sample dataset, <em>linfit_dataset.txt</em>. If you run <em>linfit.filska</em> using <em>linfit_dataset.txt</em> as the input you get</p>&#13;
<pre>&gt; <span class="codestrong1">python3 filska.py linfit.filska &lt;linfit_dataset.txt</span>&#13;
A=10.46698813&#13;
B=2.272733952</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_367"/>which tells us that the best-fit line is <em>y</em> = <em>Bx</em> + <em>A</em> (see <a href="ch13.xhtml#ch013fig3">Figure 13-3</a>). The fit looks pretty good, so we have confidence that the code is working.</p>&#13;
<div class="imagec"><img id="ch013fig3" src="Images/13fig03.jpg" alt="Image" width="673" height="508"/></div>&#13;
<p class="figcap"><em>Figure 13-3: Best-fit line to the sample dataset</em></p>&#13;
<p class="indent">If we were using a high-level language to code this example, we’d likely store the dataset in some kind of array or list. Then we’d run through the list to generate the necessary sums. However, Filska has no arrays. So how can we do it? The solution comes from observing that all we need is a single pass through the dataset and some way of accumulating each point as we read it. There is no need to store all the data first and then process it, because we can process each point as it is read. In algorithm form, we need to code the following:</p>&#13;
<ol>&#13;
<li class="noindent">Read a point from the input file, (<em>x</em>, <em>y</em>).</li>&#13;
<li class="noindent">Add the <em>x</em>  value to the running total of <em>x</em>  values.</li>&#13;
<li class="noindent">Add <em>x</em><sup>2</sup>  to the running total of <em>x</em><sup>2</sup>  values.</li>&#13;
<li class="noindent">Add <em>y</em>  to the running total of <em>y</em>  values.</li>&#13;
<li class="noindent">Add <em>xy</em>  to the running total of <em>xy</em>  values.</li>&#13;
<li class="noindent">Repeat from Step 1 until all points have been read.</li>&#13;
<li class="noindent">Calculate <em>a</em>  and <em>b</em>  using the running totals.</li>&#13;
</ol>&#13;
<p class="indent">We need to track the sums of <em>x</em>, <em>y</em>, <em>x</em><sup>2</sup>, and <em>xy</em>, along with the total number of points read, <em>N</em>. That’s too many values to depend solely upon memory and the registers. Thus, we need something much like the subprograms of the previous section, which can be initialized, sum, and finally report <span epub:type="pagebreak" id="page_368"/>their totals. Using the analogy of a class, as we did previously, we need something like the following.</p>&#13;
<pre>class Adder:&#13;
    def __init__(self):&#13;
        self.s = 0&#13;
    def Add(self, v):&#13;
        self.s += v&#13;
    def Get(self):&#13;
        return self.s</pre>&#13;
<p class="noindent">This class sets its internal state to 0 when instantiated, and then adds values passed to <code>Add</code> and reports its current sum when <code>Get</code> is called.</p>&#13;
<p class="indent">We can build this structure in Filska using subprogram memory to store the sum and registers to provide values or return values. We’ll keep the current point’s <em>x</em> value in the X register and the <em>y</em> value in the Y register. We’ll use the Z register to tell the subprogram whether to accumulate (Z = 0) or return the sum (Z ≠ 0) in Y.</p>&#13;
<p class="indent">Now take a look at <a href="ch13.xhtml#ch013list13">Listing 13-13</a>, which shows the <code>sumxy</code> subprogram from <em>linfit.filska</em>.</p>&#13;
<pre>{ sumxy&#13;
 <span class="ent">➊</span> set,0       " first call: zero sum &#13;
    jmp,main    " and back to main&#13;
 <span class="ent">➋</span> swp,mz      " look at Z stashing M&#13;
    tst,n,8     " return value in Y&#13;
 <span class="ent">➌</span> swp,mz      " restore total&#13;
    mul,z=xy    " Z &lt;-- X*Y &#13;
    add,z=mz    " Z &lt;-- M + X*Y &#13;
    set,0       " M &lt;-- 0&#13;
    swp,mz      " M &lt;--&gt; Z, restore Z and M&#13;
    jmp,main    " return to main&#13;
    gto,-8      " test again&#13;
 <span class="ent">➍</span> swp,mz      " Z=1, return M in Y&#13;
    tmy         " and put it in Y&#13;
    jmp,main    " and back to main&#13;
    gto,-2      " put sum in Y and return to main&#13;
}</pre>&#13;
<p class="caption" id="ch013list13"><em>Listing 13-13: The <span class="codeitalic1">sumxy</span> subprogram</em></p>&#13;
<p class="indent">When <code>sumxy</code> is called the first time, it sets its local memory to 0 and returns to <code>main</code> <span class="ent">➊</span>. Subsequent calls begin with <span class="ent">➋</span> and branch depending upon Z. At this point, X and Y contain the respective <em>x</em> and <em>y</em> values of the current point. If Z is not 0, the <code>tst</code> instruction branches forward to <span class="ent">➍</span> to move local memory, the sum of the products of <em>x</em> and <em>y</em>, to Y.</p>&#13;
<p class="indent">Note two things about the code so far. First, at <span class="ent">➋</span>, to test that Z is not 0, we have to swap memory and Z, so Z’s value is in memory, but the memory value is stashed in Z. After all, losing the sum in memory would make the <span epub:type="pagebreak" id="page_369"/>entire subprogram useless. Therefore, at <span class="ent">➍</span> the swap must happen again to restore the actual sum of the <em>xy</em> pairs and ensure that Z is also unchanged. Second, when Z ≠ 0, the subprogram is in a permanent state of simply reporting its sum in Y. That means it no longer pays attention to Z’s state. This works for our program and frees Z for other uses, if necessary. The <code>gto</code> jumping back to <code>tmy</code> makes this happen.</p>&#13;
<p class="indent">If Z is 0, the <code>tst</code> fails, and execution continues <span class="ent">➌</span>. First, Z and memory are swapped, as at <span class="ent">➍</span> to restore the sum. Then Z is used to hold the product of <em>x</em> and <em>y</em> and added to memory, thereby accumulating the product for the current point. Of course, using Z in this way changes its value, so before transferring back to <code>main</code>, we must reset Z to 0. The <code>jmp</code> to <code>main</code> is followed by a <code>gto</code> to branch back the beginning of the test on Z for the next transfer to <code>sumxy</code> from <code>main</code>.</p>&#13;
<p class="indent">The pattern set up in <code>sumxy</code> is repeated for <code>sumx</code>, <code>sumy</code>, <code>sumx2</code>, and <code>sum</code>, where the second to last accumulates <em>x</em><sup>2</sup> and the last counts the number of points processed. By controlling the state of Z, <code>main</code> moves from accumulating to calculating. The trigger to change state is reading the flag value of <code>-999999</code> for <em>x</em>.</p>&#13;
<p class="indent">The <code>main</code> subprogram of <em>linfit.filska</em> is rather long, so we’ll only examine pieces of it. <a href="ch13.xhtml#ch013list14">Listing 13-14</a> covers the first part, which initializes the sums and processes the data points.</p>&#13;
<pre>{ main&#13;
 <span class="ent">➊</span> jmp,sum&#13;
    jmp,sumx&#13;
    jmp,sumy&#13;
    jmp,sumxy&#13;
    jmp,sumx2&#13;
&#13;
    set,0           " Z=0, accumulate mode&#13;
    tmz             "&#13;
    ipt             " read X&#13;
    cmp,-999999     " data done?&#13;
    tst,e,10        " yes, calculate&#13;
    tmx             " no, move to X register&#13;
    ipt             " read Y&#13;
    tmy             " move to Y register&#13;
&#13;
 <span class="ent">➋</span> jmp,sum         " accumulate the x,y data&#13;
    jmp,sumx&#13;
    jmp,sumy&#13;
    jmp,sumxy&#13;
    jmp,sumx2&#13;
&#13;
    gto,-11         " continue the loop</pre>&#13;
<p class="caption" id="ch013list14"><em>Listing 13-14: Accumulating sums in <span class="codeitalic1">main</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_370"/>The first block of code calls each of the accumulator subprograms to initialize them <span class="ent">➊</span>. Next, the main loop starts by setting Z = 0 to put each subprogram in accumulator mode. The first <code>ipt</code> instruction reads an <em>x</em> value, checks to see if it is <code>-999999</code>, and if so, branches forward to exit the loop. The code then places <em>x</em> in the X register. The second <code>ipt</code> reads the <em>y</em> value and puts it in Y.</p>&#13;
<p class="indent">The second block of <code>jmp</code> instructions accumulates each of the totals <span class="ent">➋</span>. Lastly, the <code>gto</code> branches back to the beginning of the main loop, the first <code>ipt</code> instruction.</p>&#13;
<p class="indent">When the flag value of <code>-999999</code> is read, the input file has been processed, and execution moves to calculation mode, so it’s time for Equation 13.2. If we look at Equation 13.2, we see that both <em>a</em> and <em>b</em> depend on Δ. Therefore, we split the calculation into finding the numerators for <em>a</em> and <em>b</em> and then dividing by Δ.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch013list15">Listing 13-15</a> calculates the numerator for <em>a</em>.</p>&#13;
<pre>    set,1           " Z = 1, return sums in Y mode&#13;
    tmz&#13;
    jmp,sumx2       " Y = sumx2&#13;
    tym             " M = sumx2&#13;
    jmp,sumy        " Y = sumy&#13;
    mul,z=my        " Z = sumx2*sumy&#13;
    jmp,sumx        " Y = sumx&#13;
    tym             " M = sumx&#13;
    jmp,sumxy       " Y = sumxy&#13;
    mul,m=my        " M = sumx*sumxy&#13;
    sub,z=zm        " Z = sumx2*sumy - sumx*sumxy&#13;
    jmp,numA        " store in numA</pre>&#13;
<p class="caption" id="ch013list15"><em>Listing 13-15: Calculations in <span class="codeitalic1">main</span></em></p>&#13;
<p class="noindent">First, Z is set to 1 to cause the subprograms to return their sums in Y, and then the sequence of steps calculates what we need for <em>a</em>’s numerator in Equation 13.2. The <code>numA</code> subprogram, not shown, stores what’s in Z on the first call, returning it in Y on all future calls. A similar sequence of steps calculates the numerator for <em>b</em>, stored in <code>numB</code>, and Δ itself in <code>delta</code>. The final instructions of <code>main</code> calculate <code>numA</code> divided by <code>delta</code> and print it as <em>a</em>. Then the same is done for <em>b</em> using <code>numB</code>. The program ends with <code>hlt</code>.</p>&#13;
<h3 class="h3" id="lev1sec91"><strong>Discussion</strong></h3>&#13;
<p class="noindent">It’s clear Filska is a limited language, though useful for specific tasks. Many programming languages develop idioms, which are snippets of code that show up frequently. We developed a Filska idiom above by using a subprogram as a memory location with additional functionality, something we showed was similar to a simple class in other languages. We used this idiom as a “write once, read many” memory, with or without additional processing, or, via a flag in a register, as a read/write memory, as we did for the linear least-squares fit example.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_371"/>Filska does not support arrays, but it is possible to emulate them using subprograms as the array elements. We won’t list the code here, but do take a look at <em>array.filska</em>, an example that creates an array of 10 values. The demo stores values in the array by index and then dumps the array in order.</p>&#13;
<p class="indent">In the end, what should we make of Filska? We’ve seen it implement certain algorithms, even ones leading to useful outcomes. Is Filska Turing complete? Although it’s true that most imperative programming languages are very likely Turing complete, Filska is perhaps not because of its severe memory constraints. Three general-purpose registers and one memory location per subprogram might be the limiting factor. However, there is no limit to the number of subprograms we can define, and the array demo shows how to use that feature to emulate an array that is, in theory, as large as we would care to make it. Therefore, we might argue we do have an arbitrary amount of data available. In the end, deciding whether Filska is Turing complete is beyond what we can reasonably address in this book. Perhaps a theoretical computer scientist will take up the challenge and share their results with us. If so, check the GitHub site for the book.</p>&#13;
<h3 class="h3" id="lev1sec92"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter used Filska to implement a set of (hopefully) fun math-related examples. We got geeky and used curve fitting to produce <code>HELLO, WORLD!</code>. We explored the Fibonacci sequence, pseudorandom number generation, fractals, roots of equations, and fitting a data to a line. In each case, we needed to think carefully about the structure of our data and code to make the best use possible of Filska’s severe programming constraints.</p>&#13;
<p class="indent">Filska was designed to calculate, and all of our examples involved math in some way. Let’s relax a bit now and consider our second esolang, one designed purely for fun, and one that’s considerably simpler in every way. Let’s leave math behind, step outside, and watch the fireflies.<span epub:type="pagebreak" id="page_372"/></p>&#13;
</div></body></html>