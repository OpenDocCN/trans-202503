- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 12 BINARY TREES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12 二叉树
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: We’ve considered linear structures in previous chapters, and now we’ll start
    working with more complex structures—in particular, binary trees and some variants.
    (We’ll explore more general trees in the next chapter.) Binary trees find their
    way into lots of places, including data compression algorithms, video games, cryptographic
    techniques, compilers, and more, so they are a structure well worth knowing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中已经考虑过线性结构，现在我们将开始处理更复杂的结构——特别是二叉树及其一些变体。（我们将在下一章探讨更一般的树。）二叉树在许多地方都有应用，包括数据压缩算法、视频游戏、加密技术、编译器等，因此它们是值得了解的结构。
- en: A special variety, binary search trees, can be quite efficient for implementing
    the bags or sets we explored in the previous chapter. However, since those kinds
    of trees can, on occasion, provide not-so-good performance, we’ll also consider
    some variants, such as assuredly balanced binary search trees (AVL trees) and
    probabilistically balanced trees (randomized binary search trees and splay trees).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的变体——二叉搜索树，对于实现我们在上一章中探讨的袋（bag）或集合（set）非常高效。然而，由于这些树在某些情况下可能表现不佳，我们还将考虑一些变种，例如保证平衡的二叉搜索树（AVL
    树）和概率平衡树（随机二叉搜索树和伸展树）。
- en: '### What Are Trees?'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 什么是树？'
- en: Trees allow you to represent hierarchical data structures. They differ from
    linear structures because a node can be connected to several other nodes, albeit
    with some restrictions. Organizational charts (or *organigrams*) are well-known
    examples of trees where a section of an enterprise can have several subsections,
    which themselves may have sub-subsections, and so on, in a recursive fashion,
    such as shown [Figure 12-1](chapter12.xhtml#fig12-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 树结构允许你表示层次化的数据结构。它们与线性结构不同，因为一个节点可以连接多个其他节点，尽管存在一些限制。组织结构图（或*组织图*）是树的典型例子，其中一个企业的一个部分可以有多个子部分，这些子部分本身也可能有子子部分，依此类推，采用递归的方式，如图
    [Figure 12-1](chapter12.xhtml#fig12-1) 所示。
- en: '![](../images/Figure12-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-1.jpg)'
- en: 'Figure 12-1: An organigram from NASA, November 1961\. Don’t worry if the text
    is unreadable; the structure is the important part, not the labels. (From [https://commons.wikimedia.org/wiki/File:NASA_Organizational_Chart_November_1,_1961.jpg](https://commons.wikimedia.org/wiki/File:NASA_Organizational_Chart_November_1,_1961.jpg).)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1：来自 NASA 的组织结构图，1961 年 11 月。别担心如果文字不可读；重要的是结构部分，而不是标签。（来源：[https://commons.wikimedia.org/wiki/File:NASA_Organizational_Chart_November_1,_1961.jpg](https://commons.wikimedia.org/wiki/File:NASA_Organizational_Chart_November_1,_1961.jpg)）
- en: HyperText Markup Language (HTML) also has a treelike structure. An HTML element
    can contain several other elements, which may themselves include further elements.
    Directories on your computer employ a tree structure as well. A directory has
    files and more directories, which themselves have files and more directories,
    and so on. (See question 12.2 at the end of this chapter for an exception.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本标记语言（HTML）也具有类似树的结构。一个 HTML 元素可以包含多个其他元素，这些元素本身也可能包含进一步的元素。计算机上的目录结构也采用树形结构。一个目录下有文件和其他目录，这些目录下也有文件和更多目录，以此类推。（请参见本章末尾的第
    12.2 题，那里有个例外情况。）
- en: '#### General Trees'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 一般树'
- en: A tree can be empty or consist of a node (called the *root* of the tree) that
    has several subtrees, each of which may be empty, of course. The root is the *parent*
    of its subtrees, and the roots of those subtrees are *children* of the root. The
    *nodes* that form a tree are connected by *edges* or *arcs*. Nodes with both parents
    and children are called *internal nodes*, and nodes without children are called
    *external nodes* or (more appropriately for the tree motif) *leaves*. Given a
    node, its children, and the children of those children, and so on are called its
    *descendants*. Similarly, the parent of a node, and the parent of that parent,
    and so on are called the node’s *ancestors*. The *level* of the tree’s root is
    1, its children are level 2, the children of those children are level 3, and so
    on. The number of a node’s nonempty children is called its *degree*. Finally,
    for any tree or subtree, its *size* is the number of its nodes, and its *height*
    is the number of nodes in the longest path from the root to a leaf.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一棵树可以为空，或者由一个节点（称为树的*根*节点）组成，该节点有若干子树，每个子树当然也可以为空。根节点是其子树的*父节点*，而那些子树的根节点是根节点的*子节点*。形成树的*节点*通过*边*或*弧*连接。既有父节点也有子节点的节点被称为*内部节点*，没有子节点的节点被称为*外部节点*，或者（更符合树的概念）称为*叶子节点*。给定一个节点，它的子节点、子节点的子节点，以此类推，统称为它的*后代*。类似地，节点的父节点、父节点的父节点，以此类推，统称为节点的*祖先*。树的根节点的*层级*为
    1，它的子节点为 2 层，子节点的子节点为 3 层，依此类推。节点非空子节点的数量称为它的*度*。最后，对于任何一棵树或子树，它的*大小*是指其节点的数量，而它的*高度*是指从根节点到叶子节点的最长路径上节点的数量。
- en: NOTE
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注
- en: '*From the previous definitions, it follows that there can be at most one path
    between any two nodes; trees cannot have any cycles or loops anywhere. Another
    property is that given any two nodes, either one is an ancestor of the other or
    they both have a common ancestor.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*根据之前的定义，可以得出结论：任何两个节点之间最多只有一条路径；树中不能存在任何循环或环路。另外一个属性是：给定任意两个节点，要么一个是另一个的祖先，要么它们有一个共同的祖先。*'
- en: Trees are usually represented with the root at the top and the leaves at the
    bottom. Even if this goes against biology, we’ll follow that style. A possible
    tree could look like [Figure 12-2](chapter12.xhtml#fig12-2) (with the root at
    the top and all links going downward).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 树通常表示为根节点在上，叶子节点在下。即使这与生物学不符，我们也将遵循这种风格。一个可能的树形结构可以像[图 12-2](chapter12.xhtml#fig12-2)一样（根节点在上，所有链接向下）。
- en: '![](../images/Figure12-2.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-2.jpg)'
- en: 'Figure 12-2: Trees are usually shown with the root at the top, branching down
    to the leaves, despite what biology teaches.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：树通常是根节点在上，枝干向下分布到叶子节点，尽管生物学上并非如此。
- en: We’ll consider general trees (that is, those with any number of subtrees in
    any node) in the following chapter, so here we’ll focus on the most common version,
    binary trees.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论一般树（即每个节点可以有任意数量的子树），所以这里我们将重点讨论最常见的版本——二叉树。
- en: Binary Trees
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二叉树
- en: A *binary tree* is either empty or has exactly two subtrees. We’ll see some
    additional definitions later, so the tree in [Figure 12-2](chapter12.xhtml#fig12-2)
    actually could be a binary tree. A binary tree is *full* if every node either
    is a leaf or has two nonempty children. [Figure 12-3](chapter12.xhtml#fig12-3)
    shows a possible case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*二叉树*要么为空，要么恰好有两个子树。稍后我们会看到一些额外的定义，所以[图 12-2](chapter12.xhtml#fig12-2)中的树实际上也可以是二叉树。如果每个节点要么是叶子节点，要么有两个非空子节点，那么这棵树是*满*二叉树。[图
    12-3](chapter12.xhtml#fig12-3)展示了一个可能的情况。'
- en: '![](../images/Figure12-3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-3.jpg)'
- en: 'Figure 12-3: A full binary tree: all nodes have zero or two children.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-3：满二叉树：所有节点要么没有子节点，要么有两个子节点。
- en: Full binary trees aren’t really that interesting unless they also satisfy some
    other properties. For example, if a tree is full and all leaves are at the same
    level, it’s called a *perfect* binary tree, which implies that nodes are packed
    as tightly as possible, as shown in [Figure 12-4](chapter12.xhtml#fig12-4).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 满二叉树本身并不特别有趣，除非它还满足其他一些属性。例如，如果一棵树是满的，并且所有叶子节点都在同一层级，那么它被称为*完美*二叉树，这意味着节点尽可能紧密地排列在一起，如[图
    12-4](chapter12.xhtml#fig12-4)所示。
- en: '![](../images/Figure12-4.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-4.jpg)'
- en: 'Figure 12-4: A perfect binary tree is full and has all leaves at the same level.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-4：完美的二叉树是满的，且所有叶子节点位于同一层级。
- en: An interesting property, which a little math easily proves, is that the size
    of a perfect binary tree of *h* height is 2*^h* – 1, so adding a new level approximately
    doubles the tree’s size. Conversely, the height of a perfect tree with *n* nodes
    is log *n*, rounded up. (We are using logarithms in base 2.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的性质是，通过简单的数学证明，完美二叉树的大小为 *h* 高度的 2*^h* – 1，因此添加一个新层大约会使树的大小翻倍。反之，具有 *n*
    个节点的完美树的高度是 log *n*，向上取整。（我们使用的是以2为底的对数。）
- en: Finally, if you have a tree of *h* height that becomes perfect if you eliminate
    all nodes at level *h* (with the allowed exception of the last level), it’s called
    a *complete* tree. We’ll look at some of those structures later in [Chapter 14](chapter14.xhtml),
    when we study heaps. [Figure 12-5](chapter12.xhtml#fig12-5) shows a complete tree,
    because if you were to remove all the nodes at the bottom level, you’d be left
    with a perfect tree.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你有一个高度为 *h* 的树，在删除所有 *h* 层的节点后（最后一层可以例外），它就会变成完美的树，这种树称为 *完全树*。我们将在稍后的[第14章](chapter14.xhtml)中学习堆时，进一步探讨这些结构。[图12-5](chapter12.xhtml#fig12-5)展示了一个完全树，因为如果你删除底层的所有节点，剩下的将是一个完美的树。
- en: '![](../images/Figure12-5.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-5.jpg)'
- en: 'Figure 12-5: A complete tree would become a full tree if the bottom leaves
    were removed.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-5：如果删除底部叶子节点，一个完全树就会变成满二叉树。
- en: 'With the generic definitions out of the way, let’s get started with binary
    trees. We’ll include a key in each node, and you can add more data attributes
    if needed. We’ll also have left and right pointers to the subtrees: each may either
    be null or point to another binary tree. Let’s start writing a binary tree module
    (you’ll reuse some of these methods here for binary tree variants later):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了通用定义后，我们开始讨论二叉树。我们将在每个节点中包括一个键值，并且可以根据需要添加更多的数据属性。我们还将为左右子树设置指针：每个指针要么为空，要么指向另一个二叉树。让我们开始编写一个二叉树模块（你将会在后面的二叉树变体中重复使用一些方法）：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There’s not much to this code: newTree() ❶ builds an initially empty tree;
    newNode() ❷ creates a new node with a given key and (by default null) subtrees;
    and isEmpty() ❸ detects whether a tree is empty (no surprise here).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不复杂：newTree() ❶ 构建一个初始为空的树；newNode() ❷ 创建一个具有给定键值和（默认是空的）子树的新节点；isEmpty()
    ❸ 检测树是否为空（这没有什么好惊讶的）。
- en: Binary Search Trees
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: For the remainder of this chapter, we’ll use *binary search trees*, which are
    a variant of binary trees, to implement the *bag* or *set* abstract data type
    (ADT), because they provide very efficient searching for keys. (Remember, the
    difference is that bags allow repeated values, but sets don’t.) For these trees,
    each node will be an object with a key, plus some links to point at its children;
    in practice, you could also include an extra data field in a node for other usages.
    [Table 12-1](chapter12.xhtml#tab12-1) describes the ADT.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩下的部分，我们将使用 *二叉搜索树*，这是一种二叉树的变体，用来实现 *袋* 或 *集合* 抽象数据类型（ADT），因为它们提供了非常高效的键值查找。（记住，袋允许重复值，而集合则不允许。）对于这些树，每个节点将是一个包含键的对象，并且有一些链接指向它的子节点；实际上，你也可以在节点中包含额外的数据字段，用于其他用途。[表12-1](chapter12.xhtml#tab12-1)描述了该ADT。
- en: 'Table 12-1: Operations on Sets'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1：集合的操作
- en: '| Operation | Signature | Description |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → set | Create a new set. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → 集合 | 创建一个新的集合。 |'
- en: '| Empty? | set → boolean | Given a set, determine if it is empty. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 是否为空？ | 集合 → 布尔值 | 给定一个集合，确定它是否为空。 |'
- en: '| Add | set × value → set &#124; error | Given a new value, add it to the set.
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | 集合 × 值 → 集合 &#124; 错误 | 给定一个新值，将其添加到集合中。 |'
- en: '| Remove | set × value → set | Given a value, remove it from the set. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | 集合 × 值 → 集合 | 给定一个值，从集合中移除它。 |'
- en: '| Find | set × value → boolean | Given a value, check if it exists in the set.
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | 集合 × 值 → 布尔值 | 给定一个值，检查它是否存在于集合中。 |'
- en: 'What’s the difference between a binary tree and a binary search tree? Binary
    search trees satisfy the following property: for all nodes, the left subtree has
    only smaller keys and the right subtree has only greater keys. If you decide to
    allow duplicate keys, you need to amend the condition to say that the left subtree
    has smaller or equal keys and the right subtree has greater or equal keys. In
    [Figure 12-6](chapter12.xhtml#fig12-6), one of the trees is a binary search tree,
    but the other is not because of a single unlucky detail. Can you tell which is
    which?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树和二叉搜索树有什么区别？二叉搜索树满足以下性质：对于所有节点，左子树的键都比根节点的键小，右子树的键都比根节点的键大。如果你决定允许重复键，你需要修改这个条件，规定左子树的键小于或等于根节点的键，右子树的键大于或等于根节点的键。在[图12-6](chapter12.xhtml#fig12-6)中，其中一棵树是二叉搜索树，另一棵则不是，原因是一个不幸的细节。你能分辨出哪一棵是吗？
- en: '![](../images/Figure12-6.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-6.jpg)'
- en: 'Figure 12-6: Two binary trees, but only one is a binary search tree. Which
    is it?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-6：两棵二叉树，但只有一棵是二叉搜索树。哪一棵是？
- en: The bottom tree isn’t a binary search tree, because the 13 key is to the right
    of key 22, and it should be to its left. Can you figure out exactly where it should
    go?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的树不是二叉搜索树，因为13的键在22的右侧，而它应该在左侧。你能找出它应该放在哪里吗？
- en: This property regarding keys of roots and subtrees is what allows you to use
    binary search trees as sets.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于根节点和子树键的这个性质，使得你可以将二叉搜索树用作集合。
- en: Finding a Key in a Binary Search Tree
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在二叉搜索树中查找键
- en: 'The recursive property regarding the relation of keys (which also applies to
    every subtree) provides a simple searching method. If you are looking for a given
    value in a binary search tree, one of three situations must happen:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于键之间关系的递归性质（同样适用于每个子树）提供了一种简单的搜索方法。如果你在二叉搜索树中查找一个给定的值，必定会发生以下三种情况之一：
- en: If the value is the key at the root of the tree, you’re done.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值就是根节点的键，那你就完成了搜索。
- en: Otherwise, if the value is smaller than the key at the root, the value (if present)
    must be in the left subtree.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果值小于根节点的键，该值（如果存在）一定在左子树中。
- en: Finally, if the value is greater than the key at the root, the value must be
    in the right subtree.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果值大于根节点的键，该值一定在右子树中。
- en: You can test this. [Figure 12-7](chapter12.xhtml#fig12-7) shows a successful
    search for 12, highlighting the path that was taken and all the visited nodes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以测试这个。[图12-7](chapter12.xhtml#fig12-7)展示了成功找到12的搜索过程，突出显示了所走的路径和所有访问过的节点。
- en: '![](../images/Figure12-7.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-7.jpg)'
- en: 'Figure 12-7: A successful search for key 12 in a binary search tree'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-7：在二叉搜索树中成功找到键12的搜索过程
- en: The search starts at the root. Since 12 < 22, it moves to the left subtree.
    There, since 12 > 9, it proceeds to the right subtree. Then, as 12 > 11, it again
    goes to the right subtree, and the key is found. If you had been looking for 34
    instead, the search would have failed, as shown in [Figure 12-8](chapter12.xhtml#fig12-8).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索从根节点开始。由于12 < 22，搜索转向左子树。在那里，由于12 > 9，搜索进入右子树。接着，由于12 > 11，搜索再次进入右子树，最终找到目标值。如果你要找的是34，搜索将会失败，如[图12-8](chapter12.xhtml#fig12-8)所示。
- en: '![](../images/Figure12-8.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-8.jpg)'
- en: 'Figure 12-8: A failed search for key 34 in a binary search tree'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-8：在二叉搜索树中查找键34失败的过程
- en: Since 34 > 22, the search starts down the root’s right subtree; next, as 34
    < 56, it goes to the left. Then, as 34 > 24, it tries to go to the right but finds
    an empty tree (shown with a dotted border), so the search was unsuccessful.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于34 > 22，搜索从根节点的右子树开始；接着，因34 < 56，搜索转向左子树。然后，因34 > 24，搜索尝试进入右子树，但发现是一个空树（用虚线边框表示），因此搜索失败。
- en: 'You can code this logic straightaway, even before considering how you would
    do additions or deletions to a tree:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接编写这个逻辑代码，甚至在考虑如何进行树的插入或删除操作之前：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since trees are recursive by definition, it should be no surprise that this
    algorithm (and most others in this chapter) is implemented using recursion. There
    are two base cases: if the tree is empty ❶, the key isn’t in the tree, and if
    the key matches the value you’re looking for ❷, the search succeeds. But how do
    you keep searching? If the key you’re looking for is smaller than the key at the
    root, you recursively search the left subtree, and the right subtree otherwise
    ❸.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于树是递归定义的，因此这个算法（以及本章中的大多数算法）是通过递归实现的，这并不令人惊讶。这里有两个基本情况：如果树为空 ❶，则键不在树中；如果键与正在查找的值匹配
    ❷，搜索成功。但接下来如何继续搜索呢？如果你查找的键小于根节点的键，你就递归地搜索左子树，反之则搜索右子树 ❸。
- en: Adding Values to a Binary Search Tree
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向二叉搜索树中添加值
- en: How can we add a new key to a tree? Let’s work with a bag, and accept repeated
    keys; you’ll see how to do a set too. Be careful not to disturb the relationship
    between the root key and those of its subtrees—using a recursive algorithm is
    the best way to do this. If the tree is empty, you can simply add a new leaf to
    it. If the tree isn’t empty, apply recursion to go down the left or right subtree,
    depending on where the new key should be, until you reach an empty tree where
    you can insert the new key.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将新键添加到树中？让我们使用袋子，并接受重复键；你也会看到如何处理集合。要小心不要破坏根节点与其子树之间的关系——使用递归算法是最好的方法。如果树为空，你可以简单地添加一个新的叶子节点。如果树不为空，使用递归深入左或右子树，具体取决于新键应该位于何处，直到到达一个空树，在那里可以插入新键。
- en: The previous section showed a failed search for a 34 key, so now the new key
    would be added at the place where the search ended, as shown in [Figure 12-9](chapter12.xhtml#fig12-9).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节展示了一个失败的查找操作，目标是查找键值 34，因此现在新键值将被添加到查找结束的位置，正如在[图 12-9](chapter12.xhtml#fig12-9)所示。
- en: '![](../images/Figure12-9.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-9.jpg)'
- en: 'Figure 12-9: Adding a new key to a binary search tree at the place where it
    should have been found in a search'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-9：在二叉搜索树中将新键值添加到应该在查找中找到的位置
- en: 'The code for this is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其代码如下：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the tree is empty ❶, create a new node with the key to add, and that will
    be the root. If the tree isn’t empty, decide which of its subtrees must add the
    new key ❷ and proceed recursively from there. (If implementing a set instead of
    a bag, you should check whether keyToAdd equals tree.key, and in that case reject
    the addition; see question 12.16.) This example uses a different coding style
    from the one in find() just for variety.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树是空的 ❶，创建一个包含要添加的键的新节点，并将其作为根节点。如果树不为空，则决定哪个子树需要添加新键 ❷，然后从那里递归地进行操作。（如果实现的是集合而不是袋子，应该检查
    keyToAdd 是否等于 tree.key，如果相等则拒绝添加；见问题 12.16。）这个示例使用了一种与 find() 中不同的编码风格，主要是为了多样性。
- en: Removing Values from a Binary Search Tree
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从二叉搜索树中移除值
- en: Now let’s look at how to remove a key from a binary search tree. Consider the
    tree shown in [Figure 12-10](chapter12.xhtml#fig12-10).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何从二叉搜索树中移除一个键。考虑[图 12-10](chapter12.xhtml#fig12-10)中所示的树。
- en: '![](../images/Figure12-10.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-10.jpg)'
- en: 'Figure 12-10: A binary search tree before deleting some keys'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-10：在删除某些键之前的二叉搜索树
- en: If you try to remove a key that you can’t find in the tree, you don’t need to
    do anything. Easy.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试移除一个在树中找不到的键，你什么也不需要做。很简单。
- en: 'Another simple case is removing a leaf: just remove its key, which makes it
    an empty tree. For instance, removing 10 would result in the following situation,
    where 11 ends up with an empty left subtree, as shown in [Figure 12-11](chapter12.xhtml#fig12-11).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的情况是移除叶子节点：只需移除其键，这样它就变成了一个空树。例如，移除 10 会导致如下情况，其中 11 的左子树为空，如[图 12-11](chapter12.xhtml#fig12-11)所示。
- en: '![](../images/Figure12-11.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-11.jpg)'
- en: 'Figure 12-11: Removing a leaf (key 10, in this case) is straightforward.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-11：移除叶子节点（此处为键值 10）是直接的。
- en: However, things can get complicated. For example, if you want to remove a node
    that has at most one child, that’s still easy. Just replace it with its child,
    as in [Figure 12-12](chapter12.xhtml#fig12-12), where the 24 key was removed by
    making the 23 key the left child of the 56 key.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事情可能会变得复杂。例如，如果你想移除一个至多只有一个子节点的节点，这仍然很简单。只需将其替换为它的子节点，如[图 12-12](chapter12.xhtml#fig12-12)所示，其中
    24 键通过将 23 键设置为 56 键的左子节点被移除。
- en: '![](../images/Figure12-12.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-12.jpg)'
- en: 'Figure 12-12: Removing a key (in this case, 24) with only one child is also
    straightforward.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-12：移除一个只有一个子节点的键（此处为 24）也很简单。
- en: A complex problem is dealing with a node that has two nonempty children. The
    most common solution is to find the key immediately following it, remove it, and
    put it in place of the node you wanted to remove. For instance, if you want to
    remove the 9 key in [Figure 12-12](chapter12.xhtml#fig12-12), since that node
    has two subtrees, you would search for the next higher key (in this particular
    example, 10), remove it, and put it into the 9 key’s place, as shown in [Figure
    12-13](chapter12.xhtml#fig12-13).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的问题是处理具有两个非空子节点的节点。最常见的解决方案是找到它后面紧跟的键，移除它，并将其放入你想要移除的节点位置。例如，如果你想移除[图 12-12](chapter12.xhtml#fig12-12)中的键
    9，由于该节点有两个子树，你需要搜索下一个较大的键（在此示例中为 10），将其移除，并将其放入 9 键的位置，正如在[图 12-13](chapter12.xhtml#fig12-13)所示。
- en: '![](../images/Figure12-13.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-13.jpg)'
- en: 'Figure 12-13: Removing a key (here, 9) is the hardest case; you have to put
    another key in its place to maintain the binary search tree structure.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-13：移除一个键（这里是 9）是最困难的情况；你必须放置另一个键来替代它，以保持二叉搜索树的结构。
- en: 'This method of replacing the removed key doesn’t break the search rules. There’s
    a missing step, though—namely, how to find the next higher key. We’ll get to that
    in the next section, but first here’s the code to remove a key:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代被删除键的方法不会破坏搜索规则。不过，仍有一个缺失的步骤——也就是如何找到下一个更大的键。我们将在下一节讨论这个问题，首先是移除键的代码：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first three conditions ❶ ❷ ❸ match the find() method: check for an empty
    tree; if you haven’t found the key to delete, proceed to a subtree recursively.
    The next case ❹ deals with removing a leaf: set the tree to null. The next two
    conditions ❺ ❻ deal with nodes that have a single child; set the tree to that
    child. Finally, in the last case ❼ you must find the key ❽ that follows the one
    you want to delete and use it to replace that key and then finish by recursively
    deleting that key from the right subtree ❾. You can complete the algorithm by
    considering how to find the next higher key.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个条件 ❶ ❷ ❸ 与 find() 方法相匹配：检查树是否为空；如果没有找到要删除的键，则递归地遍历子树。接下来的情况 ❹ 处理删除叶节点：将树设置为
    null。接下来的两个条件 ❺ ❻ 处理只有一个子节点的节点；将树设置为该子节点。最后，在最后一种情况 ❼ 中，你必须找到紧随其后的键 ❽，用它替换要删除的键，然后通过递归地从右子树
    ❾ 中删除该键来完成操作。你可以通过考虑如何找到下一个更大的键来完成算法。
- en: NOTE
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*This is not the only way to do a deletion; we’ll see more in the sections
    “Removing a Key from a Randomized Tree” on [page 267](chapter12.xhtml#pg_267)
    and “Removing a Key from a Treap” on [page 336](chapter14.xhtml#pg_336).*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*这并不是唯一的删除方法；我们将在“从随机树中删除键”一节（见[第 267 页](chapter12.xhtml#pg_267)）和“从 Treap
    中删除键”一节（见[第 336 页](chapter14.xhtml#pg_336)）中看到更多的实现方式。*'
- en: Finding the Minimum or Maximum Value in a Binary Search Tree
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在二叉搜索树中查找最小值或最大值
- en: Because of the relationship between the root and its subtrees, the needed key
    (the following key) must be the minimum value of the right subtree. (Conversely,
    the previous key would be the maximum value of the left subtree.) [Figure 12-14](chapter12.xhtml#fig12-14)
    shows how to look for the key following the 9 key. You need to go to its right
    subtree and then go left until you can’t move in that direction any longer to
    find the 10 key.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于根节点与其子树之间的关系，所需的键（即下一个键）必须是右子树中的最小值。（相反，前一个键将是左子树中的最大值。）[图 12-14](chapter12.xhtml#fig12-14)展示了如何查找比
    9 更大的键。你需要去它的右子树，然后不断向左移动，直到不能再向左走，从而找到 10 这个键。
- en: '![](../images/Figure12-14.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-14.jpg)'
- en: 'Figure 12-14: Finding the following key; here, you want the minimum key greater
    than 9.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-14：查找下一个键；这里你想要找到比 9 更大的最小键。
- en: For a different example, if you wanted to find the *previous* key to 23, you
    would go to its *left* subtree and then move *right* until reaching the end to
    find the 22 key. Keep in mind that this logic works only for nodes that have the
    necessary subtrees. If you want to find the next key of, say, 11, 12, or 22, the
    logic would fail. Fortunately, this doesn’t apply to cases in which you want to
    find the next higher key.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果你想找到 23 的*前一个*键，你需要先去它的*左*子树，然后向*右*移动，直到到达末尾，找到 22 这个键。请记住，这个逻辑仅适用于具有必要子树的节点。如果你想找到
    11、12 或 22 的下一个键，逻辑将会失败。幸运的是，这种情况不适用于你想要找到下一个更大的键的情况。
- en: 'You can take advantage of similar logic to implement both minKey() and maxKey():'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用类似的逻辑来实现 minKey() 和 maxKey() 方法：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First look at minKey(), which is what you wanted in this case; maxKey() is analogous.
    You have an auxiliary _minMax() method that does the actual searching ❶ based
    on whatever arguments minKey() and maxKey() pass to it. Looking for the minimum
    requires always going to the left, so that takes care of the second parameter
    of _minMax(), which will go down that side ❹ until an empty tree is found ❸. Now,
    if you try to find the minimum of an empty tree ❷, what value should be returned?
    You’ll do the same thing the Math.min() function does; if you call it without
    any arguments, it returns Infinity (similarly Math.max() === -Infinity), so that’s
    the third parameter of _minMax().
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先查看 minKey()，这是您在此情况下需要的；maxKey() 类似。您有一个辅助的 _minMax() 方法，它根据 minKey() 和 maxKey()
    传递给它的参数进行实际搜索❶。查找最小值需要始终向左走，因此这解决了 _minMax() 的第二个参数，它将沿着这一侧一直向下 ❹，直到找到一个空树❸。现在，如果您尝试查找一个空树的最小值❷，应该返回什么值呢？您将执行
    Math.min() 函数的相同操作；如果没有传递任何参数给它，它会返回 Infinity（类似地，Math.max() === -Infinity），所以这就是
    _minMax() 的第三个参数。
- en: NOTE
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you analyze the removal algorithm, you may decide that it does more work
    than needed because it travels down the right subtree once to find the next key
    and then processes the same subtree again to remove the found key. Why not do
    both things at once? See question 12.17 for this optimization.*  ##### Traversing
    a Binary Search Tree'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您分析删除算法，您可能会发现它做的工作比需要的多，因为它会先遍历右子树找到下一个键，然后再次遍历同一个子树来删除找到的键。为什么不将两者合并一次完成呢？请参阅问题
    12.17 中的优化方法。*  ##### 遍历二叉搜索树'
- en: 'Many processes involve accessing all nodes of a tree (also called *traversing*
    a tree or doing a *tree traversal*) to do something with each—for example, you
    could have stored words in a binary search tree and want to produce an alphabetically
    ordered listing of them. This is called *visiting* the nodes. If you don’t want
    to exclude any nodes, three possible scenarios exist for such a general visitation
    (the pre-, in-, and post- prefixes in these traversal methods are related to when
    the root is visited):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 许多过程涉及访问树的所有节点（也叫做*遍历*树或进行*树遍历*），以便对每个节点执行某些操作——例如，您可能在一个二叉搜索树中存储了单词，并希望生成一个按字母顺序排列的单词列表。这就是所谓的*访问*节点。如果您不想排除任何节点，那么存在三种可能的遍历情况（这些遍历方法中的前缀
    pre-、in- 和 post- 与根节点的访问时机相关）：
- en: '**Preorder **Visit the root of a tree, then traverse its left subtree, and
    finally traverse its right subtree.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**前序遍历** 访问树的根节点，然后遍历其左子树，最后遍历右子树。'
- en: '**Inorder **Traverse the left subtree first, then visit the root, and finally
    traverse the right subtree.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**中序遍历** 先遍历左子树，然后访问根节点，最后遍历右子树。'
- en: '**Postorder **Traverse the left subtree first, then traverse the right subtree,
    and finish by visiting the root.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**后序遍历** 先遍历左子树，再遍历右子树，最后访问根节点。'
- en: Of course, you traverse an empty tree by doing nothing at all, as visiting applies
    only to existing keys. Also, note that traversal of subtrees is done by recursively
    applying the same traversal algorithm.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，遍历一个空树时什么也不做，因为访问只适用于已存在的键。同时，注意子树的遍历是通过递归地应用相同的遍历算法来完成的。
- en: 'Here’s a basic algorithm where the default visit() method just prints the visited
    key:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的算法，其中默认的 visit() 方法只是打印访问的键：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code follows the description: for example, preOrder() first visits the
    root, then traverses the left subtree, and it finally traverses the right subtree.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遵循描述：例如，preOrder()首先访问根节点，然后遍历左子树，最后遍历右子树。
- en: For debugging purposes, it’s useful to be able to print the list of the tree’s
    keys in ascending order. If you have a tree and call inOrder(), all keys are listed
    in order. It starts at the root and processes all the keys less than the root
    (listing them in order). Next, it prints the root, and then it processes all the
    keys greater than the root (also listing them in order), providing the desired
    result.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试目的，能够按升序打印树的键列表非常有用。如果您有一棵树并调用 inOrder()，所有键将按顺序列出。它从根节点开始，处理所有小于根节点的键（按顺序列出）。接下来，它打印根节点，然后处理所有大于根节点的键（也按顺序列出），从而提供所需的结果。
- en: NOTE
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*This algorithm is similar to quicksort from [Chapter 6](chapter6.xhtml). You
    have a left set of keys, which you order. Then you have the pivot, and then you
    have a right set of keys, which you also order, and the result is the complete
    ordered array.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个算法类似于 [第6章](chapter6.xhtml) 中的快速排序。你有一组左侧的键，将它们排序。然后你有一个枢轴键，然后你有一组右侧的键，也将它们排序，最终的结果就是完整的有序数组。*'
- en: Getting a list of keys is fine, but seeing the structure is better, so you want
    to get a printout of it. Consider the tree in [Figure 12-15](chapter12.xhtml#fig12-15).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 获取键的列表是可以的，但看到树的结构会更好，因此你需要获取树的打印输出。请参考 [图 12-15](chapter12.xhtml#fig12-15)
    中的树。
- en: '![](../images/Figure12-15.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-15.jpg)'
- en: 'Figure 12-15: A binary search tree for which we want to print out its structure'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-15：我们希望打印出其结构的二叉搜索树
- en: 'You could use console.log() for the printout, but that’s not too user friendly;
    console.dir()is a tad better. You could try something like console.log(JSON.stringify(tree)),
    but that’s really hard to read; you get some very unfriendly output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `console.log()` 来输出，但这并不太友好；`console.dir()` 会稍好一些。你也可以尝试类似 `console.log(JSON.stringify(tree))`
    的方式，但那样输出非常难以阅读，你会得到一些非常不友好的输出：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To understand the tree’s structure, consider a print() method based on the
    preorder code. It prints the root first, on one line, followed by its left subtree
    (with an L: preceding it to signify the left subtree), and then the right subtree
    (with an R:), indenting children to the right, and children’s children even more,
    and so forth.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '为了理解树的结构，可以考虑基于前序遍历代码的 `print()` 方法。它首先打印根节点，接着打印左子树（前面加上 L: 来表示左子树），然后是右子树（加上
    R:），并且将子节点往右缩进，子节点的子节点进一步缩进，以此类推。'
- en: 'The resulting content was similar to the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出内容大致如下：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The root (22) is at the top, followed by L: 9 (and further below, R: 60), showing
    both of the root’s children. For each new key, you also see its children, further
    indented, so it’s clear enough for debugging.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '根节点（22）在顶部，接着是 L: 9（再下面是 R: 60），显示了根节点的两个子节点。对于每个新的键，你还会看到它的子节点，且缩进更深，因此对于调试来说是足够清晰的。'
- en: 'The code to produce this output is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 产生这种输出的代码如下：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you compare the logic with the earlier preOrder() method, it’s the exact
    same idea: do something with the key first, and then process its left and right
    subtrees in order.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将逻辑与之前的 `preOrder()` 方法进行比较，会发现其基本思路相同：首先处理键，然后按顺序处理它的左子树和右子树。
- en: Considering Performance for Binary Search Trees
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考虑二叉搜索树的性能
- en: Now that we’ve looked at binary search tree algorithms in detail, what about
    their performance? Let’s start with the *worst* possible case. The most dreadful
    situation you might get after adding several keys to a tree is some kind of linear
    structure like the one shown in [Figure 12-16](chapter12.xhtml#fig12-16), which
    in searching terms basically is equivalent to simple linked lists with *O*(*n*)
    performance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细了解了二叉搜索树算法，那它们的性能如何呢？我们先从 *最坏* 情况开始。你在树中添加了几个键之后，可能遇到的最糟糕情况是某种线性结构，就像
    [图 12-16](chapter12.xhtml#fig12-16) 中所示，这种结构在搜索时基本上等同于简单的链表，时间复杂度是 *O*(*n*)。
- en: '![](../images/Figure12-16.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-16.jpg)'
- en: 'Figure 12-16: Some worst-case binary search trees'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-16：一些最坏情况下的二叉搜索树
- en: Going back to the shapes we’ve looked at earlier, it’s obvious that a tree’s
    shape impacts an algorithm’s performance. The perfect tree is best, which would
    be *O*(log *n*). With linear-like structures, searches would become *O*(*n*),
    and for large trees, that’s a huge difference.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前看到的树形结构，显然树的形状会影响算法的性能。最理想的树形结构是最好的，其时间复杂度是 *O*(log *n*)。对于类似线性结构的情况，搜索的时间复杂度会变为
    *O*(*n*)，而对于大树来说，这是一个巨大的差异。
- en: In terms of probability, if you take a set of keys in random order, it can be
    proved that most of the trees will be relatively short in height, and bad cases
    will be relatively few. While the worst case would still be *O*(*n*), on average,
    we expect *O*(log *n*) performance. [Table 12-2](chapter12.xhtml#tab12-2) shows
    average and worst-case performance for the tree.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从概率角度来看，如果你随机顺序取一组键，可以证明大多数树的高度会比较短，坏情况会相对较少。虽然最坏情况下时间复杂度仍为 *O*(*n*)，但在平均情况下，我们期望获得
    *O*(log *n*) 的性能。[表 12-2](chapter12.xhtml#tab12-2) 展示了树的平均和最坏情况性能。
- en: 'Table 12-2: Performance of Operations for Binary Search Trees'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-2：二叉搜索树操作的性能
- en: '| Operation | Average performance | Worst case |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 平均性能 | 最坏情况 |'
- en: '| --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | O(1) | O(1) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) | O(1) |'
- en: '| Add | O(log n) | O(n) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n) | O(n) |'
- en: '| Remove | O(log n) | O(n) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(log n) | O(n) |'
- en: '| Find | O(log n) | O(n) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(log n) | O(n) |'
- en: '| Traverse | O(n) | O(n) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 遍历 | O(n) | O(n) |'
- en: What can you do about that? We’ll look at two options in the following sections
    that attempt to ensure that the tree never reaches a bad shape and stays as short
    and balanced as possible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么该怎么办呢？接下来我们将探讨两个方案，旨在确保树不会变成不良形状，并保持尽可能短且平衡。
- en: Assured Balanced Binary Search Trees
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保证平衡的二叉搜索树
- en: 'As we saw earlier, a tree can become a linear (or almost linear) structure,
    and its performance will be quite poor. It’s possible to ensure that a tree is
    kept in balance, however, guaranteeing optimum performance. Here are two different
    ways of dealing with this problem:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，树可能变成线性（或几乎线性）的结构，性能会非常差。不过，确保树保持平衡是可能的，从而保证最佳的性能。这里有两种不同的处理方式：
- en: '*Assured balanced trees* become efficient because they follow some explicit
    structural constraint that never lets trees get out of shape, but they imply extra
    running time and memory usage, needing more complex algorithms—usually add() and
    remove()—to ensure that the constraints still apply after modifying the tree.
    These trees offer a consistent performance in an absolute (neither amortized nor
    probabilistic) way.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保证平衡树*之所以高效，是因为它们遵循某些明确的结构约束，这些约束确保树始终不会失衡，但这也意味着额外的运行时间和内存使用，需要更复杂的算法——通常是add()和remove()——来确保修改树之后约束仍然适用。这些树提供了在绝对意义上（一种非摊销也非概率的方式）的稳定性能。'
- en: '*Probabilistically balanced trees* (or *self-adjusting trees*) are efficient
    only in an amortized sense. They do not follow any explicit structure rule, but
    they can be in any possible shape, depending on methods like add() or find() to
    adjust the structure in such a way that it most likely improves over time.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*概率平衡树*（或*自调整树*）仅在摊销意义上是高效的。它们没有遵循任何显式的结构规则，而是可以呈现任意形态，依赖像add()或find()这样的操作来调整结构，以便随着时间的推移，最有可能获得更好的性能。'
- en: Height-balanced *AVL trees* do not let trees get out of balance by forcing both
    subtrees of any node to assuredly have approximately the same height. Weight-balanced
    trees also offer assured balance, by keeping the weights of both subtrees of any
    node within a given factor of each other; we’ll consider bounded balance (BB[α])
    trees later.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 高度平衡的*AVL树*通过强制保证每个节点的左右子树高度差不超过1，来避免树失去平衡。权重平衡树也能保证平衡，通过保持每个节点的左右子树的权重差不超过某个给定的因子；稍后我们将讨论*有界平衡*（BB[α]）树。
- en: AVL Trees
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AVL树
- en: 'AVL trees, invented by Adelson-Velsky and Landis in 1962, are well balanced
    by following a simple rule: *for all nodes, the heights of their left and right
    subtrees must differ at most by one*. This automatically rules out all the badly
    performing shapes of binary trees.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 1962年，Adelson-Velsky和Landis发明的AVL树，通过遵循一个简单的规则保持良好的平衡：*对于所有节点，左右子树的高度差最多为1*。这自动排除了所有表现不佳的二叉树形态。
- en: '[Figure 12-17](chapter12.xhtml#fig12-17) shows a correctly balanced tree and
    an unbalanced one. Which is which?'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-17](chapter12.xhtml#fig12-17)展示了一棵平衡的树和一棵不平衡的树。哪个是哪个？'
- en: '![](../images/Figure12-17.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-17.jpg)'
- en: 'Figure 12-17: Two binary trees, but only one is balanced. Which is it?'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-17：两棵二叉树，只有一棵是平衡的。是哪一棵？
- en: 'The rightmost tree is well balanced, and the leftmost tree is not, because
    the left child of the root is out of balance: its left subtree has a height of
    3, and its right subtree has a height of 1\. The balance of a node is the difference
    in heights between its right subtree and left subtree, so the balances in the
    correct tree in [Figure 12-17](chapter12.xhtml#fig12-17) would be as the one shown
    in [Figure 12-18](chapter12.xhtml#fig12-18).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最右边的树是平衡的，而最左边的树不是，因为根节点的左子树失衡：它的左子树高度为3，右子树高度为1。节点的平衡是指其左右子树高度之差，因此[图12-17](chapter12.xhtml#fig12-17)中的正确树的平衡情况，将如[图12-18](chapter12.xhtml#fig12-18)所示。
- en: '![](../images/Figure12-18.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-18.jpg)'
- en: 'Figure 12-18: The balanced binary tree showing the balances for all nodes'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-18：展示了所有节点平衡情况的平衡二叉树
- en: Now that we’ve looked at the desired shape of AVL trees, you can code them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了AVL树的期望形态，你可以开始编写它们的代码了。
- en: Defining an AVL Tree
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义AVL树
- en: 'We’ll base the AVL trees on binary search trees. Several of the operations
    will still work—for instance, finding a key in an AVL tree is exactly the same,
    so we won’t see that code again here. There’s a slight difference though: you
    need to add a _height attribute to each node to help check whether it’s in balance,
    and you need code to access or calculate that attribute. The basic code starts
    as follows—note that you are reusing some methods of basic binary search trees:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于二叉搜索树构建AVL树。许多操作仍然适用——例如，在AVL树中查找一个键与在普通二叉搜索树中的方式完全相同，所以我们在这里不会再展示该代码。不过有一个小的不同之处：你需要为每个节点添加一个*高度属性*，以帮助检查它是否平衡，并且需要编写代码来访问或计算该属性。基本的代码如下——请注意，你将重用一些基本二叉搜索树的方法：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When constructing a new node, add the new _height attribute ❶, and then have
    a _getHeight() method to access it; take care so the height of an empty tree is
    0 ❷. The new _calcHeight() method ❸ calculates the height of a node; assume both
    subtrees already have their own heights calculated, and the height of the total
    tree is one more than the height of its tallest subtree. Finally, calculate the
    balance of a node ❹ as the difference between the height of its right and left
    subtrees. That balance can be only –1, 0, or 1; other values imply an unbalanced
    tree.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造一个新节点时，添加新的_高度属性❶，然后有一个_getHeight()方法来访问它；注意，空树的高度是0❷。新的_calcHeight()方法❸计算节点的高度；假设两个子树已经计算出它们自己的高度，而整个树的高度是其最高子树的高度加一。最后，计算节点的平衡性❹，即右子树和左子树的高度差。该平衡值只能是-1、0或1；其他值意味着树不平衡。
- en: Adding a Key to an AVL Tree
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向AVL树添加一个键
- en: 'To add a new key, the logic is similar to what we already saw, except for a
    single factor: after deciding where to add the new key, the tree may become out
    of balance, so you need to move nodes around to restore it. Here’s the additional
    code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新键的逻辑与我们之前看到的类似，唯一的不同因素是：在决定添加新键的位置后，树可能会失去平衡，所以你需要移动节点来恢复平衡。以下是附加的代码：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is exactly the same code as for binary search trees, except it adds a final
    _fixBalance() call that takes care of balancing the tree if needed. Before getting
    to that part, let’s review how to remove keys, which is also quite similar to
    what you did previously.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这与二叉搜索树的代码完全相同，只是它添加了一个最终的_fixBalance()调用，用于在需要时平衡树。在进入这一部分之前，让我们回顾一下如何删除键，这与之前做的非常相似。
- en: Removing a Key from an AVL Tree
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从AVL树中删除一个键
- en: 'After seeing how to add a new key, removing a key will look familiar:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何添加新键之后，删除键会显得很熟悉：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As with adding a key, the only difference with the previous code is at the end
    where you apply the balance fix.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加一个键一样，唯一不同的是在最后应用平衡修复。
- en: Rotating Nodes in an AVL Tree
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在AVL树中旋转节点
- en: Adding or removing nodes essentially uses the same logic as for common binary
    search trees, but without intervention, the trees are likely to fall out of balance.
    The solution is to apply *rotations* that won’t affect searching but will restore
    balance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 添加或删除节点本质上与常见的二叉搜索树使用相同的逻辑，但如果不干预，树可能会失去平衡。解决方案是应用*旋转*，这些旋转不会影响搜索，但能恢复平衡。
- en: The two basic tree rotations are symmetrical, as shown in [Figure 12-19](chapter12.xhtml#fig12-19),
    where the minus sign represents a smaller key value than the plus sign. After
    any of the rotations, the tree still allows searching, but the height and balance
    may change, and this allows you to restore an AVL tree.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 两种基本的树旋转是对称的，如[图12-19](chapter12.xhtml#fig12-19)所示，其中负号表示比正号小的键值。经过任何旋转后，树仍然可以进行搜索，但高度和结构可能发生变化，这可以让你恢复一个AVL树。
- en: '![](../images/Figure12-19.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-19.jpg)'
- en: 'Figure 12-19: The two symmetrical rotations that can be used to solve balance
    issues'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-19：可以用来解决平衡问题的两种对称旋转
- en: 'Rotating from left to right is a right rotation and from right to left is a
    left rotation. To remember which rotation is which, notice the direction the old
    root moves: in a right rotation, the root becomes its own right subtree, and in
    a left rotation, the root becomes its own left subtree. Another way of looking
    at it is in a right rotation, the node that was on the left becomes the root (that
    is, it moved to the right), and the root becomes a subtree, and in a left rotation,
    the node on the right becomes the root.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右的旋转是右旋，从右到左的旋转是左旋。要记住哪个是哪个旋转，可以注意观察旧根节点的移动方向：在右旋中，根节点成为其右子树，而在左旋中，根节点成为其左子树。另一种看法是，在右旋中，原本在左边的节点成为了根节点（也就是它移动到了右边），根节点变成了一个子树，而在左旋中，原本在右边的节点成为了根节点。
- en: NOTE
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you search for more information on tree rotations, you’ll find many inconsistencies,
    and in some cases, what we call a right rotation, other sources call a left one,
    so be careful.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你搜索更多关于树旋转的信息，你会发现很多不一致的地方，在某些情况下，我们称之为右旋的旋转，其他来源却称之为左旋，所以要小心。*'
- en: 'There are two possible cases when rotations are needed: one needs a single
    rotation, and the other requires two. In the first case (shown in [Figure 12-20](chapter12.xhtml#fig12-20)),
    the tree was balanced, but a new key was added in subtree A, making it taller,
    which put the whole tree out of balance. (Alternatively, you could have removed
    a key from subtree C, making it shorter.) In this case, the problem occurs at
    the left subtree of the left child of the root or, symmetrically, at the right
    subtree of the right child. These situations are logically called *left-left*
    and *right-right*.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行旋转时有两种可能情况：一种需要单次旋转，另一种需要两次旋转。在第一种情况（如[图12-20](chapter12.xhtml#fig12-20)所示），树是平衡的，但在子树A中添加了一个新键，使其变得更高，从而导致整个树失去平衡。（或者，您也可以从子树C中删除一个键，使其变短。）在这种情况下，问题出现在根节点的左子节点的左子树，或者对称地，出现在右子节点的右子树。这些情况在逻辑上被称为*左-左*和*右-右*。
- en: '![](../images/Figure12-20.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-20.jpg)'
- en: 'Figure 12-20: Using a right rotation to fix the unbalanced node with key 60'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-20：使用右旋转修复键值为60的失衡节点
- en: The solution is to apply a right rotation to the root of the left subtree (because
    the imbalance happened at the left subtree), which results in a balanced situation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是对左子树的根节点应用右旋转（因为失衡发生在左子树上），从而使树恢复平衡。
- en: '[Figure 12-21](chapter12.xhtml#fig12-21) shows a more complex scenario. A new
    key was added at the right subtree of the left subtree of the root, throwing the
    latter out of balance. This *left-right* case and its mirrored *right-left* case
    need two rotations to be fixed.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-21](chapter12.xhtml#fig12-21)展示了一个更复杂的场景。一个新键被添加到根节点的左子树的右子树中，使得后者失去平衡。这个*左-右*情况及其镜像的*右-左*情况需要两次旋转才能修复。'
- en: '![](../images/Figure12-21.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-21.jpg)'
- en: 'Figure 12-21: Fixing balance in a harder case needs a left rotation first (at
    the 9 key node) and then a right rotation (at the 60 key node).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-21：修复更复杂的失衡情况需要首先进行左旋转（在9键节点处），然后进行右旋转（在60键节点处）。
- en: A first left rotation brings the lowest key (22, in this case) closer to the
    root, and now a right rotation takes it all the way up, restoring balance. [Figure
    12-21](chapter12.xhtml#fig12-21) shows the scenario where the addition was in
    B; if it had been in C, the solution still would be the same, and it would also
    apply if instead of an addition, you had removed a key from D, making it shorter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次左旋转将最低的键（在此情况下为22）移动到根节点附近，现在右旋转将它完全提升到根节点，恢复平衡。[图12-21](chapter12.xhtml#fig12-21)展示了添加操作发生在B的场景；如果它发生在C中，解决方案仍然相同，如果不是添加，而是从D中删除了一个键使其变短，情况也一样。
- en: 'Now consider the code to rotate a node:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑旋转一个节点的代码：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You start by finding the “other” side for the rotation ❶, and you also get a
    reference to the node on the side of the root ❷ (the one that will become the
    root of the tree) to make the code briefer. Then, you exchange some pointers ❸
    and finish by recalculating the heights of the two involved nodes; it’s important
    to do the “lower” node ❹ first.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先找到旋转的“另一侧” ❶，并获取根节点一侧的节点的引用 ❷（将成为树的新根节点）以简化代码。然后，交换一些指针 ❸，最后重新计算这两个节点的高度；重要的是先处理“较低”的节点
    ❹。
- en: NOTE
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you call* _rotate() *with a* left *parameter, it actually does a right
    rotation, which may be a bit confusing. The idea is you’re saying which node should
    become root. So for a right rotation, the left child moves up to be the root.
    In some algorithms, you’ll see that this is more natural.*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你调用* _rotate() *并传入一个* left *参数，它实际上会执行右旋转，这可能有点令人困惑。其思想是你在指定哪个节点应该成为根节点。因此，对于右旋转，左子节点上升成为根节点。在某些算法中，你会发现这样做更自然。*'
- en: 'Now, let’s finish by providing the missing _fixBalance() method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过提供缺失的_fixBalance()方法来完成：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the tree is empty ❶, there’s nothing to do. Otherwise, recalculate the root’s
    height ❷ (since the recent addition or removal may have changed it), and also
    find the node’s balance ❸. If the node is imbalanced on the left ❹, check whether
    an extra rotation is needed ❺ and do it if necessary, ending with a single rotation
    ❻. The other if is just the symmetrical case ❼, and it does the same things, but
    the sides are reversed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树为空 ❶，则无需任何操作。否则，重新计算根节点的高度 ❷（因为最近的添加或删除可能已改变它），并且还要找到节点的平衡 ❸。如果节点在左侧不平衡 ❹，检查是否需要额外的旋转
    ❺，并在必要时进行旋转，最终进行单次旋转 ❻。另一个 if 只是对称的情况 ❼，它执行相同的操作，但左右两侧交换。
- en: Considering Performance for AVL Trees
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考虑AVL树的性能
- en: Given the assured balance that the structure of AVL trees provides, all the
    operations (adding, removing, finding) have the same logarithmic performance.
    There’s no different worst case, as shown in [Table 12-3](chapter12.xhtml#tab12-3).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于 AVL 树结构提供的确保平衡的特性，所有操作（添加、删除、查找）都具有相同的对数性能。没有不同的最坏情况，如 [表 12-3](chapter12.xhtml#tab12-3)
    所示。
- en: 'Table 12-3: Performance of Operations for AVL Trees'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-3：AVL 树操作性能
- en: '| Operation | Average performance | Worst case |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 平均性能 | 最坏情况 |'
- en: '| --- | --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | O(1) | O(1) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) | O(1) |'
- en: '| Add | O(log n) | O(log n) |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n) | O(log n) |'
- en: '| Remove | O(log n) | O(log n) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(log n) | O(log n) |'
- en: '| Find | O(log n) | O(log n) |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(log n) | O(log n) |'
- en: '| Traverse | O(n) | O(n) |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 遍历 | O(n) | O(n) |'
- en: It can be proved that the height of an AVL tree is bounded by 1.44 log *n*,
    and that also confirms the performance listed earlier (see question 12.18). In
    the next chapter, you’ll look at *red-black trees*, which have similar restrictions
    and performance but are based on multiway trees. Searches may be a tad slower
    (because those trees may be taller) and insertions a bit faster (requiring fewer
    rotations), but overall, the results are the same.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可以证明，AVL 树的高度被 1.44 log *n* 所限制，这也确认了之前列出的性能（见问题 12.18）。在下一章中，你将学习 *红黑树*，它们有类似的限制和性能，但基于多路树。搜索可能稍微慢一点（因为这些树可能更高），插入则稍微快一点（因为需要的旋转更少），但总体结果是相同的。
- en: Weight-Bounded Balanced Trees
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 权重约束平衡树
- en: 'Instead of making sure that the heights of both subtrees of any node are within
    1 of each other, *weight-bounded balanced (BB[α])* trees maintain a different
    invariant: that the *weights* (size of the tree plus 1) in the left and right
    subtrees are in a specific relationship. If a tree has size *n* and its subtrees
    have sizes *p* and *q*, you then have (*p* + 1) ≥ α(*n* + 1) and (*q* + 1) ≥ α(*n*
    + 1), with 0 < α < 0.5.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与确保任何节点的两个子树高度相差不超过 1 不同，*权重约束平衡（BB[α]）* 树维持着一个不同的不变量：即左右子树的*权重*（树的大小加 1）有一个特定的关系。如果一棵树的大小为
    *n*，其左右子树的大小分别为 *p* 和 *q*，那么就有 (*p* + 1) ≥ α(*n* + 1) 和 (*q* + 1) ≥ α(*n* + 1)，其中
    0 < α < 0.5。
- en: An equivalent way of looking at this is requiring that (*p* + 1) / (*n* + 1)
    ≥ α and (*q* + 1) / (*n* + 1) ≥ α. Since both fractions add up to 1 (see question
    12.20), this is the same as saying that both subtrees must satisfy α ≤ weight(subtree)
    / weight(tree) ≤ 1 – α. The quotient in the middle is called the *balance* of
    the subtree. [Figure 12-22](chapter12.xhtml#fig12-22) shows a BB[0.29289] tree
    where keys from 1 to 12 were inserted in ascending order; the numbers on the edges
    show the balance of the corresponding subtree.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种等效的方式是要求 (*p* + 1) / (*n* + 1) ≥ α 和 (*q* + 1) / (*n* + 1) ≥ α。由于这两个分数加起来等于
    1（见问题 12.20），这相当于说两个子树必须满足 α ≤ weight(子树) / weight(树) ≤ 1 – α。中间的商称为子树的*平衡*。[图
    12-22](chapter12.xhtml#fig12-22) 显示了一棵 BB[0.29289] 树，其中从 1 到 12 的键按升序插入；边缘上的数字表示相应子树的平衡。
- en: '![](../images/Figure12-22.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-22.jpg)'
- en: 'Figure 12-22: A weight-bounded balanced tree (BB[0.29289] in this case) showing
    the calculated balance for every node with children'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-22：一棵权重约束平衡树（此处为 BB[0.29289]），显示了每个有子节点的节点的计算平衡
- en: The value α = 0.5 sounds like a perfect balance (for all nodes, the right and
    left subtrees would be of equal sizes), but it has been proven that it doesn’t
    really work, and not every value of α does. The α should be between 0.18182 (=
    2/11) and 0.29289 (= 1 – √2/2) for balancing to work.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: α = 0.5 的值看起来像是一个完美的平衡（对于所有节点，左右子树的大小将相等），但已证明它并不适用，并不是所有的 α 值都有效。为了实现平衡，α 应该在
    0.18182 (= 2/11) 和 0.29289 (= 1 – √2/2) 之间。
- en: NOTE
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*When we defined the weight of a node and added 1 to its size, if it weren’t
    for that additional 1, it would be impossible to have a weight-balanced tree of
    just two nodes. Can you see why?*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我们定义一个节点的权重并将其大小加 1 时，如果没有那额外的 1，就无法构建只有两个节点的权重平衡树。你能看出为什么吗？*'
- en: A BB[α] tree needs to carry the extra data of its size in every node in order
    to calculate its weight. This is necessary for balancing (so you can check the
    balance condition given previously), but it’s also useful for other operations,
    such as finding a key by its rank.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: BB[α] 树需要在每个节点中携带额外的大小数据，以便计算其权重。这对于平衡是必要的（以便你可以检查之前给出的平衡条件），但它对其他操作也很有用，比如通过秩查找键。
- en: When adding to or removing keys from the tree, if balance is not kept, we apply
    rotations (as in AVL trees) to restore balance. Since BB[α] trees are binary search
    trees, the find operation and traversals work without any changes. You need to
    consider only additions and removals.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在向树中添加或删除键时，如果没有保持平衡，我们会应用旋转（如同在 AVL 树中那样）来恢复平衡。由于 BB[α] 树是二叉搜索树，查找操作和遍历操作不需要任何修改。你只需要考虑添加和删除操作。
- en: Defining a Weight-Bounded Balanced Tree
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义加权平衡树
- en: 'These new trees and AVL trees share a lot of code. The biggest difference is
    that instead of including the height of a tree in each node, we include a size
    attribute and fix the balance by considering sizes instead of heights:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新树与 AVL 树共享大量的代码。最大的区别是，我们不再在每个节点中包含树的高度，而是包含一个大小属性，并通过考虑大小而不是高度来修复平衡：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When creating a new node, set its size to 1 ❶ instead of a height attribute.
    And instead of functions related to getting or calculating heights, you have a
    function as a getter for the tree’s previously calculated size ❷, another function
    to calculate the size of any tree ❸, and a third one to calculate the balance
    of a subtree ❹, which you’ll need for balance fixing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新节点时，将其大小设置为 1 ❶，而不是设置为高度属性。并且你将不再使用与获取或计算高度相关的函数，而是有一个函数用于获取树的已计算大小 ❷，另一个函数用于计算任何树的大小
    ❸，以及第三个用于计算子树平衡度 ❹，这些都是你修复平衡时所需要的。
- en: Adding and Removing Keys to and from a Weight-Bounded Balanced Tree
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向加权平衡树添加和删除键
- en: 'I mentioned there would be a surprise, and it’s that adding or removing keys
    is done in exactly the same way as for AVL trees. Look at the code from the previous
    section. When adding a new key, you did it in the standard way (that is, the same
    way as for binary search trees), and you finished by calling a function to fix
    the balance, if needed. The only difference here is that the latter function will
    be implemented in another way:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过会有一个惊喜，那就是添加或删除键的方式与 AVL 树完全相同。请看前面部分的代码。添加新键时，你是以标准方式进行的（即，与二叉搜索树相同），并且在最后通过调用一个函数来修复平衡（如果需要）。这里唯一的不同之处是，后者的函数将以另一种方式实现：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deleting a key worked the same way. You first applied the standard binary search
    tree algorithm and, at the end, called the same function as with additions to
    restore balance whenever required.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 删除键的过程与添加键相同。你首先应用标准的二叉搜索树算法，并且在结束时，像添加操作一样调用相同的函数，在需要时恢复平衡。
- en: You’ll see the exact same process here; the only difference is how you restore
    balance.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到完全相同的过程；唯一的区别是你恢复平衡的方式。
- en: Fixing Balance in a Weight-Bounded Balanced Tree
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修复加权平衡树的平衡
- en: The original paper that described BB[α] trees shows (with math that’s not included
    here) that there are two possible cases (plus their symmetrical ones) and that
    simple or double rotations are enough to restore balance. Now consider cases where
    a node has an overweight left subtree; the symmetrical cases are handled the same
    way.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 BB[α] 树的原始论文（这里没有包含数学推导）显示，有两种可能的情况（以及它们的对称情况），并且简单或双重旋转足以恢复平衡。现在考虑一个节点具有超重的左子树的情况；对称情况将以相同的方式处理。
- en: 'First, a review of some conditions. The balance of a subtree should be α ≤
    balance(subtree) ≤ 1 – α. Several constants will be used when balancing, but we
    won’t derive the values here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回顾一些条件。子树的平衡应该满足 α ≤ balance(subtree) ≤ 1 – α。当平衡时，会使用一些常量，但我们在这里不推导这些值：
- en: α is the underweight limit; if a subtree’s balance is below α, the tree is out
    of balance.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: α 是低重心限制；如果子树的平衡度低于 α，则树处于不平衡状态。
- en: β = 1 – α is the overweight limit; if a subtree’s balance is above β, there’s
    also an imbalance.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: β = 1 – α 是超重限制；如果子树的平衡度高于 β，树也会不平衡。
- en: γ = α/β = α / (1 – α) is the underweight limit for a subtree’s child.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: γ = α/β = α / (1 – α) 是子树孩子的低重心限制。
- en: δ = 1 – γ = (1 – 2α) / (1– α) is the overweight limit for a subtree’s child.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: δ = 1 – γ = (1 – 2α) / (1 – α) 是子树孩子的超重限制。
- en: 'The following code defines the values (the comments show the approximate value
    of each constant):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了各个值（注释中显示了每个常量的大致值）：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, you will fix unbalanced trees. The first situation is shown in [Figure
    12-23](chapter12.xhtml#fig12-23). The left subtree has grown too much (or the
    right subtree has decreased in size), so the tree is not in balance. You can calculate
    the balance of the right subtree of the left subtree (B) and find it is below
    δ, so it’s not overweight. In this case, a single rotation to the right (shoving
    the B subtree to the right, which must have been underweight) rebalances the tree.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将修复不平衡的树。第一个情况如图[12-23](chapter12.xhtml#fig12-23)所示。左子树过大（或者右子树的大小减少），导致树不平衡。你可以计算左子树右子树的平衡因子（B），发现它低于δ，因此并没有超重。在这种情况下，通过单次右旋（将B子树移至右侧，而B子树本来就应为轻的）即可重新平衡树。
- en: '![](../images/Figure12-23.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-23.jpg)'
- en: 'Figure 12-23: A single rotation fixes balance issues in some cases.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-23：在某些情况下，单次旋转可以修复平衡问题。
- en: The second situation is a bit more complex. The left subtree is overweight,
    and the balance of its left subtree’s right subtree exceeds the δ value. A single
    rotation wouldn’t be enough to restore balance (the tree would still be out of
    balance), and in this case, a double rotation is needed to bring everything back
    to normal. Note that part of the overweight subtree is sent to the right (C),
    and the other part (B) remains on the left, as shown in [Figure 12-24](chapter12.xhtml#fig12-24).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况稍微复杂一点。左子树超重，而且左子树的右子树的平衡因子超过了δ值。单次旋转不足以恢复平衡（树仍然不平衡），在这种情况下，需要进行双次旋转才能将一切恢复正常。注意，超重子树的一部分被移至右侧（C），另一部分（B）则保留在左侧，如图[12-24](chapter12.xhtml#fig12-24)所示。
- en: '![](../images/Figure12-24.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-24.jpg)'
- en: 'Figure 12-24: Two rotations are needed to fix balance in more complex situations.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-24：在更复杂的情况下，需要两次旋转来修复平衡。
- en: 'So, the logic for deciding whether rotations are needed (and which) is this:
    first check both children to see if either is overweight (say it’s the left one)
    by comparing its balance to β. Then check whether the other side’s grandchild
    (the right child of the left child) is overweight, but compare its balance to
    a different limit of δ. Depending on the result of the second check, you’ll do
    one or two rotations:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，判断是否需要旋转（以及旋转类型）的逻辑如下：首先检查两个孩子，看是否有一个超重（假设是左孩子），通过比较其平衡因子与β。如果是，接着检查另一侧的孙子节点（左孩子的右孩子），但要与不同的δ限制进行比较。根据第二次检查的结果，你将执行一次或两次旋转：
- en: '[PRE17]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the tree isn’t empty, start by updating its size ❶. Then, first check whether
    the left child is overweight ❷; if so, do a second check for the right child of
    the left child ❸, and if that tree is also overweight, do the first of two rotations
    ❹; then do the rotation to the right ❺ that will finish the job. If the left child
    wasn’t overweight, check the right child ❻, and the logic is symmetric to the
    cases noted earlier ❹ ❺.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树不为空，首先更新其大小 ❶。然后，首先检查左孩子是否超重 ❷；如果是，接着检查左孩子的右孩子 ❸，如果该树也超重，则进行第一次旋转 ❹；接着执行右旋
    ❺，完成任务。如果左孩子没有超重，则检查右孩子 ❻，逻辑与之前提到的情况对称 ❹ ❺。
- en: 'You now know how to update the tree by adding or removing keys, but BB[α] trees
    allow other operations as well, including finding by rank, splitting a tree in
    two, or joining two trees into one.  ##### Finding an Element by Rank in a Weight-Bounded
    Balanced Tree'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何通过添加或删除键来更新树，但BB[α]树还支持其他操作，包括通过秩查找、将树分裂成两棵树，或将两棵树合并成一棵。##### 在带权重约束的平衡树中按秩查找元素
- en: 'As mentioned previously, having the size of each tree at its root, which is
    needed by BB[α] trees for balancing purposes, provides an extra benefit, because
    it allows further operations with good performance. Consider one here: finding
    an element (in this case, the seventh) by rank, as you saw in [Chapter 11](chapter11.xhtml).
    The tree in [Figure 12-25](chapter12.xhtml#fig12-25) is the same as [Figure 12-22](chapter12.xhtml#fig12-22),
    but now the subtrees’ sizes are shown next to each node.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，BB[α]树为了平衡目的需要在每棵树的根节点上保存其大小，这不仅能提供额外的好处，还能支持更高效的操作。例如：通过秩查找一个元素（在此情况下是第七个元素），就像在[第11章](chapter11.xhtml)中所看到的那样。图[12-25](chapter12.xhtml#fig12-25)中的树与图[12-22](chapter12.xhtml#fig12-22)相同，但现在每个节点旁边显示了子树的大小。
- en: '![](../images/Figure12-25.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-25.jpg)'
- en: 'Figure 12-25: Including the size of each subtree at its root allows you to
    find an element by rank in an efficient way; here you’re looking for the seventh
    key.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-25：在每个子树根节点处包含其大小，可以高效地按秩查找元素；这里你正在查找第七个键。
- en: 'The left subtree has three elements, so if you were looking for the fourth
    element, that would be the root itself, and you’d be done! In this case, however,
    you are looking for the seventh element, so you need to keep searching. First,
    decide whether to go left or right: the left subtree has only three elements,
    so the seventh element must be the third element in the right subtree. You need
    to discount the three elements of the left subtree and also the root, so that
    removes four from the count, and you move right.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Now you are at the 8 key root, which has size 8\. Its left subtree has three
    elements, and as you are looking for the third element of that tree, you keep
    going down to the left. At the 6 key root, repeat the procedure, and this time
    go right, as you need to discount one element from the left subtree and one from
    the root, so now you want the first element of the right subtree. Then you arrive
    at the 7 key, which is what you wanted.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily implement this search with recursion:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, dismiss all the cases in which the search will fail ❶: an empty tree
    or asking for a rank outside the size of the tree. If the rank you want isn’t
    greater than the size of the left subtree ❷, continue the search there. Otherwise,
    if the rank you want is exactly one more than the left subtree’s size ❸, the root
    is the answer, and you are done. Finally, if none of the preceding conditions
    hold, go right, and you have to discount the left subtree’s size and the root
    to continue the search ❹.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Weight-Balanced Binary Trees
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As in the case of AVL trees, ensuring balance in BB[α] trees makes for constant
    performance, with no worst cases. For all operations (adding, removing, and finding),
    the total cost is logarithmic, so weight-balanced binary trees ensure good performance,
    as shown in [Table 12-4](chapter12.xhtml#tab12-4).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-4: Performance of Operations for Weight-Balanced Binary Trees'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Average performance | Worst case |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) | O(1) |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| Add | O(log n) | O(log n) |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n) | O(log n) |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| Find | O(log n) | O(log n) |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| Find by rank | O(log n) | O(log n) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| Traverse | O(n) | O(n) |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: Also in comparison with AVL trees, the code isn’t very complex, and in both
    cases, you just depend on a “balance fix” function to be used after additions
    or removals.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Probabilistic Balance Binary Search Trees
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assured balance trees make operations more complex to ensure that a well-balanced
    shape will be kept at all times and thus provide a constant performance for operations.
    The other approach, *probabilistic balanced* trees, are simpler in implementation,
    require no extra memory usage, and can be as efficient (in an amortized sense)
    as assured balance trees—but you have to cope with the possible disadvantage of
    some individual slow operations mixed in with a long series of fast ones.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'So, these trees do not ensure balance, but rather, they promise it in a probabilistic
    sense, and unless you are really unlucky, they will perform quite well. In this
    chapter, we’ll consider two versions of these trees: *randomized* *binary search
    trees*, which apply balancing operations in a random manner, and *splay trees*,
    which restructure trees to make future searches faster. In [Chapter 14](chapter14.xhtml)
    we’ll consider one more option: treaps*.*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些树并不保证平衡，而是以概率的方式保证平衡，除非你非常不幸运，它们的表现会非常好。在本章中，我们将考虑这两种树的版本：*随机化* *二叉搜索树*，它以随机的方式应用平衡操作，以及*伸展树*，它通过重构树来加速未来的搜索。在[第14章](chapter14.xhtml)中，我们还会考虑另一种选择：treaps*。
- en: Randomized Binary Search Trees
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随机化二叉搜索树
- en: Balanced trees guarantee performance by enforcing some constraints. This is
    an advantage in terms of performance, but it adds an extra level of complexity
    for operations, plus the need for some bookkeeping information at each node to
    determine whether restructuring is needed. Another way to avoid bad cases is to
    use randomized algorithms that provide a guarantee of their *expected* performance
    in terms of probability for any kind of input data. Depending on the implementation
    (and also on your particular data), a randomized algorithm may be faster than
    the corresponding assured balanced version, and it may be better for your needs.
    For instance, if you add keys in ascending order, balanced trees will have to
    do frequent balancing operations; if the algorithm works with random-based decisions
    at some points, fewer balancing operations may be needed; we’ll see this more
    clearly later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡树通过强制执行一些约束来保证性能。这在性能上是一个优势，但它为操作增加了额外的复杂性，而且每个节点还需要一些书籍管理信息来判断是否需要重构。避免坏情况的另一种方法是使用随机化算法，它能保证对于任何类型的输入数据，在概率上提供*期望*的性能。根据实现方式（以及你的特定数据），随机化算法可能比相应的平衡版本更快，且可能更适合你的需求。例如，如果你按升序添加键，平衡树将不得不频繁执行平衡操作；如果算法在某些点上做出基于随机决策的操作，可能会需要更少的平衡操作；稍后我们会更清楚地看到这一点。
- en: The first such structure we’ll look at uses random numbers to decide whether
    a new addition should be at the root of the tree or go in its usual place. The
    insertion and deletion algorithms randomly decide how to either add a key to or
    remove a key from the tree. Both procedures produce a random structure, as if
    the input values had been shuffled, as you saw in [Chapter 10](chapter10.xhtml).
    Remember, we won’t need to reconsider how to find a key since we are still dealing
    with binary search trees and the earlier search logic still applies.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个这种结构使用随机数来决定新插入的元素是应该放在树的根节点，还是放在它的常规位置。插入和删除算法通过随机决定是将一个键添加到树中，还是将一个键从树中移除。这两个过程都会生成一个随机结构，就像你在[第10章](chapter10.xhtml)中看到的那样，输入值被随机打乱。记住，我们不需要重新考虑如何查找一个键，因为我们仍然在处理二叉搜索树，之前的搜索逻辑依然适用。
- en: Defining the Randomized Binary Search Tree
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义随机化二叉搜索树
- en: 'Randomized trees will have the same structure as BB[α] trees, including a size
    attribute, but instead of using it for rebalancing the tree, we’ll use it to help
    determine randomly what action to take. The basic code is as follows, and again
    we’ll be reusing some code from standard binary search trees:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化树的结构将与BB[α]树相同，包括一个大小属性，但我们将不再使用它来重新平衡树，而是用它来帮助随机决定采取什么操作。基本代码如下，我们将再次重用一些来自标准二叉搜索树的代码：
- en: '[PRE19]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is exactly the same way the BB[α] code started, except here the newNode()
    method lets you provide initial values for the left and right pointers, otherwise
    setting them to null.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这与BB[α]代码的开始方式完全相同，只是这里的newNode()方法允许你为左右指针提供初始值，否则将其设置为null。
- en: NOTE
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Having a* size *attribute means that you’ll also be able to find an element
    by rank quickly, as in BB[α] trees.*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*拥有一个*大小*属性意味着你也能像在BB[α]树中那样快速按排名查找元素。*'
- en: Adding a Key to a Randomized Binary Search Tree
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向随机化二叉搜索树添加一个键
- en: In a standard binary search tree, if you start adding keys to an initially empty
    tree, the first key you add becomes its root, and it will stay there unless you
    remove it. This next algorithm acts differently. Each time a key is added, it
    randomly decides whether it should go at the root or be added as a leaf, wherever
    that may be, similar to the sampling algorithms described previously. This method
    ensures that *any* key can be the root, so the order in which you do additions
    won’t matter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'If the algorithm chooses to place the new key at the root, it splits the tree
    into two subtrees: one with all keys smaller than the future new root and the
    other with keys greater than it. Otherwise, if the algorithm didn’t opt for placing
    the new key as root, a common insertion logic is applied. Take a look at the basic
    algorithm first; the details will be filled in later:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the tree is empty ❶, set the key at the root with empty subtrees and calculate
    its size before returning. Since you are moving nodes around, you’ll have to recalculate
    sizes. Just like the sampling algorithm from [Chapter 10](chapter10.xhtml), you
    may decide that the new value has to go at the root ❷. In that case, use an auxiliary
    algorithm to split the tree in two parts ❸: the key that’s being added becomes
    the root, and the two split trees become its subtrees ❹.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, if the random test fails, apply the algorithm you know well
    from binary search trees ❺. (Remember that to implement a set instead of a bag,
    you check if keyToAdd equals tree.key and reject the new key if so.) Note, however,
    that in each recursive step, you’re also using random numbers to decide whether
    to split the current tree, so randomness applies not only to the tree’s root but
    also throughout the structure. The last step of add() is to calculate the size
    of the root ❻, which is done no matter what happens in the earlier steps.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Consider a sample case of this algorithm before dealing with the missing splitting
    code. Suppose you want to add a key of 20 to the tree shown in [Figure 12-26](chapter12.xhtml#fig12-26).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-26.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-26: A binary search tree before adding a key of 20'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Before comparing 20 to 23, generate a random number. Because the tree’s size
    is 9, it’s a probability of one in nine that the algorithm will split the tree
    and set 20 at its root, and in eight out of nine cases, the root will still be
    23\. Otherwise, you keep working in the usual fashion to add a key in a binary
    search tree.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the test passes. Split the tree in two parts and set them as subtrees
    for 20, which becomes the new root, as shown in [Figure 12-27](chapter12.xhtml#fig12-27).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-27.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-27: If a random test succeeds, the new key becomes the root of the
    tree.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Now, assume the test fails. Leave the original root in place and move to its
    left to compare 20 to 9\. This time, since the size of the current tree is 5,
    the random test has a one in five probability of success. If the test succeeds
    this time, 20 goes in place of 9, splitting the tree rooted at 9 and doing the
    same kind of job as before.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'A third possibility is if the random test fails the first two times. In that
    case, compare 20 with 12 and do another random test, now with one in three odds,
    because the original tree rooted at 12 has three nodes. And if that test fails,
    you still try again, with one in two odds, before comparing 20 to 22\. If and
    *only if* every random test fails, you end by placing 20 exactly where you would
    place it in a normal binary search tree: in this case, to the left of the 22 key.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the Randomized Binary Search Tree
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The splitting algorithm is reminiscent of the pivoting part of quicksort from
    [Chapter 6](chapter6.xhtml). You have a “pivot” key and want to split the structure
    into two trees, so all keys in the first tree are smaller than the pivot and all
    keys in the second are greater than it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Start with the same tree we used before and see how splitting would work with
    regard to a 20 key, as shown in [Figure 12-28](chapter12.xhtml#fig12-28).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-28.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-28: The same tree as shown in [Figure 12-26](chapter12.xhtml#fig12-26)
    before splitting it in two with regard to the 20 value'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'First set up two empty trees: one has values less than 20, and the other has
    values greater than 20\. Both start empty. The first step compares 20 with 23\.
    Since 23 is greater, that root and its right subtree go into the tree with greater
    values. Also, you need to “remember” the left subtree of 23 (now empty), because
    future values greater than 20 but less than 23 will go there. The two split trees
    (the one with lesser values, currently empty) would look like the ones shown in
    [Figure 12-29](chapter12.xhtml#fig12-29), and you’d go on to process the subtree
    rooted at 9.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-29.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-29: The first step: 23 is greater than 20, so part of the tree goes
    to the right. The dotted circles show where new subtrees will be added.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Now you have 20, which is greater than 9, so 9 and its left subtree go into
    the “smaller” tree, and you remember the right subtree of 9, which is where any
    future values greater than 9 but less than 20 will go. The split trees now look
    like the ones in [Figure 12-30](chapter12.xhtml#fig12-30), and you can move on
    to the 12 key.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-30.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-30: The second step: 9 is less than 20, so part of the tree goes
    to the left.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the same situation: 20 is greater than 12, so connect 12 and its left
    subtree to the remembered right subtree of the smaller tree, getting the scenario
    shown in [Figure 12-31](chapter12.xhtml#fig12-31). Now remember the right subtree
    of 12 as the possible place to add more values.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-31.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-31: The third step: 12 is less than 20, so add to the left tree.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re almost finished: 20 is less than 22, so 22 (and its right subtree, if
    it has one) goes to the remembered place in the “greater” tree, as shown in [Figure
    12-32](chapter12.xhtml#fig12-32).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-32.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-32: The fourth step: 22 is greater than 20, so add to the right tree.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Since there are no more nodes to process, finish by setting the final tree’s
    root to 20, with the “smaller” and “greater” trees as subtrees. The result, shown
    in [Figure 12-33](chapter12.xhtml#fig12-33) is what you saw earlier.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-33.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-33: The fifth step: the tree was split, and now you set 20 at its
    root.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Now examine the code, which has the tricky issue of how to remember places
    in split trees:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First create two trees, newTrees, as you split the original tree. When you are
    done with the tree ❶, just return that pair. Otherwise ❷, decide which side to
    split ❸ and join the split part to the correct new tree; you also have to remember
    where the next joining will be done ❹ before proceeding recursively down the tree
    ❺. Finish by calculating the tree size ❻, because you need it for your random
    tests.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Randomized Tree
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The algorithm for removing a key is almost the same as before, but with one
    main difference: what to do if the key to be removed has two children. Here’s
    the basic code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The algorithm is pretty standard, and you have seen this code several times
    now with some small exceptions. When you remove a key from a subtree, you need
    to update the size attribute ❶ ❷, but the interesting difference is when you want
    to remove a key that has two subtrees, you use a joining procedure ❸ to merge
    the left and right subtrees into a new tree, which then replaced the removed key.
    (See question 12.22 for more on the deletion algorithm.)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Joining Two Randomized Binary Search Trees
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can build a new tree out of two separate ones by picking one of the subtrees,
    using its root as the root for the new subtree, and recursively processing the
    rest of the trees. Consider the sample case shown in [Figure 12-34](chapter12.xhtml#fig12-34)
    and try to delete the 20 key added earlier.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-34.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-34: Deleting a root (here, 20) requires joining its subtrees into
    a single tree.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: You need to make a single tree out of both of the root’s left and right subtrees
    and decide how to do it via random selection, so either 9 or 23 will become the
    new root. Suppose the random choice picks 9\. Set 9 as the root of the new tree,
    along with its left subtree, and at its right subtree, set the result of joining
    its right subtree with the other subtree, the one rooted at 23.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have to choose among 12 and 23; suppose you select the latter. You
    can add 23 and its right subtree to the tree you are building, and then you still
    have to finish joining the subtrees rooted at 12 and 22\. If you randomly pick
    12 to be the next root, you’ll get the situation shown in [Figure 12-35](chapter12.xhtml#fig12-35).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-35.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-35: The new tree after randomly selecting 9 for its root and 23 for
    its right subtree'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: As the last step, you need to join an empty subtree (12’s right subtree) and
    22’s, so the final tree becomes the one shown in [Figure 12-36](chapter12.xhtml#fig12-36)
    where you’ve removed the 20 key using the new style of algorithm.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-36.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-36: The last step, after joining 12’s right empty subtree and 22’s
    subtree'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the code. To decide from which tree to pick the root, use the same
    rule when you considered considered sampling: if the subtrees were of sizes 6
    and 4 you’d pick the first tree’s root with a 6/10 probability and the second
    tree’s root with a 4/10 probability. Here’s the algorithm:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, get the sizes ❶ of the trees to join to make the random choice later.
    If both trees are empty ❷, you’re done. If not, randomly decide (based on the
    trees’ own sizes) which one will provide the root ❸. If it’s the left one, take
    its root and its left subtree with no changes and replace its right subtree, with
    the result of joining it with the other subtree you were working with. Of course,
    if you picked the right subtree ❹, the logic would be the same, but mirrored.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Randomized Binary Search Trees
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The effects of the randomized addition procedure make the average performance
    logarithmic. Even if the structure can become out of shape at times, continued
    operations bring it back to a good shape. The worst cases still are linear in
    time. There is, after all, a possibility that all random numbers may “work against
    you” to produce a badly shaped tree, but on average, that doesn’t happen; check
    [Table 12-5](chapter12.xhtml#tab12-5).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-5: Performance of Operations for Randomized Binary Search Trees'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Average performance | Worst case |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) | O(1) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| Add | O(log n) | O(n) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n) | O(n) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| Find | O(log n) | O(n) |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| Traverse | O(n) | O(n) |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: 'This structure provides logarithmic performance with high probability: the
    shape of the search tree will be that of a tree created with a random sequence
    of keys. Now consider a different structure that will provide amortized logarithmic
    performance, so a series of operations will have a total time that is logarithmic
    on average.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Splay Trees
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned previously, binary search trees can have *O*(*n*) performance,
    and although this happens only occasionally, it can be a problem. The balanced
    trees from the previous sections take preventive actions to avoid that issue,
    but *splay trees* provide another solution. This version of binary search trees
    guarantees amortized *O*(log *n*) performance, meaning that a sequence of *k*
    successive operations will have *O*(*k* log *n*) performance, which isn’t as good
    as guaranteed *O*(log *n*), but it’s almost as good.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: With splay trees, whenever a node is accessed, it’s moved to the root by a process
    called *splaying*, which is a sequence of rotations that brings up the desired
    node. This doesn’t guarantee a well-balanced tree by any means, but over time,
    splay trees tend to become reasonably well shaped and provide a good alternative
    to other binary search tree implementations.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Consider the situation in [Figure 12-37](chapter12.xhtml#fig12-37) where the
    12 key is sought.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-37.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-37: In a splay tree, after a search (here, for key 12), the found
    node becomes the tree’s new root.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'After finding 12, that key is brought up to the root (you’ll see how later),
    which also causes other paths to change: 23 is pushed down the root’s right subtree,
    10 moves closer to the root, and 22 moves from left to right. Even if it’s possible
    for the tree to become badly shaped, the sequence of operations usually restructures
    it for better performance over time. If you frequently require access to a few
    sets of keys, searches will be quite fast, because those keys will be nearer to
    the root, which is an advantage for many use cases. An example of this is provided
    by compilers and their symbol tables: usually when a symbol is defined (say, in
    a function), there’s a good probability you’ll be accessing it several times in
    a short period.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Splaying a Tree
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Splay trees have specific rules, with quaint names like *zig-zig* or *zag*,
    and they are based on simple rotations. Consider the different cases. In [Figures
    12-38](chapter12.xhtml#fig12-38) through [12-40](chapter12.xhtml#fig12-40), the
    key to be moved up is always 1 (highlighted).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 1: Left Child of the Root**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: If the key is the left child of the root, apply a single right rotation to bring
    the key to the root. This is called a *zig* case, as shown in [Figure 12-38](chapter12.xhtml#fig12-38).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-38.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-38: A single right rotation moves a left subtree up to the root.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The opposite case is if the key were the right child of the root; then you’d
    do a rotation to the left, which is called a *zag*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 2: Right Child of the Left Child of the Root**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: In this *zag-zig* case, first rotate the key to the left and then rotate it
    to the right to bring it up to the root, as shown in [Figure 12-39](chapter12.xhtml#fig12-39).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-39.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-39: Two rotations are needed for the right child of a left child.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: In the opposite case (*zig-zag*), first apply a rotation to the right and then
    to the left.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 3: Left Child of the Left Child of the Root**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'This *zig-zig* case might trip you up, because the order of rotations is altered:
    first you rotate the *parent* of the bottom key to the right and *then* you rotate
    the key itself, as shown in [Figure 12-40](chapter12.xhtml#fig12-40).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-40.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-40: Two right rotations are needed for the left child of a left child.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: You might think an easier algorithm in this case could rotate the key twice,
    but the result isn’t optimal, and a simple example may convince you of this. Assume
    you started with a (not very good) tree, as shown in [Figure 12-41](chapter12.xhtml#fig12-41),
    and splayed up the 1 key.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-41.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-41: Why always rotating the found key isn’t very good'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: You could attempt to use rotations to the right to move the 1 up. At each step,
    the 1 moves up one place, relocating the original root to its right (first 2;
    then 3 and 2; then 4, 3, and 2; and so on), and by the time 1 gets up to the root,
    all the other keys (2–5) are still in the same structure they were before, as
    shown in [Figure 12-42](chapter12.xhtml#fig12-42).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-42.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-42: After all rotations, the tree’s structure becomes worse.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: In this splaying algorithm, two zig-zig rotations could handle this case. First,
    1 becomes a root with 2 and 3 to its right, and then 1 moves to the tree’s top,
    with 4 and 5 at its right; 2 and 3 are relocated to the left of 4, as shown in
    [Figure 12-43](chapter12.xhtml#fig12-43).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-43.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-43: The rotations suggested in the text produce a better structure.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The zig-zig logic produces a better balanced tree, with several shorter paths
    from the root to nodes, and that serves as a justification for using more complex
    logic.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider splaying in terms of actual code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Splaying continues until an empty tree is reached or the key you’re looking
    for is found ❶. As long as those conditions are not met, continue. Decide on which
    subtree you should find the key ❷, and if that subtree is empty, you’re also done.
    (If the tree doesn’t contain the key you’re looking for, the last key you found
    is the one that moves up, so *some* restructuring is always done.) If you find
    the key at the root of the subtree ❸, you have a zig or a zag, and a single rotation
    suffices. If not, if the key you are searching for is at the same side of the
    subtree ❹, you have a zig-zig or zag-zag. First recursively splay the lowest subtree
    ❺, then rotate the root ❻, and finish the last rotation later ❾. The other possibility
    is either a zig-zag or a zag-zig: splay the lowest subtree ❼ and finish with the
    two other rotations ❽ ❾ described earlier.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Finding a Key in a Splayed Tree
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This algorithm is simple. Apply the splaying algorithm first, then check whether
    the value that got to the root is what you were looking for:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Unless the tree is empty, splay it. Splaying ❶ is *always* done, whether or
    not the key exists, so the new key at the root may or may not be what you were
    looking for, which explains the final test ❷.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key to a Splayed Tree
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To add a key, first apply splaying to restructure the tree and then add a new
    root at the top. The tree in [Figure 12-44](chapter12.xhtml#fig12-44), which is
    the same tree used earlier when showing how splaying worked, shows how to add
    an 11 key.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-44.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-44: A splay tree into which you’ll insert an 11 key'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to splay using 11 as the splaying value. This key isn’t present
    in the tree, so the algorithm ends with 10 at the root, as shown in [Figure 12-45](chapter12.xhtml#fig12-45).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-45.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-45: The first step: the tree is splayed with regard to the 11 value.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s easy to finish: 11 should become the root, with 10 (the current root)
    at its left and 23 at the right, as shown in [Figure 12-46](chapter12.xhtml#fig12-46).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-46.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-46: The final step: the 11 becomes the new root, with the splayed
    parts as subtrees.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, create the node that will become the new root ❶. Then, splay the tree
    ❷, so the root becomes the nearest key to the one added. Then link the new root
    properly ❸, and the new node will be the tree’s root.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Splayed Tree
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Removing a key starts by splaying the tree, so the root becomes either the key
    you wanted to remove or a different one, if the key you wanted to remove wasn’t
    present in the tree. If the key was found, do the usual steps. If it has zero
    children or just one child, removal is simple; if it has two children, find the
    next key in its right subtree and set it at the root, but splay it as well.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: You can see how this works by attempting to remove 12 from the tree shown in
    [Figure 12-47](chapter12.xhtml#fig12-47).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-47.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-47: A splay tree from which you want to delete the 12 key'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The first step, as with adding and searching, is to splay the tree using 12
    as the key; you already saw this example, and the result was the updated tree
    shown in [Figure 12-48](chapter12.xhtml#fig12-48).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-48.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-48: The splay tree after splaying, so the 12 becomes the root'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Since the 12 was found, you can proceed. In this case, you have two subtrees,
    so you have to find the key that follows 12 (22) and use that value to splay the
    root’s subtree, getting the new tree shown in [Figure 12-49](chapter12.xhtml#fig12-49).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-49.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-49: The tree after splaying the subtree with 22 at its root'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Now you can easily remove 12 by placing 22 in its place, and you have finished
    the algorithm, as shown in [Figure 12-50](chapter12.xhtml#fig12-50). Note that
    the 22 key cannot have a left subtree, because there’s no value between 12 and
    22.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-50.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-50: The final tree after 22 becomes the root'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'First look at the code to splay a tree, bringing its minimum value to the top.
    Remember from earlier algorithms that we find the minimum key going left until
    we can’t go any further. The idea here is to apply rotations so the minimum key
    ends up at the top:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The algorithm is basically the same as _splay(), except you always assume you’re
    going left ❶ ❷ ❸. Compare the code; it’s the same as earlier, except side is replaced
    with left. (There’s another way of deriving the _splayMinimum() code; see question
    12.25.) With that out of the way, the code for removal is as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the tree isn’t empty, start by splaying it ❶ and then check whether the key
    you want to remove is now at the root. If so, you can easily deal with cases where
    the new root has fewer than two children ❷ ❸ ❹. Otherwise, save the left subtree
    ❺ and then splay the right subtree, bringing its minimum to the top ❻, and the
    minimum takes the place of the key you are deleting. You just have to fix its
    left subtree ❼ and you’re done.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*See question 12.24 to verify that you understand an important detail of this
    algorithm: Why are you only overriding the splayed subtree’s left tree in the
    last steps of the removal process?*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Splay Trees
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Splay trees can, in the worst case, produce a linear tree, so performance would
    be linear in that case and probably would rule them out in a real-time context
    when you need absolute guarantees as to processing time. However, the amortized
    cost of a series of operations is logarithmic, meaning that, on average, a sequence
    of *k* operations (additions and removals) would have a total cost *O*(*k* log
    *n*), which works to a logarithmic amortized performance; [Table 12-6](chapter12.xhtml#tab12-6)
    sums up the results.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-6: Performance of Operations for Splay Trees'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Amortized performance |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| Add | O(log n) |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n) |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| Find | O(log n) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '| Traverse | O(n) |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
- en: One interesting feature is that the structure not only self-reorganizes, but
    it also provides better performance, because frequently accessed keys end up close
    to the root. This makes splay trees appropriate for implementing caches, for example.
    The fact that nodes need no extra bookkeeping data (such as the tree’s height
    or size) makes it interesting if lack of memory is a problem, and yet another
    benefit is that performance is, on average, as efficient as other trees.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced trees, in particular, binary search trees, which provide
    a good implementation for the bag and set ADTs, with high-performing *add*, *remove*,
    and *find* methods. You explored the performance of these trees and saw several
    variants aimed to ensure good, fast algorithms.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter we’ll explore more general tree-based structures, and
    we’ll also consider special search-oriented structures that provide quite efficient
    searches and updates.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '### Questions'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '**12.1  A Matter of Levels**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Can you define the height of a tree in terms of levels?
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '**12.2  Breaking the Rules**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'Filesystem directories are often said to have a treelike structure, but that’s
    not always true. Can you think of a feature that allows directories to be, say,
    like circular lists (as seen in [Chapter 10](chapter10.xhtml)) or even possibly
    like graphs (as you’ll see in [Chapter 17](chapter17.xhtml))? A hint: directory
    entries can be of many types.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '**12.3  What’s in a Name?**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some questions regarding full, perfect, and complete trees: Which
    term implies another? For example, are full trees also complete? And are complete
    trees full? What happens with full and perfect trees? What about perfect and complete?'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '**12.4  A** **find()** **One-Liner**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: It’s certainly less clear, but can you write the find() method with a single
    line of code?
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '**12.5  Sizing a Tree**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Write a calcSize() function that will find the size of a binary tree.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**12.6  Tall as a Tree**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Write a calcHeight() function to find the height of a binary tree.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '**12.7  Copy a Tree**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a binary tree, write an algorithm that will produce a copy of it. (Hint:
    you may want to consider using a preorder traversal for this.)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '**12.8  Do the Math**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: This problem can pop up if you are writing a compiler or an interpreter. Suppose
    you have a binary tree whose nodes can have either a number or a mathematical
    operator (addition, subtraction, multiplication, and division). Such a tree can
    be used to represent any mathematical expression; for instance, the tree in [Figure
    12-51](chapter12.xhtml#fig12-51) stands for (2 + 3) * 6.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-51.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-51: Do the math.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Show that you can evaluate such an expression by properly traversing the tree.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '**12.9  Making It Bad**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'In what order should you insert keys in a common binary search tree to produce
    a linear list? And if you have *n* keys, how many ways can you produce a tree
    with not one single full node? (Hint: Which values could you pick first to add
    into the tree? Which values could come next?)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '**12.10  Rebuild the Tree**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are given the preorder and inorder listings of the keys in a binary
    search tree with no duplicate keys, you can rebuild it; write an algorithm to
    do this. Your input will be two arrays of values: the first will have the tree’s
    keys in preorder, and the second will have them in inorder.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '**12.11  More Rebuilding?**'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: For the previous question, would you have been able to rebuild the tree out
    of the inorder and postorder listings? What about out of the preorder and postorder
    listings?
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '**12.12  Equal Traversals**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: For which trees are keys visited in the same order with preorder and inorder
    traversals? What about for inorder and postorder? Or for preorder and postorder?
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '**12.13  Sorting by Traversing**'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Use the inOrder() traversal to, given a binary search tree, produce an ordered
    array of its keys.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '**12.14  Generic Order**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Write an anyOrder(tree,order,visit) function that will accept an order parameter
    that can be "PRE", "IN", or "POST" and will do the corresponding traversal of
    tree, with the given visit() function.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '**12.15  No Recursion Traversal**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Implement all traversals without using recursion; use a stack instead.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '**12.16  No Duplicates Allowed**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Modify the addition logic for binary search trees to reject attempts to add
    duplicate keys. After such an attempt, the tree should remain unchanged, and an
    error should be thrown.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '**12.17  Get and Delete**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Write a _removeMinFromTree(tree) method that will find the least key in a binary
    search tree, remove it, and return both the key and the updated tree at the same
    time. Use this new method to optimize _remove() by dropping the need for _findNext().
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '**12.18  AVL Worst**'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: What’s the smallest number of nodes that an AVL tree can have related to its
    height? In other words, if an AVL tree has height 1, 2, 3 ..., what’s the smallest
    number of nodes it may have?
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '**12.19  Singles Only**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Consider a child node with no siblings called *single child*. Can you have more
    than 50 percent single children in an AVL tree?
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '**12.20  Why One?**'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: In weight-balanced trees, why is it that the balances of the left subtree and
    the right subtree (that is, the fractions *weight(left subtree) / weight(tree)*
    and *weight(right subtree) / weight(tree)*) add up to 1?
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '**12.21  Easier Randomizing?**'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'A developer had the following thought:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Binary search trees behave badly if keys are added in order, but behave well
    with a random order. What would happen if instead of adding keys to a tree, I
    hashed them first? The hashed keys are, to all effects, random, and so an ordered
    sequence of keys would become a totally disordered one, ensuring good performance.
    Of course, when looking for a key, I’d really need to look for the hashed key,
    but that’s no big deal. Problem solved; binary trees with hashed keys will *always*
    behave well!
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Is this reasoning correct?
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '**12.22  Why Not Decrement?**'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: In the remove() logic for randomized binary trees, why did you use _calcSize()
    instead of decrementing as in the following?
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**12.23  Bad Splay?**'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: You saw earlier that adding keys in ascending or descending order was a bad
    case for common binary search trees. What happens with splay trees in those cases?
    And if after those additions you remove a few keys, what tree shape do you get?
    Is it any better?
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '**12.24  What Left Subtree?**'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the remove() method for splay trees, after splaying the root’s
    right subtree, what’s the value of this.right.left and why?
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '**12.25  Code Transformation**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Show that you can transform _splay() to _splayMinimum() by assuming that keyToUp
    equals -Infinity. Why should this work?
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '**12.26  Full Rebalance**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen several strategies for rebalancing trees, but you may also want
    to rebalance a common binary search tree. Can you come up with a restructure(tree)
    function that will balance a binary search tree into as perfect a shape as possible?
    You should attempt to split nodes as evenly as possible between left and right
    subtrees, everywhere in the tree.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
