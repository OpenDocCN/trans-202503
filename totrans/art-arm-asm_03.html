<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_45" aria-label="45"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch2">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">2</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">DATA REPRESENTATION AND OPERATIONS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">A major stumbling block many beginners encounter when learning assembly language is the common use of the binary and hexadecimal numbering systems. However, the advantages of these systems far outweigh their disadvantages: they greatly simplify the discussion of other topics, including bit operations, signed numeric representation, character codes, and packed data.</p>&#13;
<p class="TX">This chapter discusses the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The binary and hexadecimal numbering systems</li>&#13;
<li class="BL">Binary data organization (bits, nibbles, bytes, half words, words, and double words)</li>&#13;
<li class="BL">Signed and unsigned numbering systems</li>&#13;
<li class="BL">Arithmetic, logical, shift, and rotate operations on binary values</li>&#13;
<li class="BL">Bit fields and packed data</li>&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_46" aria-label="46"/>Floating-point and binary-code decimal formats</li>&#13;
<li class="BL">Character data</li>&#13;
</ul>&#13;
<p class="TX">The remainder of this book depends on your understanding of these basic concepts. If you are already familiar with these terms from other courses or study, you should still skim this material to be sure you’re not missing anything, and to learn the instructions this chapter introduces, before proceeding to the next one. If you are unfamiliar or only partly familiar with this material, study it carefully before proceeding. Don’t skip any sections: <i>all the material in this chapter is important</i>!</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-20"/><span class="SANS_Futura_Std_Bold_B_11">2.1 Numbering Systems</span></h3>&#13;
<p class="TNI1">Most modern computer systems do not use the decimal (base-10) system to represent numeric values. Instead, they typically use a binary numbering system. This is because the binary (base-2) numbering system more closely matches the electronic circuitry used to represent numeric values in a computer system.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-18"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.1.1 Decimal</span></h4>&#13;
<p class="TNI1">You’ve been using the decimal numbering system for so long that you probably take it for granted. When you see a number like 123, you don’t think about the value 123; rather, you generate a mental image of how many items this value represents. In reality, however, the number 123 represents the following:</p>&#13;
<p class="Equation">(1 × 10<sup>2</sup>) + (2 × 10<sup>1</sup>) + (3 × 10<sup>0</sup>)</p>&#13;
<p class="Continued1">or</p>&#13;
<p class="Equation">100 + 20 + 3</p>&#13;
<p class="TX">In a decimal <i>positional numbering system</i>, each digit appearing to the left of the decimal point represents a value from 0 to 9 multiplied by an increasing power of 10. Digits appearing to the right of the decimal point represent a value from 0 to 9 multiplied by an increasing negative power of 10. For example, the value 123.456 means this:</p>&#13;
<p class="Equation">(1 × 10<sup>2</sup>) + (2 × 10<sup>1</sup>) + (3 × 10<sup>0</sup>) + (4 × 10<sup>−1</sup>) + (5 × 10<sup>−2</sup>) + (6 × 10<sup>−3</sup>)</p>&#13;
<p class="Continued1">or</p>&#13;
<p class="Equation">100 + 20 + 3 + 0.4 + 0.05 + 0.006</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-19"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.1.2 Binary</span></h4>&#13;
<p class="TNI1">Most modern computer systems operate using <i>binary</i> logic. The computer uses two voltage levels (usually 0 V and 2.4 to 5 V) to represent values. These two levels can represent exactly two unique values. These could be <span role="doc-pagebreak" epub:type="pagebreak" id="pg_47" aria-label="47"/>any two values, but they typically represent the values 0 and 1, the two digits in the binary numbering system.</p>&#13;
<p class="TX">The binary numbering system works just like the decimal numbering system, except binary allows only the digits 0 and 1 (rather than 0 to 9) and uses powers of 2 rather than powers of 10. Therefore, converting a binary number to decimal is easy. For each 1 in a binary string, add 2<i><sup>n</sup></i>, where <i>n</i> is the zero-based position of the binary digit. For example, the binary value 11001010<sub>2</sub> represents the following:</p>&#13;
<p class="Equation">(1 × 2<sup>7</sup>) + (1 × 2<sup>6</sup>) + (0 × 2<sup>5</sup>) + (0 × 2<sup>4</sup>) + (1 × 2<sup>3</sup>) + (0 × 2<sup>2</sup>) + (1 × 2<sup>1</sup>) + (0 × 2<sup>0</sup>)</p>&#13;
<p class="Equation">= 128<sub>10</sub> + 64<sub>10</sub> + 8<sub>10</sub> + 2<sub>10</sub></p>&#13;
<p class="Equation1">= 202<sub>10</sub></p>&#13;
<p class="TX">Converting decimal to binary is slightly more difficult. You must find those powers of 2 that, when added together, produce the decimal result.</p>&#13;
<p class="TX">A simple way to convert decimal to binary is the <i>even/odd, divide-by-2</i> algorithm, comprising the following steps:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  If the number is even, emit a 0. If the number is odd, emit a 1.</p>&#13;
<p class="ListNumber">  2.  Divide the number by 2 and throw away any fractional component or remainder.</p>&#13;
<p class="ListNumber">  3.  If the quotient is 0, the algorithm is complete.</p>&#13;
<p class="ListNumber">  4.  If the quotient is not 0 and is odd, insert a 1 before the current string; if the number is even, prefix your binary string with 0.</p>&#13;
<p class="ListNumber">  5.  Go back to step 2 and repeat.</p>&#13;
</div>&#13;
<p class="TX">Binary numbers, although they have little importance in HLLs, appear everywhere in assembly language programs, so make sure you’re comfortable with them.</p>&#13;
<p class="TX">In the purest sense, every binary number contains an infinite number of digits (or <i>bits</i>, which is short for <i>binary digits</i>). For example, you can represent the number 5 with any of the following:</p>&#13;
<p class="ListPlain">101</p>&#13;
<p class="ListPlain">00000101</p>&#13;
<p class="ListPlain">0000000000101</p>&#13;
<p class="ListPlain">... 000000000000101</p>&#13;
<p class="TX">Any number of leading-zero digits may precede the binary number without changing its value. Because the ARM typically works with groups of 8 bits, this book will zero-extend all binary numbers to a multiple of 4 or 8 bits. Following this convention, you’d represent the number 5 as 0101<sub>2</sub> or 00000101<sub>2</sub>.</p>&#13;
<p class="TX">To make larger numbers easier to read, I will often separate each group of 4 binary bits with an underscore. For example, I will write the binary value 1010111110110010 as 1010_1111_1011_0010. (Gas does not actually <span role="doc-pagebreak" epub:type="pagebreak" id="pg_48" aria-label="48"/>allow you to insert underscores into the middle of a binary number; I use this convention just for readability purposes.)</p>&#13;
<p class="TX">The usual convention is to number each bit as follows: the rightmost bit in a binary number is bit position 0, and each bit to the left is given the next successive bit number. An 8-bit binary value uses bits 0 to 7:</p>&#13;
<p class="ListPlain"><i>X</i><sub>7</sub> <i>X</i><sub>6</sub> <i>X</i><sub>5</sub> <i>X</i><sub>4</sub> <i>X</i><sub>3</sub> <i>X</i><sub>2</sub> <i>X</i><sub>1</sub> <i>X</i><sub>0</sub></p>&#13;
<p class="TX">A 16-bit binary value uses bit positions 0 to 15:</p>&#13;
<p class="ListPlain"><i>X</i><sub>15</sub> <i>X</i><sub>14</sub> <i>X</i><sub>13</sub> <i>X</i><sub>12</sub> <i>X</i><sub>11</sub> <i>X</i><sub>10</sub> <i>X</i><sub>9</sub> <i>X</i><sub>8</sub> <i>X</i><sub>7</sub> <i>X</i><sub>6</sub> <i>X</i><sub>5</sub> <i>X</i><sub>4</sub> <i>X</i><sub>3</sub> <i>X</i><sub>2</sub> <i>X</i><sub>1</sub> <i>X</i><sub>0</sub></p>&#13;
<p class="TX">A 32-bit binary value uses bit positions 0 to 31, and so on.</p>&#13;
<p class="TX">Bit 0 is the <i>low-order (LO)</i> bit; some refer to this as the <i>least significant bit</i>. The leftmost bit is called the <i>high-order (HO)</i> bit, or the <i>most significant bit</i>. I’ll refer to the intermediate bits by their respective bit numbers.</p>&#13;
<p class="TX">In Gas, you can specify binary values as a string of 0 or 1 digits beginning with the sequence 0b—for example, 0b10111111.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-20"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.1.3 Hexadecimal</span></h4>&#13;
<p class="TNI1">Unfortunately, binary numbers are verbose: representing the value 202<sub>10</sub> requires eight binary digits but only three decimal digits. When dealing with large values, binary numbers quickly become unwieldy. Since the computer “thinks” in binary, however, using the binary numbering system is convenient when creating values for the computer to use. Although you can convert between decimal (which humans tend to be most comfortable with) and binary, the conversion is not a trivial task. Additionally, many assembly language constants are easier to read and understand when written in binary (rather than decimal), so it’s often a better idea to use binary.</p>&#13;
<p class="TX">The <i>hexadecimal</i> (base-16) numbering system solves many of the problems inherent in the binary system: hexadecimal numbers are compact, and it’s simple to convert them to binary, and vice versa. For this reason, most engineers use the hexadecimal numbering system rather than binary.</p>&#13;
<p class="TX">Because the <i>radix</i> (base) of a hexadecimal number is 16, each hexadecimal digit to the left of the hexadecimal point represents a certain value multiplied by a successive power of 16. For example, the number 1,234<sub>16</sub> is equal to this:</p>&#13;
<p class="Equation">(1 × 16<sup>3</sup>) + (2 × 16<sup>2</sup>) + (3 × 16<sup>1</sup>) + (4 × 16<sup>0</sup>)</p>&#13;
<p class="Continued1">or</p>&#13;
<p class="Equation">4,096<sub>10</sub> + 512<sub>10</sub> + 48<sub>10</sub> + 4<sub>10</sub> = 4,660<sub>10</sub></p>&#13;
<p class="TX">Each hexadecimal digit can represent one of 16 values from 0 to 15<sub>10</sub>. Because there are only 10 decimal digits, you need 6 additional digits to represent the values in the range 10<sub>10</sub> to 15<sub>10</sub>. Rather than create new symbols for these digits, the convention is to use the letters A to F. The following are examples of valid hexadecimal numbers:</p>&#13;
<div class="top">&#13;
<p class="ListPlain"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_49" aria-label="49"/>1234<sub>16</sub></p>&#13;
<p class="ListPlain">DEAD<sub>16</sub></p>&#13;
<p class="ListPlain">BEEF<sub>16</sub></p>&#13;
<p class="ListPlain">0AFB<sub>16</sub></p>&#13;
<p class="ListPlain">F001<sub>16</sub></p>&#13;
<p class="ListPlain">D8B4<sub>16</sub></p>&#13;
</div>&#13;
<p class="TX">Because you’ll often need to enter hexadecimal numbers into the computer system, and on most computer systems you cannot enter a subscript to denote the radix of the associated value, you’ll need a different mechanism for representing hexadecimal numbers. In this book, I use the following Gas conventions:</p>&#13;
<ul class="ul">&#13;
<li class="BL">All hexadecimal values have a 0x prefix (for example, 0x123A4 and 0xDEAD).</li>&#13;
<li class="BL">All binary values begin with a 0b sequence (for example, 0b10010).</li>&#13;
<li class="BL">Decimal numbers do not have a prefix character.</li>&#13;
<li class="BL">If the radix is clear from the context, I may drop the 0x or 0b prefix characters.</li>&#13;
</ul>&#13;
<p class="TX">Gas also allows the use of octal (base-8) numbers that begin with a leading 0 and contain only the digits 0 through 7. This book, however, does not use octal numbers.</p>&#13;
<p class="TX">Here are examples of valid hexadecimal numbers using Gas notation:</p>&#13;
<div class="top">&#13;
<p class="ListPlain">0x1234</p>&#13;
<p class="ListPlain">0xDEAD</p>&#13;
<p class="ListPlain">0xBEEF</p>&#13;
<p class="ListPlain">0xAFB</p>&#13;
<p class="ListPlain">0xF001</p>&#13;
<p class="ListPlain">0xD8B4</p>&#13;
</div>&#13;
<p class="TX">As you can see, hexadecimal numbers are compact and easy to read. In addition, you can easily convert between hexadecimal and binary. <a href="chapter2.xhtml#tab2-1">Table 2-1</a> provides all the information you need to convert any hexadecimal number into a binary number, or vice versa.</p>&#13;
<p class="TX">To convert a hexadecimal number into a binary number, substitute the corresponding 4 bits for each hexadecimal digit in the number. For example, to convert 0xABCD into a binary value, convert each hexadecimal digit according to <a href="chapter2.xhtml#tab2-1">Table 2-1</a>: A becomes 1010, B becomes 1011, C becomes 1100, and D becomes 1101, giving you the binary value 1010_1011_1100_1101.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_50" aria-label="50"/>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-1:</span></span> <span class="SANS_Futura_Std_Book_11">Binary/Hexadecimal Conversion</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Binary</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Hexadecimal</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Decimal</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0000</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0001</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0010</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0011</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0100</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">4</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">4</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0101</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">5</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">5</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0110</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">6</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">6</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0111</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">7</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">7</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1000</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">8</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">8</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1001</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">9</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">9</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1010</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1011</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">B</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">11</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1100</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">C</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">12</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1101</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">13</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1110</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">E</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">14</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1111</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">15</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Converting a binary number into hexadecimal format is almost as easy:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Pad the binary number with 0s to make sure that the number contains a multiple of 4 bits. For example, given the binary number 1011001010, add 2 bits to the left of the number so that it contains 12 bits: 001011001010.</p>&#13;
<p class="ListNumber">  2.  Separate the binary value into groups of 4 bits. In this example, you’d get 0010_1100_1010.</p>&#13;
<p class="ListNumber">  3.  Look up these binary values in <a href="chapter2.xhtml#tab2-1">Table 2-1</a> and substitute the appropriate hexadecimal digits: 0x2CA.</p>&#13;
</div>&#13;
<p class="TX">Contrast this with the difficulty of conversion between decimal and binary, or decimal and hexadecimal!</p>&#13;
<p class="TX">Because you’ll need to convert between hexadecimal and binary over and over again, take a few minutes to memorize the conversion table. Even if you have a calculator that can do the conversion for you, manual conversion is much faster and more convenient once you get the hang of it.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-21"/><span class="SANS_Futura_Std_Bold_B_11">2.2 Numbers vs. Representation</span></h3>&#13;
<p class="TNI1">Many people confuse numbers and their representation. Beginning assembly language students often ask, “I have a binary number in the W0 register; how do I convert that to a hexadecimal number in the W0 register?” The answer is, “You don’t.” Although one could make a strong argument <span role="doc-pagebreak" epub:type="pagebreak" id="pg_51" aria-label="51"/>that numbers in memory or in registers are represented in binary, it’s best to view values in memory or in a register as abstract numeric quantities. Strings of symbols like 128, 0x80, or 0b10000000 are not different numbers; they are simply different representations for the quantity that people refer to as “one hundred twenty-eight.” Inside the computer, a number is a number regardless of representation; the only time representation matters is when you input or output the value in a human-readable form.</p>&#13;
<p class="TX">Pure assembly language has no generic print or write functions you can call to display numeric quantities as strings on your console. <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> demonstrates how to write your own procedures to handle this process. For the time being, the Gas code in this book relies on the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function to display numeric values. Consider Listing 2-1, which converts various decimal values to their hexadecimal equivalents.</p>&#13;
<pre id="pre-73"><code>// Listing2-1.S&#13;
//&#13;
// Displays some numeric values on the console&#13;
#include "aoaa.inc"&#13;
&#13;
            .data&#13;
// Program title, required by C++ code:&#13;
&#13;
titleStr:   .asciz      "Listing 2-1"&#13;
&#13;
// Format strings for three calls to printf():&#13;
&#13;
fmtStrI:    .asciz      "i=%d, converted to hex=%x\n"&#13;
fmtStrJ:    .asciz      "j=%d, converted to hex=%x\n"&#13;
fmtStrK:    .asciz      "k=%d, converted to hex=%x\n"&#13;
&#13;
// Some values to print in decimal and hexadecimal form:&#13;
&#13;
            .align      2  // Be nice and word-align.&#13;
i:          .dword      1&#13;
j:          .dword      123&#13;
k:          .dword      456789&#13;
saveLR:     .dword      0&#13;
&#13;
            .text&#13;
            .align      2      // Code must be word-aligned.&#13;
            .extern     printf // printf is outside this code.&#13;
&#13;
// Return program title to C++ program:&#13;
&#13;
getTitle:&#13;
&#13;
// Load address of "titleStr" into the X0 register (X0 holds&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_52" aria-label="52"/>// the function return result) and return back to the caller:&#13;
&#13;
            lea x0, titleStr&#13;
            ret&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            .global     asmMain&#13;
asmMain:&#13;
            sub         sp, sp, #64 // Magic instruction&#13;
&#13;
// Save LR so we can return to C++ program:&#13;
&#13;
            lea         x0, saveLR&#13;
            str         lr, [x0]&#13;
&#13;
// Call printf three times to print the three values&#13;
// i, j, and k:&#13;
//&#13;
// printf("i=%d, converted to hex=%x\n", i, i);&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> lea         x0, fmtStrI&#13;
            vparm2      i           // Get parameter 2&#13;
            vparm3      i           // Get parameter 3&#13;
            bl          printf&#13;
&#13;
// printf("j=%d, converted to hex=%x\n", j, j);&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> lea         x0, fmtStrJ&#13;
            vparm2      j&#13;
            vparm3      j&#13;
            bl          printf&#13;
&#13;
// printf("k=%d, converted to hex=%x\n", k, k);&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> lea         x0, fmtStrK&#13;
            vparm2      k&#13;
            vparm3      k&#13;
            bl          printf&#13;
&#13;
// Restore LR so we can return to C++ program:&#13;
&#13;
            lea         x0, saveLR&#13;
            ldr         lr, [x0]&#13;
&#13;
            add         sp, sp, #64  // Magic instruction&#13;
            ret                      // Returns to caller</code></pre>&#13;
<p class="TX">To simulate the C statement</p>&#13;
<pre id="pre-74"><code>printf("i=%d, converted to hex=%x\n", i, i);</code></pre>&#13;
<p class="Continued1">the code must load three parameters <span class="CodeAnnotation" aria-label="annotation1">❶</span> into X0, X1, and X2: the address of the format string (<span class="SANS_TheSansMonoCd_W5Regular_11">fmtStrI</span>) and the current value held in variable <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> (passed <span role="doc-pagebreak" epub:type="pagebreak" id="pg_53" aria-label="53"/>twice, in X1 and X2). Note that the <span class="SANS_TheSansMonoCd_W5Regular_11">vparm2</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">vparm3</span> macros will load their argument (<span class="SANS_TheSansMonoCd_W5Regular_11">i</span>) into X1 and X2, respectively. In a similar vein, the code sets up X0, X1, and X2 to print the values held in the <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> variables <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">This decimal-to-hexadecimal conversion program uses the generic <i>c.cpp</i> program from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, along with the generic <i>build</i> shell script. You can compile and run this program by using the following commands at the command line:</p>&#13;
<pre id="pre-75"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing2-1</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing2-1</span>&#13;
Calling Listing2-1:&#13;
i=1, converted to hex=1&#13;
j=123, converted to hex=7b&#13;
k=456789, converted to hex=6f855&#13;
Listing2-1 terminated</code></pre>&#13;
<p class="TX">As you can see, this program displays the initialized values of <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> in decimal and hexadecimal form.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-22"/><span class="SANS_Futura_Std_Bold_B_11">2.3 Data Organization</span></h3>&#13;
<p class="TNI1">In pure mathematics, a value’s representation may require an arbitrary number of bits. Computers, on the other hand, generally work with a specific number of bits. Common collections are single bits, groups of 4 bits (called <i>nibbles</i>), 8 bits (<i>bytes</i>), 16 bits (<i>half words</i>, or <i>hwords</i>), 32 bits (<i>words</i>), 64 bits (<i>double words</i>, or <i>dwords</i>), 128 bits (<i>quad words</i>, or <i>qwords</i>), and more. The following subsections describe how the ARM CPU organizes these groups of bits and the typical values you can represent with them.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-21"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.3.1 Bits</span></h4>&#13;
<p class="TNI1">The smallest unit of data on a binary computer is a single <i>bit</i>. With one bit, you can represent any two distinct items, such as 0 or 1, true or false, and right or wrong. However, you are <i>not</i> limited to representing binary data types; you could use a single bit to represent the numbers 723 and 1,245 or, perhaps, the colors red and blue, or even the color red and the number 3,256. You can represent <i>any</i> two values with a single bit, but <i>only</i> two values with a single bit.</p>&#13;
<p class="TX">Different bits can represent different things. For example, you could use one bit to represent the values 0 and 1, while a different bit could represent the values true and false, and another bit could represent the two colors red and blue. You can’t tell what a bit represents just by looking at it, though.</p>&#13;
<p class="TX">This illustrates the whole idea behind computer data structures: <i>data is what you define it to be</i>. If you use a bit to represent a Boolean (true/false) value, then that bit, by your definition, represents true or false. However, you must be consistent. If you’re using a bit to represent true or false at one point in your program, you shouldn’t use that value to represent red or blue later.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_54" aria-label="54"/>&#13;
<h4 class="H2" id="sec8"><span id="h2-22"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.3.2 Nibbles</span></h4>&#13;
<p class="TNI1">A <i>nibble</i> is a collection of 4 bits. With a nibble, you can represent up to 16 distinct values, using the 16 possible unique combinations of those 4 bits:</p>&#13;
<pre id="pre-76"><code>0000&#13;
0001&#13;
0010&#13;
0011&#13;
0100&#13;
0101&#13;
0110&#13;
0111&#13;
1000&#13;
1001&#13;
1010&#13;
1011&#13;
1100&#13;
1101&#13;
1110&#13;
1111</code></pre>&#13;
<p class="TX">A nibble takes 4 bits to represent a single digit in <i>binary-coded decimal (BCD)</i> numbers and hexadecimal numbers. In the case of hexadecimal numbers, each of the values 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F is represented with 4 bits. BCD uses 4 binary bits to represent each of the 10 digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) used in decimal numbers.</p>&#13;
<p class="TX">BCD requires 4 bits because you can represent only 8 different values with 3 bits, and representing 10 values takes at least 4 bits. (The additional 6 values you can represent with 4 bits are never used in BCD representation.) In fact, any 16 distinct values can be represented with a nibble, though hexadecimal and BCD digits are the primary items you’ll represent with a single nibble.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-23"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.3.3 Bytes</span></h4>&#13;
<p class="TNI1">Without question, the most important data structure used by the ARM microprocessor is the <i>byte</i>, which consists of 8 bits. Main memory and I/O addresses on the ARM are all byte addresses. This means that the smallest item that can be individually accessed by an ARM program is an 8-bit value. To access anything smaller requires that you read the byte containing the data and eliminate the unwanted bits. The bits in a byte are normally numbered from 0 to 7, as shown in <a href="chapter2.xhtml#fig2-1">Figure 2-1</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig2-1" src="../images/Figure2-1.jpg" alt="" width="512" height="114"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-1: Bit numbering</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Bit 0 is the <i>LO bit</i>, or <i>least significant bit</i>, and bit 7 is the <i>HO bit</i>, or <i>most significant bit,</i> of the byte. I’ll refer to any other bit by its number.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_55" aria-label="55"/>A byte contains exactly 2 nibbles, as shown in <a href="chapter2.xhtml#fig2-2">Figure 2-2</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig2-2" src="../images/Figure2-2.jpg" alt="" width="511" height="160"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-2: The 2 nibbles in a byte</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Bits 0 to 3 compose the <i>LO nibble</i>, and bits 4 to 7 form the <i>HO nibble</i>. Because a byte contains exactly 2 nibbles, byte values require two hexadecimal digits.</p>&#13;
<p class="TX">Because a byte contains 8 bits, it can represent 2<sup>8</sup> (256) values. Generally, assembly programmers use a byte to represent numeric values in the range 0 through 255, signed numbers in the range –128 through +127 (see section 2.6, <span class="Xref">“Signed and Unsigned Numbers,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_65">page 65</a></span>), character codes, and other special data types requiring no more than 256 values. Many data types have fewer than 256 items, so 8 bits is often sufficient.</p>&#13;
<p class="TX">Because the ARM is a byte-addressable machine, it’s more efficient to manipulate a whole byte than an individual bit or nibble. That means it’s more efficient to use a whole byte to represent data types that require 2 to 256 items, even if fewer than 8 bits would suffice.</p>&#13;
<p class="TX">Probably the most important use for a byte is holding a character value. Characters typed at the keyboard, displayed on the screen, and printed on the printer all have numeric values. To communicate with the rest of the world, PCs typically use a variant of the American Standard Code for Information Interchange (ASCII) character set or the Unicode character set. The ASCII character set has 128 defined codes. (Because the Unicode character set has far more than 256 characters, a single byte is insufficient to represent all the Unicode characters; see section 2.17, <span class="Xref">“Gas Support for the Unicode Character Set,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_102">page 102</a></span> for more.)</p>&#13;
<p class="TX">Bytes are also the smallest variable you can create in a Gas program. To create an arbitrary byte variable, use the <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> data type, as follows:</p>&#13;
<pre id="pre-77"><code>          .data&#13;
byteVar:  .byte   0</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">byte</span> data type holds any 8-bit value: small signed integers, small unsigned integers, characters, and the like. It’s up to you to keep track of the type of object you’ve put into a byte variable.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-24"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.3.4 Half Words</span></h4>&#13;
<p class="TNI1">A <i>half word</i> is a group of 16 bits. The bits in a half word are numbered from 0 to 15, as <a href="chapter2.xhtml#fig2-3">Figure 2-3</a> shows. As with the byte, bit 0 is the LO bit. For half words, bit 15 is the HO bit. When referencing any other bit in a half word, I’ll use its bit position number.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_56" aria-label="56"/>&#13;
<figure class="IMG"><img class="img7" id="fig2-3" src="../images/Figure2-3.jpg" alt="" width="1012" height="104"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-3: The bit numbers in a half word</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A half word contains exactly 2 bytes, as shown in <a href="chapter2.xhtml#fig2-4">Figure 2-4</a>. Bits 0 to 7 form the LO byte, and bits 8 to 15 form the HO byte.</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-4" src="../images/Figure2-4.jpg" alt="" width="1138" height="193"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-4: The 2 bytes in a half word</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A half word also contains 4 nibbles, as shown in <a href="chapter2.xhtml#fig2-5">Figure 2-5</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-5" src="../images/Figure2-5.jpg" alt="" width="1012" height="217"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-5: The nibbles in a half word</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">With 16 bits, you can represent 2<sup>16</sup> (65,536) values. These could be the values in the range 0 to 65,535 or, as is usually the case, the signed values –32,768 to +32,767, or any other data type with no more than 65,536 values.</p>&#13;
<p class="TX">The two major uses for half words are short signed integer values and short unsigned integer values. Unsigned numeric values are represented by the binary value corresponding to the bits in the half word. Signed numeric values use the two’s complement form for numeric values (see section 2.6, <span class="Xref">“Signed and Unsigned Numbers,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_65">page 65</a></span>).</p>&#13;
<p class="TX">As with bytes, you can also create half-word variables in a Gas program. To create an arbitrary half-word variable, just use the <span class="SANS_TheSansMonoCd_W5Regular_11">.hword</span> data type, as follows:</p>&#13;
<pre id="pre-78"><code>         .data&#13;
hw:      .hword  0</code></pre>&#13;
<p class="Continued1">This defines a 16-bit variable (<span class="SANS_TheSansMonoCd_W5Regular_11">hw</span>) initialized with 0.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-25"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.3.5 Words</span></h4>&#13;
<p class="TNI1">A word quantity is 32 bits long, as shown in <a href="chapter2.xhtml#fig2-6">Figure 2-6</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig2-6" src="../images/Figure2-6.jpg" alt="" width="1689" height="88"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-6: The bit numbers in a word</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_57" aria-label="57"/>Naturally, this word can be divided into a HO half word and a LO half word, 4 bytes, or 8 nibbles, as shown in <a href="chapter2.xhtml#fig2-7">Figure 2-7</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig2-7" src="../images/Figure2-7.jpg" alt="" width="1688" height="662"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-7: The nibbles, bytes, and half words in a word</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Words can represent all kinds of things. You’ll commonly use them to represent 32-bit integer values (which allow unsigned numbers in the range 0 to 4,294,967,295 or signed numbers in the range –2,147,483,648 to +2,147,483,647); 32-bit floating-point values also fit into a word.</p>&#13;
<p class="TX">You can create an arbitrary word variable by using the <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span> declaration, as in the following example:</p>&#13;
<pre id="pre-79"><code>      .data&#13;
w:    .word   0</code></pre>&#13;
<p class="Continued1">This defines a 32-bit variable (<span class="SANS_TheSansMonoCd_W5Regular_11">w</span>) initialized with 0.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-26"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.3.6 Double Words and Quad Words</span></h4>&#13;
<p class="TNI1"><i>Double-word</i> (64-bit) values are also important because 64-bit integers, pointers, and certain floating-point data types require 64 bits. In a similar vein, <i>quad-word</i> (128-bit) values are important because the ARM Neon instruction set can manipulate 128-bit values. The <i>aoaa.inc</i> include file includes the <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.qword</span> macros, which allow Gas to declare 64- and 128-bit values by using the <span class="SANS_TheSansMonoCd_W5Regular_11">dword</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">qword</span> types:</p>&#13;
<pre id="pre-80"><code>      .data&#13;
dw:   .dword 0&#13;
qw:   .qword 0</code></pre>&#13;
<p class="TX">Without <i>aoaa.inc</i>, the standard Gas directives are <span class="SANS_TheSansMonoCd_W5Regular_11">.quad</span> (for dwords) and <span class="SANS_TheSansMonoCd_W5Regular_11">.octa</span> (for qwords). This book uses <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.qword</span> because they are more descriptive.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_58" aria-label="58"/>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Technically, Gas does support</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.dword</span><i>. It’s the macOS assembler (Clang assembler) that doesn’t support</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.dword</span> <i>and requires the macro in the</i> <span class="note_Italic">aoaa.inc</span> <i>header file.</i></p>&#13;
<p class="TX">You cannot directly manipulate 128-bit integer objects by using standard instructions like <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">add</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> because the standard ARM integer registers process only 64 bits at a time. In <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, you’ll see how to manipulate these <i>extended-precision</i> values; <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> describes how to directly manipulate qword values by using SIMD instructions.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h1-23"/><span class="SANS_Futura_Std_Bold_B_11">2.4 Logical Operations on Bits</span></h3>&#13;
<p class="TNI1">Although you can represent numeric values with bytes, half words, words, and so on, these are also groups of bits that you can manipulate at the bit level. This section describes the operations on individual bits and how to operate on these bits in larger data structures. You will typically do four logical operations (Boolean functions) on hexadecimal and binary numbers: AND, OR, XOR (exclusive-OR), and NOT.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-27"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.4.1 AND</span></h4>&#13;
<p class="TNI1">The AND operation is <i>dyadic</i>, meaning it accepts exactly two operands of individual binary bits, as shown here:</p>&#13;
<pre id="pre-81"><code>0 and 0 = 0&#13;
0 and 1 = 0&#13;
1 and 0 = 0&#13;
1 and 1 = 1</code></pre>&#13;
<p class="TX">Many texts call the AND operation a <i>binary operation</i>. The term <i>dyadic</i> means the same thing and avoids confusion with the binary numbering system.</p>&#13;
<p class="TX">A <i>truth table</i>, which takes the form shown in <a href="chapter2.xhtml#tab2-2">Table 2-2</a>, is a compact way to represent the AND operation.</p>&#13;
<table class="Basic-Table1">&#13;
<caption><p class="TT" id="tab2-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-2:</span></span> <span class="SANS_Futura_Std_Book_11">AND Truth Table</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">AND</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">0</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">1</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Truth tables work just like the multiplication tables you may have encountered in school. The values in the left column correspond to the left operand of the AND operation. The values in the first row correspond to the right operand of the AND operation. The value located at the intersection of the row and column (for a particular pair of input values) is the result of ANDing those two values together.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_59" aria-label="59"/>In English, the AND operation is, “If the first operand is 1 and the second operand is 1, the result is 1; otherwise, the result is 0.” You could also state this as, “If either or both operands are 0, the result is 0.”</p>&#13;
<p class="TX">You can use the AND operation to force a 0 result: if one of the operands is 0, the result is always 0 regardless of the other operand. In <a href="chapter2.xhtml#tab2-2">Table 2-2</a>, for example, the row labeled with a 0 input contains only 0s, and the column labeled with a 0 contains only 0s. Conversely, if one operand contains a 1, the result is exactly the value of the second operand. These results of the AND operation are important, particularly when you want to force bits to 0. This chapter investigates these uses of the AND operation in section 2.5, <span class="Xref">“Logical Operations on Binary Numbers and Bit Strings,”</span> on <span class="Xref">the next page</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-28"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.4.2 OR</span></h4>&#13;
<p class="TNI1">The OR operation, which is also dyadic, is defined as follows:</p>&#13;
<pre id="pre-82"><code>0 or 0 = 0&#13;
0 or 1 = 1&#13;
1 or 0 = 1&#13;
1 or 1 = 1</code></pre>&#13;
<p class="TX"><a href="chapter2.xhtml#tab2-3">Table 2-3</a> shows the truth table for the OR operation.</p>&#13;
<table class="Basic-Table1">&#13;
<caption><p class="TT" id="tab2-3"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-3:</span></span> <span class="SANS_Futura_Std_Book_11">OR Truth Table</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">OR</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">0</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">1</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Colloquially, the OR operation is, “If the first operand or the second operand (or both) is 1, the result is 1; otherwise, the result is 0.” This is also known as the <i>inclusive-OR</i> operation.</p>&#13;
<p class="TX">If one of the operands to the OR operation is a 1, the result is always 1 regardless of the second operand’s value. If one operand is 0, the result is always the value of the second operand. As with the AND operation, this is an important side effect of the OR operation that will prove quite useful.</p>&#13;
<p class="TX">There is a difference between this form of the inclusive-OR operation and the standard English meaning. Consider the sentence “I am going to the store, <i>or</i> I am going to the park.” Such a statement implies that the speaker is going to the store or to the park, but not to both places. This colloquial use of <i>or</i> is analogous not to the inclusive-OR but to the <i>exclusive-OR</i> operation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-29"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.4.3 XOR</span></h4>&#13;
<p class="TNI1">The XOR (exclusive-OR) operation is also dyadic. Its definition is as follows:</p>&#13;
<pre id="pre-83"><code>0 xor 0 = 0&#13;
0 xor 1 = 1&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_60" aria-label="60"/>1 xor 0 = 1&#13;
1 xor 1 = 0</code></pre>&#13;
<p class="TX"><a href="chapter2.xhtml#tab2-4">Table 2-4</a> shows the truth table for the XOR operation.</p>&#13;
<table class="Basic-Table1">&#13;
<caption><p class="TT" id="tab2-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-4:</span></span> <span class="SANS_Futura_Std_Book_11">XOR Truth Table</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">XOR</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">0</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">1</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">In English, the XOR operation is, “If the first operand or the second operand, but not both, is 1, the result is 1; otherwise, the result is 0.”</p>&#13;
<p class="TX">If one of the operands to the exclusive-OR operation is a 1, the result is always the <i>inverse</i> of the other operand; that is, if one operand is 1, the result is 0 if the other operand is 1, and the result is 1 if the other operand is 0. If the first operand contains a 0, the result is exactly the value of the second operand. This feature lets you selectively invert bits in a bit string.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-30"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.4.4 NOT</span></h4>&#13;
<p class="TNI1">The NOT operation is <i>monadic</i>, meaning it accepts only one operand:</p>&#13;
<pre id="pre-84"><code>not 0 = 1&#13;
not 1 = 0</code></pre>&#13;
<p class="TX"><a href="chapter2.xhtml#tab2-5">Table 2-5</a> shows the truth table for the NOT operation.</p>&#13;
<table class="Basic-Table1">&#13;
<caption><p class="TT" id="tab2-5"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-5:</span></span> <span class="SANS_Futura_Std_Book_11">NOT Truth Table</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">NOT</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">0</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">1</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"/></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The NOT operation inverts the value of the input bit.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h1-24"/><span class="SANS_Futura_Std_Bold_B_11">2.5 Logical Operations on Binary Numbers and Bit Strings</span></h3>&#13;
<p class="TNI1">The previous section defined the logical functions for single-bit operands. Because the ARM uses groups of 8, 16, 32, 64, or more bits, this section extends the definition of these functions to deal with more than 2 bits.</p>&#13;
<p class="TX">Logical functions on the ARM operate on a <i>bit-by-bit</i> (or <i>bitwise</i>) basis. Given two values, these functions operate on bit 0 of each value, producing bit 0 of the result; then they operate on bit 1 of the input values, producing bit 1 of the result, and so on. For example, if you want to compute the AND of the following two 8-bit numbers, you would perform the AND operation on each column independently of the others:</p>&#13;
<pre id="pre-85"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label="61"/>0b1011_0101&#13;
0b1110_1110&#13;
-----------&#13;
0b1010_0100</code></pre>&#13;
<p class="TX">You may apply this bit-by-bit calculation to the other logical functions as well. To perform a logical operation on two hexadecimal numbers, first convert them to binary.</p>&#13;
<p class="TX">The ability to force bits to 0 or 1 by using the AND or OR operations and the ability to invert bits by using the XOR operation are very important when working with strings of bits (for example, binary numbers). These operations let you selectively manipulate certain bits within a bit string while leaving other bits unaffected.</p>&#13;
<p class="TX">For example, if you have an 8-bit binary value <i>X</i> and want to guarantee that bits 4 to 7 contain 0s, you could AND the value <i>X</i> with the binary value 0000_1111. This bitwise AND operation would force the HO 4 bits to 0 and pass the LO 4 bits of <i>X</i> unchanged. Likewise, you could force the LO bit of <i>X</i> to 1 and invert bit 2 of <i>X</i> by ORing <i>X</i> with 0000_0001 and then XORing <i>X</i> with 0000_0100.</p>&#13;
<p class="TX">Using the AND, OR, and XOR operations to manipulate bit strings in this fashion is known as <i>masking</i> bit strings, because you can use certain values (1 for AND, 0 for OR/XOR) to mask out or mask in certain bits from the operation when forcing bits to 0, 1, or their inverse. The term <i>masking</i> comes from painting. Painters use tape (masking tape) and paper to cover (<i>mask out</i>) those portions of an object they want to protect while painting. In a similar sense, programmers use 1s (with the AND operation) in bit positions they want to protect when forcing bits to 0, and they use 0s (with the OR operation) to mask bit positions they want to protect when forcing bits to 1.</p>&#13;
<p class="TX">The ARM-64 CPUs support five instructions that apply these bitwise logical operations to their operands: <span class="SANS_TheSansMonoCd_W5Regular_11">and</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">and</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> instructions use the same syntax as the <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> instructions you learned about in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>:</p>&#13;
<pre id="pre-86"><code>and   <var>dest</var>, <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">left</span>, <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">right</span>&#13;
ands  <var>dest</var>, <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">left</span>, <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">right</span>  // Affects the flags&#13;
orr   <var>dest</var>, <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">left</span>, <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">right</span>&#13;
eor   <var>dest</var>, <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">left</span>, <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">right</span>  // XOR operation</code></pre>&#13;
<p class="TX">These operands have the same limitations as the <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> operands. Specifically, the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">source</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">left</span> operand has to be a register operand, the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">source</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">right</span> operand must be a register or a constant, and the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dest</span> operand must be a register. The operands must also be the same size. You’ll see extensions to this syntax in section 2.19, <span class="Xref">“Operand2,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_106">page 106</a></span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> instructions do not have versions with the <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix. You’ll have to work around this bizarre limitation in the instruction set if you would like to test the flags after these instructions.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_62" aria-label="62"/>The immediate constant (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">source</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">right</span> operand) has a completely different set of restrictions than the immediate constants for <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span>. For more information on what constitutes legal immediate constants, see section 2.19, <span class="Xref">“Operand2,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_106">page 106</a></span>.</p>&#13;
<p class="TX">These instructions compute the obvious bitwise logical operation via the following equation:</p>&#13;
<pre id="pre-87"><code><var>dest</var> = <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">left</span> <var>operator</var> <var>source</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">right</span></code></pre>&#13;
<p class="TX">The ARM doesn’t have an actual <span class="SANS_TheSansMonoCd_W5Regular_11">not</span> instruction. Instead, a variant of the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction does the honors: <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> (move and not). This instruction takes the following form:</p>&#13;
<pre id="pre-88"><code>mvn  <var>dest</var>, <var>source</var></code></pre>&#13;
<p class="TX">Note that this instruction does not provide a form with an <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix that updates the condition code flags after its execution.</p>&#13;
<p class="TX">This instruction computes the following result:</p>&#13;
<pre id="pre-89"><code><var>dest</var> = not(<var>source</var>)</code></pre>&#13;
<p class="Continued1">The operands must both be registers.</p>&#13;
<p class="TX">The program in Listing 2-2 inputs two hexadecimal values from the user and calculates their logical AND, OR, XOR, and NOT.</p>&#13;
<pre id="pre-90"><code>// Listing2-2.S&#13;
//&#13;
// Demonstrate AND, OR, XOR, and NOT operations.&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
             .data&#13;
leftOp:      .dword     0xf0f0f0f&#13;
rightOp1:    .dword     0xf0f0f0f0&#13;
rightOp2:    .dword     0x12345678&#13;
result:      .dword     0&#13;
saveLR:      .dword     0&#13;
&#13;
titleStr:    .asciz   "Listing 2-2"&#13;
&#13;
fmtStr1:     .asciz   "%lx AND %lx = %lx\n"&#13;
fmtStr2:     .asciz   "%lx OR  %lx = %lx\n"&#13;
fmtStr3:     .asciz   "%lx XOR %lx = %lx\n"&#13;
fmtStr4:     .asciz   "NOT %lx = %lx\n"&#13;
&#13;
             .text&#13;
             .align     2   // Make code word-aligned.&#13;
&#13;
             .extern    printf&#13;
&#13;
// Return program title to C++ program:&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label="63"/>            .global     getTitle&#13;
getTitle:&#13;
&#13;
// Load address of "titleStr" into the X0 register (X0 holds the&#13;
// function return result) and return back to the caller:&#13;
&#13;
            lea     x0, titleStr&#13;
            ret&#13;
&#13;
// Here is the "asmMain" function.&#13;
&#13;
            .global asmMain&#13;
asmMain:&#13;
&#13;
// "Magic" instruction offered without explanation at this point:&#13;
&#13;
            sub     sp, sp, 64&#13;
&#13;
// Save LR so we can return to C++ code:&#13;
&#13;
            lea     x0, saveLR&#13;
            str     lr, [x0]&#13;
&#13;
// Demonstrate the AND operation:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> lea     x0, leftOp&#13;
            ldr     x1, [x0]&#13;
            lea     x0, rightOp1&#13;
            ldr     x2, [x0]&#13;
            and     x3, x1, x2  // Compute left AND right.&#13;
            lea     x0, result&#13;
            str     x3, [x0]&#13;
&#13;
            lea     x0, fmtStr1 // Print result.&#13;
            vparm2  leftOp&#13;
            vparm3  rightOp1&#13;
            vparm4  result&#13;
            bl      printf&#13;
&#13;
// Demonstrate the OR operation:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> lea     x0, leftOp&#13;
            ldr     x1, [x0]&#13;
            lea     x0, rightOp1&#13;
            ldr     x2, [x0]&#13;
            orr     x3, x1, x2  // Compute left OR right.&#13;
            lea     x0, result&#13;
            str     x3, [x0]&#13;
&#13;
            lea     x0, fmtStr2 // Print result.&#13;
            vparm2  leftOp&#13;
            vparm3  rightOp1&#13;
            vparm4  result&#13;
            bl      printf&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label="64"/>// Demonstrate the XOR operation:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> lea     x0, leftOp&#13;
            ldr     x1, [x0]&#13;
            lea     x0, rightOp1&#13;
            ldr     x2, [x0]&#13;
            eor     x3, x1, x2  // Compute left XOR right.&#13;
            lea     x0, result&#13;
            str     x3, [x0]&#13;
&#13;
            lea     x0, fmtStr3 // Print result.&#13;
            vparm2  leftOp&#13;
            vparm3  rightOp1&#13;
            vparm4  result&#13;
            bl      printf&#13;
&#13;
// Demonstrate the NOT instruction:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> lea     x0, leftOp&#13;
            ldr     x1, [x0]&#13;
            mvn     w1, w1      // W1 = not W1 (32 bits)&#13;
            lea     x0, result&#13;
            str     x1, [x0]&#13;
&#13;
            lea     x0, fmtStr4 // Print result.&#13;
            vparm2  leftOp&#13;
            vparm3  result&#13;
            bl      printf&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> lea     x0, rightOp1&#13;
            ldr     x1, [x0]&#13;
            mvn     w1, w1      // W1 = not W1 (32 bits)&#13;
            lea     x0, result&#13;
            str     x1, [x0]&#13;
&#13;
            lea     x0, fmtStr4 // Print result.&#13;
            vparm2  rightOp1&#13;
            vparm3  result&#13;
            bl      printf&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> lea     x0, rightOp2&#13;
            ldr     x1, [x0]&#13;
            mvn     w1, w1      // W1 = not W1&#13;
            lea     x0, result&#13;
            str     x1, [x0]&#13;
&#13;
            lea     x0, fmtStr4 // Print result.&#13;
            vparm2  rightOp2&#13;
            vparm3  result&#13;
            bl      printf&#13;
&#13;
// Another "magic" instruction that undoes the effect of&#13;
// the previous one before this procedure returns to its&#13;
// caller:&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label="65"/>            add     sp, sp, #64&#13;
&#13;
// Restore LR so we can return to C++ code:&#13;
&#13;
            lea     x0, saveLR&#13;
            ldr     lr, [x0]&#13;
            ret     // Returns to caller</code></pre>&#13;
<p class="TX">The code computes the logical AND <span class="CodeAnnotation" aria-label="annotation1">❶</span>, OR <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and XOR <span class="CodeAnnotation" aria-label="annotation3">❸</span> of <span class="SANS_TheSansMonoCd_W5Regular_11">leftOp</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">rightOp1</span>. It then prints the result. The code next computes the NOT of <span class="SANS_TheSansMonoCd_W5Regular_11">leftOp</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">rightOp1</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">rightOp2</span> <span class="CodeAnnotation" aria-label="annotation6">❻</span> and prints their results.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and output for the program in Listing 2-2:</p>&#13;
<pre id="pre-91"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing2-2</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing2-2</span>&#13;
Calling Listing2-2:&#13;
f0f0f0f AND f0f0f0f0 = 0&#13;
f0f0f0f OR  f0f0f0f0 = ffffffff&#13;
f0f0f0f XOR f0f0f0f0 = ffffffff&#13;
NOT f0f0f0f = f0f0f0f0&#13;
NOT f0f0f0f0 = f0f0f0f&#13;
NOT 12345678 = edcba987&#13;
Listing2-2 terminated</code></pre>&#13;
<p class="TX">As you can see, the AND operation clears bits, the OR operation sets bits, and the XOR and NOT operations invert bits.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span id="h1-25"/><span class="SANS_Futura_Std_Bold_B_11">2.6 Signed and Unsigned Numbers</span></h3>&#13;
<p class="TNI1">Thus far, this chapter has treated binary numbers as unsigned values. The binary number 0 ... 00000 represents 0, 0 ... 00001 represents 1, 0 ... 00010 represents 2, and so on toward infinity. With <i>n</i> bits, you can represent 2<i><sup>n</sup></i> unsigned numbers.</p>&#13;
<p class="TX">What about negative numbers? If you assign half of the possible combinations to the negative values, and half to the positive values and 0, with <i>n</i> bits you can represent the signed values in the range –2<i><sup>n</sup></i><sup>–1</sup> to +2<i><sup>n</sup></i><sup>–1</sup> – 1. This means you can represent the negative values –128 to –1 and the nonnegative values 0 to 127 with a single 8-bit byte. With a 16-bit half word, you can represent values in the range –32,768 to +32,767. With a 32-bit word, you can represent values in the range –2,147,483,648 to +2,147,483,647.</p>&#13;
<p class="TX">In mathematics and computer science, the <i>complement method</i> encodes negative and nonnegative (positive plus zero) numbers into two equal sets in such a way that they can use the same algorithm or hardware to perform addition and produce the correct result regardless of the sign.</p>&#13;
<p class="TX">The ARM microprocessor uses <i>two’s complement</i> notation to represent signed integers. In this system, the HO bit of a number is a <i>sign bit</i>: the integers are divided into two equal sets. If the sign bit is 0, the number is positive (or zero); if the sign bit is 1, the number is negative (taking a complement form, which I’ll describe in a moment).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label="66"/>Here are some examples of 16-bit positive and negative numbers:</p>&#13;
<div class="top">&#13;
<p class="ListPlain">0x8000 is negative because the HO bit is 1.</p>&#13;
<p class="ListPlain">0x100 is positive because the HO bit is 0.</p>&#13;
<p class="ListPlain">0x7FFF is positive.</p>&#13;
<p class="ListPlain">0xFFFF is negative.</p>&#13;
<p class="ListPlain">0xFFF is positive.</p>&#13;
</div>&#13;
<p class="TX">If the HO bit is 0, the number is positive (or zero) and uses the standard binary format. If the HO bit is 1, the number is negative and uses the two’s complement form: the magic form that supports addition of negative and nonnegative numbers with no special hardware.</p>&#13;
<p class="TX">You convert a positive number to its negative two’s complement form with the following algorithm steps:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Invert all the bits in the number; that is, apply the NOT function.</p>&#13;
<p class="ListNumber">  2.  Add 1 to the inverted result and ignore any carry out of the HO bit.</p>&#13;
</div>&#13;
<p class="TX">This produces a bit pattern that satisfies the mathematical definition of the complement form. In particular, adding negative and nonnegative numbers using this form produces the expected result.</p>&#13;
<p class="TX">For example, to compute the 8-bit equivalent of –5:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Write 5 in binary: 0000_0101.</p>&#13;
<p class="ListNumber">  2.  Invert all the bits: 1111_1010.</p>&#13;
<p class="ListNumber">  3.  Add 1 to obtain the result: 1111_1011.</p>&#13;
</div>&#13;
<p class="TX">If you take –5 and perform the two’s complement operation on it, you get your original value, 0000_0101, back again:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Take the two’s complement for –5: 1111_1011.</p>&#13;
<p class="ListNumber">  2.  Invert all the bits: 0000_0100.</p>&#13;
<p class="ListNumber">  3.  Add 1 to obtain the result 0000_0101.</p>&#13;
</div>&#13;
<p class="TX">If you add +5 and –5 together (ignoring any carry out of the HO bit), you get the expected result of 0:</p>&#13;
<pre id="pre-92"><code>     0b1111_1011     Take the two's complement for -5.&#13;
   + 0b0000_0101     Invert all the bits and add 1.&#13;
     -----------&#13;
(1)  0b0000_0000     Sum is zero, if you ignore carry.</code></pre>&#13;
<p class="TX">The following examples provide some positive and negative 16-bit signed values:</p>&#13;
<div class="top">&#13;
<p class="ListPlain">0x7FFF: +32,767, the largest 16-bit positive number</p>&#13;
<p class="ListPlain">0x4000: +16,384</p>&#13;
<p class="ListPlain">0x8000: –32,768, the smallest 16-bit negative number</p>&#13;
</div>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label="67"/>To convert the preceding numbers to their negative counterpart (that is, to negate them), do the following:</p>&#13;
<pre id="pre-93"><code>0x7FFF: 0b0111_1111_1111_1111   +32,767&#13;
        0b1000_0000_0000_0000   Invert all the bits (8000h).&#13;
        0b1000_0000_0000_0001   Add 1 (8001h or -32,767).&#13;
x04000: 0b0100_0000_0000_0000   16,384&#13;
        0b1011_1111_1111_1111   Invert all the bits (0BFFFh).&#13;
        0b1100_0000_0000_0000   Add 1 (0C000h or -16,384).&#13;
0x8000: 0b1000_0000_0000_0000   -32,768&#13;
        0b0111_1111_1111_1111   Invert all the bits (7FFFh).&#13;
        0b1000_0000_0000_0000   Add 1 (8000h or -32,768).</code></pre>&#13;
<p class="TX">0x8000 inverted becomes 0x7FFF. After adding 1, you obtain 0x8000! Wait, what’s going on here? –(–32,768) is –32,768? Of course not. But the value +32,768 cannot be represented with a 16-bit signed number, so you cannot negate the smallest negative value.</p>&#13;
<p class="TX">Usually, you won’t need to perform the two’s complement operation by hand. The ARM microprocessor provides an instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">neg</span> (negate), that performs this operation for you:</p>&#13;
<pre id="pre-94"><code>neg  <var>dest</var>, <var>source</var>&#13;
negs <var>dest</var>, <var>source</var>  // Sets condition code flags</code></pre>&#13;
<p class="TX">This instruction computes <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dest</span> = <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">-source</span>, and the operands must be registers. Because this is a signed integer operation, it only makes sense to operate on signed integer values. Listing 2-3 demonstrates the two’s complement operation and the <span class="SANS_TheSansMonoCd_W5Regular_11">neg</span> instruction on signed 32-bit integer values.</p>&#13;
<pre id="pre-95"><code>// Listing2-3.S&#13;
//&#13;
// Demonstrates two's complement operation and input of&#13;
// numeric values&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .equ        maxLen, 256&#13;
&#13;
            .data&#13;
titleStr:   .asciz      "Listing 2-3"&#13;
&#13;
prompt1:    .asciz      "Enter an integer between 0 and 127:"&#13;
fmtStr1:    .asciz      "Value in hexadecimal: %x\n"&#13;
fmtStr2:    .asciz      "Invert all the bits (hexadecimal): %x\n"&#13;
fmtStr3:    .asciz      "Add 1 (hexadecimal): %x\n"&#13;
fmtStr4:    .asciz      "Output as signed integer: %d\n"&#13;
fmtStr5:    .ascii      "Negate again and output as signed integer:"&#13;
            .asciz      " %d\n"&#13;
&#13;
fmtStr6:    .asciz      "Using neg instruction: %d\n"&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_68" aria-label="68"/>intValue:   .dword      0&#13;
saveLR:     .dword      0&#13;
&#13;
&#13;
// The following reserves 256 bytes of storage to hold a string&#13;
// read from the user.&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> input:      .space      maxLen, 0&#13;
&#13;
            .text&#13;
            .align      2&#13;
            .extern     printf&#13;
            .extern     atoi&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> .extern     readLine&#13;
&#13;
// Return program title to C++ program:&#13;
&#13;
            .global     getTitle&#13;
getTitle:&#13;
            lea         x0, titleStr&#13;
            ret&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            .global     asmMain&#13;
asmMain:&#13;
&#13;
// "Magic" instruction offered without explanation at this point:&#13;
&#13;
            sub     sp, sp, #128&#13;
&#13;
// Save LR so we can return to C++ program:&#13;
&#13;
            lea     x0, saveLR&#13;
            str     lr, [x0]&#13;
&#13;
// Read an unsigned integer from the user: this code will blindly&#13;
// assume that the user's input was correct. The atoi function&#13;
// returns zero if there was some sort of error on the user&#13;
// input. Later chapters in AoAA will describe how to check for&#13;
// errors from the user.&#13;
&#13;
            lea     x0, prompt1&#13;
            bl      printf&#13;
&#13;
            lea     x0, input&#13;
            mov     x1, #maxLen&#13;
            bl      readLine&#13;
&#13;
// Call C stdlib strtol function:&#13;
//&#13;
// i = strtol(str, NULL, 10)&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label="69"/>          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> lea     x0, input&#13;
            mov     x1, xzr&#13;
            mov     x2, #10&#13;
            bl      strtol&#13;
            lea     x1, intValue&#13;
            str     x0, [x1]&#13;
&#13;
// Print the input value (in decimal) as a hexadecimal number:&#13;
&#13;
            lea     x0, fmtStr1&#13;
            vparm2  intValue&#13;
            bl      printf&#13;
&#13;
// Perform the two's complement operation on the input number.&#13;
// Begin by inverting all the bits:&#13;
&#13;
            lea     x1, intValue&#13;
            ldr     x0, [x1]&#13;
            mvn     x0, x0      // Not X0&#13;
            str     x0, [x1]    // Store back into intValue.&#13;
            lea     x0, fmtStr2&#13;
            vparm2  intValue&#13;
            bl      printf&#13;
&#13;
// Invert all the bits and add 1 (inverted value is in intValue):&#13;
&#13;
            lea     x0, intValue&#13;
            ldr     x1, [x0]&#13;
            add     x1, x1, #1&#13;
            str     x1, [x0]    // Store back into intValue.&#13;
            lea     x0, fmtStr3&#13;
            vparm2  intValue&#13;
            bl      printf&#13;
&#13;
            lea     x0, fmtStr4 // Output as integer rather&#13;
            vparm2  intValue    // than hexadecimal.&#13;
            bl      printf&#13;
&#13;
// Negate the value and print as a signed integer. Note that&#13;
// intValue already contains the negated value, so this code&#13;
// will print the original value:&#13;
&#13;
            lea     x0, intValue&#13;
            ldr     x1, [x0]&#13;
            mvn     x1, x1&#13;
            add     x1, x1, #1&#13;
            str     x1, [x0]&#13;
            lea     x0, fmtStr5&#13;
            vparm2  intValue&#13;
            bl      printf&#13;
&#13;
// Negate the value using the neg instruction:&#13;
&#13;
            lea     x0, intValue&#13;
            ldr     x1, [x0]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label="70"/>            neg     x1, x1&#13;
            str     x1, [x0]&#13;
            lea     x0, fmtStr6&#13;
            vparm2  intValue&#13;
            bl      printf&#13;
&#13;
// Another "magic" instruction that undoes the effect of the&#13;
// previous one before this procedure returns to its caller:&#13;
&#13;
            lea     x0, saveLR&#13;
            ldr     lr, [x0]&#13;
            add     sp, sp, #128&#13;
            ret     // Returns to caller</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">.space</span> directive <span class="CodeAnnotation" aria-label="annotation1">❶</span> is new in this chapter. This directive reserves a buffer (array of bytes). The first operand specifies the number of bytes to reserve, and the second operand specifies the value to assign to each byte in the buffer. This particular directive sets aside 256 bytes to hold a line of text to be input by the user. We’ll discuss arrays and memory allocation for arrays further in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">readLine</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> is supplied by the C++ code in the <i>c.cpp</i> source file. This function expects two parameters: the address of a buffer in the X0 register and a maximum input count in the X1 register (including room for a zero-terminating byte). When called, this function will read a line of text from the standard input device and place those characters in the specified buffer (zero-terminating, and truncating if the input is greater than the value passed in X1).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">strtol</span> function <span class="CodeAnnotation" aria-label="annotation3">❸</span> is a C stdlib function that will convert a string of characters, presumably containing numeric digits, into long integer form (64 bits). This function expects three arguments: X0 contains the address of a buffer (containing the string to convert); X1 points at the end of the numeric string, or is ignored if it contains NULL (0); and X2 contains the radix (base) for the conversion. The function returns the converted value in the X0 register.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and program output for Listing 2-3 (I supplied <span class="SANS_TheSansMonoCd_W5Regular_11">123</span> as the input for this particular run of the program):</p>&#13;
<pre id="pre-96"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing2-3</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing2-3</span>&#13;
Calling Listing2-3:&#13;
Enter an integer between 0 and 127:123&#13;
Value in hexadecimal: 7b&#13;
Invert all the bits (hexadecimal): ffffff84&#13;
Add 1 (hexadecimal): ffffff85&#13;
Output as signed integer: -123&#13;
Negate again and output as signed integer: 123&#13;
Using neg instruction: -123&#13;
Listing2-3 terminated</code></pre>&#13;
<p class="TX">As you can see, this program reads an integer value in decimal format from the user, inverts the bits, adds 1 (the two’s complement operation), and then displays the result.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label="71"/>&#13;
<h3 class="H1" id="sec20"><span id="h1-26"/><span class="SANS_Futura_Std_Bold_B_11">2.7 Sign Extension and Zero Extension</span></h3>&#13;
<p class="TNI1">Converting a small two’s complement value to a larger number of bits can be accomplished via <i>sign extension</i> operations.</p>&#13;
<p class="TX">To extend a signed value from a certain number of bits to a greater number of bits, copy the sign bit into all the additional bits in the new format. For example, to sign-extend an 8-bit number to a 16-bit number, copy bit 7 of the 8-bit number into bits 8 to 15 of the 16-bit number. To sign-extend a 16-bit half word to a word, copy bit 15 into bits 16 to 31 of the word. Likewise, to sign-extend a 32-bit word into a 64-bit double word, copy bit 31 from the word through the upper 32 bits of the double word.</p>&#13;
<p class="TX">You must use sign extension when manipulating signed values of varying lengths. For example, to add a signed byte quantity to a word quantity, you must sign-extend the byte quantity to a word before adding the two values. Other operations (multiplication and division, in particular) may require a sign extension to 32 bits. <a href="chapter2.xhtml#tab2-6">Table 2-6</a> provides several examples of sign extension.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-6"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-6:</span></span> <span class="SANS_Futura_Std_Book_11">Examples of Sign Extension</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">8 bits</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">16 bits</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">32 bits</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x80</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFF80</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFFFFFF80</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x28</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x0028</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x00000028</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x9A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFF9A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFFFFFF9A</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x7F</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x007F</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x0000007F</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x1020</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x00001020</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x8086</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFFFF8086</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">To extend an unsigned value to a larger one, you must <i>zero-extend</i> the value. Zero extension is easy—just store a zero into the HO byte(s) of the larger operand. For example, to zero-extend the 8-bit value 0x82 to 16 bits, prepend a zero to the HO byte, yielding 0x0082. <a href="chapter2.xhtml#tab2-7">Table 2-7</a> provides several zero-extension examples.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-7"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-7:</span></span> <span class="SANS_Futura_Std_Book_11">Examples of Zero Extension</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">8 bits</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">16 bits</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">32 bits</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x80</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x0080</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x00000080</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x28</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x0028</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x00000028</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x9A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x009A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x0000009A</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x7F</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x007F</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x0000007F</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x1020</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x00001020</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">—</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x8086</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x00008086</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label="72"/>You can zero-extend to double or quad words by using this same approach.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h3 class="H1" id="sec21"><span id="h1-27"/><span class="SANS_Futura_Std_Bold_B_11">2.8 Sign Contraction and Saturation</span></h3>&#13;
<p class="TNI1"><i>Sign contraction</i>, converting a value with a certain number of bits to the identical value with a fewer number of bits, is a little more difficult. You cannot always convert a given <i>n</i>-bit number to an <i>m</i>-bit number if <i>m</i> &lt; <i>n</i>. For example, consider the value –448. As a 16-bit signed number, its hexadecimal representation is 0xFE40. The magnitude of this number is too large for an 8-bit value, so you cannot sign-contract it to 8 bits; doing so would create an overflow condition.</p>&#13;
<p class="TX">To properly sign-contract a value, the HO bits to discard must all contain either 0 or 1, and the HO bit of your resulting value must match <i>every</i> bit you’ve removed from the number. Here are some examples (16 bits to 8 bits):</p>&#13;
<div class="top">&#13;
<p class="ListPlain">0xFF80 can be sign-contracted to 0x80.</p>&#13;
<p class="ListPlain">0x0040 can be sign-contracted to 0x40.</p>&#13;
<p class="ListPlain">0xFE40 cannot be sign-contracted to 8 bits.</p>&#13;
<p class="ListPlain">0x0100 cannot be sign-contracted to 8 bits.</p>&#13;
</div>&#13;
<p class="TX">If you must convert a larger object to a smaller object, and you’re willing to live with loss of precision, you can use <i>saturation</i>. To convert a value via saturation, copy the larger value to the smaller value if it is not outside the range of the smaller object. If the larger value is outside the range of the smaller value, <i>clip</i> the value by setting it to the largest (or smallest) value within the range of the smaller object.</p>&#13;
<p class="TX">For example, when converting a 16-bit signed integer to an 8-bit signed integer, if the 16-bit value is in the range –128 to +127, you copy the LO byte of the 16-bit object to the 8-bit object. If the 16-bit signed value is greater than +127, you clip the value to +127 and store +127 into the 8-bit object. Likewise, if the value is less than –128, you clip the final 8-bit object to –128.</p>&#13;
<p class="TX">Although clipping the value to the limits of the smaller object results in loss of precision, this is sometimes acceptable because the alternative is to raise an exception or otherwise reject the calculation. For many applications, such as audio or video processing, the clipped result is still recognizable, so the conversion is a reasonable choice.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h3 class="H1" id="sec22"><span id="h1-28"/><span class="SANS_Futura_Std_Bold_B_11">2.9 Loading and Storing Byte and Half-Word Values</span></h3>&#13;
<p class="TNI1">Memory on the ARM is byte-addressable. Up to this point, however, all loads and stores in this book have been either word or dword operations (determined by the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">str</span> register’s size). Fear not: the ARM CPU provides instructions for loading and storing bytes, half words, words, double words, and even quad words.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_73" aria-label="73"/>The generic <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction takes the following forms:</p>&#13;
<pre id="pre-97"><code>ldr    <var>reg</var>, <var>mem</var>&#13;
ldrb   <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">32</span>, <var>mem</var>&#13;
ldrsb  <var>reg</var>, <var>mem</var>&#13;
ldrh   <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">32</span>, <var>mem</var>&#13;
ldrsh  <var>reg</var>, <var>mem</var>&#13;
ldrsw  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span>, <var>mem</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">32</span> operands can be only 32-bit registers, and the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">64</span> operand can be only a 64-bit register. The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span> (no subscript) operands can be 32- or 64-bit registers.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ldrb</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ldrsb</span> instructions load a byte from memory into the destination register. Since the register is always 32 or 64 bits wide, the byte from memory must be extended in some fashion when it is loaded into the register. The <span class="SANS_TheSansMonoCd_W5Regular_11">ldrb</span> instruction zero-extends the byte from memory into the register. The <span class="SANS_TheSansMonoCd_W5Regular_11">ldrsb</span> instruction sign-extends the memory byte into the register. Zero extension works only with 32-bit registers, but the <span class="SANS_TheSansMonoCd_W5Regular_11">ldrb</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ldrh</span> instructions will automatically zero out the HO 32 bits of the corresponding 64-bit register. If you sign-extend a byte or half word into a 32-bit register, this will zero out the HO 32 bits of the corresponding 64-bit register. Specify a 64-bit register if you want to sign-extend the byte or half word throughout the 64-bit register.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ldrh</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ldrsh</span> instructions similarly load and extend a half-word value from memory by using zero extension (<span class="SANS_TheSansMonoCd_W5Regular_11">ldrh</span>) and sign extension (<span class="SANS_TheSansMonoCd_W5Regular_11">ldrsh</span>). As before, the <span class="SANS_TheSansMonoCd_W5Regular_11">ldrh</span> instruction accepts a 32-bit register, but it will automatically zero-extend throughout the full 64 bits of the register.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ldrsw</span> instruction will fetch a 32-bit signed integer from memory and sign-extend it into the 64-bit register specified as the destination. No explicit instruction zero-extends from 32 to 64 bits; the standard <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction, with a 32-bit register operand, will automatically do this.</p>&#13;
<p class="TX">Note that <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mem</span> operands consisting only of a label (PC-relative addressing) are valid only for the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ldrsw</span> instructions. The other instructions allow only register-based addressing modes (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">[X0]</span>).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ldr{</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span><span class="SANS_TheSansMonoCd_W5Regular_11">}</span> instructions work well for loading and extending byte, half-word, and word values from memory. If the value to extend is sitting in another register, you don’t want to have to store that register in memory, so you can extend the value into a different register. Fortunately, the ARM provides a set of instructions, <span class="SANS_TheSansMonoCd_W5Regular_11">sxtb</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sxth</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">sxtw</span>, specifically for this situation:</p>&#13;
<pre id="pre-98"><code>sxtb <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src</span>  // Sign-extends LO byte of <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src</span>&#13;
sxth <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src</span>  // Sign-extends LO half word of <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src</span>&#13;
sxtw <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src</span>  // Sign-extends LO word of <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src</span></code></pre>&#13;
<p class="Continued1">The <span class="SANS_TheSansMonoCd_W5Regular_11">sxtw</span> instruction requires a 64-bit destination register. The <span class="SANS_TheSansMonoCd_W5Regular_11">sxtb</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sxth</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">sxtw</span> instructions require 32-bit source registers, regardless of the destination register size.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_74" aria-label="74"/>The ARM does not provide any explicit instructions for zero-extending one register into another. However, you can use some tricks to achieve the same result. Whenever you move data from one register into a 32-bit register, the ARM automatically zeros out the HO 32 bits of the corresponding destination 64-bit register. You can use this behavior to zero-extend any smaller value to a larger value.</p>&#13;
<p class="TX">The following instruction copies W<i>m</i> into W<i>n</i> and clears the HO 32 bits of X<i>n</i> in the process:</p>&#13;
<pre id="pre-99"><code>mov  w<var>n</var>, w<var>m</var>  // Zero-extends 32-bit W<var>m</var> into X<var>n</var></code></pre>&#13;
<p class="TX">The following instruction ANDs the value in W<i>m</i> with 0xFFFF and then stores the result into W<i>n</i>, zero-extending throughout the HO bits of X<i>n</i>:</p>&#13;
<pre id="pre-100"><code>and  w<var>n</var>, w<var>m</var>, #0xFFFF  // Zero-extends 16 bits to 64</code></pre>&#13;
<p class="TX">And, finally, the following instruction zero-extends the LO byte of W<i>m</i> through X<i>n</i>:</p>&#13;
<pre id="pre-101"><code>and  w<var>n</var>, w<var>m</var>, #0xFF  // Zero-extends 8 bits to 64</code></pre>&#13;
<p class="TX">Storing bytes and half words to memory is much simpler than loading. The ARM doesn’t support contraction or saturation while storing to memory. Therefore, the byte and half-word store instructions take the following two forms:</p>&#13;
<pre id="pre-102"><code>strb <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">32</span>, <var>mem</var>&#13;
strh <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">32</span>, <var>mem</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">strb</span> instruction stores the LO byte of the specified register to memory. The <span class="SANS_TheSansMonoCd_W5Regular_11">strh</span> instruction stores the LO half word of the register to memory. The register must be a 32-bit register (if you want to store the LO byte or half word of a 64-bit register, simply specify the 32-bit register instead; this does the same thing). Note that <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mem</span> must be a register-based addressing mode (these instructions do not allow the PC-relative addressing mode).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h3 class="H1" id="sec23"><span id="h1-29"/><span class="SANS_Futura_Std_Bold_B_11">2.10 Control-Transfer Instructions</span></h3>&#13;
<p class="TNI1">The assembly language examples thus far have limped along without making use of <i>conditional execution</i>, or the ability to make decisions while executing code. Indeed, except for the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instructions, I haven’t covered any ways to affect the straight-line execution of assembly code. However, to provide meaningful examples for the remainder of this book, you’ll soon need the ability to conditionally execute sections of code. Taking a brief detour from load and store instructions, this section provides a brief introduction to the subject of conditional execution and transferring control to other sections of your program.</p>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_75" aria-label="75"/>&#13;
<h4 class="H2" id="sec24"><span id="h2-31"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.10.1 Branch</span></h4>&#13;
<p class="TNI1">Perhaps the best place to start is with a discussion of the ARM unconditional control-transfer instruction: the <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> instruction. The <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> instruction takes the form</p>&#13;
<pre id="pre-103"><code>b <var>statementLabel</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">statementLabel</span> is an identifier attached to a machine instruction in your <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section. The <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> instruction immediately transfers control to the statement prefaced by the label. This is semantically equivalent to a <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span> statement in an HLL.</p>&#13;
<p class="TX">Here is an example of a statement label in front of a <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction:</p>&#13;
<pre id="pre-104"><code>stmtLbl: mov x0, #55</code></pre>&#13;
<p class="TX">Like all Gas symbols, statement labels have an address associated with them: the memory address of the machine instruction following the label.</p>&#13;
<p class="TX">Statement labels don’t have to be on the same physical source line as a machine instruction. Consider the following example:</p>&#13;
<pre id="pre-105"><code>anotherLabel:&#13;
   mov x0, #55</code></pre>&#13;
<p class="TX">This example is semantically equivalent to the previous one. The value (address) bound to <span class="SANS_TheSansMonoCd_W5Regular_11">anotherLabel</span> is the address of the machine instruction following the label. In this case, it’s still the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction, even though that <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction appears on the next line (it still follows the label without any other Gas statements that would generate code occurring between the label and the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> statement).</p>&#13;
<aside class="box" aria-label="box-6">&#13;
<p class="BH" id="box-6"><span class="SANS_Dogma_OT_Bold_B_11">B IS FOR BAD</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">The letter</span> <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> <span class="SANS_Futura_Std_Book_11">is an incredibly bad choice for an instruction mnemonic. The fact that it looks like a single-letter variable name, most of the time, makes reading both code and this book more difficult. For a while, I considered creating the following CPP macro to allow me to use</span> <span class="SANS_TheSansMonoCd_W5Regular_11">bra</span> <span class="SANS_Futura_Std_Book_11">rather than</span> <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> <span class="SANS_Futura_Std_Book_11">in this book:</span></p>&#13;
<pre id="pre-106"><code>#define bra b</code></pre>&#13;
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">Ultimately, my concern that some people would prefer to use the “official” mnemonic prevented me from doing this. However, you can use this trick on your own to write more readable code.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">The ARM supports a special version of the conditional branch:</span> <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> <span class="SANS_Futura_Std_Book_11">(branch always). This instruction is an unconditional branch to the target location. The main drawback to using</span> <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> <span class="SANS_Futura_Std_Book_11">is that it is limited to a ±1MB range (like the other</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_76" aria-label="76"/><span class="SANS_Futura_Std_Book_11">conditional branches), while the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> <span class="SANS_Futura_Std_Book_11">instruction supports a ±128MB range. However, the ±1MB range is sufficient for most cases. This book favors using the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> <span class="SANS_Futura_Std_Book_11">mnemonic because it is more readable. If you prefer, feel free to substitute</span> <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> <span class="SANS_Futura_Std_Book_11">for</span> <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> <span class="SANS_Futura_Std_Book_11">in your own code (or, better yet, use the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">bra</span> <span class="SANS_Futura_Std_Book_11">macro I described).</span></p>&#13;
</aside>&#13;
<p class="TX">Technically, you could also jump to a procedure label instead of a statement label. However, the <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> instruction does not set up a return address; if the procedure executes a <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction, the return location may be undefined. <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> explores return addresses in greater detail.</p>&#13;
<p class="TX">Because <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> is a poor name for an instruction mnemonic (as we just discussed in <span class="Xref">“B Is for Bad”</span>), this book will use the <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction when branching to code within the current source file and reserve <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> for those rare instances when branching to code outside a ±1MB range.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h2-32"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.10.2 Instructions That Affect the Condition Code Flags</span></h4>&#13;
<p class="TNI1">When presenting the <span class="SANS_TheSansMonoCd_W5Regular_11">add</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">and</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">neg</span> instructions, I pointed out that they typically take two forms:</p>&#13;
<pre id="pre-107"><code><var>instr</var>   <var>operands</var>&#13;
<var>instrs</var>  <var>operands</var>  // Only adds, subs, ands, and negs</code></pre>&#13;
<p class="TX">The form with the <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix (<span class="SANS_TheSansMonoCd_W5Regular_11">adds</span>, for example) will update the condition code flags in the PSTATE register after the instruction completes. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instructions will do the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Set the carry flag if an unsigned overflow occurs during the arithmetic operation and clear it otherwise.</li>&#13;
<li class="BL">Set the overflow flag if a signed overflow occurs.</li>&#13;
<li class="BL">Set the zero flag if the operation produces a zero result.</li>&#13;
<li class="BL">Set the negative (sign) flag if the operation produces a negative result (HO bit is set).</li>&#13;
</ul>&#13;
<p class="TX">While not all instructions support the <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix, many that perform some sort of calculation will allow this suffix. By allowing you to select which instructions affect the flags, the ARM CPU allows you to preserve the condition codes across the execution of some instructions whose effect on the flags you want to ignore.</p>&#13;
<p class="TX">As their name suggests, these condition codes allow you to test for certain conditions and conditionally execute code based on those tests. The next section describes how you can test the condition code flags and make decisions based on their settings.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_77" aria-label="77"/>&#13;
<h4 class="H2" id="sec26"><span id="h2-33"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.10.3 Conditional Branch</span></h4>&#13;
<p class="TNI1">Although the <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">b</span> instruction is indispensable in assembly language programs, it doesn’t provide any ability to conditionally execute sections of code—hence the name <i>unconditional branch</i>. Fortunately, the ARM CPUs provide a wide array of <i>conditional branch instructions</i> that allow conditional execution of code.</p>&#13;
<p class="TX">These instructions test the condition code bits in the PSTATE register to determine whether a branch should be taken. There are four condition code bits in the PSTATE register that these conditional jump instructions test: the carry, sign, overflow, and zero flags.</p>&#13;
<p class="TX">The ARM CPUs provide eight instructions that test each of these four flags, as shown in <a href="chapter2.xhtml#tab2-8">Table 2-8</a>. The basic operation of the conditional jump instructions is to test a flag to see whether it is set (1) or clear (0) and branch to a target label if the test succeeds. If the test fails, the program continues execution with the next instruction following the conditional jump instruction.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-8"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-8:</span></span> <span class="SANS_Futura_Std_Book_11">Conditional Branch Instructions That Test the Condition Code Flags</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Instruction</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Explanation</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bcs</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if carry is set. Jump to</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> <span class="SANS_Futura_Std_Book_11">if the carry flag is set (1); control falls through to the next instruction if the carry is clear (0).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bcc</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if carry is clear. Jump to</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> <span class="SANS_Futura_Std_Book_11">if the carry flag is clear (0); fall through if the carry is set (1).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bvs</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if overflow set. Jump to</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> <span class="SANS_Futura_Std_Book_11">if the overflow flag is set (1); fall through if the overflow is clear (0).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bvc</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if overflow clear. Jump to</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> <span class="SANS_Futura_Std_Book_11">if the overflow flag is clear (0); fall through if the overflow is set (1).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bmi</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if minus. Jump to</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> <span class="SANS_Futura_Std_Book_11">if the negative (sign) flag is set (1); fall through if the sign is clear (0).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bpl</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if positive (or zero). Jump to</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> <span class="SANS_Futura_Std_Book_11">if the negative flag is clear (0); fall through if the sign is set (1).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">beq</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if equal. Jump to</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> <span class="SANS_Futura_Std_Book_11">if the zero flag is set (1); fall through if zero is clear (0).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bne</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not equal. Jump to</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> <span class="SANS_Futura_Std_Book_11">if the zero flag is clear (0); fall through if zero is set (1).</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">For historical reasons, Gas also allows conditional branch mnemonics of the form <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>.<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">condition</span> (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">b.cs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">b.cc</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">b.vs</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">b.vc</span>). This form is based on the 32-bit ARM instruction set that allowed conditional execution of most data-processing instructions by using a “dot condition” suffix. While the 64-bit ARM instruction set no longer supports these conditional instructions, it does allow the dot condition syntax for the branch instruction. Since it’s easier to type the conditional branches without the period, most people use that form when writing 64-bit ARM assembly language with Gas. Gas under Linux does not seem to support <span class="SANS_TheSansMonoCd_W5Regular_11">bal</span> but does support <span role="doc-pagebreak" epub:type="pagebreak" id="pg_78" aria-label="78"/><span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span>, and the macOS assembler seems to support <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> just fine. That’s why this book uses <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> for unconditional branches.</p>&#13;
<p class="TX">To use a conditional branch instruction, you must first execute an instruction that affects one or more of the condition code flags. For example, an unsigned arithmetic overflow will set the carry flag; if overflow does not occur, the carry flag will be clear. Therefore, you could use the <span class="SANS_TheSansMonoCd_W5Regular_11">bcs</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bcc</span> instructions after an <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> instruction to see whether an unsigned overflow occurred during the calculation. For example, the following code checks for unsigned overflow by using <span class="SANS_TheSansMonoCd_W5Regular_11">bcs</span>:</p>&#13;
<pre id="pre-108"><code>    lea  x0, int32Var&#13;
    ldr  w0, [x0]&#13;
    lea  x1, anotherVar&#13;
    ldr  w1, [x1]&#13;
    adds w0, w0, w1&#13;
    bcs  overflowOccured&#13;
&#13;
// Continue down here if the addition did not&#13;
// produce an overflow.&#13;
&#13;
    .&#13;
    .&#13;
    .&#13;
&#13;
overflowOccured:&#13;
&#13;
// Execute this code if the sum of int32Var and anotherVar&#13;
// does not fit into 32 bits.</code></pre>&#13;
<p class="TX">As noted earlier, <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> (and <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">negs</span>) sets the condition codes based on signed/unsigned overflow, a zero result, or a negative result. The <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction copies the HO bit of its result into the negative flag and sets/clears the zero flag if it produces a zero/nonzero result.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h2-34"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.10.4 cmp and Corresponding Conditional Branches</span></h4>&#13;
<p class="TNI1">The ARM <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction is extremely useful in conjunction with the conditional branches. The syntax for <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> is</p>&#13;
<pre id="pre-109"><code>cmp <var>left</var>, <var>right</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">left</span> is a register (32 or 64 bits) and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">right</span> is either a register or a small immediate constant. The instruction compares the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">left</span> operand to the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">right</span> operand and sets the flags based on the comparison. You can then use the conditional branch instructions to transfer control based on the result of the comparison.</p>&#13;
<p class="TX">Although <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> does not have an <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix, it will set the condition code flags; indeed, that’s why <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> exists. Technically, <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> isn’t a real instruction, but rather an alias (synonym) for the <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction with a destination operand of WZR or XZR.</p>&#13;
<aside class="box" aria-label="box-7">&#13;
<p class="BH" id="box-7"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_79" aria-label="79"/><span class="SANS_Dogma_OT_Bold_B_11">PSEUDO-INSTRUCTIONS (ALIASES) AND BUILT-IN MACROS</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">You’ll often discover that two ARM64 assembly language instructions do exactly the same operation. Consider, for example, the following two instructions:</span></p>&#13;
<pre id="pre-110"><code>cmp x0, x1&#13;
subs xzr, x0, x1</code></pre>&#13;
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">The first instruction compares X0 to X1 and sets the condition code flags. The second instruction subtracts X1 from X0, sets the condition code flags, and then throws the result away (whenever you store a value into the zero register—WZR or XZR—the result is lost). The comparison operation is exactly equivalent to subtraction if you don’t keep the difference (which is exactly what the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> <span class="SANS_Futura_Std_Book_11">instruction is doing), meaning these two instructions do exactly the same thing.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">The ARM’s designers noticed this semantic equivalence between many of their instructions and decided, “This is a RISC machine; we should not include extra hardware to handle redundant instructions.” As they already had the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> <span class="SANS_Futura_Std_Book_11">instruction, they basically threw out the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">instruction.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">You may be thinking, “Didn’t you discuss the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">instruction already?” Yes, I did. But I lied: this isn’t actually a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">machine instruction. When the assembler accepts and executes a mnemonic named</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">that does everything you’d expect a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">instruction to do, under the covers Gas has actually translated that</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">instruction into a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> <span class="SANS_Futura_Std_Book_11">instruction.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">The</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">instruction is an example of a</span> <span class="SANS_Futura_Std_Book_Oblique_11">pseudo-instruction</span><span class="SANS_Futura_Std_Book_11">, a macro built into Gas (and most other ARM assemblers) that automatically translates</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">into the corresponding</span> <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> <span class="SANS_Futura_Std_Book_11">instruction. In fact, a fair number of ARM instructions fall into this same category.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">In this book, we won’t worry about whether an instruction is real or pseudo. The semantics are the important aspect, not the particular assembly language syntax. If the assembler contains (standardized) built-in macros to help you write clearer code, so much the better. This section exists just to let you know what is going on if you read about pseudo-instructions elsewhere or if you look at a disassembled listing of your code and the instructions have changed from what you actually wrote.</span></p>&#13;
</aside>&#13;
<p class="TX">After executing a compare instruction, you might ask these reasonable questions:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Is the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">leftOperand</span> equal to the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rightOperand</span>?</li>&#13;
<li class="BL">Is the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">leftOperand</span> not equal to the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rightOperand</span>?</li>&#13;
<li class="BL">Is the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">leftOperand</span> less than the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rightOperand</span>?</li>&#13;
<li class="BL">Is the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">leftOperand</span> less than or equal to the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rightOperand</span>?</li>&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_80" aria-label="80"/>Is the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">leftOperand</span> greater than the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rightOperand</span>?</li>&#13;
<li class="BL">Is the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">leftOperand</span> greater than or equal to the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rightOperand</span>?</li>&#13;
</ul>&#13;
<p class="TX">For less-than and greater-than comparisons, you might also ask, “Are these signed or unsigned comparisons?”</p>&#13;
<p class="TX">The ARM provides conditional branches to use after executing <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> that answer these questions. <a href="chapter2.xhtml#tab2-9">Table 2-9</a> lists these instructions for unsigned comparisons.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-9"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-9:</span></span> <span class="SANS_Futura_Std_Book_11">Unsigned Conditional Branches</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Instruction</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Flag(s) tested</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">beq</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Z = 1</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if equal; fall through if not equal. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is equal to the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bne</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Z = 0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not equal; fall through if equal. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is not equal to the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bhi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">C = 1 and Z = 0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if higher; fall through if not higher. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is greater than the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bhs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">C = 1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if higher or same; fall through if not higher or same. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is greater than or equal the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">blo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">C = 0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if lower; fall through if not lower. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is less than the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bls</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">C = 0 or Z = 1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if lower or same; fall through if not lower or same. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is less than or equal to the second operand.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">If the left and right operands contain signed integer values, use the signed branches in <a href="chapter2.xhtml#tab2-10">Table 2-10</a>.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-10"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-10:</span></span> <span class="SANS_Futura_Std_Book_11">Signed Conditional Branches</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Instruction</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Flag(s) tested</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">beq</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Z = 1</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if equal; fall through if not equal. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is equal to the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bne</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Z = 0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not equal; fall through if equal. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is not equal to the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bgt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Z = 0 and N = V</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if greater than; fall through if less than or equal. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is greater than the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N = V</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if greater than or equal; fall through if less than. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is greater than or equal to the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">blt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N ≠ V</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if less than; fall through if greater than or equal. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is less than the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ble</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N ≠ V or Z = 1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if less than or equal; fall through if greater than. After a comparison, this branch will be taken if the first</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">operand is less than or equal to the second operand.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_81" aria-label="81"/>As for the earlier branches based on condition codes, Gas allows branches of the form <span class="SANS_TheSansMonoCd_W5Regular_11">b.</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">condition</span> in addition to the forms in <a href="chapter2.xhtml#tab2-9">Tables 2-9</a> and <a href="chapter2.xhtml#tab2-10">2-10</a>. As it turns out, as shown in the “Flag(s) tested” columns, the <span class="SANS_TheSansMonoCd_W5Regular_11">bcs</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bhs</span> instructions are synonyms, as are the <span class="SANS_TheSansMonoCd_W5Regular_11">bcc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">blo</span> instructions.</p>&#13;
<p class="TX">Importantly, the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction sets the flags only for integer comparisons, which will also cover characters and other types you can encode with an integer value. Specifically, the instruction does not compare floating-point values and set the flags as appropriate for a floating-point comparison.</p>&#13;
<p class="TX">Sometimes it’s convenient to branch on an opposite condition. For example, you might have the following logic:</p>&#13;
<pre id="pre-111"><code>    cmp x0, x1&#13;
    // Branch to geLbl if X0 is not less than X1.&#13;
&#13;
    // Fall through to this code if X0 &lt; X1.&#13;
     .&#13;
     .&#13;
     .&#13;
// Branch here if NOT(X0 &lt; X1) (that is, X0 &gt;= X1).&#13;
geLbl:</code></pre>&#13;
<p class="TX">Of course, the opposite of <i>less than</i> is <i>greater than or equal</i>, so this pseudocode could be written as follows:</p>&#13;
<pre id="pre-112"><code>    cmp x0, x1&#13;
    bge geLbl&#13;
&#13;
    // Fall through to this code if X0 &lt; X1.&#13;
     .&#13;
     .&#13;
     .&#13;
// Branch here if NOT(X0 &lt; X1) (that is, X0 &gt;= X1).&#13;
geLbl:</code></pre>&#13;
<p class="TX">However, using opposite branches to skip around the code you want to execute on a condition (such as less than) can make your code harder to read. People generally read the <span class="SANS_TheSansMonoCd_W5Regular_11">bge</span> instruction as “branch to a label because the comparison produced greater than or equal,” not as “fall through if the comparison result was less than.”</p>&#13;
<p class="TX">To help make such logic clearer, the <i>aoaa.inc</i> include file contains macros for several <i>opposite branches</i>. <a href="chapter2.xhtml#tab2-11">Table 2-11</a> lists these macros and their meanings.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_82" aria-label="82"/>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-11"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-11:</span></span> <span class="SANS_Futura_Std_Book_11">Opposite Branches</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Opposite branch</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Equivalent to</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Meaning</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bnhs</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">blo</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not higher or the same. After a comparison, this branch will be taken if the first cmp operand is not higher or the same (not greater than or equal to, unsigned) the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bnhi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not higher. After a comparison, this branch will be taken if the first cmp operand is not higher (not greater than, unsigned) the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bnls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bhi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not lower or the same. After a comparison, this branch will be taken if the first cmp operand is not lower or the same (not less than or equal to, unsigned) the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bnlo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bhs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not lower. After a comparison, this branch will be taken if the first cmp operand is not lower (not less than, unsigned) the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bngt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ble</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not greater than. After a comparison, this branch will be taken if the first cmp operand is not greater than (signed) the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bnge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">blt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not greater than or equal. After a comparison, this branch will be taken if the first cmp operand is not greater than or equal to (signed) the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bnlt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not less than. After a comparison, this branch will be taken if the first cmp operand is not less than (signed) the second operand.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bnle</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">bgt</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branch if not less than or equal. After a comparison, this branch will be taken if the first cmp operand is not less than or equal to (signed) the second operand.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">You should read each of these opposite-branch mnemonics as “fall through on condition” (ignoring the <i>not</i>).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h3 class="H1" id="sec28"><span id="h1-30"/><span class="SANS_Futura_Std_Bold_B_11">2.11 Shifts and Rotates</span></h3>&#13;
<p class="TNI1">The <i>shift</i> and <i>rotate</i> operations are another set of logical operations that apply to bit strings. These two categories can be further broken into left shifts, left rotates, right shifts, and right rotates.</p>&#13;
<p class="TX">The <i>shift-left operation</i> moves each bit in a bit string one position to the left, as shown in <a href="chapter2.xhtml#fig2-8">Figure 2-8</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-8" src="../images/Figure2-8.jpg" alt="" width="768" height="150"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-8: The shift-left operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Bit 0 moves into bit position 1, the previous value in bit position 1 moves into bit position 2, and so on. You’ll shift a 0 into bit 0, and the previous value of the HO bit will be lost.</p>&#13;
<p class="TX">The ARM provides a logical shift-left instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span>, that performs this useful operation. This is the syntax for <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span>:</p>&#13;
<pre id="pre-113"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_83" aria-label="83"/>lsl  <var>dest</var>, <var>source</var>, <var>count</var> // Does not affect any flags</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">count</span> operand is either a register or an immediate constant in the range 0 to <i>n</i>, where <i>n</i> is one less than the number of bits in the destination operand (for example, <i>n</i> = 31 for 32-bit operands and <i>n</i> = 63 for 64-bit operands). The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dest</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">source</span> operands are registers.</p>&#13;
<p class="TX">When the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">count</span> operand is the value 1 (either an immediate constant or in a register), the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction performs the operation shown in <a href="chapter2.xhtml#fig2-9">Figure 2-9</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-9" src="../images/Figure2-9.jpg" alt="" width="1072" height="142"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-9: Shift-left operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">count</span> value is 0, no shift occurs and the value remains unchanged. If the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">count</span> value is greater than 1, the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction shifts the specified number of bits (shifting 0s into the LO position). Note that the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction does not affect any flags.</p>&#13;
<p class="TX">Shifting a value to the left by one digit is the same thing as multiplying it by its radix (base). For example, shifting a decimal number one position to the left (adding a 0 to the right of the number) effectively multiplies it by 10 (the radix):</p>&#13;
<pre id="pre-114"><code>1234 shl 1 = 12340&#13;
// (shl 1 means shift one digit position to the left.)</code></pre>&#13;
<p class="TX">Because the radix of a binary number is 2, shifting it left multiplies it by 2. If you shift a value to the left <i>n</i> times, you multiply that value by 2<i><sup>n</sup></i>.</p>&#13;
<p class="TX">A <i>shift-right</i> operation works the same way, except you’re moving the data in the opposite direction. For a byte value, bit 7 moves into bit 6, bit 6 moves into bit 5, bit 5 moves into bit 4, and so on. During a shift right, you’ll move a 0 into bit 7 (see <a href="chapter2.xhtml#fig2-10">Figure 2-10</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-10" src="../images/Figure2-10.jpg" alt="" width="998" height="139"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-10: The shift-right operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As you’d expect, the ARM provides an <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> instruction that shifts the bits to the right in a destination operand. The syntax is similar to the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction:</p>&#13;
<pre id="pre-115"><code>lsr  <var>dest</var>, <var>source</var>, <var>count</var> // Does not affect any flags</code></pre>&#13;
<p class="TX">This instruction shifts a 0 into the HO bit of the destination operand and shifts the other bits one place to the right (that is, from a higher bit number to a lower bit number).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_84" aria-label="84"/>Because a shift left is equivalent to a multiplication by 2, it should come as no surprise that a shift right is roughly comparable to a division by 2 (or, in general, a division by the radix of the number). If you perform <i>n</i> shift-right operations, you will divide that number by 2<i><sup>n</sup></i>.</p>&#13;
<p class="TX">However, a shift right is equivalent to only an <i>unsigned</i> division by 2. For example, if you shift the unsigned representation of 254 (0xFE) one place to the right, you get 127 (0x7F), exactly what you would expect. However, if you shift the two’s complement representation of –2 (0xFE) to the right one position, you get 127 (0x7F), which is <i>not</i> correct. This problem occurs because you’re shifting a 0 into bit 7. If bit 7 previously contained a 1, you’re changing it from a negative to a positive number—not a good thing to do when dividing by 2.</p>&#13;
<p class="TX">To use the shift right as a division operator, this chapter must define a third shift operation: <i>arithmetic shift right</i>. There is no need for an arithmetic shift left; the standard shift-left operation works for both signed and unsigned numbers, assuming no overflow occurs.</p>&#13;
<p class="TX">An arithmetic shift right works just like the normal shift-right operation (a logical shift right), except instead of shifting a 0 into the HO bit, an arithmetic shift-right operation copies the HO bit back into itself. That is, the shift operation does not modify the HO bit, as <a href="chapter2.xhtml#fig2-11">Figure 2-11</a> shows.</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-11" src="../images/Figure2-11.jpg" alt="" width="812" height="186"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-11: Arithmetic shift-right operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">An arithmetic shift right generally produces the signed integer result you expect. For example, if you perform the arithmetic shift-right operation on –2 (0xFE), you get –1 (0xFF). However, this operation always rounds the numbers to the closest integer that is <i>less than or equal to the actual result</i>. For example, if you apply the arithmetic shift-right operation on –1 (0xFF), the result is –1, not 0. Because –1 is less than 0, the arithmetic shift-right operation rounds toward –1. This is not a bug in the arithmetic shift-right operation; it just uses a different (though valid) definition of integer division.</p>&#13;
<p class="TX">The ARM-64 provides an arithmetic shift-right instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">asr</span> (arithmetic shift right). This instruction’s syntax is nearly identical to <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span>:</p>&#13;
<pre id="pre-116"><code>asr  <var>dest</var>, <var>source</var>, <var>count</var> // Does not affect any flags</code></pre>&#13;
<p class="TX">The usual limitations on the operands apply. This instruction operates as shown in <a href="chapter2.xhtml#fig2-12">Figure 2-12</a> if the count is 1.</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-12" src="../images/Figure2-12.jpg" alt="" width="1051" height="187"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-12: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">asr</span> <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">source</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">, #1</span> <span class="SANS_Futura_Std_Book_Oblique_11">operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_85" aria-label="85"/>If the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">count</span> value is 0, no shift occurs and the value remains unchanged. If the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">count</span> value is greater than 1, the <span class="SANS_TheSansMonoCd_W5Regular_11">asr</span> instruction shifts the specified number of bits (shifting 0s into the LO position).</p>&#13;
<p class="TX">The <i>rotate-left</i> and <i>rotate-right</i> operations behave like the shift-left and shift-right operations, except the bit shifted out from one end is shifted back in at the other end. <a href="chapter2.xhtml#fig2-13">Figure 2-13</a> diagrams these operations.</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-13" src="../images/Figure2-13.jpg" alt="" width="812" height="425"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-13: The rotate-left and rotate-right operations</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The ARM provides a <span class="SANS_TheSansMonoCd_W5Regular_11">ror</span> (rotate-right) instruction, but it does not have a rotate-left instruction. The syntax for the rotate right is similar to the shift instructions:</p>&#13;
<pre id="pre-117"><code>ror  <var>dest</var>, <var>source</var>, <var>count</var> // Does not affect any flags</code></pre>&#13;
<p class="TX"><a href="chapter2.xhtml#fig2-14">Figure 2-14</a> shows the operation of this instruction on a register. Note that this instruction does not affect any flags. If the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">count</span> value is 0, no rotate occurs and the value remains unchanged. If the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">count</span> value is greater than 1, the rotate instructions rotate the specified number of bits (shifting 0s into the appropriate position).</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-14" src="../images/Figure2-14.jpg" alt="" width="850" height="200"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-14: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ror</span> <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">source</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">, #1</span> <span class="SANS_Futura_Std_Book_Oblique_11">operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you absolutely need a <span class="SANS_TheSansMonoCd_W5Regular_11">rol</span> operation, it can be (somewhat) synthesized using other instructions. <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> covers this in greater detail.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h3 class="H1" id="sec29"><span id="h1-31"/><span class="SANS_Futura_Std_Bold_B_11">2.12 Bit Fields and Packed Data</span></h3>&#13;
<p class="TNI1">Although the ARM operates most efficiently on byte, half-word, word, and dword data types, occasionally you’ll need to work with a data type that uses a number of bits other than 8, 16, 32, or 64. You could zero-extend a nonstandard data size to the next larger power of 2 (such as extending a 22-bit value to a 32-bit value); this turns out to be fast, but if you have a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_86" aria-label="86"/>large array of such values, slightly more than 31 percent of the memory is going to waste (10 bits in every 32-bit value). However, suppose you were to repurpose those 10 bits for something else. By <i>packing</i> the separate 22-bit and 10-bit values into a single 32-bit value, you don’t waste any space.</p>&#13;
<p class="TX">For example, consider a date of the form 04/02/01. Representing this date requires three numeric values: month, day, and year values. Months, of course, take on the values 1 to 12. At least 4 bits, a maximum of 16 values, are needed to represent the month. Days range from 1 to 31. This means it will take 5 bits, a maximum of 32 values, to represent the day entry. The year value, assuming that you’re working with values in the range 0 to 99, requires 7 bits, which can be used to represent up to 128 values. This means we need 2 bytes to hold the whole date, since 4 + 5 + 7 = 16 bits.</p>&#13;
<p class="TX">In other words, you can pack the date data into 2 bytes rather than the 3 that would be required if you used a separate byte for each of the month, day, and year values. This saves 1 byte of memory for each date stored, which could make for significant savings if you need to store many dates. The bits could be arranged as shown in <a href="chapter2.xhtml#fig2-15">Figure 2-15</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-15" src="../images/Figure2-15.jpg" alt="" width="1021" height="122"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-15: Short packed-date format (2 bytes)</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In the figure, <i>MMMM</i> represents the 4 bits making up the month value, <i>DDDDD</i> represents the 5 bits making up the day, and <i>YYYYYYY</i> represents the 7 bits composing the year. Each collection of bits representing a data item is a <i>bit field</i>. For example, April 2, 2001, would be represented as 0x4101:</p>&#13;
<pre id="pre-118"><code>0100      00010   0000001  = 0100_0001_0000_0001b or 0x4101&#13;
4         2       01</code></pre>&#13;
<p class="TX">Although packed values are <i>space efficient</i> (that is, they make efficient use of memory), they are computationally <i>inefficient</i> (slow!). That’s because unpacking the data packed into the various bit fields requires extra instructions. These take additional time to execute and additional bytes to hold the instructions; hence, you must carefully consider whether packed data fields will save you anything. The sample program in Listing 2-4 demonstrates the effort that goes into packing and unpacking this 16-bit date format.</p>&#13;
<pre id="pre-119"><code>// Listing2-4.S&#13;
//&#13;
// Demonstrate packed data types.&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
             .equ    NULL, 0         // Error code&#13;
             .equ    maxLen, 256     // Max input line size&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_87" aria-label="87"/>             .data&#13;
&#13;
saveLRMain:  .dword  0&#13;
saveLRRN:    .dword  0&#13;
&#13;
ttlStr:      .asciz  "Listing 2-4"&#13;
moPrompt:    .asciz  "Enter current month: "&#13;
dayPrompt:   .asciz  "Enter current day: "&#13;
&#13;
yearPrompt:  .ascii  "Enter current year "&#13;
             .asciz  "(last 2 digits only): "&#13;
&#13;
packed:      .ascii  "Packed date is %04x = "&#13;
             .asciz  "%02d/%02d/%02d\n"&#13;
&#13;
theDate:     .asciz  "The date is %02d/%02d/%02d\n"&#13;
&#13;
badDayStr:   .ascii  "Bad day value was entered "&#13;
             .asciz  "(expected 1-31)\n"&#13;
&#13;
badMonthStr: .ascii "Bad month value was entered "&#13;
             .asciz "(expected 1-12)\n"&#13;
&#13;
badYearStr:  .ascii "Bad year value was entered "&#13;
             .asciz "(expected 00-99)\n"&#13;
&#13;
// These need extra padding so they can be printed&#13;
// as integers. They're really byte (and word) values.&#13;
&#13;
month:      .dword  0&#13;
day:        .dword  0&#13;
year:       .dword  0&#13;
date:       .dword  0&#13;
&#13;
m:          .dword  0&#13;
d:          .dword  0&#13;
y:          .dword  0&#13;
&#13;
input:      .fill    maxLen, 0&#13;
&#13;
            .text&#13;
            .align  2       // Word-align code&#13;
            .extern printf&#13;
            .extern readLine&#13;
            .extern strtol&#13;
&#13;
// Return program title to C++ program:&#13;
&#13;
            .global getTitle&#13;
getTitle:&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_88" aria-label="88"/>// Here's a user-written function that reads a numeric value from&#13;
// the user:&#13;
//&#13;
// int readNum(char *prompt);&#13;
//&#13;
// A pointer to a string containing a prompt message is passed in&#13;
// the X0 register.&#13;
//&#13;
// This procedure prints the prompt, reads an input string from&#13;
// the user, then converts the input string to an integer and&#13;
// returns the integer value in X0.&#13;
&#13;
readNum:&#13;
            lea     x1, saveLRRN&#13;
            str     lr, [x1]        // Save return address.&#13;
&#13;
// Must set up stack properly (using this "magic" instruction)&#13;
// before you can call any C/C++ functions:&#13;
&#13;
            sub     sp, sp, #64&#13;
&#13;
// Print the prompt message. Note that the prompt message was&#13;
// passed to this procedure in X0; we're just passing it on to&#13;
// printf:&#13;
&#13;
            bl      printf&#13;
&#13;
// Set up arguments for readLine and read a line of text from&#13;
// the user. Note that readLine returns NULL (0) in RAX if there&#13;
// was an error.&#13;
&#13;
            lea     x0, input&#13;
            mov     x1, #maxLen&#13;
            bl      readLine&#13;
&#13;
// Test for a bad input string:&#13;
&#13;
            cmp     x0, #NULL&#13;
            beq     badInput&#13;
&#13;
// Okay, good input at this point. Try converting the string&#13;
// to an integer by calling strtol. The strtol function returns&#13;
// 0 if there was an error, but this is a perfectly fine&#13;
// return result, so we ignore errors.&#13;
&#13;
            lea     x0, input       // Ptr to string&#13;
            mov     x1, #NULL       // No end string pointer&#13;
            mov     x2, #10         // Decimal conversion&#13;
            bl      strtol          // Convert to integer.&#13;
&#13;
badInput:&#13;
            add     sp, sp, #64     // Undo stack setup.&#13;
            lea     x1, saveLRRN    // Restore return address.&#13;
            ldr     lr, [x1]&#13;
            ret&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_89" aria-label="89"/>// Here is the "asmMain" function:&#13;
            .global asmMain&#13;
asmMain:&#13;
            sub     sp, sp, #64     // Magic instruction&#13;
            lea     x0, saveLRMain&#13;
            str     lr, [x0]&#13;
&#13;
// Read the date from the user. Begin by reading the month:&#13;
&#13;
            lea     x0, moPrompt&#13;
            bl      readNum&#13;
&#13;
// Verify the month is in the range 1..12:&#13;
&#13;
            cmp     x0, #1&#13;
            blo     badMonth&#13;
            cmp     x0, #12&#13;
            bhi     badMonth&#13;
&#13;
// Good month, save it for now:&#13;
&#13;
            lea     x1, month&#13;
            strb    w0, [x1]    // 1..12 fits in a byte.&#13;
&#13;
// Read the day:&#13;
&#13;
            lea     x0, dayPrompt&#13;
            bl      readNum&#13;
&#13;
// We'll be lazy here and verify only that the day is in&#13;
// the range 1..31.&#13;
&#13;
            cmp     x0, #1&#13;
            blo     badDay&#13;
            cmp     x0, #31&#13;
            bhi     badDay&#13;
&#13;
// Good day, save it for now:&#13;
&#13;
            lea     x1, day&#13;
            strb    w0, [x1]    // 1..31 fits in a byte.&#13;
&#13;
// Read the year:&#13;
&#13;
            lea     x0, yearPrompt&#13;
            bl      readNum&#13;
&#13;
// Verify that the year is in the range 0..99:&#13;
&#13;
            cmp     x0, #0&#13;
            blo     badYear&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_90" aria-label="90"/>            cmp     x0, #99&#13;
            bhi     badYear&#13;
&#13;
// Good year, save it for now:&#13;
&#13;
            lea     x1, year&#13;
            strb    w0, [x1] // 0..99 fits in a byte.&#13;
&#13;
// Pack the data into the following bits:&#13;
//&#13;
//  15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0&#13;
//   m  m  m  m  d  d  d  d  d  y  y  y  y  y  y  y&#13;
&#13;
            lea     x0, month&#13;
            ldrb    w1, [x0]&#13;
            lsl     w1, w1, #5&#13;
&#13;
            lea     x0, day&#13;
            ldrb    w2, [x0]&#13;
            orr     w1, w1, w2&#13;
            lsl     w1, w1, #7&#13;
&#13;
            lea     x0, year&#13;
            ldrb    w2, [x0]&#13;
            orr     w1, w1, w2&#13;
&#13;
            lea     x0, date&#13;
            strh    w1, [x0]&#13;
&#13;
// Print the packed date:&#13;
&#13;
            lea     x0, packed&#13;
            vparm2  date&#13;
            vparm3  month&#13;
            vparm4  day&#13;
            vparm5  year&#13;
            bl      printf&#13;
&#13;
// Unpack the date and print it:&#13;
&#13;
            lea     x0, date&#13;
            ldrh    w1, [x0]&#13;
&#13;
            // Extract month:&#13;
&#13;
            lsr     w2, w1, #12&#13;
            lea     x0, m&#13;
            strb    w2, [x0]&#13;
&#13;
            // Extract day:&#13;
&#13;
            lsr     w3, w1, #7&#13;
            and     w3, w3, #0x1f&#13;
            lea     x0, d&#13;
            strb    w3, [x0]&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_91" aria-label="91"/>            // Extract year:&#13;
&#13;
            and     w1, w1, #0x7f&#13;
            lea     x0, y&#13;
            strb    w1, [x0]&#13;
&#13;
            lea     x0, theDate&#13;
            vparm2  m&#13;
            vparm3  d&#13;
            vparm4  y&#13;
            bl      printf&#13;
&#13;
            b.al    allDone&#13;
&#13;
// Come down here if a bad day was entered:&#13;
&#13;
badDay:&#13;
            lea     x0, badDayStr&#13;
            bl      printf&#13;
            b.al    allDone&#13;
&#13;
// Come down here if a bad month was entered:&#13;
&#13;
badMonth:&#13;
            lea     x0, badMonthStr&#13;
            bl      printf&#13;
            b.al    allDone&#13;
&#13;
// Come here if a bad year was entered:&#13;
&#13;
badYear:&#13;
            lea     x0, badYearStr&#13;
            bl      printf&#13;
&#13;
allDone:&#13;
            add     sp, sp, #64&#13;
            lea     x0, saveLRMain&#13;
            ldr     lr, [x0]&#13;
            ret     // Returns to caller</code></pre>&#13;
<p class="TX">Here’s the result of building and running this program:</p>&#13;
<pre id="pre-120"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing2-4</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing2-4</span>&#13;
Calling Listing2-4:&#13;
Enter current month: <span class="SANS_TheSansMonoCd_W7Bold_11">2</span>&#13;
Enter current day: <span class="SANS_TheSansMonoCd_W7Bold_11">4</span>&#13;
Enter current year (last 2 digits only): <span class="SANS_TheSansMonoCd_W7Bold_11">56</span>&#13;
Packed date is 2238 = 02/04/56&#13;
The date is 02/04/56&#13;
Listing2-4 terminated</code></pre>&#13;
<p class="TX">The infamous problems with Y2K (year 2000) taught everyone that using a date format limited to 100 years (or even 127 years) would be quite <span role="doc-pagebreak" epub:type="pagebreak" id="pg_92" aria-label="92"/>foolish. If you’re too young to remember this fiasco, programmers in the middle to late 1900s used to encode only the last two digits of the year in their dates. When the year 2000 rolled around, these programs were incapable of distinguishing dates like 2024 and 1924.</p>&#13;
<p class="TX">To avoid this problem and future-proof the packed-date format in Listing 2-4, you can extend the format to 4 bytes packed into a double-word variable, as shown in <a href="chapter2.xhtml#fig2-16">Figure 2-16</a>. (As you’ll see in <span class="Xref"><a href="chapter3.xhtml">Chapters 3</a></span> and <span class="Xref"><a href="chapter4.xhtml">4</a></span>, you should always try to create data objects whose length is an even power of 2—that is, 1 byte, 2 bytes, 4 bytes, 8 bytes, and so on—or you will pay a performance penalty.)</p>&#13;
<figure class="IMG"><img class="img7" id="fig2-16" src="../images/Figure2-16.jpg" alt="" width="1143" height="113"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-16: The long packed-date format (4 bytes)</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The month and day fields now consist of 8 bits each, so they can be extracted as a byte object from the word. This leaves 16 bits for the year, with a range of 65,536 years. By rearranging the bits so the year field is in the HO bit positions, the month field is in the middle bit positions, and the day field is in the LO bit positions, the long date format allows you to easily compare two dates to see whether one date is less than, equal to, or greater than another date. Consider the following code:</p>&#13;
<pre id="pre-121"><code>     lea x0, Date1  // Assume Date1 and Date2 are words.&#13;
     ldr x1, [x0]   // Using the long packed-date format&#13;
     lea x0, Date2&#13;
     ldr x2, [x0]&#13;
     cmp x1, x2&#13;
     ble d1LEd2&#13;
&#13;
       // Do something if Date1 &gt; Date2.&#13;
&#13;
d1LEd2:</code></pre>&#13;
<p class="TX">Had you kept the different date fields in separate variables, or organized the fields differently, you would not have been able to compare <span class="SANS_TheSansMonoCd_W5Regular_11">Date1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Date2</span> as easily as for the short packed-date format. Therefore, this example demonstrates another reason for packing data even if you don’t realize any space savings: it can make certain computations more convenient or even more efficient (contrary to what normally happens when you pack data).</p>&#13;
<p class="TX">Examples of practical packed data types abound. You could pack eight Boolean values into a single byte, two BCD digits into a byte, and so on. A classic example of packed data is the PSTATE register (see <a href="chapter2.xhtml#fig2-17">Figure 2-17</a>). This register packs four important Boolean objects, along with 12 important system flags, into a single 32-bit register.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_93" aria-label="93"/>&#13;
<figure class="IMG"><img class="img1" id="fig2-17" src="../images/Figure2-17.jpg" alt="" width="1672" height="105"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-17: The PSTATE register as packed Boolean data</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You’ll commonly access the condition code flags by using the conditional jump instructions. Occasionally, you may need to manipulate the individual condition code bits in the PSTATE register. You can do this with the <span class="SANS_TheSansMonoCd_W5Regular_11">msr</span> (move to system register) and <span class="SANS_TheSansMonoCd_W5Regular_11">mrs</span> (move system register) instructions</p>&#13;
<pre id="pre-122"><code>msr  <var>systemReg</var>, <var>reg</var>&#13;
mrs  <var>reg</var>, <var>systemReg</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span> is one of the ARM’s 64-bit general-purpose registers and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">systemReg</span> is a special <i>system register</i> name. The system register of interest here is NZCV, named after the condition code flags.</p>&#13;
<p class="TX">The following instruction copies bits 28 to 31 in the PSTATE register into the corresponding bits in X0 and copies 0s to all the other bits in X0:</p>&#13;
<pre id="pre-123"><code>mrs  x0, nzcv</code></pre>&#13;
<p class="TX">This instruction copies bits 28 to 31 in X0 to the condition code bits in PSTATE (without affecting any other bits in PSTATE):</p>&#13;
<pre id="pre-124"><code>msr  nzcv, x0</code></pre>&#13;
<p class="TX">If you want to explicitly set the carry flag, without affecting any other condition code flags, you could do that as follows:</p>&#13;
<pre id="pre-125"><code>mrs  x0, nzcv&#13;
orr  x0, x0, #0x20000000  // Carry is in bit 29; set it.&#13;
msr  nzcv, x0</code></pre>&#13;
<p class="TX">This ORs a 1 bit into the carry flag in the PSTATE register.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h3 class="H1" id="sec30"><span id="h1-32"/><span class="SANS_Futura_Std_Bold_B_11">2.13 IEEE Floating-Point Formats</span></h3>&#13;
<p class="TNI1">Back in 1976, when Intel planned to introduce a floating-point coprocessor for its new 8086 microprocessor, it hired the best numerical analyst it could find to design a floating-point format. That person then hired two other experts in the field, and the three of them—William Kahan, Jerome Coonen, and Harold Stone—designed Intel’s floating-point format. They did such a good job designing the KCS floating-point standard that the Institute of Electrical and Electronics Engineers (IEEE) adopted it for its floating-point format. That format has become the standard used by CPU vendors, including Arm.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_94" aria-label="94"/>The IEEE-754 standard single- and double-precision formats correspond to C’s float and double types or FORTRAN’s real and double-precision types. These same formats are available to ARM assembly language programmers.</p>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-35"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.13.1 Single-Precision Format</span></h4>&#13;
<p class="TNI1">The <i>single-precision format</i> uses a one’s complement 24-bit mantissa, an 8-bit excess-127 exponent, and a single sign bit. <i>One’s complement</i> notation consists of a sign bit and an unsigned binary number, with the sign bit indicating the sign of the binary number. The <i>mantissa</i> (the part of the number that represents the significant digits) usually represents a value from 1.0 to just under 2.0. The HO bit of the mantissa is always assumed to be 1 and represents a value just to the left of the binary point. (A <i>binary point</i> is the same thing as a <i>decimal point</i>, except it appears in binary numbers rather than decimal numbers.) The remaining 23 mantissa bits (the fraction) appear to the right of the binary point.</p>&#13;
<p class="TX">Therefore, the mantissa represents the value:</p>&#13;
<pre id="pre-126"><code>1.<var>mmmmmmm mmmmmmmm</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">mmmm</span> characters represent the 23 bits of the mantissa. Because the HO bit of the mantissa is always 1, the single-precision format doesn’t actually store this bit within the 32 bits of the floating-point number. This HO bit is known as an <i>implied bit</i>.</p>&#13;
<p class="TX">Because you are working with binary numbers, each position to the right of the binary point represents a value (0 or 1) times a successive negative power of 2. The implied <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> bit is always multiplied by 2<sup>0</sup>, which is 1. This is why the mantissa is always greater than or equal to 1.0. Even if the other mantissa bits are all 0s, the implied <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> bit always gives us the value 1.0. Of course, even if you had an almost infinite number of 1 bits after the binary point, they still would not add up to 2.0. This is why the mantissa can represent values in the range 1.0 to just under 2.0.</p>&#13;
<p class="TX">There is one exception to the implied bit always being 1: the IEEE floating-point format supports <i>denormalized</i> values, where the HO bit is not 0. However, this book generally ignores denormalized values.</p>&#13;
<p class="TX">Although there is an infinite number of values between 1.0 and 2.0, you can represent only 8 million of them because the format uses a 23-bit mantissa (with the implied 24th bit always being <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>). This is the reason for inaccuracy in floating-point arithmetic: you are limited to a fixed number of bits in computations involving single-precision floating-point values.</p>&#13;
<p class="TX">As noted, the mantissa uses a one’s complement format rather than two’s complement to represent signed values. This means that the 24-bit value of the mantissa is simply an unsigned binary number, and the sign bit determines whether that value is positive or negative. One’s complement numbers have the unusual property that there are two representations for 0.0 (with the sign bit set or clear). Generally, this is important only to the person designing the floating-point software or hardware system. This book assumes that the value 0.0 always has the sign bit clear.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_95" aria-label="95"/>To represent values outside the range 1.0 to just under 2.0, the exponent portion of the floating-point format comes into play. The floating-point format raises 2 to the power specified by the exponent and then multiplies the mantissa by this value. The exponent is 8 bits and is stored in an excess-127 format. In <i>excess-127 format</i>, the exponent 0 is represented by the value 127 (0x7F), negative exponents are values in the range 1 to 126, and positive exponents are values in the range 128 to 254 (0 and 255 are reserved for special cases). To convert an exponent to excess-127 format, add 127 to the exponent value. The use of excess-127 format makes it easier to compare floating-point values.</p>&#13;
<p class="TX">The single-precision floating-point format takes the form shown in <a href="chapter2.xhtml#fig2-18">Figure 2-18</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig2-18" src="../images/Figure2-18.jpg" alt="" width="1688" height="272"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-18: The single-precision (32-bit) floating-point format</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">With a 24-bit mantissa, you will get approximately six and a half (decimal) digits of precision (half a digit of precision means that the first six digits can all be in the range 0 to 9, but the seventh digit can only be in the range 0 to <i>x</i>, where <i>x</i> &lt; 9 and is generally close to 5). Note, however, that only six digits are guaranteed. With an 8-bit excess-127 exponent, the <i>dynamic range</i> of single-precision floating-point numbers is approximately 2 <sup>± 127</sup>, or about 10 <sup>± 38</sup>. This dynamic range is the difference in size between the smallest and largest positive values.</p>&#13;
<p class="TX">Although single-precision floating-point numbers are perfectly suitable for many applications, the precision and dynamic range are somewhat limited and unsuitable for many financial, scientific, and other applications. Furthermore, during long chains of computations, the limited accuracy of the single-precision format may introduce serious errors.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h2-36"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.13.2 Double-Precision Format</span></h4>&#13;
<p class="TNI1">The <i>double-precision format</i> helps overcome the problems of single-precision floating-point. Using twice the space, the double-precision format has an 11-bit excess-1,023 exponent and a 53-bit mantissa (with an implied HO bit of <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>), plus a sign bit. Double-precision floating-point values take the form shown in <a href="chapter2.xhtml#fig2-19">Figure 2-19</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_96" aria-label="96"/>&#13;
<figure class="IMG"><img class="img1" id="fig2-19" src="../images/Figure2-19.jpg" alt="" width="1686" height="177"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-19: The 64-bit double-precision floating-point format</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The 53rd mantissa bit is implied and is always <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>. The double-precision format provides a dynamic range of about 10 <sup>± 308</sup> and at least 15 digits of precision, sufficient for most applications.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h3 class="H1" id="sec33"><span id="h1-33"/><span class="SANS_Futura_Std_Bold_B_11">2.14 Normalized Floating-Point Values</span></h3>&#13;
<p class="TNI1">To maintain maximum precision during computation, most computations use normalized values. A <i>normalized floating-point value</i> is one whose HO mantissa bit contains 1. Almost any nonnormalized value can be normalized: shift the mantissa bits to the left and decrement the exponent until a 1 appears in the HO bit of the mantissa. Remember, the exponent is a binary exponent. Each time you increment the exponent, you multiply the floating-point value by 2. Likewise, whenever you decrement the exponent, you divide the floating-point value by 2. By the same token, shifting the mantissa to the left one bit-position multiplies the floating-point value by 2; likewise, shifting the mantissa to the right divides the floating-point value by 2. Therefore, shifting the mantissa to the left one position <i>and</i> decrementing the exponent does not change the value of the floating-point number at all.</p>&#13;
<p class="TX">Keeping floating-point numbers normalized maintains the maximum number of bits of precision for a computation. If the HO <i>n</i> bits of the mantissa are all 0s, the mantissa has that many fewer bits of precision available for computation. Therefore, a floating-point computation will be more accurate if it involves only normalized values.</p>&#13;
<p class="TX">In two important cases, a floating-point number cannot be normalized. First, the floating-point value 0.0 can’t be normalized, because the representation for 0.0 has no 1 bits in the mantissa. This, however, is not a problem because you can exactly represent the value 0.0 with only a single bit.</p>&#13;
<p class="TX">In the second case, you have some HO bits in the mantissa that are 0s, but the biased exponent is also 0 (and you cannot decrement it to normalize the mantissa). Rather than disallow certain small values, whose HO mantissa bits and biased exponent are 0 (the most negative exponent possible), the IEEE standard allows special <i>denormalized</i> values to represent these smaller values. (The alternative would be to underflow the values to 0.) Although the use of denormalized values allows IEEE floating-point computations to produce better results than if underflow occurred, keep in mind that denormalized values offer fewer bits of precision. Some texts use the term <i>subnormal</i> to describe denormalized values.</p>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_97" aria-label="97"/>&#13;
<h4 class="H2" id="sec34"><span id="h2-37"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.14.1 Nonnumeric Values</span></h4>&#13;
<p class="TNI1">The IEEE floating-point standard recognizes four special nonnumeric values: –infinity, +infinity, and two special not-a-number (NaN) values. For each of these special numbers, the exponent field is filled with all 1 bits.</p>&#13;
<p class="TX">If the exponent is all 1 bits and the mantissa is all 0 bits (excluding the implied bit), then the value is infinity. The sign bit will be 0 for +infinity and 1 for –infinity.</p>&#13;
<p class="TX">If the exponent is all 1 bits and the mantissa is not all 0 bits, the value is an invalid number (known as a <i>NaN</i> in IEEE 754 terminology). NaNs represent illegal operations, such as trying to take the square root of a negative number.</p>&#13;
<p class="TX">Unordered comparisons occur whenever either operand (or both) is a NaN. As NaNs have an indeterminate value, they are incomparable. Any attempt to perform an unordered comparison typically results in an exception or some sort of error. Ordered comparisons, on the other hand, involve two operands, neither of which is a NaN.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h4 class="H2" id="sec35"><span id="h2-38"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.14.2 Gas Support for Floating-Point Values</span></h4>&#13;
<p class="TNI1">Gas provides a couple of data declarations to support the use of floating-point data in your assembly language programs. Gas floating-point constants allow the following syntax: the constant begins with an optional <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> or <span class="symbol">−</span> symbol, denoting the sign of the mantissa (if this is not present, Gas assumes that the mantissa is positive). This is followed by one or more decimal digits, then a decimal point and zero or more decimal digits. These are optionally followed by an <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">E</span>, which is in turn optionally followed by a sign (<span class="SANS_TheSansMonoCd_W5Regular_11">+</span> or <span class="symbol">−</span>) and one or more decimal digits.</p>&#13;
<p class="TX">The decimal point or the <span class="SANS_TheSansMonoCd_W5Regular_11">e</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">E</span> must be present to differentiate a floating-point literal constant from an integer or unsigned literal constant. Here are some examples of legal floating-point literal constants:</p>&#13;
<pre id="pre-127"><code>1.234  3.75e2  -1.0  1.1e-1  1.e+4  0.1  -123.456e+300  +25.0e0</code></pre>&#13;
<p class="Continued1">A floating-point literal constant must begin with a decimal digit, so you must use, for example, <span class="SANS_TheSansMonoCd_W5Regular_11">0.1</span> rather than <span class="SANS_TheSansMonoCd_W5Regular_11">.1</span> in your programs.</p>&#13;
<p class="TX">To declare a floating-point variable, use the <span class="SANS_TheSansMonoCd_W5Regular_11">.single</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">.double</span> data types. Aside from using these types to declare floating-point variables rather than integers, their use is nearly identical to that of <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span><i>,</i> and so on. The following examples demonstrate these declarations and their syntax:</p>&#13;
<pre id="pre-128"><code>          .data&#13;
fltVar1:  .single  0.0&#13;
fltVar1a: .single  2.7&#13;
pi:       .single  3.14159&#13;
DblVar:   .double  0.0&#13;
DblVar2:  .double  1.23456789e+10&#13;
DPVar:    .double  -1.0e-104&#13;
IntAsFP:  .double  -123</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_98" aria-label="98"/>As usual, this book uses the C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function to print floating-point values to the console output. Certainly, an assembly language routine could be written to provide this same output, but the C stdlib provides a convenient way to avoid writing that complex code (at least until <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>).</p>&#13;
<p class="TX">Floating-point arithmetic is different from integer arithmetic; you cannot use the ARM <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> instructions to operate on floating-point values. This chapter presents only the floating-point formats; see <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> for more information on floating-point arithmetic and general floating-point operations.</p>&#13;
<p class="TX">In the meantime, let’s consider some other data formats.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h3 class="H1" id="sec36"><span id="h1-34"/><span class="SANS_Futura_Std_Bold_B_11">2.15 Binary-Coded Decimal Representation</span></h3>&#13;
<p class="TNI1">Although the integer and floating-point formats cover most of the numeric needs of an average program, in some special cases other numeric representations are convenient. This section expands on the definition of the BCD format presented earlier. Although the ARM CPU doesn’t provide hardware support for BCD, it’s still a common format that some software uses, with BCD arithmetic provided by programmer-written software functions.</p>&#13;
<p class="TX">BCD values are a sequence of nibbles, with each nibble representing a value in the range 0 to 9. With a single byte, you can represent values containing two decimal digits, or values in the range 0 to 99. <a href="chapter2.xhtml#fig2-20">Figure 2-20</a> shows the two BCD digits, represented by 4 bits each, in a byte.</p>&#13;
<figure class="IMG"><img class="img5" id="fig2-20" src="../images/Figure2-20.jpg" alt="" width="766" height="262"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-20: Two-digit BCD data representation in memory</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As you can see, BCD storage isn’t particularly memory efficient. For example, an 8-bit BCD variable can represent values in the range 0 to 99, while that same 8 bits, when holding a binary value, can represent values in the range 0 to 255. Likewise, a 16-bit binary value can represent values in the range 0 to 65,535, while a 16-bit BCD value can represent only about one-sixth of those values (0 to 9,999).</p>&#13;
<p class="TX">However, it’s easy to convert BCD values between the internal numeric representation and their string representation, for example, using BCD to encode multidigit decimal values in hardware with a thumb wheel or dial. For these two reasons, you’re likely to see people using BCD in embedded systems (such as toaster ovens, calculators, alarm clocks, and nuclear reactors) but rarely in general-purpose computer software.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_99" aria-label="99"/>Unfortunately, all BCD operations on ARM have to be done using software functions, as BCD arithmetic is not built into the hardware on the ARM. As a result, computations involving BCD arithmetic can run slowly. Because the BCD data type is very specialized and used in only a few situations (for example, in embedded systems), this book won’t spend any more time discussing it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h3 class="H1" id="sec37"><span id="h1-35"/><span class="SANS_Futura_Std_Bold_B_11">2.16 Characters</span></h3>&#13;
<p class="TNI1">Perhaps the most important data type on a personal computer is the character data type. <i>Character</i> refers to a human or machine-readable symbol that is typically a nonnumeric entity. Specifically, a character is any symbol that you can typically type on a keyboard (including symbols that may require multiple keypresses to produce) or display on a video display.</p>&#13;
<p class="TX">Letters (<i>alphabetic characters</i>), punctuation symbols, numeric digits, spaces, tabs, carriage returns (<small>ENTER</small>), other control characters, and other special symbols are all characters. <i>Numeric characters</i> are distinct from numbers: the character <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> is different from the value 1. The computer (generally) uses two internal representations for numeric characters (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, ..., <span class="SANS_TheSansMonoCd_W5Regular_11">9</span>) versus the numeric values 0 to 9.</p>&#13;
<p class="TX">Most computer systems use a single- or multibyte sequence to encode the various characters in binary form. Linux and macOS use either the ASCII or Unicode encodings for characters. This section discusses the ASCII and Unicode character sets and the character declaration facilities that Gas provides.</p>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
&#13;
<h4 class="H2" id="sec38"><span id="h2-39"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.16.1 The ASCII Character Encoding</span></h4>&#13;
<p class="TNI1">The ASCII character set maps 128 textual characters to the unsigned integer values 0 to 127 (0 to 0x7F). Although the exact mapping of characters to numeric values is arbitrary and unimportant, you must use a standardized code for this mapping so that when you communicate with other programs and peripheral devices, you all speak the same “language.” ASCII is a standardized code: if you use the ASCII code 65 to represent the character A, then you know that a peripheral device (such as a printer) will correctly interpret this value as the character A whenever you transmit data to that device.</p>&#13;
<p class="TX">Despite some major shortcomings, ASCII has become the standard for data interchange across computer systems and programs. Most programs can accept and produce ASCII data. Because you will be dealing with ASCII characters in assembly language, I recommend you study the layout of the character set and memorize a few key ASCII codes (for example, for <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">A</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">a</span>, and so on). See <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span> for a list of all the ASCII character codes.</p>&#13;
<p class="TX">Today, Unicode (especially the UTF-8 encoding) is rapidly replacing ASCII, because the ASCII character set is insufficient for handling international alphabets and other special characters, as you’ll see in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>. Nevertheless, most modern code still uses ASCII, so you should be familiar with it.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_100" aria-label="100"/>The ASCII character set is divided into four groups of 32 characters. The first 32 characters, ASCII codes 0 to 0x1F (31), form a special set of nonprinting characters, the control characters. They are called <i>control characters</i> because they perform various printer/display control operations rather than display symbols. Examples include <i>carriage return</i>, which positions the cursor to the left side of the current line of characters; <i>line feed</i>, which moves the cursor down one line on the output device; and <i>backspace</i>, which moves the cursor back one position to the left. (Historically, <i>carriage return</i> refers to the paper carriage used on typewriters: physically moving the carriage all the way to the right enabled the next character typed to appear at the left side of the paper.) Unfortunately, different control characters perform different operations on different output devices. Little standardization exists among output devices. To find out exactly how a control character affects a particular device, consult its manual.</p>&#13;
<p class="TX">The second group of 32 ASCII character codes contains various punctuation symbols, special characters, and the numeric digits. The most notable characters in this group include the space character (ASCII code 0x20) and the numeric digits (ASCII codes 0x30 to 0x39).</p>&#13;
<p class="TX">The third group of 32 ASCII characters contains the uppercase alphabetic characters. The ASCII codes for the characters A through Z lie in the range 0x41 to 0x5A (65 to 90). Because there are only 26 alphabetic characters, the remaining 6 codes hold various special symbols.</p>&#13;
<p class="TX">The fourth, and final, group of 32 ASCII character codes represents the lowercase alphabetic symbols, 5 additional special symbols, and another control character (DELETE). The lowercase character symbols use the ASCII codes 0x61 to 0x7A. If you convert the codes for the upper- and lowercase characters to binary, you will notice that the uppercase symbols differ from their lowercase equivalents in exactly one bit position. For example, consider the character codes for <span class="SANS_TheSansMonoCd_W5Regular_11">E</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> in <a href="chapter2.xhtml#fig2-21">Figure 2-21</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig2-21" src="../images/Figure2-21.jpg" alt="" width="626" height="302"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-21: The ASCII codes for E and e</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The only place upper- and lowercase differ is in bit 5. Uppercase characters always contain a 0 in bit 5; lowercase alphabetic characters always contain a 1 in bit 5. You can use this fact to quickly convert between upper- and lowercase. You can force an uppercase character to lowercase by setting bit 5 to 1, or force a lowercase character to uppercase by setting bit 5 to 0.</p>&#13;
<p class="TX">Indeed, bits 5 and 6 determine which of the four groups in the ASCII character set you’re in, as <a href="chapter2.xhtml#tab2-12">Table 2-12</a> shows. You could, for instance, convert any upper- or lowercase (or corresponding special) character to its equivalent control character by setting bits 5 and 6 to 0.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_101" aria-label="101"/>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-12"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-12:</span></span> <span class="SANS_Futura_Std_Book_11">ASCII Groups</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Bit 6</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Bit 5</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Group</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Control characters</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Digits and punctuation</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Uppercase and special</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Lowercase and special</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Consider the ASCII codes of the numeric digit characters in <a href="chapter2.xhtml#tab2-13">Table 2-13</a>.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-13"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-13:</span></span> <span class="SANS_Futura_Std_Book_11">ASCII Codes for Numeric Digits</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Character</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Decimal</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Hexadecimal</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">48</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">30h</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">49</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">31h</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">50</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">32h</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">51</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">33h</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">4</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">52</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">34h</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">5</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">53</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">35h</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">6</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">54</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">36h</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">7</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">55</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">37h</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">8</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">56</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">38h</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">9</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">57</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">39h</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The LO nibble of the ASCII code is the binary equivalent of the represented number. By stripping away (that is, setting to 0) the HO nibble of a numeric character, you can convert that character code to the corresponding binary representation. Conversely, you can convert a binary value in the range 0 to 9 to its ASCII character representation by simply setting the HO nibble to 3. You can use the AND operation to force the HO bits to 0; likewise, you can use the OR operation to force the HO bits to 0b0011 (3).</p>&#13;
<p class="TX">Unfortunately, you <i>cannot</i> convert a string of numeric characters to its equivalent binary representation by simply stripping the HO nibble from each digit in the string. Converting 123 (0x31, 0x32, 0x33) in this fashion yields 3 bytes, or 0x010203, but the correct value for 123 is 0x7B. The conversions described in the preceding paragraph work only for single digits.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
&#13;
<h4 class="H2" id="sec39"><span id="h2-40"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.16.2 Gas Support for ASCII Characters</span></h4>&#13;
<p class="TNI1">Gas provides support for character variables and literals in your assembly language programs. Character literal constants in Gas consist of a character surrounded by a pair of apostrophes (or single quotes):</p>&#13;
<pre id="pre-129"><code>'A'</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_102" aria-label="102"/>Technically, a character constant in Gas consists of a single apostrophe followed by a single character. Gas allows a second version consisting of a character surrounded by apostrophes. However, the macOS assembler supports only the latter form, so this book uses only that form to ensure that all example code will assemble on both systems.</p>&#13;
<p class="TX">To represent an apostrophe as a character constant, use the backslash character followed by an apostrophe. For example:</p>&#13;
<pre id="pre-130"><code>'\''</code></pre>&#13;
<p class="TX">You can also use the other escape character sequences in a character constant. See <span class="Xref">section 1.7, “Declaring Memory Variables in Gas,”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_16">page 16</a></span> for details.</p>&#13;
<p class="TX">To declare a character variable in a Gas program, use the <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> declaration. For example, the following declaration demonstrates how to declare a variable named <span class="SANS_TheSansMonoCd_W5Regular_11">UserInput</span>:</p>&#13;
<pre id="pre-131"><code>           .data&#13;
UserInput: .byte  0</code></pre>&#13;
<p class="TX">This declaration reserves 1 byte of storage that you could use to store any character value. You can also initialize character variables as follows:</p>&#13;
<pre id="pre-132"><code>              .data&#13;
TheCharA:     .byte 'A'&#13;
ExtendedChar: .byte 128  // Character code greater than 0x7F</code></pre>&#13;
<p class="TX">Because character variables are 8-bit objects, you can manipulate them as you would any 8-bit value. You can move character variables into registers and store the LO byte of a register into a character variable.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
&#13;
<h3 class="H1" id="sec40"><span id="h1-36"/><span class="SANS_Futura_Std_Bold_B_11">2.17 Gas Support for the Unicode Character Set</span></h3>&#13;
<p class="TNI1">Unfortunately, ASCII supports only 128 character codes. Even if you extend the definition to 8 bits (as IBM did on the original PC), you’re limited to 256 characters. This is far too small for modern multinational, multilingual applications. Back in the 1990s, several companies developed an extension to ASCII, known as <i>Unicode</i>, using a 2-byte character size. Therefore, the original Unicode supported up to 65,536 character codes.</p>&#13;
<p class="TX">As well-thought-out as the original Unicode standard was, systems engineers discovered that even 65,536 symbols were insufficient. Today, Unicode defines 1,112,064 possible characters (code points), encoded using a variable-length character format.</p>&#13;
<p class="TX">Unfortunately, Gas provides almost no support for Unicode text in a source file. Certainly, if you have a text editor that supports editing UTF-8 source files, Gas will accept UTF-8 characters in character and string literals. However, it probably won’t do much with Unicode beyond that (I haven’t tried this, but I doubt Gas will accept UTF-16 or UTF-32 source files).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_103" aria-label="103"/><span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> covers Unicode format and implementation in much greater detail.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
&#13;
<h3 class="H1" id="sec41"><span id="h1-37"/><span class="SANS_Futura_Std_Bold_B_11">2.18 Machine Code</span></h3>&#13;
<p class="TNI1">Gas translates human-readable source files into a special binary form known as <i>machine code</i>. With many (non-RISC) CPUs, it is possible to work in assembly language without knowing much about the underlying machine code that the assembler produces. With RISC processors, such as the ARM, you must have a basic understanding of the underlying machine code in order to understand how to write decent assembly language source code.</p>&#13;
<p class="TX">Like most RISC CPUs, the ARM64 translates individual machine instructions into a single 32-bit value. This is one of the fundamental principles behind RISC: instructions are always the same length on a given CPU, and that length is almost always 32 bits. Variable-length instructions are verboten. However, if the instruction set supports immediate constants (which the assembler encodes as part of the machine instruction), and you have 64-bit registers, how do you load a 64-bit immediate constant into a register when the instructions are limited to 32 bits? The short answer is, “You don’t.” You may recall from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> that immediate constants were limited to a very small range, and now you know why: the constants must be encoded into a 32-bit instruction value, along with considerable other information. This severely limits the size of immediate constants.</p>&#13;
<aside class="box" aria-label="box-8">&#13;
<p class="BH" id="box-8"><span class="SANS_Dogma_OT_Bold_B_11">UNDER MY THUMB</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">The 32-bit variants of the ARM support a special 16-bit instruction-length mode known as the Thumb instruction set. This was done to reduce the size of programs in cost-sensitive embedded applications. In fact, certain embedded versions of the ARM support only the Thumb instruction set. However, Thumb extensions are definitely non-RISC-like. The ARM64 CPUs do not support the Thumb instruction set (while operating in 64-bit mode), as most ARM64 CPUs have a fair amount of memory installed in the system.</span></p>&#13;
</aside>&#13;
<p class="TX">Immediate constants aren’t the only thing you must encode within an instruction’s 32-bit value. Every instruction operand will require a certain number of bits to encode. For example, the ARM64 CPU has 32 general-purpose registers. It takes 5 bits to encode 32 values. Therefore, each register in an operand will consume 5 bits out of the 32 available for that instruction. The following <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> instruction will require at least 15 bits to encode the three registers (as any general-purpose register is legal for the destination, first-source, and second-source registers):</p>&#13;
<pre id="pre-133"><code>adds x0, x1, x2</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_104" aria-label="104"/>In addition to registers and constants, other pieces of information must be encoded in an ARM instruction, such as the size of the operation (32 bits versus 64 bits). Many instructions, like <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> in the preceding example, allow immediate constants (as the second source operand) in addition to registers. There must be some way to differentiate those two operand forms, which take at least 1 bit. Many instructions provide an option to update the flags at the end of the instructions’ execution, which takes another bit. Many additional options exist that this book hasn’t even begun to cover. We’re rapidly running out of bits.</p>&#13;
<p class="TX">RISC instructions must be not only fixed-length but also easy to decode using hardware. This means that for all instructions, a certain number of bits in fixed locations in the 32-bit instruction determine the type or classification of the instruction. Consider the basic instruction format for the ARM64 shown in <a href="chapter2.xhtml#fig2-22">Figure 2-22</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig2-22" src="../images/Figure2-22.jpg" alt="" width="1680" height="92"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-22: The basic ARM instruction format</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">op0</span> field (<span class="SANS_TheSansMonoCd_W5Regular_11">op0</span> is short for <i>operation code 0</i>, itself usually shortened to <i>opcode</i>) specifies the instruction’s operation. In this example, this 4-bit field divides the instruction set into seven components, as shown in <a href="chapter2.xhtml#tab2-14">Table 2-14</a>.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-14"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-14:</span></span> <span class="SANS_Futura_Std_Book_11">The</span> <span class="SANS_TheSansMonoCd_W5Regular_11">op0</span> <span class="SANS_Futura_Std_Book_11">4-Bit Field in Instruction Encoding</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_TheSansMonoCd_W7Bold_11">op0</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Encoding group or instruction page</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0000<br/>0001<br/>0010<br/>0011</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Reserved/unallocated</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1000<br/>1001</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Data processing instructions with immediate constants</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1010<br/>1011</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Branches, exception-generating instructions, and system instructions</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0100<br/>0110<br/>1100<br/>1110</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Loads and stores</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0101<br/>1101</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Data processing instructions with registers</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0111</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Data processing: SIMD and floating-point instructions</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1111</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Data processing: SIMD and floating-point instructions</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Consider the instructions in the second group in <a href="chapter2.xhtml#tab2-14">Table 2-14</a>: data processing instructions with immediate constants. This group uses the decoding shown in <a href="chapter2.xhtml#fig2-23">Figure 2-23</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_105" aria-label="105"/>&#13;
<figure class="IMG"><img class="img1" id="fig2-23" src="../images/Figure2-23.jpg" alt="" width="1677" height="88"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-23: Encoding of data processing instructions with immediate constants</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The 3 bits in <span class="SANS_TheSansMonoCd_W5Regular_11">op1</span> (note that bit 25 is shared with <span class="SANS_TheSansMonoCd_W5Regular_11">op0</span>) can be decoded as shown in <a href="chapter2.xhtml#tab2-15">Table 2-15</a>.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-15"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-15:</span></span> <span class="SANS_Futura_Std_Book_11">Instructions with</span> <span class="SANS_TheSansMonoCd_W5Regular_11">op0</span> <span class="SANS_Futura_Std_Book_11">Equal to 0b100</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_TheSansMonoCd_W7Bold_11">op1</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Decoding group or instruction page</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">000<br/>001</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">PC-relative addressing mode instructions</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">010<br/>011</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add/subtract immediate instructions</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">100</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Logical immediate instructions</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">101</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Move Wide immediate instructions</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">110</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Bitfield instructions</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">111</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Extract instructions</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Now consider the add/subtract immediate instructions group from <a href="chapter2.xhtml#tab2-15">Table 2-15</a>. The full encoding for these instructions appears in <a href="chapter2.xhtml#fig2-24">Figure 2-24</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig2-24" src="../images/Figure2-24.jpg" alt="" width="1685" height="449"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 2-24: Add/subtract immediate instructions</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The add and subtract instructions are a classic example of a packed-data field (as discussed in section 2.12, <span class="Xref">“Bit Fields and Packed Data,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_85">page 85</a></span>). The fields have the following meanings:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>sf</b>    Indicates the instruction size (variant). If 0, this is a 32-bit instruction and the registers specified by the Reg<sub>src1</sub> and Reg<sub>dest</sub> fields are 32-bit registers. If 1, this is a 64-bit instruction, and the registers are 64-bit registers.</p>&#13;
<p class="RunInPara"><b>op (bit 30)</b>    Is an extension of the opcode (bits 24 through 28). If this bit is 0, the instruction is an <span class="SANS_TheSansMonoCd_W5Regular_11">add</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> instruction; if this bit is 1, it’s a <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_106" aria-label="106"/><b>S</b>    Specifies whether there was an <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span>) on the instruction. If this bit is 1, the instruction will update the condition code flags after the execution of the instruction; if this bit is 0, no such update takes place.</p>&#13;
<p class="RunInPara"><b>Shift</b>    Specifies how the instruction treats the Immediate12 field. I’ll discuss this field in greater detail shortly.</p>&#13;
<p class="RunInPara"><b>Immediate12</b>    Is a 12-bit unsigned integer value (0 to +4,096). This instruction will zero-extend that value to the instruction’s size (32 or 64 bits).</p>&#13;
<p class="RunInPara"><b>Reg</b><b><sub>src</sub></b>    Specifies the source register, the second operand for the instruction.</p>&#13;
<p class="RunInPara"><b>Reg</b><b><sub>dest</sub></b>    Specifies the destination register, the first operand for the instruction.</p>&#13;
</div>&#13;
<p class="TX">The Shift field depends on the Immediate12 field and is a bit complex. This field may contain 0b00 or 0b01 (0b10 and 0b11 are reserved values). If this field contains 0b00, the instruction uses the zero-extended value of the Immediate12 field as is. However, if this field contains 0b01, the instruction first shifts the Immediate12 to the left by 12 bits and uses that shifted value. This shifted form is useful when doing pointer arithmetic and adding in page offsets (see <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> for an explanation of memory-management pages).</p>&#13;
<p class="TX">If the add and subtract instructions are limited to a 12-bit immediate constant (possibly shifted to the left 12 bits), how do you add a 32- or 64-bit constant to a register? You can’t do it directly; instead, you have to load that constant into another register and use that register as the second source operand rather than an immediate constant. As I pointed out earlier, the same problem arises with the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction and immediate constants. As with add and subtract, the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction is limited to 32 bits, meaning you cannot load a 32- or 64-bit constant into a register with a single <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction. The operative word here is <i>single</i>. You can load a 32- or 64-bit constant into a register by using multiple <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instructions. The next section discusses how to do this.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
&#13;
<h3 class="H1" id="sec42"><span id="h1-38"/><span class="SANS_Futura_Std_Bold_B_11">2.19 Operand2</span></h3>&#13;
<p class="TNI1">Most ARM data processing instructions (such as <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span>) require three operands: a destination operand and two source operands. In the following instruction, X0 is the destination operand, X1 is the first source operand, and X2 is the second source operand:</p>&#13;
<pre id="pre-134"><code>add  x0, x1, x2  // Computes X0 = X1 + X2</code></pre>&#13;
<p class="TX">Thus far in this book, I’ve used registers and immediate constants as the second source operand. However, the ARM CPUs support several formats for this second operand, known as <i>Operand2</i>. These forms, shown in <a href="chapter2.xhtml#tab2-16">Table 2-16</a>, are extremely powerful, making Operand2 legendary on the ARM.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_107" aria-label="107"/>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-16"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-16:</span></span> <span class="SANS_Futura_Std_Book_11">Operand2 Allowable Fields</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Operand2</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">#immediate</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">A 12-bit immediate value of 0–4,095 (used by arithmetic instructions) or a 16-bit immediate value (used by move instructions).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">#pattern</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">A constant that specifies a run of 0s and 1s. Used to generate a bitmask for the logical instructions. For logical instructions only.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">W</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> <span class="SANS_Futura_Std_Book_11">or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">One of the general-purpose registers (32- or 64-bit).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">W</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n shiftOp</span> <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The contents of a 32-bit register shifted the number of positions specified by the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span> <span class="SANS_Futura_Std_Book_11">operand (0–31).</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">shiftOp</span> <span class="SANS_Futura_Std_Book_11">is</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">asr</span><span class="SANS_Futura_Std_Book_11">, or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ror</span><span class="SANS_Futura_Std_Book_11">.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n shiftOp</span> <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The contents of a 64-bit register shifted the number of positions specified by the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span> <span class="SANS_Futura_Std_Book_11">operand (0–63).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">W</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n extendOp</span> <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The contents of a 32-bit register are zero- or sign-extended and then shifted to the left by the immediate value (0–31). This form is not available for logical instructions, as sign extension doesn’t logically apply to those.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">extendOp</span> <span class="SANS_Futura_Std_Book_11">is</span> <span class="SANS_TheSansMonoCd_W5Regular_11">uxtb</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">uxth</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">uxtw</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">uxtx</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">sxtb</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">sxth</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">sxtw</span><span class="SANS_Futura_Std_Book_11">, or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">sxtx</span><span class="SANS_Futura_Std_Book_11">.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n extendOp</span> <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The contents of a 64-bit register are zero- or sign-extended and then shifted to the left by the immediate value (0–31). This form is not available for logical instructions, as sign extension doesn’t logically apply to those.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The following sections describe each of these Operand2 forms.</p>&#13;
<section epub:type="division" aria-labelledby="sec43">&#13;
&#13;
<h4 class="H2" id="sec43"><span id="h2-41"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.19.1 #immediate</span></h4>&#13;
<p class="TNI1">The immediate form of Operand2, or <span class="SANS_TheSansMonoCd_W5Regular_11">#immediate</span>, is one of its more common uses (the other being one of the 32 general-purpose registers). Because the immediate operand is encoded as part of the 32-bit instruction value, it is always significantly less than 32 bits in length. As you’ve seen, the arithmetic instructions allow only a 12-bit unsigned integer as an immediate operand. Other instructions allow different immediate operand sizes. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction allows 16-bit unsigned immediate operands.</p>&#13;
<p class="TX">Although many immediate constants you’ll encounter in programs will fit into 12 or 16 bits, some values won’t. As noted earlier in this chapter, in those situations you will have to load a register with the larger constant and use that value in that register, rather than using an immediate constant. See section 2.20, <span class="Xref">“Large Constants,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_111">page 111</a></span> to learn how to handle this situation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec44">&#13;
&#13;
<h4 class="H2" id="sec44"><span id="h2-42"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.19.2 #pattern</span></h4>&#13;
<p class="TNI1">The ARM logical instructions (such as <span class="SANS_TheSansMonoCd_W5Regular_11">and</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span>) provide a 13-bit immediate (<span class="SANS_TheSansMonoCd_W5Regular_11">#pattern</span>) field encoded into the 32-bit instruction. However, this is not a straightforward 13-bit immediate value. Instead, it’s a combination of 3 separate bit fields that form a <i>bitmask pattern</i>. <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span> describes the use of these bitmasks in greater detail. Until then, understand that there are some weird limitations on the type of immediate constants that the logical instructions support.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_108" aria-label="108"/>The Arm Compiler Armasm User Guide’s entry is difficult to understand. Basically, it says that immediate constants for logical instructions consist of binary values that contain a run (consecutive sequence) of 1 bits followed by (and possibly preceded by) 0 bits. Each sequence can be 2, 4, 8, 16, 32, or 64 bits in length. The following are legal examples of such immediate constants:</p>&#13;
<pre id="pre-135"><code>and     x0, x0, #0b1&#13;
and     x0, x0, #0b11&#13;
and     x0, x0, #0b111&#13;
and     x0, x0, #0b1110&#13;
and     x0, x0, #0b11100</code></pre>&#13;
<p class="Continued1">In each case, there is a single run of 1 bits, possibly surrounded by 0 bits.</p>&#13;
<p class="TX">The following examples are not legal immediate constants:</p>&#13;
<pre id="pre-136"><code>and     x0, x0, #0b101&#13;
and     x0, x0, #0b10101&#13;
and     x0, x0, #0b1110111&#13;
and     x0, x0, #0b101100</code></pre>&#13;
<p class="Continued1">These examples are illegal because they contain multiple runs of 1 bits within the same immediate constant.</p>&#13;
<p class="TX">The “vector of identical elements” phrase (from the Armasm Guide) tells us that if the sequence is less than the register size (32 or 64 bits), the instruction replicates the sequence throughout the register in order to fill it to 32 or 64 bits. Therefore, it is possible to have multiple runs of 1 bits in an immediate constant if there are identical sequences of 1s and 0s, where each sequence is a multiple of 2, 4, 8, 16, or 32 bits in length. The following are legal examples:</p>&#13;
<pre id="pre-137"><code>// This AND instruction contains 4 copies of the sequence&#13;
// 0b11110000:&#13;
&#13;
        and     w0, w0, #0b11110000111100001111000011110000&#13;
&#13;
// This sequence is legal because it contains 16 copies of&#13;
// the 2-bit sequence 0b10:&#13;
&#13;
        and     w0, w0, #0b01010101010101010101010101010101&#13;
&#13;
// This sequence is legal because it contains 2 copies of&#13;
// the 32-bit sequence 0b11111111111111110000000000000000:&#13;
&#13;
        and     x0, x0, #0xFFFF0000FFFF0000</code></pre>&#13;
<p class="TX">However, if you want to use the “vector of identical elements” scheme, you must provide a constant that completely fills the destination register. The following example is illegal because it has two runs within 16 bits that are not replicated throughout the HO 16 bits of the 32-bit W0 register:</p>&#13;
<pre id="pre-138"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_109" aria-label="109"/>and     w0, w0, #0b1111000011110000</code></pre>&#13;
<p class="Continued1">This scheme is confusing but generates the most common types of immediate constants with just a few bits, so the complexity is worth it.</p>&#13;
<p class="TX">If you accidentally supply an inappropriate constant, Gas will respond with an error message such as <span class="SANS_TheSansMonoCd_W5Regular_11">error: expected compatible register or logical immediate</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">error: immediate out of range at operand 3 -- 'and w0,w0,#0b1111000011110000'</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec45">&#13;
&#13;
<h4 class="H2" id="sec45"><span id="h2-43"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.19.3 Register</span></h4>&#13;
<p class="TNI1">The most common form for Operand2 is one of the ARM’s general-purpose registers (32 or 64 bits). Given that registers have appeared in most examples thus far, there’s no need to further discuss this form.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec46">&#13;
&#13;
<h4 class="H2" id="sec46"><span id="h2-44"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.19.4 Shifted Register</span></h4>&#13;
<p class="TNI1">Another Operand2 form combines an ARM register with a shift operation. This form adds an extra operand to the instruction, consisting of one of the shift operators in <a href="chapter2.xhtml#tab2-17">Table 2-17</a> along with a small immediate constant (in the range 0 to <i>n</i>, where <i>n</i> is the size of the destination register).</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-17"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-17:</span></span> <span class="SANS_Futura_Std_Book_11">Operand2 Shift Operators</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lsl #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Logically shifts a copy of the Operand2 register value to the left</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span> <span class="SANS_Futura_Std_Book_11">bits and uses the result.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lsr #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Logically shifts a copy of the Operand2 register value to the right</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span> <span class="SANS_Futura_Std_Book_11">bits and uses the result.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">asr #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Arithmetically shifts a copy of the Operand2 register value to the right</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span> <span class="SANS_Futura_Std_Book_11">bits and uses the result.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ror #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Logically rotates a copy of the Operand2 register value to the right</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span> <span class="SANS_Futura_Std_Book_11">bits and uses the result. This form is available with only the logical instructions.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">As you’ll see in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, using the shifted register Operand2 form will prove handy when indexing into arrays and other data structures.</p>&#13;
<p class="TX">To use the shifted register Operand2 form, simply tack on an extra operand to the end of the instruction’s operand list with one of the operators appearing in <a href="chapter2.xhtml#tab2-17">Table 2-17</a>. Here are some examples:</p>&#13;
<pre id="pre-139"><code>add w0, w1, w2, lsl #4  // W0 = W1 + (W2 &lt;&lt; 4)&#13;
sub x0, x1, x2, lsr #1  // X0 = X1 - (X2 &gt;&gt; 1)&#13;
add x0, x1, x2, asr #1  // X0 = X1 + (X2 asr 1)&#13;
and x0, x1, x2, ror #2  // X0 = X1 &amp; (X2 ror 2)</code></pre>&#13;
<p class="TX">As the comments indicate, each of these instructions shifts the value in W2 or X2 before using that value as the second source operand.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec47">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_110" aria-label="110"/>&#13;
<h4 class="H2" id="sec47"><span id="h2-45"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.19.5 Extending Register</span></h4>&#13;
<p class="TNI1">The last set of Operand2 forms provide zero and sign extension, along with an optional logical shift left, of an Operand2 register. The basic instruction syntax is</p>&#13;
<pre id="pre-140"><code>instr  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span><var>, reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span><var>, reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span><var>, extendop #optional_imm</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">extendop</span> is one of the operators in <a href="chapter2.xhtml#tab2-18">Table 2-18</a>. If the <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span> value is not present, it defaults to 0.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab2-18"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 2-18:</span></span> <span class="SANS_Futura_Std_Book_11">Extend Operators</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Extend operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">uxtb #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Zero-extends the LO byte of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">to the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span><span class="SANS_Futura_Std_Book_11">. The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">operand should be a word-sized register (W</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">), regardless of the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span><span class="SANS_Futura_Std_Book_11">. (Gas seems to accept a dword register, substituting the corresponding word register.) If the optional immediate value is present, it must be a value in the range 0–4 and will shift the result of the extension by the specified number of bits.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">uxth #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Zero-extends the LO half word of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">to the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span><span class="SANS_Futura_Std_Book_11">. The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">operand should be a word-sized register (W</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">), regardless of the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span><span class="SANS_Futura_Std_Book_11">. If the optional immediate value is present, it must be a value in the range 0–4 and will shift the result of the extension by the specified number of bits.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">uxtw #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Zero-extends the LO word of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">to the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span><span class="SANS_Futura_Std_Book_11">. The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">operand should be a word-sized register (W</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">), regardless of the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span><span class="SANS_Futura_Std_Book_11">. If the optional immediate value is present, it must be a value in the range 0–4 and will shift the result of the extension by the specified number of bits. Note that if all the registers are words (W</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">), then this operator is equivalent to</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lsl #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span><span class="SANS_Futura_Std_Book_11">.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">uxtx #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">This operator is applicable only when all the registers are 64 bits. This is the default condition if no extend (or shift) operator is present after an Operand2 register.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">sxtb #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Sign-extends the LO byte of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">to the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span><span class="SANS_Futura_Std_Book_11">. The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">operand should be a word-sized register (W</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">), regardless of the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span><span class="SANS_Futura_Std_Book_11">. If the optional immediate value is present, it must be a value in the range 0–4 and will shift the result of the extension by the specified number of bits.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">sxth #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Sign-extends the LO half word of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">to the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span><span class="SANS_Futura_Std_Book_11">. The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">operand should be a word-sized register (W</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">), regardless of the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span><span class="SANS_Futura_Std_Book_11">. If the optional immediate value is present, it must be a value in the range 0–4 and will shift the result of the extension by the specified number of bits.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">sxtw #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Sign-extends the LO word of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">to the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span><span class="SANS_Futura_Std_Book_11">. The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> <span class="SANS_Futura_Std_Book_11">operand must be a word-sized register (W</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">), regardless of the size of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span><span class="SANS_Futura_Std_Book_11">. If the optional immediate value is present, it must be a value in the range 0–4 and will shift the result of the extension by the specified number of bits. If all the registers are words (W</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">), this operator is equivalent to</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lsl #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span><span class="SANS_Futura_Std_Book_11">. Note that</span> <span class="SANS_TheSansMonoCd_W5Regular_11">uxtw</span> <span class="SANS_Futura_Std_Book_11">is preferred over this form when all registers are word sized (both do the same thing with word-sized registers).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">sxtx #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">This operator is applicable only when all the registers are 64 bits. This is effectively the same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">uxtx</span> <span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_TheSansMonoCd_W5Regular_11">uxtx</span> <span class="SANS_Futura_Std_Book_11">is the preferred form).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lsl #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">optional_imm</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">If the extend operator is redundant (</span><span class="SANS_TheSansMonoCd_W5Regular_11">uxtx</span><span class="SANS_Futura_Std_Book_11">/</span><span class="SANS_TheSansMonoCd_W5Regular_11">sxtx</span> <span class="SANS_Futura_Std_Book_11">for double words,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">uxtw</span><span class="SANS_Futura_Std_Book_11">/</span><span class="SANS_TheSansMonoCd_W5Regular_11">sxtw</span> <span class="SANS_Futura_Std_Book_11">for word registers), you should use the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> <span class="SANS_Futura_Std_Book_11">operator for clarity (it is the same operation).</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The extension operators are very useful for mixed-sized arithmetic. <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> discusses this when it covers operating on different-sized operands.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec48">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_111" aria-label="111"/>&#13;
<h3 class="H1" id="sec48"><span id="h1-39"/><span class="SANS_Futura_Std_Bold_B_11">2.20 Large Constants</span></h3>&#13;
<p class="TNI1">At several points, this chapter has punted on the solution to dealing with immediate constants that don’t fit into 12 or 16 bits. It’s time to rectify that omission.</p>&#13;
<p class="TX">As mentioned, if you need a constant for an arithmetic or logical operation that won’t fit within the bits set aside for constants in the instruction’s encoding, you’ll have to load that constant into a register and operate on the register rather than directly using the constant. The drawback to this scheme is that you’ll need at least one additional instruction, and often more, to first load the constant into a temporary register so you can use that value in an arithmetic operation. For example, suppose you want to add the value 40,000 to the X1 register. The following instruction won’t work because 40,000 won’t fit in 12 bits:</p>&#13;
<pre id="pre-141"><code>add x1, x1, #40000</code></pre>&#13;
<p class="Continued1">However, since 40,000 will fit in 16 bits, you could do the following:</p>&#13;
<pre id="pre-142"><code>mov x0, #40000  // Works, because mov allows 16-bit consts&#13;
add x1, x1, x0  // Add 40000 to X1.</code></pre>&#13;
<p class="Continued1">Sadly, your program will be a little larger (an extra 4 bytes for the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction) and a little slower (executing two instructions rather than one), but it’s about as efficient as it’s going to get.</p>&#13;
<p class="TX">What if you want to add a constant that won’t fit into 16 bits (perhaps 400,000)? This problem has a couple of solutions. First, as you saw in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, a variant of the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction allows you to load any sized constant into a register (32 or 64 bits). That form has the following syntax</p>&#13;
<pre id="pre-143"><code>ldr <var>reg</var>, =<var>largeConstant</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span> is a general-purpose register (32- or 64-bit) and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">largeConstant</span> is an immediate value (literal or symbolic) that will fit in the specified register. This instruction form will set aside storage (within the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, which is read-only) and initialize that storage with the specified constant. When the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction executes, it will load the contents of that memory location into the specified register.</p>&#13;
<p class="TX">This single instruction is a convenient way to load a large constant into a register. However, this approach has a couple of problems. First, accessing memory on the ARM is a relatively slow process. Second, because Gas inserts the constant into your <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, it could affect the performance of other code in your program; although this is rare and probably not worth worrying about, it’s something to keep in mind.</p>&#13;
<p class="TX">Fortunately, you can load larger constants into a general-purpose register in other ways. These techniques involve additional variants of the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction: <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">movk</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec49">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_112" aria-label="112"/>&#13;
<h4 class="H2" id="sec49"><span id="h2-46"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.20.1 movz</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> instruction (move, with zeroing) has the following syntax</p>&#13;
<pre id="pre-144"><code>movz <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>&#13;
movz <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, lsl #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> is any general-purpose (32- or 64-bit) register, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> is a 16-bit immediate constant, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> is one of the four values 0, 16, 32, or 48 (0 is the default value, if the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> operand is not present).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> instruction will take the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> constant and shift it to the left the number of bits specified by the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">imm</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> constant (with 0s in all the other bit positions, hence the <i>with zeroing</i> in the name). It will then move this shifted constant into the destination register. The following three instructions do exactly the same thing, loading the constant 122 into X0:</p>&#13;
<pre id="pre-145"><code>mov  x0, #122&#13;
movz x0, #122&#13;
movz x0, #122, lsl #0</code></pre>&#13;
<p class="TX">The difference between <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> is that <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> will sign-extend the immediate constant you supply, whereas <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> will zero-extend the constant. For values less than 0x8000, both will load the same constant into the destination register (in fact, the assembler may convert the <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> instruction to <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> if both would produce the same result). Keep in mind that the shift value can be only 0, 16, 32, or 48; you cannot specify an arbitrary bit-shift value for this instruction.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> instruction is useful when you want to load a 16-bit value into the HO half word of a 32-bit register, or one of the three HO half words (1, 2, or 3) of a 64-bit register.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec50">&#13;
&#13;
<h4 class="H2" id="sec50"><span id="h2-47"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.20.2 movk</span></h4>&#13;
<p class="TNI1">Although the <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> instruction allows you to move some values that are larger than 65,535 into a register, it’s not a general solution for loading 32- and 64-bit constants into a register. The <span class="SANS_TheSansMonoCd_W5Regular_11">movk</span> instruction (combined with <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span>) fulfills that role. The <span class="SANS_TheSansMonoCd_W5Regular_11">movk</span> instruction (move and keep unaffected bits) has a syntax very similar to <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span>:</p>&#13;
<pre id="pre-146"><code>movk <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1  </span>// Default is "lsl #0"&#13;
movk <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, lsl #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span></code></pre>&#13;
<p class="Continued1">The <span class="SANS_TheSansMonoCd_W5Regular_11">movk</span> instruction will shift the immediate operand by 0, 16, 32, or 48 bits and then merge that value into the destination register. (It does not zero the other bit positions but instead preserves their original values.)</p>&#13;
<p class="TX">To load a 32-bit immediate constant into the W0 register, use the following instruction sequence:</p>&#13;
<pre id="pre-147"><code>mov  w0, #LO_16_bits&#13;
movk w0, #HO_16_bits, lsl #16</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_113" aria-label="113"/>To load a full 64 bits into X0, use the following:</p>&#13;
<pre id="pre-148"><code>mov  x0, #LO_16_bits&#13;
movk x0, #Bits_16_to_31, lsl #16&#13;
movk x0, #Bits_32_to_47, lsl #32&#13;
movk x0, #HO_16_bits, lsl #48</code></pre>&#13;
<p class="Continued1">Most of the time, the immediate constant won’t require a full 64 bits, so you might be able to get by with two or three instructions rather than the full four. However, you’ll never need more than four instructions to load a 64-bit constant into a register (and never more than two to load a 32-bit constant).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec51">&#13;
&#13;
<h4 class="H2" id="sec51"><span id="h2-48"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">2.20.3 movn</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">movn</span> (move not) instruction is another variant of <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> that logically negates the immediate constant before loading it into the destination register. The syntax is the same as <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span> (swapping, of course, <span class="SANS_TheSansMonoCd_W5Regular_11">movn</span> for <span class="SANS_TheSansMonoCd_W5Regular_11">movz</span>):</p>&#13;
<pre id="pre-149"><code>movn <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>    // Default shift is lsl #0.&#13;
movn <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, lsl #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">movn</span> instruction shifts the immediate constant by 0, 16, 32, or 48 bits and then inverts the whole (32- or 64-bit) bit string before assigning it to the destination register.</p>&#13;
<p class="TX">Consider the following example:</p>&#13;
<pre id="pre-150"><code>movn x1, #0xff, lsl 16</code></pre>&#13;
<p class="TX">This instruction loads 0xFFFFFFFFFF00FFFF into the X1 register. (0xFF shifts left 16 bit positions and then inverts all the bits.)</p>&#13;
<p class="TX">Particularly when loading negative constants into a register, the <span class="SANS_TheSansMonoCd_W5Regular_11">movn</span> instruction can help reduce the number of instructions needed to load a 64-bit constant. However, 32-bit constants, which don’t fit into 16 bits, will generally take two instructions no matter what. This differs from the <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> instruction in that it allows shifted immediate constants.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec52">&#13;
&#13;
<h3 class="H1" id="sec52"><span id="h1-40"/><span class="SANS_Futura_Std_Bold_B_11">2.21 Moving On</span></h3>&#13;
<p class="TNI1">This chapter covered basic data types, representation, and operations on those data types. This includes the decimal, binary, and hexadecimal numbering systems, and machine-level data including bits, nibbles, and so on. It discussed logical operations on bits and bit strings, signed and unsigned integer representation and sign and zero extension to expand the number of bits used by a number, as well as sign contraction and saturation to reduce the number of bits used by a number. It also introduced floating-point and BCD data formats and character data (including ASCII and Unicode characters).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_114" aria-label="114"/>This chapter also included information on machine instruction encoding and presented ARM assembly language instructions to load and store memory values, compare and branch instructions for controlling program flow, and shift and rotate instructions. It described packing data into bit fields, the Operand2 formats for constants and other operands, and how to load large constants that won’t fit in the 32-bit instruction encoding into a register.</p>&#13;
<p class="TX">In short, this chapter provided the tools and techniques you need for manipulating various types of constants in assembly language programs. While constants are an important part of any assembly language program, being able to manipulate variable data is the basis of most computer systems. The next chapter discusses the ARM memory subsystem and how to create and efficiently use memory-based variables.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec53">&#13;
&#13;
<h3 class="H1" id="sec53"><span id="h1-41"/><span class="SANS_Futura_Std_Bold_B_11">2.22 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">For general information about data representation and Boolean functions, consider reading my book <i>Write Great Code</i>, Volume 1, 2nd edition (No Starch Press, 2020), or a textbook on data structures and algorithms.</li>&#13;
<li class="BL">ASCII and Unicode are both International Organization for Standardization (ISO) standards, and ISO provides reports for both character sets. Generally, those reports cost money, but you can also find lots of information about the ASCII and Unicode character sets by searching for them by name on the internet. You can also read about Unicode at <i><a href="https://www.unicode.org">https://<wbr/>www<wbr/>.unicode<wbr/>.org</a></i>. Finally, <i>Write Great Code</i>, cited previously, contains additional information on the history, use, and encoding of the Unicode character set.</li>&#13;
<li class="BL">For more on ARM CPUs, see <i><a href="https://developer.arm.com">https://<wbr/>developer<wbr/>.arm<wbr/>.com</a></i>.</li>&#13;
<li class="BL">To learn more on the IEEE floating-point single-precision format, see <i><a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Single<wbr/>-precision<wbr/>_floating<wbr/>-point<wbr/>_format</a></i>.</li>&#13;
<li class="BL">Find out more about the IEEE floating-point double-precision format at <i><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Double<wbr/>-precision<wbr/>_floating<wbr/>-point<wbr/>_format</a></i>.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-9">&#13;
<p class="BH" id="box-9"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What does the decimal value 9,384.576 represent (in terms of powers of 10)?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  Convert the following binary values to decimal:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  1010</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  1100</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  0111</span></p>&#13;
<p class="BoxListLetterSub"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_115" aria-label="115"/><span class="SANS_Futura_Std_Book_11">d.  1001</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">e.  0011</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">f.  1111</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  Convert the following binary values to hexadecimal:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  1010</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  1110</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  1011</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">d.  1101</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">e.  0010</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">f.  1100</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">g.  1100_1111</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">h.  1001_1000_1101_0001</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  Convert the following hexadecimal values to binary:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  12AF</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  9BE7</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  4A</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">d.  137F</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">e.  F00D</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">f.  BEAD</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">g.  4938</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  Convert the following hexadecimal values to decimal:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  A</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  B</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  F</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">d.  D</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">e.  E</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">f.  C</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  How many bits are there in a:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  Word</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  Qword</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  Half word</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">d.  Dword</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">e.  BCD digit</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">f.  Byte</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">g.  Nibble</span></p>&#13;
<p class="BoxListNumber"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_116" aria-label="116"/><span class="SANS_Futura_Std_Book_11">  7.  How many bytes are there in a:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  Word</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  Dword</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  Qword</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">d.  Half word</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  How many different values can you represent with a:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  Nibble</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  Byte</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  Half word</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">d.  Bit</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  9.  How many bits does it take to represent a hexadecimal digit?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">10.  How are the bits in a byte numbered?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">11.  Which bit number is the LO bit of a word?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">12.  Which bit number is the HO bit of a dword?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">13.  Compute the AND of the following binary values:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  0 and 0</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  0 and 1</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  1 and 0</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">d.  1 and 1</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">14.  Compute the OR of the following binary values:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  0 or 0</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  0 and 1</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  1 and 0</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">d.  1 and 1</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">15.  Compute the XOR of the following binary values:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  0 and 0</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  0 and 1</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  1 and 0</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">d.  1 and 1</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">16.  The NOT operation is the same as XORing with what value?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">17.  Which logical operation would you use to force bits to 0 in a bit string?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">18.  Which logical operation would you use to force bits to 1 in a bit string?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">19.  Which logical operation would you use to invert all the bits in a bit string?</span></p>&#13;
<p class="BoxListNumber"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label="117"/><span class="SANS_Futura_Std_Book_11">20.  Which logical operation would you use to invert selected bits in a bit string?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">21.  Which machine instruction will invert all the bits in a register?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">22.  What is the two’s complement of the 8-bit value 5 (00000101b)?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">23.  What is the two’s complement of the signed 8-bit value –2 (11111110)?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">24.  Which of the following signed 8-bit values are negative?</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  1111_1111b</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  0111_0001b</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  1000_0000b</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">d.  0000_0000b</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">e.  1000_0001b</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">f.  0000_0001b</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">25.  Which machine instruction takes the two’s complement of a value in a register or memory location?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">26.  Which of the following 16-bit values can be correctly sign-contracted to 8 bits?</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  1111_1111_1111_1111</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  1000_0000_0000_0000</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  000_0000_0000_0001</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">d.  1111_1111_1111_0000</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">e.  1111_1111_0000_0000</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">f.  0000_1111_0000_1111</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">g.  0000_0000_1111_1111</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">h.  0000_0001_0000_0000</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">27.  What machine instruction provides the equivalent of an HLL</span> <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span> <span class="SANS_Futura_Std_Book_11">statement?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">28.  What is the syntax for a GNU statement label?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">29.  What flags are the condition codes?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">30.  Which condition code does</span> <span class="SANS_TheSansMonoCd_W5Regular_11">beq</span> <span class="SANS_Futura_Std_Book_11">test?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">31.  Which condition codes does</span> <span class="SANS_TheSansMonoCd_W5Regular_11">blo</span> <span class="SANS_Futura_Std_Book_11">test?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">32.  Which conditional branch instructions transfer control based on an unsigned comparison?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">33.  Which conditional branch instructions transfer control based on a signed comparison?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">34.  How does the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> <span class="SANS_Futura_Std_Book_11">instruction affect the zero flag?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">35.  A shift left is equivalent to what arithmetic operation?</span></p>&#13;
<p class="BoxListNumber"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label="118"/><span class="SANS_Futura_Std_Book_11">36.  A shift right is equivalent to what arithmetic operation?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">37.  When performing a chain of floating-point addition, subtraction, multiplication, and division operations, which operations should you try to do first?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">38.  What is a normalized floating-point value?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">39.  How many bits does a (standard) ASCII character require?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">40.  What is the hexadecimal representation of the ASCII characters 0 through 9?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">41.  What delimiter character(s) does Gas use to define character constants?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>