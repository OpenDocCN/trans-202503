- en: '**4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DYNAMIC ANALYSIS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter uses a malware sample from the Xenomorph phishing family, first
    described by Dutch security company ThreatFabric in March 2022, to introduce popular
    dynamic analysis tools for Android and best practices for using these tools. We
    cover the use of a device emulator to run the malicious app, as well as the use
    of tcpdump, Wireshark, and Frida to learn about the app’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In any serious reverse engineering context, analysts use static and dynamic
    techniques in tandem to speed up malware analysis. Thus, toward the end of this
    chapter, we’ll supplement our dynamic analysis with static analysis in jadx. You’ll
    witness how to use dynamic analysis to gain a broad understanding of a piece of
    malware functionality, then seek out additional information through static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is Dynamic Code Analysis?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In program analysis and reverse engineering, the term *dynamic analysis* or
    *dynamic code analysis* refers to the application of analysis techniques that
    uncover properties of the program under observation by executing its code. This
    contrasts with static analysis, described in the previous chapter, which aims
    to discover properties of a program by analyzing its code and structure without
    executing it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, running an app is not enough to understand what the app is doing.
    Dynamic analysis involves a whole arsenal of tools that monitor and interact with
    the app, including debuggers and software to intercept API calls, dump memory,
    or inspect network traffic. Still other tools might implement ways to interact
    with the app’s GUI or automatically test the app’s security properties for potential
    vulnerabilities. When run together, these tools should build a picture of how
    an app interacts with a device. The more tools you deploy to monitor the device,
    the more complete your understanding of the app becomes. However, deploying and
    maintaining all of these tools can take considerable time and money.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic vs. Static Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamic and static analysis are complements. To get a full picture of an app’s
    functionality, you’ll need to use both forms of analysis, and all professional
    malware analysis programs do so.
  prefs: []
  type: TYPE_NORMAL
- en: An example of the stark differences between static and dynamic analysis is the
    amount of effort required to set them up. For static analysis, you only have to
    load an app into jadx. On the other hand, dynamic analysis requires first setting
    up a device (real or virtual) that can execute the program, then making sure you
    have the ability to intercept and log system calls, network traffic, filesystem
    changes, and any other device modifications that the app could make. Finally,
    you have to execute the app and interact with it in the hopes of triggering malicious
    functionality. This can be more difficult than you might expect, as malware apps
    often deploy myriad anti-analysis tricks and refuse to run when they believe they
    are under analysis in a security researcher’s test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have overcome all of these obstacles and have an app running on your
    test device, however, dynamic analysis shines. It is much faster to make progress
    than with static analysis, as you can observe what the app is doing and try to
    force its execution in any direction that interests you. Your analysis system
    will log all sensitive API calls, network traffic, and environmental information
    and put the details into a report for you to study later. There is no need to
    slog through all the app code, as with static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Another place where dynamic and static analysis complement each other is in
    terms of *code coverage*, a measure of how much code an analysis technique can
    analyze. In static analysis, all of an app’s code is available for analysis. In
    dynamic analysis, you can only consider the executed code. The difference between
    the two can be huge. Even the best dynamic analysis runs of an app struggle to
    execute more than 5 to 10 percent of an app’s code. The remaining 90 to 95 percent
    remains a mystery and can only be uncovered by static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Android Studio Emulator**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first tool you’ll have to set up for dynamic analysis is the runtime environment
    in which to execute the app. You can choose to use either a real Android device
    or an emulated one. Next, you must select the device type and configuration and,
    if you’re using an emulator, whether to use the default emulator that comes with
    the Android SDK or a third-party one.
  prefs: []
  type: TYPE_NORMAL
- en: Using an emulator is cheap and allows you to quickly reset your analysis if
    something goes wrong. You can also get started easily. On the other hand, most
    Android malware tries to detect whether it’s running in an emulator and behaves
    differently if it thinks it’s under analysis, which can lead to you wasting large
    amounts of time. If you use a real device, you’ll breeze past these checks.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the standard Android emulator that ships with the Android Studio IDE
    and the Android SDK for the dynamic analysis in this chapter. We recommend installing
    Android Studio in its entirety, as it sets up the necessary SDK packages for you
    and provides a nice user interface. Installing just the Android SDK works too,
    but it requires a lot more fiddling around. You can download Android Studio at
    [*https://developer.android.com/studio*](https://developer.android.com/studio).
    Follow the instructions at [*https://developer.android.com/studio/install*](https://developer.android.com/studio/install)
    to install it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a System Image***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before you can start the emulator, you must first create a system image that
    the emulator can boot. The most comfortable way to do this is by using Android
    Studio. Access the device manager configuration screen by selecting **Tools**
    ▸ **Device Manager**. The device manager will walk you through creating system
    images for the Android emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use a system image configured for a Pixel XL device with API 30, compiled
    for a 32-bit x86 architecture. We chose this architecture to make the emulator
    faster, as these images can use a real computer’s CPU virtualization features.
    Choosing an ARM processor image is slower, as an x86 host machine would have to
    emulate the ARM architecture. Of course, if you’re running an ARM-based host computer,
    you should choose an ARM-based Android system image, for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: '***Starting the Emulator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While it’s possible to start the Android emulator from Android Studio, we prefer
    to run it from the command line. This provides us with a whole range of command
    line options that aren’t easily accessible from Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick way to start the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command takes just two arguments. We use `@` to pass the name of the API
    30 Pixel XL system image created in Android Studio in the previous step. The second
    argument, `-no-boot-anim`, disables the system boot animation to boot up the system
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: '***Resetting the Emulator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During your dynamic analysis, you’ll often want to return to a clean slate by
    removing all artifacts created by previous runs of the malware from the system.
    Otherwise, you might get confused about where certain malware artifacts came from
    if you can’t tie them to anything that happened during the most recent run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to get back to a clean slate is to wipe all data from the Android
    emulator and reset it to its original state. The emulator provides the handy `-wipe-data`
    command line argument for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We highly recommend making liberal use of this argument between malware runs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Interacting with the Emulator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To interact with the emulated device, we will use the Android Debug Bridge command
    line tool, adb, which ships with the Android SDK and can communicate with devices
    over USB or TCP/IP. This tool supports a dozen or so commands that you can learn
    more about by running `adb --help`. Throughout this chapter, we’ll use adb commands
    to install apps on the device, upload files to it, and download files from it.
  prefs: []
  type: TYPE_NORMAL
- en: '**EMULATORS AND ANTI-ANALYSIS TECHNIQUES**'
  prefs: []
  type: TYPE_NORMAL
- en: Hundreds of dynamic anti-analysis techniques published on the internet attempt
    to detect emulators. These techniques range from fairly simple to quite sophisticated.
    For example, the default Android emulator does not attempt to hide itself. Rather,
    it broadcasts that it’s an emulator through system properties like its device
    model (set to `goldfish`) and its emulated mobile carrier (set to `Android`).
    Malware can easily detect that it’s running on this emulator by checking these
    system properties or by looking at the CPU architecture of the device it’s running
    on. There are nearly no real x86 Android devices, so anytime an app is running
    on an x86 CPU, it’s probably on an emulated device.
  prefs: []
  type: TYPE_NORMAL
- en: But apps don’t have to rely on these default values or hardware properties to
    detect emulators. Some may check whether popular apps like Facebook are installed
    on the device. Facebook is found on nearly all real devices but rarely on emulators.
    Other apps check whether the user’s SMS and web browsing history resemble a real
    user’s or are empty, like on a newly spun-up emulator. In even more extreme cases,
    apps can run code to evaluate timing properties of memory access. Emulated memory
    behaves differently at the hardware level than real, physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: Many publicly documented anti-analysis techniques target the dynamic analysis
    tools frequently installed on emulators. Usually, these techniques attempt to
    detect files, processes, or other system properties that are only present when
    a dynamic analysis tool is installed. In particular, malware can detect the powerful
    Frida tool used in this chapter in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: In a professional malware analysis lab, the cat-and-mouse game between apps
    trying to detect dynamic analysis tools and lab developers trying to hide them
    is one of the most time-consuming aspects of the profession. In the worst-case
    scenario, malware developers can upload malware files that specifically target
    your lab. These apps enumerate the system properties of your devices and send
    the information back to the malware developers, who then build anti-analysis techniques
    specifically for your equipment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic Analysis Tools**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the Android emulator, we’ll use several third-party applications in
    our analysis: tcpdump, to intercept and log network traffic from the emulator;
    Wireshark, to analyze that network traffic; and Frida, to manipulate the malware
    we analyze.'
  prefs: []
  type: TYPE_NORMAL
- en: '***tcpdump***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tcpdump command line tool is a network traffic logger and analyzer. We’ll
    use it to capture all network traffic sent between the malware and its command-and-control
    server so that we can inspect the data that the malware collects and the commands
    it receives.
  prefs: []
  type: TYPE_NORMAL
- en: As tcpdump is an open source tool, you can download it from [*https://tcpdump.org*](https://tcpdump.org).
    The official website distributes source code only, so you’ll have to compile it
    for the Android CPU architecture of your test device. Instructions for compiling
    tcpdump can be found in the official GitHub repository, at [*https://github.com/the-tcpdump-group/tcpdump/blob/master/INSTALL.md*](https://github.com/the-tcpdump-group/tcpdump/blob/master/INSTALL.md).
    Third-party websites also host precompiled tcpdump binaries for different Android
    CPU architectures, but we don’t know how trustworthy these third-party sites are,
    so proceed with caution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, install tcpdump on Android with adb by pushing the binary to the device
    and marking it as executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `adb push` command transfers a file from the host computer to the Android
    device, and `adb shell` executes shell commands on the device. Please note that
    Android uses the MirBSD Korn Shell (mksh), which might behave differently from
    the more popular Bash shell to which you are probably accustomed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Wireshark***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Wireshark is an open source network traffic analyzer. We’ll use it as a GUI
    for the data captured by tcpdump. You can download it from its official website,
    [*https://wireshark.org*](https://wireshark.org). Because you’ll install Wireshark
    on your host system, not on the Android emulator, choose the installer for your
    host system. For example, if you are running Windows, install Wireshark for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '***Frida***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Frida is a dynamic instrumentation toolkit that you can use to analyze running
    applications, log what they execute, and manipulate them at runtime. It is open
    source and supports many different operating systems and executable file formats.
    The official way to install Frida is to use pip, a package installer for the Python
    programming language, so as a prerequisite to using Frida, you must first install
    the latest versions of Python 3 and pip from [*https://python.org*](https://python.org)
    and [*https://pypi.org/project/pip/*](https://pypi.org/project/pip/). Next, install
    Frida by running `pip install frida-tools`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like adb, Frida uses a client/server architecture: a server binary (`frida-server`)
    runs on the Android device, and a client (`frida`) runs on the host machine to
    interact with the Android device. Download `frida-server` from Frida’s GitHub
    page ([*https://github.com/frida/frida*](https://github.com/frida/frida)), which
    offers precompiled binaries for many different operating systems and CPU architectures,
    then install it on the Android device using adb and make the file executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**The Malware Sample**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve installed our dynamic analysis tools, we can begin our analysis.
    We’ll look at an Android malware sample called *com.spike.old* (v1, 2877). This
    malware, which masquerades as a device cleaner utility, was never directly found
    on Google Play. Rather, its distributors uploaded a separate malware dropper app,
    *vizeeva.fast.cleaner* (v4, 8f50), which downloaded and installed *com.spike.old*.
  prefs: []
  type: TYPE_NORMAL
- en: This phishing application of the Xenomorph family has some interesting properties
    that we will explore in this chapter. It targets banks across the world, as well
    as some other apps whose login credentials have value to the malware developers.
    When users interact with the legitimate bank apps, the malware tries to phish
    for the user’s credentials by faking a login dialog that looks like it comes from
    the legitimate app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin our analysis, download the malware file from [*https://github.com/android-malware-ml-book*](https://github.com/android-malware-ml-book).
    Then install the app on the emulator using the `adb install` command, which takes
    an APK file on the host machine, uploads it to the Android device, and initiates
    the installation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find an installed app’s private data in the */data/data/<package name>*
    directory. Immediately after you’ve installed the app, this directory exists but
    is empty, as you can see by inspecting it with the commands shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first command, `adb root`, restarts the adb daemon (`adbd`) on the device
    with root privileges. You must do this to access the private files of apps that
    are protected by Android’s process isolation security guarantees. The output shows
    three default directories that were created during installation, but no files
    yet. In future malware analysis, you can skip this directory check, as the layout
    of app directories is always the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Malicious Functionality**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll execute the app while our dynamic analysis tools run in the background
    to monitor what it’s doing. This workflow is the essence of dynamic analysis,
    and the approach of this section mirrors the steps taken to find entry points
    in [Chapter 3](ch03.xhtml). The difference is that instead of looking for structural
    properties of the app (like permissions, APIs, or entry points), we’re now observing
    different effects of the malware on its environment and using these as clues for
    further analysis of the malware’s functionality. Concretely, we will look at how
    the malware interacts with the emulator’s filesystem, its network connections,
    and the system log.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the app, you can either start it through the app drawer in the emulator,
    like a regular user, or use the command line with adb’s somewhat obscure app starting
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Originally developed for app testing, `monkey` is a helper program on Android
    that simulates a real user interacting with the target app. Here, we only use
    its capability to start a given app by name. The trailing `1` refers to the number
    of user interface events we want `monkey` to simulate in the target process. In
    our case, we only need to start the app once.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the app is running, it should display the screen shown in [Figure 4-1](ch04.xhtml#ch4fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: The first screen of the malicious sample*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the app tries to convince the user to grant it access to the
    powerful accessibility API. A click of the large circular button at the bottom
    opens the system dialog, where the user can give the app this permission. For
    now, we won’t grant access to the accessibility permission or go deeper into the
    application. Instead, we’ll move on to the next step of the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '***Observing Filesystem Changes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that the app is running, we can take another look at its default file directory.
    To make this output more useful, let’s refine the `adb` command to dump the file
    types of all files in this directory. The quotation marks are necessary due to
    the trailing semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the creation of a lot of new files. Many of these are boilerplate
    files created by Android, but two stand out. The first is *shared_prefs/ring0.xml*,
    which seems to be a joke name: ring zero is the highest privilege level for execution
    on some computers. The other is *app_Dynamic OptDex/hq.json*, which has a file
    extension that implies it is a text file. However, the `file` command has indicated
    that it’s a ZIP file. We should investigate this mismatch between the declared
    file extension and the file’s contents.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Downloading Files for Inspection***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For further inspection of the files dumped by the app, we can download all
    of them from the device to the host computer with `adb pull`. This command can
    download both individual files and entire directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s perform a quick inspection of the two suspicious files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The *ring0.xml* file seems to contain configuration settings of unknown meaning,
    but with an interesting domain name. The *hq.json* file seems to contain DEX code,
    as indicated by the *classes.dex* string. Presumably, the malware writes this
    file to disk and loads it.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have leads into the malware that we could chase down. What
    is the suspicious domain in the XML file? What do the other configuration options
    mean? Where does the DEX file come from, and what does it do? For now, we won’t
    pursue these leads. Instead, we’ll use other dynamic analysis tools to learn more
    about the malware.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Apps can also access other parts of the filesystem. In particular, many apps
    write data to Android’s shared external storage. For brevity, we have omitted
    a discussion of the malware’s interaction with these storage areas, but a complete
    dynamic analysis should cover this.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Capturing Network Traffic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another target of dynamic analysis is network traffic. We can capture and analyze
    this traffic to find out where malware sends data to and where it receives it
    from. This can provide important insights into the commands the malware can execute
    and what sensitive data it may attempt to steal.
  prefs: []
  type: TYPE_NORMAL
- en: Before capturing network traffic, it’s important to reset the emulated device
    to a clean state. Otherwise, the app may not repeat some network requests that
    already happened during prior runs. What if, for example, the DEX code file *hq.json*
    was downloaded from the internet? The app might not download the file again, as
    it’s already present on disk. You’d be stumped if you wanted to understand the
    origins of this DEX file.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, after you wipe the device, you’ll need to again upload the tcpdump
    file to the emulator and make it executable. This task can quickly get tedious
    if you find yourself resetting the emulator regularly. We recommend putting all
    the emulator configuration commands into a shell script that you can easily execute
    after wiping it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture network data, we use the `adb exec-out` command to run the `tcpdump`
    executable on the emulator. We then use `adb exec-out` to transfer binary data
    from the emulator to the host system, piping it into Wireshark for easy consumption.
    It’s worth noting that network traffic can only be captured if `adbd` runs as
    root on the device. If you haven’t put `adbd` into root mode after resetting the
    emulator, now is a good time to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We use the tcpdump command line option `-i any` to capture traffic from any
    network interface. The combination of `-U` and `-w` makes sure that captured packets
    are immediately written to the output file. The Wireshark command line arguments
    `-k -S` immediately start capturing and displaying packets. The `-i -` argument
    tells Wireshark to expect network packets to come from stdin, which is where they
    get piped from adb.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this command captures all network traffic from the device, meaning
    that the captured data doesn’t necessarily come from the malware under analysis.
    If other processes make network connections, their traffic will be captured, too.
    On a freshly reset device, this is usually not a problem, as barely any apps are
    running and the operating system makes very few network connections. To get a
    better understanding of the default network connections on your Android device,
    you could capture the network traffic without running the malware or any other
    app.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing Network Traffic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once tcpdump and Wireshark are up and running, we can start looking at the captured
    traffic. [Figure 4-2](ch04.xhtml#ch4fig2) shows an example of a Wireshark session
    with packets captured during a run of *com.spike.old*. The top third of the Wireshark
    window shows a summary of all captured network packets. The middle third shows
    parsed information about the selected HTTP network packet. The lower third shows
    a hex dump of the selected packet’s payload.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Wireshark showing captured network traffic from the malicious
    app*'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the information from [Figure 4-2](ch04.xhtml#ch4fig2) is reproduced
    in [Listing 4-1](ch04.xhtml#ch4lis1) to make it more readable. In particular,
    we’ve chosen to show the structured information about the HTTP packet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: Details of a captured network connection in Wireshark*'
  prefs: []
  type: TYPE_NORMAL
- en: From this, we learn that the intercepted packet is an HTTP POST request to *http://simpleyo5.tk/ping*,
    a URL on the same domain we previously saw in the suspicious configuration file,
    *ring0.xml*. The abbreviated hex dump at the bottom of the listing shows that
    the POST payload (the data sent to the domain) appears to be JSON-formatted text
    with keys `hash` and `id` and what appear to be Base64-encoded values.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing network traffic proved to be a successful strategy. We’ve confirmed
    that the malware uses the domain *simpleyo5.tk*, and that JSON and Base64-encoded
    data gets sent to the domain’s */ping* endpoint. We also know some of the plaintext
    JSON keys. We’ll add these insights to our collection of leads to pursue later.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing Logs with Logcat***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One powerful source of information is Android’s system-wide log, which the operating
    system and apps use to log debug data, error messages, and other information.
    Careless malware developers who use the default logging system to debug their
    apps may forget to remove log statements in their final release and inadvertently
    give away a lot of information.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, *com.spike.old* is one of those apps. It makes heavy use of
    logging, and the information it logs is so detailed that we’ve intentionally placed
    this section after our discussions of network capture and filesystem analysis
    to avoid giving away too much information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard way to access the Android system log is to use the logcat tool,
    for example, through the `adb logcat` command. By default, logcat dumps the whole
    system logfile, which is usually many thousands of lines. To filter out irrelevant
    details, we can specify the process ID of the app under observation, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We first query for the malware’s process ID (in our case, 3711) and then tell
    logcat to only include lines with this ID. As we mentioned, the `logcat` command
    returns way too much useful information to print here. However, a sneak peek is
    shown in [Listing 4-2](ch04.xhtml#ch4lis2). Yes, the app really dumps the encryption
    parameters for its command-and-control communications to the system log. Usually,
    you won’t get this lucky during malware analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-2: The logcat output for* com.spike.old'
  prefs: []
  type: TYPE_NORMAL
- en: The string `pioneer_bridge_over_white_rabbits` is noteworthy. It’s a debug string
    used by the app as a prefix for its logs. Why the app includes it is unclear.
    Elsewhere in the log data (but omitted here), you can find information about the
    network payloads, a mapping of encrypted and decrypted JSON objects, fairly detailed
    information about which classes are executed, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage of logcat is that the operating system buffers and preserves
    its log for a while. This means that you don’t need to monitor logcat while the
    app is running: it’s possible to grab information from the system log long after
    the app under analysis has stopped executing. Because logcat is size-limited,
    the availability of an app’s data depends on how many log entries are generated
    on an Android device before earlier log entries get culled. In practice, usually
    they remain available for a few hours.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Analysis with Frida**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve used the tools adb, logcat, tcpdump, and Wireshark to quickly
    discover properties of the app under observation. However, these tools don’t allow
    us to link the observed app properties back to concrete sections of the app’s
    code. We now know that *com.spike.old* dumps files to disk, connects to a command-and-control
    server, and encrypts its communication, but we don’t know any details about where,
    why, or how it does any of this. We can use Frida to make these connections.
  prefs: []
  type: TYPE_NORMAL
- en: Frida is a powerful tool, and an explanation of all of its functions could fill
    a whole other book. Here, we’ll only cover those that further our understanding
    of the malicious sample. In particular, we’ll use `frida-trace` to quickly understand
    which interesting Java APIs the malware uses. We’ll also use Frida scripting to
    find these interesting APIs in the malware’s code. Curious readers are encouraged
    to read more about Frida’s many uses, as this chapter covers only about 1 percent
    of the tool’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running frida-server***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You should have already installed `frida-server` on the device and made it
    executable. Now you must run it so that it can communicate with the `frida` client
    on the host system and interact with the malware. We’ll use `adb shell` again
    to run `frida-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: One caveat is that `frida-server` must run with root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using frida-trace to Find Interesting APIs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `frida-trace` tool can dynamically trace method calls in the app under
    observation and dump some basic properties about the APIs it uses. The tool expects
    a list of methods to intercept, and it sends these methods’ inputs and outputs
    to stdout. It supports regular expressions, making the monitoring of all methods
    of a class, or even a package, a breeze. For example, the following command dumps
    information about how the malware uses all methods in the classes `Cipher` and
    `SecretKeySpec` from the default Java cryptography package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This command outputs hundreds of lines of information about the use of this
    cryptography API. [Listing 4-3](ch04.xhtml#ch4lis3) shows a tiny part. We can
    see how the malware sets up an AES encryption key and an initialization vector
    (IV), and then uses the cipher defined by these properties to decrypt a byte array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-3: The output of frida-trace related to cryptography APIs*'
  prefs: []
  type: TYPE_NORMAL
- en: This output gives us more leads to pursue later. We’ve confirmed that the app
    uses the default Java cryptography package, and we know some of the configuration
    parameters it uses for encryption.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml), we recommended that reverse engineers build a list
    of interesting API methods to search for when analyzing a program’s code. You
    can use this same list with `frida-trace` to intercept and log how mal-ware uses
    the APIs. Besides cryptography APIs, you might try to intercept those related
    to network communication, filesystem access, or access to sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding Entry Points into the Malware with Frida Scripting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The downside of `frida-trace` is that it can’t link the observed APIs to the
    malware’s code. We might know now that the malware uses encryption, and even how
    it sets up its ciphers, but we don’t know where this happens. To make this connection,
    we can use Frida scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting is likely Frida’s most useful capability. It allows Frida users to
    write custom code in different programming languages to interact with the program
    under observation. In this section, we’ll use this capability to connect API calls
    to the underlying malware’s code by observing the stack traces of interesting
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using `frida-trace`, we learned that the malware calls the default Java cryptography
    API `Cipher.doFinal` to encrypt and decrypt data. We can now specifically target
    this API with a custom Frida script that discovers the locations in the malware
    that call the API. Written in JavaScript, [Listing 4-4](ch04.xhtml#ch4lis4) is
    a very simple Frida script that intercepts the `Cipher.doFinal` API. Save it to
    a file called *xeno-dofinal.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-4: A Frida script that intercepts the doFinal API*'
  prefs: []
  type: TYPE_NORMAL
- en: We use `Java.perform`, from Frida’s JavaScript API, to ensure that the current
    thread is attached to the virtual machine and then execute the function given
    in its argument. In our example, the provided function contains the code responsible
    for hooking `Cipher.doFinal`. Hooking a Java method first requires acquiring a
    JavaScript wrapper for its class. To do this, we use the Frida JavaScript API
    `Java.use`, which takes a fully qualified Java class name as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: Before hooking and overwriting a method, we need to determine whether there
    are multiple methods with the same name in the hooked class. If so, we need to
    disambiguate them using the `overload` function, explicitly passing it the method
    parameters’ Java types. Here, we do this for the `doFinal` method by passing the
    argument `”[B”`, which indicates a byte array in Java type syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve found the correct overloaded method, we overwrite the object’s `implementation`
    property with the simple assignment of a custom function. Now, every time the
    app calls the hooked API, our code executes instead of the original API code.
    We also use an old Java trick to get our current location by throwing a new exception
    and printing its stack trace. Lastly, we return the expected value of `doFinal`
    by calling its original implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can use jadx to help you intercept methods defined in the app under analysis.
    In the jadx context menu for method definitions or calls, select **Copy as Frida
    Snippet**. This creates Frida JavaScript that uses* Java.use*, as we did in our
    script.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Executing the Frida Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Execute the Frida script from the host machine’s command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-U` argument instructs Frida to look for a device connected over USB,
    and the `-f` argument spawns the malware app. The `-l` argument specifies the
    script file to run. Once you run this command, the Frida shell should open and
    spawn the malware in a suspended state. To continue its execution, enter %resume
    in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 4-5](ch04.xhtml#ch4lis5) shows the script’s output. You should read
    this log from top to bottom. Each printed stack trace begins with `java.lang.Exception`,
    followed by the `doFinal` call under observation. After that, you’ll see the code
    snippet that calls `doFinal`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-5: The Frida script’s output shows places where* doFinal *is called.*'
  prefs: []
  type: TYPE_NORMAL
- en: The first stack trace shows the `encryptMessage` function, and the second shows
    `decryptMessage`. For the first time, we’re able to develop an understanding of
    the app’s control flow. The script’s output shows exactly how the `doFinal` method
    is called from the nonstandard *com.sniff* package, which must be the part of
    the malware that performs encryption.
  prefs: []
  type: TYPE_NORMAL
- en: To gain further insight into the malware, we could repeat this process for other
    interesting functions. For example, we might want to find where *ring0.xml* and
    *hq.json* are written to disk, and where the network connection to the command-and-control
    server is set up. We leave these tasks as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decrypting the Command-and-Control Communications**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in the previous chapter, one of the most important properties of the malware
    we’ll want to reverse engineer is its encrypted communication with the command-and-control
    server. Breaking the encryption will allow us to better understand the commands
    it supports. Rather than using static analysis and code reading to find out how
    this communication works, we’ll use dynamic analysis. Between tcpdump, logcat,
    and Frida, we have all the tools we need.
  prefs: []
  type: TYPE_NORMAL
- en: After our earlier analysis using tcpdump and Wireshark, we know that the first
    connection the malware makes is an HTTP POST request to *http://simpleyo5.tk/ping*.
    In this request, the malware sends a JSON object with four entries, as shown in
    [Listing 4-6](ch04.xhtml#ch4lis6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-6: The JSON payload posted to the* /ping *URL*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s still unclear what these values are. The one plaintext entry, `"type":
    "request_verify"`, suggests that the purpose of this connection is to request
    that the malware client be verified. We’ve shortened the value of `id` here; originally,
    it had more than 7,000 bytes. Its length indicates that it might be the message’s
    main payload. The value of `hash` is unknown at this point, as is the value of
    `iv`, which has a noteworthy name. Could this be the initialization vector used
    to encrypt the payload? Later, we’ll confirm this to be the case.'
  prefs: []
  type: TYPE_NORMAL
- en: '***With CyberChef***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CyberChef ([*https://gchq.github.io/CyberChef*](https://gchq.github.io/CyberChef))
    is an open source web app for encryption, encoding, compression, and data analysis.
    Developed by the Government Communications Headquarters (GCHQ), the British equivalent
    of the NSA, it is likely the most user-friendly way to manipulate, transform,
    and decrypt data during malware analysis. In this section, we’ll use it to play
    around with the malware’s encrypted communications protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-3](ch04.xhtml#ch4fig3) shows the CyberChef interface. In the upper-right
    corner, you can input plaintext data to transform. The bottom-right corner is
    an output field for the transformed data. On the left side, you can pick from
    dozens of data transformations to drag and drop into the center.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Using CyberChef to get the hexadecimal byte values of a Base64-encoded
    string*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example shown here, we’ve input the `iv` value from the JSON payload
    in the previous section. Then we chose two data transformations to apply: Base64
    decoding and converting the result into a hex string. This outputs the string
    `33 42 9c 49 1c 0e 32 f2 a7 6c d7 78 4c 4e f5 f5`, which corresponds to the bytes
    of the `iv` value before it was Base64-encoded.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*CyberChef recipes can be much more complex than shown here, often using control
    flow operations, code disassembly, or YARA rules.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Frida output told us that the malware uses AES encryption in its so-called
    CBC mode to encrypt and decrypt payloads. We need to recover the encryption keys
    and algorithm initialization vectors to successfully decrypt the payload. In the
    logcat logs, the JSON payload itself, and Frida’s output, we’ve encountered a
    couple of potential encryption keys and initialization vectors. In the next section,
    we’ll present a more structured approach to discovering these values, but for
    now, let’s use the IV from the JSON payload and the encryption key we found in
    the system log. We can use this information to complete the CyberChef recipe,
    making sure to pick the appropriate input formats for the payload, key, and IV
    (in our case, Raw, Hex, and Base64). [Figure 4-4](ch04.xhtml#ch4fig4) shows the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Decrypting command-and-control communication with CyberChef*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve reproduced the decrypted JSON payload in its entirety in [Listing 4-7](ch04.xhtml#ch4lis7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-7: The decrypted JSON payload posted to the* /ping *URL*'
  prefs: []
  type: TYPE_NORMAL
- en: The `api` field is likely the device’s Android API version (remember that we
    configured this to 30 at the beginning of this chapter). Next is a list of apps,
    presumably those installed on the system. The `imei` and `model` fields are probably
    the device’s IMEI number and device model. It’s unclear what `numbers` is, but
    it could be the device’s phone number or the phone numbers of contacts from the
    contact list. The `tag` field likely identifies the malware app itself, while
    `uid` could be some sort of unique user ID.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we now need to consider the data that the server returns. [Listing
    4-8](ch04.xhtml#ch4lis8) shows the response to the POST request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-8: The JSON response received from the* /ping *URL*'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` field’s value, `response_verify`, matches the POST payload’s `request_verify`
    field. The other three fields, `hash`, `id`, and `iv`, also match fields from
    the POST request. Their values are seemingly Base64-encoded.
  prefs: []
  type: TYPE_NORMAL
- en: An attempt to decrypt the `id` field with the previously used encryption key
    and IV value from the POST response doesn’t immediately produce a readable result.
    The decrypted value is a 16-byte array with seemingly random bytes. Their purpose
    and meaning are unclear for now. Likewise, we can’t easily decrypt the POST payloads
    of subsequent connections to the command-and-control server. We must strategically
    explore the malware in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: '***With Frida***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To automate the interception and decryption of encrypted command-and-control
    communications, we can use Frida. In particular, we’ll develop a script that intercepts
    important Java encryption API methods and writes their inputs and outputs to files
    for later examination. To accomplish this, we’ll use some advanced Frida features.
  prefs: []
  type: TYPE_NORMAL
- en: Notably, rather than using the Frida command line to spawn the malware process,
    we’ll use a second script, the *control script*, to spawn the malware process
    and control its execution. The control script will inject another script, similar
    to the one we wrote earlier in this chapter, into that process.
  prefs: []
  type: TYPE_NORMAL
- en: The Control Script
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s begin by developing the control script, which spawns the malware app,
    attaches to it, injects the Frida script, and logs intercepted API arguments to
    disk. We’ve chosen to write it in Python to showcase Frida’s support for different
    scripting languages. Save this code to a file named *xeno.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-9](ch04.xhtml#ch4lis9) is the control script’s main function. It
    uses Frida Python bindings to interact with the Android emulator.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-9: The control script’s main function*'
  prefs: []
  type: TYPE_NORMAL
- en: The main function connects to the Android emulator over USB, launches and attaches
    to the malware process, and gets its process ID. It uses the `inject_script` function
    to inject the Frida script into the malware process and then continues its execution,
    keeping the script alive until the user hits CTRL-C. [Listing 4-10](ch04.xhtml#ch4lis10)
    shows the definition of `inject_script`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-10: The control script’s process injection function*'
  prefs: []
  type: TYPE_NORMAL
- en: This function loads the Frida script file *xeno.js* (which you will find later
    in this chapter, in [Listing 4-12](ch04.xhtml#ch4lis12)) into the malware process.
    Most importantly, it sets up the callback method `on_message`, which can receive
    messages from the Frida script inside the malware process. The format of these
    messages will become clearer once we discuss the injected script’s code. Generally,
    Frida’s default message format defines key/value pairs, with two default keys,
    `type` and `payload`. Our injected script overwrites the `payload` values with
    new key/value pairs. For each message, the key can be `iv`, `key`, `input`, or
    `output`, depending on the type of binary data in the value field.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the control script defines the `write_data` function, which takes the
    intercepted data and writes it to multiple files ([Listing 4-11](ch04.xhtml#ch4lis11)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-11: The control script’s file writing function*'
  prefs: []
  type: TYPE_NORMAL
- en: To preserve the chronological order in which the data was collected, this function
    writes each piece to a distinct file using a filename that contains the current
    time in milliseconds (ms) and the data type.
  prefs: []
  type: TYPE_NORMAL
- en: The Injected Script
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The script that we inject into the malware process is much smaller. Its only
    job is to intercept Java cryptography APIs `SecretKeySpec` and `Cipher.doFinal`
    and send the data passed to them to the control script. [Listing 4-12](ch04.xhtml#ch4lis12)
    shows this JavaScript script in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-12: The injected script* (xeno.js)'
  prefs: []
  type: TYPE_NORMAL
- en: This script reuses key Frida scripting concepts, such as `Java.perform` and
    `Java.use`, discussed earlier in this chapter. It also sends messages to the control
    script, using the default Frida `send` method, to transmit the encryption keys,
    initialization vectors, and plaintext and ciphertext messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the Python script should generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script creates files containing encryption keys, initialization
    vectors, input arrays to encryption methods, and output arrays from encryption
    methods. Note that the code does not try to determine whether data is encrypted
    or decrypted, so the filenames don’t tell us whether we can find the unencrypted
    plaintext for cryptographic operations in the *input* or *output* files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Linux command line tool xxd to dump hex values and ASCII representations
    of the content of the key and initialization vector files. You’ll notice that
    the first key is the one we’ve encountered on multiple occasions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: By examining these files, we can discover that for outgoing network traffic
    the input file contains the unencrypted information that is then encrypted and
    sent to the command-and-control server. Likewise, for inbound traffic coming from
    the command-and-control server, the input file contains the received encrypted
    messages, and the output files contain the decrypted messages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Command-and-Control Server Messages**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our Frida script provides information about the encrypted payloads, it
    doesn’t link the payloads to URL connections. However, unless we want to fully
    automate our analysis, it doesn’t have to. We’ve already logged the HTTP connections
    and their payloads with tcpdump and can look at them in Wireshark. Let’s compare
    the payloads from the files written to Frida with those visible in Wireshark.
    Because the malware makes very few connections to its server, it’s completely
    feasible to continue without automating this step.
  prefs: []
  type: TYPE_NORMAL
- en: '***The /ping URL***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we dumped network traffic with tcpdump and Wireshark, we learned that the
    malware’s first connection is to *http://simpleyo5.tk/ping*. We also successfully
    decrypted its payload with information from Frida and logcat. The largest part
    of the payload was the list of installed apps. The server replied with a JSON
    payload of a similar format but much smaller size. Running tcpdump and Wireshark
    for longer does not seem to change this payload and response. While the app makes
    subsequent connections to this URL, it only seems to use this command to make
    the server aware of an available client.
  prefs: []
  type: TYPE_NORMAL
- en: '***The /metrics URL***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you take another look at Wireshark, you’ll notice another URL to which the
    malware connects, and this one is much more interesting. After the first connection
    to */ping*, the malware starts connecting to *http://simpleyo5.tk/metrics*. These
    connections are more frequent and have more diverse payloads in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: In the first connection to the */metrics* endpoint, the malware transmits a
    JSON file with plaintext keys and encrypted values that is similar to the one
    it transmits to */ping*. For example, it could look like the one in [Listing 4-13](ch04.xhtml#ch4lis13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-13: The JSON payload posted to the* /metrics *URL for a* jni_update
    *command*'
  prefs: []
  type: TYPE_NORMAL
- en: The values in the fields `hash`, `id`, and `iv` likely play a role similar to
    the one they play in the payload to */ping*. The `metrics` field is new and replaces
    the plaintext value of the `type` field sent to */ping*.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that `metrics` decrypts to `{”type”:”inj_update”}`, which seems
    to be a simple request from the app to the server to receive information about
    “injections,” whatever that is. The server responds with a long message that decrypts
    to the JSON payload shown in [Listing 4-14](ch04.xhtml#ch4lis14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-14: The decrypted JSON response from the* /metrics *URL*'
  prefs: []
  type: TYPE_NORMAL
- en: This long list of app package names and URLs is interesting. Today, these URLs
    are long gone, but we explored them in a previous analysis and can present them
    here. Each HTML file is a phishing page for a different legitimate app. The screenshot
    in [Figure 4-5](ch04.xhtml#ch4fig5) shows the phishing page associated with *com.android.vending*,
    the package name of the Google Play app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch04fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: An input field to phish credit card information in Google Play*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `inj_update`, the */metrics* URL can also receive at least one
    other command. On a subsequent connection, the malware sends it a command called
    `get_coms` whose payload is shown in [Listing 4-15](ch04.xhtml#ch4lis15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-15: A decrypted JSON payload posted to the* /metrics *URL for a*
    get_coms *command*'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `type` field indicating the message type, only the `user_present`
    field seems self-explanatory. It’s not clear what `rm_triggered` refers to, and
    the exact meaning of the `permissions` field also remains mysterious. We do get
    an additional hint, though, that the app cares about app notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our tests, `get_coms` was by far the most common command sent to the server.
    Unfortunately, the only response we observed was the empty payload `{''type'':
    ''get_coms'', ''coms'': []}`. By the time we attempted an in-depth analysis, the
    command-and-control servers had been shut down, so we had to use the payloads
    previously collected in our malware scanner archives to reason about the malware
    behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Rotating Encryption Keys***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Readers who have meticulously followed along with this app analysis on their
    computers may have noticed that the malware changes encryption keys. You can observe
    this when the Frida script logs different values into the key files, but it becomes
    increasingly obvious when you try to manually decrypt payloads with CyberChef.
  prefs: []
  type: TYPE_NORMAL
- en: The encryption key we discovered earlier, `5f 9e 4a 92 b1 d8 c8 b9 8d b9 b7
    f8 f8 80 0d 2e`, is used for only the initial command-and-control server communications
    during the first connection to the */ping* URL. Recall that the */ping* reply
    payload contains a JSON field called `id`. This field holds the new encryption
    key. The field is itself encrypted, but we can decrypt it using the original key
    and the initialization vector from the reply’s `iv` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the app also logs this new key into the system log. We can
    retrieve it using logcat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The Base64-encrypted value at the end of each log line is the new encryption
    key. The log also shows that the encryption key further rotates, presumably with
    each call to */ping*, as between any two calls to */ping* the key seems to remain
    stable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Malware Functionality**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running the app and inspecting its command-and-control messages has given us
    several leads to pursue. We know that the app wants to acquire the permission
    to use the accessibility API, cares about installed apps, and is interested in
    notification listener permissions. Let’s use this information to dig deeper.
  prefs: []
  type: TYPE_NORMAL
- en: '***com.sniff with frida-trace***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On several occasions, our analysis has confirmed the presence of a Java package
    named *com.sniff* . One of the next steps we could take is to explore this package
    with Frida.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might naively try to use `frida-trace` to intercept all methods in this
    package and log their usage, arguments, and return values. However, if you simply
    run a command similar to the one we used to intercept the cryptography APIs earlier
    in this chapter, this won’t work well, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the output, Frida can find only four methods in the `MainApplication`
    class. This happens because the Java class loader hasn’t finished loading all
    of the app’s classes by the time `frida-trace` enumerates the loaded classes.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to perform a more complete trace. First, it’s possible to
    change the `frida-trace` command so it attaches to an existing process rather
    than spawning a new process. While easy to do, this would mean missing out on
    all method calls between the start of the app and Frida attaching to the process.
    The alternative option is to write a more complex Frida script that waits for
    the class loader to complete, enumerates all methods, and intercepts them. For
    our purpose, the scrappy option of attaching to a running process should work
    fairly well, due to a quirk in the malware. Because the malware blocks most of
    its functionality from executing until the user grants it permission to use the
    accessibility API, we simply launch the app, let it sit at the accessibility request
    window, and attach Frida to the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell `frida-server` to attach to a process rather than spawn its own, we
    can switch the `-f` argument to `-p` and pass it the process ID instead of the
    package name. We could also attach to a process by name, but doing so is awkward
    on Android because Frida expects the app name, not the package name. Usually,
    during malware analysis, you’ll quickly learn an app’s package name but not its
    textual name. Here, we attach to *com.spike.old* through its process ID, 24606:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We’ve shortened the output significantly for this book. In practice, this script
    generates hundreds of lines per second. Even this partial log, of 700 ms of activity,
    shows a wealth of information. We see more class and package names in *com.sniff*
    , as well as how the malware reads the command-and-control URL from the *ring0.xml*
    configuration file and uses encryption. All of this is tied together by the mysterious
    `KingService` class.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, malware doesn’t come with an execution block mechanism like this
    sample’s accessibility request window. In these cases, you really may miss out
    on important method calls that happen before `frida-trace` attaches to the target
    process. You can find examples of custom scripts on the internet, including some
    library code to make the whole process very simple.
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessibility Abuse***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We mentioned that the very first thing the app asks users to do is to grant
    it permission to use the accessibility API. Why it desires this permission is
    still unclear, so let’s dig deeper to find out. For this task, we can once again
    use `frida-trace` to cast a wide net, logging all uses of the accessibility API
    by the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After manually granting the app access to the accessibility API in the emulator,
    the `frida-trace` command creates several megabytes of output. In the emulator,
    however, you won’t see much apart from the home screen and two permission dialogs,
    for reading SMS messages and making phone calls, which pop up and then disappear.
    Presumably, the app grants itself these permissions by simulating a user clicking
    the dialogs’ buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slogging through megabytes of accessibility API usage logs is a chore. We can
    start by looking for certain patterns, though. When inspecting call traces in
    Frida earlier in this chapter, we identified *com.sniff.sibling* as a potentially
    interesting Java package in the malware. Grepping through the logfile reveals
    two interesting Java classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `PermissionActivity` class could be the activity responsible for clicking
    the buttons in the SMS and call permission dialogs, while `Accessibility EnableHintActivity`
    could be the permission showing the window that asks the user to grant accessibility
    permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to look at the logfile is to try to understand which classes in
    the accessibility API the app uses. The answer, it turns out, is a lot. The following
    Linux shell command returns about 50 different classes, creating a much more complicated
    situation than our earlier experiment with intercepting cryptography APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Without an idea of what to look for next, this method of exploration may lead
    to a dead end. We’ve reached a point at which pure dynamic analysis becomes too
    cumbersome, and a mixed-mode exploration of the program, with the help of static
    analysis, may be in order.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Static Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve instrumented, observed, and manipulated the sample in so many
    different ways, we have dozens of leads we could pursue to dive deeper into the
    app. Unfortunately, our leads don’t suggest any easy ways to trigger specific
    code and behavior. Instead, we must look at the source code, bolstering our dynamic
    analysis with static techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Command-and-Control Servers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first piece of analysis we can complete involves the command-and-control
    server. With dynamic analysis, we found a domain, *simpleyo5.tk*, with two endpoints,
    */ping* and */metrics*. A search for this domain in jadx reveals a single line.
    The code and its surrounding lines, from *com.sniff.sibling.Constants*, is shown
    in [Listing 4-16](ch04.xhtml#ch4lis16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-16: Domain names and encryption key inside* com.spike.old'
  prefs: []
  type: TYPE_NORMAL
- en: Apparently, the malware can switch between up to four command-and-control domains
    for its commands. The communications encryption key we previously discovered is
    defined in the line right above the server array initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Very often in malware analysis, you’ll find interesting pieces of functionality
    located close together in the code. For example, take a look at the strings from
    the *com.sniff.sibling.Constants* file shown in [Listing 4-17](ch04.xhtml#ch4lis17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-17: Other interesting strings found in* com.sniff.sibling.Constants'
  prefs: []
  type: TYPE_NORMAL
- en: You should recognize these strings from our earlier analysis stages. In particular,
    the strings with the four capital letters were the XML tag names from the mysterious
    *ring0.xml* configuration file. We can see that these tag names aren’t just random
    characters but abbreviations that indicate their function. Dynamic analysis alone
    couldn’t have uncovered that. Likewise, the presence of only two strings starting
    with `api*` provides some evidence that */ping* and */metrics* are the only endpoints
    supported by the malware’s command-and-control servers.
  prefs: []
  type: TYPE_NORMAL
- en: One other piece of code in *com.sniff.sibling.Constants* is particularly interesting.
    In the static initializer, close to the initialization of the command-and-control
    server array, are statements that hint at which permissions the malware uses.
    [Listing 4-18](ch04.xhtml#ch4lis18) shows this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-18: Permission strings in* com.sniff.sibling.Constants'
  prefs: []
  type: TYPE_NORMAL
- en: Even with the caveats about permissions described in [Chapter 3](ch03.xhtml),
    this list gives us more information about the malware’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Server Commands***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our analysis of *com.sniff.sibling.Constants* revealed all of the malware’s
    command-and-control servers and their URLs, but we still don’t have the full list
    of commands the app is capable of executing. This illustrates yet another problem
    of pure dynamic analysis: if the server doesn’t instruct the malware to execute
    certain commands while under observation, the dynamic analysis environment will
    never learn about them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that the */metrics* URL supports at least two commands: `inj_update`
    and `get_coms`. To find other potential commands, we can search for the ones we
    know about and hope that the others are defined nearby. A search for these two
    command strings shows that they appear at four locations in the code, three of
    which are quite interesting.'
  prefs: []
  type: TYPE_NORMAL
- en: We first find `inj_update` referenced inside *com.sniff.sibling.Api.Controllers.ApiOperationsController*.
    Shown in [Listing 4-19](ch04.xhtml#ch4lis19), the code using this string is helpfully
    called `parsePayload`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-19: Code in* parsePayload *confirms the existence of three commands.*'
  prefs: []
  type: TYPE_NORMAL
- en: The code is unnecessarily complex, as all it does is parse the previously decrypted
    response from the server to understand whether the retrieved JSON object has a
    `type` tag with a value of `notif_ic_update`, `get_coms`, or `inj_update`. We
    haven’t yet encountered `notif_ic_update`, but it appears to be unused, as no
    branch in the final `if` statement is associated with this command. Maybe that’s
    why we didn’t observe it being sent from the server.
  prefs: []
  type: TYPE_NORMAL
- en: These strings appear again inside the mysterious `KingService` class we’ve seen
    several times during our analysis. Shown in [Listing 4-20](ch04.xhtml#ch4lis20),
    the function that uses them seems to be the malware’s main execution loop. Every
    step of the malware is outlined there and matches what we observed using logcat
    and Frida.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-20: The malware’s main execution loop, found in the* KingService
    *class*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code straightforwardly shows that the malware first tries to connect to
    the internet and bails if no network is available. Then it checks whether the
    network is busy—that is, whether any other server command is in progress. It also
    checks the following: whether the client is verified and, if so, that the verification
    has not yet expired; whether it’s time to send the `inj_update` command to the
    server; whether it’s time to send the `get_coms` command to the server; whether
    necessary permissions have been granted; and whether the malware was granted notification
    access. Finally, it starts *doze mode*, a setting related to battery optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: Based on this main execution loop, we can confirm that our dynamic analysis
    was fairly complete. We uncovered all of these execution options, except for the
    one related to doze mode. Code inspection will show that entering doze mode is
    an attempt by the malware to exclude itself from system-wide optimization features
    that might kill the malware process to preserve battery life.
  prefs: []
  type: TYPE_NORMAL
- en: The third interesting piece of code that references the string `inj_update`
    is in the *com.sniff.sibling.Api.TDP.ApiGetCommandsResponsePayload* class, which
    contains code to further parse the `get_coms` server response. Shortened for brevity,
    its beginning is shown in [Listing 4-21](ch04.xhtml#ch4lis21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-21: Code that reveals additional server commands*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code goes through all the commands received from the command-and-control
    server and executes the functionality for each (omitted here). We can now see
    that the malware understands the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: app_list Uploads information about installed apps to the server
  prefs: []
  type: TYPE_NORMAL
- en: sms_log Uploads all SMS from the device to the server
  prefs: []
  type: TYPE_NORMAL
- en: notif_ic_enable Starts intercepting notifications on the device
  prefs: []
  type: TYPE_NORMAL
- en: notif_ic_disable Stops intercepting notifications on the device
  prefs: []
  type: TYPE_NORMAL
- en: sms_ic_enable Starts intercepting SMS
  prefs: []
  type: TYPE_NORMAL
- en: sms_ic_disable Stops intercepting SMS
  prefs: []
  type: TYPE_NORMAL
- en: inj_enable Enables phishing overlay windows
  prefs: []
  type: TYPE_NORMAL
- en: inj_disable Disables phishing overlay windows
  prefs: []
  type: TYPE_NORMAL
- en: inj_update Asks the server for new phishing windows
  prefs: []
  type: TYPE_NORMAL
- en: Besides these commands, the malware also looks for many commands that aren’t
    backed by any code. This indicates that the malware is under heavy development
    and may add more functionality in the future. The unimplemented commands are `self_kill`,
    `fg_disable`, `inj_list`, `self_cleanup`, `notif_ic_update`, `fg_enable`, `app_kill`,
    `sms_ic_update`, `sms_ic_list`, and `notif_ic_list`. We can only guess their purposes
    from their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know everything about the command-and-control servers: their domains,
    URLs, and commands. We also know the data that the malware collects and which
    commands are actually implemented. This gives us a very good overview of its capabilities,
    proving once again that understanding the malware’s command handler is key to
    understanding its functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: '***More Accessibility Abuse***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the remaining mysteries about this malware sample concerns its use of
    the accessibility API. We’ve already discovered that the malware actively pushes
    the user to grant it access to this API, and that once this is done the malware
    makes extensive use of its classes and methods. However, we don’t yet know exactly
    what it uses the API for.
  prefs: []
  type: TYPE_NORMAL
- en: Code that uses the accessibility API isn’t easy to understand. The API is complex
    and messy, and achieving anything with it takes a lot of code. Because it comprises
    more than 1,000 lines, showing and explaining all of the malware’s accessibility
    API functionality is out of this book’s scope. Instead, we’ll limit ourselves
    to a few highlights.
  prefs: []
  type: TYPE_NORMAL
- en: Most of this code is in *com.sniff.sibling.Accessibility*, a package that contains
    nearly 20 classes, primarily for simulating real user clicks on predefined apps.
    For example, the malware can make itself the default SMS handling app by clicking
    through a series of system settings. Likewise, it has defense mechanisms that
    check whether the user has opened system dialogs for removing or disabling the
    malware and close these dialogs if necessary, before the user can complete the
    removal process.
  prefs: []
  type: TYPE_NORMAL
- en: The central part of the accessibility abuse code is the *com.sniff.sibling.Services.FitnessAccessibilityService*
    class, which extends the default Android class *android.accessibilityservice.AccessibilityService*
    and provides callback methods invoked for accessibility events happening on the
    system. The most interesting method in this service, `windowStateChangedEvent`,
    handles apps coming to the foreground or otherwise changing state. When this happens,
    the malware checks which app has come to the foreground and takes the appropriate
    action. If it finds a phishing target, for example, it shows the phishing dialog.
    If it instead finds a permission dialog, it clicks a button to grant the app that
    permission. [Listing 4-22](ch04.xhtml#ch4lis22) shows a slice of the `windowStateChangedEvent`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-22: The accessibility API is used to handle new apps coming to the
    foreground.*'
  prefs: []
  type: TYPE_NORMAL
- en: First, the malware checks whether it should inject phishing dialogs (`injectionsEnabled`)
    and target the active app with such a dialog (`packageHas Injection`). If so,
    the phishing dialog is shown. The next few `if` statements are self-defense mechanisms
    that simulate clicks on the back button when the user opens system dialogs to
    remove the malware. Following that is the code that accepts all permission requests
    for the app and takes some system dialog–specific actions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Automatically Granting Permissions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The service also handles generic accessibility events and events that invoke
    `windowContentChanged` and `notificationStateChanged`. The code in these sections
    is messy and hard to follow. For example, take a look at the code to perform the
    seemingly simple action of clicking the OK button on a permission dialog to automatically
    grant the malware all permissions it requests. [Listing 4-23](ch04.xhtml#ch4lis23)
    shows the code for `checkPermissionsClick`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-23: Simulating a click on the permission dialog if necessary*'
  prefs: []
  type: TYPE_NORMAL
- en: The app first checks whether the accessibility event came from `permission controller`
    or `packageinstaller`, to make sure the app is showing the desired dialog. Then
    it checks whether its app name is part of the hierarchy that led to the accessibility
    event. We’ve omitted the 20 lines of code for doing so here. Finally, the malware
    makes sure that it hasn’t yet been granted the relevant permission. If it already
    has all the permissions it requires, the dialog likely was launched by a different
    app.
  prefs: []
  type: TYPE_NORMAL
- en: After confirming all of these conditions, the malware clicks the dialog’s OK
    button. [Listing 4-24](ch04.xhtml#ch4lis24) shows the first method for accomplishing
    this click.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-24: The outer method for clicking the permission dialog button*'
  prefs: []
  type: TYPE_NORMAL
- en: This method simply invokes `pressAllowButton`, shown in [Listing 4-25](ch04.xhtml#ch4lis25).
    Here, things become more complicated, as the method iterates over lists of button
    IDs and button labels. The button label list contains the strings `Allow` and
    `OK`, meaning this code will actually fail to locate the buttons if the device
    doesn’t use these terms due to its language setting. The button ID list contains
    five strings of the form `com.android.packageinstaller:id/permission_allow_button`,
    which are presumably the IDs for the permission dialog in different Android versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-25: Locating the permission dialog button*'
  prefs: []
  type: TYPE_NORMAL
- en: To press a button based on its text label, the malware must first retrieve the
    text of all buttons in the active dialog. If one of these buttons matches the
    expected text, it can perform a click, as shown in [Listing 4-26](ch04.xhtml#ch4lis26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-26: Clicking the permission dialog button*'
  prefs: []
  type: TYPE_NORMAL
- en: A separate, nearly identical method identifies the button to click based on
    its ID rather than its label text. The only difference is that it uses the `findAccessibilityNodeInfosByViewId`
    method instead of `findAccessibilityNodeInfosByText`. The one remaining method,
    `clickButton`, is shown in [Listing 4-27](ch04.xhtml#ch4lis27); it uses the accessibility
    API `performAction` to execute the click.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-27: Clicking a button with the accessibility API*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even a simple workflow like clicking the OK button in a permission
    dialog takes so much code that it’s no wonder more advanced manipulation of the
    system and its dialogs take more than 1,000 lines. Following this code requires
    knowledge of Android internals and modifications made by device manufacturers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Injecting Phishing Windows***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s discuss how the malware fulfills its ultimate purpose: phishing. Conceptually,
    phishing for credentials involves displaying a phishing window, hoping that the
    victim falls for the ruse, and then sending the stolen credentials to a remote
    server for future use. This app follows this textbook behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already discovered information about the phishing process. From the accessibility
    API code, we learned that the app displays the phishing window when a target app
    becomes active. When analyzing communications with the command-and-control server,
    we learned where the target app configuration comes from and what the phishing
    windows look like. The only thing we don’t yet understand is how the app displays
    the phishing window and steals the credentials.
  prefs: []
  type: TYPE_NORMAL
- en: A class called `OverlayInjectActivity` is responsible for showing the phishing
    dialog, collecting user credentials, and sending them to the command-and-control
    server ([Listing 4-28](ch04.xhtml#ch4lis28)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-28: The phishing window uses a WebView to show the phishing pages.*'
  prefs: []
  type: TYPE_NORMAL
- en: When this dialog is shown, it loads the phishing page’s HTML code into a WebView
    and shows it to the user. The `getPageResource` method fetches HTML that has been
    customized for the target.
  prefs: []
  type: TYPE_NORMAL
- en: '***Stealing Credentials***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Lastly, to understand how the app steals credentials, we need to know how the
    credentials entered by the user travel from the HTML page in the WebView to the
    app and how the app sends them to its command-and-control server.
  prefs: []
  type: TYPE_NORMAL
- en: A JavaScript interface serves as a bridge between the website and the app. As
    you saw in [Listing 4-28](ch04.xhtml#ch4lis28), the interface is based on a Java
    class named `WebAppInterface` that is exposed to the website as a JavaScript object
    of name `Android`. [Listing 4-29](ch04.xhtml#ch4lis29) shows the complete `WebAppInterface`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-29: The* WebAppInterface *class bridges the app and the phishing
    page.*'
  prefs: []
  type: TYPE_NORMAL
- en: The class defines two methods marked with the annotation `@JavascriptInterface`,
    which makes them available to the HTML page’s JavaScript code. The `send_log_injects`
    method simply calls the more interesting method, `returnResult`. When the app
    receives the stolen credentials, it issues a new command-and-control message of
    type `inj_success` that sends the stolen credentials to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a look at an example HTML page, such as the one for phishing Gmail account
    information, makes this interaction easier to understand. [Listing 4-30](ch04.xhtml#ch4lis30)
    shows an excerpt from the phishing page, which takes form input from the user,
    turns it into a JSON string, and sends it to the app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-30: Excerpt of the HTML code for the Gmail phishing page*'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML page defines an input form with a password field and a button. When
    the user clicks the button, the JavaScript method `checkPassword` is called to
    perform a quick password plausibility check. Then, `checkPassword` calls the `process`
    method, which serializes the input form into a JSON object and sends that to the
    Java code of the app through the JavaScript interface method `Android.send_log_injects`.
    The Java code of the app then sends the JSON string to the server to complete
    the password theft operation. At this point, the user has fallen for the phishing
    attack and the malware has achieved its goal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Up Next**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After following the analysis steps in this chapter, you should understand the
    malware’s main functionality. It waits until a target application is running and
    then creates an overlay window over the legitimate app, imitating the app’s user
    interface and asking the user to log in. The credentials the user enters into
    the dialog are then stolen. This is facilitated by abuse of the accessibility
    API and orchestrated by a command-and-control server.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter should have also demonstrated the value of dynamic analysis. Using
    just a few tools, ranging from simple log analysis to powerful Frida scripts,
    we were able to make rapid progress in our analysis. We successfully discovered
    most of the malware’s functionality and developed a high-level understanding of
    how it works. Then we used static analysis to complement our understanding of
    details that are elusive to pure dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this book, we’ll transition away from the manual analysis
    of individual malware samples to using machine learning as a means of quickly
    identifying and classifying numerous malicious apps. There are millions of malware
    samples floating around the internet today, and human analysts will look at very,
    very few of these. Instead, defenders will identify the vast majority of them
    through automated means. In that sense, the next few chapters of the book more
    accurately describe how professional malware detection and analysis works.
  prefs: []
  type: TYPE_NORMAL
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  prefs: []
  type: TYPE_NORMAL
