<html><head></head><body>
<section>
<header>
<h1 class="part">
<span class="PartNumber"><span epub:type="pagebreak" title="221" id="Page_221"/>Part II</span><br/>
<span class="PartTitle">C for Big Machines</span></h1>
</header>
<p class="PartIntro">So far we’ve concentrated on embedded programming. With embedded systems, you have limited memory and limited resources. However, C is designed to work on larger machines with operating systems (that we don’t have to program ourselves), and it has many features that are useful on these larger machines.</p>
<p>For example, there is a memory region called the <em>heap</em> that allows you to allocate and free memory, as needed, to store complex objects. Things like web browsers and XML parsers make extensive use of the heap.</p>
<p>We haven’t covered this before because we barely had enough memory for the stack—and dividing memory into a stack and heap would like dividing a drop of water between two glasses. It’s possible, but very tricky and not very useful.</p>
<p>We also haven’t covered the C I/O system. We’ve had to do the I/O ourselves, going directly to the hardware. On big machines with an operating system, the C I/O system and the operating system hide all those details from you.</p>
<p>Let’s take a look at the differences between embedded and non-embedded programming.</p>
<p>In<b> </b>embedded programming, when you write to a device, you write directly to the device. This means that you must know the details of the device you are using. For<b> </b>non-embedded programming, when you call <code>write</code> to write to a device, you tell the operating system to do the work, including buffering to make the I/O more efficient and dealing with the actual device.</p>
<p><span epub:type="pagebreak" title="222" id="Page_222"/>In<b> </b>embedded programming, you have limited memory. You need to know where every byte is and how its being used. With non-embedded programming,<b> </b>you have an operating system and memory mapping system, which gives you access to a lot of memory. Most programs can afford to waste memory, and a lot of programs do.</p>
<p>An embedded program is loaded into flash memory by an external loader. In our case, it’s called ST-LINK and is hidden inside the IDE, but it’s there. The program stays in flash forever and is never unloaded or replaced during the normal operation of the system. Non-embedded systems, on the other hand, have an operating system that loads and unloads programs as needed.</p>
<p>An embedded system runs one program. You barely have enough memory for that. However non-embedded systems can and do run more than one program at a time. The system I’m writing this on is currently running 341 programs, and it’s a small system.</p>
<p>Embedded programs never stop, whereas non-embedded<b> </b>ones can exit and return control to the operating system.</p>
<p>Embedded systems store all their data in memory. Non-embedded systems have a filesystem and can read and write file data as well as screens, networks, and other peripherals.</p>
<p>Finally, errors in embedded systems must be handled by your program. For non-embedded systems, you have an operating system that will catch errors not handled by the program and print a warning or stop the program. The operating system keeps a bad program from damaging other resources on the system. In contrast, if an embedded program<b> </b>goes south, you can easily brick the system.</p>
<p>C++ works well on larger systems because, in most cases, the overhead does not significantly affect things. For example, let’s suppose you want to write a program to read a bunch of data from a database and write a report. For a report that runs once a day, who cares if the program uses 0.5 seconds of CPU time versus 0.2 seconds?</p>
<p>However, if you are doing high-performance computing, such as gaming, animation, or video editing, you need the performance and precision of C. Even though it’s an older language, C still has its place on mainframes.</p>
<p>In this section, you’ll learn how to use the heap, which is dynamic memory that can be allocated or freed at will. You will also learn how to deal with the operating system’s I/O system—actually, two I/O systems: the buffered I/O system and the raw I/O system.</p>
<p>Finally, you will discover how to use floating-point numbers. Most cheap embedded processors don’t have a floating-point unit, so we can’t use floating-point numbers in embedded programs. Also, although mainframes have dedicated floating-point hardware, you must use this feature carefully; otherwise, you may get unexpected results.</p>
</section>
</body></html>