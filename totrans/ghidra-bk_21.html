<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_363"/>
<h2 class="h2" id="ch17"><strong><span class="big">17</span><br/>GHIDRA LOADERS</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent">Except for a brief example demonstrating the Raw Binary loader in <a href="ch04.xhtml#ch04">Chapter 4</a>, Ghidra has identified the file type and happily loaded and analyzed all of the files we have thrown at it. This will not always be the case. At some point, you are likely to be confronted with a dialog like the one shown in <a href="ch17.xhtml#fig17_1">Figure 17-1</a>. (This particular file is shellcode, which Ghidra is unable to recognize, as there is no defined structure, meaningful file extension, or magic number.)</p>
<span epub:type="pagebreak" id="page_364"/>
<div class="image"><img src="Images/fig17-1.jpg" alt="image" width="574" height="357"/></div>
<p class="figcap" id="fig17_1"><em>Figure 17-1: Raw Binary loader example</em></p>
<p class="indent">So what happened when we tried to import this file? Let’s start with a high-level view of Ghidra’s process for loading a file:</p>
<ol>
<li class="noindent">In the Ghidra Project window, the user specifies a file to load into a project.</li>
<li class="noindent">The Ghidra Importer polls all of the Ghidra loaders, and each loader tries to identify the file. Each then responds with a list of load specifications to populate the Import dialog if it can load the file. (An empty list means “I can’t load this file.”)</li>
<li class="noindent">The Importer collects responses from all of the loaders, builds a list of loaders that recognize the file, and presents a populated Import dialog to the user.</li>
<li class="noindent">The user chooses a loader and associated information for loading the file.</li>
<li class="noindent">The Importer invokes the user-selected loader that then loads the file.</li>
</ol>
<p class="indent">For the file in <a href="ch17.xhtml#fig17_1">Figure 17-1</a>, none of the format-specific loaders responded with a “yes.” As a result, the task was passed to the only loader willing to take any file at any time—the Raw Binary loader. This loader performs almost no work, shifting the analysis burden to the reverse engineer. If you ever find yourself analyzing similar files that all appear to have the “raw” format, it may be time to build a specialized loader to help you with some or all of the loading process. Several tasks need to be undertaken to create a new loader that Ghidra can use to load a file in a new format.</p>
<p class="indent">In this chapter, we first walk you through analysis of a file whose format is not recognized by Ghidra. This will help you understand the process of analyzing an unknown file and also make a strong case for building a loader, which is how we will spend the second half of the chapter.</p>
<span epub:type="pagebreak" id="page_365"/>
<h3 class="h3" id="ch17lev306"><strong>Unknown File Analysis</strong></h3>
<p class="noindent">Ghidra includes loader modules to recognize many of the more common executable and archive file formats, but there is no way that Ghidra can accommodate the ever-increasing number of file formats for storing executable code. Binary images may contain executable files formatted for use with specific operating systems, ROM images extracted from embedded systems, firmware images extracted from flash updates, or simply raw blocks of machine language, perhaps extracted from network packet captures. The format of these images may be dictated by the operating system (executable files), the target processor and system architecture (ROM images), or nothing at all (exploit shellcode embedded in application layer data).</p>
<p class="indent">Assuming that a processor module is available to disassemble the code contained in the unknown binary, it will be your job to properly arrange the file image within Ghidra before informing Ghidra which portions of the binary represent code and which portions of the binary represent data. For most processor types, the result of loading a file using the raw format is simply a list of the contents of the file piled into a single segment, beginning at address zero, as shown in <a href="ch17.xhtml#exa17_1">Listing 17-1</a>.</p>
<pre>00000000 4d       ??         4Dh    M<br/>
00000001 5a       ??         5Ah    Z<br/>
00000002 90       ??         90h<br/>
00000003 00       ??         00h<br/>
00000004 03       ??         03h<br/>
00000005 00       ??         00h<br/>
00000006 00       ??         00h<br/>
00000007 00       ??         00h</pre>
<p class="ex-caption" id="exa17_1"><em>Listing 17-1: Initial lines of an unanalyzed PE file loaded using the Raw Binary loader</em></p>
<p class="indent">In some cases, depending on the sophistication of the selected processor module, some disassembly takes place. For example, a selected processor for an embedded microcontroller can make specific assumptions about the memory layout of ROM images, or an analyzer with knowledge of common code sequences associated with a specific processor can optimistically format any matches as code.</p>
<p class="indent">When you are faced with an unrecognized file, arm yourself with as much information about the file as you can get your hands on. Useful resources might include notes on how and where the file was obtained, processor references, operating system references, system design documentation, and any memory layout information obtained through debugging or hardware-assisted analysis (such as via logic analyzers).</p>
<p class="indent">In the following section, for the sake of example, we assume that Ghidra does not recognize the Windows PE file format. PE is a well-known file format that many readers may be familiar with. More importantly, documents detailing the structure of PE files are widely available, which makes dissecting an arbitrary PE file a relatively simple task.</p>
<span epub:type="pagebreak" id="page_366"/>
<h3 class="h3" id="ch17lev307"><strong>Manually Loading a Windows PE File</strong></h3>
<p class="noindent">When you can find documentation on the format of a particular file, your life will be significantly easier as you attempt to use Ghidra to help you make sense of the binary. <a href="ch17.xhtml#exa17_1">Listing 17-1</a> shows the first few lines of an unanalyzed PE file loaded into Ghidra using the Raw Binary loader and <code>x86:LE:32:default:windows</code> as its language/compiler specification.<sup><a id="ch17fn1a" href="footnotes.xhtml#ch17fn1">1</a></sup> The PE specification states that a valid PE file begins with an MS-DOS header structure, beginning with the 2-byte signature, <code>4Dh 5Ah</code> (<code>MZ</code>), which we see in the first two lines of <a href="ch17.xhtml#exa17_1">Listing 17-1</a>.<sup><a id="ch17fn2a" href="footnotes.xhtml#ch17fn2">2</a></sup> The 4-byte value located at offset <code>0x3C</code> in the file contains the offset to the next header we need to find: the PE header.</p>
<p class="indent">Two strategies for breaking down the fields of the MS-DOS header are (1) to define appropriately sized data values for each field in the MS-DOS header and (2) to use Ghidra’s Data Type Manager functionality to define and apply an <code>IMAGE_DOS_HEADER</code> structure in accordance with the PE file specification. We will look at the challenges associated with option 1 in an example later in the chapter. In this case, option 2 requires significantly less effort.</p>
<p class="indent">When using the Raw Binary loader, Ghidra does not load the Data Type Manager with the Windows data types, so we can load the archive containing MS-DOS types, <em>windows_vs12_32.gdt</em>, ourselves. Locate the <code>IMAGE_DOS_HEADER</code> either by navigating to it within the archive or choosing <span class="smallcaps">CTRL-</span>F to find it in the Data Type Manager window; then drag and drop the header onto the start of the file. You can also place the cursor on the first address in the listing and choose Data ▸ Choose Data Type (or hotkey T) from the right-click context menu and enter, or navigate to, the data type in the resulting Data Type Chooser dialog. Any of these options yields the following listing, with descriptive end-of-line comments describing each field:</p>
<pre>00000000 4d 5a      WORD      5A4Dh    e_magic<br/>
00000002 90 00      WORD      90h      e_cblp<br/>
00000004 03 00      WORD      3h       e_cp<br/>
00000006 00 00      WORD      0h       e_crlc<br/>
00000008 04 00      WORD      4h       e_cparhdr<br/>
0000000a 00 00      WORD      0h       e_minalloc<br/>
0000000c ff ff      WORD      FFFFh    e_maxalloc<br/>
0000000e 00 00      WORD      0h       e_ss<br/>
00000010 b8 00      WORD      B8h      e_sp<br/>
00000012 00 00      WORD      0h       e_csum<br/>
00000014 00 00      WORD      0h       e_ip<br/>
00000016 00 00      WORD      0h       e_cs<br/>
00000018 40 00      WORD      40h      e_lfarlc<br/>
0000001a 00 00      WORD      0h       e_ovno<br/>
0000001c 00 00 00   WORD[4]            e_res<br/>
         00 00 00<br/>
         00 00<br/>
<span epub:type="pagebreak" id="page_367"/>
00000024 00 00      WORD      0h       e_oemid<br/>
00000026 00 00      WORD      0h       e_oeminfo<br/>
00000028 00 00 00   WORD[10]           e_res2<br/>
         00 00 00<br/>
         00 00 00<br/>
0000003c d8 00 00   LONG      D8h      e_lfanew</pre>
<p class="indent">The <code>e_lfanew</code> field in the final line of the previous listing has a value of <code>D8h</code>, indicating that a PE header should be found at offset <code>D8h</code> (216 bytes) into the binary. Examining the bytes at offset <code>D8h</code> should reveal the magic number for a PE header, <code>50h 45h</code> (<code>PE</code>), which indicates that we should apply an <code>IMAGE_NT_HEADERS</code> structure at offset <code>D8h</code> into the binary. Here is a portion of the resulting expanded Ghidra listing:</p>
<pre>000000d8    IMAGE_NT_HEADERS<br/>
   000000d8       DWORD           4550h     Signature<br/>
   000000dc    IMAGE_FILE_HEADER            FileHeader<br/>
      000000dc    WORD            14Ch      Machine<span class="ent">➊</span><br/>
      000000de    WORD            5h        NumberOfSections<span class="ent">➋</span><br/>
      000000e0    DWORD           40FDFD    TimeDateStamp<br/>
      000000e4    DWORD           0h        PointerToSymbolTable<br/>
      000000e8    DWORD           0h        NumberOfSymbols<br/>
      000000ec    WORD            E0h       SizeOfOptionalHeader<br/>
      000000ee    WORD            10Fh      Characteristics<br/>
   000000f0    IMAGE_OPTIONAL_HEADER32      OptionalHeader<br/>
      000000f0    WORD            10Bh      Magic<br/>
      000000f2    BYTE            '\u0006'  MajorLinkerVersion<br/>
      000000f3    BYTE            '\0'      MinorLinkerVersion<br/>
      000000f4    DWORD           21000h    SizeOfCode<br/>
      000000f8    DWORD           A000h     SizeOfInitializedData<br/>
      000000fc    DWORD           0h        SizeOfUninitializedData<br/>
      00000100    DWORD           14E0h     AddressOfEntryPoint<span class="ent">➌</span><br/>
      00000104    DWORD           1000h     BaseOfCode<br/>
      00000108    DWORD           1000h     BaseOfData<br/>
      0000010c    DWORD           400000h   ImageBase<span class="ent">➍</span><br/>
      00000110    DWORD           1000h     SectionAlignment<span class="ent">➎</span><br/>
      00000114    DWORD           1000h     FileAlignment<span class="ent">➏</span></pre>
<p class="indent">At this point, we have revealed a number of interesting pieces of information that will help us to further refine the layout of the binary. First, the <code>Machine</code> field <span class="ent">➊</span> in a PE header indicates the target processor type for which the file was built. The value <code>14Ch</code> indicates that the file is for use with x86 processor types. Had the machine type been something else, such as <code>1C0h</code> (ARM), we would need to close the CodeBrowser, right-click our file in the Project window to select the Set Language option, and choose the correct language setting.</p>
<p class="indent">The <code>ImageBase</code> field <span class="ent">➍</span> indicates the base virtual address for the loaded file image. Using this information, we can incorporate some virtual address information into the CodeBrowser. Using the Window ▸ Memory Map menu option, we are shown the list of memory blocks (<a href="ch17.xhtml#fig17_2">Figure 17-2</a>) that make up the current program. In this case, a single memory block contains all of the <span epub:type="pagebreak" id="page_368"/>program’s content. The Raw Binary loader has no means of determining appropriate memory addresses for any of our program’s content, so it places all of the content in a single memory block starting at address zero.</p>
<div class="image"><img src="Images/fig17-2.jpg" alt="image" width="574" height="226"/></div>
<p class="figcap" id="fig17_2"><em>Figure 17-2: The Memory Map window</em></p>
<p class="indent">The Memory Map window’s tool buttons, shown in <a href="ch17.xhtml#fig17_3">Figure 17-3</a>, are used to manipulate memory blocks. In order to properly map our image into memory, the first thing we need to do is set the base address specified in the PE header.</p>
<div class="image"><img src="Images/fig17-3.jpg" alt="image" width="678" height="679"/></div>
<p class="figcap" id="fig17_3"><em>Figure 17-3: Memory Map window tools</em></p>
<span epub:type="pagebreak" id="page_369"/>
<p class="indent">The <code>ImageBase</code> field <span class="ent">➍</span> tells us that the correct base address for this binary is <code>00400000</code>. We can use the Set Image Base option to adjust the image base from the default to this value. Once we click OK, all Ghidra windows will be updated to reflect the new memory layout of the program, as shown in <a href="ch17.xhtml#fig17_4">Figure 17-4</a>. (Be careful using this option after you already have multiple memory blocks defined; it will shift every memory block the same distance as the base memory block.)</p>
<div class="image"><img src="Images/fig17-4.jpg" alt="image" width="574" height="223"/></div>
<p class="figcap" id="fig17_4"><em>Figure 17-4: Memory Map after setting image base</em></p>
<p class="indent">The <code>AddressOfEntryPoint</code> field <span class="ent">➌</span> specifies the relative virtual address (RVA) of the program entry point. In the PE file specification, an RVA is a relative offset from the program’s base virtual address, while the program entry point is the address of the first instruction within the program file that will be executed. In this case, an entry point RVA of <code>14E0h</code> indicates that the program will begin execution at virtual address <code>4014E0h</code> (<code>400000h + 14E0h</code>). This is our first indication of where we should begin looking for code within the program. Before we can do that, however, we need to properly map the remainder of the program to appropriate virtual addresses.</p>
<p class="indent">The PE format uses sections to describe the mapping of file content to memory ranges. By parsing the section headers for each section in the file, we can complete the basic virtual memory layout of the program. The <code>NumberOfSections</code> field <span class="ent">➋</span> indicates the number of sections contained in a PE file (in this case, five). According to the PE specification, an array of section header structures immediately follows the <code>IMAGE_NT_HEADERS</code> structure. Individual elements in the array are <code>IMAGE_SECTION_HEADER</code> structures, which we define in the Ghidra structures editor and apply (five times, in this case) to the bytes following the <code>IMAGE_NT_HEADERS</code> structure. Alternatively, you can select the first byte of the first section header and set its type to <code>IMAGE</code><code>_SECTION_HEADER[</code><span class="codeitalic">n</span><code>]</code>, where <span class="codeitalic">n</span> is 5 in this example, to collapse the entire array into a single Ghidra display line.</p>
<p class="indent">The <code>FileAlignment</code> field <span class="ent">➏</span> and the <code>SectionAlignment</code> field <span class="ent">➎</span> indicate how the data for each section is aligned within the file and how that same data will be aligned when mapped into memory. In our example, both fields are set to align on <code>1000h</code> byte offsets.<sup><a id="ch17fn3a" href="footnotes.xhtml#ch17fn3">3</a></sup> In the PE format, there is no requirement <span epub:type="pagebreak" id="page_370"/>that these two numbers be the same. The fact that they are the same does make our lives easier, however, as it means that offsets to content within the disk file are identical to offsets to the corresponding bytes in the loaded memory image of the file. Understanding how sections are aligned is important in helping us avoid errors when we manually create sections for our program.</p>
<p class="indent">After structuring each of the section headers, we have enough information to create additional segments within the program. Applying an <code>IMAGE_SECTION_HEADER</code> template to the bytes immediately following the <code>IMAGE_NT_HEADERS</code> structure yields the first section header in our Ghidra listing:</p>
<pre>004001d0    IMAGE_SECTION_HEADER<br/>
   004001d0       BYTE[8]         ".text"   Name<span class="ent">➊</span><br/>
   004001d8    _union_226                   Misc<br/>
      004001d8    DWORD           20A80h    PhysicalAddress<br/>
      004001d8    DWORD           20A80h    VirtualSize<br/>
   004001dc       DWORD           1000h     VirtualAddress<span class="ent">➋</span><br/>
   004001e0       DWORD           21000h    SizeOfRawData<span class="ent">➌</span><br/>
   004001e4       DWORD           1000h     PointerToRawData<span class="ent">➍</span><br/>
   004001e8       DWORD           0h        PointerToRelocations<br/>
   004001ec       DWORD           0h        PointerToLinenumbers<br/>
   004001f0       WORD            0h        NumberOfRelocations<br/>
   004001f2       WORD            0h        NumberOfLinenumbers</pre>
<p class="indent">The <code>Name</code> field <span class="ent">➊</span> informs us that this header describes the <code>.text</code> section. All of the remaining fields are potentially useful in formatting the listing, but we will focus on the three that describe the layout of the section. The <code>PointerToRawData</code> field <span class="ent">➍</span> (<code>1000h</code>) indicates the file offset at which the content of the section can be found. Note that this value is a multiple of the file alignment value, <code>1000h</code>. Sections within a PE file are arranged in increasing file offset (and virtual address) order. Since this section begins at file offset <code>1000h</code>, the first <code>1000h</code> bytes of the file contain file header data and padding (if there are fewer than <code>1000h</code> bytes of header data, the section must be padded to a <code>1000h</code> byte boundary). Therefore, even though the header bytes do not, strictly speaking, constitute a section, we can highlight the fact that they are logically related by grouping them into a memory block in the Ghidra listing.</p>
<p class="indent">Ghidra offers two ways to create new memory blocks, both accessed through the Memory Map window from <a href="ch17.xhtml#fig17_2">Figure 17-2</a>. The Add Block tool (refer to <a href="ch17.xhtml#fig17_3">Figure 17-3</a>) opens the dialog shown in <a href="ch17.xhtml#fig17_5">Figure 17-5</a>, which is used to add new memory blocks that do not overlap with any existing memory block. The dialog asks for the name of the new memory block, its start address, and its length. The block may be initialized with a constant value (zero-filled, for example), initialized with content from the current file (you indicate the file offset from which the content is taken), or left uninitialized.</p>
<p class="indent">The second way to create a new block is to split an existing block. To split a block in Ghidra, you must first select the block to split in the Memory Map window and then use the Split Block tool (refer to <a href="ch17.xhtml#fig17_3">Figure 17-3</a>) to open the dialog shown in <a href="ch17.xhtml#fig17_6">Figure 17-6</a>. We are just starting out, so we have only one block to split. We start by splitting the file at the beginning of the <code>.text</code> section to carve the program headers off of the beginning of the existing block. When we enter <span epub:type="pagebreak" id="page_371"/>the length (<code>1000h</code>) of our block to split (the header section), Ghidra automatically computes the remaining address and length fields. All that is left is to provide a name for the new block being created at the split point. Here, we use the name contained in the first section header: <code>.text</code>.</p>
<div class="image"><img src="Images/fig17-5.jpg" alt="image" width="461" height="520"/></div>
<p class="figcap" id="fig17_5"><em>Figure 17-5: The Add Memory Block dialog</em></p>
<div class="image"><img src="Images/fig17-6.jpg" alt="image" width="334" height="450"/></div>
<p class="figcap" id="fig17_6"><em>Figure 17-6: The Split Block dialog</em></p>
<span epub:type="pagebreak" id="page_372"/>
<p class="indent">We now have two blocks in our memory map. The first block contains the correctly sized program headers. The second block contains the correctly named, but not correctly sized, <code>.text</code> section. This situation is reflected in <a href="ch17.xhtml#fig17_7">Figure 17-7</a>, where we can see that the size of the <code>.text</code> section is <code>0x29000</code> bytes.</p>
<div class="image"><img src="Images/fig17-7.jpg" alt="image" width="574" height="152"/></div>
<p class="figcap" id="fig17_7"><em>Figure 17-7: Memory Map window after splitting a block</em></p>
<p class="indent">Returning to the header for the <code>.text</code> section, we see that the <code>VirtualAddress</code> field <span class="ent">➋</span> (<code>1000h</code>) is an RVA that specifies the memory offset (from <code>ImageBase</code>) at which the section content begins and that the <code>SizeOfRawData</code> field <span class="ent">➌</span> (<code>21000h</code>) indicates how many bytes of data are present in the file. In other words, this particular section header tells us that the <code>.text</code> section is created by mapping the <code>21000h</code> bytes from file offsets <code>1000h-21FFFh</code> to virtual addresses <code>401000h-421FFFh</code>.</p>
<p class="indent">Because we split the original memory block at the beginning of the <code>.text</code> section, the newly created <code>.text</code> section temporarily contains all remaining sections, since its current size of <code>0x29000</code> is greater than the correct size of <code>0x21000</code>. By consulting the remaining section headers and repeatedly splitting the last memory block, we make progress toward a correct final memory map for the program. However, a problem arises when we reach the following pair of section headers:</p>
<pre>00400220    IMAGE_SECTION_HEADER<br/>
   00400220       BYTE[8]         ".data"   Name<br/>
   00400228    _union_226                   Misc<br/>
      00400228    DWORD           5624h     PhysicalAddress<br/>
      00400228    DWORD           5624h     VirtualSize<span class="ent">➊</span><br/>
   0040022c       DWORD           24000h    VirtualAddress<span class="ent">➋</span><br/>
   00400230       DWORD           4000h     SizeOfRawData<span class="ent">➌</span><br/>
   00400234       DWORD           24000h    PointerToRawData<br/>
   00400238       DWORD           0h        PointerToRelocations<br/>
   0040023c       DWORD           0h        PointerToLinenumbers<br/>
   00400240       WORD            0h        NumberOfRelocations<br/>
   00400242       WORD            0h        NumberOfLinenumbers<br/>
   00400244       DWORD           C0000040h Characteristics<br/>
00400248    IMAGE_SECTION_HEADER<br/>
   00400248       BYTE[8] ".idata" Name<br/>
   00400250    _union_226 Misc<br/>
      00400250    DWORD           75Ch      PhysicalAddress<br/>
      00400250    DWORD           75Ch      VirtualSize<br/>
<span epub:type="pagebreak" id="page_373"/>
   00400254       DWORD           2A000h    VirtualAddress<span class="ent">➍</span><br/>
   00400258       DWORD           1000h     SizeOfRawData<br/>
   0040025c       DWORD           28000h    PointerToRawData<span class="ent">➎</span><br/>
   00400260       DWORD           0h        PointerToRelocations<br/>
   00400264       DWORD           0h        PointerToLinenumbers<br/>
   00400268       WORD            0h        NumberOfRelocations<br/>
   0040026a       WORD            0h        NumberOfLinenumbers<br/>
   0040026c       DWORD           C0000040h Characteristics</pre>
<p class="indent">The <code>.data</code> section’s virtual size <span class="ent">➊</span> is larger than its file size <span class="ent">➌</span>. What does this mean and how does it impact our memory map? The compiler has concluded that the program requires <code>5624h</code> bytes of runtime static data, but supplies only <code>4000h</code> bytes to initialize that data. The remaining <code>1624h</code> bytes of runtime data will not be initialized with content from the executable file, as they are allocated for uninitialized global variables. (It is not uncommon to see such variables allocated within a dedicated program section named <code>.bss</code>.)</p>
<p class="indent">To finalize our memory map, we must choose an appropriate size for the <code>.data</code> section and ensure that subsequent sections are correctly mapped as well. The <code>.data</code> section maps <code>4000h</code> bytes of file data from file offset <code>24000h</code> to memory address <code>424000h</code> <span class="ent">➋</span> (<code>ImageBase</code> + <code>VirtualAddress</code>). The next section (<code>.idata</code>) maps <code>1000h</code> bytes from file offset <code>28000h</code> <span class="ent">➎</span> to memory address <code>42A000h</code> <span class="ent">➍</span>. If you’re paying close attention, you may have noticed that the <code>.data</code> section appears to occupy <code>6000h</code> bytes in memory (<code>42A000h–424000h</code>), and in fact it does. The reasoning behind this size is that the <code>.data</code> section requires <code>5624h</code> bytes, but this is not an even multiple of <code>1000h</code>, so the section will be padded up to <code>6000h</code> bytes so that the <code>.idata</code> section properly adheres to the section alignment requirement specified in the PE header. In order to finish our memory map, we must carry out the following actions:</p>
<ol>
<li class="noindent">Split the <code>.data</code> section using a length of <code>4000h</code>. The resulting <code>.idata</code> section will, for the moment, start at <code>428000h</code>.</li>
<li class="noindent">Move the <code>.idata</code> section to address <code>42A000h</code> by clicking the Move Block icon (<a href="ch17.xhtml#fig17_3">Figure 17-3</a>) and setting the start address to 42A000h.</li>
<li class="noindent">Split off, and, if necessary, move any remaining sections to achieve the final program layout.</li>
<li class="noindent">Optionally, expand any sections whose virtual size aligns to a higher boundary than their file size. In our example, the <code>.data</code> section’s virtual size, <code>5624h</code>, aligns to <code>6000h</code>, while its file size, <code>4000h</code>, aligns to <code>4000h</code>. Once we have created room by moving the <code>.idata</code> section to its proper location, we will expand the <code>.data</code> section from <code>4000h</code> to <code>6000h</code> bytes.</li>
</ol>
<p class="indent">To expand the <code>.data</code> section, highlight the <code>.data</code> section in the Memory Map window and then select the <strong>Expand Down</strong> tool (refer to <a href="ch17.xhtml#fig17_3">Figure 17-3</a>) to modify the end address (or length) of the section. The Expand Block Down dialog is shown in <a href="ch17.xhtml#fig17_8">Figure 17-8</a>. (This operation will add the <em>.exp</em> extension to the section name.)</p>
<span epub:type="pagebreak" id="page_374"/>
<div class="image"><img src="Images/fig17-8.jpg" alt="image" width="374" height="231"/></div>
<p class="figcap" id="fig17_8"><em>Figure 17-8: The Expand Block Down dialog</em></p>
<p class="indent">Our final memory map, obtained after the series of block moves, splits, and expansions, appears in <a href="ch17.xhtml#fig17_9">Figure 17-9</a>. In addition to the section name, start and end addresses, and length columns, read (R), write (W), and execute (X) permissions are shown for each section in the form of checkboxes. For PE files, these values are specified via bits in the <code>Characteristics</code> field of each section header. Consult the PE specification for information on parsing the <code>Characteristics</code> field to properly set permissions for each section.</p>
<div class="image"><img src="Images/fig17-9.jpg" alt="image" width="574" height="227"/></div>
<p class="figcap" id="fig17_9"><em>Figure 17-9: Final Memory Map window after creating all sections</em></p>
<p class="indent">With all program sections properly mapped, we need to locate some bytes that have a high likelihood of being code. The <code>AddressOfEntryPoint</code> (RVA <code>14E0h</code>, or virtual address <code>4014E0h</code>) leads us to the program’s entry point, which is known to be code. Navigating to this location, we see the following raw byte listing:</p>
<pre>004014e0  ??     55h    U<br/>
004014e1  ??     8Bh<br/>
004014e2  ??     ECh<br/>
...</pre>
<p class="indent">Using the context menu to disassemble (hotkey D) from <code>address</code> <code>004014e0</code> starts the recursive descent process (whose progress may be tracked in the lower-right corner of the Code Browser) and causes the bytes above to be reformatted as the code seen here:</p>
<pre>     FUN_004014e0<br/>
004014e0  PUSH   EBP<br/>
<span epub:type="pagebreak" id="page_375"/>
004014e1  MOV    EBP,ESP<br/>
004014e3  PUSH   -0x1<br/>
004014e5  PUSH   DAT_004221b8<br/>
004014ea  PUSH   LAB_004065f0<br/>
004014ef  MOV    EAX,FS:[0x0]<br/>
004014f5  PUSH   EAX</pre>
<p class="indent">At this point, we would hope that we had enough code to perform a comprehensive analysis of the binary. If we had fewer clues regarding the memory layout of the binary, or the separation between code and data within the file, we would need to rely on other sources of information to guide our analysis. Some potential approaches to determining correct memory layout and locating code include the following:</p>
<ul>
<li class="noindent">Use processor reference manuals to understand where reset vectors may be found.</li>
<li class="noindent">Search for strings in the binary that might suggest the architecture, operating system, or compiler used to build the binary.</li>
<li class="noindent">Search for common code sequences such as function prologues associated with the processor for which the binary was built.</li>
<li class="noindent">Perform statistical analysis over portions of the binary to find regions that look statistically similar to known binaries.</li>
<li class="noindent">Look for repetitive data sequences that might be tables of addresses (for example, many nontrivial 32-bit integers that all share the same upper 12 bits).<sup><a id="ch17fn4a" href="footnotes.xhtml#ch17fn4">4</a></sup> These may be pointers and may provide clues regarding the memory layout of the binary.</li>
</ul>
<p class="indent">In rounding out our discussion of loading raw binaries, consider that you would need to repeat each step covered in this section every time you open a binary with the same format that remains unknown to Ghidra. Along the way, you might automate some of your actions by writing scripts that perform some of the header parsing and segment creation for you. This is exactly the purpose of a Ghidra loader module! In the next section, we’ll write a simple loader module to introduce Ghidra’s loader module architecture, before moving on to more sophisticated loader modules that perform some common tasks associated with loading files that adhere to a structured format.</p>
<h3 class="h3" id="ch17lev308"><strong>Example 1: SimpleShellcode Loader Module</strong></h3>
<p class="noindent">At the beginning of this chapter, we tried to load a shellcode file into Ghidra and were referred to the Raw Binary loader. In <a href="ch15.xhtml#ch15">Chapter 15</a>, we used Eclipse and GhidraDev to create an analyzer module and then added it as an extension <span epub:type="pagebreak" id="page_376"/>to Ghidra. Recall that one of the module options provided by Ghidra was to create a loader module. In this chapter, we will build a simple loader module as an extension to Ghidra to load shellcode. As in our <a href="ch15.xhtml#ch15">Chapter 15</a> example, we will use a simplified software development process, as this is just a simple demonstration project. Our process will include the following steps:</p>
<ol>
<li class="noindent">Define the problem.</li>
<li class="noindent">Create the Eclipse module.</li>
<li class="noindent">Build the loader.</li>
<li class="noindent">Add the loader to our Ghidra installation.</li>
<li class="noindent">Test the loader from our Ghidra installation.</li>
</ol>
<span epub:type="pagebreak" id="page_377"/>
<div class="box5">
<p class="boxtitle-c"><strong>WHAT IS SHELLCODE AND WHY DO WE CARE?</strong></p>
<p class="noindent">To be pedantic, <em>shellcode</em> is raw machine code whose sole purpose is to spawn a user space shell process (for example, <em>/bin/sh</em>), most often by communicating directly with the operating system kernel using system calls. The use of system calls eliminates any dependencies on user space libraries such as <em>libc</em>. The term <em>raw</em> in this case should not be confused with a Ghidra Raw Binary loader. Raw machine code is code that has no packaging in the form of file headers and is quite compact when compared to a compiled executable that carries out the same actions. Compact shellcode for x86-64 on Linux may be as small as 30 bytes, but a compiled version of the following C program, which also spawns a shell, is still over 6000 bytes, even after it has been stripped:</p>
<pre>#include &lt;stdlib.h&gt;<br/>
int main(int argc, char **argv, char **envp) {<br/>
   execve("/bin/sh", NULL, NULL);<br/>
}</pre>
<p class="indent">The drawback to shellcode is that it can’t be run directly from the command line. Instead, it is typically injected into an existing process, and action is taken to transfer control to the shellcode. Attackers may attempt to place shellcode into a process’s memory space, in conjunction with other input consumed by the process, and then trigger a control flow hijack vulnerability that allows the attacker to redirect the process’s execution to their injected shellcode. Because shellcode is often embedded within other input intended for a process, shellcode may be observed in network traffic intended for a vulnerable server process, or within a file meant to be opened by a vulnerable viewing application.</p>
<p class="indent">Over time, the term <em>shellcode</em> has come to be used generically to describe any raw machine code incorporated into an exploit, regardless of whether the execution of that machine code spawns a user space shell on the target system.</p>
</div>
<h4 class="h4" id="ch17lev309"><strong><em>Step 0: Take a Step Back</em></strong></h4>
<p class="noindent">Before we can even start to define the problem, we need to understand (a) what Ghidra currently does with a shellcode file and (b) what we would like Ghidra to do with a shellcode file. Basically, we have to load and analyze a shellcode file as a raw binary and then use the information we discover to inform the development of our shellcode loader (and potentially an analyzer). Fortunately for us, most shellcode is not nearly as complicated as a PE file. Let’s take a deep breath and dive into the world of shellcode.</p>
<p class="indent">Let’s start by analyzing the shellcode file we tried to load at the beginning of the chapter. We loaded the file and were referred to the Raw Binary loader as our only option, as shown earlier in <a href="ch17.xhtml#fig17_1">Figure 17-1</a>. There was no recommendation for a language as the Raw Binary loader just “inherited” our file because none of the other loaders wanted it. Let’s select a relatively common language/compiler specification, <code>x86:LE:32:default:gcc</code>, as shown in <a href="ch17.xhtml#fig17_10">Figure 17-10</a>.</p>
<div class="image"><img src="Images/fig17-10.jpg" alt="image" width="488" height="302"/></div>
<p class="figcap" id="fig17_10"><em>Figure 17-10: Import dialog with language/compiler specification</em></p>
<p class="indent">We click <strong>OK</strong> and get an Import Results Summary window that includes the content shown in <a href="ch17.xhtml#fig17_11">Figure 17-11</a>.</p>
<div class="image"><img src="Images/fig17-11.jpg" alt="image" width="676" height="345"/></div>
<p class="figcap" id="fig17_11"><em>Figure 17-11: Import Results Summary for shellcode file</em></p>
<span epub:type="pagebreak" id="page_378"/>
<p class="indent">Based on the contents of the enlarged block in the summary, we know that there are only 78 bytes in the file in one memory/data block, and that is about all the help we get from the Raw Binary loader. If we open the file in the CodeBrowser, Ghidra will offer to auto analyze the file. Regardless of whether or not Ghidra auto analyzes the file, the Listing window in the CodeBrowser displays the content shown in <a href="ch17.xhtml#fig17_12">Figure 17-12</a>. Note that there is only one section in Program Trees, the Symbol Tree is empty, and the Data Type Manager has no entries in the folder specific to the file. In addition, the Decompiler window remains empty, as no functions have been identified in the file.</p>
<div class="image"><img src="Images/fig17-12.jpg" alt="image" width="574" height="556"/></div>
<p class="figcap" id="fig17_12"><em>Figure 17-12: CodeBrowser window after loading (or analyzing) the shellcode file</em></p>
<p class="indent">Right-click the first address in the file and choose <strong>Disassemble</strong> (hotkey D) from the context menu. In the Listing window, we now see something we can work with—a list of instructions! <a href="ch17.xhtml#exa17_2">Listing 17-2</a> shows the instructions after disassembly and after we have done some analysis on the file. The end-of-line comments document some of the analysis of this short file.</p>
<pre>0000002b  INC    EBX<br/>
0000002c  MOV    AL,0x66       ; 0x66 is Linux sys_socketcall<br/>
0000002e  INT    0x80          ; transfers flow to kernel to<br/>
                               ; execute system call<br/>
<span epub:type="pagebreak" id="page_379"/>
00000030  XCHG   EAX,EBX<br/>
00000031  POP    ECX<br/>
        LAB_00000032             XREF[1]:  00000038(j)<br/>
00000032  PUSH   0x3f          ; 0x3f is Linux sys_dup2<br/>
00000034  POP    EAX<br/>
00000035  INT    0x80          ; transfers flow to kernel to<br/>
                               ; execute system call<br/>
00000037  DEC    ECX<br/>
00000038  JNS   LAB_00000<br/>
0000003a  PUSH   0x68732f2f    ; 0x68732f2f converts to "//sh"<br/>
0000003f  PUSH   0x6e69622f    ; 0x6e69622f converts to "/bin"<br/>
00000044  MOV    EBX,ESP<br/>
00000046  PUSH   EAX<br/>
00000047  PUSH   EBX<br/>
00000048  MOV    ECX,ESP<br/>
0000004a  MOV    AL,0xb        ; 0xb is Linux sys_execve which<br/>
                               ; executes a specified program<br/>
0000004c  INT    0x80          ; transfers flow to kernel to<br/>
                                      ; execute system call</pre>
<p class="ex-caption" id="exa17_2"><em>Listing 17-2: Disassembled 32-bit Linux shellcode</em></p>
<p class="indent">Based on our analysis, the shellcode invokes the Linux <em>execve</em> system call (at <code>0000004c</code>) to launch <em>/bin/sh</em> (which was pushed onto the stack at <code>0000003a</code> and <code>000003f</code>). The fact that these instructions have meaning to us indicates that we likely chose an appropriate language and disassembly starting point.</p>
<p class="indent">We now know enough about the loading process to define our loader. (We also have enough information to build a simple shellcode analyzer, but that is a task for another day.)</p>
<h4 class="h4" id="ch17lev310"><strong><em>Step 1: Define the Problem</em></strong></h4>
<p class="noindent">Our task is to design and develop a simple loader that will load shellcode into our Listing window and set the entry point, which will facilitate auto analysis. The loader needs to be added to Ghidra and be available as a Ghidra Loader option. It also needs to be able to respond to the Ghidra Importer poll in an appropriate manner: the same way as the Raw Binary loader does. This will make our new loader a second catchall loader option. As a side note, all of the examples will utilize the FlatProgramAPI. While the FlatProgramAPI is not generally used for building extensions, its use will reinforce the scripting concepts presented in <a href="ch14.xhtml#ch14">Chapter 14</a> that you are likely to use when developing Ghidra scripts in Java.</p>
<h4 class="h4" id="ch17lev311"><strong><em>Step 2: Create the Eclipse Module</em></strong></h4>
<p class="noindent">As discussed in <a href="ch15.xhtml#ch15">Chapter 15</a>, use <strong>GhidraDev</strong> ▸ <strong>New</strong> ▸ <strong>Ghidra Module Project</strong> to create a module called SimpleShellcode that uses the Loader Module template. This will create a file called <em>SimpleShellcodeLoader.java</em> in the <em>src/main/java</em> folder within the SimpleShellcode module. This folder hierarchy is shown in context in <a href="ch17.xhtml#fig17_13">Figure 17-13</a>.</p>
<span epub:type="pagebreak" id="page_380"/>
<div class="image"><img src="Images/fig17-13.jpg" alt="image" width="328" height="128"/></div>
<p class="figcap" id="fig17_13"><em>Figure 17-13:</em> SimpleShellcode <em>hierarchy</em></p>
<h4 class="h4" id="ch17lev312"><strong><em>Step 3: Build the Loader</em></strong></h4>
<p class="noindent">A partial image of the loader template <em>SimpleShellcodeLoader.java</em> is shown in <a href="ch17.xhtml#fig17_14">Figure 17-14</a>. The functions have been collapsed so that you can see all of the loader methods provided in the loader template. Recall that Eclipse will recommend imports if you need them as you develop your code, so you can jump right into coding and accept the recommended <code>import</code> statements when Eclipse detects that you need them.</p>
<div class="image"><img src="Images/fig17-14.jpg" alt="image" width="637" height="303"/></div>
<p class="figcap" id="fig17_14"><em>Figure 17-14:</em> SimpleShellcodeLoader <em>template</em></p>
<p class="indent">Within the loader template in <a href="ch17.xhtml#fig17_14">Figure 17-14</a> are six <em>task tags</em> to the left of the line numbers that indicate where you should start your development. We will expand each section as we address specific tasks and include the before and after content associated with each task so you will understand how you need to modify the template. (Some content will be wrapped or reformatted for readability and comments minimized to conserve space.) Unlike the analyzer module you wrote in <a href="ch15.xhtml#ch15">Chapter 15</a>, this module does not require any obvious class member variables, so you can jump right into the tasks at hand.</p>
<h5 class="h5" id="ch17lev313"><strong>Step 3-1: Document the Class</strong></h5>
<p class="noindent">When you expand the first task tag, you see the following task description:</p>
<pre>/**<br/>
 * TODO: Provide class-level documentation that describes what this<br/>
 * loader does.<br/>
 */</pre>
<span epub:type="pagebreak" id="page_381"/>
<p class="indent">This task involves replacing the existing <code>TODO</code> comments with comments that describe what the loader does:</p>
<pre>/*<br/>
 * This loader loads shellcode binaries into Ghidra,<br/>
 * including setting an entry point.<br/>
 */</pre>
<h5 class="h5" id="ch17lev314"><strong>Step 3-2: Name and Describe the Loader</strong></h5>
<p class="noindent">Expanding the next task tag reveals a <code>TODO</code> comment and the string you need to edit. This makes it easy to identify where you should start working. The second task contains the following:</p>
<pre>public String getName() {<br/>
       // TODO: Name the loader.  This name must match the name<br/>
       // of the loader in the .opinion files<br/>
     return "My loader"<span class="ent">➊</span>;<br/>
}</pre>
<p class="indent">Change the string <span class="ent">➊</span> to something meaningful. You don’t need to worry about matching the name in the <em>.opinion</em> files, as they are not applicable to loaders that will accept any files. You will see <em>.opinion</em> files when you get to the third example. Ignoring the <em>.opinion</em> file comment in the template results in the following code:</p>
<pre>public String getName() {<br/>
   return "Simple Shellcode Loader";<br/>
}</pre>
<h5 class="h5" id="ch17lev315"><strong>Step 3-3: Determine If the Loader Can Load This File</strong></h5>
<p class="noindent">The second step in the loading process we described at the beginning of the chapter involved the Importer loader poll. This task requires you to determine if your loader can load the file and provide a response to the Importer through your method’s return value:</p>
<pre>public Collection&lt;LoadSpec&gt; findSupportedLoadSpecs(ByteProvider provider)<br/>
                            throws IOException {<br/>
   List&lt;LoadSpec&gt; loadSpecs = new ArrayList&lt;&gt;();<br/><br/>
   // TODO: Examine the bytes in 'provider' to determine if this loader<br/>
   // can load it.  If it can load it, return the appropriate load<br/>
   // specifications.<br/>
   return loadSpecs;<br/>
}</pre>
<p class="indent">Most loaders do this by examining the content of the file to find a magic number or header structure. The <code>ByteProvider</code> input parameter is a Ghidra-provided read-only wrapper around an input file stream. We are <span epub:type="pagebreak" id="page_382"/>going to simplify our task and adopt the <code>LoadSpec</code> list that the Raw Binary loader uses, which ignores file content and simply lists all possible <code>LoadSpec</code>s. We will then give our loader a lower priority than the Raw Binary loader so that if a more specific loader exists, it will automatically have a higher priority in the Ghidra Import dialog.</p>
<pre>public Collection&lt;LoadSpec&gt; findSupportedLoadSpecs(ByteProvider provider)<br/>
                                                   throws IOException {<br/>
   // The List of load specs supported by this loader<br/>
   List&lt;LoadSpec&gt; loadSpecs = new ArrayList&lt;&gt;();<br/>
   List&lt;LanguageDescription&gt; languageDescriptions =<br/>
        getLanguageService().getLanguageDescriptions(false);<br/>
   for (LanguageDescription languageDescription : languageDescriptions) {<br/>
      Collection&lt;CompilerSpecDescription&gt; compilerSpecDescriptions =<br/>
         languageDescription.getCompatibleCompilerSpecDescriptions();<br/>
      for (CompilerSpecDescription compilerSpecDescription :<br/>
           compilerSpecDescriptions) {<br/>
         LanguageCompilerSpecPair lcs =<br/>
            new LanguageCompilerSpecPair(languageDescription.getLanguageID(),<br/>
            compilerSpecDescription.getCompilerSpecID());<br/>
         loadSpecs.add(new LoadSpec(this, 0, lcs, false));<br/>
      }<br/>
   }<br/>
   return loadSpecs;<br/>
}</pre>
<p class="indent">Every loader has an associated tier and tier priority. Ghidra defines four tiers of loaders, ranging from highly specialized (tier 0) to format agnostic (tier 3). When multiple loaders are willing to accept a file, Ghidra sorts the loader list displayed to the user in increasing tier order. Loaders within the same tier are further sorted in increasing tier priority order (that is, tier priority 10 is listed before tier priority 20).</p>
<p class="indent">For example, the PE loader and the Raw Binary loader are both willing to load PE files, but the PE loader is a better choice to load this format (its tier is 1), so it will appear before the Raw Binary loader (tier 3, tier priority 100) in the list. We set the Simple Shellcode Loader’s tier to 3 (<code>LoaderTier.UNTARGETED_LOADER</code>) and priority to 101, so it will be given the lowest priority by the Importer when populating the Import window with candidate loaders. To accomplish this, add the following two methods to your loader:</p>
<pre>@Override<br/>
public LoaderTier getTier() {<br/>
   return LoaderTier.UNTARGETED_LOADER;<br/>
}<br/>
@Override<br/>
public int getTierPriority() {<br/>
   return 101;<br/>
}</pre>
<span epub:type="pagebreak" id="page_383"/>
<h5 class="h5" id="ch17lev316"><strong>Step 3-4: Load the Bytes</strong></h5>
<p class="noindent">The following method shown before and after we edit the content does the heavy lifting of loading content from the file being imported into our Ghidra project (in this case, it loads the shellcode):</p>
<pre>protected void load(ByteProvider provider, LoadSpec loadSpec,<br/>
               List&lt;Option&gt; options, Program program, TaskMonitor monitor,<br/>
               MessageLog log) throws CancelledException, IOException {<br/><br/>
   // TODO: Load the bytes from 'provider' into the 'program'.<br/>
}</pre>
<pre>protected void load(ByteProvider provider, LoadSpec loadSpec,<br/>
               List&lt;Option&gt; options, Program program, TaskMonitor monitor,<br/>
               MessageLog log) throws CancelledException, IOException {<br/>
<span class="ent">➊</span> FlatProgramAPI flatAPI = new FlatProgramAPI(program);<br/>
   try {<br/>
      monitor.setMessage("Simple Shellcode: Starting loading");<br/>
      // create the memory block we're going to load the shellcode into<br/>
      Address start_addr = flatAPI.toAddr(0x0);<br/>
   <span class="ent">➋</span> MemoryBlock block = flatAPI.createMemoryBlock("SHELLCODE",<br/>
      start_addr, provider.readBytes(0, provider.length()), false);<br/>
      // make this memory block read/execute but not writeable<br/>
   <span class="ent">➌</span> block.setRead(true);<br/>
      block.setWrite(false);<br/>
      block.setExecute(true);<br/>
      // set the entry point for the shellcode to the start address<br/>
   <span class="ent">➍</span> flatAPI.addEntryPoint(start_addr);<br/>
      monitor.setMessage( "Simple Shellcode: Completed loading" );<br/>
   } catch (Exception e) {<br/>
      e.printStackTrace();<br/>
      throw new IOException("Failed to load shellcode");<br/>
   }<br/>
}</pre>
<p class="indent">Note that, unlike the scripts in <a href="ch14.xhtml#ch14">Chapters 14</a> and <a href="ch15.xhtml#ch15">15</a>, which inherit from <code>GhidraScript</code> (and ultimately <code>FlatProgramAPI</code>), our loader class has no direct access to the Flat API. Therefore, to simplify our access to some commonly used API classes, we instantiate our own <code>FlatProgramAPI</code> object <span class="ent">➊</span>. Next, we create a <code>MemoryBlock</code> named <code>SHELLCODE</code> at address zero <span class="ent">➋</span> and populate it with the entire contents of the input file. We take the time to set some reasonable permissions <span class="ent">➌</span> on the new memory region before adding an entry point <span class="ent">➍</span> that informs Ghidra where it should begin its disassembly.</p>
<p class="indent">Adding an entry point is a very important step for a loader. The presence of entry points is the primary means by which Ghidra locates addresses known to contain code (as opposed to data). As it parses the input file, the loader is ideally suited to discover any entry points and identify them to Ghidra.</p>
<span epub:type="pagebreak" id="page_384"/>
<h5 class="h5" id="ch17lev317"><strong>Step 3-5: Register Custom Loader Options</strong></h5>
<p class="noindent">Some loaders offer users the option to modify various parameters associated with the loading process. You may override the <code>getDefaultOptions</code> function to provide Ghidra with a list of custom options available for your loader:</p>
<pre>public List&lt;Option&gt; getDefaultOptions(ByteProvider provider, LoadSpec<br/>
       loadSpec,DomainObject domainObject, boolean isLoadIntoProgram) {<br/>
   List&lt;Option&gt; list = super.getDefaultOptions(provider, loadSpec,<br/><br/>
                       domainObject, isLoadIntoProgram);<br/>
   // TODO: If this loader has custom options, add them to 'list'<br/>
   list.add(new Option("Option name goes here",<br/>
                        Default option value goes here));<br/>
   return list;<br/>
}</pre>
<p class="indent">Since this loader is just for demonstration purposes, we will not add any options. Options for a loader might include setting an offset into the file at which to start reading, and setting the base address at which to load the binary. To view the options associated with any loader, click the <strong>Options . . .</strong> button on the bottom right of the Import dialog (refer to <a href="ch17.xhtml#fig17_1">Figure 17-1</a>).</p>
<pre>public List&lt;Option&gt; getDefaultOptions(ByteProvider provider, LoadSpec<br/>
       loadSpec,DomainObject domainObject, boolean isLoadIntoProgram) {<br/>
   // no options<br/>
   List&lt;Option&gt; list = new ArrayList&lt;Option&gt;();<br/>
   return list;<br/>
}</pre>
<h5 class="h5" id="ch17lev318"><strong>Step 3-6: Validate Options</strong></h5>
<p class="noindent">The next task is to validate the options:</p>
<pre>public String validateOptions(ByteProvider provider, LoadSpec loadSpec,<br/>
                              List&lt;Option&gt; options, Program program) {<br/><br/>
   // TODO: If this loader has custom options, validate them here.<br/>
   // Not all options require validation.<br/>
   return super.validateOptions(provider, loadSpec, options, program);<br/>
}</pre>
<p class="indent">As we do not have any options, we just return <code>null</code>:</p>
<pre>public String validateOptions(ByteProvider provider, LoadSpec loadSpec,<br/>
                              List&lt;Option&gt; options, Program program) {<br/><br/>
   // No options, so no need to validate<br/>
   return null;<br/>
}</pre>
<span epub:type="pagebreak" id="page_385"/>
<div class="box5">
<p class="boxtitle-c"><strong>TESTING MODULES FROM ECLIPSE</strong></p>
<p class="noindent">If you are one of those programmers who doesn’t always get the code exactly right on the first try, you can avoid the multiple “export, start Ghidra, import extension, add extension to import list, choose extension, restart Ghidra, test extension” cycles by running the new code from Eclipse. If you choose Run ▸ Run As from the Eclipse menu, you will be given the option to run as Ghidra (or as Ghidra Headless). This will launch Ghidra, and you can import a file to the current project. Your loader will be included in the import options, and all console feedback will be provided in the Eclipse console. You can interact with the file in Ghidra, just like any other file. You can then exit out of your Ghidra project without saving and either (1) adjust the code, or (2) “export, start Ghidra, import extension, add extension to import list, choose extension, restart Ghidra, and test extension” just one time.</p>
</div>
<h4 class="h4" id="ch17lev319"><strong><em>Step 4: Add the Loader to Our Ghidra Installation</em></strong></h4>
<p class="noindent">After confirming that this module functions correctly, export the Ghidra module extension from Eclipse and then install the extension in Ghidra, just as we did with the SimpleROPAnalyzer module in <a href="ch15.xhtml#ch15">Chapter 15</a>. Select <strong>GhidraDev</strong> ▸ <strong>Export</strong> ▸ <strong>Ghidra Module Extension</strong>, choosing the <strong>SimpleShellcode</strong> module, and follow the same click-through process that you did in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>
<p class="indent">To import the extension into Ghidra, choose <strong>File</strong> ▸ <strong>Install Extensions</strong> from the Ghidra Project window. Add the new loader to the list and select it. Once you restart Ghidra, the new loader should be available as an option, but you should test to be sure.</p>
<h4 class="h4" id="ch17lev320"><strong><em>Step 5: Test the Loader Within Ghidra</em></strong></h4>
<p class="noindent">Our simplified test plan is just to demonstrate functionality. SimpleShellcode passed an acceptance test consisting of the following criteria:</p>
<ol>
<li class="noindent">(Pass) SimpleShellcode appears as a loader option with lower priority than Raw Binary.</li>
<li class="noindent">(Pass) SimpleShellcode loads a file and sets the entry point.</li>
</ol>
<p class="indent">Test case 1 passed, as shown in <a href="ch17.xhtml#fig17_15">Figure 17-15</a>. A second confirmation is shown in <a href="ch17.xhtml#fig17_16">Figure 17-16</a>, where the PE file analyzed earlier in the chapter is being loaded. In both cases, we see that the Simple Shellcode Loader option has the lowest priority in the Format list.</p>
<span epub:type="pagebreak" id="page_386"/>
<div class="image"><img src="Images/fig17-15.jpg" alt="image" width="574" height="379"/></div>
<p class="figcap" id="fig17_15"><em>Figure 17-15: Import window with our new loader listed as an option</em></p>
<div class="image"><img src="Images/fig17-16.jpg" alt="image" width="574" height="382"/></div>
<p class="figcap" id="fig17_16"><em>Figure 17-16: Import window with our new loader listed as an option for a PE file</em></p>
<p class="indent">Choose the language specification based on the information available about the binary and how it was obtained. Let’s assume that the shellcode was captured from packets headed for an x86 box. In that case, selecting <code>x86:LE:32:default:gcc</code> for our language/compiler specification is probably a good starting point.</p>
<span epub:type="pagebreak" id="page_387"/>
<p class="indent">After we select a language and click OK for the file shown in <a href="ch17.xhtml#fig17_15">Figure 17-15</a>, the binary will be imported into our Ghidra project. We can then open the program in the CodeBrowser, and Ghidra will provide us an option to analyze the file. If we accept the analysis, we will see the following listing:</p>
<pre>     undefined FUN_00000000()<br/>
        undefined  AL:1 &lt;RETURN&gt;<br/>
        undefined4 Stack[-0x10]:4 local_10  XREF[1]: 00000022(W)<br/>
     FUN_00000000                           XREF[1]: Entry Point(*)<span class="ent">➊</span><br/>
00000000 31 db          XOR    EBX,EBX<br/>
00000002 f7 e3          MUL    EBX<br/>
00000004 53             PUSH   EBX<br/>
00000005 43             INC    EBX<br/>
00000006 53             PUSH   EBX<br/>
00000007 6a 02          PUSH   0x2<br/>
00000009 89 e1          MOV    ECX,ESP<br/>
0000000b b0 66          MOV    AL,0x66<br/>
0000000d cd 80          INT    0x80<br/>
0000000f 5b             POP    EBX<br/>
00000010 5e             POP    ESI<br/>
00000011 52             PUSH   EDX<br/>
00000012 68 02 00 11 5c PUSH   0x5c110002</pre>
<p class="indent">An entry point <span class="ent">➊</span> is identified, so Ghidra is able to provide us with a disassembly to begin our analysis.</p>
<p class="indent">SimpleShellcodeLoader was a trivial example, as shellcode is generally found embedded within some other data. For demonstration purposes, we will use our loader module as a base to create a loader module that extracts shellcode from C source files and loads the shellcode for analysis. This may, for example, allow us to build shellcode signatures that Ghidra can recognize in other binaries. We will not go into great depth for each step, as we are just augmenting the capabilities of our existing shellcode loader.</p>
<h3 class="h3" id="ch17lev321"><strong>Example 2: Simple Shellcode Source Loader</strong></h3>
<p class="noindent">Since modules provide a way to organize code, and the SimpleShellcode module you created has everything required to create a loader, you don’t need to create a new module. Simply choose <strong>File</strong> ▸ <strong>New</strong> ▸ <strong>File</strong> from the Eclipse menu and add a new file (<em>SimpleShellcodeSourceLoader.java</em>) to your SimpleShellcode <em>src/main/java</em> folder. By doing this, all of your new loaders will be included in your new Ghidra extension.</p>
<p class="indent">To make life simple, paste the contents of your existing <em>SimpleShellcodeLoader.java</em> into this new file and update the comments about what the loader does. The following steps highlight the parts of the existing loader that you need to change to make the new loader work as expected. For the most part, you will be adding onto the existing code.</p>
<span epub:type="pagebreak" id="page_388"/>
<h4 class="h4" id="ch17lev322"><strong><em>Update 1: Modify the Response to the Importer Poll</em></strong> </h4>
<p class="noindent">The simple source loader is going to make its decision based strictly on the file extension. If the file does not end in <em>.c</em>, the loader will return an empty <code>loadSpecs</code> list. If the file does end with <em>.c</em>, it will return the same <code>loadSpecs</code> list that it did for the previous loader. To make this work, you need to add the following test to the <code>findSupportLoadSpecs</code> method:</p>
<pre>// The List of load specs supported by this loader<br/>
List&lt;LoadSpec&gt; loadSpecs = new ArrayList&lt;&gt;();<br/>
// Activate loader if the filename ends in a .c extension<br/>
if (!provider.getName().endsWith(".c")) {<br/>
   return loadSpecs;<br/>
}</pre>
<p class="indent">We’ve also decided that our loader deserves a higher priority than the Raw Binary loader because ours identifies a particular type of file to accept and is better suited for that type of file. This is done by returning a higher priority (lower value) from our <code>getTierPriority</code> method:</p>
<pre>public int getTierPriority() {<br/>
   // priority of this loader<br/>
   return 99;<br/>
}</pre>
<h4 class="h4" id="ch17lev323"><strong><em>Update 2: Find the Shellcode in the Source Code</em></strong></h4>
<p class="noindent">Recall that shellcode is just raw machine code that does something useful for us. The individual bytes in the shellcode will lie in the range <code>0..255</code>, and many of these values fall outside the range of ASCII printable characters. Therefore, when shellcode is embedded into a source file, much of it must be represented using hex escape sequences such as <code>\xFF</code>. Strings of this sort are rather unique, and we can build a regular expression to help our loader identify them. The following instance variable declaration describes the regular expression that all of the functions in our loader may use to find shellcode bytes with the selected C file:</p>
<pre>private String pattern = "\\\\x[0-9a-fA-F]{1,2}";</pre>
<p class="indent">Within the <code>load</code> method, the loader parses the file looking for patterns that match the regular expression to help calculate the amount of memory needed when loading the file into Ghidra. As shellcode is frequently not contiguous, the loader should parse the entire file looking for shellcode regions to load from the file.</p>
<pre>// set up the regex matcher<br/>
CharSequence provider_char_seq =<br/>
      new String(provider.readBytes(0, provider.length())<span class="ent">➊</span>, "UTF-8");<br/>
Pattern p = Pattern.compile(pattern);<br/>
Matcher m = p.matcher(provider_char_seq)<span class="ent">➋</span>;<br/>
<span epub:type="pagebreak" id="page_389"/>
// Determine how many matches (shellcode bytes) were found so that we can<br/>
// correctly size the memory region, then reset the matcher<br/>
int match_count = 0;<br/>
while (m.find()) {<br/>
 <span class="ent">➌</span> match_count++;<br/>
}<br/>
m.reset();</pre>
<p class="indent">After loading the entire contents of the input file <span class="ent">➊</span>, we count all of the matches <span class="ent">➌</span> against our regular expression <span class="ent">➋</span>.</p>
<h4 class="h4" id="ch17lev324"><strong><em>Update 3: Convert Shellcode to Byte Values</em></strong></h4>
<p class="noindent">The <code>load()</code> method next needs to convert the hex escape sequences into byte values and put them in a byte array:</p>
<pre>byte[] shellcode = new byte[match_count];<br/>
// convert the hex representation of bytes in the source code to actual<br/>
// byte values in the binary we're creating in Ghidra<br/>
int ii = 0;<br/>
while (m.find()) {<br/>
   // strip out the \x<br/>
   String hex_digits = m.group().replaceAll("[^0-9a-fA-F]+", "")<span class="ent">➊</span>;<br/>
   // parse what's left into an integer and cast it to a byte, then<br/>
   // set current byte in byte array to that value<br/>
   shellcode[ii++]<span class="ent">➋</span> = (byte)Integer.parseInt(hex_digits, 16)<span class="ent">➌</span>;<br/>
}</pre>
<p class="indent">The hex digits are extracted from each matching string <span class="ent">➊</span> and converted into byte values <span class="ent">➌</span> that get appended to our shellcode array <span class="ent">➋</span>.</p>
<h4 class="h4" id="ch17lev325"><strong><em>Update 4: Load Converted Byte Array</em></strong></h4>
<p class="noindent">Finally, because the shellcode is in a byte array, the <code>load()</code> method needs to copy it from the byte array into the program’s memory. This is the actual loading step and the last required step for your loader to accomplish the goal:</p>
<pre>// create the memory block and populate it with the shellcode<br/>
Address start_addr = flatAPI.toAddr(0x0);<br/>
MemoryBlock block =<br/>
      flatAPI.createMemoryBlock("SHELLCODE", start_addr, shellcode, false);</pre>
<h4 class="h4" id="ch17lev326"><strong><em>Results</em></strong></h4>
<p class="noindent">To test our new loader, we create a C source file that contains the following escaped representation of x86 shellcode:</p>
<pre>unsigned char buf[] =<br/>
   "\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80"<br/>
   "\x5b\x5e\x52\x68\x02\x00\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a"<br/>
   "\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0"<br/>
<span epub:type="pagebreak" id="page_390"/>
   "\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f"<br/>
   "\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0"<br/>
   "\x0b\xcd\x80";</pre>
<p class="indent">Because our source file’s name ends in <em>.c</em>, our loader appears in the list as the top selection, with higher priority than the Raw Binary and Simple Shellcode loaders, as shown in <a href="ch17.xhtml#fig17_17">Figure 17-17</a>.</p>
<div class="image"><img src="Images/fig17-17.jpg" alt="image" width="567" height="389"/></div>
<p class="figcap" id="fig17_17"><em>Figure 17-17: Import dialog for shellcode source file</em></p>
<p class="indent">Selecting this loader, using the same default compiler/language specification as the previous example (<code>x86:LE:32:default:gcc</code>), and letting Ghidra auto analyze the file yields the following function in the disassembly listing:</p>
<pre>     **************************************************************<br/>
     *                         FUNCTION                           *<br/>
     **************************************************************<br/>
     undefined FUN_00000000()<br/>
        undefined AL:1 &lt;RETURN&gt;<br/>
        undefined4 Stack[-0x10]:4 local_10<br/>
     FUN_00000000                      XREF[1]: Entry Point(*)<br/>
00000000  XOR    EBX,EBX<br/>
00000002  MUL    EBX<br/>
00000004  PUSH   EBX<br/>
00000005  INC    EBX<br/>
00000006  PUSH   EBX</pre>
<p class="indent">Scrolling down through the listing leads us to the familiar content (see <a href="ch17.xhtml#exa17_2">Listing 17-2</a>) shown here (with comments added for clarity):</p>
<pre>        LAB_00000032<br/>
00000032  PUSH   0x3f<br/>
00000034  POP    EAX<br/>
<span epub:type="pagebreak" id="page_391"/>
00000035  INT    0x80<br/>
00000037  DEC    ECX<br/>
00000038  JNS    LAB_00000<br/>
0000003a  PUSH   0x68732f2f          ; 0x68732f2f converts to "//sh"<br/>
0000003f  PUSH   0x6e69622f          ; 0x6e69622f converts to "/bin"</pre>
<p class="indent">Most reverse engineering efforts focus on binaries. In this case, we have stepped outside that box and used Ghidra to load shellcode for analysis as well as to extract shellcode from C source files. Our goal was to demonstrate the flexibility and simplicity of creating loaders for Ghidra. Now, let’s step back into that box and create a loader for a structured file format.</p>
<p class="indent">Assume that our target shellcode is contained within an ELF binary and that, for the sake of this example, Ghidra does not recognize ELF binaries. Further, none of us have ever heard of an ELF binary. Let the adventure begin.</p>
<h3 class="h3" id="ch17lev327"><strong>Example 3: Simple ELF Shellcode Loader</strong></h3>
<p class="noindent">Congratulations! You are now the resident RE expert on shellcode, and colleagues are reporting what they suspect is shellcode contained in binaries and are being referred by Ghidra to the Raw Binary loader. Since this does not appear to be a one-off problem, and you think there is a good chance you will see more binaries with similar characteristics, you decide to build a loader that will handle this new type of file. As discussed in <a href="ch13.xhtml#ch13">Chapter 13</a>, you can use tools internal or external to Ghidra to capture information about the file. If you once again turn to the command line, <code>file</code> provides helpful information to start building your loader:</p>
<pre>$ <span class="codestrong1">file elf_shellcode_min</span><br/>
  elf_shellcode_min: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV),<br/>
  statically linked, corrupted section header size<br/>
$</pre>
<p class="indent">The <code>file</code> command provides information about a format you have never heard of before, ELF. Your first step is to do some research to see if you can locate any information about this type of binary. Your friend Google will happily point you to several references about the ELF format, which you can use to locate the information you need to build your loader. Anything that provides enough accurate information to solve the problem works.<sup><a id="ch17fn5a" href="footnotes.xhtml#ch17fn5">5</a></sup></p>
<p class="indent">As this is a bigger challenge than the previous two loader examples, we will break this into sections associated with the individual files within your Eclipse SimpleShellcode module that you will need to create/modify/delete to complete your new <em>SimpleELFShellcodeLoader</em>. We will start off with some simple housekeeping.</p>
<span epub:type="pagebreak" id="page_392"/>
<h4 class="h4" id="ch17lev328"><strong><em>Housekeeping</em></strong></h4>
<p class="noindent">The first step is to create a <em>SimpleELFShellcodeLoader.java</em> file within the SimpleShellcode module in Eclipse. As you don’t want to start from nothing, you should use Save As with <em>SimpleShellcodeLoader.java</em> to create this new file. Once you have done this, there are a few minor modifications to make to the new file before you can start focusing on the new challenge:</p>
<ul>
<li class="noindent">Change the name of the class to <span class="codestrong">SimpleELFShellcodeLoader</span>.</li>
<li class="noindent">Modify the <code>getTier</code> method return value from <code>UNTARGETED_LOADER</code> to <span class="codestrong">GENERIC_TARGET_LOADER</span>.</li>
<li class="noindent">Delete the <code>getTierPriority</code> method.</li>
<li class="noindent">Modify the <code>getName</code> method to return <span class="codestrong">"Simple ELF Shellcode Loader"</span>.</li>
</ul>
<p class="indent">Once you have completed the housekeeping tasks, let’s apply the information you learned from your research about the new header format.</p>
<h4 class="h4" id="ch17lev329"><strong><em>ELF Header Format</em></strong></h4>
<p class="noindent">While researching this new format, you discover that the ELF format contains three types of headers: the file header (or ELF header), the program header(s), and the section header(s). You can start by focusing on the ELF header. Associated with each field in the ELF header is an offset as well as other information about the field. Since you need to access only a few of these fields and you won’t be modifying the offsets, declare the following constants as instance variables within your loader class to help your loader correctly parse this new header format:</p>
<pre>private final byte[] ELF_MAGIC            = {0x7f, 0x45, 0x4c, 0x46};<br/>
private final long EH_MAGIC_OFFSET        = 0x00;<br/>
private final long EH_MAGIC_LEN           = 4;<br/><br/>
private final long EH_CLASS_OFFSET        = 0x04;<br/>
private final byte EH_CLASS_32BIT         = 0x01;<br/><br/>
private final long EH_DATA_OFFSET         = 0x05;<br/>
private final byte EH_DATA_LITTLE_ENDIAN  = 0x01;<br/><br/>
private final long EH_ETYPE_OFFSET        = 0x10;<br/>
private final long EH_ETYPE_LEN           = 0x02;<br/>
private final short EH_ETYPE_EXEC         = 0x02;<br/><br/>
private final long EH_EMACHINE_OFFSET     = 0x12;<br/>
private final long EH_EMACHINE_LEN        = 0x02;<br/>
private final short EH_EMACHINE_X86       = 0x03;<br/><br/>
private final long EH_EFLAGS_OFFSET       = 0x24;<br/>
private final long EN_EFLAGS_LEN          = 4;<br/><br/>
private final long EH_EEHSIZE_OFFSET      = 0x28;<br/>
private final long EH_PHENTSIZE_OFFSET    = 0x2A;<br/>
private final long EH_PHNUM_OFFSET        = 0x2C;</pre>
<span epub:type="pagebreak" id="page_393"/>
<p class="indent">With a description of the ELF header in hand, the next step is to determine how to respond to the Importer poll to ensure that the new ELF loader is capable of loading only files that adhere to the ELF format. In the previous two examples, the shellcode loaders did not look at file contents to determine if they could load a file. This simplified coding these examples significantly. Now things are a bit more complicated. Fortunately, the ELF documentation provides important clues to help determine the appropriate loader specifications.</p>
<h4 class="h4" id="ch17lev330"><strong><em>Find Supported Load Specifications</em></strong></h4>
<p class="noindent">The loader can’t load anything that isn’t in the right format and can reject any file by returning an empty <code>loadSpecs</code> list. Within the <code>findSupportedLoadSpecs()</code> method, immediately eliminate all binaries that don’t have the expected magic number by using the following code:</p>
<pre>byte[] magic = provider.readBytes(EH_MAGIC_OFFSET, EH_MAGIC_LEN);<br/>
if (!Arrays.equals(magic, ELF_MAGIC)) {<br/>
   // the binary is not an ELF<br/>
   return loadSpecs;<br/>
}</pre>
<p class="indent">Once the undesirables have been eliminated, the loader can check the bit width and endianness to see if the architecture is reasonable for an ELF binary. For this demonstration, let’s further limit the types of binaries the loader will accept to 32-bit little-endian:</p>
<pre>byte ei_class = provider.readByte(EH_CLASS_OFFSET);<br/>
byte ei_data = provider.readByte(EH_DATA_OFFSET);<br/>
if ((ei_class != EH_CLASS_32BIT) || (ei_data != EH_DATA_LITTLE_ENDIAN)) {<br/>
   // not an ELF we want to accept<br/>
   return loadSpecs;<br/>
}</pre>
<p class="indent">To round out the verification process, the following code checks if this is an ELF executable file (as opposed to a shared library) for the x86 architecture:</p>
<pre>byte[] etyp = provider.readBytes(EH_ETYPE_OFFSET, EH_ETYPE_LEN);<br/>
short e_type =<br/>
      ByteBuffer.wrap(etyp).order(ByteOrder.LITTLE_ENDIAN).getShort();<br/>
byte[] emach = provider.readBytes(EH_EMACHINE_OFFSET, EH_EMACHINE_LEN);<br/>
short e_machine =<br/>
      ByteBuffer.wrap(emach).order(ByteOrder.LITTLE_ENDIAN).getShort();<br/>
if ((e_type != EH_ETYPE_EXEC) || (e_machine != EH_EMACHINE_X86)) {<br/>
   // not an ELF we want to accept<br/>
   return loadSpecs;<br/>
}</pre>
<p class="indent">Now that you have limited your file types, you can query the opinion service for matching language and compiler specifications. Conceptually, you <span epub:type="pagebreak" id="page_394"/>query the opinion services with values extracted from the file you are loading (for example, the ELF header <code>e_machine</code> field), and in response you receive a list of language/compiler specifications that your loader is willing to accept. (The “behind the scenes” actions that take place when you query the opinion service are described in more detail in the following sections.)</p>
<pre>byte[] eflag = provider.readBytes(EH_EFLAGS_OFFSET, EN_EFLAGS_LEN);<br/>
int e_flags = ByteBuffer.wrap(eflag).order(ByteOrder.LITTLE_ENDIAN).getInt();<br/>
List&lt;QueryResult&gt; results =<br/>
     QueryOpinionService.query(getName(), Short.toString(e_machine),<br/>
                               Integer.toString(e_flags));</pre>
<p class="indent">Let’s assume that the opinion service is likely to yield more results than you want to handle with this loader. You can pare the list further by excluding results based on the attributes specified in the associated language/compiler specifications. The following code filters out a compiler and a processor variant:</p>
<pre>for (QueryResult result : results) {<br/>
   CompilerSpecID cspec = result.pair.getCompilerSpec().getCompilerSpecID();<br/>
   if (cspec.toString().equals("borlanddelphi"<span class="ent">➊</span>)) {<br/>
      // ignore anything created by Delphi<br/>
      continue;<br/>
   }<br/>
   String variant = result.pair.getLanguageDescription().getVariant();<br/>
   if (variant.equals("System Management Mode"<span class="ent">➋</span>)) {<br/>
       // ignore anything where the variant is "System Management Mode"<br/>
       continue;<br/>
   }<br/>
   // valid load spec, so add it to the list<br/>
 <span class="ent">➌</span> loadSpecs.add(new LoadSpec(this, 0, result));<br/>
}<br/>
return loadSpecs;</pre>
<p class="indent">The above examples (which you are free to include in your loader) specifically exclude the <em>Delphi compiler</em> <span class="ent">➊</span> and <em>x86 system management mode</em> <span class="ent">➋</span>. You can exclude others if you wish. All of the results you have not excluded need to be added to your <code>loadSpecs</code> list <span class="ent">➌</span>.</p>
<h4 class="h4" id="ch17lev331"><strong><em>Load File Content into Ghidra</em></strong></h4>
<p class="noindent">The <code>load()</code> method of your simplified loader assumes the file consists of a minimal ELF header and a short program header, followed by the shellcode in a text section. You need to determine the total length of the header to allocate the correct amount of space for it. The following code determines the required size by using the <code>EH_EEHSIZE_OFFSET</code>, <code>EH_PHENTSIZE_OFFSET</code>, and <code>EH_PHNUM_OFFSET</code> fields from the ELF header:</p>
<pre>// Get some values from the header needed for the load process<br/>
//<br/>
// How big is the ELF header?<br/>
<span epub:type="pagebreak" id="page_395"/>
byte[] ehsz = provider.readBytes(EH_EEHSIZE_OFFSET, 2);<br/>
e_ehsize = ByteBuffer.wrap(ehsz).order(ByteOrder.LITTLE_ENDIAN).getShort();<br/><br/>
// How big is a single program header?<br/>
byte[] phsz = provider.readBytes(EH_PHENTSIZE_OFFSET, 2);<br/>
e_phentsize =<br/>
      ByteBuffer.wrap(phsz).order(ByteOrder.LITTLE_ENDIAN).getShort();<br/><br/>
// How many program headers are there?<br/>
byte[] phnum = provider.readBytes(EH_PHNUM_OFFSET, 2);<br/>
e_phnum = ByteBuffer.wrap(phunm).order(ByteOrder.LITTLE_ENDIAN).getShort();<br/><br/>
// What is the total header size for our simplified ELF format<br/>
// (This includes the ELF Header plus program headers.)<br/>
long hdr_size = e_ehsize + e_phentsize * e_phnum;</pre>
<p class="indent">Now that you know the size, create and populate the memory blocks for the ELF header section and the text section as follows:</p>
<pre>// Create the memory block for the ELF header<br/>
long LOAD_BASE = 0x10000000;  <br/>
Address hdr_start_adr = flatAPI.toAddr(LOAD_BASE);<br/>
MemoryBlock hdr_block =<br/>
      flatAPI.createMemoryBlock(".elf_header", hdr_start_adr,<br/>
                                 provider.readBytes(0, hdr_size), false);<br/>
// Make this memory block read-only<br/>
hdr_block.setRead(true);<br/>
hdr_block.setWrite(false);<br/>
hdr_block.setExecute(false);<br/><br/>
// Create the memory block for the text from the simplified ELF binary<br/>
Address txt_start_adr = flatAPI.toAddr(LOAD_BASE + hdr_size);<br/>
MemoryBlock txt_block =<br/>
      flatAPI.createMemoryBlock(".text", txt_start_adr,<br/>
             provider.readBytes(hdr_size, provider.length() – hdr_size),<br/>
             false);<br/><br/>
// Make this memory block read &amp; execute<br/>
txt_block.setRead(true);<br/>
txt_block.setWrite(false);<br/>
txt_block.setExecute(true);</pre>
<h4 class="h4" id="ch17lev332"><strong><em>Format Data Bytes and Add an Entry Point</em></strong></h4>
<p class="noindent">A few more steps, and you will be done. Loaders often apply data types and create cross-references for information derived from file headers. It is also the loader’s job to identify any entry points in the binary. Creating a list of entry points at load time provides the disassembler with a list of locations it should consider code. Our loader follows these practices:</p>
<pre>  // Add structure to the ELF HEADER<br/>
<span class="ent">➊</span> flatAPI.createData(hdr_start_adr, new ElfDataType());<br/>
<span epub:type="pagebreak" id="page_396"/>
    // Add label and entry point at start of shellcode<br/>
<span class="ent">➋</span> flatAPI.createLabel(txt_start_adr, "shellcode", true);<br/>
<span class="ent">➌</span> flatAPI.addEntryPoint(txt_start_adr);<br/><br/>
  // Add a cross reference from the ELF header to the entrypoint<br/>
  Data d = flatAPI.getDataAt(hdr_start_adr).getComponent(0).getComponent(9);<br/>
<span class="ent">➍</span> flatAPI.createMemoryReference(d, txt_start_adr, RefType.DATA);</pre>
<p class="indent">First, the Ghidra ELF header data type is applied at the start of the ELF headers <span class="ent">➊</span>.<sup><a id="ch17fn6a" href="footnotes.xhtml#ch17fn6">6</a></sup> Second, a label <span class="ent">➋</span> and an entry point <span class="ent">➌</span> are created for the shellcode. Finally, we create a cross-reference between the entry point field in the ELF header and the start of the shellcode <span class="ent">➍</span>.</p>
<p class="indent">Congratulations! You are done writing the Java code for your loader, but we need to address a couple of issues to ensure that you understand all of the dependencies between your new loader and some important related files in order for your loader to operate as expected.</p>
<p class="indent">This example leverages an existing processor architecture (x86), and some work was done behind the scenes that helped this loader work correctly. Recall that the Importer polled the loaders and magically produced acceptable language/compiler specifications. The following two files provided information critical to the loader. The first of these files is the x86 language definition file <em>x86.ldefs</em>, is a component of the x86 processor module.</p>
<h4 class="h4" id="ch17lev333"><strong><em>Language Definition Files</em></strong></h4>
<p class="noindent">Every processer has an associated language definition file. This is an XML-formatted file that includes all of the information required to generate language/compiler specifications for the processor. Language definitions from the <em>x86.ldefs</em> file that meet the requirements for a 32-bit ELF binary are shown in the following listing:</p>
<span epub:type="pagebreak" id="page_397"/>
<pre>&lt;language processor="x86"<br/>
          endian="little"<br/>
          size="32"<br/>
          variant="default"<br/>
          version="2.8"<br/>
          slafile="x86.sla"<br/>
          processorspec="x86.pspec"<br/>
          manualindexfile="../manuals/x86.idx"<br/>
          id="x86:LE:32:default"&gt;<br/>
   &lt;description&gt;Intel/AMD 32-bit x86&lt;/description&gt;<br/>
   &lt;compiler name="Visual Studio" spec="x86win.cspec" id="windows"/&gt;<br/>
   &lt;compiler name="gcc" spec="x86gcc.cspec" id="gcc"/&gt;<br/>
   &lt;compiler name="Borland C++" spec="x86borland.cspec" id="borlandcpp"/&gt;<br/>
 <span class="ent">➊</span> &lt;compiler name="Delphi" spec="x86delphi.cspec" id="borlanddelphi"/&gt;<br/>
&lt;/language&gt;<br/>
&lt;language processor="x86"<br/>
          endian="little"<br/>
          size="32"<br/>
        <span class="ent">➋</span> variant="System Management Mode"<br/>
          version="2.8"<br/>
          slafile="x86.sla"<br/>
          processorspec="x86-16.pspec"<br/>
          manualindexfile="../manuals/x86.idx"<br/>
          id="x86:LE:32:System Management Mode"&gt;<br/>
   &lt;description&gt;Intel/AMD 32-bit x86 System Management Mode&lt;/description&gt;<br/>
   &lt;compiler name="default" spec="x86-16.cspec" id="default"/&gt;<br/>
&lt;/language&gt;</pre>
<p class="indent">This file is used to populate the recommended language/compiler specs presented as import options. In this case, there are five recommended specifications (each starting with the <code>compiler</code> tag), which will be returned based on information associated with the ELF binary, but our loader eliminates two from consideration based on the compiler <span class="ent">➊</span> and the variant <span class="ent">➋</span>.</p>
<h4 class="h4" id="ch17lev334"><strong><em>Opinion Files</em></strong></h4>
<p class="noindent">Another type of support file is the <em>.opinion</em> file. This is an XML-formatted file that contains constraints associated with your loader. To be recognized by the opinion query service, each loader must have an entry in an opinion file. The following listing shows a suitable opinion file entry for the loader you just built:</p>
<pre>&lt;opinions&gt;<br/>
   &lt;constraint loader="Simple ELF Shellcode Loader" compilerSpecID="gcc"&gt;<br/>
      &lt;constraint<span class="ent">➊</span> primary<span class="ent">➋</span>="3" processor="x86"  endian="little" size="32" /&gt;<br/>
      &lt;constraint primary="62" processor="x86"  endian="little" size="64" /&gt;<br/>
   &lt;/constraint&gt;<br/>
&lt;/opinions&gt;</pre>
<p class="indent">Everything in the entry should be familiar, except possibly the <code>primary</code> field <span class="ent">➋</span>. This field is the primary key for a search that identifies the machine as defined in the ELF header. Within the ELF header, the value <code>0x03</code> in the <code>e_machine</code> field means x86, and <code>0x3E</code> in the <code>e_machine</code> field means amd64. A <code>&lt;constraint&gt;</code> tag <span class="ent">➊</span> defines an association between a primary key (<code>"3"</code>/x86) and the remaining attributes of the <code>&lt;constraint&gt;</code> tag. This information is used by the query service to locate the appropriate entries in the language definition files.</p>
<p class="indent">Our only remaining task is to place our opinion data in an appropriate place where Ghidra will find it. The only opinion files that ship with Ghidra reside in the <em>data/languages</em> subdirectory of a Ghidra processor module. Although you could insert your opinion data into an existing opinion file, it’s a good idea to avoid modifying any processor opinion files, as your modifications will need to be reapplied anytime you upgrade your Ghidra installation.</p>
<p class="indent">Instead, create a new opinion file containing our opinion data. You can name the file anything you wish, but <em>SimpleShellcode.opinion</em> seems reasonable. Our Eclipse Loader Module template contains its own <em>data</em> subdirectory. Save <span epub:type="pagebreak" id="page_398"/>your opinion file in this location so it will be associated with your loader module. Ghidra will locate it when looking for opinion files, and any upgrades to the Ghidra installation should not affect your module.</p>
<p class="indent">Now that you understand what is going on behind the scenes, it is time to test your loader and see if it behaves as anticipated.</p>
<h4 class="h4" id="ch17lev335"><strong><em>Results</em></strong></h4>
<p class="noindent">To demonstrate the success of the new simplified ELF loader (one program header and no sections), let’s walk through the loading process and observe how the loader performs at each step of the process.</p>
<p class="indent">From the Ghidra Project window, import a file. The importer will poll all of Ghidra’s loaders, including yours, to see which are willing to load this file. Recall that your loader is expecting a file that fits the following profile:</p>
<ul>
<li class="noindent">ELF magic number at the start of the file</li>
<li class="noindent">32-bit little endian</li>
<li class="noindent">ELF executable for the x86 architecture</li>
<li class="noindent">Cannot have been compiled by Delphi</li>
<li class="noindent">Cannot have the variant “System Management Mode”</li>
</ul>
<p class="indent">If you load a file that fits that profile, you should see an Import dialog similar to the one in <a href="ch17.xhtml#fig17_18">Figure 17-18</a> that displays a prioritized list of the loaders willing to process this file.</p>
<div class="image"><img src="Images/fig17-18.jpg" alt="image" width="574" height="367"/></div>
<p class="figcap" id="fig17_18"><em>Figure 17-18: Import options for</em> elf_shellcode_min</p>
<p class="indent">The loader with the highest priority is Ghidra’s ELF loader. Let’s compare the language/compiler specifications that it will accept (top of <a href="ch17.xhtml#fig17_19">Figure 17-19</a>) with the ones that your new loader will accept at the bottom of the figure.</p>
<span epub:type="pagebreak" id="page_399"/>
<div class="image"><img src="Images/fig17-19.jpg" alt="image" width="574" height="429"/></div>
<p class="figcap" id="fig17_19"><em>Figure 17-19: Acceptable language/compiler specifications for two different loaders</em></p>
<p class="indent">The Delphi compiler and the System Management Mode variant are accepted by the stock ELF loader but not by your loader, as they have been filtered out. When you select your loader for the file <em>elf_shellcode_min</em>, you should see a summary similar to <a href="ch17.xhtml#fig17_20">Figure 17-20</a>.</p>
<div class="image"><img src="Images/fig17-20.jpg" alt="image" width="574" height="443"/></div>
<p class="figcap" id="fig17_20"><em>Figure 17-20: Import Results Summary window for the new ELF Shellcode Loader</em></p>
<span epub:type="pagebreak" id="page_400"/>
<p class="indent">If you open the file in the CodeBrowser and allow Ghidra to auto analyze the file, you should see the following ELF header definition at the top of the file:</p>
<pre>10000000 7f             db      7Fh          e_ident_magic_num<br/>
10000001 45 4c 46       ds      "ELF"        e_ident_magic_str<br/>
10000004 01             db      1h           e_ident_class<br/>
10000005 01             db      1h           e_ident_data<br/>
10000006 01             db      1h           e_ident_version<br/>
10000007 00 00 00 00 00 db[9]                e_ident_pad<br/>
         00 00 00 00<br/>
10000010 02 00          dw      2h           e_type<br/>
10000012 03 00          dw      3h           e_machine<br/>
10000014 01 00 00 00    ddw     1h           e_version<br/>
10000018 54 00 00 10    ddw     shellcode<span class="ent">➊</span>  e_entry<br/>
1000001c 34 00 00 00    ddw     34h          e_phoff<br/>
10000020 00 00 00 00    ddw     0h           e_shoff<br/>
10000024 00 00 00 00    ddw     0h           e_flags<br/>
10000028 34 00          dw      34h          e_ehsize</pre>
<p class="indent">Within the listing, the <code>shellcode</code> label <span class="ent">➊</span> is clearly associated with the entry point. Double-clicking the <code>shellcode</code> label takes you to a function, named <code>shellcode</code>, that contains the same shellcode contents we’ve seen in our previous two examples, including the following:</p>
<pre>1000008c  JNS    LAB_10000086<br/>
1000008e  PUSH   "//sh"<br/>
10000093  PUSH   "/bin"<br/>
10000098  MOV    EBX,ESP<br/>
1000009a  PUSH   EAX</pre>
<p class="indent">Now that you have confirmed that your new loader works, you can add it as an extension to your Ghidra installation and share it with your colleagues who have been anxiously awaiting this functionality.</p>
<h3 class="h3" id="ch17lev336"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, we focused on the challenges associated with dealing with unrecognized binary files. We walked through examples of the loading and analysis processes that we can use within Ghidra to help us with these challenging reverse engineering scenarios. Finally, we extended our module creation capabilities to the world of Ghidra loaders.</p>
<p class="noindent">While the examples that we built were trivial, they provided the foundation and introduced all of the components required to write more complex loader modules in Ghidra. In the next chapter, we round out our discussion of Ghidra modules with an introduction to processor modules—the components most responsible for the overall formatting of a disassembled binary.</p>
</div>



  </body></html>