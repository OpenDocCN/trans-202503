- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: 'When we talk about how programming languages work, we tend to borrow metaphors
    from fantasy novels: compilers are magic, and the people who work on them are
    wizards. Dragons may be involved somehow. But in the day-to-day lives of most
    programmers, compilers behave less like magical artifacts and more like those
    universal translator earpieces from science fiction. They aren’t flashy or dramatic;
    they don’t demand a lot of attention. They just hum along in the background, translating
    a language you speak (or type) fluently into the alien language of machines.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: For some reason, sci-fi characters rarely seem to wonder how their translators
    work. But once you’ve been coding for a while, it’s hard not to feel curious about
    what your compiler is doing. A few years ago, this curiosity got the better of
    me, so I decided to learn more about compilers by writing one of my own. It was
    important to me to write a compiler for a real programming language, one that
    I’d used myself. And I wanted my compiler to generate assembly code that I could
    run without an emulator or virtual machine. But when I looked around, I found
    that most guides to compiler construction used toy languages that ran on idealized
    processors. Some of these guides were excellent, but they weren’t quite what I
    was looking for.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'I finally got unstuck when a friend pointed me toward a short paper titled
    “An Incremental Approach to Compiler Construction” by Abdulaziz Ghuloum (*[http://<wbr>scheme2006<wbr>.cs<wbr>.uchicago<wbr>.edu<wbr>/11<wbr>-ghuloum<wbr>.pdf](http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf)*).
    It explained how to compile Scheme to x86 assembly, starting with the simplest
    possible programs and adding one new language construct at a time. I didn’t particularly
    want to write a compiler for Scheme, so I adapted the paper to a language I was
    more interested in: C. As I kept working on the project, I switched from x86 to
    its modern counterpart, x64 assembly. I also built out support for a larger subset
    of C and added a few optimization passes. By this point, I had gone way beyond
    Ghuloum’s original scheme (pun intended, sorry), but his basic strategy held up
    remarkably well: focusing on one small piece of the language at a time made it
    easy to stay on track and see that I was making progress. In this book, you’ll
    tackle the same project. Along the way, you’ll gain a deeper understanding of
    the code you write and the system it runs on.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Who This Book Is For</samp>
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I wrote this book for programmers who are curious about how compilers work.
    Many books about compiler construction are written as textbooks for college or
    graduate-level classes, but this one is meant to be accessible to someone exploring
    the topic on their own. You won’t need any prior knowledge of compilers, interpreters,
    or assembly code to complete this project. A basic understanding of computer architecture
    is helpful, but not essential; I’ll discuss important concepts as they come up
    and occasionally point you to outside resources with more background information.
    That said, this is not a book for novice programmers. You should be comfortable
    writing substantive programs on your own, and you should be familiar with binary
    numbers, regular expressions, and basic data structures like graphs and trees.
    You’ll need to know C well enough to read and understand small C programs, but
    you don’t need to be an expert C programmer. We’ll explore the ins and outs of
    the language as we go.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这本书是为了那些对编译器如何工作感到好奇的程序员。许多关于编译器构建的书籍是为大学或研究生水平的课程编写的，但这本书的目的是让那些自己探索这一主题的人也能轻松理解。你不需要具备编译器、解释器或汇编语言的任何先验知识就能完成这个项目。对计算机架构的基本理解是有帮助的，但并非必需；我会在涉及到相关概念时进行讨论，并偶尔推荐一些外部资源以供你了解更多背景信息。话虽如此，这本书并不是为初学编程的人准备的。你应该能够独立编写有实质内容的程序，并且对二进制数字、正则表达式以及图形和树等基本数据结构有所了解。你需要对C语言有足够的了解，能读懂并理解小型C程序，但不需要是C语言专家。在本书中，我们会随着进度一起深入探索语言的方方面面。
- en: Although this book is geared toward newcomers to the subject, it will also be
    worthwhile for people who have some experience with compilers already. Maybe you
    implemented a toy language for a college class or personal project, and now you’d
    like to work on something more realistic. Or maybe you’ve worked on interpreters
    in the past, and you want to try your hand at compiling programs down to machine
    code. If you’re in this category, this book will cover some material you already
    know, but it will provide plenty of new challenges too. At the very least, I promise
    you’ll learn a few things about C.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书是针对编程新手编写的，但对于已经有一些编译器经验的人来说同样是值得一读的。也许你曾为大学课程或个人项目实现了一个简单的语言，现在你希望做一些更实际的工作。或者，可能你曾经做过解释器相关的工作，想尝试将程序编译成机器代码。如果你属于这一类人，这本书会涉及一些你已经了解的内容，但也会提供许多新的挑战。至少，我保证你会学到一些关于C语言的知识。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why Write a C Compiler?</samp>
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么要编写C语言编译器？</samp>
- en: I assume you’re already sold on the idea of writing a compiler—you did pick
    up this book, after all. I want to talk a little bit about why we’re writing a
    compiler for C in particular. The short answer is that C is a (relatively) simple
    language, but not a toy language. At its core, C is simple enough to implement
    even if you’ve never written a compiler before. But it’s also a particularly clear
    example of how programming languages are shaped by the systems they run on and
    the people who use them. Some aspects of C vary based on what hardware you’re
    targeting; others vary between operating systems; still others are left unspecified
    to give compiler writers more flexibility. Some bits of the language are historical
    artifacts that have stuck around to support legacy code, while others are more
    recent attempts to make C safer and more reliable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经对编写编译器的想法有所了解——毕竟你已经拿起了这本书。我想稍微谈一下为什么我们特别要为C语言编写一个编译器。简短的回答是，C是一种（相对）简单的语言，但并不是玩具语言。从本质上讲，即使你从未编写过编译器，C语言也足够简单，可以实现。但它也是一个特别清晰的例子，展示了编程语言如何受到它们运行的系统和使用者的影响。C的一些特性会根据你目标的硬件而有所不同；其他特性则在操作系统之间有所差异；还有一些特性则没有明确规定，以便给编译器开发者更多的灵活性。语言中的一些部分是历史遗留物，保留至今是为了支持旧代码，而另一些则是较新的尝试，旨在让C语言变得更安全、更可靠。
- en: These messy parts of C are worth tackling for a couple of reasons. First, you’ll
    develop a solid mental model of how your compiler fits in with all the other pieces
    of your system. Second, you’ll get a sense of the different perspectives that
    different groups of people bring to the language, from the specification authors
    trying to stamp out ambiguity and inconsistency, to compiler implementers looking
    for performance improvements, to ordinary programmers who just want their code
    to work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的这些复杂部分值得解决，原因有几个。首先，你将发展出一个清晰的思维模型，理解你的编译器如何与系统中的其他部分协同工作。其次，你会感受到不同群体对语言的不同看法，从试图消除歧义和不一致的规范作者，到寻求性能改进的编译器实现者，再到只想让代码正常工作的普通程序员。
- en: 'I hope this project will make you think about *all* programming languages differently:
    not as fixed sets of rules enshrined in language standards, but as ongoing negotiations
    between the people who design, implement, and use them. Once you start looking
    at programming languages this way, they become richer, more interesting, and less
    frustrating to work with.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这个项目能让你以不同的方式看待*所有*编程语言：不仅仅是语言标准中规定的固定规则集，而是设计、实现和使用这些语言的人们之间持续的协商。一旦你开始以这种方式看待编程语言，它们就会变得更加丰富、有趣，并且不那么令人沮丧。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compilation from 10,000 Feet</samp>
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">从10,000英尺高度看编译过程</samp>
- en: Before we go any further, let’s take a high-level look at how source code turns
    into an executable and where the compiler fits into the process. We’ll clear up
    some terminology and review a tiny bit of computer architecture while we’re at
    it. A *compiler* is a program that translates code from one programming language
    to another. It’s just one part (though often the most complex part) of the whole
    system that’s responsible for getting your code up and running. We’re going to
    build a compiler that translates C programs into *assembly code*, a textual representation
    of the instructions we want the processor to run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们从高层次上了解一下源代码是如何转变为可执行文件的，以及编译器在这个过程中的位置。我们会清理一些术语，并在此过程中稍微回顾一下计算机架构。*编译器*是一个将代码从一种编程语言转换为另一种编程语言的程序。它只是整个系统的一部分（尽管通常是最复杂的部分），该系统负责让你的代码能够运行。我们将构建一个编译器，将C程序转换为*汇编代码*，这是我们希望处理器执行的指令的文本表示。
- en: Different processors understand different instructions; we’ll focus on the x64
    instruction set, also called x86-64 or AMD64\. This is what most people’s computers
    run. (The other instruction set you’re likely to encounter is ARM. Most smartphones
    and tablets have ARM processors, and they’re starting to show up in laptops too.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的处理器理解不同的指令；我们将专注于x64指令集，也叫做x86-64或AMD64\。这是大多数人计算机运行的指令集。（你可能遇到的另一种指令集是ARM。大多数智能手机和平板电脑使用ARM处理器，ARM处理器也开始出现在笔记本电脑中。）
- en: The processor doesn’t understand text, so it can’t run our assembly code as
    is. We need to convert it into *object code*, or binary instructions that the
    processor can decode and execute. For example, the assembly instruction <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> corresponds to the byte <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xc3</samp>. The *assembler* handles this
    conversion, taking in assembly programs and spitting out object files. Finally,
    the *linker* combines all the object files we need to include in our final program,
    resolves any references to variables or functions from other files, and adds some
    information about how to actually start up the program. The end result is an executable
    that we can run. This is a wildly oversimplified view of what happens, but it’s
    good enough to get us started.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器无法理解文本，因此它无法直接运行我们的汇编代码。我们需要将其转换为*目标代码*，即处理器能够解码并执行的二进制指令。例如，汇编指令<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>对应的字节是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xc3</samp>。*汇编器*处理这个转换，接收汇编程序并输出目标文件。最后，*链接器*将我们需要包含在最终程序中的所有目标文件合并，解决来自其他文件的变量或函数的引用，并添加一些关于如何启动程序的信息。最终的结果是一个可执行文件，我们可以运行它。这是一个极度简化的视图，但足够让我们入门。
- en: 'Aside from the compiler, assembler, and linker, compiling a C program requires
    yet another tool: the *preprocessor*, which runs right before the compiler. The
    preprocessor strips out comments, executes preprocessor directives like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>, and expands macros to
    produce preprocessed code that’s ready to be compiled. The whole process looks
    something like [Figure 1](#fig-1).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1: Transforming a source
    file into an executable [Description](description-01.xhtml)</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: When you compile a program with a command like <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">clang</samp>, you’re actually
    invoking the *compiler driver*, a small wrapper that’s responsible for calling
    the preprocessor, compiler, assembler, and linker in turn. You’ll write your own
    compiler and compiler driver, but you won’t write your own preprocessor, assembler,
    or linker. Instead, you’ll use the versions of these tools already installed on
    your system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">What You’ll Build</samp>
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Over the course of this book, you’ll build a compiler for a large subset of
    C. You can write your compiler in any programming language you like; I’ll present
    key parts of the implementation in pseudocode. The book is organized into three
    parts. In [Part I, The Basics](part1.xhtml), you’ll implement the core features
    of C: expressions, variables, control-flow statements, and function calls.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1](chapter1.xhtml): A Minimal Compiler** In this chapter, you’ll
    build a working compiler that can handle the simplest possible C programs, which
    just return integer constants. You’ll learn about the different stages of compilation,
    how to represent a C program internally as an abstract syntax tree, and how to
    read simple assembly programs.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2](chapter2.xhtml): Unary Operators** Next, you’ll start to expand
    your compiler by implementing two unary operators: negation and bitwise complement.
    This chapter introduces TACKY, a new intermediate representation that bridges
    the gap between the abstract syntax tree and assembly code. It also explains how
    to perform negation and bitwise complement in assembly, and how assembly programs
    store values in a region of memory called the stack.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3](chapter3.xhtml): Binary Operators** In this chapter, you’ll implement
    the binary operators that perform basic arithmetic, like addition and subtraction.
    You’ll use a technique called precedence climbing to parse arithmetic expressions
    with the correct associativity and precedence, and you’ll learn how to do arithmetic
    in assembly.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4](chapter4.xhtml): Logical and Relational Operators** Here, you’ll
    add support for the logical AND, OR, and NOT operators and relational operators
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>. This chapter introduces
    several new kinds of assembly instructions, including conditional instructions
    and jumps.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5](chapter5.xhtml): Local Variables** Next, you’ll extend your compiler
    to support local variable declarations, uses, and assignments. You’ll add a new
    compiler stage to perform semantic analysis in this chapter. This stage detects
    programming errors like using an undeclared variable.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6](chapter6.xhtml): if Statements and Conditional Expressions** In
    this chapter, you’ll add support for <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, your compiler’s first control-flow structure, as well as conditional
    expressions of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">a ? b :
    c</samp>. Using TACKY as an intermediate representation will pay off here; you
    can implement both language constructs with existing TACKY instructions, so you
    won’t need to touch later compiler stages.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7](chapter7.xhtml): Compound Statements** Here, you’ll add support
    for compound statements, which group together statements and declarations and
    control the scope of identifiers. You’ll take a close look at C’s scoping rules
    and learn how to apply those rules during semantic analysis.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8](chapter8.xhtml): Loops** This chapter covers <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements. You’ll
    write a new semantic analysis pass to associate <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements with
    their enclosing loops.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 9](chapter9.xhtml): Functions** In this chapter, you’ll implement
    function calls and declarations of functions other than <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    You’ll have two major tasks here: writing a type checker to detect semantic errors
    like calling functions with the wrong number of arguments, and generating assembly
    code. You’ll learn all the ins and outs of the calling conventions for Unix-like
    systems, which dictate how function calls work in assembly. By meticulously following
    these conventions, you’ll be able to compile code that calls external libraries.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10](chapter10.xhtml): File Scope Variable Declarations and Storage-Class
    Specifiers** Next, you’ll add support for file scope variable declarations and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    specifiers. This chapter discusses several properties of C identifiers, including
    linkage and storage duration. It walks through how to determine an identifier’s
    linkage and storage duration in the semantic analysis stage and covers how those
    properties impact the assembly you ultimately generate. It also introduces a new
    region of memory, the data section, and describes how to define and operate on
    values stored there.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In [Part II, Types Beyond int](part2.xhtml), you’ll implement additional types.
    This is where we’ll take the most in-depth look at the messy, confusing, and surprising
    bits of C.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 11](chapter11.xhtml): Long Integers** In this chapter, you’ll implement
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> type and lay the
    groundwork to add more types in later chapters. You’ll learn how to infer the
    type of every expression during type checking and how to operate on values of
    different sizes in assembly.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 12](chapter12.xhtml): Unsigned Integers** Here, you’ll implement
    the unsigned integer types. This chapter dives into the C standard’s rules on
    integer type conversions and covers a few new assembly instructions that perform
    unsigned integer operations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 13](chapter13.xhtml): Floating-Point Numbers** Next, you’ll add
    the floating-point <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type. This chapter describes the binary representation of floating-point numbers
    and the perils of floating-point rounding error. It introduces a new set of assembly
    instructions for performing floating-point operations and explains the calling
    conventions for passing floating-point arguments and return values.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 14](chapter14.xhtml): Pointers** In this chapter, you’ll implement
    pointer types and the address and pointer dereference operators. You’ll validate
    pointer operations in the type checker and add explicit memory access instructions
    to the TACKY intermediate representation.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 15](chapter15.xhtml): Arrays and Pointer Arithmetic** This chapter
    picks up where [Chapter 14](chapter14.xhtml) left off by adding support for array
    types and several related language features: the subscript operator, pointer arithmetic,
    and compound initializers. It digs into the relationship between arrays and pointers
    and lays out how the type checker should analyze these types.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 16](chapter16.xhtml): Characters and Strings** This chapter covers
    the character types, character constants, and string literals. You’ll learn about
    the different ways C programs use string literals, and you’ll add new TACKY and
    assembly constructs to represent string constants. At the end of the chapter,
    you’ll compile a couple of example programs that perform input/output (I/O) operations.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 17](chapter17.xhtml): Supporting Dynamic Memory Allocation** In
    this chapter, you’ll implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator,
    which will allow you to compile programs that call <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    and the other memory management functions. The biggest challenge here is handling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> in the type checker.
    Because <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> is a type with
    no values, the type checker will treat it very differently from the other types
    you’ve implemented so far.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 18](chapter18.xhtml): Structures** Structures, along with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    member access operators, are the last language features you’ll add in this book.
    To implement them, you’ll need all the skills you learned in earlier chapters.
    In the semantic analysis stage, you’ll resolve structure tags according to C’s
    scoping rules and analyze structure type declarations to determine how they’re
    laid out in memory. When you generate TACKY, you’ll translate member access operators
    into sequences of simple memory access instructions. And when you generate assembly,
    you’ll follow the calling conventions for passing structures as arguments and
    return values.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: In [Part III, Optimizations](part3.xhtml), you won’t add any new language features.
    Instead, you’ll implement several classic compiler optimizations to generate more
    efficient assembly code. [Part III](part3.xhtml) is quite different from [Parts
    I](part1.xhtml) and [II](part2.xhtml) because these optimizations aren’t specific
    to C; they work just as well for programs written in any language.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 19](chapter19.xhtml): Optimizing TACKY Programs** In this chapter,
    you’ll add an optimization stage targeting TACKY programs. This stage will include
    four different optimizations: constant folding, unreachable code elimination,
    dead store elimination, and copy propagation. These four optimizations work together,
    making each one more effective than it would be by itself. This chapter introduces
    several tools for understanding a program’s behavior, including control-flow graphs
    and data-flow analysis. You’ll use these tools to discover ways to optimize programs
    without changing their behavior.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 20](chapter20.xhtml): Register Allocation** To cap off this project,
    you’ll write a register allocator, which figures out how to store values in the
    assembly program in registers instead of memory. You’ll use graph coloring to
    find a valid mapping from values to registers. Once the initial version of your
    register allocator is working, you’ll use another technique, register coalescing,
    to make it even more effective and remove some unnecessary assembly instructions.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**Next Steps** We’ll wrap up with a few suggestions about how to keep learning
    and building out your compiler on your own.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[Parts II](part2.xhtml) and [III](part3.xhtml) both build on [Part I](part1.xhtml),
    but they’re independent of each other. You can complete either of them, both,
    or neither. The appendixes include some helpful information you can refer to along
    the way.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Appendix A: Debugging Assembly Code with GDB or LLDB** This appendix walks
    you through how to use GDB, the GNU debugger, and LLDB, the LLVM debugger, to
    debug assembly programs. When your compiler produces buggy assembly, these tools
    will help you figure out what’s going on.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Appendix B: Assembly Generation and Code Emission Tables** The tables in
    this appendix summarize how to convert each TACKY construct to assembly, and how
    to print each assembly construct during code emission. All of the chapters where
    we update these passes include similar tables showing what changed in that chapter;
    this appendix brings it all together.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a disclaimer: this book covers a lot of ground, but it doesn’t cover
    everything. There are some really important parts of C that we won’t implement:
    function pointers, variable-length argument lists, <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>,
    and type qualifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    to name just a few. Instead of cramming in as many features as possible, we’ll
    dive deep on the features we *do* implement so that you really understand how
    and why they work. That way, you’ll learn all the skills and concepts you need
    to keep building on your own.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Use This Book</samp>
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each chapter is a detailed guide to implementing a particular feature. At the
    beginning of a chapter, I’ll discuss the feature you’re about to build and any
    important concepts you’ll need to understand to get started. Then, we’ll walk
    through how to update each stage of the compiler to support this new feature.
    I’ll include pseudocode for any steps that are particularly tricky or important.
    Don’t feel like you need to follow the pseudocode exactly; it’s there to clarify
    what you want to accomplish, not to prescribe all the details of how you go about
    it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Each chapter builds on the one before it, so you’ll need to complete them in
    order, except that you can skip to [Part III](part3.xhtml) without completing
    [Part II](part2.xhtml) first.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Test Suite</samp>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every chapter includes a few checkpoints where you can stop and test your compiler
    with this book’s test suite, which is available at *[https://<wbr>github<wbr>.com<wbr>/nlsandler<wbr>/writing<wbr>-a<wbr>-c<wbr>-compiler<wbr>-tests](https://github.com/nlsandler/writing-a-c-compiler-tests)*.
    For each chapter, the test suite includes a set of invalid test programs that
    your compiler should reject with an error message and a set of valid test programs
    that it should compile successfully. Use the provided *test_compiler* script to
    run the tests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extra Credit Features</samp>
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some chapters mention additional language features that you can implement on
    your own; I call these “extra credit” features. An extra credit feature is related
    to the main feature covered in the chapter. You can implement it using techniques
    you’ve already learned, but you’ll have to figure out the details for yourself.
    You might need to look at the assembly output for a few test programs to figure
    out how to handle them. You’ll also need to consult outside references, like the
    C standard and the documentation for the x64 instruction set (you’ll find links
    to these and other resources in “Additional Resources” on [page xxxvi](#pg_xxxvi)).
    The extra credit features are totally optional; try out the ones that seem interesting
    and skip the ones that don’t.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Tests for these features are included in the test suite but aren’t run by default.
    You can run them by passing the appropriate command line options to *test_compiler*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Some Advice on Choosing an Implementation
    Language</samp>
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it’s possible to write a compiler in any programming language, some languages
    are better suited to the task than others. We’ll be creating a compiler *for*
    C, but I don’t recommend writing it *in* C. Although C has its strengths as a
    programming language, this project doesn’t play to any of them. You’re better
    off choosing a language with easier memory management and a more extensive standard
    library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also consider using a language with *pattern matching*. You can
    think of this as a kind of souped-up <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement that lets you define different cases for values that have different
    structures and include different data. (Note that this is distinct from regular
    expression matching, which also gets called “pattern matching” occasionally.)
    Our very first snippet of pseudocode shows pattern matching in action:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This turns out to be extremely useful for analyzing and transforming programs,
    which generally contain several types of expressions, statements, and so on, like
    this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The pseudocode in this book uses pattern matching all over the place, so you’ll
    have an easier time following along if you use a language that supports it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: For a long time, pattern matching was the province of functional languages like
    ML and Haskell. (It’s no coincidence that these languages are very popular in
    programming language academia.) More recently, just about everyone else has noticed
    that pattern matching is great, and it’s making its way into more mainstream languages.
    Rust and Swift both support pattern matching, Python added it in version 3.10,
    and Java has been gradually building out support for it since version 16\. Before
    you start writing a compiler in your favorite language, do a little research to
    find out what sort of support it has for pattern matching. Depending on what you
    find, you might decide to use the latest and greatest version of the language,
    use a pattern matching library (C++, for example, has several), or use your second-favorite
    language instead. Or you might decide to ignore my advice; pattern matching is
    helpful, but you can get by without it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">System Requirements</samp>
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this project, you’ll need a macOS or Linux system with an x64 processor
    (or a Mac with an Apple Silicon processor, which can emulate x64 without too much
    fuss). If you’re on a Windows machine, you’ll need to set up a Linux environment
    using Windows Subsystem for Linux (WSL). You can find setup instructions for WSL
    at *[https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/windows<wbr>/wsl<wbr>/install](https://docs.microsoft.com/en-us/windows/wsl/install)*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'This project has two dependencies. To run *test_compiler*, you’ll need Python
    3.8 or later. You may have a recent version of Python installed already; if not,
    you can download it from *[https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads](https://www.python.org/downloads)*
    or install it with your system’s package manager. (See this book’s web page at
    *[https://<wbr>norasandler<wbr>.com<wbr>/book<wbr>/#setup](https://norasandler.com/book/#setup)*
    for more detailed installation instructions.) To check that you have a suitable
    version of Python installed, run:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll also need a real C compiler (or, strictly speaking, a real C compiler
    driver) to invoke the preprocessor, assembler, and linker. The test script depends
    on the compiler driver as well. If you’re on Linux, use GCC as the compiler driver.
    If you’re on macOS, use the version of Clang included in Xcode. (The test script
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command to invoke
    the compiler driver; Xcode’s Clang gets installed under both the name <samp class="SANS_TheSansMonoCd_W5Regular_11">clang</samp>
    and the alias <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>.) It’s
    a good idea to install a debugger that can step through assembly code too, to
    help you debug the code that your compiler produces. I recommend debugging with
    GDB on Linux and LLDB on macOS.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installing GCC and
    GDB on Linux</samp>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’re running Linux, you should use GCC as the compiler driver and GDB
    as the debugger. To check whether they’re already installed, run:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If either of these commands is missing, you can install them with your system’s
    package manager. For example, to install both tools on Ubuntu, run:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installing the Command
    Line Developer Tools on macOS</samp>
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest option on macOS is to install the Xcode command line developer
    tools, which include the Clang compiler and LLDB debugger. To check whether they’re
    already installed, run:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the tools aren’t installed already, you’ll be prompted to install them when
    you try to run this command.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this book were compiled with GCC, so if you compile them with
    Clang, the resulting assembly will sometimes look a little different. These differences
    won’t impact your ability to complete the project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running on Apple
    Silicon</samp>
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your computer has an Apple Silicon processor (Apple’s ARM chip), you’ll
    need to use Rosetta 2 to run the programs you compile. The easiest solution is
    to run everything—including your compiler and the test script—as x64 binaries
    under Rosetta 2\. To open an x64 shell, run:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can run your compiler, Clang, the compiled programs, and *test_compiler*
    in this shell, and everything should work fine. Just make sure to build your compiler
    itself to run on x64 and not ARM.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'If the <samp class="SANS_TheSansMonoCd_W5Regular_11">arch</samp> command doesn’t
    work, Rosetta 2 may not be installed yet. To install it, run:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Your Setup</samp>
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The test script includes a <samp class="SANS_TheSansMonoCd_W5Regular_11">--check-setup</samp>
    option that you can use to make sure your system is set up correctly. Run these
    commands to download the test suite and validate your setup:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the test script doesn’t report any issues, you’re ready to get started!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: You can find errata, updates, links, and other resources on this book’s web
    page at *[https://<wbr>norasandler<wbr>.com<wbr>/book<wbr>/](https://norasandler.com/book/)*.
    If you run into any problems with the project or the test script, check this page
    first. New versions of GCC, the Xcode command line tools, and the other tools
    this project depends on are released periodically; the book’s web page includes
    any updates to the project that are needed to work with the latest versions of
    these tools.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get stuck and want to see a complete, working implementation of the
    project, refer to this book’s reference implementation: NQCC2, the not-quite-C
    compiler, available at *[https://<wbr>github<wbr>.com<wbr>/nlsandler<wbr>/nqcc2](https://github.com/nlsandler/nqcc2)*.
    It’s written in OCaml, but it has lots of comments to help you understand it if
    you’re not an OCaml programmer.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here are a few external resources that you might find helpful. These
    will be especially useful if you decide to implement any of the extra credit features
    or otherwise build out your compiler beyond what’s covered in this book:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The **C standard** specifies how C programs are supposed to behave. We’ll use
    C17 (ISO/IEC 9899:2018), which was the latest version of the standard at the time
    this book was being written. You can buy a copy from the International Standards
    Institute (ISO) at *[https://<wbr>www<wbr>.iso<wbr>.org<wbr>/standard<wbr>/74528<wbr>.html](https://www.iso.org/standard/74528.html)*.
    Alternatively, if the idea of paying $200 for a PDF doesn’t appeal to you, you
    can use a similar draft version of the standard, which is freely available at
    *[https://<wbr>www<wbr>.open<wbr>-std<wbr>.org<wbr>/JTC1<wbr>/SC22<wbr>/WG14<wbr>/www<wbr>/docs<wbr>/n2310<wbr>.pdf](https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2310.pdf)*.
    This is an early draft of C23—the next version of the standard after C17—with
    diff marks indicating what’s changed. It’s not the official ISO standard, so I
    wouldn’t recommend using it to build a production C compiler, but it’s close enough
    for this project.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **System V Application Binary Interface (ABI)** defines a set of conventions
    that executables follow on Unix-like operating systems. This will be important
    starting in [Chapter 9](chapter9.xhtml), when we implement function calls. You
    can find the latest version of the System V ABI for x64 systems at *[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Intel 64 Software Developer’s Manual** (*[https://<wbr>www<wbr>.intel<wbr>.com<wbr>/content<wbr>/www<wbr>/us<wbr>/en<wbr>/developer<wbr>/articles<wbr>/technical<wbr>/intel<wbr>-sdm<wbr>.html](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)*)
    is Intel’s official documentation for the x64 instruction set. We care about Volume
    2, the instruction set reference. There’s also an unofficial version at *[https://<wbr>www<wbr>.felixcloutier<wbr>.com<wbr>/x86<wbr>/](https://www.felixcloutier.com/x86/)*,
    which is easier to browse.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compiler Explorer** (*[https://<wbr>godbolt<wbr>.org](https://godbolt.org)*)
    is an extremely nifty website where you can see how a variety of widely used compilers
    translate your code to assembly. It makes it easy to compare the output of different
    compilers and see the impact of various optimization levels and compiler flags.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*C23 is set to be published in 2024, superseding C17\. For our purposes, the
    differences between C17 and C23 aren’t significant. We won’t implement the new
    language features introduced in C23, but we aren’t implementing all of C17, either.
    The subset of C we* do *implement looks pretty much the same in both versions
    of the standard. If you’re curious about what’s different in C23, you can find
    a free, nearly final draft at* [https://<wbr>open<wbr>-std<wbr>.org<wbr>/JTC1<wbr>/SC22<wbr>/WG14<wbr>/www<wbr>/docs<wbr>/n3096<wbr>.pdf](https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf)
    *and an informal list of changes at* [https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/23](https://en.cppreference.com/w/c/23)*.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Let’s Go!</samp>
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve covered all the preliminaries and we’re ready to get started. In [Chapter
    1](chapter1.xhtml), we’ll compile our first C program.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
