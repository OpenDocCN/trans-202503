- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_11">导言</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'When we talk about how programming languages work, we tend to borrow metaphors
    from fantasy novels: compilers are magic, and the people who work on them are
    wizards. Dragons may be involved somehow. But in the day-to-day lives of most
    programmers, compilers behave less like magical artifacts and more like those
    universal translator earpieces from science fiction. They aren’t flashy or dramatic;
    they don’t demand a lot of attention. They just hum along in the background, translating
    a language you speak (or type) fluently into the alien language of machines.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论编程语言如何工作时，我们往往借用来自幻想小说的比喻：编译器是魔法，而从事编译器工作的人是巫师。龙可能以某种方式参与其中。但在大多数程序员的日常生活中，编译器的表现更像是科幻小说中的通用翻译耳机，而不是魔法物品。它们既不炫目也不戏剧化，不会吸引太多注意力。它们只是悄无声息地在后台运行，将你流利地使用（或输入）的语言翻译成机器的外语。
- en: For some reason, sci-fi characters rarely seem to wonder how their translators
    work. But once you’ve been coding for a while, it’s hard not to feel curious about
    what your compiler is doing. A few years ago, this curiosity got the better of
    me, so I decided to learn more about compilers by writing one of my own. It was
    important to me to write a compiler for a real programming language, one that
    I’d used myself. And I wanted my compiler to generate assembly code that I could
    run without an emulator or virtual machine. But when I looked around, I found
    that most guides to compiler construction used toy languages that ran on idealized
    processors. Some of these guides were excellent, but they weren’t quite what I
    was looking for.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 出于某种原因，科幻小说中的角色似乎很少去想他们的翻译器是如何工作的。但一旦你开始编写代码，就很难不对你的编译器在做什么产生好奇。几年前，这种好奇心占据了我，于是我决定通过编写自己的编译器来深入了解编译器的工作原理。对我来说，编写一个真实编程语言的编译器很重要，这是我自己使用过的语言。而且我希望我的编译器生成的汇编代码可以在没有仿真器或虚拟机的情况下运行。但当我四处查找时，我发现大多数编译器构建指南都使用运行在理想化处理器上的玩具语言。这些指南有些非常优秀，但它们并不是我真正需要的。
- en: 'I finally got unstuck when a friend pointed me toward a short paper titled
    “An Incremental Approach to Compiler Construction” by Abdulaziz Ghuloum (*[http://<wbr>scheme2006<wbr>.cs<wbr>.uchicago<wbr>.edu<wbr>/11<wbr>-ghuloum<wbr>.pdf](http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf)*).
    It explained how to compile Scheme to x86 assembly, starting with the simplest
    possible programs and adding one new language construct at a time. I didn’t particularly
    want to write a compiler for Scheme, so I adapted the paper to a language I was
    more interested in: C. As I kept working on the project, I switched from x86 to
    its modern counterpart, x64 assembly. I also built out support for a larger subset
    of C and added a few optimization passes. By this point, I had gone way beyond
    Ghuloum’s original scheme (pun intended, sorry), but his basic strategy held up
    remarkably well: focusing on one small piece of the language at a time made it
    easy to stay on track and see that I was making progress. In this book, you’ll
    tackle the same project. Along the way, you’ll gain a deeper understanding of
    the code you write and the system it runs on.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当一位朋友把我引导到阿卜杜拉齐兹·古鲁姆（Abdulaziz Ghuloum）的一篇短文《编译器构建的增量方法》（* [http://<wbr>scheme2006<wbr>.cs<wbr>.uchicago<wbr>.edu<wbr>/11<wbr>-ghuloum<wbr>.pdf](http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf)
    *）时，我终于解开了困境。文中解释了如何将 Scheme 编译为 x86 汇编，从最简单的程序开始，一次添加一个新的语言结构。我并不特别想为 Scheme
    编写一个编译器，所以我将这篇论文改编为我更感兴趣的语言：C。随着我在这个项目上的不断推进，我从 x86 切换到了现代版本的 x64 汇编。我还扩展了对 C
    的更大子集的支持，并添加了一些优化过程。到这时，我已经远远超出了古鲁姆原始的计划（抱歉，双关一下），但他的基本策略仍然非常有效：一次专注于语言的一个小部分，这使得我能够保持进展，看到自己在不断前进。在这本书中，你将进行同样的项目。在这个过程中，你将深入理解你编写的代码以及它运行的系统。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Who This Book Is For</samp>
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">本书适合谁阅读</samp>
- en: I wrote this book for programmers who are curious about how compilers work.
    Many books about compiler construction are written as textbooks for college or
    graduate-level classes, but this one is meant to be accessible to someone exploring
    the topic on their own. You won’t need any prior knowledge of compilers, interpreters,
    or assembly code to complete this project. A basic understanding of computer architecture
    is helpful, but not essential; I’ll discuss important concepts as they come up
    and occasionally point you to outside resources with more background information.
    That said, this is not a book for novice programmers. You should be comfortable
    writing substantive programs on your own, and you should be familiar with binary
    numbers, regular expressions, and basic data structures like graphs and trees.
    You’ll need to know C well enough to read and understand small C programs, but
    you don’t need to be an expert C programmer. We’ll explore the ins and outs of
    the language as we go.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这本书是为了那些对编译器如何工作感到好奇的程序员。许多关于编译器构建的书籍是为大学或研究生水平的课程编写的，但这本书的目的是让那些自己探索这一主题的人也能轻松理解。你不需要具备编译器、解释器或汇编语言的任何先验知识就能完成这个项目。对计算机架构的基本理解是有帮助的，但并非必需；我会在涉及到相关概念时进行讨论，并偶尔推荐一些外部资源以供你了解更多背景信息。话虽如此，这本书并不是为初学编程的人准备的。你应该能够独立编写有实质内容的程序，并且对二进制数字、正则表达式以及图形和树等基本数据结构有所了解。你需要对C语言有足够的了解，能读懂并理解小型C程序，但不需要是C语言专家。在本书中，我们会随着进度一起深入探索语言的方方面面。
- en: Although this book is geared toward newcomers to the subject, it will also be
    worthwhile for people who have some experience with compilers already. Maybe you
    implemented a toy language for a college class or personal project, and now you’d
    like to work on something more realistic. Or maybe you’ve worked on interpreters
    in the past, and you want to try your hand at compiling programs down to machine
    code. If you’re in this category, this book will cover some material you already
    know, but it will provide plenty of new challenges too. At the very least, I promise
    you’ll learn a few things about C.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书是针对编程新手编写的，但对于已经有一些编译器经验的人来说同样是值得一读的。也许你曾为大学课程或个人项目实现了一个简单的语言，现在你希望做一些更实际的工作。或者，可能你曾经做过解释器相关的工作，想尝试将程序编译成机器代码。如果你属于这一类人，这本书会涉及一些你已经了解的内容，但也会提供许多新的挑战。至少，我保证你会学到一些关于C语言的知识。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why Write a C Compiler?</samp>
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么要编写C语言编译器？</samp>
- en: I assume you’re already sold on the idea of writing a compiler—you did pick
    up this book, after all. I want to talk a little bit about why we’re writing a
    compiler for C in particular. The short answer is that C is a (relatively) simple
    language, but not a toy language. At its core, C is simple enough to implement
    even if you’ve never written a compiler before. But it’s also a particularly clear
    example of how programming languages are shaped by the systems they run on and
    the people who use them. Some aspects of C vary based on what hardware you’re
    targeting; others vary between operating systems; still others are left unspecified
    to give compiler writers more flexibility. Some bits of the language are historical
    artifacts that have stuck around to support legacy code, while others are more
    recent attempts to make C safer and more reliable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经对编写编译器的想法有所了解——毕竟你已经拿起了这本书。我想稍微谈一下为什么我们特别要为C语言编写一个编译器。简短的回答是，C是一种（相对）简单的语言，但并不是玩具语言。从本质上讲，即使你从未编写过编译器，C语言也足够简单，可以实现。但它也是一个特别清晰的例子，展示了编程语言如何受到它们运行的系统和使用者的影响。C的一些特性会根据你目标的硬件而有所不同；其他特性则在操作系统之间有所差异；还有一些特性则没有明确规定，以便给编译器开发者更多的灵活性。语言中的一些部分是历史遗留物，保留至今是为了支持旧代码，而另一些则是较新的尝试，旨在让C语言变得更安全、更可靠。
- en: These messy parts of C are worth tackling for a couple of reasons. First, you’ll
    develop a solid mental model of how your compiler fits in with all the other pieces
    of your system. Second, you’ll get a sense of the different perspectives that
    different groups of people bring to the language, from the specification authors
    trying to stamp out ambiguity and inconsistency, to compiler implementers looking
    for performance improvements, to ordinary programmers who just want their code
    to work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的这些复杂部分值得解决，原因有几个。首先，你将发展出一个清晰的思维模型，理解你的编译器如何与系统中的其他部分协同工作。其次，你会感受到不同群体对语言的不同看法，从试图消除歧义和不一致的规范作者，到寻求性能改进的编译器实现者，再到只想让代码正常工作的普通程序员。
- en: 'I hope this project will make you think about *all* programming languages differently:
    not as fixed sets of rules enshrined in language standards, but as ongoing negotiations
    between the people who design, implement, and use them. Once you start looking
    at programming languages this way, they become richer, more interesting, and less
    frustrating to work with.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这个项目能让你以不同的方式看待*所有*编程语言：不仅仅是语言标准中规定的固定规则集，而是设计、实现和使用这些语言的人们之间持续的协商。一旦你开始以这种方式看待编程语言，它们就会变得更加丰富、有趣，并且不那么令人沮丧。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compilation from 10,000 Feet</samp>
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">从10,000英尺高度看编译过程</samp>
- en: Before we go any further, let’s take a high-level look at how source code turns
    into an executable and where the compiler fits into the process. We’ll clear up
    some terminology and review a tiny bit of computer architecture while we’re at
    it. A *compiler* is a program that translates code from one programming language
    to another. It’s just one part (though often the most complex part) of the whole
    system that’s responsible for getting your code up and running. We’re going to
    build a compiler that translates C programs into *assembly code*, a textual representation
    of the instructions we want the processor to run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们从高层次上了解一下源代码是如何转变为可执行文件的，以及编译器在这个过程中的位置。我们会清理一些术语，并在此过程中稍微回顾一下计算机架构。*编译器*是一个将代码从一种编程语言转换为另一种编程语言的程序。它只是整个系统的一部分（尽管通常是最复杂的部分），该系统负责让你的代码能够运行。我们将构建一个编译器，将C程序转换为*汇编代码*，这是我们希望处理器执行的指令的文本表示。
- en: Different processors understand different instructions; we’ll focus on the x64
    instruction set, also called x86-64 or AMD64\. This is what most people’s computers
    run. (The other instruction set you’re likely to encounter is ARM. Most smartphones
    and tablets have ARM processors, and they’re starting to show up in laptops too.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的处理器理解不同的指令；我们将专注于x64指令集，也叫做x86-64或AMD64\。这是大多数人计算机运行的指令集。（你可能遇到的另一种指令集是ARM。大多数智能手机和平板电脑使用ARM处理器，ARM处理器也开始出现在笔记本电脑中。）
- en: The processor doesn’t understand text, so it can’t run our assembly code as
    is. We need to convert it into *object code*, or binary instructions that the
    processor can decode and execute. For example, the assembly instruction <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> corresponds to the byte <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xc3</samp>. The *assembler* handles this
    conversion, taking in assembly programs and spitting out object files. Finally,
    the *linker* combines all the object files we need to include in our final program,
    resolves any references to variables or functions from other files, and adds some
    information about how to actually start up the program. The end result is an executable
    that we can run. This is a wildly oversimplified view of what happens, but it’s
    good enough to get us started.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器无法理解文本，因此它无法直接运行我们的汇编代码。我们需要将其转换为*目标代码*，即处理器能够解码并执行的二进制指令。例如，汇编指令<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>对应的字节是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xc3</samp>。*汇编器*处理这个转换，接收汇编程序并输出目标文件。最后，*链接器*将我们需要包含在最终程序中的所有目标文件合并，解决来自其他文件的变量或函数的引用，并添加一些关于如何启动程序的信息。最终的结果是一个可执行文件，我们可以运行它。这是一个极度简化的视图，但足够让我们入门。
- en: 'Aside from the compiler, assembler, and linker, compiling a C program requires
    yet another tool: the *preprocessor*, which runs right before the compiler. The
    preprocessor strips out comments, executes preprocessor directives like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>, and expands macros to
    produce preprocessed code that’s ready to be compiled. The whole process looks
    something like [Figure 1](#fig-1).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译器、汇编器和链接器，编译C程序还需要另一个工具：*预处理器*，它在编译器之前运行。预处理器会剥离注释，执行预处理指令，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>，并扩展宏，以生成已经准备好进行编译的预处理代码。整个过程大致如下图所示
    [图1](#fig-1)。
- en: '![](../images/fig1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1: Transforming a source
    file into an executable [Description](description-01.xhtml)</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1：将源文件转化为可执行文件 [描述](description-01.xhtml)</samp>
- en: When you compile a program with a command like <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">clang</samp>, you’re actually
    invoking the *compiler driver*, a small wrapper that’s responsible for calling
    the preprocessor, compiler, assembler, and linker in turn. You’ll write your own
    compiler and compiler driver, but you won’t write your own preprocessor, assembler,
    or linker. Instead, you’ll use the versions of these tools already installed on
    your system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用像 <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">clang</samp>
    这样的命令编译程序时，您实际上是在调用 *编译器驱动程序*，它是一个小的包装器，负责依次调用预处理器、编译器、汇编器和链接器。您将编写自己的编译器和编译器驱动程序，但不会编写自己的预处理器、汇编器或链接器。相反，您将使用系统中已经安装的这些工具的版本。
- en: <samp class="SANS_Futura_Std_Bold_B_11">What You’ll Build</samp>
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">您将构建的内容</samp>
- en: 'Over the course of this book, you’ll build a compiler for a large subset of
    C. You can write your compiler in any programming language you like; I’ll present
    key parts of the implementation in pseudocode. The book is organized into three
    parts. In [Part I, The Basics](part1.xhtml), you’ll implement the core features
    of C: expressions, variables, control-flow statements, and function calls.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，您将构建一个支持C语言大部分子集的编译器。您可以使用任何编程语言编写自己的编译器；我将以伪代码呈现实现的关键部分。本书分为三个部分。在[第一部分，基础知识](part1.xhtml)中，您将实现C语言的核心特性：表达式、变量、控制流语句和函数调用。
- en: '**[Chapter 1](chapter1.xhtml): A Minimal Compiler** In this chapter, you’ll
    build a working compiler that can handle the simplest possible C programs, which
    just return integer constants. You’ll learn about the different stages of compilation,
    how to represent a C program internally as an abstract syntax tree, and how to
    read simple assembly programs.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第1章](chapter1.xhtml)：一个最简编译器** 在本章中，您将构建一个能够处理最简单C程序的编译器，这些程序仅返回整数常量。您将了解编译的不同阶段，如何将C程序在内部表示为抽象语法树，以及如何读取简单的汇编程序。'
- en: '**[Chapter 2](chapter2.xhtml): Unary Operators** Next, you’ll start to expand
    your compiler by implementing two unary operators: negation and bitwise complement.
    This chapter introduces TACKY, a new intermediate representation that bridges
    the gap between the abstract syntax tree and assembly code. It also explains how
    to perform negation and bitwise complement in assembly, and how assembly programs
    store values in a region of memory called the stack.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第2章](chapter2.xhtml)：一元运算符** 接下来，您将通过实现两个一元运算符来扩展您的编译器：取反和按位取反。本章介绍了TACKY，一种新的中间表示，它桥接了抽象语法树和汇编代码之间的差距。它还解释了如何在汇编中执行取反和按位取反，以及汇编程序如何在名为栈的内存区域中存储值。'
- en: '**[Chapter 3](chapter3.xhtml): Binary Operators** In this chapter, you’ll implement
    the binary operators that perform basic arithmetic, like addition and subtraction.
    You’ll use a technique called precedence climbing to parse arithmetic expressions
    with the correct associativity and precedence, and you’ll learn how to do arithmetic
    in assembly.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第3章](chapter3.xhtml)：二元运算符** 在本章中，您将实现执行基本算术运算的二元运算符，如加法和减法。您将使用一种名为优先级提升（precedence
    climbing）的技术来解析算术表达式，确保正确的结合性和优先级，并学习如何在汇编中进行算术运算。'
- en: '**[Chapter 4](chapter4.xhtml): Logical and Relational Operators** Here, you’ll
    add support for the logical AND, OR, and NOT operators and relational operators
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>. This chapter introduces
    several new kinds of assembly instructions, including conditional instructions
    and jumps.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第四章](chapter4.xhtml)：逻辑和关系运算符** 在这一章中，您将为逻辑与（AND）、逻辑或（OR）、逻辑非（NOT）运算符以及诸如`>`、`==`和`!=`等关系运算符添加支持。本章介绍了几种新的汇编指令，包括条件指令和跳转指令。'
- en: '**[Chapter 5](chapter5.xhtml): Local Variables** Next, you’ll extend your compiler
    to support local variable declarations, uses, and assignments. You’ll add a new
    compiler stage to perform semantic analysis in this chapter. This stage detects
    programming errors like using an undeclared variable.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第五章](chapter5.xhtml)：局部变量** 接下来，您将扩展编译器，以支持局部变量的声明、使用和赋值。在本章中，您将添加一个新的编译阶段来执行语义分析。这个阶段能够检测编程错误，比如使用未声明的变量。'
- en: '**[Chapter 6](chapter6.xhtml): if Statements and Conditional Expressions** In
    this chapter, you’ll add support for <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, your compiler’s first control-flow structure, as well as conditional
    expressions of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">a ? b :
    c</samp>. Using TACKY as an intermediate representation will pay off here; you
    can implement both language constructs with existing TACKY instructions, so you
    won’t need to touch later compiler stages.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第六章](chapter6.xhtml)：if 语句和条件表达式** 在本章中，您将为编译器添加对`if`语句的支持，这是编译器的第一个控制流结构，同时还将支持形式为`a
    ? b : c`的条件表达式。使用TACKY作为中间表示将在这里大有裨益；您可以通过现有的TACKY指令实现这两种语言结构，因此无需修改后续的编译阶段。'
- en: '**[Chapter 7](chapter7.xhtml): Compound Statements** Here, you’ll add support
    for compound statements, which group together statements and declarations and
    control the scope of identifiers. You’ll take a close look at C’s scoping rules
    and learn how to apply those rules during semantic analysis.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第七章](chapter7.xhtml)：复合语句** 在这一章中，您将添加对复合语句的支持，复合语句将语句和声明组合在一起，并控制标识符的作用域。您将详细研究C语言的作用域规则，并学习如何在语义分析阶段应用这些规则。'
- en: '**[Chapter 8](chapter8.xhtml): Loops** This chapter covers <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements. You’ll
    write a new semantic analysis pass to associate <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements with
    their enclosing loops.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第八章](chapter8.xhtml)：循环** 本章涉及`while`、`do`和`for`循环，以及`break`和`continue`语句。您将编写一个新的语义分析阶段，将`break`和`continue`语句与它们所包含的循环关联起来。'
- en: '**[Chapter 9](chapter9.xhtml): Functions** In this chapter, you’ll implement
    function calls and declarations of functions other than <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    You’ll have two major tasks here: writing a type checker to detect semantic errors
    like calling functions with the wrong number of arguments, and generating assembly
    code. You’ll learn all the ins and outs of the calling conventions for Unix-like
    systems, which dictate how function calls work in assembly. By meticulously following
    these conventions, you’ll be able to compile code that calls external libraries.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第九章](chapter9.xhtml)：函数** 在本章中，您将实现对`main`之外的函数调用和函数声明的支持。您在这里有两个主要任务：编写类型检查器来检测语义错误，例如调用函数时传递错误数量的参数，以及生成汇编代码。您将深入学习Unix类系统的调用约定，这些约定决定了汇编中的函数调用方式。通过严格遵守这些约定，您将能够编译调用外部库的代码。'
- en: '**[Chapter 10](chapter10.xhtml): File Scope Variable Declarations and Storage-Class
    Specifiers** Next, you’ll add support for file scope variable declarations and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    specifiers. This chapter discusses several properties of C identifiers, including
    linkage and storage duration. It walks through how to determine an identifier’s
    linkage and storage duration in the semantic analysis stage and covers how those
    properties impact the assembly you ultimately generate. It also introduces a new
    region of memory, the data section, and describes how to define and operate on
    values stored there.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第10章](chapter10.xhtml)：文件作用域变量声明与存储类说明符** 接下来，你将增加对文件作用域变量声明以及<samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static</samp>说明符的支持。本章讨论了C语言标识符的几个特性，包括链接性和存储持续时间。它会讲解如何在语义分析阶段确定标识符的链接性和存储持续时间，以及这些特性如何影响你最终生成的汇编代码。它还介绍了内存的新区域——数据段，并描述了如何定义和操作存储在其中的值。'
- en: In [Part II, Types Beyond int](part2.xhtml), you’ll implement additional types.
    This is where we’ll take the most in-depth look at the messy, confusing, and surprising
    bits of C.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第II部分，超越 int 的类型](part2.xhtml)中，你将实现更多的类型。本部分将深入探讨C语言中的一些混乱、令人困惑和出乎意料的细节。
- en: '**[Chapter 11](chapter11.xhtml): Long Integers** In this chapter, you’ll implement
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> type and lay the
    groundwork to add more types in later chapters. You’ll learn how to infer the
    type of every expression during type checking and how to operate on values of
    different sizes in assembly.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第11章](chapter11.xhtml)：长整型** 在本章中，你将实现<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>类型，并为后续章节添加更多类型奠定基础。你将学习如何在类型检查时推断每个表达式的类型，并学习如何在汇编中操作不同大小的值。'
- en: '**[Chapter 12](chapter12.xhtml): Unsigned Integers** Here, you’ll implement
    the unsigned integer types. This chapter dives into the C standard’s rules on
    integer type conversions and covers a few new assembly instructions that perform
    unsigned integer operations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第12章](chapter12.xhtml)：无符号整数** 在这一章中，你将实现无符号整数类型。此章节详细讲解C语言标准中的整数类型转换规则，并介绍一些新的汇编指令，用于执行无符号整数操作。'
- en: '**[Chapter 13](chapter13.xhtml): Floating-Point Numbers** Next, you’ll add
    the floating-point <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type. This chapter describes the binary representation of floating-point numbers
    and the perils of floating-point rounding error. It introduces a new set of assembly
    instructions for performing floating-point operations and explains the calling
    conventions for passing floating-point arguments and return values.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第13章](chapter13.xhtml)：浮点数** 接下来，你将实现浮点数类型<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。本章描述了浮点数的二进制表示及浮点舍入误差的风险。它介绍了一组新的汇编指令，用于执行浮点运算，并解释了传递浮点参数和返回值的调用约定。'
- en: '**[Chapter 14](chapter14.xhtml): Pointers** In this chapter, you’ll implement
    pointer types and the address and pointer dereference operators. You’ll validate
    pointer operations in the type checker and add explicit memory access instructions
    to the TACKY intermediate representation.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第14章](chapter14.xhtml)：指针** 在本章中，你将实现指针类型以及地址和指针解引用操作符。你还将在类型检查器中验证指针操作，并为TACKY中间表示添加显式内存访问指令。'
- en: '**[Chapter 15](chapter15.xhtml): Arrays and Pointer Arithmetic** This chapter
    picks up where [Chapter 14](chapter14.xhtml) left off by adding support for array
    types and several related language features: the subscript operator, pointer arithmetic,
    and compound initializers. It digs into the relationship between arrays and pointers
    and lays out how the type checker should analyze these types.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第15章](chapter15.xhtml)：数组与指针运算** 本章接续[第14章](chapter14.xhtml)的内容，增加对数组类型及相关语言特性支持：下标操作符、指针运算和复合初始化器。它深入探讨了数组和指针之间的关系，并阐明类型检查器应如何分析这些类型。'
- en: '**[Chapter 16](chapter16.xhtml): Characters and Strings** This chapter covers
    the character types, character constants, and string literals. You’ll learn about
    the different ways C programs use string literals, and you’ll add new TACKY and
    assembly constructs to represent string constants. At the end of the chapter,
    you’ll compile a couple of example programs that perform input/output (I/O) operations.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第16章](chapter16.xhtml): 字符和字符串** 本章涵盖了字符类型、字符常量和字符串字面量。你将了解C语言程序使用字符串字面量的不同方式，并且你将添加新的TACKY和汇编构造来表示字符串常量。在本章的最后，你将编译几个执行输入/输出（I/O）操作的示例程序。'
- en: '**[Chapter 17](chapter17.xhtml): Supporting Dynamic Memory Allocation** In
    this chapter, you’ll implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator,
    which will allow you to compile programs that call <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    and the other memory management functions. The biggest challenge here is handling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> in the type checker.
    Because <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> is a type with
    no values, the type checker will treat it very differently from the other types
    you’ve implemented so far.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第17章](chapter17.xhtml): 支持动态内存分配** 在本章中，你将实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    类型和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 操作符，这将使你能够编译调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 和其他内存管理函数的程序。这里最大的挑战是处理类型检查器中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    是一种没有值的类型，类型检查器会与之前实现的其他类型有很大不同的处理方式。'
- en: '**[Chapter 18](chapter18.xhtml): Structures** Structures, along with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    member access operators, are the last language features you’ll add in this book.
    To implement them, you’ll need all the skills you learned in earlier chapters.
    In the semantic analysis stage, you’ll resolve structure tags according to C’s
    scoping rules and analyze structure type declarations to determine how they’re
    laid out in memory. When you generate TACKY, you’ll translate member access operators
    into sequences of simple memory access instructions. And when you generate assembly,
    you’ll follow the calling conventions for passing structures as arguments and
    return values.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第18章](chapter18.xhtml): 结构体** 结构体，以及成员访问操作符 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>，是本书中你将添加的最后一组语言特性。为了实现它们，你需要在前面章节中学到的所有技能。在语义分析阶段，你将根据C语言的作用域规则解析结构体标签，并分析结构体类型声明，确定它们在内存中的布局。当你生成TACKY时，你将把成员访问操作符转化为一系列简单的内存访问指令。而在生成汇编代码时，你将遵循传递结构体作为参数和返回值的调用约定。'
- en: In [Part III, Optimizations](part3.xhtml), you won’t add any new language features.
    Instead, you’ll implement several classic compiler optimizations to generate more
    efficient assembly code. [Part III](part3.xhtml) is quite different from [Parts
    I](part1.xhtml) and [II](part2.xhtml) because these optimizations aren’t specific
    to C; they work just as well for programs written in any language.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三部分，优化](part3.xhtml)中，你不会添加任何新的语言特性。相反，你将实现几个经典的编译器优化，以生成更高效的汇编代码。[第三部分](part3.xhtml)与[第一部分](part1.xhtml)和[第二部分](part2.xhtml)有很大不同，因为这些优化并非C语言特有，它们同样适用于用任何语言编写的程序。
- en: '**[Chapter 19](chapter19.xhtml): Optimizing TACKY Programs** In this chapter,
    you’ll add an optimization stage targeting TACKY programs. This stage will include
    four different optimizations: constant folding, unreachable code elimination,
    dead store elimination, and copy propagation. These four optimizations work together,
    making each one more effective than it would be by itself. This chapter introduces
    several tools for understanding a program’s behavior, including control-flow graphs
    and data-flow analysis. You’ll use these tools to discover ways to optimize programs
    without changing their behavior.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第19章](chapter19.xhtml): 优化TACKY程序** 在本章中，你将添加一个针对TACKY程序的优化阶段。这个阶段将包括四种不同的优化：常量折叠、不可达代码消除、死存储消除和复制传播。这四种优化是协同工作的，每一项优化都会比单独使用时更有效。本章还介绍了几种工具，用于理解程序的行为，包括控制流图和数据流分析。你将使用这些工具发现优化程序的方法，而不会改变它们的行为。'
- en: '**[Chapter 20](chapter20.xhtml): Register Allocation** To cap off this project,
    you’ll write a register allocator, which figures out how to store values in the
    assembly program in registers instead of memory. You’ll use graph coloring to
    find a valid mapping from values to registers. Once the initial version of your
    register allocator is working, you’ll use another technique, register coalescing,
    to make it even more effective and remove some unnecessary assembly instructions.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第20章](chapter20.xhtml)：寄存器分配** 为了完成这个项目，你将编写一个寄存器分配器，用于确定如何在汇编程序中将值存储在寄存器中，而不是内存中。你将使用图着色技术来找到值与寄存器之间的有效映射。一旦你的寄存器分配器的初始版本工作正常，你将使用另一种技术——寄存器合并，进一步提高其效率，去除一些不必要的汇编指令。'
- en: '**Next Steps** We’ll wrap up with a few suggestions about how to keep learning
    and building out your compiler on your own.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一步** 最后，我们将总结一些关于如何继续学习并独立构建你的编译器的建议。'
- en: '[Parts II](part2.xhtml) and [III](part3.xhtml) both build on [Part I](part1.xhtml),
    but they’re independent of each other. You can complete either of them, both,
    or neither. The appendixes include some helpful information you can refer to along
    the way.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二部分](part2.xhtml)和[第三部分](part3.xhtml)都建立在[第一部分](part1.xhtml)的基础上，但它们是相互独立的。你可以完成其中任何一部分、两部分，或都不完成。附录提供了一些有用的信息，供你在过程中参考。'
- en: '**Appendix A: Debugging Assembly Code with GDB or LLDB** This appendix walks
    you through how to use GDB, the GNU debugger, and LLDB, the LLVM debugger, to
    debug assembly programs. When your compiler produces buggy assembly, these tools
    will help you figure out what’s going on.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**附录 A：使用 GDB 或 LLDB 调试汇编代码** 本附录将引导你如何使用GDB（GNU调试器）和LLDB（LLVM调试器）来调试汇编程序。当你的编译器生成有问题的汇编时，这些工具将帮助你找出问题所在。'
- en: '**Appendix B: Assembly Generation and Code Emission Tables** The tables in
    this appendix summarize how to convert each TACKY construct to assembly, and how
    to print each assembly construct during code emission. All of the chapters where
    we update these passes include similar tables showing what changed in that chapter;
    this appendix brings it all together.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**附录 B：汇编生成与代码发射表** 本附录中的表格总结了如何将每个TACKY构造转换为汇编，并且如何在代码发射过程中打印每个汇编构造。在更新这些处理阶段的所有章节中，都包括类似的表格，展示了该章节中所做的更改；本附录将这些内容整合在一起。'
- en: 'Finally, a disclaimer: this book covers a lot of ground, but it doesn’t cover
    everything. There are some really important parts of C that we won’t implement:
    function pointers, variable-length argument lists, <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>,
    and type qualifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    to name just a few. Instead of cramming in as many features as possible, we’ll
    dive deep on the features we *do* implement so that you really understand how
    and why they work. That way, you’ll learn all the skills and concepts you need
    to keep building on your own.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，免责声明：本书覆盖了很多内容，但并不涵盖所有内容。有一些C语言中非常重要的部分我们不会实现：如函数指针、可变长度参数列表、<samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>和类型限定符，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">const</samp>，仅举几例。我们并不是尽可能多地塞入功能，而是会深入探讨我们*实现的*功能，确保你真正理解它们是如何工作以及为什么这样工作。通过这种方式，你将掌握继续自主构建所需的所有技能和概念。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Use This Book</samp>
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">如何使用本书</samp>
- en: Each chapter is a detailed guide to implementing a particular feature. At the
    beginning of a chapter, I’ll discuss the feature you’re about to build and any
    important concepts you’ll need to understand to get started. Then, we’ll walk
    through how to update each stage of the compiler to support this new feature.
    I’ll include pseudocode for any steps that are particularly tricky or important.
    Don’t feel like you need to follow the pseudocode exactly; it’s there to clarify
    what you want to accomplish, not to prescribe all the details of how you go about
    it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都是实现特定功能的详细指南。在每章的开头，我会讨论你将要构建的功能以及你需要理解的任何重要概念，以便开始。接着，我们将逐步讲解如何更新编译器的各个阶段，以支持这个新功能。如果某些步骤特别复杂或重要，我会提供伪代码。你不需要严格按照伪代码操作；它的目的是帮助你明确要完成的目标，而不是规定具体的操作细节。
- en: Each chapter builds on the one before it, so you’ll need to complete them in
    order, except that you can skip to [Part III](part3.xhtml) without completing
    [Part II](part2.xhtml) first.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都在前一章的基础上构建，因此你需要按顺序完成它们，除非你跳过[第二部分](part2.xhtml)直接开始[第三部分](part3.xhtml)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Test Suite</samp>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">测试套件</samp>
- en: Every chapter includes a few checkpoints where you can stop and test your compiler
    with this book’s test suite, which is available at *[https://<wbr>github<wbr>.com<wbr>/nlsandler<wbr>/writing<wbr>-a<wbr>-c<wbr>-compiler<wbr>-tests](https://github.com/nlsandler/writing-a-c-compiler-tests)*.
    For each chapter, the test suite includes a set of invalid test programs that
    your compiler should reject with an error message and a set of valid test programs
    that it should compile successfully. Use the provided *test_compiler* script to
    run the tests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都包含几个检查点，你可以停下来并使用本书的测试套件测试你的编译器，该测试套件可以在*[https://<wbr>github<wbr>.com<wbr>/nlsandler<wbr>/writing<wbr>-a<wbr>-c<wbr>-compiler<wbr>-tests](https://github.com/nlsandler/writing-a-c-compiler-tests)*中找到。每章的测试套件包括一组无效的测试程序，你的编译器应当拒绝并显示错误信息；还包括一组有效的测试程序，编译器应能成功编译。使用提供的*test_compiler*脚本来运行这些测试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extra Credit Features</samp>
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">额外加分特性</samp>
- en: Some chapters mention additional language features that you can implement on
    your own; I call these “extra credit” features. An extra credit feature is related
    to the main feature covered in the chapter. You can implement it using techniques
    you’ve already learned, but you’ll have to figure out the details for yourself.
    You might need to look at the assembly output for a few test programs to figure
    out how to handle them. You’ll also need to consult outside references, like the
    C standard and the documentation for the x64 instruction set (you’ll find links
    to these and other resources in “Additional Resources” on [page xxxvi](#pg_xxxvi)).
    The extra credit features are totally optional; try out the ones that seem interesting
    and skip the ones that don’t.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些章节提到额外的语言特性，你可以自行实现；我称这些为“额外加分”特性。额外加分特性与章节中讲解的主要特性相关。你可以运用已经学到的技术来实现这些特性，但需要自己解决细节。你可能需要查看一些测试程序的汇编输出，以弄清楚如何处理这些特性。你还需要查阅外部参考资料，比如
    C 标准和 x64 指令集文档（你可以在[第 xxxvi 页](#pg_xxxvi)的“附加资源”中找到这些和其他资源的链接）。这些额外加分特性完全是可选的；你可以尝试那些看起来有趣的特性，跳过那些没有兴趣的特性。
- en: Tests for these features are included in the test suite but aren’t run by default.
    You can run them by passing the appropriate command line options to *test_compiler*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性的测试已包含在测试套件中，但默认情况下不会运行。你可以通过传递适当的命令行选项给*test_compiler*来运行它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Some Advice on Choosing an Implementation
    Language</samp>
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">选择实现语言的一些建议</samp>
- en: While it’s possible to write a compiler in any programming language, some languages
    are better suited to the task than others. We’ll be creating a compiler *for*
    C, but I don’t recommend writing it *in* C. Although C has its strengths as a
    programming language, this project doesn’t play to any of them. You’re better
    off choosing a language with easier memory management and a more extensive standard
    library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以用任何编程语言编写编译器，但有些语言比其他语言更适合这一任务。我们将创建一个*for* C 的编译器，但我不建议用 C 来编写它。尽管 C 作为编程语言有其优势，但这个项目并不发挥其优势。你最好选择一种具有更容易的内存管理和更丰富标准库的语言。
- en: 'You should also consider using a language with *pattern matching*. You can
    think of this as a kind of souped-up <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement that lets you define different cases for values that have different
    structures and include different data. (Note that this is distinct from regular
    expression matching, which also gets called “pattern matching” occasionally.)
    Our very first snippet of pseudocode shows pattern matching in action:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑使用支持*模式匹配*的语言。你可以将其看作是一种升级版的<samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句，允许你为具有不同结构和包含不同数据的值定义不同的情况。（注意，这与正则表达式匹配不同，正则表达式匹配有时也被称为“模式匹配”。）我们第一段伪代码演示了模式匹配的使用：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This turns out to be extremely useful for analyzing and transforming programs,
    which generally contain several types of expressions, statements, and so on, like
    this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于分析和转换程序非常有用，因为程序通常包含多种类型的表达式、语句等，例如：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The pseudocode in this book uses pattern matching all over the place, so you’ll
    have an easier time following along if you use a language that supports it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的伪代码到处都使用了模式匹配，因此如果你使用一种支持模式匹配的语言，会更容易跟上进度。
- en: For a long time, pattern matching was the province of functional languages like
    ML and Haskell. (It’s no coincidence that these languages are very popular in
    programming language academia.) More recently, just about everyone else has noticed
    that pattern matching is great, and it’s making its way into more mainstream languages.
    Rust and Swift both support pattern matching, Python added it in version 3.10,
    and Java has been gradually building out support for it since version 16\. Before
    you start writing a compiler in your favorite language, do a little research to
    find out what sort of support it has for pattern matching. Depending on what you
    find, you might decide to use the latest and greatest version of the language,
    use a pattern matching library (C++, for example, has several), or use your second-favorite
    language instead. Or you might decide to ignore my advice; pattern matching is
    helpful, but you can get by without it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，模式匹配是函数式编程语言（如 ML 和 Haskell）的专属功能。（这些语言在编程语言学术界非常流行，绝非巧合。）最近，几乎所有人都注意到模式匹配非常有用，它正在进入更多的主流语言。Rust
    和 Swift 都支持模式匹配，Python 在 3.10 版本中添加了此功能，Java 从 16 版本开始逐步构建对其的支持。在开始用你喜欢的语言编写编译器之前，做一些研究，了解该语言对模式匹配的支持情况。根据你找到的信息，你可能决定使用该语言的最新版本，使用模式匹配库（例如，C++
    有几个这样的库），或者使用你第二喜欢的语言。或者你可能决定忽略我的建议；模式匹配很有用，但没有它也能应付。
- en: <samp class="SANS_Futura_Std_Bold_B_11">System Requirements</samp>
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">系统要求</samp>
- en: To complete this project, you’ll need a macOS or Linux system with an x64 processor
    (or a Mac with an Apple Silicon processor, which can emulate x64 without too much
    fuss). If you’re on a Windows machine, you’ll need to set up a Linux environment
    using Windows Subsystem for Linux (WSL). You can find setup instructions for WSL
    at *[https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/windows<wbr>/wsl<wbr>/install](https://docs.microsoft.com/en-us/windows/wsl/install)*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个项目，你需要一台运行 macOS 或 Linux 系统的计算机，且配备 x64 处理器（或者一台配备 Apple Silicon 处理器的 Mac，该处理器可以无需太多麻烦地模拟
    x64）。如果你使用的是 Windows 计算机，你需要通过 Windows 子系统 Linux（WSL）设置一个 Linux 环境。你可以在 *[https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/windows<wbr>/wsl<wbr>/install](https://docs.microsoft.com/en-us/windows/wsl/install)*
    找到 WSL 的安装说明。
- en: 'This project has two dependencies. To run *test_compiler*, you’ll need Python
    3.8 or later. You may have a recent version of Python installed already; if not,
    you can download it from *[https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads](https://www.python.org/downloads)*
    or install it with your system’s package manager. (See this book’s web page at
    *[https://<wbr>norasandler<wbr>.com<wbr>/book<wbr>/#setup](https://norasandler.com/book/#setup)*
    for more detailed installation instructions.) To check that you have a suitable
    version of Python installed, run:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目有两个依赖项。要运行*test_compiler*，你需要 Python 3.8 或更高版本。你可能已经安装了较新版本的 Python；如果没有，可以从
    *[https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads](https://www.python.org/downloads)*
    下载，或通过系统的包管理器安装。（有关详细的安装说明，请参见本书的网页 *[https://<wbr>norasandler<wbr>.com<wbr>/book<wbr>/#setup](https://norasandler.com/book/#setup)*。）要检查是否安装了合适版本的
    Python，请运行：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll also need a real C compiler (or, strictly speaking, a real C compiler
    driver) to invoke the preprocessor, assembler, and linker. The test script depends
    on the compiler driver as well. If you’re on Linux, use GCC as the compiler driver.
    If you’re on macOS, use the version of Clang included in Xcode. (The test script
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command to invoke
    the compiler driver; Xcode’s Clang gets installed under both the name <samp class="SANS_TheSansMonoCd_W5Regular_11">clang</samp>
    and the alias <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>.) It’s
    a good idea to install a debugger that can step through assembly code too, to
    help you debug the code that your compiler produces. I recommend debugging with
    GDB on Linux and LLDB on macOS.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个真正的 C 编译器（严格来说，是一个真正的 C 编译器驱动程序）来调用预处理器、汇编器和链接器。测试脚本也依赖于编译器驱动程序。如果你使用的是
    Linux，使用 GCC 作为编译器驱动程序。如果你使用的是 macOS，使用 Xcode 中包含的 Clang 版本。（测试脚本使用<samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>命令来调用编译器驱动程序；Xcode
    的 Clang 安装时会有 <samp class="SANS_TheSansMonoCd_W5Regular_11">clang</samp> 和别名 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>。）最好安装一个可以逐步调试汇编代码的调试器，帮助你调试编译器生成的代码。我建议在
    Linux 上使用 GDB，在 macOS 上使用 LLDB 进行调试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installing GCC and
    GDB on Linux</samp>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在 Linux 上安装 GCC 和
    GDB</samp>
- en: 'If you’re running Linux, you should use GCC as the compiler driver and GDB
    as the debugger. To check whether they’re already installed, run:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Linux，应该使用 GCC 作为编译器驱动程序，使用 GDB 作为调试器。要检查它们是否已经安装，运行：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If either of these commands is missing, you can install them with your system’s
    package manager. For example, to install both tools on Ubuntu, run:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少其中任何一条命令，您可以通过系统的包管理器安装它们。例如，在 Ubuntu 上安装这两个工具，运行：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installing the Command
    Line Developer Tools on macOS</samp>
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在 macOS 上安装命令行开发工具</samp>
- en: 'The simplest option on macOS is to install the Xcode command line developer
    tools, which include the Clang compiler and LLDB debugger. To check whether they’re
    already installed, run:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上最简单的选项是安装 Xcode 命令行开发工具，这些工具包括 Clang 编译器和 LLDB 调试器。要检查它们是否已经安装，运行：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the tools aren’t installed already, you’ll be prompted to install them when
    you try to run this command.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果工具尚未安装，当您尝试运行此命令时，系统会提示您安装它们。
- en: The examples in this book were compiled with GCC, so if you compile them with
    Clang, the resulting assembly will sometimes look a little different. These differences
    won’t impact your ability to complete the project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例是用 GCC 编译的，因此如果您使用 Clang 编译，它生成的汇编代码有时会有所不同。这些差异不会影响您完成项目的能力。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running on Apple
    Silicon</samp>
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在 Apple Silicon 上运行</samp>
- en: 'If your computer has an Apple Silicon processor (Apple’s ARM chip), you’ll
    need to use Rosetta 2 to run the programs you compile. The easiest solution is
    to run everything—including your compiler and the test script—as x64 binaries
    under Rosetta 2\. To open an x64 shell, run:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机使用 Apple Silicon 处理器（苹果的 ARM 芯片），您需要使用 Rosetta 2 来运行您编译的程序。最简单的解决方案是将所有内容——包括编译器和测试脚本——作为
    x64 二进制文件在 Rosetta 2 下运行。要打开 x64 终端，运行：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can run your compiler, Clang, the compiled programs, and *test_compiler*
    in this shell, and everything should work fine. Just make sure to build your compiler
    itself to run on x64 and not ARM.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这个终端中运行您的编译器、Clang、编译后的程序以及 *test_compiler*，一切应该都能正常工作。只需确保构建您的编译器以便它能在
    x64 上运行，而不是 ARM。
- en: 'If the <samp class="SANS_TheSansMonoCd_W5Regular_11">arch</samp> command doesn’t
    work, Rosetta 2 may not be installed yet. To install it, run:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">arch</samp> 命令无法工作，可能是因为尚未安装
    Rosetta 2。要安装它，请运行：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Your Setup</samp>
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">验证您的设置</samp>
- en: 'The test script includes a <samp class="SANS_TheSansMonoCd_W5Regular_11">--check-setup</samp>
    option that you can use to make sure your system is set up correctly. Run these
    commands to download the test suite and validate your setup:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">--check-setup</samp>
    选项，您可以使用它来确保系统已正确设置。运行以下命令以下载测试套件并验证您的设置：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the test script doesn’t report any issues, you’re ready to get started!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试脚本没有报告任何问题，您就可以开始了！
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '## <samp class="SANS_Futura_Std_Bold_B_11">附加资源</samp>'
- en: You can find errata, updates, links, and other resources on this book’s web
    page at *[https://<wbr>norasandler<wbr>.com<wbr>/book<wbr>/](https://norasandler.com/book/)*.
    If you run into any problems with the project or the test script, check this page
    first. New versions of GCC, the Xcode command line tools, and the other tools
    this project depends on are released periodically; the book’s web page includes
    any updates to the project that are needed to work with the latest versions of
    these tools.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的网页上找到勘误、更新、链接以及其他资源，网址为 *[https://<wbr>norasandler<wbr>.com<wbr>/book<wbr>/](https://norasandler.com/book/)*。如果您在项目或测试脚本中遇到问题，请先查看此页面。本书的网页会包含针对
    GCC、Xcode 命令行工具和该项目所依赖的其他工具的最新版本发布的更新。
- en: 'If you get stuck and want to see a complete, working implementation of the
    project, refer to this book’s reference implementation: NQCC2, the not-quite-C
    compiler, available at *[https://<wbr>github<wbr>.com<wbr>/nlsandler<wbr>/nqcc2](https://github.com/nlsandler/nqcc2)*.
    It’s written in OCaml, but it has lots of comments to help you understand it if
    you’re not an OCaml programmer.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到困难，并且希望查看该项目的完整工作实现，请参考本书的参考实现：NQCC2，即不完全的 C 编译器，可以在 *[https://<wbr>github<wbr>.com<wbr>/nlsandler<wbr>/nqcc2](https://github.com/nlsandler/nqcc2)*
    获取。它是用 OCaml 编写的，但有很多注释可以帮助您理解，即使您不是 OCaml 程序员。
- en: 'Finally, here are a few external resources that you might find helpful. These
    will be especially useful if you decide to implement any of the extra credit features
    or otherwise build out your compiler beyond what’s covered in this book:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是一些你可能会发现有用的外部资源。如果你决定实现任何额外的加分功能，或者进一步构建你的编译器，这些资源尤其有用：
- en: The **C standard** specifies how C programs are supposed to behave. We’ll use
    C17 (ISO/IEC 9899:2018), which was the latest version of the standard at the time
    this book was being written. You can buy a copy from the International Standards
    Institute (ISO) at *[https://<wbr>www<wbr>.iso<wbr>.org<wbr>/standard<wbr>/74528<wbr>.html](https://www.iso.org/standard/74528.html)*.
    Alternatively, if the idea of paying $200 for a PDF doesn’t appeal to you, you
    can use a similar draft version of the standard, which is freely available at
    *[https://<wbr>www<wbr>.open<wbr>-std<wbr>.org<wbr>/JTC1<wbr>/SC22<wbr>/WG14<wbr>/www<wbr>/docs<wbr>/n2310<wbr>.pdf](https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2310.pdf)*.
    This is an early draft of C23—the next version of the standard after C17—with
    diff marks indicating what’s changed. It’s not the official ISO standard, so I
    wouldn’t recommend using it to build a production C compiler, but it’s close enough
    for this project.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C 标准** 规定了 C 程序应该如何表现。我们将使用 C17（ISO/IEC 9899:2018），这是本书编写时最新的标准版本。你可以从国际标准化组织（ISO）购买副本，网址是
    *[https://www.iso.org/standard/74528.html](https://www.iso.org/standard/74528.html)*。另外，如果你不喜欢为
    PDF 支付 200 美元，你可以使用标准的类似草案版本，该版本可在 *[https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2310.pdf](https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2310.pdf)*
    上免费下载。这是 C23 的早期草案——C17 之后的下一个版本，带有显示更改的差异标记。它不是官方的 ISO 标准，所以我不建议用它来构建生产级的 C 编译器，但对于这个项目来说，它已经足够接近了。'
- en: The **System V Application Binary Interface (ABI)** defines a set of conventions
    that executables follow on Unix-like operating systems. This will be important
    starting in [Chapter 9](chapter9.xhtml), when we implement function calls. You
    can find the latest version of the System V ABI for x64 systems at *[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**System V 应用程序二进制接口（ABI）** 定义了一组约定，供 Unix 类操作系统上的可执行文件遵循。这将在 [第 9 章](chapter9.xhtml)
    中变得重要，当我们实现函数调用时。你可以在 *[https://gitlab.com/x86-psABIs/x86-64-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*
    找到 x64 系统的最新版本的 System V ABI。'
- en: The **Intel 64 Software Developer’s Manual** (*[https://<wbr>www<wbr>.intel<wbr>.com<wbr>/content<wbr>/www<wbr>/us<wbr>/en<wbr>/developer<wbr>/articles<wbr>/technical<wbr>/intel<wbr>-sdm<wbr>.html](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)*)
    is Intel’s official documentation for the x64 instruction set. We care about Volume
    2, the instruction set reference. There’s also an unofficial version at *[https://<wbr>www<wbr>.felixcloutier<wbr>.com<wbr>/x86<wbr>/](https://www.felixcloutier.com/x86/)*,
    which is easier to browse.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Intel 64 软件开发者手册** (*[https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)*)
    是英特尔官方文档，涵盖 x64 指令集。我们关注的是第 2 卷，即指令集参考。还有一个非官方版本，位于 *[https://www.felixcloutier.com/x86/](https://www.felixcloutier.com/x86/)*，它更易于浏览。'
- en: '**Compiler Explorer** (*[https://<wbr>godbolt<wbr>.org](https://godbolt.org)*)
    is an extremely nifty website where you can see how a variety of widely used compilers
    translate your code to assembly. It makes it easy to compare the output of different
    compilers and see the impact of various optimization levels and compiler flags.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器探索器** (*[https://godbolt.org](https://godbolt.org)*) 是一个非常实用的网站，你可以在这里查看各种广泛使用的编译器如何将你的代码转换成汇编语言。它使得比较不同编译器的输出变得非常容易，并且能够看到不同优化级别和编译器标志的影响。'
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*C23 is set to be published in 2024, superseding C17\. For our purposes, the
    differences between C17 and C23 aren’t significant. We won’t implement the new
    language features introduced in C23, but we aren’t implementing all of C17, either.
    The subset of C we* do *implement looks pretty much the same in both versions
    of the standard. If you’re curious about what’s different in C23, you can find
    a free, nearly final draft at* [https://<wbr>open<wbr>-std<wbr>.org<wbr>/JTC1<wbr>/SC22<wbr>/WG14<wbr>/www<wbr>/docs<wbr>/n3096<wbr>.pdf](https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf)
    *and an informal list of changes at* [https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/23](https://en.cppreference.com/w/c/23)*.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*C23计划于2024年发布，取代C17。就我们的目的而言，C17和C23之间的差异并不显著。我们不会实现C23中引入的新语言特性，但我们也没有实现C17中的所有内容。我们实现的C子集在两个版本的标准中基本相同。如果你对C23中的不同之处感兴趣，可以在*
    [https://<wbr>open<wbr>-std<wbr>.org<wbr>/JTC1<wbr>/SC22<wbr>/WG14<wbr>/www<wbr>/docs<wbr>/n3096<wbr>.pdf](https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf)
    *找到一个免费的、几乎最终版的草案，另外也可以在* [https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/23](https://en.cppreference.com/w/c/23)*上看到一个非正式的变更列表。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Let’s Go!</samp>
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">让我们开始吧！</samp>
- en: We’ve covered all the preliminaries and we’re ready to get started. In [Chapter
    1](chapter1.xhtml), we’ll compile our first C program.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了所有的前置知识，准备好开始了。在[第1章](chapter1.xhtml)中，我们将编写我们的第一个C程序。
