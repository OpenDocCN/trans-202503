<html><head></head><body>
<h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_431"/><span class="big">16</span><br/>USING THE M4 MACRO PROCESSOR WITH AUTOCONF</h2>&#13;
<p class="quote"><em>By the time you’ve sorted out a complicated idea into little steps that even a stupid machine can deal with, you’ve learned something about it yourself.</em><br/>—<em>Douglas Adams</em>, Dirk Gently’s Holistic Detective Agency</p>&#13;
<p class="image1"><img src="../images/common.jpg" alt="Image"/></p>&#13;
<p class="noindent">The M4 macro processor is simple to use, yet hard to comprehend. The simplicity comes from the fact that it does just one thing very well. I’ll wager that you or I could write the base functionality of M4 in a C program in just a few hours. At the same time, two aspects of M4 make it rather difficult to understand immediately.</p>&#13;
<p class="indent">First, the exceptions introduced by <em>special cases</em> that M4 deals with when it processes input text make it hard to grasp all of its rules immediately, though this complexity is easily mastered with time, patience, and practice. Second, the stack-based, pre-order recursive nature of M4’s text-processing model is difficult for the human mind to comprehend. Humans tend to process information breadth first, comprehending complete levels of a problem or data set, one level at a time, whereas M4 processes text in a depth-first fashion.</p>&#13;
<p class="indent">This chapter covers what I consider the bare minimum you need to know to write Autoconf input files. I can’t do justice to M4 in a single chapter of this book, so I’ll cover just the highlights. For more detail, read the <span epub:type="pagebreak" id="page_432"/><em>GNU M4 Manual</em>.<sup><a id="ch16fn_1" href="footnote.xhtml#ch16fn1">1</a></sup> If you’ve already had some experience with M4, try the examples in that manual and then try solving a few text problems of your own using M4. A small amount of such experimentation will vastly improve your understanding of M4.</p>&#13;
<h3 class="h3" id="ch16sec1">M4 Text Processing</h3>&#13;
<p class="noindent">Like many other classic Unix tools, M4 is written as a standard input/output (<span class="literal">stdio</span>) filter. That is, it accepts input from standard input (<span class="literal">stdin</span>), processes it, and then sends it to standard output (<span class="literal">stdout</span>). Input text is read in as a stream of bytes and converted to <em>tokens</em> before processing. Tokens consist of comments, names, quoted strings, and single characters that are not part of a comment, name, or quoted string.</p>&#13;
<p class="indent">The <em>default</em> quote characters are the backtick (<span class="literal">`</span>) and the single quote (<span class="literal">'</span>).<sup><a id="ch16fn_2" href="footnote.xhtml#ch16fn2">2</a></sup> Use the backtick to start a quoted string and the single quote character to terminate one:</p>&#13;
<pre>`A quoted string'</pre>&#13;
<p class="indent">M4 comments are similar to quoted strings in that each one is processed as a single token. Each comment is delimited by a hash mark (<span class="literal">#</span>) and a newline (<span class="literal">\n</span>) character. Thus, all text following an <em>unquoted</em> hash mark, up to and including the next newline character, is considered part of a comment.</p>&#13;
<p class="indent">Comments are not stripped from the output as they are in other computer language preprocessors, such as the C-language preprocessor. Rather, they are simply passed through without further processing.</p>&#13;
<p class="indent">The following example contains five tokens: a name token, a space character token, another name token, a second space character token, and finally, a single comment token:</p>&#13;
<pre>Two names # followed by a comment</pre>&#13;
<p class="indent">A <em>name</em> is any sequence of letters, digits, and underscore characters that does not begin with a digit. Thus, the first line of the following example contains two digit character tokens, followed by a name token, whereas the second line contains only a single name token:</p>&#13;
<pre>88North20th_street&#13;
_88North20th_street</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_433"/>Note that whitespace characters (horizontal and vertical tabs, form feeds, carriage returns, spaces, and newlines) are specifically not part of a name, so whitespace characters may (and often do) act as name or other token delimiters. However, such whitespace delimiters are not discarded by M4, as they often are by a computer language compiler’s parser. They’re simply passed through from the input stream directly to the output stream without further modification.</p>&#13;
<h4 class="h4" id="ch16sec1-1"><em>Defining Macros</em></h4>&#13;
<p class="noindent">M4 provides a variety of built-in macros, many of which are critical to the proper use of this tool. For instance, it would be very difficult to get any useful functionality out of M4 if it didn’t provide a way of defining macros. M4’s macro-definition macro is called <span class="literal">define</span>.</p>&#13;
<p class="indent">The <span class="literal">define</span> macro is simple to describe:</p>&#13;
<pre>define(<span class="codeitalic1">macro</span>[, <span class="codeitalic1">expansion</span>])</pre>&#13;
<p class="indent">The <span class="literal">define</span> macro expects at least one parameter, even if it’s empty. If you supply only one parameter, then instances of the macro name that are found in the input text are simply deleted from the output text:</p>&#13;
<pre>   $ <span class="codestrong1">m4</span>&#13;
   <span class="codestrong1">define(`macro')</span>&#13;
&#13;
   <span class="codestrong1">Hello macro world!</span>&#13;
<span class="ent">➊</span> Hello   world!&#13;
  <span class="codestrong1">&lt;ctrl-d&gt;</span>$</pre>&#13;
<p class="indent">Note in the output text at <span class="ent">➊</span> that there are two spaces between <span class="literal">Hello</span> and <span class="literal">world!</span> All tokens except names that map to defined macros are passed from the input stream to the output stream without modification, with one exception: whenever any quoted text outside of comments is read from the input stream, one level of quotes is removed.</p>&#13;
<p class="indent">Another subtle aspect of the <span class="literal">define</span> macro is that its expansion is the empty string. Thus, the output of the preceding definition is simply the trailing carriage return after the definition in the input string.</p>&#13;
<p class="indent">Names, of course, are candidates for macro expansion. If a name token is found in the symbol table, it is replaced with the macro expansion, as shown in the following example:</p>&#13;
<pre>   $ <span class="codestrong1">m4</span>&#13;
<span class="ent">➊</span> <span class="codestrong1">define(`macro', `expansion')</span>&#13;
<span class="ent">➋</span>&#13;
   <span class="codestrong1">macro ``quoted' macro text'</span>&#13;
<span class="ent">➌</span> expansion `quoted' macro text&#13;
   <span class="codestrong1">&lt;ctrl-d&gt;</span>$</pre>&#13;
<p class="indent">The second output line at <span class="ent">➌</span> shows us that the first token (the name <span class="literal">macro</span>) is expanded and the outer level of quotes around <span class="literal">``quoted' macro</span> <span epub:type="pagebreak" id="page_434"/><span class="literal">text'</span> are removed by M4. The blank line at <span class="ent">➋</span> following the macro definition comes from the newline character I entered into the input stream when I pressed the enter key after the macro definition at <span class="ent">➊</span>. Since this newline character is not part of the macro definition, M4 simply passes it through to the output stream. This can be a problem when defining macros in input text because you could end up with a slew of blank lines in the output text, one for each macro defined in the input text. Fortunately, there are ways around this problem. For example, I could simply not enter that newline character, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">m4</span>&#13;
<span class="codestrong1">define(`macro', `expansion')macro</span>&#13;
expansion&#13;
<span class="codestrong1">&lt;ctrl-d&gt;</span>$</pre>&#13;
<p class="indent">That solves the problem, but it doesn’t take a genius to see that this can lead to some readability issues. If you have to define your macros in this manner so that they don’t affect your output text, you’ll have a few run-on sentences in your input text!</p>&#13;
<p class="indent">As a solution for this problem, M4 provides another built-in macro called <span class="literal">dnl</span>,<sup><a id="ch16fn_3" href="footnote.xhtml#ch16fn3">3</a></sup> which causes all input text up to and including the next newline character to be discarded. It’s common to find <span class="literal">dnl</span> used in <em>configure.ac</em>, but it’s even more common to find it used in <em>.m4</em> macro definition files consumed by Autoconf while processing <em>configure.ac</em> files.</p>&#13;
<p class="indent">Here’s an example of the proper use of <span class="literal">dnl</span>:</p>&#13;
<pre>$ <span class="codestrong1">m4</span>&#13;
<span class="codestrong1">define(`macro', `expansion')dnl</span>&#13;
<span class="codestrong1">macro</span>&#13;
expansion&#13;
<span class="codestrong1">&lt;ctrl-d&gt;</span>$</pre>&#13;
<p class="indent">There are a few dozen built-in M4 macros, all of which provide functionality that can’t be obtained in any other way within M4. Some redefine fundamental behavior in M4.</p>&#13;
<p class="indent">For example, the <span class="literal">changequote</span> macro is used to change the default quote characters from backtick and single quote to whatever you want. Autoconf uses a line like this near the top of the input stream to change the M4 quotes to the left and right square bracket characters, like so:</p>&#13;
<pre>changequote(`[',`]')dnl</pre>&#13;
<p class="indent">Why would the Autoconf designers do this? Well, it’s quite common in shell code to find unbalanced pairs of single quote characters. In shell code, both backtick and single quote are common in expressions that use the same character to both start and end an expression. This is confusing to M4, which requires open and close quote characters to be distinct from <span epub:type="pagebreak" id="page_435"/>each other in order to properly process its input stream. You’ll recall from <a href="ch04.xhtml">Chapter 4</a> that the input text to Autoconf is shell script, which means that there’s a good chance Autoconf will run into an unbalanced pair of M4 quotes in every input file it reads. This can lead to errors that are very difficult to track down, because they have more to do with M4 than they do with Autoconf. It’s far less likely that the input shell script will contain an unbalanced pair of square bracket characters.</p>&#13;
<h4 class="h4" id="ch16sec1-2"><em>Macros with Arguments</em></h4>&#13;
<p class="noindent">Macros may also be defined to accept arguments, which may be referenced in the expansion text with <span class="literal">$1</span>, <span class="literal">$2</span>, <span class="literal">$3</span>, and so on. The number of arguments passed can be found in the variable <span class="literal">$#</span>, and <span class="literal">$@</span> can be used to pass all arguments of one macro call onto another. When using arguments in a macro call, there can be no intervening whitespace between the macro name and the opening parenthesis. Here’s an example of a macro that’s defined and then called in various ways:</p>&#13;
<pre>   $ <span class="codestrong1">m4</span>&#13;
   <span class="codestrong1">define(`with2args', `The $# arguments are $1 and $2.')dnl</span>&#13;
<span class="ent">➊</span> <span class="codestrong1">with2args</span>&#13;
   The 0 arguments are  and .&#13;
   <span class="codestrong1">with2args()</span>&#13;
   The 1 arguments are  and .&#13;
<span class="ent">➋</span> <span class="codestrong1">with2args(`arg1')</span>&#13;
   The 1 arguments are arg1 and .&#13;
   <span class="codestrong1">with2args(`arg1', `arg2')</span>&#13;
   The 2 arguments are arg1 and arg2.&#13;
   <span class="codestrong1">with2args(`arg1', `arg2', `arg3')</span>&#13;
   The 3 arguments are arg1 and arg2.&#13;
<span class="ent">➌</span> <span class="codestrong1">with2args (`arg1', `arg2')</span>&#13;
   The 0 arguments are  and . (arg1, arg2)&#13;
   <span class="codestrong1">&lt;ctrl-d&gt;</span>$</pre>&#13;
<p class="indent">In this example, the first call at <span class="ent">➊</span> is a macro call without arguments. The second call is a macro call with one empty argument. Such calls treat the parameters as if empty arguments were actually passed.<sup><a id="ch16fn_4" href="footnote.xhtml#ch16fn4">4</a></sup> In both cases, the macro expands to “<span class="literal">The N arguments are    and .</span>” (note the double space between the last two words and the space between the last word and the period), but the “N” is 0 in the first call and 1 in the second. Therefore, the empty set of parentheses in the second call carries an empty single argument. The next three calls, beginning at <span class="ent">➋</span>, pass one, two, and three arguments, respectively. As you can see by the resulting outputs of these three calls, parameters in the expansion text that reference missing arguments are treated as empty, while arguments passed without corresponding references are simply ignored.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_436"/>The last call, at <span class="ent">➌</span>, is a bit different. Notice that it contains a space between the macro name and the opening parenthesis. The initial output of this call is similar to that of the first call, but following that initial output, we find what appears to be a minor variation on the originally intended argument list (the quotes are missing). This is a macro call <em>without arguments</em>. Since it’s not actually part of the macro call, M4 treats the argument list simply as text on the input stream. Thus, it’s copied directly to the output stream, minus one level of quotes.</p>&#13;
<p class="indent">When passing arguments in macro calls, be aware of whitespace around arguments. The rules are simple: unquoted <em>leading</em> whitespace is removed from arguments, and <em>trailing</em> whitespace is always preserved, whether quoted or not. Of course, <em>whitespace</em> here refers to carriage returns and newline characters, as well as spaces and tabs. Here’s an example of calling a macro with variations in leading and trailing whitespace:</p>&#13;
<pre>   $ <span class="codestrong1">m4</span>&#13;
   <span class="codestrong1">define(`with3args', `The three arguments are $1, $2, and $3.')dnl</span>&#13;
<span class="ent">➊</span> <span class="codestrong1">with3args(arg1,</span>&#13;
             <span class="codestrong1">arg2,</span>&#13;
             <span class="codestrong1">arg3)</span>&#13;
   The three arguments are arg1, arg2, and arg3.&#13;
<span class="ent">➋</span> <span class="codestrong1">with3args(arg1</span>&#13;
             <span class="codestrong1">,arg2</span>&#13;
             <span class="codestrong1">,arg3</span>&#13;
             <span class="codestrong1">)</span>&#13;
   The three arguments are arg1&#13;
             , arg2&#13;
             , and arg3&#13;
             .&#13;
   <span class="codestrong1">&lt;ctrl-d&gt;</span>$</pre>&#13;
<p class="indent">In this example, I purposely omitted the quotes around the macro arguments in the calls at <span class="ent">➊</span> and <span class="ent">➋</span> in order to reduce confusion. The call at <span class="ent">➊</span> has only leading whitespace in the form of newlines and tab characters, while the call at <span class="ent">➋</span> has only trailing whitespace. I’ll cover quoting rules shortly, at which point you’ll see clearly how quoting affects whitespace in macro arguments.</p>&#13;
<h3 class="h3" id="ch16sec2">The Recursive Nature of M4</h3>&#13;
<p class="noindent">Now we consider the recursive nature of the M4 input stream. Whenever a name token is expanded by a macro definition, the expansion text is pushed back onto the input stream for complete reprocessing. This recursive reprocessing continues to occur as long as there are macro calls found in the input stream that generate text.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_437"/>Here’s an example:</p>&#13;
<pre>$ <span class="codestrong1">m4</span>&#13;
<span class="codestrong1">define(`macro', `expansion')dnl</span>&#13;
<span class="codestrong1">macro ``quoted' text'</span>&#13;
expansion `quoted' text&#13;
<span class="codestrong1">&lt;ctrl-d&gt;</span>$</pre>&#13;
<p class="indent">Here, I define a macro called <em>macro</em> and then present this macro name on the input stream, followed by additional text, some of which is quoted and some of which is double quoted.</p>&#13;
<p class="indent">The process used by M4 to parse this example is shown in <a href="ch16.xhtml#ch16fig1">Figure 16-1</a>.</p>&#13;
<p class="image"><img src="../images/16fig01.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch16fig1"><em>Figure 16-1: The procedure used by M4 to process an input text stream</em></p>&#13;
<p class="indent">In the bottom line of the figure, M4 is generating a stream of output text (<span class="literal">expansion `quoted</span><span class="literal">'</span> <span class="literal">text</span>) from a stream of input text (<span class="literal">macro ``quoted' text'</span>).</p>&#13;
<p class="indent">The diagram above this line shows how M4 actually generates the output text from the input text. When the first token (<span class="literal">macro</span>) is read in the top line, M4 finds a matching symbol in the symbol table, pushes it onto the input stream on the second line, and then restarts the input stream. Thus, the very next token read is another name token (<span class="literal">expansion</span>). Since this name is not found in the symbol table, the text is sent directly to the output stream. The third line sends the next token from the input stream (a space character) directly to the output stream. Finally, in the fourth line, one level of quotes is removed from the quoted text (<span class="literal">``quoted' text'</span>), and the result (<span class="literal">`quoted' text</span>) is sent to the output stream.</p>&#13;
<h4 class="h4" id="ch16sec2-1"><span epub:type="pagebreak" id="page_438"/><em>Infinite Recursion</em></h4>&#13;
<p class="noindent">As you might guess, there are some potentially nasty side effects of this process. For example, you can accidentally define a macro that is infinitely recursive. The expansion of such a macro would lead to a massive amount of unwanted output, followed by a stack overflow. This is easy to do:</p>&#13;
<pre>$ <span class="codestrong1">m4</span>&#13;
<span class="codestrong1">define(`macro', `This is a macro')dnl</span>&#13;
<span class="codestrong1">macro</span>&#13;
This is a This is a This is a This is a This is a This is a... <span class="codestrong1">&lt;ctrl-c&gt;</span>&#13;
$</pre>&#13;
<p class="indent">This happens because the macro name expands into text containing the macro’s own name, which is then pushed back onto the input stream for reprocessing. Consider the following scenario: <em>What would have been the result if I’d left the quotes off of the expansion text in the macro definition? What would have happened if I’d added another set of quotes around the expansion text?</em> To help you discover the answers to these questions, let’s turn next to M4 quoting rules.</p>&#13;
<h4 class="h4" id="ch16sec2-2"><em>Quoting Rules</em></h4>&#13;
<p class="noindent">Proper quoting is critical. You have probably encountered situations where your invocations of Autoconf macros didn’t work as you expected. The problem is often a case of under-quoting, which means you omitted a required level of quotes around some text.</p>&#13;
<p class="indent">You see, each time text passes through M4, a layer of quotes is stripped off. Quoted strings are not names and are therefore not subject to macro expansion, but if a quoted string passes through M4 twice, the second time through, it’s no longer quoted. As a result, individual words within that string are no longer part of a string but instead are parsed as name tokens, which are subject to macro expansion. To illustrate this, enter the following text at a shell prompt:</p>&#13;
<pre>   $ <span class="codestrong1">m4</span>&#13;
   <span class="codestrong1">define(`def', `DEF')dnl</span>&#13;
<span class="ent">➊</span> <span class="codestrong1">define(`abc', `def')dnl</span>&#13;
   <span class="codestrong1">abc</span>&#13;
   DEF&#13;
<span class="ent">➋</span> <span class="codestrong1">define(`abc', ``def'')dnl</span>&#13;
   <span class="codestrong1">abc</span>&#13;
   def&#13;
<span class="ent">➌</span> <span class="codestrong1">define(`abc', ```def''')dnl</span>&#13;
   <span class="codestrong1">abc</span>&#13;
   `def'&#13;
   <span class="codestrong1">&lt;ctrl-d&gt;</span>$</pre>&#13;
<p class="indent">In this example, the first time <span class="literal">abc</span> is defined (at <span class="ent">➊</span>), it’s quoted once. As M4 processes the macro definition, it removes a layer of quotes. Thus, the expansion text is stored in the symbol table without quotes, but it’s pushed <span epub:type="pagebreak" id="page_439"/>back onto the input stream and therefore is transformed into <span class="literal">DEF</span> due to the first macro definition.</p>&#13;
<p class="indent">As you can see, the second definition of <span class="literal">abc</span> (at <span class="ent">➋</span>) is double quoted, so when the definition is processed and the outer layer of quotes is stripped off, we would expect the expansion text in the symbol table to contain at least one set of quotes, and it does. Then why don’t we see quotes around the output text? Remember that when macros are expanded, the expansion text is pushed onto the front of the input stream and reparsed using the usual rules. Thus, while the text of the second definition is stored quoted in the symbol table, as it’s reprocessed upon use, the second layer of quotes is removed between the input and output streams.</p>&#13;
<p class="indent">The difference between <span class="ent">➊</span> and <span class="ent">➋</span> in this example is that the expansion text of <span class="ent">➋</span> is treated as quoted text by M4, rather than as a potential macro name. The quotes are removed during definition, but the enclosed text is not considered for further expansion because it’s still quoted.</p>&#13;
<p class="indent">In the third definition of <span class="literal">abc</span> (at <span class="ent">➌</span>), we finally see the result we were perhaps hoping to obtain: a quoted version of the output text. The expansion text is entered into the symbol table double quoted, because the outermost set of quotes is stripped off during processing of the definition. Then, when the macro is used, the expansion text is reprocessed and the second set of quotes is stripped off, leaving one set in the final output text.</p>&#13;
<p class="indent">If you keep these rules in mind as you work with macros within Autoconf (including both definitions and calls), you’ll find it easier to understand why things may not work the way you think they should. The <em>GNU M4 Manual</em> provides a simple rule of thumb for using quotes in macro calls: for each layer of nested parentheses in a macro call, use one layer of quotes.</p>&#13;
<h3 class="h3" id="ch16sec3">Autoconf and M4</h3>&#13;
<p class="noindent">The <span class="literal">autoconf</span> program is a rather simple shell script. About 80 percent of the shell code in the script exists simply to ensure that the shell is functional enough to perform the required tasks. The remaining 20 percent parses command line options. The last line of the script executes the <span class="literal">autom4te</span> program, a Perl script that acts as a wrapper around the <span class="literal">m4</span> utility. Ultimately, <span class="literal">autom4te</span> calls <span class="literal">m4</span> like this:</p>&#13;
<pre>/usr/bin/m4 --nesting-limit=1024 --gnu --include=/usr/share/autoconf \&#13;
--debug=aflq --fatal-warning --debugfile=autom4te.cache/traces.0t \&#13;
--trace=AC_CANONICAL_BUILD ... --trace=sinclude \&#13;
--reload-state=/usr/share/autoconf/autoconf.m4f aclocal.m4 configure.ac</pre>&#13;
<p class="indent">As you can see, the three files that M4 is processing are <em>/usr/share</em><em>/autoconf</em><em>/autoconf.m4f</em>, <em>aclocal.m4</em>, and <em>configure.ac</em>, in that order.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The</em> .m4f <em>extension on the master Autoconf macro file signifies a</em> frozen <em>M4 input file—a sort of precompiled version of the original</em> .m4 <em>file. When a frozen macro file is processed, it must be specified after a <span class="literal">--reload-state</span> option, in order to make M4 <span epub:type="pagebreak" id="page_440"/>aware that it’s not a normal input file. State is built cumulatively within M4 over all input files, so any macros defined by</em> aclocal.m4, <em>for instance, are available during the processing of</em> configure.ac.</p>&#13;
</div>&#13;
<p class="indent">The ellipsis between the two <span class="literal">--trace</span> options in the command line above is a placeholder for more than 100 such <span class="literal">--trace</span> options. It’s a good thing the shell can handle long command lines!</p>&#13;
<p class="indent">The master Autoconf macro file, <em>autoconf.m4</em>, merely includes (using the <span class="literal">m4_include</span> macro) the other dozen or so Autoconf macro files, in the correct order, and then does a small amount of housekeeping before leaving M4 ready to process user input (via <em>configure.ac</em>). The <em>aclocal.m4</em> file is our project’s macro file, built originally by the <span class="literal">aclocal</span> utility or handwritten for projects that don’t use Automake. By the time <em>configure.ac</em> is processed, the M4 environment has been configured with hundreds of Autoconf macro definitions, which may be called as needed by <em>configure.ac</em>. This environment includes not only the recognized <span class="literal">AC_*</span> macros but also a few lower layers of Autoconf-provided macros that you may use to write your own macros.</p>&#13;
<p class="indent">One such lower layer is <em>m4sugar</em>,<sup><a id="ch16fn_5" href="footnote.xhtml#ch16fn5">5</a></sup> which provides a nice clean namespace in which to define all of the Autoconf macros, as well as several improvements and additions to the existing M4 macros.</p>&#13;
<p class="indent">Autoconf modifies the M4 environment in a few ways. First, as mentioned earlier, it changes the default quote characters from the backtick and single quote characters to the open and close square bracket characters. In addition, it configures M4 built-in macros such that most are prefixed with <span class="literal">m4_</span>, thereby creating a unique namespace for M4 macros. Thus, the M4 <span class="literal">define</span> macro becomes <span class="literal">m4_define</span>, and so on.<sup><a id="ch16fn_6" href="footnote.xhtml#ch16fn6">6</a></sup></p>&#13;
<p class="indent">Autoconf provides its own version of <span class="literal">m4_define</span> called <span class="literal">AC_DEFUN</span>. You should use <span class="literal">AC_DEFUN</span> instead of <span class="literal">m4_define</span> because it ensures that certain environmental constraints important to Autoconf are in place when your macro is called. The <span class="literal">AC_DEFUN</span> macro supports a prerequisite framework, so you can specify which macros are required to have been called before your macro may be called. This framework is accessed by using the <span class="literal">AC_REQUIRE</span> macro to indicate your macro’s requirements at the beginning of your macro definition, like so:</p>&#13;
<pre># Test for option A&#13;
# -----------------&#13;
AC_DEFUN([TEST_A],&#13;
[AC_REQUIRE([TEST_B])dnl&#13;
test "$A" = "yes" &amp;&amp; options="$options A"])</pre>&#13;
<p class="indent">The rules for writing Autoconf macros using <span class="literal">AC_DEFUN</span> and the prerequisite framework are outlined in <a href="ch09.xhtml">Chapter 9</a> of the <em>GNU Autoconf Manual</em>. Before you write your own macros, read <a href="ch08.xhtml">Chapters 8</a> and <a href="ch09.xhtml">9</a> of that manual.</p>&#13;
<h4 class="h4" id="ch16sec4"><span epub:type="pagebreak" id="page_441"/>Writing Autoconf Macros</h4>&#13;
<p class="noindent">Why would we want to write Autoconf macros in the first place? One reason is that a project’s <em>configure.ac</em> file might contain several instances of similar sets of code and we need the <span class="literal">configure</span> script to perform the same set of high-level operations on multiple directories or file sets. By converting the process into a macro, we reduce the number of lines of code in the <em>configure.ac</em> file, thereby reducing the number of possible points of failure. Another reason might be that an easily encapsulated bit of <em>configure.ac</em> code could be useful in other projects, or even to other people.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The GNU Autoconf Archive provides many sets of related macros to solve common Autoconf problems. Anyone may contribute to the archive by emailing their macros to the project maintainer. There are frequent tarball releases available for free from the project website.</em><sup><a id="ch16fn_7" href="footnote.xhtml#ch16fn7">7</a></sup></p>&#13;
</div>&#13;
<h4 class="h4" id="ch16sec4-1"><em>Simple Text Replacement</em></h4>&#13;
<p class="noindent">The simplest type of macro is one that replaces text verbatim, with no substitutions. An excellent example of this is found in the FLAIM project, where the flaim, xflaim, and sql projects’ <span class="literal">configure</span> scripts attempt to locate the ftk (FLAIM toolkit) project library and header file. Since I already discussed the operation of this code in <a href="ch14.xhtml">Chapter 14</a>, I’ll only cover it briefly here as it relates to writing Autoconf macros, but I provide the relevant bit of <em>configure.ac</em> code in <a href="ch16.xhtml#ch16ex1">Listing 16-1</a> for convenience.<sup><a id="ch16fn_8" href="footnote.xhtml#ch16fn8">8</a></sup></p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
# Configure FTKLIB, FTKINC, FTK_LTLIB and FTK_INCLUDE&#13;
AC_ARG_VAR([FTKLIB], [The PATH wherein libflaimtk.la can be found.])&#13;
AC_ARG_VAR([FTKINC], [The PATH wherein flaimtk.h can be found.])&#13;
&#13;
# Ensure that both or neither FTK paths were specified.&#13;
if { test -n "$FTKLIB" &amp;&amp; test -z "$FTKINC"; } || \&#13;
   { test -z "$FTKLIB" &amp;&amp; test -n "$FTKINC"; }; then&#13;
  AC_MSG_ERROR([Specify both FTKINC and FTKLIB, or neither.])&#13;
fi&#13;
&#13;
# Not specified? Check for FTK in standard places.&#13;
if test -z "$FTKLIB"; then&#13;
  # Check for FLAIM toolkit as a sub-project.&#13;
  if test -d "$srcdir/ftk"; then&#13;
    AC_CONFIG_SUBDIRS([ftk])&#13;
    FTKINC='$(top_srcdir)/ftk/src'&#13;
    FTKLIB='$(top_builddir)/ftk/src'&#13;
  else&#13;
    # Check for FLAIM toolkit as a superproject.&#13;
<span epub:type="pagebreak" id="page_442"/>    if test -d "$srcdir/../ftk"; then&#13;
      FTKINC='$(top_srcdir)/../ftk/src'&#13;
      FTKLIB='$(top_builddir)/../ftk/src'&#13;
    fi&#13;
  fi&#13;
fi&#13;
&#13;
# Still empty? Check for *installed* FLAIM toolkit.&#13;
if test -z "$FTKLIB"; then&#13;
  AC_CHECK_LIB([flaimtk], [ftkFastChecksum],&#13;
    [AC_CHECK_HEADERS([flaimtk.h])&#13;
     LIBS="-lflaimtk $LIBS"],&#13;
    [AC_MSG_ERROR([No FLAIM toolkit found. Terminating.])])&#13;
fi&#13;
&#13;
# AC_SUBST command line variables from FTKLIB and FTKINC.&#13;
if test -n "$FTKLIB"; then&#13;
  AC_SUBST([FTK_LTLIB], ["$FTKLIB/libflaimtk.la"])&#13;
  AC_SUBST([FTK_INCLUDE], ["-I$FTKINC"])&#13;
fi&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch16ex1"><em>Listing 16-1:</em> xflaim/configure.ac: <em>The ftk search code from the xflaim project</em></p>&#13;
<p class="indent">This code is identical in flaim, xflaim, and sql, though it may be modified in the future for one reason or another, so keeping it embedded in all three <em>configure.ac</em> files is redundant and error prone.</p>&#13;
<p class="indent">Even if we were to convert this code to a macro, we’d still have to put a copy of the macro file into each of the projects’ <em>m4</em> directories. However, we could later edit only one of these macro files and copy it from the authoritative location into the other projects’ <em>m4</em> directories, or even use symlinks in git rather than copies to ensure there is truly only a single copy of the <em>.m4</em> file. This would be a better solution than having all of the code embedded in all three <em>configure.ac</em> files.</p>&#13;
<p class="indent">By converting this code to a macro, we can keep it in one place where portions of it cannot be confused for code that is not related to the process of locating the FLAIM toolkit library and header file. This happens quite often during later maintenance of a project’s <em>configure.ac</em> file, as additional code designed for other purposes is dropped between chunks of code belonging to sequences like this.</p>&#13;
<p class="indent">Let’s try converting this code into a macro. Our first attempt might look like <a href="ch16.xhtml#ch16ex2">Listing 16-2</a>. (I’ve omitted a large chunk in the middle that is identical to the original code, for the sake of brevity.)</p>&#13;
<pre>AC_DEFUN([FLM_FTK_SEARCH],&#13;
[AC_ARG_VAR([FTKLIB], [The PATH wherein libflaimtk.la can be found.])&#13;
AC_ARG_VAR([FTKINC], [The PATH wherein flaimtk.h can be found.])&#13;
<span class="codeitalic1">--snip--</span>&#13;
# AC_SUBST command line variables from FTKLIB and FTKINC.&#13;
if test -n "$FTKLIB"; then&#13;
  AC_SUBST([FTK_LTLIB], ["$FTKLIB/libflaimtk.la"])&#13;
<span epub:type="pagebreak" id="page_443"/>  AC_SUBST([FTK_INCLUDE], ["-I$FTKINC"])&#13;
fi])</pre>&#13;
<p class="caption" id="ch16ex2"><em>Listing 16-2:</em> xflaim/m4/flm_ftk_search.m4: <em>A first attempt at encapsulating ftk search code</em></p>&#13;
<p class="indent">In this pass, I’ve simply cut and pasted the entire <em>configure.ac</em> code sequence verbatim into the <span class="literal">macro-body</span> argument of a call to <span class="literal">AC_DEFUN</span>. The <span class="literal">AC_DEFUN</span> macro is defined by Autoconf and provides some additional functionality over the <span class="literal">m4_define</span> macro provided by M4. This additional functionality is strictly related to the prerequisite framework provided by Autoconf.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Be aware that <em><span class="literal">AC_DEFUN</span></em> must be used (rather than <em><span class="literal">m4_define</span></em>) in order for the macro definition to be found by <em><span class="literal">aclocal</span></em> in your external macro definition files. You must use <em><span class="literal">AC_DEFUN</span></em> if your macro definitions are in external files, but for simple macros defined within</em> configure.ac <em>itself, you can use</em> <span class="literal">m4_define</span>.</p>&#13;
</div>&#13;
<p class="indent">Notice the use of M4 quoting around both the macro name (<span class="literal">FLM_FTK _SEARCH</span>) and the entire macro body. To illustrate the problems with not using these quotes in this example, consider how M4 would process the macro definition without the quotes. If the macro name were left unquoted, not much damage would be done, unless the macro happened to already be defined. If the macro were already defined, M4 would treat the macro name as a call with no parameters, and the existing definition would replace the macro name as M4 was reading the macro definition. (In this case, because of the unique name of the macro, there’s not much chance that it’s already defined, so I could have left the macro name unquoted with little effect, but it’s good to be consistent.)</p>&#13;
<p class="indent">On the other hand, the macro body contains a fair amount of text and even Autoconf macro calls. Had we left the body unquoted, these macro calls would be expanded during the reading of the definition rather than during the later use of the macro, as we had intended.</p>&#13;
<p class="indent">Because the quotes are present, M4 stores the macro body as provided, with no additional processing during the reading of the definition other than to remove the outermost layer of quotes. Later, when the macro is called, the body text is inserted into the input stream in place of the macro call, with one layer of quotes removed, and only then are the embedded macros expanded.</p>&#13;
<p class="indent">This macro requires no arguments because the same text is used identically in all three <em>configure.ac</em> files. The effect on <em>configure.ac</em> is to replace the entire chunk of code with the name of the macro, as shown in <a href="ch16.xhtml#ch16ex3">Listing 16-3</a>.</p>&#13;
<pre>   <span class="codeitalic1a">--snip--</span>&#13;
   <span class="ash"># Add jni.h include directories to include search path</span>&#13;
   <span class="ash">AX_JNI_INCLUDE_DIR</span>&#13;
   <span class="ash">for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS; do</span>&#13;
     <span class="ash">CPPFLAGS="$CPPFLAGS -I$JNI_INCLUDE_DIR"</span>&#13;
   <span class="ash">done</span>&#13;
&#13;
<span class="ent">➊</span> # Configure FTKLIB, FTKINC, FTK_LTLIB, and FTK_INCLUDE&#13;
   FLM_FTK_SEARCH&#13;
<span epub:type="pagebreak" id="page_444"/>   <span class="ash"># Check for Java compiler.</span>&#13;
   <span class="codeitalic1a">--</span><span class="codeitalic1a">snip--</span></pre>&#13;
<p class="caption" id="ch16ex3"><em>Listing 16-3:</em> xflaim/configure.ac: <em>Replacing the ftk search code with the new macro call</em></p>&#13;
<p class="indent">When writing a macro from existing code, consider the inputs to the existing chunk of code and the outputs provided by the code. Inputs will become possible macro arguments, and outputs will become documented effects. In <a href="ch16.xhtml#ch16ex3">Listing 16-3</a>, we have no inputs and thus no arguments, but what are the documentable effects of this code?</p>&#13;
<p class="indent">The comment at <span class="ent">➊</span> over the macro call in <a href="ch16.xhtml#ch16ex3">Listing 16-3</a> alludes to these effects. The <span class="literal">FTKLIB</span> and <span class="literal">FTKINC</span> variables are defined, and the <span class="literal">FTK_LTLIB</span> and <span class="literal">FTK_INCLUDE</span> variables are defined and substituted using <span class="literal">AC_SUBST</span>.</p>&#13;
<h4 class="h4" id="ch16sec4-2"><em>Documenting Your Macros</em></h4>&#13;
<p class="noindent">A proper macro definition provides a header comment that documents possible arguments, results, and potential side effects of the macro, as shown in <a href="ch16.xhtml#ch16ex4">Listing 16-4</a>.</p>&#13;
<pre># FLM_FTK_SEARCH&#13;
# --------------&#13;
# Define AC_ARG_VAR (user variables), FTKLIB, and FTKINC,&#13;
# allowing the user to specify the location of the flaim toolkit&#13;
# library and header file. If not specified, check for these files:&#13;
#&#13;
#   1. As a sub-project.&#13;
#   2. As a super-project (sibling to the current project).&#13;
#   3. As installed components on the system.&#13;
#&#13;
# If found, AC_SUBST FTK_LTLIB and FTK_INCLUDE variables with&#13;
# values derived from FTKLIB and FTKINC user variables.&#13;
# FTKLIB and FTKINC are file locations, whereas FTK_LTLIB and&#13;
# FTK_INCLUDE are linker and preprocessor command line options.&#13;
#&#13;
# Author:   John Calcote &lt;john.calcote@gmail.com&gt;&#13;
# Modified: 2009-08-30&#13;
# License:  AllPermissive&#13;
#&#13;
AC_DEFUN([FLM_FTK_SEARCH],&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch16ex4"><em>Listing 16-4:</em> xflaim/m4/flm_ftk_search.m4: <em>Adding a documentation header to the macro definition</em></p>&#13;
<p class="indent">This header comment documents both the effects of this macro and the way it operates, giving the user a clear picture of the sort of functionality they’ll get when they call it. The <em>GNU Autoconf Manual</em> indicates that such macro definition header comments are stripped from the final output; if you search the <span class="literal">configure</span> script for some text in the comment header, you’ll see that it’s missing.</p>&#13;
<p class="indent">Regarding coding style, the <em>GNU Autoconf Manual</em> suggests that it is good macro definition style to place the macro body’s closing <span epub:type="pagebreak" id="page_445"/>square-bracket quote and the closing parenthesis alone on the last line of the macro definition, along with a comment containing only the name of the macro being defined, as shown in <a href="ch16.xhtml#ch16ex5">Listing 16-5</a>.</p>&#13;
<pre>   <span class="codeitalic1a">--snip--</span>&#13;
   <span class="ash">AC_SUBST([FTK_INCLUDE], ["-I$FTKINC"])</span>&#13;
<span class="ent">➊</span> <span class="ash">fi</span>[]dnl&#13;
   <span class="ash">])</span># FLM_FTK_SEARCH</pre>&#13;
<p class="caption" id="ch16ex5"><em>Listing 16-5:</em> xflaim/m4/flm_ftk_search.m4: <em>Suggested macro body closing style</em></p>&#13;
<p class="indent">The <em>GNU Autoconf Manual</em> also suggests that, if you don’t like the extra carriage return that the use of this format adds to the generated <span class="literal">configure</span> script, you can append the text <span class="literal">[]dnl</span> to the last line of the macro body, as shown at <span class="ent">➊</span> in <a href="ch16.xhtml#ch16ex5">Listing 16-5</a>. The use of <span class="literal">dnl</span> causes the trailing carriage return to be ignored, and the open and close square brackets are simply empty Autoconf quotes that are stripped out during processing of later macro calls. The quotes (square brackets) are used to separate <span class="literal">fi</span> and <span class="literal">dnl</span> so they’re recognized by M4 as two separate words.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The</em> GNU Autoconf Manual <em>defines a very complete naming convention for macros and their containing files. I’ve chosen simply to prefix all macro names and their containing files that are strictly related to the project with a project-specific prefix—in this case, <em><span class="literal">FLM_</span></em> (<em><span class="literal">flm_</span></em>).</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch16sec4-3"><em>M4 Conditionals</em></h4>&#13;
<p class="noindent">Now that you know how to write basic M4 macros, we’ll consider what it means to allow M4 to decide which text should be used to replace your macro call, based on arguments passed in the call.</p>&#13;
<h5 class="h5">Calling a Macro with and Without Arguments</h5>&#13;
<p class="noindent">Take a look at <a href="ch16.xhtml#ch16ex6">Listing 16-6</a>, which is my first attempt at writing the <span class="literal">FLM_PROG</span><span class="literal">_TRY_DOXYGEN</span> macro that was first used in <a href="ch14.xhtml">Chapter 14</a>. This macro was designed with an optional argument, which isn’t apparent from its use in <a href="ch14.xhtml">Chapter 14</a> because the FLAIM code called the macro without arguments. Let’s examine the definition of this macro. In the process, we’ll discover what it means to call it with and without arguments.</p>&#13;
<pre>   # FLM_PROG_TRY_DOXYGEN([quiet])&#13;
   # ------------------------------&#13;
   # FLM_PROG_TRY_DOXYGEN tests for an existing doxygen source&#13;
   # documentation program. It sets or uses the environment&#13;
   # variable DOXYGEN.&#13;
   #&#13;
   # If no arguments are given to this macro, and no doxygen&#13;
   # program can be found, it prints a warning message to STDOUT&#13;
   # and to the config.log file. If the quiet argument is passed,&#13;
   # then only the normal "check" line is displayed. Any other-token&#13;
   # argument is considered by autoconf to be an error at expansion&#13;
<span epub:type="pagebreak" id="page_446"/>   # time.&#13;
   #&#13;
   # Makes the DOXYGEN variable precious to Autoconf. You can&#13;
   # use the DOXYGEN variable in your Makefile.in files with&#13;
   # @DOXYGEN@.&#13;
   #&#13;
   # Author: John Calcote &lt;john.calcote@gmail.com&gt;&#13;
   # Modified: 2009-08-30&#13;
   # License: AllPermissive&#13;
   #&#13;
   AC_DEFUN([FLM_PROG_TRY_DOXYGEN],&#13;
<span class="ent">➊</span> [AC_ARG_VAR([DOXYGEN], [Doxygen source doc generation program])dnl&#13;
<span class="ent">➋</span> AC_CHECK_PROGS([DOXYGEN], [doxygen])&#13;
<span class="ent">➌</span> m4_ifval([$1],,&#13;
<span class="ent">➍</span> [if test -z "$DOXYGEN"; then&#13;
     AC_MSG_WARN([doxygen not found - continuing without Doxygen support])&#13;
   fi])&#13;
   ])# FLM_PROG_TRY_DOXYGEN</pre>&#13;
<p class="caption" id="ch16ex6"><em>Listing 16-6:</em> ftk/m4/flm_prog_try_doxygen.m4: <em>A first attempt at <span class="literal">FLM_PROG_TRY_DOXYGEN</span></em></p>&#13;
<p class="indent">First, we see a call to the <span class="literal">AC_ARG_VAR</span> macro at <span class="ent">➊</span>, which is used to make the <span class="literal">DOXYGEN</span> variable precious to Autoconf. Making a variable precious causes Autoconf to display it within the <span class="literal">configure</span> script’s help text as an influential environment variable. The <span class="literal">AC_ARG_VAR</span> macro also makes the specified variable an Autoconf substitution variable. At <span class="ent">➋</span>, we come to the heart of this macro—the call to <span class="literal">AC_CHECK_PROGS</span>. This macro checks for a <span class="literal">doxygen</span> program in the system search path, but it only looks for the program (passed in the second argument) if the variable (passed in the first argument) is empty. If this variable is not empty, <span class="literal">AC_CHECK_PROGS</span> assumes that the end user has already specified the proper program in the variable in the user’s environment, and it does nothing. In this case, the <span class="literal">DOXYGEN</span> variable is populated with <em>doxygen</em> if the <span class="literal">doxygen</span> program is found in the system search path. In either case, a reference to the <span class="literal">DOXYGEN</span> variable is substituted into template files by Autoconf. (Since we just called <span class="literal">AC_ARG_VAR</span> on <span class="literal">DOXYGEN</span>, this step is redundant but harmless.)</p>&#13;
<p class="indent">The call to <span class="literal">m4_ifval</span> at <span class="ent">➌</span> brings us to the point of this section. This is a conditional macro defined in Autoconf’s <em>m4sugar</em> layer—a layer of simple macros designed to make writing higher-level Autoconf macros easier. M4 conditional macros are designed to generate one block of text if a condition is true and another if the condition is false. The purpose of <span class="literal">m4_ifval</span> is to generate text based on whether its first argument is empty. If its first argument is not empty, the macro generates the text in its second argument. If its first argument is empty, the macro generates the text in its third argument.</p>&#13;
<p class="indent">The <span class="literal">FLM_PROG_TRY_DOXYGEN</span> macro works with or without an argument. If no arguments are passed, <span class="literal">FLM_PROG_TRY_DOXYGEN</span> will print a warning message that the build is continuing without Doxygen support if the <span class="literal">doxygen</span> program is not in the system search path. On the other hand, if the <span class="literal">quiet</span> option is passed to <span class="literal">FLM_PROG_TRY_DOXYGEN</span>, no message will be printed if the <span class="literal">doxygen</span> program is not found.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_447"/>In <a href="ch16.xhtml#ch16ex6">Listing 16-6</a>, <span class="literal">m4_ifval</span> generates no text (the second argument is empty) if the first argument contains text. The first argument is <span class="literal">$1</span>, which refers to the contents of the first argument passed to <span class="literal">FLM_PROG_TRY_DOXGEN</span>. If no arguments are given to our macro, <span class="literal">$1</span> will be empty, and <span class="literal">m4_ifval</span> will generate the text in its third argument shown at <span class="ent">➍</span>. On the other hand, if we pass <span class="literal">quiet</span> (or any text, for that matter) to <span class="literal">FLM_PROG_TRY_DOXYGEN</span>, <span class="literal">$1</span> will contain <span class="literal">quiet</span>, and <span class="literal">m4_ifval</span> will generate nothing.</p>&#13;
<p class="indent">The shell code in the third argument (at <span class="ent">➍</span>) checks to see if the <span class="literal">DOXYGEN</span> variable is still empty after the call to <span class="literal">AC_CHECK_PROGS</span>. If it is, it calls <span class="literal">AC_MSG_WARN</span> to display a configuration warning.</p>&#13;
<h5 class="h5">Adding Precision</h5>&#13;
<p class="noindent">Autoconf provides a macro called <span class="literal">m4_if</span>, a renamed version of the M4 built-in <span class="literal">ifelse</span> macro. The <span class="literal">m4_if</span> macro is similar in nature to <em>m4sugar</em>’s <span class="literal">m4_ifval</span>. <a href="ch16.xhtml#ch16ex7">Listing 16-7</a> shows how we might use <span class="literal">ifelse</span> in place of <span class="literal">m4_ifval</span>, if we didn’t have <em>m4sugar</em> macros to work with.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
ifelse ([$1],,&#13;
<span class="ash">[if test -z "$DOXYGEN"; then</span>&#13;
<span class="ash">AC_MSG_WARN([Doxygen program not found - continuing without Doxygen])</span>&#13;
<span class="ash">fi])</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption" id="ch16ex7"><em>Listing 16-7: Using <span class="literal">ifelse</span> instead of <span class="literal">m4_ifval</span></em></p>&#13;
<p class="indent">The macros appear to be identical in function, but this appearance is only circumstantial; the parameters are used differently. In this case, if the first argument (<span class="literal">$1</span>) is the same as the second argument (the empty string), the contents of the third argument (<span class="literal">[if test -z ...]</span>) are generated. Otherwise, the contents of the fourth (nonexistent) argument are generated because omitted arguments are treated as if the empty string had been passed. Therefore, the following two macro invocations are identical:</p>&#13;
<pre>m4_ifval([$1],[a],[b]])&#13;
ifelse([$1],[],[b],[a])</pre>&#13;
<p class="indent"><span class="literal">FLM_PROG_TRY_DOXYGEN</span> treats any text in its argument as if <span class="literal">quiet</span> was passed. In order to facilitate future enhancements to this macro, we should limit the allowed text in this argument to something that makes sense; otherwise, users could abuse this parameter and we’d be stuck supporting whatever they pass for the sake of backward compatibility. The <span class="literal">m4_if</span> macro can help us out here. This macro is quite powerful because it accepts an unlimited number of arguments. Here are its basic prototypes:</p>&#13;
<pre>m4_if(<span class="codeitalic1">comment</span>)&#13;
m4_if(<span class="codeitalic1">string-1</span>, <span class="codeitalic1">string-2</span>, <span class="codeitalic1">equal</span>[, <span class="codeitalic1">not-equal</span>])&#13;
m4_if(<span class="codeitalic1">string-1</span>, <span class="codeitalic1">string-2</span>, <span class="codeitalic1">equal-1</span>, <span class="codeitalic1">string-3</span>, <span class="codeitalic1">string-4</span>, <span class="codeitalic1">equal-2</span>,&#13;
    ...[, <span class="codeitalic1">not-equal</span>])</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_448"/>If only one parameter is passed to <span class="literal">m4_if</span>, that parameter is treated as a comment because there’s not much that <span class="literal">m4_if</span> can do with one argument. If three or four arguments are passed, the description I gave for <span class="literal">ifelse</span> in <a href="ch16.xhtml#ch16ex7">Listing 16-7</a> is also accurate for <span class="literal">m4_if</span>. However, if five or more arguments are passed, the fourth and fifth become the comparison strings for a second else-if clause. The last argument in an arbitrarily long set of triples is generated if the last two comparison strings are different.</p>&#13;
<p class="indent">We can use <span class="literal">m4_if</span> to ensure that <span class="literal">quiet</span> is the only acceptable option in the list of options accepted by <span class="literal">FLM_PROG_TRY_DOXYGEN</span>. <a href="ch16.xhtml#ch16ex8">Listing 16-8</a> shows one possible implementation.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
m4_if([$1],,&#13;
[if test -z "$DOXYGEN"; then&#13;
    AC_MSG_WARN([doxygen not found - continuing without Doxygen support])&#13;
fi], [$1], [quiet],, [m4_fatal([Invalid option in FLM_PROG_TRY_DOXYGEN])])&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch16ex8"><em>Listing 16-8: Restricting the argument options allowed by <span class="literal">FLM_PROG_TRY_DOXYGEN</span></em></p>&#13;
<p class="indent">In this case, we want a message to be printed if <span class="literal">doxygen</span> is missing in all cases except when the <span class="literal">quiet</span> option is given as the first argument passed into our macro. In <a href="ch16.xhtml#ch16ex8">Listing 16-8</a>, I’ve given <span class="literal">FLM_PROG_TRY_DOXYGEN</span> the ability to detect cases when something other than <span class="literal">quiet</span> or the empty string is passed in this parameter and to do something specific in response. <a href="ch16.xhtml#ch16ex9">Listing 16-9</a> shows the resulting pseudocode generated by the expansion of <span class="literal">FLM_PROG_TRY_DOXYGEN</span>.</p>&#13;
<pre>if $1 == '' then&#13;
    Generate WARNING if no doxygen program is found&#13;
else if $1 == 'quiet' then&#13;
    Don't generate any messages&#13;
else&#13;
    Generate a fatal "bad parameter" error at autoconf (autoreconf) time&#13;
end</pre>&#13;
<p class="caption" id="ch16ex9"><em>Listing 16-9: Pseudocode for <a href="ch16.xhtml#ch16ex8">Listing 16-8</a>’s use of the <span class="literal">m4_if</span> macro</em></p>&#13;
<p class="indent">Let’s examine exactly what’s going on in <a href="ch16.xhtml#ch16ex8">Listing 16-8</a>. If arguments one (<span class="literal">[$1]</span>) and two (<span class="literal">[]</span>) are the same, a warning message is generated when <span class="literal">doxygen</span> is not found. If arguments four (<span class="literal">[$1]</span>) and five (<span class="literal">[quiet]</span>) are the same, nothing is generated; otherwise, arguments four and five are different, and a fatal error (via <span class="literal">m4_fatal</span>) is generated by Autoconf when it’s executed against the calling <em>configure.ac</em> file. It’s very simple, once you see how it works <em>and</em> once you get the bugs worked out—which brings us nicely to our next topic.</p>&#13;
<h3 class="h3" id="ch16sec5"><span epub:type="pagebreak" id="page_449"/>Diagnosing Problems</h3>&#13;
<p class="noindent">One of the most significant stumbling blocks that people run into at this point is not so much a lack of understanding of how these macros work but a lack of attention to detail. There are several places where things can go wrong when writing even a simple macro like this. For example, you might have any of the following problems:</p>&#13;
<ul>&#13;
<li class="noindent">Space between a macro name and the opening parenthesis</li>&#13;
<li class="noindent">Unbalanced brackets or parentheses</li>&#13;
<li class="noindent">The wrong number of parameters</li>&#13;
<li class="noindent">A misspelled macro name</li>&#13;
<li class="noindent">Incorrectly quoted arguments to a macro</li>&#13;
<li class="noindent">A missing comma in a macro’s parameter list</li>&#13;
</ul>&#13;
<p class="indent">M4 is rather unforgiving of such mistakes. Worse, its error messages can be even more cryptic than those of <span class="literal">make</span>.<sup><a id="ch16fn_9" href="footnote.xhtml#ch16fn9">9</a></sup> If you get strange errors and you think your macro should be working, your best diagnostic method is to scan the definition very carefully looking for the preceding conditions. These mistakes are easy to make, and in the end most problems come down to some combination of them.</p>&#13;
<p class="indent">Another very useful debugging tool is the <span class="literal">m4_traceon</span> and <span class="literal">m4_traceoff</span> macro pair. The macro signatures are as follows:</p>&#13;
<pre>m4_traceon([<span class="codeitalic1">name</span>, ...])&#13;
m4_traceoff([<span class="codeitalic1">name</span>, ...])</pre>&#13;
<p class="indent">All arguments are optional. When given, the arguments should be a comma-separated list of macro names you’d like M4 to print to the output stream as these names are encountered in the input stream. If you omit the arguments, M4 will print the name of every macro it expands.</p>&#13;
<p class="indent">A typical trace session in M4 looks something like this:</p>&#13;
<pre>   $ <span class="codestrong1">m4</span>&#13;
   <span class="codestrong1">define(`abc', `def')dnl</span>&#13;
   <span class="codestrong1">define(`def', `ghi')dnl</span>&#13;
   <span class="codestrong1">traceon(`abc', `def')dnl</span>&#13;
   <span class="codestrong1">abc</span>&#13;
<span class="ent">➊</span> m4trace: -1- abc&#13;
   m4trace: -1- def&#13;
<span epub:type="pagebreak" id="page_450"/>   ghi&#13;
   <span class="codestrong1">traceoff(`abc', `def')dnl</span>&#13;
<span class="ent">➋</span> m4trace: -1- traceoff&#13;
   <span class="codestrong1">&lt;ctrl-d&gt;</span>$</pre>&#13;
<p class="indent">The number between dashes in the output lines at <span class="ent">➊</span> and <span class="ent">➋</span> indicates the nesting level, which is usually 1. The value of the trace facility is that you can easily see when the traced macros are expanded within the context of the output text generated. The M4 tracing facility can also be enabled from the command line with the <span class="literal">-t</span> or <span class="literal">--trace</span> option:</p>&#13;
<pre>$ <span class="codestrong1">m4 --trace=abc</span></pre>&#13;
<p class="indent">Or more appropriately for this discussion:</p>&#13;
<pre>$ <span class="codestrong1">autoconf --trace=FLM_PROG_TRY_DOXYGEN</span></pre>&#13;
<p class="indent">The latter has the added benefit of allowing you to specify a format for the trace output. For more insight into the use of the format portion of the option, try entering <span class="literal">autom4te --help</span> at the command prompt. For more information on the use of the M4 trace options, refer to <a href="ch07.xhtml">Chapter 7</a> (specifically, Section 7.2) of the <em>GNU M4 Manual</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The Autotools rely heavily on tracing for more than just debugging. Various of the Autotools and their supporting utilities use traces on</em> configure.ac <em>to gather information used in other stages of the configuration process. (Recall the 100+ trace options on the</em> m4 <em>command line.) For more information on tracing within Autoconf, refer to Section 3.4 of the</em> GNU Autoconf Manual, <em>titled “Using <em><span class="literal">autoconf</span></em> to Create <em><span class="literal">configure</span></em>.”</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch16sec6">Summary</h3>&#13;
<p class="noindent">Using M4 is deceptively complex. On the surface it appears simple, but as you get deeper into it, you find ways of using it that almost defy comprehension. Nonetheless, the complexities are not insurmountable. As you become proficient with M4, you’ll find that your way of thinking about certain problems changes. It’s worth gaining some M4 proficiency for that reason alone. It’s like adding a new tool to your software-engineering toolbox.</p>&#13;
<p class="indent">A powerful M4 concept I did not cover, but that you should be aware of, is <em>iteration</em>. Normally, we think of iteration in terms of loops, but M4 has no actual looping constructs. Rather, iteration is managed through recursion. For details, refer to the manual’s discussion of the <span class="literal">forloop</span> and <span class="literal">foreach</span> macros.</p>&#13;
<p class="indent">Because the very foundation of Autoconf is M4, becoming proficient with M4 will give you more insight into Autoconf than you might think. The more about M4 you know, the more about Autoconf you’ll understand at a glance.</p>&#13;
</body></html>