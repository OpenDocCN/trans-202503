- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 4 RECONNAISSANCE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every hacking engagement starts with some form of information gathering. In
    this chapter, we’ll perform reconnaissance on targets by writing bash scripts
    to run various hacking tools. You’ll learn how to use bash to automate tasks and
    chain multiple tools into a single workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the process, you’ll develop an important bash-scripting skill: parsing the
    output of various tools to extract only the information you need. Your scripts
    will interact with tools that figure out what hosts are online, what ports are
    open on those hosts, and what services they are running, then deliver this information
    to you in the format you require.'
  prefs: []
  type: TYPE_NORMAL
- en: Perform all hacking activities in your Kali environment against the vulnerable
    network you set up in [Chapter 3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Reusable Target Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *scope* is a list of systems or resources you’re allowed to target. In penetration
    testing or bug-hunting engagements, the target company might provide you with
    various types of scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: Individual IP addresses, such as 172.16.10.1 and 172.16.10.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networks, such as 172.16.10.0/24 and 172.16.10.1–172.16.10.254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual domain names, such as *lab.example.com*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A parent domain name and all its subdomains, such as **.example.com*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with tools such as port and vulnerability scanners, you’ll often
    need to run the same type of scan against all hosts in your scope. This can be
    hard to do efficiently, however, as each tool uses its own syntax. For instance,
    one tool might allow you to specify an input file containing a list of targets,
    while other tools may require individual addresses.
  prefs: []
  type: TYPE_NORMAL
- en: When working with tools that don’t let you provide a wide range of targets,
    you can use bash to automate this process. In this section, we’ll use bash to
    create IP- and DNS-based target lists that you could feed to scanners.
  prefs: []
  type: TYPE_NORMAL
- en: Consecutive IP Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine that you need to create a file containing a list of IP addresses from
    172.16.10.1 to 172.16.10.254\. While you could write all 254 addresses by hand,
    this would be time-consuming. Let’s use bash to automate the job! We’ll consider
    three strategies: using the seq command in a for loop, using brace expansion with
    echo, and using brace expansion with printf.'
  prefs: []
  type: TYPE_NORMAL
- en: In the for loop shown in [Listing 4-1](chapter4.xhtml#Lis4-1), we use seq to
    iterate through numbers ranging from 1 to 254 and assign each number to the ip
    variable. After each iteration, we use echo to write the IP address to a dedicated
    file on disk, *172-16-10-hosts.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: Creating a list of IP addresses with the seq command and a for
    loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run this code directly from the command line or save it in a script
    and then run it. The generated file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As in most cases, you can use multiple approaches to achieve the same task in
    bash. We can generate the IP address list by using a simple echo command, without
    running any loops. In [Listing 4-2](chapter4.xhtml#Lis4-2), we use echo with brace
    expansion to generate the strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: Performing brace expansion with echo'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that this command outputs a list of IP addresses on a single line,
    separated by spaces. This isn’t ideal, as what we really want is each IP address
    on a separate line. In [Listing 4-3](chapter4.xhtml#Lis4-3), we use sed to replace
    spaces with newline characters (\n).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: Generating a list of IP addresses with echo and sed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the printf command to generate the same list. Using
    printf won’t require piping to sed, producing a cleaner output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The %d is an integer placeholder, which will be swapped with the numbers defined
    in the brace expansion to produce a list of IP addresses from 10.1.0.1 to 10.1.0.254\.
    You can redirect the output to a new file and then use it as an input file.
  prefs: []
  type: TYPE_NORMAL
- en: Possible Subdomains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Say you’re performing a penetration test against a company with the parent domain
    *example.com*. In this engagement, you’re not restricted to any specific IP address
    or domain name, which means that any asset you find on this parent domain during
    the information-gathering stage is considered in scope.
  prefs: []
  type: TYPE_NORMAL
- en: Companies tend to host their services and applications on dedicated subdomains.
    These subdomains can be anything, but more often than not, companies use names
    that make sense to humans and are easy to enter into a web browser. For example,
    you might find the help-desk portal at *helpdesk.example.com*, the monitoring
    system at *monitoring.example.com*, the continuous integration system at *jenkins.example.com*,
    the email server at *mail.example.com*, and the file transfer server at *ftp.example.com*.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we generate a list of possible subdomains for a target? Bash makes
    this easy. First, we’ll need a list of common subdomains. You can find such a
    list built into Kali at */usr/share/wordlists/amass/subdomains-top1mil-110000.txt*
    or */usr/share/wordlists/amass/bitquark_subdomains_top100K.txt*. To look for wordlists
    on the internet, you could use the following Google search query to search for
    files on GitHub provided by community members: **subdomain wordlist site:gist.github.com**.
    This will search GitHub for code snippets (also called *gists*) containing the
    words *subdomain wordlist*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of this example, we’ll use *subdomains-1000.txt*, which is
    included with this chapter’s files in the book’s GitHub repository. Download this
    subdomain list and save it in your home directory. The file contains one subdomain
    per line without an associated parent domain. You’ll have to join each subdomain
    with the target’s parent domain to form a fully qualified domain name. As in the
    previous section, we’ll show multiple strategies for accomplishing this task:
    using a while loop and using sed.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can download this chapter’s resources from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch04](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch04).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-4](chapter4.xhtml#Lis4-4) accepts a parent domain and a wordlist
    from the user, then prints a list of fully qualified subdomains by using the wordlist
    you downloaded earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: Using a while loop to generate a list of subdomains'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script uses a while loop to read the file and assign each line to the subdomain
    variable in turn. The echo command then concatenates these two strings together
    to form a full domain name. Save this script as *generate_subdomains.sh* and provide
    it with two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the parent domain, and the second is the path to the file
    containing all possible subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: We can use sed to write content to the end of each line in a file. In [Listing
    4-5](chapter4.xhtml#Lis4-5), the command uses the $ sign to find the end of a
    line, then replace it with the target domain prefixed with a dot (*.example.com*)
    to complete the domain name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: Using sed to generate a list of subdomains'
  prefs: []
  type: TYPE_NORMAL
- en: The s at the beginning of the argument to sed stands for *substitute*, and g
    means that sed will replace all matches in the file, not just the first match.
    So, in simple terms, we substitute the end of each line in the file with *.example.com*.
    If you save this code to a script, the output should look the same as in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Host Discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing a range of addresses, one of the first things you’ll likely want
    to do is find out information about them. Do they have any open ports? What services
    are behind those ports, and are they vulnerable to any security flaws? Answering
    these questions manually is possible, but this can be challenging if you need
    to do it for hundreds or thousands of hosts. Let’s use bash to automate network
    enumeration tasks.
  prefs: []
  type: TYPE_NORMAL
- en: One way to identify live hosts is by attempting to send them network packets
    and wait for them to return responses. In this section, we’ll use bash and additional
    network utilities to perform host discovery.
  prefs: []
  type: TYPE_NORMAL
- en: ping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At its most basic form, the ping command takes one argument: a target IP address
    or domain name. Run the following command to see its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The ping command will run forever, so press CTRL-C to stop its execution.
  prefs: []
  type: TYPE_NORMAL
- en: If you read the ping manual page (by running man ping), you’ll notice that there
    is no way to run the command against multiple hosts at once. But using bash, we
    can do this quite easily. [Listing 4-6](chapter4.xhtml#Lis4-6) pings all hosts
    on the network 172.16.10.0/24.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-6: Using a while loop to ping multiple hosts'
  prefs: []
  type: TYPE_NORMAL
- en: At ❶, we run a while loop that reads from the file passed to the script on the
    command line. This file is assigned to the variable FILE. We read each line from
    the file and assign it to the host variable. We then run the ping command, using
    the -c argument with a value of 1 at ❷, which tells ping to send a ping request
    only once and exit. By default on Linux, ping sends ping requests indefinitely
    until you stop it manually by sending a SIGHUP signal (CTRL-C).
  prefs: []
  type: TYPE_NORMAL
- en: We also use the arguments -W 1 (to set a timeout in seconds) and -w 1 (to set
    a deadline in seconds) to limit the amount of time ping will wait to receive a
    response. This is important because we don’t want ping to get stuck on an unresponsive
    IP address; we want it to continue reading from the file until all 254 hosts are
    tested.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the standard input stream to read the file and “feed” the while
    loop with its contents ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this code to *multi_host_ping.sh* and run it while passing in the *hosts*
    file. You should see that the code picks up a few live hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The caveat to this host-discovery approach is that certain hosts, especially
    hardened ones, might not reply to ping commands at all. So, if we rely solely
    on this method for discovery, we might miss out on live hosts on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that commands that run forever by default, such as ping, could pose
    a challenge when integrated into a bash script. In this example, we’ve explicitly
    set a few special flags to ensure that our bash script won’t hang when it executes
    ping. This is why it’s important to first test commands in the terminal before
    integrating them into your scripts. More often than not, tools have special options
    to ensure they don’t execute forever, such as timeout options.
  prefs: []
  type: TYPE_NORMAL
- en: For tools that don’t provide a timeout option, the timeout command allows you
    to run commands and exit after a certain amount of time has passed. You can prepend
    timeout to any Linux utility, passing it an interval (in the *seconds, minutes,
    hours* format)—for example, timeout 5s ping 8.8.8.8. After the time has elapsed,
    the entire command exits.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Nmap port scanner has a special option called -sn that performs a *ping
    sweep*. This simple technique finds live hosts on a network by sending them a
    ping command and waiting for a positive response (called a *ping response*). Since
    many operating systems respond to ping by default, this technique has proved valuable.
    The ping sweep in Nmap will essentially make Nmap send Internet Control Message
    Protocol packets over the network to discover running hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This output has a lot of text. With a bit of bash magic, we can get a cleaner
    output by using the grep and awk commands to extract only the IP addresses that
    were identified as being alive ([Listing 4-7](chapter4.xhtml#Lis4-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-7: Parsing Nmap’s ping scan output'
  prefs: []
  type: TYPE_NORMAL
- en: Using Nmap’s built-in ping sweep scan may be more useful than manually wrapping
    the ping utility with bash, because you don’t have to worry about checking for
    conditions such as whether the command was successful. Moreover, in penetration
    tests, you may drop an Nmap binary on more than one type of operating system,
    and the same syntax will work consistently whether the ping utility exists or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: arp-scan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can perform penetration testing remotely, from a different network, or from
    within the same network as the target. In this section, we’ll highlight the use
    of arp-scan as a way to find hosts on a network when the test is done locally.
  prefs: []
  type: TYPE_NORMAL
- en: The arp-scan utility sends Address Resolution Protocol (ARP) packets to hosts
    on a network and displays any responses it gets back. *ARP* maps *media access
    control (MAC)* addresses, which are unique 12-digit hexadecimal addresses assigned
    to network devices, to the IP addresses on a network. Because ARP is a Layer 2
    protocol in the Open Systems Interconnection (OSI) model, it is useful only when
    you’re on a local network; ARP can’t be used to perform a remote scan over the
    internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that arp-scan requires root privileges to run; this is because it uses
    functions to read and write packets that require elevated privileges. At its most
    basic form, you can run it by executing the arp-scan command and passing a single
    IP address as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We also need to tell arp-scan which network interface to send packets on, as
    Kali has a few network interfaces. To achieve this, we use the -I argument. The
    br_public interface corresponds to the 172.16.10.0/24 network in the lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'To scan entire networks, you can pass arp-scan a CIDR range, such as */24*.
    For example, the following command scans all IP addresses from 172.16.10.1 to
    172.16.10.254:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use the hosts file you created in “Consecutive IP Addresses”
    on [page 70](#pg_70) as input to arp-scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output generated by arp-scan should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This output consists of three fields: the IP address, the MAC address, and
    vendor details, identified by the first three octets of the MAC address. In this
    scan, the tool identified four hosts on the network that responded to ARP packets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Receiving Alerts About New Hosts'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you want to be notified whenever a new host appears on the network.
    For example, maybe you want to know when new laptops or IT assets have connected.
    This could be useful if you’re testing a target in a different time zone, where
    device users might not be online when you are.
  prefs: []
  type: TYPE_NORMAL
- en: You can use bash to send yourself an email whenever your script discovers new
    assets. [Listing 4-9](chapter4.xhtml#Lis4-9) runs a continuous scan to identify
    new online hosts, adds these to the *172-16-10-hosts.txt* file created in “Consecutive
    IP Addresses” on [page 70](#pg_70), and notifies you of the discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Because this script is more involved than the previous ones, we’ll walk through
    an example solution ([Listing 4-8](chapter4.xhtml#Lis4-8)), then discuss ways
    to improve it on your own.
  prefs: []
  type: TYPE_NORMAL
- en: host_monitor _notification.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-8: Using sendemail to receive notifications about new arp-scan discoveries'
  prefs: []
  type: TYPE_NORMAL
- en: First, we set a few variables. We assign the file containing the hosts to look
    for, *172-16-10-hosts.txt*, to the KNOWN_HOSTS variable, and the target network
    172.16.10.0/24 to the NETWORK variable. We also set the FROM_ADDR and TO_ADDR
    variables, which we’ll use to send the notification email.
  prefs: []
  type: TYPE_NORMAL
- en: We then use while to run an infinite loop ❶. This loop won’t end unless we intentionally
    break out of it. Within the loop, we run arp-scan with the options -x to display
    a plain output (so it’s easier to parse) and -I to define the network interface
    br_public ❷. In the same line, we use a while read loop to iterate through the
    output of arp-scan. We use awk to parse each IP address in the output and assign
    it to the host variable ❸.
  prefs: []
  type: TYPE_NORMAL
- en: At ❹, we use an if condition to check whether the host variable (which represents
    a host discovered by arp-scan) exists in our *hosts* file. If it does, we don’t
    do anything, but if it doesn’t, we write it to the file ❺ and send an email notification
    ❻ by using the sendemail command. Notice that each line in the sendemail command
    ends with a backslash (\). When lines are long, bash allows us to separate them
    in this way while still treating them as a single command. Breaking long code
    lines makes them easier to read. At the end of this process, we use sleep 10 to
    wait 10 seconds before running this discovery again.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this script, you should receive an email whenever a new host is discovered.
    To properly send email messages, you’ll need to configure a mail transfer agent
    such as Postfix on the system. Refer to the documentation at *[https://www.postfix.org/documentation.html](https://www.postfix.org/documentation.html)*
    for more information on doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the continuous network probing the script performs isn’t very stealthy.
    To probe the network more covertly, try modifying the script in one of the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Slow the probing so it triggers every few hours or after an arbitrary number
    of minutes. You can even randomize this interval to make it less predictable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of sending notifications over the network, try writing the results to
    memory if you’re running the script from within a compromised network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload the results to an innocent-looking third-party website. The Living Off
    Trusted Sites (LOTS) Project at *[https://lots-project.com](https://lots-project.com)*
    maintains an inventory of legitimate websites that corporate networks often allow.
    Attackers commonly use these to carry out activities such as data exfiltration
    so that their traffic blends with other legitimate traffic, making it harder for
    analysts to spot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know the hosts available on the 172.16.10.0/24 network, we recommend
    removing any unresponsive IP addresses from the *172-16-10-hosts.txt* file to
    make your future scans faster.
  prefs: []
  type: TYPE_NORMAL
- en: To go even further, we encourage you to experiment with other notification delivery
    methods, such as Slack, Discord, Microsoft Teams, or any other messaging system
    you use on a daily basis. Platforms such as Slack, for example, use a *webhook*,
    which enables a script to make an HTTP POST request to a special uniform resource
    locator (URL) to deliver a custom message to a channel of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Port Scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you’ve discovered hosts on the network, you can run a port scanner to
    find their open ports and the services they’re running. Let’s explore port scanning
    by using three tools: Nmap, RustScan, and Netcat.'
  prefs: []
  type: TYPE_NORMAL
- en: Nmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nmap allows us to perform port scanning against single targets or multiple
    targets at the same time. In the following example, we use Nmap to perform a port
    scan of the domain *scanme.nmap.org*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Nmap also accepts IP addresses, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we provide Nmap with no special options on the command line, it will use
    the following default settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Perform a SYN scan **Nmap will use a synchronization (SYN) scan to discover
    open ports on a target. Also called a *half-open scan*, a *SYN scan* involves
    sending a SYN packet and waiting for a response. Nmap won’t complete the full
    TCP handshake (meaning ACK won’t be sent back), which is why we call this scan
    *half open*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scan the top 1,000 ports **Nmap will scan only popular ports known to be
    frequently in use, such as TCP ports 21, 22, 80, and 443\. It won’t scan the entire
    port range of 0–65,534, to conserve resources.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scan TCP ports **Nmap will scan only TCP ports, not User Datagram Protocol
    (UDP) ports.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nmap allows you to scan multiple targets by passing them on the command line.
    In the following example, we scan both *localhost* and *scanme.nmap.org*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Nmap can also read targets from a given file when passed the -iL option. The
    targets must be separated by newlines. Let’s use the *172-16-10-hosts.txt* file
    with Nmap to scan multiple targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This scan may take some time to complete because of the use of the -sV option,
    which detects the version of services on each port. As you can see, Nmap returns
    a few IP addresses and their open ports, including their services and even information
    related to the operating system running on the host. If we wanted to filter, say,
    only the open ports, we could do by using grep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Nmap is able to identify services on several open TCP ports, such as the File
    Transfer Protocol (FTP) on port 21, Secure Shell (SSH) on port 22, and HTTP on
    port 80\. Later in this chapter, we’ll take a closer look at each of these services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nmap also allows you to pass the --open flag on the command line to show only
    the ports that were found open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Kali’s own interface IP (172.16.10.1) will be captured in this port scan, since
    it is part of the hosts file. You can use Nmap’s --exclude option to exclude this
    specific IP when performing a network-wide scan: --exclude 172.16.10.1. You can
    also remove it manually from the file for convenience.'
  prefs: []
  type: TYPE_NORMAL
- en: Use man nmap to learn more about Nmap’s scanning and filtering capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: RustScan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RustScan is becoming more popular in the bug-bounty and penetration-testing
    spaces because of its speed and extensibility. The following rustscan command
    runs a port scan. The -a (address) argument accepts a single address or an address
    range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: RustScan’s output is fairly easy to parse with bash. Lines starting with Open
    indicate that an open port was found on a specific IP address. These are followed
    by the IP address and port, separated by a colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run RustScan, you may notice that the initial output contains banners,
    author credits, and additional information not directly related to the scan results.
    Use the -g (greppable) option to show only the scanning information. The following
    command uses the greppable output mode to scan 172.16.10.0/24 on the first 1,024
    ports (also called *privileged ports*) with the -r (range) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the output is more grep friendly. To parse it, all we need to do is pass
    the delimiter ->, which separates the IP address and port, with awk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This command outputs two fields: the IP address and the port. To get rid of
    the [] surrounding the port number, we use the tr command and the -d (delete)
    argument followed by the characters to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This should return a cleaner output.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Remember that running port scanners in aggressive modes increases the chances
    of getting caught, especially if the target implements an intrusion detection
    system or endpoint detection and response system. Also, if you scan at a rapid
    pace, you may cause a denial of service as a result of the network flood.*'
  prefs: []
  type: TYPE_NORMAL
- en: Netcat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use Netcat for port scanning activities. People often use this
    tool when they want to check the state of a single port (such as whether it’s
    open or closed), but Netcat also enables you to scan multiple ports with a single
    command. Let’s see how this can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to scan TCP ports 1–1024 on 172.16.10.11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use nc with the -z flag (zero input/output, or I/O, mode, which won’t send
    any data) and the -v (verbose) flag, followed by the target IP and the port range
    separated by a hyphen (-). As you can see in the output, two ports were found
    open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Organizing Scan Results'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting your scan results into categories of interest is often useful. For
    example, you could dump results for each IP address into a dedicated file or organize
    the results based on the versions of the software found. In this exercise, you’ll
    organize your scan results based on port numbers. Write a script that does the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Runs Nmap against hosts in a file
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Uses bash to create individual files whose filenames are open ports
  prefs: []
  type: TYPE_NORMAL
- en: 3.  In each file, writes the IP address on which the corresponding port was
    open
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this exercise, you should have a bunch of files, such as *port-22.txt*,
    *port-80.txt*, and *port-8080.txt*, and in each file, you should see one or more
    IP addresses at which that port was found to be open. This can be useful when
    you have a large number of target hosts and want to attack them in clusters by
    targeting specific protocols associated with given ports.
  prefs: []
  type: TYPE_NORMAL
- en: To get you started, [Listing 4-9](chapter4.xhtml#Lis4-9) shows an example solution.
  prefs: []
  type: TYPE_NORMAL
- en: nmap_to _portfiles.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-9: Using bash to organize scan results by port'
  prefs: []
  type: TYPE_NORMAL
- en: We assign the output of the nmap command to the variable NMAP_RESULT ❶. In this
    command, we also filter for specific lines containing the words Nmap scan report
    or tcp open. These lines are part of Nmap’s standard port scan output, and they
    indicate that open ports were found on an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: We use a while loop to read NMAP_RESULT line by line, checking whether each
    line contains the string report for ❷. This line will hold the IP address where
    ports are found open. If such a line exists, we assign it to the ip variable.
    Then we parse the line to extract the port that is found open ❸. At ❹, we create
    the file variable to hold the file we’ll create on disk with the naming scheme
    *port-NUMBER.txt*. Finally, we append the IP address to the file ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script to a file named *nmap_to_portfiles.sh* and run it. Next, run
    ls -l to see what files were created, and use cat to view their contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you’ve seen, Nmap’s standard output format is a little challenging to parse
    but not impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the script shown here, consider using one of Nmap’s additional output
    format options, which can make parsing easier, especially for scripting purposes.
    One of these options is the -oG flag, for the greppable output format, which is
    grep and awk friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The output now prints the IP address and its open ports on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also tell Nmap to generate Extensible Markup Language (XML) output
    by using the -oX option. Open ports in an XML Nmap output look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As an extra challenge, try putting together a one-liner bash script that extracts
    the open ports from XML output.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting New Open Ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if you want to monitor a host until it opens a certain port? You may find
    this useful if you’re testing an environment in which hosts come up and down frequently.
    We can do this quite easily with a while loop.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 4-10](chapter4.xhtml#Lis4-10), we continuously check whether a port
    is open, waiting five seconds between each execution. Once we find an open port,
    we pass this information to Nmap to perform a service discovery and write the
    output to a file.
  prefs: []
  type: TYPE_NORMAL
- en: port _watchdog.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-10: A watchdog script for newly opened ports'
  prefs: []
  type: TYPE_NORMAL
- en: At ❷, we start an infinite while loop. The loop runs RustScan, passing it the
    -a (address) argument containing an IP address we receive on the command line
    ❸. We also pass RustScan the -g (greppable) option to produce a format that is
    grep friendly, and the port option (-p) to scan a particular port, which we also
    receive on the command line and assign the result to the port_scan variable.
  prefs: []
  type: TYPE_NORMAL
- en: We check the result of the scan ❹. If the result is not empty, we pass the IP
    address and the port to the service_discovery function ❺, which does an Nmap service-version
    discovery scan (-sV) and writes the result to the logfile *watchdog.log* ❶. If
    the port scan fails, which means the port is closed, we sleep for five seconds
    ❻. As a result, the process will repeat every five seconds until the port is found
    open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script and then run it with the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since nothing should be running on this port of your localhost, the script
    should run forever. We can simulate a port-opening event by using Python’s built-in
    *http.server* module, which starts a simple HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the *port_watchdog.sh* script should show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the results of the scan by opening the *watchdog.log* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this script, you should be able to identify four IP addresses on the
    network with open ports: 172.16.10.10 (belonging to the *p-web-01* machine) running
    8081/TCP; 172.16.10.11 (belonging to the *p-ftp-01* machine) running both 21/TCP
    and 80/TCP; 172.16.10.12 (belonging to the *p-web-02* machine) running 80/TCP;
    and 172.16.10.13 (belonging to the *p-jumpbox-01* machine) running 22/TCP.'
  prefs: []
  type: TYPE_NORMAL
- en: Banner Grabbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learning about the software running on a remote server is a crucial step in
    a penetration test. In the remainder of this chapter, we’ll look at how to identify
    what’s behind a port and a service—for example, what web server is running on
    port 8081, and what technologies does it use to serve content to clients?
  prefs: []
  type: TYPE_NORMAL
- en: '*Banner grabbing* is the process of extracting the information published by
    remote network services when a connection is established between two parties.
    Services often transmit these banners to “greet” clients, which can use the information
    provided in various ways, such as to ensure they’re connecting to the right target.
    Banners could also include a system admin message of the day or the service’s
    specific running version.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Passive banner grabbing* uses third-party websites to look up banner information.
    For example, websites such as Shodan (*[https://shodan.io](https://shodan.io)*),
    ZoomEye (*[https://zoomeye.org](https://zoomeye.org)*), and Censys (*[https://censys.io](https://censys.io)*)
    perform scans to map the internet, grabbing banners, versions, website pages,
    and ports, then create an inventory using this data. We can use such websites
    to look up banner information without ever interacting with the target server
    ourselves.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Active banner grabbing* is the opposite; it establishes a connection to a
    server and interacts with it directly to receive its banner information. Examples
    of network services that tend to advertise themselves by using banners include
    web servers, SSH servers, FTP servers, Telnet servers, network printers, Internet
    of Things devices, and message queues.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that banners are generally free-form text fields, and they can
    be changed to mislead clients. For example, an Apache web server could present
    itself as another type of web server, such as nginx. Some organizations even create
    *honeypot servers* to lure threat actors (or penetration testers). Honeypots use
    deception technologies to masquerade as vulnerable servers, but their real purpose
    is to detect and analyze attacker activity. More often than not, however, banners
    transmit default settings that system administrators haven’t bothered to change.
  prefs: []
  type: TYPE_NORMAL
- en: Using Active Banner Grabbing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate what active banner grabbing looks like, we’ll use the following
    Netcat command to connect to port 21 (FTP) running on IP address 172.16.10.11
    (*p-ftp-01*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, 172.16.10.11 is running the FTP server vsFTPd version 3.0.5\.
    This information may change if the vsFTPd version gets upgraded or downgraded,
    or if the system administrator decides to disable banner advertisement completely
    in the FTP server’s configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Netcat is a good example of a tool that doesn’t natively support probing multiple
    IP addresses. So, knowing a bit of bash scripting can help us out here. [Listing
    4-11](chapter4.xhtml#Lis4-11) will use Netcat to grab banners on port 21 from
    multiple hosts saved in a file.
  prefs: []
  type: TYPE_NORMAL
- en: netcat_banner _grab.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-11: Banner grabbing using Netcat'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script accepts two parameters on the command line: FILE and PORT. We use
    an if condition to check whether two arguments were indeed passed on the command
    line ❶; if not, we exit with a status code of 1 (fail) and print a usage message
    indicating how to run the script. We then use another if condition with the -f
    test to check whether the file provided by the user actually exists on disk ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: At ❸, we check that the port provided by the user is a number. Anything other
    than a number will fail. Then we read the host file line by line and run the nc
    (Netcat) command on the given port for each ❹. We use another if condition to
    check whether the command result is not empty ❺, meaning a port was found open,
    and print the IP address and data that returned from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting HTTP Responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll often find the popular curl HTTP client on production systems. To perform
    banner grabbing on HTTP responses, we can use curl to send an HTTP request using
    the HEAD method. The HEAD method allows us to read response headers without fetching
    the entire response payload from the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web servers often advertise themselves by setting the Server HTTP response
    header to their name. Sometimes you may also encounter the running version advertised
    there. The following curl command sends an HTTP HEAD request to the *p-web-01*
    machine (172.16.10.10:8081):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the server returns a bunch of headers in the response, one of
    which is the Server header. This header reveals that the remote server is running
    a Python-based web framework named Werkzeug version 2.2.3, powered by Python version
    3.11.1.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-12](chapter4.xhtml#Lis4-12) incorporates this curl command into
    a larger script that prompts the user for information with the bash read command,
    then presents the user with a banner.'
  prefs: []
  type: TYPE_NORMAL
- en: curl_banner _grab.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-12: Extracting the server response header from web servers'
  prefs: []
  type: TYPE_NORMAL
- en: This interactive script asks the user to provide details about the target on
    the command line. First, we use the read command to prompt the user to enter an
    IP address and assign this value to the ip_address variable ❶. We then ask the
    user for the desired port number and save that to the port variable ❷.
  prefs: []
  type: TYPE_NORMAL
- en: At ❸, we check whether the ip_address variable length is zero by using the -z
    test and exit if this condition is true. Next, we do the same check on the port
    variable ❹. This time, if the user didn’t provide a port, we use the default HTTP
    port, 80 ❺. At ❻, we store the output to the result variable. We use grep and
    awk to parse the result of curl and extract the Server header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script, and when prompted, provide the IP address 172.16.10.10 and
    port 8081:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script returns the correct information from the target IP
    address and port. If we didn’t specify a port in the terminal, it would have defaulted
    to port 80\. Note that we could have used Netcat to send HTTP HEAD requests too,
    but it’s useful to know more than one method to achieve a given task.
  prefs: []
  type: TYPE_NORMAL
- en: Using Nmap Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nmap is more than just a port scanner; we can transform it into a full-fledged
    vulnerability assessment tool. The *Nmap Scripting Engine (NSE)* allows penetration
    testers to write scripts in the Lua language to extend Nmap’s capabilities. Nmap
    comes preinstalled with some Lua scripts, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The *banner.nse* script in the */usr/share/nmap/scripts* folder allows you
    to grab the banners from many hosts simultaneously. The following bash command
    uses this script to perform a banner grab and service discovery (-sV):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When the banner-grabbing script finds a banner, the output line containing
    that banner will begin with a special character sequence (|_). We can filter for
    this sequence to extract banner information, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that, in the case of 172.16.10.10 port 8081 (the *p-web-01*
    machine), Nmap responds with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The blackice-icecap? value indicates that Nmap is unable to definitively discover
    the identity of the service. But if you look closely at the fingerprint -strings
    dump, you’ll see some HTTP-related information that reveals the same response
    headers we found when banner grabbing manually using curl. Specifically, note
    the Werkzeug web server banner. With a bit of googling, you’ll find that this
    server runs on Flask, a Python-based web framework.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Operating Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nmap can also guess the target server’s running operating system by using *TCP/IP
    fingerprinting*, which is part of its operating system detection scan. This technique
    identifies the implementation of the operating system’s TCP/IP stack by crafting
    packets in various ways and analyzing the returned responses. Each operating system
    (such as Linux, Windows, and macOS) implements the TCP/IP stack slightly differently,
    and Nmap analyzes these subtle differences to identify the running system. In
    some cases, Nmap may also be able to identify the running kernel version.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run an operating system detection scan, use the -O flag in Nmap. Note that
    this scan requires sudo privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Let’s create a bash script that can parse this output and sort it by IP address
    and operating system ([Listing 4-13](chapter4.xhtml#Lis4-13)).
  prefs: []
  type: TYPE_NORMAL
- en: os_detection.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-13: Parsing an operating system detection scan'
  prefs: []
  type: TYPE_NORMAL
- en: Because this scan requires root privileges, we check for the effective user’s
    ID ❶. If the user ID isn’t equal to zero, we exit because there is no point in
    continuing if the user isn’t using root privileges. We then check whether the
    user passed target hosts as arguments on the command line ❷. At ❸, we run the
    Nmap operating system detection scan against these targets, which we’ve assigned
    to the HOSTS variable.
  prefs: []
  type: TYPE_NORMAL
- en: We use a while loop ❹ to iterate through the scan results, parsing each line
    and assigning the IP address in the output to the ip variable. We then parse the
    line a second time to extract the operating system information from Nmap. We use
    sed to clean the output so it shows only the operating system, removing everything
    after the word Seq. Next, we check whether both the ip and os variables are set
    ❺. If they are, this means we’ve parsed the output correctly and can finish the
    script by printing the IP address and the operating system type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why we parse the output the way we do, using grep, awk and sed,
    run the following command in a separate terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the output is separated by whitespaces. The IP address is found
    immediately after the first space, and the operating system type comes after the
    word OS: but before the word Seq, which is why we needed to extract the text between
    these two. You can do this parsing in other ways too, such as with regular expressions;
    this is just one way of achieving the task.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to save and run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we’ve identified a couple of HTTP servers, an FTP server, and
    an SSH server. Let’s take a closer look at the HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Websites and JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use WhatWeb to see the services running on the web applications in the
    172.16.10.0/24 network. We’ll begin by looking at 172.16.10.10 (*p-web-01*) on
    port 8081:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: WhatWeb’s output is printed to standard output by default, separated by spaces
    and commas. As you can see, it found some information about the technology running
    on this web server.
  prefs: []
  type: TYPE_NORMAL
- en: We could parse this output quite easily with tools such as awk and grep, but
    to introduce you to new techniques, we’ll instead explore how to parse *JavaScript
    Object Notation (JSON)* output. JSON is a data format composed of keys and values.
    To parse it, it’s helpful to use a tool like jq to traverse the JSON structure
    and extract the information we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'WhatWeb can format the output in JSON with the --log-json parameter, which
    expects a filename passed as its value. But what if we want to send the output
    to the screen without writing it to the disk? We can provide the parameter with
    the */dev/stdout* file, forcing it to send its output to standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now the output is printed to standard output and formatted in JSON. As you can
    see, we get the same information as when we ran the basic whatweb command, without
    the special formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is an array of objects, and we can use a tool such as jq to extract
    the relevant information. For example, let’s extract the value of HTTPServer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The jq syntax might seem a little odd at first, so let’s dissect it. We place
    the pattern to extract between two single quotes ('). Here, we select the first
    element in the array (.[0]), which contains various objects composed of keys and
    values. Then we select the plugins key, followed by the HTTPServer key. Within
    the HTTPServer key, there is another key named string, which is an array. We select
    the first element in that array by using string[0], which holds the value Werkzeug/2.3.7
    Python/3.11.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can extract the IP address. Just swap the HTTPServer key with
    the IP key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and run WhatWeb against every web server we’ve identified to see the
    technologies they run.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we put bash to use in many ways. We created dynamic target
    host lists; used multiple tools to perform host discovery, port scanning, and
    banner grabbing; created an automated script to notify us of newly discovered
    hosts; and parsed various tool results. In the next chapter, we’ll run vulnerability
    scanners and fuzzers against these targets.
  prefs: []
  type: TYPE_NORMAL
