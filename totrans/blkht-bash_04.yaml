- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 4 RECONNAISSANCE
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 侦察
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Every hacking engagement starts with some form of information gathering. In
    this chapter, we’ll perform reconnaissance on targets by writing bash scripts
    to run various hacking tools. You’ll learn how to use bash to automate tasks and
    chain multiple tools into a single workflow.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每次黑客攻击活动都始于某种形式的信息收集。在本章中，我们将通过编写 bash 脚本来对目标进行侦察，运行各种黑客工具。你将学习如何使用 bash 自动化任务，并将多个工具串联成一个工作流。
- en: 'In the process, you’ll develop an important bash-scripting skill: parsing the
    output of various tools to extract only the information you need. Your scripts
    will interact with tools that figure out what hosts are online, what ports are
    open on those hosts, and what services they are running, then deliver this information
    to you in the format you require.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你将发展出一项重要的 bash 脚本技能：解析各种工具的输出，提取你需要的信息。你的脚本将与工具进行交互，确定哪些主机在线，哪些主机的端口是开放的，运行了哪些服务，然后以你要求的格式将这些信息传递给你。
- en: Perform all hacking activities in your Kali environment against the vulnerable
    network you set up in [Chapter 3](chapter3.xhtml).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](chapter3.xhtml) 中设置的易受攻击的网络上，所有黑客活动都应在 Kali 环境中进行。
- en: Creating Reusable Target Lists
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可重用的目标列表
- en: 'A *scope* is a list of systems or resources you’re allowed to target. In penetration
    testing or bug-hunting engagements, the target company might provide you with
    various types of scopes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围* 是你被允许攻击的系统或资源列表。在渗透测试或漏洞挖掘活动中，目标公司可能会向你提供各种类型的范围：'
- en: Individual IP addresses, such as 172.16.10.1 and 172.16.10.2
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立的 IP 地址，如 172.16.10.1 和 172.16.10.2
- en: Networks, such as 172.16.10.0/24 and 172.16.10.1–172.16.10.254
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络，如 172.16.10.0/24 和 172.16.10.1–172.16.10.254
- en: Individual domain names, such as *lab.example.com*
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立的域名，如 *lab.example.com*
- en: A parent domain name and all its subdomains, such as **.example.com*
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个父域名及其所有子域名，如 **.example.com*
- en: When working with tools such as port and vulnerability scanners, you’ll often
    need to run the same type of scan against all hosts in your scope. This can be
    hard to do efficiently, however, as each tool uses its own syntax. For instance,
    one tool might allow you to specify an input file containing a list of targets,
    while other tools may require individual addresses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用如端口和漏洞扫描器等工具时，你通常需要对你范围内的所有主机进行相同类型的扫描。然而，由于每个工具使用不同的语法，这可能很难高效完成。例如，一个工具可能允许你指定一个包含目标列表的输入文件，而其他工具可能需要单独的地址。
- en: When working with tools that don’t let you provide a wide range of targets,
    you can use bash to automate this process. In this section, we’ll use bash to
    create IP- and DNS-based target lists that you could feed to scanners.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一些不允许你提供广泛目标范围的工具时，你可以使用 bash 来自动化这个过程。在本节中，我们将使用 bash 创建基于 IP 和 DNS 的目标列表，供扫描工具使用。
- en: Consecutive IP Addresses
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连续的 IP 地址
- en: 'Imagine that you need to create a file containing a list of IP addresses from
    172.16.10.1 to 172.16.10.254\. While you could write all 254 addresses by hand,
    this would be time-consuming. Let’s use bash to automate the job! We’ll consider
    three strategies: using the seq command in a for loop, using brace expansion with
    echo, and using brace expansion with printf.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要创建一个包含从 172.16.10.1 到 172.16.10.254 的 IP 地址列表的文件。虽然你可以手动写下所有 254 个地址，但这会非常耗时。让我们使用
    bash 来自动化这个任务！我们将考虑三种策略：在 for 循环中使用 seq 命令，使用 echo 的花括号扩展，以及使用 printf 的花括号扩展。
- en: In the for loop shown in [Listing 4-1](chapter4.xhtml#Lis4-1), we use seq to
    iterate through numbers ranging from 1 to 254 and assign each number to the ip
    variable. After each iteration, we use echo to write the IP address to a dedicated
    file on disk, *172-16-10-hosts.txt*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4-1](chapter4.xhtml#Lis4-1) 中显示的 for 循环中，我们使用 seq 来遍历从 1 到 254 的数字，并将每个数字分配给
    ip 变量。每次迭代后，我们使用 echo 将 IP 地址写入磁盘上的专用文件 *172-16-10-hosts.txt*。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: Creating a list of IP addresses with the seq command and a for
    loop'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：使用 seq 命令和 for 循环创建 IP 地址列表
- en: 'You can run this code directly from the command line or save it in a script
    and then run it. The generated file should look like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接从命令行运行这段代码，或者将其保存在脚本中再运行。生成的文件应该如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As in most cases, you can use multiple approaches to achieve the same task in
    bash. We can generate the IP address list by using a simple echo command, without
    running any loops. In [Listing 4-2](chapter4.xhtml#Lis4-2), we use echo with brace
    expansion to generate the strings.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数情况一样，您可以在 bash 中使用多种方法来完成相同的任务。我们可以使用简单的 echo 命令生成 IP 地址列表，而不需要运行任何循环。在
    [列表 4-2](chapter4.xhtml#Lis4-2) 中，我们使用 echo 与大括号展开生成字符串。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-2: Performing brace expansion with echo'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-2：使用 echo 执行大括号展开
- en: You’ll notice that this command outputs a list of IP addresses on a single line,
    separated by spaces. This isn’t ideal, as what we really want is each IP address
    on a separate line. In [Listing 4-3](chapter4.xhtml#Lis4-3), we use sed to replace
    spaces with newline characters (\n).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，此命令在单行上输出以空格分隔的 IP 地址列表。这并不理想，因为我们真正想要的是每个 IP 地址单独占据一行。在 [列表 4-3](chapter4.xhtml#Lis4-3)
    中，我们使用 sed 将空格替换为换行符（\n）。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-3: Generating a list of IP addresses with echo and sed'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-3：使用 echo 和 sed 生成 IP 地址列表
- en: 'Alternatively, you can use the printf command to generate the same list. Using
    printf won’t require piping to sed, producing a cleaner output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 printf 命令生成相同的列表。使用 printf 不需要管道到 sed，产生更干净的输出：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The %d is an integer placeholder, which will be swapped with the numbers defined
    in the brace expansion to produce a list of IP addresses from 10.1.0.1 to 10.1.0.254\.
    You can redirect the output to a new file and then use it as an input file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`%d` 是整数占位符，将与大括号展开中定义的数字交换，以生成从 10.1.0.1 到 10.1.0.254 的 IP 地址列表。您可以将输出重定向到新文件，然后将其用作输入文件。'
- en: Possible Subdomains
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可能的子域
- en: Say you’re performing a penetration test against a company with the parent domain
    *example.com*. In this engagement, you’re not restricted to any specific IP address
    or domain name, which means that any asset you find on this parent domain during
    the information-gathering stage is considered in scope.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在对公司的父域 *example.com* 进行渗透测试。在此次参与中，您不受限于任何特定的 IP 地址或域名，这意味着您在信息收集阶段发现的该父域上的任何资产都被视为在范围内。
- en: Companies tend to host their services and applications on dedicated subdomains.
    These subdomains can be anything, but more often than not, companies use names
    that make sense to humans and are easy to enter into a web browser. For example,
    you might find the help-desk portal at *helpdesk.example.com*, the monitoring
    system at *monitoring.example.com*, the continuous integration system at *jenkins.example.com*,
    the email server at *mail.example.com*, and the file transfer server at *ftp.example.com*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 公司倾向于将其服务和应用程序托管在专用子域上。这些子域可以是任何内容，但通常情况下，公司使用对人类有意义且易于输入到 Web 浏览器中的名称。例如，您可能会在
    *helpdesk.example.com* 找到帮助台门户，*monitoring.example.com* 上的监控系统，*jenkins.example.com*
    上的持续集成系统，*mail.example.com* 上的电子邮件服务器以及 *ftp.example.com* 上的文件传输服务器。
- en: 'How can we generate a list of possible subdomains for a target? Bash makes
    this easy. First, we’ll need a list of common subdomains. You can find such a
    list built into Kali at */usr/share/wordlists/amass/subdomains-top1mil-110000.txt*
    or */usr/share/wordlists/amass/bitquark_subdomains_top100K.txt*. To look for wordlists
    on the internet, you could use the following Google search query to search for
    files on GitHub provided by community members: **subdomain wordlist site:gist.github.com**.
    This will search GitHub for code snippets (also called *gists*) containing the
    words *subdomain wordlist*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何为目标生成可能的子域列表？Bash 让这变得很容易。首先，我们需要一个常见子域的列表。您可以在 Kali 中找到这样的列表，位于 */usr/share/wordlists/amass/subdomains-top1mil-110000.txt*
    或 */usr/share/wordlists/amass/bitquark_subdomains_top100K.txt*。要查找互联网上的单词列表，您可以使用以下
    Google 搜索查询来搜索由社区成员提供的 GitHub 文件：**subdomain wordlist site:gist.github.com**。这将搜索
    GitHub 上包含单词 *subdomain wordlist* 的代码片段（也称为 *gists*）。
- en: 'For the purposes of this example, we’ll use *subdomains-1000.txt*, which is
    included with this chapter’s files in the book’s GitHub repository. Download this
    subdomain list and save it in your home directory. The file contains one subdomain
    per line without an associated parent domain. You’ll have to join each subdomain
    with the target’s parent domain to form a fully qualified domain name. As in the
    previous section, we’ll show multiple strategies for accomplishing this task:
    using a while loop and using sed.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 出于本示例的目的，我们将使用*subdomains-1000.txt*，它包含在本章文件中，并且存储在书籍的GitHub存储库中。下载这个子域列表并将其保存在你的主目录中。该文件每行包含一个子域名，但没有关联的父域名。你需要将每个子域名与目标的父域名连接起来形成一个完全限定的域名。与前一节一样，我们将展示多种完成此任务的策略：使用while循环和使用sed。
- en: NOTE
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can download this chapter’s resources from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch04](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch04).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以从* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch04](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch04)
    *下载本章的资源*。'
- en: '[Listing 4-4](chapter4.xhtml#Lis4-4) accepts a parent domain and a wordlist
    from the user, then prints a list of fully qualified subdomains by using the wordlist
    you downloaded earlier.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-4](chapter4.xhtml#Lis4-4)接受用户提供的父域名和一个单词列表，然后通过使用你之前下载的单词列表打印出一个完全限定子域名列表。'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-4: Using a while loop to generate a list of subdomains'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：使用while循环生成子域名列表
- en: 'The script uses a while loop to read the file and assign each line to the subdomain
    variable in turn. The echo command then concatenates these two strings together
    to form a full domain name. Save this script as *generate_subdomains.sh* and provide
    it with two arguments:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用while循环读取文件，并依次将每行赋值给变量subdomain。然后echo命令将这两个字符串连接在一起以形成完整的域名。将此脚本保存为*generate_subdomains.sh*并向其提供两个参数：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first argument is the parent domain, and the second is the path to the file
    containing all possible subdomains.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是父域名，第二个参数是包含所有可能子域名的文件的路径。
- en: We can use sed to write content to the end of each line in a file. In [Listing
    4-5](chapter4.xhtml#Lis4-5), the command uses the $ sign to find the end of a
    line, then replace it with the target domain prefixed with a dot (*.example.com*)
    to complete the domain name.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用sed将内容写入文件每一行的末尾。在[列表 4-5](chapter4.xhtml#Lis4-5)中，该命令使用$符号来找到行尾，然后用目标域名前缀加上一个点(*.example.com*)来完成域名。
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-5: Using sed to generate a list of subdomains'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-5：使用sed生成子域名列表
- en: The s at the beginning of the argument to sed stands for *substitute*, and g
    means that sed will replace all matches in the file, not just the first match.
    So, in simple terms, we substitute the end of each line in the file with *.example.com*.
    If you save this code to a script, the output should look the same as in the previous
    example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: sed中参数的开头的s代表*substitute*，g代表sed将在文件中替换所有匹配项，而不仅仅是第一个匹配项。因此，简单来说，我们用*.example.com*替换文件中每一行的末尾。如果你将此代码保存为脚本，输出应与前面的示例相同。
- en: Host Discovery
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机发现
- en: When testing a range of addresses, one of the first things you’ll likely want
    to do is find out information about them. Do they have any open ports? What services
    are behind those ports, and are they vulnerable to any security flaws? Answering
    these questions manually is possible, but this can be challenging if you need
    to do it for hundreds or thousands of hosts. Let’s use bash to automate network
    enumeration tasks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试一系列地址时，你可能首先想要做的事情之一是获取有关它们的信息。它们是否有任何开放端口？这些端口后面有什么服务？它们是否容易受到安全漏洞的影响？手动回答这些问题是可能的，但如果你需要为数百甚至数千个主机执行此操作，这可能会很具挑战性。让我们使用bash来自动化网络枚举任务。
- en: One way to identify live hosts is by attempting to send them network packets
    and wait for them to return responses. In this section, we’ll use bash and additional
    network utilities to perform host discovery.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一种识别活动主机的方法是尝试发送网络数据包并等待它们返回响应。在本节中，我们将使用bash和其他网络实用程序来执行主机发现。
- en: ping
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ping
- en: 'At its most basic form, the ping command takes one argument: a target IP address
    or domain name. Run the following command to see its output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本形式中，ping命令接受一个参数：目标IP地址或域名。运行以下命令来查看其输出：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The ping command will run forever, so press CTRL-C to stop its execution.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ping命令将永远运行，因此按CTRL-C停止其执行。
- en: If you read the ping manual page (by running man ping), you’ll notice that there
    is no way to run the command against multiple hosts at once. But using bash, we
    can do this quite easily. [Listing 4-6](chapter4.xhtml#Lis4-6) pings all hosts
    on the network 172.16.10.0/24.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看ping的手册页面（通过运行man ping），你会注意到没有办法一次性对多个主机运行该命令。但是通过bash，我们可以非常轻松地做到这一点。[示例4-6](chapter4.xhtml#Lis4-6)对网络172.16.10.0/24上的所有主机进行ping测试。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-6: Using a while loop to ping multiple hosts'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-6：使用while循环ping多个主机
- en: At ❶, we run a while loop that reads from the file passed to the script on the
    command line. This file is assigned to the variable FILE. We read each line from
    the file and assign it to the host variable. We then run the ping command, using
    the -c argument with a value of 1 at ❷, which tells ping to send a ping request
    only once and exit. By default on Linux, ping sends ping requests indefinitely
    until you stop it manually by sending a SIGHUP signal (CTRL-C).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我们运行一个while循环，从命令行传递给脚本的文件中读取内容。该文件被赋值给变量FILE。我们从文件中读取每一行并将其赋值给host变量。然后我们运行ping命令，使用-c参数并设置值为1，在❷处告诉ping只发送一次ping请求并退出。默认情况下，在Linux上，ping会无限期地发送ping请求，直到你手动通过发送SIGHUP信号（CTRL-C）停止它。
- en: We also use the arguments -W 1 (to set a timeout in seconds) and -w 1 (to set
    a deadline in seconds) to limit the amount of time ping will wait to receive a
    response. This is important because we don’t want ping to get stuck on an unresponsive
    IP address; we want it to continue reading from the file until all 254 hosts are
    tested.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了参数-W 1（设置超时时间，单位为秒）和-w 1（设置截止时间，单位为秒），以限制ping等待响应的时间。这非常重要，因为我们不希望ping在遇到无响应的IP地址时卡住；我们希望它继续从文件中读取，直到所有254个主机都经过测试。
- en: Finally, we use the standard input stream to read the file and “feed” the while
    loop with its contents ❸.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用标准输入流读取文件，并将文件内容“传递”给while循环 ❸。
- en: 'Save this code to *multi_host_ping.sh* and run it while passing in the *hosts*
    file. You should see that the code picks up a few live hosts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码保存为*multi_host_ping.sh*并在传入*hosts*文件时运行。你应该会看到代码检测到一些活跃主机：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The caveat to this host-discovery approach is that certain hosts, especially
    hardened ones, might not reply to ping commands at all. So, if we rely solely
    on this method for discovery, we might miss out on live hosts on the network.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种主机发现方法的一个警告是，某些主机，尤其是经过强化的主机，可能根本不会响应ping命令。因此，如果我们仅依赖这种方法进行发现，可能会错过网络上的活跃主机。
- en: Also note that commands that run forever by default, such as ping, could pose
    a challenge when integrated into a bash script. In this example, we’ve explicitly
    set a few special flags to ensure that our bash script won’t hang when it executes
    ping. This is why it’s important to first test commands in the terminal before
    integrating them into your scripts. More often than not, tools have special options
    to ensure they don’t execute forever, such as timeout options.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，默认情况下会无限运行的命令（如ping）在集成到bash脚本时可能会带来挑战。在本示例中，我们明确设置了一些特殊标志，以确保我们的bash脚本在执行ping时不会挂起。因此，在将命令集成到脚本中之前，先在终端中测试命令非常重要。通常，工具会提供一些特殊选项，确保它们不会永远执行，例如超时选项。
- en: For tools that don’t provide a timeout option, the timeout command allows you
    to run commands and exit after a certain amount of time has passed. You can prepend
    timeout to any Linux utility, passing it an interval (in the *seconds, minutes,
    hours* format)—for example, timeout 5s ping 8.8.8.8. After the time has elapsed,
    the entire command exits.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有提供超时选项的工具，timeout命令允许你在经过一段时间后自动退出命令。你可以将timeout加到任何Linux工具之前，并传递一个时间间隔（以*秒，分钟，小时*的格式）—例如，timeout
    5s ping 8.8.8.8。在时间到达后，整个命令会退出。
- en: Nmap
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nmap
- en: 'The Nmap port scanner has a special option called -sn that performs a *ping
    sweep*. This simple technique finds live hosts on a network by sending them a
    ping command and waiting for a positive response (called a *ping response*). Since
    many operating systems respond to ping by default, this technique has proved valuable.
    The ping sweep in Nmap will essentially make Nmap send Internet Control Message
    Protocol packets over the network to discover running hosts:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap端口扫描器有一个特别的选项叫做-sn，它执行一个*ping扫描*。这种简单的技术通过向网络上的主机发送ping命令并等待积极响应（称为*ping响应*）来查找活跃主机。由于许多操作系统默认会响应ping，因此这种技术被证明是非常有价值的。Nmap中的ping扫描基本上会使Nmap通过网络发送互联网控制消息协议（ICMP）数据包，以发现正在运行的主机：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This output has a lot of text. With a bit of bash magic, we can get a cleaner
    output by using the grep and awk commands to extract only the IP addresses that
    were identified as being alive ([Listing 4-7](chapter4.xhtml#Lis4-7)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出包含很多文本。通过一些 bash 魔法，我们可以使用 grep 和 awk 命令提取仅识别为活动的 IP 地址，以获得更清晰的输出。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 4-7: Parsing Nmap’s ping scan output'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7：解析 Nmap 的 ping 扫描输出](chapter4.xhtml#Lis4-7)'
- en: Using Nmap’s built-in ping sweep scan may be more useful than manually wrapping
    the ping utility with bash, because you don’t have to worry about checking for
    conditions such as whether the command was successful. Moreover, in penetration
    tests, you may drop an Nmap binary on more than one type of operating system,
    and the same syntax will work consistently whether the ping utility exists or
    not.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Nmap 的内置 ping 扫描可能比手动使用 bash 包装 ping 实用程序更有用，因为您不必担心检查命令是否成功的条件。此外，在渗透测试中，您可能会在多种操作系统上放置
    Nmap 二进制文件，并且相同的语法将始终在 ping 实用程序存在与否的情况下一致工作。
- en: arp-scan
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: arp-scan
- en: We can perform penetration testing remotely, from a different network, or from
    within the same network as the target. In this section, we’ll highlight the use
    of arp-scan as a way to find hosts on a network when the test is done locally.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以远程执行渗透测试，从不同的网络或与目标相同的网络内部执行。在本节中，我们将强调使用 arp-scan 作为在本地进行测试时发现网络中主机的方法。
- en: The arp-scan utility sends Address Resolution Protocol (ARP) packets to hosts
    on a network and displays any responses it gets back. *ARP* maps *media access
    control (MAC)* addresses, which are unique 12-digit hexadecimal addresses assigned
    to network devices, to the IP addresses on a network. Because ARP is a Layer 2
    protocol in the Open Systems Interconnection (OSI) model, it is useful only when
    you’re on a local network; ARP can’t be used to perform a remote scan over the
    internet.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: arp-scan 实用程序向网络上的主机发送地址解析协议（ARP）数据包，并显示它收到的任何响应。*ARP* 映射了分配给网络设备的唯一的 12 位十六进制地址（称为媒体访问控制（MAC）地址）到
    IP 地址。因为 ARP 是 OSI 模型中的第二层协议，在本地网络上才有用；ARP 不能用于通过互联网执行远程扫描。
- en: 'Note that arp-scan requires root privileges to run; this is because it uses
    functions to read and write packets that require elevated privileges. At its most
    basic form, you can run it by executing the arp-scan command and passing a single
    IP address as an argument:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，arp-scan 需要 root 权限才能运行；这是因为它使用需要提升权限的函数来读取和写入数据包。在其最基本的形式中，您可以通过执行 arp-scan
    命令并将单个 IP 地址作为参数传递来运行它：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We also need to tell arp-scan which network interface to send packets on, as
    Kali has a few network interfaces. To achieve this, we use the -I argument. The
    br_public interface corresponds to the 172.16.10.0/24 network in the lab.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要告诉 arp-scan 在哪个网络接口上发送数据包，因为 Kali 有几个网络接口。为此，我们使用 -I 参数。br_public 接口对应于实验室中的
    172.16.10.0/24 网络。
- en: 'To scan entire networks, you can pass arp-scan a CIDR range, such as */24*.
    For example, the following command scans all IP addresses from 172.16.10.1 to
    172.16.10.254:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要扫描整个网络，您可以传递 arp-scan 一个 CIDR 范围，例如 */24*。例如，以下命令扫描从 172.16.10.1 到 172.16.10.254
    的所有 IP 地址：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, you can use the hosts file you created in “Consecutive IP Addresses”
    on [page 70](#pg_70) as input to arp-scan:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以将在“连续 IP 地址”中创建的 hosts 文件作为 arp-scan 的输入：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output generated by arp-scan should look like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: arp-scan 生成的输出应如下所示：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This output consists of three fields: the IP address, the MAC address, and
    vendor details, identified by the first three octets of the MAC address. In this
    scan, the tool identified four hosts on the network that responded to ARP packets.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出由三个字段组成：IP 地址、MAC 地址和供应商详细信息，由 MAC 地址的前三个八位组标识。在此扫描中，工具识别出网络上四个响应 ARP 数据包的主机。
- en: 'Exercise 3: Receiving Alerts About New Hosts'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3：接收关于新主机的警报
- en: Imagine that you want to be notified whenever a new host appears on the network.
    For example, maybe you want to know when new laptops or IT assets have connected.
    This could be useful if you’re testing a target in a different time zone, where
    device users might not be online when you are.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望在网络上出现新主机时收到通知。例如，也许你想知道新的笔记本电脑或 IT 资产何时连接。如果你在测试不同时区的目标，当你在线时设备用户可能不在线，这可能很有用。
- en: You can use bash to send yourself an email whenever your script discovers new
    assets. [Listing 4-9](chapter4.xhtml#Lis4-9) runs a continuous scan to identify
    new online hosts, adds these to the *172-16-10-hosts.txt* file created in “Consecutive
    IP Addresses” on [page 70](#pg_70), and notifies you of the discovery.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 bash 在脚本发现新资产时向自己发送电子邮件。[Listing 4-9](chapter4.xhtml#Lis4-9) 运行一个持续扫描，识别新的在线主机，将它们添加到“连续
    IP 地址”中创建的 *172-16-10-hosts.txt* 文件，并通知你发现的结果。
- en: Because this script is more involved than the previous ones, we’ll walk through
    an example solution ([Listing 4-8](chapter4.xhtml#Lis4-8)), then discuss ways
    to improve it on your own.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个脚本比之前的更复杂，我们将通过一个示例解决方案（[Listing 4-8](chapter4.xhtml#Lis4-8)）来进行讲解，然后讨论如何自行改进它。
- en: host_monitor _notification.sh
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: host_monitor _notification.sh
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 4-8: Using sendemail to receive notifications about new arp-scan discoveries'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-8：使用 sendemail 接收关于新 arp-scan 发现的通知
- en: First, we set a few variables. We assign the file containing the hosts to look
    for, *172-16-10-hosts.txt*, to the KNOWN_HOSTS variable, and the target network
    172.16.10.0/24 to the NETWORK variable. We also set the FROM_ADDR and TO_ADDR
    variables, which we’ll use to send the notification email.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置一些变量。我们将包含要查找的主机的文件 *172-16-10-hosts.txt* 赋值给 KNOWN_HOSTS 变量，将目标网络 172.16.10.0/24
    赋值给 NETWORK 变量。我们还设置了 FROM_ADDR 和 TO_ADDR 变量，用于发送通知邮件。
- en: We then use while to run an infinite loop ❶. This loop won’t end unless we intentionally
    break out of it. Within the loop, we run arp-scan with the options -x to display
    a plain output (so it’s easier to parse) and -I to define the network interface
    br_public ❷. In the same line, we use a while read loop to iterate through the
    output of arp-scan. We use awk to parse each IP address in the output and assign
    it to the host variable ❸.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 while 运行一个无限循环 ❶。除非我们主动退出，否则这个循环不会结束。在循环内部，我们使用 arp-scan 命令，并使用 -x 选项以显示纯文本输出（以便更容易解析），使用
    -I 选项定义网络接口 br_public ❷。在同一行中，我们使用 while read 循环遍历 arp-scan 输出的内容。我们使用 awk 解析输出中的每个
    IP 地址，并将其赋值给 host 变量 ❸。
- en: At ❹, we use an if condition to check whether the host variable (which represents
    a host discovered by arp-scan) exists in our *hosts* file. If it does, we don’t
    do anything, but if it doesn’t, we write it to the file ❺ and send an email notification
    ❻ by using the sendemail command. Notice that each line in the sendemail command
    ends with a backslash (\). When lines are long, bash allows us to separate them
    in this way while still treating them as a single command. Breaking long code
    lines makes them easier to read. At the end of this process, we use sleep 10 to
    wait 10 seconds before running this discovery again.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❹ 处，我们使用 if 条件判断主机变量（代表由 arp-scan 发现的主机）是否存在于我们的 *hosts* 文件中。如果存在，我们什么也不做；如果不存在，我们将其写入文件
    ❺ 并通过 sendemail 命令发送电子邮件通知 ❻。注意，sendemail 命令中的每一行都以反斜杠（\）结尾。当行较长时，bash 允许我们以这种方式分隔它们，同时仍将其视为单个命令。将长代码行分开可以使其更易读。在此过程的最后，我们使用
    sleep 10 等待 10 秒钟，然后再运行此发现过程。
- en: If you run this script, you should receive an email whenever a new host is discovered.
    To properly send email messages, you’ll need to configure a mail transfer agent
    such as Postfix on the system. Refer to the documentation at *[https://www.postfix.org/documentation.html](https://www.postfix.org/documentation.html)*
    for more information on doing so.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行此脚本，每当发现新主机时，你应该会收到一封电子邮件。为了正确发送邮件，你需要在系统上配置邮件传输代理，例如 Postfix。有关如何配置的更多信息，请参阅文档
    *[https://www.postfix.org/documentation.html](https://www.postfix.org/documentation.html)*。
- en: 'Note that the continuous network probing the script performs isn’t very stealthy.
    To probe the network more covertly, try modifying the script in one of the following
    ways:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，脚本执行的持续网络探测并不隐秘。若要更隐秘地探测网络，尝试以以下方式修改脚本：
- en: Slow the probing so it triggers every few hours or after an arbitrary number
    of minutes. You can even randomize this interval to make it less predictable.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低探测速度，使其每隔几个小时或任意分钟数触发一次。你甚至可以将此间隔随机化，以使其更难预测。
- en: Instead of sending notifications over the network, try writing the results to
    memory if you’re running the script from within a compromised network.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在受损的网络中运行脚本，尝试将结果写入内存，而不是通过网络发送通知。
- en: Upload the results to an innocent-looking third-party website. The Living Off
    Trusted Sites (LOTS) Project at *[https://lots-project.com](https://lots-project.com)*
    maintains an inventory of legitimate websites that corporate networks often allow.
    Attackers commonly use these to carry out activities such as data exfiltration
    so that their traffic blends with other legitimate traffic, making it harder for
    analysts to spot.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果上传到看似无害的第三方网站。Living Off Trusted Sites（LOTS）项目在*[https://lots-project.com](https://lots-project.com)*维护着一个合法网站清单，企业网络通常允许这些网站。攻击者通常利用这些网站执行诸如数据外泄等活动，使其流量混入其他合法流量中，使分析师更难以发现。
- en: Now that you know the hosts available on the 172.16.10.0/24 network, we recommend
    removing any unresponsive IP addresses from the *172-16-10-hosts.txt* file to
    make your future scans faster.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道172.16.10.0/24网络上可用的主机，我们建议从*172-16-10-hosts.txt*文件中删除任何无响应的IP地址，以使您未来的扫描更快。
- en: To go even further, we encourage you to experiment with other notification delivery
    methods, such as Slack, Discord, Microsoft Teams, or any other messaging system
    you use on a daily basis. Platforms such as Slack, for example, use a *webhook*,
    which enables a script to make an HTTP POST request to a special uniform resource
    locator (URL) to deliver a custom message to a channel of choice.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索，我们鼓励您尝试其他通知传递方法，如Slack、Discord、Microsoft Teams或您日常使用的任何其他消息系统。例如，像Slack这样的平台使用*webhook*，它允许脚本向特定统一资源定位符（URL）发出HTTP
    POST请求，以向所选频道发送自定义消息。
- en: Port Scanning
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口扫描
- en: 'Once you’ve discovered hosts on the network, you can run a port scanner to
    find their open ports and the services they’re running. Let’s explore port scanning
    by using three tools: Nmap, RustScan, and Netcat.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您发现了网络上的主机，您可以运行端口扫描程序来查找它们的开放端口和正在运行的服务。让我们通过使用三个工具来探索端口扫描：Nmap、RustScan和Netcat。
- en: Nmap
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nmap
- en: 'Nmap allows us to perform port scanning against single targets or multiple
    targets at the same time. In the following example, we use Nmap to perform a port
    scan of the domain *scanme.nmap.org*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap允许我们针对单个目标或多个目标同时执行端口扫描。在下面的示例中，我们使用Nmap对域名*scanme.nmap.org*执行端口扫描：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Nmap also accepts IP addresses, like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap还接受IP地址，如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we provide Nmap with no special options on the command line, it will use
    the following default settings:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在命令行上未提供Nmap的任何特殊选项时，它将使用以下默认设置：
- en: '**Perform a SYN scan **Nmap will use a synchronization (SYN) scan to discover
    open ports on a target. Also called a *half-open scan*, a *SYN scan* involves
    sending a SYN packet and waiting for a response. Nmap won’t complete the full
    TCP handshake (meaning ACK won’t be sent back), which is why we call this scan
    *half open*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行SYN扫描 **Nmap将使用同步（SYN）扫描来发现目标上的开放端口。也称为*半开放扫描*，*SYN扫描*涉及发送一个SYN包并等待响应。Nmap不会完成完整的TCP握手（也就是不会发送ACK），这就是为什么我们称这种扫描为*半开放*。'
- en: '**Scan the top 1,000 ports **Nmap will scan only popular ports known to be
    frequently in use, such as TCP ports 21, 22, 80, and 443\. It won’t scan the entire
    port range of 0–65,534, to conserve resources.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**扫描前1000个端口 **Nmap只会扫描那些经常使用的热门端口，比如TCP端口21、22、80和443。它不会扫描整个端口范围0至65,534，以节约资源。'
- en: '**Scan TCP ports **Nmap will scan only TCP ports, not User Datagram Protocol
    (UDP) ports.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**扫描TCP端口 **Nmap只会扫描TCP端口，不会扫描用户数据报协议（UDP）端口。'
- en: 'Nmap allows you to scan multiple targets by passing them on the command line.
    In the following example, we scan both *localhost* and *scanme.nmap.org*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap允许您通过命令行传递多个目标进行扫描。在下面的示例中，我们同时扫描*localhost*和*scanme.nmap.org*：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Nmap can also read targets from a given file when passed the -iL option. The
    targets must be separated by newlines. Let’s use the *172-16-10-hosts.txt* file
    with Nmap to scan multiple targets:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递-iL选项时，Nmap还可以从给定文件中读取目标。目标必须以新行分隔。让我们使用*Nmap扫描多个目标的172-16-10-hosts.txt*文件：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This scan may take some time to complete because of the use of the -sV option,
    which detects the version of services on each port. As you can see, Nmap returns
    a few IP addresses and their open ports, including their services and even information
    related to the operating system running on the host. If we wanted to filter, say,
    only the open ports, we could do by using grep:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了-sV选项，该扫描可能需要一些时间来完成，该选项用于检测每个端口的服务版本。正如您所见，Nmap返回了一些IP地址及其开放端口，包括它们的服务甚至与主机上运行的操作系统相关的信息。如果我们想要过滤，比如只想看到开放的端口，我们可以使用grep：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Nmap is able to identify services on several open TCP ports, such as the File
    Transfer Protocol (FTP) on port 21, Secure Shell (SSH) on port 22, and HTTP on
    port 80\. Later in this chapter, we’ll take a closer look at each of these services.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 能够识别几个开放的 TCP 端口上的服务，例如端口 21 上的文件传输协议 (FTP)，端口 22 上的安全外壳协议 (SSH)，以及端口 80
    上的 HTTP。在本章后面，我们将更详细地查看每个服务。
- en: 'Nmap also allows you to pass the --open flag on the command line to show only
    the ports that were found open:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 也允许您在命令行上使用 --open 标志，仅显示找到的开放端口：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Kali’s own interface IP (172.16.10.1) will be captured in this port scan, since
    it is part of the hosts file. You can use Nmap’s --exclude option to exclude this
    specific IP when performing a network-wide scan: --exclude 172.16.10.1. You can
    also remove it manually from the file for convenience.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Kali 的本机接口 IP（172.16.10.1）将在此端口扫描中被捕获，因为它在 hosts 文件中。您可以使用 Nmap 的 --exclude
    选项在执行网络范围扫描时排除此特定 IP：--exclude 172.16.10.1。您还可以从文件中手动删除它以方便操作。
- en: Use man nmap to learn more about Nmap’s scanning and filtering capabilities.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 man nmap 命令了解更多关于 Nmap 扫描和过滤功能的信息。
- en: RustScan
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RustScan
- en: 'RustScan is becoming more popular in the bug-bounty and penetration-testing
    spaces because of its speed and extensibility. The following rustscan command
    runs a port scan. The -a (address) argument accepts a single address or an address
    range:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: RustScan 在漏洞赏金和渗透测试领域越来越受欢迎，因为其速度和可扩展性。以下是 rustscan 命令执行的端口扫描。-a（地址）参数接受单个地址或地址范围：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: RustScan’s output is fairly easy to parse with bash. Lines starting with Open
    indicate that an open port was found on a specific IP address. These are followed
    by the IP address and port, separated by a colon.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: RustScan 的输出非常适合用 bash 解析。以 Open 开头的行表明在特定 IP 地址上找到了开放端口。这些行后面跟着 IP 地址和端口，用冒号分隔。
- en: 'When you run RustScan, you may notice that the initial output contains banners,
    author credits, and additional information not directly related to the scan results.
    Use the -g (greppable) option to show only the scanning information. The following
    command uses the greppable output mode to scan 172.16.10.0/24 on the first 1,024
    ports (also called *privileged ports*) with the -r (range) option:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 RustScan 时，您可能会注意到初始输出包含横幅、作者信用和与扫描结果无直接关系的其他信息。使用 -g（grepable）选项仅显示扫描信息。以下命令使用
    grepable 输出模式扫描 172.16.10.0/24 的前 1024 个端口（也称为 *特权端口*）：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now the output is more grep friendly. To parse it, all we need to do is pass
    the delimiter ->, which separates the IP address and port, with awk:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出更适合用 grep。要解析它，我们只需传递分隔符 ->，用 awk 分隔 IP 地址和端口：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This command outputs two fields: the IP address and the port. To get rid of
    the [] surrounding the port number, we use the tr command and the -d (delete)
    argument followed by the characters to delete:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令输出两个字段：IP 地址和端口。为了去掉周围的 [] 括号，我们使用 tr 命令和 -d（删除）参数后跟要删除的字符：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This should return a cleaner output.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回更清晰的输出。
- en: WARNING
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 警告
- en: '*Remember that running port scanners in aggressive modes increases the chances
    of getting caught, especially if the target implements an intrusion detection
    system or endpoint detection and response system. Also, if you scan at a rapid
    pace, you may cause a denial of service as a result of the network flood.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，在激进模式下运行端口扫描程序会增加被发现的风险，特别是如果目标使用入侵检测系统或终端响应系统。此外，如果您以快速的速度扫描，可能会因网络洪水而导致拒绝服务。*'
- en: Netcat
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Netcat
- en: You can also use Netcat for port scanning activities. People often use this
    tool when they want to check the state of a single port (such as whether it’s
    open or closed), but Netcat also enables you to scan multiple ports with a single
    command. Let’s see how this can be achieved.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 Netcat 进行端口扫描活动。当人们想要检查单个端口的状态（如是否开放或关闭）时，通常会使用此工具，但 Netcat 也可以让您用单个命令扫描多个端口。让我们看看如何实现这一点。
- en: 'Run the following command to scan TCP ports 1–1024 on 172.16.10.11:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令扫描 172.16.10.11 上的 TCP 端口 1–1024：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use nc with the -z flag (zero input/output, or I/O, mode, which won’t send
    any data) and the -v (verbose) flag, followed by the target IP and the port range
    separated by a hyphen (-). As you can see in the output, two ports were found
    open.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 nc 命令，带有 -z 标志（零输入/输出模式，不会发送任何数据）和 -v 标志（详细模式），然后是目标 IP 和用连字符（-）分隔的端口范围。如输出所示，找到两个开放端口。
- en: 'Exercise 4: Organizing Scan Results'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4：整理扫描结果
- en: 'Sorting your scan results into categories of interest is often useful. For
    example, you could dump results for each IP address into a dedicated file or organize
    the results based on the versions of the software found. In this exercise, you’ll
    organize your scan results based on port numbers. Write a script that does the
    following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将扫描结果按感兴趣的类别进行分类通常非常有用。例如，你可以将每个 IP 地址的结果导出到一个专门的文件中，或根据发现的软件版本来整理结果。在本练习中，你将根据端口号来组织扫描结果。编写一个脚本，实现以下功能：
- en: 1.  Runs Nmap against hosts in a file
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  对文件中的主机运行 Nmap
- en: 2.  Uses bash to create individual files whose filenames are open ports
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  使用 bash 创建以开放端口为文件名的单独文件
- en: 3.  In each file, writes the IP address on which the corresponding port was
    open
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  在每个文件中，写入对应端口开放时的 IP 地址
- en: At the end of this exercise, you should have a bunch of files, such as *port-22.txt*,
    *port-80.txt*, and *port-8080.txt*, and in each file, you should see one or more
    IP addresses at which that port was found to be open. This can be useful when
    you have a large number of target hosts and want to attack them in clusters by
    targeting specific protocols associated with given ports.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习的最后，你应该会有一堆文件，例如 *port-22.txt*、*port-80.txt* 和 *port-8080.txt*，在每个文件中，你应该能看到一个或多个
    IP 地址，表示该端口被发现开放。当你有大量目标主机时，这可以非常有用，尤其是当你希望通过针对与特定端口相关的协议进行群体攻击时。
- en: To get you started, [Listing 4-9](chapter4.xhtml#Lis4-9) shows an example solution.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你入门，[清单 4-9](chapter4.xhtml#Lis4-9) 显示了一个示例解决方案。
- en: nmap_to _portfiles.sh
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: nmap_to_portfiles.sh
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 4-9: Using bash to organize scan results by port'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-9：使用 bash 根据端口组织扫描结果
- en: We assign the output of the nmap command to the variable NMAP_RESULT ❶. In this
    command, we also filter for specific lines containing the words Nmap scan report
    or tcp open. These lines are part of Nmap’s standard port scan output, and they
    indicate that open ports were found on an IP address.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 nmap 命令的输出赋值给变量 NMAP_RESULT ❶。在这个命令中，我们还会过滤出包含“Nmap scan report”或“tcp open”字样的特定行。这些行是
    Nmap 标准端口扫描输出的一部分，表示在某个 IP 地址上发现了开放端口。
- en: We use a while loop to read NMAP_RESULT line by line, checking whether each
    line contains the string report for ❷. This line will hold the IP address where
    ports are found open. If such a line exists, we assign it to the ip variable.
    Then we parse the line to extract the port that is found open ❸. At ❹, we create
    the file variable to hold the file we’ll create on disk with the naming scheme
    *port-NUMBER.txt*. Finally, we append the IP address to the file ❺.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 while 循环逐行读取 NMAP_RESULT，检查每一行是否包含字符串“report for ❷”。这一行将包含发现端口开放的 IP 地址。如果找到这样的行，我们将其赋值给
    ip 变量。然后，我们解析该行，提取发现开放的端口 ❸。在 ❹ 处，我们创建文件变量，用于保存我们将创建的磁盘文件，命名方案为 *port-NUMBER.txt*。最后，我们将
    IP 地址附加到文件 ❺。
- en: 'Save the script to a file named *nmap_to_portfiles.sh* and run it. Next, run
    ls -l to see what files were created, and use cat to view their contents:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本保存为 *nmap_to_portfiles.sh* 文件并运行。接下来，运行 ls -l 查看哪些文件已创建，并使用 cat 查看它们的内容：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you’ve seen, Nmap’s standard output format is a little challenging to parse
    but not impossible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Nmap 的标准输出格式稍微有些难以解析，但并非不可能。
- en: 'To improve the script shown here, consider using one of Nmap’s additional output
    format options, which can make parsing easier, especially for scripting purposes.
    One of these options is the -oG flag, for the greppable output format, which is
    grep and awk friendly:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进此脚本，可以考虑使用 Nmap 的其他输出格式选项，这些选项可以简化解析，尤其是在脚本编写时。其中一个选项是 -oG 标志，它用于生成便于 grep
    和 awk 使用的可搜索输出格式：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The output now prints the IP address and its open ports on the same line.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在会在同一行打印 IP 地址及其开放的端口。
- en: 'You can also tell Nmap to generate Extensible Markup Language (XML) output
    by using the -oX option. Open ports in an XML Nmap output look like the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 -oX 选项让 Nmap 生成可扩展标记语言（XML）输出。XML 格式的 Nmap 输出中的开放端口如下所示：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As an extra challenge, try putting together a one-liner bash script that extracts
    the open ports from XML output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外挑战，尝试编写一个单行的 bash 脚本，从 XML 输出中提取开放端口。
- en: Detecting New Open Ports
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测新的开放端口
- en: What if you want to monitor a host until it opens a certain port? You may find
    this useful if you’re testing an environment in which hosts come up and down frequently.
    We can do this quite easily with a while loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想监视某台主机，直到它开放某个特定端口怎么办？如果你正在测试一个主机频繁上线和下线的环境，你可能会发现这非常有用。我们可以通过 while 循环轻松实现这一点。
- en: In [Listing 4-10](chapter4.xhtml#Lis4-10), we continuously check whether a port
    is open, waiting five seconds between each execution. Once we find an open port,
    we pass this information to Nmap to perform a service discovery and write the
    output to a file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 4-10](chapter4.xhtml#Lis4-10)中，我们持续检查端口是否打开，每次执行之间间隔五秒。一旦我们找到一个开放端口，我们将这些信息传递给Nmap进行服务发现，并将结果写入文件。
- en: port _watchdog.sh
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: port _watchdog.sh
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 4-10: A watchdog script for newly opened ports'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-10：新开放端口的看门狗脚本
- en: At ❷, we start an infinite while loop. The loop runs RustScan, passing it the
    -a (address) argument containing an IP address we receive on the command line
    ❸. We also pass RustScan the -g (greppable) option to produce a format that is
    grep friendly, and the port option (-p) to scan a particular port, which we also
    receive on the command line and assign the result to the port_scan variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在❷，我们启动一个无限循环。该循环运行RustScan，并传递给它包含我们在命令行中收到的IP地址的-a（地址）参数❸。我们还传递RustScan -g（greppable）选项，生成适合grep的格式，并传递端口选项（-p）以扫描特定端口，这个端口同样是我们从命令行接收的，结果被分配给port_scan变量。
- en: We check the result of the scan ❹. If the result is not empty, we pass the IP
    address and the port to the service_discovery function ❺, which does an Nmap service-version
    discovery scan (-sV) and writes the result to the logfile *watchdog.log* ❶. If
    the port scan fails, which means the port is closed, we sleep for five seconds
    ❻. As a result, the process will repeat every five seconds until the port is found
    open.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查扫描结果❹。如果结果不为空，我们将IP地址和端口传递给service_discovery函数❺，该函数执行Nmap服务版本发现扫描（-sV），并将结果写入日志文件*watchdog.log*❶。如果端口扫描失败，意味着端口已关闭，我们将暂停五秒❻。因此，整个过程将每五秒重复一次，直到找到开放的端口。
- en: 'Save the script and then run it with the following arguments:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，然后使用以下参数运行它：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since nothing should be running on this port of your localhost, the script
    should run forever. We can simulate a port-opening event by using Python’s built-in
    *http.server* module, which starts a simple HTTP server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本地主机的此端口不应有任何服务在运行，脚本将永远运行。我们可以通过使用Python的内置*http.server*模块来模拟端口打开事件，该模块启动一个简单的HTTP服务器：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now the *port_watchdog.sh* script should show the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，*port_watchdog.sh*脚本应显示以下内容：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can view the results of the scan by opening the *watchdog.log* file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打开*watchdog.log*文件来查看扫描结果：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using this script, you should be able to identify four IP addresses on the
    network with open ports: 172.16.10.10 (belonging to the *p-web-01* machine) running
    8081/TCP; 172.16.10.11 (belonging to the *p-ftp-01* machine) running both 21/TCP
    and 80/TCP; 172.16.10.12 (belonging to the *p-web-02* machine) running 80/TCP;
    and 172.16.10.13 (belonging to the *p-jumpbox-01* machine) running 22/TCP.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个脚本，你应该能够在网络上识别出四个具有开放端口的IP地址：172.16.10.10（属于*p-web-01*机器）运行8081/TCP；172.16.10.11（属于*p-ftp-01*机器）同时运行21/TCP和80/TCP；172.16.10.12（属于*p-web-02*机器）运行80/TCP；以及172.16.10.13（属于*p-jumpbox-01*机器）运行22/TCP。
- en: Banner Grabbing
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 横幅抓取
- en: Learning about the software running on a remote server is a crucial step in
    a penetration test. In the remainder of this chapter, we’ll look at how to identify
    what’s behind a port and a service—for example, what web server is running on
    port 8081, and what technologies does it use to serve content to clients?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 了解远程服务器上运行的软件是渗透测试中的关键步骤。在本章的其余部分，我们将探讨如何识别端口和服务背后的内容——例如，端口8081上运行的是什么Web服务器，它使用哪些技术为客户端提供内容？
- en: '*Banner grabbing* is the process of extracting the information published by
    remote network services when a connection is established between two parties.
    Services often transmit these banners to “greet” clients, which can use the information
    provided in various ways, such as to ensure they’re connecting to the right target.
    Banners could also include a system admin message of the day or the service’s
    specific running version.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*Banner grabbing*（横幅抓取）是指提取远程网络服务在建立连接时发布的信息的过程。服务通常会传输这些横幅以“迎接”客户端，客户端可以以多种方式利用提供的信息，例如确保它们连接到正确的目标。横幅还可能包含系统管理员的每日消息或服务的特定运行版本。'
- en: '*Passive banner grabbing* uses third-party websites to look up banner information.
    For example, websites such as Shodan (*[https://shodan.io](https://shodan.io)*),
    ZoomEye (*[https://zoomeye.org](https://zoomeye.org)*), and Censys (*[https://censys.io](https://censys.io)*)
    perform scans to map the internet, grabbing banners, versions, website pages,
    and ports, then create an inventory using this data. We can use such websites
    to look up banner information without ever interacting with the target server
    ourselves.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*被动横幅抓取*使用第三方网站查找横幅信息。例如，像 Shodan (*[https://shodan.io](https://shodan.io)*)、ZoomEye
    (*[https://zoomeye.org](https://zoomeye.org)*)、Censys (*[https://censys.io](https://censys.io)*)
    这样的网站执行扫描，映射互联网，抓取横幅、版本、网页和端口，然后利用这些数据创建清单。我们可以使用这些网站查找横幅信息，而无需与目标服务器直接交互。'
- en: '*Active banner grabbing* is the opposite; it establishes a connection to a
    server and interacts with it directly to receive its banner information. Examples
    of network services that tend to advertise themselves by using banners include
    web servers, SSH servers, FTP servers, Telnet servers, network printers, Internet
    of Things devices, and message queues.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*主动横幅抓取*则恰恰相反；它建立与服务器的连接并直接与其交互，以接收其横幅信息。通过横幅进行自我宣传的网络服务包括 Web 服务器、SSH 服务器、FTP
    服务器、Telnet 服务器、网络打印机、物联网设备和消息队列等。'
- en: Keep in mind that banners are generally free-form text fields, and they can
    be changed to mislead clients. For example, an Apache web server could present
    itself as another type of web server, such as nginx. Some organizations even create
    *honeypot servers* to lure threat actors (or penetration testers). Honeypots use
    deception technologies to masquerade as vulnerable servers, but their real purpose
    is to detect and analyze attacker activity. More often than not, however, banners
    transmit default settings that system administrators haven’t bothered to change.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，横幅通常是自由格式的文本字段，可以更改以误导客户端。例如，Apache Web 服务器可能会伪装成另一种类型的 Web 服务器，如 nginx。一些组织甚至会创建
    *蜜罐服务器* 来引诱威胁行为者（或渗透测试者）。蜜罐利用欺骗技术伪装成脆弱的服务器，但它们的真正目的是检测和分析攻击者的活动。然而，更多时候，横幅传输的是系统管理员没有更改的默认设置。
- en: Using Active Banner Grabbing
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用主动横幅抓取
- en: 'To demonstrate what active banner grabbing looks like, we’ll use the following
    Netcat command to connect to port 21 (FTP) running on IP address 172.16.10.11
    (*p-ftp-01*):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示什么是主动横幅抓取，我们将使用以下 Netcat 命令连接到 IP 地址 172.16.10.11 上运行的端口 21（FTP）（*p-ftp-01*）：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, 172.16.10.11 is running the FTP server vsFTPd version 3.0.5\.
    This information may change if the vsFTPd version gets upgraded or downgraded,
    or if the system administrator decides to disable banner advertisement completely
    in the FTP server’s configuration.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，172.16.10.11 正在运行 FTP 服务器 vsFTPd 版本 3.0.5。这些信息可能会发生变化，具体取决于 vsFTPd 版本的升级或降级，或者系统管理员是否决定在
    FTP 服务器的配置中完全禁用横幅广告。
- en: Netcat is a good example of a tool that doesn’t natively support probing multiple
    IP addresses. So, knowing a bit of bash scripting can help us out here. [Listing
    4-11](chapter4.xhtml#Lis4-11) will use Netcat to grab banners on port 21 from
    multiple hosts saved in a file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat 是一个很好的例子，说明了一个工具本身并不支持探测多个 IP 地址。因此，了解一些 bash 脚本编程可以帮助我们解决这个问题。[Listing
    4-11](chapter4.xhtml#Lis4-11) 将使用 Netcat 从一个文件中保存的多个主机抓取端口 21 上的横幅。
- en: netcat_banner _grab.sh
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: netcat_banner _grab.sh
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 4-11: Banner grabbing using Netcat'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-11：使用 Netcat 进行横幅抓取
- en: 'This script accepts two parameters on the command line: FILE and PORT. We use
    an if condition to check whether two arguments were indeed passed on the command
    line ❶; if not, we exit with a status code of 1 (fail) and print a usage message
    indicating how to run the script. We then use another if condition with the -f
    test to check whether the file provided by the user actually exists on disk ❷.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本在命令行接受两个参数：FILE 和 PORT。我们使用 if 条件语句检查是否确实传入了两个参数 ❶；如果没有，我们以状态码 1（失败）退出，并打印一个使用提示，说明如何运行该脚本。然后我们使用另一个
    if 条件语句，并通过 -f 测试检查用户提供的文件是否确实存在于磁盘上 ❷。
- en: At ❸, we check that the port provided by the user is a number. Anything other
    than a number will fail. Then we read the host file line by line and run the nc
    (Netcat) command on the given port for each ❹. We use another if condition to
    check whether the command result is not empty ❺, meaning a port was found open,
    and print the IP address and data that returned from the server.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❸ 处，我们检查用户提供的端口是否为数字。任何非数字的输入都将失败。然后，我们逐行读取主机文件并在每个 ❹ 处运行给定端口上的 nc (Netcat)
    命令。我们使用另一个 if 条件来检查命令结果是否不为空 ❺，这意味着发现了开放的端口，并打印从服务器返回的 IP 地址和数据。
- en: Detecting HTTP Responses
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测 HTTP 响应
- en: You’ll often find the popular curl HTTP client on production systems. To perform
    banner grabbing on HTTP responses, we can use curl to send an HTTP request using
    the HEAD method. The HEAD method allows us to read response headers without fetching
    the entire response payload from the web server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 生产系统上经常会出现流行的 curl HTTP 客户端。为了对 HTTP 响应执行横幅抓取，我们可以使用 curl 发送 HTTP 请求，使用 HEAD
    方法。HEAD 方法允许我们读取响应头，而无需从 Web 服务器获取整个响应载荷。
- en: 'Web servers often advertise themselves by setting the Server HTTP response
    header to their name. Sometimes you may also encounter the running version advertised
    there. The following curl command sends an HTTP HEAD request to the *p-web-01*
    machine (172.16.10.10:8081):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器通常通过将 Server HTTP 响应头设置为其名称来进行自我宣传。有时您可能还会在那里遇到宣传的运行版本。以下 curl 命令向 *p-web-01*
    机器（172.16.10.10:8081）发送 HTTP HEAD 请求：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the server returns a bunch of headers in the response, one of
    which is the Server header. This header reveals that the remote server is running
    a Python-based web framework named Werkzeug version 2.2.3, powered by Python version
    3.11.1.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，服务器在响应中返回了一堆头信息，其中之一是 Server 头信息。这个头信息显示远程服务器正在运行一个名为 Werkzeug 版本 2.2.3
    的基于 Python 的 Web 框架，由 Python 版本 3.11.1 驱动。
- en: '[Listing 4-12](chapter4.xhtml#Lis4-12) incorporates this curl command into
    a larger script that prompts the user for information with the bash read command,
    then presents the user with a banner.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-12](chapter4.xhtml#Lis4-12) 将这个 curl 命令整合到一个更大的脚本中，使用 bash read 命令提示用户输入信息，然后向用户呈现一个横幅。'
- en: curl_banner _grab.sh
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: curl_banner _grab.sh
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 4-12: Extracting the server response header from web servers'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-12：从 Web 服务器提取服务器响应头
- en: This interactive script asks the user to provide details about the target on
    the command line. First, we use the read command to prompt the user to enter an
    IP address and assign this value to the ip_address variable ❶. We then ask the
    user for the desired port number and save that to the port variable ❷.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交互式脚本要求用户在命令行中提供有关目标的详细信息。首先，我们使用 read 命令提示用户输入 IP 地址，并将这个值分配给 ip_address
    变量 ❶。然后，我们要求用户输入所需的端口号，并将其保存到 port 变量 ❷ 中。
- en: At ❸, we check whether the ip_address variable length is zero by using the -z
    test and exit if this condition is true. Next, we do the same check on the port
    variable ❹. This time, if the user didn’t provide a port, we use the default HTTP
    port, 80 ❺. At ❻, we store the output to the result variable. We use grep and
    awk to parse the result of curl and extract the Server header.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❸ 处，我们通过使用 -z 测试检查 ip_address 变量的长度是否为零，并在此条件为真时退出。接下来，我们对端口变量 ❹ 进行相同的检查。这次，如果用户没有提供端口，我们使用默认的
    HTTP 端口 80 ❺。在 ❻ 处，我们将输出存储到 result 变量中。我们使用 grep 和 awk 解析 curl 的结果并提取 Server 头信息。
- en: 'Run the script, and when prompted, provide the IP address 172.16.10.10 and
    port 8081:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，并在提示时提供 IP 地址 172.16.10.10 和端口 8081：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the script returns the correct information from the target IP
    address and port. If we didn’t specify a port in the terminal, it would have defaulted
    to port 80\. Note that we could have used Netcat to send HTTP HEAD requests too,
    but it’s useful to know more than one method to achieve a given task.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，脚本返回了从目标 IP 地址和端口获取的正确信息。如果我们在终端中没有指定端口，它会默认使用端口 80\. 请注意，我们也可以使用 Netcat
    发送 HTTP HEAD 请求，但了解多种实现给定任务的方法是很有用的。
- en: Using Nmap Scripts
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Nmap 脚本
- en: 'Nmap is more than just a port scanner; we can transform it into a full-fledged
    vulnerability assessment tool. The *Nmap Scripting Engine (NSE)* allows penetration
    testers to write scripts in the Lua language to extend Nmap’s capabilities. Nmap
    comes preinstalled with some Lua scripts, as you can see here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 不仅仅是一个端口扫描器；我们可以将其转化为一个功能齐全的漏洞评估工具。*Nmap 脚本引擎 (NSE)* 允许渗透测试人员使用 Lua 语言编写脚本来扩展
    Nmap 的功能。Nmap 预装了一些 Lua 脚本，正如你在这里所见：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The *banner.nse* script in the */usr/share/nmap/scripts* folder allows you
    to grab the banners from many hosts simultaneously. The following bash command
    uses this script to perform a banner grab and service discovery (-sV):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*banner.nse* 脚本位于 */usr/share/nmap/scripts* 文件夹中，允许你同时从多个主机抓取 banner。以下 bash
    命令使用此脚本执行 banner 抓取和服务发现（-sV）：'
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When the banner-grabbing script finds a banner, the output line containing
    that banner will begin with a special character sequence (|_). We can filter for
    this sequence to extract banner information, like so:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当 banner 抓取脚本找到一个 banner 时，包含该 banner 的输出行将以特殊的字符序列（|_）开头。我们可以过滤这个序列来提取 banner
    信息，方法如下：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You may have noticed that, in the case of 172.16.10.10 port 8081 (the *p-web-01*
    machine), Nmap responds with the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，在 172.16.10.10 的 8081 端口（*p-web-01* 机器）的情况下，Nmap 会做出如下回应：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The blackice-icecap? value indicates that Nmap is unable to definitively discover
    the identity of the service. But if you look closely at the fingerprint -strings
    dump, you’ll see some HTTP-related information that reveals the same response
    headers we found when banner grabbing manually using curl. Specifically, note
    the Werkzeug web server banner. With a bit of googling, you’ll find that this
    server runs on Flask, a Python-based web framework.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: blackice-icecap? 值表示 Nmap 无法明确发现服务的身份。但如果你仔细查看指纹 -strings 转储，你会看到一些与 HTTP 相关的信息，揭示了我们手动使用
    curl 进行 banner 抓取时发现的相同响应头。具体来说，请注意 Werkzeug Web 服务器的 banner。稍微 Google 一下，你会发现这个服务器运行在
    Flask 上，这是一个基于 Python 的 Web 框架。
- en: Detecting Operating Systems
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作系统检测
- en: Nmap can also guess the target server’s running operating system by using *TCP/IP
    fingerprinting*, which is part of its operating system detection scan. This technique
    identifies the implementation of the operating system’s TCP/IP stack by crafting
    packets in various ways and analyzing the returned responses. Each operating system
    (such as Linux, Windows, and macOS) implements the TCP/IP stack slightly differently,
    and Nmap analyzes these subtle differences to identify the running system. In
    some cases, Nmap may also be able to identify the running kernel version.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 还可以通过使用 *TCP/IP 指纹识别* 来猜测目标服务器的操作系统，这也是其操作系统检测扫描的一部分。此技术通过以不同方式构造数据包并分析返回的响应，识别操作系统
    TCP/IP 堆栈的实现。每个操作系统（如 Linux、Windows 和 macOS）对 TCP/IP 堆栈的实现略有不同，Nmap 分析这些微妙的差异来识别运行的系统。在某些情况下，Nmap
    还可能能够识别运行的内核版本。
- en: 'To run an operating system detection scan, use the -O flag in Nmap. Note that
    this scan requires sudo privileges:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行操作系统检测扫描，请在 Nmap 中使用 -O 标志。请注意，此扫描需要 sudo 权限：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Let’s create a bash script that can parse this output and sort it by IP address
    and operating system ([Listing 4-13](chapter4.xhtml#Lis4-13)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 bash 脚本，解析此输出并按 IP 地址和操作系统进行排序（[Listing 4-13](chapter4.xhtml#Lis4-13)）。
- en: os_detection.sh
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: os_detection.sh
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 4-13: Parsing an operating system detection scan'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-13: 解析操作系统检测扫描'
- en: Because this scan requires root privileges, we check for the effective user’s
    ID ❶. If the user ID isn’t equal to zero, we exit because there is no point in
    continuing if the user isn’t using root privileges. We then check whether the
    user passed target hosts as arguments on the command line ❷. At ❸, we run the
    Nmap operating system detection scan against these targets, which we’ve assigned
    to the HOSTS variable.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因为此扫描需要 root 权限，我们会检查有效用户的 ID ❶。如果用户 ID 不等于零，则退出，因为如果用户没有使用 root 权限，继续进行没有意义。然后我们检查用户是否在命令行中传递了目标主机
    ❷。在 ❸，我们对这些目标运行 Nmap 操作系统检测扫描，并将其分配给 HOSTS 变量。
- en: We use a while loop ❹ to iterate through the scan results, parsing each line
    and assigning the IP address in the output to the ip variable. We then parse the
    line a second time to extract the operating system information from Nmap. We use
    sed to clean the output so it shows only the operating system, removing everything
    after the word Seq. Next, we check whether both the ip and os variables are set
    ❺. If they are, this means we’ve parsed the output correctly and can finish the
    script by printing the IP address and the operating system type.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个 while 循环 ❹ 遍历扫描结果，解析每一行，并将输出中的 IP 地址赋值给 ip 变量。然后我们再次解析该行，提取 Nmap 的操作系统信息。我们使用
    sed 清理输出，使其仅显示操作系统信息，删除 Seq 字样后的所有内容。接下来，我们检查 ip 和 os 变量是否都已设置 ❺。如果都已设置，意味着我们已正确解析了输出，可以通过打印
    IP 地址和操作系统类型来完成脚本。
- en: 'To understand why we parse the output the way we do, using grep, awk and sed,
    run the following command in a separate terminal:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们为什么以这种方式解析输出，使用 grep、awk 和 sed，可以在一个单独的终端中运行以下命令：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, the output is separated by whitespaces. The IP address is found
    immediately after the first space, and the operating system type comes after the
    word OS: but before the word Seq, which is why we needed to extract the text between
    these two. You can do this parsing in other ways too, such as with regular expressions;
    this is just one way of achieving the task.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，输出是由空格分隔的。IP 地址位于第一个空格之后，操作系统类型位于 OS: 之后，但在 Seq 之前，这就是为什么我们需要提取这两个词之间的文本。你也可以用其他方法进行解析，比如使用正则表达式；这只是实现任务的一种方法。'
- en: 'Use the following command to save and run the script:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令保存并运行脚本：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point, we’ve identified a couple of HTTP servers, an FTP server, and
    an SSH server. Let’s take a closer look at the HTTP servers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经识别出几个 HTTP 服务器、一个 FTP 服务器和一个 SSH 服务器。接下来，我们仔细看看 HTTP 服务器。
- en: Analyzing Websites and JSON
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网站分析与 JSON
- en: 'Let’s use WhatWeb to see the services running on the web applications in the
    172.16.10.0/24 network. We’ll begin by looking at 172.16.10.10 (*p-web-01*) on
    port 8081:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 WhatWeb 查看 172.16.10.0/24 网络中运行的 Web 应用程序的服务。我们将首先查看 172.16.10.10（*p-web-01*）上的
    8081 端口：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: WhatWeb’s output is printed to standard output by default, separated by spaces
    and commas. As you can see, it found some information about the technology running
    on this web server.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: WhatWeb 的输出默认打印到标准输出，内容由空格和逗号分隔。如你所见，它找到了关于此 Web 服务器运行技术的一些信息。
- en: We could parse this output quite easily with tools such as awk and grep, but
    to introduce you to new techniques, we’ll instead explore how to parse *JavaScript
    Object Notation (JSON)* output. JSON is a data format composed of keys and values.
    To parse it, it’s helpful to use a tool like jq to traverse the JSON structure
    and extract the information we need.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 awk 和 grep 等工具轻松解析此输出，但为了向你介绍一些新技巧，我们将探索如何解析 *JavaScript 对象表示法（JSON）*
    输出。JSON 是由键和值组成的数据格式。为了解析它，使用像 jq 这样的工具来遍历 JSON 结构并提取我们需要的信息会非常有帮助。
- en: 'WhatWeb can format the output in JSON with the --log-json parameter, which
    expects a filename passed as its value. But what if we want to send the output
    to the screen without writing it to the disk? We can provide the parameter with
    the */dev/stdout* file, forcing it to send its output to standard output:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: WhatWeb 可以通过 --log-json 参数将输出格式化为 JSON，该参数需要传入一个文件名作为值。但如果我们想将输出发送到屏幕而不写入磁盘怎么办？我们可以将参数指定为
    */dev/stdout* 文件，强制它将输出发送到标准输出：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now the output is printed to standard output and formatted in JSON. As you can
    see, we get the same information as when we ran the basic whatweb command, without
    the special formatting.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出被打印到标准输出，并以 JSON 格式显示。如你所见，我们获得的信息与运行基础的 whatweb 命令时得到的信息相同，只是没有特殊的格式。
- en: 'The output is an array of objects, and we can use a tool such as jq to extract
    the relevant information. For example, let’s extract the value of HTTPServer:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个对象数组，我们可以使用像 jq 这样的工具来提取相关信息。例如，让我们提取 HTTPServer 的值：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The jq syntax might seem a little odd at first, so let’s dissect it. We place
    the pattern to extract between two single quotes ('). Here, we select the first
    element in the array (.[0]), which contains various objects composed of keys and
    values. Then we select the plugins key, followed by the HTTPServer key. Within
    the HTTPServer key, there is another key named string, which is an array. We select
    the first element in that array by using string[0], which holds the value Werkzeug/2.3.7
    Python/3.11.4.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: jq 语法刚开始可能看起来有点奇怪，我们来逐步解析它。我们将提取模式放在两个单引号（'）之间。在这里，我们选择数组中的第一个元素（.[0]），该元素包含由键和值组成的各种对象。接着，我们选择
    plugins 键，再选择 HTTPServer 键。在 HTTPServer 键内，有一个名为 string 的键，它是一个数组。我们使用 string[0]
    来选择该数组中的第一个元素，它包含的值是 Werkzeug/2.3.7 Python/3.11.4。
- en: 'Similarly, we can extract the IP address. Just swap the HTTPServer key with
    the IP key:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以提取 IP 地址。只需将 HTTPServer 键替换为 IP 键：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Go ahead and run WhatWeb against every web server we’ve identified to see the
    technologies they run.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行 WhatWeb，检查我们已识别的每个 Web 服务器，查看它们运行的技术。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we put bash to use in many ways. We created dynamic target
    host lists; used multiple tools to perform host discovery, port scanning, and
    banner grabbing; created an automated script to notify us of newly discovered
    hosts; and parsed various tool results. In the next chapter, we’ll run vulnerability
    scanners and fuzzers against these targets.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以多种方式运用了bash。我们创建了动态目标主机列表；使用多种工具执行主机发现、端口扫描和横幅获取；创建了一个自动化脚本来通知我们新发现的主机；并解析了各种工具的结果。在下一章中，我们将对这些目标运行漏洞扫描器和模糊测试工具。
