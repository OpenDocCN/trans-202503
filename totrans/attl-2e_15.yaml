- en: '15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FLAIM PART II: PUSHING THE ENVELOPE'
  prefs: []
  type: TYPE_NORMAL
- en: '*What we do in college is to get over our little-mindedness. Education—to get
    it you have to hang around till you catch on.'
  prefs: []
  type: TYPE_NORMAL
- en: —Robert Lee Frost*^([1](footnote.xhtml#ch15fn1))
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s a well-understood principle that no matter how many books you read, or
    how many lectures you attend, or how many queries you present on mailing lists,
    you’ll still be left with unanswered questions. It’s estimated that half of the
    world’s population has access to the internet today.^([2](footnote.xhtml#ch15fn2))
    There are thousands of terabytes of information available from your desktop. Nevertheless,
    it seems every project has one or two issues that are just different enough from
    all others that even internet searches are fraught with futility.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the potential frustration of learning the Autotools, this chapter
    continues with the FLAIM build system conversion project by tackling some of the
    less common features of FLAIM’s build system requirements. My hope is that by
    presenting solutions to some of these less common problems, you’ll become familiar
    with the underlying framework provided by the Autotools. Such familiarity provides
    the insight needed to bend the Autotools to your own unique requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The *xflaim* library provides Java and C# language bindings. Automake provides
    rudimentary support for building Java sources but currently provides no built-in
    support for building C# sources. In this chapter, I’ll show you how to use Automake’s
    built-in Java support to build the Java language bindings in xflaim, and then
    I’ll show you how to write your own `make` rules for the C# language bindings.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll round out this chapter, and finish up the FLAIM conversion pro­ject, with
    discussions of using native compiler options, building generated documentation,
    and adding your own top-level recursive `make` targets.
  prefs: []
  type: TYPE_NORMAL
- en: Building Java Sources Using the Autotools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *GNU Automake Manual* presents information on building Java sources in two
    different ways. The first is the traditional and widely understood method of compiling
    Java source code into Java byte code, which can then be executed within the Java
    virtual machine (JVM). The second way is the lesser-known method of compiling
    Java source code directly into native machine code using the GNU Compiler for
    Java (`gcj`) frontend to the GNU compiler tool suite. The object files containing
    this machine code can then be linked together into native executable programs
    using the standard GNU linker. Probably due to lack of interest, and to the JVM’s
    having been vastly improved over the years, the GCJ project is no longer being
    maintained. It’s therefore likely that all support for this mechanism will soon
    be entirely dropped from the Autotools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll focus on the former—building Java class files from Java
    source files using the Automake built-in `JAVA` primary. We’ll also explore the
    necessary extensions required to build and install *.jar* files.
  prefs: []
  type: TYPE_NORMAL
- en: '*Autotools Java Support*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Autoconf has little, if any, built-in support for Java. For example, it provides
    no macros that locate Java tools in the end user’s environment.^([3](footnote.xhtml#ch15fn3))
    Automake’s built-in support for building Java classes is minimal, but getting
    it to work is not really that difficult if you’re willing to dig in a bit. The
    biggest stumbling block is conceptual more than functional. You have to work a
    little to align your understanding of the Java build process with that of the
    Automake designers.
  prefs: []
  type: TYPE_NORMAL
- en: Automake provides a built-in primary (`JAVA`) for building Java sources, but
    it does not provide any preconfigured installation location prefixes for installing
    Java classes. However, the usual place to install Java classes and *.jar* files
    is in the `$(datadir)`*/java* directory, so creating a proper prefix is as simple
    as using the Automake prefix extension mechanism of defining a variable suffixed
    with *dir*, as shown in [Listing 15-1](ch15.xhtml#ch15ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-1: Defining a Java installation directory in a* Makefile.am *file*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you don’t often want to install Java sources, which is what you will accomplish
    when you define your `JAVA` primary in this manner. Rather, you want the *.class*
    files to be installed, or more likely a *.jar* file containing all of your *.class*
    files. It’s generally more useful, therefore, to define the `JAVA` primary with
    the `noinst` prefix. Additionally, files in a `JAVA` primary list are not distributed
    by default, so you may even want to use the `dist` super-prefix, as shown in [Listing
    15-2](ch15.xhtml#ch15ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-2: Defining a list of non-installed Java files that are distributed*'
  prefs: []
  type: TYPE_NORMAL
- en: When you define a list of Java source files in a variable containing the `JAVA`
    primary, Automake generates a `make` rule that builds that list of files all in
    one command, using the syntax shown in [Listing 15-3](ch15.xhtml#ch15ex3).^([4](footnote.xhtml#ch15fn4))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-3: This long shell command was taken from a* Makefile *generated
    by Automake.*'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the code you see in these commands exists solely to prepend the `$(srcdir)`
    prefix onto each file in the user-specified list of Java sources in order to properly
    support `VPATH` builds. This code uses a shell `for` statement to split the list
    into individual files, prepend the `$(srcdir)`, and then reassemble the list.^([5](footnote.xhtml#ch15fn5))
  prefs: []
  type: TYPE_NORMAL
- en: The part that actually does the work of building the Java sources is found in
    two lines (four wrapped lines, actually)^([6](footnote.xhtml#ch15fn6)) near the
    bottom at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Automake generates a stamp file at ➋ because the single `$(JAVAC)` command generates
    several *.class* files from the *.java* files. Rather than choosing one of these
    files at random, Automake generates and uses a stamp file as the target of the
    rule, which causes `make` to ignore the relationships between individual *.class*
    files and their corresponding *.java* files. That is, if you delete a *.class*
    file, the rules in the makefile will not cause it to be rebuilt. The only way
    to cause the re-execution of the `$(JAVAC)` command is to either modify one or
    more of the *.java* files, thereby causing their timestamps to become newer than
    that of the stamp file, or delete the stamp file entirely.
  prefs: []
  type: TYPE_NORMAL
- en: The variables used in the build environment and on the command line include
    `JAVAROOT`, `JAVAC`, `JAVACFLAGS`, `AM_JAVACFLAGS`, and `CLASSPATH_ENV`. Each
    variable may be specified in the *Makefile.am* file.^([7](footnote.xhtml#ch15fn7))
    If a variable is not specified, the defaults shown in [Listing 15-3](ch15.xhtml#ch15ex3)
    are used instead.
  prefs: []
  type: TYPE_NORMAL
- en: All *.java* files specified in a `JAVA` primary variable are compiled using
    a single command line, which may pose a problem on systems with limited command
    line lengths. If you encounter such a problem, you can either break up your Java
    project into multiple Java source directories or develop your own `make` rules
    for building Java classes. (When I discuss building C# code in “Building the C#
    Sources” on [page 418](ch15.xhtml#page_418), I demonstrate how to write such custom
    rules.)
  prefs: []
  type: TYPE_NORMAL
- en: The `CLASSPATH_ENV` variable sets the Java `CLASSPATH` environment variable
    so that it contains `$(JAVAROOT)`, `$(srcdir)/$(JAVAROOT)`, and then any class
    path that may have been configured in the environment by the end user.
  prefs: []
  type: TYPE_NORMAL
- en: The `JAVAROOT` variable is used to specify the location of the project’s Java
    root directory within the project’s build tree, where the Java compiler will expect
    to find the start of generated package directory hierarchies belonging to your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: The `JAVAC` variable contains `javac` by default, with the assumption that `javac`
    can be found in the system path. The `AM_JAVACFLAGS` variable may be set in *Makefile.am*,
    though the non-Automake version of this variable (`JAVACFLAGS`) is considered
    a user variable and thus shouldn’t be set in makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: This is all fine as far as it goes, but it doesn’t go nearly far enough. In
    this relatively simple Java project, we still need to generate Java native interface
    (JNI) header files using the `javah` utility as well as a *.jar* file from the
    *.class* files built from the Java sources. Unfortunately, Automake-provided Java
    support doesn’t even begin to handle these tasks, so we’ll have to do the rest
    with handcoded `make` rules. We’ll begin with Autoconf macros to ensure that we
    have a good Java build environment.
  prefs: []
  type: TYPE_NORMAL
- en: '*Using ac-archive Macros*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The GNU Autoconf Archive supplies community-contributed Autoconf macros that
    come close to what we need in order to ensure that we have a good Java development
    environment. In this particular case, I downloaded the latest source package and
    just hand-installed the *.m4* files that I needed into the *xflaim/m4* directory.^([8](footnote.xhtml#ch15fn8))
  prefs: []
  type: TYPE_NORMAL
- en: Then I modified the files (including their names) to work the way my `FLM_PROG_TRY_DOXYGEN`
    macro works. I wanted to locate any existing Java tools, but I also wanted be
    able to continue without them if necessary. Though it has gotten much better in
    the last 10 years, given the politics surrounding the existence of Java tools
    in Linux distributions, this is probably a wise approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'I created the following macros within corresponding Java-related *.m4* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLM_PROG_TRY_JAVAC` is defined in *flm_prog_try_javac.m4*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLM_PROG_TRY_JAVAH` is defined in *flm_prog_try_javah.m4*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLM_PROG_TRY_JAVADOC` is defined in *flm_prog_try_javadoc.m4*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLM_PROG_TRY_JAR` is defined in *flm_prog_try_jar.m4*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLM_PROG_TRY_JNI` is defined in *flm_prog_try_jni.m4*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With a bit more effort, I was also able to create the C# macros I needed to
    accomplish the same tasks for the C# language bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLM_PROG_TRY_CSC` is defined in *flm_prog_try_csc.m4*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLM_PROG_TRY_CSVM` is defined in *flm_prog_try_csvm.m4*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 15-4](ch15.xhtml#ch15ex4) shows the portion of the xflaim *configure.ac*
    file that invokes these Java and C# macros.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-4:* xflaim/configure.ac: *The portion of this file that searches
    for Java and C# tools*'
  prefs: []
  type: TYPE_NORMAL
- en: These macros set the `CSC`, `CSVM`, `JAVAC`, `JAVAH`, `JAVADOC`, and `JAR` variables
    to the location of their respective C# and Java tools and then substitute them
    into the xflaim project’s *Makefile.in* templates using `AC_SUBST`. If any of
    these variables are already set in the user’s environment when the `configure`
    script is executed, their values are left untouched, thus allowing the user to
    override the values that would have been set by the macros.
  prefs: []
  type: TYPE_NORMAL
- en: I discuss the internal operation of these macros in [Chapter 16](ch16.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '*Canonical System Information*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The only non-obvious bit of information you need to know about using macros
    from the GNU Autoconf Archive is that many of them rely on the built-in Autoconf
    macro, `AC_CANONICAL_HOST`. Autoconf provides a way to automatically expand any
    macros used internally by a macro definition right before the definition so that
    required macros are made available immediately. However, if `AC_CANONICAL_HOST`
    is not used before certain macros (including `LT_INIT`), `autoreconf` will generate
    about a dozen warning messages.
  prefs: []
  type: TYPE_NORMAL
- en: To eliminate these warnings, I added `AC_CANONICAL_TARGET` to my xflaim-level
    *configure.ac* file, immediately after the call to `AC_INIT`. The `AC_CANONICAL_SYSTEM`
    macro, and the macros that it calls (`AC_CANONICAL_BUILD`, `AC_CANONICAL_HOST`,
    and `AC_CANONICAL_TARGET`), are designed to ensure that the `$build`, `$host`,
    and `$target` environment variables are defined by `configure` to contain appropriate
    values describing the user’s build, host, and target systems, respectively. Because
    I’m not doing any cross-compiling in this build system, I only needed to invoke
    `AC_CANONICAL_TARGET`.
  prefs: []
  type: TYPE_NORMAL
- en: These variables contain canonical values for the build, host, and target CPU,
    vendor, and operating system. Values like these are very useful to extension macros.
    If a macro can assume these variables are set properly, then it saves quite a
    bit of code duplication in the macro definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of these variables are calculated using the helper scripts `config
    .guess` and `config.sub`, which are distributed with Autoconf.^([9](footnote.xhtml#ch15fn9))
    The `config.guess` script uses a combination of `uname` commands to ferret out
    information about the build system, then uses that information to derive a set
    of canonical values for CPU, vendor, and operating system. The `config.sub` script
    is used to reformat build, host, and target information specified by the user
    on the `configure` command line into a canonical value. The host and target values
    default to that of the build, unless you override them with command line options
    to `configure`. Such an override might be used when cross-compiling. (See “Item
    6: Cross-Compiling” on [page 517](ch18.xhtml#page_517) for a more detailed explanation
    of cross-compiling within the Autotools framework.)'
  prefs: []
  type: TYPE_NORMAL
- en: '*The xflaim/java Directory Structure*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The original xflaim source layout had the Java JNI and C# native sources located
    in directory structures outside of *xflaim/src*. The JNI sources were in *xflaim/java/jni*,
    and the C# native sources were in *xflaim/csharp/xflaim*. While Automake can generate
    rules for accessing files outside the current directory hierarchy, it seems silly
    to put these files so far away from the only library they can really belong to.
    Therefore, in this case, I broke my own rule about not rearranging files and moved
    the contents of these two directories beneath *xflaim/src*. I named the JNI directory
    *xflaim/src/java* and the C# native sources directory *xflaim/src/cs*. The following
    diagram illustrates this new directory hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I also added a *wrapper* directory beneath the *java* directory,
    in which I rooted the xflaim wrapper package hierarchy. Since the Java xflaim
    wrapper classes are part of the Java xflaim package, they must be located in a
    directory called *xflaim*. Nevertheless, the build happens in the wrapper directory.
    There are no build files found in the *wrapper/xflaim* directory or any directories
    below that point.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*No matter how deep your package hierarchy is, you will still build the Java
    classes in the* wrapper *directory, which is the *`JAVAROOT`* directory for this
    project. Autotools Java projects consider the *`JAVAROOT`* directory the build
    directory for the java package.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The xflaim/src/Makefile.am File*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this point, the *configure.ac* file is doing about all it can to ensure that
    I have a good Java build environment, in which case my build system will be able
    to generate my JNI wrapper classes and header files and build my C++ JNI sources.
    If my end user’s system doesn’t provide these tools, they simply won’t be able
    to build or link the JNI language bindings to the *xflaim* library on that host.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the *xflaim/src/Makefile.am* file shown in [Listing 15-5](ch15.xhtml#ch15ex5)
    and examine the portions that are relevant to building the Java and C# language
    bindings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-5*: xflaim/src/Makefile.am: *The portion of this makefile that
    builds Java and C# sources*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already explained the use of the conditionals to ensure that the *java*
    and *cs* directories are only built if the proper conditions are met. You can
    now see how this fits into the build system I’ve created so far.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I’m conditionally defining two new library variables. If I can build
    the Java language bindings, the *java* subdirectory will be built, and the `JNI_LIBADD`
    variable will refer to the library that is built in the *java* directory. If I
    can build the C# language bindings, the *cs* subdirectory will be built, and the
    `CSI_LIBADD` variable will refer to the library that is built in the *cs* directory.
    In either case, if the required tools are not found by `configure`, the corresponding
    variable will remain undefined. When an undefined `make` variable is referenced,
    it expands to nothing, so there’s no harm in using it in `libxflaim_la_LIBADD`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Building the JNI C++ Sources*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now turn your attention to the *xflaim/src/java/Makefile.am* file shown in [Listing
    15-6](ch15.xhtml#ch15ex6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-6*: xflaim/src/java/Makefile.am: *This makefile builds the JNI
    sources.*'
  prefs: []
  type: TYPE_NORMAL
- en: Again, I want the *wrapper* directory to be built first (the dot at the end
    of the `SUBDIRS` list is implied), before the *xflaim* library, because the *wrapper*
    directory will build the class files and JNI header files required by the JNI
    convenience library sources. Building this directory is not conditional. If I’ve
    made it this far into the build hierarchy, I know I have all the Java tools I
    need. This *Makefile.am* file simply builds a convenience library containing my
    JNI C++ interface functions.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way Libtool builds both shared and static libraries from the
    same sources, this convenience library will become part of both the *xflaim* shared
    and static libraries. The original build system makefile accounted for this by
    linking the JNI and C# native interface objects only into the shared library (where
    they make sense).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The fact that these libraries are added to both the shared and static* xflaim
    *libraries is not really a problem. Objects in a static library remain unused
    in applications or libraries linking to the static library, as long as functions
    and data in those objects remain unreferenced, though this is a bit of a wart
    on my new build system.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Java Wrapper Classes and JNI Headers*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, *xflaim/src/java/wrapper/Makefile.am* takes us to the heart of the
    matter. I’ve tried many different configurations for building Java JNI wrappers,
    and this one always comes out on top. [Listing 15-7](ch15.xhtml#ch15ex7) shows
    the *wrapper* directory’s Automake input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-7*: xflaim/src/java/wrapper/Makefile.am: *The wrapper directory’s*
    Makefile.am *file*'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the file, I’ve set the `JAVAROOT` variable to dot (`.`), because
    I want Automake to be able to tell the Java compiler that this is where the package
    hierarchy begins. The default value for `JAVAROOT` is `$(top_builddir)`, which
    would incorrectly have the wrapper class belong to the *xflaim.src.java.wrapper.xflaim*
    package.
  prefs: []
  type: TYPE_NORMAL
- en: I create a variable at ➊ called `jarfile`, which derives its value from `$(PACKAGE``_TARNAME)`
    and `$(PACKAGE_VERSION)`. (Recall from [Chapter 3](ch03.xhtml) that this is also
    how the `distdir` variable is derived, from which the name of the tarball comes.)
    A `make` rule indicates how the *.jar* file should be built. Here, I’m using the
    `JAR` variable, whose value was calculated by the `FLM_PROG_TRY_JNI` macro in
    the `configure` script.
  prefs: []
  type: TYPE_NORMAL
- en: I define a new installation variable at ➋ called `jardir` where *.jar* files
    are to be installed, and I use that variable as the prefix for a `DATA` primary
    at ➌. Automake considers files that fit the Automake *`where_HOW`* scheme (with
    a defined *`where`*`dir`) as either architecture-independent data files or platform-specific
    executables. Installation location variables (those ending in `dir`) that begin
    with `bin`, `sbin`, `libexec`, `sysconf`, `localstate`, `lib`, or `pkglib` or
    that contain the string “exec” are considered platform-specific executables and
    are installed during execution of the `install-exec` target. Automake considers
    files installed in any other locations data files. These are installed during
    execution of the `install-data` target. The well-known installation locations
    such as *bindir*, *sbindir*, and so on are already taken, but if you want to install
    custom architecture-dependent executable files, just ensure that your custom installation
    location variable contains the string “exec,” as in `myspecialexecdir`.
  prefs: []
  type: TYPE_NORMAL
- en: I use another stamp file at ➍ in the rule that builds the JNI header files from
    the *.class* files for the same reasons that Automake uses a stamp file in the
    rule that it uses to build *.class* files from *.java* source files.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most complex part of this makefile, so I’ll break it into smaller
    pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The rule states that the stamp file depends on the source files listed in the
    `dist_noinst_JAVA` variable. The command is a bit of complex shell script that
    strips the *.java* extensions from the file list and converts all the slash characters
    into periods. The reason for this is that the `javah` utility wants a list of
    class names, not a list of filenames. The `$(JAVAH)` command then accepts this
    entire list as input in order to generate a corresponding list of JNI header files.
    The last line, of course, generates the stamp file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally at ➎, I hook my `java-headers.stamp` target into the `all` target by
    adding it as a dependency to the `all-local` target. When the `all` target (the
    default for all Automake-generated makefiles) is executed in this makefile, *java-headers.stamp*
    will be built, along with the JNI headers.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s a good idea to add custom rule targets as dependencies to the Automake-provided
    hook and local targets, rather than directly associating commands with these hook
    and local targets. By doing this, the commands for individual tasks on those targets
    remain isolated and thus easier to maintain.*'
  prefs: []
  type: TYPE_NORMAL
- en: I add the *.jar* file, all of the *.class* files, the *java-headers.stamp* file,
    and all of the generated JNI header files to the `CLEANFILES` variable at ➏ so
    that Automake will clean them up when `make clean` is executed. Again, I can use
    the `CLEANFILES` variable here because I’m not trying to delete any directories.
  prefs: []
  type: TYPE_NORMAL
- en: The final step in writing any such custom code is to ensure that the `distcheck`
    target still works, because when we generate our own products, we have to ensure
    that the `clean` target properly removes them all.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I should mention that the rule to build the *.jar* file, near the top
    of [Listing 15-7](ch15.xhtml#ch15ex7), relies on a wildcard to pick up all the
    *.class* files in the *xflaim* directory. The Autotools purposely avoid such wildcards
    for many reasons, including the very valid reason that you may inadvertently pick
    up files that were built by a previous build that are no longer relevant to your
    project after changes eliminate those sources from the project. For Java, the
    only way to specify the exact *.class* files that should go into the *.jar* file
    is to parse all the *.java* files and derive a list of *.class* files that would
    be built from those sources. I made a judgment call here and decided that using
    a wildcard was worth the possible problems doing so may cause. I also used wildcards
    in the `CLEANFILES` variable near the bottom of [Listing 15-7](ch15.xhtml#ch15ex7).
    Of course, the same potential problems exist here—you could remove a file that
    is present but no longer associated with the build.
  prefs: []
  type: TYPE_NORMAL
- en: '*A Caveat About Using the JAVA Primary*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The one important caveat to using the `JAVA` primary is that you may define
    only one `JAVA` primary variable per *Makefile.am* file. The reason for this is
    that multiple classes may be generated from a single *.java* file, and the only
    way to know which classes came from which *.java* file would be for Automake to
    parse the *.java* files (which is ridiculous, and arguably the primary reason
    why build tools like *Apache Ant* and *Maven* were developed). Rather than do
    this, Automake allows only one `JAVA` primary per file, so all *.class* files
    generated within a given build directory are installed in the location specified
    by the single `JAVA` primary variable prefix.^([10](footnote.xhtml#ch15fn10))
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The system I’ve designed will work fine for this case, but it’s a good thing
    I don’t need to install my JNI header files, because I have no way of knowing
    what they’re called from within my* Makefile.am *file*!'
  prefs: []
  type: TYPE_NORMAL
- en: You should by now be able to see the problems that the Autotools have with Java.
    In fact, these problems are not so much related to the design issues in the Autotools
    as they are to design issues within the Java language itself, as you’ll see in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building the C# Sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Returning to the *xflaim/src/cs* directory brings us to a discussion of building
    sources for a language for which Automake has no support: C#. [Listing 15-8](ch15.xhtml#ch15ex8)
    shows the *Makefile.am* file that I wrote for the *cs* directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-8*: xflaim/src/cs/Makefile.am: *The contents of the cs directory’s
    Automake input file*'
  prefs: []
  type: TYPE_NORMAL
- en: Not surprisingly, this looks almost identical to the *Makefile.am* file found
    in the *xflaim/src/java* directory because I’m building a simple convenience library
    from C++ source files found in this directory, just as I did in the *java* directory.
    As in the Java version, this makefile first builds a subdirectory called *wrapper*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-9](ch15.xhtml#ch15ex9) shows the full contents of the *wrapper/Makefile.am*
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-9*: xflaim/src/cs/wrapper/Makefile.am: *The full contents of the
    C# makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: The default target for *Makefile.am* is `all`, the same as that of a normal
    non-Automake makefile. Again, I’ve hooked my code into the `all` target by implementing
    the `all-local` target, which depends on a file named *xflaim_csharp.dll*.^([11](footnote.xhtml#ch15fn11))
  prefs: []
  type: TYPE_NORMAL
- en: The C# sources are built by the commands under the *xflaim_csharp.dll* target
    at ➋, and the *xflaim_csharp.dll* binary depends on the list of C# source files
    specified in the `xfcs_sources` variable. The commands in this rule are copied
    from the Automake-generated *java/wrapper/Makefile* and are slightly modified
    to build C# binaries from C# source files (as highlighted in the listing). This
    isn’t intended to be a lesson in building C# sources; the point here is that the
    default target is automatically built by creating a dependency between the `all-local`
    target and your own targets at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: This *Makefile.am* file also builds a set of unit tests in C# that assess the
    C# language bindings. The target of this rule is *cstest.exe* (➌), which ultimately
    becomes a C# executable. The rule states that *cstest.exe* depends on *xflaim_csharp.dll*
    and the source files. I’ve again copied the commands from the rule for building
    *xflaim_csharp.dll* (as highlighted) and modified them for building the C# programs.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, upon building the `check` target, the Automake-generated makefile
    will attempt to execute the scripts or executables listed in the `TESTS` variable.
    The idea here is to ensure that all necessary components are built before these
    files are executed. I’ve tied into the `check` target by defining `check-local`
    and making it depend on my test code targets.
  prefs: []
  type: TYPE_NORMAL
- en: The `cstest_script` at ➍ is a shell script built solely to execute the *cstest.exe*
    binary within the C# virtual machine. The C# virtual machine is found in the `CSVM`
    variable, which was defined in `configure` by the code generated by the `FLM_PROG_TRY_CSVM`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: The `cstest_script` depends only on the `cstest.exe` program. However, the *xflaim*
    library either must be present in the current directory or must be in the system
    library search path. We gain maximum portability here by using Libtool’s *execute*
    mode to add the *xflaim* library to the system library search path before executing
    the C# virtual machine at ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '*Manual Installation*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since in this example I’m doing everything myself, I have to write my own installation
    rules. [Listing 15-10](ch15.xhtml#ch15ex10) reproduces only the installation rules
    in the *Makefile.am* file from [Listing 15-9](ch15.xhtml#ch15ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-10*: xflaim/src/cs/wrapper/Makefile.am: *The installation rules
    of this makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: According to the rules defined in the *GNU Coding Standards*, the installation
    targets do not depend on the binaries they install, so if the binaries haven’t
    been built yet, I may have to exit from *root* to my user account to build the
    binaries with `make all` first.
  prefs: []
  type: TYPE_NORMAL
- en: Automake distinguishes between installing programs and installing data. However,
    there’s only one `uninstall` target. The rationale seems to be that you might
    want to do an `install-exec` operation per system in your network, but only one
    shared `install-data` operation. Uninstalling a product requires no such separation,
    because uninstalling data multiple times is typically harmless.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cleaning Up Again*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As usual, things must be cleaned up properly in order to make distribution checks
    happy. The `clean-local` target handles this nicely, as shown in [Listing 15-11](ch15.xhtml#ch15ex11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-11*: xflaim/src/cs/wrapper/Makefile.am: *The clean rules defined
    in this makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Compiler Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original GNU Make build system provided a number of command line build options.
    By specifying a list of auxiliary targets on the `make` command line, the user
    could indicate that they wanted a debug or release build, force a 32-bit build
    on a 64-bit system, generate generic SPARC code on a Solaris system, and so on.
    This was a turnkey approach to build systems that is quite common in commercial
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In open source projects, and particularly in Autotools-based build systems,
    the more common practice is to omit much of this rigid framework, allowing the
    user to set their own options in the standard user variables: `CC`, `CPP`, `CXX`,
    `CFLAGS`, `CXXFLAGS`, `CPPFLAGS`, and so on.^([12](footnote.xhtml#ch15fn12))'
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most compelling argument for the Autotools approach to option management
    is that it’s policy driven and the rigid frameworks used by commercial software
    vendors can easily be implemented in terms of the much more flexible policy-driven
    Autotools framework. For example, a *config.site* file might be used to provide
    site-wide options for all Autotools-based builds done at a particular site. A
    simple script can be used to configure various environment-based options before
    calling `configure`, or these options may even be passed to `configure` or `make`
    directly within such a script. The Autotools policy-driven approach offers the
    flexibility to be as configurable as a developer might want or as tight as required
    by management.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, we’d like to have FLAIM project options conform to the Autotools
    policy-driven approach; however, I didn’t want to lose the research effort involved
    in determining the hardcoded native compiler options specified in the original
    makefile. To this end, I’ve added back in *some* of the options to the *configure.ac*
    file that were supported by the original build system, but I’ve left others out.
    [Listing 15-12](ch15.xhtml#ch15ex12) shows the end result of these efforts. This
    code enables various native compiler options, optimizations, and debugging features
    on demand, based on the contents of some of the user variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-12*: xflaim/configure.ac: *The portion of this file that enables
    compiler-specific options*'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this code depends on the earlier use of the `AC_CANONICAL_SYSTEM`
    (or `AC_CANONICAL_TARGET`) macro, which sets `build`, `host`, and `target` environment
    variables to canonical string values that indicate CPU, vendor, and operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 15-12](ch15.xhtml#ch15ex12), I used the `host` variable in the `case`
    statement at ➊ to determine the type of system for which I was building. This
    `case` statement determines if the user is building on Solaris, Apple Darwin,
    AIX, or HP-UX by looking for substrings in `host` that are common to all variations
    of these platforms. The `config.guess` and `config.sub` files are your friends
    here. If you need to write code like this for your project, examine these files
    to find common traits for the processes and systems for which you’d like to set
    various compiler and linker options.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In each of these cases (except for the definition of the *`OSX`* preprocessor
    variable on Apple Darwin systems), I’m really only setting flags for native compilers.
    The GNU compiler tools seem to be able to handle any code without the need for
    additional compiler options. It’s worth reiterating here that the Autotools feature-present
    approach to setting options once again wins. Maintenance is reduced dramatically
    when you don’t have to support large *`case`* statements for an ever-growing list
    of supported hosts and tool sets.*'
  prefs: []
  type: TYPE_NORMAL
- en: Hooking Doxygen into the Build Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I want to generate documentation as part of my build process, if possible. That
    is, if the user has `doxygen` installed, the build system will use it to build
    Doxygen documentation as part of the `make all` process.
  prefs: []
  type: TYPE_NORMAL
- en: The original build system has both static and generated documentation. The static
    documentation should always be installed, but the Doxygen documentation can only
    be built if the `doxygen` program is available on the host. Thus, I always build
    the *docs* directory, but I use the `AM_CONDITIONAL` macro to conditionally build
    the *docs/doxygen* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Doxygen uses a configuration file (often called *doxyfile*) to configure literally
    hundreds of Doxygen options. This configuration file contains some information
    that is known to the configuration script. This sounds like the perfect opportunity
    to use an Autoconf-generated file. To this end, I’ve written an Autoconf template
    file called *doxyfile.in* that contains most of what a normal Doxygen input file
    would contain, as well as a few Autoconf substitution variable references. The
    relevant lines in this file are shown in [Listing 15-13](ch15.xhtml#ch15ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-13*: xflaim/docs/doxygen/doxyfile.in: *The lines in this file that
    contain Autoconf variables*'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other lines in this file, but they are all identical to the output
    file, so I’ve omitted them for the sake of space and clarity. The key here is
    that `config.status` will replace these substitution variables with their values
    as defined in *configure.ac* and by Autoconf itself. If these values change in
    *configure.ac*, the generated file will be rewritten with the new values. I’ve
    added a conditional reference for *xflaim/docs/doxygen/doxyfile* to the `AC_CONFIG_FILES`
    list in xflaim’s *configure.ac* file. That’s all it takes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-14](ch15.xhtml#ch15ex14) shows the *xflaim/docs/doxygen/Makefile.am*
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-14*: xflaim/docs/doxygen/Makefile.am: *The full contents of this
    makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I create a package name at ➊ for the tarball that will contain the Doxygen
    documentation files. This is basically the same as the distribution tarball for
    the xflaim project, except that it contains the text `-doxy` after the package
    name.
  prefs: []
  type: TYPE_NORMAL
- en: I define a `doc_DATA` variable at ➋ that contains the name of the Doxygen tarball.
    This file will be installed in the `$(docdir)` directory, which by default is
    `$(datarootdir)`*/doc/*`$(PACKAGE_TARNAME)`, and `$(datarootdir)` is configured
    by Automake as `$(prefix)`*/share*, by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* `DATA` *primary brings with it significant Automake functionality—installation
    is managed automatically. While I must build the Doxygen documentation package,
    the* `DATA` *primary automatically hooks the* `all` *target for me so that my
    package is built when the user executes* `make` *or* `make all`.'
  prefs: []
  type: TYPE_NORMAL
- en: I use another stamp file at ➌ because Doxygen generates literally hundreds of
    *.html* files from the source files in my project. Rather than attempt to figure
    out a rational way to assign dependencies, I’ve chosen to generate one stamp file
    and then use that to determine whether the documentation is out-of-date.^([13](footnote.xhtml#ch15fn13))
  prefs: []
  type: TYPE_NORMAL
- en: I also decided that it would be nice to unpack the documentation archive into
    the package *doc* directory. Left up to Automake, the tarball would make it into
    the proper directory at installation time, but that’s as far as it would go. I
    needed to be able to hook the installation process to do this, and this is the
    perfect use for an Automake `-hook` target. I use the `install-data-hook` target
    at ➍ because the `-hook` targets allow you to perform extra user-defined shell
    commands after the operation that’s being hooked has completed. Likewise, I use
    `uninstall-hook` to remove the *html* directory created when the *.tar* file was
    extracted during installation. (There is no distinction between uninstalling platform-specific
    and platform-independent files, so there is only one hook for uninstalling files.)
  prefs: []
  type: TYPE_NORMAL
- en: To clean my generated files, I use a combination of the `CLEANFILES` variable
    at ➎ and a `clean-local` rule just to demonstrate that it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Nonstandard Targets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a new nonstandard target is a little different than hooking an existing
    target. In the first place, you don’t need to use `AM_CONDITIONAL` and other Autoconf
    tests to see if you have the tools you need. Instead, you can do all conditional
    testing from the *Makefile.am* file because you control the entire command set
    associated with the target, although this isn’t recommended practice. (It’s always
    preferable to ensure that the build environment is configured correctly from the
    `configure` script.) In cases where `make` targets can only be expected to work
    under certain conditions, or on certain platforms, it’s a good idea to provide
    checks within the target to ensure that the operation requested can actually be
    performed.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, I create a directory within each project root directory called
    *obs* to contain the *Makefile.am* file for building RPM package files. (*OBS*
    is an acronym for *openSUSE Build Service*, an online package-building service.)^([14](footnote.xhtml#ch15fn14))
  prefs: []
  type: TYPE_NORMAL
- en: Building RPM package files is done using a configuration file, called a *spec*
    file, which is very much like the *doxyfile* used to configure Doxygen for a specific
    project. As with the *doxyfile*, the RPM spec file references information that
    `configure` knows about the package. So, I wrote an *xflaim.spec.in* file, adding
    substitution variables where appropriate, and then added another file reference
    to the `AC_CONFIG_FILES` macro. This allows `configure` to substitute information
    about the project into the spec file. [Listing 15-15](ch15.xhtml#ch15ex15) shows
    the relevant portion of the *xflaim.spec.in* file in bold.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-15*: x flaim/obs/xflaim.spec.in: *The portion of this file that
    illustrates using Autoconf variables*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the variables `@PACKAGE_TARNAME@` and `@PACKAGE_VERSION@`
    in this listing. Although the tar name is not likely to change much over the life
    of this project, the version will change often. Without the Autoconf substitution
    mechanism, I’d have to remember to update this version number whenever I updated
    the version in the *configure.ac* file. [Listing 15-16](ch15.xhtml#ch15ex16) shows
    the *xflaim/obs/Makefile.am* file, which actually does the work of building the
    RPMs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-16*: xflaim/obs/Makefile.am: *The complete contents of this makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: Building RPM packages is rather simple, as you can see. The targets provided
    by this makefile include `srcrpm` and `rpms`. The `rpmcheck` target at ➊ is used
    internally to verify that RPMs can be built in the end user’s environment.
  prefs: []
  type: TYPE_NORMAL
- en: In order to find out which targets in a lower-level *Makefile.am* file are supported
    by a top-level build, look at the top-level *Makefile.am* file. As [Listing 15-17](ch15.xhtml#ch15ex17)
    shows, if the target is not passed down, that target must be intended for internal
    use only, within the lower-level directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-17*: xflaim/Makefile.am: *If the target is not passed down, it’s
    an internal target.*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the command at ➊ in [Listing 15-17](ch15.xhtml#ch15ex17),
    when a user targets `rpms` or `srcrpm` from the top-level build directory, the
    commands are recursively passed down to *obs/Makefile*. The remaining commands
    simply remove droppings left behind by the RPM build process that are simpler
    to remove at this level. (Try building an RPM package sometime, and you’ll see
    what I mean!)
  prefs: []
  type: TYPE_NORMAL
- en: Notice, too, that both of these top-level makefile targets depend on the `dist`
    target because the RPM build process requires the distribution tarball. Adding
    the tarball as a dependency of the `rpms` target simply ensures that the distribution
    tarball is there when the `rpmbuild` utility needs it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While using the Autotools, you have many details to manage—most of which, as
    they say in the open source software world, *can wait for the next release*! Even
    as I committed this code to the FLAIM project repository, I noticed details that
    could be improved. The takeaway lesson here is that a build system is never really
    finished. It should be incrementally improved over time, as you find time in your
    schedule to work on it. And it can be rewarding to do so.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve shown you a number of new features that have not been covered in earlier
    chapters, and there are many more features that I cannot begin to cover in this
    book. Study the Autotools manuals to become truly proficient. At this point, it
    should be pretty simple for you to pick up that additional information yourself.
  prefs: []
  type: TYPE_NORMAL
