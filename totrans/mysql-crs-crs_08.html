<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="63" id="Page_63"/><a class="XrefDestination" id="6"/><span class="XrefDestination" id="xref-503007c06-001"/>6</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="PerformingComplexJoinswithMultipleTables"/><span class="XrefDestination" id="xref-503007c06-002"/>Performing Complex Joins with Multiple Tables</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt="" width="200" height="200"/>
</figure>
<p class="ChapterIntro">In <a class="xref" href="c05.xhtml">Chapter 5</a>, you saw how to join two tables and display the data in one result set. In this chapter, you’ll create complex joins with more than two tables, learn about associative tables, and see how to combine or limit the results of a query. You’ll then explore different ways to temporarily save a query’s results in a table-like format, including temporary tables, derived tables, and Common Table Expressions (CTEs). Finally, you’ll learn how to work with subqueries, which let you nest one query inside another for more refined results.</p>
<h2 id="h1-503007c06-0001"><a class="XrefDestination" id="WritingOneQuerywithTwoJoinTypes"/><span class="XrefDestination" id="xref-503007c06-003"/>Writing One Query with Two Join Types</h2>
<p class="BodyFirst">Joining three or more tables introduces greater complexity than joining two, as you might have different join types (like an inner and an outer join) <span epub:type="pagebreak" title="64" id="Page_64"/>in the same query. For example, <a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a> illustrates three tables in the <code>police</code> database, which contains information on crimes, including the suspect and location.</p>
<figure>
<img src="image_fi/503007c06/f06001.png" class="" alt="" width="847" height="198"/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>: Three tables within the <span class="LiteralInCaption"><code>police</code></span> database</p></figcaption>
</figure>
<p>The <code>location</code> table contains the locations where the crimes occurred:</p>
<pre><code>location_id  location_name
-----------  -------------------------
    1        Corner of Main and Elm
    2        Family Donut Shop
    3        House of Vegan Restaurant</code></pre>
<p>The <code>crime</code> table contains a description of the crimes:</p>
<pre><code>crime_id  location_id  suspect_id  crime_name
--------  -----------  ----------  -------------------------------------
    1          1           1       Jaywalking
    2          2           2       Larceny: Donut
    3          3          null     Receiving Salad Under False Pretenses</code></pre>
<p>The <code>suspect</code> table contains information about the suspect:</p>
<pre><code>suspect_id  suspect_name
----------  ---------------
     1      Eileen Sideways
     2      Hugo Hefty</code></pre>
<p>Say you want to write a query that joins all three tables to get a list of crimes, where they occurred, and the name of the suspect. The <code>police</code> database was designed so that there will always be a matching location in the <code>location</code> table for every crime in the <code>crime</code> table. However, there may not be a matching suspect in the <code>suspect</code> table because the police have not identified a suspect for every crime.</p>
<p>You’ll perform an inner join between the <code>crime</code> and <code>location</code> tables, because you know there will be a match. But because there may not be a suspect match for each crime, you’ll do an outer join between the <code>crime</code> table and the <code>suspect</code> table. Your query might look like this:</p>
<pre><code>select c.crime_name,
       l.location_name,
       s.suspect_name
<span epub:type="pagebreak" title="65" id="Page_65"/>from   crime c
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> join   location l
  on   c.location_id = l.location_id
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> left join suspect s
  on   c.suspect_id = s.suspect_id;</code></pre>
<p>In this example, you alias the tables with <code>c</code> for <code>crime</code>, <code>l</code> for <code>location</code>, and <code>s</code> for <code>suspect</code>. You use the <code>join</code> syntax for the inner join between the <code>crime</code> and <code>location</code> tables <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and the <code>left join</code> syntax for the outer join to the <code>suspect</code> table <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>Using a left join might cause some confusion in this context. When you were using <code>left join</code> with only two tables in <a class="xref" href="c05.xhtml">Chapter 5</a>, it was easy to understand which was the left table and which was the right, because there were only two possibilities. But how does it work now that you’re joining three tables?</p>
<p>To understand multiple-table joins, imagine that MySQL is building temporary tables as it progresses through the query. MySQL joins the first two tables, <code>crime</code> and <code>location</code>, and the result of that join becomes the left table. Then MySQL does a <code>left join</code> between the <code>crime</code>/<code>location</code> combined table and the <code>suspect</code> table on the right.</p>
<p>You used a <em>left</em> join for the outer join because you want all of the crimes and locations to appear regardless of whether there is a match with the <code>suspect</code> table on the right. The results of this query are as follows:</p>
<pre><code>crime_name                             location_name           suspect_name
-------------------------------------  ----------------------  ---------------
Jaywalking                             Corner of Main and Elm  Eileen Sideways
Larceny: Donut                         Family Donut Shop       Hugo Hefty
Receiving Salad Under False Pretenses  Green Vegan Restaurant  null</code></pre>
<p>The suspect for the last crime was able to escape, so the value of the <code>suspect_name</code> on the last row is <code>null</code>. If you had used an inner join instead, the query wouldn’t have returned the last row, because inner joins return rows only where there is a match.</p>
<p>You can use the null value that gets returned from an outer join to your advantage. Say you want to write a query to display only crimes where the suspect is not known. You could specify in the query that you want to see only rows where the suspect name <code>is</code> <code>null</code>:</p>
<pre><code>select c.crime_name,
       l.location_name,
       s.suspect_name
from   crime c
join   location l
  on   c.location_id = l.location_id
left join suspect s
  on   c.suspect_id = s.suspect_id
where  <b>s.suspect_name is null</b>;</code></pre>
<p><span epub:type="pagebreak" title="66" id="Page_66"/>The results of this query are:</p>
<pre><code>crime_name                             location_name           suspect_name
-------------------------------------  ----------------------  ---------------
Receiving Salad Under False Pretenses  Green Vegan Restaurant  null</code></pre>
<p>Adding the <code>where</code> clause on the last line of the query showed you only rows that have no matching row in the <code>suspect</code> table, which limited your list to crimes with unknown suspects.</p>
<h2 id="h1-503007c06-0002"><a class="XrefDestination" id="JoiningManyTables"/><span class="XrefDestination" id="xref-503007c06-004"/>Joining Many Tables</h2>
<p class="BodyFirst">MySQL allows up to 61 tables in a join, though you’ll rarely need to write queries with that many. If you find yourself joining more than 10 tables, that’s a sign the database could be redesigned to make writing queries simpler.</p>
<p>The <code>wine</code> database has six tables you can use to help plan a trip to a winery. Let’s look at all six in turn.</p>
<p>The <code>country</code> table stores the countries where the wineries are located:</p>
<pre><code>country_id  country_name
----------  ------------
    1       France
    2       Spain
    3       USA</code></pre>
<p>The <code>region</code> table stores the regions within those countries where the wineries are located:</p>
<pre><code>region_id  region_name         country_id
---------  -----------         ----------
    1      Napa Valley             3
    2      Walla Walla Valley      3
    3      Texas Hill              3</code></pre>
<p>The <code>viticultural_area</code> table stores the wine-growing subregions where the wineries are located:</p>
<pre><code>viticultural_area_id  viticultural_area_name  region_id
--------------------  ----------------------  ---------
          1           Atlas Peak                  1
          2           Calistoga                   1
          3           Wild Horse Valley           1</code></pre>
<p>The <code>wine_type</code> table stores information about the types of wine available:</p>
<pre><code>wine_type_id  wine_type_name
------------  ------------------
       1      Chardonnay
       2      Cabernet Sauvignon
       3      Merlot</code></pre>
<p><span epub:type="pagebreak" title="67" id="Page_67"/>The <code>winery</code> table stores information about the wineries:</p>
<pre><code>winery_id  winery_name            viticultural_area_id  offering_tours_flag
---------  ---------------------  --------------------  -------------------
    1      Silva Vineyards                   1                    0
    2      Chateau Traileur Parc             2                    1
    3      Winosaur Estate                   3                    1</code></pre>
<p>The <code>portfolio</code> table stores information about the winery’s portfolio of wines—that is, which wines the winery offers:</p>
<pre><code>winery_id  wine_type_id  in_season_flag
---------  ------------  --------------
    1            1             1
    1            2             1
    1            3             0
    2            1             1
    2            2             1
    2            3             1
    3            1             1
    3            2             1
    3            3             1</code></pre>
<p>For example, the winery with a <code>winery_id</code> of <code>1</code> (Silva Vineyards) offers the wine with a <code>wine_type_id</code> of <code>1</code> (Chardonnay), which is in season (its <code>in_season_flag</code>—a boolean value—is <code>1</code>, indicating true).</p>
<p><a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a> shows a query that joins all six tables to find a winery in the USA that has a Merlot in season and is offering tours.</p>
<pre><code>select c.country_name,
       r.region_name,
       v.viticultural_area_name,
       w.winery_name
from   country c
join   region r
  on   c.country_id = r.country_id
 and   c.country_name = 'USA'
join   viticultural_area v
  on   r.region_id = v.region_id
join   winery w
  on   v.viticultural_area_id = w.viticultural_area_id
 and   w.offering_tours_flag is true
join   portfolio p
  on   w.winery_id = p.winery_id
 and   p.in_season_flag is true
join   wine_type t
  on   p.wine_type_id = t.wine_type_id
 and   t.wine_type_name = 'Merlot';</code></pre>
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: A query to list US wineries with in-season Merlot</p>
<p>While this is a longer query than you’re used to, you’ve seen most of the syntax before. You create table aliases for each table name in the query (<code><span epub:type="pagebreak" title="68" id="Page_68"/>country</code>, <code>region</code>, <code>viticultural_area</code>, <code>winery</code>, <code>portfolio</code>, and <code>wine_type</code>). When referring to columns in the query, you precede the column names with the table aliases and a period. For example, you precede the <code>offering_tours_flag</code> column with <code>w</code> because it is in the <code>winery</code> table, resulting in <code>w.offering_tours_flag</code>. (Remember from <a class="xref" href="c04.xhtml">Chapter 4</a> that it’s best practice to add the suffix <code>_flag</code> to columns that contain boolean values like <code>true</code> or <code>false</code>, which is the case with the <code>offering_tours</code> column, since a winery either offers tours or doesn’t.) Finally, you perform inner joins on each table with the word <code>join</code>, as there should be matching values when you join these tables.</p>
<p>Unlike our earlier queries, this query contains some joins between tables where more than one condition must be met. For example, when you join the <code>country</code> and <code>region</code> tables, there are <em>two</em> conditions that need to be met:</p>
<ul class="disc">
<li>The value in the <code>country_id</code> column of the <code>country</code> table must match the value in the <code>country_id</code> column of the <code>region</code> table.</li>
<li>The value in the <code>country_name</code> column of the <code>country</code> table must equal <code>USA</code>.</li>
</ul>
<p>You handled the first condition using the <code>on</code> keyword:</p>
<pre><code>from   country c
join   region r
  <b>on</b>   c.country_id = r.country_id</code></pre>
<p>Then you used the <code>and</code> keyword to specify the second condition:</p>
<pre><code> <b>and</b>   c.country_name = 'USA'</code></pre>
<p>You can add more <code>and</code> statements to specify as many joining conditions as you need.</p>
<p>The results of the query in <a href="#listing6-1">Listing 6-1</a> are as follows:</p>
<pre><code>country_name   region_name     viticultural_area_name   winery_name
------------   -------------   ----------------------   ---------------------
    USA        Napa Valley     Calistoga                Chateau Traileur Parc
    USA        Napa Valley     Wild Horse Valley        Winosaur Estate</code></pre>
<h2 id="h1-503007c06-0003"><a class="XrefDestination" id="AssociativeTables"/><span class="XrefDestination" id="xref-503007c06-005"/>Associative Tables</h2>
<p class="BodyFirst">In <a href="#listing6-1">Listing 6-1</a>, most of the tables are straightforward: the <code>winery</code> table stores a list of wineries, <code>region</code> stores a list of regions, <code>country</code> stores countries, and <code>viticultural_area</code> stores viticultural areas (wine-growing subregions).</p>
<p>The <code>portfolio</code> table, however, is a little different. Remember, it stores information about which wines are in each winery’s portfolio. Here it is again:</p>
<pre><code>winery_id  wine_type_id  in_season_flag
---------  ------------  --------------
    1            1             1
    1            2             1
<span epub:type="pagebreak" title="69" id="Page_69"/>    1            3             0
    2            1             1
    2            2             1
    2            3             1
    3            1             1
    3            2             1
    3            3             1</code></pre>
<p>Its <code>winery_id</code> column is the primary key of the <code>winery</code> table, and its <code>wine_type_id</code> column is the primary key of the <code>wine_type</code> table. This makes <code>portfolio</code> an <em>associative table</em> because it associates rows that are stored in other tables to each other by referencing their primary keys, as illustrated in <a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>.</p>
<figure>
<img src="image_fi/503007c06/f06002.png" class="" alt="" width="847" height="203"/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: The <span class="LiteralInCaption"><code>portfolio</code></span> table is an associative table.</p></figcaption>
</figure>
<p>The <code>portfolio</code> table represents <em>many-to-many relationships</em> because one winery can produce many wine types, and one wine type can be produced in many wineries. For example, winery <code>1</code> (Silva Vineyards) offers many wine types: <code>1</code> (Chardonnay), <code>2</code> (Cabernet Sauvignon), and <code>3</code> (Merlot). Wine type <code>1</code> (Chardonnay) is offered by many wineries: <code>1</code> (Silva Vineyards), <code>2</code> (Chateau Traileur Parc), and <code>3</code> (Winosaur Estate). The <code>portfolio</code> table contains that list of relationships between each <code>winery_id</code> and <code>wine_type_id</code> that tells us which wineries have which wine types. As a bonus, it also contains the <code>in_season_flag</code> column, which, as you’ve seen, tracks whether that wine is in season at that winery.</p>
<p>Next, we’ll look at different ways to work with the data that’s returned from your queries. We’ll start with some simple options for managing the data in your result set and then cover some more involved approaches in the latter half of the chapter.</p>
<h2 id="h1-503007c06-0004"><a class="XrefDestination" id="ManagingtheDatainYourResultSet"/><span class="XrefDestination" id="xref-503007c06-006"/>Managing the Data in Your Result Set</h2>
<p class="BodyFirst">Sometimes you’ll want to control how much data from your queries is displayed in your result set. For example, you might want to pare down your results or combine the results of several <code>select</code> statements. SQL provides keywords to add this functionality to your queries.</p>
<h3 id="h2-503007c06-0001"><span epub:type="pagebreak" title="70" id="Page_70"/><a class="XrefDestination" id="ThelimitKeyword"/><span class="XrefDestination" id="xref-503007c06-007"/>The limit Keyword</h3>
<p class="BodyFirst">The <code>limit</code> keyword lets you limit the number of rows displayed in your result set. For example, consider a table called <code>best_wine_contest</code> that holds the results of a contest where wine tasters voted for their favorite wines. If you query the table and <code>order by</code> the <code>place</code> column, you’ll see the wines that ranked the best first:</p>
<pre><code>select *
from   best_wine_contest
order by place;</code></pre>
<p>The results are:</p>
<pre><code>wine_name     place
------------  -----
Riesling        1
Pinot Grigio    2
Zinfandel       3
Malbec          4
Verdejo         5</code></pre>
<p>If you want to see only the top three wines, use <code>limit 3</code>:</p>
<pre><code>select *
from   best_wine_contest
order by place
limit 3;</code></pre>
<p>Now the results are:</p>
<pre><code>wine_name     place
------------  -----
Riesling        1
Pinot Grigio    2
Zinfandel       3</code></pre>
<p>The <code>limit</code> keyword limited the results to three rows. To see only the wine that won top place, you could use <code>limit 1</code>.</p>
<h3 id="h2-503007c06-0002"><a class="XrefDestination" id="TheunionKeyword"/><span class="XrefDestination" id="xref-503007c06-008"/>The union Keyword</h3>
<p class="BodyFirst">The <code>union</code> keyword combines the results of multiple <code>select</code> statements into one result set. For example, the following query selects all the wine types from two different tables, <code>wine_type</code> and <code>best_wine_contest</code>, and shows them in one list:</p>
<pre><code>select wine_type_name from wine_type
union
select wine_name from best_wine_contest;</code></pre>
<p><span epub:type="pagebreak" title="71" id="Page_71"/>The result is:</p>
<pre><code>wine_type_name
------------------
Chardonnay
Cabernet Sauvignon
Merlot
Riesling
Pinot Grigio
Zinfandel
Malbec
Verdejo</code></pre>
<p>The <code>wine_type</code> table has a column called <code>wine_type_name</code> that includes Chardonnay, Cabernet Sauvignon, and Merlot. The <code>best_wine_contest</code> table has a column called <code>wine_name</code> that includes Riesling, Pinot Grigio, Zinfandel, Malbec, and Verdejo. Using <code>union</code> allows you to see all of the wines together in one result set.</p>
<p>You can use <code>union</code> only when every <code>select</code> statement has the same number of columns. The union works in this example because you specified just one column in each of the <code>select</code> statements. The column name in the result set is usually taken from the first <code>select</code> statement.</p>
<p>The <code>union</code> keyword will remove duplicate values from the result set. For example, if you had Merlot in both the <code>wine_type</code> and the <code>best_wine_contest</code> tables, using <code>union</code> would produce a list of distinct wines, with Merlot listed only once. To see a list that includes duplicate values, use <code>union all</code>:</p>
<pre><code>select wine_type_name from wine_type
union all
select wine_name from best_wine_contest;</code></pre>
<p>The result would be:</p>
<pre><code>wine_type_name
------------------
Chardonnay
Cabernet Sauvignon
Merlot
Riesling
Pinot Grigio
Zinfandel
Malbec
Verdejo
Merlot</code></pre>
<p>Now you can see that Merlot is listed twice.</p>
<p>Next, you’ll dive in a bit deeper to make your queries even more efficient by creating temporary result sets in a table-like format.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2><span epub:type="pagebreak" title="72" id="Page_72"/>Try It Yourself</h2>
<p class="BoxBodyFirst">In the <code>nutrition</code> database, there are two tables, <code>good_snack</code> and <code>bad_snack</code>.</p>
<p>The <code>good_snack</code> table looks like this:</p>
<pre><code>snack_name
----------
carrots
salad
soup</code></pre>
<p>The <code>bad_snack</code> table looks like this:</p>
<pre><code>snack_name
----------
sausage pizza
BBQ ribs
nachos</code></pre>
<p class="BoxListNumberCustom1"><b>6-1.</b>	Write a query to display all the snacks from both tables in one result set.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-503007c06-0005"><a class="XrefDestination" id="TemporaryTables"/><span class="XrefDestination" id="xref-503007c06-010"/>Temporary Tables</h2>
<p class="BodyFirst">MySQL allows you to create temporary tables—that is, a temporary result set that will exist only for your current session and then be automatically dropped. For example, you can create a temporary table using a tool like MySQL Workbench and then query that table within the tool. If you close and reopen MySQL Workbench, however, the temporary table will be gone. You can reuse a temporary table several times in a single session.</p>
<p>You can define a temporary table the same way you create a regular table, except that you use the syntax <code>create temporary table</code> instead of <code>create table</code>:</p>
<pre><code>create temporary table wp1
(
    winery_name            varchar(100),
    viticultural_area_id   int
)</code></pre>
<p>The <code>wp1</code> temporary table gets created with the column names and data types that you specified, without any rows.</p>
<p>To create a temporary table based on the results of a query, simply precede the query with the same <code>create temporary table</code> syntax, as shown in <a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a>, and the resulting temporary table will contain the rows of data that were selected from the query.</p>
<pre><code><span epub:type="pagebreak" title="73" id="Page_73"/> create temporary table winery_portfolio
 select w.winery_name,
        w.viticultural_area_id
 from   winery w
 join   portfolio p
<span class="CodeAnnotationCode" aria-label="annotation1">❶</span>  on   w.winery_id = p.winery_id
<span class="CodeAnnotationCode" aria-label="annotation2">❷</span> and   w.offering_tours_flag is true
  and   p.in_season_flag is true
 join   wine_type t
<span class="CodeAnnotationCode" aria-label="annotation3">❸</span>  on   p.wine_type_id = t.wine_type_id
<span class="CodeAnnotationCode" aria-label="annotation4">❹</span> and   t.wine_type_name = 'Merlot';</code></pre>
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Creating a temporary table</p>
<p>Here you create a temporary table called <code>winery_portfolio</code> that stores the results of a query joining the <code>winery</code>, <code>portfolio</code>, and <code>wine_type</code> tables from <a href="#listing6-1">Listing 6-1</a> and <a href="#figure6-2">Figure 6-2</a>. The <code>winery</code> and <code>portfolio</code> tables are joined based on two conditions:</p>
<ul class="disc">
<li>The values of the <code>winery_id</code> columns in the tables match <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</li>
<li>The winery is offering tours. For this, you check that the <code>offering_tours_flag</code> in the <code>winery</code> table is set to <code>true</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</li>
</ul>
<p class="BodyContinued">Those results are joined with the <code>wine_type</code> table based on two conditions:</p>
<ul class="disc">
<li>The values of the <code>wine_type_id</code> columns in the tables match <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</li>
<li>The <code>wine_type_name</code> in the <code>wine_type</code> table is <code>Merlot</code> <span class="CodeAnnotation" aria-label="annotation4">❹</span>.

<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Temporary tables are created with the data types of the columns you’ve selected in the query. For example, in <a href="#listing6-2">Listing 6-2</a> you selected <code>winery_name</code> from the <code>winery</code> table, which was defined as <code>varchar(100)</code>, so the <code>winery_portfolio</code> temporary table also gets created with a <code>winery_name</code> column defined as <code>varchar(100)</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside></li>
</ul>
<p>Once you’ve created a temporary table, you can query its contents by selecting from it, just as you would with a permanent table:</p>
<pre><code>select * from winery_portfolio;</code></pre>
<p>The results are:</p>
<pre><code>winery_name            viticultural_area_id
---------------------  --------------------
Chateau Traileur Parc          2
Winosaur Estate                3</code></pre>
<p>Now you can write a second query to select from the <code>winery_portfolio</code> temporary table and join it with other three tables from <a href="#listing6-1">Listing 6-1</a>:</p>
<pre><code>select c.country_name,
       r.region_name,
       v.viticultural_area_name,
<span epub:type="pagebreak" title="74" id="Page_74"/>       w.winery_name
from   country c
join   region r
  on   c.country_id = r.country_id
 and   c.country_name = 'USA'
join   viticultural_area v
  on   r.region_id = v.region_id
join   <b>winery_portfolio</b> w
  on   v.viticultural_area_id = w.viticultural_area_id;</code></pre>
<p>Here you are joining the <code>winery_portfolio</code> temporary table to the remaining tables that were part of the original query in <a href="#listing6-1">Listing 6-1</a>: <code>country</code>, <code>region</code>, and <code>viticultural_area</code>. In this way, you simplified a large, six-table query by isolating the data from three tables into a temporary table and then joining that temporary table with the other three tables. This query returns the same results as <a href="#listing6-1">Listing 6-1</a>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>Try It Yourself</h2>
<p class="BoxBodyFirst">The <code>canada</code> database contains the <code>province</code>, <code>capital_city</code>, and <code>tourist_attraction</code> tables shown here.</p>
<p>The <code>province</code> table looks like this:</p>
<pre><code>province_id  province_name          official_language
-----------  ---------------------  -----------------
     1       Alberta                English
     2       British Columbia       English
     3       Manitoba               English
     4       New Brunswick          English, French
     5       Newfoundland           English
     6       Nova Scotia            English
     7       Ontario                English
     8       Prince Edward Island   English
     9       Quebec                 French
     10      Saskatchewan           English</code></pre>
<p>The <code>capital_city</code> table looks like this:</p>
<pre><code>city_id   city_name   province_id
-------   ---------   -----------
   1      Toronto          7
   2      Quebec City      9
   3      Halifax          5
   4      Fredericton      4
   5      Winnipeg         3
   6      Victoria         2
   7      Charlottetown    8
   8      Regina          10
   9      Edmonton         1
   10     St. Johns        5</code></pre>
<p><span epub:type="pagebreak" title="75" id="Page_75"/>The <code>tourist_attraction</code> table looks like this:</p>
<pre><code>attraction_id  attraction_name              attraction_city_id  open_flag
-------------  ---------------------------  ------------------  ---------
      1        CN Tower                             1              true
      2        Old Quebec                           2              true
      3        Royal Ontario Museum                 1              true
      4        Place Royale                         2              true
      5        Halifax Citadel                      3              true
      6        Garrison District                    4              true
      7        Confederation Centre of...           7              true
      8        Stone Hall Castle                    8              true
      9        West Edmonton Mall                   9              true
      10       Signal Hill                         10              true
      11       Canadian Museum for Human...         5              true
      12       Royal BC Museum                      6              true
      13       Sunnyside Amusement Park             1              false</code></pre>
<p class="BoxListNumberCustom1"><b>6-2.</b>	Write a query that performs an inner join between the three tables. Select the <code>attraction_name</code> column from the <code>tourist_attraction</code> table, the <code>city_name</code> column from the <code>capital_city</code> table, and the <code>province_name</code> column from the <code>province</code> table.</p>
<p class="ListBody">Select rows from the <code>attraction</code> table only where the <code>open_flag</code> is set to <code>true</code>. Select rows from the <code>province</code> table only where the <code>official_language</code> is set to <code>French</code>.</p>
<p class="BoxListNumberCustom1"><b>6-3.</b>	Create a temporary table called <code>open_tourist_attraction</code> that selects the <code>attraction_city_id</code> and <code>attraction_name</code> columns from the <code>tourist_attraction</code> table where the <code>open_flag</code> value is <code>true</code>.</p>
<p class="BoxListNumberCustom1"><b>6-4.</b>	Write a query that joins the <code>open_tourist_attraction</code> temporary table you created in Exercise 6-2 to the <code>capital_city</code> table. Select the <code>attraction_name</code> column from the <code>open_tourist_attraction</code> temporary table and the <code>city_name</code> column from the <code>capital_city</code> table. Select only rows from the <code>capital_city</code> table that have a <code>city_name</code> of <code>Toronto</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-503007c06-0006"><a class="XrefDestination" id="CommonTableExpressions"/><span class="XrefDestination" id="xref-503007c06-012"/>Common Table Expressions</h2>
<p class="BodyFirst">Common Table Expressions (CTEs), a feature introduced in MySQL version 8.0, are a temporary result set that you name and can then select from as if it were a table. You can use CTEs only for the duration of one query (versus temporary tables, which can be used for the entire session). <a href="#listing6-3" id="listinganchor6-3">Listing 6-3</a> shows how to use a CTE to simplify the query from <a href="#listing6-1">Listing 6-1</a>:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> with winery_portfolio_cte as
(
    select w.winery_name,
           w.viticultural_area_id
    from   winery w
<span epub:type="pagebreak" title="76" id="Page_76"/>    join   portfolio p
      on   w.winery_id = p.winery_id
     and   w.offering_tours_flag is true
     and   p.in_season_flag is true
    join   wine_type t
      on   p.wine_type_id = t.wine_type_id
     and   t.wine_type_name = 'Merlot'
)
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> select c.country_name,
       r.region_name,
       v.viticultural_area_name,
       wp.winery_name
from   country c
join   region r
  on   c.country_id = r.country_id
 and   c.country_name = 'USA'
join   viticultural_area v
  on   r.region_id = v.region_id
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> join   winery_portfolio_cte wp
  on   v.viticultural_area_id = wp.viticultural_area_id;</code></pre>
<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: Naming and then querying a CTE</p>
<p>First, you use the <code>with</code> keyword to give the CTE a name; here, you define the name <code>winery_portfolio_cte</code> for the results of the query shown between the parentheses <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then you add another query <span class="CodeAnnotation" aria-label="annotation2">❷</span> that uses <code>winery_portfolio_cte</code> in a join as if it were a table <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The results are the same as those of <a href="#listing6-1">Listing 6-1</a>.</p>
<p>CTEs and temporary tables both temporarily save the results of a query in a table-like format. However, while temporary tables can be used more than once (that is, in multiple queries) in a session, CTEs can be used only for the duration of the query in which they are defined. After you run <a href="#listing6-3">Listing 6-3</a>, try to run another query to select from <code>winery_portfolio_cte</code>:</p>
<pre><code>select * from winery_portfolio_cte;</code></pre>
<p>You’ll get an error:</p>
<pre><code>Error Code: 1146. Table 'wine.winery_portfolio_cte' doesn't exist</code></pre>
<p>MySQL is looking for a <em>table</em> named <code>winery_portfolio_cte</code>, so it’s no surprise it can’t locate your CTE. Besides that, the CTE existed only for the duration of your query, so it’s no longer available.</p>
<h2 id="h1-503007c06-0007"><a class="XrefDestination" id="RecursiveCommonTableExpressions"/><span class="XrefDestination" id="xref-503007c06-013"/>Recursive Common Table Expressions</h2>
<p class="BodyFirst">Recursion is a technique that is used when an object references itself. When I think of recursion, I think of Russian nesting dolls. You open the largest doll and discover a smaller doll within it; then you open that doll and find <span epub:type="pagebreak" title="77" id="Page_77"/>an even smaller doll within that; and so on until you reach the tiniest doll in the center. In other words, to see all the dolls, you start with the largest doll and then iterate through each smaller doll until you find a doll that doesn’t contain another one.</p>
<p>Recursion is useful when your data is organized as a hierarchy or a series of values where you need to know the previous value to arrive at the current value.</p>
<p>A recursive CTE references itself. Recursive CTEs have two <code>select</code> statements separated by a <code>union</code> statement. Take a look at this recursive CTE called <code>borg_scale_cte</code>, which contains a series of numbers between 6 and 20:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> with recursive borg_scale_cte as
(
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> select    6 as current_count
    union
  <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> select    current_count + 1
    from      borg_scale_cte
  <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> where     current_count &lt; 20
)
select * from borg_scale_cte;</code></pre>
<p>First, you define the CTE as <code>recursive</code> and name it <code>borg_scale_cte</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, the first <code>select</code> statement returns the first row containing the number <code>6 </code><span class="CodeAnnotation" aria-label="annotation2">❷</span>. The second <code>select</code> statement returns all other rows with values <code>7</code> through <code>20</code>. It continually adds <code>1</code> to the <code>current_count</code> column and selects the resulting numbers <span class="CodeAnnotation" aria-label="annotation3">❸</span>, so long as the <code>current_count</code> is less than <code>20</code> <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>
<p>In the last line, you use the wildcard character <code>*</code> to select all the values from the CTE, which returns:</p>
<pre><code>current_count
-------------
      6
      7
      8
      9
     10
     11
     12
     13
     14
     15
     16
     17
     18
     19
     20</code></pre>
<p>You can also use a recursive CTE as if it were a table and join it with other tables, for example.</p>
<h2 id="h1-503007c06-0008"><span epub:type="pagebreak" title="78" id="Page_78"/><a class="XrefDestination" id="DerivedTables"/><span class="XrefDestination" id="xref-503007c06-014"/>Derived Tables</h2>
<p class="BodyFirst">Derived tables are an alternative to CTEs for creating a table of results just for use within a query. The SQL that creates the derived table goes within parentheses:</p>
<pre><code>select   wot.winery_name,
         t.wine_type_name
from     portfolio p
join wine_type t
on       p.wine_type_id = t.wine_type_id
join (
     select *
     from   winery
     where  offering_tours_flag is true
     ) wot
On       p.winery_id = wot.winery_id;</code></pre>
<p>The query within the parentheses produces a derived table aliased as <code>wot</code> (short for <em>wineries offering tours</em>). You can treat <code>wot</code> as if it were just another table, joining it to the <code>portfolio</code> and <code>wine_type</code> tables, and selecting columns from it. As with a CTE, the derived table is available just for the duration of your query.</p>
<p>The choice to use a derived table rather than a CTE is often a matter of style. Some developers prefer to use CTEs because they feel CTEs are a more readable option. If you need to use recursion, however, you would have to use a CTE.</p>
<h2 id="h1-503007c06-0009"><a class="XrefDestination" id="Subqueries"/><span class="XrefDestination" id="xref-503007c06-015"/>Subqueries</h2>
<p class="BodyFirst">A subquery (or inner query) is a query nested within another query. A subquery is used to return data that will be used by the main query. When a query has a subquery, MySQL runs the subquery first, selects the resulting value from the database, and then passes it back to the outer query. For example, this SQL statement uses a subquery to return a list of all the wine-growing regions in the United States from the <code>wine</code> database:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> select region_name
from   region
where  country_id =
(
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> select country_id
    from   country
    where  country_name = 'USA'
);</code></pre>
<p><span epub:type="pagebreak" title="79" id="Page_79"/>The result of this query is as follows:</p>
<pre><code>region_name
------------------
Napa Valley
Walla Walla Valley
Texas Hill</code></pre>
<p>The query has two parts: the outer query <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the subquery <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Try running the subquery in isolation, without the outer query:</p>
<pre><code>    select country_id
    from   country
    where  country_name = 'USA';</code></pre>
<p>The result shows that the <code>country_id</code> returned for USA is <code>3</code>:</p>
<pre><code>country_id
----------
     3</code></pre>
<p>In your query, <code>3</code> is passed from the subquery to the outer query, which makes the entire SQL statement evaluate to:</p>
<pre><code>select region_name
from   region
where  country_id = 3;</code></pre>
<p>This results in a list of regions for <code>country_id 3</code> (<code>USA</code>) being returned:</p>
<pre><code>region_name
------------------
Napa Valley
Walla Walla Valley
Texas Hill</code></pre>
<h3 id="h2-503007c06-0003"><a class="XrefDestination" id="SubqueriesThatReturnMoreThanOneRow"/><span class="XrefDestination" id="xref-503007c06-016"/>Subqueries That Return More Than One Row</h3>
<p class="BodyFirst">Subqueries can return more than one row. Here’s the same query as before, this time including all countries, not just the USA:</p>
<pre><code>select region_name
from   region
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> where  country_id =
(
    select country_id
    from   country
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> --  where  country_name = 'USA' -  line commented out
);</code></pre>
<p><span epub:type="pagebreak" title="80" id="Page_80"/>Now the line of the subquery that specifies that you want only USA regions is commented out <span class="CodeAnnotation" aria-label="annotation2">❷</span>, so the <code>country_id</code> for all countries will be returned. When you run this query, instead of a list of regions, MySQL returns an error:</p>
<pre><code>Error Code: 1242. Subquery returns more than 1 row</code></pre>
<p>The problem is that the outer query expects only one row to be returned because you used the <code>=</code> syntax <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Instead, the subquery returns three rows: <code>country_id</code> <code>3</code> for the USA, <code>1</code> for France, and <code>2</code> for Spain. You should use <code>=</code> only when there is no possibility that the subquery could return more than one row.</p>
<p>This is a common mistake that you should be mindful of. Many developers have written a query that worked when they tested it, but all of a sudden, one day it starts producing <code>Subquery returns more than 1 row</code> errors. Nothing has changed about the query (unlike in this case where a line has been commented out), but the data in their database has changed. For example, new rows might have been added to a table, and the developer’s subquery now returns multiple rows where it used to return one.</p>
<p>To write a query where more than one row can be returned from the subquery, you can use the <code>in</code> keyword instead of <code>=</code>:</p>
<pre><code>select region_name
from   region
where  country_id <b>in</b>
(
    select country_id
    from   country
--  where  country_name = 'USA' -  line commented out
);</code></pre>
<p>Now that you’ve replaced <code>=</code> with <code>in</code>, the outer query can accept multiple rows back from the subquery without error, and you’ll get a list of regions for all countries.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>Try It Yourself</h2>
<p class="BoxBodyFirst">Say you’re working at a staffing firm and you receive a report about a query that used to run successfully but is now failing with an error message of <code>Subquery returns more than 1 row</code>. You’ve been asked to fix this query:</p>
<pre><code>select  employee_id,
        hat_size
from    wardrobe
where   employee_id =
(
        select   employee_id
        from     employee
<span epub:type="pagebreak" title="81" id="Page_81"/>        where    position_name = 'Pope'
);</code></pre>
<p>The <code>attire</code> database contains the <code>wardrobe</code> and <code>employee</code> tables.</p>
<p>The <code>wardrobe</code> table looks like this:</p>
<pre><code>employee_id  hat_size
-----------  --------
      1        8.25
      2        7.50
      3        6.75</code></pre>
<p>The <code>employee</code> table looks like this:</p>
<pre><code>employee_id  employee_name  position_name
-----------  -------------  -------------
     1       Benedict       Pope
     2       Garth          Singer
     3       Francis        Pope</code></pre>
<p class="BoxListNumberCustom1"><b>6-5.</b>	Employee <code>3</code> has been added to the database recently. How would you fix the query? Why do you think the query used to work without a problem, but now the same query fails?</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-503007c06-0004"><a class="XrefDestination" id="CorrelatedSubqueries"/><span class="XrefDestination" id="xref-503007c06-018"/>Correlated Subqueries</h3>
<p class="BodyFirst">In a correlated subquery, a column from a table in the subquery is joined with a column from a table in the outer query.</p>
<p>Let’s take a look at two tables called <code>best_paid</code> and <code>employee</code> in the <code>pay</code> database. The <code>best_paid</code> table shows that the highest salary in the Sales department is $200,000, and the highest salary in the Manufacturing department is $80,000:</p>
<pre><code>department      salary
----------      ------
Sales           200000
Manufacturing    80000</code></pre>
<p>The <code>employee</code> table stores a list of employees, their department, and their salary:</p>
<pre><code>employee_name   department      salary
--------------  --------------  ------
Wanda Wealthy   Sales           200000
Paul Poor       Sales            12000
Mike Mediocre   Sales            70000
Betty Builder   Manufacturing    80000
Sean Soldering  Manufacturing    80000
Ann Assembly    Manufacturing    65000</code></pre>
<p><span epub:type="pagebreak" title="82" id="Page_82"/>You can use a correlated subquery to find the highest-paid employees in each department:</p>
<pre><code>select employee_name,
       salary
from   employee e
where  salary =
       (
       select  b.salary
       from    best_paid b
       where   b.department = e.department
       );</code></pre>
<p>In the outer query, you select employees and salaries from the <code>employee</code> table. In the subquery, you join the results of the outer query with the <code>best_paid</code> table to determine if this employee has the highest salary for their department.</p>
<p>The results are:</p>
<pre><code>employee_name   salary
--------------  ------
Wanda Wealthy   200000
Betty Builder    80000
Sean Soldering   80000</code></pre>
<p>The results show that Wanda is the highest-paid employee in the Sales department and Betty and Sean are tied for the highest salary in the Manufacturing department.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>Try It Yourself</h2>
<p class="BoxBodyFirst">In the <code>monarchy</code> database, there is a table named <code>royal_family</code> that contains the following data:</p>
<pre><code>name                                birthdate
---------------------------------   ----------
Prince Louis of Cambridge           2018-04-23
Princess Charlotte of Cambridge     2015-05-02
Prince George of Cambridge          2013-07-22
Prince William, Duke of Cambridge   1982-06-21
Catherine, Duchess of Cambridge     1982-01-09
Charles, Prince of Whales           1948-11-14
Queen Elizabeth II                  1926-04-21
Prince Andrew, Duke of York         1960-02-19</code></pre>
<p class="BoxListNumberCustom1"><b>6-6.</b>	<span epub:type="pagebreak" title="83" id="Page_83"/>Write a query to select all columns from the table and order by the <code>birthdate</code> column.</p>
<p class="BoxListNumberCustom1"><b>6-7.</b>	Add <code>limit 1</code> to the end of the query to see who is the oldest royal in the table.</p>
<p class="BoxListNumberCustom1"><b>6-8.</b>	Now change the query to order by the <code>birthdate</code> column in descending order. Then add <code>limit 3</code> to the end of the query to see who the youngest three royals in the table are.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-503007c06-0010"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-503007c06-020"/>Summary</h2>
<p class="BodyFirst">In this chapter, you wrote complex SQL statements using multiple tables. You saw how to limit or combine the rows of your results, and you explored several different ways to write queries using result sets as if they were tables.</p>
<p>In the next chapter, you’ll compare values in your queries; for example, you’ll check that one value is more than another value, compare values that have different data types, and check whether a value matches some pattern.</p>
</section>
</div>
</div>
</body></html>