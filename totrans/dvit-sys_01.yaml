- en: '1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BY THE C, BY THE C, BY THE BEAUTIFUL C
  prefs: []
  type: TYPE_NORMAL
- en: “By the Beautiful Sea"
  prefs: []
  type: TYPE_NORMAL
- en: —Carroll and Atteridge, 1914
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter presents an overview of C programming written for students who
    have some experience programming in another language. It’s specifically written
    for Python programmers and uses a few Python examples for comparison purposes.
    However, it should be useful as an introduction to C programming for anyone with
    basic programming experience in any language.
  prefs: []
  type: TYPE_NORMAL
- en: C is a high-level programming language like other languages you might know,
    such as Python, Java, Ruby, or C++. It’s an imperative and a procedural programming
    language, which means that a C program is expressed as a sequence of statements
    (steps) for the computer to execute and that C programs are structured as a set
    of functions (procedures). Every C program must have at least one function, the
    `main` function, which contains the set of statements that execute when the program
    begins.
  prefs: []
  type: TYPE_NORMAL
- en: The C programming language is less abstracted from the computer’s machine language
    than some other languages with which you might be familiar. This means that C
    doesn’t have support for object-oriented programming (like Python, Java, and C++)
    or have a rich set of high-level programming abstractions (such as strings, lists,
    and dictionaries in Python). As a result, if you want to use a dictionary data
    structure in your C program, you need to implement it yourself, as opposed to
    just importing the one that is part of the programming language (as in Python).
  prefs: []
  type: TYPE_NORMAL
- en: C’s lack of high-level abstractions might make it seem like a less appealing
    programming language to use. However, being less abstracted from the underlying
    machine makes C easier for a programmer to see and understand the relationship
    between a program’s code and the computer’s execution of it. C programmers retain
    more control over how their programs execute on the hardware, and they can write
    code that runs more efficiently than equivalent code written using the higher-level
    abstractions provided by other programming languages. In particular, they have
    more control over how their programs manage memory, which can have a significant
    impact on performance. Thus, C remains the *de facto* language for computer systems
    programming where low-level control and efficiency are crucial.
  prefs: []
  type: TYPE_NORMAL
- en: We use C in this book because of its expressiveness of program control and its
    relatively straightforward translation to assembly and machine code that a computer
    executes. This chapter introduces programming in C, beginning with an overview
    of its features. [Chapter 2](ch02.xhtml#ch02) then describes C’s features in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Getting Started Programming in C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by looking at a “hello world" program that includes an example of
    calling a function from the math library. We compare the Python version of this
    program (first) to the C version (second). The C version might be put in a file
    named `hello.c` (`.c` is the suffix convention for C source code files), whereas
    the Python version might be in a file named `hello.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Python version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: C version
  prefs: []
  type: TYPE_NORMAL
- en: '**Note** Both the C version^([1](ch01.xhtml#fn1_1)) and Python version^([2](ch01.xhtml#fn1_2))
    are available for download.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that both versions of this program have similar structure and language
    constructs, albeit with different language syntax. In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments:**'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, multiline comments begin and end with `'''`, and single-line comments
    begin with `#`.
  prefs: []
  type: TYPE_NORMAL
- en: In C, multiline comments begin with `/*` and end with `*/`, and single-line
    comments begin with `//`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing library code:**'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, libraries are included (imported) using `import`.
  prefs: []
  type: TYPE_NORMAL
- en: In C, libraries are included (imported) using `#include`. All `#include` statements
    appear at the top of the program, outside of function bodies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks:**'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, indentation denotes a block.
  prefs: []
  type: TYPE_NORMAL
- en: In C, blocks (for example, function, loop, and conditional bodies) start with
    `{` and end with `}`.
  prefs: []
  type: TYPE_NORMAL
- en: '**The main function:**'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, `def main():` defines the main function.
  prefs: []
  type: TYPE_NORMAL
- en: In C, `int main(){ }` defines the main function. The `main` function returns
    a value of type `int`, which is C’s name for specifying the signed integer type
    (signed integers are values like –3, 0, 1234). The `main` function returns the
    `int` value 0 to signify running to completion without error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Statements:**'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, each statement is on a separate line.
  prefs: []
  type: TYPE_NORMAL
- en: In C, each statement ends with a semicolon `;`. In C, statements must be within
    the body of some function (in `main` in this example).
  prefs: []
  type: TYPE_NORMAL
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the `print` function prints a formatted string. Values for the placeholders
    in the format string follow a `%` symbol in a comma-separated list of values (for
    example, the value of `sqrt(4)` will be printed in place of the `%f` placeholder
    in the format string).
  prefs: []
  type: TYPE_NORMAL
- en: In C, the `printf` function prints a formatted string. Values for the placeholders
    in the format string are additional arguments separated by commas (for example,
    the value of `sqrt(4)` will be printed in place of the `%f` placeholder in the
    format string).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few important differences to note in the C and Python versions
    of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Indentation:**'
  prefs: []
  type: TYPE_NORMAL
- en: In C, indentation doesn’t have meaning, but it’s good programming style to indent
    statements based on the nested level of their containing block.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: C’s `printf` function doesn’t automatically print a newline character at the
    end like Python’s `print` function does. As a result, C programmers need to explicitly
    specify a newline character (`\n`) in the format string when a newline is desired
    in the output.
  prefs: []
  type: TYPE_NORMAL
- en: main **function:**
  prefs: []
  type: TYPE_NORMAL
- en: A C program must have a function named `main`, and its return type must be `int`.
    This means that the `main` function returns a signed integer type value. Python
    programs don’t need to name their main function `main`, but they often do by convention.
  prefs: []
  type: TYPE_NORMAL
- en: The C `main` function has an explicit `return` statement to return an `int`
    value (by convention, `main` should return `0` if the main function is successfully
    executed without errors).
  prefs: []
  type: TYPE_NORMAL
- en: A Python program needs to include an explicit call to its `main` function to
    run it when the program executes. In C, its `main` function is automatically called
    when the C program executes.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.1 Compiling and Running C Programs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python is an interpreted programming language, which means that another program,
    the Python interpreter, runs Python programs: the Python interpreter acts like
    a virtual machine on which Python programs are run. To run a Python program, the
    program source code (`hello.py`) is given as input to the Python interpreter program
    that runs it. For example (`$` is the Linux shell prompt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Python interpreter is a program that is in a form that can be run directly
    on the underlying system (this form is called *binary executable*) and takes as
    input the Python program that it runs ([Figure 1-1](ch01.xhtml#ch1fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/01fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: A Python program is directly executed by the Python interpreter,
    which is a binary executable program that is run on the underlying system (OS
    and hardware).*'
  prefs: []
  type: TYPE_NORMAL
- en: To run a C program, it must first be translated into a form that a computer
    system can directly execute. A C *compiler* is a program that translates C source
    code into a *binary executable* form that the computer hardware can directly execute.
    A binary executable consists of a series of 0’s and 1’s in a well-defined format
    that a computer can run.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to run the C program `hello.c` on a Unix system, the C code must
    first be compiled by a C compiler (for example, the GNU C compiler, GCC ^([3](ch01.xhtml#fn1_3)))
    that produces a binary executable (by default named `a.out`). The binary executable
    version of the program can then be run directly on the system ([Figure 1-2](ch01.xhtml#ch1fig2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '(Note that some C compilers might need to be explicitly told to link in the
    math library: `-lm`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/01fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: The C compiler (gcc) builds C source code into a binary executable
    file (a.out). The underlying system (OS and hardware) directly executes the a.out
    file to run the program.*'
  prefs: []
  type: TYPE_NORMAL
- en: Detailed Steps
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In general, the following sequence describes the necessary steps for editing,
    compiling, and running a C program on a Unix system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, using a text editor (e.g., `vim`^([4](ch01.xhtml#fn1_4))), write and
    save your C source code program in a file (e.g., `hello.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, compile the source to an executable form, and then run it. The most basic
    syntax for compiling with `gcc` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If compilation yields no errors, the compiler creates a binary executable file
    named `a.out`. The compiler also allows you to specify the name of the binary
    executable file to generate using the `-o` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, this command instructs `gcc` to compile `hello.c` into an executable
    file named `hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke the executable program using `./hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Any changes made to the C source code (the `hello.c` file) must be recompiled
    with `gcc` to produce a new version of `hello`. If the compiler detects any errors
    during compilation, the `./hello` file won’t be created/re-created (but beware,
    an older version of the file from a previous successful compilation might still
    exist).
  prefs: []
  type: TYPE_NORMAL
- en: 'Often when compiling with `gcc`, you want to include several command line options.
    For example, these options enable more compiler warnings and build a binary executable
    with extra debugging information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because the `gcc` command line can be long, frequently the `make` utility is
    used to simplify compiling C programs and for cleaning up files created by `gcc`.
    Using `make` and writing a `Makefile` are important skills that you will develop
    as you build up experience with C programming.^([5](ch01.xhtml#fn1_5))
  prefs: []
  type: TYPE_NORMAL
- en: We cover compiling and linking with C library code in more detail at the end
    of [Chapter 2](ch02.xhtml#ch02).
  prefs: []
  type: TYPE_NORMAL
- en: Variables and C Numeric Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like Python, C uses variables as named storage locations for holding data. Thinking
    about the scope and type of program variables is important to understand the semantics
    of what your program will do when you run it. A variable’s *scope* defines when
    the variable has meaning (that is, where and when in your program it can be used)
    and its lifetime (that is, it could persist for the entire run of a program or
    only during a function activation). A variable’s *type* defines the range of values
    that it can represent and how those values will be interpreted when performing
    operations on its data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C, all variables must be declared before they can be used. To declare a
    variable, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A variable can have only a single type. The basic C types include `char`, `int`,
    `float`, and `double`. By convention, C variables should be declared at the beginning
    of their scope (at the top of a `{ }` block), before any C statements in that
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Below is an example C code snippet that shows declarations and uses of variables
    of some different types. We discuss types and operators in more detail after the
    example.
  prefs: []
  type: TYPE_NORMAL
- en: vars.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the semicolons galore. Recall that C statements are delineated by `;`,
    not line breaks—C expects a semicolon after every statement. You’ll forget some,
    and `gcc` almost never informs you that you missed a semicolon, even though that
    might be the only syntax error in your program. In fact, often when you forget
    a semicolon, the compiler indicates a syntax error on the line *after* the one
    with the missing semicolon: the reason is that `gcc` interprets it as part of
    the statement from the previous line. As you continue to program in C, you’ll
    learn to correlate `gcc` errors with the specific C syntax mistakes that they
    describe.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.2 C Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C supports a small set of built-in data types, and it provides a few ways in
    which programmers can construct basic collections of types (arrays and structs).
    From these basic building blocks, a C programmer can build complex data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'C defines a set of basic types for storing numeric values. Here are some examples
    of numeric literal values of different C types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The C `char` type stores a numeric value. However, it’s often used by programmers
    to store the value of an ASCII character. A character literal value is specified
    in C as a single character between single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'C doesn’t support a string type, but programmers can create strings from the
    `char` type and C’s support for constructing arrays of values, which we discuss
    in later sections. C does, however, support a way of expressing string literal
    values in programs: a string literal is any sequence of characters between double
    quotes. C programmers often pass string literals as the format string argument
    to `printf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Python supports strings, but it doesn’t have a `char` type. In C, a string
    and a `char` are two very different types, and they evaluate differently. This
    difference is illustrated by contrasting a C string literal that contains one
    character with a C `char` literal. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We discuss C strings and `char` variables in more detail in the “Strings and
    the String Library” section on [page 93](ch02.xhtml#lev1_14). Here, we’ll mainly
    focus on C’s numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: C Numeric Types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C supports several different types for storing numeric values. The types differ
    in the format of the numeric values they represent. For example, the `float` and
    `double` types can represent real values, `int` represents signed integer values,
    and `unsigned int` represents unsigned integer values. Real values are positive
    or negative values with a decimal point, such as – 1*.*23 or 0*.*0056\. Signed
    integers store positive, negative, or zero integer values, such as – 333, 0, or
    3456\. Unsigned integers store strictly non-negative integer values, such as 0
    or 1234.
  prefs: []
  type: TYPE_NORMAL
- en: C’s numeric types also differ in the range and precision of the values they
    can represent. The range or precision of a value depends on the number of bytes
    associated with its type. Types with more bytes can represent a larger range of
    values (for integer types), or higher-precision values (for real types), than
    types with fewer bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 1-1](ch01.xhtml#ch1tab1) shows the number of storage bytes, the kind
    of numeric values stored, and how to declare a variable for a variety of common
    C numeric types (note that these are typical sizes—the exact number of bytes depends
    on the hardware architecture).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-1:** C Numeric Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type name** | **Usual size** | **Values stored** | **How to declare** |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | 1 byte | integers | `char x;` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | 2 bytes | signed integers | `short x;` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | 4 bytes | signed integers | `int x;` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | 4 or 8 bytes | signed integers | `long x;` |'
  prefs: []
  type: TYPE_TB
- en: '| `long long` | 8 bytes | signed integers | `long long x;` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | 4 bytes | signed real numbers | `float x;` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | 8 bytes | signed real numbers | `double x;` |'
  prefs: []
  type: TYPE_TB
- en: 'C also provides *unsigned* versions of the integer numeric types (`char`, `short`,
    `int`, `long`, and `long long`). To declare a variable as unsigned, add the keyword
    `unsigned` before the type name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The C standard doesn’t specify whether the `char` type is signed or unsigned.
    As a result, some implementations might implement `char` as signed integer values
    and others as unsigned. It’s good programming practice to explicitly declare `unsigned
    char` if you want to use the unsigned version of a `char` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact number of bytes for each of the C types might vary from one architecture
    to the next. The sizes in [Table 1-1](ch01.xhtml#ch1tab1) are minimum (and common)
    sizes for each type. You can print the exact size on a given machine using C’s
    `sizeof` operator, which takes the name of a type as an argument and evaluates
    to the number of bytes used to store that type. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sizeof` operator evaluates to an unsigned long value, so in the call to
    `printf`, use the placeholder `%lu` to print its value. On most architectures
    the output of these statements will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic Operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Arithmetic operators combine values of numeric types. The resulting type of
    the operation is based on the types of the operands. For example, if two `int`
    values are combined with an arithmetic operator, the resulting type is also an
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: C performs automatic type conversion when an operator combines operands of two
    different types. For example, if an `int` operand is combined with a `float` operand,
    the integer operand is first converted to its floating-point equivalent before
    the operator is applied, and the type of the operation’s result is `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following arithmetic operators can be used on most numeric type operands:'
  prefs: []
  type: TYPE_NORMAL
- en: add (`+`) and subtract (`-`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'multiply (`*`), divide (`/`), and mod(`%`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mod operator (`%`) can only take integer-type operands (`int`, `unsigned
    int`, `short`, and so on).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If both operands are `int` types, the divide operator (`/`) performs integer
    division (the resulting value is an `int`, truncating anything beyond the decimal
    point from the division operation). For example `8/3` evaluates to `2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If one or both of the operands are `float` (or `double`), `/` performs real
    division and evaluates to a `float` (or `double`) result. For example, `8/3.0`
    evaluates to approximately `2.666667`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'assignment (`=`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'assignment with update (`+=`, `-=`, `*=`, `/=`, and `%=`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'increment (`++`) and decrement (`--`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning PRE- VERSUS POST-INCREMENT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operators `++variable` and `variable++` are both valid, but they’re evaluated
    slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`++x`: increment `x` first, then use its value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x++`: use `x`’s value first, then increment it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In many cases, it doesn’t matter which you use because the value of the incremented
    or decremented variable isn’t being used in the statement. For example, these
    two statements are equivalent (although the first is the most commonly used syntax
    for this statement):'
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  prefs: []
  type: TYPE_NORMAL
- en: ++x;
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, the context affects the outcome (when the value of the incremented
    or decremented variable *is* being used in the statement). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: x = 6;
  prefs: []
  type: TYPE_NORMAL
- en: 'y = ++x + 2;  // y is assigned 9: increment x first, then evaluate x + 2 (9)'
  prefs: []
  type: TYPE_NORMAL
- en: x = 6;
  prefs: []
  type: TYPE_NORMAL
- en: 'y = x++ + 2;  // y is assigned 8: evaluate x + 2 first (8), then increment
    x'
  prefs: []
  type: TYPE_NORMAL
- en: Code like the preceding example that uses an arithmetic expression with an increment
    operator is often hard to read, and it’s easy to get wrong. As a result, it’s
    generally best to avoid writing code like this; instead, write separate statements
    for exactly the order you want. For example, if you want to first increment `x`
    and then assign `x + 1` to `y`, just write it as two separate statements.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing this
  prefs: []
  type: TYPE_NORMAL
- en: y = ++x + 1;
  prefs: []
  type: TYPE_NORMAL
- en: 'write it as two separate statements:'
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  prefs: []
  type: TYPE_NORMAL
- en: y = x + 1;
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Input/Output (printf and scanf)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C’s `printf` function prints values to the terminal, and the `scanf` function
    reads in values entered by a user. The `printf` and `scanf` functions belong to
    C’s standard I/O library, which needs to be explicitly included at the top of
    any `.c` file that uses these functions by using `#include <stdio.h>`. In this
    section, we introduce the basics of using `printf` and `scanf` in C programs.
    “I/O in C (Standard and File)” on [page 113](ch02.xhtml#lev1_16) discusses C’s
    input and output functions in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1 printf
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'C’s `printf` function is very similar to formatted print in Python, where the
    caller specifies a format string to print. The format string often contains formatting
    specifiers, such as special characters that will print tabs (`\t`) or newlines
    (`\n`), or placeholders for values in the output. Placeholders consist of `%`
    followed by a type specifier letter (for example, `%d` represents a placeholder
    for an integer value). For each placeholder in the format string, `printf` expects
    an additional argument. Here, you can see an example program in Python and C with
    formatted output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Python version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: C version
  prefs: []
  type: TYPE_NORMAL
- en: 'When run, both versions of this program produce identically formatted output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between C’s `printf` and Python’s `print` functions are
    that the Python version implicitly prints a newline character at the end of the
    output string, but the C version does not. As a result, the C format strings in
    this example have newline (`\n`) characters at the end to explicitly print a newline
    character. The syntax for listing the argument values for the placeholders in
    the format string is also slightly different in C’s `printf` and Python’s `print`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'C uses the same formatting placeholders as Python for specifying different
    types of values. The preceding example demonstrates the following formatting placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'C additionally supports the `%c` placeholder for printing a character value.
    This placeholder is useful when a programmer wants to print the ASCII character
    associated with a particular numeric encoding. Here’s a C code snippet that prints
    a `char` as its numeric value (`%d`) and as its character encoding (`%c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, the program’s output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 1.2.2 scanf
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C’s `scanf` function represents one method for reading in values entered by
    the user (via the keyboard) and storing them in program variables. The `scanf`
    function can be a bit picky about the exact format in which the user enters data,
    which means that it’s not very robust to badly formed user input. In “I/O in C
    (Standard and File)” on [page 113](ch02.xhtml#lev1_16), we discuss more robust
    ways of reading input values from the user. For now, remember that if your program
    gets into an infinite loop due to badly formed user input, you can always press
    CTRL-C to terminate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading input is handled differently in Python and C: Python uses the `input`
    function to read in a value as a string, and then the program converts the string
    value to an `int`, whereas C uses `scanf` to read in an `int` value and to store
    it at the location in memory of an `int` program variable (for example, `&num1`).
    This code displays example programs for reading user input values in Python and
    C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Python version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: C version
  prefs: []
  type: TYPE_NORMAL
- en: 'When run, both programs read in two values (here, 30 and 67):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Like `printf`, `scanf` takes a format string that specifies the number and types
    of values to read in (for example, `"%d"` specifies one `int` value). The `scanf`
    function skips over leading and trailing whitespace as it reads in a numeric value,
    so its format string only needs to contain a sequence of formatting placeholders,
    usually with no whitespace or other formatting characters between the placeholders
    in its format string. The arguments for the placeholders in the format string
    specify the *locations* of program variables into which the values read in will
    be stored. Prefixing the name of a variable with the `&` operator produces the
    location of that variable in the program’s memory — the memory address of the
    variable. “C’s Pointer Variables” on [page 66](ch02.xhtml#lev1_10) discusses the
    `&` operator in more detail. For now, we use it only in the context of the `scanf`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another `scanf` example, in which the format string has placeholders
    for two values, the first an `int` and the second a `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: scanf_ex.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When inputting data to a program via `scanf`, individual numeric input values
    must be separated by at least one whitespace character. However, because `scanf`
    skips over additional leading and trailing whitespace characters (for example,
    spaces, tabs, and newlines), a user could enter input values with any amount of
    space before or after each input value. For instance, if a user enters the following
    for the call to `scanf` in the preceding example, `scanf` will read in 8 and store
    it in the `x` variable, and then read in 3.14 and store it in the `pi` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 1.3 Conditionals and Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code examples that follow show that the syntax and semantics of `if`–`else`
    statements in C and Python are very similar. The main syntactic difference is
    that Python uses indentation to indicate “body” statements, whereas C uses curly
    braces (but you should still use good indentation in your C code).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Python version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: C version
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python and C syntax for `if`–`else` statements is almost identical with
    only minor differences. In both, the `else` part is optional. Python and C also
    support multiway branching by chaining `if` and `else if` statements. The following
    describes the full `if`–`else` C syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 1.3.1 Boolean Values in C
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'C doesn’t provide a Boolean type with true or false values. Instead, integer
    values evaluate to *true* or *false* when used in conditional statements. When
    used in conditional expressions, an integer expression that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*zero* (0) evaluates to *false*;'
  prefs: []
  type: TYPE_NORMAL
- en: '*nonzero* (any positive or negative value) evaluates to *true*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C has a set of relational and logical operators for Boolean expressions. The
    *relational operators* take operand(s) of the same type and evaluate to zero (false)
    or nonzero (true). The set of relational operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: equality (`==` and inequality (not equal, `!=`);
  prefs: []
  type: TYPE_NORMAL
- en: 'comparison operators: less than (`<`), less than or equal (`<=`), greater than
    (`>`), and greater than or equal (`>=`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following C code snippets show examples of relational operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'C’s *logical operators* take integer “Boolean” operand(s) and evaluate to either
    zero (false) or nonzero (true). The set of logical operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: logical negation (`!`);
  prefs: []
  type: TYPE_NORMAL
- en: 'logical and (`&&`): stops evaluating at the first false expression (short-circuiting);'
  prefs: []
  type: TYPE_NORMAL
- en: 'logical or (`||`): stops evaluating at the first true expression (short-circuiting).'
  prefs: []
  type: TYPE_NORMAL
- en: C’s *short-circuit* logical operator evaluation stops evaluating a logical expression
    as soon as the result is known. For example, if the first operand to a logical
    and (`&&`) expression evaluates to false, the result of the `&&` expression must
    be false. As a result, the second operand’s value need not be evaluated, and it
    is not evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of conditional statements in C that use logical
    operators (it’s always best to use parentheses around complex Boolean expressions
    to make them easier to read):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 1.3.2 Loops in C
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like Python, C supports `for` and `while` loops. Additionally, C provides `do`–`while`
    loops.
  prefs: []
  type: TYPE_NORMAL
- en: while Loops
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `while` loop syntax in C and Python is almost identical, and the behavior
    is the same. Here, you can see example programs with `while` loops in C and Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Python version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: C version
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` loop syntax in C is very similar in Python, and both are evaluated
    in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` loop checks the Boolean expression first and executes the body
    if true. In the preceding example program, the value of the `val` variable will
    be repeatedly printed in the `while` loop until its value is greater than the
    value of the `num` variable. If the user enters `10`, the C and Python programs
    will print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'C also has a `do`–`while` loop that is similar to its `while` loop, but it
    executes the loop body first and then checks a condition and repeats executing
    the loop body for as long as the condition is true. That is, a `do`–`while` loop
    will always execute the loop body at least one time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For additional `while` loop examples, have a look at `whileLoop1.c`^([6](ch01.xhtml#fn1_6))
    and `whileLoop2.c`.^([7](ch01.xhtml#fn1_7))
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `for` loop is different in C than it is in Python. In Python, `for` loops
    are iterations over sequences, whereas in C, `for` loops are more general looping
    constructs. Here are example programs that use `for` loops to print all the values
    between 0 and a user-provided input number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Python version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: C version
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you can see that the C `for` loop syntax is quite different
    from the Python `for` loop syntax. It’s also evaluated differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C `for` loop syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop evaluation rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Evaluate <initialization> one time when first entering the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Evaluate the <boolean expression> . If it’s 0 (false), drop out of the `for`
    loop (in other words, the program is done repeating the loop body statements).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Evaluate the statements inside the loop <body> .
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Evaluate the <step> expression.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Repeat from step (2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example `for` loop to print the values 0, 1, and 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the `for` loop evaluation rules on the preceding loop yields the
    following sequence of actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The following program shows a more complicated `for` loop example (it’s also
    available to download^([8](ch01.xhtml#fn1_8))). Note that just because C supports
    `for` loops with a list of statements for its <initialization> and <step> parts,
    it’s best to keep it simple. (This example illustrates a more complicated `for`
    loop syntax, but the `for` loop would be easier to read and understand if it were
    simplified by moving the `j` `+= 10` step statement to the end of the loop body
    and having just a single step statement, `i += 1`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In C, `for` loops and `while` loops are equivalent in power, meaning that any
    `while` loop can be expressed as a `for` loop, and vice versa. The same is not
    true in Python, where `for` loops are iterations over a sequence of values. As
    such, they cannot express some looping behavior that the more general Python `while`
    loop can express. Indefinite loops are one example that can only be written as
    a `while` loop in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `while` loop in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop can be translated to an equivalent `for` loop in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In Python, however, this type of looping behavior can be expressed only by using
    a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Because `for` and `while` loops are equally expressive in C, only one looping
    construct is needed in the language. However, `for` loops are a more natural language
    construct for definite loops (like iterating over a range of values), whereas
    `while` loops are a more natural language construct for indefinite loops (like
    repeating until the user enters an even number). As a result, C provides both
    to programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions break code into manageable pieces and reduce code duplication. Functions
    might take zero or more *parameters* as input and they *return* a single value
    of a specific type. A function *declaration* or *prototype* specifies the function’s
    name, its return type, and its parameter list (the number and types of all the
    parameters). A function *definition* includes the code to be executed when the
    function is called. All functions in C must be declared before they’re called.
    This can be done by declaring a function prototype or by fully defining the function
    before calling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example function definition. Note that the comments describe what
    the function does, the details of each parameter (what it’s used for and what
    it should be passed), and what the function returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions that don’t return a value should specify the `void` return type.
    Here’s an example of a `void` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As in any programming language that supports functions or procedures, a *function
    call* invokes a function, passing specific argument values for the particular
    call. A function is called by its name and is passed arguments, with one argument
    for each corresponding function parameter. In C, calling a function looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments to C functions are *passed by value*: each function parameter is
    assigned the *value* of the corresponding argument passed to it in the function
    call by the caller. Pass by value semantics mean that any change to a parameter’s
    value in the function (that is, assigning a parameter a new value in the function)
    is *not visible* to the caller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example function calls to the `max` and `print_table` functions
    listed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of a full program that shows a call to a slightly different
    implementation of the `max` function that has an additional statement to change
    the value of its parameter (`x = y`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows what two runs of this program might look like. Note
    the difference in the parameter `x`’s value (printed from inside the `max` function)
    in the two runs. Specifically, notice that changing the value of parameter `x`
    in the second run does *not* affect the variable that was passed in as an argument
    to `max` after the call returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Because arguments are *passed by value* to functions, the preceding version
    of the `max` function that changes one of its parameter values behaves identically
    to the original version of `max` that does not.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.1 The Stack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *execution stack* keeps track of the state of active functions in a program.
    Each function call creates a new *stack frame* (sometimes called an *activation
    frame* or *activation record*) containing its parameter and local variable values.
    The frame on the top of the stack is the active frame; it represents the function
    activation that is currently executing, and only its local variables and parameters
    are in scope. When a function is called, a new stack frame is created for it (*pushed*
    on the top of the stack), and space for its local variables and parameters is
    allocated in the new frame. When a function returns, its stack frame is removed
    from the stack (*popped* from the top of the stack), leaving the caller’s stack
    frame on the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: For the preceding example program, at the point in its execution right before
    `max` executes the `return` statement, the execution stack will look like [Figure
    1-3](ch01.xhtml#ch1fig3). Recall that the argument values to `max` passed by `main`
    are *passed by value*, meaning that the parameters to `max`, `x` and `y`, are
    assigned the values of their corresponding arguments, `a` and `b` from the call
    in `main`. Despite the `max` function changing the value of `x`, the change doesn’t
    affect the value of `a` in `main`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/01fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: The execution stack contents just before returning from the `max`
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: The following full program includes two functions and shows examples of calling
    them from the `main` function. In this program, we declare function prototypes
    for `max` and `print_table` above the `main` function so that `main` can access
    them despite being defined first. The `main` function contains the high-level
    steps of the full program, and defining it first echoes the top-down design of
    the program. This example includes comments describing the parts of the program
    that are important to functions and function calls. You can also download and
    run the full program.^([9](ch01.xhtml#fn1_9))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 1.5 Arrays and Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *array* is a C construct that creates an ordered collection of data elements
    of the same type and associates this collection with a single program variable.
    *Ordered* means that each element is in a specific position in the collection
    of values (that is, there is an element in position 0, position 1, and so on),
    not that the values are necessarily sorted. Arrays are one of C’s primary mechanisms
    for grouping multiple data values and referring to them by a single name. Arrays
    come in several flavors, but the basic form is a *one-dimensional array*, which
    is useful for implementing list-like data structures and strings in C.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.1 Introduction to Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C arrays can store multiple data values of the *same* type. In this chapter,
    we discuss *statically declared* arrays, meaning that the total capacity (the
    maximum number of elements that can be stored in an array) is fixed and is defined
    when the array variable is declared. In the next chapter, we discuss other array
    types such as “Dynamically Allocated” on [page 153](ch02.xhtml#lev3_9) and “Two-Dimensional
    Arrays” on [page 84](ch02.xhtml#lev2_23).
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows Python and C versions of a program that initializes
    and then prints a collection of integer values. The Python version uses its built-in
    list type to store the list of values, whereas the C version uses an array of
    `int` types to store the collection of values.
  prefs: []
  type: TYPE_NORMAL
- en: In general, Python provides a high-level list interface to the programmer that
    hides much of the low-level implementation details. C, on the other hand, exposes
    a low-level array implementation to the programmer and leaves it up to the programmer
    to implement higher-level functionality. In other words, arrays enable low-level
    data storage without higher-level list functionality, such as `len`, `append`,
    `insert`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Python version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '*C version*'
  prefs: []
  type: TYPE_NORMAL
- en: The C and Python versions of this program have several similarities, most notably
    that individual elements can be accessed via *indexing*, and that index values
    start at `0`. That is, both languages refer to the very first element in a collection
    as the element at position `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main differences in the C and Python versions of this program relate to
    the capacity of the list or array and how their sizes (number of elements) are
    determined. For a Python list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'For a C array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Python version, the programmer doesn’t need to specify the capacity
    of a list in advance: Python automatically increases a list’s capacity as needed
    by the program. For example, the Python `append` function automatically increases
    the size of the Python list and adds the passed value to the end.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, when declaring an array variable in C, the programmer must specify
    its type (the type of each value stored in the array) and its total capacity (the
    maximum number of storage locations). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The preceding declarations create one variable named `arr`, an array of `int`
    values with a total capacity of 10, and another variable named `str`, an array
    of `char` values with a total capacity of 20.
  prefs: []
  type: TYPE_NORMAL
- en: To compute the size of a list (size meaning the total number of values in the
    list), Python provides a `len` function that returns the size of any list passed
    to it. In C, the programmer has to explicitly keep track of the number of elements
    in the array (for example, the `size` variable in the C listing on [page 47](ch01.xhtml#lev2_10)).
  prefs: []
  type: TYPE_NORMAL
- en: Another difference that might not be apparent from looking at the Python and
    C versions of this program is how the Python list and the C array are stored in
    memory. C dictates the array layout in program memory, whereas Python hides how
    lists are implemented from the programmer. In C, individual array elements are
    allocated in consecutive locations in the program’s memory. For example, the third
    array position is located in memory immediately following the second array position
    and immediately before the fourth array position.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.2 Array Access Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python provides multiple ways to access elements in its lists. C, however,
    supports only indexing, as described earlier. Valid index values range from 0
    to the capacity of the array minus 1\. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This example declares the array with a capacity of 10 (it has 10 elements),
    but it only uses the first six (our current collection of values is size 6, not
    10). It’s often the case when using statically declared arrays that some of an
    array’s capacity will remain unused. As a result, we need another program variable
    to keep track of the actual size (number of elements) in the array (`num` in this
    example).
  prefs: []
  type: TYPE_NORMAL
- en: Python and C differ in their error-handling approaches when a program attempts
    to access an invalid index. Python throws an `IndexError` exception if an invalid
    index value is used to access elements in a list (e.g., indexing beyond the number
    of elements in a list). In C, it’s up to the programmer to ensure that their code
    uses only valid index values when indexing into arrays. As a result, for code
    like the following that accesses an array element beyond the bounds of the allocated
    array, the program’s runtime behavior is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The C compiler is happy to compile code that accesses array positions beyond
    the bounds of the array; there is no bounds checking by the compiler or at runtime.
    As a result, running this code can lead to unexpected program behavior (and the
    behavior might differ from run to run). It can lead to your program crashing,
    it can change another variable’s value, or it might have no effect on your program’s
    behavior. In other words, this situation leads to a program bug that might or
    might not show up as unexpected program behavior. Thus, as a C programmer, it’s
    up to you to ensure that your array accesses refer to valid positions!
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.3 Arrays and Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The semantics of passing arrays to functions in C is similar to that of passing
    lists to functions in Python: the function can alter the elements in the passed
    array or list. Here’s an example function that takes two parameters, an `int`
    array parameter (`arr`), and an `int` parameter (`size`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[]` after the parameter name tells the compiler that the type of the parameter
    `arr` is *array of int*, not `int` like the parameter `size`. In the next chapter,
    we show an alternate syntax for specifying array parameters. The capacity of the
    array parameter `arr` isn’t specified: `arr[]` means that this function can be
    called with an array argument of any capacity. Because there is no way to get
    an array’s size or capacity just from the array variable, functions that are passed
    arrays almost always also have a second parameter that specifies the array’s size
    (the `size` parameter in the preceding example).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a function that has an array parameter, pass *the name of the array*
    as the argument. Here is a C code snippet with example calls to the `print_array`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In C, the name of the array variable is equivalent to the *base address* of
    the array (i.e., the memory location of its 0th element). Due to C’s *pass by
    value* function call semantics, when you pass an array to a function, each element
    of the array is *not* individually passed to the function. In other words, the
    function isn’t receiving a copy of each array element. Instead, an array parameter
    gets the *value of the array’s base address*. This behavior implies that when
    a function modifies the elements of an array that was passed as a parameter, the
    changes *will* persist when the function returns. For example, consider this C
    program snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The call in `main` to the `test` function is passed the argument `arr`, whose
    value is the base address of the `arr` array in memory. The parameter `a` in the
    test function gets a copy of this base address value. In other words, parameter
    `a` *refers to the same array storage locations as its argument*, `arr`. As a
    result, when the test function changes a value stored in the `a` array (`a[3]
    = 8`), it affects the corresponding position in the argument array (`arr[3]` is
    now 8). The reason is that the value of `a` is the base address of `arr`, and
    the value of `arr` is the base address of `arr`, so both `a` and `arr` refer to
    the same array (the same storage locations in memory)! [Figure 1-4](ch01.xhtml#ch1fig4)
    shows the stack contents at the point in the execution just before the test function
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/01fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: The stack contents for a function with an array parameter*'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter `a` is passed the value of the base address of the array argument
    `arr`, which means they both refer to the same set of array storage locations
    in memory. We indicate this with the arrow from `a` to `arr`. Values that get
    modified by the function `test` are highlighted. Changing the value of the parameter
    `size` does *not* change the value of its corresponding argument `n`, but changing
    the value of one of the elements referred to by `a` (e.g., `a[3] = 8`) does affect
    the value of the corresponding position in `arr`.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.4 Introduction to Strings and the C String Library
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python implements a string type and provides a rich interface for using strings,
    but there is no corresponding string type in C. Instead, strings are implemented
    as arrays of `char` values. Not every character array is used as a C string, but
    every C string is a character array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that arrays in C might be defined with a larger size than a program
    ultimately uses. For example, we saw in the “Array Access Methods” section on
    [page 47](ch01.xhtml#lev2_10) that we might declare an array of size 10 but only
    use the first six positions. This behavior has important implications for strings:
    we can’t assume that a string’s length is equal to that of the array that stores
    it. For this reason, strings in C must end with a special character value, the
    *null character* (`’\0’`), to indicate the end of the string.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings that end with a null character are said to be *null-terminated*. Although
    all strings in C *should* be null-terminated, failing to properly account for
    null characters is a common source of errors for novice C programmers. When using
    strings, it’s important to keep in mind that your character arrays must be declared
    with enough capacity to store each character value in the string plus the null
    character (`’\0’`). For example, to store the string `"hi"`, you need an array
    of at least three chars (one to store `'h'`, one to store `'i'`, and one to store
    `'\0'`).
  prefs: []
  type: TYPE_NORMAL
- en: Because strings are commonly used, C provides a string library that contains
    functions for manipulating strings. Programs that use these string library functions
    need to include the `string.h` header.
  prefs: []
  type: TYPE_NORMAL
- en: When printing the value of a string with `printf`, use the `%s` placeholder
    in the format string. The `printf` function will print all the characters in the
    array argument until it encounters the `’\0’` character. Similarly, string library
    functions often either locate the end of a string by searching for the `’\0’`
    character or add a `’\0’` character to the end of any string that they modify.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that uses strings and string library functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `strlen` function in the C string library returns the number of characters
    in its string argument. A string’s terminating null character doesn’t count as
    part of the string’s length, so the call to `strlen(str1)` returns 2 (the length
    of the string `"hi"`). The `strcpy` function copies one character at a time from
    a source string (the second parameter) to a destination string (the first parameter)
    until it reaches a null character in the source.
  prefs: []
  type: TYPE_NORMAL
- en: Note that most C string library functions expect the call to pass in a character
    array that has enough capacity for the function to perform its job. For example,
    you wouldn’t want to call `strcpy` with a destination string that isn’t large
    enough to contain the source; doing so will lead to undefined behavior in your
    program!
  prefs: []
  type: TYPE_NORMAL
- en: C string library functions also require that string values passed to them are
    correctly formed, with a terminating `’\0’` character. It’s up to you as the C
    programmer to ensure that you pass in valid strings for C library functions to
    manipulate. Thus, in the call to `strcpy` in the preceding example, if the source
    string (`str1`) was not initialized to have a terminating `’\0’` character, `strcpy`
    would continue beyond the end of the `str1` array’s bounds, leading to undefined
    behavior that could cause it to crash.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning STRCPY CAN BE AN UNSAFE FUNCTION**'
  prefs: []
  type: TYPE_NORMAL
- en: The previous example uses the `strcpy` function safely. In general, though,
    `strcpy` poses a security risk because it assumes that its destination is large
    enough to store the entire string, which may not always be the case (for example,
    if the string comes from user input).
  prefs: []
  type: TYPE_NORMAL
- en: We chose to show `strcpy` now to simplify the introduction to strings, but we
    illustrate safer alternatives in the “Strings and the String Library" section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we discuss C strings and the string library in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 Structs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays and structs are the two ways in which C supports creating collections
    of data elements. Arrays are used to create an ordered collection of data elements
    of the same type, whereas *structs* are used to create a collection of data elements
    of *different types*. A C programmer can combine array and struct building blocks
    in many different ways to create more complex data types and structures. This
    section introduces structs, and in the next chapter we characterize structs in
    more detail (“C Structs” on [page 103](ch02.xhtml#lev1_15)) and show how you can
    combine them with arrays (“Arrays of Structs” on [page 198](ch02.xhtml#lev2_30)).
  prefs: []
  type: TYPE_NORMAL
- en: C is not an object-oriented language; thus, it doesn’t support classes. It does,
    however, support defining structured types, which are like the data part of classes.
    A `struct` is a type used to represent a heterogeneous collection of data; it’s
    a mechanism for treating a set of different types as a single, coherent unit.
    C structs provide a level of abstraction on top of individual data values, treating
    them as a single type. For example, a student has a name, age, grade point average
    (GPA), and graduation year. A programmer could define a new `struct` type to combine
    those four data elements into a single `struct student` variable that contains
    a name value (type `char []`, to hold a string), an age value (type `int`), a
    GPA value (type `float`), and a graduation year value (type `int`). A single variable
    of this struct type can store all four pieces of data for a particular student;
    for example, (“Freya”, 19, 3.7, 2021).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three steps to defining and using `struct` types in C programs:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Define a new `struct` type that represents the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Declare variables of the new `struct` type.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Use dot (`.`) notation to access individual field values of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.1 Defining a Struct Type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A struct type definition should appear *outside of any function*, typically
    near the top of the program’s `.c` file. The syntax for defining a new struct
    type is the following (`struct` is a reserved keyword):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of defining a new `struct studentT` type for storing student
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This struct definition adds a new type to C’s type system, and the type’s name
    is `struct studentT`. This struct defines four fields, and each field definition
    includes the type and name of the field. Note that in this example, the `name`
    field’s type is a character array, for use as a string (see “Introduction to Strings
    and the C String Library” on [page 50](ch01.xhtml#lev2_12)).
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.2 Declaring Variables of Struct Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once the type has been defined, you can declare variables of the new type, `struct`
    `studentT`. Note that unlike the other types we’ve encountered so far that consist
    of just a single word (for example, `int`, `char`, and `float`), the name of our
    new struct type is two words, `struct studentT`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 1.6.3 Accessing Field Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To access field values in a struct variable, use *dot notation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: When accessing structs and their fields, carefully consider the types of the
    variables you’re using. Novice C programmers often introduce bugs into their programs
    by failing to account for the types of struct fields. [Table 1-2](ch01.xhtml#ch1tab2)
    shows the types of several expressions surrounding our `struct studentT` type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-2:** The Types Associated with Various `struct studentT` Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **C type** |'
  prefs: []
  type: TYPE_TB
- en: '| `student1` | `struct studentT` |'
  prefs: []
  type: TYPE_TB
- en: '| `student1.age` | integer (`int`) |'
  prefs: []
  type: TYPE_TB
- en: '| `student1.name` | array of characters (`char []`) |'
  prefs: []
  type: TYPE_TB
- en: '| `student1.name[3]` | character (`char`), the type stored in each position
    of the `name` array |'
  prefs: []
  type: TYPE_TB
- en: 'Here are some examples of assigning a `struct studentT` variable’s fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 1-5](ch01.xhtml#ch1fig5) illustrates the layout of the `student1` variable
    in memory after the field assignments in the preceding example. Only the struct
    variable’s fields (the areas in boxes) are stored in memory. The field names are
    labeled on the figure for clarity, but to the C compiler, fields are simply storage
    locations or *offsets* from the start of the struct variable’s memory. For example,
    based on the definition of a `struct studentT`, the compiler knows that to access
    the field named `gpa`, it must skip past an array of 64 characters (`name`) and
    one integer (`age`). Note that in the figure, the `name` field only depicts the
    first six characters of the 64-character array.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/01fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: The `student1` variable’s memory after assigning each of its fields*'
  prefs: []
  type: TYPE_NORMAL
- en: 'C struct types are *lvalues*, meaning they can appear on the left side of an
    assignment statement. Thus, a struct variable can be assigned the value of another
    struct variable using a simple assignment statement. The field values of the struct
    on the right side of the assignment statement are *copied* to the field values
    of the struct on the left side of the assignment statement. In other words, the
    contents of memory of one struct are copied to the memory of the other. Here’s
    an example of assigning a struct’s values in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 1-6](ch01.xhtml#ch1fig6) shows the values of the two student variables
    after the assignment statement and call to `strcpy` have executed. Note that the
    figure depicts the `name` fields as the string values they contain rather than
    the full array of 64 characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/01fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-6: Layout of the `student1` and `student2` structs after executing
    the struct assignment and `strcpy` call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'C provides a `sizeof` operator that takes a type and returns the number of
    bytes used by the type. The `sizeof` operator can be used on any C type, including
    struct types, to see how much memory space a variable of that type needs. For
    example, we can print the size of a `struct studentT` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: When run, this line should print out a value of *at least* 76 bytes, because
    64 characters are in the `name` array (1 byte for each `char`), 4 bytes for the
    `int age` field, 4 bytes for the `float gpa` field, and 4 bytes for the `int`
    `grad_yr` field. The exact number of bytes might be larger than 76 on some machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a full example program (available for download^([10](ch01.xhtml#fn1_10)))
    that defines and demonstrates the use of our `struct studentT` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, this program outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: LVALUES
  prefs: []
  type: TYPE_NORMAL
- en: An *lvalue* is an expression that can appear on the left side of an assignment
    statement. It’s an expression that represents a memory storage location. As we
    introduce C pointer types and examples of creating more complicated structures
    that combine C arrays, structs, and pointers, it’s important to think carefully
    about types and to keep in mind which C expressions are valid lvalues (which can
    be used on the left side of an assignment statement).
  prefs: []
  type: TYPE_NORMAL
- en: 'From what we know about C so far, single variables of base types, array elements,
    and structs are all lvalues. The name of a statically declared array is *not*
    an lvalue (you cannot change the base address of a statically declared array in
    memory). The following example code snippet illustrates valid and invalid C assignment
    statements based on the lvalue status of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 1.6.4 Passing Structs to Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In C, arguments of all types are *passed by value* to functions. Thus, if a
    function has a struct type parameter, then when called with a struct argument,
    the argument’s *value* is passed to its parameter, meaning that the parameter
    gets a copy of its argument’s value. The value of a struct variable is the contents
    of its memory, which is why we can assign the fields of one struct to be the same
    as another struct in a single assignment statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Because the value of a struct variable represents the full contents of its memory,
    passing a struct as an argument to a function gives the parameter a *copy* of
    all the argument struct’s field values. If the function changes the field values
    of a struct parameter, the changes to the parameter’s field values have *no effect*
    on the corresponding field values of the argument. That is, changes to the parameter’s
    fields only modify values in the parameter’s memory locations for those fields,
    not in the argument’s memory locations for those fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a full example program (available for download^([11](ch01.xhtml#fn1_11)))
    using the `checkID` function that takes a struct parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'When `main` calls `checkID`, the value of the `student` struct (a copy of the
    memory contents of all its fields) is passed to the `s` parameter. When the function
    changes the value of its parameter’s `age` field, it *doesn’t* affect the `age`
    field of its argument (`student`). This behavior can be seen by running the program,
    which outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that when `checkID` prints the `age` field, it reflects the
    function’s change to the `age` field of the parameter `s`. However, after the
    function call returns, `main` prints the `age` field of `student` with the same
    value it had prior to the `checkID` call. [Figure 1-7](ch01.xhtml#ch1fig7) illustrates
    the contents of the call stack just before the `checkID` function returns.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/01fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-7: The contents of the call stack before returning from the `checkID`
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the pass by value semantics of struct parameters is particularly
    important when a struct contains a statically declared array field (like the `name`
    field in `struct studentT`). When such a struct is passed to a function, the struct
    argument’s entire memory contents, including every array element in the array
    field, is copied to its parameter. If the parameter struct’s array contents are
    changed by the function, those changes will *not* persist after the function returns.
    This behavior might seem odd given what we know about how arrays are passed to
    functions (“Arrays and Functions” on [page 48](ch01.xhtml#lev2_11)), but it’s
    consistent with the struct copying behavior described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we introduced many parts of the C programming language by comparing
    them to similar language constructs in Python, a language that many readers might
    know. C has similar language features to those of many other high-level imperative
    and object-oriented programming languages, including variables, loops, conditionals,
    functions, and I/O. Some key differences between the C and Python features we
    discussed include C requiring that all variables be declared of a specific type
    before they’re used, and that C arrays and strings are a lower-level abstraction
    than Python’s lists and strings. The lower-level abstractions allow a C programmer
    more control over how their program accesses its memory and thus more control
    over their program’s efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we cover the C programming language in detail. We revisit
    in more depth the many language features presented in this chapter, and we introduce
    some new C language features, most notably C pointer variables and support for
    dynamic memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch01.xhtml#rfn1_1) *[https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.c](https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.c)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch01.xhtml#rfn1_2) *[https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.py](https://diveintosystems.org/antora/diveintosystems/1.0/C_intro/_attachments/hello.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch01.xhtml#rfn1_3) *[https://gcc.gnu.org](https://gcc.gnu.org)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch01.xhtml#rfn1_4) See *[https://www.cs.swarthmore.edu/help/editors.html](https://www.cs.swarthmore.edu/help/editors.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch01.xhtml#rfn1_5) See “Using make and writing Makefile” at *[https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html](https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[6.](ch01.xhtml#rfn1_6) *book/modules/C_intro/assets/attachments/whileLoop1.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[7.](ch01.xhtml#rfn1_7) *book/modules/C_intro/assets/attachments/whileLoop2.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[8.](ch01.xhtml#rfn1_8) *book/modules/C_intro/assets/attachments/forLoop2.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[9.](ch01.xhtml#rfn1_9) *book/modules/C_intro/assets/attachments/function.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[10.](ch01.xhtml#rfn1_10) *book/modules/C_intro/assets/attachments/studentTstruct.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[11.](ch01.xhtml#rfn1_11) *book/modules/C_intro/assets/attachments/structfunc.c*'
  prefs: []
  type: TYPE_NORMAL
